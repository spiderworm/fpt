/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(50);


/***/ },
/* 1 */,
/* 2 */,
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _System = __webpack_require__(4);
	
	var _System2 = _interopRequireDefault(_System);
	
	var _EntityCollection = __webpack_require__(6);
	
	var _EntityCollection2 = _interopRequireDefault(_EntityCollection);
	
	var _Ticker = __webpack_require__(7);
	
	var _Ticker2 = _interopRequireDefault(_Ticker);
	
	var _Physics = __webpack_require__(8);
	
	var _Physics2 = _interopRequireDefault(_Physics);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var FPTGame = _System2.default.createClass({
	
		constructor: function constructor() {
			this.entities = _EntityCollection2.default.create();
	
			this.systems.add(_Physics2.default.create(this));
	
			this._ticker = _Ticker2.default.create(1000 / 60, this.tick.bind(this));
		},
	
		setLevel: function setLevel(level) {
			this.level = level;
			this.entities.add(level);
		}
	
	});
	
	FPTGame.create = function () {
		return new FPTGame();
	};
	
	exports.default = FPTGame;

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _SystemCollection = __webpack_require__(5);
	
	var _SystemCollection2 = _interopRequireDefault(_SystemCollection);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var System = function () {
		_createClass(System, null, [{
			key: 'createClass',
			value: function createClass(props) {
				function Klass() {
					System.call(this);
					props.constructor.apply(this, arguments);
				};
				Klass.prototype = props;
				props.__proto__ = System.prototype;
				return Klass;
			}
		}, {
			key: 'create',
			value: function create() {
				return new System();
			}
		}]);
	
		function System() {
			_classCallCheck(this, System);
	
			this.systems = _SystemCollection2.default.create();
		}
	
		_createClass(System, [{
			key: 'tick',
			value: function tick(ms) {
				if (this.entities) {
					this.entities.forEach(function (entity) {
						this.tickEntity(entity, ms);
					}.bind(this));
				}
				this.tickSubsystems(ms);
			}
		}, {
			key: 'tickEntity',
			value: function tickEntity(entity, ms) {}
		}, {
			key: 'tickSubsystems',
			value: function tickSubsystems(ms) {
				this.systems.forEach(function (system) {
					return system.tick(ms);
				});
			}
		}]);
	
		return System;
	}();
	
	exports.default = System;

/***/ },
/* 5 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var SystemCollection = function () {
		_createClass(SystemCollection, null, [{
			key: "create",
			value: function create() {
				return new SystemCollection();
			}
		}]);
	
		function SystemCollection() {
			_classCallCheck(this, SystemCollection);
	
			this._systems = [];
		}
	
		_createClass(SystemCollection, [{
			key: "add",
			value: function add(system) {
				this._systems.push(system);
			}
		}, {
			key: "forEach",
			value: function forEach(callback) {
				this._systems.forEach(callback);
			}
		}]);
	
		return SystemCollection;
	}();

	exports.default = SystemCollection;

/***/ },
/* 6 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var EntityCollection = function () {
		_createClass(EntityCollection, null, [{
			key: "create",
			value: function create() {
				return new EntityCollection();
			}
		}]);
	
		function EntityCollection() {
			_classCallCheck(this, EntityCollection);
	
			this._entities = [];
		}
	
		_createClass(EntityCollection, [{
			key: "add",
			value: function add(entity) {
				this._entities.push(entity);
			}
		}, {
			key: "forEach",
			value: function forEach(callback) {
				this._entities.forEach(callback);
			}
		}]);
	
		return EntityCollection;
	}();

	exports.default = EntityCollection;

/***/ },
/* 7 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Ticker = function () {
		_createClass(Ticker, null, [{
			key: "create",
			value: function create(ms, callback) {
				return new Ticker(ms, callback);
			}
		}]);
	
		function Ticker(ms, callback) {
			_classCallCheck(this, Ticker);
	
			this._time = +new Date();
			this._callback = callback;
			setInterval(this._nextTick.bind(this), ms);
		}
	
		_createClass(Ticker, [{
			key: "_nextTick",
			value: function _nextTick() {
				var now = +new Date();
				var ms = now - this._time;
				this._time = now;
				this._callback(ms);
			}
		}]);
	
		return Ticker;
	}();
	
	exports.default = Ticker;
	;

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _System = __webpack_require__(4);
	
	var _System2 = _interopRequireDefault(_System);
	
	var _cannon = __webpack_require__(9);
	
	var _cannon2 = _interopRequireDefault(_cannon);
	
	var _FPTGame = __webpack_require__(3);
	
	var _FPTGame2 = _interopRequireDefault(_FPTGame);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Physics = _System2.default.createClass({
	
		constructor: function constructor(fptGame) {
	
			this.entities = fptGame.entities;
	
			var world = new _cannon2.default.World();
			world.gravity = new _cannon2.default.Vec3(0, -9.8, 0);
			world.broadphase = new _cannon2.default.NaiveBroadphase();
			var solver = new _cannon2.default.GSSolver();
			solver.iterations = 7;
			world.defaultContactMaterial.contactEquationRegularizationTime = 0.55;
			solver.tolerance = 0.01;
			world.solver = solver;
	
			world.quatNormalizeFast = true;
			world.quatNormalizeSkip = 0;
	
			world.defaultContactMaterial.friction = 0.7;
			world.defaultContactMaterial.restitution = 0.0;
			world.defaultContactMaterial.contactEquationStiffness = 1e9;
			world.defaultContactMaterial.contactEquationRegularizationTime = 4;
			world.broadphase.useBoundingBoxes = true;
			world.allowSleep = false;
	
			this.world = world;
		},
	
		tick: function tick(ms, entityCollection) {
			this.entities.forEach(this._prepareEntity.bind(this));
			this.world.step(ms / 1000);
			this.entities.forEach(this._updateEntity.bind(this));
			this.tickSubsystems(ms);
		},
	
		_prepareEntity: function _prepareEntity(entity) {
			var pieces = entity.get('pieces');
			if (pieces) {
				pieces.forEach(function (piece) {
					this._prepareEntity(piece);
				}.bind(this));
			}
			var physics = entity.get('physics');
			if (physics) {
				if (!physics.ready) {
					this.world.add(physics.cannon);
				}
				physics.ready = true;
			}
		},
	
		_updateEntity: function _updateEntity(entity) {
			var physics = entity.get('physics');
			if (physics) {
				//console.info(physics.position);
			} else {}
		}
	
	});
	
	Physics.create = function (fptGame) {
		return new Physics(fptGame);
	};
	
	exports.default = Physics;

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	var require;var require;/*
	 * Copyright (c) 2014 cannon.js Authors
	 *
	 * Permission is hereby granted, free of charge, to any person
	 * obtaining a copy of this software and associated documentation
	 * files (the "Software"), to deal in the Software without
	 * restriction, including without limitation the rights to use, copy,
	 * modify, merge, publish, distribute, sublicense, and/or sell copies
	 * of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be
	 * included in all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
	 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
	 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	 */
	
	!function(e){if(true)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.CANNON=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
	module.exports={
	  "name": "cannon",
	  "version": "0.6.0",
	  "description": "A lightweight 3D physics engine written in JavaScript.",
	  "homepage": "https://github.com/schteppe/cannon.js",
	  "author": "Stefan Hedman <schteppe@gmail.com> (http://steffe.se)",
	  "keywords": [
	    "cannon.js",
	    "cannon",
	    "physics",
	    "engine",
	    "3d"
	  ],
	  "main": "./build/cannon.js",
	  "engines": {
	    "node": "*"
	  },
	  "repository": {
	    "type": "git",
	    "url": "https://github.com/schteppe/cannon.js.git"
	  },
	  "bugs": {
	    "url": "https://github.com/schteppe/cannon.js/issues"
	  },
	  "licenses": [
	    {
	      "type": "MIT"
	    }
	  ],
	  "devDependencies": {
	    "jshint": "latest",
	    "uglify-js": "latest",
	    "nodeunit": "^0.9.0",
	    "grunt": "~0.4.0",
	    "grunt-contrib-jshint": "~0.1.1",
	    "grunt-contrib-nodeunit": "^0.4.1",
	    "grunt-contrib-concat": "~0.1.3",
	    "grunt-contrib-uglify": "^0.5.1",
	    "grunt-browserify": "^2.1.4",
	    "grunt-contrib-yuidoc": "^0.5.2",
	    "browserify": "*"
	  },
	  "dependencies": {}
	}
	
	},{}],2:[function(_dereq_,module,exports){
	// Export classes
	module.exports = {
	    version :                       _dereq_('../package.json').version,
	
	    ArrayCollisionMatrix :          _dereq_('./collision/ArrayCollisionMatrix'),
	    Body :                          _dereq_('./objects/Body'),
	    Box :                           _dereq_('./shapes/Box'),
	    Broadphase :                    _dereq_('./collision/Broadphase'),
	    Constraint :                    _dereq_('./constraints/Constraint'),
	    ContactEquation :               _dereq_('./equations/ContactEquation'),
	    Narrowphase :                   _dereq_('./world/Narrowphase'),
	    ContactMaterial :               _dereq_('./material/ContactMaterial'),
	    ConvexPolyhedron :              _dereq_('./shapes/ConvexPolyhedron'),
	    Cylinder :                      _dereq_('./shapes/Cylinder'),
	    DistanceConstraint :            _dereq_('./constraints/DistanceConstraint'),
	    Equation :                      _dereq_('./equations/Equation'),
	    EventTarget :                   _dereq_('./utils/EventTarget'),
	    FrictionEquation :              _dereq_('./equations/FrictionEquation'),
	    GSSolver :                      _dereq_('./solver/GSSolver'),
	    GridBroadphase :                _dereq_('./collision/GridBroadphase'),
	    Heightfield :                   _dereq_('./shapes/Heightfield'),
	    HingeConstraint :               _dereq_('./constraints/HingeConstraint'),
	    Mat3 :                          _dereq_('./math/Mat3'),
	    Material :                      _dereq_('./material/Material'),
	    NaiveBroadphase :               _dereq_('./collision/NaiveBroadphase'),
	    ObjectCollisionMatrix :         _dereq_('./collision/ObjectCollisionMatrix'),
	    Pool :                          _dereq_('./utils/Pool'),
	    Particle :                      _dereq_('./shapes/Particle'),
	    Plane :                         _dereq_('./shapes/Plane'),
	    PointToPointConstraint :        _dereq_('./constraints/PointToPointConstraint'),
	    Quaternion :                    _dereq_('./math/Quaternion'),
	    Ray :                           _dereq_('./collision/Ray'),
	    RaycastVehicle :                _dereq_('./objects/RaycastVehicle'),
	    RaycastResult :                 _dereq_('./collision/RaycastResult'),
	    RigidVehicle :                  _dereq_('./objects/RigidVehicle'),
	    RotationalEquation :            _dereq_('./equations/RotationalEquation'),
	    RotationalMotorEquation :       _dereq_('./equations/RotationalMotorEquation'),
	    SAPBroadphase :                 _dereq_('./collision/SAPBroadphase'),
	    SPHSystem :                     _dereq_('./objects/SPHSystem'),
	    Shape :                         _dereq_('./shapes/Shape'),
	    Solver :                        _dereq_('./solver/Solver'),
	    Sphere :                        _dereq_('./shapes/Sphere'),
	    SplitSolver :                   _dereq_('./solver/SplitSolver'),
	    Spring :                        _dereq_('./objects/Spring'),
	    Vec3 :                          _dereq_('./math/Vec3'),
	    Vec3Pool :                      _dereq_('./utils/Vec3Pool'),
	    World :                         _dereq_('./world/World'),
	};
	
	},{"../package.json":1,"./collision/ArrayCollisionMatrix":4,"./collision/Broadphase":5,"./collision/GridBroadphase":6,"./collision/NaiveBroadphase":7,"./collision/ObjectCollisionMatrix":8,"./collision/Ray":9,"./collision/RaycastResult":10,"./collision/SAPBroadphase":11,"./constraints/Constraint":12,"./constraints/DistanceConstraint":13,"./constraints/HingeConstraint":14,"./constraints/PointToPointConstraint":15,"./equations/ContactEquation":16,"./equations/Equation":17,"./equations/FrictionEquation":18,"./equations/RotationalEquation":19,"./equations/RotationalMotorEquation":20,"./material/ContactMaterial":21,"./material/Material":22,"./math/Mat3":24,"./math/Quaternion":25,"./math/Vec3":27,"./objects/Body":28,"./objects/RaycastVehicle":29,"./objects/RigidVehicle":30,"./objects/SPHSystem":31,"./objects/Spring":32,"./shapes/Box":34,"./shapes/ConvexPolyhedron":35,"./shapes/Cylinder":36,"./shapes/Heightfield":37,"./shapes/Particle":38,"./shapes/Plane":39,"./shapes/Shape":40,"./shapes/Sphere":41,"./solver/GSSolver":42,"./solver/Solver":43,"./solver/SplitSolver":44,"./utils/EventTarget":45,"./utils/Pool":46,"./utils/Vec3Pool":49,"./world/Narrowphase":50,"./world/World":51}],3:[function(_dereq_,module,exports){
	var Vec3 = _dereq_('../math/Vec3');
	var Utils = _dereq_('../utils/Utils');
	
	module.exports = AABB;
	
	/**
	 * Axis aligned bounding box class.
	 * @class AABB
	 * @constructor
	 * @param {Object}  [options]
	 * @param {Array}   [options.upperBound]
	 * @param {Array}   [options.lowerBound]
	 */
	function AABB(options){
	    options = options || {};
	
	    /**
	     * The lower bound of the bounding box.
	     * @property lowerBound
	     * @type {Array}
	     */
	    this.lowerBound = new Vec3();
	    if(options.lowerBound){
	        this.lowerBound.copy(options.lowerBound);
	    }
	
	    /**
	     * The upper bound of the bounding box.
	     * @property upperBound
	     * @type {Array}
	     */
	    this.upperBound = new Vec3();
	    if(options.upperBound){
	        this.upperBound.copy(options.upperBound);
	    }
	}
	
	var tmp = new Vec3();
	
	/**
	 * Set the AABB bounds from a set of points.
	 * @method setFromPoints
	 * @param {Array} points An array of Vec3's.
	 * @todo
	 */
	AABB.prototype.setFromPoints = function(points, position, quaternion, skinSize){
	    var l = this.lowerBound,
	        u = this.upperBound,
	        q = quaternion;
	
	    // Set to the first point
	    l.copy(points[0]);
	    if(q){
	        q.vmult(l, l);
	    }
	    u.copy(l);
	
	    for(var i = 1; i<points.length; i++){
	        var p = points[i];
	
	        if(q){
	            q.vmult(p, tmp);
	            p = tmp;
	        }
	
	        if(p.x > u.x){ u.x = p.x; }
	        if(p.x < l.x){ l.x = p.x; }
	        if(p.y > u.y){ u.y = p.y; }
	        if(p.y < l.y){ l.y = p.y; }
	        if(p.z > u.z){ u.z = p.z; }
	        if(p.z < l.z){ l.z = p.z; }
	    }
	
	    // Add offset
	    if (position) {
	        position.vadd(l, l);
	        position.vadd(u, u);
	    }
	
	    if(skinSize){
	        l.x -= skinSize;
	        l.y -= skinSize;
	        l.z -= skinSize;
	        u.x += skinSize;
	        u.y += skinSize;
	        u.z += skinSize;
	    }
	};
	
	/**
	 * Copy bounds from an AABB to this AABB
	 * @method copy
	 * @param  {AABB} aabb
	 */
	AABB.prototype.copy = function(aabb){
	    // vectors copy is the other direction... bad!
	    this.lowerBound.copy(aabb.lowerBound);
	    this.upperBound.copy(aabb.upperBound);
	};
	
	/**
	 * Extend this AABB so that it covers the given AABB too.
	 * @method extend
	 * @param  {AABB} aabb
	 * @todo
	 */
	AABB.prototype.extend = function(aabb){
	    // Extend lower bound
	    var l = aabb.lowerBound.x;
	    if(this.lowerBound.x > l){
	        this.lowerBound.x = l;
	    }
	
	    // Upper
	    var u = aabb.upperBound.x;
	    if(this.upperBound.x < u){
	        this.upperBound.x = u;
	    }
	
	    // Extend lower bound
	    var l = aabb.lowerBound.y;
	    if(this.lowerBound.y > l){
	        this.lowerBound.y = l;
	    }
	
	    // Upper
	    var u = aabb.upperBound.y;
	    if(this.upperBound.y < u){
	        this.upperBound.y = u;
	    }
	};
	
	/**
	 * Returns true if the given AABB overlaps this AABB.
	 * @method overlaps
	 * @param  {AABB} aabb
	 * @return {Boolean}
	 */
	AABB.prototype.overlaps = function(aabb){
	    var l1 = this.lowerBound,
	        u1 = this.upperBound,
	        l2 = aabb.lowerBound,
	        u2 = aabb.upperBound;
	
	    //      l2        u2
	    //      |---------|
	    // |--------|
	    // l1       u1
	
	    return ((l2.x <= u1.x && u1.x <= u2.x) || (l1.x <= u2.x && u2.x <= u1.x)) &&
	           ((l2.y <= u1.y && u1.y <= u2.y) || (l1.y <= u2.y && u2.y <= u1.y));
	};
	
	},{"../math/Vec3":27,"../utils/Utils":48}],4:[function(_dereq_,module,exports){
	module.exports = ArrayCollisionMatrix;
	
	/**
	 * Collision "matrix". It's actually a triangular-shaped array of whether two bodies are touching this step, for reference next step
	 * @class ArrayCollisionMatrix
	 * @constructor
	 */
	function ArrayCollisionMatrix() {
	
	    /**
	     * The matrix storage
	     * @property matrix
	     * @type {Array}
	     */
		this.matrix = [];
	}
	
	/**
	 * Get an element
	 * @method get
	 * @param  {Number} i
	 * @param  {Number} j
	 * @return {Number}
	 */
	ArrayCollisionMatrix.prototype.get = function(i, j) {
		i = i.index;
		j = j.index;
	    if (j > i) {
	        var temp = j;
	        j = i;
	        i = temp;
	    }
		return this.matrix[(i*(i + 1)>>1) + j-1];
	};
	
	/**
	 * Set an element
	 * @method set
	 * @param {Number} i
	 * @param {Number} j
	 * @param {Number} value
	 */
	ArrayCollisionMatrix.prototype.set = function(i, j, value) {
		i = i.index;
		j = j.index;
	    if (j > i) {
	        var temp = j;
	        j = i;
	        i = temp;
	    }
		this.matrix[(i*(i + 1)>>1) + j-1] = value ? 1 : 0;
	};
	
	/**
	 * Sets all elements to zero
	 * @method reset
	 */
	ArrayCollisionMatrix.prototype.reset = function() {
		for (var i=0, l=this.matrix.length; i!==l; i++) {
			this.matrix[i]=0;
		}
	};
	
	/**
	 * Sets the max number of objects
	 * @method setNumObjects
	 * @param {Number} n
	 */
	ArrayCollisionMatrix.prototype.setNumObjects = function(n) {
		this.matrix.length = n*(n-1)>>1;
	};
	
	},{}],5:[function(_dereq_,module,exports){
	var Body = _dereq_('../objects/Body');
	var Vec3 = _dereq_('../math/Vec3');
	var Quaternion = _dereq_('../math/Quaternion');
	var Shape = _dereq_('../shapes/Shape');
	var Plane = _dereq_('../shapes/Plane');
	
	module.exports = Broadphase;
	
	/**
	 * Base class for broadphase implementations
	 * @class Broadphase
	 * @constructor
	 * @author schteppe
	 */
	function Broadphase(){
	    /**
	    * The world to search for collisions in.
	    * @property world
	    * @type {World}
	    */
	    this.world = null;
	
	    /**
	     * If set to true, the broadphase uses bounding boxes for intersection test, else it uses bounding spheres.
	     * @property useBoundingBoxes
	     * @type {Boolean}
	     */
	    this.useBoundingBoxes = false;
	
	    this.dirty = true;
	}
	
	/**
	 * Get the collision pairs from the world
	 * @method collisionPairs
	 * @param {World} world The world to search in
	 * @param Array p1 Empty array to be filled with body objects
	 * @param Array p2 Empty array to be filled with body objects
	 * @return array An array with two subarrays of body indices
	 */
	Broadphase.prototype.collisionPairs = function(world,p1,p2){
	    throw new Error("collisionPairs not implemented for this BroadPhase class!");
	};
	
	/**
	 * Check if a body pair needs to be intersection tested at all.
	 * @method needBroadphaseCollision
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 * @return {bool}
	 */
	var Broadphase_needBroadphaseCollision_STATIC_OR_KINEMATIC = Body.STATIC | Body.KINEMATIC;
	Broadphase.prototype.needBroadphaseCollision = function(bodyA,bodyB){
	
	    // Check collision filter masks
	    if( (bodyA.collisionFilterGroup & bodyB.collisionFilterMask)===0 || (bodyB.collisionFilterGroup & bodyA.collisionFilterMask)===0){
	        return false;
	    }
	
	    // Check types
	    if(((bodyA.type & Broadphase_needBroadphaseCollision_STATIC_OR_KINEMATIC)!==0 || bodyA.sleepState === Body.SLEEPING) &&
	       ((bodyB.type & Broadphase_needBroadphaseCollision_STATIC_OR_KINEMATIC)!==0 || bodyB.sleepState === Body.SLEEPING)) {
	        // Both bodies are static, kinematic or sleeping. Skip.
	        return false;
	    }
	
	    // Two particles don't collide
	    /*
	    if(!bodyA.shape && !bodyB.shape){
	        return false;
	    }
	    */
	
	    // Two planes don't collide
	    /*
	    if(bodyA.shape instanceof Plane && bodyB.shape instanceof Plane){
	        return false;
	    }
	    */
	
	    return true;
	};
	
	/**
	 * Check if the bounding volumes of two bodies intersect.
	 * @method intersectionTest
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 * @param {array} pairs1
	 * @param {array} pairs2
	  */
	Broadphase.prototype.intersectionTest = function(bi, bj, pairs1, pairs2){
	    if(this.useBoundingBoxes){
	        this.doBoundingBoxBroadphase(bi,bj,pairs1,pairs2);
	    } else {
	        this.doBoundingSphereBroadphase(bi,bj,pairs1,pairs2);
	    }
	};
	
	/**
	 * Check if the bounding spheres of two bodies are intersecting.
	 * @method doBoundingSphereBroadphase
	 * @param {Body} bi
	 * @param {Body} bj
	 * @param {Array} pairs1 bi is appended to this array if intersection
	 * @param {Array} pairs2 bj is appended to this array if intersection
	 */
	var Broadphase_collisionPairs_r = new Vec3(), // Temp objects
	    Broadphase_collisionPairs_normal =  new Vec3(),
	    Broadphase_collisionPairs_quat =  new Quaternion(),
	    Broadphase_collisionPairs_relpos  =  new Vec3();
	Broadphase.prototype.doBoundingSphereBroadphase = function(bi,bj,pairs1,pairs2){
	    var r = Broadphase_collisionPairs_r;
	    bj.position.vsub(bi.position,r);
	    var boundingRadiusSum2 = Math.pow(bi.boundingRadius + bj.boundingRadius, 2);
	    var norm2 = r.norm2();
	    if(norm2 < boundingRadiusSum2){
	        pairs1.push(bi);
	        pairs2.push(bj);
	    }
	};
	
	/**
	 * Check if the bounding boxes of two bodies are intersecting.
	 * @method doBoundingBoxBroadphase
	 * @param Body bi
	 * @param Body bj
	 * @param {Array} pairs1
	 * @param {Array} pairs2
	 */
	Broadphase.prototype.doBoundingBoxBroadphase = function(bi,bj,pairs1,pairs2){
	    if(bi.aabbNeedsUpdate){
	        bi.computeAABB();
	    }
	    if(bj.aabbNeedsUpdate){
	        bj.computeAABB();
	    }
	
	    // Check AABB / AABB
	    if(bi.aabb.overlaps(bj.aabb)){
	        pairs1.push(bi);
	        pairs2.push(bj);
	    }
	};
	
	/**
	 * Removes duplicate pairs from the pair arrays.
	 * @method makePairsUnique
	 * @param {Array} pairs1
	 * @param {Array} pairs2
	 */
	var Broadphase_makePairsUnique_temp = { keys:[] },
	    Broadphase_makePairsUnique_p1 = [],
	    Broadphase_makePairsUnique_p2 = [];
	Broadphase.prototype.makePairsUnique = function(pairs1,pairs2){
	    var t = Broadphase_makePairsUnique_temp,
	        p1 = Broadphase_makePairsUnique_p1,
	        p2 = Broadphase_makePairsUnique_p2,
	        N = pairs1.length;
	
	    for(var i=0; i!==N; i++){
	        p1[i] = pairs1[i];
	        p2[i] = pairs2[i];
	    }
	
	    pairs1.length = 0;
	    pairs2.length = 0;
	
	    for(var i=0; i!==N; i++){
	        var id1 = p1[i].id,
	            id2 = p2[i].id;
	        var key = id1 < id2 ? id1+","+id2 :  id2+","+id1;
	        t[key] = i;
	        t.keys.push(key);
	    }
	
	    for(var i=0; i!==t.keys.length; i++){
	        var key = t.keys.pop(),
	            pairIndex = t[key];
	        pairs1.push(p1[pairIndex]);
	        pairs2.push(p2[pairIndex]);
	        delete t[key];
	    }
	};
	
	/**
	 * To be implemented by subcasses
	 * @method setWorld
	 * @param {World} world
	 */
	Broadphase.prototype.setWorld = function(world){
	};
	
	var bsc_dist = new Vec3();
	Broadphase.boundingSphereCheck = function(bi,bj){
	    var dist = bsc_dist;
	    bi.position.vsub(bj.position,dist);
	    return Math.pow(bi.shape.boundingSphereRadius + bj.shape.boundingSphereRadius,2) > dist.norm2();
	};
	
	/**
	 * Returns all the bodies within the AABB.
	 * @method aabbQuery
	 * @param  {World} world
	 * @param  {AABB} aabb
	 * @return {array}
	 */
	Broadphase.prototype.aabbQuery = function(world, aabb){
	    console.warn('.aabbQuery is not implemented in this Broadphase subclass.');
	    return [];
	};
	},{"../math/Quaternion":25,"../math/Vec3":27,"../objects/Body":28,"../shapes/Plane":39,"../shapes/Shape":40}],6:[function(_dereq_,module,exports){
	module.exports = GridBroadphase;
	
	var Broadphase = _dereq_('./Broadphase');
	var Vec3 = _dereq_('../math/Vec3');
	var Shape = _dereq_('../shapes/Shape');
	
	/**
	 * Axis aligned uniform grid broadphase.
	 * @class GridBroadphase
	 * @constructor
	 * @extends Broadphase
	 * @todo Needs support for more than just planes and spheres.
	 * @param {Vec3} aabbMin
	 * @param {Vec3} aabbMax
	 * @param {Number} nx Number of boxes along x
	 * @param {Number} ny Number of boxes along y
	 * @param {Number} nz Number of boxes along z
	 */
	function GridBroadphase(aabbMin,aabbMax,nx,ny,nz){
	    Broadphase.apply(this);
	    this.nx = nx || 10;
	    this.ny = ny || 10;
	    this.nz = nz || 10;
	    this.aabbMin = aabbMin || new Vec3(100,100,100);
	    this.aabbMax = aabbMax || new Vec3(-100,-100,-100);
		var nbins = this.nx * this.ny * this.nz;
		if (nbins <= 0) {
			throw "GridBroadphase: Each dimension's n must be >0";
		}
	    this.bins = [];
		this.binLengths = []; //Rather than continually resizing arrays (thrashing the memory), just record length and allow them to grow
		this.bins.length = nbins;
		this.binLengths.length = nbins;
		for (var i=0;i<nbins;i++) {
			this.bins[i]=[];
			this.binLengths[i]=0;
		}
	}
	GridBroadphase.prototype = new Broadphase();
	GridBroadphase.prototype.constructor = GridBroadphase;
	
	/**
	 * Get all the collision pairs in the physics world
	 * @method collisionPairs
	 * @param {World} world
	 * @param {Array} pairs1
	 * @param {Array} pairs2
	 */
	var GridBroadphase_collisionPairs_d = new Vec3();
	var GridBroadphase_collisionPairs_binPos = new Vec3();
	GridBroadphase.prototype.collisionPairs = function(world,pairs1,pairs2){
	    var N = world.numObjects(),
	        bodies = world.bodies;
	
	    var max = this.aabbMax,
	        min = this.aabbMin,
	        nx = this.nx,
	        ny = this.ny,
	        nz = this.nz;
	
		var xstep = ny*nz;
		var ystep = nz;
		var zstep = 1;
	
	    var xmax = max.x,
	        ymax = max.y,
	        zmax = max.z,
	        xmin = min.x,
	        ymin = min.y,
	        zmin = min.z;
	
	    var xmult = nx / (xmax-xmin),
	        ymult = ny / (ymax-ymin),
	        zmult = nz / (zmax-zmin);
	
	    var binsizeX = (xmax - xmin) / nx,
	        binsizeY = (ymax - ymin) / ny,
	        binsizeZ = (zmax - zmin) / nz;
	
		var binRadius = Math.sqrt(binsizeX*binsizeX + binsizeY*binsizeY + binsizeZ*binsizeZ) * 0.5;
	
	    var types = Shape.types;
	    var SPHERE =            types.SPHERE,
	        PLANE =             types.PLANE,
	        BOX =               types.BOX,
	        COMPOUND =          types.COMPOUND,
	        CONVEXPOLYHEDRON =  types.CONVEXPOLYHEDRON;
	
	    var bins=this.bins,
			binLengths=this.binLengths,
	        Nbins=this.bins.length;
	
	    // Reset bins
	    for(var i=0; i!==Nbins; i++){
	        binLengths[i] = 0;
	    }
	
	    var ceil = Math.ceil;
		var min = Math.min;
		var max = Math.max;
	
		function addBoxToBins(x0,y0,z0,x1,y1,z1,bi) {
			var xoff0 = ((x0 - xmin) * xmult)|0,
				yoff0 = ((y0 - ymin) * ymult)|0,
				zoff0 = ((z0 - zmin) * zmult)|0,
				xoff1 = ceil((x1 - xmin) * xmult),
				yoff1 = ceil((y1 - ymin) * ymult),
				zoff1 = ceil((z1 - zmin) * zmult);
	
			if (xoff0 < 0) { xoff0 = 0; } else if (xoff0 >= nx) { xoff0 = nx - 1; }
			if (yoff0 < 0) { yoff0 = 0; } else if (yoff0 >= ny) { yoff0 = ny - 1; }
			if (zoff0 < 0) { zoff0 = 0; } else if (zoff0 >= nz) { zoff0 = nz - 1; }
			if (xoff1 < 0) { xoff1 = 0; } else if (xoff1 >= nx) { xoff1 = nx - 1; }
			if (yoff1 < 0) { yoff1 = 0; } else if (yoff1 >= ny) { yoff1 = ny - 1; }
			if (zoff1 < 0) { zoff1 = 0; } else if (zoff1 >= nz) { zoff1 = nz - 1; }
	
			xoff0 *= xstep;
			yoff0 *= ystep;
			zoff0 *= zstep;
			xoff1 *= xstep;
			yoff1 *= ystep;
			zoff1 *= zstep;
	
			for (var xoff = xoff0; xoff <= xoff1; xoff += xstep) {
				for (var yoff = yoff0; yoff <= yoff1; yoff += ystep) {
					for (var zoff = zoff0; zoff <= zoff1; zoff += zstep) {
						var idx = xoff+yoff+zoff;
						bins[idx][binLengths[idx]++] = bi;
					}
				}
			}
		}
	
	    // Put all bodies into the bins
	    for(var i=0; i!==N; i++){
	        var bi = bodies[i];
	        var si = bi.shape;
	
	        switch(si.type){
	        case SPHERE:
	            // Put in bin
	            // check if overlap with other bins
	            var x = bi.position.x,
	                y = bi.position.y,
	                z = bi.position.z;
	            var r = si.radius;
	
				addBoxToBins(x-r, y-r, z-r, x+r, y+r, z+r, bi);
	            break;
	
	        case PLANE:
	            if(si.worldNormalNeedsUpdate){
	                si.computeWorldNormal(bi.quaternion);
	            }
	            var planeNormal = si.worldNormal;
	
				//Relative position from origin of plane object to the first bin
				//Incremented as we iterate through the bins
				var xreset = xmin + binsizeX*0.5 - bi.position.x,
					yreset = ymin + binsizeY*0.5 - bi.position.y,
					zreset = zmin + binsizeZ*0.5 - bi.position.z;
	
	            var d = GridBroadphase_collisionPairs_d;
				d.set(xreset, yreset, zreset);
	
				for (var xi = 0, xoff = 0; xi !== nx; xi++, xoff += xstep, d.y = yreset, d.x += binsizeX) {
					for (var yi = 0, yoff = 0; yi !== ny; yi++, yoff += ystep, d.z = zreset, d.y += binsizeY) {
						for (var zi = 0, zoff = 0; zi !== nz; zi++, zoff += zstep, d.z += binsizeZ) {
							if (d.dot(planeNormal) < binRadius) {
								var idx = xoff + yoff + zoff;
								bins[idx][binLengths[idx]++] = bi;
							}
						}
					}
				}
	            break;
	
	        default:
				if (bi.aabbNeedsUpdate) {
					bi.computeAABB();
				}
	
				addBoxToBins(
					bi.aabb.lowerBound.x,
					bi.aabb.lowerBound.y,
					bi.aabb.lowerBound.z,
					bi.aabb.upperBound.x,
					bi.aabb.upperBound.y,
					bi.aabb.upperBound.z,
					bi);
	            break;
	        }
	    }
	
	    // Check each bin
	    for(var i=0; i!==Nbins; i++){
			var binLength = binLengths[i];
			//Skip bins with no potential collisions
			if (binLength > 1) {
				var bin = bins[i];
	
				// Do N^2 broadphase inside
				for(var xi=0; xi!==binLength; xi++){
					var bi = bin[xi];
					for(var yi=0; yi!==xi; yi++){
						var bj = bin[yi];
						if(this.needBroadphaseCollision(bi,bj)){
							this.intersectionTest(bi,bj,pairs1,pairs2);
						}
					}
				}
			}
	    }
	
	//	for (var zi = 0, zoff=0; zi < nz; zi++, zoff+= zstep) {
	//		console.log("layer "+zi);
	//		for (var yi = 0, yoff=0; yi < ny; yi++, yoff += ystep) {
	//			var row = '';
	//			for (var xi = 0, xoff=0; xi < nx; xi++, xoff += xstep) {
	//				var idx = xoff + yoff + zoff;
	//				row += ' ' + binLengths[idx];
	//			}
	//			console.log(row);
	//		}
	//	}
	
	    this.makePairsUnique(pairs1,pairs2);
	};
	
	},{"../math/Vec3":27,"../shapes/Shape":40,"./Broadphase":5}],7:[function(_dereq_,module,exports){
	module.exports = NaiveBroadphase;
	
	var Broadphase = _dereq_('./Broadphase');
	var AABB = _dereq_('./AABB');
	
	/**
	 * Naive broadphase implementation, used in lack of better ones.
	 * @class NaiveBroadphase
	 * @constructor
	 * @description The naive broadphase looks at all possible pairs without restriction, therefore it has complexity N^2 (which is bad)
	 * @extends Broadphase
	 */
	function NaiveBroadphase(){
	    Broadphase.apply(this);
	}
	NaiveBroadphase.prototype = new Broadphase();
	NaiveBroadphase.prototype.constructor = NaiveBroadphase;
	
	/**
	 * Get all the collision pairs in the physics world
	 * @method collisionPairs
	 * @param {World} world
	 * @param {Array} pairs1
	 * @param {Array} pairs2
	 */
	NaiveBroadphase.prototype.collisionPairs = function(world,pairs1,pairs2){
	    var bodies = world.bodies,
	        n = bodies.length,
	        i,j,bi,bj;
	
	    // Naive N^2 ftw!
	    for(i=0; i!==n; i++){
	        for(j=0; j!==i; j++){
	
	            bi = bodies[i];
	            bj = bodies[j];
	
	            if(!this.needBroadphaseCollision(bi,bj)){
	                continue;
	            }
	
	            this.intersectionTest(bi,bj,pairs1,pairs2);
	        }
	    }
	};
	
	var tmpAABB = new AABB();
	
	/**
	 * Returns all the bodies within an AABB.
	 * @method aabbQuery
	 * @param  {World} world
	 * @param  {AABB} aabb
	 * @param {array} result An array to store resulting bodies in.
	 * @return {array}
	 */
	NaiveBroadphase.prototype.aabbQuery = function(world, aabb, result){
	    result = result || [];
	
	    // Naive loop
	    for(var i = 0; i < world.bodies.length; i++){
	        var b = world.bodies[i];
	
	        // Ugly hack until RigidBody gets aabb
	        if(b.aabb.overlaps(aabb)){
	            result.push(b);
	        }
	    }
	
	    return result;
	};
	},{"./AABB":3,"./Broadphase":5}],8:[function(_dereq_,module,exports){
	module.exports = ObjectCollisionMatrix;
	
	/**
	 * Records what objects are colliding with each other
	 * @class ObjectCollisionMatrix
	 * @constructor
	 */
	function ObjectCollisionMatrix() {
	
	    /**
	     * The matrix storage
	     * @property matrix
	     * @type {Object}
	     */
		this.matrix = {};
	}
	
	/**
	 * @method get
	 * @param  {Number} i
	 * @param  {Number} j
	 * @return {Number}
	 */
	ObjectCollisionMatrix.prototype.get = function(i, j) {
		i = i.id;
		j = j.id;
	    if (j > i) {
	        var temp = j;
	        j = i;
	        i = temp;
	    }
		return i+'-'+j in this.matrix;
	};
	
	/**
	 * @method set
	 * @param  {Number} i
	 * @param  {Number} j
	 * @param {Number} value
	 */
	ObjectCollisionMatrix.prototype.set = function(i, j, value) {
		i = i.id;
		j = j.id;
	    if (j > i) {
	        var temp = j;
	        j = i;
	        i = temp;
		}
		if (value) {
			this.matrix[i+'-'+j] = true;
		}
		else {
			delete this.matrix[i+'-'+j];
		}
	};
	
	/**
	 * Empty the matrix
	 * @method reset
	 */
	ObjectCollisionMatrix.prototype.reset = function() {
		this.matrix = {};
	};
	
	/**
	 * Set max number of objects
	 * @method setNumObjects
	 * @param {Number} n
	 */
	ObjectCollisionMatrix.prototype.setNumObjects = function(n) {
	};
	
	},{}],9:[function(_dereq_,module,exports){
	module.exports = Ray;
	
	var Vec3 = _dereq_('../math/Vec3');
	var Quaternion = _dereq_('../math/Quaternion');
	var Transform = _dereq_('../math/Transform');
	var ConvexPolyhedron = _dereq_('../shapes/ConvexPolyhedron');
	var Box = _dereq_('../shapes/Box');
	var RaycastResult = _dereq_('../collision/RaycastResult');
	var Shape = _dereq_('../shapes/Shape');
	var AABB = _dereq_('../collision/AABB');
	
	/**
	 * A line in 3D space that intersects bodies and return points.
	 * @class Ray
	 * @constructor
	 * @param {Vec3} from
	 * @param {Vec3} to
	 */
	function Ray(from, to){
	    /**
	     * @property {Vec3} from
	     */
	    this.from = from ? from.clone() : new Vec3();
	
	    /**
	     * @property {Vec3} to
	     */
	    this.to = to ? to.clone() : new Vec3();
	
	    this._direction = new Vec3();
	
	    /**
	     * The precision of the ray. Used when checking parallelity etc.
	     * @property {Number} precision
	     */
	    this.precision = 0.0001;
	}
	Ray.prototype.constructor = Ray;
	
	var v1 = new Vec3(),
	    v2 = new Vec3();
	
	/*
	 * As per "Barycentric Technique" as named here http://www.blackpawn.com/texts/pointinpoly/default.html But without the division
	 */
	function pointInTriangle(p, a, b, c) {
	    c.vsub(a,v0);
	    b.vsub(a,v1);
	    p.vsub(a,v2);
	
	    var dot00 = v0.dot( v0 );
	    var dot01 = v0.dot( v1 );
	    var dot02 = v0.dot( v2 );
	    var dot11 = v1.dot( v1 );
	    var dot12 = v1.dot( v2 );
	
	    var u,v;
	
	    return  ( (u = dot11 * dot02 - dot01 * dot12) >= 0 ) &&
	            ( (v = dot00 * dot12 - dot01 * dot02) >= 0 ) &&
	            ( u + v < ( dot00 * dot11 - dot01 * dot01 ) );
	}
	
	/**
	 * Shoot a ray at a body, get back information about the hit.
	 * @method intersectBody
	 * @param {Body} body
	 * @return {Array} An array of results. The result objects has properties: distance (float), point (Vec3) and body (Body).
	 */
	Ray.prototype.intersectBody = function (body, result, direction) {
	    if(!direction){
	        this._updateDirection();
	        direction = this._direction;
	    }
	
	    var xi = new Vec3();
	    var qi = new Quaternion();
	    for (var i = 0; i < body.shapes.length; i++) {
	
	        body.quaternion.mult(body.shapeOrientations[i], qi);
	        body.quaternion.vmult(body.shapeOffsets[i], xi);
	        xi.vadd(body.position, xi);
	
	        return this.intersectShape(
	            body.shapes[i],
	            qi,
	            xi,
	            body,
	            direction,
	            result
	        );
	    }
	};
	
	/**
	 * @method intersectBodies
	 * @param {Array} bodies An array of Body objects.
	 * @return {Array} See intersectBody
	 */
	Ray.prototype.intersectBodies = function (bodies, result) {
	    this._updateDirection();
	    var direction = this._direction;
	
	    if(result instanceof RaycastResult){
	        result.reset();
	    }
	
	    for ( var i = 0, l = bodies.length; i < l; i ++ ) {
	        this.intersectBody(bodies[i], result, direction);
	    }
	};
	
	Ray.prototype._updateDirection = function(){
	    this.to.vsub(this.from, this._direction);
	    this._direction.normalize();
	};
	
	/**
	 * @method intersectShape
	 * @param {Shape} shape
	 * @param {Quaternion} quat
	 * @param {Vec3} position
	 * @param {Body} body
	 * @return {Array} See intersectBody()
	 */
	Ray.prototype.intersectShape = function(shape, quat, position, body, direction, result){
	    var from = this.from;
	
	    // Checking boundingSphere
	    var distance = distanceFromIntersection(from, direction, position);
	    if ( distance > shape.boundingSphereRadius ) {
	        return result;
	    }
	
	    this[shape.type](shape, quat, position, body, direction, result);
	
	    return result;
	};
	
	var vector = new Vec3();
	var normal = new Vec3();
	var intersectPoint = new Vec3();
	
	var a = new Vec3();
	var b = new Vec3();
	var c = new Vec3();
	var d = new Vec3();
	
	var tmpRaycastResult = new RaycastResult();
	
	
	Ray.prototype.intersectBox = function(shape, quat, position, body, direction, result){
	    return this.intersectConvex(shape.convexPolyhedronRepresentation, quat, position, body, direction, result);
	};
	Ray.prototype[Shape.types.BOX] = Ray.prototype.intersectBox;
	
	
	Ray.prototype.intersectPlane = function(shape, quat, position, body, direction, result){
	    var from = this.from;
	    var to = this.to;
	
	    // Get plane normal
	    var worldNormal = new Vec3(0, 0, 1);
	    quat.vmult(worldNormal, worldNormal);
	
	    var len = new Vec3();
	    from.vsub(position, len);
	    var planeToFrom = len.dot(worldNormal);
	    to.vsub(position, len);
	    var planeToTo = len.dot(worldNormal);
	
	    if(planeToFrom * planeToTo > 0){
	        // "from" and "to" are on the same side of the plane... bail out
	        return result;
	    }
	
	    if(from.distanceTo(to) < planeToFrom){
	        return result;
	    }
	
	    var n_dot_dir = worldNormal.dot(direction);
	
	    if (Math.abs(n_dot_dir) < this.precision) {
	        // No intersection
	        return result;
	    }
	
	    var planePointToFrom = new Vec3();
	    var dir_scaled_with_t = new Vec3();
	    var hitPointWorld = new Vec3();
	
	    from.vsub(position, planePointToFrom);
	    var t = -worldNormal.dot(planePointToFrom) / n_dot_dir;
	    direction.scale(t, dir_scaled_with_t);
	    from.vadd(dir_scaled_with_t, hitPointWorld);
	
	    if(this.reportIntersection(worldNormal, hitPointWorld, shape, body, result)){
	        return result;
	    }
	
	    return result;
	};
	Ray.prototype[Shape.types.PLANE] = Ray.prototype.intersectPlane;
	
	Ray.prototype.getAABB = function(result){
	    var to = this.to;
	    var from = this.from;
	    result.lowerBound.x = Math.min(to.x, from.x);
	    result.lowerBound.y = Math.min(to.y, from.y);
	    result.upperBound.x = Math.max(to.x, from.x);
	    result.upperBound.y = Math.max(to.y, from.y);
	};
	
	var intersectConvexOptions = {
	    faceList: [0]
	};
	Ray.prototype.intersectHeightfield = function(shape, quat, position, body, direction, result){
	    var data = shape.data,
	        w = shape.elementSize,
	        worldPillarOffset = new Vec3();
	
	    // Convert the ray to local heightfield coordinates
	    var localRay = new Ray(this.from, this.to);
	    Transform.pointToLocalFrame(position, quat, localRay.from, localRay.from);
	    Transform.pointToLocalFrame(position, quat, localRay.to, localRay.to);
	
	    // Get the index of the data points to test against
	    var index = [];
	    var iMinX = null;
	    var iMinY = null;
	    var iMaxX = null;
	    var iMaxY = null;
	
	    var inside = shape.getIndexOfPosition(localRay.from.x, localRay.from.y, index, false);
	    if(inside){
	        iMinX = index[0];
	        iMinY = index[1];
	        iMaxX = index[0];
	        iMaxY = index[1];
	    }
	    inside = shape.getIndexOfPosition(localRay.to.x, localRay.to.y, index, false);
	    if(inside){
	        if (iMinX === null || index[0] < iMinX) { iMinX = index[0]; }
	        if (iMaxX === null || index[0] > iMaxX) { iMaxX = index[0]; }
	        if (iMinY === null || index[1] < iMinY) { iMinY = index[1]; }
	        if (iMaxY === null || index[1] > iMaxY) { iMaxY = index[1]; }
	    }
	
	    if(iMinX === null){
	        return result;
	    }
	
	    var minMax = [];
	    shape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);
	    var min = minMax[0];
	    var max = minMax[1];
	
	    // // Bail out if the ray can't touch the bounding box
	    // // TODO
	    // var aabb = new AABB();
	    // this.getAABB(aabb);
	    // if(aabb.intersects()){
	    //     return;
	    // }
	
	    for(var i = iMinX; i <= iMaxX; i++){
	        for(var j = iMinY; j <= iMaxY; j++){
	
	            // Lower triangle
	            shape.getConvexTrianglePillar(i, j, false);
	            Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset);
	            this.intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, direction, result, intersectConvexOptions);
	
	            // Upper triangle
	            shape.getConvexTrianglePillar(i, j, true);
	            Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset);
	            this.intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, direction, result, intersectConvexOptions);
	        }
	    }
	
	    return result;
	};
	Ray.prototype[Shape.types.HEIGHTFIELD] = Ray.prototype.intersectHeightfield;
	
	
	Ray.prototype.intersectSphere = function(shape, quat, position, body, direction, result){
	    var from = this.from,
	        to = this.to,
	        r = shape.radius;
	
	    var a = Math.pow(to.x - from.x, 2) + Math.pow(to.y - from.y, 2) + Math.pow(to.z - from.z, 2);
	    var b = 2 * ((to.x - from.x) * (from.x - position.x) + (to.y - from.y) * (from.y - position.y) + (to.z - from.z) * (from.z - position.z));
	    var c = Math.pow(from.x - position.x, 2) + Math.pow(from.y - position.y, 2) + Math.pow(from.z - position.z, 2) - Math.pow(r, 2);
	
	    var delta = Math.pow(b, 2) - 4 * a * c;
	
	    if(delta < 0){
	        // No intersection
	        return result;
	
	    } else if(delta === 0){
	        // single intersection point
	        var intersectionPoint = new Vec3();
	        from.lerp(to, delta, intersectionPoint);
	
	        var normal = new Vec3();
	        intersectionPoint.vsub(position, normal);
	        normal.normalize();
	
	        if(this.reportIntersection(normal, intersectionPoint, shape, body, result)){
	            return result;
	        }
	    } else {
	        var d1 = (- b - Math.sqrt(delta)) / (2 * a);
	        var d2 = (- b + Math.sqrt(delta)) / (2 * a);
	
	        var intersectionPoint = new Vec3();
	        from.lerp(to, d1, intersectionPoint);
	        var normal = new Vec3();
	        intersectionPoint.vsub(position, normal);
	        normal.normalize();
	        if(this.reportIntersection(normal, intersectionPoint, shape, body, result)){
	            return result;
	        }
	
	        from.lerp(to, d2, intersectionPoint);
	        var normal = new Vec3();
	        intersectionPoint.vsub(position, normal);
	        normal.normalize();
	        if(this.reportIntersection(normal, intersectionPoint, shape, body, result)){
	            return result;
	        }
	    }
	
	    return result;
	};
	Ray.prototype[Shape.types.SPHERE] = Ray.prototype.intersectSphere;
	
	
	var intersectConvex_minDistNormal = new Vec3();
	var intersectConvex_minDistIntersect = new Vec3();
	Ray.prototype.intersectConvex = function intersectConvex(shape, quat, position, body, direction, result, options){
	    var minDistNormal = intersectConvex_minDistNormal;
	    var minDistIntersect = intersectConvex_minDistIntersect;
	    var faceList = (options && options.faceList) || null;
	
	    // Checking faces
	    var faces = shape.faces,
	        vertices = shape.vertices,
	        normals = shape.faceNormals;
	
	    var from = this.from;
	    var to = this.to;
	    var fromToDistance = from.distanceTo(to);
	
	    var reportClosest = result instanceof RaycastResult;
	    var minDist = -1;
	    var Nfaces = faceList ? faceList.length : faces.length;
	
	    for (var j = 0; j < Nfaces; j++) {
	        var fi = faceList ? faceList[j] : j;
	
	        var face = faces[fi];
	        var faceNormal = normals[fi];
	        var q = quat;
	        var x = position;
	
	        // determine if ray intersects the plane of the face
	        // note: this works regardless of the direction of the face normal
	
	        // Get plane point in world coordinates...
	        vector.copy(vertices[face[0]]);
	        q.vmult(vector,vector);
	        vector.vadd(x,vector);
	
	        // ...but make it relative to the ray from. We'll fix this later.
	        vector.vsub(from,vector);
	
	        // Get plane normal
	        q.vmult(faceNormal,normal);
	
	        // If this dot product is negative, we have something interesting
	        var dot = direction.dot(normal);
	
	        // Bail out if ray and plane are parallel
	        if ( Math.abs( dot ) < this.precision ){
	            continue;
	        }
	
	        // calc distance to plane
	        var scalar = normal.dot(vector) / dot;
	
	        // if negative distance, then plane is behind ray
	        if (scalar < 0){
	            continue;
	        }
	
	        if (dot < 0) {
	
	            // Intersection point is from + direction * scalar
	            direction.mult(scalar,intersectPoint);
	            intersectPoint.vadd(from,intersectPoint);
	
	            // a is the point we compare points b and c with.
	            a.copy(vertices[face[0]]);
	            q.vmult(a,a);
	            x.vadd(a,a);
	
	            for(var i = 1; i < face.length - 1; i++){
	                // Transform 3 vertices to world coords
	                b.copy(vertices[face[i]]);
	                c.copy(vertices[face[i+1]]);
	                q.vmult(b,b);
	                q.vmult(c,c);
	                x.vadd(b,b);
	                x.vadd(c,c);
	
	                var distance = intersectPoint.distanceTo(from);
	
	                if(!pointInTriangle(intersectPoint, a, b, c) || distance > fromToDistance){
	                    continue;
	                }
	
	                if(minDist === -1 || distance < minDist){
	                    minDist = distance;
	                    minDistNormal.copy(normal);
	                    minDistIntersect.copy(intersectPoint);
	                }
	            }
	        }
	    }
	
	    if(minDist !== -1 && this.reportIntersection(minDistNormal, minDistIntersect, shape, body, result)){
	        return result;
	    }
	
	    return result;
	};
	
	Ray.prototype[Shape.types.CONVEXPOLYHEDRON] = Ray.prototype.intersectConvex;
	
	
	Ray.prototype.reportIntersection = function(normal, hitPointWorld, shape, body, result){
	    var from = this.from;
	    var to = this.to;
	    var distance = from.distanceTo(hitPointWorld);
	
	    if(!(result instanceof RaycastResult)){
	        // Got a callback
	        tmpRaycastResult.set(
	            from,
	            to,
	            normal,
	            hitPointWorld,
	            shape,
	            body,
	            distance
	        );
	        tmpRaycastResult.hasHit = true;
	        result(tmpRaycastResult);
	
	        return true;
	
	    } else {
	
	        // Store if closer than current cloest
	        if(distance < result.distance || !result.hasHit){
	            result.hasHit = true;
	            result.set(
	                from,
	                to,
	                normal,
	                hitPointWorld,
	                shape,
	                body,
	                distance
	            );
	        }
	
	        return false;
	    }
	};
	
	var v0 = new Vec3(),
	    intersect = new Vec3();
	function distanceFromIntersection(from, direction, position) {
	
	    // v0 is vector from from to position
	    position.vsub(from,v0);
	    var dot = v0.dot( direction );
	
	    // intersect = direction*dot + from
	    direction.mult(dot,intersect);
	    intersect.vadd(from,intersect);
	
	    var distance = position.distanceTo(intersect);
	
	    return distance;
	}
	
	
	},{"../collision/AABB":3,"../collision/RaycastResult":10,"../math/Quaternion":25,"../math/Transform":26,"../math/Vec3":27,"../shapes/Box":34,"../shapes/ConvexPolyhedron":35,"../shapes/Shape":40}],10:[function(_dereq_,module,exports){
	var Vec3 = _dereq_('../math/Vec3');
	
	module.exports = RaycastResult;
	
	function RaycastResult(){
		this.rayFromWorld = new Vec3();
		this.rayToWorld = new Vec3();
		this.hitNormalWorld = new Vec3();
		this.hitPointWorld = new Vec3();
		this.hasHit = false;
		this.shape = null;
		this.body = null;
		this.distance = -1;
	}
	
	RaycastResult.prototype.reset = function () {
		this.rayFromWorld.setZero();
		this.rayToWorld.setZero();
		this.hitNormalWorld.setZero();
		this.hitPointWorld.setZero();
		this.hasHit = false;
		this.shape = null;
		this.body = null;
		this.distance = -1;
	};
	
	RaycastResult.prototype.set = function(
		rayFromWorld,
		rayToWorld,
		hitNormalWorld,
		hitPointWorld,
		shape,
		body,
		distance
	){
		this.rayFromWorld.copy(rayFromWorld);
		this.rayToWorld.copy(rayToWorld);
		this.hitNormalWorld.copy(hitNormalWorld);
		this.hitPointWorld.copy(hitPointWorld);
		this.shape = shape;
		this.body = body;
		this.distance = distance;
	};
	},{"../math/Vec3":27}],11:[function(_dereq_,module,exports){
	var Shape = _dereq_('../shapes/Shape');
	var Broadphase = _dereq_('../collision/Broadphase');
	
	module.exports = SAPBroadphase;
	
	/**
	 * Sweep and prune broadphase along one axis.
	 *
	 * @class SAPBroadphase
	 * @constructor
	 * @param {World} world
	 * @extends Broadphase
	 */
	function SAPBroadphase(world){
	    Broadphase.apply(this);
	
	    /**
	     * List of bodies currently in the broadphase.
	     * @property axisList
	     * @type {Array}
	     */
	    this.axisList = [];
	
	    /**
	     * The world to search in.
	     * @property world
	     * @type {World}
	     */
	    this.world = null;
	
	    /**
	     * Axis to sort the bodies along. Set to 0 for x axis, and 1 for y axis. For best performance, choose an axis that the bodies are spread out more on.
	     * @property axisIndex
	     * @type {Number}
	     */
	    this.axisIndex = 0;
	
	    var axisList = this.axisList;
	
	    this._addBodyHandler = function(e){
	        axisList.push(e.body);
	    };
	
	    this._removeBodyHandler = function(e){
	        var idx = axisList.indexOf(e.body);
	        if(idx !== -1){
	            axisList.splice(idx,1);
	        }
	    };
	
	    if(world){
	        this.setWorld(world);
	    }
	}
	SAPBroadphase.prototype = new Broadphase();
	
	/**
	 * Change the world
	 * @method setWorld
	 * @param  {World} world
	 */
	SAPBroadphase.prototype.setWorld = function(world){
	    // Clear the old axis array
	    this.axisList.length = 0;
	
	    // Add all bodies from the new world
	    for(var i=0; i<world.bodies.length; i++){
	        this.axisList.push(world.bodies[i]);
	    }
	
	    // Remove old handlers, if any
	    world.removeEventListener("addBody", this._addBodyHandler);
	    world.removeEventListener("removeBody", this._removeBodyHandler);
	
	    // Add handlers to update the list of bodies.
	    world.addEventListener("addBody", this._addBodyHandler);
	    world.addEventListener("removeBody", this._removeBodyHandler);
	
	    this.world = world;
	    this.dirty = true;
	};
	
	/**
	 * @static
	 * @method insertionSortX
	 * @param  {Array} a
	 * @return {Array}
	 */
	SAPBroadphase.insertionSortX = function(a) {
	    for(var i=1,l=a.length;i<l;i++) {
	        var v = a[i];
	        for(var j=i - 1;j>=0;j--) {
	            if(a[j].aabb.lowerBound.x <= v.aabb.lowerBound.x){
	                break;
	            }
	            a[j+1] = a[j];
	        }
	        a[j+1] = v;
	    }
	    return a;
	};
	
	/**
	 * @static
	 * @method insertionSortY
	 * @param  {Array} a
	 * @return {Array}
	 */
	SAPBroadphase.insertionSortY = function(a) {
	    for(var i=1,l=a.length;i<l;i++) {
	        var v = a[i];
	        for(var j=i - 1;j>=0;j--) {
	            if(a[j].aabb.lowerBound.y <= v.aabb.lowerBound.y){
	                break;
	            }
	            a[j+1] = a[j];
	        }
	        a[j+1] = v;
	    }
	    return a;
	};
	
	/**
	 * @static
	 * @method insertionSortZ
	 * @param  {Array} a
	 * @return {Array}
	 */
	SAPBroadphase.insertionSortZ = function(a) {
	    for(var i=1,l=a.length;i<l;i++) {
	        var v = a[i];
	        for(var j=i - 1;j>=0;j--) {
	            if(a[j].aabb.lowerBound.z <= v.aabb.lowerBound.z){
	                break;
	            }
	            a[j+1] = a[j];
	        }
	        a[j+1] = v;
	    }
	    return a;
	};
	
	/**
	 * Collect all collision pairs
	 * @method collisionPairs
	 * @param  {World} world
	 * @param  {Array} p1
	 * @param  {Array} p2
	 */
	SAPBroadphase.prototype.collisionPairs = function(world,p1,p2){
	    var bodies = this.axisList,
	        N = bodies.length,
	        axisIndex = this.axisIndex,
	        i, j;
	
	    if(this.dirty){
	        this.sortList();
	        this.dirty = false;
	    }
	
	    // Look through the list
	    for(i=0; i !== N; i++){
	        var bi = bodies[i];
	
	        for(j=i+1; j < N; j++){
	            var bj = bodies[j];
	
	            if(!this.needBroadphaseCollision(bi,bj)){
	                continue;
	            }
	
	            if(!SAPBroadphase.checkBounds(bi,bj,axisIndex)){
	                break;
	            }
	
	            this.intersectionTest(bi,bj,p1,p2);
	        }
	    }
	};
	
	SAPBroadphase.prototype.sortList = function(){
	    var axisList = this.axisList;
	    var axisIndex = this.axisIndex;
	    var N = axisList.length;
	
	    // Update AABBs
	    for(var i = 0; i!==N; i++){
	        var bi = axisList[i];
	        if(bi.aabbNeedsUpdate){
	            bi.computeAABB();
	        }
	    }
	
	    // Sort the list
	    if(axisIndex === 0){
	        SAPBroadphase.insertionSortX(axisList);
	    } else if(axisIndex === 1){
	        SAPBroadphase.insertionSortY(axisList);
	    } else if(axisIndex === 2){
	        SAPBroadphase.insertionSortZ(axisList);
	    }
	};
	
	/**
	 * Check if the bounds of two bodies overlap, along the given SAP axis.
	 * @static
	 * @method checkBounds
	 * @param  {Body} bi
	 * @param  {Body} bj
	 * @param  {Number} axisIndex
	 * @return {Boolean}
	 */
	SAPBroadphase.checkBounds = function(bi, bj, axisIndex){
	    var axis;
	    if(axisIndex === 0){ axis = 'x'; }
	    if(axisIndex === 1){ axis = 'y'; }
	    if(axisIndex === 2){ axis = 'z'; }
	
	    var biPos = bi.position[axis],
	        ri = bi.boundingRadius,
	        bjPos = bj.position[axis],
	        rj = bj.boundingRadius,
	        boundA1 = biPos - ri,
	        boundA2 = biPos + ri,
	        boundB1 = bjPos - rj,
	        boundB2 = bjPos + rj;
	
	    return boundB1 < boundA2;
	};
	
	/**
	 * Computes the variance of the body positions and estimates the best
	 * axis to use. Will automatically set property .axisIndex.
	 * @method autoDetectAxis
	 */
	SAPBroadphase.prototype.autoDetectAxis = function(){
	    var sumX=0,
	        sumX2=0,
	        sumY=0,
	        sumY2=0,
	        sumZ=0,
	        sumZ2=0,
	        bodies = this.axisList,
	        N = bodies.length,
	        invN=1/N;
	
	    for(var i=0; i!==N; i++){
	        var b = bodies[i];
	
	        var centerX = b.position.x;
	        sumX += centerX;
	        sumX2 += centerX*centerX;
	
	        var centerY = b.position.y;
	        sumY += centerY;
	        sumY2 += centerY*centerY;
	
	        var centerZ = b.position.z;
	        sumZ += centerZ;
	        sumZ2 += centerZ*centerZ;
	    }
	
	    var varianceX = sumX2 - sumX*sumX*invN,
	        varianceY = sumY2 - sumY*sumY*invN,
	        varianceZ = sumZ2 - sumZ*sumZ*invN;
	
	    if(varianceX > varianceY){
	        if(varianceX > varianceZ){
	            this.axisIndex = 0;
	        } else{
	            this.axisIndex = 2;
	        }
	    } else if(varianceY > varianceZ){
	        this.axisIndex = 1;
	    } else{
	        this.axisIndex = 2;
	    }
	};
	
	/**
	 * Returns all the bodies within an AABB.
	 * @method aabbQuery
	 * @param  {World} world
	 * @param  {AABB} aabb
	 * @param {array} result An array to store resulting bodies in.
	 * @return {array}
	 */
	SAPBroadphase.prototype.aabbQuery = function(world, aabb, result){
	    result = result || [];
	
	    if(this.dirty){
	        this.sortList();
	        this.dirty = false;
	    }
	
	    var axisIndex = this.axisIndex, axis = 'x';
	    if(axisIndex === 1){ axis = 'y'; }
	    if(axisIndex === 2){ axis = 'z'; }
	
	    var axisList = this.axisList;
	    var lower = aabb.lowerBound[axis];
	    var upper = aabb.upperBound[axis];
	    for(var i = 0; i < axisList.length; i++){
	        var b = axisList[i];
	
	        if(b.aabb.upperBound[axis] > lower && b.aabb.lowerBound[axis] < upper && b.aabb.overlaps(aabb)){
	            result.push(b);
	        }
	    }
	
	    return result;
	};
	},{"../collision/Broadphase":5,"../shapes/Shape":40}],12:[function(_dereq_,module,exports){
	module.exports = Constraint;
	
	var Utils = _dereq_('../utils/Utils');
	
	/**
	 * Constraint base class
	 * @class Constraint
	 * @author schteppe
	 * @constructor
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 */
	function Constraint(bodyA, bodyB, options){
	    options = Utils.defaults(options,{
	        collideConnected : true,
	        wakeUpBodies : true,
	    });
	
	    /**
	     * Equations to be solved in this constraint
	     * @property equations
	     * @type {Array}
	     */
	    this.equations = [];
	
	    /**
	     * @property {Body} bodyA
	     */
	    this.bodyA = bodyA;
	
	    /**
	     * @property {Body} bodyB
	     */
	    this.bodyB = bodyB;
	
	    /**
	     * @property {Number} id
	     */
	    this.id = Constraint.idCounter++;
	
	    /**
	     * Set to true if you want the bodies to collide when they are connected.
	     * @property collideConnected
	     * @type {boolean}
	     */
	    this.collideConnected = options.collideConnected;
	
	    if(options.wakeUpBodies){
	        if(bodyA){
	            bodyA.wakeUp();
	        }
	        if(bodyB){
	            bodyB.wakeUp();
	        }
	    }
	}
	
	/**
	 * @method update
	 */
	Constraint.prototype.update = function(){
	    throw new Error("method update() not implmemented in this Constraint subclass!");
	};
	
	Constraint.idCounter = 0;
	
	},{"../utils/Utils":48}],13:[function(_dereq_,module,exports){
	module.exports = DistanceConstraint;
	
	var Constraint = _dereq_('./Constraint');
	var ContactEquation = _dereq_('../equations/ContactEquation');
	
	/**
	 * Constrains two bodies to be at a constant distance from each other.
	 * @class DistanceConstraint
	 * @constructor
	 * @author schteppe
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 * @param {Number} distance
	 * @param {Number} maxForce
	 * @extends Constraint
	 */
	function DistanceConstraint(bodyA,bodyB,distance,maxForce){
	    Constraint.call(this,bodyA,bodyB);
	
	    if(typeof(maxForce)==="undefined" ) {
	        maxForce = 1e6;
	    }
	
	    // Equations to be fed to the solver
	    var eqs = this.equations = [
	        new ContactEquation(bodyA,bodyB), // Just in the normal direction
	    ];
	
	    var normal = eqs[0];
	
	    normal.minForce = -maxForce;
	    normal.maxForce =  maxForce;
	
	    // Update
	    this.update = function(){
	        bodyB.position.vsub(bodyA.position,normal.ni);
	        normal.ni.normalize();
	        /*bodyA.quaternion.vmult(pivotA,normal.ri);
	        bodyB.quaternion.vmult(pivotB,normal.rj);*/
	        normal.ni.mult( distance*0.5,normal.ri);
	        normal.ni.mult( -distance*0.5,normal.rj);
	    };
	}
	DistanceConstraint.prototype = new Constraint();
	
	},{"../equations/ContactEquation":16,"./Constraint":12}],14:[function(_dereq_,module,exports){
	module.exports = HingeConstraint;
	
	var Constraint = _dereq_('./Constraint');
	var RotationalEquation = _dereq_('../equations/RotationalEquation');
	var RotationalMotorEquation = _dereq_('../equations/RotationalMotorEquation');
	var ContactEquation = _dereq_('../equations/ContactEquation');
	var Vec3 = _dereq_('../math/Vec3');
	
	/**
	 * Hinge constraint. Tries to keep the local body axes equal.
	 * @class HingeConstraint
	 * @constructor
	 * @author schteppe
	 * @param {RigidBody} bodyA
	 * @param {RigidBody} bodyB
	 * @param {object} [options]
	 * @param {Vec3} [options.pivotA] A point defined locally in bodyA. This defines the offset of axisA.
	 * @param {Vec3} [options.axisA] an axis that bodyA can rotate around.
	 * @param {Vec3} [options.pivotB]
	 * @param {Vec3} [options.axisB]
	 * @param {Number} [options.maxForce=1e6]
	 * @extends Constraint
	 */
	function HingeConstraint(bodyA, bodyB, options){ // bodyA, pivotA, axisA, bodyB, pivotB, axisB, maxForce
	    Constraint.call(this, bodyA, bodyB, options);
	
	    var maxForce = typeof(options.maxForce) !== 'undefined' ? options.maxForce : 1e6;
	
	    // TODO: use a clever default setup... how?
	    var pivotA = this.pivotA = typeof(options.pivotA) !== 'undefined' ? options.pivotA.clone() : new Vec3();
	    var pivotB = this.pivotB = typeof(options.pivotB) !== 'undefined' ? options.pivotB.clone() : new Vec3();
	    var axisA = this.axisA = typeof(options.axisA) !== 'undefined' ? options.axisA.clone() : new Vec3(1,0,0);
	    var axisB = this.axisB = typeof(options.axisB) !== 'undefined' ? options.axisB.clone() : new Vec3(1,0,0);
	
	    var that = this;
	
	    // Equations to be fed to the solver
	    var eqs = this.equations = [
	        new RotationalEquation(bodyA,bodyB), // rotational1
	        new RotationalEquation(bodyA,bodyB), // rotational2
	        new ContactEquation(bodyA,bodyB),    // p2pNormal
	        new ContactEquation(bodyA,bodyB),    // p2pTangent1
	        new ContactEquation(bodyA,bodyB),    // p2pTangent2
	    ];
	
	    var r1 =        this.getRotationalEquation1();
	    var r2 =        this.getRotationalEquation2();
	    var normal =    this.getPointToPointEquation1();
	    var t1 =        this.getPointToPointEquation2();
	    var t2 =        this.getPointToPointEquation3();
	    var motor; // not activated by default
	
	    t1.minForce = t2.minForce = normal.minForce = -maxForce;
	    t1.maxForce = t2.maxForce = normal.maxForce =  maxForce;
	
	    var unitPivotA = pivotA.unit();
	    var unitPivotB = pivotB.unit();
	
	    var axisA_x_pivotA = this.axisA_x_pivotA = new Vec3();
	    var axisA_x_axisA_x_pivotA = this.axisA_x_axisA_x_pivotA = new Vec3();
	    var axisB_x_pivotB = this.axisB_x_pivotB = new Vec3();
	    axisA.cross(unitPivotA,axisA_x_pivotA);
	    if(axisA_x_pivotA.norm2() < 0.001){ // pivotA is along the same line as axisA
	        unitPivotA.tangents(axisA_x_pivotA,axisA_x_pivotA);
	    }
	    axisA.cross(axisA_x_pivotA,axisA_x_axisA_x_pivotA);
	    axisB.cross(unitPivotB,axisB_x_pivotB);
	    if(axisB_x_pivotB.norm2() < 0.001){ // pivotB is along the same line as axisB
	        axisB.tangents(axisB_x_pivotB,axisB_x_pivotB);
	    }
	
	    axisA_x_pivotA.normalize();
	    axisB_x_pivotB.normalize();
	
	    // Motor stuff
	    this.motorEnabled = false;
	    this.motorTargetVelocity = 0;
	    this.motorMinForce = -maxForce;
	    this.motorMaxForce = maxForce;
	    this.motorEquation = new RotationalMotorEquation(bodyA,bodyB,maxForce);
	}
	HingeConstraint.prototype = new Constraint();
	
	/**
	 * @method enableMotor
	 */
	HingeConstraint.prototype.enableMotor = function(){
	    if(!this.motorEnabled){
	        this.equations.push(this.motorEquation);
	        this.motorEnabled = true;
	    }
	};
	
	/**
	 * @method disableMotor
	 */
	HingeConstraint.prototype.disableMotor = function(){
	    if(this.motorEnabled){
	        this.motorEnabled = false;
	        this.equations.pop();
	    }
	};
	
	HingeConstraint.prototype.update = function(){
	    var bodyA = this.bodyA,
	        bodyB = this.bodyB,
	        eqs = this.equations,
	        motor = this.motorEquation,
	        r1 = eqs[0],
	        r2 = eqs[1],
	        normal = eqs[2],
	        t1 = eqs[3],
	        t2 = eqs[4];
	    var axisA_x_pivotA = this.axisA_x_pivotA;
	    var axisA = this.axisA;
	    var axisB = this.axisB;
	    var pivotA = this.pivotA;
	    var pivotB = this.pivotB;
	    var axisA_x_axisA_x_pivotA = this.axisA_x_axisA_x_pivotA;
	    var axisB_x_pivotB = this.axisB_x_pivotB;
	
	    // Update world positions of pivots
	    /*
	    bodyB.position.vsub(bodyA.position,normal.ni);
	    normal.ni.normalize();
	    */
	    normal.ni.set(1,0,0);
	    t1.ni.set(0,1,0);
	    t2.ni.set(0,0,1);
	    bodyA.quaternion.vmult(this.pivotA,normal.ri);
	    bodyB.quaternion.vmult(this.pivotB,normal.rj);
	
	    //normal.ni.tangents(t1.ni,t2.ni);
	    t1.ri.copy(normal.ri);
	    t1.rj.copy(normal.rj);
	    t2.ri.copy(normal.ri);
	    t2.rj.copy(normal.rj);
	
	    axisA.cross(pivotA, axisA_x_pivotA);
	    if(axisA_x_pivotA.norm2() < 0.001){ // pivotA is along the same line as axisA
	        pivotA.tangents(axisA_x_pivotA, axisA_x_pivotA);
	    }
	    axisA.cross(axisA_x_pivotA, axisA_x_axisA_x_pivotA);
	    axisB.cross(pivotB, axisB_x_pivotB);
	    if(axisB_x_pivotB.norm2() < 0.001){ // pivotB is along the same line as axisB
	        axisB.tangents(axisB_x_pivotB,axisB_x_pivotB);
	    }
	
	    axisA_x_pivotA.normalize();
	    axisB_x_pivotB.normalize();
	
	    // update rotational constraints
	    bodyA.quaternion.vmult(axisA_x_pivotA, r1.ni);
	    bodyB.quaternion.vmult(axisB, r1.nj);
	    bodyA.quaternion.vmult(axisA_x_axisA_x_pivotA, r2.ni);
	    bodyB.quaternion.vmult(axisB, r2.nj);
	
	    if(this.motorEnabled){
	        bodyA.quaternion.vmult(this.axisA, motor.axisA);
	        bodyB.quaternion.vmult(this.axisB, motor.axisB);
	        motor.targetVelocity = this.motorTargetVelocity;
	        motor.maxForce = this.motorMaxForce;
	        motor.minForce = this.motorMinForce;
	    }
	};
	
	HingeConstraint.prototype.getRotationalEquation1 =   function(){ return this.equations[0]; };
	HingeConstraint.prototype.getRotationalEquation2 =   function(){ return this.equations[1]; };
	HingeConstraint.prototype.getPointToPointEquation1 = function(){ return this.equations[2]; };
	HingeConstraint.prototype.getPointToPointEquation2 = function(){ return this.equations[3]; };
	HingeConstraint.prototype.getPointToPointEquation3 = function(){ return this.equations[4]; };
	
	},{"../equations/ContactEquation":16,"../equations/RotationalEquation":19,"../equations/RotationalMotorEquation":20,"../math/Vec3":27,"./Constraint":12}],15:[function(_dereq_,module,exports){
	module.exports = PointToPointConstraint;
	
	var Constraint = _dereq_('./Constraint');
	var ContactEquation = _dereq_('../equations/ContactEquation');
	
	/**
	 * Connects two bodies at given offset points.
	 * @class PointToPointConstraint
	 * @extends Constraint
	 * @constructor
	 * @param {Body} bodyA
	 * @param {Vec3} pivotA The point relative to the center of mass of bodyA which bodyA is constrained to.
	 * @param {Body} bodyB Body that will be constrained in a similar way to the same point as bodyA. We will therefore get sort of a link between bodyA and bodyB. If not specified, bodyA will be constrained to a static point.
	 * @param {Vec3} pivotB See pivotA.
	 * @param {Number} maxForce The maximum force that should be applied to constrain the bodies.
	 *
	 * @example
	 *     var bodyA = new Body({ mass: 1 });
	 *     var bodyB = new Body({ mass: 1 });
	 *     bodyA.position.set(-1, 0, 0);
	 *     bodyB.position.set(1, 0, 0);
	 *     bodyA.addShape(shapeA);
	 *     bodyB.addShape(shapeB);
	 *     world.addBody(bodyA);
	 *     world.addBody(bodyB);
	 *     var localPivotA = new Vec3(1, 0, 0);
	 *     var localPivotB = new Vec3(-1, 0, 0);
	 *     var constraint = new PointToPointConstraint(bodyA, localPivotA, bodyB, localPivotB);
	 *     world.addConstraint(constraint);
	 */
	function PointToPointConstraint(bodyA,pivotA,bodyB,pivotB,maxForce){
	    Constraint.call(this,bodyA,bodyB);
	
	    // Equations to be fed to the solver
	    var eqs = this.equations = [
	        new ContactEquation(bodyA,bodyB), // Normal
	        new ContactEquation(bodyA,bodyB), // Tangent2
	        new ContactEquation(bodyA,bodyB), // Tangent2
	    ];
	
	    var normal = eqs[0];
	    var t1 = eqs[1];
	    var t2 = eqs[2];
	
	    t1.minForce = t2.minForce = normal.minForce = -maxForce;
	    t1.maxForce = t2.maxForce = normal.maxForce =  maxForce;
	
	    // Update
	    this.update = function(){
	        bodyB.position.vsub(bodyA.position,normal.ni);
	        normal.ni.normalize();
	        bodyA.quaternion.vmult(pivotA,normal.ri);
	        bodyB.quaternion.vmult(pivotB,normal.rj);
	
	        normal.ni.tangents(t1.ni,t2.ni);
	        t1.ri.copy(normal.ri);
	        t1.rj.copy(normal.rj);
	        t2.ri.copy(normal.ri);
	        t2.rj.copy(normal.rj);
	    };
	}
	PointToPointConstraint.prototype = new Constraint();
	
	},{"../equations/ContactEquation":16,"./Constraint":12}],16:[function(_dereq_,module,exports){
	module.exports = ContactEquation;
	
	var Equation = _dereq_('./Equation');
	var Vec3 = _dereq_('../math/Vec3');
	var Mat3 = _dereq_('../math/Mat3');
	
	/**
	 * Contact/non-penetration constraint equation
	 * @class ContactEquation
	 * @constructor
	 * @author schteppe
	 * @param {Body} bj
	 * @param {Body} bi
	 * @extends Equation
	 */
	function ContactEquation(bi,bj){
	    Equation.call(this,bi,bj,0,1e6);
	
	    /**
	     * @property restitution
	     * @type {Number}
	     */
	    this.restitution = 0.0; // "bounciness": u1 = -e*u0
	
	    /**
	     * World-oriented vector that goes from the center of bi to the contact point.
	     * @property {Vec3} ri
	     */
	    this.ri = new Vec3();
	
	    /**
	     * World-oriented vector that starts in body j position and goes to the contact point.
	     * @property {Vec3} rj
	     */
	    this.rj = new Vec3();
	
	    this.penetrationVec = new Vec3();
	
	    /**
	     * Contact normal, pointing out of body i.
	     * @property {Vec3} ni
	     */
	    this.ni = new Vec3();
	
	    this.rixn = new Vec3();
	    this.rjxn = new Vec3();
	
	    this.invIi = new Mat3();
	    this.invIj = new Mat3();
	
	    // Cache
	    this.biInvInertiaTimesRixn =  new Vec3();
	    this.bjInvInertiaTimesRjxn =  new Vec3();
	}
	
	ContactEquation.prototype = new Equation();
	ContactEquation.prototype.constructor = ContactEquation;
	
	var ContactEquation_computeB_temp1 = new Vec3(); // Temp vectors
	var ContactEquation_computeB_temp2 = new Vec3();
	var ContactEquation_computeB_zero = new Vec3();
	ContactEquation.prototype.computeB = function(h){
	    var a = this.a,
	        b = this.b,
	        bi = this.bi,
	        bj = this.bj,
	        ri = this.ri,
	        rj = this.rj,
	        rixn = this.rixn,
	        rjxn = this.rjxn,
	
	        zero = ContactEquation_computeB_zero,
	
	        vi = bi.velocity,
	        wi = bi.angularVelocity ? bi.angularVelocity : zero,
	        fi = bi.force,
	        taui = bi.tau ? bi.tau : zero,
	
	        vj = bj.velocity,
	        wj = bj.angularVelocity ? bj.angularVelocity : zero,
	        fj = bj.force,
	        tauj = bj.tau ? bj.tau : zero,
	
	        penetrationVec = this.penetrationVec,
	        invMassi = bi.invMass,
	        invMassj = bj.invMass,
	
	        invIi = this.invIi,
	        invIj = this.invIj,
	
	        GA = this.jacobianElementA,
	        GB = this.jacobianElementB,
	
	        n = this.ni;
	
	    // Caluclate cross products
	    ri.cross(n,rixn);
	    rj.cross(n,rjxn);
	
	    // g = xj+rj -(xi+ri)
	    // G = [ -ni  -rixn  ni  rjxn ]
	    n.negate(GA.spatial);
	    rixn.negate(GA.rotational);
	    GB.spatial.copy(n);
	    GB.rotational.copy(rjxn);
	
	    // Calculate the penetration vector
	    var penetrationVec = this.penetrationVec;
	    penetrationVec.set(0,0,0);
	    penetrationVec.vadd(bj.position,penetrationVec);
	    penetrationVec.vadd(rj,penetrationVec);
	    penetrationVec.vsub(bi.position,penetrationVec);
	    penetrationVec.vsub(ri,penetrationVec);
	
	    var g = n.dot(penetrationVec);
	
	    var invIi_vmult_taui = ContactEquation_computeB_temp1;
	    var invIj_vmult_tauj = ContactEquation_computeB_temp2;
	    if(bi.invInertiaWorld){
	        bi.invInertiaWorld.vmult(taui,invIi_vmult_taui);
	    } else {
	        invIi_vmult_taui.set(0,0,0);
	    }
	    if(bj.invInertiaWorld){
	        bj.invInertiaWorld.vmult(tauj,invIj_vmult_tauj);
	    } else {
	        invIj_vmult_tauj.set(0,0,0);
	    }
	
	    // Compute iteration
	    var ePlusOne = this.restitution+1;
	    var GW = ePlusOne*vj.dot(n) - ePlusOne*vi.dot(n) + wj.dot(rjxn) - wi.dot(rixn);
	    var GiMf = this.computeGiMf();//fj.dot(n)*invMassj - fi.dot(n)*invMassi + rjxn.dot(invIj_vmult_tauj) - rixn.dot(invIi_vmult_taui);
	
	    var B = - g * a - GW * b - h*GiMf;
	
	    return B;
	};
	
	// Compute C = GMG+eps in the SPOOK equation
	/*
	var computeC_temp1 = new Vec3();
	var computeC_temp2 = new Vec3();
	ContactEquation.prototype.computeC = function(){
	    var bi = this.bi;
	    var bj = this.bj;
	    var rixn = this.rixn;
	    var rjxn = this.rjxn;
	    var invMassi = bi.invMass;
	    var invMassj = bj.invMass;
	
	    var C = invMassi + invMassj + this.eps;
	
	    var invIi = this.invIi;
	    var invIj = this.invIj;
	
	    // Compute rxn * I * rxn for each body
	    if(bi.invInertiaWorld) bi.invInertiaWorld.vmult(rixn, this.biInvInertiaTimesRixn);
	    if(bj.invInertiaWorld) bj.invInertiaWorld.vmult(rjxn, this.bjInvInertiaTimesRjxn);
	
	    C += this.biInvInertiaTimesRixn.dot(rixn);
	    C += this.bjInvInertiaTimesRjxn.dot(rjxn);
	
	    return C;
	};
	
	var computeGWlambda_ulambda = new Vec3();
	ContactEquation.prototype.computeGWlambda = function(){
	    var bi = this.bi;
	    var bj = this.bj;
	    var ulambda = computeGWlambda_ulambda;
	
	    var GWlambda = 0.0;
	
	    bj.vlambda.vsub(bi.vlambda, ulambda);
	    GWlambda += ulambda.dot(this.ni);
	
	    // Angular
	    if(bi.wlambda){
	        GWlambda -= bi.wlambda.dot(this.rixn);
	    }
	    if(bj.wlambda){
	        GWlambda += bj.wlambda.dot(this.rjxn);
	    }
	
	    return GWlambda;
	};
	
	var ContactEquation_addToWlambda_temp1 = new Vec3();
	var ContactEquation_addToWlambda_temp2 = new Vec3();
	ContactEquation.prototype.addToWlambda = function(deltalambda){
	    var bi = this.bi,
	        bj = this.bj,
	        rixn = this.rixn,
	        rjxn = this.rjxn,
	        invMassi = bi.invMass,
	        invMassj = bj.invMass,
	        n = this.ni,
	        temp1 = ContactEquation_addToWlambda_temp1,
	        temp2 = ContactEquation_addToWlambda_temp2;
	
	
	    // Add to linear velocity
	    n.mult(invMassi * deltalambda, temp2);
	    bi.vlambda.vsub(temp2,bi.vlambda);
	    n.mult(invMassj * deltalambda, temp2);
	    bj.vlambda.vadd(temp2,bj.vlambda);
	
	    // Add to angular velocity
	    if(bi.wlambda !== undefined){
	        this.biInvInertiaTimesRixn.mult(deltalambda,temp1);
	
	        bi.wlambda.vsub(temp1,bi.wlambda);
	    }
	    if(bj.wlambda !== undefined){
	        this.bjInvInertiaTimesRjxn.mult(deltalambda,temp1);
	        bj.wlambda.vadd(temp1,bj.wlambda);
	    }
	};
	*/
	
	},{"../math/Mat3":24,"../math/Vec3":27,"./Equation":17}],17:[function(_dereq_,module,exports){
	module.exports = Equation;
	
	var JacobianElement = _dereq_('../math/JacobianElement'),
	    Vec3 = _dereq_('../math/Vec3');
	
	/**
	 * Equation base class
	 * @class Equation
	 * @constructor
	 * @author schteppe
	 * @param {Body} bi
	 * @param {Body} bj
	 * @param {Number} minForce Minimum (read: negative max) force to be applied by the constraint.
	 * @param {Number} maxForce Maximum (read: positive max) force to be applied by the constraint.
	 */
	function Equation(bi,bj,minForce,maxForce){
	    this.id = -1;
	
	    /**
	     * @property {number} minForce
	     */
	    this.minForce = typeof(minForce)==="undefined" ? -1e6 : minForce;
	
	    /**
	     * @property {number} maxForce
	     */
	    this.maxForce = typeof(maxForce)==="undefined" ? 1e6 : maxForce;
	
	    /**
	     * @property bi
	     * @type {Body}
	     */
	    this.bi = bi;
	
	    /**
	     * @property bj
	     * @type {Body}
	     */
	    this.bj = bj;
	
	    /**
	     * SPOOK parameter
	     * @property {number} a
	     */
	    this.a = 0.0;
	
	    /**
	     * SPOOK parameter
	     * @property {number} b
	     */
	    this.b = 0.0;
	
	    /**
	     * SPOOK parameter
	     * @property {number} eps
	     */
	    this.eps = 0.0;
	
	    /**
	     * @property {JacobianElement} jacobianElementA
	     */
	    this.jacobianElementA = new JacobianElement();
	
	    /**
	     * @property {JacobianElement} jacobianElementA
	     */
	    this.jacobianElementB = new JacobianElement();
	
	    // Set typical spook params
	    this.setSpookParams(1e7,4,1/60);
	
	    this.enabled = true;
	}
	Equation.prototype.constructor = Equation;
	
	/**
	 * Recalculates a,b,eps.
	 * @method setSpookParams
	 */
	Equation.prototype.setSpookParams = function(stiffness,relaxation,timeStep){
	    var d = relaxation,
	        k = stiffness,
	        h = timeStep;
	    this.a = 4.0 / (h * (1 + 4 * d));
	    this.b = (4.0 * d) / (1 + 4 * d);
	    this.eps = 4.0 / (h * h * k * (1 + 4 * d));
	};
	
	/**
	 * Computes the RHS of the SPOOK equation
	 * @method computeB
	 * @return {Number}
	 */
	Equation.prototype.computeB = function(a,b,h){
	    var GW = this.computeGW(),
	        Gq = this.computeGq(),
	        GiMf = this.computeGiMf();
	    return - Gq * a - GW * b - GiMf*h;
	};
	
	/**
	 * Computes G*q, where q are the generalized body coordinates
	 * @method computeGq
	 * @return {Number}
	 */
	Equation.prototype.computeGq = function(){
	    var GA = this.jacobianElementA,
	        GB = this.jacobianElementB,
	        bi = this.bi,
	        bj = this.bj,
	        xi = bi.position,
	        xj = bj.position;
	    return GA.spatial.dot(xi) + GB.spatial.dot(xj);
	};
	
	var zero = new Vec3();
	
	/**
	 * Computes G*W, where W are the body velocities
	 * @method computeGW
	 * @return {Number}
	 */
	Equation.prototype.computeGW = function(){
	    var GA = this.jacobianElementA,
	        GB = this.jacobianElementB,
	        bi = this.bi,
	        bj = this.bj,
	        vi = bi.velocity,
	        vj = bj.velocity,
	        wi = bi.angularVelocity || zero,
	        wj = bj.angularVelocity || zero;
	    return GA.multiplyVectors(vi,wi) + GB.multiplyVectors(vj,wj);
	};
	
	
	/**
	 * Computes G*Wlambda, where W are the body velocities
	 * @method computeGWlambda
	 * @return {Number}
	 */
	Equation.prototype.computeGWlambda = function(){
	    var GA = this.jacobianElementA,
	        GB = this.jacobianElementB,
	        bi = this.bi,
	        bj = this.bj,
	        vi = bi.vlambda,
	        vj = bj.vlambda,
	        wi = bi.wlambda || zero,
	        wj = bj.wlambda || zero;
	    return GA.multiplyVectors(vi,wi) + GB.multiplyVectors(vj,wj);
	};
	
	/**
	 * Computes G*inv(M)*f, where M is the mass matrix with diagonal blocks for each body, and f are the forces on the bodies.
	 * @method computeGiMf
	 * @return {Number}
	 */
	var iMfi = new Vec3(),
	    iMfj = new Vec3(),
	    invIi_vmult_taui = new Vec3(),
	    invIj_vmult_tauj = new Vec3();
	Equation.prototype.computeGiMf = function(){
	    var GA = this.jacobianElementA,
	        GB = this.jacobianElementB,
	        bi = this.bi,
	        bj = this.bj,
	        fi = bi.force,
	        ti = bi.tau,
	        fj = bj.force,
	        tj = bj.tau,
	        invMassi = bi.invMassSolve,
	        invMassj = bj.invMassSolve;
	
	    if(bi.invInertiaWorldSolve){ bi.invInertiaWorldSolve.vmult(ti,invIi_vmult_taui); }
	    else { invIi_vmult_taui.set(0,0,0); }
	    if(bj.invInertiaWorldSolve){ bj.invInertiaWorldSolve.vmult(tj,invIj_vmult_tauj); }
	    else { invIj_vmult_tauj.set(0,0,0); }
	
	    fi.mult(invMassi,iMfi);
	    fj.mult(invMassj,iMfj);
	
	    return GA.multiplyVectors(iMfi,invIi_vmult_taui) + GB.multiplyVectors(iMfj,invIj_vmult_tauj);
	};
	
	/**
	 * Computes G*inv(M)*G'
	 * @method computeGiMGt
	 * @return {Number}
	 */
	var tmp = new Vec3();
	Equation.prototype.computeGiMGt = function(){
	    var GA = this.jacobianElementA,
	        GB = this.jacobianElementB,
	        bi = this.bi,
	        bj = this.bj,
	        invMassi = bi.invMassSolve,
	        invMassj = bj.invMassSolve,
	        invIi = bi.invInertiaWorldSolve,
	        invIj = bj.invInertiaWorldSolve,
	        result = invMassi + invMassj;
	
	    if(invIi){
	        invIi.vmult(GA.rotational,tmp);
	        result += tmp.dot(GA.rotational);
	    }
	
	    if(invIj){
	        invIj.vmult(GB.rotational,tmp);
	        result += tmp.dot(GB.rotational);
	    }
	
	    return  result;
	};
	
	var addToWlambda_temp = new Vec3(),
	    addToWlambda_Gi = new Vec3(),
	    addToWlambda_Gj = new Vec3(),
	    addToWlambda_ri = new Vec3(),
	    addToWlambda_rj = new Vec3(),
	    addToWlambda_Mdiag = new Vec3();
	
	/**
	 * Add constraint velocity to the bodies.
	 * @method addToWlambda
	 * @param {Number} deltalambda
	 */
	Equation.prototype.addToWlambda = function(deltalambda){
	    var GA = this.jacobianElementA,
	        GB = this.jacobianElementB,
	        bi = this.bi,
	        bj = this.bj,
	        temp = addToWlambda_temp;
	
	    // Add to linear velocity
	    // v_lambda += inv(M) * delta_lamba * G
	    GA.spatial.mult(bi.invMassSolve * deltalambda,temp);
	    bi.vlambda.vadd(temp, bi.vlambda);
	
	    GB.spatial.mult(bj.invMassSolve * deltalambda,temp);
	    bj.vlambda.vadd(temp, bj.vlambda);
	
	    // Add to angular velocity
	    if(bi.invInertiaWorldSolve){
	        bi.invInertiaWorldSolve.vmult(GA.rotational,temp);
	        temp.mult(deltalambda,temp);
	        bi.wlambda.vadd(temp,bi.wlambda);
	    }
	
	    if(bj.invInertiaWorldSolve){
	        bj.invInertiaWorldSolve.vmult(GB.rotational,temp);
	        temp.mult(deltalambda,temp);
	        bj.wlambda.vadd(temp,bj.wlambda);
	    }
	};
	
	/**
	 * Compute the denominator part of the SPOOK equation: C = G*inv(M)*G' + eps
	 * @method computeInvC
	 * @param  {Number} eps
	 * @return {Number}
	 */
	Equation.prototype.computeC = function(){
	    return this.computeGiMGt() + this.eps;
	};
	
	},{"../math/JacobianElement":23,"../math/Vec3":27}],18:[function(_dereq_,module,exports){
	module.exports = FrictionEquation;
	
	var Equation = _dereq_('./Equation');
	var Vec3 = _dereq_('../math/Vec3');
	var Mat3 = _dereq_('../math/Mat3');
	
	/**
	 * Constrains the slipping in a contact along a tangent
	 * @class FrictionEquation
	 * @constructor
	 * @author schteppe
	 * @param {Body} bi
	 * @param {Body} bj
	 * @param {Number} slipForce should be +-F_friction = +-mu * F_normal = +-mu * m * g
	 * @extends Equation
	 */
	function FrictionEquation(bi,bj,slipForce){
	    Equation.call(this,bi,bj,-slipForce,slipForce);
	    this.ri = new Vec3();
	    this.rj = new Vec3();
	    this.t = new Vec3(); // tangent
	
	
	    // The following is just cache
	    this.rixt = new Vec3();
	    this.rjxt = new Vec3();
	    this.wixri = new Vec3();
	    this.wjxrj = new Vec3();
	
	    this.invIi = new Mat3();
	    this.invIj = new Mat3();
	
	    this.relVel = new Vec3();
	    this.relForce = new Vec3();
	
	    this.biInvInertiaTimesRixt =  new Vec3();
	    this.bjInvInertiaTimesRjxt =  new Vec3();
	}
	
	FrictionEquation.prototype = new Equation();
	FrictionEquation.prototype.constructor = FrictionEquation;
	
	var FrictionEquation_computeB_temp1 = new Vec3();
	var FrictionEquation_computeB_temp2 = new Vec3();
	var FrictionEquation_computeB_zero = new Vec3();
	FrictionEquation.prototype.computeB = function(h){
	    var a = this.a,
	        b = this.b,
	        bi = this.bi,
	        bj = this.bj,
	        ri = this.ri,
	        rj = this.rj,
	        rixt = this.rixt,
	        rjxt = this.rjxt,
	        wixri = this.wixri,
	        wjxrj = this.wjxrj,
	        zero = FrictionEquation_computeB_zero;
	
	    var vi = bi.velocity,
	        wi = bi.angularVelocity ? bi.angularVelocity : zero,
	        fi = bi.force,
	        taui = bi.tau ? bi.tau : zero,
	
	        vj = bj.velocity,
	        wj = bj.angularVelocity ? bj.angularVelocity : zero,
	        fj = bj.force,
	        tauj = bj.tau ? bj.tau : zero,
	
	        relVel = this.relVel,
	        relForce = this.relForce,
	        invMassi = bi.invMass,
	        invMassj = bj.invMass,
	
	        invIi = this.invIi,
	        invIj = this.invIj,
	
	        t = this.t,
	
	        invIi_vmult_taui = FrictionEquation_computeB_temp1,
	        invIj_vmult_tauj = FrictionEquation_computeB_temp2;
	
	    // Caluclate cross products
	    ri.cross(t,rixt);
	    rj.cross(t,rjxt);
	
	    wi.cross(ri,wixri);
	    wj.cross(rj,wjxrj);
	
	    // G = [-t -rixt t rjxt]
	    // And remember, this is a pure velocity constraint, g is always zero!
	    var GA = this.jacobianElementA,
	        GB = this.jacobianElementB;
	    t.negate(GA.spatial);
	    rixt.negate(GA.rotational);
	    GB.spatial.copy(t);
	    GB.rotational.copy(rjxt);
	
	    if(bi.invInertiaWorld){ bi.invInertiaWorld.vmult(taui,invIi_vmult_taui); }
	    else { invIi_vmult_taui.set(0,0,0); }
	    if(bj.invInertiaWorld){ bj.invInertiaWorld.vmult(tauj,invIj_vmult_tauj); }
	    else { invIj_vmult_tauj.set(0,0,0); }
	
	    var GW = this.computeGW();//vj.dot(t) - vi.dot(t) + wjxrj.dot(t) - wixri.dot(t), // eq. 40
	    var GiMf = this.computeGiMf();//fj.dot(t)*invMassj - fi.dot(t)*invMassi + rjxt.dot(invIj_vmult_tauj) - rixt.dot(invIi_vmult_taui);
	
	    // we do only want to constrain velocity, so g=0
	    var B = - GW * b - h*GiMf;
	
	    return B;
	};
	
	/*
	// Compute C = G * Minv * G + eps
	//var FEcomputeC_temp1 = new Vec3();
	//var FEcomputeC_temp2 = new Vec3();
	FrictionEquation.prototype.computeC = function(){
	    var bi = this.bi,
	        bj = this.bj,
	        rixt = this.rixt,
	        rjxt = this.rjxt,
	        invMassi = bi.invMass,
	        invMassj = bj.invMass,
	        C = invMassi + invMassj + this.eps,
	        invIi = this.invIi,
	        invIj = this.invIj;
	
	    // Compute rxt * I * rxt for each body
	    if(bi.invInertiaWorld) bi.invInertiaWorld.vmult(rixt,this.biInvInertiaTimesRixt);
	    if(bj.invInertiaWorld) bj.invInertiaWorld.vmult(rjxt,this.bjInvInertiaTimesRjxt);
	    C += this.biInvInertiaTimesRixt.dot(rixt);
	    C += this.bjInvInertiaTimesRjxt.dot(rjxt);
	
	    return C;
	};
	
	var FrictionEquation_computeGWlambda_ulambda = new Vec3();
	FrictionEquation.prototype.computeGWlambda = function(){
	    var bi = this.bi;
	    var bj = this.bj;
	
	    var GWlambda = 0.0;
	    var ulambda = FrictionEquation_computeGWlambda_ulambda;
	    bj.vlambda.vsub(bi.vlambda,ulambda);
	    GWlambda += ulambda.dot(this.t);
	
	    // Angular
	    if(bi.wlambda){
	        GWlambda -= bi.wlambda.dot(this.rixt);
	    }
	    if(bj.wlambda){
	        GWlambda += bj.wlambda.dot(this.rjxt);
	    }
	
	    return GWlambda;
	};
	
	var FrictionEquation_addToWlambda_tmp = new Vec3();
	FrictionEquation.prototype.addToWlambda = function(deltalambda){
	    var bi = this.bi,
	        bj = this.bj,
	        rixt = this.rixt,
	        rjxt = this.rjxt,
	        invMassi = bi.invMass,
	        invMassj = bj.invMass,
	        t = this.t,
	        tmp = FrictionEquation_addToWlambda_tmp,
	        wi = bi.wlambda,
	        wj = bj.wlambda;
	
	    // Add to linear velocity
	    t.mult(invMassi * deltalambda, tmp);
	    bi.vlambda.vsub(tmp,bi.vlambda);
	
	    t.mult(invMassj * deltalambda, tmp);
	    bj.vlambda.vadd(tmp,bj.vlambda);
	
	    // Add to angular velocity
	    if(wi){
	        this.biInvInertiaTimesRixt.mult(deltalambda,tmp);
	        wi.vsub(tmp,wi);
	    }
	    if(wj){
	        this.bjInvInertiaTimesRjxt.mult(deltalambda,tmp);
	        wj.vadd(tmp,wj);
	    }
	};
	*/
	
	},{"../math/Mat3":24,"../math/Vec3":27,"./Equation":17}],19:[function(_dereq_,module,exports){
	module.exports = RotationalEquation;
	
	var Vec3 = _dereq_('../math/Vec3');
	var Mat3 = _dereq_('../math/Mat3');
	var Equation = _dereq_('./Equation');
	
	/**
	 * Rotational constraint. Works to keep the local vectors orthogonal to each other.
	 * @class RotationalEquation
	 * @constructor
	 * @author schteppe
	 * @param {RigidBody} bj
	 * @param {Vec3} localVectorInBodyA
	 * @param {RigidBody} bi
	 * @param {Vec3} localVectorInBodyB
	 * @extends Equation
	 */
	function RotationalEquation(bodyA, bodyB){
	    Equation.call(this,bodyA,bodyB,-1e6,1e6);
	    this.ni = new Vec3(); // World oriented localVectorInBodyA
	    this.nj = new Vec3(); // ...and B
	
	    this.nixnj = new Vec3();
	    this.njxni = new Vec3();
	
	    this.invIi = new Mat3();
	    this.invIj = new Mat3();
	
	    this.relVel = new Vec3();
	    this.relForce = new Vec3();
	}
	
	RotationalEquation.prototype = new Equation();
	RotationalEquation.prototype.constructor = RotationalEquation;
	
	var zero = new Vec3();
	
	RotationalEquation.prototype.computeB = function(h){
	    var a = this.a,
	        b = this.b,
	        bi = this.bi,
	        bj = this.bj,
	
	        ni = this.ni,
	        nj = this.nj,
	
	        nixnj = this.nixnj,
	        njxni = this.njxni,
	
	        vi = bi.velocity,
	        wi = bi.angularVelocity ? bi.angularVelocity : zero,
	        fi = bi.force,
	        taui = bi.tau ? bi.tau : zero,
	
	        vj = bj.velocity,
	        wj = bj.angularVelocity ? bj.angularVelocity : zero,
	        fj = bj.force,
	        tauj = bj.tau ? bj.tau : zero,
	
	        invMassi = bi.invMass,
	        invMassj = bj.invMass,
	
	        GA = this.jacobianElementA,
	        GB = this.jacobianElementB,
	
	        invIi = this.invIi,
	        invIj = this.invIj;
	
	    // Caluclate cross products
	    ni.cross(nj,nixnj);
	    nj.cross(ni,njxni);
	
	    // g = ni * nj
	    // gdot = (nj x ni) * wi + (ni x nj) * wj
	    // G = [0 njxni 0 nixnj]
	    // W = [vi wi vj wj]
	    GA.rotational.copy(njxni);
	    GB.rotational.copy(nixnj);
	
	    var g = -ni.dot(nj),
	        GW = this.computeGW(),//njxni.dot(wi) + nixnj.dot(wj),
	        GiMf = this.computeGiMf();//njxni.dot(invIi.vmult(taui)) + nixnj.dot(invIj.vmult(tauj));
	
	    var B = - g * a - GW * b - h*GiMf;
	
	    return B;
	};
	
	/*
	// Compute C = GMG+eps
	RotationalEquation.prototype.computeC = function(){
	    var bi = this.bi;
	    var bj = this.bj;
	    var nixnj = this.nixnj;
	    var njxni = this.njxni;
	    var invMassi = bi.invMass;
	    var invMassj = bj.invMass;
	
	    var C = this.eps;
	
	
	    C += bi.invInertiaWorld.vmult(njxni).dot(njxni);
	    C += bj.invInertiaWorld.vmult(nixnj).dot(nixnj);
	
	    return C;
	};
	
	var computeGWlambda_ulambda = new Vec3();
	RotationalEquation.prototype.computeGWlambda = function(){
	    var bi = this.bi;
	    var bj = this.bj;
	    var ulambda = computeGWlambda_ulambda;
	
	    var GWlambda = 0.0;
	    //bj.vlambda.vsub(bi.vlambda, ulambda);
	    //GWlambda += ulambda.dot(this.ni);
	
	    // Angular
	    if(bi.wlambda){
	        GWlambda += bi.wlambda.dot(this.njxni);
	    }
	    if(bj.wlambda){
	        GWlambda += bj.wlambda.dot(this.nixnj);
	    }
	
	    //console.log("GWlambda:",GWlambda);
	
	    return GWlambda;
	};
	
	RotationalEquation.prototype.addToWlambda = function(deltalambda){
	    var bi = this.bi;
	    var bj = this.bj;
	    var nixnj = this.nixnj;
	    var njxni = this.njxni;
	    var invMassi = bi.invMass;
	    var invMassj = bj.invMass;
	
	    // Add to linear velocity
	    //bi.vlambda.vsub(n.mult(invMassi * deltalambda),bi.vlambda);
	    //bj.vlambda.vadd(n.mult(invMassj * deltalambda),bj.vlambda);
	
	    // Add to angular velocity
	    if(bi.wlambda){
	        var I = bi.invInertiaWorld;
	        bi.wlambda.vsub(I.vmult(nixnj).mult(deltalambda),bi.wlambda);
	    }
	    if(bj.wlambda){
	        var I = bj.invInertiaWorld;
	        bj.wlambda.vadd(I.vmult(nixnj).mult(deltalambda),bj.wlambda);
	    }
	};
	*/
	
	},{"../math/Mat3":24,"../math/Vec3":27,"./Equation":17}],20:[function(_dereq_,module,exports){
	module.exports = RotationalMotorEquation;
	
	var Vec3 = _dereq_('../math/Vec3');
	var Mat3 = _dereq_('../math/Mat3');
	var Equation = _dereq_('./Equation');
	
	/**
	 * Rotational motor constraint. Works to keep the relative angular velocity of the bodies to a given value
	 * @class RotationalMotorEquation
	 * @constructor
	 * @author schteppe
	 * @param {RigidBody} bodyA
	 * @param {RigidBody} bodyB
	 * @param {Number} maxForce
	 * @extends Equation
	 */
	function RotationalMotorEquation(bodyA, bodyB, maxForce){
	    maxForce = maxForce || 1e6;
	    Equation.call(this,bodyA,bodyB,-maxForce,maxForce);
	    this.axisA = new Vec3(); // World oriented rotational axis
	    this.axisB = new Vec3(); // World oriented rotational axis
	
	    this.invIi = new Mat3();
	    this.invIj = new Mat3();
	
	    /**
	     * Motor velocity
	     * @property {Number} targetVelocity
	     */
	    this.targetVelocity = 0;
	}
	
	RotationalMotorEquation.prototype = new Equation();
	RotationalMotorEquation.prototype.constructor = RotationalMotorEquation;
	
	var zero = new Vec3();
	
	RotationalMotorEquation.prototype.computeB = function(h){
	    var a = this.a,
	        b = this.b,
	        bi = this.bi,
	        bj = this.bj,
	
	        axisA = this.axisA,
	        axisB = this.axisB,
	
	        vi = bi.velocity,
	        wi = bi.angularVelocity ? bi.angularVelocity : zero,
	        fi = bi.force,
	        taui = bi.tau ? bi.tau : zero,
	
	        vj = bj.velocity,
	        wj = bj.angularVelocity ? bj.angularVelocity : zero,
	        fj = bj.force,
	        tauj = bj.tau ? bj.tau : zero,
	
	        GA = this.jacobianElementA,
	        GB = this.jacobianElementB,
	
	        invMassi = bi.invMass,
	        invMassj = bj.invMass;
	
	    // g = 0
	    // gdot = axisA * wi - axisB * wj
	    // G = [0 axisA 0 -axisB]
	    // W = [vi wi vj wj]
	
	    GA.rotational.copy(axisA);
	    axisB.negate(GB.rotational);
	
	    var GW = this.computeGW() - this.targetVelocity,
	        GiMf = this.computeGiMf();//axis.dot(invIi.vmult(taui)) + axis.dot(invIj.vmult(tauj));
	
	    var B = - GW * b - h*GiMf;
	
	    return B;
	};
	
	/*
	// Compute C = GMG+eps
	RotationalMotorEquation.prototype.computeC = function(){
	    var bi = this.bi;
	    var bj = this.bj;
	    var axisA = this.axisA;
	    var axisB = this.axisB;
	    var invMassi = bi.invMass;
	    var invMassj = bj.invMass;
	
	    var C = this.eps;
	
	    C += bi.invInertiaWorld.vmult(axisA).dot(axisB);
	    C += bj.invInertiaWorld.vmult(axisB).dot(axisB);
	
	    return C;
	};
	
	var computeGWlambda_ulambda = new Vec3();
	RotationalMotorEquation.prototype.computeGWlambda = function(){
	    var bi = this.bi;
	    var bj = this.bj;
	    var ulambda = computeGWlambda_ulambda;
	    var axisA = this.axisA;
	    var axisB = this.axisB;
	
	    var GWlambda = 0.0;
	    //bj.vlambda.vsub(bi.vlambda, ulambda);
	    //GWlambda += ulambda.dot(this.ni);
	
	    // Angular
	    if(bi.wlambda){
	        GWlambda += bi.wlambda.dot(axisA);
	    }
	    if(bj.wlambda){
	        GWlambda += bj.wlambda.dot(axisB);
	    }
	
	    //console.log("GWlambda:",GWlambda);
	
	    return GWlambda;
	};
	
	RotationalMotorEquation.prototype.addToWlambda = function(deltalambda){
	    var bi = this.bi;
	    var bj = this.bj;
	    var axisA = this.axisA;
	    var axisB = this.axisB;
	    var invMassi = bi.invMass;
	    var invMassj = bj.invMass;
	
	    // Add to linear velocity
	    //bi.vlambda.vsub(n.mult(invMassi * deltalambda),bi.vlambda);
	    //bj.vlambda.vadd(n.mult(invMassj * deltalambda),bj.vlambda);
	
	    // Add to angular velocity
	    if(bi.wlambda){
	        var I = bi.invInertiaWorld;
	        bi.wlambda.vsub(I.vmult(axisA).mult(deltalambda),bi.wlambda);
	    }
	    if(bj.wlambda){
	        var I = bj.invInertiaWorld;
	        bj.wlambda.vadd(I.vmult(axisB).mult(deltalambda),bj.wlambda);
	    }
	};
	*/
	
	},{"../math/Mat3":24,"../math/Vec3":27,"./Equation":17}],21:[function(_dereq_,module,exports){
	var Utils = _dereq_('../utils/Utils');
	
	module.exports = ContactMaterial;
	
	/**
	 * Defines what happens when two materials meet.
	 * @class ContactMaterial
	 * @constructor
	 * @param {Material} m1
	 * @param {Material} m2
	 * @param {Number} friction
	 * @param {Number} restitution
	 */
	function ContactMaterial(m1, m2, options){
	    options = Utils.defaults(options, {
	        friction: 0.3,
	        restitution: 0.3,
	        contactEquationStiffness: 1e7,
	        contactEquationRelaxation: 3,
	        frictionEquationStiffness: 1e7,
	        frictionEquationRelaxation: 3
	    });
	
	    /**
	     * Identifier of this material
	     * @property {Number} id
	     */
	    this.id = ContactMaterial.idCounter++;
	
	    /**
	     * Participating materials
	     * @property {Array} materials
	     * @todo  Should be .materialA and .materialB instead
	     */
	    this.materials = [m1, m2];
	
	    /**
	     * Friction coefficient
	     * @property {Number} friction
	     */
	    this.friction = options.friction;
	
	    /**
	     * Restitution coefficient
	     * @property {Number} restitution
	     */
	    this.restitution = options.restitution;
	
	    /**
	     * Stiffness of the produced contact equations
	     * @property {Number} contactEquationStiffness
	     */
	    this.contactEquationStiffness = options.contactEquationStiffness;
	
	    /**
	     * Relaxation time of the produced contact equations
	     * @property {Number} contactEquationRelaxation
	     */
	    this.contactEquationRelaxation = options.contactEquationRelaxation;
	
	    /**
	     * Stiffness of the produced friction equations
	     * @property {Number} frictionEquationStiffness
	     */
	    this.frictionEquationStiffness = options.frictionEquationStiffness;
	
	    /**
	     * Relaxation time of the produced friction equations
	     * @property {Number} frictionEquationRelaxation
	     */
	    this.frictionEquationRelaxation = options.frictionEquationRelaxation;
	}
	
	ContactMaterial.idCounter = 0;
	
	},{"../utils/Utils":48}],22:[function(_dereq_,module,exports){
	module.exports = Material;
	
	/**
	 * Defines a physics material.
	 * @class Material
	 * @constructor
	 * @param {String} name
	 * @author schteppe
	 */
	function Material(name){
	    /**
	     * @property name
	     * @type {String}
	     */
	    this.name = name;
	    this.id = Material.idCounter++;
	}
	
	Material.idCounter = 0;
	
	},{}],23:[function(_dereq_,module,exports){
	module.exports = JacobianElement;
	
	var Vec3 = _dereq_('./Vec3');
	
	/**
	 * An element containing 6 entries, 3 spatial and 3 rotational degrees of freedom.
	 * @class JacobianElement
	 * @constructor
	 */
	function JacobianElement(){
	
	    /**
	     * @property {Vec3} spatial
	     */
	    this.spatial = new Vec3();
	
	    /**
	     * @property {Vec3} rotational
	     */
	    this.rotational = new Vec3();
	}
	
	/**
	 * Multiply with other JacobianElement
	 * @method multiplyElement
	 * @param  {JacobianElement} element
	 * @return {Number}
	 */
	JacobianElement.prototype.multiplyElement = function(element){
	    return element.spatial.dot(this.spatial) + element.rotational.dot(this.rotational);
	};
	
	/**
	 * Multiply with two vectors
	 * @method multiplyVectors
	 * @param  {Vec3} spatial
	 * @param  {Vec3} rotational
	 * @return {Number}
	 */
	JacobianElement.prototype.multiplyVectors = function(spatial,rotational){
	    return spatial.dot(this.spatial) + rotational.dot(this.rotational);
	};
	
	},{"./Vec3":27}],24:[function(_dereq_,module,exports){
	module.exports = Mat3;
	
	var Vec3 = _dereq_('./Vec3');
	
	/**
	 * A 3x3 matrix.
	 * @class Mat3
	 * @constructor
	 * @param array elements Array of nine elements. Optional.
	 * @author schteppe / http://github.com/schteppe
	 */
	function Mat3(elements){
	    /**
	     * A vector of length 9, containing all matrix elements
	     * @property {Array} elements
	     */
	    if(elements){
	        this.elements = elements;
	    } else {
	        this.elements = [0,0,0,0,0,0,0,0,0];
	    }
	}
	
	/**
	 * Sets the matrix to identity
	 * @method identity
	 * @todo Should perhaps be renamed to setIdentity() to be more clear.
	 * @todo Create another function that immediately creates an identity matrix eg. eye()
	 */
	Mat3.prototype.identity = function(){
	    this.elements[0] = 1;
	    this.elements[1] = 0;
	    this.elements[2] = 0;
	
	    this.elements[3] = 0;
	    this.elements[4] = 1;
	    this.elements[5] = 0;
	
	    this.elements[6] = 0;
	    this.elements[7] = 0;
	    this.elements[8] = 1;
	};
	
	/**
	 * Set all elements to zero
	 * @method setZero
	 */
	Mat3.prototype.setZero = function(){
	    var e = this.elements;
	    e[0] = 0;
	    e[1] = 0;
	    e[2] = 0;
	    e[3] = 0;
	    e[4] = 0;
	    e[5] = 0;
	    e[6] = 0;
	    e[7] = 0;
	    e[8] = 0;
	};
	
	/**
	 * Sets the matrix diagonal elements from a Vec3
	 * @method setTrace
	 */
	Mat3.prototype.setTrace = function(vec3){
	    var e = this.elements;
	    e[0] = vec3.x;
	    e[4] = vec3.y;
	    e[8] = vec3.z;
	};
	
	/**
	 * Sets the matrix diagonal elements from a Vec3
	 * @method setTrace
	 */
	Mat3.prototype.getTrace = function(target){
	    var target = target || new Vec3();
	    var e = this.elements;
	    target.x = e[0];
	    target.y = e[4];
	    target.z = e[8];
	};
	
	/**
	 * Matrix-Vector multiplication
	 * @method vmult
	 * @param {Vec3} v The vector to multiply with
	 * @param {Vec3} target Optional, target to save the result in.
	 */
	Mat3.prototype.vmult = function(v,target){
	    target = target || new Vec3();
	
	    var e = this.elements,
	        x = v.x,
	        y = v.y,
	        z = v.z;
	    target.x = e[0]*x + e[1]*y + e[2]*z;
	    target.y = e[3]*x + e[4]*y + e[5]*z;
	    target.z = e[6]*x + e[7]*y + e[8]*z;
	
	    return target;
	};
	
	/**
	 * Matrix-scalar multiplication
	 * @method smult
	 * @param {Number} s
	 */
	Mat3.prototype.smult = function(s){
	    for(var i=0; i<this.elements.length; i++){
	        this.elements[i] *= s;
	    }
	};
	
	/**
	 * Matrix multiplication
	 * @method mmult
	 * @param {Mat3} m Matrix to multiply with from left side.
	 * @return {Mat3} The result.
	 */
	Mat3.prototype.mmult = function(m,target){
	    var r = target || new Mat3();
	    for(var i=0; i<3; i++){
	        for(var j=0; j<3; j++){
	            var sum = 0.0;
	            for(var k=0; k<3; k++){
	                sum += m.elements[i+k*3] * this.elements[k+j*3];
	            }
	            r.elements[i+j*3] = sum;
	        }
	    }
	    return r;
	};
	
	/**
	 * Scale each column of the matrix
	 * @method scale
	 * @param {Vec3} v
	 * @return {Mat3} The result.
	 */
	Mat3.prototype.scale = function(v,target){
	    target = target || new Mat3();
	    var e = this.elements,
	        t = target.elements;
	    for(var i=0; i!==3; i++){
	        t[3*i + 0] = v.x * e[3*i + 0];
	        t[3*i + 1] = v.y * e[3*i + 1];
	        t[3*i + 2] = v.z * e[3*i + 2];
	    }
	    return target;
	};
	
	/**
	 * Solve Ax=b
	 * @method solve
	 * @param {Vec3} b The right hand side
	 * @param {Vec3} target Optional. Target vector to save in.
	 * @return {Vec3} The solution x
	 * @todo should reuse arrays
	 */
	Mat3.prototype.solve = function(b,target){
	    target = target || new Vec3();
	
	    // Construct equations
	    var nr = 3; // num rows
	    var nc = 4; // num cols
	    var eqns = [];
	    for(var i=0; i<nr*nc; i++){
	        eqns.push(0);
	    }
	    var i,j;
	    for(i=0; i<3; i++){
	        for(j=0; j<3; j++){
	            eqns[i+nc*j] = this.elements[i+3*j];
	        }
	    }
	    eqns[3+4*0] = b.x;
	    eqns[3+4*1] = b.y;
	    eqns[3+4*2] = b.z;
	
	    // Compute right upper triangular version of the matrix - Gauss elimination
	    var n = 3, k = n, np;
	    var kp = 4; // num rows
	    var p, els;
	    do {
	        i = k - n;
	        if (eqns[i+nc*i] === 0) {
	            // the pivot is null, swap lines
	            for (j = i + 1; j < k; j++) {
	                if (eqns[i+nc*j] !== 0) {
	                    np = kp;
	                    do {  // do ligne( i ) = ligne( i ) + ligne( k )
	                        p = kp - np;
	                        eqns[p+nc*i] += eqns[p+nc*j];
	                    } while (--np);
	                    break;
	                }
	            }
	        }
	        if (eqns[i+nc*i] !== 0) {
	            for (j = i + 1; j < k; j++) {
	                var multiplier = eqns[i+nc*j] / eqns[i+nc*i];
	                np = kp;
	                do {  // do ligne( k ) = ligne( k ) - multiplier * ligne( i )
	                    p = kp - np;
	                    eqns[p+nc*j] = p <= i ? 0 : eqns[p+nc*j] - eqns[p+nc*i] * multiplier ;
	                } while (--np);
	            }
	        }
	    } while (--n);
	
	    // Get the solution
	    target.z = eqns[2*nc+3] / eqns[2*nc+2];
	    target.y = (eqns[1*nc+3] - eqns[1*nc+2]*target.z) / eqns[1*nc+1];
	    target.x = (eqns[0*nc+3] - eqns[0*nc+2]*target.z - eqns[0*nc+1]*target.y) / eqns[0*nc+0];
	
	    if(isNaN(target.x) || isNaN(target.y) || isNaN(target.z) || target.x===Infinity || target.y===Infinity || target.z===Infinity){
	        throw "Could not solve equation! Got x=["+target.toString()+"], b=["+b.toString()+"], A=["+this.toString()+"]";
	    }
	
	    return target;
	};
	
	/**
	 * Get an element in the matrix by index. Index starts at 0, not 1!!!
	 * @method e
	 * @param {Number} row
	 * @param {Number} column
	 * @param {Number} value Optional. If provided, the matrix element will be set to this value.
	 * @return {Number}
	 */
	Mat3.prototype.e = function( row , column ,value){
	    if(value===undefined){
	        return this.elements[column+3*row];
	    } else {
	        // Set value
	        this.elements[column+3*row] = value;
	    }
	};
	
	/**
	 * Copy another matrix into this matrix object.
	 * @method copy
	 * @param {Mat3} source
	 * @return {Mat3} this
	 */
	Mat3.prototype.copy = function(source){
	    for(var i=0; i < source.elements.length; i++){
	        this.elements[i] = source.elements[i];
	    }
	    return this;
	};
	
	/**
	 * Returns a string representation of the matrix.
	 * @method toString
	 * @return string
	 */
	Mat3.prototype.toString = function(){
	    var r = "";
	    var sep = ",";
	    for(var i=0; i<9; i++){
	        r += this.elements[i] + sep;
	    }
	    return r;
	};
	
	/**
	 * reverse the matrix
	 * @method reverse
	 * @param {Mat3} target Optional. Target matrix to save in.
	 * @return {Mat3} The solution x
	 */
	Mat3.prototype.reverse = function(target){
	
	    target = target || new Mat3();
	
	    // Construct equations
	    var nr = 3; // num rows
	    var nc = 6; // num cols
	    var eqns = [];
	    for(var i=0; i<nr*nc; i++){
	        eqns.push(0);
	    }
	    var i,j;
	    for(i=0; i<3; i++){
	        for(j=0; j<3; j++){
	            eqns[i+nc*j] = this.elements[i+3*j];
	        }
	    }
	    eqns[3+6*0] = 1;
	    eqns[3+6*1] = 0;
	    eqns[3+6*2] = 0;
	    eqns[4+6*0] = 0;
	    eqns[4+6*1] = 1;
	    eqns[4+6*2] = 0;
	    eqns[5+6*0] = 0;
	    eqns[5+6*1] = 0;
	    eqns[5+6*2] = 1;
	
	    // Compute right upper triangular version of the matrix - Gauss elimination
	    var n = 3, k = n, np;
	    var kp = nc; // num rows
	    var p;
	    do {
	        i = k - n;
	        if (eqns[i+nc*i] === 0) {
	            // the pivot is null, swap lines
	            for (j = i + 1; j < k; j++) {
	                if (eqns[i+nc*j] !== 0) {
	                    np = kp;
	                    do { // do line( i ) = line( i ) + line( k )
	                        p = kp - np;
	                        eqns[p+nc*i] += eqns[p+nc*j];
	                    } while (--np);
	                    break;
	                }
	            }
	        }
	        if (eqns[i+nc*i] !== 0) {
	            for (j = i + 1; j < k; j++) {
	                var multiplier = eqns[i+nc*j] / eqns[i+nc*i];
	                np = kp;
	                do { // do line( k ) = line( k ) - multiplier * line( i )
	                    p = kp - np;
	                    eqns[p+nc*j] = p <= i ? 0 : eqns[p+nc*j] - eqns[p+nc*i] * multiplier ;
	                } while (--np);
	            }
	        }
	    } while (--n);
	
	    // eliminate the upper left triangle of the matrix
	    i = 2;
	    do {
	        j = i-1;
	        do {
	            var multiplier = eqns[i+nc*j] / eqns[i+nc*i];
	            np = nc;
	            do {
	                p = nc - np;
	                eqns[p+nc*j] =  eqns[p+nc*j] - eqns[p+nc*i] * multiplier ;
	            } while (--np);
	        } while (j--);
	    } while (--i);
	
	    // operations on the diagonal
	    i = 2;
	    do {
	        var multiplier = 1 / eqns[i+nc*i];
	        np = nc;
	        do {
	            p = nc - np;
	            eqns[p+nc*i] = eqns[p+nc*i] * multiplier ;
	        } while (--np);
	    } while (i--);
	
	    i = 2;
	    do {
	        j = 2;
	        do {
	            p = eqns[nr+j+nc*i];
	            if( isNaN( p ) || p ===Infinity ){
	                throw "Could not reverse! A=["+this.toString()+"]";
	            }
	            target.e( i , j , p );
	        } while (j--);
	    } while (i--);
	
	    return target;
	};
	
	/**
	 * Set the matrix from a quaterion
	 * @method setRotationFromQuaternion
	 * @param {Quaternion} q
	 */
	Mat3.prototype.setRotationFromQuaternion = function( q ) {
	    var x = q.x, y = q.y, z = q.z, w = q.w,
	        x2 = x + x, y2 = y + y, z2 = z + z,
	        xx = x * x2, xy = x * y2, xz = x * z2,
	        yy = y * y2, yz = y * z2, zz = z * z2,
	        wx = w * x2, wy = w * y2, wz = w * z2,
	        e = this.elements;
	
	    e[3*0 + 0] = 1 - ( yy + zz );
	    e[3*0 + 1] = xy - wz;
	    e[3*0 + 2] = xz + wy;
	
	    e[3*1 + 0] = xy + wz;
	    e[3*1 + 1] = 1 - ( xx + zz );
	    e[3*1 + 2] = yz - wx;
	
	    e[3*2 + 0] = xz - wy;
	    e[3*2 + 1] = yz + wx;
	    e[3*2 + 2] = 1 - ( xx + yy );
	
	    return this;
	};
	
	/**
	 * Transpose the matrix
	 * @method transpose
	 * @param  {Mat3} target Where to store the result.
	 * @return {Mat3} The target Mat3, or a new Mat3 if target was omitted.
	 */
	Mat3.prototype.transpose = function( target ) {
	    target = target || new Mat3();
	
	    var Mt = target.elements,
	        M = this.elements;
	
	    for(var i=0; i!==3; i++){
	        for(var j=0; j!==3; j++){
	            Mt[3*i + j] = M[3*j + i];
	        }
	    }
	
	    return target;
	};
	
	},{"./Vec3":27}],25:[function(_dereq_,module,exports){
	module.exports = Quaternion;
	
	var Vec3 = _dereq_('./Vec3');
	
	/**
	 * A Quaternion describes a rotation in 3D space. The Quaternion is mathematically defined as Q = x*i + y*j + z*k + w, where (i,j,k) are imaginary basis vectors. (x,y,z) can be seen as a vector related to the axis of rotation, while the real multiplier, w, is related to the amount of rotation.
	 * @class Quaternion
	 * @constructor
	 * @param {Number} x Multiplier of the imaginary basis vector i.
	 * @param {Number} y Multiplier of the imaginary basis vector j.
	 * @param {Number} z Multiplier of the imaginary basis vector k.
	 * @param {Number} w Multiplier of the real part.
	 * @see http://en.wikipedia.org/wiki/Quaternion
	 */
	function Quaternion(x,y,z,w){
	    /**
	     * @property {Number} x
	     */
	    this.x = x!==undefined ? x : 0;
	
	    /**
	     * @property {Number} y
	     */
	    this.y = y!==undefined ? y : 0;
	
	    /**
	     * @property {Number} z
	     */
	    this.z = z!==undefined ? z : 0;
	
	    /**
	     * The multiplier of the real quaternion basis vector.
	     * @property {Number} w
	     */
	    this.w = w!==undefined ? w : 1;
	}
	
	/**
	 * Set the value of the quaternion.
	 * @method set
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} z
	 * @param {Number} w
	 */
	Quaternion.prototype.set = function(x,y,z,w){
	    this.x = x;
	    this.y = y;
	    this.z = z;
	    this.w = w;
	};
	
	/**
	 * Convert to a readable format
	 * @method toString
	 * @return string
	 */
	Quaternion.prototype.toString = function(){
	    return this.x+","+this.y+","+this.z+","+this.w;
	};
	
	/**
	 * Convert to an Array
	 * @method toArray
	 * @return Array
	 */
	Quaternion.prototype.toArray = function(){
	    return [this.x, this.y, this.z, this.w];
	};
	
	/**
	 * Set the quaternion components given an axis and an angle.
	 * @method setFromAxisAngle
	 * @param {Vec3} axis
	 * @param {Number} angle in radians
	 */
	Quaternion.prototype.setFromAxisAngle = function(axis,angle){
	    var s = Math.sin(angle*0.5);
	    this.x = axis.x * s;
	    this.y = axis.y * s;
	    this.z = axis.z * s;
	    this.w = Math.cos(angle*0.5);
	};
	
	/**
	 * Converts the quaternion to axis/angle representation.
	 * @method setFromAxisAngle
	 * @param {Vec3} targetAxis Optional. A vector object to reuse for storing the axis.
	 * @return Array An array, first elemnt is the axis and the second is the angle in radians.
	 */
	Quaternion.prototype.toAxisAngle = function(targetAxis){
	    targetAxis = targetAxis || new Vec3();
	    this.normalize(); // if w>1 acos and sqrt will produce errors, this cant happen if quaternion is normalised
	    var angle = 2 * Math.acos(this.w);
	    var s = Math.sqrt(1-this.w*this.w); // assuming quaternion normalised then w is less than 1, so term always positive.
	    if (s < 0.001) { // test to avoid divide by zero, s is always positive due to sqrt
	        // if s close to zero then direction of axis not important
	        targetAxis.x = this.x; // if it is important that axis is normalised then replace with x=1; y=z=0;
	        targetAxis.y = this.y;
	        targetAxis.z = this.z;
	    } else {
	        targetAxis.x = this.x / s; // normalise axis
	        targetAxis.y = this.y / s;
	        targetAxis.z = this.z / s;
	    }
	    return [targetAxis,angle];
	};
	
	var sfv_t1 = new Vec3(),
	    sfv_t2 = new Vec3();
	
	/**
	 * Set the quaternion value given two vectors. The resulting rotation will be the needed rotation to rotate u to v.
	 * @method setFromVectors
	 * @param {Vec3} u
	 * @param {Vec3} v
	 */
	Quaternion.prototype.setFromVectors = function(u,v){
	    if(u.isAntiparallelTo(v)){
	        var t1 = sfv_t1;
	        var t2 = sfv_t2;
	
	        u.tangents(t1,t2);
	        this.setFromAxisAngle(t1,Math.PI);
	    } else {
	        var a = u.cross(v);
	        this.x = a.x;
	        this.y = a.y;
	        this.z = a.z;
	        this.w = Math.sqrt(Math.pow(u.norm(),2) * Math.pow(v.norm(),2)) + u.dot(v);
	        this.normalize();
	    }
	};
	
	/**
	 * Quaternion multiplication
	 * @method mult
	 * @param {Quaternion} q
	 * @param {Quaternion} target Optional.
	 * @return {Quaternion}
	 */
	var Quaternion_mult_va = new Vec3();
	var Quaternion_mult_vb = new Vec3();
	var Quaternion_mult_vaxvb = new Vec3();
	Quaternion.prototype.mult = function(q,target){
	    target = target || new Quaternion();
	    var w = this.w,
	        va = Quaternion_mult_va,
	        vb = Quaternion_mult_vb,
	        vaxvb = Quaternion_mult_vaxvb;
	
	    va.set(this.x,this.y,this.z);
	    vb.set(q.x,q.y,q.z);
	    target.w = w*q.w - va.dot(vb);
	    va.cross(vb,vaxvb);
	
	    target.x = w * vb.x + q.w*va.x + vaxvb.x;
	    target.y = w * vb.y + q.w*va.y + vaxvb.y;
	    target.z = w * vb.z + q.w*va.z + vaxvb.z;
	
	    return target;
	};
	
	/**
	 * Get the inverse quaternion rotation.
	 * @method inverse
	 * @param {Quaternion} target
	 * @return {Quaternion}
	 */
	Quaternion.prototype.inverse = function(target){
	    var x = this.x, y = this.y, z = this.z, w = this.w;
	    target = target || new Quaternion();
	
	    this.conjugate(target);
	    var inorm2 = 1/(x*x + y*y + z*z + w*w);
	    target.x *= inorm2;
	    target.y *= inorm2;
	    target.z *= inorm2;
	    target.w *= inorm2;
	
	    return target;
	};
	
	/**
	 * Get the quaternion conjugate
	 * @method conjugate
	 * @param {Quaternion} target
	 * @return {Quaternion}
	 */
	Quaternion.prototype.conjugate = function(target){
	    target = target || new Quaternion();
	
	    target.x = -this.x;
	    target.y = -this.y;
	    target.z = -this.z;
	    target.w = this.w;
	
	    return target;
	};
	
	/**
	 * Normalize the quaternion. Note that this changes the values of the quaternion.
	 * @method normalize
	 */
	Quaternion.prototype.normalize = function(){
	    var l = Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);
	    if ( l === 0 ) {
	        this.x = 0;
	        this.y = 0;
	        this.z = 0;
	        this.w = 0;
	    } else {
	        l = 1 / l;
	        this.x *= l;
	        this.y *= l;
	        this.z *= l;
	        this.w *= l;
	    }
	};
	
	/**
	 * Approximation of quaternion normalization. Works best when quat is already almost-normalized.
	 * @method normalizeFast
	 * @see http://jsperf.com/fast-quaternion-normalization
	 * @author unphased, https://github.com/unphased
	 */
	Quaternion.prototype.normalizeFast = function () {
	    var f = (3.0-(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w))/2.0;
	    if ( f === 0 ) {
	        this.x = 0;
	        this.y = 0;
	        this.z = 0;
	        this.w = 0;
	    } else {
	        this.x *= f;
	        this.y *= f;
	        this.z *= f;
	        this.w *= f;
	    }
	};
	
	/**
	 * Multiply the quaternion by a vector
	 * @method vmult
	 * @param {Vec3} v
	 * @param {Vec3} target Optional
	 * @return {Vec3}
	 */
	Quaternion.prototype.vmult = function(v,target){
	    target = target || new Vec3();
	
	    var x = v.x,
	        y = v.y,
	        z = v.z;
	
	    var qx = this.x,
	        qy = this.y,
	        qz = this.z,
	        qw = this.w;
	
	    // q*v
	    var ix =  qw * x + qy * z - qz * y,
	    iy =  qw * y + qz * x - qx * z,
	    iz =  qw * z + qx * y - qy * x,
	    iw = -qx * x - qy * y - qz * z;
	
	    target.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
	    target.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
	    target.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
	
	    return target;
	};
	
	/**
	 * Copies value of source to this quaternion.
	 * @method copy
	 * @param {Quaternion} source
	 * @return {Quaternion} this
	 */
	Quaternion.prototype.copy = function(source){
	    this.x = source.x;
	    this.y = source.y;
	    this.z = source.z;
	    this.w = source.w;
	    return this;
	};
	
	/**
	 * Convert the quaternion to euler angle representation. Order: YZX, as this page describes: http://www.euclideanspace.com/maths/standards/index.htm
	 * @method toEuler
	 * @param {Vec3} target
	 * @param string order Three-character string e.g. "YZX", which also is default.
	 */
	Quaternion.prototype.toEuler = function(target,order){
	    order = order || "YZX";
	
	    var heading, attitude, bank;
	    var x = this.x, y = this.y, z = this.z, w = this.w;
	
	    switch(order){
	    case "YZX":
	        var test = x*y + z*w;
	        if (test > 0.499) { // singularity at north pole
	            heading = 2 * Math.atan2(x,w);
	            attitude = Math.PI/2;
	            bank = 0;
	        }
	        if (test < -0.499) { // singularity at south pole
	            heading = -2 * Math.atan2(x,w);
	            attitude = - Math.PI/2;
	            bank = 0;
	        }
	        if(isNaN(heading)){
	            var sqx = x*x;
	            var sqy = y*y;
	            var sqz = z*z;
	            heading = Math.atan2(2*y*w - 2*x*z , 1 - 2*sqy - 2*sqz); // Heading
	            attitude = Math.asin(2*test); // attitude
	            bank = Math.atan2(2*x*w - 2*y*z , 1 - 2*sqx - 2*sqz); // bank
	        }
	        break;
	    default:
	        throw new Error("Euler order "+order+" not supported yet.");
	    }
	
	    target.y = heading;
	    target.z = attitude;
	    target.x = bank;
	};
	
	/**
	 * See http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m
	 * @method setFromEuler
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} z
	 * @param {String} order The order to apply angles: 'XYZ' or 'YXZ' or any other combination
	 */
	Quaternion.prototype.setFromEuler = function ( x, y, z, order ) {
	    order = order || "XYZ";
	
	    var c1 = Math.cos( x / 2 );
	    var c2 = Math.cos( y / 2 );
	    var c3 = Math.cos( z / 2 );
	    var s1 = Math.sin( x / 2 );
	    var s2 = Math.sin( y / 2 );
	    var s3 = Math.sin( z / 2 );
	
	    if ( order === 'XYZ' ) {
	
	        this.x = s1 * c2 * c3 + c1 * s2 * s3;
	        this.y = c1 * s2 * c3 - s1 * c2 * s3;
	        this.z = c1 * c2 * s3 + s1 * s2 * c3;
	        this.w = c1 * c2 * c3 - s1 * s2 * s3;
	
	    } else if ( order === 'YXZ' ) {
	
	        this.x = s1 * c2 * c3 + c1 * s2 * s3;
	        this.y = c1 * s2 * c3 - s1 * c2 * s3;
	        this.z = c1 * c2 * s3 - s1 * s2 * c3;
	        this.w = c1 * c2 * c3 + s1 * s2 * s3;
	
	    } else if ( order === 'ZXY' ) {
	
	        this.x = s1 * c2 * c3 - c1 * s2 * s3;
	        this.y = c1 * s2 * c3 + s1 * c2 * s3;
	        this.z = c1 * c2 * s3 + s1 * s2 * c3;
	        this.w = c1 * c2 * c3 - s1 * s2 * s3;
	
	    } else if ( order === 'ZYX' ) {
	
	        this.x = s1 * c2 * c3 - c1 * s2 * s3;
	        this.y = c1 * s2 * c3 + s1 * c2 * s3;
	        this.z = c1 * c2 * s3 - s1 * s2 * c3;
	        this.w = c1 * c2 * c3 + s1 * s2 * s3;
	
	    } else if ( order === 'YZX' ) {
	
	        this.x = s1 * c2 * c3 + c1 * s2 * s3;
	        this.y = c1 * s2 * c3 + s1 * c2 * s3;
	        this.z = c1 * c2 * s3 - s1 * s2 * c3;
	        this.w = c1 * c2 * c3 - s1 * s2 * s3;
	
	    } else if ( order === 'XZY' ) {
	
	        this.x = s1 * c2 * c3 - c1 * s2 * s3;
	        this.y = c1 * s2 * c3 - s1 * c2 * s3;
	        this.z = c1 * c2 * s3 + s1 * s2 * c3;
	        this.w = c1 * c2 * c3 + s1 * s2 * s3;
	
	    }
	
	    return this;
	
	};
	
	Quaternion.prototype.clone = function(){
	    return new Quaternion(this.x, this.y, this.z, this.w);
	};
	},{"./Vec3":27}],26:[function(_dereq_,module,exports){
	var Vec3 = _dereq_('./Vec3');
	var Quaternion = _dereq_('./Quaternion');
	
	module.exports = Transform;
	
	function Transform() {
		this.position = new Vec3();
		this.quaternion = new Quaternion();
	}
	
	var tmpQuat = new Quaternion();
	Transform.pointToLocalFrame = function(position, quaternion, worldPoint, result){
	    var result = result || new Vec3();
	    worldPoint.vsub(position, result);
	    quaternion.conjugate(tmpQuat);
	    tmpQuat.vmult(result, result);
	    return result;
	};
	
	Transform.pointToWorldFrame = function(position, quaternion, localPoint, result){
	    var result = result || new Vec3();
	    quaternion.vmult(localPoint, result);
	    result.vadd(position, result);
	    return result;
	};
	
	Transform.prototype.vectorToWorldFrame = function(localVector, result){
	    var result = result || new Vec3();
	    this.quaternion.vmult(localVector, result);
	    return result;
	};
	
	Transform.vectorToLocalFrame = function(position, quaternion, worldVector, result){
	    var result = result || new Vec3();
	    quaternion.w *= -1;
	    quaternion.vmult(worldVector, result);
	    quaternion.w *= -1;
	    return result;
	};
	
	},{"./Quaternion":25,"./Vec3":27}],27:[function(_dereq_,module,exports){
	module.exports = Vec3;
	
	var Mat3 = _dereq_('./Mat3');
	
	/**
	 * 3-dimensional vector
	 * @class Vec3
	 * @constructor
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} z
	 * @author schteppe
	 * @example
	 *     var v = new Vec3(1, 2, 3);
	 *     console.log('x=' + v.x); // x=1
	 */
	function Vec3(x,y,z){
	    /**
	     * @property x
	     * @type {Number}
	     */
	    this.x = x||0.0;
	
	    /**
	     * @property y
	     * @type {Number}
	     */
	    this.y = y||0.0;
	
	    /**
	     * @property z
	     * @type {Number}
	     */
	    this.z = z||0.0;
	}
	
	Vec3.ZERO = new Vec3(0, 0, 0);
	
	/**
	 * Vector cross product
	 * @method cross
	 * @param {Vec3} v
	 * @param {Vec3} target Optional. Target to save in.
	 * @return {Vec3}
	 */
	Vec3.prototype.cross = function(v,target){
	    var vx=v.x, vy=v.y, vz=v.z, x=this.x, y=this.y, z=this.z;
	    target = target || new Vec3();
	
	    target.x = (y * vz) - (z * vy);
	    target.y = (z * vx) - (x * vz);
	    target.z = (x * vy) - (y * vx);
	
	    return target;
	};
	
	/**
	 * Set the vectors' 3 elements
	 * @method set
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} z
	 * @return Vec3
	 */
	Vec3.prototype.set = function(x,y,z){
	    this.x = x;
	    this.y = y;
	    this.z = z;
	    return this;
	};
	
	/**
	 * Set all components of the vector to zero.
	 * @method setZero
	 */
	Vec3.prototype.setZero = function(){
	    this.x = this.y = this.z = 0;
	};
	
	/**
	 * Vector addition
	 * @method vadd
	 * @param {Vec3} v
	 * @param {Vec3} target Optional.
	 * @return {Vec3}
	 */
	Vec3.prototype.vadd = function(v,target){
	    if(target){
	        target.x = v.x + this.x;
	        target.y = v.y + this.y;
	        target.z = v.z + this.z;
	    } else {
	        return new Vec3(this.x + v.x,
	                               this.y + v.y,
	                               this.z + v.z);
	    }
	};
	
	/**
	 * Vector subtraction
	 * @method vsub
	 * @param {Vec3} v
	 * @param {Vec3} target Optional. Target to save in.
	 * @return {Vec3}
	 */
	Vec3.prototype.vsub = function(v,target){
	    if(target){
	        target.x = this.x - v.x;
	        target.y = this.y - v.y;
	        target.z = this.z - v.z;
	    } else {
	        return new Vec3(this.x-v.x,
	                               this.y-v.y,
	                               this.z-v.z);
	    }
	};
	
	/**
	 * Get the cross product matrix a_cross from a vector, such that a x b = a_cross * b = c
	 * @method crossmat
	 * @see http://www8.cs.umu.se/kurser/TDBD24/VT06/lectures/Lecture6.pdf
	 * @return {Mat3}
	 */
	Vec3.prototype.crossmat = function(){
	    return new Mat3([     0,  -this.z,   this.y,
	                            this.z,        0,  -this.x,
	                           -this.y,   this.x,        0]);
	};
	
	/**
	 * Normalize the vector. Note that this changes the values in the vector.
	 * @method normalize
	 * @return {Number} Returns the norm of the vector
	 */
	Vec3.prototype.normalize = function(){
	    var x=this.x, y=this.y, z=this.z;
	    var n = Math.sqrt(x*x + y*y + z*z);
	    if(n>0.0){
	        var invN = 1/n;
	        this.x *= invN;
	        this.y *= invN;
	        this.z *= invN;
	    } else {
	        // Make something up
	        this.x = 0;
	        this.y = 0;
	        this.z = 0;
	    }
	    return n;
	};
	
	/**
	 * Get the version of this vector that is of length 1.
	 * @method unit
	 * @param {Vec3} target Optional target to save in
	 * @return {Vec3} Returns the unit vector
	 */
	Vec3.prototype.unit = function(target){
	    target = target || new Vec3();
	    var x=this.x, y=this.y, z=this.z;
	    var ninv = Math.sqrt(x*x + y*y + z*z);
	    if(ninv>0.0){
	        ninv = 1.0/ninv;
	        target.x = x * ninv;
	        target.y = y * ninv;
	        target.z = z * ninv;
	    } else {
	        target.x = 1;
	        target.y = 0;
	        target.z = 0;
	    }
	    return target;
	};
	
	/**
	 * Get the 2-norm (length) of the vector
	 * @method norm
	 * @return {Number}
	 */
	Vec3.prototype.norm = function(){
	    var x=this.x, y=this.y, z=this.z;
	    return Math.sqrt(x*x + y*y + z*z);
	};
	
	/**
	 * Get the squared length of the vector
	 * @method norm2
	 * @return {Number}
	 */
	Vec3.prototype.norm2 = function(){
	    return this.dot(this);
	};
	
	/**
	 * Get distance from this point to another point
	 * @method distanceTo
	 * @param  {Vec3} p
	 * @return {Number}
	 */
	Vec3.prototype.distanceTo = function(p){
	    var x=this.x, y=this.y, z=this.z;
	    var px=p.x, py=p.y, pz=p.z;
	    return Math.sqrt((px-x)*(px-x)+
	                     (py-y)*(py-y)+
	                     (pz-z)*(pz-z));
	};
	
	/**
	 * Multiply the vector with a scalar
	 * @deprecated Use .scale instead
	 * @method mult
	 * @param {Number} scalar
	 * @param {Vec3} target
	 * @return {Vec3}
	 */
	Vec3.prototype.mult = function(scalar,target){
	    target = target || new Vec3();
	    var x = this.x,
	        y = this.y,
	        z = this.z;
	    target.x = scalar * x;
	    target.y = scalar * y;
	    target.z = scalar * z;
	    return target;
	};
	
	/**
	 * Multiply the vector with a scalar.
	 * @method scale
	 * @param {Number} scalar
	 * @param {Vec3} target
	 * @return {Vec3}
	 */
	Vec3.prototype.scale = Vec3.prototype.mult;
	
	/**
	 * Calculate dot product
	 * @method dot
	 * @param {Vec3} v
	 * @return {Number}
	 */
	Vec3.prototype.dot = function(v){
	    return this.x * v.x + this.y * v.y + this.z * v.z;
	};
	
	/**
	 * @method isZero
	 * @return bool
	 */
	Vec3.prototype.isZero = function(){
	    return this.x===0 && this.y===0 && this.z===0;
	};
	
	/**
	 * Make the vector point in the opposite direction.
	 * @method negate
	 * @param {Vec3} target Optional target to save in
	 * @return {Vec3}
	 */
	Vec3.prototype.negate = function(target){
	    target = target || new Vec3();
	    target.x = -this.x;
	    target.y = -this.y;
	    target.z = -this.z;
	    return target;
	};
	
	/**
	 * Compute two artificial tangents to the vector
	 * @method tangents
	 * @param {Vec3} t1 Vector object to save the first tangent in
	 * @param {Vec3} t2 Vector object to save the second tangent in
	 */
	var Vec3_tangents_n = new Vec3();
	var Vec3_tangents_randVec = new Vec3();
	Vec3.prototype.tangents = function(t1,t2){
	    var norm = this.norm();
	    if(norm>0.0){
	        var n = Vec3_tangents_n;
	        var inorm = 1/norm;
	        n.set(this.x*inorm,this.y*inorm,this.z*inorm);
	        var randVec = Vec3_tangents_randVec;
	        if(Math.abs(n.x) < 0.9){
	            randVec.set(1,0,0);
	            n.cross(randVec,t1);
	        } else {
	            randVec.set(0,1,0);
	            n.cross(randVec,t1);
	        }
	        n.cross(t1,t2);
	    } else {
	        // The normal length is zero, make something up
	        t1.set(1,0,0).normalize();
	        t2.set(0,1,0).normalize();
	    }
	};
	
	/**
	 * Converts to a more readable format
	 * @method toString
	 * @return string
	 */
	Vec3.prototype.toString = function(){
	    return this.x+","+this.y+","+this.z;
	};
	
	/**
	 * Converts to an array
	 * @method toArray
	 * @return Array
	 */
	Vec3.prototype.toArray = function(){
	    return [this.x, this.y, this.z];
	};
	
	/**
	 * Copies value of source to this vector.
	 * @method copy
	 * @param {Vec3} source
	 * @return {Vec3} this
	 */
	Vec3.prototype.copy = function(source){
	    this.x = source.x;
	    this.y = source.y;
	    this.z = source.z;
	    return this;
	};
	
	
	/**
	 * Do a linear interpolation between two vectors
	 * @method lerp
	 * @param {Vec3} v
	 * @param {Number} t A number between 0 and 1. 0 will make this function return u, and 1 will make it return v. Numbers in between will generate a vector in between them.
	 * @param {Vec3} target
	 */
	Vec3.prototype.lerp = function(v,t,target){
	    var x=this.x, y=this.y, z=this.z;
	    target.x = x + (v.x-x)*t;
	    target.y = y + (v.y-y)*t;
	    target.z = z + (v.z-z)*t;
	};
	
	/**
	 * Check if a vector equals is almost equal to another one.
	 * @method almostEquals
	 * @param {Vec3} v
	 * @param {Number} precision
	 * @return bool
	 */
	Vec3.prototype.almostEquals = function(v,precision){
	    if(precision===undefined){
	        precision = 1e-6;
	    }
	    if( Math.abs(this.x-v.x)>precision ||
	        Math.abs(this.y-v.y)>precision ||
	        Math.abs(this.z-v.z)>precision){
	        return false;
	    }
	    return true;
	};
	
	/**
	 * Check if a vector is almost zero
	 * @method almostZero
	 * @param {Number} precision
	 */
	Vec3.prototype.almostZero = function(precision){
	    if(precision===undefined){
	        precision = 1e-6;
	    }
	    if( Math.abs(this.x)>precision ||
	        Math.abs(this.y)>precision ||
	        Math.abs(this.z)>precision){
	        return false;
	    }
	    return true;
	};
	
	var antip_neg = new Vec3();
	
	/**
	 * Check if the vector is anti-parallel to another vector.
	 * @method isAntiparallelTo
	 * @param  {Vec3}  v
	 * @param  {Number}  precision Set to zero for exact comparisons
	 * @return {Boolean}
	 */
	Vec3.prototype.isAntiparallelTo = function(v,precision){
	    this.negate(antip_neg);
	    return antip_neg.almostEquals(v,precision);
	};
	
	/**
	 * Clone the vector
	 * @method clone
	 * @return {Vec3}
	 */
	Vec3.prototype.clone = function(){
	    return new Vec3(this.x, this.y, this.z);
	};
	},{"./Mat3":24}],28:[function(_dereq_,module,exports){
	module.exports = Body;
	
	var EventTarget = _dereq_('../utils/EventTarget');
	var Shape = _dereq_('../shapes/Shape');
	var Vec3 = _dereq_('../math/Vec3');
	var Mat3 = _dereq_('../math/Mat3');
	var Quaternion = _dereq_('../math/Quaternion');
	var Material = _dereq_('../material/Material');
	var AABB = _dereq_('../collision/AABB');
	var Box = _dereq_('../shapes/Box');
	
	/**
	 * Base class for all body types.
	 * @class Body
	 * @constructor
	 * @extends EventTarget
	 * @param {object} [options]
	 * @param {Vec3} [options.position]
	 * @param {number} [options.mass]
	 * @param {number} [options.type]
	 * @param {number} [options.linearDamping]
	 * @example
	 *     var body = new Body({
	 *         mass: 1
	 *     });
	 *     var shape = new Sphere(1);
	 *     body.addShape(shape);
	 *     world.add(body);
	 */
	function Body(options){
	    options = options || {};
	
	    EventTarget.apply(this);
	
	    this.id = Body.idCounter++;
	
	    /**
	     * Reference to the world the body is living in
	     * @property world
	     * @type {World}
	     */
	    this.world = null;
	
	    /**
	     * Callback function that is used BEFORE stepping the system. Use it to apply forces, for example. Inside the function, "this" will refer to this Body object.
	     * @property preStep
	     * @type {Function}
	     * @deprecated Use World events instead
	     */
	    this.preStep = null;
	
	    /**
	     * Callback function that is used AFTER stepping the system. Inside the function, "this" will refer to this Body object.
	     * @property postStep
	     * @type {Function}
	     * @deprecated Use World events instead
	     */
	    this.postStep = null;
	
	    this.vlambda = new Vec3();
	
	    /**
	     * @property {Number} collisionFilterGroup
	     */
	    this.collisionFilterGroup = 1;
	
	    /**
	     * @property {Number} collisionFilterMask
	     */
	    this.collisionFilterMask = 1;
	
	    /**
	     * Whether to produce contact forces
	     * @property {Number} collisionResponse
	     */
		this.collisionResponse = true;
	
	    /**
	     * @property position
	     * @type {Vec3}
	     */
	    this.position = new Vec3();
	
	    if(options.position){
	        this.position.copy(options.position);
	    }
	
	    /**
	     * @property {Vec3} previousPosition
	     */
	    this.previousPosition = new Vec3();
	
	    /**
	     * Initial position of the body
	     * @property initPosition
	     * @type {Vec3}
	     */
	    this.initPosition = new Vec3();
	
	    /**
	     * @property velocity
	     * @type {Vec3}
	     */
	    this.velocity = new Vec3();
	
	    /**
	     * @property initVelocity
	     * @type {Vec3}
	     */
	    this.initVelocity = new Vec3();
	
	    /**
	     * Linear force on the body
	     * @property force
	     * @type {Vec3}
	     */
	    this.force = new Vec3();
	
	    var mass = typeof(options.mass) === 'number' ? options.mass : 0;
	
	    /**
	     * @property mass
	     * @type {Number}
	     */
	    this.mass = mass;
	
	    /**
	     * @property invMass
	     * @type {Number}
	     */
	    this.invMass = mass > 0 ? 1.0 / mass : 0;
	
	    /**
	     * @property material
	     * @type {Material}
	     */
	    this.material = options.material || null;
	
	    /**
	     * @property float linearDamping
	     * @type {Number}
	     */
	    this.linearDamping = typeof(options.linearDamping) === 'number' ? options.linearDamping : 0.01;
	
	    /**
	     * One of the states Body.DYNAMIC, Body.STATIC and Body.KINEMATIC
	     * @property type
	     * @type {Number}
	     */
	    this.type = (mass <= 0.0 ? Body.STATIC : Body.DYNAMIC);
	    if(typeof(options.type) === typeof(Body.STATIC)){
	        this.type = options.type;
	    }
	
	    /**
	     * If true, the body will automatically fall to sleep.
	     * @property allowSleep
	     * @type {Boolean}
	     */
	    this.allowSleep = true;
	
	    /**
	     * Current sleep state.
	     * @property sleepState
	     * @type {Number}
	     */
	    this.sleepState = 0;
	
	    /**
	     * If the speed (the norm of the velocity) is smaller than this value, the body is considered sleepy.
	     * @property sleepSpeedLimit
	     * @type {Number}
	     */
	    this.sleepSpeedLimit = 0.1;
	
	    /**
	     * If the body has been sleepy for this sleepTimeLimit seconds, it is considered sleeping.
	     * @property sleepTimeLimit
	     * @type {Number}
	     */
	    this.sleepTimeLimit = 1;
	
	    this.timeLastSleepy = 0;
	
	    this._wakeUpAfterNarrowphase = false;
	
	
	    /**
	     * Rotational force on the body, around center of mass
	     * @property Vec3 tau
	     * @todo should be renamed to .angularForce
	     */
	    this.tau = new Vec3();
	
	    /**
	     * Orientation of the body
	     * @property quaternion
	     * @type {Quaternion}
	     */
	    this.quaternion = new Quaternion();
	
	    /**
	     * @property initQuaternion
	     * @type {Quaternion}
	     */
	    this.initQuaternion = new Quaternion();
	
	    /**
	     * @property angularVelocity
	     * @type {Vec3}
	     */
	    this.angularVelocity = new Vec3();
	
	    /**
	     * @property initAngularVelocity
	     * @type {Vec3}
	     */
	    this.initAngularVelocity = new Vec3();
	
	    this.interpolatedPosition = new Vec3();
	    this.interpolatedQuaternion = new Quaternion();
	
	    /**
	     * @property shapes
	     * @type {array}
	     */
	    this.shapes = [];
	
	    /**
	     * @property shapeOffsets
	     * @type {array}
	     */
	    this.shapeOffsets = [];
	
	    /**
	     * @property shapeOrientations
	     * @type {array}
	     */
	    this.shapeOrientations = [];
	
	    /**
	     * @property inertia
	     * @type {Vec3}
	     */
	    this.inertia = new Vec3();
	
	    /**
	     * @property {Vec3} invInertia
	     */
	    this.invInertia = new Vec3();
	
	    /**
	     * @property {Mat3} invInertiaWorld
	     */
	    this.invInertiaWorld = new Mat3();
	
	    this.invMassSolve = 0;
	
	    /**
	     * @property {Vec3} invInertiaSolve
	     */
	    this.invInertiaSolve = new Vec3();
	
	    /**
	     * @property {Mat3} invInertiaWorldSolve
	     */
	    this.invInertiaWorldSolve = new Mat3();
	
	    /**
	     * Set to true if you don't want the body to rotate. Make sure to run .updateMassProperties() after changing this.
	     * @property {Boolean} fixedRotation
	     */
	    this.fixedRotation = false;
	
	    /**
	     * @property {Number} angularDamping
	     */
	    this.angularDamping = 0.01; // Perhaps default should be zero here?
	
	    /**
	     * @property aabb
	     * @type {Vec3}
	     */
	    this.aabb = new AABB();
	
	    /**
	     * Indicates if the AABB needs to be updated before use.
	     * @property aabbNeedsUpdate
	     * @type {Boolean}
	     */
	    this.aabbNeedsUpdate = true;
	
	    this.wlambda = new Vec3();
	
	    this.updateMassProperties();
	}
	Body.prototype = new EventTarget();
	Body.prototype.constructor = Body;
	
	/**
	 * A dynamic body is fully simulated. Can be moved manually by the user, but normally they move according to forces. A dynamic body can collide with all body types. A dynamic body always has finite, non-zero mass.
	 * @static
	 * @property DYNAMIC
	 * @type {Number}
	 */
	Body.DYNAMIC = 1;
	
	/**
	 * A static body does not move during simulation and behaves as if it has infinite mass. Static bodies can be moved manually by setting the position of the body. The velocity of a static body is always zero. Static bodies do not collide with other static or kinematic bodies.
	 * @static
	 * @property DYNAMIC
	 * @type {Number}
	 */
	Body.STATIC = 2;
	
	/**
	 * A kinematic body moves under simulation according to its velocity. They do not respond to forces. They can be moved manually, but normally a kinematic body is moved by setting its velocity. A kinematic body behaves as if it has infinite mass. Kinematic bodies do not collide with other static or kinematic bodies.
	 * @static
	 * @property DYNAMIC
	 * @type {Number}
	 */
	Body.KINEMATIC = 4;
	
	
	
	/**
	 * @static
	 * @property AWAKE
	 * @type {number}
	 */
	Body.AWAKE = 0;
	
	/**
	 * @static
	 * @property SLEEPY
	 * @type {number}
	 */
	Body.SLEEPY = 1;
	
	/**
	 * @static
	 * @property SLEEPING
	 * @type {number}
	 */
	Body.SLEEPING = 2;
	
	Body.idCounter = 0;
	
	/**
	 * Wake the body up.
	 * @method wakeUp
	 */
	Body.prototype.wakeUp = function(){
	    var s = this.sleepState;
	    this.sleepState = 0;
	    if(s === Body.SLEEPING){
	        this.dispatchEvent({type:"wakeup"});
	    }
	};
	
	/**
	 * Force body sleep
	 * @method sleep
	 */
	Body.prototype.sleep = function(){
	    this.sleepState = Body.SLEEPING;
	    this.velocity.set(0,0,0);
	    this.angularVelocity.set(0,0,0);
	};
	
	Body.sleepyEvent = {
	    type: "sleepy"
	};
	
	Body.sleepEvent = {
	    type: "sleep"
	};
	
	/**
	 * Called every timestep to update internal sleep timer and change sleep state if needed.
	 * @method sleepTick
	 * @param {Number} time The world time in seconds
	 */
	Body.prototype.sleepTick = function(time){
	    if(this.allowSleep){
	        var sleepState = this.sleepState;
	        var speedSquared = this.velocity.norm2() + this.angularVelocity.norm2();
	        var speedLimitSquared = Math.pow(this.sleepSpeedLimit,2);
	        if(sleepState===Body.AWAKE && speedSquared < speedLimitSquared){
	            this.sleepState = Body.SLEEPY; // Sleepy
	            this.timeLastSleepy = time;
	            this.dispatchEvent(Body.sleepyEvent);
	        } else if(sleepState===Body.SLEEPY && speedSquared > speedLimitSquared){
	            this.wakeUp(); // Wake up
	        } else if(sleepState===Body.SLEEPY && (time - this.timeLastSleepy ) > this.sleepTimeLimit){
	            this.sleep(); // Sleeping
	            this.dispatchEvent(Body.sleepEvent);
	        }
	    }
	};
	
	/**
	 * If the body is sleeping, it should be immovable / have infinite mass during solve. We solve it by having a separate "solve mass".
	 * @method updateSolveMassProperties
	 */
	Body.prototype.updateSolveMassProperties = function(){
	    if(this.sleepState === Body.SLEEPING || this.type === Body.KINEMATIC){
	        this.invMassSolve = 0;
	        this.invInertiaSolve.setZero();
	        this.invInertiaWorldSolve.setZero();
	    } else {
	        this.invMassSolve = this.invMass;
	        this.invInertiaSolve.copy(this.invInertia);
	        this.invInertiaWorldSolve.copy(this.invInertiaWorld);
	    }
	};
	
	/**
	 * Convert a world point to local body frame.
	 * @method pointToLocalFrame
	 * @param  {Vec3} worldPoint
	 * @param  {Vec3} result
	 * @return {Vec3}
	 */
	Body.prototype.pointToLocalFrame = function(worldPoint,result){
	    var result = result || new Vec3();
	    worldPoint.vsub(this.position,result);
	    this.quaternion.conjugate().vmult(result,result);
	    return result;
	};
	
	/**
	 * Convert a local body point to world frame.
	 * @method pointToWorldFrame
	 * @param  {Vec3} worldPoint
	 * @param  {Vec3} result
	 * @return {Vec3}
	 */
	Body.prototype.pointToWorldFrame = function(localPoint,result){
	    var result = result || new Vec3();
	    this.quaternion.vmult(localPoint,result);
	    result.vadd(this.position,result);
	    return result;
	};
	
	/**
	 * Convert a local body point to world frame.
	 * @method pointToWorldFrame
	 * @param  {Vec3} worldPoint
	 * @param  {Vec3} result
	 * @return {Vec3}
	 */
	Body.prototype.vectorToWorldFrame = function(localVector, result){
	    var result = result || new Vec3();
	    this.quaternion.vmult(localVector, result);
	    return result;
	};
	
	var tmpVec = new Vec3();
	var tmpQuat = new Quaternion();
	
	
	Body.prototype.addShape = function(shape, _offset, _orientation){
	    var offset = new Vec3();
	    var orientation = new Quaternion();
	
	    if(_offset){
	        offset.copy(_offset);
	    }
	    if(_orientation){
	        orientation.copy(_orientation);
	    }
	
	    this.shapes.push(shape);
	    this.shapeOffsets.push(offset);
	    this.shapeOrientations.push(orientation);
	    this.updateMassProperties();
	    this.updateBoundingRadius();
	
	    this.aabbNeedsUpdate = true;
	};
	
	/**
	 * Update the bounding radius of the body. Should be done if any of the shapes are changed.
	 * @method updateBoundingRadius
	 */
	Body.prototype.updateBoundingRadius = function(){
	    var shapes = this.shapes,
	        shapeOffsets = this.shapeOffsets,
	        N = shapes.length,
	        radius = 0;
	
	    for(var i=0; i!==N; i++){
	        var shape = shapes[i];
	        shape.updateBoundingSphereRadius();
	        var offset = shapeOffsets[i].norm(),
	            r = shape.boundingSphereRadius;
	        if(offset + r > radius){
	            radius = offset + r;
	        }
	    }
	
	    this.boundingRadius = radius;
	};
	
	/**
	 * Updates the .aabb
	 * @method computeAABB
	 * @todo rename to updateAABB()
	 */
	Body.prototype.computeAABB = function(){
	    var shapes = this.shapes,
	        shapeOffsets = this.shapeOffsets,
	        shapeOrientations = this.shapeOrientations,
	        N = shapes.length,
	        offset = tmpVec,
	        orientation = tmpQuat,
	        bodyQuat = this.quaternion,
	        aabb = this.aabb,
	        shapeAABB = new AABB();
	
	    for(var i=0; i!==N; i++){
	        var shape = shapes[i];
	
	        // Get shape world quaternion
	        shapeOrientations[i].mult(bodyQuat, orientation);
	
	        // Get shape world position
	        orientation.vmult(shapeOffsets[i], offset);
	        offset.vadd(this.position, offset);
	
	        // vec2.rotate(offset, shapeOffsets[i], bodyAngle);
	        // vec2.add(offset, offset, this.position);
	
	        // Get shape AABB
	        shape.calculateWorldAABB(offset, orientation, shapeAABB.lowerBound, shapeAABB.upperBound);
	
	        if(i === 0){
	            aabb.copy(shapeAABB);
	        } else {
	            aabb.extend(shapeAABB);
	        }
	    }
	
	    this.aabbNeedsUpdate = false;
	};
	
	var uiw_m1 = new Mat3(),
	    uiw_m2 = new Mat3(),
	    uiw_m3 = new Mat3();
	
	/**
	 * Update .inertiaWorld and .invInertiaWorld
	 * @method updateInertiaWorld
	 */
	Body.prototype.updateInertiaWorld = function(force){
	    var I = this.invInertia;
	    if (I.x === I.y && I.y === I.z && !force) {
	        // If inertia M = s*I, where I is identity and s a scalar, then
	        //    R*M*R' = R*(s*I)*R' = s*R*I*R' = s*R*R' = s*I = M
	        // where R is the rotation matrix.
	        // In other words, we don't have to transform the inertia if all
	        // inertia diagonal entries are equal.
	    } else {
	        var m1 = uiw_m1,
	            m2 = uiw_m2,
	            m3 = uiw_m3;
	        m1.setRotationFromQuaternion(this.quaternion);
	        m1.transpose(m2);
	        m1.scale(I,m1);
	        m1.mmult(m2,this.invInertiaWorld);
	        //m3.getTrace(this.invInertiaWorld);
	    }
	
	    /*
	    this.quaternion.vmult(this.inertia,this.inertiaWorld);
	    this.quaternion.vmult(this.invInertia,this.invInertiaWorld);
	    */
	};
	
	/**
	 * Apply force to a world point. This could for example be a point on the Body surface. Applying force this way will add to Body.force and Body.tau.
	 * @method applyForce
	 * @param  {Vec3} force The amount of force to add.
	 * @param  {Vec3} worldPoint A world point to apply the force on.
	 */
	var Body_applyForce_r = new Vec3();
	var Body_applyForce_rotForce = new Vec3();
	Body.prototype.applyForce = function(force,worldPoint){
	    if(this.type !== Body.DYNAMIC){
	        return;
	    }
	
	    // Compute point position relative to the body center
	    var r = Body_applyForce_r;
	    worldPoint.vsub(this.position,r);
	
	    // Compute produced rotational force
	    var rotForce = Body_applyForce_rotForce;
	    r.cross(force,rotForce);
	
	    // Add linear force
	    this.force.vadd(force,this.force);
	
	    // Add rotational force
	    this.tau.vadd(rotForce,this.tau);
	};
	
	/**
	 * Apply impulse to a world point. This could for example be a point on the Body surface. An impulse is a force added to a body during a short period of time (impulse = force * time). Impulses will be added to Body.velocity and Body.angularVelocity.
	 * @method applyImpulse
	 * @param  {Vec3} impulse The amount of impulse to add.
	 * @param  {Vec3} worldPoint A world point to apply the force on.
	 */
	var Body_applyImpulse_r = new Vec3();
	var Body_applyImpulse_velo = new Vec3();
	var Body_applyImpulse_rotVelo = new Vec3();
	Body.prototype.applyImpulse = function(impulse, worldPoint){
	    if(this.type !== Body.DYNAMIC){
	        return;
	    }
	
	    // Compute point position relative to the body center
	    var r = Body_applyImpulse_r;
	    worldPoint.vsub(this.position,r);
	
	    // Compute produced central impulse velocity
	    var velo = Body_applyImpulse_velo;
	    velo.copy(impulse);
	    velo.mult(this.invMass,velo);
	
	    // Add linear impulse
	    this.velocity.vadd(velo, this.velocity);
	
	    // Compute produced rotational impulse velocity
	    var rotVelo = Body_applyImpulse_rotVelo;
	    r.cross(impulse,rotVelo);
	
	    /*
	    rotVelo.x *= this.invInertia.x;
	    rotVelo.y *= this.invInertia.y;
	    rotVelo.z *= this.invInertia.z;
	    */
	    this.invInertiaWorld.vmult(rotVelo,rotVelo);
	
	    // Add rotational Impulse
	    this.angularVelocity.vadd(rotVelo, this.angularVelocity);
	};
	
	/**
	 * Should be called whenever you change the body mass.
	 * @method updateMassProperties
	 */
	/*Body.prototype.updateMassProperties = function(){
	    this.invMass = this.mass>0 ? 1.0/this.mass : 0;
	    this.shape.calculateLocalInertia(this.mass, this.inertia);
	    var I = this.inertia;
	    var fixed = this.fixedRotation;
	    this.invInertia.set(
	        I.x > 0 && !fixed ? 1.0 / I.x : 0,
	        I.y > 0 && !fixed ? 1.0 / I.y : 0,
	        I.z > 0 && !fixed ? 1.0 / I.z : 0
	    );
	    this.updateInertiaWorld(true);
	};
	*/
	
	Body.prototype.updateMassProperties = function(){
	    var target = new Vec3();
	
	    // TODO: check if only 1 shape at origin, use shape inertia in that case
	
	    this.invMass = this.mass > 0 ? 1.0 / this.mass : 0;
	    var I = this.inertia;
	    var fixed = this.fixedRotation;
	
	    // Approximate with AABB
	    this.computeAABB();
	    Box.calculateInertia(new Vec3(
	        (this.aabb.upperBound.x-this.aabb.lowerBound.x) / 2,
	        (this.aabb.upperBound.y-this.aabb.lowerBound.y) / 2,
	        (this.aabb.upperBound.z-this.aabb.lowerBound.z) / 2
	    ), this.mass, I);
	
	    this.invInertia.set(
	        I.x > 0 && !fixed ? 1.0 / I.x : 0,
	        I.y > 0 && !fixed ? 1.0 / I.y : 0,
	        I.z > 0 && !fixed ? 1.0 / I.z : 0
	    );
	    this.updateInertiaWorld(true);
	};
	
	/**
	 * Get world velocity of a point in the body.
	 * @method getVelocityAtWorldPoint
	 * @param  {Vec3} worldPoint
	 * @param  {Vec3} result
	 * @return {Vec3} The result vector.
	 */
	Body.prototype.getVelocityAtWorldPoint = function(worldPoint, result){
	    var r = new Vec3();
	    worldPoint.vsub(this.position, r);
	    this.angularVelocity.cross(r, result);
	    this.velocity.vadd(result, result);
	    return result;
	};
	
	},{"../collision/AABB":3,"../material/Material":22,"../math/Mat3":24,"../math/Quaternion":25,"../math/Vec3":27,"../shapes/Box":34,"../shapes/Shape":40,"../utils/EventTarget":45}],29:[function(_dereq_,module,exports){
	var Body = _dereq_('./Body');
	var Vec3 = _dereq_('../math/Vec3');
	var Quaternion = _dereq_('../math/Quaternion');
	var RaycastResult = _dereq_('../collision/RaycastResult');
	var Ray = _dereq_('../collision/Ray');
	var WheelInfo = _dereq_('../objects/WheelInfo');
	
	module.exports = RaycastVehicle;
	
	/**
	 * Vehicle helper class that casts rays from the wheel positions towards the ground and applies forces.
	 * @class RaycastVehicle
	 * @constructor
	 * @param {object} [options.chassisBody]
	 * @param {object} [options.indexRightAxis]
	 * @param {object} [options.indexLeftAxis]
	 * @param {object} [options.indexUpAxis]
	 */
	function RaycastVehicle(options){
	
	    /**
	     * @property {Body} chassisBody
	     */
	    this.chassisBody = options.chassisBody;
	
	    /**
	     * @property {array} wheelInfos An array of WheelInfo objects.
	     */
	    this.wheelInfos = [];
	
	    /**
	     * Will be set to true if the car is sliding.
	     * @property {boolean} sliding
	     */
	    this.sliding = false;
	
	    /**
	     * @property {World} world
	     */
	    this.world = null;
	
	    /**
	     * Index of the right axis, 0=x, 1=y, 2=z
	     * @property {integer} indexRightAxis
	     * @default 1
	     */
	    this.indexRightAxis = typeof(options.indexRightAxis) !== 'undefined' ? options.indexRightAxis : 1;
	
	    /**
	     * Index of the forward axis, 0=x, 1=y, 2=z
	     * @property {integer} indexForwardAxis
	     * @default 0
	     */
	    this.indexForwardAxis = typeof(options.indexForwardAxis) !== 'undefined' ? options.indexForwardAxis : 0;
	
	    /**
	     * Index of the up axis, 0=x, 1=y, 2=z
	     * @property {integer} indexUpAxis
	     * @default 2
	     */
	    this.indexUpAxis = typeof(options.indexUpAxis) !== 'undefined' ? options.indexUpAxis : 2;
	}
	
	var tmpVec1 = new Vec3();
	var tmpVec2 = new Vec3();
	var tmpVec3 = new Vec3();
	var tmpVec4 = new Vec3();
	var tmpVec5 = new Vec3();
	var tmpVec6 = new Vec3();
	var tmpRay = new Ray();
	
	/**
	 * Add a wheel. For information about the options, see WheelInfo.
	 * @param {object} [options]
	 * @method addWheel
	 */
	RaycastVehicle.prototype.addWheel = function(options){
	    options = options || {};
	
	    var info = new WheelInfo(options);
	    var index = this.wheelInfos.length;
	    this.wheelInfos.push(info);
	
	    return index;
	};
	
	/**
	 * Set the steering value of a wheel.
	 * @method setSteeringValue
	 * @param {number} value
	 * @param {integer} wheelIndex
	 */
	RaycastVehicle.prototype.setSteeringValue = function(value, wheelIndex){
	    var wheel = this.wheelInfos[wheelIndex];
	    wheel.steering = value;
	};
	
	var torque = new Vec3();
	
	/**
	 * Set the wheel force to apply on one of the wheels each time step
	 * @method applyEngineForce
	 * @param  {number} value
	 * @param  {integer} wheelIndex
	 */
	RaycastVehicle.prototype.applyEngineForce = function(value, wheelIndex){
	    this.wheelInfos[wheelIndex].engineForce = value;
	};
	
	/**
	 * Set the braking force of a wheel
	 * @method setBrake
	 * @param {number} brake
	 * @param {integer} wheelIndex
	 */
	RaycastVehicle.prototype.setBrake = function(brake, wheelIndex){
	    this.wheelInfos[wheelIndex].brake = brake;
	};
	
	/**
	 * Add the vehicle including its constraints to the world.
	 * @method addToWorld
	 * @param {World} world
	 */
	RaycastVehicle.prototype.addToWorld = function(world){
	    var constraints = this.constraints;
	    world.add(this.chassisBody);
	    var that = this;
	    world.addEventListener('preStep', function(){
	        that.updateVehicle(world.dt);
	    });
	    this.world = world;
	};
	
	RaycastVehicle.prototype.getVehicleAxisWorld = function(axisIndex, result){
	    result.set(
	        axisIndex === 0 ? 1 : 0,
	        axisIndex === 1 ? 1 : 0,
	        axisIndex === 2 ? 1 : 0
	    );
	    this.chassisBody.vectorToWorldFrame(result, result);
	};
	
	RaycastVehicle.prototype.updateVehicle = function(timeStep){
	    var wheelInfos = this.wheelInfos;
	    var numWheels = wheelInfos.length;
	    var chassisBody = this.chassisBody;
	
	    for (var i = 0; i < numWheels; i++) {
	        this.updateWheelTransform(i, false);
	    }
	
	    this.currentVehicleSpeedKmHour = 3.6 * chassisBody.velocity.norm();
	
	    var forwardWorld = new Vec3();
	    this.getVehicleAxisWorld(this.indexForwardAxis, forwardWorld);
	
	    if (forwardWorld.dot(chassisBody.velocity) < 0){
	        this.currentVehicleSpeedKmHour *= -1;
	    }
	
	    // simulate suspension
	    for (var i = 0; i < numWheels; i++) {
	        this.castRay(wheelInfos[i]);
	    }
	
	    this.updateSuspension(timeStep);
	
	    var impulse = new Vec3();
	    var relpos = new Vec3();
	    for (var i = 0; i < numWheels; i++) {
	        //apply suspension force
	        var wheel = wheelInfos[i];
	        var suspensionForce = wheel.suspensionForce;
	        if (suspensionForce > wheel.maxSuspensionForce) {
	            suspensionForce = wheel.maxSuspensionForce;
	        }
	        wheel.raycastResult.hitNormalWorld.scale(suspensionForce * timeStep, impulse);
	
	        wheel.raycastResult.hitPointWorld.vsub(chassisBody.position, relpos);
	        chassisBody.applyImpulse(impulse, wheel.raycastResult.hitPointWorld/*relpos*/);
	    }
	
	    this.updateFriction(timeStep);
	
	    var hitNormalWorldScaledWithProj = new Vec3();
	    var fwd  = new Vec3();
	    var vel = new Vec3();
	    for (i = 0; i < numWheels; i++) {
	        var wheel = wheelInfos[i];
	        //var relpos = new Vec3();
	        //wheel.chassisConnectionPointWorld.vsub(chassisBody.position, relpos);
	        chassisBody.getVelocityAtWorldPoint(wheel.chassisConnectionPointWorld, vel);
	
	        // Hack to get the rotation in the correct direction
	        var m = 1;
	        switch(this.indexUpAxis){
	        case 1:
	            m = -1;
	            break;
	        }
	
	        if (wheel.isInContact) {
	
	            this.getVehicleAxisWorld(this.indexForwardAxis, fwd);
	            var proj = fwd.dot(wheel.raycastResult.hitNormalWorld);
	            wheel.raycastResult.hitNormalWorld.scale(proj, hitNormalWorldScaledWithProj);
	
	            fwd.vsub(hitNormalWorldScaledWithProj, fwd);
	
	            var proj2 = fwd.dot(vel);
	            wheel.deltaRotation = m * proj2 * timeStep / wheel.radius;
	        }
	
	        if((wheel.sliding || !wheel.isInContact) && wheel.engineForce !== 0 && wheel.useCustomSlidingRotationalSpeed){
	            // Apply custom rotation when accelerating and sliding
	            wheel.deltaRotation = (wheel.engineForce > 0 ? 1 : -1) * wheel.customSlidingRotationalSpeed * timeStep;
	        }
	
	        // Lock wheels
	        if(Math.abs(wheel.brake) > Math.abs(wheel.engineForce)){
	            wheel.deltaRotation = 0;
	        }
	
	        wheel.rotation += wheel.deltaRotation; // Use the old value
	        wheel.deltaRotation *= 0.99; // damping of rotation when not in contact
	    }
	};
	
	RaycastVehicle.prototype.updateSuspension = function(deltaTime) {
	    var chassisBody = this.chassisBody;
	    var chassisMass = chassisBody.mass;
	    var wheelInfos = this.wheelInfos;
	    var numWheels = wheelInfos.length;
	
	    for (var w_it = 0; w_it < numWheels; w_it++){
	        var wheel = wheelInfos[w_it];
	
	        if (wheel.isInContact){
	            var force;
	
	            // Spring
	            var susp_length = wheel.suspensionRestLength;
	            var current_length = wheel.suspensionLength;
	            var length_diff = (susp_length - current_length);
	
	            force = wheel.suspensionStiffness * length_diff * wheel.clippedInvContactDotSuspension;
	
	            // Damper
	            var projected_rel_vel = wheel.suspensionRelativeVelocity;
	            var susp_damping;
	            if (projected_rel_vel < 0) {
	                susp_damping = wheel.dampingCompression;
	            } else {
	                susp_damping = wheel.dampingRelaxation;
	            }
	            force -= susp_damping * projected_rel_vel;
	
	            wheel.suspensionForce = force * chassisMass;
	            if (wheel.suspensionForce < 0) {
	                wheel.suspensionForce = 0;
	            }
	        } else {
	            wheel.suspensionForce = 0;
	        }
	    }
	};
	
	/**
	 * Remove the vehicle including its constraints from the world.
	 * @method removeFromWorld
	 * @param {World} world
	 */
	RaycastVehicle.prototype.removeFromWorld = function(world){
	    var constraints = this.constraints;
	    world.remove(this.chassisBody);
	    world.removeEventListener('preStep', this.updateVehicle);
	    this.world = null;
	};
	
	// var from = new Vec3();
	// var to = new Vec3();
	var castRay_rayvector = new Vec3();
	var castRay_target = new Vec3();
	RaycastVehicle.prototype.castRay = function(wheel) {
	    var rayvector = castRay_rayvector;
	    var target = castRay_target;
	
	    this.updateWheelTransformWorld(wheel);
	    var chassisBody = this.chassisBody;
	
	    var depth = -1;
	
	    var raylen = wheel.suspensionRestLength + wheel.radius;
	
	    wheel.directionWorld.scale(raylen, rayvector);
	    var source = wheel.chassisConnectionPointWorld;
	    source.vadd(rayvector, target);
	    var raycastResult = wheel.raycastResult;
	
	    var param = 0;
	
	    raycastResult.reset();
	    this.world.rayTest(source, target, raycastResult);
	    var object = raycastResult.body;
	
	    wheel.raycastResult.groundObject = 0;
	
	    if (object) {
	        depth = raycastResult.distance;
	        wheel.raycastResult.hitNormalWorld  = raycastResult.hitNormalWorld;
	        wheel.isInContact = true;
	
	        var hitDistance = raycastResult.distance;
	        wheel.suspensionLength = hitDistance - wheel.radius;
	
	        // clamp on max suspension travel
	        var minSuspensionLength = wheel.suspensionRestLength - wheel.maxSuspensionTravel;
	        var maxSuspensionLength = wheel.suspensionRestLength + wheel.maxSuspensionTravel;
	        if (wheel.suspensionLength < minSuspensionLength) {
	            wheel.suspensionLength = minSuspensionLength;
	        }
	        if (wheel.suspensionLength > maxSuspensionLength) {
	            wheel.suspensionLength = maxSuspensionLength;
	            wheel.raycastResult.reset();
	        }
	
	        var denominator = wheel.raycastResult.hitNormalWorld.dot(wheel.directionWorld);
	
	        var chassis_velocity_at_contactPoint = new Vec3();
	        chassisBody.getVelocityAtWorldPoint(wheel.raycastResult.hitPointWorld, chassis_velocity_at_contactPoint);
	
	        var projVel = wheel.raycastResult.hitNormalWorld.dot( chassis_velocity_at_contactPoint );
	
	        if (denominator >= -0.1) {
	            wheel.suspensionRelativeVelocity = 0;
	            wheel.clippedInvContactDotSuspension = 1 / 0.1;
	        } else {
	            var inv = -1 / denominator;
	            wheel.suspensionRelativeVelocity = projVel * inv;
	            wheel.clippedInvContactDotSuspension = inv;
	        }
	
	    } else {
	
	        //put wheel info as in rest position
	        wheel.suspensionLength = wheel.suspensionRestLength + 0 * wheel.maxSuspensionTravel;
	        wheel.suspensionRelativeVelocity = 0.0;
	        wheel.directionWorld.scale(-1, wheel.raycastResult.hitNormalWorld);
	        wheel.clippedInvContactDotSuspension = 1.0;
	    }
	
	    return depth;
	};
	
	RaycastVehicle.prototype.updateWheelTransformWorld = function(wheel){
	    wheel.isInContact = false;
	    var chassisBody = this.chassisBody;
	    chassisBody.pointToWorldFrame(wheel.chassisConnectionPointLocal, wheel.chassisConnectionPointWorld);
	    chassisBody.vectorToWorldFrame(wheel.directionLocal, wheel.directionWorld);
	    chassisBody.vectorToWorldFrame(wheel.axleLocal, wheel.axleWorld);
	};
	
	RaycastVehicle.prototype.updateWheelTransform = function(wheelIndex){
	    var up = tmpVec4;
	    var right = tmpVec5;
	    var fwd = tmpVec6;
	
	    var wheel = this.wheelInfos[wheelIndex];
	    this.updateWheelTransformWorld(wheel);
	
	    wheel.directionLocal.scale(-1, up);
	    right.copy(wheel.axleLocal);
	    up.cross(right, fwd);
	    fwd.normalize();
	    right.normalize();
	
	    // Rotate around steering over the wheelAxle
	    var steering = wheel.steering;
	    var steeringOrn = new Quaternion();
	    steeringOrn.setFromAxisAngle(up, steering);
	
	    var rotatingOrn = new Quaternion();
	    rotatingOrn.setFromAxisAngle(right, wheel.rotation);
	
	    // World rotation of the wheel
	    var q = wheel.worldTransform.quaternion;
	    this.chassisBody.quaternion.mult(steeringOrn, q);
	    q.mult(rotatingOrn, q);
	
	    q.normalize();
	
	    // world position of the wheel
	    var p = wheel.worldTransform.position;
	    p.copy(wheel.directionWorld);
	    p.scale(wheel.suspensionLength, p);
	    p.vadd(wheel.chassisConnectionPointWorld, p);
	};
	
	var directions = [
	    new Vec3(1, 0, 0),
	    new Vec3(0, 1, 0),
	    new Vec3(0, 0, 1)
	];
	
	
	RaycastVehicle.prototype.getWheelTransformWorld = function(wheelIndex) {
	    return this.wheelInfos[wheelIndex].worldTransform;
	};
	
	
	var updateFriction_surfNormalWS_scaled_proj = new Vec3();
	var updateFriction_axle = [];
	var updateFriction_forwardWS = [];
	var sideFrictionStiffness2 = 1;
	RaycastVehicle.prototype.updateFriction = function(timeStep) {
	    var surfNormalWS_scaled_proj = updateFriction_surfNormalWS_scaled_proj;
	
	    //calculate the impulse, so that the wheels don't move sidewards
	    var wheelInfos = this.wheelInfos;
	    var numWheels = wheelInfos.length;
	    var chassisBody = this.chassisBody;
	    var forwardWS = updateFriction_forwardWS;
	    var axle = updateFriction_axle;
	
	    var numWheelsOnGround = 0;
	
	    for (var i = 0; i < numWheels; i++) {
	        var wheel = wheelInfos[i];
	
	        var groundObject = wheel.raycastResult.body;
	        if (groundObject){
	            numWheelsOnGround++;
	        }
	
	        wheel.sideImpulse = 0;
	        wheel.forwardImpulse = 0;
	        if(!forwardWS[i]){
	            forwardWS[i] = new Vec3();
	        }
	        if(!axle[i]){
	            axle[i] = new Vec3();
	        }
	    }
	
	    for (var i = 0; i < numWheels; i++){
	        var wheel = wheelInfos[i];
	
	        var groundObject = wheel.raycastResult.body;
	
	        if (groundObject) {
	            var axlei = axle[i];
	            var wheelTrans = this.getWheelTransformWorld(i);
	
	            // Get world axle
	            wheelTrans.vectorToWorldFrame(directions[this.indexRightAxis], axlei);
	
	            var surfNormalWS = wheel.raycastResult.hitNormalWorld;
	            var proj = axlei.dot(surfNormalWS);
	            surfNormalWS.scale(proj, surfNormalWS_scaled_proj);
	            axlei.vsub(surfNormalWS_scaled_proj, axlei);
	            axlei.normalize();
	
	            surfNormalWS.cross(axlei, forwardWS[i]);
	            forwardWS[i].normalize();
	
	            wheel.sideImpulse = resolveSingleBilateral(
	                chassisBody,
	                wheel.raycastResult.hitPointWorld,
	                groundObject,
	                wheel.raycastResult.hitPointWorld,
	                axlei
	            );
	
	            wheel.sideImpulse *= sideFrictionStiffness2;
	        }
	    }
	
	    var sideFactor = 1;
	    var fwdFactor = 0.5;
	
	    this.sliding = false;
	    for (var i = 0; i < numWheels; i++) {
	        var wheel = wheelInfos[i];
	        var groundObject = wheel.raycastResult.body;
	
	        var rollingFriction = 0;
	
	        wheel.slipInfo = 1;
	        if (groundObject) {
	            var defaultRollingFrictionImpulse = 0;
	            var maxImpulse = wheel.brake ? wheel.brake : defaultRollingFrictionImpulse;
	
	            // btWheelContactPoint contactPt(chassisBody,groundObject,wheelInfraycastInfo.hitPointWorld,forwardWS[wheel],maxImpulse);
	            // rollingFriction = calcRollingFriction(contactPt);
	            rollingFriction = calcRollingFriction(chassisBody, groundObject, wheel.raycastResult.hitPointWorld, forwardWS[i], maxImpulse);
	
	            rollingFriction += wheel.engineForce * timeStep;
	
	            // rollingFriction = 0;
	            var factor = maxImpulse / rollingFriction;
	            wheel.slipInfo *= factor;
	        }
	
	        //switch between active rolling (throttle), braking and non-active rolling friction (nthrottle/break)
	
	        wheel.forwardImpulse = 0;
	        wheel.skidInfo = 1;
	
	        if (groundObject) {
	            wheel.skidInfo = 1;
	
	            var maximp = wheel.suspensionForce * timeStep * wheel.frictionSlip;
	            var maximpSide = maximp;
	
	            var maximpSquared = maximp * maximpSide;
	
	            wheel.forwardImpulse = rollingFriction;//wheelInfo.engineForce* timeStep;
	
	            var x = wheel.forwardImpulse * fwdFactor;
	            var y = wheel.sideImpulse * sideFactor;
	
	            var impulseSquared = x * x + y * y;
	
	            wheel.sliding = false;
	            if (impulseSquared > maximpSquared) {
	                this.sliding = true;
	                wheel.sliding = true;
	
	                var factor = maximp / Math.sqrt(impulseSquared);
	
	                wheel.skidInfo *= factor;
	            }
	        }
	    }
	
	    if (this.sliding) {
	        for (var i = 0; i < numWheels; i++) {
	            var wheel = wheelInfos[i];
	            if (wheel.sideImpulse !== 0) {
	                if (wheel.skidInfo < 1){
	                    wheel.forwardImpulse *= wheel.skidInfo;
	                    wheel.sideImpulse *= wheel.skidInfo;
	                }
	            }
	        }
	    }
	
	    // apply the impulses
	    for (var i = 0; i < numWheels; i++) {
	        var wheel = wheelInfos[i];
	
	        var rel_pos = new Vec3();
	        //wheel.raycastResult.hitPointWorld.vsub(chassisBody.position, rel_pos);
	        // cannons applyimpulse is using world coord for the position
	        rel_pos.copy(wheel.raycastResult.hitPointWorld);
	
	        if (wheel.forwardImpulse !== 0) {
	            var impulse = new Vec3();
	            forwardWS[i].scale(wheel.forwardImpulse, impulse);
	            chassisBody.applyImpulse(impulse, rel_pos);
	        }
	
	        if (wheel.sideImpulse !== 0){
	            var groundObject = wheel.raycastResult.body;
	
	            var rel_pos2 = new Vec3();
	            //wheel.raycastResult.hitPointWorld.vsub(groundObject.position, rel_pos2);
	            rel_pos2.copy(wheel.raycastResult.hitPointWorld);
	            var sideImp = new Vec3();
	            axle[i].scale(wheel.sideImpulse, sideImp);
	
	            // Scale the relative position in the up direction with rollInfluence.
	            // If rollInfluence is 1, the impulse will be applied on the hitPoint (easy to roll over), if it is zero it will be applied in the same plane as the center of mass (not easy to roll over).
	            chassisBody.pointToLocalFrame(rel_pos, rel_pos);
	            rel_pos['xyz'[this.indexUpAxis]] *= wheel.rollInfluence;
	            chassisBody.pointToWorldFrame(rel_pos, rel_pos);
	            chassisBody.applyImpulse(sideImp, rel_pos);
	
	            //apply friction impulse on the ground
	            sideImp.scale(-1, sideImp);
	            groundObject.applyImpulse(sideImp, rel_pos2);
	        }
	    }
	};
	
	var calcRollingFriction_vel1 = new Vec3();
	var calcRollingFriction_vel2 = new Vec3();
	var calcRollingFriction_vel = new Vec3();
	
	function calcRollingFriction(body0, body1, frictionPosWorld, frictionDirectionWorld, maxImpulse) {
	    var j1 = 0;
	    var contactPosWorld = frictionPosWorld;
	
	    // var rel_pos1 = new Vec3();
	    // var rel_pos2 = new Vec3();
	    var vel1 = calcRollingFriction_vel1;
	    var vel2 = calcRollingFriction_vel2;
	    var vel = calcRollingFriction_vel;
	    // contactPosWorld.vsub(body0.position, rel_pos1);
	    // contactPosWorld.vsub(body1.position, rel_pos2);
	
	    body0.getVelocityAtWorldPoint(contactPosWorld, vel1);
	    body1.getVelocityAtWorldPoint(contactPosWorld, vel2);
	    vel1.vsub(vel2, vel);
	
	    var vrel = frictionDirectionWorld.dot(vel);
	
	    var denom0 = computeImpulseDenominator(body0, frictionPosWorld, frictionDirectionWorld);
	    var denom1 = computeImpulseDenominator(body1, frictionPosWorld, frictionDirectionWorld);
	    var relaxation = 1;
	    var jacDiagABInv = relaxation / (denom0 + denom1);
	
	    // calculate j that moves us to zero relative velocity
	    j1 = -vrel * jacDiagABInv;
	
	    if (maxImpulse < j1) {
	        j1 = maxImpulse;
	    }
	    if (j1 < -maxImpulse) {
	        j1 = -maxImpulse;
	    }
	
	    return j1;
	}
	
	var computeImpulseDenominator_r0 = new Vec3();
	var computeImpulseDenominator_c0 = new Vec3();
	var computeImpulseDenominator_vec = new Vec3();
	var computeImpulseDenominator_m = new Vec3();
	function computeImpulseDenominator(body, pos, normal) {
	    var r0 = computeImpulseDenominator_r0;
	    var c0 = computeImpulseDenominator_c0;
	    var vec = computeImpulseDenominator_vec;
	    var m = computeImpulseDenominator_m;
	
	    pos.vsub(body.position, r0);
	    r0.cross(normal, c0);
	    body.invInertiaWorld.vmult(c0, m);
	    m.cross(r0, vec);
	
	    return body.invMass + normal.dot(vec);
	}
	
	
	var resolveSingleBilateral_vel1 = new Vec3();
	var resolveSingleBilateral_vel2 = new Vec3();
	var resolveSingleBilateral_vel = new Vec3();
	
	//bilateral constraint between two dynamic objects
	function resolveSingleBilateral(body1, pos1, body2, pos2, normal, impulse){
	    var normalLenSqr = normal.norm2();
	    if (normalLenSqr > 1.1){
	        return 0; // no impulse
	    }
	    // var rel_pos1 = new Vec3();
	    // var rel_pos2 = new Vec3();
	    // pos1.vsub(body1.position, rel_pos1);
	    // pos2.vsub(body2.position, rel_pos2);
	
	    var vel1 = resolveSingleBilateral_vel1;
	    var vel2 = resolveSingleBilateral_vel2;
	    var vel = resolveSingleBilateral_vel;
	    body1.getVelocityAtWorldPoint(pos1, vel1);
	    body2.getVelocityAtWorldPoint(pos2, vel2);
	
	    vel1.vsub(vel2, vel);
	
	    var rel_vel = normal.dot(vel);
	
	    var contactDamping = 0.2;
	    var massTerm = 1 / (body1.invMass + body2.invMass);
	    var impulse = - contactDamping * rel_vel * massTerm;
	
	    return impulse;
	}
	},{"../collision/Ray":9,"../collision/RaycastResult":10,"../math/Quaternion":25,"../math/Vec3":27,"../objects/WheelInfo":33,"./Body":28}],30:[function(_dereq_,module,exports){
	var Body = _dereq_('./Body');
	var Sphere = _dereq_('../shapes/Sphere');
	var Box = _dereq_('../shapes/Box');
	var Vec3 = _dereq_('../math/Vec3');
	var HingeConstraint = _dereq_('../constraints/HingeConstraint');
	
	module.exports = RigidVehicle;
	
	/**
	 * Simple vehicle helper class with spherical rigid body wheels.
	 * @class RigidVehicle
	 * @constructor
	 * @param {object} [options.chassisBody]
	 */
	function RigidVehicle(options){
	    this.wheelBodies = [];
	
	    /**
	     * @property coordinateSystem
	     * @type {Vec3}
	     */
	    this.coordinateSystem = typeof(options.coordinateSystem)==='undefined' ? new Vec3(1, 2, 3) : options.coordinateSystem.clone();
	
	    /**
	     * @property {Body} chassisBody
	     */
	    this.chassisBody = options.chassisBody;
	
	    if(!this.chassisBody){
	        // No chassis body given. Create it!
	        var chassisShape = new Box(new Vec3(5, 2, 0.5));
	        this.chassisBody = new Body(1, chassisShape);
	    }
	
	    /**
	     * @property constraints
	     * @type {Array}
	     */
	    this.constraints = [];
	
	    this.wheelAxes = [];
	    this.wheelForces = [];
	}
	
	/**
	 * Add a wheel
	 * @method addWheel
	 * @param {object} options
	 * @param {object} [options.isFrontWheel]
	 * @param {Vec3} [options.position] Position of the wheel, locally in the chassis body.
	 * @param {Vec3} [options.direction] Slide direction of the wheel along the suspension.
	 * @param {Vec3} [options.axis] Axis of rotation of the wheel, locally defined in the chassis.
	 * @param {Body} [options.body] The wheel body.
	 */
	RigidVehicle.prototype.addWheel = function(options){
	    options = options || {};
	    var wheelBody = options.body;
	    if(!wheelBody){
	        wheelBody =  new Body(1, new Sphere(1.2));
	    }
	    this.wheelBodies.push(wheelBody);
	    this.wheelForces.push(0);
	
	    // Position constrain wheels
	    var zero = new Vec3();
	    var position = typeof(options.position) !== 'undefined' ? options.position.clone() : new Vec3();
	
	    // Set position locally to the chassis
	    var worldPosition = new Vec3();
	    this.chassisBody.pointToWorldFrame(position, worldPosition);
	    wheelBody.position.set(worldPosition.x, worldPosition.y, worldPosition.z);
	
	    // Constrain wheel
	    var axis = typeof(options.axis) !== 'undefined' ? options.axis.clone() : new Vec3(0, 1, 0);
	    this.wheelAxes.push(axis);
	
	    var hingeConstraint = new HingeConstraint(this.chassisBody, wheelBody, {
	        pivotA: position,
	        axisA: axis,
	        pivotB: Vec3.ZERO,
	        axisB: axis,
	        collideConnected: false
	    });
	    this.constraints.push(hingeConstraint);
	
	    return this.wheelBodies.length - 1;
	};
	
	/**
	 * Set the steering value of a wheel.
	 * @method setSteeringValue
	 * @param {number} value
	 * @param {integer} wheelIndex
	 * @todo check coordinateSystem
	 */
	RigidVehicle.prototype.setSteeringValue = function(value, wheelIndex){
	    // Set angle of the hinge axis
	    var axis = this.wheelAxes[wheelIndex];
	
	    var c = Math.cos(value),
	        s = Math.sin(value),
	        x = axis.x,
	        y = axis.y;
	    this.constraints[wheelIndex].axisA.set(
	        c*x -s*y,
	        s*x +c*y,
	        0
	    );
	};
	
	/**
	 * Set the target rotational speed of the hinge constraint.
	 * @method setMotorSpeed
	 * @param {number} value
	 * @param {integer} wheelIndex
	 */
	RigidVehicle.prototype.setMotorSpeed = function(value, wheelIndex){
	    var hingeConstraint = this.constraints[wheelIndex];
	    hingeConstraint.enableMotor();
	    hingeConstraint.motorTargetVelocity = value;
	};
	
	/**
	 * Set the target rotational speed of the hinge constraint.
	 * @method disableMotor
	 * @param {number} value
	 * @param {integer} wheelIndex
	 */
	RigidVehicle.prototype.disableMotor = function(wheelIndex){
	    var hingeConstraint = this.constraints[wheelIndex];
	    hingeConstraint.disableMotor();
	};
	
	var torque = new Vec3();
	
	/**
	 * Set the wheel force to apply on one of the wheels each time step
	 * @method setWheelForce
	 * @param  {number} value
	 * @param  {integer} wheelIndex
	 */
	RigidVehicle.prototype.setWheelForce = function(value, wheelIndex){
	    this.wheelForces[wheelIndex] = value;
	};
	
	/**
	 * Apply a torque on one of the wheels.
	 * @method applyWheelForce
	 * @param  {number} value
	 * @param  {integer} wheelIndex
	 */
	RigidVehicle.prototype.applyWheelForce = function(value, wheelIndex){
	    var axis = this.wheelAxes[wheelIndex];
	    var wheelBody = this.wheelBodies[wheelIndex];
	    var bodyTorque = wheelBody.tau;
	
	    axis.scale(value, torque);
	    wheelBody.vectorToWorldFrame(torque, torque);
	    bodyTorque.vadd(torque, bodyTorque);
	};
	
	/**
	 * Add the vehicle including its constraints to the world.
	 * @method addToWorld
	 * @param {World} world
	 */
	RigidVehicle.prototype.addToWorld = function(world){
	    var constraints = this.constraints;
	    var bodies = this.wheelBodies.concat([this.chassisBody]);
	
	    for (var i = 0; i < bodies.length; i++) {
	        world.add(bodies[i]);
	    }
	
	    for (var i = 0; i < constraints.length; i++) {
	        world.addConstraint(constraints[i]);
	    }
	
	    world.addEventListener('preStep', this._update.bind(this));
	};
	
	RigidVehicle.prototype._update = function(){
	    var wheelForces = this.wheelForces;
	    for (var i = 0; i < wheelForces.length; i++) {
	        this.applyWheelForce(wheelForces[i], i);
	    }
	};
	
	/**
	 * Remove the vehicle including its constraints from the world.
	 * @method removeFromWorld
	 * @param {World} world
	 */
	RigidVehicle.prototype.removeFromWorld = function(world){
	    var constraints = this.constraints;
	    var bodies = this.wheelBodies.concat([this.chassisBody]);
	
	    for (var i = 0; i < bodies.length; i++) {
	        world.remove(bodies[i]);
	    }
	
	    for (var i = 0; i < constraints.length; i++) {
	        world.removeConstraint(constraints[i]);
	    }
	};
	
	var worldAxis = new Vec3();
	
	/**
	 * Get current rotational velocity of a wheel
	 * @method getWheelSpeed
	 * @param {integer} wheelIndex
	 */
	RigidVehicle.prototype.getWheelSpeed = function(wheelIndex){
	    var axis = this.wheelAxes[wheelIndex];
	    var wheelBody = this.wheelBodies[wheelIndex];
	    var w = wheelBody.angularVelocity;
	    this.chassisBody.vectorToWorldFrame(axis, worldAxis);
	    return w.dot(worldAxis);
	};
	
	},{"../constraints/HingeConstraint":14,"../math/Vec3":27,"../shapes/Box":34,"../shapes/Sphere":41,"./Body":28}],31:[function(_dereq_,module,exports){
	module.exports = SPHSystem;
	
	var Shape = _dereq_('../shapes/Shape');
	var Vec3 = _dereq_('../math/Vec3');
	var Quaternion = _dereq_('../math/Quaternion');
	var Particle = _dereq_('../shapes/Particle');
	var Body = _dereq_('../objects/Body');
	var Material = _dereq_('../material/Material');
	
	/**
	 * Smoothed-particle hydrodynamics system
	 * @class SPHSystem
	 * @constructor
	 */
	function SPHSystem(){
	    this.particles = [];
	    this.density = 1; // kg/m3
	    this.smoothingRadius = 1; // Adjust so there are about 15-20 neighbor particles within this radius
	    this.speedOfSound = 1;
	    this.viscosity = 0.01;
	    this.eps = 0.000001;
	
	    // Stuff Computed per particle
	    this.pressures = [];
	    this.densities = [];
	    this.neighbors = [];
	}
	
	SPHSystem.prototype.add = function(particle){
	    this.particles.push(particle);
	    if(this.neighbors.length < this.particles.length){
	        this.neighbors.push([]);
	    }
	};
	
	SPHSystem.prototype.remove = function(particle){
	    var idx = this.particles.indexOf(particle);
	    if(idx !== -1){
	        this.particles.splice(idx,1);
	        if(this.neighbors.length > this.particles.length){
	            this.neighbors.pop();
	        }
	    }
	};
	
	/**
	 * Get neighbors within smoothing volume, save in the array neighbors
	 * @method getNeighbors
	 * @param {Body} particle
	 * @param {Array} neighbors
	 */
	var SPHSystem_getNeighbors_dist = new Vec3();
	SPHSystem.prototype.getNeighbors = function(particle,neighbors){
	    var N = this.particles.length,
	        id = particle.id,
	        R2 = this.smoothingRadius * this.smoothingRadius,
	        dist = SPHSystem_getNeighbors_dist;
	    for(var i=0; i!==N; i++){
	        var p = this.particles[i];
	        p.position.vsub(particle.position,dist);
	        if(id!==p.id && dist.norm2() < R2){
	            neighbors.push(p);
	        }
	    }
	};
	
	// Temp vectors for calculation
	var SPHSystem_update_dist = new Vec3(),
	    SPHSystem_update_a_pressure = new Vec3(),
	    SPHSystem_update_a_visc = new Vec3(),
	    SPHSystem_update_gradW = new Vec3(),
	    SPHSystem_update_r_vec = new Vec3(),
	    SPHSystem_update_u = new Vec3(); // Relative velocity
	SPHSystem.prototype.update = function(){
	    var N = this.particles.length,
	        dist = SPHSystem_update_dist,
	        cs = this.speedOfSound,
	        eps = this.eps;
	
	    for(var i=0; i!==N; i++){
	        var p = this.particles[i]; // Current particle
	        var neighbors = this.neighbors[i];
	
	        // Get neighbors
	        neighbors.length = 0;
	        this.getNeighbors(p,neighbors);
	        neighbors.push(this.particles[i]); // Add current too
	        var numNeighbors = neighbors.length;
	
	        // Accumulate density for the particle
	        var sum = 0.0;
	        for(var j=0; j!==numNeighbors; j++){
	
	            //printf("Current particle has position %f %f %f\n",objects[id].pos.x(),objects[id].pos.y(),objects[id].pos.z());
	            p.position.vsub(neighbors[j].position, dist);
	            var len = dist.norm();
	
	            var weight = this.w(len);
	            sum += neighbors[j].mass * weight;
	        }
	
	        // Save
	        this.densities[i] = sum;
	        this.pressures[i] = cs * cs * (this.densities[i] - this.density);
	    }
	
	    // Add forces
	
	    // Sum to these accelerations
	    var a_pressure= SPHSystem_update_a_pressure;
	    var a_visc =    SPHSystem_update_a_visc;
	    var gradW =     SPHSystem_update_gradW;
	    var r_vec =     SPHSystem_update_r_vec;
	    var u =         SPHSystem_update_u;
	
	    for(var i=0; i!==N; i++){
	
	        var particle = this.particles[i];
	
	        a_pressure.set(0,0,0);
	        a_visc.set(0,0,0);
	
	        // Init vars
	        var Pij;
	        var nabla;
	        var Vij;
	
	        // Sum up for all other neighbors
	        var neighbors = this.neighbors[i];
	        var numNeighbors = neighbors.length;
	
	        //printf("Neighbors: ");
	        for(var j=0; j!==numNeighbors; j++){
	
	            var neighbor = neighbors[j];
	            //printf("%d ",nj);
	
	            // Get r once for all..
	            particle.position.vsub(neighbor.position,r_vec);
	            var r = r_vec.norm();
	
	            // Pressure contribution
	            Pij = -neighbor.mass * (this.pressures[i] / (this.densities[i]*this.densities[i] + eps) + this.pressures[j] / (this.densities[j]*this.densities[j] + eps));
	            this.gradw(r_vec, gradW);
	            // Add to pressure acceleration
	            gradW.mult(Pij , gradW);
	            a_pressure.vadd(gradW, a_pressure);
	
	            // Viscosity contribution
	            neighbor.velocity.vsub(particle.velocity, u);
	            u.mult( 1.0 / (0.0001+this.densities[i] * this.densities[j]) * this.viscosity * neighbor.mass , u );
	            nabla = this.nablaw(r);
	            u.mult(nabla,u);
	            // Add to viscosity acceleration
	            a_visc.vadd( u, a_visc );
	        }
	
	        // Calculate force
	        a_visc.mult(particle.mass, a_visc);
	        a_pressure.mult(particle.mass, a_pressure);
	
	        // Add force to particles
	        particle.force.vadd(a_visc, particle.force);
	        particle.force.vadd(a_pressure, particle.force);
	    }
	};
	
	// Calculate the weight using the W(r) weightfunction
	SPHSystem.prototype.w = function(r){
	    // 315
	    var h = this.smoothingRadius;
	    return 315.0/(64.0*Math.PI*Math.pow(h,9)) * Math.pow(h*h-r*r,3);
	};
	
	// calculate gradient of the weight function
	SPHSystem.prototype.gradw = function(rVec,resultVec){
	    var r = rVec.norm(),
	        h = this.smoothingRadius;
	    rVec.mult(945.0/(32.0*Math.PI*Math.pow(h,9)) * Math.pow((h*h-r*r),2) , resultVec);
	};
	
	// Calculate nabla(W)
	SPHSystem.prototype.nablaw = function(r){
	    var h = this.smoothingRadius;
	    var nabla = 945.0/(32.0*Math.PI*Math.pow(h,9)) * (h*h-r*r)*(7*r*r - 3*h*h);
	    return nabla;
	};
	
	},{"../material/Material":22,"../math/Quaternion":25,"../math/Vec3":27,"../objects/Body":28,"../shapes/Particle":38,"../shapes/Shape":40}],32:[function(_dereq_,module,exports){
	var Vec3 = _dereq_('../math/Vec3');
	
	module.exports = Spring;
	
	/**
	 * A spring, connecting two bodies.
	 *
	 * @class Spring
	 * @constructor
	 * @param {Body} bodyA
	 * @param {Body} bodyB
	 * @param {Object} [options]
	 * @param {number} [options.restLength]   A number > 0. Default: 1
	 * @param {number} [options.stiffness]    A number >= 0. Default: 100
	 * @param {number} [options.damping]      A number >= 0. Default: 1
	 * @param {Vec3}  [options.worldAnchorA] Where to hook the spring to body A, in world coordinates.
	 * @param {Vec3}  [options.worldAnchorB]
	 * @param {Vec3}  [options.localAnchorA] Where to hook the spring to body A, in local body coordinates.
	 * @param {Vec3}  [options.localAnchorB]
	 */
	function Spring(bodyA,bodyB,options){
	    options = options || {};
	
	    /**
	     * Rest length of the spring.
	     * @property restLength
	     * @type {number}
	     */
	    this.restLength = typeof(options.restLength) === "number" ? options.restLength : 1;
	
	    /**
	     * Stiffness of the spring.
	     * @property stiffness
	     * @type {number}
	     */
	    this.stiffness = options.stiffness || 100;
	
	    /**
	     * Damping of the spring.
	     * @property damping
	     * @type {number}
	     */
	    this.damping = options.damping || 1;
	
	    /**
	     * First connected body.
	     * @property bodyA
	     * @type {Body}
	     */
	    this.bodyA = bodyA;
	
	    /**
	     * Second connected body.
	     * @property bodyB
	     * @type {Body}
	     */
	    this.bodyB = bodyB;
	
	    /**
	     * Anchor for bodyA in local bodyA coordinates.
	     * @property localAnchorA
	     * @type {Vec3}
	     */
	    this.localAnchorA = new Vec3();
	
	    /**
	     * Anchor for bodyB in local bodyB coordinates.
	     * @property localAnchorB
	     * @type {Vec3}
	     */
	    this.localAnchorB = new Vec3();
	
	    if(options.localAnchorA){
	        this.localAnchorA.copy(options.localAnchorA);
	    }
	    if(options.localAnchorB){
	        this.localAnchorB.copy(options.localAnchorB);
	    }
	    if(options.worldAnchorA){
	        this.setWorldAnchorA(options.worldAnchorA);
	    }
	    if(options.worldAnchorB){
	        this.setWorldAnchorB(options.worldAnchorB);
	    }
	}
	
	/**
	 * Set the anchor point on body A, using world coordinates.
	 * @method setWorldAnchorA
	 * @param {Vec3} worldAnchorA
	 */
	Spring.prototype.setWorldAnchorA = function(worldAnchorA){
	    this.bodyA.pointToLocalFrame(worldAnchorA,this.localAnchorA);
	};
	
	/**
	 * Set the anchor point on body B, using world coordinates.
	 * @method setWorldAnchorB
	 * @param {Vec3} worldAnchorB
	 */
	Spring.prototype.setWorldAnchorB = function(worldAnchorB){
	    this.bodyB.pointToLocalFrame(worldAnchorB,this.localAnchorB);
	};
	
	/**
	 * Get the anchor point on body A, in world coordinates.
	 * @method getWorldAnchorA
	 * @param {Vec3} result The vector to store the result in.
	 */
	Spring.prototype.getWorldAnchorA = function(result){
	    this.bodyA.pointToWorldFrame(this.localAnchorA,result);
	};
	
	/**
	 * Get the anchor point on body B, in world coordinates.
	 * @method getWorldAnchorB
	 * @param {Vec3} result The vector to store the result in.
	 */
	Spring.prototype.getWorldAnchorB = function(result){
	    this.bodyB.pointToWorldFrame(this.localAnchorB,result);
	};
	
	var applyForce_r =              new Vec3(),
	    applyForce_r_unit =         new Vec3(),
	    applyForce_u =              new Vec3(),
	    applyForce_f =              new Vec3(),
	    applyForce_worldAnchorA =   new Vec3(),
	    applyForce_worldAnchorB =   new Vec3(),
	    applyForce_ri =             new Vec3(),
	    applyForce_rj =             new Vec3(),
	    applyForce_ri_x_f =         new Vec3(),
	    applyForce_rj_x_f =         new Vec3(),
	    applyForce_tmp =            new Vec3();
	
	/**
	 * Apply the spring force to the connected bodies.
	 * @method applyForce
	 */
	Spring.prototype.applyForce = function(){
	    var k = this.stiffness,
	        d = this.damping,
	        l = this.restLength,
	        bodyA = this.bodyA,
	        bodyB = this.bodyB,
	        r = applyForce_r,
	        r_unit = applyForce_r_unit,
	        u = applyForce_u,
	        f = applyForce_f,
	        tmp = applyForce_tmp;
	
	    var worldAnchorA = applyForce_worldAnchorA,
	        worldAnchorB = applyForce_worldAnchorB,
	        ri = applyForce_ri,
	        rj = applyForce_rj,
	        ri_x_f = applyForce_ri_x_f,
	        rj_x_f = applyForce_rj_x_f;
	
	    // Get world anchors
	    this.getWorldAnchorA(worldAnchorA);
	    this.getWorldAnchorB(worldAnchorB);
	
	    // Get offset points
	    worldAnchorA.vsub(bodyA.position,ri);
	    worldAnchorB.vsub(bodyB.position,rj);
	
	    // Compute distance vector between world anchor points
	    worldAnchorB.vsub(worldAnchorA,r);
	    var rlen = r.norm();
	    r_unit.copy(r);
	    r_unit.normalize();
	
	    // Compute relative velocity of the anchor points, u
	    bodyB.velocity.vsub(bodyA.velocity,u);
	    // Add rotational velocity
	
	    bodyB.angularVelocity.cross(rj,tmp);
	    u.vadd(tmp,u);
	    bodyA.angularVelocity.cross(ri,tmp);
	    u.vsub(tmp,u);
	
	    // F = - k * ( x - L ) - D * ( u )
	    r_unit.mult(-k*(rlen-l) - d*u.dot(r_unit), f);
	
	    // Add forces to bodies
	    bodyA.force.vsub(f,bodyA.force);
	    bodyB.force.vadd(f,bodyB.force);
	
	    // Angular force
	    ri.cross(f,ri_x_f);
	    rj.cross(f,rj_x_f);
	    bodyA.tau.vsub(ri_x_f,bodyA.tau);
	    bodyB.tau.vadd(rj_x_f,bodyB.tau);
	};
	
	},{"../math/Vec3":27}],33:[function(_dereq_,module,exports){
	var Vec3 = _dereq_('../math/Vec3');
	var Transform = _dereq_('../math/Transform');
	var RaycastResult = _dereq_('../collision/RaycastResult');
	var Utils = _dereq_('../utils/Utils');
	
	module.exports = WheelInfo;
	
	/**
	 * @class WheelInfo
	 * @constructor
	 * @param {Object} [options]
	 *
	 * @param {Vec3} [options.chassisConnectionPointLocal]
	 * @param {Vec3} [options.chassisConnectionPointWorld]
	 * @param {Vec3} [options.directionLocal]
	 * @param {Vec3} [options.directionWorld]
	 * @param {Vec3} [options.axleLocal]
	 * @param {Vec3} [options.axleWorld]
	 * @param {number} [options.suspensionRestLength=1]
	 * @param {number} [options.suspensionMaxLength=2]
	 * @param {number} [options.radius=1]
	 * @param {number} [options.suspensionStiffness=100]
	 * @param {number} [options.dampingCompression=10]
	 * @param {number} [options.dampingRelaxation=10]
	 * @param {number} [options.frictionSlip=10000]
	 * @param {number} [options.steering=0]
	 * @param {number} [options.rotation=0]
	 * @param {number} [options.deltaRotation=0]
	 * @param {number} [options.rollInfluence=0.01]
	 * @param {number} [options.maxSuspensionForce]
	 * @param {number} [options.isFrontWheel=true]
	 * @param {number} [options.clippedInvContactDotSuspension=1]
	 * @param {number} [options.suspensionRelativeVelocity=0]
	 * @param {number} [options.suspensionForce=0]
	 * @param {number} [options.skidInfo=0]
	 * @param {number} [options.suspensionLength=0]
	 * @param {number} [options.maxSuspensionTravel=1]
	 * @param {number} [options.useCustomSlidingRotationalSpeed=false]
	 * @param {number} [options.customSlidingRotationalSpeed=-0.1]
	 */
	function WheelInfo(options){
	    options = Utils.defaults(options, {
	        chassisConnectionPointLocal: new Vec3(),
	        chassisConnectionPointWorld: new Vec3(),
	        directionLocal: new Vec3(),
	        directionWorld: new Vec3(),
	        axleLocal: new Vec3(),
	        axleWorld: new Vec3(),
	        suspensionRestLength: 1,
	        suspensionMaxLength: 2,
	        radius: 1,
	        suspensionStiffness: 100,
	        dampingCompression: 10,
	        dampingRelaxation: 10,
	        frictionSlip: 10000,
	        steering: 0,
	        rotation: 0,
	        deltaRotation: 0,
	        rollInfluence: 0.01,
	        maxSuspensionForce: Number.MAX_VALUE,
	        isFrontWheel: true,
	        clippedInvContactDotSuspension: 1,
	        suspensionRelativeVelocity: 0,
	        suspensionForce: 0,
	        skidInfo: 0,
	        suspensionLength: 0,
	        maxSuspensionTravel: 1,
	        useCustomSlidingRotationalSpeed: false,
	        customSlidingRotationalSpeed: -0.1
	    });
	
	    /**
	     * @property {number} maxSuspensionTravel
	     */
	    this.maxSuspensionTravel = options.maxSuspensionTravel;
	
	    /**
	     * @property {number} customSlidingRotationalSpeed
	     */
	    this.customSlidingRotationalSpeed = options.customSlidingRotationalSpeed;
	
	    /**
	     * @property {Boolean} useCustomSlidingRotationalSpeed]
	     */
	    this.useCustomSlidingRotationalSpeed = options.useCustomSlidingRotationalSpeed;
	
	    /**
	     * @property {Boolean} sliding
	     */
	    this.sliding = false;
	
	    /**
	     * @property {Vec3} chassisConnectionPointLocal
	     */
	    this.chassisConnectionPointLocal = options.chassisConnectionPointLocal.clone();
	
	    /**
	     * @property {Vec3} chassisConnectionPointWorld
	     */
	    this.chassisConnectionPointWorld = options.chassisConnectionPointWorld.clone();
	
	    /**
	     * @property {Vec3} directionLocal
	     */
	    this.directionLocal = options.directionLocal.clone();
	
	    /**
	     * @property {Vec3} directionWorld
	     */
	    this.directionWorld = options.directionWorld.clone();
	
	    /**
	     * @property {Vec3} axleLocal
	     */
	    this.axleLocal = options.axleLocal.clone();
	
	    /**
	     * @property {Vec3} axleWorld
	     */
	    this.axleWorld = options.axleWorld.clone();
	
	    /**
	     * @property {number} suspensionRestLength
	     */
	    this.suspensionRestLength = options.suspensionRestLength;
	
	    /**
	     * @property {number} suspensionMaxLength
	     */
	    this.suspensionMaxLength = options.suspensionMaxLength;
	
	    /**
	     * @property {number} radius
	     */
	    this.radius = options.radius;
	
	    /**
	     * @property {number} suspensionStiffness
	     */
	    this.suspensionStiffness = options.suspensionStiffness;
	
	    /**
	     * @property {number} dampingCompression
	     */
	    this.dampingCompression = options.dampingCompression;
	
	    /**
	     * @property {number} dampingRelaxation
	     */
	    this.dampingRelaxation = options.dampingRelaxation;
	
	    /**
	     * @property {number} frictionSlip
	     */
	    this.frictionSlip = options.frictionSlip;
	
	    /**
	     * @property {number} steering
	     */
	    this.steering = 0;
	
	    /**
	     * @property {number} rotation
	     */
	    this.rotation = 0;
	
	    /**
	     * @property {number} deltaRotation
	     */
	    this.deltaRotation = 0;
	
	    /**
	     * @property {number} rollInfluence
	     */
	    this.rollInfluence = options.rollInfluence;
	
	    /**
	     * @property {number} maxSuspensionForce
	     */
	    this.maxSuspensionForce = options.maxSuspensionForce;
	
	    /**
	     * @property {number} engineForce
	     */
	    this.engineForce = 0;
	
	    /**
	     * @property {number} brake
	     */
	    this.brake = 0;
	
	    /**
	     * @property {number} isFrontWheel
	     */
	    this.isFrontWheel = options.isFrontWheel;
	
	    /**
	     * @property {number} clippedInvContactDotSuspension
	     */
	    this.clippedInvContactDotSuspension = 1;
	
	    /**
	     * @property {number} suspensionRelativeVelocity
	     */
	    this.suspensionRelativeVelocity = 0;
	
	    /**
	     * @property {number} suspensionForce
	     */
	    this.suspensionForce = 0;
	
	    /**
	     * @property {number} skidInfo
	     */
	    this.skidInfo = 0;
	
	    /**
	     * @property {number} suspensionLength
	     */
	    this.suspensionLength = 0;
	
	    /**
	     * @property {number} sideImpulse
	     */
	    this.sideImpulse = 0;
	
	    /**
	     * @property {number} forwardImpulse
	     */
	    this.forwardImpulse = 0;
	
	    /**
	     * The result from raycasting
	     * @property {RaycastResult} raycastResult
	     */
	    this.raycastResult = new RaycastResult();
	
	    /**
	     * Wheel world transform
	     * @property {Transform} worldTransform
	     */
	    this.worldTransform = new Transform();
	
	    /**
	     * @property {boolean} isInContact
	     */
	    this.isInContact = false;
	}
	
	var chassis_velocity_at_contactPoint = new Vec3();
	var relpos = new Vec3();
	var chassis_velocity_at_contactPoint = new Vec3();
	WheelInfo.prototype.updateWheel = function(chassis){
	    var raycastResult = this.raycastResult;
	
	    if (this.isInContact){
	        var project= raycastResult.hitNormalWorld.dot(raycastResult.directionWorld);
	        raycastResult.hitPointWorld.vsub(chassis.position, relpos);
	        chassis.getVelocityAtWorldPoint(relpos, chassis_velocity_at_contactPoint);
	        var projVel = raycastResult.hitNormalWorld.dot( chassis_velocity_at_contactPoint );
	        if (project >= -0.1) {
	            this.suspensionRelativeVelocity = 0.0;
	            this.clippedInvContactDotSuspension = 1.0 / 0.1;
	        } else {
	            var inv = -1 / project;
	            this.suspensionRelativeVelocity = projVel * inv;
	            this.clippedInvContactDotSuspension = inv;
	        }
	
	    } else {
	        // Not in contact : position wheel in a nice (rest length) position
	        raycastResult.suspensionLength = this.suspensionRestLength;
	        this.suspensionRelativeVelocity = 0.0;
	        raycastResult.directionWorld.scale(-1, raycastResult.hitNormalWorld);
	        this.clippedInvContactDotSuspension = 1.0;
	    }
	};
	},{"../collision/RaycastResult":10,"../math/Transform":26,"../math/Vec3":27,"../utils/Utils":48}],34:[function(_dereq_,module,exports){
	module.exports = Box;
	
	var Shape = _dereq_('./Shape');
	var Vec3 = _dereq_('../math/Vec3');
	var ConvexPolyhedron = _dereq_('./ConvexPolyhedron');
	
	/**
	 * A 3d box shape.
	 * @class Box
	 * @constructor
	 * @param {Vec3} halfExtents
	 * @author schteppe
	 * @extends Shape
	 */
	function Box(halfExtents){
	    Shape.call(this);
	
	    this.type = Shape.types.BOX;
	
	    /**
	     * @property halfExtents
	     * @type {Vec3}
	     */
	    this.halfExtents = halfExtents;
	
	    /**
	     * Used by the contact generator to make contacts with other convex polyhedra for example
	     * @property convexPolyhedronRepresentation
	     * @type {ConvexPolyhedron}
	     */
	    this.convexPolyhedronRepresentation = null;
	
	    this.updateConvexPolyhedronRepresentation();
	    this.updateBoundingSphereRadius();
	}
	Box.prototype = new Shape();
	Box.prototype.constructor = Box;
	
	/**
	 * Updates the local convex polyhedron representation used for some collisions.
	 * @method updateConvexPolyhedronRepresentation
	 */
	Box.prototype.updateConvexPolyhedronRepresentation = function(){
	    var sx = this.halfExtents.x;
	    var sy = this.halfExtents.y;
	    var sz = this.halfExtents.z;
	    var V = Vec3;
	
	    var h = new ConvexPolyhedron([new V(-sx,-sy,-sz),
	                                         new V( sx,-sy,-sz),
	                                         new V( sx, sy,-sz),
	                                         new V(-sx, sy,-sz),
	                                         new V(-sx,-sy, sz),
	                                         new V( sx,-sy, sz),
	                                         new V( sx, sy, sz),
	                                         new V(-sx, sy, sz)],
	                                         [[3,2,1,0], // -z
	                                          [4,5,6,7], // +z
	                                          [5,4,0,1], // -y
	                                          [2,3,7,6], // +y
	                                          [0,4,7,3], // -x
	                                          [1,2,6,5], // +x
	                                          ],
	                                        [new V( 0, 0,-1),
	                                         new V( 0, 0, 1),
	                                         new V( 0,-1, 0),
	                                         new V( 0, 1, 0),
	                                         new V(-1, 0, 0),
	                                         new V( 1, 0, 0)]);
	    this.convexPolyhedronRepresentation = h;
	};
	
	/**
	 * @method calculateLocalInertia
	 * @param  {Number} mass
	 * @param  {Vec3} target
	 * @return {Vec3}
	 */
	Box.prototype.calculateLocalInertia = function(mass,target){
	    target = target || new Vec3();
	    Box.calculateInertia(this.halfExtents, mass, target);
	    return target;
	};
	
	Box.calculateInertia = function(halfExtents,mass,target){
	    var e = halfExtents;
	    target.x = 1.0 / 12.0 * mass * (   2*e.y*2*e.y + 2*e.z*2*e.z );
	    target.y = 1.0 / 12.0 * mass * (   2*e.x*2*e.x + 2*e.z*2*e.z );
	    target.z = 1.0 / 12.0 * mass * (   2*e.y*2*e.y + 2*e.x*2*e.x );
	};
	
	/**
	 * Get the box 6 side normals
	 * @method getSideNormals
	 * @param {Boolean}     includeNegative If true, this function returns 6 vectors. If false, it only returns 3 (but you get 6 by reversing those 3)
	 * @param {Quaternion}  quat            Orientation to apply to the normal vectors. If not provided, the vectors will be in respect to the local frame.
	 * @return {array}
	 */
	Box.prototype.getSideNormals = function(sixTargetVectors,quat){
	    var sides = sixTargetVectors;
	    var ex = this.halfExtents;
	    sides[0].set(  ex.x,     0,     0);
	    sides[1].set(     0,  ex.y,     0);
	    sides[2].set(     0,     0,  ex.z);
	    sides[3].set( -ex.x,     0,     0);
	    sides[4].set(     0, -ex.y,     0);
	    sides[5].set(     0,     0, -ex.z);
	
	    if(quat!==undefined){
	        for(var i=0; i!==sides.length; i++){
	            quat.vmult(sides[i],sides[i]);
	        }
	    }
	
	    return sides;
	};
	
	Box.prototype.volume = function(){
	    return 8.0 * this.halfExtents.x * this.halfExtents.y * this.halfExtents.z;
	};
	
	Box.prototype.updateBoundingSphereRadius = function(){
	    this.boundingSphereRadius = this.halfExtents.norm();
	};
	
	var worldCornerTempPos = new Vec3();
	var worldCornerTempNeg = new Vec3();
	Box.prototype.forEachWorldCorner = function(pos,quat,callback){
	
	    var e = this.halfExtents;
	    var corners = [[  e.x,  e.y,  e.z],
	                   [ -e.x,  e.y,  e.z],
	                   [ -e.x, -e.y,  e.z],
	                   [ -e.x, -e.y, -e.z],
	                   [  e.x, -e.y, -e.z],
	                   [  e.x,  e.y, -e.z],
	                   [ -e.x,  e.y, -e.z],
	                   [  e.x, -e.y,  e.z]];
	    for(var i=0; i<corners.length; i++){
	        worldCornerTempPos.set(corners[i][0],corners[i][1],corners[i][2]);
	        quat.vmult(worldCornerTempPos,worldCornerTempPos);
	        pos.vadd(worldCornerTempPos,worldCornerTempPos);
	        callback(worldCornerTempPos.x,
	                 worldCornerTempPos.y,
	                 worldCornerTempPos.z);
	    }
	};
	
	var worldCornersTemp = [
	    new Vec3(),
	    new Vec3(),
	    new Vec3(),
	    new Vec3(),
	    new Vec3(),
	    new Vec3(),
	    new Vec3(),
	    new Vec3()
	];
	Box.prototype.calculateWorldAABB = function(pos,quat,min,max){
	
	    var e = this.halfExtents;
	    worldCornersTemp[0].set(e.x, e.y, e.z);
	    worldCornersTemp[1].set(-e.x,  e.y, e.z);
	    worldCornersTemp[2].set(-e.x, -e.y, e.z);
	    worldCornersTemp[3].set(-e.x, -e.y, -e.z);
	    worldCornersTemp[4].set(e.x, -e.y, -e.z);
	    worldCornersTemp[5].set(e.x,  e.y, -e.z);
	    worldCornersTemp[6].set(-e.x,  e.y, -e.z);
	    worldCornersTemp[7].set(e.x, -e.y,  e.z);
	
	    var wc = worldCornersTemp[0];
	    quat.vmult(wc, wc);
	    pos.vadd(wc, wc);
	    max.copy(wc);
	    min.copy(wc);
	    for(var i=1; i<8; i++){
	        var wc = worldCornersTemp[i];
	        quat.vmult(wc, wc);
	        pos.vadd(wc, wc);
	        var x = wc.x;
	        var y = wc.y;
	        var z = wc.z;
	        if(x > max.x){
	            max.x = x;
	        }
	        if(y > max.y){
	            max.y = y;
	        }
	        if(z > max.z){
	            max.z = z;
	        }
	
	        if(x < min.x){
	            min.x = x;
	        }
	        if(y < min.y){
	            min.y = y;
	        }
	        if(z < min.z){
	            min.z = z;
	        }
	    }
	
	    // Get each axis max
	    // min.set(Infinity,Infinity,Infinity);
	    // max.set(-Infinity,-Infinity,-Infinity);
	    // this.forEachWorldCorner(pos,quat,function(x,y,z){
	    //     if(x > max.x){
	    //         max.x = x;
	    //     }
	    //     if(y > max.y){
	    //         max.y = y;
	    //     }
	    //     if(z > max.z){
	    //         max.z = z;
	    //     }
	
	    //     if(x < min.x){
	    //         min.x = x;
	    //     }
	    //     if(y < min.y){
	    //         min.y = y;
	    //     }
	    //     if(z < min.z){
	    //         min.z = z;
	    //     }
	    // });
	};
	
	},{"../math/Vec3":27,"./ConvexPolyhedron":35,"./Shape":40}],35:[function(_dereq_,module,exports){
	module.exports = ConvexPolyhedron;
	
	var Shape = _dereq_('./Shape');
	var Vec3 = _dereq_('../math/Vec3');
	var Quaternion = _dereq_('../math/Quaternion');
	var Transform = _dereq_('../math/Transform');
	
	/**
	 * A set of polygons describing a convex shape.
	 * @class ConvexPolyhedron
	 * @constructor
	 * @extends Shape
	 * @description The shape MUST be convex for the code to work properly. No polygons may be coplanar (contained
	 * in the same 3D plane), instead these should be merged into one polygon.
	 *
	 * @param {array} points An array of Vec3's
	 * @param {array} faces Array of integer arrays, describing which vertices that is included in each face.
	 * @param {array} normals Deprecated. Normals are now automatically generated from polygons.
	 *
	 * @author qiao / https://github.com/qiao (original author, see https://github.com/qiao/three.js/commit/85026f0c769e4000148a67d45a9e9b9c5108836f)
	 * @author schteppe / https://github.com/schteppe
	 * @see http://www.altdevblogaday.com/2011/05/13/contact-generation-between-3d-convex-meshes/
	 * @see http://bullet.googlecode.com/svn/trunk/src/BulletCollision/NarrowPhaseCollision/btPolyhedralContactClipping.cpp
	 *
	 * @todo Move the clipping functions to ContactGenerator?
	 * @todo Automatically merge coplanar polygons in constructor.
	 */
	function ConvexPolyhedron( points , faces , normals ) {
	    var that = this;
	    Shape.call( this );
	    this.type = Shape.types.CONVEXPOLYHEDRON;
	
	    /**
	     * Array of Vec3
	     * @property vertices
	     * @type {Array}
	     */
	    this.vertices = points||[];
	
	    this.worldVertices = []; // World transformed version of .vertices
	    this.worldVerticesNeedsUpdate = true;
	
	    /**
	     * Array of integer arrays, indicating which vertices each face consists of
	     * @property faces
	     * @type {Array}
	     */
	    this.faces = faces||[];
	
	    /**
	     * Array of Vec3
	     * @property faceNormals
	     * @type {Array}
	     */
	    this.faceNormals = [];
	    this.computeNormals();
	
	    this.worldFaceNormalsNeedsUpdate = true;
	    this.worldFaceNormals = []; // World transformed version of .faceNormals
	
	    /**
	     * Array of Vec3
	     * @property uniqueEdges
	     * @type {Array}
	     */
	    this.uniqueEdges = [];
	
	    this.computeEdges();
	    this.updateBoundingSphereRadius();
	}
	ConvexPolyhedron.prototype = new Shape();
	ConvexPolyhedron.prototype.constructor = ConvexPolyhedron;
	
	/**
	 * Computes uniqueEdges
	 * @method computeEdges
	 */
	ConvexPolyhedron.prototype.computeEdges = function(){
	    var faces = this.faces;
	    var vertices = this.vertices;
	    var nv = vertices.length;
	    var edges = this.uniqueEdges;
	
	    edges.length = 0;
	
	    for(var pi=0; pi<nv; pi++){
	        var p = vertices[pi];
	        if(!(p instanceof Vec3)){
	            throw "Argument 1 must be instance of Vec3";
	        }
	        this.uniqueEdges.push(p);
	    }
	
	    for(var i=0; i<faces.length; i++){
	        var face = faces[i];
	        var numVertices = face.length;
	        for(var j = 0; j < numVertices; j++){
	            var k = ( j+1 ) % numVertices;
	            var edge = new Vec3();
	            vertices[face[j]].vsub(vertices[face[k]], edge);
	            edge.normalize();
	            var found = false;
	            for(var p=0; p < edges.length; p++){
	                if (edges[p].almostEquals(edge) || edges[p].almostEquals(edge)){
	                    found = true;
	                    break;
	                }
	            }
	
	            if (!found){
	                edges.push(edge);
	            }
	
	            if (edge) {
	                edge.face1 = i;
	            } else {
	                /*
	                var ed;
	                ed.m_face0 = i;
	                edges.insert(vp,ed);
	                 */
	            }
	        }
	    }
	};
	
	/**
	 * Compute the normals of the faces. Will reuse existing Vec3 objects in the .faceNormals array if they exist.
	 * @method computeNormals
	 */
	ConvexPolyhedron.prototype.computeNormals = function(){
	    this.faceNormals.length = this.faces.length;
	
	    // Generate normals
	    for(var i=0; i<this.faces.length; i++){
	
	        // Check so all vertices exists for this face
	        for(var j=0; j<this.faces[i].length; j++){
	            if(!this.vertices[this.faces[i][j]]){
	                throw new Error("Vertex "+this.faces[i][j]+" not found!");
	            }
	        }
	
	        var n = this.faceNormals[i] || new Vec3();
	        this.getFaceNormal(i,n);
	        n.negate(n);
	        this.faceNormals[i] = n;
	        var vertex = this.vertices[this.faces[i][0]];
	        if(n.dot(vertex) < 0){
	            console.error(".faceNormals[" + i + "] = Vec3("+n.toString()+") looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.");
	            for(var j=0; j<this.faces[i].length; j++){
	                console.warn(".vertices["+this.faces[i][j]+"] = Vec3("+this.vertices[this.faces[i][j]].toString()+")");
	            }
	        }
	    }
	};
	
	/**
	 * Get face normal given 3 vertices
	 * @static
	 * @method getFaceNormal
	 * @param {Vec3} va
	 * @param {Vec3} vb
	 * @param {Vec3} vc
	 * @param {Vec3} target
	 */
	var cb = new Vec3();
	var ab = new Vec3();
	ConvexPolyhedron.computeNormal = function ( va, vb, vc, target ) {
	    vb.vsub(va,ab);
	    vc.vsub(vb,cb);
	    cb.cross(ab,target);
	    if ( !target.isZero() ) {
	        target.normalize();
	    }
	};
	
	/**
	 * Compute the normal of a face from its vertices
	 * @method getFaceNormal
	 * @param  {Number} i
	 * @param  {Vec3} target
	 */
	ConvexPolyhedron.prototype.getFaceNormal = function(i,target){
	    var f = this.faces[i];
	    var va = this.vertices[f[0]];
	    var vb = this.vertices[f[1]];
	    var vc = this.vertices[f[2]];
	    return ConvexPolyhedron.computeNormal(va,vb,vc,target);
	};
	
	/**
	 * @method clipAgainstHull
	 * @param {Vec3} posA
	 * @param {Quaternion} quatA
	 * @param {ConvexPolyhedron} hullB
	 * @param {Vec3} posB
	 * @param {Quaternion} quatB
	 * @param {Vec3} separatingNormal
	 * @param {Number} minDist Clamp distance
	 * @param {Number} maxDist
	 * @param {array} result The an array of contact point objects, see clipFaceAgainstHull
	 * @see http://bullet.googlecode.com/svn/trunk/src/BulletCollision/NarrowPhaseCollision/btPolyhedralContactClipping.cpp
	 */
	var cah_WorldNormal = new Vec3();
	ConvexPolyhedron.prototype.clipAgainstHull = function(posA,quatA,hullB,posB,quatB,separatingNormal,minDist,maxDist,result){
	    var WorldNormal = cah_WorldNormal;
	    if(!(posA instanceof Vec3)){
	        throw new Error("posA must be Vec3");
	    }
	    if(!(quatA instanceof Quaternion)){
	        throw new Error("quatA must be Quaternion");
	    }
	    var hullA = this;
	    var curMaxDist = maxDist;
	    var closestFaceB = -1;
	    var dmax = -Infinity;
	    for(var face=0; face < hullB.faces.length; face++){
	        WorldNormal.copy(hullB.faceNormals[face]);
	        quatB.vmult(WorldNormal,WorldNormal);
	        //posB.vadd(WorldNormal,WorldNormal);
	        var d = WorldNormal.dot(separatingNormal);
	        if (d > dmax){
	            dmax = d;
	            closestFaceB = face;
	        }
	    }
	    var worldVertsB1 = [];
	    var polyB = hullB.faces[closestFaceB];
	    var numVertices = polyB.length;
	    for(var e0=0; e0<numVertices; e0++){
	        var b = hullB.vertices[polyB[e0]];
	        var worldb = new Vec3();
	        worldb.copy(b);
	        quatB.vmult(worldb,worldb);
	        posB.vadd(worldb,worldb);
	        worldVertsB1.push(worldb);
	    }
	
	    if (closestFaceB>=0){
	        this.clipFaceAgainstHull(separatingNormal,
	                                 posA,
	                                 quatA,
	                                 worldVertsB1,
	                                 minDist,
	                                 maxDist,
	                                 result);
	    }
	};
	
	/**
	 * Find the separating axis between this hull and another
	 * @method findSeparatingAxis
	 * @param {ConvexPolyhedron} hullB
	 * @param {Vec3} posA
	 * @param {Quaternion} quatA
	 * @param {Vec3} posB
	 * @param {Quaternion} quatB
	 * @param {Vec3} target The target vector to save the axis in
	 * @return {bool} Returns false if a separation is found, else true
	 */
	var fsa_faceANormalWS3 = new Vec3(),
	    fsa_Worldnormal1 = new Vec3(),
	    fsa_deltaC = new Vec3(),
	    fsa_worldEdge0 = new Vec3(),
	    fsa_worldEdge1 = new Vec3(),
	    fsa_Cross = new Vec3();
	ConvexPolyhedron.prototype.findSeparatingAxis = function(hullB,posA,quatA,posB,quatB,target){
	    var faceANormalWS3 = fsa_faceANormalWS3,
	        Worldnormal1 = fsa_Worldnormal1,
	        deltaC = fsa_deltaC,
	        worldEdge0 = fsa_worldEdge0,
	        worldEdge1 = fsa_worldEdge1,
	        Cross = fsa_Cross;
	
	    var dmin = Infinity;
	    var hullA = this;
	    var curPlaneTests=0;
	    var numFacesA = hullA.faces.length;
	
	    // Test normals from hullA
	    for(var i=0; i<numFacesA; i++){
	        // Get world face normal
	        faceANormalWS3.copy(hullA.faceNormals[i]);
	        quatA.vmult(faceANormalWS3,faceANormalWS3);
	        //posA.vadd(faceANormalWS3,faceANormalWS3); // Needed?
	        //console.log("face normal:",hullA.faceNormals[i].toString(),"world face normal:",faceANormalWS3);
	        var d = hullA.testSepAxis(faceANormalWS3, hullB, posA, quatA, posB, quatB);
	        if(d===false){
	            return false;
	        }
	
	        if(d<dmin){
	            dmin = d;
	            target.copy(faceANormalWS3);
	        }
	    }
	
	    // Test normals from hullB
	    var numFacesB = hullB.faces.length;
	    for(var i=0;i<numFacesB;i++){
	        Worldnormal1.copy(hullB.faceNormals[i]);
	        quatB.vmult(Worldnormal1,Worldnormal1);
	        //posB.vadd(Worldnormal1,Worldnormal1);
	        //console.log("facenormal",hullB.faceNormals[i].toString(),"world:",Worldnormal1.toString());
	        curPlaneTests++;
	        var d = hullA.testSepAxis(Worldnormal1, hullB,posA,quatA,posB,quatB);
	        if(d===false){
	            return false;
	        }
	
	        if(d<dmin){
	            dmin = d;
	            target.copy(Worldnormal1);
	        }
	    }
	
	    var edgeAstart,edgeAend,edgeBstart,edgeBend;
	
	    var curEdgeEdge = 0;
	    // Test edges
	    for(var e0=0; e0<hullA.uniqueEdges.length; e0++){
	        // Get world edge
	        worldEdge0.copy(hullA.uniqueEdges[e0]);
	        quatA.vmult(worldEdge0,worldEdge0);
	        //posA.vadd(worldEdge0,worldEdge0); // needed?
	
	        //console.log("edge0:",worldEdge0.toString());
	
	        for(var e1=0; e1<hullB.uniqueEdges.length; e1++){
	            worldEdge1.copy(hullB.uniqueEdges[e1]);
	            quatB.vmult(worldEdge1,worldEdge1);
	            //posB.vadd(worldEdge1,worldEdge1); // needed?
	            //console.log("edge1:",worldEdge1.toString());
	            worldEdge0.cross(worldEdge1,Cross);
	            curEdgeEdge++;
	            if(!Cross.almostZero()){
	                Cross.normalize();
	                var dist = hullA.testSepAxis( Cross, hullB, posA,quatA,posB,quatB);
	                if(dist===false){
	                    return false;
	                }
	                if(dist<dmin){
	                    dmin = dist;
	                    target.copy(Cross);
	                }
	            }
	        }
	    }
	
	    posB.vsub(posA,deltaC);
	    if((deltaC.dot(target))>0.0){
	        target.negate(target);
	    }
	    return true;
	};
	
	/**
	 * Test separating axis against two hulls. Both hulls are projected onto the axis and the overlap size is returned if there is one.
	 * @method testSepAxis
	 * @param {Vec3} axis
	 * @param {ConvexPolyhedron} hullB
	 * @param {Vec3} posA
	 * @param {Quaternion} quatA
	 * @param {Vec3} posB
	 * @param {Quaternion} quatB
	 * @return {float} The overlap depth, or FALSE if no penetration.
	 */
	ConvexPolyhedron.prototype.testSepAxis = function(axis, hullB, posA, quatA, posB, quatB){
	    var maxminA=[], maxminB=[], hullA=this;
	    ConvexPolyhedron.project(hullA, axis, posA, quatA, maxminA);
	    ConvexPolyhedron.project(hullB, axis, posB, quatB, maxminB);
	    var maxA = maxminA[0];
	    var minA = maxminA[1];
	    var maxB = maxminB[0];
	    var minB = maxminB[1];
	    if(maxA<minB || maxB<minA){
	        //console.log(minA,maxA,minB,maxB);
	        return false; // Separated
	    }
	    var d0 = maxA - minB;
	    var d1 = maxB - minA;
	    var depth = d0<d1 ? d0:d1;
	    return depth;
	};
	
	var cli_aabbmin = new Vec3(),
	    cli_aabbmax = new Vec3();
	
	/**
	 * @method calculateLocalInertia
	 * @param  {Number} mass
	 * @param  {Vec3} target
	 */
	ConvexPolyhedron.prototype.calculateLocalInertia = function(mass,target){
	    // Approximate with box inertia
	    // Exact inertia calculation is overkill, but see http://geometrictools.com/Documentation/PolyhedralMassProperties.pdf for the correct way to do it
	    this.computeLocalAABB(cli_aabbmin,cli_aabbmax);
	    var x = cli_aabbmax.x - cli_aabbmin.x,
	        y = cli_aabbmax.y - cli_aabbmin.y,
	        z = cli_aabbmax.z - cli_aabbmin.z;
	    target.x = 1.0 / 12.0 * mass * ( 2*y*2*y + 2*z*2*z );
	    target.y = 1.0 / 12.0 * mass * ( 2*x*2*x + 2*z*2*z );
	    target.z = 1.0 / 12.0 * mass * ( 2*y*2*y + 2*x*2*x );
	};
	
	/**
	 * @method getPlaneConstantOfFace
	 * @param  {Number} face_i Index of the face
	 * @return {Number}
	 */
	ConvexPolyhedron.prototype.getPlaneConstantOfFace = function(face_i){
	    var f = this.faces[face_i];
	    var n = this.faceNormals[face_i];
	    var v = this.vertices[f[0]];
	    var c = -n.dot(v);
	    return c;
	};
	
	/**
	 * Clip a face against a hull.
	 * @method clipFaceAgainstHull
	 * @param {Vec3} separatingNormal
	 * @param {Vec3} posA
	 * @param {Quaternion} quatA
	 * @param {Array} worldVertsB1 An array of Vec3 with vertices in the world frame.
	 * @param {Number} minDist Distance clamping
	 * @param {Number} maxDist
	 * @param Array result Array to store resulting contact points in. Will be objects with properties: point, depth, normal. These are represented in world coordinates.
	 */
	var cfah_faceANormalWS = new Vec3(),
	    cfah_edge0 = new Vec3(),
	    cfah_WorldEdge0 = new Vec3(),
	    cfah_worldPlaneAnormal1 = new Vec3(),
	    cfah_planeNormalWS1 = new Vec3(),
	    cfah_worldA1 = new Vec3(),
	    cfah_localPlaneNormal = new Vec3(),
	    cfah_planeNormalWS = new Vec3();
	ConvexPolyhedron.prototype.clipFaceAgainstHull = function(separatingNormal, posA, quatA, worldVertsB1, minDist, maxDist,result){
	    if(!(separatingNormal instanceof Vec3)){
	        throw new Error("sep normal must be vector");
	    }
	    if(!(worldVertsB1 instanceof Array)){
	        throw new Error("world verts must be array");
	    }
	
	    var faceANormalWS = cfah_faceANormalWS,
	        edge0 = cfah_edge0,
	        WorldEdge0 = cfah_WorldEdge0,
	        worldPlaneAnormal1 = cfah_worldPlaneAnormal1,
	        planeNormalWS1 = cfah_planeNormalWS1,
	        worldA1 = cfah_worldA1,
	        localPlaneNormal = cfah_localPlaneNormal,
	        planeNormalWS = cfah_planeNormalWS;
	
	    minDist = Number(minDist);
	    maxDist = Number(maxDist);
	    var hullA = this;
	    var worldVertsB2 = [];
	    var pVtxIn = worldVertsB1;
	    var pVtxOut = worldVertsB2;
	    // Find the face with normal closest to the separating axis
	    var closestFaceA = -1;
	    var dmin = Infinity;
	    for(var face=0; face<hullA.faces.length; face++){
	        faceANormalWS.copy(hullA.faceNormals[face]);
	        quatA.vmult(faceANormalWS,faceANormalWS);
	        //posA.vadd(faceANormalWS,faceANormalWS);
	        var d = faceANormalWS.dot(separatingNormal);
	        if (d < dmin){
	            dmin = d;
	            closestFaceA = face;
	        }
	    }
	    if (closestFaceA<0){
	        console.log("--- did not find any closest face... ---");
	        return;
	    }
	    //console.log("closest A: ",closestFaceA);
	    // Get the face and construct connected faces
	    var polyA = hullA.faces[closestFaceA];
	    polyA.connectedFaces = [];
	    for(var i=0; i<hullA.faces.length; i++){
	        for(var j=0; j<hullA.faces[i].length; j++){
	            if(polyA.indexOf(hullA.faces[i][j])!==-1 /* Sharing a vertex*/ && i!==closestFaceA /* Not the one we are looking for connections from */ && polyA.connectedFaces.indexOf(i)===-1 /* Not already added */ ){
	                polyA.connectedFaces.push(i);
	            }
	        }
	    }
	    // Clip the polygon to the back of the planes of all faces of hull A, that are adjacent to the witness face
	    var numContacts = pVtxIn.length;
	    var numVerticesA = polyA.length;
	    var res = [];
	    for(var e0=0; e0<numVerticesA; e0++){
	        var a = hullA.vertices[polyA[e0]];
	        var b = hullA.vertices[polyA[(e0+1)%numVerticesA]];
	        a.vsub(b,edge0);
	        WorldEdge0.copy(edge0);
	        quatA.vmult(WorldEdge0,WorldEdge0);
	        posA.vadd(WorldEdge0,WorldEdge0);
	        worldPlaneAnormal1.copy(this.faceNormals[closestFaceA]);//transA.getBasis()* btVector3(polyA.m_plane[0],polyA.m_plane[1],polyA.m_plane[2]);
	        quatA.vmult(worldPlaneAnormal1,worldPlaneAnormal1);
	        posA.vadd(worldPlaneAnormal1,worldPlaneAnormal1);
	        WorldEdge0.cross(worldPlaneAnormal1,planeNormalWS1);
	        planeNormalWS1.negate(planeNormalWS1);
	        worldA1.copy(a);
	        quatA.vmult(worldA1,worldA1);
	        posA.vadd(worldA1,worldA1);
	        var planeEqWS1 = -worldA1.dot(planeNormalWS1);
	        var planeEqWS;
	        if(true){
	            var otherFace = polyA.connectedFaces[e0];
	            localPlaneNormal.copy(this.faceNormals[otherFace]);
	            var localPlaneEq = this.getPlaneConstantOfFace(otherFace);
	
	            planeNormalWS.copy(localPlaneNormal);
	            quatA.vmult(planeNormalWS,planeNormalWS);
	            //posA.vadd(planeNormalWS,planeNormalWS);
	            var planeEqWS = localPlaneEq - planeNormalWS.dot(posA);
	        } else  {
	            planeNormalWS.copy(planeNormalWS1);
	            planeEqWS = planeEqWS1;
	        }
	
	        // Clip face against our constructed plane
	        this.clipFaceAgainstPlane(pVtxIn, pVtxOut, planeNormalWS, planeEqWS);
	
	        // Throw away all clipped points, but save the reamining until next clip
	        while(pVtxIn.length){
	            pVtxIn.shift();
	        }
	        while(pVtxOut.length){
	            pVtxIn.push(pVtxOut.shift());
	        }
	    }
	
	    //console.log("Resulting points after clip:",pVtxIn);
	
	    // only keep contact points that are behind the witness face
	    localPlaneNormal.copy(this.faceNormals[closestFaceA]);
	
	    var localPlaneEq = this.getPlaneConstantOfFace(closestFaceA);
	    planeNormalWS.copy(localPlaneNormal);
	    quatA.vmult(planeNormalWS,planeNormalWS);
	
	    var planeEqWS = localPlaneEq - planeNormalWS.dot(posA);
	    for (var i=0; i<pVtxIn.length; i++){
	        var depth = planeNormalWS.dot(pVtxIn[i]) + planeEqWS; //???
	        /*console.log("depth calc from normal=",planeNormalWS.toString()," and constant "+planeEqWS+" and vertex ",pVtxIn[i].toString()," gives "+depth);*/
	        if (depth <=minDist){
	            console.log("clamped: depth="+depth+" to minDist="+(minDist+""));
	            depth = minDist;
	        }
	
	        if (depth <=maxDist){
	            var point = pVtxIn[i];
	            if(depth<=0){
	                /*console.log("Got contact point ",point.toString(),
	                  ", depth=",depth,
	                  "contact normal=",separatingNormal.toString(),
	                  "plane",planeNormalWS.toString(),
	                  "planeConstant",planeEqWS);*/
	                var p = {
	                    point:point,
	                    normal:planeNormalWS,
	                    depth: depth,
	                };
	                result.push(p);
	            }
	        }
	    }
	};
	
	/**
	 * Clip a face in a hull against the back of a plane.
	 * @method clipFaceAgainstPlane
	 * @param {Array} inVertices
	 * @param {Array} outVertices
	 * @param {Vec3} planeNormal
	 * @param {Number} planeConstant The constant in the mathematical plane equation
	 */
	ConvexPolyhedron.prototype.clipFaceAgainstPlane = function(inVertices,outVertices, planeNormal, planeConstant){
	    if(!(planeNormal instanceof Vec3)){
	        throw new Error("planeNormal must be Vec3, "+planeNormal+" given");
	    }
	    if(!(inVertices instanceof Array)) {
	        throw new Error("invertices must be Array, "+inVertices+" given");
	    }
	    if(!(outVertices instanceof Array)){
	        throw new Error("outvertices must be Array, "+outVertices+" given");
	    }
	    var n_dot_first, n_dot_last;
	    var numVerts = inVertices.length;
	
	    if(numVerts < 2){
	        return outVertices;
	    }
	
	    var firstVertex = inVertices[inVertices.length-1],
	        lastVertex =   inVertices[0];
	
	    n_dot_first = planeNormal.dot(firstVertex) + planeConstant;
	
	    for(var vi = 0; vi < numVerts; vi++){
	        lastVertex = inVertices[vi];
	        n_dot_last = planeNormal.dot(lastVertex) + planeConstant;
	        if(n_dot_first < 0){
	            if(n_dot_last < 0){
	                // Start < 0, end < 0, so output lastVertex
	                var newv = new Vec3();
	                newv.copy(lastVertex);
	                outVertices.push(newv);
	            } else {
	                // Start < 0, end >= 0, so output intersection
	                var newv = new Vec3();
	                firstVertex.lerp(lastVertex,
	                                 n_dot_first / (n_dot_first - n_dot_last),
	                                 newv);
	                outVertices.push(newv);
	            }
	        } else {
	            if(n_dot_last<0){
	                // Start >= 0, end < 0 so output intersection and end
	                var newv = new Vec3();
	                firstVertex.lerp(lastVertex,
	                                 n_dot_first / (n_dot_first - n_dot_last),
	                                 newv);
	                outVertices.push(newv);
	                outVertices.push(lastVertex);
	            }
	        }
	        firstVertex = lastVertex;
	        n_dot_first = n_dot_last;
	    }
	    return outVertices;
	};
	
	// Updates .worldVertices and sets .worldVerticesNeedsUpdate to false.
	ConvexPolyhedron.prototype.computeWorldVertices = function(position,quat){
	    var N = this.vertices.length;
	    while(this.worldVertices.length < N){
	        this.worldVertices.push( new Vec3() );
	    }
	
	    var verts = this.vertices,
	        worldVerts = this.worldVertices;
	    for(var i=0; i!==N; i++){
	        quat.vmult( verts[i] , worldVerts[i] );
	        position.vadd( worldVerts[i] , worldVerts[i] );
	    }
	
	    this.worldVerticesNeedsUpdate = false;
	};
	
	var computeLocalAABB_worldVert = new Vec3();
	ConvexPolyhedron.prototype.computeLocalAABB = function(aabbmin,aabbmax){
	    var n = this.vertices.length,
	        vertices = this.vertices,
	        worldVert = computeLocalAABB_worldVert;
	
	    aabbmin.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
	    aabbmax.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
	
	    for(var i=0; i<n; i++){
	        var v = vertices[i];
	        if     (v.x < aabbmin.x){
	            aabbmin.x = v.x;
	        } else if(v.x > aabbmax.x){
	            aabbmax.x = v.x;
	        }
	        if     (v.y < aabbmin.y){
	            aabbmin.y = v.y;
	        } else if(v.y > aabbmax.y){
	            aabbmax.y = v.y;
	        }
	        if     (v.z < aabbmin.z){
	            aabbmin.z = v.z;
	        } else if(v.z > aabbmax.z){
	            aabbmax.z = v.z;
	        }
	    }
	};
	
	/**
	 * Updates .worldVertices and sets .worldVerticesNeedsUpdate to false.
	 * @method computeWorldFaceNormals
	 * @param  {Quaternion} quat
	 */
	ConvexPolyhedron.prototype.computeWorldFaceNormals = function(quat){
	    var N = this.faceNormals.length;
	    while(this.worldFaceNormals.length < N){
	        this.worldFaceNormals.push( new Vec3() );
	    }
	
	    var normals = this.faceNormals,
	        worldNormals = this.worldFaceNormals;
	    for(var i=0; i!==N; i++){
	        quat.vmult( normals[i] , worldNormals[i] );
	    }
	
	    this.worldFaceNormalsNeedsUpdate = false;
	};
	
	/**
	 * @method updateBoundingSphereRadius
	 */
	ConvexPolyhedron.prototype.updateBoundingSphereRadius = function(){
	    // Assume points are distributed with local (0,0,0) as center
	    var max2 = 0;
	    var verts = this.vertices;
	    for(var i=0, N=verts.length; i!==N; i++) {
	        var norm2 = verts[i].norm2();
	        if(norm2 > max2){
	            max2 = norm2;
	        }
	    }
	    this.boundingSphereRadius = Math.sqrt(max2);
	};
	
	var tempWorldVertex = new Vec3();
	
	/**
	 * @method calculateWorldAABB
	 * @param {Vec3}        pos
	 * @param {Quaternion}  quat
	 * @param {Vec3}        min
	 * @param {Vec3}        max
	 */
	ConvexPolyhedron.prototype.calculateWorldAABB = function(pos,quat,min,max){
	    var n = this.vertices.length, verts = this.vertices;
	    var minx,miny,minz,maxx,maxy,maxz;
	    for(var i=0; i<n; i++){
	        tempWorldVertex.copy(verts[i]);
	        quat.vmult(tempWorldVertex,tempWorldVertex);
	        pos.vadd(tempWorldVertex,tempWorldVertex);
	        var v = tempWorldVertex;
	        if     (v.x < minx || minx===undefined){
	            minx = v.x;
	        } else if(v.x > maxx || maxx===undefined){
	            maxx = v.x;
	        }
	
	        if     (v.y < miny || miny===undefined){
	            miny = v.y;
	        } else if(v.y > maxy || maxy===undefined){
	            maxy = v.y;
	        }
	
	        if     (v.z < minz || minz===undefined){
	            minz = v.z;
	        } else if(v.z > maxz || maxz===undefined){
	            maxz = v.z;
	        }
	    }
	    min.set(minx,miny,minz);
	    max.set(maxx,maxy,maxz);
	};
	
	/**
	 * Get approximate convex volume
	 * @method volume
	 * @return {Number}
	 */
	ConvexPolyhedron.prototype.volume = function(){
	    return 4.0 * Math.PI * this.boundingSphereRadius / 3.0;
	};
	
	/**
	 * Get an average of all the vertices positions
	 * @method getAveragePointLocal
	 * @param  {Vec3} target
	 * @return {Vec3}
	 */
	ConvexPolyhedron.prototype.getAveragePointLocal = function(target){
	    target = target || new Vec3();
	    var n = this.vertices.length,
	        verts = this.vertices;
	    for(var i=0; i<n; i++){
	        target.vadd(verts[i],target);
	    }
	    target.mult(1/n,target);
	    return target;
	};
	
	/**
	 * Transform all local points. Will change the .vertices
	 * @method transformAllPoints
	 * @param  {Vec3} offset
	 * @param  {Quaternion} quat
	 */
	ConvexPolyhedron.prototype.transformAllPoints = function(offset,quat){
	    var n = this.vertices.length,
	        verts = this.vertices;
	
	    // Apply rotation
	    if(quat){
	        // Rotate vertices
	        for(var i=0; i<n; i++){
	            var v = verts[i];
	            quat.vmult(v,v);
	        }
	        // Rotate face normals
	        for(var i=0; i<this.faceNormals.length; i++){
	            var v = this.faceNormals[i];
	            quat.vmult(v,v);
	        }
	        /*
	        // Rotate edges
	        for(var i=0; i<this.uniqueEdges.length; i++){
	            var v = this.uniqueEdges[i];
	            quat.vmult(v,v);
	        }*/
	    }
	
	    // Apply offset
	    if(offset){
	        for(var i=0; i<n; i++){
	            var v = verts[i];
	            v.vadd(offset,v);
	        }
	    }
	};
	
	/**
	 * Checks whether p is inside the polyhedra. Must be in local coords. The point lies outside of the convex hull of the other points if and only if the direction of all the vectors from it to those other points are on less than one half of a sphere around it.
	 * @method pointIsInside
	 * @param  {Vec3} p      A point given in local coordinates
	 * @return {Boolean}
	 */
	var ConvexPolyhedron_pointIsInside = new Vec3();
	var ConvexPolyhedron_vToP = new Vec3();
	var ConvexPolyhedron_vToPointInside = new Vec3();
	ConvexPolyhedron.prototype.pointIsInside = function(p){
	    var n = this.vertices.length,
	        verts = this.vertices,
	        faces = this.faces,
	        normals = this.faceNormals;
	    var positiveResult = null;
	    var N = this.faces.length;
	    var pointInside = ConvexPolyhedron_pointIsInside;
	    this.getAveragePointLocal(pointInside);
	    for(var i=0; i<N; i++){
	        var numVertices = this.faces[i].length;
	        var n = normals[i];
	        var v = verts[faces[i][0]]; // We only need one point in the face
	
	        // This dot product determines which side of the edge the point is
	        var vToP = ConvexPolyhedron_vToP;
	        p.vsub(v,vToP);
	        var r1 = n.dot(vToP);
	
	        var vToPointInside = ConvexPolyhedron_vToPointInside;
	        pointInside.vsub(v,vToPointInside);
	        var r2 = n.dot(vToPointInside);
	
	        if((r1<0 && r2>0) || (r1>0 && r2<0)){
	            return false; // Encountered some other sign. Exit.
	        } else {
	        }
	    }
	
	    // If we got here, all dot products were of the same sign.
	    return positiveResult ? 1 : -1;
	};
	
	/**
	 * Get max and min dot product of a convex hull at position (pos,quat) projected onto an axis. Results are saved in the array maxmin.
	 * @static
	 * @method project
	 * @param {ConvexPolyhedron} hull
	 * @param {Vec3} axis
	 * @param {Vec3} pos
	 * @param {Quaternion} quat
	 * @param {array} result result[0] and result[1] will be set to maximum and minimum, respectively.
	 */
	var project_worldVertex = new Vec3();
	var project_localAxis = new Vec3();
	var project_localOrigin = new Vec3();
	ConvexPolyhedron.project = function(hull, axis, pos, quat, result){
	    var n = hull.vertices.length,
	        worldVertex = project_worldVertex,
	        localAxis = project_localAxis,
	        max = 0,
	        min = 0,
	        localOrigin = project_localOrigin,
	        vs = hull.vertices;
	
	    localOrigin.setZero();
	
	    // Transform the axis to local
	    Transform.vectorToLocalFrame(pos, quat, axis, localAxis);
	    Transform.pointToLocalFrame(pos, quat, localOrigin, localOrigin);
	    var add = localOrigin.dot(localAxis);
	
	    min = max = vs[0].dot(localAxis);
	
	    for(var i = 1; i < n; i++){
	        var val = vs[i].dot(localAxis);
	
	        if(val > max){
	            max = val;
	        }
	
	        if(val < min){
	            min = val;
	        }
	    }
	
	    min -= add;
	    max -= add;
	
	    if(min > max){
	        // Inconsistent - swap
	        var temp = min;
	        min = max;
	        max = temp;
	    }
	    // Output
	    result[0] = max;
	    result[1] = min;
	};
	
	},{"../math/Quaternion":25,"../math/Transform":26,"../math/Vec3":27,"./Shape":40}],36:[function(_dereq_,module,exports){
	module.exports = Cylinder;
	
	var Shape = _dereq_('./Shape');
	var Vec3 = _dereq_('../math/Vec3');
	var Quaternion = _dereq_('../math/Quaternion');
	var ConvexPolyhedron = _dereq_('./ConvexPolyhedron');
	
	/**
	 * @class Cylinder
	 * @constructor
	 * @extends ConvexPolyhedron
	 * @author schteppe / https://github.com/schteppe
	 * @param {Number} radiusTop
	 * @param {Number} radiusBottom
	 * @param {Number} height
	 * @param {Number} numSegments The number of segments to build the cylinder out of
	 */
	function Cylinder( radiusTop, radiusBottom, height , numSegments ) {
	    var N = numSegments,
	        verts = [],
	        normals = [],
	        faces = [],
	        bottomface = [],
	        topface = [],
	        cos = Math.cos,
	        sin = Math.sin;
	
	    // First bottom point
	    verts.push(new Vec3(radiusBottom*cos(0),
	                               radiusBottom*sin(0),
	                               -height*0.5));
	    bottomface.push(0);
	
	    // First top point
	    verts.push(new Vec3(radiusTop*cos(0),
	                               radiusTop*sin(0),
	                               height*0.5));
	    topface.push(1);
	
	    for(var i=0; i<N; i++){
	        var theta = 2*Math.PI/N * (i+1);
	        var thetaN = 2*Math.PI/N * (i+0.5);
	        if(i<N-1){
	            // Bottom
	            verts.push(new Vec3(radiusBottom*cos(theta),
	                                       radiusBottom*sin(theta),
	                                       -height*0.5));
	            bottomface.push(2*i+2);
	            // Top
	            verts.push(new Vec3(radiusTop*cos(theta),
	                                       radiusTop*sin(theta),
	                                       height*0.5));
	            topface.push(2*i+3);
	            // Normal
	            normals.push(new Vec3(cos(thetaN),
	                                         sin(thetaN),
	                                         0));
	            // Face
	            faces.push([2*i+2, 2*i+3, 2*i+1,2*i]);
	        } else {
	            faces.push([0,1, 2*i+1, 2*i]); // Connect
	            // Normal
	            normals.push(new Vec3(cos(thetaN),sin(thetaN),0));
	        }
	    }
	    faces.push(topface);
	    normals.push(new Vec3(0,0,1));
	
	    // Reorder bottom face
	    var temp = [];
	    for(var i=0; i<bottomface.length; i++){
	        temp.push(bottomface[bottomface.length - i - 1]);
	    }
	    faces.push(temp);
	    normals.push(new Vec3(0,0,-1));
	
	    this.type = Shape.types.CONVEXPOLYHEDRON;
	    ConvexPolyhedron.call( this, verts, faces, normals );
	}
	
	Cylinder.prototype = new ConvexPolyhedron();
	
	},{"../math/Quaternion":25,"../math/Vec3":27,"./ConvexPolyhedron":35,"./Shape":40}],37:[function(_dereq_,module,exports){
	var Shape = _dereq_('./Shape');
	var ConvexPolyhedron = _dereq_('./ConvexPolyhedron');
	var Vec3 = _dereq_('../math/Vec3');
	var Utils = _dereq_('../utils/Utils');
	
	module.exports = Heightfield;
	
	/**
	 * Heightfield shape class. Height data is given as an array. These data points are spread out evenly with a given distance.
	 * @class Heightfield
	 * @extends Shape
	 * @constructor
	 * @param {Array} data An array of Y values that will be used to construct the terrain.
	 * @param {object} options
	 * @param {Number} [options.minValue] Minimum value of the data points in the data array. Will be computed automatically if not given.
	 * @param {Number} [options.maxValue] Maximum value.
	 * @param {Number} [options.elementSize=0.1] World spacing between the data points in X direction.
	 * @todo Should be possible to use along all axes, not just y
	 *
	 * @example
	 *     // Generate some height data (y-values).
	 *     var data = [];
	 *     for(var i = 0; i < 1000; i++){
	 *         var y = 0.5 * Math.cos(0.2 * i);
	 *         data.push(y);
	 *     }
	 *
	 *     // Create the heightfield shape
	 *     var heightfieldShape = new Heightfield(data, {
	 *         elementSize: 1 // Distance between the data points in X and Y directions
	 *     });
	 *     var heightfieldBody = new Body();
	 *     heightfieldBody.addShape(heightfieldShape);
	 *     world.addBody(heightfieldBody);
	 */
	function Heightfield(data, options){
	    options = Utils.defaults(options, {
	        maxValue : null,
	        minValue : null,
	        elementSize : 1
	    });
	
	    /**
	     * An array of numbers, or height values, that are spread out along the x axis.
	     * @property {array} data
	     */
	    this.data = data;
	
	    /**
	     * Max value of the data
	     * @property {number} maxValue
	     */
	    this.maxValue = options.maxValue;
	
	    /**
	     * Max value of the data
	     * @property {number} minValue
	     */
	    this.minValue = options.minValue;
	
	    /**
	     * The width of each element
	     * @property {number} elementSize
	     * @todo elementSizeX and Y
	     */
	    this.elementSize = options.elementSize;
	
	    if(options.minValue === null){
	        this.updateMinValue();
	    }
	    if(options.maxValue === null){
	        this.updateMaxValue();
	    }
	
	    this.cacheEnabled = true;
	
	    Shape.call(this);
	
	    this.pillarConvex = new ConvexPolyhedron();
	    this.pillarOffset = new Vec3();
	
	    this.type = Shape.types.HEIGHTFIELD;
	    this.updateBoundingSphereRadius();
	
	    // "i_j_isUpper" => { convex: ..., offset: ... }
	    // for example:
	    // _cachedPillars["0_2_1"]
	    this._cachedPillars = {};
	}
	Heightfield.prototype = new Shape();
	
	/**
	 * Call whenever you change the data array.
	 * @method update
	 */
	Heightfield.prototype.update = function(){
	    this._cachedPillars = {};
	};
	
	/**
	 * @method updateMinValue
	 * Update the .minValue property
	 */
	Heightfield.prototype.updateMinValue = function(){
	    var data = this.data;
	    var minValue = data[0][0];
	    for(var i=0; i !== data.length; i++){
	        for(var j=0; j !== data[i].length; j++){
	            var v = data[i][j];
	            if(v < minValue){
	                minValue = v;
	            }
	        }
	    }
	    this.minValue = minValue;
	};
	
	/**
	 * Update the .maxValue property
	 * @method updateMaxValue
	 */
	Heightfield.prototype.updateMaxValue = function(){
	    var data = this.data;
	    var maxValue = data[0][0];
	    for(var i=0; i !== data.length; i++){
	        for(var j=0; j !== data[i].length; j++){
	            var v = data[i][j];
	            if(v > maxValue){
	                maxValue = v;
	            }
	        }
	    }
	    this.maxValue = maxValue;
	};
	
	/**
	 * Set the height value at an index. Don't forget to update maxValue and minValue after you're done.
	 * @method setHeightValueAtIndex
	 * @param {integer} xi
	 * @param {integer} yi
	 * @param {number} value
	 */
	Heightfield.prototype.setHeightValueAtIndex = function(xi, yi, value){
	    var data = this.data;
	    data[xi][yi] = value;
	
	    // Invalidate cache
	    this.clearCachedConvexTrianglePillar(xi, yi, false);
	    if(xi > 0){
	        this.clearCachedConvexTrianglePillar(xi - 1, yi, true);
	        this.clearCachedConvexTrianglePillar(xi - 1, yi, false);
	    }
	    if(yi > 0){
	        this.clearCachedConvexTrianglePillar(xi, yi - 1, true);
	        this.clearCachedConvexTrianglePillar(xi, yi - 1, false);
	    }
	    if(yi > 0 && xi > 0){
	        this.clearCachedConvexTrianglePillar(xi - 1, yi - 1, true);
	    }
	};
	
	/**
	 * Get max/min in a rectangle in the matrix data
	 * @method getRectMinMax
	 * @param  {integer} iMinX
	 * @param  {integer} iMinY
	 * @param  {integer} iMaxX
	 * @param  {integer} iMaxY
	 * @param  {array} [result] An array to store the results in.
	 * @return {array} The result array, if it was passed in. Minimum will be at position 0 and max at 1.
	 */
	Heightfield.prototype.getRectMinMax = function (iMinX, iMinY, iMaxX, iMaxY, result) {
	    result = result || [];
	
	    // Get max and min of the data
	    var data = this.data,
	        max = this.minValue; // Set first value
	    for(var i = iMinX; i < iMaxX; i++){
	        for(var j = iMinY; j < iMaxY; j++){
	            var height = data[i][j];
	            if(height > max){
	                max = height;
	            }
	        }
	    }
	
	    result[0] = this.minValue;
	    result[1] = max;
	};
	
	/**
	 * Get the index of a local position on the heightfield. The indexes indicate the rectangles, so if your terrain is made of N x N height data points, you will have rectangle indexes ranging from 0 to N-1.
	 * @method getIndexOfPosition
	 * @param  {number} x
	 * @param  {number} y
	 * @param  {array} result Two-element array
	 * @param  {boolean} clamp If the position should be clamped to the heightfield edge.
	 * @return {boolean}
	 */
	Heightfield.prototype.getIndexOfPosition = function (x, y, result, clamp) {
	
	    // Get the index of the data points to test against
	    var w = this.elementSize;
	    var data = this.data;
	    var xi = Math.floor(x / w);
	    var yi = Math.floor(y / w);
	
	    result[0] = xi;
	    result[1] = yi;
	
	    if(clamp){
	        // Clamp index to edges
	        if(xi < 0){ xi = 0; }
	        if(yi < 0){ yi = 0; }
	        if(xi >= data.length - 1){ xi = data.length - 1; }
	        if(yi >= data[0].length - 1){ yi = data[0].length - 1; }
	    }
	
	    // Bail out if we are out of the terrain
	    if(xi < 0 || yi < 0 || xi >= data.length-1 || yi >= data[0].length-1){
	        return false;
	    }
	
	    return true;
	};
	
	Heightfield.prototype.getHeightAt = function(x, y, edgeClamp){
	    var idx = [];
	    this.getIndexOfPosition(x, y, idx, edgeClamp);
	
	    // TODO: do it better
	    var minmax = [];
	    this.getRectMinMax(idx[0], idx[1] + 1, idx[0], idx[1] + 1, minmax);
	
	    return (minmax[0] + minmax[1]) / 2; // average
	};
	
	Heightfield.prototype.getCacheConvexTrianglePillarKey = function(xi, yi, getUpperTriangle){
	    return xi + '_' + yi + '_' + (getUpperTriangle ? 1 : 0);
	};
	
	Heightfield.prototype.getCachedConvexTrianglePillar = function(xi, yi, getUpperTriangle){
	    return this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)];
	};
	
	Heightfield.prototype.setCachedConvexTrianglePillar = function(xi, yi, getUpperTriangle, convex, offset){
	    this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)] = {
	        convex: convex,
	        offset: offset
	    };
	};
	
	Heightfield.prototype.clearCachedConvexTrianglePillar = function(xi, yi, getUpperTriangle){
	    delete this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)];
	};
	
	/**
	 * Get a triangle in the terrain in the form of a triangular convex shape.
	 * @method getConvexTrianglePillar
	 * @param  {integer} i
	 * @param  {integer} j
	 * @param  {boolean} getUpperTriangle
	 */
	Heightfield.prototype.getConvexTrianglePillar = function(xi, yi, getUpperTriangle){
	    var result = this.pillarConvex;
	    var offsetResult = this.pillarOffset;
	
	    if(this.cacheEnabled){
	        var data = this.getCachedConvexTrianglePillar(xi, yi, getUpperTriangle);
	        if(data){
	            this.pillarConvex = data.convex;
	            this.pillarOffset = data.offset;
	            return;
	        }
	
	        result = new ConvexPolyhedron();
	        offsetResult = new Vec3();
	
	        this.pillarConvex = result;
	        this.pillarOffset = offsetResult;
	    }
	
	    var data = this.data;
	    var elementSize = this.elementSize;
	    var faces = result.faces;
	
	    // Reuse verts if possible
	    result.vertices.length = 6;
	    for (var i = 0; i < 6; i++) {
	        if(!result.vertices[i]){
	            result.vertices[i] = new Vec3();
	        }
	    }
	
	    // Reuse faces if possible
	    faces.length = 5;
	    for (var i = 0; i < 5; i++) {
	        if(!faces[i]){
	            faces[i] = [];
	        }
	    }
	
	    var verts = result.vertices;
	
	    var h = (Math.min(
	        data[xi][yi],
	        data[xi+1][yi],
	        data[xi][yi+1],
	        data[xi+1][yi+1]
	    ) - this.minValue ) / 2 + this.minValue;
	
	    if (!getUpperTriangle) {
	
	        // Center of the triangle pillar - all polygons are given relative to this one
	        offsetResult.set(
	            (xi + 0.25) * elementSize, // sort of center of a triangle
	            (yi + 0.25) * elementSize,
	            h // vertical center
	        );
	
	        // Top triangle verts
	        verts[0].set(
	            -0.25 * elementSize,
	            -0.25 * elementSize,
	            data[xi][yi] - h
	        );
	        verts[1].set(
	            0.75 * elementSize,
	            -0.25 * elementSize,
	            data[xi + 1][yi] - h
	        );
	        verts[2].set(
	            -0.25 * elementSize,
	            0.75 * elementSize,
	            data[xi][yi + 1] - h
	        );
	
	        // bottom triangle verts
	        verts[3].set(
	            -0.25 * elementSize,
	            -0.25 * elementSize,
	            -h
	        );
	        verts[4].set(
	            0.75 * elementSize,
	            -0.25 * elementSize,
	            -h
	        );
	        verts[5].set(
	            -0.25 * elementSize,
	            0.75  * elementSize,
	            -h
	        );
	
	        // top triangle
	        faces[0][0] = 0;
	        faces[0][1] = 1;
	        faces[0][2] = 2;
	
	        // bottom triangle
	        faces[1][0] = 5;
	        faces[1][1] = 4;
	        faces[1][2] = 3;
	
	        // -x facing quad
	        faces[2][0] = 0;
	        faces[2][1] = 2;
	        faces[2][2] = 5;
	        faces[2][3] = 3;
	
	        // -y facing quad
	        faces[3][0] = 1;
	        faces[3][1] = 0;
	        faces[3][2] = 3;
	        faces[3][3] = 4;
	
	        // +xy facing quad
	        faces[4][0] = 4;
	        faces[4][1] = 5;
	        faces[4][2] = 2;
	        faces[4][3] = 1;
	
	
	    } else {
	
	        // Center of the triangle pillar - all polygons are given relative to this one
	        offsetResult.set(
	            (xi + 0.75) * elementSize, // sort of center of a triangle
	            (yi + 0.75) * elementSize,
	            h // vertical center
	        );
	
	        // Top triangle verts
	        verts[0].set(
	            0.25 * elementSize,
	            0.25 * elementSize,
	            data[xi + 1][yi + 1] - h
	        );
	        verts[1].set(
	            -0.75 * elementSize,
	            0.25 * elementSize,
	            data[xi][yi + 1] - h
	        );
	        verts[2].set(
	            0.25 * elementSize,
	            -0.75 * elementSize,
	            data[xi + 1][yi] - h
	        );
	
	        // bottom triangle verts
	        verts[3].set(
	            0.25 * elementSize,
	            0.25 * elementSize,
	            - h
	        );
	        verts[4].set(
	            -0.75 * elementSize,
	            0.25 * elementSize,
	            - h
	        );
	        verts[5].set(
	            0.25 * elementSize,
	            -0.75 * elementSize,
	            - h
	        );
	
	        // Top triangle
	        faces[0][0] = 0;
	        faces[0][1] = 1;
	        faces[0][2] = 2;
	
	        // bottom triangle
	        faces[1][0] = 5;
	        faces[1][1] = 4;
	        faces[1][2] = 3;
	
	        // +x facing quad
	        faces[2][0] = 2;
	        faces[2][1] = 5;
	        faces[2][2] = 3;
	        faces[2][3] = 0;
	
	        // +y facing quad
	        faces[3][0] = 3;
	        faces[3][1] = 4;
	        faces[3][2] = 1;
	        faces[3][3] = 0;
	
	        // -xy facing quad
	        faces[4][0] = 1;
	        faces[4][1] = 4;
	        faces[4][2] = 5;
	        faces[4][3] = 2;
	    }
	
	    result.computeNormals();
	    result.computeEdges();
	    result.updateBoundingSphereRadius();
	
	    this.setCachedConvexTrianglePillar(xi, yi, getUpperTriangle, result, offsetResult);
	};
	
	Heightfield.prototype.calculateLocalInertia = function(mass, target){
	    target = target || new Vec3();
	    target.set(0, 0, 0);
	    return target;
	};
	
	Heightfield.prototype.volume = function(){
	    return Number.MAX_VALUE; // The terrain is infinite
	};
	
	Heightfield.prototype.calculateWorldAABB = function(pos, quat, min, max){
	    // TODO: do it properly
	    min.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
	    max.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
	};
	
	Heightfield.prototype.updateBoundingSphereRadius = function(){
	    // Use the bounding box of the min/max values
	    var data = this.data,
	        s = this.elementSize;
	    this.boundingSphereRadius = new Vec3(data.length * s, data[0].length * s, Math.max(Math.abs(this.maxValue), Math.abs(this.minValue))).norm();
	};
	},{"../math/Vec3":27,"../utils/Utils":48,"./ConvexPolyhedron":35,"./Shape":40}],38:[function(_dereq_,module,exports){
	module.exports = Particle;
	
	var Shape = _dereq_('./Shape');
	var Vec3 = _dereq_('../math/Vec3');
	
	/**
	 * A 3d box shape.
	 * @class Particle
	 * @constructor
	 * @author schteppe
	 * @extends Shape
	 */
	function Particle(){
	    Shape.call(this);
	
	    this.type = Shape.types.PARTICLE;
	}
	Particle.prototype = new Shape();
	Particle.prototype.constructor = Particle;
	
	/**
	 * @method calculateLocalInertia
	 * @param  {Number} mass
	 * @param  {Vec3} target
	 * @return {Vec3}
	 */
	Particle.prototype.calculateLocalInertia = function(mass,target){
	    target = target || new Vec3();
	    target.set(0, 0, 0);
	    return target;
	};
	
	Particle.prototype.volume = function(){
	    return 0;
	};
	
	Particle.prototype.updateBoundingSphereRadius = function(){
	    this.boundingSphereRadius = 0;
	};
	
	Particle.prototype.calculateWorldAABB = function(pos,quat,min,max){
	    // Get each axis max
	    min.copy(pos);
	    max.copy(pos);
	};
	
	},{"../math/Vec3":27,"./Shape":40}],39:[function(_dereq_,module,exports){
	module.exports = Plane;
	
	var Shape = _dereq_('./Shape');
	var Vec3 = _dereq_('../math/Vec3');
	
	/**
	 * A plane, facing in the Z direction. The plane has its surface at z=0 and everything below z=0 is assumed to be solid plane. To make the plane face in some other direction than z, you must put it inside a RigidBody and rotate that body. See the demos.
	 * @class Plane
	 * @constructor
	 * @extends Shape
	 * @author schteppe
	 */
	function Plane(){
	    Shape.call(this);
	    this.type = Shape.types.PLANE;
	
	    // World oriented normal
	    this.worldNormal = new Vec3();
	    this.worldNormalNeedsUpdate = true;
	
	    this.boundingSphereRadius = Number.MAX_VALUE;
	}
	Plane.prototype = new Shape();
	Plane.prototype.constructor = Plane;
	
	Plane.prototype.computeWorldNormal = function(quat){
	    var n = this.worldNormal;
	    n.set(0,0,1);
	    quat.vmult(n,n);
	    this.worldNormalNeedsUpdate = false;
	};
	
	Plane.prototype.calculateLocalInertia = function(mass,target){
	    target = target || new Vec3();
	    return target;
	};
	
	Plane.prototype.volume = function(){
	    return Number.MAX_VALUE; // The plane is infinite...
	};
	
	var tempNormal = new Vec3();
	Plane.prototype.calculateWorldAABB = function(pos, quat, min, max){
	    // The plane AABB is infinite, except if the normal is pointing along any axis
	    tempNormal.set(0,0,1); // Default plane normal is z
	    quat.vmult(tempNormal,tempNormal);
	    var maxVal = Number.MAX_VALUE;
	    min.set(-maxVal, -maxVal, -maxVal);
	    max.set(maxVal, maxVal, maxVal);
	
	    if(tempNormal.x === 1){ max.x = pos.x; }
	    if(tempNormal.y === 1){ max.y = pos.y; }
	    if(tempNormal.z === 1){ max.z = pos.z; }
	
	    if(tempNormal.x === -1){ min.x = pos.x; }
	    if(tempNormal.y === -1){ min.y = pos.y; }
	    if(tempNormal.z === -1){ min.z = pos.z; }
	};
	
	Plane.prototype.updateBoundingSphereRadius = function(){
	    this.boundingSphereRadius = Number.MAX_VALUE;
	};
	},{"../math/Vec3":27,"./Shape":40}],40:[function(_dereq_,module,exports){
	module.exports = Shape;
	
	var Shape = _dereq_('./Shape');
	var Vec3 = _dereq_('../math/Vec3');
	var Quaternion = _dereq_('../math/Quaternion');
	var Material = _dereq_('../material/Material');
	
	/**
	 * Base class for shapes
	 * @class Shape
	 * @constructor
	 * @author schteppe
	 * @todo Should have a mechanism for caching bounding sphere radius instead of calculating it each time
	 */
	function Shape(){
	
	    /**
	     * The type of this shape. Must be set to an int > 0 by subclasses.
	     * @property type
	     * @type {Number}
	     * @see Shape.types
	     */
	    this.type = 0;
	
	    /**
	     * The local bounding sphere radius of this shape.
	     * @property {Number} boundingSphereRadius
	     */
	    this.boundingSphereRadius = 0;
	
	    /**
	     * @property {boolean} collisionResponse
	     */
	    this.collisionResponse = true;
	}
	Shape.prototype.constructor = Shape;
	
	/**
	 * Computes the bounding sphere radius. The result is stored in the property .boundingSphereRadius
	 * @method updateBoundingSphereRadius
	 * @return {Number}
	 */
	Shape.prototype.updateBoundingSphereRadius = function(){
	    throw "computeBoundingSphereRadius() not implemented for shape type "+this.type;
	};
	
	/**
	 * Get the volume of this shape
	 * @method volume
	 * @return {Number}
	 */
	Shape.prototype.volume = function(){
	    throw "volume() not implemented for shape type "+this.type;
	};
	
	/**
	 * Calculates the inertia in the local frame for this shape.
	 * @method calculateLocalInertia
	 * @return {Vec3}
	 * @see http://en.wikipedia.org/wiki/List_of_moments_of_inertia
	 */
	Shape.prototype.calculateLocalInertia = function(mass,target){
	    throw "calculateLocalInertia() not implemented for shape type "+this.type;
	};
	
	/**
	 * The available shape types.
	 * @static
	 * @property types
	 * @type {Object}
	 */
	Shape.types = {
	    SPHERE:1,
	    PLANE:2,
	    BOX:4,
	    COMPOUND:8,
	    CONVEXPOLYHEDRON:16,
	    HEIGHTFIELD:32,
	    PARTICLE:64,
	    CYLINDER:128
	};
	
	
	},{"../material/Material":22,"../math/Quaternion":25,"../math/Vec3":27,"./Shape":40}],41:[function(_dereq_,module,exports){
	module.exports = Sphere;
	
	var Shape = _dereq_('./Shape');
	var Vec3 = _dereq_('../math/Vec3');
	
	/**
	 * Spherical shape
	 * @class Sphere
	 * @constructor
	 * @extends Shape
	 * @param {Number} radius
	 * @author schteppe / http://github.com/schteppe
	 */
	function Sphere(radius){
	    Shape.call(this);
	
	    /**
	     * @property {Number} radius
	     */
	    this.radius = radius!==undefined ? Number(radius) : 1.0;
	    this.type = Shape.types.SPHERE;
	
	    this.updateBoundingSphereRadius();
	}
	Sphere.prototype = new Shape();
	Sphere.prototype.constructor = Sphere;
	
	Sphere.prototype.calculateLocalInertia = function(mass,target){
	    target = target || new Vec3();
	    var I = 2.0*mass*this.radius*this.radius/5.0;
	    target.x = I;
	    target.y = I;
	    target.z = I;
	    return target;
	};
	
	Sphere.prototype.volume = function(){
	    return 4.0 * Math.PI * this.radius / 3.0;
	};
	
	Sphere.prototype.updateBoundingSphereRadius = function(){
	    this.boundingSphereRadius = this.radius;
	};
	
	Sphere.prototype.calculateWorldAABB = function(pos,quat,min,max){
	    var r = this.radius;
	    var axes = ['x','y','z'];
	    for(var i=0; i<axes.length; i++){
	        var ax = axes[i];
	        min[ax] = pos[ax] - r;
	        max[ax] = pos[ax] + r;
	    }
	};
	
	},{"../math/Vec3":27,"./Shape":40}],42:[function(_dereq_,module,exports){
	module.exports = GSSolver;
	
	var Vec3 = _dereq_('../math/Vec3');
	var Quaternion = _dereq_('../math/Quaternion');
	var Solver = _dereq_('./Solver');
	
	/**
	 * Constraint equation Gauss-Seidel solver.
	 * @class GSSolver
	 * @constructor
	 * @todo The spook parameters should be specified for each constraint, not globally.
	 * @author schteppe / https://github.com/schteppe
	 * @see https://www8.cs.umu.se/kurser/5DV058/VT09/lectures/spooknotes.pdf
	 * @extends Solver
	 */
	function GSSolver(){
	    Solver.call(this);
	
	    /**
	     * The number of solver iterations determines quality of the constraints in the world. The more iterations, the more correct simulation. More iterations need more computations though. If you have a large gravity force in your world, you will need more iterations.
	     * @property iterations
	     * @type {Number}
	     * @todo write more about solver and iterations in the wiki
	     */
	    this.iterations = 10;
	
	    /**
	     * When tolerance is reached, the system is assumed to be converged.
	     * @property tolerance
	     * @type {Number}
	     */
	    this.tolerance = 0;
	}
	GSSolver.prototype = new Solver();
	
	var GSSolver_solve_lambda = []; // Just temporary number holders that we want to reuse each solve.
	var GSSolver_solve_invCs = [];
	var GSSolver_solve_Bs = [];
	GSSolver.prototype.solve = function(dt,world){
	    var iter = 0,
	        maxIter = this.iterations,
	        tolSquared = this.tolerance*this.tolerance,
	        equations = this.equations,
	        Neq = equations.length,
	        bodies = world.bodies,
	        Nbodies = bodies.length,
	        h = dt,
	        q, B, invC, deltalambda, deltalambdaTot, GWlambda, lambdaj;
	
	    // Update solve mass
	    if(Neq !== 0){
	        for(var i=0; i!==Nbodies; i++){
	            bodies[i].updateSolveMassProperties();
	        }
	    }
	
	    // Things that does not change during iteration can be computed once
	    var invCs = GSSolver_solve_invCs,
	        Bs = GSSolver_solve_Bs,
	        lambda = GSSolver_solve_lambda;
	    invCs.length = Neq;
	    Bs.length = Neq;
	    lambda.length = Neq;
	    for(var i=0; i!==Neq; i++){
	        var c = equations[i];
	        lambda[i] = 0.0;
	        Bs[i] = c.computeB(h);
	        invCs[i] = 1.0 / c.computeC();
	    }
	
	    if(Neq !== 0){
	
	        // Reset vlambda
	        for(var i=0; i!==Nbodies; i++){
	            var b=bodies[i],
	                vlambda=b.vlambda,
	                wlambda=b.wlambda;
	            vlambda.set(0,0,0);
	            if(wlambda){
	                wlambda.set(0,0,0);
	            }
	        }
	
	        // Iterate over equations
	        for(iter=0; iter!==maxIter; iter++){
	
	            // Accumulate the total error for each iteration.
	            deltalambdaTot = 0.0;
	
	            for(var j=0; j!==Neq; j++){
	
	                var c = equations[j];
	
	                // Compute iteration
	                B = Bs[j];
	                invC = invCs[j];
	                lambdaj = lambda[j];
	                GWlambda = c.computeGWlambda();
	                deltalambda = invC * ( B - GWlambda - c.eps * lambdaj );
	
	                // Clamp if we are not within the min/max interval
	                if(lambdaj + deltalambda < c.minForce){
	                    deltalambda = c.minForce - lambdaj;
	                } else if(lambdaj + deltalambda > c.maxForce){
	                    deltalambda = c.maxForce - lambdaj;
	                }
	                lambda[j] += deltalambda;
	
	                deltalambdaTot += deltalambda > 0.0 ? deltalambda : -deltalambda; // abs(deltalambda)
	
	                c.addToWlambda(deltalambda);
	            }
	
	            // If the total error is small enough - stop iterate
	            if(deltalambdaTot*deltalambdaTot < tolSquared){
	                break;
	            }
	        }
	
	        // Add result to velocity
	        for(var i=0; i!==Nbodies; i++){
	            var b=bodies[i],
	                v=b.velocity,
	                w=b.angularVelocity;
	            v.vadd(b.vlambda, v);
	            if(w){
	                w.vadd(b.wlambda, w);
	            }
	        }
	    }
	
	    return iter;
	};
	
	},{"../math/Quaternion":25,"../math/Vec3":27,"./Solver":43}],43:[function(_dereq_,module,exports){
	module.exports = Solver;
	
	/**
	 * Constraint equation solver base class.
	 * @class Solver
	 * @constructor
	 * @author schteppe / https://github.com/schteppe
	 */
	function Solver(){
	    /**
	     * All equations to be solved
	     * @property {Array} equations
	     */
	    this.equations = [];
	}
	
	/**
	 * Should be implemented in subclasses!
	 * @method solve
	 * @param  {Number} dt
	 * @param  {World} world
	 */
	Solver.prototype.solve = function(dt,world){
	    // Should return the number of iterations done!
	    return 0;
	};
	
	/**
	 * Add an equation
	 * @method addEquation
	 * @param {Equation} eq
	 */
	Solver.prototype.addEquation = function(eq){
	    if (eq.enabled) {
	        this.equations.push(eq);
	    }
	};
	
	/**
	 * Remove an equation
	 * @method removeEquation
	 * @param {Equation} eq
	 */
	Solver.prototype.removeEquation = function(eq){
	    var eqs = this.equations;
	    var i = eqs.indexOf(eq);
	    if(i !== -1){
	        eqs.splice(i,1);
	    }
	};
	
	/**
	 * Add all equations
	 * @method removeAllEquations
	 */
	Solver.prototype.removeAllEquations = function(){
	    this.equations.length = 0;
	};
	
	
	},{}],44:[function(_dereq_,module,exports){
	module.exports = SplitSolver;
	
	var Vec3 = _dereq_('../math/Vec3');
	var Quaternion = _dereq_('../math/Quaternion');
	var Solver = _dereq_('./Solver');
	var Body = _dereq_('../objects/Body');
	
	/**
	 * Splits the equations into islands and solves them independently. Can improve performance.
	 * @class SplitSolver
	 * @constructor
	 * @extends Solver
	 * @param {Solver} subsolver
	 */
	function SplitSolver(subsolver){
	    Solver.call(this);
	    this.subsolver = subsolver;
	}
	SplitSolver.prototype = new Solver();
	
	// Returns the number of subsystems
	var SplitSolver_solve_nodes = []; // All allocated node objects
	var SplitSolver_solve_eqs = [];   // Temp array
	var SplitSolver_solve_bds = [];   // Temp array
	var SplitSolver_solve_dummyWorld = {bodies:null}; // Temp object
	
	/**
	 * Solve the subsystems
	 * @method solve
	 * @param  {Number} dt
	 * @param  {World} world
	 */
	SplitSolver.prototype.solve = function(dt,world){
	    var nodes=SplitSolver_solve_nodes,
	        bodies=world.bodies,
	        equations=this.equations,
	        Neq=equations.length,
	        Nbodies=bodies.length,
	        subsolver=this.subsolver;
	    // Create needed nodes, reuse if possible
	    if(nodes.length>Nbodies){
	        nodes.length = Nbodies;
	    }
	    while(nodes.length<Nbodies){
	        nodes.push({ body:null, children:[], eqs:[], visited:false });
	    }
	
	    // Reset node values
	    for(var i=0; i!==Nbodies; i++){
	        var node = nodes[i];
	        node.body = bodies[i];
	        node.children.length = 0;
	        node.eqs.length = 0;
	        node.visited = false;
	    }
	    for(var k=0; k!==Neq; k++){
	        var eq=equations[k],
	            i=bodies.indexOf(eq.bi),
	            j=bodies.indexOf(eq.bj),
	            ni=nodes[i],
	            nj=nodes[j];
	        ni.children.push(nj);
	        ni.eqs.push(eq);
	        nj.children.push(ni);
	        nj.eqs.push(eq);
	    }
	
	    var STATIC = Body.STATIC;
	    function getUnvisitedNode(nodes){
	        var Nnodes = nodes.length;
	        for(var i=0; i!==Nnodes; i++){
	            var node = nodes[i];
	            if(!node.visited && !(node.body.type & STATIC)){
	                return node;
	            }
	        }
	        return false;
	    }
	
	    function bfs(root,visitFunc){
	        var queue = [];
	        queue.push(root);
	        root.visited = true;
	        visitFunc(root);
	        while(queue.length) {
	            var node = queue.pop();
	            // Loop over unvisited child nodes
	            var child;
	            while((child = getUnvisitedNode(node.children))) {
	                child.visited = true;
	                visitFunc(child);
	                queue.push(child);
	            }
	        }
	    }
	
	    var child, n=0, eqs=SplitSolver_solve_eqs, bds=SplitSolver_solve_bds;
	    function visitFunc(node){
	        bds.push(node.body);
	        var Neqs = node.eqs.length;
	        for(var i=0; i!==Neqs; i++){
	            var eq = node.eqs[i];
	            if(eqs.indexOf(eq) === -1){
	                eqs.push(eq);
	            }
	        }
	    }
	    var dummyWorld = SplitSolver_solve_dummyWorld;
	    while((child = getUnvisitedNode(nodes))){
	        eqs.length = 0;
	        bds.length = 0;
	        bfs(child,visitFunc);
	
	        var Neqs = eqs.length;
	        for(var i=0; i!==Neqs; i++){
	            subsolver.addEquation(eqs[i]);
	        }
	
	        dummyWorld.bodies = bds;
	        var iter = subsolver.solve(dt,dummyWorld);
	        subsolver.removeAllEquations();
	        n++;
	    }
	
	    return n;
	};
	
	},{"../math/Quaternion":25,"../math/Vec3":27,"../objects/Body":28,"./Solver":43}],45:[function(_dereq_,module,exports){
	/**
	 * Base class for objects that dispatches events.
	 * @class EventTarget
	 * @constructor
	 */
	var EventTarget = function () {
	
	};
	
	module.exports = EventTarget;
	
	EventTarget.prototype = {
	    constructor: EventTarget,
	
	    /**
	     * Add an event listener
	     * @method addEventListener
	     * @param  {String} type
	     * @param  {Function} listener
	     * @return {EventTarget} The self object, for chainability.
	     */
	    addEventListener: function ( type, listener ) {
	        if ( this._listeners === undefined ){ this._listeners = {}; }
	        var listeners = this._listeners;
	        if ( listeners[ type ] === undefined ) {
	            listeners[ type ] = [];
	        }
	        if ( listeners[ type ].indexOf( listener ) === - 1 ) {
	            listeners[ type ].push( listener );
	        }
	        return this;
	    },
	
	    /**
	     * Check if an event listener is added
	     * @method hasEventListener
	     * @param  {String} type
	     * @param  {Function} listener
	     * @return {Boolean}
	     */
	    hasEventListener: function ( type, listener ) {
	        if ( this._listeners === undefined ){ return false; }
	        var listeners = this._listeners;
	        if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {
	            return true;
	        }
	        return false;
	    },
	
	    /**
	     * Remove an event listener
	     * @method removeEventListener
	     * @param  {String} type
	     * @param  {Function} listener
	     * @return {EventTarget} The self object, for chainability.
	     */
	    removeEventListener: function ( type, listener ) {
	        if ( this._listeners === undefined ){ return this; }
	        var listeners = this._listeners;
	        if ( listeners[type] === undefined ){ return this; }
	        var index = listeners[ type ].indexOf( listener );
	        if ( index !== - 1 ) {
	            listeners[ type ].splice( index, 1 );
	        }
	        return this;
	    },
	
	    /**
	     * Emit an event.
	     * @method dispatchEvent
	     * @param  {Object} event
	     * @param  {String} event.type
	     * @return {EventTarget} The self object, for chainability.
	     */
	    dispatchEvent: function ( event ) {
	        if ( this._listeners === undefined ){ return this; }
	        var listeners = this._listeners;
	        var listenerArray = listeners[ event.type ];
	        if ( listenerArray !== undefined ) {
	            event.target = this;
	            for ( var i = 0, l = listenerArray.length; i < l; i ++ ) {
	                listenerArray[ i ].call( this, event );
	            }
	        }
	        return this;
	    }
	};
	
	},{}],46:[function(_dereq_,module,exports){
	module.exports = Pool;
	
	/**
	 * For pooling objects that can be reused.
	 * @class Pool
	 * @constructor
	 */
	function Pool(){
	    /**
	     * The pooled objects
	     * @property {Array} objects
	     */
	    this.objects = [];
	
	    /**
	     * Constructor of the objects
	     * @property {mixed} type
	     */
	    this.type = Object;
	}
	
	/**
	 * Release an object after use
	 * @method release
	 * @param {Object} obj
	 */
	Pool.prototype.release = function(){
	    var Nargs = arguments.length;
	    for(var i=0; i!==Nargs; i++){
	        this.objects.push(arguments[i]);
	    }
	};
	
	/**
	 * Get an object
	 * @method get
	 * @return {mixed}
	 */
	Pool.prototype.get = function(){
	    if(this.objects.length===0){
	        return this.constructObject();
	    } else {
	        return this.objects.pop();
	    }
	};
	
	/**
	 * Construct an object. Should be implmented in each subclass.
	 * @method constructObject
	 * @return {mixed}
	 */
	Pool.prototype.constructObject = function(){
	    throw new Error("constructObject() not implemented in this Pool subclass yet!");
	};
	
	},{}],47:[function(_dereq_,module,exports){
	module.exports = TupleDictionary;
	
	/**
	 * @class TupleDictionary
	 * @constructor
	 */
	function TupleDictionary() {
	
	    /**
	     * The data storage
	     * @property data
	     * @type {Object}
	     */
	    this.data = { keys:[] };
	}
	
	/**
	 * @method get
	 * @param  {Number} i
	 * @param  {Number} j
	 * @return {Number}
	 */
	TupleDictionary.prototype.get = function(i, j) {
	    if (i > j) {
	        // swap
	        var temp = j;
	        j = i;
	        i = temp;
	    }
	    return this.data[i+'-'+j];
	};
	
	/**
	 * @method set
	 * @param  {Number} i
	 * @param  {Number} j
	 * @param {Number} value
	 */
	TupleDictionary.prototype.set = function(i, j, value) {
	    if (i > j) {
	        var temp = j;
	        j = i;
	        i = temp;
	    }
	    var key = i+'-'+j;
	
	    // Check if key already exists
	    if(!this.get(i,j)){
	        this.data.keys.push(key);
	    }
	
	    this.data[key] = value;
	};
	
	/**
	 * @method reset
	 */
	TupleDictionary.prototype.reset = function() {
	    var data = this.data,
	        keys = data.keys;
	    while(keys.length > 0){
	        var key = keys.pop();
	        delete data[key];
	    }
	};
	
	},{}],48:[function(_dereq_,module,exports){
	function Utils(){}
	
	module.exports = Utils;
	
	/**
	 * Extend an options object with default values.
	 * @static
	 * @method defaults
	 * @param  {object} options The options object. May be falsy: in this case, a new object is created and returned.
	 * @param  {object} defaults An object containing default values.
	 * @return {object} The modified options object.
	 */
	Utils.defaults = function(options, defaults){
	    options = options || {};
	
	    for(var key in defaults){
	        if(!(key in options)){
	            options[key] = defaults[key];
	        }
	    }
	
	    return options;
	};
	
	},{}],49:[function(_dereq_,module,exports){
	module.exports = Vec3Pool;
	
	var Vec3 = _dereq_('../math/Vec3');
	var Pool = _dereq_('./Pool');
	
	/**
	 * @class Vec3Pool
	 * @constructor
	 * @extends Pool
	 */
	function Vec3Pool(){
	    Pool.call(this);
	    this.type = Vec3;
	}
	Vec3Pool.prototype = new Pool();
	
	/**
	 * Construct a vector
	 * @method constructObject
	 * @return {Vec3}
	 */
	Vec3Pool.prototype.constructObject = function(){
	    return new Vec3();
	};
	
	},{"../math/Vec3":27,"./Pool":46}],50:[function(_dereq_,module,exports){
	module.exports = Narrowphase;
	
	var Shape = _dereq_('../shapes/Shape');
	var Vec3 = _dereq_('../math/Vec3');
	var Transform = _dereq_('../math/Transform');
	var ConvexPolyhedron = _dereq_('../shapes/ConvexPolyhedron');
	var Quaternion = _dereq_('../math/Quaternion');
	var Solver = _dereq_('../solver/Solver');
	var Vec3Pool = _dereq_('../utils/Vec3Pool');
	var ContactEquation = _dereq_('../equations/ContactEquation');
	
	/**
	 * Helper class for the World. Generates ContactEquations.
	 * @class Narrowphase
	 * @constructor
	 * @todo Sphere-ConvexPolyhedron contacts
	 * @todo Contact reduction
	 * @todo  should move methods to prototype
	 */
	function Narrowphase(){
	
	    /**
	     * Turns on or off contact reduction. Can be handy to turn off when debugging new collision types.
	     * @property bool contactReduction
	     */
	    this.contactReduction = false;
	
	    /**
	     * Internal storage of pooled contact points.
	     * @property {Array} contactPointPool
	     */
	    this.contactPointPool = [];
	
	    /**
	     * Pooled vectors.
	     * @property {Vec3Pool} v3pool
	     */
	    this.v3pool = new Vec3Pool();
	}
	
	/**
	 * Swaps the body references in the contact
	 * @method swapResult
	 * @param object r
	 */
	Narrowphase.prototype.swapResult = function(r){
	    var temp;
	    temp = r.ri;
	    r.ri = r.rj;
	    r.rj = temp;
	    r.ni.negate(r.ni);
	    temp = r.bi;
	    r.bi = r.bj;
	    r.bj = temp;
	};
	
	/**
	 * Removes unnecessary members of an array of ContactEquation.
	 * @method reduceContacts
	 * @param {Array} contacts
	 */
	Narrowphase.prototype.reduceContacts = function(contacts){
	
	};
	
	/**
	 * Make a contact object, by using the internal pool or creating a new one.
	 * @method makeResult
	 * @return {ContactEquation}
	 */
	Narrowphase.prototype.makeResult = function(bi, bj, si, sj, rsi, rsj){
	    var c;
	    if(this.contactPointPool.length){
	        c = this.contactPointPool.pop();
	        c.bi = bi;
	        c.bj = bj;
	    } else {
	        c = new ContactEquation(bi, bj);
	    }
	
	    c.enabled = true;
	    c.si = rsi || si;
	    c.sj = rsj || sj;
	
	    return c;
	};
	
	var tmpVec1 = new Vec3();
	var tmpVec2 = new Vec3();
	var tmpQuat1 = new Quaternion();
	var tmpQuat2 = new Quaternion();
	
	/**
	 * Generate all contacts between a list of body pairs
	 * @method getContacts
	 * @param {array} p1 Array of body indices
	 * @param {array} p2 Array of body indices
	 * @param {World} world
	 * @param {array} result Array to store generated contacts
	 * @param {array} oldcontacts Optional. Array of reusable contact objects
	 */
	Narrowphase.prototype.getContacts = function(p1,p2,world,result,oldcontacts){
	    // Save old contact objects
	    this.contactPointPool = oldcontacts;
	
	    var qi = tmpQuat1;
	    var qj = tmpQuat2;
	    var xi = tmpVec1;
	    var xj = tmpVec2;
	
	    for(var k=0, N=p1.length; k!==N; k++){
	
	        // Get current collision bodies
	        var bi = p1[k],
	            bj = p2[k];
	
	        for (var i = 0; i < bi.shapes.length; i++) {
	            bi.quaternion.mult(bi.shapeOrientations[i], qi);
	            bi.quaternion.vmult(bi.shapeOffsets[i], xi);
	            xi.vadd(bi.position, xi);
	            var si = bi.shapes[i];
	
	            for (var j = 0; j < bj.shapes.length; j++) {
	
	                // Compute world transform of shapes
	                bj.quaternion.mult(bj.shapeOrientations[j], qj);
	                bj.quaternion.vmult(bj.shapeOffsets[j], xj);
	                xj.vadd(bj.position, xj);
	                var sj = bj.shapes[j];
	
	                if(xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius){
	                    break;
	                }
	
	                // Get contacts
	                var resolver = this[si.type | sj.type];
	                if(resolver){
	                    if (si.type < sj.type) {
	                        resolver.call(this, result, si,sj,xi,xj,qi,qj,bi,bj,si,sj);
	                    } else {
	                        resolver.call(this, result, sj,si,xj,xi,qj,qi,bj,bi,si,sj);
	                    }
	                }
	                /*
	                this.narrowphase(
	                    result,
	                    bi.shapes[i],
	                    bj.shapes[j],
	                    xi, xj,
	                    qi, qj,
	                    bi, bj
	                );
	                */
	            }
	        }
	    }
	};
	
	var numWarnings = 0;
	var maxWarnings = 10;
	
	function warn(msg){
	    if(numWarnings > maxWarnings){
	        return;
	    }
	
	    numWarnings++;
	
	    console.warn(msg);
	}
	
	/**
	 * Narrowphase calculation. Get the ContactEquations given two shapes: i and j
	 * @method narrowphase
	 * @param {array} result The result one will get back with all the contact point information
	 * @param {Shape} si Colliding shape. If not given, particle is assumed.
	 * @param {Shape} sj
	 * @param {Vec3} xi Position of the center of mass
	 * @param {Vec3} xj
	 * @param {Quaternion} qi Rotation around the center of mass
	 * @param {Quaternion} qj
	 */
	/*
	Narrowphase.prototype.narrowphase = function(result,si,sj,xi,xj,qi,qj,bi,bj){
	    var swapped = false,
	        types = Shape.types,
	        SPHERE = types.SPHERE,
	        PLANE = types.PLANE,
	        PARTICLE = types.PARTICLE,
	        BOX = types.BOX,
	        COMPOUND = types.COMPOUND,
	        CONVEXPOLYHEDRON = types.CONVEXPOLYHEDRON,
	        HEIGHTFIELD = types.HEIGHTFIELD;
	
	    if(si.type > sj.type){
	        var temp;
	
	        temp = sj;
	        sj = si;
	        si = temp;
	
	        temp = xj;
	        xj = xi;
	        xi = temp;
	
	        temp = qj;
	        qj = qi;
	        qi = temp;
	
	        temp = bj;
	        bj = bi;
	        bi = temp;
	
	        swapped = true;
	    }
	
	    if(si && sj){
	        if(si.type === SPHERE){
	
	            switch(sj.type){
	            case SPHERE: // sphere-sphere
	                this.sphereSphere(result,si,sj,xi,xj,qi,qj,bi,bj);
	                break;
	            case PLANE: // sphere-plane
	                this.spherePlane(result,si,sj,xi,xj,qi,qj,bi,bj);
	                break;
	            case BOX: // sphere-box
	                this.sphereBox(result,si,sj,xi,xj,qi,qj,bi,bj);
	                break;
	            case CONVEXPOLYHEDRON: // sphere-convexpolyhedron
	                this.sphereConvex(result,si,sj,xi,xj,qi,qj,bi,bj);
	                break;
	            case HEIGHTFIELD: // sphere-heightfield
	                this.sphereHeightfield(result,si,sj,xi,xj,qi,qj,bi,bj);
	                break;
	            case PARTICLE: // Particle vs sphere
	                this.particleSphere(result,sj,si,xj,xi,qj,qi,bj,bi);
	                break;
	            default:
	                warn("Collision between Shape.types.SPHERE and "+sj.type+" not implemented yet.");
	                break;
	            }
	
	        } else if(si.type === types.PLANE){
	
	            switch(sj.type){
	            case PLANE: // plane-plane
	                // Should not give collision
	                break;
	            case BOX: // plane-box
	                this.planeBox(result,si,sj,xi,xj,qi,qj,bi,bj);
	                break;
	            case CONVEXPOLYHEDRON: // plane-convex polyhedron
	                this.planeConvex(result,si,sj,xi,xj,qi,qj,bi,bj);
	                break;
	            case PARTICLE: // plane-convex polyhedron
	                this.particlePlane(result,sj,si,xj,xi,qj,qi,bj,bi);
	                break;
	            default:
	                warn("Collision between Shape.types.PLANE and "+sj.type+" not implemented yet.");
	                break;
	            }
	
	        } else if(si.type===types.BOX){
	
	            switch(sj.type){
	            case BOX: // box-box
	                // Do convex/convex instead
	                this.convexConvex(result,si.convexPolyhedronRepresentation,sj.convexPolyhedronRepresentation,xi,xj,qi,qj,bi,bj,si,sj);
	                break;
	            case CONVEXPOLYHEDRON: // box-convexpolyhedron
	                // Do convex/convex instead
	                this.convexConvex(result,si.convexPolyhedronRepresentation,sj,xi,xj,qi,qj,bi,bj,si,sj);
	                break;
	            case PARTICLE: // Particle vs box
	                this.convexParticle(result,sj,si.convexPolyhedronRepresentation,xj,xi,qj,qi,bj,bi,si,sj);
	                break;
	            case HEIGHTFIELD: // Box vs heightfield
	                this.convexHeightfield(result,si.convexPolyhedronRepresentation,sj,xi,xj,qi,qj,bi,bj,si,sj);
	                break;
	            default:
	                warn("Collision between Shape.BOX and "+sj.type+" not implemented yet.");
	                break;
	            }
	
	        } else if(si.type===types.CONVEXPOLYHEDRON){
	
	            switch(sj.type){
	            case types.CONVEXPOLYHEDRON: // convex polyhedron - convex polyhedron
	                this.convexConvex(result,si,sj,xi,xj,qi,qj,bi,bj);
	                break;
	            case types.PARTICLE: // particle-convex
	                this.convexParticle(result,sj,si,xj,xi,qj,qi,bj,bi);
	                break;
	            default:
	                warn("Collision between Shape.types.CONVEXPOLYHEDRON and "+sj.type+" not implemented yet.");
	                break;
	            }
	
	        } else if(si.type===types.HEIGHTFIELD){
	
	            switch(sj.type){
	            case types.SPHERE: // heightfield/sphere
	                this.sphereHeightfield(result,si,sj,xi,xj,qi,qj,bi,bj);
	                break;
	            default:
	                warn("Collision between Shape.types.HEIGHTFIELD and "+sj.type+" not implemented yet.");
	                break;
	            }
	
	        } else if(si.type === PARTICLE){
	
	            // Particle!
	            switch(sj.type){
	            case types.PLANE: // Particle vs plane
	                this.particlePlane(result,si,sj,xi,xj,qi,qj,bi,bj);
	                break;
	            case types.SPHERE: // Particle vs sphere
	                this.particleSphere(result,si,sj,xi,xj,qi,qj,bi,bj);
	                break;
	            case types.BOX: // Particle vs box
	                this.convexParticle(result,si,sj.convexPolyhedronRepresentation,xi,xj,qi,qj,bi,bj);
	                break;
	            case types.CONVEXPOLYHEDRON: // particle-convex
	                this.convexParticle(result,si,sj,xi,xj,qi,qj,bi,bj);
	                break;
	            default:
	                console.warn("Collision between Particle and "+sj.type+" not implemented yet.");
	                break;
	            }
	        }
	    }
	
	    // Swap back if we swapped bodies in the beginning
	    for(var i=0, Nresults=result.length; swapped && i!==Nresults; i++){
	        this.swapResult(result[i]);
	    }
	};
	*/
	
	
	Narrowphase.prototype[Shape.types.BOX | Shape.types.BOX] =
	Narrowphase.prototype.boxBox = function(result,si,sj,xi,xj,qi,qj,bi,bj){
	    this.convexConvex(result,si.convexPolyhedronRepresentation,sj.convexPolyhedronRepresentation,xi,xj,qi,qj,bi,bj,si,sj);
	};
	
	Narrowphase.prototype[Shape.types.BOX | Shape.types.CONVEXPOLYHEDRON] =
	Narrowphase.prototype.boxConvex = function(result,si,sj,xi,xj,qi,qj,bi,bj){
	    this.convexConvex(result,si.convexPolyhedronRepresentation,sj,xi,xj,qi,qj,bi,bj,si,sj);
	};
	
	Narrowphase.prototype[Shape.types.BOX | Shape.types.PARTICLE] =
	Narrowphase.prototype.boxParticle = function(result,si,sj,xi,xj,qi,qj,bi,bj){
	    this.convexParticle(result,si.convexPolyhedronRepresentation,sj,xi,xj,qi,qj,bi,bj,si,sj);
	};
	
	/**
	 * @method sphereSphere
	 * @param  {Array}      result
	 * @param  {Shape}      si
	 * @param  {Shape}      sj
	 * @param  {Vec3}       xi
	 * @param  {Vec3}       xj
	 * @param  {Quaternion} qi
	 * @param  {Quaternion} qj
	 * @param  {Body}       bi
	 * @param  {Body}       bj
	 */
	Narrowphase.prototype[Shape.types.SPHERE] =
	Narrowphase.prototype.sphereSphere = function(result,si,sj,xi,xj,qi,qj,bi,bj){
	    // We will have only one contact in this case
	    var r = this.makeResult(bi,bj,si,sj);
	
	    // Contact normal
	    bj.position.vsub(xi, r.ni);
	    r.ni.normalize();
	
	    // Contact point locations
	    r.ri.copy(r.ni);
	    r.rj.copy(r.ni);
	    r.ri.mult(si.radius, r.ri);
	    r.rj.mult(-sj.radius, r.rj);
	    result.push(r);
	};
	
	var point_on_plane_to_sphere = new Vec3();
	var plane_to_sphere_ortho = new Vec3();
	
	/**
	 * @method spherePlane
	 * @param  {Array}      result
	 * @param  {Shape}      si
	 * @param  {Shape}      sj
	 * @param  {Vec3}       xi
	 * @param  {Vec3}       xj
	 * @param  {Quaternion} qi
	 * @param  {Quaternion} qj
	 * @param  {Body}       bi
	 * @param  {Body}       bj
	 */
	Narrowphase.prototype[Shape.types.SPHERE | Shape.types.PLANE] =
	Narrowphase.prototype.spherePlane = function(result,si,sj,xi,xj,qi,qj,bi,bj){
	    // We will have one contact in this case
	    var r = this.makeResult(bi,bj,si,sj);
	
	    // Contact normal
	    r.ni.set(0,0,1);
	    qj.vmult(r.ni, r.ni);
	    r.ni.negate(r.ni); // body i is the sphere, flip normal
	    r.ni.normalize(); // Needed?
	
	    // Vector from sphere center to contact point
	    r.ni.mult(si.radius, r.ri);
	
	    // Project down sphere on plane
	    xi.vsub(xj, point_on_plane_to_sphere);
	    r.ni.mult(r.ni.dot(point_on_plane_to_sphere), plane_to_sphere_ortho);
	    point_on_plane_to_sphere.vsub(plane_to_sphere_ortho,r.rj); // The sphere position projected to plane
	
	    if(plane_to_sphere_ortho.norm2() <= si.radius * si.radius){
	        result.push(r);
	
	        // Make it relative to the body
	        var ri = r.ri;
	        var rj = r.rj;
	        ri.vadd(xi, ri);
	        ri.vsub(bi.position, ri);
	        rj.vadd(xj, rj);
	        rj.vsub(bj.position, rj);
	    }
	};
	
	// See http://bulletphysics.com/Bullet/BulletFull/SphereTriangleDetector_8cpp_source.html
	var pointInPolygon_edge = new Vec3();
	var pointInPolygon_edge_x_normal = new Vec3();
	var pointInPolygon_vtp = new Vec3();
	function pointInPolygon(verts, normal, p){
	    var positiveResult = null;
	    var N = verts.length;
	    for(var i=0; i!==N; i++){
	        var v = verts[i];
	
	        // Get edge to the next vertex
	        var edge = pointInPolygon_edge;
	        verts[(i+1) % (N)].vsub(v,edge);
	
	        // Get cross product between polygon normal and the edge
	        var edge_x_normal = pointInPolygon_edge_x_normal;
	        //var edge_x_normal = new Vec3();
	        edge.cross(normal,edge_x_normal);
	
	        // Get vector between point and current vertex
	        var vertex_to_p = pointInPolygon_vtp;
	        p.vsub(v,vertex_to_p);
	
	        // This dot product determines which side of the edge the point is
	        var r = edge_x_normal.dot(vertex_to_p);
	
	        // If all such dot products have same sign, we are inside the polygon.
	        if(positiveResult===null || (r>0 && positiveResult===true) || (r<=0 && positiveResult===false)){
	            if(positiveResult===null){
	                positiveResult = r>0;
	            }
	            continue;
	        } else {
	            return false; // Encountered some other sign. Exit.
	        }
	    }
	
	    // If we got here, all dot products were of the same sign.
	    return true;
	}
	
	var box_to_sphere = new Vec3();
	var sphereBox_ns = new Vec3();
	var sphereBox_ns1 = new Vec3();
	var sphereBox_ns2 = new Vec3();
	var sphereBox_sides = [new Vec3(),new Vec3(),new Vec3(),new Vec3(),new Vec3(),new Vec3()];
	var sphereBox_sphere_to_corner = new Vec3();
	var sphereBox_side_ns = new Vec3();
	var sphereBox_side_ns1 = new Vec3();
	var sphereBox_side_ns2 = new Vec3();
	
	/**
	 * @method sphereBox
	 * @param  {Array}      result
	 * @param  {Shape}      si
	 * @param  {Shape}      sj
	 * @param  {Vec3}       xi
	 * @param  {Vec3}       xj
	 * @param  {Quaternion} qi
	 * @param  {Quaternion} qj
	 * @param  {Body}       bi
	 * @param  {Body}       bj
	 */
	Narrowphase.prototype[Shape.types.SPHERE | Shape.types.BOX] =
	Narrowphase.prototype.sphereBox = function(result,si,sj,xi,xj,qi,qj,bi,bj){
	    var v3pool = this.v3pool;
	
	    // we refer to the box as body j
	    var sides = sphereBox_sides;
	    xi.vsub(xj,box_to_sphere);
	    sj.getSideNormals(sides,qj);
	    var R =     si.radius;
	    var penetrating_sides = [];
	
	    // Check side (plane) intersections
	    var found = false;
	
	    // Store the resulting side penetration info
	    var side_ns = sphereBox_side_ns;
	    var side_ns1 = sphereBox_side_ns1;
	    var side_ns2 = sphereBox_side_ns2;
	    var side_h = null;
	    var side_penetrations = 0;
	    var side_dot1 = 0;
	    var side_dot2 = 0;
	    var side_distance = null;
	    for(var idx=0,nsides=sides.length; idx!==nsides && found===false; idx++){
	        // Get the plane side normal (ns)
	        var ns = sphereBox_ns;
	        ns.copy(sides[idx]);
	
	        var h = ns.norm();
	        ns.normalize();
	
	        // The normal/distance dot product tells which side of the plane we are
	        var dot = box_to_sphere.dot(ns);
	
	        if(dot<h+R && dot>0){
	            // Intersects plane. Now check the other two dimensions
	            var ns1 = sphereBox_ns1;
	            var ns2 = sphereBox_ns2;
	            ns1.copy(sides[(idx+1)%3]);
	            ns2.copy(sides[(idx+2)%3]);
	            var h1 = ns1.norm();
	            var h2 = ns2.norm();
	            ns1.normalize();
	            ns2.normalize();
	            var dot1 = box_to_sphere.dot(ns1);
	            var dot2 = box_to_sphere.dot(ns2);
	            if(dot1<h1 && dot1>-h1 && dot2<h2 && dot2>-h2){
	                var dist = Math.abs(dot-h-R);
	                if(side_distance===null || dist < side_distance){
	                    side_distance = dist;
	                    side_dot1 = dot1;
	                    side_dot2 = dot2;
	                    side_h = h;
	                    side_ns.copy(ns);
	                    side_ns1.copy(ns1);
	                    side_ns2.copy(ns2);
	                    side_penetrations++;
	                }
	            }
	        }
	    }
	    if(side_penetrations){
	        found = true;
	        var r = this.makeResult(bi,bj,si,sj);
	        side_ns.mult(-R,r.ri); // Sphere r
	        r.ni.copy(side_ns);
	        r.ni.negate(r.ni); // Normal should be out of sphere
	        side_ns.mult(side_h,side_ns);
	        side_ns1.mult(side_dot1,side_ns1);
	        side_ns.vadd(side_ns1,side_ns);
	        side_ns2.mult(side_dot2,side_ns2);
	        side_ns.vadd(side_ns2,r.rj);
	
	        // Make relative to bodies
	        r.ri.vadd(xi, r.ri);
	        r.ri.vsub(bi.position, r.ri);
	        r.rj.vadd(xj, r.rj);
	        r.rj.vsub(bj.position, r.rj);
	
	        result.push(r);
	    }
	
	    // Check corners
	    var rj = v3pool.get();
	    var sphere_to_corner = sphereBox_sphere_to_corner;
	    for(var j=0; j!==2 && !found; j++){
	        for(var k=0; k!==2 && !found; k++){
	            for(var l=0; l!==2 && !found; l++){
	                rj.set(0,0,0);
	                if(j){
	                    rj.vadd(sides[0],rj);
	                } else {
	                    rj.vsub(sides[0],rj);
	                }
	                if(k){
	                    rj.vadd(sides[1],rj);
	                } else {
	                    rj.vsub(sides[1],rj);
	                }
	                if(l){
	                    rj.vadd(sides[2],rj);
	                } else {
	                    rj.vsub(sides[2],rj);
	                }
	
	                // World position of corner
	                xj.vadd(rj,sphere_to_corner);
	                sphere_to_corner.vsub(xi,sphere_to_corner);
	
	                if(sphere_to_corner.norm2() < R*R){
	                    found = true;
	                    var r = this.makeResult(bi,bj,si,sj);
	                    r.ri.copy(sphere_to_corner);
	                    r.ri.normalize();
	                    r.ni.copy(r.ri);
	                    r.ri.mult(R,r.ri);
	                    r.rj.copy(rj);
	
	                    // Make relative to bodies
	                    r.ri.vadd(xi, r.ri);
	                    r.ri.vsub(bi.position, r.ri);
	                    r.rj.vadd(xj, r.rj);
	                    r.rj.vsub(bj.position, r.rj);
	
	                    result.push(r);
	                }
	            }
	        }
	    }
	    v3pool.release(rj);
	    rj = null;
	
	    // Check edges
	    var edgeTangent = v3pool.get();
	    var edgeCenter = v3pool.get();
	    var r = v3pool.get(); // r = edge center to sphere center
	    var orthogonal = v3pool.get();
	    var dist = v3pool.get();
	    var Nsides = sides.length;
	    for(var j=0; j!==Nsides && !found; j++){
	        for(var k=0; k!==Nsides && !found; k++){
	            if(j%3 !== k%3){
	                // Get edge tangent
	                sides[k].cross(sides[j],edgeTangent);
	                edgeTangent.normalize();
	                sides[j].vadd(sides[k], edgeCenter);
	                r.copy(xi);
	                r.vsub(edgeCenter,r);
	                r.vsub(xj,r);
	                var orthonorm = r.dot(edgeTangent); // distance from edge center to sphere center in the tangent direction
	                edgeTangent.mult(orthonorm,orthogonal); // Vector from edge center to sphere center in the tangent direction
	
	                // Find the third side orthogonal to this one
	                var l = 0;
	                while(l===j%3 || l===k%3){
	                    l++;
	                }
	
	                // vec from edge center to sphere projected to the plane orthogonal to the edge tangent
	                dist.copy(xi);
	                dist.vsub(orthogonal,dist);
	                dist.vsub(edgeCenter,dist);
	                dist.vsub(xj,dist);
	
	                // Distances in tangent direction and distance in the plane orthogonal to it
	                var tdist = Math.abs(orthonorm);
	                var ndist = dist.norm();
	
	                if(tdist < sides[l].norm() && ndist<R){
	                    found = true;
	                    var res = this.makeResult(bi,bj,si,sj);
	                    edgeCenter.vadd(orthogonal,res.rj); // box rj
	                    res.rj.copy(res.rj);
	                    dist.negate(res.ni);
	                    res.ni.normalize();
	
	                    res.ri.copy(res.rj);
	                    res.ri.vadd(xj,res.ri);
	                    res.ri.vsub(xi,res.ri);
	                    res.ri.normalize();
	                    res.ri.mult(R,res.ri);
	
	                    // Make relative to bodies
	                    res.ri.vadd(xi, res.ri);
	                    res.ri.vsub(bi.position, res.ri);
	                    res.rj.vadd(xj, res.rj);
	                    res.rj.vsub(bj.position, res.rj);
	
	                    result.push(res);
	                }
	            }
	        }
	    }
	    v3pool.release(edgeTangent,edgeCenter,r,orthogonal,dist);
	};
	
	var convex_to_sphere = new Vec3();
	var sphereConvex_edge = new Vec3();
	var sphereConvex_edgeUnit = new Vec3();
	var sphereConvex_sphereToCorner = new Vec3();
	var sphereConvex_worldCorner = new Vec3();
	var sphereConvex_worldNormal = new Vec3();
	var sphereConvex_worldPoint = new Vec3();
	var sphereConvex_worldSpherePointClosestToPlane = new Vec3();
	var sphereConvex_penetrationVec = new Vec3();
	var sphereConvex_sphereToWorldPoint = new Vec3();
	
	/**
	 * @method sphereConvex
	 * @param  {Array}      result
	 * @param  {Shape}      si
	 * @param  {Shape}      sj
	 * @param  {Vec3}       xi
	 * @param  {Vec3}       xj
	 * @param  {Quaternion} qi
	 * @param  {Quaternion} qj
	 * @param  {Body}       bi
	 * @param  {Body}       bj
	 */
	Narrowphase.prototype[Shape.types.SPHERE | Shape.types.CONVEXPOLYHEDRON] =
	Narrowphase.prototype.sphereConvex = function(result,si,sj,xi,xj,qi,qj,bi,bj){
	    var v3pool = this.v3pool;
	    xi.vsub(xj,convex_to_sphere);
	    var normals = sj.faceNormals;
	    var faces = sj.faces;
	    var verts = sj.vertices;
	    var R =     si.radius;
	    var penetrating_sides = [];
	
	    if(convex_to_sphere.norm2() > si.boundingSphereRadius + sj.boundingSphereRadius){
	        return;
	    }
	
	    // Check corners
	    for(var i=0; i!==verts.length; i++){
	        var v = verts[i];
	
	        // World position of corner
	        var worldCorner = sphereConvex_worldCorner;
	        qj.vmult(v,worldCorner);
	        xj.vadd(worldCorner,worldCorner);
	        var sphere_to_corner = sphereConvex_sphereToCorner;
	        worldCorner.vsub(xi, sphere_to_corner);
	        if(sphere_to_corner.norm2() < R * R){
	            found = true;
	            var r = this.makeResult(bi,bj,si,sj);
	            r.ri.copy(sphere_to_corner);
	            r.ri.normalize();
	            r.ni.copy(r.ri);
	            r.ri.mult(R,r.ri);
	            worldCorner.vsub(xj,r.rj);
	
	            // Should be relative to the body.
	            r.ri.vadd(xi, r.ri);
	            r.ri.vsub(bi.position, r.ri);
	
	            // Should be relative to the body.
	            r.rj.vadd(xj, r.rj);
	            r.rj.vsub(bj.position, r.rj);
	
	            result.push(r);
	            return;
	        }
	    }
	
	    // Check side (plane) intersections
	    var found = false;
	    for(var i=0, nfaces=faces.length; i!==nfaces && found===false; i++){
	        var normal = normals[i];
	        var face = faces[i];
	
	        // Get world-transformed normal of the face
	        var worldNormal = sphereConvex_worldNormal;
	        qj.vmult(normal,worldNormal);
	
	        // Get a world vertex from the face
	        var worldPoint = sphereConvex_worldPoint;
	        qj.vmult(verts[face[0]],worldPoint);
	        worldPoint.vadd(xj,worldPoint);
	
	        // Get a point on the sphere, closest to the face normal
	        var worldSpherePointClosestToPlane = sphereConvex_worldSpherePointClosestToPlane;
	        worldNormal.mult(-R, worldSpherePointClosestToPlane);
	        xi.vadd(worldSpherePointClosestToPlane, worldSpherePointClosestToPlane);
	
	        // Vector from a face point to the closest point on the sphere
	        var penetrationVec = sphereConvex_penetrationVec;
	        worldSpherePointClosestToPlane.vsub(worldPoint,penetrationVec);
	
	        // The penetration. Negative value means overlap.
	        var penetration = penetrationVec.dot(worldNormal);
	
	        var worldPointToSphere = sphereConvex_sphereToWorldPoint;
	        xi.vsub(worldPoint, worldPointToSphere);
	
	        if(penetration < 0 && worldPointToSphere.dot(worldNormal)>0){
	            // Intersects plane. Now check if the sphere is inside the face polygon
	            var faceVerts = []; // Face vertices, in world coords
	            for(var j=0, Nverts=face.length; j!==Nverts; j++){
	                var worldVertex = v3pool.get();
	                qj.vmult(verts[face[j]], worldVertex);
	                xj.vadd(worldVertex,worldVertex);
	                faceVerts.push(worldVertex);
	            }
	
	            if(pointInPolygon(faceVerts,worldNormal,xi)){ // Is the sphere center in the face polygon?
	                found = true;
	                var r = this.makeResult(bi,bj,si,sj);
	
	                worldNormal.mult(-R, r.ri); // Contact offset, from sphere center to contact
	                worldNormal.negate(r.ni); // Normal pointing out of sphere
	
	                var penetrationVec2 = v3pool.get();
	                worldNormal.mult(-penetration, penetrationVec2);
	                var penetrationSpherePoint = v3pool.get();
	                worldNormal.mult(-R, penetrationSpherePoint);
	
	                //xi.vsub(xj).vadd(penetrationSpherePoint).vadd(penetrationVec2 , r.rj);
	                xi.vsub(xj,r.rj);
	                r.rj.vadd(penetrationSpherePoint,r.rj);
	                r.rj.vadd(penetrationVec2 , r.rj);
	
	                // Should be relative to the body.
	                r.rj.vadd(xj, r.rj);
	                r.rj.vsub(bj.position, r.rj);
	
	                // Should be relative to the body.
	                r.ri.vadd(xi, r.ri);
	                r.ri.vsub(bi.position, r.ri);
	
	                v3pool.release(penetrationVec2);
	                v3pool.release(penetrationSpherePoint);
	
	                result.push(r);
	
	                // Release world vertices
	                for(var j=0, Nfaceverts=faceVerts.length; j!==Nfaceverts; j++){
	                    v3pool.release(faceVerts[j]);
	                }
	
	                return; // We only expect *one* face contact
	            } else {
	                // Edge?
	                for(var j=0; j!==face.length; j++){
	
	                    // Get two world transformed vertices
	                    var v1 = v3pool.get();
	                    var v2 = v3pool.get();
	                    qj.vmult(verts[face[(j+1)%face.length]], v1);
	                    qj.vmult(verts[face[(j+2)%face.length]], v2);
	                    xj.vadd(v1, v1);
	                    xj.vadd(v2, v2);
	
	                    // Construct edge vector
	                    var edge = sphereConvex_edge;
	                    v2.vsub(v1,edge);
	
	                    // Construct the same vector, but normalized
	                    var edgeUnit = sphereConvex_edgeUnit;
	                    edge.unit(edgeUnit);
	
	                    // p is xi projected onto the edge
	                    var p = v3pool.get();
	                    var v1_to_xi = v3pool.get();
	                    xi.vsub(v1, v1_to_xi);
	                    var dot = v1_to_xi.dot(edgeUnit);
	                    edgeUnit.mult(dot, p);
	                    p.vadd(v1, p);
	
	                    // Compute a vector from p to the center of the sphere
	                    var xi_to_p = v3pool.get();
	                    p.vsub(xi, xi_to_p);
	
	                    // Collision if the edge-sphere distance is less than the radius
	                    // AND if p is in between v1 and v2
	                    if(dot > 0 && dot*dot<edge.norm2() && xi_to_p.norm2() < R*R){ // Collision if the edge-sphere distance is less than the radius
	                        // Edge contact!
	                        var r = this.makeResult(bi,bj,si,sj);
	                        p.vsub(xj,r.rj);
	
	                        p.vsub(xi,r.ni);
	                        r.ni.normalize();
	
	                        r.ni.mult(R,r.ri);
	
	                        // Should be relative to the body.
	                        r.rj.vadd(xj, r.rj);
	                        r.rj.vsub(bj.position, r.rj);
	
	                        // Should be relative to the body.
	                        r.ri.vadd(xi, r.ri);
	                        r.ri.vsub(bi.position, r.ri);
	
	                        result.push(r);
	
	                        // Release world vertices
	                        for(var j=0, Nfaceverts=faceVerts.length; j!==Nfaceverts; j++){
	                            v3pool.release(faceVerts[j]);
	                        }
	
	                        v3pool.release(v1);
	                        v3pool.release(v2);
	                        v3pool.release(p);
	                        v3pool.release(xi_to_p);
	                        v3pool.release(v1_to_xi);
	
	                        return;
	                    }
	
	                    v3pool.release(v1);
	                    v3pool.release(v2);
	                    v3pool.release(p);
	                    v3pool.release(xi_to_p);
	                    v3pool.release(v1_to_xi);
	                }
	            }
	
	            // Release world vertices
	            for(var j=0, Nfaceverts=faceVerts.length; j!==Nfaceverts; j++){
	                v3pool.release(faceVerts[j]);
	            }
	        }
	    }
	};
	
	var planeBox_normal = new Vec3();
	var plane_to_corner = new Vec3();
	
	/**
	 * @method planeBox
	 * @param  {Array}      result
	 * @param  {Shape}      si
	 * @param  {Shape}      sj
	 * @param  {Vec3}       xi
	 * @param  {Vec3}       xj
	 * @param  {Quaternion} qi
	 * @param  {Quaternion} qj
	 * @param  {Body}       bi
	 * @param  {Body}       bj
	 */
	Narrowphase.prototype[Shape.types.PLANE | Shape.types.BOX] =
	Narrowphase.prototype.planeBox = function(result,si,sj,xi,xj,qi,qj,bi,bj){
	    this.planeConvex(result,si,sj.convexPolyhedronRepresentation,xi,xj,qi,qj,bi,bj);
	};
	
	var planeConvex_v = new Vec3();
	var planeConvex_normal = new Vec3();
	var planeConvex_relpos = new Vec3();
	var planeConvex_projected = new Vec3();
	
	/**
	 * @method planeConvex
	 * @param  {Array}      result
	 * @param  {Shape}      si
	 * @param  {Shape}      sj
	 * @param  {Vec3}       xi
	 * @param  {Vec3}       xj
	 * @param  {Quaternion} qi
	 * @param  {Quaternion} qj
	 * @param  {Body}       bi
	 * @param  {Body}       bj
	 */
	Narrowphase.prototype[Shape.types.PLANE | Shape.types.CONVEXPOLYHEDRON] =
	Narrowphase.prototype.planeConvex = function(
	    result,
	    planeShape,
	    convexShape,
	    planePosition,
	    convexPosition,
	    planeQuat,
	    convexQuat,
	    planeBody,
	    convexBody
	){
	    // Simply return the points behind the plane.
	    var worldVertex = planeConvex_v,
	        worldNormal = planeConvex_normal;
	    worldNormal.set(0,0,1);
	    planeQuat.vmult(worldNormal,worldNormal); // Turn normal according to plane orientation
	
	    var relpos = planeConvex_relpos;
	    for(var i = 0; i !== convexShape.vertices.length; i++){
	
	        // Get world convex vertex
	        worldVertex.copy(convexShape.vertices[i]);
	        convexQuat.vmult(worldVertex, worldVertex);
	        convexPosition.vadd(worldVertex, worldVertex);
	        worldVertex.vsub(planePosition, relpos);
	
	        var dot = worldNormal.dot(relpos);
	        if(dot <= 0.0){
	
	            var r = this.makeResult(planeBody, convexBody, planeShape, convexShape);
	
	            // Get vertex position projected on plane
	            var projected = planeConvex_projected;
	            worldNormal.mult(worldNormal.dot(relpos),projected);
	            worldVertex.vsub(projected, projected);
	            projected.vsub(planePosition, r.ri); // From plane to vertex projected on plane
	
	            r.ni.copy(worldNormal); // Contact normal is the plane normal out from plane
	
	            // rj is now just the vector from the convex center to the vertex
	            worldVertex.vsub(convexPosition, r.rj);
	
	            // Make it relative to the body
	            r.ri.vadd(planePosition, r.ri);
	            r.ri.vsub(planeBody.position, r.ri);
	            r.rj.vadd(convexPosition, r.rj);
	            r.rj.vsub(convexBody.position, r.rj);
	
	            result.push(r);
	        }
	    }
	};
	
	var convexConvex_sepAxis = new Vec3();
	var convexConvex_q = new Vec3();
	
	/**
	 * @method convexConvex
	 * @param  {Array}      result
	 * @param  {Shape}      si
	 * @param  {Shape}      sj
	 * @param  {Vec3}       xi
	 * @param  {Vec3}       xj
	 * @param  {Quaternion} qi
	 * @param  {Quaternion} qj
	 * @param  {Body}       bi
	 * @param  {Body}       bj
	 */
	Narrowphase.prototype[Shape.types.CONVEXPOLYHEDRON] =
	Narrowphase.prototype.convexConvex = function(result,si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj){
	    var sepAxis = convexConvex_sepAxis;
	
	    if(xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius){
	        return;
	    }
	
	    if(si.findSeparatingAxis(sj,xi,qi,xj,qj,sepAxis)){
	        var res = [];
	        var q = convexConvex_q;
	        si.clipAgainstHull(xi,qi,sj,xj,qj,sepAxis,-100,100,res);
	        for(var j = 0; j !== res.length; j++){
	            var r = this.makeResult(bi,bj,si,sj,rsi,rsj),
	                ri = r.ri,
	                rj = r.rj;
	            sepAxis.negate(r.ni);
	            res[j].normal.negate(q);
	            q.mult(res[j].depth, q);
	            res[j].point.vadd(q, ri);
	            rj.copy(res[j].point);
	
	            // Contact points are in world coordinates. Transform back to relative
	            ri.vsub(xi,ri);
	            rj.vsub(xj,rj);
	
	            // Make relative to bodies
	            ri.vadd(xi, ri);
	            ri.vsub(bi.position, ri);
	            rj.vadd(xj, rj);
	            rj.vsub(bj.position, rj);
	
	            result.push(r);
	        }
	    }
	};
	
	var particlePlane_normal = new Vec3();
	var particlePlane_relpos = new Vec3();
	var particlePlane_projected = new Vec3();
	
	/**
	 * @method particlePlane
	 * @param  {Array}      result
	 * @param  {Shape}      si
	 * @param  {Shape}      sj
	 * @param  {Vec3}       xi
	 * @param  {Vec3}       xj
	 * @param  {Quaternion} qi
	 * @param  {Quaternion} qj
	 * @param  {Body}       bi
	 * @param  {Body}       bj
	 */
	Narrowphase.prototype[Shape.types.PLANE | Shape.types.PARTICLE] =
	Narrowphase.prototype.planeParticle = function(result,sj,si,xj,xi,qj,qi,bj,bi){
	    var normal = particlePlane_normal;
	    normal.set(0,0,1);
	    bj.quaternion.vmult(normal,normal); // Turn normal according to plane orientation
	    var relpos = particlePlane_relpos;
	    xi.vsub(bj.position,relpos);
	    var dot = normal.dot(relpos);
	    if(dot <= 0.0){
	        var r = this.makeResult(bi,bj,si,sj);
	        r.ni.copy(normal); // Contact normal is the plane normal
	        r.ni.negate(r.ni);
	        r.ri.set(0,0,0); // Center of particle
	
	        // Get particle position projected on plane
	        var projected = particlePlane_projected;
	        normal.mult(normal.dot(xi),projected);
	        xi.vsub(projected,projected);
	        //projected.vadd(bj.position,projected);
	
	        // rj is now the projected world position minus plane position
	        r.rj.copy(projected);
	        result.push(r);
	    }
	};
	
	var particleSphere_normal = new Vec3();
	
	/**
	 * @method particleSphere
	 * @param  {Array}      result
	 * @param  {Shape}      si
	 * @param  {Shape}      sj
	 * @param  {Vec3}       xi
	 * @param  {Vec3}       xj
	 * @param  {Quaternion} qi
	 * @param  {Quaternion} qj
	 * @param  {Body}       bi
	 * @param  {Body}       bj
	 */
	Narrowphase.prototype[Shape.types.PARTICLE | Shape.types.SPHERE] =
	Narrowphase.prototype.sphereParticle = function(result,sj,si,xj,xi,qj,qi,bj,bi){
	    // The normal is the unit vector from sphere center to particle center
	    var normal = particleSphere_normal;
	    normal.set(0,0,1);
	    xi.vsub(xj,normal);
	    var lengthSquared = normal.norm2();
	
	    if(lengthSquared <= sj.radius * sj.radius){
	        var r = this.makeResult(bi,bj,si,sj);
	        normal.normalize();
	        r.rj.copy(normal);
	        r.rj.mult(sj.radius,r.rj);
	        r.ni.copy(normal); // Contact normal
	        r.ni.negate(r.ni);
	        r.ri.set(0,0,0); // Center of particle
	        result.push(r);
	    }
	};
	
	// WIP
	var cqj = new Quaternion();
	var convexParticle_local = new Vec3();
	var convexParticle_normal = new Vec3();
	var convexParticle_penetratedFaceNormal = new Vec3();
	var convexParticle_vertexToParticle = new Vec3();
	var convexParticle_worldPenetrationVec = new Vec3();
	
	/**
	 * @method convexParticle
	 * @param  {Array}      result
	 * @param  {Shape}      si
	 * @param  {Shape}      sj
	 * @param  {Vec3}       xi
	 * @param  {Vec3}       xj
	 * @param  {Quaternion} qi
	 * @param  {Quaternion} qj
	 * @param  {Body}       bi
	 * @param  {Body}       bj
	 */
	Narrowphase.prototype[Shape.types.PARTICLE | Shape.types.CONVEXPOLYHEDRON] =
	Narrowphase.prototype.convexParticle = function(result,sj,si,xj,xi,qj,qi,bj,bi){
	    var penetratedFaceIndex = -1;
	    var penetratedFaceNormal = convexParticle_penetratedFaceNormal;
	    var worldPenetrationVec = convexParticle_worldPenetrationVec;
	    var minPenetration = null;
	    var numDetectedFaces = 0;
	
	    // Convert particle position xi to local coords in the convex
	    var local = convexParticle_local;
	    local.copy(xi);
	    local.vsub(xj,local); // Convert position to relative the convex origin
	    qj.conjugate(cqj);
	    cqj.vmult(local,local);
	
	    if(sj.pointIsInside(local)){
	
	        if(sj.worldVerticesNeedsUpdate){
	            sj.computeWorldVertices(xj,qj);
	        }
	        if(sj.worldFaceNormalsNeedsUpdate){
	            sj.computeWorldFaceNormals(qj);
	        }
	
	        // For each world polygon in the polyhedra
	        for(var i=0,nfaces=sj.faces.length; i!==nfaces; i++){
	
	            // Construct world face vertices
	            var verts = [ sj.worldVertices[ sj.faces[i][0] ] ];
	            var normal = sj.worldFaceNormals[i];
	
	            // Check how much the particle penetrates the polygon plane.
	            xi.vsub(verts[0],convexParticle_vertexToParticle);
	            var penetration = -normal.dot(convexParticle_vertexToParticle);
	            if(minPenetration===null || Math.abs(penetration)<Math.abs(minPenetration)){
	                minPenetration = penetration;
	                penetratedFaceIndex = i;
	                penetratedFaceNormal.copy(normal);
	                numDetectedFaces++;
	            }
	        }
	
	        if(penetratedFaceIndex!==-1){
	            // Setup contact
	            var r = this.makeResult(bi,bj,si,sj);
	            penetratedFaceNormal.mult(minPenetration, worldPenetrationVec);
	
	            // rj is the particle position projected to the face
	            worldPenetrationVec.vadd(xi,worldPenetrationVec);
	            worldPenetrationVec.vsub(xj,worldPenetrationVec);
	            r.rj.copy(worldPenetrationVec);
	            //var projectedToFace = xi.vsub(xj).vadd(worldPenetrationVec);
	            //projectedToFace.copy(r.rj);
	
	            //qj.vmult(r.rj,r.rj);
	            penetratedFaceNormal.negate( r.ni ); // Contact normal
	            r.ri.set(0,0,0); // Center of particle
	
	            var ri = r.ri,
	                rj = r.rj;
	
	            // Make relative to bodies
	            ri.vadd(xi, ri);
	            ri.vsub(bi.position, ri);
	            rj.vadd(xj, rj);
	            rj.vsub(bj.position, rj);
	
	            result.push(r);
	        } else {
	            console.warn("Point found inside convex, but did not find penetrating face!");
	        }
	    }
	};
	
	Narrowphase.prototype[Shape.types.BOX | Shape.types.HEIGHTFIELD] =
	Narrowphase.prototype.boxHeightfield = function (result,si,sj,xi,xj,qi,qj,bi,bj){
	    this.convexHeightfield(result,si.convexPolyhedronRepresentation,sj,xi,xj,qi,qj,bi,bj);
	};
	
	var convexHeightfield_tmp1 = new Vec3();
	var convexHeightfield_tmp2 = new Vec3();
	
	/**
	 * @method sphereHeightfield
	 */
	Narrowphase.prototype[Shape.types.CONVEXPOLYHEDRON | Shape.types.HEIGHTFIELD] =
	Narrowphase.prototype.convexHeightfield = function (
	    result,
	    convexShape,
	    hfShape,
	    convexPos,
	    hfPos,
	    convexQuat,
	    hfQuat,
	    convexBody,
	    hfBody
	){
	    var data = hfShape.data,
	        w = hfShape.elementSize,
	        radius = convexShape.boundingSphereRadius,
	        worldPillarOffset = convexHeightfield_tmp2;
	
	    // Get sphere position to heightfield local!
	    var localConvexPos = convexHeightfield_tmp1;
	    Transform.pointToLocalFrame(hfPos, hfQuat, convexPos, localConvexPos);
	
	    // Get the index of the data points to test against
	    var iMinX = Math.floor((localConvexPos.x - radius) / w) - 1,
	        iMaxX = Math.ceil((localConvexPos.x + radius) / w) + 1,
	        iMinY = Math.floor((localConvexPos.y - radius) / w) - 1,
	        iMaxY = Math.ceil((localConvexPos.y + radius) / w) + 1;
	
	    // Bail out if we are out of the terrain
	    if(iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMaxY > data[0].length){
	        return;
	    }
	
	    // Clamp index to edges
	    if(iMinX < 0){ iMinX = 0; }
	    if(iMaxX < 0){ iMaxX = 0; }
	    if(iMinY < 0){ iMinY = 0; }
	    if(iMaxY < 0){ iMaxY = 0; }
	    if(iMinX >= data.length){ iMinX = data.length - 1; }
	    if(iMaxX >= data.length){ iMaxX = data.length - 1; }
	    if(iMaxY >= data[0].length){ iMaxY = data[0].length - 1; }
	    if(iMinY >= data[0].length){ iMinY = data[0].length - 1; }
	
	    var minMax = [];
	    hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);
	    var min = minMax[0];
	    var max = minMax[1];
	
	    // Bail out if we're cant touch the bounding height box
	    if(localConvexPos.z - radius > max || localConvexPos.z + radius < min){
	        return;
	    }
	
	    for(var i = iMinX; i < iMaxX; i++){
	        for(var j = iMinY; j < iMaxY; j++){
	
	            // Lower triangle
	            hfShape.getConvexTrianglePillar(i, j, false);
	            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);
	            this.convexConvex(result, convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset, convexQuat, hfQuat, convexBody, hfBody);
	
	            // Upper triangle
	            hfShape.getConvexTrianglePillar(i, j, true);
	            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);
	            this.convexConvex(result, convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset, convexQuat, hfQuat, convexBody, hfBody);
	        }
	    }
	};
	
	
	
	
	var sphereHeightfield_tmp1 = new Vec3();
	var sphereHeightfield_tmp2 = new Vec3();
	
	/**
	 * @method sphereHeightfield
	 */
	Narrowphase.prototype[Shape.types.SPHERE | Shape.types.HEIGHTFIELD] =
	Narrowphase.prototype.sphereHeightfield = function (
	    result,
	    sphereShape,
	    hfShape,
	    spherePos,
	    hfPos,
	    sphereQuat,
	    hfQuat,
	    sphereBody,
	    hfBody
	){
	    var data = hfShape.data,
	        radius = sphereShape.radius,
	        w = hfShape.elementSize,
	        worldPillarOffset = sphereHeightfield_tmp2;
	
	    // Get sphere position to heightfield local!
	    var localSpherePos = sphereHeightfield_tmp1;
	    Transform.pointToLocalFrame(hfPos, hfQuat, spherePos, localSpherePos);
	
	    // Get the index of the data points to test against
	    var iMinX = Math.floor((localSpherePos.x - radius) / w) - 1,
	        iMaxX = Math.ceil((localSpherePos.x + radius) / w) + 1,
	        iMinY = Math.floor((localSpherePos.y - radius) / w) - 1,
	        iMaxY = Math.ceil((localSpherePos.y + radius) / w) + 1;
	
	    // Bail out if we are out of the terrain
	    if(iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMaxY > data[0].length){
	        return;
	    }
	
	    // Clamp index to edges
	    if(iMinX < 0){ iMinX = 0; }
	    if(iMaxX < 0){ iMaxX = 0; }
	    if(iMinY < 0){ iMinY = 0; }
	    if(iMaxY < 0){ iMaxY = 0; }
	    if(iMinX >= data.length){ iMinX = data.length - 1; }
	    if(iMaxX >= data.length){ iMaxX = data.length - 1; }
	    if(iMaxY >= data[0].length){ iMaxY = data[0].length - 1; }
	    if(iMinY >= data[0].length){ iMinY = data[0].length - 1; }
	
	    var minMax = [];
	    hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);
	    var min = minMax[0];
	    var max = minMax[1];
	
	    // Bail out if we're cant touch the bounding height box
	    if(localSpherePos.z - radius > max || localSpherePos.z + radius < min){
	        return;
	    }
	
	    for(var i = iMinX; i < iMaxX; i++){
	        for(var j = iMinY; j < iMaxY; j++){
	
	            var numContactsBefore = result.length;
	
	            // Lower triangle
	            hfShape.getConvexTrianglePillar(i, j, false);
	            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);
	            this.sphereConvex(result, sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset, sphereQuat, hfQuat, sphereBody, hfBody);
	
	            // Upper triangle
	            hfShape.getConvexTrianglePillar(i, j, true);
	            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);
	            this.sphereConvex(result, sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset, sphereQuat, hfQuat, sphereBody, hfBody);
	
	            var numContacts = result.length - numContactsBefore;
	
	            if(numContacts > 2){
	                return;
	            }
	            /*
	            // Skip all but 1
	            for (var k = 0; k < numContacts - 1; k++) {
	                result.pop();
	            }
	            */
	        }
	    }
	};
	},{"../equations/ContactEquation":16,"../math/Quaternion":25,"../math/Transform":26,"../math/Vec3":27,"../shapes/ConvexPolyhedron":35,"../shapes/Shape":40,"../solver/Solver":43,"../utils/Vec3Pool":49}],51:[function(_dereq_,module,exports){
	/* global performance */
	
	module.exports = World;
	
	var Shape = _dereq_('../shapes/Shape');
	var Vec3 = _dereq_('../math/Vec3');
	var Quaternion = _dereq_('../math/Quaternion');
	var GSSolver = _dereq_('../solver/GSSolver');
	var Vec3Pool = _dereq_('../utils/Vec3Pool');
	var ContactEquation = _dereq_('../equations/ContactEquation');
	var FrictionEquation = _dereq_('../equations/FrictionEquation');
	var Narrowphase = _dereq_('./Narrowphase');
	var EventTarget = _dereq_('../utils/EventTarget');
	var ArrayCollisionMatrix = _dereq_('../collision/ArrayCollisionMatrix');
	var Material = _dereq_('../material/Material');
	var ContactMaterial = _dereq_('../material/ContactMaterial');
	var Body = _dereq_('../objects/Body');
	var TupleDictionary = _dereq_('../utils/TupleDictionary');
	var RaycastResult = _dereq_('../collision/RaycastResult');
	var AABB = _dereq_('../collision/AABB');
	var Ray = _dereq_('../collision/Ray');
	var NaiveBroadphase = _dereq_('../collision/NaiveBroadphase');
	
	/**
	 * The physics world
	 * @class World
	 * @constructor
	 * @extends EventTarget
	 */
	function World(){
	    EventTarget.apply(this);
	
	    /**
	     * Last used timestep. Is set to -1 if not available.
	     * @property {Number} dt
	     */
	    this.dt = -1;
	
	    /**
	     * Makes bodies go to sleep when they've been inactive
	     * @property allowSleep
	     * @type {Boolean}
	     */
	    this.allowSleep = false;
	
	    /**
	     * All the current contacts (instances of ContactEquation) in the world.
	     * @property contacts
	     * @type {Array}
	     */
	    this.contacts = [];
	    this.frictionEquations = [];
	
	    /**
	     * How often to normalize quaternions. Set to 0 for every step, 1 for every second etc.. A larger value increases performance. If bodies tend to explode, set to a smaller value (zero to be sure nothing can go wrong).
	     * @property quatNormalizeSkip
	     * @type {Number}
	     */
	    this.quatNormalizeSkip = 0;
	
	    /**
	     * Set to true to use fast quaternion normalization. It is often enough accurate to use. If bodies tend to explode, set to false.
	     * @property quatNormalizeFast
	     * @type {Boolean}
	     * @see Quaternion.normalizeFast
	     * @see Quaternion.normalize
	     */
	    this.quatNormalizeFast = false;
	
	    /**
	     * The wall-clock time since simulation start
	     * @property time
	     * @type {Number}
	     */
	    this.time = 0.0;
	
	    /**
	     * Number of timesteps taken since start
	     * @property stepnumber
	     * @type {Number}
	     */
	    this.stepnumber = 0;
	
	    /// Default and last timestep sizes
	    this.default_dt = 1/60;
	
	    this.nextId = 0;
	    /**
	     * @property gravity
	     * @type {Vec3}
	     */
	    this.gravity = new Vec3();
	
	    /**
	     * @property broadphase
	     * @type {Broadphase}
	     */
	    this.broadphase = new NaiveBroadphase();
	
	    /**
	     * @property bodies
	     * @type {Array}
	     */
	    this.bodies = [];
	
	    /**
	     * @property solver
	     * @type {Solver}
	     */
	    this.solver = new GSSolver();
	
	    /**
	     * @property constraints
	     * @type {Array}
	     */
	    this.constraints = [];
	
	    /**
	     * @property narrowphase
	     * @type {Narrowphase}
	     */
	    this.narrowphase = new Narrowphase();
	
	    /**
	     * @property {ArrayCollisionMatrix} collisionMatrix
		 * @type {ArrayCollisionMatrix}
		 */
		this.collisionMatrix = new ArrayCollisionMatrix();
	
	    /**
	     * CollisionMatrix from the previous step.
	     * @property {ArrayCollisionMatrix} collisionMatrixPrevious
		 * @type {ArrayCollisionMatrix}
		 */
		this.collisionMatrixPrevious = new ArrayCollisionMatrix();
	
	    /**
	     * All added materials
	     * @property materials
	     * @type {Array}
	     */
	    this.materials = [];
	
	    /**
	     * @property contactmaterials
	     * @type {Array}
	     */
	    this.contactmaterials = [];
	
	    /**
	     * Used to look up a ContactMaterial given two instances of Material.
	     * @property {TupleDictionary} contactMaterialTable
	     */
	    this.contactMaterialTable = new TupleDictionary();
	
	    this.defaultMaterial = new Material("default");
	
	    /**
	     * This contact material is used if no suitable contactmaterial is found for a contact.
	     * @property defaultContactMaterial
	     * @type {ContactMaterial}
	     */
	    this.defaultContactMaterial = new ContactMaterial(this.defaultMaterial, this.defaultMaterial, { friction: 0.3, restitution: 0.0 });
	
	    /**
	     * @property doProfiling
	     * @type {Boolean}
	     */
	    this.doProfiling = false;
	
	    /**
	     * @property profile
	     * @type {Object}
	     */
	    this.profile = {
	        solve:0,
	        makeContactConstraints:0,
	        broadphase:0,
	        integrate:0,
	        narrowphase:0,
	    };
	
	    /**
	     * @property subystems
	     * @type {Array}
	     */
	    this.subsystems = [];
	
	    this.addBodyEvent = {
	        type:"addBody",
	        body : null,
	    };
	
	    this.removeBodyEvent = {
	        type:"removeBody",
	        body : null,
	    };
	}
	World.prototype = new EventTarget();
	
	// Temp stuff
	var tmpAABB1 = new AABB();
	var tmpArray1 = [];
	var tmpRay = new Ray();
	
	/**
	 * Get the contact material between materials m1 and m2
	 * @method getContactMaterial
	 * @param {Material} m1
	 * @param {Material} m2
	 * @return {Contactmaterial} The contact material if it was found.
	 */
	World.prototype.getContactMaterial = function(m1,m2){
	    return this.contactMaterialTable.get(m1.id,m2.id); //this.contactmaterials[this.mats2cmat[i+j*this.materials.length]];
	};
	
	/**
	 * Get number of objects in the world.
	 * @method numObjects
	 * @return {Number}
	 * @deprecated
	 */
	World.prototype.numObjects = function(){
	    return this.bodies.length;
	};
	
	/**
	 * Store old collision state info
	 * @method collisionMatrixTick
	 */
	World.prototype.collisionMatrixTick = function(){
		var temp = this.collisionMatrixPrevious;
		this.collisionMatrixPrevious = this.collisionMatrix;
		this.collisionMatrix = temp;
		this.collisionMatrix.reset();
	};
	
	/**
	 * Add a rigid body to the simulation.
	 * @method add
	 * @param {Body} body
	 * @todo If the simulation has not yet started, why recrete and copy arrays for each body? Accumulate in dynamic arrays in this case.
	 * @todo Adding an array of bodies should be possible. This would save some loops too
	 * @deprecated Use .addBody instead
	 */
	World.prototype.add = World.prototype.addBody = function(body){
	    if(this.bodies.indexOf(body) !== -1){
	        return;
	    }
	    body.index = this.bodies.length;
	    this.bodies.push(body);
	    body.world = this;
	    body.initPosition.copy(body.position);
	    body.initVelocity.copy(body.velocity);
	    body.timeLastSleepy = this.time;
	    if(body instanceof Body){
	        body.initAngularVelocity.copy(body.angularVelocity);
	        body.initQuaternion.copy(body.quaternion);
	    }
		this.collisionMatrix.setNumObjects(this.bodies.length);
	    this.addBodyEvent.body = body;
	    this.dispatchEvent(this.addBodyEvent);
	};
	
	/**
	 * Add a constraint to the simulation.
	 * @method addConstraint
	 * @param {Constraint} c
	 */
	World.prototype.addConstraint = function(c){
	    this.constraints.push(c);
	};
	
	/**
	 * Removes a constraint
	 * @method removeConstraint
	 * @param {Constraint} c
	 */
	World.prototype.removeConstraint = function(c){
	    var idx = this.constraints.indexOf(c);
	    if(idx!==-1){
	        this.constraints.splice(idx,1);
	    }
	};
	
	/**
	 * Raycast test
	 * @method rayTest
	 * @param {Vec3} from
	 * @param {Vec3} to
	 * @param {Function|RaycastResult} result
	 */
	World.prototype.rayTest = function(from, to, result){
	    // result = result || new RaycastResult();
	
	    tmpArray1[0] = from;
	    tmpArray1[1] = to;
	    tmpAABB1.setFromPoints(tmpArray1);
	    tmpArray1.length = 0;
	
	    this.broadphase.aabbQuery(this, tmpAABB1, tmpArray1);
	
	    tmpRay.from.copy(from);
	    tmpRay.to.copy(to);
	
	    tmpRay.intersectBodies(tmpArray1, result);
	};
	
	/**
	 * Remove a rigid body from the simulation.
	 * @method remove
	 * @param {Body} body
	 * @todo Rename to .removeBody
	 */
	World.prototype.remove = function(body){
	    body.world = null;
	    var n = this.bodies.length-1,
	        bodies = this.bodies,
	        idx = bodies.indexOf(body);
	    if(idx !== -1){
	        bodies.splice(idx, 1); // Todo: should use a garbage free method
	
	        // Recompute index
	        for(var i=0; i!==bodies.length; i++){
	            bodies[i].index = i;
	        }
	
	        this.collisionMatrix.setNumObjects(n);
	        this.removeBodyEvent.body = body;
	        this.dispatchEvent(this.removeBodyEvent);
	    }
	};
	
	/**
	 * Adds a material to the World.
	 * @method addMaterial
	 * @param {Material} m
	 * @todo Necessary?
	 */
	World.prototype.addMaterial = function(m){
	    this.materials.push(m);
	};
	
	/**
	 * Adds a contact material to the World
	 * @method addContactMaterial
	 * @param {ContactMaterial} cmat
	 */
	World.prototype.addContactMaterial = function(cmat) {
	
	    // Add contact material
	    this.contactmaterials.push(cmat);
	
	    // Add current contact material to the material table
	    this.contactMaterialTable.set(cmat.materials[0].id,cmat.materials[1].id,cmat);
	};
	
	// performance.now()
	if(typeof performance === 'undefined'){
	    performance = {};
	}
	if(!performance.now){
	    var nowOffset = Date.now();
	    if (performance.timing && performance.timing.navigationStart){
	        nowOffset = performance.timing.navigationStart;
	    }
	    performance.now = function(){
	        return Date.now() - nowOffset;
	    };
	}
	
	var step_tmp1 = new Vec3();
	
	/**
	 * Step the physics world forward in time.
	 *
	 * There are two modes. The simple mode is fixed timestepping without interpolation. In this case you only use the first argument. The second case uses interpolation. In that you also provide the time since the function was last used, as well as the maximum fixed timesteps to take.
	 *
	 * @method step
	 * @param {Number} dt                       The fixed time step size to use.
	 * @param {Number} [timeSinceLastCalled]    The time elapsed since the function was last called.
	 * @param {Number} [maxSubSteps=10]         Maximum number of fixed steps to take per function call.
	 *
	 * @example
	 *     // fixed timestepping without interpolation
	 *     world.step(1/60);
	 *
	 * @see http://bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World
	 */
	World.prototype.step = function(dt, timeSinceLastCalled, maxSubSteps){
	    maxSubSteps = maxSubSteps || 10;
	    timeSinceLastCalled = timeSinceLastCalled || 0;
	
	    if(timeSinceLastCalled === 0){ // Fixed, simple stepping
	
	        this.internalStep(dt);
	
	        // Increment time
	        this.time += dt;
	
	    } else {
	
	        // Compute the number of fixed steps we should have taken since the last step
	        var internalSteps = Math.floor((this.time + timeSinceLastCalled) / dt) - Math.floor(this.time / dt);
	        internalSteps = Math.min(internalSteps,maxSubSteps);
	
	        // Do some fixed steps to catch up
	        var t0 = performance.now();
	        for(var i=0; i!==internalSteps; i++){
	            this.internalStep(dt);
	            if(performance.now() - t0 > dt * 1000){
	                // We are slower than real-time. Better bail out.
	                break;
	            }
	        }
	
	        // Increment internal clock
	        this.time += timeSinceLastCalled;
	
	        // Compute "Left over" time step
	        var h = this.time % dt;
	        var h_div_dt = h / dt;
	        var interpvelo = step_tmp1;
	        var bodies = this.bodies;
	
	        for(var j=0; j !== bodies.length; j++){
	            var b = bodies[j];
	            if(b.type !== Body.STATIC && b.sleepState !== Body.SLEEPING){
	
	                // Interpolate
	                b.position.vsub(b.previousPosition, interpvelo);
	                interpvelo.scale(h_div_dt, interpvelo);
	                b.position.vadd(interpvelo, b.interpolatedPosition);
	
	                // TODO: interpolate quaternion
	                // b.interpolatedAngle = b.angle + (b.angle - b.previousAngle) * h_div_dt;
	
	            } else {
	
	                // For static bodies, just copy. Who else will do it?
	                b.interpolatedPosition.copy(b.position);
	                b.interpolatedQuaternion.copy(b.quaternion);
	            }
	        }
	    }
	};
	
	/**
	 * Step the simulation
	 * @method step
	 * @param {Number} dt
	 */
	var World_step_postStepEvent = {type:"postStep"}, // Reusable event objects to save memory
	    World_step_preStepEvent = {type:"preStep"},
	    World_step_collideEvent = {type:"collide", body:null, contact:null },
	    World_step_oldContacts = [], // Pools for unused objects
	    World_step_frictionEquationPool = [],
	    World_step_p1 = [], // Reusable arrays for collision pairs
	    World_step_p2 = [],
	    World_step_gvec = new Vec3(), // Temporary vectors and quats
	    World_step_vi = new Vec3(),
	    World_step_vj = new Vec3(),
	    World_step_wi = new Vec3(),
	    World_step_wj = new Vec3(),
	    World_step_t1 = new Vec3(),
	    World_step_t2 = new Vec3(),
	    World_step_rixn = new Vec3(),
	    World_step_rjxn = new Vec3(),
	    World_step_step_q = new Quaternion(),
	    World_step_step_w = new Quaternion(),
	    World_step_step_wq = new Quaternion(),
	    invI_tau_dt = new Vec3();
	World.prototype.internalStep = function(dt){
	    this.dt = dt;
	
	    var world = this,
	        that = this,
	        contacts = this.contacts,
	        p1 = World_step_p1,
	        p2 = World_step_p2,
	        N = this.numObjects(),
	        bodies = this.bodies,
	        solver = this.solver,
	        gravity = this.gravity,
	        doProfiling = this.doProfiling,
	        profile = this.profile,
	        DYNAMIC = Body.DYNAMIC,
	        profilingStart,
	        constraints = this.constraints,
	        frictionEquationPool = World_step_frictionEquationPool,
	        gnorm = gravity.norm(),
	        gx = gravity.x,
	        gy = gravity.y,
	        gz = gravity.z,
	        i=0;
	
	    if(doProfiling){
	        profilingStart = performance.now();
	    }
	
	    // Add gravity to all objects
	    for(i=0; i!==N; i++){
	        var bi = bodies[i];
	        if(bi.type & DYNAMIC){ // Only for dynamic bodies
	            var f = bi.force, m = bi.mass;
	            f.x += m*gx;
	            f.y += m*gy;
	            f.z += m*gz;
	        }
	    }
	
	    // Update subsystems
	    for(var i=0, Nsubsystems=this.subsystems.length; i!==Nsubsystems; i++){
	        this.subsystems[i].update();
	    }
	
	    // Collision detection
	    if(doProfiling){ profilingStart = performance.now(); }
	    p1.length = 0; // Clean up pair arrays from last step
	    p2.length = 0;
	    this.broadphase.collisionPairs(this,p1,p2);
	    if(doProfiling){ profile.broadphase = performance.now() - profilingStart; }
	
	    // Remove constrained pairs with collideConnected == false
	    var Nconstraints = constraints.length;
	    for(i=0; i!==Nconstraints; i++){
	        var c = constraints[i];
	        if(!c.collideConnected){
	            for(var j = p1.length-1; j>=0; j-=1){
	                if( (c.bodyA === p1[j] && c.bodyB === p2[j]) ||
	                    (c.bodyB === p1[j] && c.bodyA === p2[j])){
	                    p1.splice(j, 1);
	                    p2.splice(j, 1);
	                }
	            }
	        }
	    }
	
	    this.collisionMatrixTick();
	
	    // Generate contacts
	    if(doProfiling){ profilingStart = performance.now(); }
	    var oldcontacts = World_step_oldContacts;
	    var NoldContacts = contacts.length;
	
	    for(i=0; i!==NoldContacts; i++){
	        oldcontacts.push(contacts[i]);
	    }
	    contacts.length = 0;
	
	    this.narrowphase.getContacts(p1,p2,
	                                this,
	                                contacts,
	                                oldcontacts // To be reused
	                                );
	    if(doProfiling){
	        profile.narrowphase = performance.now() - profilingStart;
	    }
	
	    // Loop over all collisions
	    if(doProfiling){
	        profilingStart = performance.now();
	    }
	    var ncontacts = contacts.length;
	
	    // Transfer FrictionEquation from current list to the pool for reuse
	    var NoldFrictionEquations = this.frictionEquations.length;
	    for(i=0; i!==NoldFrictionEquations; i++){
	        frictionEquationPool.push(this.frictionEquations[i]);
	    }
	    this.frictionEquations.length = 0;
	
	    for(var k=0; k!==ncontacts; k++){
	
	        // Current contact
	        var c = contacts[k];
	
	        // Get current collision indeces
	        var bi = c.bi,
	            bj = c.bj,
	            si = c.si,
	            sj = c.sj;
	
	        // Resolve indices
	        var i = bodies.indexOf(bi), j = bodies.indexOf(bj);
	
	        // Get collision properties
	        var cm;
	        if(bi.material && bj.material){
	            cm = this.getContactMaterial(bi.material,bj.material) || this.defaultContactMaterial;
	        } else {
	            cm = this.defaultContactMaterial;
	        }
	        var mu = cm.friction;
	
	        // g = ( xj + rj - xi - ri ) .dot ( ni )
	        var gvec = World_step_gvec;
	        gvec.set(bj.position.x + c.rj.x - bi.position.x - c.ri.x,
	                 bj.position.y + c.rj.y - bi.position.y - c.ri.y,
	                 bj.position.z + c.rj.z - bi.position.z - c.ri.z);
	        var g = gvec.dot(c.ni); // Gap, negative if penetration
	
	        // Action if penetration
	        if(g < 0.0){
	
	            c.enabled = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;
	
				c.restitution = cm.restitution;
				c.penetration = g;
				c.setSpookParams(cm.contactEquationStiffness,
	                             cm.contactEquationRelaxation,
	                             dt);
	
				solver.addEquation(c);
	
				// Add friction constraint equation
				if(mu > 0){
	
					// Create 2 tangent equations
					var mug = mu*gnorm;
					var reducedMass = (bi.invMass + bj.invMass);
					if(reducedMass > 0){
						reducedMass = 1/reducedMass;
					}
					var pool = frictionEquationPool;
					var c1 = pool.length ? pool.pop() : new FrictionEquation(bi,bj,mug*reducedMass);
					var c2 = pool.length ? pool.pop() : new FrictionEquation(bi,bj,mug*reducedMass);
					this.frictionEquations.push(c1);
					this.frictionEquations.push(c2);
	
					c1.bi = c2.bi = bi;
					c1.bj = c2.bj = bj;
					c1.minForce = c2.minForce = -mug*reducedMass;
					c1.maxForce = c2.maxForce = mug*reducedMass;
	
					// Copy over the relative vectors
					c1.ri.copy(c.ri);
					c1.rj.copy(c.rj);
					c2.ri.copy(c.ri);
					c2.rj.copy(c.rj);
	
					// Construct tangents
					c.ni.tangents(c1.t, c2.t);
	
	                // Set spook params
	                c1.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, dt);
	                c2.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, dt);
	
	                c1.enabled = c2.enabled = c.enabled;
	
					// Add equations to solver
					solver.addEquation(c1);
					solver.addEquation(c2);
				}
	
	            if( bi.allowSleep &&
	                bi.type === Body.DYNAMIC &&
	                bi.sleepState  === Body.SLEEPING &&
	                bj.sleepState  === Body.AWAKE &&
	                bj.type !== Body.STATIC
	            ){
	                var speedSquaredB = bj.velocity.norm2() + bj.angularVelocity.norm2();
	                var speedLimitSquaredB = Math.pow(bj.sleepSpeedLimit,2);
	                if(speedSquaredB >= speedLimitSquaredB*2){
	                    bi._wakeUpAfterNarrowphase = true;
	                }
	            }
	
	            if( bj.allowSleep &&
	                bj.type === Body.DYNAMIC &&
	                bj.sleepState  === Body.SLEEPING &&
	                bi.sleepState  === Body.AWAKE &&
	                bi.type !== Body.STATIC
	            ){
	                var speedSquaredA = bi.velocity.norm2() + bi.angularVelocity.norm2();
	                var speedLimitSquaredA = Math.pow(bi.sleepSpeedLimit,2);
	                if(speedSquaredA >= speedLimitSquaredA*2){
	                    bj._wakeUpAfterNarrowphase = true;
	                }
	            }
	
	            // Now we know that i and j are in contact. Set collision matrix state
				this.collisionMatrix.set(bi, bj, true);
	
	            if (this.collisionMatrix.get(bi, bj) !== this.collisionMatrixPrevious.get(bi, bj)) {
	                // First contact!
	                // We reuse the collideEvent object, otherwise we will end up creating new objects for each new contact, even if there's no event listener attached.
	                World_step_collideEvent.body = bj;
	                World_step_collideEvent.contact = c;
	                bi.dispatchEvent(World_step_collideEvent);
	
	                World_step_collideEvent.body = bi;
	                bj.dispatchEvent(World_step_collideEvent);
	
	                /*
	                bi.wakeUp();
	                bj.wakeUp();
	                */
	            }
	        }
	    }
	    if(doProfiling){
	        profile.makeContactConstraints = performance.now() - profilingStart;
	        profilingStart = performance.now();
	    }
	
	    // Wake up bodies
	    for(i=0; i!==N; i++){
	        var bi = bodies[i];
	        if(bi._wakeUpAfterNarrowphase){
	            bi.wakeUp();
	            bi._wakeUpAfterNarrowphase = false;
	        }
	    }
	
	    // Add user-added constraints
	    var Nconstraints = constraints.length;
	    for(i=0; i!==Nconstraints; i++){
	        var c = constraints[i];
	        c.update();
	        for(var j=0, Neq=c.equations.length; j!==Neq; j++){
	            var eq = c.equations[j];
	            solver.addEquation(eq);
	        }
	    }
	
	    // Solve the constrained system
	    solver.solve(dt,this);
	
	    if(doProfiling){
	        profile.solve = performance.now() - profilingStart;
	    }
	
	    // Remove all contacts from solver
	    solver.removeAllEquations();
	
	    // Apply damping, see http://code.google.com/p/bullet/issues/detail?id=74 for details
	    var pow = Math.pow;
	    for(i=0; i!==N; i++){
	        var bi = bodies[i];
	        if(bi.type & DYNAMIC){ // Only for dynamic bodies
	            var ld = pow(1.0 - bi.linearDamping,dt);
	            var v = bi.velocity;
	            v.mult(ld,v);
	            var av = bi.angularVelocity;
	            if(av){
	                var ad = pow(1.0 - bi.angularDamping,dt);
	                av.mult(ad,av);
	            }
	        }
	    }
	
	    this.dispatchEvent(World_step_preStepEvent);
	
	    // Invoke pre-step callbacks
	    for(i=0; i!==N; i++){
	        var bi = bodies[i];
	        if(bi.preStep){
	            bi.preStep.call(bi);
	        }
	    }
	
	    // Leap frog
	    // vnew = v + h*f/m
	    // xnew = x + h*vnew
	    if(doProfiling){
	        profilingStart = performance.now();
	    }
	    var q = World_step_step_q;
	    var w = World_step_step_w;
	    var wq = World_step_step_wq;
	    var stepnumber = this.stepnumber;
	    var DYNAMIC_OR_KINEMATIC = Body.DYNAMIC | Body.KINEMATIC;
	    var quatNormalize = stepnumber % (this.quatNormalizeSkip+1) === 0;
	    var quatNormalizeFast = this.quatNormalizeFast;
	    var half_dt = dt * 0.5;
	    var PLANE = Shape.types.PLANE,
	        CONVEX = Shape.types.CONVEXPOLYHEDRON;
	
	    for(i=0; i!==N; i++){
	        var b = bodies[i],
	            s = b.shape,
	            force = b.force,
	            tau = b.tau;
	        if((b.type & DYNAMIC_OR_KINEMATIC) && b.sleepState !== Body.SLEEPING){ // Only for dynamic
	            var velo = b.velocity,
	                angularVelo = b.angularVelocity,
	                pos = b.position,
	                quat = b.quaternion,
	                invMass = b.invMass,
	                invInertia = b.invInertiaWorld;
	
	            velo.x += force.x * invMass * dt;
	            velo.y += force.y * invMass * dt;
	            velo.z += force.z * invMass * dt;
	
	            if(b.angularVelocity){
	                invInertia.vmult(tau,invI_tau_dt);
	                invI_tau_dt.mult(dt,invI_tau_dt);
	                invI_tau_dt.vadd(angularVelo,angularVelo);
	                //console.log(invI_tau_dt);
	                /*
	                angularVelo.x += tau.x * invInertia.x * dt;
	                angularVelo.y += tau.y * invInertia.y * dt;
	                angularVelo.z += tau.z * invInertia.z * dt;
	                */
	            }
	
	            // Use new velocity  - leap frog
	            pos.x += velo.x * dt;
	            pos.y += velo.y * dt;
	            pos.z += velo.z * dt;
	
	            if(b.angularVelocity){
	                w.set(angularVelo.x, angularVelo.y, angularVelo.z, 0);
	                w.mult(quat,wq);
	                quat.x += half_dt * wq.x;
	                quat.y += half_dt * wq.y;
	                quat.z += half_dt * wq.z;
	                quat.w += half_dt * wq.w;
	                if(quatNormalize){
	                    if(quatNormalizeFast){
	                        quat.normalizeFast();
	                    } else {
	                        quat.normalize();
	                    }
	                }
	            }
	
	            if(b.aabb){
	                b.aabbNeedsUpdate = true;
	            }
	
	            if(s){
	                switch(s.type){
	                case PLANE:
	                    s.worldNormalNeedsUpdate = true;
	                    break;
	                case CONVEX:
	                    s.worldFaceNormalsNeedsUpdate = true;
	                    s.worldVerticesNeedsUpdate = true;
	                    break;
	                }
	            }
	
	            // Update world inertia
	            if(b.updateInertiaWorld){
	                b.updateInertiaWorld();
	            }
	        }
	        b.force.set(0,0,0);
	        if(b.tau){
	            b.tau.set(0,0,0);
	        }
	
	    }
	
	    this.broadphase.dirty = true;
	
	    if(doProfiling){
	        profile.integrate = performance.now() - profilingStart;
	    }
	
	    // Update world time
	    this.time += dt;
	    this.stepnumber += 1;
	
	    this.dispatchEvent(World_step_postStepEvent);
	
	    // Invoke post-step callbacks
	    for(i=0; i!==N; i++){
	        var bi = bodies[i];
	        var postStep = bi.postStep;
	        if(postStep){
	            postStep.call(bi);
	        }
	    }
	
	    // Sleeping update
	    if(this.allowSleep){
	        for(i=0; i!==N; i++){
	            bodies[i].sleepTick(this.time);
	        }
	    }
	};
	
	},{"../collision/AABB":3,"../collision/ArrayCollisionMatrix":4,"../collision/NaiveBroadphase":7,"../collision/Ray":9,"../collision/RaycastResult":10,"../equations/ContactEquation":16,"../equations/FrictionEquation":18,"../material/ContactMaterial":21,"../material/Material":22,"../math/Quaternion":25,"../math/Vec3":27,"../objects/Body":28,"../shapes/Shape":40,"../solver/GSSolver":42,"../utils/EventTarget":45,"../utils/TupleDictionary":47,"../utils/Vec3Pool":49,"./Narrowphase":50}]},{},[2])
	(2)
	});

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _three = __webpack_require__(11);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _TerrainView = __webpack_require__(13);
	
	var _TerrainView2 = _interopRequireDefault(_TerrainView);
	
	var _System = __webpack_require__(4);
	
	var _System2 = _interopRequireDefault(_System);
	
	var _MeshComponent = __webpack_require__(29);
	
	var _MeshComponent2 = _interopRequireDefault(_MeshComponent);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var FPTGameView = _System2.default.createClass({
	
		constructor: function constructor(fptGame) {
			this.game = fptGame;
	
			this.scene = new _three2.default.Scene();
			this.camera = new _three2.default.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
			this.camera.position.setZ(10);
			this.scene.add(this.camera);
	
			this.renderer = new _three2.default.WebGLRenderer();
			this.renderer.shadowMapType = _three2.default.PCFSoftShadowMap;
			this.renderer.shadowMapEnabled = true;
			this.renderer.shadowMapSoft = true;
			this.renderer.setClearColorHex(0xffffff);
			this.renderer.setSize(window.innerWidth, window.innerHeight);
			this.element = this.renderer.domElement;
	
			this.terrain = _TerrainView2.default.create(fptGame.level.terrain);
			this.scene.add(this.terrain.three);
	
			var tick = function () {
				this.tick();
				requestAnimationFrame(tick);
			}.bind(this);
	
			requestAnimationFrame(tick);
		},
	
		tick: function tick() {
	
			this.tickSubsystems();
	
			this.game.entities.forEach(function (entity) {
				var view = entity.get('view');
				var physics = entity.get('physics');
				var mesh = entity.get('mesh');
				if (view && physics) {
					if (!mesh) {
						mesh = _MeshComponent2.default.create();
						this.scene.add(mesh.three);
						entity.set('mesh', mesh);
					}
					var position = physics.position;
					var rotation = physics.rotation;
					mesh.three.position.set(position.x, position.y, position.z);
					mesh.three.useQuaternion = true;
					mesh.three.quaternion.set(rotation.x, rotation.y, rotation.z, rotation.w);
				}
			}.bind(this));
	
			this.renderer.render(this.scene, this.camera);
		},
		exportLevel: function exportLevel() {
			var w = window.open("", "");
			w.document.write(JSON.stringify(this.game.level.export()));
			w.document.close();
		}
	});
	
	FPTGameView.create = function (fptGame) {
		return new FPTGameView(fptGame);
	};
	
	exports.default = FPTGameView;

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {
	var window = window || {};
	var self = self || {};
	
	// High-resulution counter: emulate window.performance.now() for THREE.CLOCK
	if( window.performance === undefined ) {
	
		window.performance = { };
	
	}
	
	if( window.performance.now === undefined ) {
	
		window.performance.now = function () {
	
			var time = process.hrtime();
			return ( time[0] + time[1] / 1e9 ) * 1000;
	
		};
	
	}
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Larry Battle / http://bateru.com/news
	 */
	
	var THREE = THREE || { REVISION: '56' };
	
	self.console = self.console || {
	
		info: function () {},
		log: function () {},
		debug: function () {},
		warn: function () {},
		error: function () {}
	
	};
	
	self.Int32Array = self.Int32Array || Array;
	self.Float32Array = self.Float32Array || Array;
	
	String.prototype.trim = String.prototype.trim || function () {
	
		return this.replace( /^\s+|\s+$/g, '' );
	
	};
	
	// based on https://github.com/documentcloud/underscore/blob/bf657be243a075b5e72acc8a83e6f12a564d8f55/underscore.js#L767
	THREE.extend = function ( obj, source ) {
	
		// ECMAScript5 compatibility based on: http://www.nczonline.net/blog/2012/12/11/are-your-mixins-ecmascript-5-compatible/
		if ( Object.keys ) {
	
			var keys = Object.keys( source );
	
			for (var i = 0, il = keys.length; i < il; i++) {
	
				var prop = keys[i];
				Object.defineProperty( obj, prop, Object.getOwnPropertyDescriptor( source, prop ) );
	
			}
	
		} else {
	
			var safeHasOwnProperty = {}.hasOwnProperty;
	
			for ( var prop in source ) {
	
				if ( safeHasOwnProperty.call( source, prop ) ) {
	
					obj[prop] = source[prop];
	
				}
	
			}
	
		}
	
		return obj;
	
	};
	
	// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
	// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
	
	// requestAnimationFrame polyfill by Erik Möller
	// fixes from Paul Irish and Tino Zijdel
	
	( function () {
	
		var lastTime = 0;
		var vendors = [ 'ms', 'moz', 'webkit', 'o' ];
	
		for ( var x = 0; x < vendors.length && !window.requestAnimationFrame; ++ x ) {
	
			window.requestAnimationFrame = window[ vendors[ x ] + 'RequestAnimationFrame' ];
			window.cancelAnimationFrame = window[ vendors[ x ] + 'CancelAnimationFrame' ] || window[ vendors[ x ] + 'CancelRequestAnimationFrame' ];
	
		}
	
		if ( window.requestAnimationFrame === undefined ) {
	
			window.requestAnimationFrame = function ( callback ) {
	
				var currTime = Date.now(), timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );
				var id = window.setTimeout( function() { callback( currTime + timeToCall ); }, timeToCall );
				lastTime = currTime + timeToCall;
				return id;
	
			};
	
		}
	
		window.cancelAnimationFrame = window.cancelAnimationFrame || function ( id ) { window.clearTimeout( id ) };
	
	}() );
	
	// GL STATE CONSTANTS
	
	THREE.CullFaceNone = 0;
	THREE.CullFaceBack = 1;
	THREE.CullFaceFront = 2;
	THREE.CullFaceFrontBack = 3;
	
	THREE.FrontFaceDirectionCW = 0;
	THREE.FrontFaceDirectionCCW = 1;
	
	// SHADOWING TYPES
	
	THREE.BasicShadowMap = 0;
	THREE.PCFShadowMap = 1;
	THREE.PCFSoftShadowMap = 2;
	
	// MATERIAL CONSTANTS
	
	// side
	
	THREE.FrontSide = 0;
	THREE.BackSide = 1;
	THREE.DoubleSide = 2;
	
	// shading
	
	THREE.NoShading = 0;
	THREE.FlatShading = 1;
	THREE.SmoothShading = 2;
	
	// colors
	
	THREE.NoColors = 0;
	THREE.FaceColors = 1;
	THREE.VertexColors = 2;
	
	// blending modes
	
	THREE.NoBlending = 0;
	THREE.NormalBlending = 1;
	THREE.AdditiveBlending = 2;
	THREE.SubtractiveBlending = 3;
	THREE.MultiplyBlending = 4;
	THREE.CustomBlending = 5;
	
	// custom blending equations
	// (numbers start from 100 not to clash with other
	//  mappings to OpenGL constants defined in Texture.js)
	
	THREE.AddEquation = 100;
	THREE.SubtractEquation = 101;
	THREE.ReverseSubtractEquation = 102;
	
	// custom blending destination factors
	
	THREE.ZeroFactor = 200;
	THREE.OneFactor = 201;
	THREE.SrcColorFactor = 202;
	THREE.OneMinusSrcColorFactor = 203;
	THREE.SrcAlphaFactor = 204;
	THREE.OneMinusSrcAlphaFactor = 205;
	THREE.DstAlphaFactor = 206;
	THREE.OneMinusDstAlphaFactor = 207;
	
	// custom blending source factors
	
	//THREE.ZeroFactor = 200;
	//THREE.OneFactor = 201;
	//THREE.SrcAlphaFactor = 204;
	//THREE.OneMinusSrcAlphaFactor = 205;
	//THREE.DstAlphaFactor = 206;
	//THREE.OneMinusDstAlphaFactor = 207;
	THREE.DstColorFactor = 208;
	THREE.OneMinusDstColorFactor = 209;
	THREE.SrcAlphaSaturateFactor = 210;
	
	
	// TEXTURE CONSTANTS
	
	THREE.MultiplyOperation = 0;
	THREE.MixOperation = 1;
	THREE.AddOperation = 2;
	
	// Mapping modes
	
	THREE.UVMapping = function () {};
	
	THREE.CubeReflectionMapping = function () {};
	THREE.CubeRefractionMapping = function () {};
	
	THREE.SphericalReflectionMapping = function () {};
	THREE.SphericalRefractionMapping = function () {};
	
	// Wrapping modes
	
	THREE.RepeatWrapping = 1000;
	THREE.ClampToEdgeWrapping = 1001;
	THREE.MirroredRepeatWrapping = 1002;
	
	// Filters
	
	THREE.NearestFilter = 1003;
	THREE.NearestMipMapNearestFilter = 1004;
	THREE.NearestMipMapLinearFilter = 1005;
	THREE.LinearFilter = 1006;
	THREE.LinearMipMapNearestFilter = 1007;
	THREE.LinearMipMapLinearFilter = 1008;
	
	// Data types
	
	THREE.UnsignedByteType = 1009;
	THREE.ByteType = 1010;
	THREE.ShortType = 1011;
	THREE.UnsignedShortType = 1012;
	THREE.IntType = 1013;
	THREE.UnsignedIntType = 1014;
	THREE.FloatType = 1015;
	
	// Pixel types
	
	//THREE.UnsignedByteType = 1009;
	THREE.UnsignedShort4444Type = 1016;
	THREE.UnsignedShort5551Type = 1017;
	THREE.UnsignedShort565Type = 1018;
	
	// Pixel formats
	
	THREE.AlphaFormat = 1019;
	THREE.RGBFormat = 1020;
	THREE.RGBAFormat = 1021;
	THREE.LuminanceFormat = 1022;
	THREE.LuminanceAlphaFormat = 1023;
	
	// Compressed texture formats
	
	THREE.RGB_S3TC_DXT1_Format = 2001;
	THREE.RGBA_S3TC_DXT1_Format = 2002;
	THREE.RGBA_S3TC_DXT3_Format = 2003;
	THREE.RGBA_S3TC_DXT5_Format = 2004;
	
	/*
	// Potential future PVRTC compressed texture formats
	THREE.RGB_PVRTC_4BPPV1_Format = 2100;
	THREE.RGB_PVRTC_2BPPV1_Format = 2101;
	THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
	THREE.RGBA_PVRTC_2BPPV1_Format = 2103;
	*/
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Color = function ( value ) {
	
		if ( value !== undefined ) this.set( value );
	
		return this;
	
	};
	
	THREE.extend( THREE.Color.prototype, {
	
		r: 1, g: 1, b: 1,
	
		set: function ( value ) {
	
			switch ( typeof value ) {
	
				case "number":
					this.setHex( value );
					break;
	
				case "string":
					this.setStyle( value );
					break;
	
			}
	
		},
	
		setHex: function ( hex ) {
	
			hex = Math.floor( hex );
	
			this.r = ( hex >> 16 & 255 ) / 255;
			this.g = ( hex >> 8 & 255 ) / 255;
			this.b = ( hex & 255 ) / 255;
	
			return this;
	
		},
	
		setRGB: function ( r, g, b ) {
	
			this.r = r;
			this.g = g;
			this.b = b;
	
			return this;
	
		},
	
		setHSV: function ( h, s, v ) {
	
			console.log( 'DEPRECATED: Color\'s .setHSV() will be removed. Use .setHSL( h, s, l ) instead.' );
			return this.setHSL(h,s*v/((h=(2-s)*v)<1?h:2-h),h/2); // https://gist.github.com/xpansive/1337890
	
		},
	
		setHSL: function ( h, s, l ) {
	
			// h,s,l ranges are in 0.0 - 1.0
	
			if ( s === 0 ) {
	
				this.r = this.g = this.b = l;
	
			} else {
	
				var hue2rgb = function ( p, q, t ) {
	
					if ( t < 0 ) t += 1;
					if ( t > 1 ) t -= 1;
					if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
					if ( t < 1 / 2 ) return q;
					if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
					return p;
	
				};
	
				var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
				var q = ( 2 * l ) - p;
	
				this.r = hue2rgb( q, p, h + 1 / 3 );
				this.g = hue2rgb( q, p, h );
				this.b = hue2rgb( q, p, h - 1 / 3 );
	
			}
	
			return this;
	
		},
	
		setStyle: function ( style ) {
	
			// rgb(255,0,0)
	
			if ( /^rgb\((\d+),(\d+),(\d+)\)$/i.test( style ) ) {
	
				var color = /^rgb\((\d+),(\d+),(\d+)\)$/i.exec( style );
	
				this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
				this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
				this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;
	
				return this;
	
			}
	
			// rgb(100%,0%,0%)
	
			if ( /^rgb\((\d+)\%,(\d+)\%,(\d+)\%\)$/i.test( style ) ) {
	
				var color = /^rgb\((\d+)\%,(\d+)\%,(\d+)\%\)$/i.exec( style );
	
				this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
				this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
				this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;
	
				return this;
	
			}
	
			// #ff0000
	
			if ( /^\#([0-9a-f]{6})$/i.test( style ) ) {
	
				var color = /^\#([0-9a-f]{6})$/i.exec( style );
	
				this.setHex( parseInt( color[ 1 ], 16 ) );
	
				return this;
	
			}
	
			// #f00
	
			if ( /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test( style ) ) {
	
				var color = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec( style );
	
				this.setHex( parseInt( color[ 1 ] + color[ 1 ] + color[ 2 ] + color[ 2 ] + color[ 3 ] + color[ 3 ], 16 ) );
	
				return this;
	
			}
	
			// red
	
			if ( /^(\w+)$/i.test( style ) ) {
	
				this.setHex( THREE.ColorKeywords[ style ] );
	
				return this;
	
			}
	
	
		},
	
		copy: function ( color ) {
	
			this.r = color.r;
			this.g = color.g;
			this.b = color.b;
	
			return this;
	
		},
	
		copyGammaToLinear: function ( color ) {
	
			this.r = color.r * color.r;
			this.g = color.g * color.g;
			this.b = color.b * color.b;
	
			return this;
	
		},
	
		copyLinearToGamma: function ( color ) {
	
			this.r = Math.sqrt( color.r );
			this.g = Math.sqrt( color.g );
			this.b = Math.sqrt( color.b );
	
			return this;
	
		},
	
		convertGammaToLinear: function () {
	
			var r = this.r, g = this.g, b = this.b;
	
			this.r = r * r;
			this.g = g * g;
			this.b = b * b;
	
			return this;
	
		},
	
		convertLinearToGamma: function () {
	
			this.r = Math.sqrt( this.r );
			this.g = Math.sqrt( this.g );
			this.b = Math.sqrt( this.b );
	
			return this;
	
		},
	
		getHex: function () {
	
			return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;
	
		},
	
		getHexString: function () {
	
			return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );
	
		},
	
		getHSL: function () {
	
			var hsl = { h: 0, s: 0, l: 0 };
	
			return function () {
	
				// h,s,l ranges are in 0.0 - 1.0
	
				var r = this.r, g = this.g, b = this.b;
	
				var max = Math.max( r, g, b );
				var min = Math.min( r, g, b );
	
				var hue, saturation;
				var lightness = ( min + max ) / 2.0;
	
				if ( min === max ) {
	
					hue = 0;
					saturation = 0;
	
				} else {
	
					var delta = max - min;
	
					saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );
	
					switch ( max ) {
	
						case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
						case g: hue = ( b - r ) / delta + 2; break;
						case b: hue = ( r - g ) / delta + 4; break;
	
					}
	
					hue /= 6;
	
				}
	
				hsl.h = hue;
				hsl.s = saturation;
				hsl.l = lightness;
	
				return hsl;
	
			};
	
		}(),
	
		getStyle: function () {
	
			return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';
	
		},
	
		offsetHSL: function ( h, s, l ) {
	
			var hsl = this.getHSL();
	
			hsl.h += h; hsl.s += s; hsl.l += l;
	
			this.setHSL( hsl.h, hsl.s, hsl.l );
	
			return this;
	
		},
	
		add: function ( color ) {
	
			this.r += color.r;
			this.g += color.g;
			this.b += color.b;
	
			return this;
	
		},
	
		addColors: function ( color1, color2 ) {
	
			this.r = color1.r + color2.r;
			this.g = color1.g + color2.g;
			this.b = color1.b + color2.b;
	
			return this;
	
		},
	
		addScalar: function ( s ) {
	
			this.r += s;
			this.g += s;
			this.b += s;
	
			return this;
	
		},
	
		multiply: function ( color ) {
	
			this.r *= color.r;
			this.g *= color.g;
			this.b *= color.b;
	
			return this;
	
		},
	
		multiplyScalar: function ( s ) {
	
			this.r *= s;
			this.g *= s;
			this.b *= s;
	
			return this;
	
		},
	
		lerp: function ( color, alpha ) {
	
			this.r += ( color.r - this.r ) * alpha;
			this.g += ( color.g - this.g ) * alpha;
			this.b += ( color.b - this.b ) * alpha;
	
			return this;
	
		},
	
		clone: function () {
	
			return new THREE.Color().setRGB( this.r, this.g, this.b );
	
		}
	
	} );
	
	THREE.ColorKeywords = { "aliceblue": 0xF0F8FF, "antiquewhite": 0xFAEBD7, "aqua": 0x00FFFF, "aquamarine": 0x7FFFD4, "azure": 0xF0FFFF,
	"beige": 0xF5F5DC, "bisque": 0xFFE4C4, "black": 0x000000, "blanchedalmond": 0xFFEBCD, "blue": 0x0000FF, "blueviolet": 0x8A2BE2,
	"brown": 0xA52A2A, "burlywood": 0xDEB887, "cadetblue": 0x5F9EA0, "chartreuse": 0x7FFF00, "chocolate": 0xD2691E, "coral": 0xFF7F50,
	"cornflowerblue": 0x6495ED, "cornsilk": 0xFFF8DC, "crimson": 0xDC143C, "cyan": 0x00FFFF, "darkblue": 0x00008B, "darkcyan": 0x008B8B,
	"darkgoldenrod": 0xB8860B, "darkgray": 0xA9A9A9, "darkgreen": 0x006400, "darkgrey": 0xA9A9A9, "darkkhaki": 0xBDB76B, "darkmagenta": 0x8B008B,
	"darkolivegreen": 0x556B2F, "darkorange": 0xFF8C00, "darkorchid": 0x9932CC, "darkred": 0x8B0000, "darksalmon": 0xE9967A, "darkseagreen": 0x8FBC8F,
	"darkslateblue": 0x483D8B, "darkslategray": 0x2F4F4F, "darkslategrey": 0x2F4F4F, "darkturquoise": 0x00CED1, "darkviolet": 0x9400D3,
	"deeppink": 0xFF1493, "deepskyblue": 0x00BFFF, "dimgray": 0x696969, "dimgrey": 0x696969, "dodgerblue": 0x1E90FF, "firebrick": 0xB22222,
	"floralwhite": 0xFFFAF0, "forestgreen": 0x228B22, "fuchsia": 0xFF00FF, "gainsboro": 0xDCDCDC, "ghostwhite": 0xF8F8FF, "gold": 0xFFD700,
	"goldenrod": 0xDAA520, "gray": 0x808080, "green": 0x008000, "greenyellow": 0xADFF2F, "grey": 0x808080, "honeydew": 0xF0FFF0, "hotpink": 0xFF69B4,
	"indianred": 0xCD5C5C, "indigo": 0x4B0082, "ivory": 0xFFFFF0, "khaki": 0xF0E68C, "lavender": 0xE6E6FA, "lavenderblush": 0xFFF0F5, "lawngreen": 0x7CFC00,
	"lemonchiffon": 0xFFFACD, "lightblue": 0xADD8E6, "lightcoral": 0xF08080, "lightcyan": 0xE0FFFF, "lightgoldenrodyellow": 0xFAFAD2, "lightgray": 0xD3D3D3,
	"lightgreen": 0x90EE90, "lightgrey": 0xD3D3D3, "lightpink": 0xFFB6C1, "lightsalmon": 0xFFA07A, "lightseagreen": 0x20B2AA, "lightskyblue": 0x87CEFA,
	"lightslategray": 0x778899, "lightslategrey": 0x778899, "lightsteelblue": 0xB0C4DE, "lightyellow": 0xFFFFE0, "lime": 0x00FF00, "limegreen": 0x32CD32,
	"linen": 0xFAF0E6, "magenta": 0xFF00FF, "maroon": 0x800000, "mediumaquamarine": 0x66CDAA, "mediumblue": 0x0000CD, "mediumorchid": 0xBA55D3,
	"mediumpurple": 0x9370DB, "mediumseagreen": 0x3CB371, "mediumslateblue": 0x7B68EE, "mediumspringgreen": 0x00FA9A, "mediumturquoise": 0x48D1CC,
	"mediumvioletred": 0xC71585, "midnightblue": 0x191970, "mintcream": 0xF5FFFA, "mistyrose": 0xFFE4E1, "moccasin": 0xFFE4B5, "navajowhite": 0xFFDEAD,
	"navy": 0x000080, "oldlace": 0xFDF5E6, "olive": 0x808000, "olivedrab": 0x6B8E23, "orange": 0xFFA500, "orangered": 0xFF4500, "orchid": 0xDA70D6,
	"palegoldenrod": 0xEEE8AA, "palegreen": 0x98FB98, "paleturquoise": 0xAFEEEE, "palevioletred": 0xDB7093, "papayawhip": 0xFFEFD5, "peachpuff": 0xFFDAB9,
	"peru": 0xCD853F, "pink": 0xFFC0CB, "plum": 0xDDA0DD, "powderblue": 0xB0E0E6, "purple": 0x800080, "red": 0xFF0000, "rosybrown": 0xBC8F8F,
	"royalblue": 0x4169E1, "saddlebrown": 0x8B4513, "salmon": 0xFA8072, "sandybrown": 0xF4A460, "seagreen": 0x2E8B57, "seashell": 0xFFF5EE,
	"sienna": 0xA0522D, "silver": 0xC0C0C0, "skyblue": 0x87CEEB, "slateblue": 0x6A5ACD, "slategray": 0x708090, "slategrey": 0x708090, "snow": 0xFFFAFA,
	"springgreen": 0x00FF7F, "steelblue": 0x4682B4, "tan": 0xD2B48C, "teal": 0x008080, "thistle": 0xD8BFD8, "tomato": 0xFF6347, "turquoise": 0x40E0D0,
	"violet": 0xEE82EE, "wheat": 0xF5DEB3, "white": 0xFFFFFF, "whitesmoke": 0xF5F5F5, "yellow": 0xFFFF00, "yellowgreen": 0x9ACD32 };
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://exocortex.com
	 */
	
	THREE.Quaternion = function( x, y, z, w ) {
	
		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
		this.w = ( w !== undefined ) ? w : 1;
	
	};
	
	THREE.extend( THREE.Quaternion.prototype, {
	
		set: function ( x, y, z, w ) {
	
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
	
			return this;
	
		},
	
		copy: function ( q ) {
	
			this.x = q.x;
			this.y = q.y;
			this.z = q.z;
			this.w = q.w;
	
			return this;
	
		},
	
		setFromEuler: function ( v, order ) {
	
			// http://www.mathworks.com/matlabcentral/fileexchange/
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m
	
			var c1 = Math.cos( v.x / 2 );
			var c2 = Math.cos( v.y / 2 );
			var c3 = Math.cos( v.z / 2 );
			var s1 = Math.sin( v.x / 2 );
			var s2 = Math.sin( v.y / 2 );
			var s3 = Math.sin( v.z / 2 );
	
			if ( order === undefined || order === 'XYZ' ) {
	
				this.x = s1 * c2 * c3 + c1 * s2 * s3;
				this.y = c1 * s2 * c3 - s1 * c2 * s3;
				this.z = c1 * c2 * s3 + s1 * s2 * c3;
				this.w = c1 * c2 * c3 - s1 * s2 * s3;
	
			} else if ( order === 'YXZ' ) {
	
				this.x = s1 * c2 * c3 + c1 * s2 * s3;
				this.y = c1 * s2 * c3 - s1 * c2 * s3;
				this.z = c1 * c2 * s3 - s1 * s2 * c3;
				this.w = c1 * c2 * c3 + s1 * s2 * s3;
	
			} else if ( order === 'ZXY' ) {
	
				this.x = s1 * c2 * c3 - c1 * s2 * s3;
				this.y = c1 * s2 * c3 + s1 * c2 * s3;
				this.z = c1 * c2 * s3 + s1 * s2 * c3;
				this.w = c1 * c2 * c3 - s1 * s2 * s3;
	
			} else if ( order === 'ZYX' ) {
	
				this.x = s1 * c2 * c3 - c1 * s2 * s3;
				this.y = c1 * s2 * c3 + s1 * c2 * s3;
				this.z = c1 * c2 * s3 - s1 * s2 * c3;
				this.w = c1 * c2 * c3 + s1 * s2 * s3;
	
			} else if ( order === 'YZX' ) {
	
				this.x = s1 * c2 * c3 + c1 * s2 * s3;
				this.y = c1 * s2 * c3 + s1 * c2 * s3;
				this.z = c1 * c2 * s3 - s1 * s2 * c3;
				this.w = c1 * c2 * c3 - s1 * s2 * s3;
	
			} else if ( order === 'XZY' ) {
	
				this.x = s1 * c2 * c3 - c1 * s2 * s3;
				this.y = c1 * s2 * c3 - s1 * c2 * s3;
				this.z = c1 * c2 * s3 + s1 * s2 * c3;
				this.w = c1 * c2 * c3 + s1 * s2 * s3;
	
			}
	
			return this;
	
		},
	
		setFromAxisAngle: function ( axis, angle ) {
	
			// from http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
			// axis have to be normalized
	
			var halfAngle = angle / 2,
				s = Math.sin( halfAngle );
	
			this.x = axis.x * s;
			this.y = axis.y * s;
			this.z = axis.z * s;
			this.w = Math.cos( halfAngle );
	
			return this;
	
		},
	
		setFromRotationMatrix: function ( m ) {
	
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
	
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
			var te = m.elements,
	
				m11 = te[0], m12 = te[4], m13 = te[8],
				m21 = te[1], m22 = te[5], m23 = te[9],
				m31 = te[2], m32 = te[6], m33 = te[10],
	
				trace = m11 + m22 + m33,
				s;
	
			if ( trace > 0 ) {
	
				s = 0.5 / Math.sqrt( trace + 1.0 );
	
				this.w = 0.25 / s;
				this.x = ( m32 - m23 ) * s;
				this.y = ( m13 - m31 ) * s;
				this.z = ( m21 - m12 ) * s;
	
			} else if ( m11 > m22 && m11 > m33 ) {
	
				s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );
	
				this.w = (m32 - m23 ) / s;
				this.x = 0.25 * s;
				this.y = (m12 + m21 ) / s;
				this.z = (m13 + m31 ) / s;
	
			} else if ( m22 > m33 ) {
	
				s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );
	
				this.w = (m13 - m31 ) / s;
				this.x = (m12 + m21 ) / s;
				this.y = 0.25 * s;
				this.z = (m23 + m32 ) / s;
	
			} else {
	
				s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );
	
				this.w = ( m21 - m12 ) / s;
				this.x = ( m13 + m31 ) / s;
				this.y = ( m23 + m32 ) / s;
				this.z = 0.25 * s;
	
			}
	
			return this;
	
		},
	
		inverse: function () {
	
			this.conjugate().normalize();
	
			return this;
	
		},
	
		conjugate: function () {
	
			this.x *= -1;
			this.y *= -1;
			this.z *= -1;
	
			return this;
	
		},
	
		lengthSq: function () {
	
			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
	
		},
	
		length: function () {
	
			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );
	
		},
	
		normalize: function () {
	
			var l = this.length();
	
			if ( l === 0 ) {
	
				this.x = 0;
				this.y = 0;
				this.z = 0;
				this.w = 1;
	
			} else {
	
				l = 1 / l;
	
				this.x = this.x * l;
				this.y = this.y * l;
				this.z = this.z * l;
				this.w = this.w * l;
	
			}
	
			return this;
	
		},
	
		multiply: function ( q, p ) {
	
			if ( p !== undefined ) {
	
				console.warn( 'DEPRECATED: Quaternion\'s .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
				return this.multiplyQuaternions( q, p );
	
			}
	
			return this.multiplyQuaternions( this, q );
	
		},
	
		multiplyQuaternions: function ( a, b ) {
	
			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
	
			var qax = a.x, qay = a.y, qaz = a.z, qaw = a.w;
			var qbx = b.x, qby = b.y, qbz = b.z, qbw = b.w;
	
			this.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
			this.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
			this.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
			this.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
	
			return this;
	
		},
	
		multiplyVector3: function ( vector ) {
	
			console.warn( 'DEPRECATED: Quaternion\'s .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
			return vector.applyQuaternion( this );
	
		},
	
		slerp: function ( qb, t ) {
	
			var x = this.x, y = this.y, z = this.z, w = this.w;
	
			// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
	
			var cosHalfTheta = w * qb.w + x * qb.x + y * qb.y + z * qb.z;
	
			if ( cosHalfTheta < 0 ) {
	
				this.w = -qb.w;
				this.x = -qb.x;
				this.y = -qb.y;
				this.z = -qb.z;
	
				cosHalfTheta = -cosHalfTheta;
	
			} else {
	
				this.copy( qb );
	
			}
	
			if ( cosHalfTheta >= 1.0 ) {
	
				this.w = w;
				this.x = x;
				this.y = y;
				this.z = z;
	
				return this;
	
			}
	
			var halfTheta = Math.acos( cosHalfTheta );
			var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );
	
			if ( Math.abs( sinHalfTheta ) < 0.001 ) {
	
				this.w = 0.5 * ( w + this.w );
				this.x = 0.5 * ( x + this.x );
				this.y = 0.5 * ( y + this.y );
				this.z = 0.5 * ( z + this.z );
	
				return this;
	
			}
	
			var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;
	
			this.w = ( w * ratioA + this.w * ratioB );
			this.x = ( x * ratioA + this.x * ratioB );
			this.y = ( y * ratioA + this.y * ratioB );
			this.z = ( z * ratioA + this.z * ratioB );
	
			return this;
	
		},
	
		equals: function ( v ) {
	
			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );
	
		},
	
		clone: function () {
	
			return new THREE.Quaternion( this.x, this.y, this.z, this.w );
	
		}
	
	} );
	
	THREE.Quaternion.slerp = function ( qa, qb, qm, t ) {
	
		return qm.copy( qa ).slerp( qb, t );
	
	}
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author philogb / http://blog.thejit.org/
	 * @author egraether / http://egraether.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */
	
	THREE.Vector2 = function ( x, y ) {
	
		this.x = x || 0;
		this.y = y || 0;
	
	};
	
	THREE.extend( THREE.Vector2.prototype, {
	
		set: function ( x, y ) {
	
			this.x = x;
			this.y = y;
	
			return this;
	
		},
	
		setX: function ( x ) {
	
			this.x = x;
	
			return this;
	
		},
	
		setY: function ( y ) {
	
			this.y = y;
	
			return this;
	
		},
	
	
		setComponent: function ( index, value ) {
	
			switch ( index ) {
	
				case 0: this.x = value; break;
				case 1: this.y = value; break;
				default: throw new Error( "index is out of range: " + index );
	
			}
	
		},
	
		getComponent: function ( index ) {
	
			switch ( index ) {
	
				case 0: return this.x;
				case 1: return this.y;
				default: throw new Error( "index is out of range: " + index );
	
			}
	
		},
	
		copy: function ( v ) {
	
			this.x = v.x;
			this.y = v.y;
	
			return this;
	
		},
	
		add: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'DEPRECATED: Vector2\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );
	
			}
	
			this.x += v.x;
			this.y += v.y;
	
			return this;
	
		},
	
		addVectors: function ( a, b ) {
	
			this.x = a.x + b.x;
			this.y = a.y + b.y;
	
			return this;
	
		},
	
		addScalar: function ( s ) {
	
			this.x += s;
			this.y += s;
	
			return this;
	
		},
	
		sub: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'DEPRECATED: Vector2\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );
	
			}
	
			this.x -= v.x;
			this.y -= v.y;
	
			return this;
	
		},
	
		subVectors: function ( a, b ) {
	
			this.x = a.x - b.x;
			this.y = a.y - b.y;
	
			return this;
	
		},
	
		multiplyScalar: function ( s ) {
	
			this.x *= s;
			this.y *= s;
	
			return this;
	
		},
	
		divideScalar: function ( s ) {
	
			if ( s !== 0 ) {
	
				this.x /= s;
				this.y /= s;
	
			} else {
	
				this.set( 0, 0 );
	
			}
	
			return this;
	
		},
	
		min: function ( v ) {
	
			if ( this.x > v.x ) {
	
				this.x = v.x;
	
			}
	
			if ( this.y > v.y ) {
	
				this.y = v.y;
	
			}
	
			return this;
	
		},
	
		max: function ( v ) {
	
			if ( this.x < v.x ) {
	
				this.x = v.x;
	
			}
	
			if ( this.y < v.y ) {
	
				this.y = v.y;
	
			}
	
			return this;
	
		},
	
		clamp: function ( min, max ) {
	
			// This function assumes min < max, if this assumption isn't true it will not operate correctly
	
			if ( this.x < min.x ) {
	
				this.x = min.x;
	
			} else if ( this.x > max.x ) {
	
				this.x = max.x;
	
			}
	
			if ( this.y < min.y ) {
	
				this.y = min.y;
	
			} else if ( this.y > max.y ) {
	
				this.y = max.y;
	
			}
	
			return this;
	
		},
	
		negate: function() {
	
			return this.multiplyScalar( - 1 );
	
		},
	
		dot: function ( v ) {
	
			return this.x * v.x + this.y * v.y;
	
		},
	
		lengthSq: function () {
	
			return this.x * this.x + this.y * this.y;
	
		},
	
		length: function () {
	
			return Math.sqrt( this.x * this.x + this.y * this.y );
	
		},
	
		normalize: function () {
	
			return this.divideScalar( this.length() );
	
		},
	
		distanceTo: function ( v ) {
	
			return Math.sqrt( this.distanceToSquared( v ) );
	
		},
	
		distanceToSquared: function ( v ) {
	
			var dx = this.x - v.x, dy = this.y - v.y;
			return dx * dx + dy * dy;
	
		},
	
		setLength: function ( l ) {
	
			var oldLength = this.length();
	
			if ( oldLength !== 0 && l !== oldLength ) {
	
				this.multiplyScalar( l / oldLength );
			}
	
			return this;
	
		},
	
		lerp: function ( v, alpha ) {
	
			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
	
			return this;
	
		},
	
		equals: function( v ) {
	
			return ( ( v.x === this.x ) && ( v.y === this.y ) );
	
		},
	
		toArray: function () {
	
			return [ this.x, this.y ];
			
		},
	
		clone: function () {
	
			return new THREE.Vector2( this.x, this.y );
	
		}
	
	} );
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author *kile / http://kile.stravaganza.org/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	THREE.Vector3 = function ( x, y, z ) {
	
		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
	
	};
	
	THREE.extend( THREE.Vector3.prototype, {
	
		set: function ( x, y, z ) {
	
			this.x = x;
			this.y = y;
			this.z = z;
	
			return this;
	
		},
	
		setX: function ( x ) {
	
			this.x = x;
	
			return this;
	
		},
	
		setY: function ( y ) {
	
			this.y = y;
	
			return this;
	
		},
	
		setZ: function ( z ) {
	
			this.z = z;
	
			return this;
	
		},
	
		setComponent: function ( index, value ) {
	
			switch ( index ) {
	
				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				default: throw new Error( "index is out of range: " + index );
	
			}
	
		},
	
		getComponent: function ( index ) {
	
			switch ( index ) {
	
				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				default: throw new Error( "index is out of range: " + index );
	
			}
	
		},
	
		copy: function ( v ) {
	
			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
	
			return this;
	
		},
	
		add: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'DEPRECATED: Vector3\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );
	
			}
	
			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
	
			return this;
	
		},
	
		addScalar: function ( s ) {
	
			this.x += s;
			this.y += s;
			this.z += s;
	
			return this;
	
		},
	
		addVectors: function ( a, b ) {
	
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
	
			return this;
	
		},
	
		sub: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'DEPRECATED: Vector3\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );
	
			}
	
			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
	
			return this;
	
		},
	
		subVectors: function ( a, b ) {
	
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
	
			return this;
	
		},
	
		multiply: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'DEPRECATED: Vector3\'s .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
				return this.multiplyVectors( v, w );
	
			}
	
			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;
	
			return this;
	
		},
	
		multiplyScalar: function ( s ) {
	
			this.x *= s;
			this.y *= s;
			this.z *= s;
	
			return this;
	
		},
	
		multiplyVectors: function ( a, b ) {
	
			this.x = a.x * b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;
	
			return this;
	
		},
	
		applyMatrix3: function ( m ) {
	
			var x = this.x;
			var y = this.y;
			var z = this.z;
	
			var e = m.elements;
	
			this.x = e[0] * x + e[3] * y + e[6] * z;
			this.y = e[1] * x + e[4] * y + e[7] * z;
			this.z = e[2] * x + e[5] * y + e[8] * z;
	
			return this;
	
		},
	
		applyMatrix4: function ( m ) {
	
			// input: THREE.Matrix4 affine matrix
	
			var x = this.x, y = this.y, z = this.z;
	
			var e = m.elements;
	
			this.x = e[0] * x + e[4] * y + e[8]  * z + e[12];
			this.y = e[1] * x + e[5] * y + e[9]  * z + e[13];
			this.z = e[2] * x + e[6] * y + e[10] * z + e[14];
	
			return this;
	
		},
	
		applyProjection: function ( m ) {
	
			// input: THREE.Matrix4 projection matrix
	
			var x = this.x, y = this.y, z = this.z;
	
			var e = m.elements;
			var d = 1 / ( e[3] * x + e[7] * y + e[11] * z + e[15] ); // perspective divide
	
			this.x = ( e[0] * x + e[4] * y + e[8]  * z + e[12] ) * d;
			this.y = ( e[1] * x + e[5] * y + e[9]  * z + e[13] ) * d;
			this.z = ( e[2] * x + e[6] * y + e[10] * z + e[14] ) * d;
	
			return this;
	
		},
	
		applyQuaternion: function ( q ) {
	
			var x = this.x;
			var y = this.y;
			var z = this.z;
	
			var qx = q.x;
			var qy = q.y;
			var qz = q.z;
			var qw = q.w;
	
			// calculate quat * vector
	
			var ix =  qw * x + qy * z - qz * y;
			var iy =  qw * y + qz * x - qx * z;
			var iz =  qw * z + qx * y - qy * x;
			var iw = -qx * x - qy * y - qz * z;
	
			// calculate result * inverse quat
	
			this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
			this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
			this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
	
			return this;
	
		},
	
		applyEuler: function () {
	
			var q1 = new THREE.Quaternion();
	
			return function ( v, eulerOrder ) {
	
				var quaternion = q1.setFromEuler( v, eulerOrder );
	
				this.applyQuaternion( quaternion );
	
				return this;
	
			};
	
		}(),
	
		applyAxisAngle: function () {
	
			var q1 = new THREE.Quaternion();
	
			return function ( axis, angle ) {
	
				var quaternion = q1.setFromAxisAngle( axis, angle );
	
				this.applyQuaternion( quaternion );
	
				return this;
	
			};
	
		}(),
	
		transformDirection: function ( m ) {
	
			// input: THREE.Matrix4 affine matrix
			// vector interpreted as a direction
	
			var x = this.x, y = this.y, z = this.z;
	
			var e = m.elements;
	
			this.x = e[0] * x + e[4] * y + e[8]  * z;
			this.y = e[1] * x + e[5] * y + e[9]  * z;
			this.z = e[2] * x + e[6] * y + e[10] * z;
	
			this.normalize();
	
			return this;
	
		},
	
		divide: function ( v ) {
	
			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;
	
			return this;
	
		},
	
		divideScalar: function ( s ) {
	
			if ( s !== 0 ) {
	
				this.x /= s;
				this.y /= s;
				this.z /= s;
	
			} else {
	
				this.x = 0;
				this.y = 0;
				this.z = 0;
	
			}
	
			return this;
	
		},
	
		min: function ( v ) {
	
			if ( this.x > v.x ) {
	
				this.x = v.x;
	
			}
	
			if ( this.y > v.y ) {
	
				this.y = v.y;
	
			}
	
			if ( this.z > v.z ) {
	
				this.z = v.z;
	
			}
	
			return this;
	
		},
	
		max: function ( v ) {
	
			if ( this.x < v.x ) {
	
				this.x = v.x;
	
			}
	
			if ( this.y < v.y ) {
	
				this.y = v.y;
	
			}
	
			if ( this.z < v.z ) {
	
				this.z = v.z;
	
			}
	
			return this;
	
		},
	
		clamp: function ( min, max ) {
	
			// This function assumes min < max, if this assumption isn't true it will not operate correctly
	
			if ( this.x < min.x ) {
	
				this.x = min.x;
	
			} else if ( this.x > max.x ) {
	
				this.x = max.x;
	
			}
	
			if ( this.y < min.y ) {
	
				this.y = min.y;
	
			} else if ( this.y > max.y ) {
	
				this.y = max.y;
	
			}
	
			if ( this.z < min.z ) {
	
				this.z = min.z;
	
			} else if ( this.z > max.z ) {
	
				this.z = max.z;
	
			}
	
			return this;
	
		},
	
		negate: function () {
	
			return this.multiplyScalar( - 1 );
	
		},
	
		dot: function ( v ) {
	
			return this.x * v.x + this.y * v.y + this.z * v.z;
	
		},
	
		lengthSq: function () {
	
			return this.x * this.x + this.y * this.y + this.z * this.z;
	
		},
	
		length: function () {
	
			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );
	
		},
	
		lengthManhattan: function () {
	
			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );
	
		},
	
		normalize: function () {
	
			return this.divideScalar( this.length() );
	
		},
	
		setLength: function ( l ) {
	
			var oldLength = this.length();
	
			if ( oldLength !== 0 && l !== oldLength  ) {
	
				this.multiplyScalar( l / oldLength );
			}
	
			return this;
	
		},
	
		lerp: function ( v, alpha ) {
	
			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;
	
			return this;
	
		},
	
		cross: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'DEPRECATED: Vector3\'s .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
				return this.crossVectors( v, w );
	
			}
	
			var x = this.x, y = this.y, z = this.z;
	
			this.x = y * v.z - z * v.y;
			this.y = z * v.x - x * v.z;
			this.z = x * v.y - y * v.x;
	
			return this;
	
		},
	
		crossVectors: function ( a, b ) {
	
			this.x = a.y * b.z - a.z * b.y;
			this.y = a.z * b.x - a.x * b.z;
			this.z = a.x * b.y - a.y * b.x;
	
			return this;
	
		},
	
		projectOnVector: function () {
	
			var v1 = new THREE.Vector3();
	
			return function( vector ) {
	
				v1.copy( vector ).normalize();
				var d = this.dot( v1 );
				return this.copy( v1 ).multiplyScalar( d );
	
			};
	
		}(),
	
		projectOnPlane: function () {
	
			var v1 = new THREE.Vector3();
	
			return function( planeNormal ) {
	
				v1.copy( this ).projectOnVector( planeNormal );
	
				return this.sub( v1 );
	
			}
	
		}(),
	
		reflect: function () {
	
			var v1 = new THREE.Vector3();
	
			return function ( vector ) {
	
			    v1.copy( this ).projectOnVector( vector ).multiplyScalar( 2 );
	
			    return this.subVectors( v1, this );
	
			}
	
		}(),
	
		angleTo: function ( v ) {
	
			var theta = this.dot( v ) / ( this.length() * v.length() );
	
			// clamp, to handle numerical problems
	
			return Math.acos( THREE.Math.clamp( theta, -1, 1 ) );
	
		},
	
		distanceTo: function ( v ) {
	
			return Math.sqrt( this.distanceToSquared( v ) );
	
		},
	
		distanceToSquared: function ( v ) {
	
			var dx = this.x - v.x;
			var dy = this.y - v.y;
			var dz = this.z - v.z;
	
			return dx * dx + dy * dy + dz * dz;
	
		},
	
		getPositionFromMatrix: function ( m ) {
	
			this.x = m.elements[12];
			this.y = m.elements[13];
			this.z = m.elements[14];
	
			return this;
	
		},
	
		setEulerFromRotationMatrix: function ( m, order ) {
	
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
			// clamp, to handle numerical problems
	
			function clamp( x ) {
	
				return Math.min( Math.max( x, -1 ), 1 );
	
			}
	
			var te = m.elements;
			var m11 = te[0], m12 = te[4], m13 = te[8];
			var m21 = te[1], m22 = te[5], m23 = te[9];
			var m31 = te[2], m32 = te[6], m33 = te[10];
	
			if ( order === undefined || order === 'XYZ' ) {
	
				this.y = Math.asin( clamp( m13 ) );
	
				if ( Math.abs( m13 ) < 0.99999 ) {
	
					this.x = Math.atan2( - m23, m33 );
					this.z = Math.atan2( - m12, m11 );
	
				} else {
	
					this.x = Math.atan2( m32, m22 );
					this.z = 0;
	
				}
	
			} else if ( order === 'YXZ' ) {
	
				this.x = Math.asin( - clamp( m23 ) );
	
				if ( Math.abs( m23 ) < 0.99999 ) {
	
					this.y = Math.atan2( m13, m33 );
					this.z = Math.atan2( m21, m22 );
	
				} else {
	
					this.y = Math.atan2( - m31, m11 );
					this.z = 0;
	
				}
	
			} else if ( order === 'ZXY' ) {
	
				this.x = Math.asin( clamp( m32 ) );
	
				if ( Math.abs( m32 ) < 0.99999 ) {
	
					this.y = Math.atan2( - m31, m33 );
					this.z = Math.atan2( - m12, m22 );
	
				} else {
	
					this.y = 0;
					this.z = Math.atan2( m21, m11 );
	
				}
	
			} else if ( order === 'ZYX' ) {
	
				this.y = Math.asin( - clamp( m31 ) );
	
				if ( Math.abs( m31 ) < 0.99999 ) {
	
					this.x = Math.atan2( m32, m33 );
					this.z = Math.atan2( m21, m11 );
	
				} else {
	
					this.x = 0;
					this.z = Math.atan2( - m12, m22 );
	
				}
	
			} else if ( order === 'YZX' ) {
	
				this.z = Math.asin( clamp( m21 ) );
	
				if ( Math.abs( m21 ) < 0.99999 ) {
	
					this.x = Math.atan2( - m23, m22 );
					this.y = Math.atan2( - m31, m11 );
	
				} else {
	
					this.x = 0;
					this.y = Math.atan2( m13, m33 );
	
				}
	
			} else if ( order === 'XZY' ) {
	
				this.z = Math.asin( - clamp( m12 ) );
	
				if ( Math.abs( m12 ) < 0.99999 ) {
	
					this.x = Math.atan2( m32, m22 );
					this.y = Math.atan2( m13, m11 );
	
				} else {
	
					this.x = Math.atan2( - m23, m33 );
					this.y = 0;
	
				}
	
			}
	
			return this;
	
		},
	
		setEulerFromQuaternion: function ( q, order ) {
	
			// q is assumed to be normalized
	
			// clamp, to handle numerical problems
	
			function clamp( x ) {
	
				return Math.min( Math.max( x, -1 ), 1 );
	
			}
	
			// http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m
	
			var sqx = q.x * q.x;
			var sqy = q.y * q.y;
			var sqz = q.z * q.z;
			var sqw = q.w * q.w;
	
			if ( order === undefined || order === 'XYZ' ) {
	
				this.x = Math.atan2( 2 * ( q.x * q.w - q.y * q.z ), ( sqw - sqx - sqy + sqz ) );
				this.y = Math.asin(  clamp( 2 * ( q.x * q.z + q.y * q.w ) ) );
				this.z = Math.atan2( 2 * ( q.z * q.w - q.x * q.y ), ( sqw + sqx - sqy - sqz ) );
	
			} else if ( order ===  'YXZ' ) {
	
				this.x = Math.asin(  clamp( 2 * ( q.x * q.w - q.y * q.z ) ) );
				this.y = Math.atan2( 2 * ( q.x * q.z + q.y * q.w ), ( sqw - sqx - sqy + sqz ) );
				this.z = Math.atan2( 2 * ( q.x * q.y + q.z * q.w ), ( sqw - sqx + sqy - sqz ) );
	
			} else if ( order === 'ZXY' ) {
	
				this.x = Math.asin(  clamp( 2 * ( q.x * q.w + q.y * q.z ) ) );
				this.y = Math.atan2( 2 * ( q.y * q.w - q.z * q.x ), ( sqw - sqx - sqy + sqz ) );
				this.z = Math.atan2( 2 * ( q.z * q.w - q.x * q.y ), ( sqw - sqx + sqy - sqz ) );
	
			} else if ( order === 'ZYX' ) {
	
				this.x = Math.atan2( 2 * ( q.x * q.w + q.z * q.y ), ( sqw - sqx - sqy + sqz ) );
				this.y = Math.asin(  clamp( 2 * ( q.y * q.w - q.x * q.z ) ) );
				this.z = Math.atan2( 2 * ( q.x * q.y + q.z * q.w ), ( sqw + sqx - sqy - sqz ) );
	
			} else if ( order === 'YZX' ) {
	
				this.x = Math.atan2( 2 * ( q.x * q.w - q.z * q.y ), ( sqw - sqx + sqy - sqz ) );
				this.y = Math.atan2( 2 * ( q.y * q.w - q.x * q.z ), ( sqw + sqx - sqy - sqz ) );
				this.z = Math.asin(  clamp( 2 * ( q.x * q.y + q.z * q.w ) ) );
	
			} else if ( order === 'XZY' ) {
	
				this.x = Math.atan2( 2 * ( q.x * q.w + q.y * q.z ), ( sqw - sqx + sqy - sqz ) );
				this.y = Math.atan2( 2 * ( q.x * q.z + q.y * q.w ), ( sqw + sqx - sqy - sqz ) );
				this.z = Math.asin(  clamp( 2 * ( q.z * q.w - q.x * q.y ) ) );
	
			}
	
			return this;
	
		},
	
		getScaleFromMatrix: function ( m ) {
	
			var sx = this.set( m.elements[0], m.elements[1], m.elements[2] ).length();
			var sy = this.set( m.elements[4], m.elements[5], m.elements[6] ).length();
			var sz = this.set( m.elements[8], m.elements[9], m.elements[10] ).length();
	
			this.x = sx;
			this.y = sy;
			this.z = sz;
	
			return this;
		},
	
		equals: function ( v ) {
	
			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );
	
		},
	
		toArray: function () {
	
			return [ this.x, this.y, this.z ];
			
		},
	
		clone: function () {
	
			return new THREE.Vector3( this.x, this.y, this.z );
	
		}
	
	} );
	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	THREE.Vector4 = function ( x, y, z, w ) {
	
		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
		this.w = ( w !== undefined ) ? w : 1;
	
	};
	
	THREE.extend( THREE.Vector4.prototype, {
	
		set: function ( x, y, z, w ) {
	
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
	
			return this;
	
		},
	
		setX: function ( x ) {
	
			this.x = x;
	
			return this;
	
		},
	
		setY: function ( y ) {
	
			this.y = y;
	
			return this;
	
		},
	
		setZ: function ( z ) {
	
			this.z = z;
	
			return this;
	
		},
	
		setW: function ( w ) {
	
			this.w = w;
	
			return this;
	
		},
	
		setComponent: function ( index, value ) {
	
			switch ( index ) {
	
				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				case 3: this.w = value; break;
				default: throw new Error( "index is out of range: " + index );
	
			}
	
		},
	
		getComponent: function ( index ) {
	
			switch ( index ) {
	
				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				case 3: return this.w;
				default: throw new Error( "index is out of range: " + index );
	
			}
	
		},
	
		copy: function ( v ) {
	
			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			this.w = ( v.w !== undefined ) ? v.w : 1;
	
			return this;
	
		},
	
		add: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'DEPRECATED: Vector4\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );
	
			}
	
			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			this.w += v.w;
	
			return this;
	
		},
	
		addScalar: function ( s ) {
	
			this.x += s;
			this.y += s;
			this.z += s;
			this.w += s;
	
			return this;
	
		},
	
		addVectors: function ( a, b ) {
	
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			this.w = a.w + b.w;
	
			return this;
	
		},
	
		sub: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'DEPRECATED: Vector4\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );
	
			}
	
			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			this.w -= v.w;
	
			return this;
	
		},
	
		subVectors: function ( a, b ) {
	
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			this.w = a.w - b.w;
	
			return this;
	
		},
	
		multiplyScalar: function ( s ) {
	
			this.x *= s;
			this.y *= s;
			this.z *= s;
			this.w *= s;
	
			return this;
	
		},
	
		applyMatrix4: function ( m ) {
	
			var x = this.x;
			var y = this.y;
			var z = this.z;
			var w = this.w;
	
			var e = m.elements;
	
			this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
			this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
			this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
			this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
	
			return this;
	
		},
	
		divideScalar: function ( s ) {
	
			if ( s !== 0 ) {
	
				this.x /= s;
				this.y /= s;
				this.z /= s;
				this.w /= s;
	
			} else {
	
				this.x = 0;
				this.y = 0;
				this.z = 0;
				this.w = 1;
	
			}
	
			return this;
	
		},
	
		setAxisAngleFromQuaternion: function ( q ) {
	
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
	
			// q is assumed to be normalized
	
			this.w = 2 * Math.acos( q.w );
	
			var s = Math.sqrt( 1 - q.w * q.w );
	
			if ( s < 0.0001 ) {
	
				 this.x = 1;
				 this.y = 0;
				 this.z = 0;
	
			} else {
	
				 this.x = q.x / s;
				 this.y = q.y / s;
				 this.z = q.z / s;
	
			}
	
			return this;
	
		},
	
		setAxisAngleFromRotationMatrix: function ( m ) {
	
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
	
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
			var angle, x, y, z,		// variables for result
				epsilon = 0.01,		// margin to allow for rounding errors
				epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees
	
				te = m.elements,
	
				m11 = te[0], m12 = te[4], m13 = te[8],
				m21 = te[1], m22 = te[5], m23 = te[9],
				m31 = te[2], m32 = te[6], m33 = te[10];
	
			if ( ( Math.abs( m12 - m21 ) < epsilon )
			  && ( Math.abs( m13 - m31 ) < epsilon )
			  && ( Math.abs( m23 - m32 ) < epsilon ) ) {
	
				// singularity found
				// first check for identity matrix which must have +1 for all terms
				// in leading diagonal and zero in other terms
	
				if ( ( Math.abs( m12 + m21 ) < epsilon2 )
				  && ( Math.abs( m13 + m31 ) < epsilon2 )
				  && ( Math.abs( m23 + m32 ) < epsilon2 )
				  && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {
	
					// this singularity is identity matrix so angle = 0
	
					this.set( 1, 0, 0, 0 );
	
					return this; // zero angle, arbitrary axis
	
				}
	
				// otherwise this singularity is angle = 180
	
				angle = Math.PI;
	
				var xx = ( m11 + 1 ) / 2;
				var yy = ( m22 + 1 ) / 2;
				var zz = ( m33 + 1 ) / 2;
				var xy = ( m12 + m21 ) / 4;
				var xz = ( m13 + m31 ) / 4;
				var yz = ( m23 + m32 ) / 4;
	
				if ( ( xx > yy ) && ( xx > zz ) ) { // m11 is the largest diagonal term
	
					if ( xx < epsilon ) {
	
						x = 0;
						y = 0.707106781;
						z = 0.707106781;
	
					} else {
	
						x = Math.sqrt( xx );
						y = xy / x;
						z = xz / x;
	
					}
	
				} else if ( yy > zz ) { // m22 is the largest diagonal term
	
					if ( yy < epsilon ) {
	
						x = 0.707106781;
						y = 0;
						z = 0.707106781;
	
					} else {
	
						y = Math.sqrt( yy );
						x = xy / y;
						z = yz / y;
	
					}
	
				} else { // m33 is the largest diagonal term so base result on this
	
					if ( zz < epsilon ) {
	
						x = 0.707106781;
						y = 0.707106781;
						z = 0;
	
					} else {
	
						z = Math.sqrt( zz );
						x = xz / z;
						y = yz / z;
	
					}
	
				}
	
				this.set( x, y, z, angle );
	
				return this; // return 180 deg rotation
	
			}
	
			// as we have reached here there are no singularities so we can handle normally
	
			var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )
							 + ( m13 - m31 ) * ( m13 - m31 )
							 + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize
	
			if ( Math.abs( s ) < 0.001 ) s = 1;
	
			// prevent divide by zero, should not happen if matrix is orthogonal and should be
			// caught by singularity test above, but I've left it in just in case
	
			this.x = ( m32 - m23 ) / s;
			this.y = ( m13 - m31 ) / s;
			this.z = ( m21 - m12 ) / s;
			this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );
	
			return this;
	
		},
	
		min: function ( v ) {
	
			if ( this.x > v.x ) {
	
				this.x = v.x;
	
			}
	
			if ( this.y > v.y ) {
	
				this.y = v.y;
	
			}
	
			if ( this.z > v.z ) {
	
				this.z = v.z;
	
			}
	
			if ( this.w > v.w ) {
	
				this.w = v.w;
	
			}
	
			return this;
	
		},
	
		max: function ( v ) {
	
			if ( this.x < v.x ) {
	
				this.x = v.x;
	
			}
	
			if ( this.y < v.y ) {
	
				this.y = v.y;
	
			}
	
			if ( this.z < v.z ) {
	
				this.z = v.z;
	
			}
	
			if ( this.w < v.w ) {
	
				this.w = v.w;
	
			}
	
			return this;
	
		},
	
		clamp: function ( min, max ) {
	
			// This function assumes min < max, if this assumption isn't true it will not operate correctly
	
			if ( this.x < min.x ) {
	
				this.x = min.x;
	
			} else if ( this.x > max.x ) {
	
				this.x = max.x;
	
			}
	
			if ( this.y < min.y ) {
	
				this.y = min.y;
	
			} else if ( this.y > max.y ) {
	
				this.y = max.y;
	
			}
	
			if ( this.z < min.z ) {
	
				this.z = min.z;
	
			} else if ( this.z > max.z ) {
	
				this.z = max.z;
	
			}
	
			if ( this.w < min.w ) {
	
				this.w = min.w;
	
			} else if ( this.w > max.w ) {
	
				this.w = max.w;
	
			}
	
			return this;
	
		},
	
		negate: function() {
	
			return this.multiplyScalar( -1 );
	
		},
	
		dot: function ( v ) {
	
			return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
	
		},
	
		lengthSq: function () {
	
			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
	
		},
	
		length: function () {
	
			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );
	
		},
	
		lengthManhattan: function () {
	
			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );
	
		},
	
		normalize: function () {
	
			return this.divideScalar( this.length() );
	
		},
	
		setLength: function ( l ) {
	
			var oldLength = this.length();
	
			if ( oldLength !== 0 && l !== oldLength ) {
	
				this.multiplyScalar( l / oldLength );
			}
	
			return this;
	
		},
	
		lerp: function ( v, alpha ) {
	
			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;
			this.w += ( v.w - this.w ) * alpha;
	
			return this;
	
		},
	
		equals: function ( v ) {
	
			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );
	
		},
	
		toArray: function () {
	
			return [ this.x, this.y, this.z, this.w ];
			
		},
	
		clone: function () {
	
			return new THREE.Vector4( this.x, this.y, this.z, this.w );
	
		}
	
	} );
	/**
	 * @author bhouston / http://exocortex.com
	 */
	
	THREE.Box2 = function ( min, max ) {
	
		this.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );
		this.max = ( max !== undefined ) ? max : new THREE.Vector2( -Infinity, -Infinity );
	
	};
	
	THREE.extend( THREE.Box2.prototype, {
	
		set: function ( min, max ) {
	
			this.min.copy( min );
			this.max.copy( max );
	
			return this;
	
		},
	
		setFromPoints: function ( points ) {
	
			if ( points.length > 0 ) {
	
				var point = points[ 0 ];
	
				this.min.copy( point );
				this.max.copy( point );
	
				for ( var i = 1, il = points.length; i < il; i ++ ) {
	
					point = points[ i ];
	
					if ( point.x < this.min.x ) {
	
						this.min.x = point.x;
	
					} else if ( point.x > this.max.x ) {
	
						this.max.x = point.x;
	
					}
	
					if ( point.y < this.min.y ) {
	
						this.min.y = point.y;
	
					} else if ( point.y > this.max.y ) {
	
						this.max.y = point.y;
	
					}
	
				}
	
			} else {
	
				this.makeEmpty();
	
			}
	
			return this;
	
		},
	
		setFromCenterAndSize: function() {
	
			var v1 = new THREE.Vector2();
	
			return function ( center, size ) {
	
				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );
	
				return this;
	
			};
	
		}(),
	
		copy: function ( box ) {
	
			this.min.copy( box.min );
			this.max.copy( box.max );
	
			return this;
	
		},
	
		makeEmpty: function () {
	
			this.min.x = this.min.y = Infinity;
			this.max.x = this.max.y = -Infinity;
	
			return this;
	
		},
	
		empty: function () {
	
			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
	
			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );
	
		},
	
		center: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector2();
			return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );
	
		},
	
		size: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector2();
			return result.subVectors( this.max, this.min );
	
		},
	
		expandByPoint: function ( point ) {
	
			this.min.min( point );
			this.max.max( point );
	
			return this;
		},
	
		expandByVector: function ( vector ) {
	
			this.min.sub( vector );
			this.max.add( vector );
	
			return this;
		},
	
		expandByScalar: function ( scalar ) {
	
			this.min.addScalar( -scalar );
			this.max.addScalar( scalar );
	
			return this;
		},
	
		containsPoint: function ( point ) {
	
			if ( point.x < this.min.x || point.x > this.max.x ||
			     point.y < this.min.y || point.y > this.max.y ) {
	
				return false;
	
			}
	
			return true;
	
		},
	
		containsBox: function ( box ) {
	
			if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
			     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {
	
				return true;
	
			}
	
			return false;
	
		},
	
		getParameter: function ( point ) {
	
			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.
	
			return new THREE.Vector2(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y )
			);
	
		},
	
		isIntersectionBox: function ( box ) {
	
			// using 6 splitting planes to rule out intersections.
	
			if ( box.max.x < this.min.x || box.min.x > this.max.x ||
			     box.max.y < this.min.y || box.min.y > this.max.y ) {
	
				return false;
	
			}
	
			return true;
	
		},
	
		clampPoint: function ( point, optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector2();
			return result.copy( point ).clamp( this.min, this.max );
	
		},
	
		distanceToPoint: function() {
	
			var v1 = new THREE.Vector2();
	
			return function ( point ) {
	
				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
				return clampedPoint.sub( point ).length();
	
			};
	
		}(),
	
		intersect: function ( box ) {
	
			this.min.max( box.min );
			this.max.min( box.max );
	
			return this;
	
		},
	
		union: function ( box ) {
	
			this.min.min( box.min );
			this.max.max( box.max );
	
			return this;
	
		},
	
		translate: function ( offset ) {
	
			this.min.add( offset );
			this.max.add( offset );
	
			return this;
	
		},
	
		equals: function ( box ) {
	
			return box.min.equals( this.min ) && box.max.equals( this.max );
	
		},
	
		clone: function () {
	
			return new THREE.Box2().copy( this );
	
		}
	
	} );
	/**
	 * @author bhouston / http://exocortex.com
	 */
	
	THREE.Box3 = function ( min, max ) {
	
		this.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );
		this.max = ( max !== undefined ) ? max : new THREE.Vector3( -Infinity, -Infinity, -Infinity );
	
	};
	
	THREE.extend( THREE.Box3.prototype, {
	
		set: function ( min, max ) {
	
			this.min.copy( min );
			this.max.copy( max );
	
			return this;
	
		},
	
		setFromPoints: function ( points ) {
	
			if ( points.length > 0 ) {
	
				var point = points[ 0 ];
	
				this.min.copy( point );
				this.max.copy( point );
	
				for ( var i = 1, il = points.length; i < il; i ++ ) {
	
					point = points[ i ];
	
					if ( point.x < this.min.x ) {
	
						this.min.x = point.x;
	
					} else if ( point.x > this.max.x ) {
	
						this.max.x = point.x;
	
					}
	
					if ( point.y < this.min.y ) {
	
						this.min.y = point.y;
	
					} else if ( point.y > this.max.y ) {
	
						this.max.y = point.y;
	
					}
	
					if ( point.z < this.min.z ) {
	
						this.min.z = point.z;
	
					} else if ( point.z > this.max.z ) {
	
						this.max.z = point.z;
	
					}
	
				}
	
			} else {
	
				this.makeEmpty();
	
			}
	
			return this;
	
		},
	
		setFromCenterAndSize: function() {
	
			var v1 = new THREE.Vector3();
	
			return function ( center, size ) {
	
				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
	
				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );
	
				return this;
	
			};
	
		}(),
	
		copy: function ( box ) {
	
			this.min.copy( box.min );
			this.max.copy( box.max );
	
			return this;
	
		},
	
		makeEmpty: function () {
	
			this.min.x = this.min.y = this.min.z = Infinity;
			this.max.x = this.max.y = this.max.z = -Infinity;
	
			return this;
	
		},
	
		empty: function () {
	
			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
	
			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );
	
		},
	
		center: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );
	
		},
	
		size: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.subVectors( this.max, this.min );
	
		},
	
		expandByPoint: function ( point ) {
	
			this.min.min( point );
			this.max.max( point );
	
			return this;
	
		},
	
		expandByVector: function ( vector ) {
	
			this.min.sub( vector );
			this.max.add( vector );
	
			return this;
	
		},
	
		expandByScalar: function ( scalar ) {
	
			this.min.addScalar( -scalar );
			this.max.addScalar( scalar );
	
			return this;
	
		},
	
		containsPoint: function ( point ) {
	
			if ( point.x < this.min.x || point.x > this.max.x ||
			     point.y < this.min.y || point.y > this.max.y ||
			     point.z < this.min.z || point.z > this.max.z ) {
	
				return false;
	
			}
	
			return true;
	
		},
	
		containsBox: function ( box ) {
	
			if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
				 ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
				 ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {
	
				return true;
	
			}
	
			return false;
	
		},
	
		getParameter: function ( point ) {
	
			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.
	
			return new THREE.Vector3(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y ),
				( point.z - this.min.z ) / ( this.max.z - this.min.z )
			);
	
		},
	
		isIntersectionBox: function ( box ) {
	
			// using 6 splitting planes to rule out intersections.
	
			if ( box.max.x < this.min.x || box.min.x > this.max.x ||
			     box.max.y < this.min.y || box.min.y > this.max.y ||
			     box.max.z < this.min.z || box.min.z > this.max.z ) {
	
				return false;
	
			}
	
			return true;
	
		},
	
		clampPoint: function ( point, optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.copy( point ).clamp( this.min, this.max );
	
		},
	
		distanceToPoint: function() {
	
			var v1 = new THREE.Vector3();
	
			return function ( point ) {
	
				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
				return clampedPoint.sub( point ).length();
	
			};
	
		}(),
	
		getBoundingSphere: function() {
	
			var v1 = new THREE.Vector3();
	
			return function ( optionalTarget ) {
	
				var result = optionalTarget || new THREE.Sphere();
	
				result.center = this.center();
				result.radius = this.size( v1 ).length() * 0.5;
	
				return result;
	
			};
	
		}(),
	
		intersect: function ( box ) {
	
			this.min.max( box.min );
			this.max.min( box.max );
	
			return this;
	
		},
	
		union: function ( box ) {
	
			this.min.min( box.min );
			this.max.max( box.max );
	
			return this;
	
		},
	
		applyMatrix4: function() {
	
			var points = [
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3(),
				new THREE.Vector3()
				];
	
			return function ( matrix ) {
	
				// NOTE: I am using a binary pattern to specify all 2^3 combinations below
				points[0].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
				points[1].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
				points[2].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
				points[3].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
				points[4].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
				points[5].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
				points[6].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
				points[7].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );  // 111
	
				this.makeEmpty();
				this.setFromPoints( points );
	
				return this;
	
			};
	
		}(),
	
		translate: function ( offset ) {
	
			this.min.add( offset );
			this.max.add( offset );
	
			return this;
	
		},
	
		equals: function ( box ) {
	
			return box.min.equals( this.min ) && box.max.equals( this.max );
	
		},
	
		clone: function () {
	
			return new THREE.Box3().copy( this );
	
		}
	
	} );
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://exocortex.com
	 */
	
	THREE.Matrix3 = function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {
	
		this.elements = new Float32Array(9);
	
		this.set(
	
			( n11 !== undefined ) ? n11 : 1, n12 || 0, n13 || 0,
			n21 || 0, ( n22 !== undefined ) ? n22 : 1, n23 || 0,
			n31 || 0, n32 || 0, ( n33 !== undefined ) ? n33 : 1
	
		);
	};
	
	THREE.extend( THREE.Matrix3.prototype, {
	
		set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {
	
			var te = this.elements;
	
			te[0] = n11; te[3] = n12; te[6] = n13;
			te[1] = n21; te[4] = n22; te[7] = n23;
			te[2] = n31; te[5] = n32; te[8] = n33;
	
			return this;
	
		},
	
		identity: function () {
	
			this.set(
	
				1, 0, 0,
				0, 1, 0,
				0, 0, 1
	
			);
	
			return this;
	
		},
	
		copy: function ( m ) {
	
			var me = m.elements;
	
			this.set(
	
				me[0], me[3], me[6],
				me[1], me[4], me[7],
				me[2], me[5], me[8]
	
			);
	
			return this;
	
		},
	
		multiplyVector3: function ( vector ) {
	
			console.warn( 'DEPRECATED: Matrix3\'s .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
			return vector.applyMatrix3( this );
	
		},
	
		multiplyVector3Array: function() {
	
			var v1 = new THREE.Vector3();
	
			return function ( a ) {
	
				for ( var i = 0, il = a.length; i < il; i += 3 ) {
	
					v1.x = a[ i ];
					v1.y = a[ i + 1 ];
					v1.z = a[ i + 2 ];
	
					v1.applyMatrix3(this);
	
					a[ i ]     = v1.x;
					a[ i + 1 ] = v1.y;
					a[ i + 2 ] = v1.z;
	
				}
	
				return a;
	
			};
	
		}(),
	
		multiplyScalar: function ( s ) {
	
			var te = this.elements;
	
			te[0] *= s; te[3] *= s; te[6] *= s;
			te[1] *= s; te[4] *= s; te[7] *= s;
			te[2] *= s; te[5] *= s; te[8] *= s;
	
			return this;
	
		},
	
		determinant: function () {
	
			var te = this.elements;
	
			var a = te[0], b = te[1], c = te[2],
				d = te[3], e = te[4], f = te[5],
				g = te[6], h = te[7], i = te[8];
	
			return a*e*i - a*f*h - b*d*i + b*f*g + c*d*h - c*e*g;
	
		},
	
		getInverse: function ( matrix, throwOnInvertible ) {
	
			// input: THREE.Matrix4
			// ( based on http://code.google.com/p/webgl-mjs/ )
	
			var me = matrix.elements;
			var te = this.elements;
	
			te[ 0 ] =   me[10] * me[5] - me[6] * me[9];
			te[ 1 ] = - me[10] * me[1] + me[2] * me[9];
			te[ 2 ] =   me[6] * me[1] - me[2] * me[5];
			te[ 3 ] = - me[10] * me[4] + me[6] * me[8];
			te[ 4 ] =   me[10] * me[0] - me[2] * me[8];
			te[ 5 ] = - me[6] * me[0] + me[2] * me[4];
			te[ 6 ] =   me[9] * me[4] - me[5] * me[8];
			te[ 7 ] = - me[9] * me[0] + me[1] * me[8];
			te[ 8 ] =   me[5] * me[0] - me[1] * me[4];
	
			var det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];
	
			// no inverse
	
			if ( det === 0 ) {
	
				var msg = "Matrix3.getInverse(): can't invert matrix, determinant is 0";
	
				if ( throwOnInvertible || false ) {
	
					throw new Error( msg ); 
	
				} else {
	
					console.warn( msg );
	
				}
	
				this.identity();
	
				return this;
	
			}
	
			this.multiplyScalar( 1.0 / det );
	
			return this;
	
		},
	
		transpose: function () {
	
			var tmp, m = this.elements;
	
			tmp = m[1]; m[1] = m[3]; m[3] = tmp;
			tmp = m[2]; m[2] = m[6]; m[6] = tmp;
			tmp = m[5]; m[5] = m[7]; m[7] = tmp;
	
			return this;
	
		},
	
		getNormalMatrix: function ( m ) {
	
			// input: THREE.Matrix4
	
			this.getInverse( m ).transpose();
	
			return this;
	
		},
	
		transposeIntoArray: function ( r ) {
	
			var m = this.elements;
	
			r[ 0 ] = m[ 0 ];
			r[ 1 ] = m[ 3 ];
			r[ 2 ] = m[ 6 ];
			r[ 3 ] = m[ 1 ];
			r[ 4 ] = m[ 4 ];
			r[ 5 ] = m[ 7 ];
			r[ 6 ] = m[ 2 ];
			r[ 7 ] = m[ 5 ];
			r[ 8 ] = m[ 8 ];
	
			return this;
	
		},
	
		clone: function () {
	
			var te = this.elements;
	
			return new THREE.Matrix3(
	
				te[0], te[3], te[6],
				te[1], te[4], te[7],
				te[2], te[5], te[8]
	
			);
	
		}
	
	} );
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author jordi_ros / http://plattsoft.com
	 * @author D1plo1d / http://github.com/D1plo1d
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author timknip / http://www.floorplanner.com/
	 * @author bhouston / http://exocortex.com
	 */
	
	
	THREE.Matrix4 = function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {
	
		var te = this.elements = new Float32Array( 16 );
	
		// TODO: if n11 is undefined, then just set to identity, otherwise copy all other values into matrix
		//   we should not support semi specification of Matrix4, it is just weird.
	
		te[0] = ( n11 !== undefined ) ? n11 : 1; te[4] = n12 || 0; te[8] = n13 || 0; te[12] = n14 || 0;
		te[1] = n21 || 0; te[5] = ( n22 !== undefined ) ? n22 : 1; te[9] = n23 || 0; te[13] = n24 || 0;
		te[2] = n31 || 0; te[6] = n32 || 0; te[10] = ( n33 !== undefined ) ? n33 : 1; te[14] = n34 || 0;
		te[3] = n41 || 0; te[7] = n42 || 0; te[11] = n43 || 0; te[15] = ( n44 !== undefined ) ? n44 : 1;
	
	};
	
	THREE.extend( THREE.Matrix4.prototype, {
	
		set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {
	
			var te = this.elements;
	
			te[0] = n11; te[4] = n12; te[8] = n13; te[12] = n14;
			te[1] = n21; te[5] = n22; te[9] = n23; te[13] = n24;
			te[2] = n31; te[6] = n32; te[10] = n33; te[14] = n34;
			te[3] = n41; te[7] = n42; te[11] = n43; te[15] = n44;
	
			return this;
	
		},
	
		identity: function () {
	
			this.set(
	
				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1
	
			);
	
			return this;
	
		},
	
		copy: function ( m ) {
	
			var me = m.elements;
	
			this.set(
	
				me[0], me[4], me[8], me[12],
				me[1], me[5], me[9], me[13],
				me[2], me[6], me[10], me[14],
				me[3], me[7], me[11], me[15]
	
			);
	
			return this;
	
		},
	
		setRotationFromEuler: function ( v, order ) {
	
			var te = this.elements;
	
			var x = v.x, y = v.y, z = v.z;
			var a = Math.cos( x ), b = Math.sin( x );
			var c = Math.cos( y ), d = Math.sin( y );
			var e = Math.cos( z ), f = Math.sin( z );
	
			if ( order === undefined || order === 'XYZ' ) {
	
				var ae = a * e, af = a * f, be = b * e, bf = b * f;
	
				te[0] = c * e;
				te[4] = - c * f;
				te[8] = d;
	
				te[1] = af + be * d;
				te[5] = ae - bf * d;
				te[9] = - b * c;
	
				te[2] = bf - ae * d;
				te[6] = be + af * d;
				te[10] = a * c;
	
			} else if ( order === 'YXZ' ) {
	
				var ce = c * e, cf = c * f, de = d * e, df = d * f;
	
				te[0] = ce + df * b;
				te[4] = de * b - cf;
				te[8] = a * d;
	
				te[1] = a * f;
				te[5] = a * e;
				te[9] = - b;
	
				te[2] = cf * b - de;
				te[6] = df + ce * b;
				te[10] = a * c;
	
			} else if ( order === 'ZXY' ) {
	
				var ce = c * e, cf = c * f, de = d * e, df = d * f;
	
				te[0] = ce - df * b;
				te[4] = - a * f;
				te[8] = de + cf * b;
	
				te[1] = cf + de * b;
				te[5] = a * e;
				te[9] = df - ce * b;
	
				te[2] = - a * d;
				te[6] = b;
				te[10] = a * c;
	
			} else if ( order === 'ZYX' ) {
	
				var ae = a * e, af = a * f, be = b * e, bf = b * f;
	
				te[0] = c * e;
				te[4] = be * d - af;
				te[8] = ae * d + bf;
	
				te[1] = c * f;
				te[5] = bf * d + ae;
				te[9] = af * d - be;
	
				te[2] = - d;
				te[6] = b * c;
				te[10] = a * c;
	
			} else if ( order === 'YZX' ) {
	
				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
	
				te[0] = c * e;
				te[4] = bd - ac * f;
				te[8] = bc * f + ad;
	
				te[1] = f;
				te[5] = a * e;
				te[9] = - b * e;
	
				te[2] = - d * e;
				te[6] = ad * f + bc;
				te[10] = ac - bd * f;
	
			} else if ( order === 'XZY' ) {
	
				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
	
				te[0] = c * e;
				te[4] = - f;
				te[8] = d * e;
	
				te[1] = ac * f + bd;
				te[5] = a * e;
				te[9] = ad * f - bc;
	
				te[2] = bc * f - ad;
				te[6] = b * e;
				te[10] = bd * f + ac;
	
			}
	
			return this;
	
		},
	
		setRotationFromQuaternion: function ( q ) {
	
			var te = this.elements;
	
			var x = q.x, y = q.y, z = q.z, w = q.w;
			var x2 = x + x, y2 = y + y, z2 = z + z;
			var xx = x * x2, xy = x * y2, xz = x * z2;
			var yy = y * y2, yz = y * z2, zz = z * z2;
			var wx = w * x2, wy = w * y2, wz = w * z2;
	
			te[0] = 1 - ( yy + zz );
			te[4] = xy - wz;
			te[8] = xz + wy;
	
			te[1] = xy + wz;
			te[5] = 1 - ( xx + zz );
			te[9] = yz - wx;
	
			te[2] = xz - wy;
			te[6] = yz + wx;
			te[10] = 1 - ( xx + yy );
	
			return this;
	
		},
	
		lookAt: function() {
	
			var x = new THREE.Vector3();
			var y = new THREE.Vector3();
			var z = new THREE.Vector3();
	
			return function ( eye, target, up ) {
	
				var te = this.elements;
	
				z.subVectors( eye, target ).normalize();
	
				if ( z.length() === 0 ) {
	
					z.z = 1;
	
				}
	
				x.crossVectors( up, z ).normalize();
	
				if ( x.length() === 0 ) {
	
					z.x += 0.0001;
					x.crossVectors( up, z ).normalize();
	
				}
	
				y.crossVectors( z, x );
	
	
				te[0] = x.x; te[4] = y.x; te[8] = z.x;
				te[1] = x.y; te[5] = y.y; te[9] = z.y;
				te[2] = x.z; te[6] = y.z; te[10] = z.z;
	
				return this;
	
			};
	
		}(),
	
		multiply: function ( m, n ) {
	
			if ( n !== undefined ) {
	
				console.warn( 'DEPRECATED: Matrix4\'s .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
				return this.multiplyMatrices( m, n );
	
			}
	
			return this.multiplyMatrices( this, m );
	
		},
	
		multiplyMatrices: function ( a, b ) {
	
			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;
	
			var a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
			var a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
			var a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
			var a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
	
			var b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
			var b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
			var b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
			var b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
	
			te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
	
			te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
	
			te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
	
			te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
	
			return this;
	
		},
	
		multiplyToArray: function ( a, b, r ) {
	
			var te = this.elements;
	
			this.multiplyMatrices( a, b );
	
			r[ 0 ] = te[0]; r[ 1 ] = te[1]; r[ 2 ] = te[2]; r[ 3 ] = te[3];
			r[ 4 ] = te[4]; r[ 5 ] = te[5]; r[ 6 ] = te[6]; r[ 7 ] = te[7];
			r[ 8 ]  = te[8]; r[ 9 ]  = te[9]; r[ 10 ] = te[10]; r[ 11 ] = te[11];
			r[ 12 ] = te[12]; r[ 13 ] = te[13]; r[ 14 ] = te[14]; r[ 15 ] = te[15];
	
			return this;
	
		},
	
		multiplyScalar: function ( s ) {
	
			var te = this.elements;
	
			te[0] *= s; te[4] *= s; te[8] *= s; te[12] *= s;
			te[1] *= s; te[5] *= s; te[9] *= s; te[13] *= s;
			te[2] *= s; te[6] *= s; te[10] *= s; te[14] *= s;
			te[3] *= s; te[7] *= s; te[11] *= s; te[15] *= s;
	
			return this;
	
		},
	
		multiplyVector3: function ( vector ) {
	
			console.warn( 'DEPRECATED: Matrix4\'s .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
			return vector.applyProjection( this );
	
		},
	
		multiplyVector4: function ( vector ) {
	
			console.warn( 'DEPRECATED: Matrix4\'s .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );
	
		},
	
		multiplyVector3Array: function() {
	
			var v1 = new THREE.Vector3();
	
			return function ( a ) {
	
				for ( var i = 0, il = a.length; i < il; i += 3 ) {
	
					v1.x = a[ i ];
					v1.y = a[ i + 1 ];
					v1.z = a[ i + 2 ];
	
					v1.applyProjection( this );
	
					a[ i ]     = v1.x;
					a[ i + 1 ] = v1.y;
					a[ i + 2 ] = v1.z;
	
				}
	
				return a;
	
			};
	
		}(),
	
		rotateAxis: function ( v ) {
	
			var te = this.elements;
			var vx = v.x, vy = v.y, vz = v.z;
	
			v.x = vx * te[0] + vy * te[4] + vz * te[8];
			v.y = vx * te[1] + vy * te[5] + vz * te[9];
			v.z = vx * te[2] + vy * te[6] + vz * te[10];
	
			v.normalize();
	
			return v;
	
		},
	
		crossVector: function ( a ) {
	
			var te = this.elements;
			var v = new THREE.Vector4();
	
			v.x = te[0] * a.x + te[4] * a.y + te[8] * a.z + te[12] * a.w;
			v.y = te[1] * a.x + te[5] * a.y + te[9] * a.z + te[13] * a.w;
			v.z = te[2] * a.x + te[6] * a.y + te[10] * a.z + te[14] * a.w;
	
			v.w = ( a.w ) ? te[3] * a.x + te[7] * a.y + te[11] * a.z + te[15] * a.w : 1;
	
			return v;
	
		},
	
		determinant: function () {
	
			var te = this.elements;
	
			var n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
			var n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
			var n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
			var n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
	
			//TODO: make this more efficient
			//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
	
			return (
				n41 * (
					+n14 * n23 * n32
					-n13 * n24 * n32
					-n14 * n22 * n33
					+n12 * n24 * n33
					+n13 * n22 * n34
					-n12 * n23 * n34
				) +
				n42 * (
					+n11 * n23 * n34
					-n11 * n24 * n33
					+n14 * n21 * n33
					-n13 * n21 * n34
					+n13 * n24 * n31
					-n14 * n23 * n31
				) +
				n43 * (
					+n11 * n24 * n32
					-n11 * n22 * n34
					-n14 * n21 * n32
					+n12 * n21 * n34
					+n14 * n22 * n31
					-n12 * n24 * n31
				) +
				n44 * (
					-n13 * n22 * n31
					-n11 * n23 * n32
					+n11 * n22 * n33
					+n13 * n21 * n32
					-n12 * n21 * n33
					+n12 * n23 * n31
				)
	
			);
	
		},
	
		transpose: function () {
	
			var te = this.elements;
			var tmp;
	
			tmp = te[1]; te[1] = te[4]; te[4] = tmp;
			tmp = te[2]; te[2] = te[8]; te[8] = tmp;
			tmp = te[6]; te[6] = te[9]; te[9] = tmp;
	
			tmp = te[3]; te[3] = te[12]; te[12] = tmp;
			tmp = te[7]; te[7] = te[13]; te[13] = tmp;
			tmp = te[11]; te[11] = te[14]; te[14] = tmp;
	
			return this;
	
		},
	
		flattenToArray: function ( flat ) {
	
			var te = this.elements;
			flat[ 0 ] = te[0]; flat[ 1 ] = te[1]; flat[ 2 ] = te[2]; flat[ 3 ] = te[3];
			flat[ 4 ] = te[4]; flat[ 5 ] = te[5]; flat[ 6 ] = te[6]; flat[ 7 ] = te[7];
			flat[ 8 ] = te[8]; flat[ 9 ] = te[9]; flat[ 10 ] = te[10]; flat[ 11 ] = te[11];
			flat[ 12 ] = te[12]; flat[ 13 ] = te[13]; flat[ 14 ] = te[14]; flat[ 15 ] = te[15];
	
			return flat;
	
		},
	
		flattenToArrayOffset: function( flat, offset ) {
	
			var te = this.elements;
			flat[ offset ] = te[0];
			flat[ offset + 1 ] = te[1];
			flat[ offset + 2 ] = te[2];
			flat[ offset + 3 ] = te[3];
	
			flat[ offset + 4 ] = te[4];
			flat[ offset + 5 ] = te[5];
			flat[ offset + 6 ] = te[6];
			flat[ offset + 7 ] = te[7];
	
			flat[ offset + 8 ]  = te[8];
			flat[ offset + 9 ]  = te[9];
			flat[ offset + 10 ] = te[10];
			flat[ offset + 11 ] = te[11];
	
			flat[ offset + 12 ] = te[12];
			flat[ offset + 13 ] = te[13];
			flat[ offset + 14 ] = te[14];
			flat[ offset + 15 ] = te[15];
	
			return flat;
	
		},
	
		getPosition: function() {
	
			var v1 = new THREE.Vector3();
	
			return function () {
	
				console.warn( 'DEPRECATED: Matrix4\'s .getPosition() has been removed. Use Vector3.getPositionFromMatrix( matrix ) instead.' );
	
				var te = this.elements;
				return v1.set( te[12], te[13], te[14] );
	
			};
	
		}(),
	
		setPosition: function ( v ) {
	
			var te = this.elements;
	
			te[12] = v.x;
			te[13] = v.y;
			te[14] = v.z;
	
			return this;
	
		},
	
		getInverse: function ( m, throwOnInvertible ) {
	
			// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
			var te = this.elements;
			var me = m.elements;
	
			var n11 = me[0], n12 = me[4], n13 = me[8], n14 = me[12];
			var n21 = me[1], n22 = me[5], n23 = me[9], n24 = me[13];
			var n31 = me[2], n32 = me[6], n33 = me[10], n34 = me[14];
			var n41 = me[3], n42 = me[7], n43 = me[11], n44 = me[15];
	
			te[0] = n23*n34*n42 - n24*n33*n42 + n24*n32*n43 - n22*n34*n43 - n23*n32*n44 + n22*n33*n44;
			te[4] = n14*n33*n42 - n13*n34*n42 - n14*n32*n43 + n12*n34*n43 + n13*n32*n44 - n12*n33*n44;
			te[8] = n13*n24*n42 - n14*n23*n42 + n14*n22*n43 - n12*n24*n43 - n13*n22*n44 + n12*n23*n44;
			te[12] = n14*n23*n32 - n13*n24*n32 - n14*n22*n33 + n12*n24*n33 + n13*n22*n34 - n12*n23*n34;
			te[1] = n24*n33*n41 - n23*n34*n41 - n24*n31*n43 + n21*n34*n43 + n23*n31*n44 - n21*n33*n44;
			te[5] = n13*n34*n41 - n14*n33*n41 + n14*n31*n43 - n11*n34*n43 - n13*n31*n44 + n11*n33*n44;
			te[9] = n14*n23*n41 - n13*n24*n41 - n14*n21*n43 + n11*n24*n43 + n13*n21*n44 - n11*n23*n44;
			te[13] = n13*n24*n31 - n14*n23*n31 + n14*n21*n33 - n11*n24*n33 - n13*n21*n34 + n11*n23*n34;
			te[2] = n22*n34*n41 - n24*n32*n41 + n24*n31*n42 - n21*n34*n42 - n22*n31*n44 + n21*n32*n44;
			te[6] = n14*n32*n41 - n12*n34*n41 - n14*n31*n42 + n11*n34*n42 + n12*n31*n44 - n11*n32*n44;
			te[10] = n12*n24*n41 - n14*n22*n41 + n14*n21*n42 - n11*n24*n42 - n12*n21*n44 + n11*n22*n44;
			te[14] = n14*n22*n31 - n12*n24*n31 - n14*n21*n32 + n11*n24*n32 + n12*n21*n34 - n11*n22*n34;
			te[3] = n23*n32*n41 - n22*n33*n41 - n23*n31*n42 + n21*n33*n42 + n22*n31*n43 - n21*n32*n43;
			te[7] = n12*n33*n41 - n13*n32*n41 + n13*n31*n42 - n11*n33*n42 - n12*n31*n43 + n11*n32*n43;
			te[11] = n13*n22*n41 - n12*n23*n41 - n13*n21*n42 + n11*n23*n42 + n12*n21*n43 - n11*n22*n43;
			te[15] = n12*n23*n31 - n13*n22*n31 + n13*n21*n32 - n11*n23*n32 - n12*n21*n33 + n11*n22*n33;
	
			var det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 4 ] + me[ 2 ] * te[ 8 ] + me[ 3 ] * te[ 12 ];
	
			if ( det == 0 ) {
	
				var msg = "Matrix4.getInverse(): can't invert matrix, determinant is 0";
	
				if ( throwOnInvertible || false ) {
	
					throw new Error( msg ); 
	
				} else {
	
					console.warn( msg );
	
				}
	
				this.identity();
	
				return this;
			}
	
			this.multiplyScalar( 1 / det );
	
			return this;
	
		},
	
		compose: function() {
	
			var mRotation = new THREE.Matrix4(),
				mScale = new THREE.Matrix4();
			
			return function ( translation, rotation, scale ) {
	
				var te = this.elements;
	
				mRotation.identity();
				mRotation.setRotationFromQuaternion( rotation );
	
				mScale.makeScale( scale.x, scale.y, scale.z );
	
				this.multiplyMatrices( mRotation, mScale );
	
				te[12] = translation.x;
				te[13] = translation.y;
				te[14] = translation.z;
	
				return this;
	
			};
	
		}(),
	
		decompose: function() {
	
			var x = new THREE.Vector3(),
				y = new THREE.Vector3(),
				z = new THREE.Vector3(),
				matrix = new THREE.Matrix4();
	
			return function ( translation, rotation, scale ) {
	
				var te = this.elements;
	
				// grab the axis vectors
				x.set( te[0], te[1], te[2] );
				y.set( te[4], te[5], te[6] );
				z.set( te[8], te[9], te[10] );
	
				translation = ( translation instanceof THREE.Vector3 ) ? translation : new THREE.Vector3();
				rotation = ( rotation instanceof THREE.Quaternion ) ? rotation : new THREE.Quaternion();
				scale = ( scale instanceof THREE.Vector3 ) ? scale : new THREE.Vector3();
	
				scale.x = x.length();
				scale.y = y.length();
				scale.z = z.length();
	
				translation.x = te[12];
				translation.y = te[13];
				translation.z = te[14];
	
				// scale the rotation part
	
				matrix.copy( this );
	
				matrix.elements[0] /= scale.x;
				matrix.elements[1] /= scale.x;
				matrix.elements[2] /= scale.x;
	
				matrix.elements[4] /= scale.y;
				matrix.elements[5] /= scale.y;
				matrix.elements[6] /= scale.y;
	
				matrix.elements[8] /= scale.z;
				matrix.elements[9] /= scale.z;
				matrix.elements[10] /= scale.z;
	
				rotation.setFromRotationMatrix( matrix );
	
				return [ translation, rotation, scale ];
	
			};
	
		}(),
	
		extractPosition: function ( m ) {
	
			var te = this.elements;
			var me = m.elements;
	
			te[12] = me[12];
			te[13] = me[13];
			te[14] = me[14];
	
			return this;
	
		},
	
		extractRotation: function() {
	
			var v1 = new THREE.Vector3();
	
			return function ( m ) {
	
				var te = this.elements;
				var me = m.elements;
	
				var scaleX = 1 / v1.set( me[0], me[1], me[2] ).length();
				var scaleY = 1 / v1.set( me[4], me[5], me[6] ).length();
				var scaleZ = 1 / v1.set( me[8], me[9], me[10] ).length();
	
				te[0] = me[0] * scaleX;
				te[1] = me[1] * scaleX;
				te[2] = me[2] * scaleX;
	
				te[4] = me[4] * scaleY;
				te[5] = me[5] * scaleY;
				te[6] = me[6] * scaleY;
	
				te[8] = me[8] * scaleZ;
				te[9] = me[9] * scaleZ;
				te[10] = me[10] * scaleZ;
	
				return this;
	
			};
	
		}(),
	
		translate: function ( v ) {
	
			var te = this.elements;
			var x = v.x, y = v.y, z = v.z;
	
			te[12] = te[0] * x + te[4] * y + te[8] * z + te[12];
			te[13] = te[1] * x + te[5] * y + te[9] * z + te[13];
			te[14] = te[2] * x + te[6] * y + te[10] * z + te[14];
			te[15] = te[3] * x + te[7] * y + te[11] * z + te[15];
	
			return this;
	
		},
	
		rotateX: function ( angle ) {
	
			var te = this.elements;
			var m12 = te[4];
			var m22 = te[5];
			var m32 = te[6];
			var m42 = te[7];
			var m13 = te[8];
			var m23 = te[9];
			var m33 = te[10];
			var m43 = te[11];
			var c = Math.cos( angle );
			var s = Math.sin( angle );
	
			te[4] = c * m12 + s * m13;
			te[5] = c * m22 + s * m23;
			te[6] = c * m32 + s * m33;
			te[7] = c * m42 + s * m43;
	
			te[8] = c * m13 - s * m12;
			te[9] = c * m23 - s * m22;
			te[10] = c * m33 - s * m32;
			te[11] = c * m43 - s * m42;
	
			return this;
	
		},
	
		rotateY: function ( angle ) {
	
			var te = this.elements;
			var m11 = te[0];
			var m21 = te[1];
			var m31 = te[2];
			var m41 = te[3];
			var m13 = te[8];
			var m23 = te[9];
			var m33 = te[10];
			var m43 = te[11];
			var c = Math.cos( angle );
			var s = Math.sin( angle );
	
			te[0] = c * m11 - s * m13;
			te[1] = c * m21 - s * m23;
			te[2] = c * m31 - s * m33;
			te[3] = c * m41 - s * m43;
	
			te[8] = c * m13 + s * m11;
			te[9] = c * m23 + s * m21;
			te[10] = c * m33 + s * m31;
			te[11] = c * m43 + s * m41;
	
			return this;
	
		},
	
		rotateZ: function ( angle ) {
	
			var te = this.elements;
			var m11 = te[0];
			var m21 = te[1];
			var m31 = te[2];
			var m41 = te[3];
			var m12 = te[4];
			var m22 = te[5];
			var m32 = te[6];
			var m42 = te[7];
			var c = Math.cos( angle );
			var s = Math.sin( angle );
	
			te[0] = c * m11 + s * m12;
			te[1] = c * m21 + s * m22;
			te[2] = c * m31 + s * m32;
			te[3] = c * m41 + s * m42;
	
			te[4] = c * m12 - s * m11;
			te[5] = c * m22 - s * m21;
			te[6] = c * m32 - s * m31;
			te[7] = c * m42 - s * m41;
	
			return this;
	
		},
	
		rotateByAxis: function ( axis, angle ) {
	
			var te = this.elements;
	
			// optimize by checking axis
	
			if ( axis.x === 1 && axis.y === 0 && axis.z === 0 ) {
	
				return this.rotateX( angle );
	
			} else if ( axis.x === 0 && axis.y === 1 && axis.z === 0 ) {
	
				return this.rotateY( angle );
	
			} else if ( axis.x === 0 && axis.y === 0 && axis.z === 1 ) {
	
				return this.rotateZ( angle );
	
			}
	
			var x = axis.x, y = axis.y, z = axis.z;
			var n = Math.sqrt(x * x + y * y + z * z);
	
			x /= n;
			y /= n;
			z /= n;
	
			var xx = x * x, yy = y * y, zz = z * z;
			var c = Math.cos( angle );
			var s = Math.sin( angle );
			var oneMinusCosine = 1 - c;
			var xy = x * y * oneMinusCosine;
			var xz = x * z * oneMinusCosine;
			var yz = y * z * oneMinusCosine;
			var xs = x * s;
			var ys = y * s;
			var zs = z * s;
	
			var r11 = xx + (1 - xx) * c;
			var r21 = xy + zs;
			var r31 = xz - ys;
			var r12 = xy - zs;
			var r22 = yy + (1 - yy) * c;
			var r32 = yz + xs;
			var r13 = xz + ys;
			var r23 = yz - xs;
			var r33 = zz + (1 - zz) * c;
	
			var m11 = te[0], m21 = te[1], m31 = te[2], m41 = te[3];
			var m12 = te[4], m22 = te[5], m32 = te[6], m42 = te[7];
			var m13 = te[8], m23 = te[9], m33 = te[10], m43 = te[11];
	
			te[0] = r11 * m11 + r21 * m12 + r31 * m13;
			te[1] = r11 * m21 + r21 * m22 + r31 * m23;
			te[2] = r11 * m31 + r21 * m32 + r31 * m33;
			te[3] = r11 * m41 + r21 * m42 + r31 * m43;
	
			te[4] = r12 * m11 + r22 * m12 + r32 * m13;
			te[5] = r12 * m21 + r22 * m22 + r32 * m23;
			te[6] = r12 * m31 + r22 * m32 + r32 * m33;
			te[7] = r12 * m41 + r22 * m42 + r32 * m43;
	
			te[8] = r13 * m11 + r23 * m12 + r33 * m13;
			te[9] = r13 * m21 + r23 * m22 + r33 * m23;
			te[10] = r13 * m31 + r23 * m32 + r33 * m33;
			te[11] = r13 * m41 + r23 * m42 + r33 * m43;
	
			return this;
	
		},
	
		scale: function ( v ) {
	
			var te = this.elements;
			var x = v.x, y = v.y, z = v.z;
	
			te[0] *= x; te[4] *= y; te[8] *= z;
			te[1] *= x; te[5] *= y; te[9] *= z;
			te[2] *= x; te[6] *= y; te[10] *= z;
			te[3] *= x; te[7] *= y; te[11] *= z;
	
			return this;
	
		},
	
		getMaxScaleOnAxis: function () {
	
			var te = this.elements;
	
			var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
			var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
			var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
	
			return Math.sqrt( Math.max( scaleXSq, Math.max( scaleYSq, scaleZSq ) ) );
	
		},
	
		makeTranslation: function ( x, y, z ) {
	
			this.set(
	
				1, 0, 0, x,
				0, 1, 0, y,
				0, 0, 1, z,
				0, 0, 0, 1
	
			);
	
			return this;
	
		},
	
		makeRotationX: function ( theta ) {
	
			var c = Math.cos( theta ), s = Math.sin( theta );
	
			this.set(
	
				1, 0,  0, 0,
				0, c, -s, 0,
				0, s,  c, 0,
				0, 0,  0, 1
	
			);
	
			return this;
	
		},
	
		makeRotationY: function ( theta ) {
	
			var c = Math.cos( theta ), s = Math.sin( theta );
	
			this.set(
	
				 c, 0, s, 0,
				 0, 1, 0, 0,
				-s, 0, c, 0,
				 0, 0, 0, 1
	
			);
	
			return this;
	
		},
	
		makeRotationZ: function ( theta ) {
	
			var c = Math.cos( theta ), s = Math.sin( theta );
	
			this.set(
	
				c, -s, 0, 0,
				s,  c, 0, 0,
				0,  0, 1, 0,
				0,  0, 0, 1
	
			);
	
			return this;
	
		},
	
		makeRotationAxis: function ( axis, angle ) {
	
			// Based on http://www.gamedev.net/reference/articles/article1199.asp
	
			var c = Math.cos( angle );
			var s = Math.sin( angle );
			var t = 1 - c;
			var x = axis.x, y = axis.y, z = axis.z;
			var tx = t * x, ty = t * y;
	
			this.set(
	
				tx * x + c, tx * y - s * z, tx * z + s * y, 0,
				tx * y + s * z, ty * y + c, ty * z - s * x, 0,
				tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
				0, 0, 0, 1
	
			);
	
			 return this;
	
		},
	
		makeScale: function ( x, y, z ) {
	
			this.set(
	
				x, 0, 0, 0,
				0, y, 0, 0,
				0, 0, z, 0,
				0, 0, 0, 1
	
			);
	
			return this;
	
		},
	
		makeFrustum: function ( left, right, bottom, top, near, far ) {
	
			var te = this.elements;
			var x = 2 * near / ( right - left );
			var y = 2 * near / ( top - bottom );
	
			var a = ( right + left ) / ( right - left );
			var b = ( top + bottom ) / ( top - bottom );
			var c = - ( far + near ) / ( far - near );
			var d = - 2 * far * near / ( far - near );
	
			te[0] = x;	te[4] = 0;	te[8] = a;	te[12] = 0;
			te[1] = 0;	te[5] = y;	te[9] = b;	te[13] = 0;
			te[2] = 0;	te[6] = 0;	te[10] = c;	te[14] = d;
			te[3] = 0;	te[7] = 0;	te[11] = - 1;	te[15] = 0;
	
			return this;
	
		},
	
		makePerspective: function ( fov, aspect, near, far ) {
	
			var ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );
			var ymin = - ymax;
			var xmin = ymin * aspect;
			var xmax = ymax * aspect;
	
			return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );
	
		},
	
		makeOrthographic: function ( left, right, top, bottom, near, far ) {
	
			var te = this.elements;
			var w = right - left;
			var h = top - bottom;
			var p = far - near;
	
			var x = ( right + left ) / w;
			var y = ( top + bottom ) / h;
			var z = ( far + near ) / p;
	
			te[0] = 2 / w;	te[4] = 0;	te[8] = 0;	te[12] = -x;
			te[1] = 0;	te[5] = 2 / h;	te[9] = 0;	te[13] = -y;
			te[2] = 0;	te[6] = 0;	te[10] = -2/p;	te[14] = -z;
			te[3] = 0;	te[7] = 0;	te[11] = 0;	te[15] = 1;
	
			return this;
	
		},
	
		clone: function () {
	
			var te = this.elements;
	
			return new THREE.Matrix4(
	
				te[0], te[4], te[8], te[12],
				te[1], te[5], te[9], te[13],
				te[2], te[6], te[10], te[14],
				te[3], te[7], te[11], te[15]
	
			);
	
		}
	
	} );
	/**
	 * @author bhouston / http://exocortex.com
	 */
	
	THREE.Ray = function ( origin, direction ) {
	
		this.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();
		this.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();
	
	};
	
	THREE.extend( THREE.Ray.prototype, {
	
		set: function ( origin, direction ) {
	
			this.origin.copy( origin );
			this.direction.copy( direction );
	
			return this;
	
		},
	
		copy: function ( ray ) {
	
			this.origin.copy( ray.origin );
			this.direction.copy( ray.direction );
	
			return this;
	
		},
	
		at: function( t, optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
	
			return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );
	
		},
	
		recast: function() {
	
			var v1 = new THREE.Vector3();
	
			return function ( t ) {
	
				this.origin.copy( this.at( t, v1 ) );
	
				return this;
	
			};
	
		}(),
	
		closestPointToPoint: function ( point, optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			result.subVectors( point, this.origin );
			var directionDistance = result.dot( this.direction );
	
			return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );
	
		},
	
		distanceToPoint: function() {
	
			var v1 = new THREE.Vector3();
	
			return function ( point ) {
	
				var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );
				v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );
	
				return v1.distanceTo( point );
	
			};
	
		}(),
	
		isIntersectionSphere: function( sphere ) {
	
			return ( this.distanceToPoint( sphere.center ) <= sphere.radius );
	
		},
	
		isIntersectionPlane: function ( plane ) {
	
			// check if the line and plane are non-perpendicular, if they
			// eventually they will intersect.
			var denominator = plane.normal.dot( this.direction );
			if ( denominator != 0 ) {
	
				return true;
	
			}
	
			// line is coplanar, return origin
			if( plane.distanceToPoint( this.origin ) == 0 ) {
	
				return true;
	
			}
	
			return false;
	
		},
	
		distanceToPlane: function ( plane ) {
	
			var denominator = plane.normal.dot( this.direction );
			if ( denominator == 0 ) {
	
				// line is coplanar, return origin
				if( plane.distanceToPoint( this.origin ) == 0 ) {
	
					return 0;
	
				}
	
				// Unsure if this is the correct method to handle this case.
				return undefined;
	
			}
	
			var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;
	
			return t;
	
		},
	
		intersectPlane: function ( plane, optionalTarget ) {
	
			var t = this.distanceToPlane( plane );
	
			if ( t === undefined ) {
	
				return undefined;
			}
	
			return this.at( t, optionalTarget );
	
		},
	
		applyMatrix4: function ( matrix4 ) {
	
			this.direction.add( this.origin ).applyMatrix4( matrix4 );
			this.origin.applyMatrix4( matrix4 );
			this.direction.sub( this.origin );
	
			return this;
		},
	
		equals: function ( ray ) {
	
			return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );
	
		},
	
		clone: function () {
	
			return new THREE.Ray().copy( this );
	
		}
	
	} );
	/**
	 * @author bhouston / http://exocortex.com
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Sphere = function ( center, radius ) {
	
		this.center = ( center !== undefined ) ? center : new THREE.Vector3();
		this.radius = ( radius !== undefined ) ? radius : 0;
	
	};
	
	THREE.extend( THREE.Sphere.prototype, {
	
		set: function ( center, radius ) {
	
			this.center.copy( center );
			this.radius = radius;
	
			return this;
		},
	
		setFromCenterAndPoints: function ( center, points ) {
	
			var maxRadiusSq = 0;
	
			for ( var i = 0, il = points.length; i < il; i ++ ) {
	
				var radiusSq = center.distanceToSquared( points[ i ] );
				maxRadiusSq = Math.max( maxRadiusSq, radiusSq );
	
			}
	
			this.center = center;
			this.radius = Math.sqrt( maxRadiusSq );
	
			return this;
	
		},
	
		copy: function ( sphere ) {
	
			this.center.copy( sphere.center );
			this.radius = sphere.radius;
	
			return this;
	
		},
	
		empty: function () {
	
			return ( this.radius <= 0 );
	
		},
	
		containsPoint: function ( point ) {
	
			return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );
	
		},
	
		distanceToPoint: function ( point ) {
	
			return ( point.distanceTo( this.center ) - this.radius );
	
		},
	
		intersectsSphere: function ( sphere ) {
	
			var radiusSum = this.radius + sphere.radius;
	
			return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );
	
		},
	
		clampPoint: function ( point, optionalTarget ) {
	
			var deltaLengthSq = this.center.distanceToSquared( point );
	
			var result = optionalTarget || new THREE.Vector3();
			result.copy( point );
	
			if ( deltaLengthSq > ( this.radius * this.radius ) ) {
	
				result.sub( this.center ).normalize();
				result.multiplyScalar( this.radius ).add( this.center );
	
			}
	
			return result;
	
		},
	
		getBoundingBox: function ( optionalTarget ) {
	
			var box = optionalTarget || new THREE.Box3();
	
			box.set( this.center, this.center );
			box.expandByScalar( this.radius );
	
			return box;
	
		},
	
		applyMatrix4: function ( matrix ) {
	
			this.center.applyMatrix4( matrix );
			this.radius = this.radius * matrix.getMaxScaleOnAxis();
	
			return this;
	
		},
	
		translate: function ( offset ) {
	
			this.center.add( offset );
	
			return this;
	
		},
	
		equals: function ( sphere ) {
	
			return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );
	
		},
	
		clone: function () {
	
			return new THREE.Sphere().copy( this );
	
		}
	
	} );
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author bhouston / http://exocortex.com
	 */
	
	THREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {
	
		this.planes = [
	
			( p0 !== undefined ) ? p0 : new THREE.Plane(),
			( p1 !== undefined ) ? p1 : new THREE.Plane(),
			( p2 !== undefined ) ? p2 : new THREE.Plane(),
			( p3 !== undefined ) ? p3 : new THREE.Plane(),
			( p4 !== undefined ) ? p4 : new THREE.Plane(),
			( p5 !== undefined ) ? p5 : new THREE.Plane()
	
		];
	
	};
	
	THREE.extend( THREE.Frustum.prototype, {
	
		set: function ( p0, p1, p2, p3, p4, p5 ) {
	
			var planes = this.planes;
	
			planes[0].copy( p0 );
			planes[1].copy( p1 );
			planes[2].copy( p2 );
			planes[3].copy( p3 );
			planes[4].copy( p4 );
			planes[5].copy( p5 );
	
			return this;
	
		},
	
		copy: function ( frustum ) {
	
			var planes = this.planes;
	
			for( var i = 0; i < 6; i ++ ) {
	
				planes[i].copy( frustum.planes[i] );
	
			}
	
			return this;
	
		},
	
		setFromMatrix: function ( m ) {
	
			var planes = this.planes;
			var me = m.elements;
			var me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
			var me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
			var me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
			var me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
	
			planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
			planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
			planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
			planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
			planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
			planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();
	
			return this;
	
		},
	
		intersectsObject: function () {
	
			var center = new THREE.Vector3();
	
			return function ( object ) {
	
				// this method is expanded inlined for performance reasons.
	
				var matrix = object.matrixWorld;
				var planes = this.planes;
				var negRadius = - object.geometry.boundingSphere.radius * matrix.getMaxScaleOnAxis();
	
				center.getPositionFromMatrix( matrix );
	
				for ( var i = 0; i < 6; i ++ ) {
	
					var distance = planes[ i ].distanceToPoint( center );
	
					if ( distance < negRadius ) {
	
						return false;
	
					}
	
				}
	
				return true;
	
			};
	
		}(),
	
		intersectsSphere: function ( sphere ) {
	
			var planes = this.planes;
			var center = sphere.center;
			var negRadius = -sphere.radius;
	
			for ( var i = 0; i < 6; i ++ ) {
	
				var distance = planes[ i ].distanceToPoint( center );
	
				if ( distance < negRadius ) {
	
					return false;
	
				}
	
			}
	
			return true;
	
		},
	
		containsPoint: function ( point ) {
	
			var planes = this.planes;
	
			for ( var i = 0; i < 6; i ++ ) {
	
				if ( planes[ i ].distanceToPoint( point ) < 0 ) {
	
					return false;
	
				}
	
			}
	
			return true;
	
		},
	
		clone: function () {
	
			return new THREE.Frustum().copy( this );
	
		}
	
	} );
	/**
	 * @author bhouston / http://exocortex.com
	 */
	
	THREE.Plane = function ( normal, constant ) {
	
		this.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );
		this.constant = ( constant !== undefined ) ? constant : 0;
	
	};
	
	THREE.extend( THREE.Plane.prototype, {
	
		set: function ( normal, constant ) {
	
			this.normal.copy( normal );
			this.constant = constant;
	
			return this;
	
		},
	
		setComponents: function ( x, y, z, w ) {
	
			this.normal.set( x, y, z );
			this.constant = w;
	
			return this;
	
		},
	
		setFromNormalAndCoplanarPoint: function ( normal, point ) {
	
			this.normal.copy( normal );
			this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized
	
			return this;
	
		},
	
		setFromCoplanarPoints: function() {
	
			var v1 = new THREE.Vector3();
			var v2 = new THREE.Vector3();
	
			return function ( a, b, c ) {
	
				var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();
	
				// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
	
				this.setFromNormalAndCoplanarPoint( normal, a );
	
				return this;
	
			};
	
		}(),
	
	
		copy: function ( plane ) {
	
			this.normal.copy( plane.normal );
			this.constant = plane.constant;
	
			return this;
	
		},
	
		normalize: function () {
	
			// Note: will lead to a divide by zero if the plane is invalid.
	
			var inverseNormalLength = 1.0 / this.normal.length();
			this.normal.multiplyScalar( inverseNormalLength );
			this.constant *= inverseNormalLength;
	
			return this;
	
		},
	
		negate: function () {
	
			this.constant *= -1;
			this.normal.negate();
	
			return this;
	
		},
	
		distanceToPoint: function ( point ) {
	
			return this.normal.dot( point ) + this.constant;
	
		},
	
		distanceToSphere: function ( sphere ) {
	
			return this.distanceToPoint( sphere.center ) - sphere.radius;
	
		},
	
		projectPoint: function ( point, optionalTarget ) {
	
			return this.orthoPoint( point, optionalTarget ).sub( point ).negate();
	
		},
	
		orthoPoint: function ( point, optionalTarget ) {
	
			var perpendicularMagnitude = this.distanceToPoint( point );
	
			var result = optionalTarget || new THREE.Vector3();
			return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );
	
		},
	
		isIntersectionLine: function ( line ) {
	
			// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
	
			var startSign = this.distanceToPoint( line.start );
			var endSign = this.distanceToPoint( line.end );
	
			return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );
	
		},
	
		intersectLine: function() {
	
			var v1 = new THREE.Vector3();
	
			return function ( line, optionalTarget ) {
	
				var result = optionalTarget || new THREE.Vector3();
	
				var direction = line.delta( v1 );
	
				var denominator = this.normal.dot( direction );
	
				if ( denominator == 0 ) {
	
					// line is coplanar, return origin
					if( this.distanceToPoint( line.start ) == 0 ) {
	
						return result.copy( line.start );
	
					}
	
					// Unsure if this is the correct method to handle this case.
					return undefined;
	
				}
	
				var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;
	
				if( t < 0 || t > 1 ) {
	
					return undefined;
	
				}
	
				return result.copy( direction ).multiplyScalar( t ).add( line.start );
	
			};
	
		}(),
	
	
		coplanarPoint: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.copy( this.normal ).multiplyScalar( - this.constant );
	
		},
	
		applyMatrix4: function() {
	
			var v1 = new THREE.Vector3();
			var v2 = new THREE.Vector3();
	
			return function ( matrix, optionalNormalMatrix ) {
	
				// compute new normal based on theory here:
				// http://www.songho.ca/opengl/gl_normaltransform.html
				optionalNormalMatrix = optionalNormalMatrix || new THREE.Matrix3().getInverse( matrix ).transpose();
				var newNormal = v1.copy( this.normal ).applyMatrix3( optionalNormalMatrix );
	
				var newCoplanarPoint = this.coplanarPoint( v2 );
				newCoplanarPoint.applyMatrix4( matrix );
	
				this.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );
	
				return this;
	
			};
	
		}(),
	
		translate: function ( offset ) {
	
			this.constant = this.constant - offset.dot( this.normal );
	
			return this;
	
		},
	
		equals: function ( plane ) {
	
			return plane.normal.equals( this.normal ) && ( plane.constant == this.constant );
	
		},
	
		clone: function () {
	
			return new THREE.Plane().copy( this );
	
		}
	
	} );
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Math = {
	
		// Clamp value to range <a, b>
	
		clamp: function ( x, a, b ) {
	
			return ( x < a ) ? a : ( ( x > b ) ? b : x );
	
		},
	
		// Clamp value to range <a, inf)
	
		clampBottom: function ( x, a ) {
	
			return x < a ? a : x;
	
		},
	
		// Linear mapping from range <a1, a2> to range <b1, b2>
	
		mapLinear: function ( x, a1, a2, b1, b2 ) {
	
			return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );
	
		},
	
		// http://en.wikipedia.org/wiki/Smoothstep
	
		smoothstep: function ( x, min, max ) {
	
			if ( x <= min ) return 0;
			if ( x >= max ) return 1;
	
			x = ( x - min )/( max - min );
	
			return x*x*(3 - 2*x);
	
		},
	
		smootherstep: function ( x, min, max ) {
	
			if ( x <= min ) return 0;
			if ( x >= max ) return 1;
	
			x = ( x - min )/( max - min );
	
			return x*x*x*(x*(x*6 - 15) + 10);
	
		},
	
		// Random float from <0, 1> with 16 bits of randomness
		// (standard Math.random() creates repetitive patterns when applied over larger space)
	
		random16: function () {
	
			return ( 65280 * Math.random() + 255 * Math.random() ) / 65535;
	
		},
	
		// Random integer from <low, high> interval
	
		randInt: function ( low, high ) {
	
			return low + Math.floor( Math.random() * ( high - low + 1 ) );
	
		},
	
		// Random float from <low, high> interval
	
		randFloat: function ( low, high ) {
	
			return low + Math.random() * ( high - low );
	
		},
	
		// Random float from <-range/2, range/2> interval
	
		randFloatSpread: function ( range ) {
	
			return range * ( 0.5 - Math.random() );
	
		},
	
		sign: function ( x ) {
	
			return ( x < 0 ) ? -1 : ( ( x > 0 ) ? 1 : 0 );
	
		},
	
		degToRad: function() {
	
			var degreeToRadiansFactor = Math.PI / 180;
	
			return function ( degrees ) {
	
				return degrees * degreeToRadiansFactor;
	
			};
	
		}(),
	
		radToDeg: function() {
	
			var radianToDegreesFactor = 180 / Math.PI;
	
			return function ( radians ) {
	
				return radians * radianToDegreesFactor;
	
			};
	
		}()
	
	};
	/**
	 * Spline from Tween.js, slightly optimized (and trashed)
	 * http://sole.github.com/tween.js/examples/05_spline.html
	 *
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Spline = function ( points ) {
	
		this.points = points;
	
		var c = [], v3 = { x: 0, y: 0, z: 0 },
		point, intPoint, weight, w2, w3,
		pa, pb, pc, pd;
	
		this.initFromArray = function( a ) {
	
			this.points = [];
	
			for ( var i = 0; i < a.length; i++ ) {
	
				this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };
	
			}
	
		};
	
		this.getPoint = function ( k ) {
	
			point = ( this.points.length - 1 ) * k;
			intPoint = Math.floor( point );
			weight = point - intPoint;
	
			c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
			c[ 1 ] = intPoint;
			c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
			c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;
	
			pa = this.points[ c[ 0 ] ];
			pb = this.points[ c[ 1 ] ];
			pc = this.points[ c[ 2 ] ];
			pd = this.points[ c[ 3 ] ];
	
			w2 = weight * weight;
			w3 = weight * w2;
	
			v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
			v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
			v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );
	
			return v3;
	
		};
	
		this.getControlPointsArray = function () {
	
			var i, p, l = this.points.length,
				coords = [];
	
			for ( i = 0; i < l; i ++ ) {
	
				p = this.points[ i ];
				coords[ i ] = [ p.x, p.y, p.z ];
	
			}
	
			return coords;
	
		};
	
		// approximate length by summing linear segments
	
		this.getLength = function ( nSubDivisions ) {
	
			var i, index, nSamples, position,
				point = 0, intPoint = 0, oldIntPoint = 0,
				oldPosition = new THREE.Vector3(),
				tmpVec = new THREE.Vector3(),
				chunkLengths = [],
				totalLength = 0;
	
			// first point has 0 length
	
			chunkLengths[ 0 ] = 0;
	
			if ( !nSubDivisions ) nSubDivisions = 100;
	
			nSamples = this.points.length * nSubDivisions;
	
			oldPosition.copy( this.points[ 0 ] );
	
			for ( i = 1; i < nSamples; i ++ ) {
	
				index = i / nSamples;
	
				position = this.getPoint( index );
				tmpVec.copy( position );
	
				totalLength += tmpVec.distanceTo( oldPosition );
	
				oldPosition.copy( position );
	
				point = ( this.points.length - 1 ) * index;
				intPoint = Math.floor( point );
	
				if ( intPoint != oldIntPoint ) {
	
					chunkLengths[ intPoint ] = totalLength;
					oldIntPoint = intPoint;
	
				}
	
			}
	
			// last point ends with total length
	
			chunkLengths[ chunkLengths.length ] = totalLength;
	
			return { chunks: chunkLengths, total: totalLength };
	
		};
	
		this.reparametrizeByArcLength = function ( samplingCoef ) {
	
			var i, j,
				index, indexCurrent, indexNext,
				linearDistance, realDistance,
				sampling, position,
				newpoints = [],
				tmpVec = new THREE.Vector3(),
				sl = this.getLength();
	
			newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );
	
			for ( i = 1; i < this.points.length; i++ ) {
	
				//tmpVec.copy( this.points[ i - 1 ] );
				//linearDistance = tmpVec.distanceTo( this.points[ i ] );
	
				realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];
	
				sampling = Math.ceil( samplingCoef * realDistance / sl.total );
	
				indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
				indexNext = i / ( this.points.length - 1 );
	
				for ( j = 1; j < sampling - 1; j++ ) {
	
					index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );
	
					position = this.getPoint( index );
					newpoints.push( tmpVec.copy( position ).clone() );
	
				}
	
				newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );
	
			}
	
			this.points = newpoints;
	
		};
	
		// Catmull-Rom
	
		function interpolate( p0, p1, p2, p3, t, t2, t3 ) {
	
			var v0 = ( p2 - p0 ) * 0.5,
				v1 = ( p3 - p1 ) * 0.5;
	
			return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;
	
		};
	
	};
	/**
	 * @author bhouston / http://exocortex.com
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Triangle = function ( a, b, c ) {
	
		this.a = ( a !== undefined ) ? a : new THREE.Vector3();
		this.b = ( b !== undefined ) ? b : new THREE.Vector3();
		this.c = ( c !== undefined ) ? c : new THREE.Vector3();
	
	};
	
	THREE.Triangle.normal = function() {
	
		var v0 = new THREE.Vector3();
	
		return function( a, b, c, optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
	
			result.subVectors( c, b );
			v0.subVectors( a, b );
			result.cross( v0 );
	
			var resultLengthSq = result.lengthSq();
			if( resultLengthSq > 0 ) {
	
				return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );
	
			}
	
			return result.set( 0, 0, 0 );
	
		};
	
	}();
	
	// static/instance method to calculate barycoordinates
	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
	THREE.Triangle.barycoordFromPoint = function() {
	
		var v0 = new THREE.Vector3(),
			v1 = new THREE.Vector3(),
			v2 = new THREE.Vector3();
	
		return function ( point, a, b, c, optionalTarget ) {
	
			v0.subVectors( c, a );
			v1.subVectors( b, a );
			v2.subVectors( point, a );
	
			var dot00 = v0.dot( v0 );
			var dot01 = v0.dot( v1 );
			var dot02 = v0.dot( v2 );
			var dot11 = v1.dot( v1 );
			var dot12 = v1.dot( v2 );
	
			var denom = ( dot00 * dot11 - dot01 * dot01 );
	
			var result = optionalTarget || new THREE.Vector3();
	
			// colinear or singular triangle
			if( denom == 0 ) {
				// arbitrary location outside of triangle?
				// not sure if this is the best idea, maybe should be returning undefined
				return result.set( -2, -1, -1 );
			}
	
			var invDenom = 1 / denom;
			var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
			var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;
	
			// barycoordinates must always sum to 1
			return result.set( 1 - u - v, v, u );
	
		};
	
	}();
	
	THREE.Triangle.containsPoint = function() {
	
		var v1 = new THREE.Vector3();
	
		return function ( point, a, b, c ) {
	
			var result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );
	
			return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );
	
		};
	
	}();
	
	THREE.extend( THREE.Triangle.prototype, {
	
		constructor: THREE.Triangle,
	
		set: function ( a, b, c ) {
	
			this.a.copy( a );
			this.b.copy( b );
			this.c.copy( c );
	
			return this;
	
		},
	
		setFromPointsAndIndices: function ( points, i0, i1, i2 ) {
	
			this.a.copy( points[i0] );
			this.b.copy( points[i1] );
			this.c.copy( points[i2] );
	
			return this;
	
		},
	
		copy: function ( triangle ) {
	
			this.a.copy( triangle.a );
			this.b.copy( triangle.b );
			this.c.copy( triangle.c );
	
			return this;
	
		},
	
		area: function() {
	
			var v0 = new THREE.Vector3();
			var v1 = new THREE.Vector3();
	
			return function () {
	
				v0.subVectors( this.c, this.b );
				v1.subVectors( this.a, this.b );
	
				return v0.cross( v1 ).length() * 0.5;
	
			};
	
		}(),
	
		midpoint: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Vector3();
			return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );
	
		},
	
		normal: function ( optionalTarget ) {
	
			return THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );
	
		},
	
		plane: function ( optionalTarget ) {
	
			var result = optionalTarget || new THREE.Plane();
	
			return result.setFromCoplanarPoints( this.a, this.b, this.c );
	
		},
	
		barycoordFromPoint: function ( point, optionalTarget ) {
	
			return THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );
	
		},
	
		containsPoint: function ( point ) {
	
			return THREE.Triangle.containsPoint( point, this.a, this.b, this.c );
	
		},
	
		equals: function ( triangle ) {
	
			return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );
	
		},
	
		clone: function () {
	
			return new THREE.Triangle().copy( this );
	
		}
	
	} );
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Vertex = function ( v ) {
	
		console.warn( 'THREE.Vertex has been DEPRECATED. Use THREE.Vector3 instead.')
		return v;
	
	};
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.UV = function ( u, v ) {
	
		console.warn( 'THREE.UV has been DEPRECATED. Use THREE.Vector2 instead.')
		return new THREE.Vector2( u, v );
	
	};
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Clock = function ( autoStart ) {
	
		this.autoStart = ( autoStart !== undefined ) ? autoStart : true;
	
		this.startTime = 0;
		this.oldTime = 0;
		this.elapsedTime = 0;
	
		this.running = false;
	
	};
	
	THREE.extend( THREE.Clock.prototype, {
	
		start: function () {
	
			this.startTime = window.performance !== undefined && window.performance.now !== undefined
						? window.performance.now()
						: Date.now();
	
			this.oldTime = this.startTime;
			this.running = true;
		},
	
		stop: function () {
	
			this.getElapsedTime();
			this.running = false;
	
		},
	
		getElapsedTime: function () {
	
			this.getDelta();
			return this.elapsedTime;
	
		},
	
		getDelta: function () {
	
			var diff = 0;
	
			if ( this.autoStart && ! this.running ) {
	
				this.start();
	
			}
	
			if ( this.running ) {
	
				var newTime = window.performance !== undefined && window.performance.now !== undefined
						? window.performance.now()
						: Date.now();
	
				diff = 0.001 * ( newTime - this.oldTime );
				this.oldTime = newTime;
	
				this.elapsedTime += diff;
	
			}
	
			return diff;
	
		}
	
	} );
	/**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */
	
	THREE.EventDispatcher = function () {
	
		var listeners = {};
	
		this.addEventListener = function ( type, listener ) {
	
			if ( listeners[ type ] === undefined ) {
	
				listeners[ type ] = [];
	
			}
	
			if ( listeners[ type ].indexOf( listener ) === - 1 ) {
	
				listeners[ type ].push( listener );
	
			}
	
		};
	
		this.removeEventListener = function ( type, listener ) {
	
			var index = listeners[ type ].indexOf( listener );
	
			if ( index !== - 1 ) {
	
				listeners[ type ].splice( index, 1 );
	
			}
	
		};
	
		this.dispatchEvent = function ( event ) {
	
			var listenerArray = listeners[ event.type ];
	
			if ( listenerArray !== undefined ) {
	
				event.target = this;
	
				for ( var i = 0, l = listenerArray.length; i < l; i ++ ) {
	
					listenerArray[ i ].call( this, event );
	
				}
	
			}
	
		};
	
	};
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author bhouston / http://exocortex.com/
	 */
	
	( function ( THREE ) {
	
		THREE.Raycaster = function ( origin, direction, near, far ) {
	
			this.ray = new THREE.Ray( origin, direction );
	
			// normalized ray.direction required for accurate distance calculations
			if( this.ray.direction.lengthSq() > 0 ) {
	
				this.ray.direction.normalize();
	
			}
	
			this.near = near || 0;
			this.far = far || Infinity;
	
		};
	
		var sphere = new THREE.Sphere();
		var localRay = new THREE.Ray();
		var facePlane = new THREE.Plane();
		var intersectPoint = new THREE.Vector3();
		var matrixPosition = new THREE.Vector3();
	
		var inverseMatrix = new THREE.Matrix4();
	
		var descSort = function ( a, b ) {
	
			return a.distance - b.distance;
	
		};
	
		var intersectObject = function ( object, raycaster, intersects ) {
	
			if ( object instanceof THREE.Particle ) {
	
				matrixPosition.getPositionFromMatrix( object.matrixWorld );
				var distance = raycaster.ray.distanceToPoint( matrixPosition );
	
				if ( distance > object.scale.x ) {
	
					return intersects;
	
				}
	
				intersects.push( {
	
					distance: distance,
					point: object.position,
					face: null,
					object: object
	
				} );
	
			} else if ( object instanceof THREE.Mesh ) {
	
				// Checking boundingSphere distance to ray
				matrixPosition.getPositionFromMatrix( object.matrixWorld );
				sphere.set(
					matrixPosition,
					object.geometry.boundingSphere.radius * object.matrixWorld.getMaxScaleOnAxis() );
	
				if ( ! raycaster.ray.isIntersectionSphere( sphere ) ) {
	
					return intersects;
	
				}
	
				// Checking faces
	
				var geometry = object.geometry;
				var vertices = geometry.vertices;
	
				var isFaceMaterial = object.material instanceof THREE.MeshFaceMaterial;
				var objectMaterials = isFaceMaterial === true ? object.material.materials : null;
	
				var side = object.material.side;
	
				var a, b, c, d;
				var precision = raycaster.precision;
	
				object.matrixRotationWorld.extractRotation( object.matrixWorld );
	
				inverseMatrix.getInverse( object.matrixWorld );
	
				localRay.copy( raycaster.ray ).applyMatrix4( inverseMatrix );
	
				for ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {
	
					var face = geometry.faces[ f ];
	
					var material = isFaceMaterial === true ? objectMaterials[ face.materialIndex ] : object.material;
	
					if ( material === undefined ) continue;
	
					facePlane.setFromNormalAndCoplanarPoint( face.normal, vertices[face.a] );
	
					var planeDistance = localRay.distanceToPlane( facePlane );
	
					// bail if raycaster and plane are parallel
					if ( Math.abs( planeDistance ) < precision ) continue;
	
					// if negative distance, then plane is behind raycaster
					if ( planeDistance < 0 ) continue;
	
					// check if we hit the wrong side of a single sided face
					side = material.side;
					if( side !== THREE.DoubleSide ) {
	
						var planeSign = localRay.direction.dot( facePlane.normal );
	
						if( ! ( side === THREE.FrontSide ? planeSign < 0 : planeSign > 0 ) ) continue;
	
					}
	
					// this can be done using the planeDistance from localRay because localRay wasn't normalized, but ray was
					if ( planeDistance < raycaster.near || planeDistance > raycaster.far ) continue;
	
					intersectPoint = localRay.at( planeDistance, intersectPoint ); // passing in intersectPoint avoids a copy
	
					if ( face instanceof THREE.Face3 ) {
	
						a = vertices[ face.a ];
						b = vertices[ face.b ];
						c = vertices[ face.c ];
	
						if ( ! THREE.Triangle.containsPoint( intersectPoint, a, b, c ) ) continue;
	
					} else if ( face instanceof THREE.Face4 ) {
	
						a = vertices[ face.a ];
						b = vertices[ face.b ];
						c = vertices[ face.c ];
						d = vertices[ face.d ];
	
						if ( ( ! THREE.Triangle.containsPoint( intersectPoint, a, b, d ) ) &&
							 ( ! THREE.Triangle.containsPoint( intersectPoint, b, c, d ) ) ) continue;
	
					} else {
	
						// This is added because if we call out of this if/else group when none of the cases
						//    match it will add a point to the intersection list erroneously.
						throw Error( "face type not supported" );
	
					}
	
					intersects.push( {
	
						distance: planeDistance,	// this works because the original ray was normalized, and the transformed localRay wasn't
						point: raycaster.ray.at( planeDistance ),
						face: face,
						faceIndex: f,
						object: object
	
					} );
	
				}
	
			}
	
		};
	
		var intersectDescendants = function ( object, raycaster, intersects ) {
	
			var descendants = object.getDescendants();
	
			for ( var i = 0, l = descendants.length; i < l; i ++ ) {
	
				intersectObject( descendants[ i ], raycaster, intersects );
	
			}
		};
	
		//
	
		THREE.Raycaster.prototype.precision = 0.0001;
	
		THREE.Raycaster.prototype.set = function ( origin, direction ) {
	
			this.ray.set( origin, direction );
	
			// normalized ray.direction required for accurate distance calculations
			if( this.ray.direction.length() > 0 ) {
	
				this.ray.direction.normalize();
	
			}
	
		};
	
		THREE.Raycaster.prototype.intersectObject = function ( object, recursive ) {
	
			var intersects = [];
	
			if ( recursive === true ) {
	
				intersectDescendants( object, this, intersects );
	
			}
	
			intersectObject( object, this, intersects );
	
			intersects.sort( descSort );
	
			return intersects;
	
		};
	
		THREE.Raycaster.prototype.intersectObjects = function ( objects, recursive ) {
	
			var intersects = [];
	
			for ( var i = 0, l = objects.length; i < l; i ++ ) {
	
				intersectObject( objects[ i ], this, intersects );
	
				if ( recursive === true ) {
	
					intersectDescendants( objects[ i ], this, intersects );
	
				}
			}
	
			intersects.sort( descSort );
	
			return intersects;
	
		};
	
	}( THREE ) );
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Object3D = function () {
	
		this.id = THREE.Object3DIdCount ++;
	
		this.name = '';
		this.properties = {};
	
		this.parent = undefined;
		this.children = [];
	
		this.up = new THREE.Vector3( 0, 1, 0 );
	
		this.position = new THREE.Vector3();
		this.rotation = new THREE.Vector3();
		this.eulerOrder = THREE.Object3D.defaultEulerOrder;
		this.scale = new THREE.Vector3( 1, 1, 1 );
	
		this.renderDepth = null;
	
		this.rotationAutoUpdate = true;
	
		this.matrix = new THREE.Matrix4();
		this.matrixWorld = new THREE.Matrix4();
		this.matrixRotationWorld = new THREE.Matrix4();
	
		this.matrixAutoUpdate = true;
		this.matrixWorldNeedsUpdate = true;
	
		this.quaternion = new THREE.Quaternion();
		this.useQuaternion = false;
	
		this.visible = true;
	
		this.castShadow = false;
		this.receiveShadow = false;
	
		this.frustumCulled = true;
	
		this._vector = new THREE.Vector3();
	
	};
	
	
	THREE.Object3D.prototype = {
	
		constructor: THREE.Object3D,
	
		applyMatrix: function ( matrix ) {
	
			this.matrix.multiplyMatrices( matrix, this.matrix );
	
			this.scale.getScaleFromMatrix( this.matrix );
	
			var mat = new THREE.Matrix4().extractRotation( this.matrix );
			this.rotation.setEulerFromRotationMatrix( mat, this.eulerOrder );
	
			this.position.getPositionFromMatrix( this.matrix );
	
		},
	
		translate: function ( distance, axis ) {
	
			this.matrix.rotateAxis( axis );
			this.position.add( axis.multiplyScalar( distance ) );
	
		},
	
		translateX: function ( distance ) {
	
			this.translate( distance, this._vector.set( 1, 0, 0 ) );
	
		},
	
		translateY: function ( distance ) {
	
			this.translate( distance, this._vector.set( 0, 1, 0 ) );
	
		},
	
		translateZ: function ( distance ) {
	
			this.translate( distance, this._vector.set( 0, 0, 1 ) );
	
		},
	
		localToWorld: function ( vector ) {
	
			return vector.applyMatrix4( this.matrixWorld );
	
		},
	
		worldToLocal: function ( vector ) {
	
			return vector.applyMatrix4( THREE.Object3D.__m1.getInverse( this.matrixWorld ) );
	
		},
	
		lookAt: function ( vector ) {
	
			// TODO: Add hierarchy support.
	
			this.matrix.lookAt( vector, this.position, this.up );
	
			if ( this.rotationAutoUpdate ) {
	
				if ( this.useQuaternion === false )  {
	
					this.rotation.setEulerFromRotationMatrix( this.matrix, this.eulerOrder );
	
				} else {
	
					this.quaternion.copy( this.matrix.decompose()[ 1 ] );
	
				}
	
			}
	
		},
	
		add: function ( object ) {
	
			if ( object === this ) {
	
				console.warn( 'THREE.Object3D.add: An object can\'t be added as a child of itself.' );
				return;
	
			}
	
			if ( object instanceof THREE.Object3D ) {
	
				if ( object.parent !== undefined ) {
	
					object.parent.remove( object );
	
				}
	
				object.parent = this;
				this.children.push( object );
	
				// add to scene
	
				var scene = this;
	
				while ( scene.parent !== undefined ) {
	
					scene = scene.parent;
	
				}
	
				if ( scene !== undefined && scene instanceof THREE.Scene )  {
	
					scene.__addObject( object );
	
				}
	
			}
	
		},
	
		remove: function ( object ) {
	
			var index = this.children.indexOf( object );
	
			if ( index !== - 1 ) {
	
				object.parent = undefined;
				this.children.splice( index, 1 );
	
				// remove from scene
	
				var scene = this;
	
				while ( scene.parent !== undefined ) {
	
					scene = scene.parent;
	
				}
	
				if ( scene !== undefined && scene instanceof THREE.Scene ) {
	
					scene.__removeObject( object );
	
				}
	
			}
	
		},
	
		traverse: function ( callback ) {
	
			callback( this );
	
			for ( var i = 0, l = this.children.length; i < l; i ++ ) {
	
				this.children[ i ].traverse( callback );
	
			}
	
		},
	
		getChildByName: function ( name, recursive ) {
	
			for ( var i = 0, l = this.children.length; i < l; i ++ ) {
	
				var child = this.children[ i ];
	
				if ( child.name === name ) {
	
					return child;
	
				}
	
				if ( recursive === true ) {
	
					child = child.getChildByName( name, recursive );
	
					if ( child !== undefined ) {
	
						return child;
	
					}
	
				}
	
			}
	
			return undefined;
	
		},
	
		getDescendants: function ( array ) {
	
			if ( array === undefined ) array = [];
	
			Array.prototype.push.apply( array, this.children );
	
			for ( var i = 0, l = this.children.length; i < l; i ++ ) {
	
				this.children[ i ].getDescendants( array );
	
			}
	
			return array;
	
		},
	
		updateMatrix: function () {
	
			this.matrix.setPosition( this.position );
	
			if ( this.useQuaternion === false )  {
	
				this.matrix.setRotationFromEuler( this.rotation, this.eulerOrder );
	
			} else {
	
				this.matrix.setRotationFromQuaternion( this.quaternion );
	
			}
	
			if ( this.scale.x !== 1 || this.scale.y !== 1 || this.scale.z !== 1 ) {
	
				this.matrix.scale( this.scale );
	
			}
	
			this.matrixWorldNeedsUpdate = true;
	
		},
	
		updateMatrixWorld: function ( force ) {
	
			if ( this.matrixAutoUpdate === true ) this.updateMatrix();
	
			if ( this.matrixWorldNeedsUpdate === true || force === true ) {
	
				if ( this.parent === undefined ) {
	
					this.matrixWorld.copy( this.matrix );
	
				} else {
	
					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );
	
				}
	
				this.matrixWorldNeedsUpdate = false;
	
				force = true;
	
			}
	
			// update children
	
			for ( var i = 0, l = this.children.length; i < l; i ++ ) {
	
				this.children[ i ].updateMatrixWorld( force );
	
			}
	
		},
	
		clone: function ( object ) {
	
			if ( object === undefined ) object = new THREE.Object3D();
	
			object.name = this.name;
	
			object.up.copy( this.up );
	
			object.position.copy( this.position );
			if ( object.rotation instanceof THREE.Vector3 ) object.rotation.copy( this.rotation ); // because of Sprite madness
			object.eulerOrder = this.eulerOrder;
			object.scale.copy( this.scale );
	
			object.renderDepth = this.renderDepth;
	
			object.rotationAutoUpdate = this.rotationAutoUpdate;
	
			object.matrix.copy( this.matrix );
			object.matrixWorld.copy( this.matrixWorld );
			object.matrixRotationWorld.copy( this.matrixRotationWorld );
	
			object.matrixAutoUpdate = this.matrixAutoUpdate;
			object.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;
	
			object.quaternion.copy( this.quaternion );
			object.useQuaternion = this.useQuaternion;
	
			object.visible = this.visible;
	
			object.castShadow = this.castShadow;
			object.receiveShadow = this.receiveShadow;
	
			object.frustumCulled = this.frustumCulled;
	
			for ( var i = 0; i < this.children.length; i ++ ) {
	
				var child = this.children[ i ];
				object.add( child.clone() );
	
			}
	
			return object;
	
		}
	
	};
	
	THREE.Object3D.__m1 = new THREE.Matrix4();
	THREE.Object3D.defaultEulerOrder = 'XYZ',
	
	THREE.Object3DIdCount = 0;
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author julianwa / https://github.com/julianwa
	 */
	
	THREE.Projector = function () {
	
		var _object, _objectCount, _objectPool = [], _objectPoolLength = 0,
		_vertex, _vertexCount, _vertexPool = [], _vertexPoolLength = 0,
		_face, _face3Count, _face3Pool = [], _face3PoolLength = 0,
		_face4Count, _face4Pool = [], _face4PoolLength = 0,
		_line, _lineCount, _linePool = [], _linePoolLength = 0,
		_particle, _particleCount, _particlePool = [], _particlePoolLength = 0,
	
		_renderData = { objects: [], sprites: [], lights: [], elements: [] },
	
		_vector3 = new THREE.Vector3(),
		_vector4 = new THREE.Vector4(),
	
		_clipBox = new THREE.Box3( new THREE.Vector3( -1, -1, -1 ), new THREE.Vector3( 1, 1, 1 ) ),
		_boundingBox = new THREE.Box3(),
		_points3 = new Array( 3 ),
		_points4 = new Array( 4 ),
	
		_viewMatrix = new THREE.Matrix4(),
		_viewProjectionMatrix = new THREE.Matrix4(),
	
		_modelMatrix,
		_modelViewProjectionMatrix = new THREE.Matrix4(),
	
		_normalMatrix = new THREE.Matrix3(),
		_normalViewMatrix = new THREE.Matrix3(),
	
		_centroid = new THREE.Vector3(),
	
		_frustum = new THREE.Frustum(),
	
		_clippedVertex1PositionScreen = new THREE.Vector4(),
		_clippedVertex2PositionScreen = new THREE.Vector4();
	
		this.projectVector = function ( vector, camera ) {
	
			camera.matrixWorldInverse.getInverse( camera.matrixWorld );
	
			_viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
	
			return vector.applyProjection( _viewProjectionMatrix );
	
		};
	
		this.unprojectVector = function ( vector, camera ) {
	
			camera.projectionMatrixInverse.getInverse( camera.projectionMatrix );
	
			_viewProjectionMatrix.multiplyMatrices( camera.matrixWorld, camera.projectionMatrixInverse );
	
			return vector.applyProjection( _viewProjectionMatrix );
	
		};
	
		this.pickingRay = function ( vector, camera ) {
	
			// set two vectors with opposing z values
			vector.z = -1.0;
			var end = new THREE.Vector3( vector.x, vector.y, 1.0 );
	
			this.unprojectVector( vector, camera );
			this.unprojectVector( end, camera );
	
			// find direction from vector to end
			end.sub( vector ).normalize();
	
			return new THREE.Raycaster( vector, end );
	
		};
	
		var projectGraph = function ( root, sortObjects ) {
	
			_objectCount = 0;
	
			_renderData.objects.length = 0;
			_renderData.sprites.length = 0;
			_renderData.lights.length = 0;
	
			var projectObject = function ( parent ) {
	
				for ( var c = 0, cl = parent.children.length; c < cl; c ++ ) {
	
					var object = parent.children[ c ];
	
					if ( object.visible === false ) continue;
	
					if ( object instanceof THREE.Light ) {
	
						_renderData.lights.push( object );
	
					} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line ) {
	
						if ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {
	
							_object = getNextObjectInPool();
							_object.object = object;
	
							if ( object.renderDepth !== null ) {
	
								_object.z = object.renderDepth;
	
							} else {
	
								_vector3.getPositionFromMatrix( object.matrixWorld );
								_vector3.applyProjection( _viewProjectionMatrix );
								_object.z = _vector3.z;
	
							}
	
							_renderData.objects.push( _object );
	
						}
	
					} else if ( object instanceof THREE.Sprite || object instanceof THREE.Particle ) {
	
						_object = getNextObjectInPool();
						_object.object = object;
	
						// TODO: Find an elegant and performant solution and remove this dupe code.
	
						if ( object.renderDepth !== null ) {
	
							_object.z = object.renderDepth;
	
						} else {
	
							_vector3.getPositionFromMatrix( object.matrixWorld );
							_vector3.applyProjection( _viewProjectionMatrix );
							_object.z = _vector3.z;
	
						}
	
						_renderData.sprites.push( _object );
	
					} else {
	
						_object = getNextObjectInPool();
						_object.object = object;
	
						if ( object.renderDepth !== null ) {
	
							_object.z = object.renderDepth;
	
						} else {
	
							_vector3.getPositionFromMatrix( object.matrixWorld );
							_vector3.applyProjection( _viewProjectionMatrix );
							_object.z = _vector3.z;
	
						}
	
						_renderData.objects.push( _object );
	
					}
	
					projectObject( object );
	
				}
	
			};
	
			projectObject( root );
	
			if ( sortObjects === true ) _renderData.objects.sort( painterSort );
	
			return _renderData;
	
		};
	
		this.projectScene = function ( scene, camera, sortObjects, sortElements ) {
	
			var visible = false,
			o, ol, v, vl, f, fl, n, nl, c, cl, u, ul, object,
			geometry, vertices, faces, face, faceVertexNormals, faceVertexUvs, uvs,
			v1, v2, v3, v4, isFaceMaterial, objectMaterials;
	
			_face3Count = 0;
			_face4Count = 0;
			_lineCount = 0;
			_particleCount = 0;
	
			_renderData.elements.length = 0;
	
			scene.updateMatrixWorld();
	
			if ( camera.parent === undefined ) camera.updateMatrixWorld();
	
			_viewMatrix.copy( camera.matrixWorldInverse.getInverse( camera.matrixWorld ) );
			_viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, _viewMatrix );
	
			_normalViewMatrix.getInverse( _viewMatrix );
			_normalViewMatrix.transpose();
	
			_frustum.setFromMatrix( _viewProjectionMatrix );
	
			_renderData = projectGraph( scene, sortObjects );
	
			for ( o = 0, ol = _renderData.objects.length; o < ol; o ++ ) {
	
				object = _renderData.objects[ o ].object;
	
				_modelMatrix = object.matrixWorld;
	
				_vertexCount = 0;
	
				if ( object instanceof THREE.Mesh ) {
	
					geometry = object.geometry;
	
					vertices = geometry.vertices;
					faces = geometry.faces;
					faceVertexUvs = geometry.faceVertexUvs;
	
					_normalMatrix.getInverse( _modelMatrix );
					_normalMatrix.transpose();
	
					isFaceMaterial = object.material instanceof THREE.MeshFaceMaterial;
					objectMaterials = isFaceMaterial === true ? object.material : null;
	
					for ( v = 0, vl = vertices.length; v < vl; v ++ ) {
	
						_vertex = getNextVertexInPool();
	
						_vertex.positionWorld.copy( vertices[ v ] ).applyMatrix4( _modelMatrix );
						_vertex.positionScreen.copy( _vertex.positionWorld ).applyMatrix4( _viewProjectionMatrix );
	
						_vertex.positionScreen.x /= _vertex.positionScreen.w;
						_vertex.positionScreen.y /= _vertex.positionScreen.w;
						_vertex.positionScreen.z /= _vertex.positionScreen.w;
	
						_vertex.visible = ! ( _vertex.positionScreen.x < -1 || _vertex.positionScreen.x > 1 ||
								      _vertex.positionScreen.y < -1 || _vertex.positionScreen.y > 1 ||
								      _vertex.positionScreen.z < -1 || _vertex.positionScreen.z > 1 );
	
					}
	
					for ( f = 0, fl = faces.length; f < fl; f ++ ) {
	
						face = faces[ f ];
	
						var material = isFaceMaterial === true
							? objectMaterials.materials[ face.materialIndex ]
							: object.material;
	
						if ( material === undefined ) continue;
	
						var side = material.side;
	
						if ( face instanceof THREE.Face3 ) {
	
							v1 = _vertexPool[ face.a ];
							v2 = _vertexPool[ face.b ];
							v3 = _vertexPool[ face.c ];
	
							_points3[ 0 ] = v1.positionScreen;
							_points3[ 1 ] = v2.positionScreen;
							_points3[ 2 ] = v3.positionScreen;
	
							if ( v1.visible === true || v2.visible === true || v3.visible === true ||
								_clipBox.isIntersectionBox( _boundingBox.setFromPoints( _points3 ) ) ) {
	
								visible = ( ( v3.positionScreen.x - v1.positionScreen.x ) * ( v2.positionScreen.y - v1.positionScreen.y ) -
									( v3.positionScreen.y - v1.positionScreen.y ) * ( v2.positionScreen.x - v1.positionScreen.x ) ) < 0;
	
								if ( side === THREE.DoubleSide || visible === ( side === THREE.FrontSide ) ) {
	
									_face = getNextFace3InPool();
	
									_face.v1.copy( v1 );
									_face.v2.copy( v2 );
									_face.v3.copy( v3 );
	
								} else {
	
									continue;
	
								}
	
							} else {
	
								continue;
	
							}
	
						} else if ( face instanceof THREE.Face4 ) {
	
							v1 = _vertexPool[ face.a ];
							v2 = _vertexPool[ face.b ];
							v3 = _vertexPool[ face.c ];
							v4 = _vertexPool[ face.d ];
	
							_points4[ 0 ] = v1.positionScreen;
							_points4[ 1 ] = v2.positionScreen;
							_points4[ 2 ] = v3.positionScreen;
							_points4[ 3 ] = v4.positionScreen;
	
							if ( v1.visible === true || v2.visible === true || v3.visible === true || v4.visible === true ||
								_clipBox.isIntersectionBox( _boundingBox.setFromPoints( _points4 ) ) ) {
	
								visible = ( v4.positionScreen.x - v1.positionScreen.x ) * ( v2.positionScreen.y - v1.positionScreen.y ) -
									( v4.positionScreen.y - v1.positionScreen.y ) * ( v2.positionScreen.x - v1.positionScreen.x ) < 0 ||
									( v2.positionScreen.x - v3.positionScreen.x ) * ( v4.positionScreen.y - v3.positionScreen.y ) -
									( v2.positionScreen.y - v3.positionScreen.y ) * ( v4.positionScreen.x - v3.positionScreen.x ) < 0;
	
	
								if ( side === THREE.DoubleSide || visible === ( side === THREE.FrontSide ) ) {
	
									_face = getNextFace4InPool();
	
									_face.v1.copy( v1 );
									_face.v2.copy( v2 );
									_face.v3.copy( v3 );
									_face.v4.copy( v4 );
	
								} else {
	
									continue;
	
								}
	
							} else {
	
								continue;
	
							}
	
						}
	
						_face.normalModel.copy( face.normal );
	
						if ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {
	
							_face.normalModel.negate();
	
						}
	
						_face.normalModel.applyMatrix3( _normalMatrix ).normalize();
	
						_face.normalModelView.copy( _face.normalModel ).applyMatrix3( _normalViewMatrix );
	
						_face.centroidModel.copy( face.centroid ).applyMatrix4( _modelMatrix );
	
						faceVertexNormals = face.vertexNormals;
	
						for ( n = 0, nl = faceVertexNormals.length; n < nl; n ++ ) {
	
							var normalModel = _face.vertexNormalsModel[ n ];
							normalModel.copy( faceVertexNormals[ n ] );
	
							if ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {
	
								normalModel.negate();
	
							}
	
							normalModel.applyMatrix3( _normalMatrix ).normalize();
	
							var normalModelView = _face.vertexNormalsModelView[ n ];
							normalModelView.copy( normalModel ).applyMatrix3( _normalViewMatrix );
	
						}
	
						_face.vertexNormalsLength = faceVertexNormals.length;
	
						for ( c = 0, cl = faceVertexUvs.length; c < cl; c ++ ) {
	
							uvs = faceVertexUvs[ c ][ f ];
	
							if ( uvs === undefined ) continue;
	
							for ( u = 0, ul = uvs.length; u < ul; u ++ ) {
	
								_face.uvs[ c ][ u ] = uvs[ u ];
	
							}
	
						}
	
						_face.color = face.color;
						_face.material = material;
	
						_centroid.copy( _face.centroidModel ).applyProjection( _viewProjectionMatrix );
	
						_face.z = _centroid.z;
	
						_renderData.elements.push( _face );
	
					}
	
				} else if ( object instanceof THREE.Line ) {
	
					_modelViewProjectionMatrix.multiplyMatrices( _viewProjectionMatrix, _modelMatrix );
	
					vertices = object.geometry.vertices;
	
					v1 = getNextVertexInPool();
					v1.positionScreen.copy( vertices[ 0 ] ).applyMatrix4( _modelViewProjectionMatrix );
	
					// Handle LineStrip and LinePieces
					var step = object.type === THREE.LinePieces ? 2 : 1;
	
					for ( v = 1, vl = vertices.length; v < vl; v ++ ) {
	
						v1 = getNextVertexInPool();
						v1.positionScreen.copy( vertices[ v ] ).applyMatrix4( _modelViewProjectionMatrix );
	
						if ( ( v + 1 ) % step > 0 ) continue;
	
						v2 = _vertexPool[ _vertexCount - 2 ];
	
						_clippedVertex1PositionScreen.copy( v1.positionScreen );
						_clippedVertex2PositionScreen.copy( v2.positionScreen );
	
						if ( clipLine( _clippedVertex1PositionScreen, _clippedVertex2PositionScreen ) === true ) {
	
							// Perform the perspective divide
							_clippedVertex1PositionScreen.multiplyScalar( 1 / _clippedVertex1PositionScreen.w );
							_clippedVertex2PositionScreen.multiplyScalar( 1 / _clippedVertex2PositionScreen.w );
	
							_line = getNextLineInPool();
							_line.v1.positionScreen.copy( _clippedVertex1PositionScreen );
							_line.v2.positionScreen.copy( _clippedVertex2PositionScreen );
	
							_line.z = Math.max( _clippedVertex1PositionScreen.z, _clippedVertex2PositionScreen.z );
	
							_line.material = object.material;
	
							_renderData.elements.push( _line );
	
						}
	
					}
	
				}
	
			}
	
			for ( o = 0, ol = _renderData.sprites.length; o < ol; o++ ) {
	
				object = _renderData.sprites[ o ].object;
	
				_modelMatrix = object.matrixWorld;
	
				if ( object instanceof THREE.Particle ) {
	
					_vector4.set( _modelMatrix.elements[12], _modelMatrix.elements[13], _modelMatrix.elements[14], 1 );
					_vector4.applyMatrix4( _viewProjectionMatrix );
	
					_vector4.z /= _vector4.w;
	
					if ( _vector4.z > 0 && _vector4.z < 1 ) {
	
						_particle = getNextParticleInPool();
						_particle.object = object;
						_particle.x = _vector4.x / _vector4.w;
						_particle.y = _vector4.y / _vector4.w;
						_particle.z = _vector4.z;
	
						_particle.rotation = object.rotation.z;
	
						_particle.scale.x = object.scale.x * Math.abs( _particle.x - ( _vector4.x + camera.projectionMatrix.elements[0] ) / ( _vector4.w + camera.projectionMatrix.elements[12] ) );
						_particle.scale.y = object.scale.y * Math.abs( _particle.y - ( _vector4.y + camera.projectionMatrix.elements[5] ) / ( _vector4.w + camera.projectionMatrix.elements[13] ) );
	
						_particle.material = object.material;
	
						_renderData.elements.push( _particle );
	
					}
	
				}
	
			}
	
			if ( sortElements === true ) _renderData.elements.sort( painterSort );
	
			return _renderData;
	
		};
	
		// Pools
	
		function getNextObjectInPool() {
	
			if ( _objectCount === _objectPoolLength ) {
	
				var object = new THREE.RenderableObject();
				_objectPool.push( object );
				_objectPoolLength ++;
				_objectCount ++;
				return object;
	
			}
	
			return _objectPool[ _objectCount ++ ];
	
		}
	
		function getNextVertexInPool() {
	
			if ( _vertexCount === _vertexPoolLength ) {
	
				var vertex = new THREE.RenderableVertex();
				_vertexPool.push( vertex );
				_vertexPoolLength ++;
				_vertexCount ++;
				return vertex;
	
			}
	
			return _vertexPool[ _vertexCount ++ ];
	
		}
	
		function getNextFace3InPool() {
	
			if ( _face3Count === _face3PoolLength ) {
	
				var face = new THREE.RenderableFace3();
				_face3Pool.push( face );
				_face3PoolLength ++;
				_face3Count ++;
				return face;
	
			}
	
			return _face3Pool[ _face3Count ++ ];
	
	
		}
	
		function getNextFace4InPool() {
	
			if ( _face4Count === _face4PoolLength ) {
	
				var face = new THREE.RenderableFace4();
				_face4Pool.push( face );
				_face4PoolLength ++;
				_face4Count ++;
				return face;
	
			}
	
			return _face4Pool[ _face4Count ++ ];
	
		}
	
		function getNextLineInPool() {
	
			if ( _lineCount === _linePoolLength ) {
	
				var line = new THREE.RenderableLine();
				_linePool.push( line );
				_linePoolLength ++;
				_lineCount ++
				return line;
	
			}
	
			return _linePool[ _lineCount ++ ];
	
		}
	
		function getNextParticleInPool() {
	
			if ( _particleCount === _particlePoolLength ) {
	
				var particle = new THREE.RenderableParticle();
				_particlePool.push( particle );
				_particlePoolLength ++;
				_particleCount ++
				return particle;
	
			}
	
			return _particlePool[ _particleCount ++ ];
	
		}
	
		//
	
		function painterSort( a, b ) {
	
			return b.z - a.z;
	
		}
	
		function clipLine( s1, s2 ) {
	
			var alpha1 = 0, alpha2 = 1,
	
			// Calculate the boundary coordinate of each vertex for the near and far clip planes,
			// Z = -1 and Z = +1, respectively.
			bc1near =  s1.z + s1.w,
			bc2near =  s2.z + s2.w,
			bc1far =  - s1.z + s1.w,
			bc2far =  - s2.z + s2.w;
	
			if ( bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0 ) {
	
				// Both vertices lie entirely within all clip planes.
				return true;
	
			} else if ( ( bc1near < 0 && bc2near < 0) || (bc1far < 0 && bc2far < 0 ) ) {
	
				// Both vertices lie entirely outside one of the clip planes.
				return false;
	
			} else {
	
				// The line segment spans at least one clip plane.
	
				if ( bc1near < 0 ) {
	
					// v1 lies outside the near plane, v2 inside
					alpha1 = Math.max( alpha1, bc1near / ( bc1near - bc2near ) );
	
				} else if ( bc2near < 0 ) {
	
					// v2 lies outside the near plane, v1 inside
					alpha2 = Math.min( alpha2, bc1near / ( bc1near - bc2near ) );
	
				}
	
				if ( bc1far < 0 ) {
	
					// v1 lies outside the far plane, v2 inside
					alpha1 = Math.max( alpha1, bc1far / ( bc1far - bc2far ) );
	
				} else if ( bc2far < 0 ) {
	
					// v2 lies outside the far plane, v2 inside
					alpha2 = Math.min( alpha2, bc1far / ( bc1far - bc2far ) );
	
				}
	
				if ( alpha2 < alpha1 ) {
	
					// The line segment spans two boundaries, but is outside both of them.
					// (This can't happen when we're only clipping against just near/far but good
					//  to leave the check here for future usage if other clip planes are added.)
					return false;
	
				} else {
	
					// Update the s1 and s2 vertices to match the clipped line segment.
					s1.lerp( s2, alpha1 );
					s2.lerp( s1, 1 - alpha2 );
	
					return true;
	
				}
	
			}
	
		}
	
	};
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {
	
		this.a = a;
		this.b = b;
		this.c = c;
	
		this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
		this.vertexNormals = normal instanceof Array ? normal : [ ];
	
		this.color = color instanceof THREE.Color ? color : new THREE.Color();
		this.vertexColors = color instanceof Array ? color : [];
	
		this.vertexTangents = [];
	
		this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
	
		this.centroid = new THREE.Vector3();
	
	};
	
	THREE.Face3.prototype = {
	
		constructor: THREE.Face3,
	
		clone: function () {
	
			var face = new THREE.Face3( this.a, this.b, this.c );
	
			face.normal.copy( this.normal );
			face.color.copy( this.color );
			face.centroid.copy( this.centroid );
	
			face.materialIndex = this.materialIndex;
	
			var i, il;
			for ( i = 0, il = this.vertexNormals.length; i < il; i ++ ) face.vertexNormals[ i ] = this.vertexNormals[ i ].clone();
			for ( i = 0, il = this.vertexColors.length; i < il; i ++ ) face.vertexColors[ i ] = this.vertexColors[ i ].clone();
			for ( i = 0, il = this.vertexTangents.length; i < il; i ++ ) face.vertexTangents[ i ] = this.vertexTangents[ i ].clone();
	
			return face;
	
		}
	
	};
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {
	
		this.a = a;
		this.b = b;
		this.c = c;
		this.d = d;
	
		this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
		this.vertexNormals = normal instanceof Array ? normal : [ ];
	
		this.color = color instanceof THREE.Color ? color : new THREE.Color();
		this.vertexColors = color instanceof Array ? color : [];
	
		this.vertexTangents = [];
	
		this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
	
		this.centroid = new THREE.Vector3();
	
	};
	
	THREE.Face4.prototype = {
	
		constructor: THREE.Face4,
	
		clone: function () {
	
			var face = new THREE.Face4( this.a, this.b, this.c, this.d );
	
			face.normal.copy( this.normal );
			face.color.copy( this.color );
			face.centroid.copy( this.centroid );
	
			face.materialIndex = this.materialIndex;
	
			var i, il;
			for ( i = 0, il = this.vertexNormals.length; i < il; i ++ ) face.vertexNormals[ i ] = this.vertexNormals[ i ].clone();
			for ( i = 0, il = this.vertexColors.length; i < il; i ++ ) face.vertexColors[ i ] = this.vertexColors[ i ].clone();
			for ( i = 0, il = this.vertexTangents.length; i < il; i ++ ) face.vertexTangents[ i ] = this.vertexTangents[ i ].clone();
	
			return face;
	
		}
	
	};
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author kile / http://kile.stravaganza.org/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author bhouston / http://exocortex.com
	 */
	
	THREE.Geometry = function () {
	
		THREE.EventDispatcher.call( this );
	
		this.id = THREE.GeometryIdCount ++;
	
		this.name = '';
	
		this.vertices = [];
		this.colors = [];  // one-to-one vertex colors, used in ParticleSystem, Line and Ribbon
		this.normals = []; // one-to-one vertex normals, used in Ribbon
	
		this.faces = [];
	
		this.faceUvs = [[]];
		this.faceVertexUvs = [[]];
	
		this.morphTargets = [];
		this.morphColors = [];
		this.morphNormals = [];
	
		this.skinWeights = [];
		this.skinIndices = [];
	
		this.lineDistances = [];
	
		this.boundingBox = null;
		this.boundingSphere = null;
	
		this.hasTangents = false;
	
		this.dynamic = true; // the intermediate typed arrays will be deleted when set to false
	
		// update flags
	
		this.verticesNeedUpdate = false;
		this.elementsNeedUpdate = false;
		this.uvsNeedUpdate = false;
		this.normalsNeedUpdate = false;
		this.tangentsNeedUpdate = false;
		this.colorsNeedUpdate = false;
		this.lineDistancesNeedUpdate = false;
	
		this.buffersNeedUpdate = false;
	
	};
	
	THREE.Geometry.prototype = {
	
		constructor: THREE.Geometry,
	
		applyMatrix: function ( matrix ) {
	
			var normalMatrix = new THREE.Matrix3().getInverse( matrix ).transpose();
	
			for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {
	
				var vertex = this.vertices[ i ];
				vertex.applyMatrix4( matrix );
	
			}
	
			for ( var i = 0, il = this.faces.length; i < il; i ++ ) {
	
				var face = this.faces[ i ];
				face.normal.applyMatrix3( normalMatrix ).normalize();
	
				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {
	
					face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();
	
				}
	
				face.centroid.applyMatrix4( matrix );
	
			}
	
		},
	
		computeCentroids: function () {
	
			var f, fl, face;
	
			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
				face = this.faces[ f ];
				face.centroid.set( 0, 0, 0 );
	
				if ( face instanceof THREE.Face3 ) {
	
					face.centroid.add( this.vertices[ face.a ] );
					face.centroid.add( this.vertices[ face.b ] );
					face.centroid.add( this.vertices[ face.c ] );
					face.centroid.divideScalar( 3 );
	
				} else if ( face instanceof THREE.Face4 ) {
	
					face.centroid.add( this.vertices[ face.a ] );
					face.centroid.add( this.vertices[ face.b ] );
					face.centroid.add( this.vertices[ face.c ] );
					face.centroid.add( this.vertices[ face.d ] );
					face.centroid.divideScalar( 4 );
	
				}
	
			}
	
		},
	
		computeFaceNormals: function () {
	
			var cb = new THREE.Vector3(), ab = new THREE.Vector3();
	
			for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
				var face = this.faces[ f ];
	
				var vA = this.vertices[ face.a ];
				var vB = this.vertices[ face.b ];
				var vC = this.vertices[ face.c ];
	
				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );
	
				cb.normalize();
	
				face.normal.copy( cb );
	
			}
	
		},
	
		computeVertexNormals: function ( areaWeighted ) {
	
			var v, vl, f, fl, face, vertices;
	
			// create internal buffers for reuse when calling this method repeatedly
			// (otherwise memory allocation / deallocation every frame is big resource hog)
	
			if ( this.__tmpVertices === undefined ) {
	
				this.__tmpVertices = new Array( this.vertices.length );
				vertices = this.__tmpVertices;
	
				for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {
	
					vertices[ v ] = new THREE.Vector3();
	
				}
	
				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					face = this.faces[ f ];
	
					if ( face instanceof THREE.Face3 ) {
	
						face.vertexNormals = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];
	
					} else if ( face instanceof THREE.Face4 ) {
	
						face.vertexNormals = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];
	
					}
	
				}
	
			} else {
	
				vertices = this.__tmpVertices;
	
				for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {
	
					vertices[ v ].set( 0, 0, 0 );
	
				}
	
			}
	
			if ( areaWeighted ) {
	
				// vertex normals weighted by triangle areas
				// http://www.iquilezles.org/www/articles/normals/normals.htm
	
				var vA, vB, vC, vD;
				var cb = new THREE.Vector3(), ab = new THREE.Vector3(),
					db = new THREE.Vector3(), dc = new THREE.Vector3(), bc = new THREE.Vector3();
	
				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					face = this.faces[ f ];
	
					if ( face instanceof THREE.Face3 ) {
	
						vA = this.vertices[ face.a ];
						vB = this.vertices[ face.b ];
						vC = this.vertices[ face.c ];
	
						cb.subVectors( vC, vB );
						ab.subVectors( vA, vB );
						cb.cross( ab );
	
						vertices[ face.a ].add( cb );
						vertices[ face.b ].add( cb );
						vertices[ face.c ].add( cb );
	
					} else if ( face instanceof THREE.Face4 ) {
	
						vA = this.vertices[ face.a ];
						vB = this.vertices[ face.b ];
						vC = this.vertices[ face.c ];
						vD = this.vertices[ face.d ];
	
						// abd
	
						db.subVectors( vD, vB );
						ab.subVectors( vA, vB );
						db.cross( ab );
	
						vertices[ face.a ].add( db );
						vertices[ face.b ].add( db );
						vertices[ face.d ].add( db );
	
						// bcd
	
						dc.subVectors( vD, vC );
						bc.subVectors( vB, vC );
						dc.cross( bc );
	
						vertices[ face.b ].add( dc );
						vertices[ face.c ].add( dc );
						vertices[ face.d ].add( dc );
	
					}
	
				}
	
			} else {
	
				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					face = this.faces[ f ];
	
					if ( face instanceof THREE.Face3 ) {
	
						vertices[ face.a ].add( face.normal );
						vertices[ face.b ].add( face.normal );
						vertices[ face.c ].add( face.normal );
	
					} else if ( face instanceof THREE.Face4 ) {
	
						vertices[ face.a ].add( face.normal );
						vertices[ face.b ].add( face.normal );
						vertices[ face.c ].add( face.normal );
						vertices[ face.d ].add( face.normal );
	
					}
	
				}
	
			}
	
			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {
	
				vertices[ v ].normalize();
	
			}
	
			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
				face = this.faces[ f ];
	
				if ( face instanceof THREE.Face3 ) {
	
					face.vertexNormals[ 0 ].copy( vertices[ face.a ] );
					face.vertexNormals[ 1 ].copy( vertices[ face.b ] );
					face.vertexNormals[ 2 ].copy( vertices[ face.c ] );
	
				} else if ( face instanceof THREE.Face4 ) {
	
					face.vertexNormals[ 0 ].copy( vertices[ face.a ] );
					face.vertexNormals[ 1 ].copy( vertices[ face.b ] );
					face.vertexNormals[ 2 ].copy( vertices[ face.c ] );
					face.vertexNormals[ 3 ].copy( vertices[ face.d ] );
	
				}
	
			}
	
		},
	
		computeMorphNormals: function () {
	
			var i, il, f, fl, face;
	
			// save original normals
			// - create temp variables on first access
			//   otherwise just copy (for faster repeated calls)
	
			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
				face = this.faces[ f ];
	
				if ( ! face.__originalFaceNormal ) {
	
					face.__originalFaceNormal = face.normal.clone();
	
				} else {
	
					face.__originalFaceNormal.copy( face.normal );
	
				}
	
				if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];
	
				for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {
	
					if ( ! face.__originalVertexNormals[ i ] ) {
	
						face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();
	
					} else {
	
						face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );
	
					}
	
				}
	
			}
	
			// use temp geometry to compute face and vertex normals for each morph
	
			var tmpGeo = new THREE.Geometry();
			tmpGeo.faces = this.faces;
	
			for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {
	
				// create on first access
	
				if ( ! this.morphNormals[ i ] ) {
	
					this.morphNormals[ i ] = {};
					this.morphNormals[ i ].faceNormals = [];
					this.morphNormals[ i ].vertexNormals = [];
	
					var dstNormalsFace = this.morphNormals[ i ].faceNormals;
					var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;
	
					var faceNormal, vertexNormals;
	
					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
						face = this.faces[ f ];
	
						faceNormal = new THREE.Vector3();
	
						if ( face instanceof THREE.Face3 ) {
	
							vertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };
	
						} else {
	
							vertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3(), d: new THREE.Vector3() };
	
						}
	
						dstNormalsFace.push( faceNormal );
						dstNormalsVertex.push( vertexNormals );
	
					}
	
				}
	
				var morphNormals = this.morphNormals[ i ];
	
				// set vertices to morph target
	
				tmpGeo.vertices = this.morphTargets[ i ].vertices;
	
				// compute morph normals
	
				tmpGeo.computeFaceNormals();
				tmpGeo.computeVertexNormals();
	
				// store morph normals
	
				var faceNormal, vertexNormals;
	
				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					face = this.faces[ f ];
	
					faceNormal = morphNormals.faceNormals[ f ];
					vertexNormals = morphNormals.vertexNormals[ f ];
	
					faceNormal.copy( face.normal );
	
					if ( face instanceof THREE.Face3 ) {
	
						vertexNormals.a.copy( face.vertexNormals[ 0 ] );
						vertexNormals.b.copy( face.vertexNormals[ 1 ] );
						vertexNormals.c.copy( face.vertexNormals[ 2 ] );
	
					} else {
	
						vertexNormals.a.copy( face.vertexNormals[ 0 ] );
						vertexNormals.b.copy( face.vertexNormals[ 1 ] );
						vertexNormals.c.copy( face.vertexNormals[ 2 ] );
						vertexNormals.d.copy( face.vertexNormals[ 3 ] );
	
					}
	
				}
	
			}
	
			// restore original normals
	
			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
				face = this.faces[ f ];
	
				face.normal = face.__originalFaceNormal;
				face.vertexNormals = face.__originalVertexNormals;
	
			}
	
		},
	
		computeTangents: function () {
	
			// based on http://www.terathon.com/code/tangent.html
			// tangents go to vertices
	
			var f, fl, v, vl, i, il, vertexIndex,
				face, uv, vA, vB, vC, uvA, uvB, uvC,
				x1, x2, y1, y2, z1, z2,
				s1, s2, t1, t2, r, t, test,
				tan1 = [], tan2 = [],
				sdir = new THREE.Vector3(), tdir = new THREE.Vector3(),
				tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3(),
				n = new THREE.Vector3(), w;
	
			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {
	
				tan1[ v ] = new THREE.Vector3();
				tan2[ v ] = new THREE.Vector3();
	
			}
	
			function handleTriangle( context, a, b, c, ua, ub, uc ) {
	
				vA = context.vertices[ a ];
				vB = context.vertices[ b ];
				vC = context.vertices[ c ];
	
				uvA = uv[ ua ];
				uvB = uv[ ub ];
				uvC = uv[ uc ];
	
				x1 = vB.x - vA.x;
				x2 = vC.x - vA.x;
				y1 = vB.y - vA.y;
				y2 = vC.y - vA.y;
				z1 = vB.z - vA.z;
				z2 = vC.z - vA.z;
	
				s1 = uvB.x - uvA.x;
				s2 = uvC.x - uvA.x;
				t1 = uvB.y - uvA.y;
				t2 = uvC.y - uvA.y;
	
				r = 1.0 / ( s1 * t2 - s2 * t1 );
				sdir.set( ( t2 * x1 - t1 * x2 ) * r,
						  ( t2 * y1 - t1 * y2 ) * r,
						  ( t2 * z1 - t1 * z2 ) * r );
				tdir.set( ( s1 * x2 - s2 * x1 ) * r,
						  ( s1 * y2 - s2 * y1 ) * r,
						  ( s1 * z2 - s2 * z1 ) * r );
	
				tan1[ a ].add( sdir );
				tan1[ b ].add( sdir );
				tan1[ c ].add( sdir );
	
				tan2[ a ].add( tdir );
				tan2[ b ].add( tdir );
				tan2[ c ].add( tdir );
	
			}
	
			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
				face = this.faces[ f ];
				uv = this.faceVertexUvs[ 0 ][ f ]; // use UV layer 0 for tangents
	
				if ( face instanceof THREE.Face3 ) {
	
					handleTriangle( this, face.a, face.b, face.c, 0, 1, 2 );
	
				} else if ( face instanceof THREE.Face4 ) {
	
					handleTriangle( this, face.a, face.b, face.d, 0, 1, 3 );
					handleTriangle( this, face.b, face.c, face.d, 1, 2, 3 );
	
				}
	
			}
	
			var faceIndex = [ 'a', 'b', 'c', 'd' ];
	
			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
				face = this.faces[ f ];
	
				for ( i = 0; i < face.vertexNormals.length; i++ ) {
	
					n.copy( face.vertexNormals[ i ] );
	
					vertexIndex = face[ faceIndex[ i ] ];
	
					t = tan1[ vertexIndex ];
	
					// Gram-Schmidt orthogonalize
	
					tmp.copy( t );
					tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();
	
					// Calculate handedness
	
					tmp2.crossVectors( face.vertexNormals[ i ], t );
					test = tmp2.dot( tan2[ vertexIndex ] );
					w = (test < 0.0) ? -1.0 : 1.0;
	
					face.vertexTangents[ i ] = new THREE.Vector4( tmp.x, tmp.y, tmp.z, w );
	
				}
	
			}
	
			this.hasTangents = true;
	
		},
	
		computeLineDistances: function ( ) {
	
			var d = 0;
			var vertices = this.vertices;
	
			for ( var i = 0, il = vertices.length; i < il; i ++ ) {
	
				if ( i > 0 ) {
	
					d += vertices[ i ].distanceTo( vertices[ i - 1 ] );
	
				}
	
				this.lineDistances[ i ] = d;
	
			}
	
		},
	
		computeBoundingBox: function () {
	
			if ( this.boundingBox === null ) {
	
				this.boundingBox = new THREE.Box3();
	
			}
	
			this.boundingBox.setFromPoints( this.vertices );
	
		},
	
		computeBoundingSphere: function () {
	
			if ( this.boundingSphere === null ) {
	
				this.boundingSphere = new THREE.Sphere();
	
			}
	
			this.boundingSphere.setFromCenterAndPoints( this.boundingSphere.center, this.vertices );
	
		},
	
		/*
		 * Checks for duplicate vertices with hashmap.
		 * Duplicated vertices are removed
		 * and faces' vertices are updated.
		 */
	
		mergeVertices: function () {
	
			var verticesMap = {}; // Hashmap for looking up vertice by position coordinates (and making sure they are unique)
			var unique = [], changes = [];
	
			var v, key;
			var precisionPoints = 4; // number of decimal points, eg. 4 for epsilon of 0.0001
			var precision = Math.pow( 10, precisionPoints );
			var i,il, face;
			var indices, k, j, jl, u;
	
			// reset cache of vertices as it now will be changing.
			this.__tmpVertices = undefined;
	
			for ( i = 0, il = this.vertices.length; i < il; i ++ ) {
	
				v = this.vertices[ i ];
				key = [ Math.round( v.x * precision ), Math.round( v.y * precision ), Math.round( v.z * precision ) ].join( '_' );
	
				if ( verticesMap[ key ] === undefined ) {
	
					verticesMap[ key ] = i;
					unique.push( this.vertices[ i ] );
					changes[ i ] = unique.length - 1;
	
				} else {
	
					//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
					changes[ i ] = changes[ verticesMap[ key ] ];
	
				}
	
			};
	
	
			// if faces are completely degenerate after merging vertices, we
			// have to remove them from the geometry.
			var faceIndicesToRemove = [];
	
			for( i = 0, il = this.faces.length; i < il; i ++ ) {
	
				face = this.faces[ i ];
	
				if ( face instanceof THREE.Face3 ) {
	
					face.a = changes[ face.a ];
					face.b = changes[ face.b ];
					face.c = changes[ face.c ];
	
					indices = [ face.a, face.b, face.c ];
	
					var dupIndex = -1;
	
					// if any duplicate vertices are found in a Face3
					// we have to remove the face as nothing can be saved
					for ( var n = 0; n < 3; n ++ ) {
						if ( indices[ n ] == indices[ ( n + 1 ) % 3 ] ) {
	
							dupIndex = n;
							faceIndicesToRemove.push( i );
							break;
	
						}
					}
	
				} else if ( face instanceof THREE.Face4 ) {
	
					face.a = changes[ face.a ];
					face.b = changes[ face.b ];
					face.c = changes[ face.c ];
					face.d = changes[ face.d ];
	
					// check dups in (a, b, c, d) and convert to -> face3
	
					indices = [ face.a, face.b, face.c, face.d ];
	
					var dupIndex = -1;
	
					for ( var n = 0; n < 4; n ++ ) {
	
						if ( indices[ n ] == indices[ ( n + 1 ) % 4 ] ) {
	
							// if more than one duplicated vertex is found
							// we can't generate any valid Face3's, thus
							// we need to remove this face complete.
							if ( dupIndex >= 0 ) {
	
								faceIndicesToRemove.push( i );
	
							}
	
							dupIndex = n;
	
						}
					}
	
					if ( dupIndex >= 0 ) {
	
						indices.splice( dupIndex, 1 );
	
						var newFace = new THREE.Face3( indices[0], indices[1], indices[2], face.normal, face.color, face.materialIndex );
	
						for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {
	
							u = this.faceVertexUvs[ j ][ i ];
	
							if ( u ) {
								u.splice( dupIndex, 1 );
							}
	
						}
	
						if( face.vertexNormals && face.vertexNormals.length > 0) {
	
							newFace.vertexNormals = face.vertexNormals;
							newFace.vertexNormals.splice( dupIndex, 1 );
	
						}
	
						if( face.vertexColors && face.vertexColors.length > 0 ) {
	
							newFace.vertexColors = face.vertexColors;
							newFace.vertexColors.splice( dupIndex, 1 );
						}
	
						this.faces[ i ] = newFace;
					}
	
				}
	
			}
	
			for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {
	
				this.faces.splice( i, 1 );
	
				for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {
	
					this.faceVertexUvs[ j ].splice( i, 1 );
	
				}
	
			}
	
			// Use unique set of vertices
	
			var diff = this.vertices.length - unique.length;
			this.vertices = unique;
			return diff;
	
		},
	
		clone: function () {
	
			var geometry = new THREE.Geometry();
	
			var vertices = this.vertices;
	
			for ( var i = 0, il = vertices.length; i < il; i ++ ) {
	
				geometry.vertices.push( vertices[ i ].clone() );
	
			}
	
			var faces = this.faces;
	
			for ( var i = 0, il = faces.length; i < il; i ++ ) {
	
				geometry.faces.push( faces[ i ].clone() );
	
			}
	
			var uvs = this.faceVertexUvs[ 0 ];
	
			for ( var i = 0, il = uvs.length; i < il; i ++ ) {
	
				var uv = uvs[ i ], uvCopy = [];
	
				for ( var j = 0, jl = uv.length; j < jl; j ++ ) {
	
					uvCopy.push( new THREE.Vector2( uv[ j ].x, uv[ j ].y ) );
	
				}
	
				geometry.faceVertexUvs[ 0 ].push( uvCopy );
	
			}
	
			return geometry;
	
		},
	
		dispose: function () {
	
			this.dispatchEvent( { type: 'dispose' } );
	
		}
	
	};
	
	THREE.GeometryIdCount = 0;
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.BufferGeometry = function () {
	
		THREE.EventDispatcher.call( this );
	
		this.id = THREE.GeometryIdCount ++;
	
		// attributes
	
		this.attributes = {};
	
		// attributes typed arrays are kept only if dynamic flag is set
	
		this.dynamic = false;
	
		// offsets for chunks when using indexed elements
	
		this.offsets = [];
	
		// boundings
	
		this.boundingBox = null;
		this.boundingSphere = null;
	
		this.hasTangents = false;
	
		// for compatibility
	
		this.morphTargets = [];
	
	};
	
	THREE.BufferGeometry.prototype = {
	
		constructor : THREE.BufferGeometry,
	
		applyMatrix: function ( matrix ) {
	
			var positionArray;
			var normalArray;
	
			if ( this.attributes[ "position" ] ) positionArray = this.attributes[ "position" ].array;
			if ( this.attributes[ "normal" ] ) normalArray = this.attributes[ "normal" ].array;
	
			if ( positionArray !== undefined ) {
	
				matrix.multiplyVector3Array( positionArray );
				this.verticesNeedUpdate = true;
	
			}
	
			if ( normalArray !== undefined ) {
	
				var normalMatrix = new THREE.Matrix3();
				normalMatrix.getInverse( matrix ).transpose();
	
				normalMatrix.multiplyVector3Array( normalArray );
	
				this.normalizeNormals();
	
				this.normalsNeedUpdate = true;
	
			}
	
		},
	
		computeBoundingBox: function () {
	
			if ( this.boundingBox === null ) {
	
				this.boundingBox = new THREE.Box3();
	
			}
	
			var positions = this.attributes[ "position" ].array;
	
			if ( positions ) {
	
				var bb = this.boundingBox;
				var x, y, z;
	
				if( positions.length >= 3 ) {
					bb.min.x = bb.max.x = positions[ 0 ];
					bb.min.y = bb.max.y = positions[ 1 ];
					bb.min.z = bb.max.z = positions[ 2 ];
				}
	
				for ( var i = 3, il = positions.length; i < il; i += 3 ) {
	
					x = positions[ i ];
					y = positions[ i + 1 ];
					z = positions[ i + 2 ];
	
					// bounding box
	
					if ( x < bb.min.x ) {
	
						bb.min.x = x;
	
					} else if ( x > bb.max.x ) {
	
						bb.max.x = x;
	
					}
	
					if ( y < bb.min.y ) {
	
						bb.min.y = y;
	
					} else if ( y > bb.max.y ) {
	
						bb.max.y = y;
	
					}
	
					if ( z < bb.min.z ) {
	
						bb.min.z = z;
	
					} else if ( z > bb.max.z ) {
	
						bb.max.z = z;
	
					}
	
				}
	
			}
	
			if ( positions === undefined || positions.length === 0 ) {
	
				this.boundingBox.min.set( 0, 0, 0 );
				this.boundingBox.max.set( 0, 0, 0 );
	
			}
	
		},
	
		computeBoundingSphere: function () {
	
			if ( this.boundingSphere === null ) {
	
				this.boundingSphere = new THREE.Sphere();
	
			}
	
			var positions = this.attributes[ "position" ].array;
	
			if ( positions ) {
	
				var radiusSq, maxRadiusSq = 0;
				var x, y, z;
	
				for ( var i = 0, il = positions.length; i < il; i += 3 ) {
	
					x = positions[ i ];
					y = positions[ i + 1 ];
					z = positions[ i + 2 ];
	
					radiusSq =  x * x + y * y + z * z;
					if ( radiusSq > maxRadiusSq ) maxRadiusSq = radiusSq;
	
				}
	
				this.boundingSphere.radius = Math.sqrt( maxRadiusSq );
	
			}
	
		},
	
		computeVertexNormals: function () {
	
			if ( this.attributes[ "position" ] ) {
	
				var i, il;
				var j, jl;
	
				var nVertexElements = this.attributes[ "position" ].array.length;
	
				if ( this.attributes[ "normal" ] === undefined ) {
	
					this.attributes[ "normal" ] = {
	
						itemSize: 3,
						array: new Float32Array( nVertexElements ),
						numItems: nVertexElements
	
					};
	
				} else {
	
					// reset existing normals to zero
	
					for ( i = 0, il = this.attributes[ "normal" ].array.length; i < il; i ++ ) {
	
						this.attributes[ "normal" ].array[ i ] = 0;
	
					}
	
				}
	
				var positions = this.attributes[ "position" ].array;
				var normals = this.attributes[ "normal" ].array;
	
				var vA, vB, vC, x, y, z,
	
				pA = new THREE.Vector3(),
				pB = new THREE.Vector3(),
				pC = new THREE.Vector3(),
	
				cb = new THREE.Vector3(),
				ab = new THREE.Vector3();
	
				// indexed elements
	
				if ( this.attributes[ "index" ] ) {
	
					var indices = this.attributes[ "index" ].array;
	
					var offsets = this.offsets;
	
					for ( j = 0, jl = offsets.length; j < jl; ++ j ) {
	
						var start = offsets[ j ].start;
						var count = offsets[ j ].count;
						var index = offsets[ j ].index;
	
						for ( i = start, il = start + count; i < il; i += 3 ) {
	
							vA = index + indices[ i ];
							vB = index + indices[ i + 1 ];
							vC = index + indices[ i + 2 ];
	
							x = positions[ vA * 3 ];
							y = positions[ vA * 3 + 1 ];
							z = positions[ vA * 3 + 2 ];
							pA.set( x, y, z );
	
							x = positions[ vB * 3 ];
							y = positions[ vB * 3 + 1 ];
							z = positions[ vB * 3 + 2 ];
							pB.set( x, y, z );
	
							x = positions[ vC * 3 ];
							y = positions[ vC * 3 + 1 ];
							z = positions[ vC * 3 + 2 ];
							pC.set( x, y, z );
	
							cb.subVectors( pC, pB );
							ab.subVectors( pA, pB );
							cb.cross( ab );
	
							normals[ vA * 3 ]     += cb.x;
							normals[ vA * 3 + 1 ] += cb.y;
							normals[ vA * 3 + 2 ] += cb.z;
	
							normals[ vB * 3 ]     += cb.x;
							normals[ vB * 3 + 1 ] += cb.y;
							normals[ vB * 3 + 2 ] += cb.z;
	
							normals[ vC * 3 ]     += cb.x;
							normals[ vC * 3 + 1 ] += cb.y;
							normals[ vC * 3 + 2 ] += cb.z;
	
						}
	
					}
	
				// non-indexed elements (unconnected triangle soup)
	
				} else {
	
					for ( i = 0, il = positions.length; i < il; i += 9 ) {
	
						x = positions[ i ];
						y = positions[ i + 1 ];
						z = positions[ i + 2 ];
						pA.set( x, y, z );
	
						x = positions[ i + 3 ];
						y = positions[ i + 4 ];
						z = positions[ i + 5 ];
						pB.set( x, y, z );
	
						x = positions[ i + 6 ];
						y = positions[ i + 7 ];
						z = positions[ i + 8 ];
						pC.set( x, y, z );
	
						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );
	
						normals[ i ] 	 = cb.x;
						normals[ i + 1 ] = cb.y;
						normals[ i + 2 ] = cb.z;
	
						normals[ i + 3 ] = cb.x;
						normals[ i + 4 ] = cb.y;
						normals[ i + 5 ] = cb.z;
	
						normals[ i + 6 ] = cb.x;
						normals[ i + 7 ] = cb.y;
						normals[ i + 8 ] = cb.z;
	
					}
	
				}
	
				this.normalizeNormals();
	
				this.normalsNeedUpdate = true;
	
			}
	
		},
	
		normalizeNormals: function () {
	
			var normals = this.attributes[ "normal" ].array;
	
			var x, y, z, n;
	
			for ( var i = 0, il = normals.length; i < il; i += 3 ) {
	
				x = normals[ i ];
				y = normals[ i + 1 ];
				z = normals[ i + 2 ];
	
				n = 1.0 / Math.sqrt( x * x + y * y + z * z );
	
				normals[ i ] 	 *= n;
				normals[ i + 1 ] *= n;
				normals[ i + 2 ] *= n;
	
			}
	
		},
	
		computeTangents: function () {
	
			// based on http://www.terathon.com/code/tangent.html
			// (per vertex tangents)
	
			if ( this.attributes[ "index" ] === undefined ||
				 this.attributes[ "position" ] === undefined ||
				 this.attributes[ "normal" ] === undefined ||
				 this.attributes[ "uv" ] === undefined ) {
	
				console.warn( "Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()" );
				return;
	
			}
	
			var indices = this.attributes[ "index" ].array;
			var positions = this.attributes[ "position" ].array;
			var normals = this.attributes[ "normal" ].array;
			var uvs = this.attributes[ "uv" ].array;
	
			var nVertices = positions.length / 3;
	
			if ( this.attributes[ "tangent" ] === undefined ) {
	
				var nTangentElements = 4 * nVertices;
	
				this.attributes[ "tangent" ] = {
	
					itemSize: 4,
					array: new Float32Array( nTangentElements ),
					numItems: nTangentElements
	
				};
	
			}
	
			var tangents = this.attributes[ "tangent" ].array;
	
			var tan1 = [], tan2 = [];
	
			for ( var k = 0; k < nVertices; k ++ ) {
	
				tan1[ k ] = new THREE.Vector3();
				tan2[ k ] = new THREE.Vector3();
	
			}
	
			var xA, yA, zA,
				xB, yB, zB,
				xC, yC, zC,
	
				uA, vA,
				uB, vB,
				uC, vC,
	
				x1, x2, y1, y2, z1, z2,
				s1, s2, t1, t2, r;
	
			var sdir = new THREE.Vector3(), tdir = new THREE.Vector3();
	
			function handleTriangle( a, b, c ) {
	
				xA = positions[ a * 3 ];
				yA = positions[ a * 3 + 1 ];
				zA = positions[ a * 3 + 2 ];
	
				xB = positions[ b * 3 ];
				yB = positions[ b * 3 + 1 ];
				zB = positions[ b * 3 + 2 ];
	
				xC = positions[ c * 3 ];
				yC = positions[ c * 3 + 1 ];
				zC = positions[ c * 3 + 2 ];
	
				uA = uvs[ a * 2 ];
				vA = uvs[ a * 2 + 1 ];
	
				uB = uvs[ b * 2 ];
				vB = uvs[ b * 2 + 1 ];
	
				uC = uvs[ c * 2 ];
				vC = uvs[ c * 2 + 1 ];
	
				x1 = xB - xA;
				x2 = xC - xA;
	
				y1 = yB - yA;
				y2 = yC - yA;
	
				z1 = zB - zA;
				z2 = zC - zA;
	
				s1 = uB - uA;
				s2 = uC - uA;
	
				t1 = vB - vA;
				t2 = vC - vA;
	
				r = 1.0 / ( s1 * t2 - s2 * t1 );
	
				sdir.set(
					( t2 * x1 - t1 * x2 ) * r,
					( t2 * y1 - t1 * y2 ) * r,
					( t2 * z1 - t1 * z2 ) * r
				);
	
				tdir.set(
					( s1 * x2 - s2 * x1 ) * r,
					( s1 * y2 - s2 * y1 ) * r,
					( s1 * z2 - s2 * z1 ) * r
				);
	
				tan1[ a ].add( sdir );
				tan1[ b ].add( sdir );
				tan1[ c ].add( sdir );
	
				tan2[ a ].add( tdir );
				tan2[ b ].add( tdir );
				tan2[ c ].add( tdir );
	
			}
	
			var i, il;
			var j, jl;
			var iA, iB, iC;
	
			var offsets = this.offsets;
	
			for ( j = 0, jl = offsets.length; j < jl; ++ j ) {
	
				var start = offsets[ j ].start;
				var count = offsets[ j ].count;
				var index = offsets[ j ].index;
	
				for ( i = start, il = start + count; i < il; i += 3 ) {
	
					iA = index + indices[ i ];
					iB = index + indices[ i + 1 ];
					iC = index + indices[ i + 2 ];
	
					handleTriangle( iA, iB, iC );
	
				}
	
			}
	
			var tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3();
			var n = new THREE.Vector3(), n2 = new THREE.Vector3();
			var w, t, test;
	
			function handleVertex( v ) {
	
				n.x = normals[ v * 3 ];
				n.y = normals[ v * 3 + 1 ];
				n.z = normals[ v * 3 + 2 ];
	
				n2.copy( n );
	
				t = tan1[ v ];
	
				// Gram-Schmidt orthogonalize
	
				tmp.copy( t );
				tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();
	
				// Calculate handedness
	
				tmp2.crossVectors( n2, t );
				test = tmp2.dot( tan2[ v ] );
				w = ( test < 0.0 ) ? -1.0 : 1.0;
	
				tangents[ v * 4 ] 	  = tmp.x;
				tangents[ v * 4 + 1 ] = tmp.y;
				tangents[ v * 4 + 2 ] = tmp.z;
				tangents[ v * 4 + 3 ] = w;
	
			}
	
			for ( j = 0, jl = offsets.length; j < jl; ++ j ) {
	
				var start = offsets[ j ].start;
				var count = offsets[ j ].count;
				var index = offsets[ j ].index;
	
				for ( i = start, il = start + count; i < il; i += 3 ) {
	
					iA = index + indices[ i ];
					iB = index + indices[ i + 1 ];
					iC = index + indices[ i + 2 ];
	
					handleVertex( iA );
					handleVertex( iB );
					handleVertex( iC );
	
				}
	
			}
	
			this.hasTangents = true;
			this.tangentsNeedUpdate = true;
	
		},
	
		dispose: function () {
	
			this.dispatchEvent( { type: 'dispose' } );
	
		}
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 */
	
	THREE.Camera = function () {
	
		THREE.Object3D.call( this );
	
		this.matrixWorldInverse = new THREE.Matrix4();
	
		this.projectionMatrix = new THREE.Matrix4();
		this.projectionMatrixInverse = new THREE.Matrix4();
	
	};
	
	THREE.Camera.prototype = Object.create( THREE.Object3D.prototype );
	
	THREE.Camera.prototype.lookAt = function ( vector ) {
	
		// TODO: Add hierarchy support.
	
		this.matrix.lookAt( this.position, vector, this.up );
	
		if ( this.rotationAutoUpdate === true ) {
	
			if ( this.useQuaternion === false )  {
	
				this.rotation.setEulerFromRotationMatrix( this.matrix, this.eulerOrder );
	
			} else {
	
				this.quaternion.copy( this.matrix.decompose()[ 1 ] );
	
			}
	
		}
	
	};
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {
	
		THREE.Camera.call( this );
	
		this.left = left;
		this.right = right;
		this.top = top;
		this.bottom = bottom;
	
		this.near = ( near !== undefined ) ? near : 0.1;
		this.far = ( far !== undefined ) ? far : 2000;
	
		this.updateProjectionMatrix();
	
	};
	
	THREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );
	
	THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {
	
		this.projectionMatrix.makeOrthographic( this.left, this.right, this.top, this.bottom, this.near, this.far );
	
	};
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author greggman / http://games.greggman.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */
	
	THREE.PerspectiveCamera = function ( fov, aspect, near, far ) {
	
		THREE.Camera.call( this );
	
		this.fov = fov !== undefined ? fov : 50;
		this.aspect = aspect !== undefined ? aspect : 1;
		this.near = near !== undefined ? near : 0.1;
		this.far = far !== undefined ? far : 2000;
	
		this.updateProjectionMatrix();
	
	};
	
	THREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );
	
	
	/**
	 * Uses Focal Length (in mm) to estimate and set FOV
	 * 35mm (fullframe) camera is used if frame size is not specified;
	 * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
	 */
	
	THREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {
	
		if ( frameHeight === undefined ) frameHeight = 24;
	
		this.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );
		this.updateProjectionMatrix();
	
	}
	
	
	/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   var w = 1920;
	 *   var h = 1080;
	 *   var fullWidth = w * 3;
	 *   var fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */
	
	THREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {
	
		this.fullWidth = fullWidth;
		this.fullHeight = fullHeight;
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;
	
		this.updateProjectionMatrix();
	
	};
	
	
	THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {
	
		if ( this.fullWidth ) {
	
			var aspect = this.fullWidth / this.fullHeight;
			var top = Math.tan( THREE.Math.degToRad( this.fov * 0.5 ) ) * this.near;
			var bottom = -top;
			var left = aspect * bottom;
			var right = aspect * top;
			var width = Math.abs( right - left );
			var height = Math.abs( top - bottom );
	
			this.projectionMatrix.makeFrustum(
				left + this.x * width / this.fullWidth,
				left + ( this.x + this.width ) * width / this.fullWidth,
				top - ( this.y + this.height ) * height / this.fullHeight,
				top - this.y * height / this.fullHeight,
				this.near,
				this.far
			);
	
		} else {
	
			this.projectionMatrix.makePerspective( this.fov, this.aspect, this.near, this.far );
	
		}
	
	};
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	 
	THREE.Light = function ( hex ) {
	
		THREE.Object3D.call( this );
	
		this.color = new THREE.Color( hex );
	
	};
	
	THREE.Light.prototype = Object.create( THREE.Object3D.prototype );
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.AmbientLight = function ( hex ) {
	
		THREE.Light.call( this, hex );
	
	};
	
	THREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );
	/**
	 * @author MPanknin / http://www.redplant.de/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.AreaLight = function ( hex, intensity ) {
	
		THREE.Light.call( this, hex );
	
		this.normal = new THREE.Vector3( 0, -1, 0 );
		this.right = new THREE.Vector3( 1, 0, 0 );
	
		this.intensity = ( intensity !== undefined ) ? intensity : 1;
	
		this.width = 1.0;
		this.height = 1.0;
	
		this.constantAttenuation = 1.5;
		this.linearAttenuation = 0.5;
		this.quadraticAttenuation = 0.1;
	
	};
	
	THREE.AreaLight.prototype = Object.create( THREE.Light.prototype );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.DirectionalLight = function ( hex, intensity ) {
	
		THREE.Light.call( this, hex );
	
		this.position = new THREE.Vector3( 0, 1, 0 );
		this.target = new THREE.Object3D();
	
		this.intensity = ( intensity !== undefined ) ? intensity : 1;
	
		this.castShadow = false;
		this.onlyShadow = false;
	
		//
	
		this.shadowCameraNear = 50;
		this.shadowCameraFar = 5000;
	
		this.shadowCameraLeft = -500;
		this.shadowCameraRight = 500;
		this.shadowCameraTop = 500;
		this.shadowCameraBottom = -500;
	
		this.shadowCameraVisible = false;
	
		this.shadowBias = 0;
		this.shadowDarkness = 0.5;
	
		this.shadowMapWidth = 512;
		this.shadowMapHeight = 512;
	
		//
	
		this.shadowCascade = false;
	
		this.shadowCascadeOffset = new THREE.Vector3( 0, 0, -1000 );
		this.shadowCascadeCount = 2;
	
		this.shadowCascadeBias = [ 0, 0, 0 ];
		this.shadowCascadeWidth = [ 512, 512, 512 ];
		this.shadowCascadeHeight = [ 512, 512, 512 ];
	
		this.shadowCascadeNearZ = [ -1.000, 0.990, 0.998 ];
		this.shadowCascadeFarZ  = [  0.990, 0.998, 1.000 ];
	
		this.shadowCascadeArray = [];
	
		//
	
		this.shadowMap = null;
		this.shadowMapSize = null;
		this.shadowCamera = null;
		this.shadowMatrix = null;
	
	};
	
	THREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.HemisphereLight = function ( skyColorHex, groundColorHex, intensity ) {
	
		THREE.Light.call( this, skyColorHex );
	
		this.groundColor = new THREE.Color( groundColorHex );
	
		this.position = new THREE.Vector3( 0, 100, 0 );
	
		this.intensity = ( intensity !== undefined ) ? intensity : 1;
	
	};
	
	THREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.PointLight = function ( hex, intensity, distance ) {
	
		THREE.Light.call( this, hex );
	
		this.position = new THREE.Vector3( 0, 0, 0 );
		this.intensity = ( intensity !== undefined ) ? intensity : 1;
		this.distance = ( distance !== undefined ) ? distance : 0;
	
	};
	
	THREE.PointLight.prototype = Object.create( THREE.Light.prototype );
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.SpotLight = function ( hex, intensity, distance, angle, exponent ) {
	
		THREE.Light.call( this, hex );
	
		this.position = new THREE.Vector3( 0, 1, 0 );
		this.target = new THREE.Object3D();
	
		this.intensity = ( intensity !== undefined ) ? intensity : 1;
		this.distance = ( distance !== undefined ) ? distance : 0;
		this.angle = ( angle !== undefined ) ? angle : Math.PI / 2;
		this.exponent = ( exponent !== undefined ) ? exponent : 10;
	
		this.castShadow = false;
		this.onlyShadow = false;
	
		//
	
		this.shadowCameraNear = 50;
		this.shadowCameraFar = 5000;
		this.shadowCameraFov = 50;
	
		this.shadowCameraVisible = false;
	
		this.shadowBias = 0;
		this.shadowDarkness = 0.5;
	
		this.shadowMapWidth = 512;
		this.shadowMapHeight = 512;
	
		//
	
		this.shadowMap = null;
		this.shadowMapSize = null;
		this.shadowCamera = null;
		this.shadowMatrix = null;
	
	};
	
	THREE.SpotLight.prototype = Object.create( THREE.Light.prototype );
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Loader = function ( showStatus ) {
	
		this.showStatus = showStatus;
		this.statusDomElement = showStatus ? THREE.Loader.prototype.addStatusElement() : null;
	
		this.onLoadStart = function () {};
		this.onLoadProgress = function () {};
		this.onLoadComplete = function () {};
	
	};
	
	THREE.Loader.prototype = {
	
		constructor: THREE.Loader,
	
		crossOrigin: 'anonymous',
	
		addStatusElement: function () {
	
			var e = document.createElement( "div" );
	
			e.style.position = "absolute";
			e.style.right = "0px";
			e.style.top = "0px";
			e.style.fontSize = "0.8em";
			e.style.textAlign = "left";
			e.style.background = "rgba(0,0,0,0.25)";
			e.style.color = "#fff";
			e.style.width = "120px";
			e.style.padding = "0.5em 0.5em 0.5em 0.5em";
			e.style.zIndex = 1000;
	
			e.innerHTML = "Loading ...";
	
			return e;
	
		},
	
		updateProgress: function ( progress ) {
	
			var message = "Loaded ";
	
			if ( progress.total ) {
	
				message += ( 100 * progress.loaded / progress.total ).toFixed(0) + "%";
	
	
			} else {
	
				message += ( progress.loaded / 1000 ).toFixed(2) + " KB";
	
			}
	
			this.statusDomElement.innerHTML = message;
	
		},
	
		extractUrlBase: function ( url ) {
	
			var parts = url.split( '/' );
			parts.pop();
			return ( parts.length < 1 ? '.' : parts.join( '/' ) ) + '/';
	
		},
	
		initMaterials: function ( materials, texturePath ) {
	
			var array = [];
	
			for ( var i = 0; i < materials.length; ++ i ) {
	
				array[ i ] = THREE.Loader.prototype.createMaterial( materials[ i ], texturePath );
	
			}
	
			return array;
	
		},
	
		needsTangents: function ( materials ) {
	
			for( var i = 0, il = materials.length; i < il; i ++ ) {
	
				var m = materials[ i ];
	
				if ( m instanceof THREE.ShaderMaterial ) return true;
	
			}
	
			return false;
	
		},
	
		createMaterial: function ( m, texturePath ) {
	
			var _this = this;
	
			function is_pow2( n ) {
	
				var l = Math.log( n ) / Math.LN2;
				return Math.floor( l ) == l;
	
			}
	
			function nearest_pow2( n ) {
	
				var l = Math.log( n ) / Math.LN2;
				return Math.pow( 2, Math.round(  l ) );
	
			}
	
			function load_image( where, url ) {
	
				var image = new Image();
	
				image.onload = function () {
	
					if ( !is_pow2( this.width ) || !is_pow2( this.height ) ) {
	
						var width = nearest_pow2( this.width );
						var height = nearest_pow2( this.height );
	
						where.image.width = width;
						where.image.height = height;
						where.image.getContext( '2d' ).drawImage( this, 0, 0, width, height );
	
					} else {
	
						where.image = this;
	
					}
	
					where.needsUpdate = true;
	
				};
	
				image.crossOrigin = _this.crossOrigin;
				image.src = url;
	
			}
	
			function create_texture( where, name, sourceFile, repeat, offset, wrap, anisotropy ) {
	
				var isCompressed = /\.dds$/i.test( sourceFile );
				var fullPath = texturePath + "/" + sourceFile;
	
				if ( isCompressed ) {
	
					var texture = THREE.ImageUtils.loadCompressedTexture( fullPath );
	
					where[ name ] = texture;
	
				} else {
	
					var texture = document.createElement( 'canvas' );
	
					where[ name ] = new THREE.Texture( texture );
	
				}
	
				where[ name ].sourceFile = sourceFile;
	
				if( repeat ) {
	
					where[ name ].repeat.set( repeat[ 0 ], repeat[ 1 ] );
	
					if ( repeat[ 0 ] !== 1 ) where[ name ].wrapS = THREE.RepeatWrapping;
					if ( repeat[ 1 ] !== 1 ) where[ name ].wrapT = THREE.RepeatWrapping;
	
				}
	
				if ( offset ) {
	
					where[ name ].offset.set( offset[ 0 ], offset[ 1 ] );
	
				}
	
				if ( wrap ) {
	
					var wrapMap = {
						"repeat": THREE.RepeatWrapping,
						"mirror": THREE.MirroredRepeatWrapping
					}
	
					if ( wrapMap[ wrap[ 0 ] ] !== undefined ) where[ name ].wrapS = wrapMap[ wrap[ 0 ] ];
					if ( wrapMap[ wrap[ 1 ] ] !== undefined ) where[ name ].wrapT = wrapMap[ wrap[ 1 ] ];
	
				}
	
				if ( anisotropy ) {
	
					where[ name ].anisotropy = anisotropy;
	
				}
	
				if ( ! isCompressed ) {
	
					load_image( where[ name ], fullPath );
	
				}
	
			}
	
			function rgb2hex( rgb ) {
	
				return ( rgb[ 0 ] * 255 << 16 ) + ( rgb[ 1 ] * 255 << 8 ) + rgb[ 2 ] * 255;
	
			}
	
			// defaults
	
			var mtype = "MeshLambertMaterial";
			var mpars = { color: 0xeeeeee, opacity: 1.0, map: null, lightMap: null, normalMap: null, bumpMap: null, wireframe: false };
	
			// parameters from model file
	
			if ( m.shading ) {
	
				var shading = m.shading.toLowerCase();
	
				if ( shading === "phong" ) mtype = "MeshPhongMaterial";
				else if ( shading === "basic" ) mtype = "MeshBasicMaterial";
	
			}
	
			if ( m.blending !== undefined && THREE[ m.blending ] !== undefined ) {
	
				mpars.blending = THREE[ m.blending ];
	
			}
	
			if ( m.transparent !== undefined || m.opacity < 1.0 ) {
	
				mpars.transparent = m.transparent;
	
			}
	
			if ( m.depthTest !== undefined ) {
	
				mpars.depthTest = m.depthTest;
	
			}
	
			if ( m.depthWrite !== undefined ) {
	
				mpars.depthWrite = m.depthWrite;
	
			}
	
			if ( m.visible !== undefined ) {
	
				mpars.visible = m.visible;
	
			}
	
			if ( m.flipSided !== undefined ) {
	
				mpars.side = THREE.BackSide;
	
			}
	
			if ( m.doubleSided !== undefined ) {
	
				mpars.side = THREE.DoubleSide;
	
			}
	
			if ( m.wireframe !== undefined ) {
	
				mpars.wireframe = m.wireframe;
	
			}
	
			if ( m.vertexColors !== undefined ) {
	
				if ( m.vertexColors === "face" ) {
	
					mpars.vertexColors = THREE.FaceColors;
	
				} else if ( m.vertexColors ) {
	
					mpars.vertexColors = THREE.VertexColors;
	
				}
	
			}
	
			// colors
	
			if ( m.colorDiffuse ) {
	
				mpars.color = rgb2hex( m.colorDiffuse );
	
			} else if ( m.DbgColor ) {
	
				mpars.color = m.DbgColor;
	
			}
	
			if ( m.colorSpecular ) {
	
				mpars.specular = rgb2hex( m.colorSpecular );
	
			}
	
			if ( m.colorAmbient ) {
	
				mpars.ambient = rgb2hex( m.colorAmbient );
	
			}
	
			// modifiers
	
			if ( m.transparency ) {
	
				mpars.opacity = m.transparency;
	
			}
	
			if ( m.specularCoef ) {
	
				mpars.shininess = m.specularCoef;
	
			}
	
			// textures
	
			if ( m.mapDiffuse && texturePath ) {
	
				create_texture( mpars, "map", m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
	
			}
	
			if ( m.mapLight && texturePath ) {
	
				create_texture( mpars, "lightMap", m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
	
			}
	
			if ( m.mapBump && texturePath ) {
	
				create_texture( mpars, "bumpMap", m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
	
			}
	
			if ( m.mapNormal && texturePath ) {
	
				create_texture( mpars, "normalMap", m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
	
			}
	
			if ( m.mapSpecular && texturePath ) {
	
				create_texture( mpars, "specularMap", m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
	
			}
	
			//
	
			if ( m.mapBumpScale ) {
	
				mpars.bumpScale = m.mapBumpScale;
	
			}
	
			// special case for normal mapped material
	
			if ( m.mapNormal ) {
	
				var shader = THREE.ShaderLib[ "normalmap" ];
				var uniforms = THREE.UniformsUtils.clone( shader.uniforms );
	
				uniforms[ "tNormal" ].value = mpars.normalMap;
	
				if ( m.mapNormalFactor ) {
	
					uniforms[ "uNormalScale" ].value.set( m.mapNormalFactor, m.mapNormalFactor );
	
				}
	
				if ( mpars.map ) {
	
					uniforms[ "tDiffuse" ].value = mpars.map;
					uniforms[ "enableDiffuse" ].value = true;
	
				}
	
				if ( mpars.specularMap ) {
	
					uniforms[ "tSpecular" ].value = mpars.specularMap;
					uniforms[ "enableSpecular" ].value = true;
	
				}
	
				if ( mpars.lightMap ) {
	
					uniforms[ "tAO" ].value = mpars.lightMap;
					uniforms[ "enableAO" ].value = true;
	
				}
	
				// for the moment don't handle displacement texture
	
				uniforms[ "uDiffuseColor" ].value.setHex( mpars.color );
				uniforms[ "uSpecularColor" ].value.setHex( mpars.specular );
				uniforms[ "uAmbientColor" ].value.setHex( mpars.ambient );
	
				uniforms[ "uShininess" ].value = mpars.shininess;
	
				if ( mpars.opacity !== undefined ) {
	
					uniforms[ "uOpacity" ].value = mpars.opacity;
	
				}
	
				var parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms, lights: true, fog: true };
				var material = new THREE.ShaderMaterial( parameters );
	
				if ( mpars.transparent ) {
	
					material.transparent = true;
	
				}
	
			} else {
	
				var material = new THREE[ mtype ]( mpars );
	
			}
	
			if ( m.DbgName !== undefined ) material.name = m.DbgName;
	
			return material;
	
		}
	
	};
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.ImageLoader = function () {
	
		THREE.EventDispatcher.call( this );
	
		this.crossOrigin = null;
	
	};
	
	THREE.ImageLoader.prototype = {
	
		constructor: THREE.ImageLoader,
	
		load: function ( url, image ) {
	
			var scope = this;
	
			if ( image === undefined ) image = new Image();
	
			image.addEventListener( 'load', function () {
	
				scope.dispatchEvent( { type: 'load', content: image } );
	
			}, false );
	
			image.addEventListener( 'error', function () {
	
				scope.dispatchEvent( { type: 'error', message: 'Couldn\'t load URL [' + url + ']' } );
	
			}, false );
	
			if ( scope.crossOrigin ) image.crossOrigin = scope.crossOrigin;
	
			image.src = url;
	
		}
	
	}
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.JSONLoader = function ( showStatus ) {
	
		THREE.Loader.call( this, showStatus );
	
		this.withCredentials = false;
	
	};
	
	THREE.JSONLoader.prototype = Object.create( THREE.Loader.prototype );
	
	THREE.JSONLoader.prototype.load = function ( url, callback, texturePath ) {
	
		var scope = this;
	
		// todo: unify load API to for easier SceneLoader use
	
		texturePath = texturePath && ( typeof texturePath === "string" ) ? texturePath : this.extractUrlBase( url );
	
		this.onLoadStart();
		this.loadAjaxJSON( this, url, callback, texturePath );
	
	};
	
	THREE.JSONLoader.prototype.loadAjaxJSON = function ( context, url, callback, texturePath, callbackProgress ) {
	
		var xhr = new XMLHttpRequest();
	
		var length = 0;
	
		xhr.onreadystatechange = function () {
	
			if ( xhr.readyState === xhr.DONE ) {
	
				if ( xhr.status === 200 || xhr.status === 0 ) {
	
					if ( xhr.responseText ) {
	
						var json = JSON.parse( xhr.responseText );
						context.createModel( json, callback, texturePath );
	
					} else {
	
						console.warn( "THREE.JSONLoader: [" + url + "] seems to be unreachable or file there is empty" );
	
					}
	
					// in context of more complex asset initialization
					// do not block on single failed file
					// maybe should go even one more level up
	
					context.onLoadComplete();
	
				} else {
	
					console.error( "THREE.JSONLoader: Couldn't load [" + url + "] [" + xhr.status + "]" );
	
				}
	
			} else if ( xhr.readyState === xhr.LOADING ) {
	
				if ( callbackProgress ) {
	
					if ( length === 0 ) {
	
						length = xhr.getResponseHeader( "Content-Length" );
	
					}
	
					callbackProgress( { total: length, loaded: xhr.responseText.length } );
	
				}
	
			} else if ( xhr.readyState === xhr.HEADERS_RECEIVED ) {
	
				length = xhr.getResponseHeader( "Content-Length" );
	
			}
	
		};
	
		xhr.open( "GET", url, true );
		xhr.withCredentials = this.withCredentials;
		xhr.send( null );
	
	};
	
	THREE.JSONLoader.prototype.createModel = function ( json, callback, texturePath ) {
	
		var scope = this,
		geometry = new THREE.Geometry(),
		scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;
	
		parseModel( scale );
	
		parseSkin();
		parseMorphing( scale );
	
		geometry.computeCentroids();
		geometry.computeFaceNormals();
	
		function parseModel( scale ) {
	
			function isBitSet( value, position ) {
	
				return value & ( 1 << position );
	
			}
	
			var i, j, fi,
	
			offset, zLength, nVertices,
	
			colorIndex, normalIndex, uvIndex, materialIndex,
	
			type,
			isQuad,
			hasMaterial,
			hasFaceUv, hasFaceVertexUv,
			hasFaceNormal, hasFaceVertexNormal,
			hasFaceColor, hasFaceVertexColor,
	
			vertex, face, color, normal,
	
			uvLayer, uvs, u, v,
	
			faces = json.faces,
			vertices = json.vertices,
			normals = json.normals,
			colors = json.colors,
	
			nUvLayers = 0;
	
			// disregard empty arrays
	
			for ( i = 0; i < json.uvs.length; i++ ) {
	
				if ( json.uvs[ i ].length ) nUvLayers ++;
	
			}
	
			for ( i = 0; i < nUvLayers; i++ ) {
	
				geometry.faceUvs[ i ] = [];
				geometry.faceVertexUvs[ i ] = [];
	
			}
	
			offset = 0;
			zLength = vertices.length;
	
			while ( offset < zLength ) {
	
				vertex = new THREE.Vector3();
	
				vertex.x = vertices[ offset ++ ] * scale;
				vertex.y = vertices[ offset ++ ] * scale;
				vertex.z = vertices[ offset ++ ] * scale;
	
				geometry.vertices.push( vertex );
	
			}
	
			offset = 0;
			zLength = faces.length;
	
			while ( offset < zLength ) {
	
				type = faces[ offset ++ ];
	
	
				isQuad          	= isBitSet( type, 0 );
				hasMaterial         = isBitSet( type, 1 );
				hasFaceUv           = isBitSet( type, 2 );
				hasFaceVertexUv     = isBitSet( type, 3 );
				hasFaceNormal       = isBitSet( type, 4 );
				hasFaceVertexNormal = isBitSet( type, 5 );
				hasFaceColor	    = isBitSet( type, 6 );
				hasFaceVertexColor  = isBitSet( type, 7 );
	
				//console.log("type", type, "bits", isQuad, hasMaterial, hasFaceUv, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);
	
				if ( isQuad ) {
	
					face = new THREE.Face4();
	
					face.a = faces[ offset ++ ];
					face.b = faces[ offset ++ ];
					face.c = faces[ offset ++ ];
					face.d = faces[ offset ++ ];
	
					nVertices = 4;
	
				} else {
	
					face = new THREE.Face3();
	
					face.a = faces[ offset ++ ];
					face.b = faces[ offset ++ ];
					face.c = faces[ offset ++ ];
	
					nVertices = 3;
	
				}
	
				if ( hasMaterial ) {
	
					materialIndex = faces[ offset ++ ];
					face.materialIndex = materialIndex;
	
				}
	
				// to get face <=> uv index correspondence
	
				fi = geometry.faces.length;
	
				if ( hasFaceUv ) {
	
					for ( i = 0; i < nUvLayers; i++ ) {
	
						uvLayer = json.uvs[ i ];
	
						uvIndex = faces[ offset ++ ];
	
						u = uvLayer[ uvIndex * 2 ];
						v = uvLayer[ uvIndex * 2 + 1 ];
	
						geometry.faceUvs[ i ][ fi ] = new THREE.Vector2( u, v );
	
					}
	
				}
	
				if ( hasFaceVertexUv ) {
	
					for ( i = 0; i < nUvLayers; i++ ) {
	
						uvLayer = json.uvs[ i ];
	
						uvs = [];
	
						for ( j = 0; j < nVertices; j ++ ) {
	
							uvIndex = faces[ offset ++ ];
	
							u = uvLayer[ uvIndex * 2 ];
							v = uvLayer[ uvIndex * 2 + 1 ];
	
							uvs[ j ] = new THREE.Vector2( u, v );
	
						}
	
						geometry.faceVertexUvs[ i ][ fi ] = uvs;
	
					}
	
				}
	
				if ( hasFaceNormal ) {
	
					normalIndex = faces[ offset ++ ] * 3;
	
					normal = new THREE.Vector3();
	
					normal.x = normals[ normalIndex ++ ];
					normal.y = normals[ normalIndex ++ ];
					normal.z = normals[ normalIndex ];
	
					face.normal = normal;
	
				}
	
				if ( hasFaceVertexNormal ) {
	
					for ( i = 0; i < nVertices; i++ ) {
	
						normalIndex = faces[ offset ++ ] * 3;
	
						normal = new THREE.Vector3();
	
						normal.x = normals[ normalIndex ++ ];
						normal.y = normals[ normalIndex ++ ];
						normal.z = normals[ normalIndex ];
	
						face.vertexNormals.push( normal );
	
					}
	
				}
	
	
				if ( hasFaceColor ) {
	
					colorIndex = faces[ offset ++ ];
	
					color = new THREE.Color( colors[ colorIndex ] );
					face.color = color;
	
				}
	
	
				if ( hasFaceVertexColor ) {
	
					for ( i = 0; i < nVertices; i++ ) {
	
						colorIndex = faces[ offset ++ ];
	
						color = new THREE.Color( colors[ colorIndex ] );
						face.vertexColors.push( color );
	
					}
	
				}
	
				geometry.faces.push( face );
	
			}
	
		};
	
		function parseSkin() {
	
			var i, l, x, y, z, w, a, b, c, d;
	
			if ( json.skinWeights ) {
	
				for ( i = 0, l = json.skinWeights.length; i < l; i += 2 ) {
	
					x = json.skinWeights[ i     ];
					y = json.skinWeights[ i + 1 ];
					z = 0;
					w = 0;
	
					geometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );
	
				}
	
			}
	
			if ( json.skinIndices ) {
	
				for ( i = 0, l = json.skinIndices.length; i < l; i += 2 ) {
	
					a = json.skinIndices[ i     ];
					b = json.skinIndices[ i + 1 ];
					c = 0;
					d = 0;
	
					geometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );
	
				}
	
			}
	
			geometry.bones = json.bones;
			geometry.animation = json.animation;
	
		};
	
		function parseMorphing( scale ) {
	
			if ( json.morphTargets !== undefined ) {
	
				var i, l, v, vl, dstVertices, srcVertices;
	
				for ( i = 0, l = json.morphTargets.length; i < l; i ++ ) {
	
					geometry.morphTargets[ i ] = {};
					geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
					geometry.morphTargets[ i ].vertices = [];
	
					dstVertices = geometry.morphTargets[ i ].vertices;
					srcVertices = json.morphTargets [ i ].vertices;
	
					for( v = 0, vl = srcVertices.length; v < vl; v += 3 ) {
	
						var vertex = new THREE.Vector3();
						vertex.x = srcVertices[ v ] * scale;
						vertex.y = srcVertices[ v + 1 ] * scale;
						vertex.z = srcVertices[ v + 2 ] * scale;
	
						dstVertices.push( vertex );
	
					}
	
				}
	
			}
	
			if ( json.morphColors !== undefined ) {
	
				var i, l, c, cl, dstColors, srcColors, color;
	
				for ( i = 0, l = json.morphColors.length; i < l; i++ ) {
	
					geometry.morphColors[ i ] = {};
					geometry.morphColors[ i ].name = json.morphColors[ i ].name;
					geometry.morphColors[ i ].colors = [];
	
					dstColors = geometry.morphColors[ i ].colors;
					srcColors = json.morphColors [ i ].colors;
	
					for ( c = 0, cl = srcColors.length; c < cl; c += 3 ) {
	
						color = new THREE.Color( 0xffaa00 );
						color.setRGB( srcColors[ c ], srcColors[ c + 1 ], srcColors[ c + 2 ] );
						dstColors.push( color );
	
					}
	
				}
	
			}
	
		};
	
		var materials = this.initMaterials( json.materials, texturePath );
	
		if ( this.needsTangents( materials ) ) geometry.computeTangents();
	
		callback( geometry, materials );
	
	};
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.LoadingMonitor = function () {
	
		THREE.EventDispatcher.call( this );
	
		var scope = this;
	
		var loaded = 0;
		var total = 0;
	
		var onLoad = function ( event ) {
	
			loaded ++;
	
			scope.dispatchEvent( { type: 'progress', loaded: loaded, total: total } );
	
			if ( loaded === total ) {
	
				scope.dispatchEvent( { type: 'load' } );
	
			}
	
		};
	
		this.add = function ( loader ) {
	
			total ++;
	
			loader.addEventListener( 'load', onLoad, false );
	
		};
	
	};
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.SceneLoader = function () {
	
		this.onLoadStart = function () {};
		this.onLoadProgress = function() {};
		this.onLoadComplete = function () {};
	
		this.callbackSync = function () {};
		this.callbackProgress = function () {};
	
		this.geometryHandlerMap = {};
		this.hierarchyHandlerMap = {};
	
		this.addGeometryHandler( "ascii", THREE.JSONLoader );
	
	};
	
	THREE.SceneLoader.prototype.constructor = THREE.SceneLoader;
	
	THREE.SceneLoader.prototype.load = function ( url, callbackFinished ) {
	
		var scope = this;
	
		var xhr = new XMLHttpRequest();
	
		xhr.onreadystatechange = function () {
	
			if ( xhr.readyState === 4 ) {
	
				if ( xhr.status === 200 || xhr.status === 0 ) {
	
					var json = JSON.parse( xhr.responseText );
					scope.parse( json, callbackFinished, url );
	
				} else {
	
					console.error( "THREE.SceneLoader: Couldn't load [" + url + "] [" + xhr.status + "]" );
	
				}
	
			}
	
		};
	
		xhr.open( "GET", url, true );
		xhr.send( null );
	
	};
	
	THREE.SceneLoader.prototype.addGeometryHandler = function ( typeID, loaderClass ) {
	
		this.geometryHandlerMap[ typeID ] = { "loaderClass": loaderClass };
	
	};
	
	THREE.SceneLoader.prototype.addHierarchyHandler = function ( typeID, loaderClass ) {
	
		this.hierarchyHandlerMap[ typeID ] = { "loaderClass": loaderClass };
	
	};
	
	THREE.SceneLoader.prototype.parse = function ( json, callbackFinished, url ) {
	
		var scope = this;
	
		var urlBase = THREE.Loader.prototype.extractUrlBase( url );
	
		var geometry, material, camera, fog,
			texture, images, color,
			light, hex, intensity,
			counter_models, counter_textures,
			total_models, total_textures,
			result;
	
		var target_array = [];
	
		var data = json;
	
		// async geometry loaders
	
		for ( var typeID in this.geometryHandlerMap ) {
	
			var loaderClass = this.geometryHandlerMap[ typeID ][ "loaderClass" ];
			this.geometryHandlerMap[ typeID ][ "loaderObject" ] = new loaderClass();
	
		}
	
		// async hierachy loaders
	
		for ( var typeID in this.hierarchyHandlerMap ) {
	
			var loaderClass = this.hierarchyHandlerMap[ typeID ][ "loaderClass" ];
			this.hierarchyHandlerMap[ typeID ][ "loaderObject" ] = new loaderClass();
	
		}
	
		counter_models = 0;
		counter_textures = 0;
	
		result = {
	
			scene: new THREE.Scene(),
			geometries: {},
			face_materials: {},
			materials: {},
			textures: {},
			objects: {},
			cameras: {},
			lights: {},
			fogs: {},
			empties: {},
			groups: {}
	
		};
	
		if ( data.transform ) {
	
			var position = data.transform.position,
				rotation = data.transform.rotation,
				scale = data.transform.scale;
	
			if ( position )
				result.scene.position.set( position[ 0 ], position[ 1 ], position [ 2 ] );
	
			if ( rotation )
				result.scene.rotation.set( rotation[ 0 ], rotation[ 1 ], rotation [ 2 ] );
	
			if ( scale )
				result.scene.scale.set( scale[ 0 ], scale[ 1 ], scale [ 2 ] );
	
			if ( position || rotation || scale ) {
	
				result.scene.updateMatrix();
				result.scene.updateMatrixWorld();
	
			}
	
		}
	
		function get_url( source_url, url_type ) {
	
			if ( url_type == "relativeToHTML" ) {
	
				return source_url;
	
			} else {
	
				return urlBase + "/" + source_url;
	
			}
	
		};
	
		// toplevel loader function, delegates to handle_children
	
		function handle_objects() {
	
			handle_children( result.scene, data.objects );
	
		}
	
		// handle all the children from the loaded json and attach them to given parent
	
		function handle_children( parent, children ) {
	
			var mat, dst, pos, rot, scl, quat;
	
			for ( var objID in children ) {
	
				// check by id if child has already been handled,
				// if not, create new object
	
				if ( result.objects[ objID ] === undefined ) {
	
					var objJSON = children[ objID ];
	
					var object = null;
	
					// meshes
	
					if ( objJSON.type && ( objJSON.type in scope.hierarchyHandlerMap ) ) {
	
						if ( objJSON.loading === undefined ) {
	
							var reservedTypes = { "type": 1, "url": 1, "material": 1,
												  "position": 1, "rotation": 1, "scale" : 1,
												  "visible": 1, "children": 1, "properties": 1,
												  "skin": 1, "morph": 1, "mirroredLoop": 1, "duration": 1 };
	
							var loaderParameters = {};
	
							for ( var parType in objJSON ) {
	
								if ( ! ( parType in reservedTypes ) ) {
	
									loaderParameters[ parType ] = objJSON[ parType ];
	
								}
	
							}
	
							material = result.materials[ objJSON.material ];
	
							objJSON.loading = true;
	
							var loader = scope.hierarchyHandlerMap[ objJSON.type ][ "loaderObject" ];
	
							// ColladaLoader
	
							if ( loader.options ) {
	
								loader.load( get_url( objJSON.url, data.urlBaseType ), create_callback_hierachy( objID, parent, material, objJSON ) );
	
							// UTF8Loader
							// OBJLoader
	
							} else {
	
								loader.load( get_url( objJSON.url, data.urlBaseType ), create_callback_hierachy( objID, parent, material, objJSON ), loaderParameters );
	
							}
	
						}
	
					} else if ( objJSON.geometry !== undefined ) {
	
						geometry = result.geometries[ objJSON.geometry ];
	
						// geometry already loaded
	
						if ( geometry ) {
	
							var needsTangents = false;
	
							material = result.materials[ objJSON.material ];
							needsTangents = material instanceof THREE.ShaderMaterial;
	
							pos = objJSON.position;
							rot = objJSON.rotation;
							scl = objJSON.scale;
							mat = objJSON.matrix;
							quat = objJSON.quaternion;
	
							// use materials from the model file
							// if there is no material specified in the object
	
							if ( ! objJSON.material ) {
	
								material = new THREE.MeshFaceMaterial( result.face_materials[ objJSON.geometry ] );
	
							}
	
							// use materials from the model file
							// if there is just empty face material
							// (must create new material as each model has its own face material)
	
							if ( ( material instanceof THREE.MeshFaceMaterial ) && material.materials.length === 0 ) {
	
								material = new THREE.MeshFaceMaterial( result.face_materials[ objJSON.geometry ] );
	
							}
	
							if ( material instanceof THREE.MeshFaceMaterial ) {
	
								for ( var i = 0; i < material.materials.length; i ++ ) {
	
									needsTangents = needsTangents || ( material.materials[ i ] instanceof THREE.ShaderMaterial );
	
								}
	
							}
	
							if ( needsTangents ) {
	
								geometry.computeTangents();
	
							}
	
							if ( objJSON.skin ) {
	
								object = new THREE.SkinnedMesh( geometry, material );
	
							} else if ( objJSON.morph ) {
	
								object = new THREE.MorphAnimMesh( geometry, material );
	
								if ( objJSON.duration !== undefined ) {
	
									object.duration = objJSON.duration;
	
								}
	
								if ( objJSON.time !== undefined ) {
	
									object.time = objJSON.time;
	
								}
	
								if ( objJSON.mirroredLoop !== undefined ) {
	
									object.mirroredLoop = objJSON.mirroredLoop;
	
								}
	
								if ( material.morphNormals ) {
	
									geometry.computeMorphNormals();
	
								}
	
							} else {
	
								object = new THREE.Mesh( geometry, material );
	
							}
	
							object.name = objID;
	
							if ( mat ) {
	
								object.matrixAutoUpdate = false;
								object.matrix.set(
									mat[0],  mat[1],  mat[2],  mat[3],
									mat[4],  mat[5],  mat[6],  mat[7],
									mat[8],  mat[9],  mat[10], mat[11],
									mat[12], mat[13], mat[14], mat[15]
								);
	
							} else {
	
								object.position.set( pos[0], pos[1], pos[2] );
	
								if ( quat ) {
	
									object.quaternion.set( quat[0], quat[1], quat[2], quat[3] );
									object.useQuaternion = true;
	
								} else {
	
									object.rotation.set( rot[0], rot[1], rot[2] );
	
								}
	
								object.scale.set( scl[0], scl[1], scl[2] );
	
							}
	
							object.visible = objJSON.visible;
							object.castShadow = objJSON.castShadow;
							object.receiveShadow = objJSON.receiveShadow;
	
							parent.add( object );
	
							result.objects[ objID ] = object;
	
						}
	
					// lights
	
					} else if ( objJSON.type === "DirectionalLight" || objJSON.type === "PointLight" || objJSON.type === "AmbientLight" ) {
	
						hex = ( objJSON.color !== undefined ) ? objJSON.color : 0xffffff;
						intensity = ( objJSON.intensity !== undefined ) ? objJSON.intensity : 1;
	
						if ( objJSON.type === "DirectionalLight" ) {
	
							pos = objJSON.direction;
	
							light = new THREE.DirectionalLight( hex, intensity );
							light.position.set( pos[0], pos[1], pos[2] );
	
							if ( objJSON.target ) {
	
								target_array.push( { "object": light, "targetName" : objJSON.target } );
	
								// kill existing default target
								// otherwise it gets added to scene when parent gets added
	
								light.target = null;
	
							}
	
						} else if ( objJSON.type === "PointLight" ) {
	
							pos = objJSON.position;
							dst = objJSON.distance;
	
							light = new THREE.PointLight( hex, intensity, dst );
							light.position.set( pos[0], pos[1], pos[2] );
	
						} else if ( objJSON.type === "AmbientLight" ) {
	
							light = new THREE.AmbientLight( hex );
	
						}
	
						parent.add( light );
	
						light.name = objID;
						result.lights[ objID ] = light;
						result.objects[ objID ] = light;
	
					// cameras
	
					} else if ( objJSON.type === "PerspectiveCamera" || objJSON.type === "OrthographicCamera" ) {
	
						if ( objJSON.type === "PerspectiveCamera" ) {
	
							camera = new THREE.PerspectiveCamera( objJSON.fov, objJSON.aspect, objJSON.near, objJSON.far );
	
						} else if ( objJSON.type === "OrthographicCamera" ) {
	
							camera = new THREE.OrthographicCamera( objJSON.left, objJSON.right, objJSON.top, objJSON.bottom, objJSON.near, objJSON.far );
	
						}
	
						pos = objJSON.position;
						camera.position.set( pos[0], pos[1], pos[2] );
						parent.add( camera );
	
						camera.name = objID;
						result.cameras[ objID ] = camera;
						result.objects[ objID ] = camera;
	
					// pure Object3D
	
					} else {
	
						pos = objJSON.position;
						rot = objJSON.rotation;
						scl = objJSON.scale;
						quat = objJSON.quaternion;
	
						object = new THREE.Object3D();
						object.name = objID;
						object.position.set( pos[0], pos[1], pos[2] );
	
						if ( quat ) {
	
							object.quaternion.set( quat[0], quat[1], quat[2], quat[3] );
							object.useQuaternion = true;
	
						} else {
	
							object.rotation.set( rot[0], rot[1], rot[2] );
	
						}
	
						object.scale.set( scl[0], scl[1], scl[2] );
						object.visible = ( objJSON.visible !== undefined ) ? objJSON.visible : false;
	
						parent.add( object );
	
						result.objects[ objID ] = object;
						result.empties[ objID ] = object;
	
					}
	
					if ( object ) {
	
						if ( objJSON.properties !== undefined )  {
	
							for ( var key in objJSON.properties ) {
	
								var value = objJSON.properties[ key ];
								object.properties[ key ] = value;
	
							}
	
						}
	
						if ( objJSON.groups !== undefined ) {
	
							for ( var i = 0; i < objJSON.groups.length; i ++ ) {
	
								var groupID = objJSON.groups[ i ];
	
								if ( result.groups[ groupID ] === undefined ) {
	
									result.groups[ groupID ] = [];
	
								}
	
								result.groups[ groupID ].push( objID );
	
							}
	
						}
	
						if ( objJSON.children !== undefined ) {
	
							handle_children( object, objJSON.children );
	
						}
	
					}
	
				}
	
			}
	
		};
	
		function handle_mesh( geo, mat, id ) {
	
			result.geometries[ id ] = geo;
			result.face_materials[ id ] = mat;
			handle_objects();
	
		};
	
		function handle_hierarchy( node, id, parent, material, obj ) {
	
			var p = obj.position;
			var r = obj.rotation;
			var q = obj.quaternion;
			var s = obj.scale;
	
			node.position.set( p[0], p[1], p[2] );
	
			if ( q ) {
	
				node.quaternion.set( q[0], q[1], q[2], q[3] );
				node.useQuaternion = true;
	
			} else {
	
				node.rotation.set( r[0], r[1], r[2] );
	
			}
	
			node.scale.set( s[0], s[1], s[2] );
	
			// override children materials
			// if object material was specified in JSON explicitly
	
			if ( material ) {
	
				node.traverse( function ( child )  {
	
					child.material = material;
	
				} );
	
			}
	
			// override children visibility
			// with root node visibility as specified in JSON
	
			var visible = ( obj.visible !== undefined ) ? obj.visible : true;
	
			node.traverse( function ( child )  {
	
				child.visible = visible;
	
			} );
	
			parent.add( node );
	
			node.name = id;
	
			result.objects[ id ] = node;
			handle_objects();
	
		};
	
		function create_callback_geometry( id ) {
	
			return function( geo, mat ) {
	
				handle_mesh( geo, mat, id );
	
				counter_models -= 1;
	
				scope.onLoadComplete();
	
				async_callback_gate();
	
			}
	
		};
	
		function create_callback_hierachy( id, parent, material, obj ) {
	
			return function( event ) {
	
				var result;
	
				// loaders which use EventDispatcher
	
				if ( event.content ) {
	
					result = event.content;
	
				// ColladaLoader
	
				} else if ( event.dae ) {
	
					result = event.scene;
	
	
				// UTF8Loader
	
				} else {
	
					result = event;
	
				}
	
				handle_hierarchy( result, id, parent, material, obj );
	
				counter_models -= 1;
	
				scope.onLoadComplete();
	
				async_callback_gate();
	
			}
	
		};
	
		function create_callback_embed( id ) {
	
			return function( geo, mat ) {
	
				result.geometries[ id ] = geo;
				result.face_materials[ id ] = mat;
	
			}
	
		};
	
		function async_callback_gate() {
	
			var progress = {
	
				totalModels : total_models,
				totalTextures : total_textures,
				loadedModels : total_models - counter_models,
				loadedTextures : total_textures - counter_textures
	
			};
	
			scope.callbackProgress( progress, result );
	
			scope.onLoadProgress();
	
			if ( counter_models === 0 && counter_textures === 0 ) {
	
				finalize();
				callbackFinished( result );
	
			}
	
		};
	
		function finalize() {
	
			// take care of targets which could be asynchronously loaded objects
	
			for ( var i = 0; i < target_array.length; i ++ ) {
	
				var ta = target_array[ i ];
	
				var target = result.objects[ ta.targetName ];
	
				if ( target ) {
	
					ta.object.target = target;
	
				} else {
	
					// if there was error and target of specified name doesn't exist in the scene file
					// create instead dummy target
					// (target must be added to scene explicitly as parent is already added)
	
					ta.object.target = new THREE.Object3D();
					result.scene.add( ta.object.target );
	
				}
	
				ta.object.target.properties.targetInverse = ta.object;
	
			}
	
		};
	
		var callbackTexture = function ( count ) {
	
			counter_textures -= count;
			async_callback_gate();
	
			scope.onLoadComplete();
	
		};
	
		// must use this instead of just directly calling callbackTexture
		// because of closure in the calling context loop
	
		var generateTextureCallback = function ( count ) {
	
			return function() {
	
				callbackTexture( count );
	
			};
	
		};
	
		// first go synchronous elements
	
		// fogs
	
		var fogID, fogJSON;
	
		for ( fogID in data.fogs ) {
	
			fogJSON = data.fogs[ fogID ];
	
			if ( fogJSON.type === "linear" ) {
	
				fog = new THREE.Fog( 0x000000, fogJSON.near, fogJSON.far );
	
			} else if ( fogJSON.type === "exp2" ) {
	
				fog = new THREE.FogExp2( 0x000000, fogJSON.density );
	
			}
	
			color = fogJSON.color;
			fog.color.setRGB( color[0], color[1], color[2] );
	
			result.fogs[ fogID ] = fog;
	
		}
	
		// now come potentially asynchronous elements
	
		// geometries
	
		// count how many geometries will be loaded asynchronously
	
		var geoID, geoJSON;
	
		for ( geoID in data.geometries ) {
	
			geoJSON = data.geometries[ geoID ];
	
			if ( geoJSON.type in this.geometryHandlerMap ) {
	
				counter_models += 1;
	
				scope.onLoadStart();
	
			}
	
		}
	
		// count how many hierarchies will be loaded asynchronously
	
		var objID, objJSON;
	
		for ( objID in data.objects ) {
	
			objJSON = data.objects[ objID ];
	
			if ( objJSON.type && ( objJSON.type in this.hierarchyHandlerMap ) ) {
	
				counter_models += 1;
	
				scope.onLoadStart();
	
			}
	
		}
	
		total_models = counter_models;
	
		for ( geoID in data.geometries ) {
	
			geoJSON = data.geometries[ geoID ];
	
			if ( geoJSON.type === "cube" ) {
	
				geometry = new THREE.CubeGeometry( geoJSON.width, geoJSON.height, geoJSON.depth, geoJSON.widthSegments, geoJSON.heightSegments, geoJSON.depthSegments );
				result.geometries[ geoID ] = geometry;
	
			} else if ( geoJSON.type === "plane" ) {
	
				geometry = new THREE.PlaneGeometry( geoJSON.width, geoJSON.height, geoJSON.widthSegments, geoJSON.heightSegments );
				result.geometries[ geoID ] = geometry;
	
			} else if ( geoJSON.type === "sphere" ) {
	
				geometry = new THREE.SphereGeometry( geoJSON.radius, geoJSON.widthSegments, geoJSON.heightSegments );
				result.geometries[ geoID ] = geometry;
	
			} else if ( geoJSON.type === "cylinder" ) {
	
				geometry = new THREE.CylinderGeometry( geoJSON.topRad, geoJSON.botRad, geoJSON.height, geoJSON.radSegs, geoJSON.heightSegs );
				result.geometries[ geoID ] = geometry;
	
			} else if ( geoJSON.type === "torus" ) {
	
				geometry = new THREE.TorusGeometry( geoJSON.radius, geoJSON.tube, geoJSON.segmentsR, geoJSON.segmentsT );
				result.geometries[ geoID ] = geometry;
	
			} else if ( geoJSON.type === "icosahedron" ) {
	
				geometry = new THREE.IcosahedronGeometry( geoJSON.radius, geoJSON.subdivisions );
				result.geometries[ geoID ] = geometry;
	
			} else if ( geoJSON.type in this.geometryHandlerMap ) {
	
				var loaderParameters = {};
	
				for ( var parType in geoJSON ) {
	
					if ( parType !== "type" && parType !== "url" ) {
	
						loaderParameters[ parType ] = geoJSON[ parType ];
	
					}
	
				}
	
				var loader = this.geometryHandlerMap[ geoJSON.type ][ "loaderObject" ];
				loader.load( get_url( geoJSON.url, data.urlBaseType ), create_callback_geometry( geoID ), loaderParameters );
	
			} else if ( geoJSON.type === "embedded" ) {
	
				var modelJson = data.embeds[ geoJSON.id ],
					texture_path = "";
	
				// pass metadata along to jsonLoader so it knows the format version
	
				modelJson.metadata = data.metadata;
	
				if ( modelJson ) {
	
					var jsonLoader = this.geometryHandlerMap[ "ascii" ][ "loaderObject" ];
					jsonLoader.createModel( modelJson, create_callback_embed( geoID ), texture_path );
	
				}
	
			}
	
		}
	
		// textures
	
		// count how many textures will be loaded asynchronously
	
		var textureID, textureJSON;
	
		for ( textureID in data.textures ) {
	
			textureJSON = data.textures[ textureID ];
	
			if ( textureJSON.url instanceof Array ) {
	
				counter_textures += textureJSON.url.length;
	
				for( var n = 0; n < textureJSON.url.length; n ++ ) {
	
					scope.onLoadStart();
	
				}
	
			} else {
	
				counter_textures += 1;
	
				scope.onLoadStart();
	
			}
	
		}
	
		total_textures = counter_textures;
	
		for ( textureID in data.textures ) {
	
			textureJSON = data.textures[ textureID ];
	
			if ( textureJSON.mapping !== undefined && THREE[ textureJSON.mapping ] !== undefined  ) {
	
				textureJSON.mapping = new THREE[ textureJSON.mapping ]();
	
			}
	
			if ( textureJSON.url instanceof Array ) {
	
				var count = textureJSON.url.length;
				var url_array = [];
	
				for( var i = 0; i < count; i ++ ) {
	
					url_array[ i ] = get_url( textureJSON.url[ i ], data.urlBaseType );
	
				}
	
				var isCompressed = /\.dds$/i.test( url_array[ 0 ] );
	
				if ( isCompressed ) {
	
					texture = THREE.ImageUtils.loadCompressedTextureCube( url_array, textureJSON.mapping, generateTextureCallback( count ) );
	
				} else {
	
					texture = THREE.ImageUtils.loadTextureCube( url_array, textureJSON.mapping, generateTextureCallback( count ) );
	
				}
	
			} else {
	
				var isCompressed = /\.dds$/i.test( textureJSON.url );
				var fullUrl = get_url( textureJSON.url, data.urlBaseType );
				var textureCallback = generateTextureCallback( 1 );
	
				if ( isCompressed ) {
	
					texture = THREE.ImageUtils.loadCompressedTexture( fullUrl, textureJSON.mapping, textureCallback );
	
				} else {
	
					texture = THREE.ImageUtils.loadTexture( fullUrl, textureJSON.mapping, textureCallback );
	
				}
	
				if ( THREE[ textureJSON.minFilter ] !== undefined )
					texture.minFilter = THREE[ textureJSON.minFilter ];
	
				if ( THREE[ textureJSON.magFilter ] !== undefined )
					texture.magFilter = THREE[ textureJSON.magFilter ];
	
				if ( textureJSON.anisotropy ) texture.anisotropy = textureJSON.anisotropy;
	
				if ( textureJSON.repeat ) {
	
					texture.repeat.set( textureJSON.repeat[ 0 ], textureJSON.repeat[ 1 ] );
	
					if ( textureJSON.repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;
					if ( textureJSON.repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;
	
				}
	
				if ( textureJSON.offset ) {
	
					texture.offset.set( textureJSON.offset[ 0 ], textureJSON.offset[ 1 ] );
	
				}
	
				// handle wrap after repeat so that default repeat can be overriden
	
				if ( textureJSON.wrap ) {
	
					var wrapMap = {
					"repeat" 	: THREE.RepeatWrapping,
					"mirror"	: THREE.MirroredRepeatWrapping
					}
	
					if ( wrapMap[ textureJSON.wrap[ 0 ] ] !== undefined ) texture.wrapS = wrapMap[ textureJSON.wrap[ 0 ] ];
					if ( wrapMap[ textureJSON.wrap[ 1 ] ] !== undefined ) texture.wrapT = wrapMap[ textureJSON.wrap[ 1 ] ];
	
				}
	
			}
	
			result.textures[ textureID ] = texture;
	
		}
	
		// materials
	
		var matID, matJSON;
		var parID;
	
		for ( matID in data.materials ) {
	
			matJSON = data.materials[ matID ];
	
			for ( parID in matJSON.parameters ) {
	
				if ( parID === "envMap" || parID === "map" || parID === "lightMap" || parID === "bumpMap" ) {
	
					matJSON.parameters[ parID ] = result.textures[ matJSON.parameters[ parID ] ];
	
				} else if ( parID === "shading" ) {
	
					matJSON.parameters[ parID ] = ( matJSON.parameters[ parID ] === "flat" ) ? THREE.FlatShading : THREE.SmoothShading;
	
				} else if ( parID === "side" ) {
	
					if ( matJSON.parameters[ parID ] == "double" ) {
	
						matJSON.parameters[ parID ] = THREE.DoubleSide;
	
					} else if ( matJSON.parameters[ parID ] == "back" ) {
	
						matJSON.parameters[ parID ] = THREE.BackSide;
	
					} else {
	
						matJSON.parameters[ parID ] = THREE.FrontSide;
	
					}
	
				} else if ( parID === "blending" ) {
	
					matJSON.parameters[ parID ] = matJSON.parameters[ parID ] in THREE ? THREE[ matJSON.parameters[ parID ] ] : THREE.NormalBlending;
	
				} else if ( parID === "combine" ) {
	
					matJSON.parameters[ parID ] = matJSON.parameters[ parID ] in THREE ? THREE[ matJSON.parameters[ parID ] ] : THREE.MultiplyOperation;
	
				} else if ( parID === "vertexColors" ) {
	
					if ( matJSON.parameters[ parID ] == "face" ) {
	
						matJSON.parameters[ parID ] = THREE.FaceColors;
	
					// default to vertex colors if "vertexColors" is anything else face colors or 0 / null / false
	
					} else if ( matJSON.parameters[ parID ] )   {
	
						matJSON.parameters[ parID ] = THREE.VertexColors;
	
					}
	
				} else if ( parID === "wrapRGB" ) {
	
					var v3 = matJSON.parameters[ parID ];
					matJSON.parameters[ parID ] = new THREE.Vector3( v3[ 0 ], v3[ 1 ], v3[ 2 ] );
	
				}
	
			}
	
			if ( matJSON.parameters.opacity !== undefined && matJSON.parameters.opacity < 1.0 ) {
	
				matJSON.parameters.transparent = true;
	
			}
	
			if ( matJSON.parameters.normalMap ) {
	
				var shader = THREE.ShaderLib[ "normalmap" ];
				var uniforms = THREE.UniformsUtils.clone( shader.uniforms );
	
				var diffuse = matJSON.parameters.color;
				var specular = matJSON.parameters.specular;
				var ambient = matJSON.parameters.ambient;
				var shininess = matJSON.parameters.shininess;
	
				uniforms[ "tNormal" ].value = result.textures[ matJSON.parameters.normalMap ];
	
				if ( matJSON.parameters.normalScale ) {
	
					uniforms[ "uNormalScale" ].value.set( matJSON.parameters.normalScale[ 0 ], matJSON.parameters.normalScale[ 1 ] );
	
				}
	
				if ( matJSON.parameters.map ) {
	
					uniforms[ "tDiffuse" ].value = matJSON.parameters.map;
					uniforms[ "enableDiffuse" ].value = true;
	
				}
	
				if ( matJSON.parameters.envMap ) {
	
					uniforms[ "tCube" ].value = matJSON.parameters.envMap;
					uniforms[ "enableReflection" ].value = true;
					uniforms[ "uReflectivity" ].value = matJSON.parameters.reflectivity;
	
				}
	
				if ( matJSON.parameters.lightMap ) {
	
					uniforms[ "tAO" ].value = matJSON.parameters.lightMap;
					uniforms[ "enableAO" ].value = true;
	
				}
	
				if ( matJSON.parameters.specularMap ) {
	
					uniforms[ "tSpecular" ].value = result.textures[ matJSON.parameters.specularMap ];
					uniforms[ "enableSpecular" ].value = true;
	
				}
	
				if ( matJSON.parameters.displacementMap ) {
	
					uniforms[ "tDisplacement" ].value = result.textures[ matJSON.parameters.displacementMap ];
					uniforms[ "enableDisplacement" ].value = true;
	
					uniforms[ "uDisplacementBias" ].value = matJSON.parameters.displacementBias;
					uniforms[ "uDisplacementScale" ].value = matJSON.parameters.displacementScale;
	
				}
	
				uniforms[ "uDiffuseColor" ].value.setHex( diffuse );
				uniforms[ "uSpecularColor" ].value.setHex( specular );
				uniforms[ "uAmbientColor" ].value.setHex( ambient );
	
				uniforms[ "uShininess" ].value = shininess;
	
				if ( matJSON.parameters.opacity ) {
	
					uniforms[ "uOpacity" ].value = matJSON.parameters.opacity;
	
				}
	
				var parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms, lights: true, fog: true };
	
				material = new THREE.ShaderMaterial( parameters );
	
			} else {
	
				material = new THREE[ matJSON.type ]( matJSON.parameters );
	
			}
	
			result.materials[ matID ] = material;
	
		}
	
		// second pass through all materials to initialize MeshFaceMaterials
		// that could be referring to other materials out of order
	
		for ( matID in data.materials ) {
	
			matJSON = data.materials[ matID ];
	
			if ( matJSON.parameters.materials ) {
	
				var materialArray = [];
	
				for ( var i = 0; i < matJSON.parameters.materials.length; i ++ ) {
	
					var label = matJSON.parameters.materials[ i ];
					materialArray.push( result.materials[ label ] );
	
				}
	
				result.materials[ matID ].materials = materialArray;
	
			}
	
		}
	
		// objects ( synchronous init of procedural primitives )
	
		handle_objects();
	
		// defaults
	
		if ( result.cameras && data.defaults.camera ) {
	
			result.currentCamera = result.cameras[ data.defaults.camera ];
	
		}
	
		if ( result.fogs && data.defaults.fog ) {
	
			result.scene.fog = result.fogs[ data.defaults.fog ];
	
		}
	
		// synchronous callback
	
		scope.callbackSync( result );
	
		// just in case there are no async elements
	
		async_callback_gate();
	
	};
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.TextureLoader = function () {
	
		THREE.EventDispatcher.call( this );
	
		this.crossOrigin = null;
	
	};
	
	THREE.TextureLoader.prototype = {
	
		constructor: THREE.TextureLoader,
	
		load: function ( url ) {
	
			var scope = this;
	
			var image = new Image();
	
			image.addEventListener( 'load', function () {
	
				var texture = new THREE.Texture( image );
				texture.needsUpdate = true;
	
				scope.dispatchEvent( { type: 'load', content: texture } );
	
			}, false );
	
			image.addEventListener( 'error', function () {
	
				scope.dispatchEvent( { type: 'error', message: 'Couldn\'t load URL [' + url + ']' } );
	
			}, false );
	
			if ( scope.crossOrigin ) image.crossOrigin = scope.crossOrigin;
	
			image.src = url;
	
		}
	
	}
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Material = function () {
	
		THREE.EventDispatcher.call( this );
	
		this.id = THREE.MaterialIdCount ++;
	
		this.name = '';
	
		this.side = THREE.FrontSide;
	
		this.opacity = 1;
		this.transparent = false;
	
		this.blending = THREE.NormalBlending;
	
		this.blendSrc = THREE.SrcAlphaFactor;
		this.blendDst = THREE.OneMinusSrcAlphaFactor;
		this.blendEquation = THREE.AddEquation;
	
		this.depthTest = true;
		this.depthWrite = true;
	
		this.polygonOffset = false;
		this.polygonOffsetFactor = 0;
		this.polygonOffsetUnits = 0;
	
		this.alphaTest = 0;
	
		this.overdraw = false; // Boolean for fixing antialiasing gaps in CanvasRenderer
	
		this.visible = true;
	
		this.needsUpdate = true;
	
	};
	
	THREE.Material.prototype.setValues = function ( values ) {
	
		if ( values === undefined ) return;
	
		for ( var key in values ) {
	
			var newValue = values[ key ];
	
			if ( newValue === undefined ) {
	
				console.warn( 'THREE.Material: \'' + key + '\' parameter is undefined.' );
				continue;
	
			}
	
			if ( key in this ) {
	
				var currentValue = this[ key ];
	
				if ( currentValue instanceof THREE.Color && newValue instanceof THREE.Color ) {
	
					currentValue.copy( newValue );
	
				} else if ( currentValue instanceof THREE.Color ) {
	
					currentValue.set( newValue );
	
				} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {
	
					currentValue.copy( newValue );
	
				} else {
	
					this[ key ] = newValue;
	
				}
	
			}
	
		}
	
	};
	
	THREE.Material.prototype.clone = function ( material ) {
	
		if ( material === undefined ) material = new THREE.Material();
	
		material.name = this.name;
	
		material.side = this.side;
	
		material.opacity = this.opacity;
		material.transparent = this.transparent;
	
		material.blending = this.blending;
	
		material.blendSrc = this.blendSrc;
		material.blendDst = this.blendDst;
		material.blendEquation = this.blendEquation;
	
		material.depthTest = this.depthTest;
		material.depthWrite = this.depthWrite;
	
		material.polygonOffset = this.polygonOffset;
		material.polygonOffsetFactor = this.polygonOffsetFactor;
		material.polygonOffsetUnits = this.polygonOffsetUnits;
	
		material.alphaTest = this.alphaTest;
	
		material.overdraw = this.overdraw;
	
		material.visible = this.visible;
	
		return material;
	
	};
	
	THREE.Material.prototype.dispose = function () {
	
		this.dispatchEvent( { type: 'dispose' } );
	
	};
	
	THREE.MaterialIdCount = 0;
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  linewidth: <float>,
	 *  linecap: "round",
	 *  linejoin: "round",
	 *
	 *  vertexColors: <bool>
	 *
	 *  fog: <bool>
	 * }
	 */
	
	THREE.LineBasicMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.color = new THREE.Color( 0xffffff );
	
		this.linewidth = 1;
		this.linecap = 'round';
		this.linejoin = 'round';
	
		this.vertexColors = false;
	
		this.fog = true;
	
		this.setValues( parameters );
	
	};
	
	THREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );
	
	THREE.LineBasicMaterial.prototype.clone = function () {
	
		var material = new THREE.LineBasicMaterial();
	
		THREE.Material.prototype.clone.call( this, material );
	
		material.color.copy( this.color );
	
		material.linewidth = this.linewidth;
		material.linecap = this.linecap;
		material.linejoin = this.linejoin;
	
		material.vertexColors = this.vertexColors;
	
		material.fog = this.fog;
	
		return material;
	
	};
	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  linewidth: <float>,
	 *
	 *  scale: <float>,
	 *  dashSize: <float>,
	 *  gapSize: <float>,
	 *
	 *  vertexColors: <bool>
	 *
	 *  fog: <bool>
	 * }
	 */
	
	THREE.LineDashedMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.color = new THREE.Color( 0xffffff );
	
		this.linewidth = 1;
	
		this.scale = 1;
		this.dashSize = 3;
		this.gapSize = 1;
	
		this.vertexColors = false;
	
		this.fog = true;
	
		this.setValues( parameters );
	
	};
	
	THREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );
	
	THREE.LineDashedMaterial.prototype.clone = function () {
	
		var material = new THREE.LineDashedMaterial();
	
		THREE.Material.prototype.clone.call( this, material );
	
		material.color.copy( this.color );
	
		material.linewidth = this.linewidth;
	
		material.scale = this.scale;
		material.dashSize = this.dashSize;
		material.gapSize = this.gapSize;
	
		material.vertexColors = this.vertexColors;
	
		material.fog = this.fog;
	
		return material;
	
	};
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *
	 *  fog: <bool>
	 * }
	 */
	
	THREE.MeshBasicMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.color = new THREE.Color( 0xffffff ); // emissive
	
		this.map = null;
	
		this.lightMap = null;
	
		this.specularMap = null;
	
		this.envMap = null;
		this.combine = THREE.MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;
	
		this.fog = true;
	
		this.shading = THREE.SmoothShading;
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
	
		this.vertexColors = THREE.NoColors;
	
		this.skinning = false;
		this.morphTargets = false;
	
		this.setValues( parameters );
	
	};
	
	THREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );
	
	THREE.MeshBasicMaterial.prototype.clone = function () {
	
		var material = new THREE.MeshBasicMaterial();
	
		THREE.Material.prototype.clone.call( this, material );
	
		material.color.copy( this.color );
	
		material.map = this.map;
	
		material.lightMap = this.lightMap;
	
		material.specularMap = this.specularMap;
	
		material.envMap = this.envMap;
		material.combine = this.combine;
		material.reflectivity = this.reflectivity;
		material.refractionRatio = this.refractionRatio;
	
		material.fog = this.fog;
	
		material.shading = this.shading;
	
		material.wireframe = this.wireframe;
		material.wireframeLinewidth = this.wireframeLinewidth;
		material.wireframeLinecap = this.wireframeLinecap;
		material.wireframeLinejoin = this.wireframeLinejoin;
	
		material.vertexColors = this.vertexColors;
	
		material.skinning = this.skinning;
		material.morphTargets = this.morphTargets;
	
		return material;
	
	};
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  ambient: <hex>,
	 *  emissive: <hex>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *	fog: <bool>
	 * }
	 */
	
	THREE.MeshLambertMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.color = new THREE.Color( 0xffffff ); // diffuse
		this.ambient = new THREE.Color( 0xffffff );
		this.emissive = new THREE.Color( 0x000000 );
	
		this.wrapAround = false;
		this.wrapRGB = new THREE.Vector3( 1, 1, 1 );
	
		this.map = null;
	
		this.lightMap = null;
	
		this.specularMap = null;
	
		this.envMap = null;
		this.combine = THREE.MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;
	
		this.fog = true;
	
		this.shading = THREE.SmoothShading;
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
	
		this.vertexColors = THREE.NoColors;
	
		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;
	
		this.setValues( parameters );
	
	};
	
	THREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );
	
	THREE.MeshLambertMaterial.prototype.clone = function () {
	
		var material = new THREE.MeshLambertMaterial();
	
		THREE.Material.prototype.clone.call( this, material );
	
		material.color.copy( this.color );
		material.ambient.copy( this.ambient );
		material.emissive.copy( this.emissive );
	
		material.wrapAround = this.wrapAround;
		material.wrapRGB.copy( this.wrapRGB );
	
		material.map = this.map;
	
		material.lightMap = this.lightMap;
	
		material.specularMap = this.specularMap;
	
		material.envMap = this.envMap;
		material.combine = this.combine;
		material.reflectivity = this.reflectivity;
		material.refractionRatio = this.refractionRatio;
	
		material.fog = this.fog;
	
		material.shading = this.shading;
	
		material.wireframe = this.wireframe;
		material.wireframeLinewidth = this.wireframeLinewidth;
		material.wireframeLinecap = this.wireframeLinecap;
		material.wireframeLinejoin = this.wireframeLinejoin;
	
		material.vertexColors = this.vertexColors;
	
		material.skinning = this.skinning;
		material.morphTargets = this.morphTargets;
		material.morphNormals = this.morphNormals;
	
		return material;
	
	};
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  ambient: <hex>,
	 *  emissive: <hex>,
	 *  specular: <hex>,
	 *  shininess: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalScale: <Vector2>,
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *	fog: <bool>
	 * }
	 */
	
	THREE.MeshPhongMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.color = new THREE.Color( 0xffffff ); // diffuse
		this.ambient = new THREE.Color( 0xffffff );
		this.emissive = new THREE.Color( 0x000000 );
		this.specular = new THREE.Color( 0x111111 );
		this.shininess = 30;
	
		this.metal = false;
		this.perPixel = true;
	
		this.wrapAround = false;
		this.wrapRGB = new THREE.Vector3( 1, 1, 1 );
	
		this.map = null;
	
		this.lightMap = null;
	
		this.bumpMap = null;
		this.bumpScale = 1;
	
		this.normalMap = null;
		this.normalScale = new THREE.Vector2( 1, 1 );
	
		this.specularMap = null;
	
		this.envMap = null;
		this.combine = THREE.MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;
	
		this.fog = true;
	
		this.shading = THREE.SmoothShading;
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
	
		this.vertexColors = THREE.NoColors;
	
		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;
	
		this.setValues( parameters );
	
	};
	
	THREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );
	
	THREE.MeshPhongMaterial.prototype.clone = function () {
	
		var material = new THREE.MeshPhongMaterial();
	
		THREE.Material.prototype.clone.call( this, material );
	
		material.color.copy( this.color );
		material.ambient.copy( this.ambient );
		material.emissive.copy( this.emissive );
		material.specular.copy( this.specular );
		material.shininess = this.shininess;
	
		material.metal = this.metal;
		material.perPixel = this.perPixel;
	
		material.wrapAround = this.wrapAround;
		material.wrapRGB.copy( this.wrapRGB );
	
		material.map = this.map;
	
		material.lightMap = this.lightMap;
	
		material.bumpMap = this.bumpMap;
		material.bumpScale = this.bumpScale;
	
		material.normalMap = this.normalMap;
		material.normalScale.copy( this.normalScale );
	
		material.specularMap = this.specularMap;
	
		material.envMap = this.envMap;
		material.combine = this.combine;
		material.reflectivity = this.reflectivity;
		material.refractionRatio = this.refractionRatio;
	
		material.fog = this.fog;
	
		material.shading = this.shading;
	
		material.wireframe = this.wireframe;
		material.wireframeLinewidth = this.wireframeLinewidth;
		material.wireframeLinecap = this.wireframeLinecap;
		material.wireframeLinejoin = this.wireframeLinejoin;
	
		material.vertexColors = this.vertexColors;
	
		material.skinning = this.skinning;
		material.morphTargets = this.morphTargets;
		material.morphNormals = this.morphNormals;
	
		return material;
	
	};
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  opacity: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
	 */
	
	THREE.MeshDepthMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
	
		this.setValues( parameters );
	
	};
	
	THREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );
	
	THREE.MeshDepthMaterial.prototype.clone = function () {
	
		var material = new THREE.LineBasicMaterial();
	
		THREE.Material.prototype.clone.call( this, material );
	
		material.wireframe = this.wireframe;
		material.wireframeLinewidth = this.wireframeLinewidth;
	
		return material;
	
	};
	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * parameters = {
	 *  opacity: <float>,
	 *
	 *  shading: THREE.FlatShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
	 */
	
	THREE.MeshNormalMaterial = function ( parameters ) {
	
		THREE.Material.call( this, parameters );
	
		this.shading = THREE.FlatShading;
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
	
		this.setValues( parameters );
	
	};
	
	THREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );
	
	THREE.MeshNormalMaterial.prototype.clone = function () {
	
		var material = new THREE.MeshNormalMaterial();
	
		THREE.Material.prototype.clone.call( this, material );
	
		material.shading = this.shading;
	
		material.wireframe = this.wireframe;
		material.wireframeLinewidth = this.wireframeLinewidth;
	
		return material;
	
	};
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.MeshFaceMaterial = function ( materials ) {
	
		this.materials = materials instanceof Array ? materials : [];
	
	};
	
	THREE.MeshFaceMaterial.prototype.clone = function () {
	
		return new THREE.MeshFaceMaterial( this.materials.slice( 0 ) );
	
	};
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  size: <float>,
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  vertexColors: <bool>,
	 *
	 *  fog: <bool>
	 * }
	 */
	
	THREE.ParticleBasicMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.color = new THREE.Color( 0xffffff );
	
		this.map = null;
	
		this.size = 1;
		this.sizeAttenuation = true;
	
		this.vertexColors = false;
	
		this.fog = true;
	
		this.setValues( parameters );
	
	};
	
	THREE.ParticleBasicMaterial.prototype = Object.create( THREE.Material.prototype );
	
	THREE.ParticleBasicMaterial.prototype.clone = function () {
	
		var material = new THREE.ParticleBasicMaterial();
	
		THREE.Material.prototype.clone.call( this, material );
	
		material.color.copy( this.color );
	
		material.map = this.map;
	
		material.size = this.size;
		material.sizeAttenuation = this.sizeAttenuation;
	
		material.vertexColors = this.vertexColors;
	
		material.fog = this.fog;
	
		return material;
	
	};
	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  program: <function>,
	 *  opacity: <float>,
	 *  blending: THREE.NormalBlending
	 * }
	 */
	
	THREE.ParticleCanvasMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.color = new THREE.Color( 0xffffff );
		this.program = function ( context, color ) {};
	
		this.setValues( parameters );
	
	};
	
	THREE.ParticleCanvasMaterial.prototype = Object.create( THREE.Material.prototype );
	
	THREE.ParticleCanvasMaterial.prototype.clone = function () {
	
		var material = new THREE.ParticleCanvasMaterial();
	
		THREE.Material.prototype.clone.call( this, material );
	
		material.color.copy( this.color );
		material.program = this.program;
	
		return material;
	
	};
	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  fragmentShader: <string>,
	 *  vertexShader: <string>,
	 *
	 *  uniforms: { "parameter1": { type: "f", value: 1.0 }, "parameter2": { type: "i" value2: 2 } },
	 *
	 *  defines: { "label" : "value" },
	 *
	 *  shading: THREE.SmoothShading,
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  lights: <bool>,
	 *
	 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *	fog: <bool>
	 * }
	 */
	
	THREE.ShaderMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		this.fragmentShader = "void main() {}";
		this.vertexShader = "void main() {}";
		this.uniforms = {};
		this.defines = {};
		this.attributes = null;
	
		this.shading = THREE.SmoothShading;
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
	
		this.fog = false; // set to use scene fog
	
		this.lights = false; // set to use scene lights
	
		this.vertexColors = THREE.NoColors; // set to use "color" attribute stream
	
		this.skinning = false; // set to use skinning attribute streams
	
		this.morphTargets = false; // set to use morph targets
		this.morphNormals = false; // set to use morph normals
	
		this.setValues( parameters );
	
	};
	
	THREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );
	
	THREE.ShaderMaterial.prototype.clone = function () {
	
		var material = new THREE.ShaderMaterial();
	
		THREE.Material.prototype.clone.call( this, material );
	
		material.fragmentShader = this.fragmentShader;
		material.vertexShader = this.vertexShader;
	
		material.uniforms = THREE.UniformsUtils.clone( this.uniforms );
	
		material.attributes = this.attributes;
		material.defines = this.defines;
	
		material.shading = this.shading;
	
		material.wireframe = this.wireframe;
		material.wireframeLinewidth = this.wireframeLinewidth;
	
		material.fog = this.fog;
	
		material.lights = this.lights;
	
		material.vertexColors = this.vertexColors;
	
		material.skinning = this.skinning;
	
		material.morphTargets = this.morphTargets;
		material.morphNormals = this.morphNormals;
	
		return material;
	
	};
	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  blending: THREE.NormalBlending,
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  useScreenCoordinates: <bool>,
	 *  sizeAttenuation: <bool>,
	 *  scaleByViewport: <bool>,
	 *  alignment: THREE.SpriteAlignment.center,
	 *
	 *	uvOffset: new THREE.Vector2(),
	 *	uvScale: new THREE.Vector2(),
	 *
	 *  fog: <bool>
	 * }
	 */
	
	THREE.SpriteMaterial = function ( parameters ) {
	
		THREE.Material.call( this );
	
		// defaults
	
		this.color = new THREE.Color( 0xffffff );
		this.map = new THREE.Texture();
	
		this.useScreenCoordinates = true;
		this.depthTest = !this.useScreenCoordinates;
		this.sizeAttenuation = !this.useScreenCoordinates;
		this.scaleByViewport = !this.sizeAttenuation;
		this.alignment = THREE.SpriteAlignment.center.clone();
	
		this.fog = false;
	
		this.uvOffset = new THREE.Vector2( 0, 0 );
		this.uvScale  = new THREE.Vector2( 1, 1 );
	
		// set parameters
	
		this.setValues( parameters );
	
		// override coupled defaults if not specified explicitly by parameters
	
		parameters = parameters || {};
	
		if ( parameters.depthTest === undefined ) this.depthTest = !this.useScreenCoordinates;
		if ( parameters.sizeAttenuation === undefined ) this.sizeAttenuation = !this.useScreenCoordinates;
		if ( parameters.scaleByViewport === undefined ) this.scaleByViewport = !this.sizeAttenuation;
	
	};
	
	THREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );
	
	THREE.SpriteMaterial.prototype.clone = function () {
	
		var material = new THREE.SpriteMaterial();
	
		THREE.Material.prototype.clone.call( this, material );
	
		material.color.copy( this.color );
		material.map = this.map;
	
		material.useScreenCoordinates = this.useScreenCoordinates;
		material.sizeAttenuation = this.sizeAttenuation;
		material.scaleByViewport = this.scaleByViewport;
		material.alignment.copy( this.alignment );
	
		material.uvOffset.copy( this.uvOffset );
		material.uvScale.copy( this.uvScale );
	
		material.fog = this.fog;
	
		return material;
	
	};
	
	// Alignment enums
	
	THREE.SpriteAlignment = {};
	THREE.SpriteAlignment.topLeft = new THREE.Vector2( 1, -1 );
	THREE.SpriteAlignment.topCenter = new THREE.Vector2( 0, -1 );
	THREE.SpriteAlignment.topRight = new THREE.Vector2( -1, -1 );
	THREE.SpriteAlignment.centerLeft = new THREE.Vector2( 1, 0 );
	THREE.SpriteAlignment.center = new THREE.Vector2( 0, 0 );
	THREE.SpriteAlignment.centerRight = new THREE.Vector2( -1, 0 );
	THREE.SpriteAlignment.bottomLeft = new THREE.Vector2( 1, 1 );
	THREE.SpriteAlignment.bottomCenter = new THREE.Vector2( 0, 1 );
	THREE.SpriteAlignment.bottomRight = new THREE.Vector2( -1, 1 );
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */
	
	THREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {
	
		THREE.EventDispatcher.call( this );
	
		this.id = THREE.TextureIdCount ++;
	
		this.name = '';
	
		this.image = image;
		this.mipmaps = [];
	
		this.mapping = mapping !== undefined ? mapping : new THREE.UVMapping();
	
		this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
		this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;
	
		this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
		this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;
	
		this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
	
		this.format = format !== undefined ? format : THREE.RGBAFormat;
		this.type = type !== undefined ? type : THREE.UnsignedByteType;
	
		this.offset = new THREE.Vector2( 0, 0 );
		this.repeat = new THREE.Vector2( 1, 1 );
	
		this.generateMipmaps = true;
		this.premultiplyAlpha = false;
		this.flipY = true;
		this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
	
		this.needsUpdate = false;
		this.onUpdate = null;
	
	};
	
	THREE.Texture.prototype = {
	
		constructor: THREE.Texture,
	
		clone: function ( texture ) {
	
			if ( texture === undefined ) texture = new THREE.Texture();
	
			texture.image = this.image;
			texture.mipmaps = this.mipmaps.slice(0);
	
			texture.mapping = this.mapping;
	
			texture.wrapS = this.wrapS;
			texture.wrapT = this.wrapT;
	
			texture.magFilter = this.magFilter;
			texture.minFilter = this.minFilter;
	
			texture.anisotropy = this.anisotropy;
	
			texture.format = this.format;
			texture.type = this.type;
	
			texture.offset.copy( this.offset );
			texture.repeat.copy( this.repeat );
	
			texture.generateMipmaps = this.generateMipmaps;
			texture.premultiplyAlpha = this.premultiplyAlpha;
			texture.flipY = this.flipY;
			texture.unpackAlignment = this.unpackAlignment;
	
			return texture;
	
		},
	
		dispose: function () {
	
			this.dispatchEvent( { type: 'dispose' } );
	
		}
	
	};
	
	THREE.TextureIdCount = 0;
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {
	
		THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
	
		this.image = { width: width, height: height };
		this.mipmaps = mipmaps;
	
		this.generateMipmaps = false; // WebGL currently can't generate mipmaps for compressed textures, they must be embedded in DDS file
	
	};
	
	THREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );
	
	THREE.CompressedTexture.prototype.clone = function () {
	
		var texture = new THREE.CompressedTexture();
	
		THREE.Texture.prototype.clone.call( this, texture );
	
		return texture;
	
	};
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {
	
		THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
	
		this.image = { data: data, width: width, height: height };
	
	};
	
	THREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );
	
	THREE.DataTexture.prototype.clone = function () {
	
		var texture = new THREE.DataTexture();
	
		THREE.Texture.prototype.clone.call( this, texture );
	
		return texture;
	
	};
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Particle = function ( material ) {
	
		THREE.Object3D.call( this );
	
		this.material = material;
	
	};
	
	THREE.Particle.prototype = Object.create( THREE.Object3D.prototype );
	
	THREE.Particle.prototype.clone = function ( object ) {
	
		if ( object === undefined ) object = new THREE.Particle( this.material );
	
		THREE.Object3D.prototype.clone.call( this, object );
	
		return object;
	
	};
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.ParticleSystem = function ( geometry, material ) {
	
		THREE.Object3D.call( this );
	
		this.geometry = geometry;
		this.material = ( material !== undefined ) ? material : new THREE.ParticleBasicMaterial( { color: Math.random() * 0xffffff } );
	
		this.sortParticles = false;
	
		if ( this.geometry ) {
	
			// calc bound radius
	
			if( this.geometry.boundingSphere === null ) {
	
				this.geometry.computeBoundingSphere();
	
			}
	
		}
	
		this.frustumCulled = false;
	
	};
	
	THREE.ParticleSystem.prototype = Object.create( THREE.Object3D.prototype );
	
	THREE.ParticleSystem.prototype.clone = function ( object ) {
	
		if ( object === undefined ) object = new THREE.ParticleSystem( this.geometry, this.material );
		object.sortParticles = this.sortParticles;
	
		THREE.Object3D.prototype.clone.call( this, object );
	
		return object;
	
	};
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Line = function ( geometry, material, type ) {
	
		THREE.Object3D.call( this );
	
		this.geometry = geometry;
		this.material = ( material !== undefined ) ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );
		this.type = ( type !== undefined ) ? type : THREE.LineStrip;
	
		if ( this.geometry ) {
	
			if ( ! this.geometry.boundingSphere ) {
	
				this.geometry.computeBoundingSphere();
	
			}
	
		}
	
	};
	
	THREE.LineStrip = 0;
	THREE.LinePieces = 1;
	
	THREE.Line.prototype = Object.create( THREE.Object3D.prototype );
	
	THREE.Line.prototype.clone = function ( object ) {
	
		if ( object === undefined ) object = new THREE.Line( this.geometry, this.material, this.type );
	
		THREE.Object3D.prototype.clone.call( this, object );
	
		return object;
	
	};
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author jonobr1 / http://jonobr1.com/
	 */
	
	THREE.Mesh = function ( geometry, material ) {
	
		THREE.Object3D.call( this );
	
		this.geometry = geometry;
		this.material = ( material !== undefined ) ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff, wireframe: true } );
	
		if ( this.geometry !== undefined ) {
	
			if ( this.geometry.boundingSphere === null ) {
	
				this.geometry.computeBoundingSphere();
	
			}
	
			this.updateMorphTargets();
	
		}
	
	};
	
	THREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );
	
	THREE.Mesh.prototype.updateMorphTargets = function () {
	
		if ( this.geometry.morphTargets.length > 0 ) {
	
			this.morphTargetBase = -1;
			this.morphTargetForcedOrder = [];
			this.morphTargetInfluences = [];
			this.morphTargetDictionary = {};
	
			for ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {
	
				this.morphTargetInfluences.push( 0 );
				this.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;
	
			}
	
		}
	
	};
	
	THREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {
	
		if ( this.morphTargetDictionary[ name ] !== undefined ) {
	
			return this.morphTargetDictionary[ name ];
	
		}
	
		console.log( "THREE.Mesh.getMorphTargetIndexByName: morph target " + name + " does not exist. Returning 0." );
	
		return 0;
	
	};
	
	THREE.Mesh.prototype.clone = function ( object ) {
	
		if ( object === undefined ) object = new THREE.Mesh( this.geometry, this.material );
	
		THREE.Object3D.prototype.clone.call( this, object );
	
		return object;
	
	};
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Bone = function( belongsToSkin ) {
	
		THREE.Object3D.call( this );
	
		this.skin = belongsToSkin;
		this.skinMatrix = new THREE.Matrix4();
	
	};
	
	THREE.Bone.prototype = Object.create( THREE.Object3D.prototype );
	
	THREE.Bone.prototype.update = function ( parentSkinMatrix, forceUpdate ) {
	
		// update local
	
		if ( this.matrixAutoUpdate ) {
	
			forceUpdate |= this.updateMatrix();
	
		}
	
		// update skin matrix
	
		if ( forceUpdate || this.matrixWorldNeedsUpdate ) {
	
			if( parentSkinMatrix ) {
	
				this.skinMatrix.multiplyMatrices( parentSkinMatrix, this.matrix );
	
			} else {
	
				this.skinMatrix.copy( this.matrix );
	
			}
	
			this.matrixWorldNeedsUpdate = false;
			forceUpdate = true;
	
		}
	
		// update children
	
		var child, i, l = this.children.length;
	
		for ( i = 0; i < l; i ++ ) {
	
			this.children[ i ].update( this.skinMatrix, forceUpdate );
	
		}
	
	};
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {
	
		THREE.Mesh.call( this, geometry, material );
	
		//
	
		this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;
	
		// init bones
	
		this.identityMatrix = new THREE.Matrix4();
	
		this.bones = [];
		this.boneMatrices = [];
	
		var b, bone, gbone, p, q, s;
	
		if ( this.geometry && this.geometry.bones !== undefined ) {
	
			for ( b = 0; b < this.geometry.bones.length; b ++ ) {
	
				gbone = this.geometry.bones[ b ];
	
				p = gbone.pos;
				q = gbone.rotq;
				s = gbone.scl;
	
				bone = this.addBone();
	
				bone.name = gbone.name;
				bone.position.set( p[0], p[1], p[2] );
				bone.quaternion.set( q[0], q[1], q[2], q[3] );
				bone.useQuaternion = true;
	
				if ( s !== undefined ) {
	
					bone.scale.set( s[0], s[1], s[2] );
	
				} else {
	
					bone.scale.set( 1, 1, 1 );
	
				}
	
			}
	
			for ( b = 0; b < this.bones.length; b ++ ) {
	
				gbone = this.geometry.bones[ b ];
				bone = this.bones[ b ];
	
				if ( gbone.parent === -1 ) {
	
					this.add( bone );
	
				} else {
	
					this.bones[ gbone.parent ].add( bone );
	
				}
	
			}
	
			//
	
			var nBones = this.bones.length;
	
			if ( this.useVertexTexture ) {
	
				// layout (1 matrix = 4 pixels)
				//	RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
				//  with  8x8  pixel texture max   16 bones  (8 * 8  / 4)
				//  	 16x16 pixel texture max   64 bones (16 * 16 / 4)
				//  	 32x32 pixel texture max  256 bones (32 * 32 / 4)
				//  	 64x64 pixel texture max 1024 bones (64 * 64 / 4)
	
				var size;
	
				if ( nBones > 256 )
					size = 64;
				else if ( nBones > 64 )
					size = 32;
				else if ( nBones > 16 )
					size = 16;
				else
					size = 8;
	
				this.boneTextureWidth = size;
				this.boneTextureHeight = size;
	
				this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
				this.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );
				this.boneTexture.minFilter = THREE.NearestFilter;
				this.boneTexture.magFilter = THREE.NearestFilter;
				this.boneTexture.generateMipmaps = false;
				this.boneTexture.flipY = false;
	
			} else {
	
				this.boneMatrices = new Float32Array( 16 * nBones );
	
			}
	
			this.pose();
	
		}
	
	};
	
	THREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );
	
	THREE.SkinnedMesh.prototype.addBone = function( bone ) {
	
		if ( bone === undefined ) {
	
			bone = new THREE.Bone( this );
	
		}
	
		this.bones.push( bone );
	
		return bone;
	
	};
	
	THREE.SkinnedMesh.prototype.updateMatrixWorld = function ( force ) {
	
		this.matrixAutoUpdate && this.updateMatrix();
	
		// update matrixWorld
	
		if ( this.matrixWorldNeedsUpdate || force ) {
	
			if ( this.parent ) {
	
				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );
	
			} else {
	
				this.matrixWorld.copy( this.matrix );
	
			}
	
			this.matrixWorldNeedsUpdate = false;
	
			force = true;
	
		}
	
		// update children
	
		for ( var i = 0, l = this.children.length; i < l; i ++ ) {
	
			var child = this.children[ i ];
	
			if ( child instanceof THREE.Bone ) {
	
				child.update( this.identityMatrix, false );
	
			} else {
	
				child.updateMatrixWorld( true );
	
			}
	
		}
	
		// make a snapshot of the bones' rest position
	
		if ( this.boneInverses == undefined ) {
	
			this.boneInverses = [];
	
			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
				var inverse = new THREE.Matrix4();
	
				inverse.getInverse( this.bones[ b ].skinMatrix );
	
				this.boneInverses.push( inverse );
	
			}
	
		}
	
		// flatten bone matrices to array
	
		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
			// compute the offset between the current and the original transform;
	
			//TODO: we could get rid of this multiplication step if the skinMatrix
			// was already representing the offset; however, this requires some
			// major changes to the animation system
	
			THREE.SkinnedMesh.offsetMatrix.multiplyMatrices( this.bones[ b ].skinMatrix, this.boneInverses[ b ] );
	
			THREE.SkinnedMesh.offsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );
	
		}
	
		if ( this.useVertexTexture ) {
	
			this.boneTexture.needsUpdate = true;
	
		}
	
	};
	
	THREE.SkinnedMesh.prototype.pose = function () {
	
		this.updateMatrixWorld( true );
	
		for ( var i = 0; i < this.geometry.skinIndices.length; i ++ ) {
	
			// normalize weights
	
			var sw = this.geometry.skinWeights[ i ];
	
			var scale = 1.0 / sw.lengthManhattan();
	
			if ( scale !== Infinity ) {
	
				sw.multiplyScalar( scale );
	
			} else {
	
				sw.set( 1 ); // this will be normalized by the shader anyway
	
			}
	
		}
	
	};
	
	THREE.SkinnedMesh.prototype.clone = function ( object ) {
	
		if ( object === undefined ) object = new THREE.SkinnedMesh( this.geometry, this.material, this.useVertexTexture );
	
		THREE.Mesh.prototype.clone.call( this, object );
	
		return object;
	
	};
	
	THREE.SkinnedMesh.offsetMatrix = new THREE.Matrix4();
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.MorphAnimMesh = function ( geometry, material ) {
	
		THREE.Mesh.call( this, geometry, material );
	
		// API
	
		this.duration = 1000; // milliseconds
		this.mirroredLoop = false;
		this.time = 0;
	
		// internals
	
		this.lastKeyframe = 0;
		this.currentKeyframe = 0;
	
		this.direction = 1;
		this.directionBackwards = false;
	
		this.setFrameRange( 0, this.geometry.morphTargets.length - 1 );
	
	};
	
	THREE.MorphAnimMesh.prototype = Object.create( THREE.Mesh.prototype );
	
	THREE.MorphAnimMesh.prototype.setFrameRange = function ( start, end ) {
	
		this.startKeyframe = start;
		this.endKeyframe = end;
	
		this.length = this.endKeyframe - this.startKeyframe + 1;
	
	};
	
	THREE.MorphAnimMesh.prototype.setDirectionForward = function () {
	
		this.direction = 1;
		this.directionBackwards = false;
	
	};
	
	THREE.MorphAnimMesh.prototype.setDirectionBackward = function () {
	
		this.direction = -1;
		this.directionBackwards = true;
	
	};
	
	THREE.MorphAnimMesh.prototype.parseAnimations = function () {
	
		var geometry = this.geometry;
	
		if ( ! geometry.animations ) geometry.animations = {};
	
		var firstAnimation, animations = geometry.animations;
	
		var pattern = /([a-z]+)(\d+)/;
	
		for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {
	
			var morph = geometry.morphTargets[ i ];
			var parts = morph.name.match( pattern );
	
			if ( parts && parts.length > 1 ) {
	
				var label = parts[ 1 ];
				var num = parts[ 2 ];
	
				if ( ! animations[ label ] ) animations[ label ] = { start: Infinity, end: -Infinity };
	
				var animation = animations[ label ];
	
				if ( i < animation.start ) animation.start = i;
				if ( i > animation.end ) animation.end = i;
	
				if ( ! firstAnimation ) firstAnimation = label;
	
			}
	
		}
	
		geometry.firstAnimation = firstAnimation;
	
	};
	
	THREE.MorphAnimMesh.prototype.setAnimationLabel = function ( label, start, end ) {
	
		if ( ! this.geometry.animations ) this.geometry.animations = {};
	
		this.geometry.animations[ label ] = { start: start, end: end };
	
	};
	
	THREE.MorphAnimMesh.prototype.playAnimation = function ( label, fps ) {
	
		var animation = this.geometry.animations[ label ];
	
		if ( animation ) {
	
			this.setFrameRange( animation.start, animation.end );
			this.duration = 1000 * ( ( animation.end - animation.start ) / fps );
			this.time = 0;
	
		} else {
	
			console.warn( "animation[" + label + "] undefined" );
	
		}
	
	};
	
	THREE.MorphAnimMesh.prototype.updateAnimation = function ( delta ) {
	
		var frameTime = this.duration / this.length;
	
		this.time += this.direction * delta;
	
		if ( this.mirroredLoop ) {
	
			if ( this.time > this.duration || this.time < 0 ) {
	
				this.direction *= -1;
	
				if ( this.time > this.duration ) {
	
					this.time = this.duration;
					this.directionBackwards = true;
	
				}
	
				if ( this.time < 0 ) {
	
					this.time = 0;
					this.directionBackwards = false;
	
				}
	
			}
	
		} else {
	
			this.time = this.time % this.duration;
	
			if ( this.time < 0 ) this.time += this.duration;
	
		}
	
		var keyframe = this.startKeyframe + THREE.Math.clamp( Math.floor( this.time / frameTime ), 0, this.length - 1 );
	
		if ( keyframe !== this.currentKeyframe ) {
	
			this.morphTargetInfluences[ this.lastKeyframe ] = 0;
			this.morphTargetInfluences[ this.currentKeyframe ] = 1;
	
			this.morphTargetInfluences[ keyframe ] = 0;
	
			this.lastKeyframe = this.currentKeyframe;
			this.currentKeyframe = keyframe;
	
		}
	
		var mix = ( this.time % frameTime ) / frameTime;
	
		if ( this.directionBackwards ) {
	
			mix = 1 - mix;
	
		}
	
		this.morphTargetInfluences[ this.currentKeyframe ] = mix;
		this.morphTargetInfluences[ this.lastKeyframe ] = 1 - mix;
	
	};
	
	THREE.MorphAnimMesh.prototype.clone = function ( object ) {
	
		if ( object === undefined ) object = new THREE.MorphAnimMesh( this.geometry, this.material );
	
		object.duration = this.duration;
		object.mirroredLoop = this.mirroredLoop;
		object.time = this.time;
	
		object.lastKeyframe = this.lastKeyframe;
		object.currentKeyframe = this.currentKeyframe;
	
		object.direction = this.direction;
		object.directionBackwards = this.directionBackwards;
	
		THREE.Mesh.prototype.clone.call( this, object );
	
		return object;
	
	};
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Ribbon = function ( geometry, material ) {
	
		THREE.Object3D.call( this );
	
		this.geometry = geometry;
		this.material = material;
	
	};
	
	THREE.Ribbon.prototype = Object.create( THREE.Object3D.prototype );
	
	THREE.Ribbon.prototype.clone = function ( object ) {
	
		if ( object === undefined ) object = new THREE.Ribbon( this.geometry, this.material );
	
		THREE.Object3D.prototype.clone.call( this, object );
	
		return object;
	
	};
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.LOD = function () {
	
		THREE.Object3D.call( this );
	
		this.LODs = [];
	
	};
	
	
	THREE.LOD.prototype = Object.create( THREE.Object3D.prototype );
	
	THREE.LOD.prototype.addLevel = function ( object3D, visibleAtDistance ) {
	
		if ( visibleAtDistance === undefined ) {
	
			visibleAtDistance = 0;
	
		}
	
		visibleAtDistance = Math.abs( visibleAtDistance );
	
		for ( var l = 0; l < this.LODs.length; l ++ ) {
	
			if ( visibleAtDistance < this.LODs[ l ].visibleAtDistance ) {
	
				break;
	
			}
	
		}
	
		this.LODs.splice( l, 0, { visibleAtDistance: visibleAtDistance, object3D: object3D } );
		this.add( object3D );
	
	};
	
	THREE.LOD.prototype.update = function ( camera ) {
	
		if ( this.LODs.length > 1 ) {
	
			camera.matrixWorldInverse.getInverse( camera.matrixWorld );
	
			var inverse  = camera.matrixWorldInverse;
			var distance = -( inverse.elements[2] * this.matrixWorld.elements[12] + inverse.elements[6] * this.matrixWorld.elements[13] + inverse.elements[10] * this.matrixWorld.elements[14] + inverse.elements[14] );
	
			this.LODs[ 0 ].object3D.visible = true;
	
			for ( var l = 1; l < this.LODs.length; l ++ ) {
	
				if( distance >= this.LODs[ l ].visibleAtDistance ) {
	
					this.LODs[ l - 1 ].object3D.visible = false;
					this.LODs[ l     ].object3D.visible = true;
	
				} else {
	
					break;
	
				}
	
			}
	
			for( ; l < this.LODs.length; l ++ ) {
	
				this.LODs[ l ].object3D.visible = false;
	
			}
	
		}
	
	};
	
	THREE.LOD.prototype.clone = function () {
	
		// TODO
	
	};
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Sprite = function ( material ) {
	
		THREE.Object3D.call( this );
	
		this.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();
	
		this.rotation3d = this.rotation;
		this.rotation = 0;
	
	};
	
	THREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );
	
	/*
	 * Custom update matrix
	 */
	
	THREE.Sprite.prototype.updateMatrix = function () {
	
		this.matrix.setPosition( this.position );
	
		this.rotation3d.set( 0, 0, this.rotation );
		this.matrix.setRotationFromEuler( this.rotation3d );
	
		if ( this.scale.x !== 1 || this.scale.y !== 1 ) {
	
			this.matrix.scale( this.scale );
	
		}
	
		this.matrixWorldNeedsUpdate = true;
	
	};
	
	THREE.Sprite.prototype.clone = function ( object ) {
	
		if ( object === undefined ) object = new THREE.Sprite( this.material );
	
		THREE.Object3D.prototype.clone.call( this, object );
	
		return object;
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.Scene = function () {
	
		THREE.Object3D.call( this );
	
		this.fog = null;
		this.overrideMaterial = null;
	
		this.matrixAutoUpdate = false;
	
		this.__objects = [];
		this.__lights = [];
	
		this.__objectsAdded = [];
		this.__objectsRemoved = [];
	
	};
	
	THREE.Scene.prototype = Object.create( THREE.Object3D.prototype );
	
	THREE.Scene.prototype.__addObject = function ( object ) {
	
		if ( object instanceof THREE.Light ) {
	
			if ( this.__lights.indexOf( object ) === - 1 ) {
	
				this.__lights.push( object );
	
			}
	
			if ( object.target && object.target.parent === undefined ) {
	
				this.add( object.target );
	
			}
	
		} else if ( !( object instanceof THREE.Camera || object instanceof THREE.Bone ) ) {
	
			if ( this.__objects.indexOf( object ) === - 1 ) {
	
				this.__objects.push( object );
				this.__objectsAdded.push( object );
	
				// check if previously removed
	
				var i = this.__objectsRemoved.indexOf( object );
	
				if ( i !== -1 ) {
	
					this.__objectsRemoved.splice( i, 1 );
	
				}
	
			}
	
		}
	
		for ( var c = 0; c < object.children.length; c ++ ) {
	
			this.__addObject( object.children[ c ] );
	
		}
	
	};
	
	THREE.Scene.prototype.__removeObject = function ( object ) {
	
		if ( object instanceof THREE.Light ) {
	
			var i = this.__lights.indexOf( object );
	
			if ( i !== -1 ) {
	
				this.__lights.splice( i, 1 );
	
			}
	
		} else if ( !( object instanceof THREE.Camera ) ) {
	
			var i = this.__objects.indexOf( object );
	
			if( i !== -1 ) {
	
				this.__objects.splice( i, 1 );
				this.__objectsRemoved.push( object );
	
				// check if previously added
	
				var ai = this.__objectsAdded.indexOf( object );
	
				if ( ai !== -1 ) {
	
					this.__objectsAdded.splice( ai, 1 );
	
				}
	
			}
	
		}
	
		for ( var c = 0; c < object.children.length; c ++ ) {
	
			this.__removeObject( object.children[ c ] );
	
		}
	
	};
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Fog = function ( hex, near, far ) {
	
		this.name = '';
	
		this.color = new THREE.Color( hex );
	
		this.near = ( near !== undefined ) ? near : 1;
		this.far = ( far !== undefined ) ? far : 1000;
	
	};
	
	THREE.Fog.prototype.clone = function () {
	
		return new THREE.Fog( this.color.getHex(), this.near, this.far );
	
	};
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.FogExp2 = function ( hex, density ) {
	
		this.name = '';
		this.color = new THREE.Color( hex );
		this.density = ( density !== undefined ) ? density : 0.00025;
	
	};
	
	THREE.FogExp2.prototype.clone = function () {
	
		return new THREE.FogExp2( this.color.getHex(), this.density );
	
	};
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.CanvasRenderer = function ( parameters ) {
	
		console.log( 'THREE.CanvasRenderer', THREE.REVISION );
	
		var smoothstep = THREE.Math.smoothstep;
	
		parameters = parameters || {};
	
		var _this = this,
		_renderData, _elements, _lights,
		_projector = new THREE.Projector(),
	
		_canvas = parameters.canvas !== undefined
				? parameters.canvas
				: document.createElement( 'canvas' ),
	
		_canvasWidth, _canvasHeight, _canvasWidthHalf, _canvasHeightHalf,
		_context = _canvas.getContext( '2d' ),
	
		_clearColor = new THREE.Color( 0x000000 ),
		_clearOpacity = 0,
	
		_contextGlobalAlpha = 1,
		_contextGlobalCompositeOperation = 0,
		_contextStrokeStyle = null,
		_contextFillStyle = null,
		_contextLineWidth = null,
		_contextLineCap = null,
		_contextLineJoin = null,
		_contextDashSize = null,
		_contextGapSize = 0,
	
		_v1, _v2, _v3, _v4,
		_v5 = new THREE.RenderableVertex(),
		_v6 = new THREE.RenderableVertex(),
	
		_v1x, _v1y, _v2x, _v2y, _v3x, _v3y,
		_v4x, _v4y, _v5x, _v5y, _v6x, _v6y,
	
		_color = new THREE.Color(),
		_color1 = new THREE.Color(),
		_color2 = new THREE.Color(),
		_color3 = new THREE.Color(),
		_color4 = new THREE.Color(),
	
		_diffuseColor = new THREE.Color(),
		_emissiveColor = new THREE.Color(),
	
		_lightColor = new THREE.Color(),
	
		_patterns = {}, _imagedatas = {},
	
		_near, _far,
	
		_image, _uvs,
		_uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y,
	
		_clipBox = new THREE.Box2(),
		_clearBox = new THREE.Box2(),
		_elemBox = new THREE.Box2(),
	
		_enableLighting = false,
		_ambientLight = new THREE.Color(),
		_directionalLights = new THREE.Color(),
		_pointLights = new THREE.Color(),
	
		_vector3 = new THREE.Vector3(), // Needed for PointLight
	
		_pixelMap, _pixelMapContext, _pixelMapImage, _pixelMapData,
		_gradientMap, _gradientMapContext, _gradientMapQuality = 16;
	
		_pixelMap = document.createElement( 'canvas' );
		_pixelMap.width = _pixelMap.height = 2;
	
		_pixelMapContext = _pixelMap.getContext( '2d' );
		_pixelMapContext.fillStyle = 'rgba(0,0,0,1)';
		_pixelMapContext.fillRect( 0, 0, 2, 2 );
	
		_pixelMapImage = _pixelMapContext.getImageData( 0, 0, 2, 2 );
		_pixelMapData = _pixelMapImage.data;
	
		_gradientMap = document.createElement( 'canvas' );
		_gradientMap.width = _gradientMap.height = _gradientMapQuality;
	
		_gradientMapContext = _gradientMap.getContext( '2d' );
		_gradientMapContext.translate( - _gradientMapQuality / 2, - _gradientMapQuality / 2 );
		_gradientMapContext.scale( _gradientMapQuality, _gradientMapQuality );
	
		_gradientMapQuality --; // Fix UVs
	
		// dash+gap fallbacks for Firefox and everything else
	
		if ( _context.setLineDash === undefined ) {
	
			if ( _context.mozDash !== undefined ) {
	
				_context.setLineDash = function ( values ) {
	
					_context.mozDash = values[ 0 ] !== null ? values : null;
	
				}
	
			} else {
	
				_context.setLineDash = function () {}
	
			}
	
		}
	
		this.domElement = _canvas;
	
		this.devicePixelRatio = parameters.devicePixelRatio !== undefined
					? parameters.devicePixelRatio
					: window.devicePixelRatio !== undefined
						? window.devicePixelRatio
						: 1;
	
		this.autoClear = true;
		this.sortObjects = true;
		this.sortElements = true;
	
		this.info = {
	
			render: {
	
				vertices: 0,
				faces: 0
	
			}
	
		}
	
		// WebGLRenderer compatibility
	
		this.supportsVertexTextures = function () {};
		this.setFaceCulling = function () {};
	
		this.setSize = function ( width, height ) {
	
			_canvasWidth = width * this.devicePixelRatio;
			_canvasHeight = height * this.devicePixelRatio;
	
			_canvasWidthHalf = Math.floor( _canvasWidth / 2 );
			_canvasHeightHalf = Math.floor( _canvasHeight / 2 );
	
			_canvas.width = _canvasWidth;
			_canvas.height = _canvasHeight;
	
			_canvas.style.width = width + 'px';
			_canvas.style.height = height + 'px';
	
			_clipBox.set(
				new THREE.Vector2( - _canvasWidthHalf, - _canvasHeightHalf ),
				new THREE.Vector2( _canvasWidthHalf, _canvasHeightHalf )
			);
	
			_clearBox.set(
				new THREE.Vector2( - _canvasWidthHalf, - _canvasHeightHalf ),
				new THREE.Vector2( _canvasWidthHalf, _canvasHeightHalf )
			);
	
			_contextGlobalAlpha = 1;
			_contextGlobalCompositeOperation = 0;
			_contextStrokeStyle = null;
			_contextFillStyle = null;
			_contextLineWidth = null;
			_contextLineCap = null;
			_contextLineJoin = null;
	
		};
	
		this.setClearColor = function ( color, opacity ) {
	
			_clearColor.copy( color );
			_clearOpacity = opacity !== undefined ? opacity : 1;
	
			_clearBox.set(
				new THREE.Vector2( - _canvasWidthHalf, - _canvasHeightHalf ),
				new THREE.Vector2( _canvasWidthHalf, _canvasHeightHalf )
			);
	
		};
	
		this.setClearColorHex = function ( hex, opacity ) {
	
			_clearColor.setHex( hex );
			_clearOpacity = opacity !== undefined ? opacity : 1;
	
			_clearBox.set(
				new THREE.Vector2( - _canvasWidthHalf, - _canvasHeightHalf ),
				new THREE.Vector2( _canvasWidthHalf, _canvasHeightHalf )
			);
	
		};
	
		this.getMaxAnisotropy  = function () {
	
			return 0;
	
		};
	
		this.clear = function () {
	
			_context.setTransform( 1, 0, 0, - 1, _canvasWidthHalf, _canvasHeightHalf );
	
			if ( _clearBox.empty() === false ) {
	
				_clearBox.intersect( _clipBox );
				_clearBox.expandByScalar( 2 );
	
				if ( _clearOpacity < 1 ) {
	
					_context.clearRect(
						_clearBox.min.x | 0,
						_clearBox.min.y | 0,
						( _clearBox.max.x - _clearBox.min.x ) | 0,
						( _clearBox.max.y - _clearBox.min.y ) | 0
					);
	
				}
	
				if ( _clearOpacity > 0 ) {
	
					setBlending( THREE.NormalBlending );
					setOpacity( 1 );
	
					setFillStyle( 'rgba(' + Math.floor( _clearColor.r * 255 ) + ',' + Math.floor( _clearColor.g * 255 ) + ',' + Math.floor( _clearColor.b * 255 ) + ',' + _clearOpacity + ')' );
	
					_context.fillRect(
						_clearBox.min.x | 0,
						_clearBox.min.y | 0,
						( _clearBox.max.x - _clearBox.min.x ) | 0,
						( _clearBox.max.y - _clearBox.min.y ) | 0
					);
	
				}
	
				_clearBox.makeEmpty();
	
			}
	
	
		};
	
		this.render = function ( scene, camera ) {
	
			if ( camera instanceof THREE.Camera === false ) {
	
				console.error( 'THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera.' );
				return;
	
			}
	
			if ( this.autoClear === true ) {
	
				this.clear();
	
			}
	
			_context.setTransform( 1, 0, 0, - 1, _canvasWidthHalf, _canvasHeightHalf );
	
			_this.info.render.vertices = 0;
			_this.info.render.faces = 0;
	
			_renderData = _projector.projectScene( scene, camera, this.sortObjects, this.sortElements );
			_elements = _renderData.elements;
			_lights = _renderData.lights;
	
			/* DEBUG
			setFillStyle( 'rgba( 0, 255, 255, 0.5 )' );
			_context.fillRect( _clipBox.min.x, _clipBox.min.y, _clipBox.max.x - _clipBox.min.x, _clipBox.max.y - _clipBox.min.y );
			*/
	
			_enableLighting = _lights.length > 0;
	
			if ( _enableLighting === true ) {
	
				 calculateLights();
	
			}
	
			for ( var e = 0, el = _elements.length; e < el; e++ ) {
	
				var element = _elements[ e ];
	
				var material = element.material;
	
				if ( material === undefined || material.visible === false ) continue;
	
				_elemBox.makeEmpty();
	
				if ( element instanceof THREE.RenderableParticle ) {
	
					_v1 = element;
					_v1.x *= _canvasWidthHalf; _v1.y *= _canvasHeightHalf;
	
					renderParticle( _v1, element, material );
	
				} else if ( element instanceof THREE.RenderableLine ) {
	
					_v1 = element.v1; _v2 = element.v2;
	
					_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;
					_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;
	
					_elemBox.setFromPoints( [ _v1.positionScreen, _v2.positionScreen ] );
	
					if ( _clipBox.isIntersectionBox( _elemBox ) === true ) {
	
						renderLine( _v1, _v2, element, material );
	
					}
	
				} else if ( element instanceof THREE.RenderableFace3 ) {
	
					_v1 = element.v1; _v2 = element.v2; _v3 = element.v3;
	
					if ( _v1.positionScreen.z < -1 || _v1.positionScreen.z > 1 ) continue;
					if ( _v2.positionScreen.z < -1 || _v2.positionScreen.z > 1 ) continue;
					if ( _v3.positionScreen.z < -1 || _v3.positionScreen.z > 1 ) continue;
	
					_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;
					_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;
					_v3.positionScreen.x *= _canvasWidthHalf; _v3.positionScreen.y *= _canvasHeightHalf;
	
					if ( material.overdraw === true ) {
	
						expand( _v1.positionScreen, _v2.positionScreen );
						expand( _v2.positionScreen, _v3.positionScreen );
						expand( _v3.positionScreen, _v1.positionScreen );
	
					}
	
					_elemBox.setFromPoints( [ _v1.positionScreen, _v2.positionScreen, _v3.positionScreen ] );
	
					renderFace3( _v1, _v2, _v3, 0, 1, 2, element, material );
	
				} else if ( element instanceof THREE.RenderableFace4 ) {
	
					_v1 = element.v1; _v2 = element.v2; _v3 = element.v3; _v4 = element.v4;
	
					if ( _v1.positionScreen.z < -1 || _v1.positionScreen.z > 1 ) continue;
					if ( _v2.positionScreen.z < -1 || _v2.positionScreen.z > 1 ) continue;
					if ( _v3.positionScreen.z < -1 || _v3.positionScreen.z > 1 ) continue;
					if ( _v4.positionScreen.z < -1 || _v4.positionScreen.z > 1 ) continue;
	
					_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;
					_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;
					_v3.positionScreen.x *= _canvasWidthHalf; _v3.positionScreen.y *= _canvasHeightHalf;
					_v4.positionScreen.x *= _canvasWidthHalf; _v4.positionScreen.y *= _canvasHeightHalf;
	
					_v5.positionScreen.copy( _v2.positionScreen );
					_v6.positionScreen.copy( _v4.positionScreen );
	
					if ( material.overdraw === true ) {
	
						expand( _v1.positionScreen, _v2.positionScreen );
						expand( _v2.positionScreen, _v4.positionScreen );
						expand( _v4.positionScreen, _v1.positionScreen );
	
						expand( _v3.positionScreen, _v5.positionScreen );
						expand( _v3.positionScreen, _v6.positionScreen );
	
					}
	
					_elemBox.setFromPoints( [ _v1.positionScreen, _v2.positionScreen, _v3.positionScreen, _v4.positionScreen ] );
	
					renderFace4( _v1, _v2, _v3, _v4, _v5, _v6, element, material, scene );
	
				}
	
				/* DEBUG
				setLineWidth( 1 );
				setStrokeStyle( 'rgba( 0, 255, 0, 0.5 )' );
				_context.strokeRect( _elemBox.min.x, _elemBox.min.y, _elemBox.max.x - _elemBox.min.x, _elemBox.max.y - _elemBox.min.y );
				*/
	
				_clearBox.union( _elemBox );
	
			}
	
			/* DEBUG
			setLineWidth( 1 );
			setStrokeStyle( 'rgba( 255, 0, 0, 0.5 )' );
			_context.strokeRect( _clearBox.min.x, _clearBox.min.y, _clearBox.max.x - _clearBox.min.x, _clearBox.max.y - _clearBox.min.y );
			*/
	
			_context.setTransform( 1, 0, 0, 1, 0, 0 );
	
			//
	
			function calculateLights() {
	
				_ambientLight.setRGB( 0, 0, 0 );
				_directionalLights.setRGB( 0, 0, 0 );
				_pointLights.setRGB( 0, 0, 0 );
	
				for ( var l = 0, ll = _lights.length; l < ll; l ++ ) {
	
					var light = _lights[ l ];
					var lightColor = light.color;
	
					if ( light instanceof THREE.AmbientLight ) {
	
						_ambientLight.add( lightColor );
	
					} else if ( light instanceof THREE.DirectionalLight ) {
	
						// for particles
	
						_directionalLights.add( lightColor );
	
					} else if ( light instanceof THREE.PointLight ) {
	
						// for particles
	
						_pointLights.add( lightColor );
	
					}
	
				}
	
			}
	
			function calculateLight( position, normal, color ) {
	
				for ( var l = 0, ll = _lights.length; l < ll; l ++ ) {
	
					var light = _lights[ l ];
	
					_lightColor.copy( light.color );
	
					if ( light instanceof THREE.DirectionalLight ) {
	
						var lightPosition = _vector3.getPositionFromMatrix( light.matrixWorld ).normalize();
	
						var amount = normal.dot( lightPosition );
	
						if ( amount <= 0 ) continue;
	
						amount *= light.intensity;
	
						color.add( _lightColor.multiplyScalar( amount ) );
	
					} else if ( light instanceof THREE.PointLight ) {
	
						var lightPosition = _vector3.getPositionFromMatrix( light.matrixWorld );
	
						var amount = normal.dot( _vector3.subVectors( lightPosition, position ).normalize() );
	
						if ( amount <= 0 ) continue;
	
						amount *= light.distance == 0 ? 1 : 1 - Math.min( position.distanceTo( lightPosition ) / light.distance, 1 );
	
						if ( amount == 0 ) continue;
	
						amount *= light.intensity;
	
						color.add( _lightColor.multiplyScalar( amount ) );
	
					}
	
				}
	
			}
	
			function renderParticle( v1, element, material ) {
	
				setOpacity( material.opacity );
				setBlending( material.blending );
	
				var width, height, scaleX, scaleY,
				bitmap, bitmapWidth, bitmapHeight;
	
				if ( material instanceof THREE.ParticleBasicMaterial ) {
	
					if ( material.map === null ) {
	
						scaleX = element.object.scale.x;
						scaleY = element.object.scale.y;
	
						// TODO: Be able to disable this
	
						scaleX *= element.scale.x * _canvasWidthHalf;
						scaleY *= element.scale.y * _canvasHeightHalf;
	
						_elemBox.min.set( v1.x - scaleX, v1.y - scaleY );
						_elemBox.max.set( v1.x + scaleX, v1.y + scaleY );
	
						if ( _clipBox.isIntersectionBox( _elemBox ) === false ) {
	
							return;
	
						}
	
						setFillStyle( material.color.getStyle() );
	
						_context.save();
						_context.translate( v1.x, v1.y );
						_context.rotate( - element.rotation );
						_context.scale( scaleX, scaleY );
						_context.fillRect( -1, -1, 2, 2 );
						_context.restore();
	
					} else {
	
						bitmap = material.map.image;
						bitmapWidth = bitmap.width >> 1;
						bitmapHeight = bitmap.height >> 1;
	
						scaleX = element.scale.x * _canvasWidthHalf;
						scaleY = element.scale.y * _canvasHeightHalf;
	
						width = scaleX * bitmapWidth;
						height = scaleY * bitmapHeight;
	
						// TODO: Rotations break this...
	
						_elemBox.min.set( v1.x - width, v1.y - height );
						_elemBox.max.set( v1.x + width, v1.y + height );
	
						if ( _clipBox.isIntersectionBox( _elemBox ) === false ) {
	
							return;
	
						}
	
						_context.save();
						_context.translate( v1.x, v1.y );
						_context.rotate( - element.rotation );
						_context.scale( scaleX, - scaleY );
	
						_context.translate( - bitmapWidth, - bitmapHeight );
						_context.drawImage( bitmap, 0, 0 );
						_context.restore();
	
					}
	
					/* DEBUG
					setStrokeStyle( 'rgb(255,255,0)' );
					_context.beginPath();
					_context.moveTo( v1.x - 10, v1.y );
					_context.lineTo( v1.x + 10, v1.y );
					_context.moveTo( v1.x, v1.y - 10 );
					_context.lineTo( v1.x, v1.y + 10 );
					_context.stroke();
					*/
	
				} else if ( material instanceof THREE.ParticleCanvasMaterial ) {
	
					width = element.scale.x * _canvasWidthHalf;
					height = element.scale.y * _canvasHeightHalf;
	
					_elemBox.min.set( v1.x - width, v1.y - height );
					_elemBox.max.set( v1.x + width, v1.y + height );
	
					if ( _clipBox.isIntersectionBox( _elemBox ) === false ) {
	
						return;
	
					}
	
					setStrokeStyle( material.color.getStyle() );
					setFillStyle( material.color.getStyle() );
	
					_context.save();
					_context.translate( v1.x, v1.y );
					_context.rotate( - element.rotation );
					_context.scale( width, height );
	
					material.program( _context );
	
					_context.restore();
	
				}
	
			}
	
			function renderLine( v1, v2, element, material ) {
	
				setOpacity( material.opacity );
				setBlending( material.blending );
	
				_context.beginPath();
				_context.moveTo( v1.positionScreen.x, v1.positionScreen.y );
				_context.lineTo( v2.positionScreen.x, v2.positionScreen.y );
	
				if ( material instanceof THREE.LineBasicMaterial ) {
	
					setLineWidth( material.linewidth );
					setLineCap( material.linecap );
					setLineJoin( material.linejoin );
					setStrokeStyle( material.color.getStyle() );
					setDashAndGap( null, null );
	
					_context.stroke();
					_elemBox.expandByScalar( material.linewidth * 2 );
	
				} else if ( material instanceof THREE.LineDashedMaterial ) {
	
					setLineWidth( material.linewidth );
					setLineCap( material.linecap );
					setLineJoin( material.linejoin );
					setStrokeStyle( material.color.getStyle() );
					setDashAndGap( material.dashSize, material.gapSize );
	
					_context.stroke();
					_elemBox.expandByScalar( material.linewidth * 2 );
	
				}
	
			}
	
			function renderFace3( v1, v2, v3, uv1, uv2, uv3, element, material ) {
	
				_this.info.render.vertices += 3;
				_this.info.render.faces ++;
	
				setOpacity( material.opacity );
				setBlending( material.blending );
	
				_v1x = v1.positionScreen.x; _v1y = v1.positionScreen.y;
				_v2x = v2.positionScreen.x; _v2y = v2.positionScreen.y;
				_v3x = v3.positionScreen.x; _v3y = v3.positionScreen.y;
	
				drawTriangle( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y );
	
				if ( ( material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial ) && material.map === null ) {
	
					_diffuseColor.copy( material.color );
					_emissiveColor.copy( material.emissive );
	
					if ( material.vertexColors === THREE.FaceColors ) {
	
						_diffuseColor.multiply( element.color );
	
					}
	
					if ( _enableLighting === true ) {
	
						if ( material.wireframe === false && material.shading == THREE.SmoothShading && element.vertexNormalsLength == 3 ) {
	
							_color1.copy( _ambientLight );
							_color2.copy( _ambientLight );
							_color3.copy( _ambientLight );
	
							calculateLight( element.v1.positionWorld, element.vertexNormalsModel[ 0 ], _color1 );
							calculateLight( element.v2.positionWorld, element.vertexNormalsModel[ 1 ], _color2 );
							calculateLight( element.v3.positionWorld, element.vertexNormalsModel[ 2 ], _color3 );
	
							_color1.multiply( _diffuseColor ).add( _emissiveColor );
							_color2.multiply( _diffuseColor ).add( _emissiveColor );
							_color3.multiply( _diffuseColor ).add( _emissiveColor );
							_color4.addColors( _color2, _color3 ).multiplyScalar( 0.5 );
	
							_image = getGradientTexture( _color1, _color2, _color3, _color4 );
	
							clipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );
	
						} else {
	
							_color.copy( _ambientLight );
	
							calculateLight( element.centroidModel, element.normalModel, _color );
	
							_color.multiply( _diffuseColor ).add( _emissiveColor );
	
							material.wireframe === true
								? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )
								: fillPath( _color );
	
						}
	
					} else {
	
						material.wireframe === true
							? strokePath( material.color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )
							: fillPath( material.color );
	
					}
	
				} else if ( material instanceof THREE.MeshBasicMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial ) {
	
					if ( material.map !== null ) {
	
						if ( material.map.mapping instanceof THREE.UVMapping ) {
	
							_uvs = element.uvs[ 0 ];
							patternPath( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uvs[ uv1 ].x, _uvs[ uv1 ].y, _uvs[ uv2 ].x, _uvs[ uv2 ].y, _uvs[ uv3 ].x, _uvs[ uv3 ].y, material.map );
	
						}
	
	
					} else if ( material.envMap !== null ) {
	
						if ( material.envMap.mapping instanceof THREE.SphericalReflectionMapping ) {
	
							_vector3.copy( element.vertexNormalsModelView[ uv1 ] );
							_uv1x = 0.5 * _vector3.x + 0.5;
							_uv1y = 0.5 * _vector3.y + 0.5;
	
							_vector3.copy( element.vertexNormalsModelView[ uv2 ] );
							_uv2x = 0.5 * _vector3.x + 0.5;
							_uv2y = 0.5 * _vector3.y + 0.5;
	
							_vector3.copy( element.vertexNormalsModelView[ uv3 ] );
							_uv3x = 0.5 * _vector3.x + 0.5;
							_uv3y = 0.5 * _vector3.y + 0.5;
	
							patternPath( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y, material.envMap );
	
						}/* else if ( material.envMap.mapping == THREE.SphericalRefractionMapping ) {
	
	
	
						}*/
	
	
					} else {
	
						_color.copy( material.color );
	
						if ( material.vertexColors === THREE.FaceColors ) {
	
							_color.multiply( element.color );
	
						}
	
						material.wireframe === true
							? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )
							: fillPath( _color );
	
					}
	
				} else if ( material instanceof THREE.MeshDepthMaterial ) {
	
					_near = camera.near;
					_far = camera.far;
	
					_color1.r = _color1.g = _color1.b = 1 - smoothstep( v1.positionScreen.z * v1.positionScreen.w, _near, _far );
					_color2.r = _color2.g = _color2.b = 1 - smoothstep( v2.positionScreen.z * v2.positionScreen.w, _near, _far );
					_color3.r = _color3.g = _color3.b = 1 - smoothstep( v3.positionScreen.z * v3.positionScreen.w, _near, _far );
					_color4.addColors( _color2, _color3 ).multiplyScalar( 0.5 );
	
					_image = getGradientTexture( _color1, _color2, _color3, _color4 );
	
					clipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );
	
				} else if ( material instanceof THREE.MeshNormalMaterial ) {
	
					var normal;
	
					if ( material.shading == THREE.FlatShading ) {
	
						normal = element.normalModelView;
	
						_color.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );
	
						material.wireframe === true
							? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )
							: fillPath( _color );
	
					} else if ( material.shading == THREE.SmoothShading ) {
	
						normal = element.vertexNormalsModelView[ uv1 ];
						_color1.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );
	
						normal = element.vertexNormalsModelView[ uv2 ];
						_color2.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );
	
						normal = element.vertexNormalsModelView[ uv3 ];
						_color3.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );
	
						_color4.addColors( _color2, _color3 ).multiplyScalar( 0.5 );
	
						_image = getGradientTexture( _color1, _color2, _color3, _color4 );
	
						clipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );
	
					}
	
				}
	
			}
	
			function renderFace4( v1, v2, v3, v4, v5, v6, element, material ) {
	
				_this.info.render.vertices += 4;
				_this.info.render.faces ++;
	
				setOpacity( material.opacity );
				setBlending( material.blending );
	
				if ( ( material.map !== undefined && material.map !== null ) || ( material.envMap !== undefined && material.envMap !== null ) ) {
	
					// Let renderFace3() handle this
	
					renderFace3( v1, v2, v4, 0, 1, 3, element, material );
					renderFace3( v5, v3, v6, 1, 2, 3, element, material );
	
					return;
	
				}
	
				_v1x = v1.positionScreen.x; _v1y = v1.positionScreen.y;
				_v2x = v2.positionScreen.x; _v2y = v2.positionScreen.y;
				_v3x = v3.positionScreen.x; _v3y = v3.positionScreen.y;
				_v4x = v4.positionScreen.x; _v4y = v4.positionScreen.y;
				_v5x = v5.positionScreen.x; _v5y = v5.positionScreen.y;
				_v6x = v6.positionScreen.x; _v6y = v6.positionScreen.y;
	
				if ( material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial ) {
	
					_diffuseColor.copy( material.color );
					_emissiveColor.copy( material.emissive );
	
					if ( material.vertexColors === THREE.FaceColors ) {
	
						_diffuseColor.multiply( element.color );
	
					}
	
					if ( _enableLighting === true ) {
	
						if ( material.wireframe === false && material.shading == THREE.SmoothShading && element.vertexNormalsLength == 4 ) {
	
							_color1.copy( _ambientLight );
							_color2.copy( _ambientLight );
							_color3.copy( _ambientLight );
							_color4.copy( _ambientLight );
	
							calculateLight( element.v1.positionWorld, element.vertexNormalsModel[ 0 ], _color1 );
							calculateLight( element.v2.positionWorld, element.vertexNormalsModel[ 1 ], _color2 );
							calculateLight( element.v4.positionWorld, element.vertexNormalsModel[ 3 ], _color3 );
							calculateLight( element.v3.positionWorld, element.vertexNormalsModel[ 2 ], _color4 );
	
							_color1.multiply( _diffuseColor ).add( _emissiveColor );
							_color2.multiply( _diffuseColor ).add( _emissiveColor );
							_color3.multiply( _diffuseColor ).add( _emissiveColor );
							_color4.multiply( _diffuseColor ).add( _emissiveColor );
	
							_image = getGradientTexture( _color1, _color2, _color3, _color4 );
	
							// TODO: UVs are incorrect, v4->v3?
	
							drawTriangle( _v1x, _v1y, _v2x, _v2y, _v4x, _v4y );
							clipImage( _v1x, _v1y, _v2x, _v2y, _v4x, _v4y, 0, 0, 1, 0, 0, 1, _image );
	
							drawTriangle( _v5x, _v5y, _v3x, _v3y, _v6x, _v6y );
							clipImage( _v5x, _v5y, _v3x, _v3y, _v6x, _v6y, 1, 0, 1, 1, 0, 1, _image );
	
						} else {
	
							_color.copy( _ambientLight );
	
							calculateLight( element.centroidModel, element.normalModel, _color );
	
							_color.multiply( _diffuseColor ).add( _emissiveColor );
	
							drawQuad( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _v4x, _v4y );
	
							material.wireframe === true
								? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )
								: fillPath( _color );
	
						}
	
					} else {
	
						_color.addColors( _diffuseColor, _emissiveColor );
	
						drawQuad( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _v4x, _v4y );
	
						material.wireframe === true
							? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )
							: fillPath( _color );
	
					}
	
				} else if ( material instanceof THREE.MeshBasicMaterial ) {
	
					_color.copy( material.color );
	
					if ( material.vertexColors === THREE.FaceColors ) {
	
						_color.multiply( element.color );
	
					}
	
					drawQuad( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _v4x, _v4y );
	
					material.wireframe === true
						? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )
						: fillPath( _color );
	
				} else if ( material instanceof THREE.MeshNormalMaterial ) {
	
					var normal;
	
					if ( material.shading == THREE.FlatShading ) {
	
						normal = element.normalModelView;
						_color.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );
	
						drawQuad( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _v4x, _v4y );
	
						material.wireframe === true
							? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )
							: fillPath( _color );
	
					} else if ( material.shading == THREE.SmoothShading ) {
	
						normal = element.vertexNormalsModelView[ 0 ];
						_color1.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );
	
						normal = element.vertexNormalsModelView[ 1 ];
						_color2.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );
	
						normal = element.vertexNormalsModelView[ 3 ];
						_color3.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );
	
						normal = element.vertexNormalsModelView[ 2 ];
						_color4.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );
	
						_image = getGradientTexture( _color1, _color2, _color3, _color4 );
	
						drawTriangle( _v1x, _v1y, _v2x, _v2y, _v4x, _v4y );
						clipImage( _v1x, _v1y, _v2x, _v2y, _v4x, _v4y, 0, 0, 1, 0, 0, 1, _image );
	
						drawTriangle( _v5x, _v5y, _v3x, _v3y, _v6x, _v6y );
						clipImage( _v5x, _v5y, _v3x, _v3y, _v6x, _v6y, 1, 0, 1, 1, 0, 1, _image );
	
					}
	
	
	
				} else if ( material instanceof THREE.MeshDepthMaterial ) {
	
					_near = camera.near;
					_far = camera.far;
	
					_color1.r = _color1.g = _color1.b = 1 - smoothstep( v1.positionScreen.z * v1.positionScreen.w, _near, _far );
					_color2.r = _color2.g = _color2.b = 1 - smoothstep( v2.positionScreen.z * v2.positionScreen.w, _near, _far );
					_color3.r = _color3.g = _color3.b = 1 - smoothstep( v4.positionScreen.z * v4.positionScreen.w, _near, _far );
					_color4.r = _color4.g = _color4.b = 1 - smoothstep( v3.positionScreen.z * v3.positionScreen.w, _near, _far );
	
					_image = getGradientTexture( _color1, _color2, _color3, _color4 );
	
					// TODO: UVs are incorrect, v4->v3?
	
					drawTriangle( _v1x, _v1y, _v2x, _v2y, _v4x, _v4y );
					clipImage( _v1x, _v1y, _v2x, _v2y, _v4x, _v4y, 0, 0, 1, 0, 0, 1, _image );
	
					drawTriangle( _v5x, _v5y, _v3x, _v3y, _v6x, _v6y );
					clipImage( _v5x, _v5y, _v3x, _v3y, _v6x, _v6y, 1, 0, 1, 1, 0, 1, _image );
	
				}
	
			}
	
			//
	
			function drawTriangle( x0, y0, x1, y1, x2, y2 ) {
	
				_context.beginPath();
				_context.moveTo( x0, y0 );
				_context.lineTo( x1, y1 );
				_context.lineTo( x2, y2 );
				_context.closePath();
	
			}
	
			function drawQuad( x0, y0, x1, y1, x2, y2, x3, y3 ) {
	
				_context.beginPath();
				_context.moveTo( x0, y0 );
				_context.lineTo( x1, y1 );
				_context.lineTo( x2, y2 );
				_context.lineTo( x3, y3 );
				_context.closePath();
	
			}
	
			function strokePath( color, linewidth, linecap, linejoin ) {
	
				setLineWidth( linewidth );
				setLineCap( linecap );
				setLineJoin( linejoin );
				setStrokeStyle( color.getStyle() );
	
				_context.stroke();
	
				_elemBox.expandByScalar( linewidth * 2 );
	
			}
	
			function fillPath( color ) {
	
				setFillStyle( color.getStyle() );
				_context.fill();
	
			}
	
			function patternPath( x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, texture ) {
	
				if ( texture instanceof THREE.DataTexture || texture.image === undefined || texture.image.width == 0 ) return;
	
				if ( texture.needsUpdate === true ) {
	
					var repeatX = texture.wrapS == THREE.RepeatWrapping;
					var repeatY = texture.wrapT == THREE.RepeatWrapping;
	
					_patterns[ texture.id ] = _context.createPattern(
						texture.image, repeatX === true && repeatY === true
							? 'repeat'
							: repeatX === true && repeatY === false
								? 'repeat-x'
								: repeatX === false && repeatY === true
									? 'repeat-y'
									: 'no-repeat'
					);
	
					texture.needsUpdate = false;
	
				}
	
				_patterns[ texture.id ] === undefined
					? setFillStyle( 'rgba(0,0,0,1)' )
					: setFillStyle( _patterns[ texture.id ] );
	
				// http://extremelysatisfactorytotalitarianism.com/blog/?p=2120
	
				var a, b, c, d, e, f, det, idet,
				offsetX = texture.offset.x / texture.repeat.x,
				offsetY = texture.offset.y / texture.repeat.y,
				width = texture.image.width * texture.repeat.x,
				height = texture.image.height * texture.repeat.y;
	
				u0 = ( u0 + offsetX ) * width;
				v0 = ( 1.0 - v0 + offsetY ) * height;
	
				u1 = ( u1 + offsetX ) * width;
				v1 = ( 1.0 - v1 + offsetY ) * height;
	
				u2 = ( u2 + offsetX ) * width;
				v2 = ( 1.0 - v2 + offsetY ) * height;
	
				x1 -= x0; y1 -= y0;
				x2 -= x0; y2 -= y0;
	
				u1 -= u0; v1 -= v0;
				u2 -= u0; v2 -= v0;
	
				det = u1 * v2 - u2 * v1;
	
				if ( det === 0 ) {
	
					if ( _imagedatas[ texture.id ] === undefined ) {
	
						var canvas = document.createElement( 'canvas' )
						canvas.width = texture.image.width;
						canvas.height = texture.image.height;
	
						var context = canvas.getContext( '2d' );
						context.drawImage( texture.image, 0, 0 );
	
						_imagedatas[ texture.id ] = context.getImageData( 0, 0, texture.image.width, texture.image.height ).data;
	
					}
	
					var data = _imagedatas[ texture.id ];
					var index = ( Math.floor( u0 ) + Math.floor( v0 ) * texture.image.width ) * 4;
	
					_color.setRGB( data[ index ] / 255, data[ index + 1 ] / 255, data[ index + 2 ] / 255 );
					fillPath( _color );
	
					return;
	
				}
	
				idet = 1 / det;
	
				a = ( v2 * x1 - v1 * x2 ) * idet;
				b = ( v2 * y1 - v1 * y2 ) * idet;
				c = ( u1 * x2 - u2 * x1 ) * idet;
				d = ( u1 * y2 - u2 * y1 ) * idet;
	
				e = x0 - a * u0 - c * v0;
				f = y0 - b * u0 - d * v0;
	
				_context.save();
				_context.transform( a, b, c, d, e, f );
				_context.fill();
				_context.restore();
	
			}
	
			function clipImage( x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, image ) {
	
				// http://extremelysatisfactorytotalitarianism.com/blog/?p=2120
	
				var a, b, c, d, e, f, det, idet,
				width = image.width - 1,
				height = image.height - 1;
	
				u0 *= width; v0 *= height;
				u1 *= width; v1 *= height;
				u2 *= width; v2 *= height;
	
				x1 -= x0; y1 -= y0;
				x2 -= x0; y2 -= y0;
	
				u1 -= u0; v1 -= v0;
				u2 -= u0; v2 -= v0;
	
				det = u1 * v2 - u2 * v1;
	
				idet = 1 / det;
	
				a = ( v2 * x1 - v1 * x2 ) * idet;
				b = ( v2 * y1 - v1 * y2 ) * idet;
				c = ( u1 * x2 - u2 * x1 ) * idet;
				d = ( u1 * y2 - u2 * y1 ) * idet;
	
				e = x0 - a * u0 - c * v0;
				f = y0 - b * u0 - d * v0;
	
				_context.save();
				_context.transform( a, b, c, d, e, f );
				_context.clip();
				_context.drawImage( image, 0, 0 );
				_context.restore();
	
			}
	
			function getGradientTexture( color1, color2, color3, color4 ) {
	
				// http://mrdoob.com/blog/post/710
	
				_pixelMapData[ 0 ] = ( color1.r * 255 ) | 0;
				_pixelMapData[ 1 ] = ( color1.g * 255 ) | 0;
				_pixelMapData[ 2 ] = ( color1.b * 255 ) | 0;
	
				_pixelMapData[ 4 ] = ( color2.r * 255 ) | 0;
				_pixelMapData[ 5 ] = ( color2.g * 255 ) | 0;
				_pixelMapData[ 6 ] = ( color2.b * 255 ) | 0;
	
				_pixelMapData[ 8 ] = ( color3.r * 255 ) | 0;
				_pixelMapData[ 9 ] = ( color3.g * 255 ) | 0;
				_pixelMapData[ 10 ] = ( color3.b * 255 ) | 0;
	
				_pixelMapData[ 12 ] = ( color4.r * 255 ) | 0;
				_pixelMapData[ 13 ] = ( color4.g * 255 ) | 0;
				_pixelMapData[ 14 ] = ( color4.b * 255 ) | 0;
	
				_pixelMapContext.putImageData( _pixelMapImage, 0, 0 );
				_gradientMapContext.drawImage( _pixelMap, 0, 0 );
	
				return _gradientMap;
	
			}
	
			// Hide anti-alias gaps
	
			function expand( v1, v2 ) {
	
				var x = v2.x - v1.x, y =  v2.y - v1.y,
				det = x * x + y * y, idet;
	
				if ( det === 0 ) return;
	
				idet = 1 / Math.sqrt( det );
	
				x *= idet; y *= idet;
	
				v2.x += x; v2.y += y;
				v1.x -= x; v1.y -= y;
	
			}
		};
	
		// Context cached methods.
	
		function setOpacity( value ) {
	
			if ( _contextGlobalAlpha !== value ) {
	
				_context.globalAlpha = value;
				_contextGlobalAlpha = value;
	
			}
	
		}
	
		function setBlending( value ) {
	
			if ( _contextGlobalCompositeOperation !== value ) {
	
				if ( value === THREE.NormalBlending ) {
	
					_context.globalCompositeOperation = 'source-over';
	
				} else if ( value === THREE.AdditiveBlending ) {
	
					_context.globalCompositeOperation = 'lighter';
	
				} else if ( value === THREE.SubtractiveBlending ) {
	
					_context.globalCompositeOperation = 'darker';
	
				}
	
				_contextGlobalCompositeOperation = value;
	
			}
	
		}
	
		function setLineWidth( value ) {
	
			if ( _contextLineWidth !== value ) {
	
				_context.lineWidth = value;
				_contextLineWidth = value;
	
			}
	
		}
	
		function setLineCap( value ) {
	
			// "butt", "round", "square"
	
			if ( _contextLineCap !== value ) {
	
				_context.lineCap = value;
				_contextLineCap = value;
	
			}
	
		}
	
		function setLineJoin( value ) {
	
			// "round", "bevel", "miter"
	
			if ( _contextLineJoin !== value ) {
	
				_context.lineJoin = value;
				_contextLineJoin = value;
	
			}
	
		}
	
		function setStrokeStyle( value ) {
	
			if ( _contextStrokeStyle !== value ) {
	
				_context.strokeStyle = value;
				_contextStrokeStyle = value;
	
			}
	
		}
	
		function setFillStyle( value ) {
	
			if ( _contextFillStyle !== value ) {
	
				_context.fillStyle = value;
				_contextFillStyle = value;
	
			}
	
		}
	
		function setDashAndGap( dashSizeValue, gapSizeValue ) {
	
			if ( _contextDashSize !== dashSizeValue || _contextGapSize !== gapSizeValue ) {
	
				_context.setLineDash( [ dashSizeValue, gapSizeValue ] );
				_contextDashSize = dashSizeValue;
				_contextGapSize = gapSizeValue;
	
			}
	
		}
	
	};
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 */
	
	THREE.ShaderChunk = {
	
		// FOG
	
		fog_pars_fragment: [
	
			"#ifdef USE_FOG",
	
				"uniform vec3 fogColor;",
	
				"#ifdef FOG_EXP2",
	
					"uniform float fogDensity;",
	
				"#else",
	
					"uniform float fogNear;",
					"uniform float fogFar;",
	
				"#endif",
	
			"#endif"
	
		].join("\n"),
	
		fog_fragment: [
	
			"#ifdef USE_FOG",
	
				"float depth = gl_FragCoord.z / gl_FragCoord.w;",
	
				"#ifdef FOG_EXP2",
	
					"const float LOG2 = 1.442695;",
					"float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );",
					"fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );",
	
				"#else",
	
					"float fogFactor = smoothstep( fogNear, fogFar, depth );",
	
				"#endif",
	
				"gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );",
	
			"#endif"
	
		].join("\n"),
	
		// ENVIRONMENT MAP
	
		envmap_pars_fragment: [
	
			"#ifdef USE_ENVMAP",
	
				"uniform float reflectivity;",
				"uniform samplerCube envMap;",
				"uniform float flipEnvMap;",
				"uniform int combine;",
	
				"#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )",
	
					"uniform bool useRefract;",
					"uniform float refractionRatio;",
	
				"#else",
	
					"varying vec3 vReflect;",
	
				"#endif",
	
			"#endif"
	
		].join("\n"),
	
		envmap_fragment: [
	
			"#ifdef USE_ENVMAP",
	
				"vec3 reflectVec;",
	
				"#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )",
	
					"vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );",
	
					"if ( useRefract ) {",
	
						"reflectVec = refract( cameraToVertex, normal, refractionRatio );",
	
					"} else { ",
	
						"reflectVec = reflect( cameraToVertex, normal );",
	
					"}",
	
				"#else",
	
					"reflectVec = vReflect;",
	
				"#endif",
	
				"#ifdef DOUBLE_SIDED",
	
					"float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );",
					"vec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );",
	
				"#else",
	
					"vec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );",
	
				"#endif",
	
				"#ifdef GAMMA_INPUT",
	
					"cubeColor.xyz *= cubeColor.xyz;",
	
				"#endif",
	
				"if ( combine == 1 ) {",
	
					"gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );",
	
				"} else if ( combine == 2 ) {",
	
					"gl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;",
	
				"} else {",
	
					"gl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );",
	
				"}",
	
			"#endif"
	
		].join("\n"),
	
		envmap_pars_vertex: [
	
			"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )",
	
				"varying vec3 vReflect;",
	
				"uniform float refractionRatio;",
				"uniform bool useRefract;",
	
			"#endif"
	
		].join("\n"),
	
		worldpos_vertex : [
	
			"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )",
	
				"#ifdef USE_SKINNING",
	
					"vec4 worldPosition = modelMatrix * skinned;",
	
				"#endif",
	
				"#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )",
	
					"vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );",
	
				"#endif",
	
				"#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )",
	
					"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
	
				"#endif",
	
			"#endif"
	
		].join("\n"),
	
		envmap_vertex : [
	
			"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )",
	
				"vec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;",
				"worldNormal = normalize( worldNormal );",
	
				"vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );",
	
				"if ( useRefract ) {",
	
					"vReflect = refract( cameraToVertex, worldNormal, refractionRatio );",
	
				"} else {",
	
					"vReflect = reflect( cameraToVertex, worldNormal );",
	
				"}",
	
			"#endif"
	
		].join("\n"),
	
		// COLOR MAP (particles)
	
		map_particle_pars_fragment: [
	
			"#ifdef USE_MAP",
	
				"uniform sampler2D map;",
	
			"#endif"
	
		].join("\n"),
	
	
		map_particle_fragment: [
	
			"#ifdef USE_MAP",
	
				"gl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );",
	
			"#endif"
	
		].join("\n"),
	
		// COLOR MAP (triangles)
	
		map_pars_vertex: [
	
			"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )",
	
				"varying vec2 vUv;",
				"uniform vec4 offsetRepeat;",
	
			"#endif"
	
		].join("\n"),
	
		map_pars_fragment: [
	
			"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )",
	
				"varying vec2 vUv;",
	
			"#endif",
	
			"#ifdef USE_MAP",
	
				"uniform sampler2D map;",
	
			"#endif"
	
		].join("\n"),
	
		map_vertex: [
	
			"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )",
	
				"vUv = uv * offsetRepeat.zw + offsetRepeat.xy;",
	
			"#endif"
	
		].join("\n"),
	
		map_fragment: [
	
			"#ifdef USE_MAP",
	
				"vec4 texelColor = texture2D( map, vUv );",
	
				"#ifdef GAMMA_INPUT",
	
					"texelColor.xyz *= texelColor.xyz;",
	
				"#endif",
	
				"gl_FragColor = gl_FragColor * texelColor;",
	
			"#endif"
	
		].join("\n"),
	
		// LIGHT MAP
	
		lightmap_pars_fragment: [
	
			"#ifdef USE_LIGHTMAP",
	
				"varying vec2 vUv2;",
				"uniform sampler2D lightMap;",
	
			"#endif"
	
		].join("\n"),
	
		lightmap_pars_vertex: [
	
			"#ifdef USE_LIGHTMAP",
	
				"varying vec2 vUv2;",
	
			"#endif"
	
		].join("\n"),
	
		lightmap_fragment: [
	
			"#ifdef USE_LIGHTMAP",
	
				"gl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );",
	
			"#endif"
	
		].join("\n"),
	
		lightmap_vertex: [
	
			"#ifdef USE_LIGHTMAP",
	
				"vUv2 = uv2;",
	
			"#endif"
	
		].join("\n"),
	
		// BUMP MAP
	
		bumpmap_pars_fragment: [
	
			"#ifdef USE_BUMPMAP",
	
				"uniform sampler2D bumpMap;",
				"uniform float bumpScale;",
	
				// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen
				//	http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html
	
				// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)
	
				"vec2 dHdxy_fwd() {",
	
					"vec2 dSTdx = dFdx( vUv );",
					"vec2 dSTdy = dFdy( vUv );",
	
					"float Hll = bumpScale * texture2D( bumpMap, vUv ).x;",
					"float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;",
					"float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;",
	
					"return vec2( dBx, dBy );",
	
				"}",
	
				"vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {",
	
					"vec3 vSigmaX = dFdx( surf_pos );",
					"vec3 vSigmaY = dFdy( surf_pos );",
					"vec3 vN = surf_norm;",		// normalized
	
					"vec3 R1 = cross( vSigmaY, vN );",
					"vec3 R2 = cross( vN, vSigmaX );",
	
					"float fDet = dot( vSigmaX, R1 );",
	
					"vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );",
					"return normalize( abs( fDet ) * surf_norm - vGrad );",
	
				"}",
	
			"#endif"
	
		].join("\n"),
	
		// NORMAL MAP
	
		normalmap_pars_fragment: [
	
			"#ifdef USE_NORMALMAP",
	
				"uniform sampler2D normalMap;",
				"uniform vec2 normalScale;",
	
				// Per-Pixel Tangent Space Normal Mapping
				// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html
	
				"vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {",
	
					"vec3 q0 = dFdx( eye_pos.xyz );",
					"vec3 q1 = dFdy( eye_pos.xyz );",
					"vec2 st0 = dFdx( vUv.st );",
					"vec2 st1 = dFdy( vUv.st );",
	
					"vec3 S = normalize(  q0 * st1.t - q1 * st0.t );",
					"vec3 T = normalize( -q0 * st1.s + q1 * st0.s );",
					"vec3 N = normalize( surf_norm );",
	
					"vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;",
					"mapN.xy = normalScale * mapN.xy;",
					"mat3 tsn = mat3( S, T, N );",
					"return normalize( tsn * mapN );",
	
				"}",
	
			"#endif"
	
		].join("\n"),
	
		// SPECULAR MAP
	
		specularmap_pars_fragment: [
	
			"#ifdef USE_SPECULARMAP",
	
				"uniform sampler2D specularMap;",
	
			"#endif"
	
		].join("\n"),
	
		specularmap_fragment: [
	
			"float specularStrength;",
	
			"#ifdef USE_SPECULARMAP",
	
				"vec4 texelSpecular = texture2D( specularMap, vUv );",
				"specularStrength = texelSpecular.r;",
	
			"#else",
	
				"specularStrength = 1.0;",
	
			"#endif"
	
		].join("\n"),
	
		// LIGHTS LAMBERT
	
		lights_lambert_pars_vertex: [
	
			"uniform vec3 ambient;",
			"uniform vec3 diffuse;",
			"uniform vec3 emissive;",
	
			"uniform vec3 ambientLightColor;",
	
			"#if MAX_DIR_LIGHTS > 0",
	
				"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
				"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];",
	
			"#endif",
	
			"#if MAX_HEMI_LIGHTS > 0",
	
				"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];",
				"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];",
				"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];",
	
			"#endif",
	
			"#if MAX_POINT_LIGHTS > 0",
	
				"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",
				"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
				"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",
	
			"#endif",
	
			"#if MAX_SPOT_LIGHTS > 0",
	
				"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];",
				"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
				"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];",
				"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",
				"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];",
				"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];",
	
			"#endif",
	
			"#ifdef WRAP_AROUND",
	
				"uniform vec3 wrapRGB;",
	
			"#endif"
	
		].join("\n"),
	
		lights_lambert_vertex: [
	
			"vLightFront = vec3( 0.0 );",
	
			"#ifdef DOUBLE_SIDED",
	
				"vLightBack = vec3( 0.0 );",
	
			"#endif",
	
			"transformedNormal = normalize( transformedNormal );",
	
			"#if MAX_DIR_LIGHTS > 0",
	
			"for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {",
	
				"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",
				"vec3 dirVector = normalize( lDirection.xyz );",
	
				"float dotProduct = dot( transformedNormal, dirVector );",
				"vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );",
	
				"#ifdef DOUBLE_SIDED",
	
					"vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );",
	
					"#ifdef WRAP_AROUND",
	
						"vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );",
	
					"#endif",
	
				"#endif",
	
				"#ifdef WRAP_AROUND",
	
					"vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );",
					"directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );",
	
					"#ifdef DOUBLE_SIDED",
	
						"directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );",
	
					"#endif",
	
				"#endif",
	
				"vLightFront += directionalLightColor[ i ] * directionalLightWeighting;",
	
				"#ifdef DOUBLE_SIDED",
	
					"vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;",
	
				"#endif",
	
			"}",
	
			"#endif",
	
			"#if MAX_POINT_LIGHTS > 0",
	
				"for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",
	
					"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
					"vec3 lVector = lPosition.xyz - mvPosition.xyz;",
	
					"float lDistance = 1.0;",
					"if ( pointLightDistance[ i ] > 0.0 )",
						"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );",
	
					"lVector = normalize( lVector );",
					"float dotProduct = dot( transformedNormal, lVector );",
	
					"vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );",
	
					"#ifdef DOUBLE_SIDED",
	
						"vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );",
	
						"#ifdef WRAP_AROUND",
	
							"vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );",
	
						"#endif",
	
					"#endif",
	
					"#ifdef WRAP_AROUND",
	
						"vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );",
						"pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );",
	
						"#ifdef DOUBLE_SIDED",
	
							"pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );",
	
						"#endif",
	
					"#endif",
	
					"vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;",
	
					"#ifdef DOUBLE_SIDED",
	
						"vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;",
	
					"#endif",
	
				"}",
	
			"#endif",
	
			"#if MAX_SPOT_LIGHTS > 0",
	
				"for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",
	
					"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
					"vec3 lVector = lPosition.xyz - mvPosition.xyz;",
	
					"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );",
	
					"if ( spotEffect > spotLightAngleCos[ i ] ) {",
	
						"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );",
	
						"float lDistance = 1.0;",
						"if ( spotLightDistance[ i ] > 0.0 )",
							"lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );",
	
						"lVector = normalize( lVector );",
	
						"float dotProduct = dot( transformedNormal, lVector );",
						"vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );",
	
						"#ifdef DOUBLE_SIDED",
	
							"vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );",
	
							"#ifdef WRAP_AROUND",
	
								"vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );",
	
							"#endif",
	
						"#endif",
	
						"#ifdef WRAP_AROUND",
	
							"vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );",
							"spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );",
	
							"#ifdef DOUBLE_SIDED",
	
								"spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );",
	
							"#endif",
	
						"#endif",
	
						"vLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;",
	
						"#ifdef DOUBLE_SIDED",
	
							"vLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;",
	
						"#endif",
	
					"}",
	
				"}",
	
			"#endif",
	
			"#if MAX_HEMI_LIGHTS > 0",
	
				"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {",
	
					"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );",
					"vec3 lVector = normalize( lDirection.xyz );",
	
					"float dotProduct = dot( transformedNormal, lVector );",
	
					"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;",
					"float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;",
	
					"vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );",
	
					"#ifdef DOUBLE_SIDED",
	
						"vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );",
	
					"#endif",
	
				"}",
	
			"#endif",
	
			"vLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;",
	
			"#ifdef DOUBLE_SIDED",
	
				"vLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;",
	
			"#endif"
	
		].join("\n"),
	
		// LIGHTS PHONG
	
		lights_phong_pars_vertex: [
	
			"#ifndef PHONG_PER_PIXEL",
	
			"#if MAX_POINT_LIGHTS > 0",
	
				"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
				"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",
	
				"varying vec4 vPointLight[ MAX_POINT_LIGHTS ];",
	
			"#endif",
	
			"#if MAX_SPOT_LIGHTS > 0",
	
				"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
				"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",
	
				"varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];",
	
			"#endif",
	
			"#endif",
	
			"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )",
	
				"varying vec3 vWorldPosition;",
	
			"#endif"
	
		].join("\n"),
	
	
		lights_phong_vertex: [
	
			"#ifndef PHONG_PER_PIXEL",
	
			"#if MAX_POINT_LIGHTS > 0",
	
				"for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",
	
					"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
					"vec3 lVector = lPosition.xyz - mvPosition.xyz;",
	
					"float lDistance = 1.0;",
					"if ( pointLightDistance[ i ] > 0.0 )",
						"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );",
	
					"vPointLight[ i ] = vec4( lVector, lDistance );",
	
				"}",
	
			"#endif",
	
			"#if MAX_SPOT_LIGHTS > 0",
	
				"for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",
	
					"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
					"vec3 lVector = lPosition.xyz - mvPosition.xyz;",
	
					"float lDistance = 1.0;",
					"if ( spotLightDistance[ i ] > 0.0 )",
						"lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );",
	
					"vSpotLight[ i ] = vec4( lVector, lDistance );",
	
				"}",
	
			"#endif",
	
			"#endif",
	
			"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )",
	
				"vWorldPosition = worldPosition.xyz;",
	
			"#endif"
	
		].join("\n"),
	
		lights_phong_pars_fragment: [
	
			"uniform vec3 ambientLightColor;",
	
			"#if MAX_DIR_LIGHTS > 0",
	
				"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
				"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];",
	
			"#endif",
	
			"#if MAX_HEMI_LIGHTS > 0",
	
				"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];",
				"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];",
				"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];",
	
			"#endif",
	
			"#if MAX_POINT_LIGHTS > 0",
	
				"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",
	
				"#ifdef PHONG_PER_PIXEL",
	
					"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
					"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",
	
				"#else",
	
					"varying vec4 vPointLight[ MAX_POINT_LIGHTS ];",
	
				"#endif",
	
			"#endif",
	
			"#if MAX_SPOT_LIGHTS > 0",
	
				"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];",
				"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
				"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];",
				"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];",
				"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];",
	
				"#ifdef PHONG_PER_PIXEL",
	
					"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",
	
				"#else",
	
					"varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];",
	
				"#endif",
	
			"#endif",
	
			"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )",
	
				"varying vec3 vWorldPosition;",
	
			"#endif",
	
			"#ifdef WRAP_AROUND",
	
				"uniform vec3 wrapRGB;",
	
			"#endif",
	
			"varying vec3 vViewPosition;",
			"varying vec3 vNormal;"
	
		].join("\n"),
	
		lights_phong_fragment: [
	
			"vec3 normal = normalize( vNormal );",
			"vec3 viewPosition = normalize( vViewPosition );",
	
			"#ifdef DOUBLE_SIDED",
	
				"normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );",
	
			"#endif",
	
			"#ifdef USE_NORMALMAP",
	
				"normal = perturbNormal2Arb( -viewPosition, normal );",
	
			"#elif defined( USE_BUMPMAP )",
	
				"normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );",
	
			"#endif",
	
			"#if MAX_POINT_LIGHTS > 0",
	
				"vec3 pointDiffuse  = vec3( 0.0 );",
				"vec3 pointSpecular = vec3( 0.0 );",
	
				"for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",
	
					"#ifdef PHONG_PER_PIXEL",
	
						"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
						"vec3 lVector = lPosition.xyz + vViewPosition.xyz;",
	
						"float lDistance = 1.0;",
						"if ( pointLightDistance[ i ] > 0.0 )",
							"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );",
	
						"lVector = normalize( lVector );",
	
					"#else",
	
						"vec3 lVector = normalize( vPointLight[ i ].xyz );",
						"float lDistance = vPointLight[ i ].w;",
	
					"#endif",
	
					// diffuse
	
					"float dotProduct = dot( normal, lVector );",
	
					"#ifdef WRAP_AROUND",
	
						"float pointDiffuseWeightFull = max( dotProduct, 0.0 );",
						"float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );",
	
						"vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );",
	
					"#else",
	
						"float pointDiffuseWeight = max( dotProduct, 0.0 );",
	
					"#endif",
	
					"pointDiffuse  += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;",
	
					// specular
	
					"vec3 pointHalfVector = normalize( lVector + viewPosition );",
					"float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );",
					"float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );",
	
					"#ifdef PHYSICALLY_BASED_SHADING",
	
						// 2.0 => 2.0001 is hack to work around ANGLE bug
	
						"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",
	
						"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, pointHalfVector ), 5.0 );",
						"pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;",
	
					"#else",
	
						"pointSpecular += specular * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance;",
	
					"#endif",
	
				"}",
	
			"#endif",
	
			"#if MAX_SPOT_LIGHTS > 0",
	
				"vec3 spotDiffuse  = vec3( 0.0 );",
				"vec3 spotSpecular = vec3( 0.0 );",
	
				"for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",
	
					"#ifdef PHONG_PER_PIXEL",
	
						"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
						"vec3 lVector = lPosition.xyz + vViewPosition.xyz;",
	
						"float lDistance = 1.0;",
						"if ( spotLightDistance[ i ] > 0.0 )",
							"lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );",
	
						"lVector = normalize( lVector );",
	
					"#else",
	
						"vec3 lVector = normalize( vSpotLight[ i ].xyz );",
						"float lDistance = vSpotLight[ i ].w;",
	
					"#endif",
	
					"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );",
	
					"if ( spotEffect > spotLightAngleCos[ i ] ) {",
	
						"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );",
	
						// diffuse
	
						"float dotProduct = dot( normal, lVector );",
	
						"#ifdef WRAP_AROUND",
	
							"float spotDiffuseWeightFull = max( dotProduct, 0.0 );",
							"float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );",
	
							"vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );",
	
						"#else",
	
							"float spotDiffuseWeight = max( dotProduct, 0.0 );",
	
						"#endif",
	
						"spotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;",
	
						// specular
	
						"vec3 spotHalfVector = normalize( lVector + viewPosition );",
						"float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );",
						"float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );",
	
						"#ifdef PHYSICALLY_BASED_SHADING",
	
							// 2.0 => 2.0001 is hack to work around ANGLE bug
	
							"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",
	
							"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, spotHalfVector ), 5.0 );",
							"spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;",
	
						"#else",
	
							"spotSpecular += specular * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * spotEffect;",
	
						"#endif",
	
					"}",
	
				"}",
	
			"#endif",
	
			"#if MAX_DIR_LIGHTS > 0",
	
				"vec3 dirDiffuse  = vec3( 0.0 );",
				"vec3 dirSpecular = vec3( 0.0 );" ,
	
				"for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {",
	
					"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",
					"vec3 dirVector = normalize( lDirection.xyz );",
	
					// diffuse
	
					"float dotProduct = dot( normal, dirVector );",
	
					"#ifdef WRAP_AROUND",
	
						"float dirDiffuseWeightFull = max( dotProduct, 0.0 );",
						"float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );",
	
						"vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );",
	
					"#else",
	
						"float dirDiffuseWeight = max( dotProduct, 0.0 );",
	
					"#endif",
	
					"dirDiffuse  += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;",
	
					// specular
	
					"vec3 dirHalfVector = normalize( dirVector + viewPosition );",
					"float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );",
					"float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );",
	
					"#ifdef PHYSICALLY_BASED_SHADING",
	
						/*
						// fresnel term from skin shader
						"const float F0 = 0.128;",
	
						"float base = 1.0 - dot( viewPosition, dirHalfVector );",
						"float exponential = pow( base, 5.0 );",
	
						"float fresnel = exponential + F0 * ( 1.0 - exponential );",
						*/
	
						/*
						// fresnel term from fresnel shader
						"const float mFresnelBias = 0.08;",
						"const float mFresnelScale = 0.3;",
						"const float mFresnelPower = 5.0;",
	
						"float fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );",
						*/
	
						// 2.0 => 2.0001 is hack to work around ANGLE bug
	
						"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",
	
						//"dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;",
	
						"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );",
						"dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;",
	
					"#else",
	
						"dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight;",
	
					"#endif",
	
				"}",
	
			"#endif",
	
			"#if MAX_HEMI_LIGHTS > 0",
	
				"vec3 hemiDiffuse  = vec3( 0.0 );",
				"vec3 hemiSpecular = vec3( 0.0 );" ,
	
				"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {",
	
					"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );",
					"vec3 lVector = normalize( lDirection.xyz );",
	
					// diffuse
	
					"float dotProduct = dot( normal, lVector );",
					"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;",
	
					"vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );",
	
					"hemiDiffuse += diffuse * hemiColor;",
	
					// specular (sky light)
	
					"vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );",
					"float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;",
					"float hemiSpecularWeightSky = specularStrength * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );",
	
					// specular (ground light)
	
					"vec3 lVectorGround = -lVector;",
	
					"vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );",
					"float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;",
					"float hemiSpecularWeightGround = specularStrength * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );",
	
					"#ifdef PHYSICALLY_BASED_SHADING",
	
						"float dotProductGround = dot( normal, lVectorGround );",
	
						// 2.0 => 2.0001 is hack to work around ANGLE bug
	
						"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",
	
						"vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );",
						"vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );",
						"hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );",
	
					"#else",
	
						"hemiSpecular += specular * hemiColor * ( hemiSpecularWeightSky + hemiSpecularWeightGround ) * hemiDiffuseWeight;",
	
					"#endif",
	
				"}",
	
			"#endif",
	
			"vec3 totalDiffuse = vec3( 0.0 );",
			"vec3 totalSpecular = vec3( 0.0 );",
	
			"#if MAX_DIR_LIGHTS > 0",
	
				"totalDiffuse += dirDiffuse;",
				"totalSpecular += dirSpecular;",
	
			"#endif",
	
			"#if MAX_HEMI_LIGHTS > 0",
	
				"totalDiffuse += hemiDiffuse;",
				"totalSpecular += hemiSpecular;",
	
			"#endif",
	
			"#if MAX_POINT_LIGHTS > 0",
	
				"totalDiffuse += pointDiffuse;",
				"totalSpecular += pointSpecular;",
	
			"#endif",
	
			"#if MAX_SPOT_LIGHTS > 0",
	
				"totalDiffuse += spotDiffuse;",
				"totalSpecular += spotSpecular;",
	
			"#endif",
	
			"#ifdef METAL",
	
				"gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );",
	
			"#else",
	
				"gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;",
	
			"#endif"
	
		].join("\n"),
	
		// VERTEX COLORS
	
		color_pars_fragment: [
	
			"#ifdef USE_COLOR",
	
				"varying vec3 vColor;",
	
			"#endif"
	
		].join("\n"),
	
	
		color_fragment: [
	
			"#ifdef USE_COLOR",
	
				"gl_FragColor = gl_FragColor * vec4( vColor, opacity );",
	
			"#endif"
	
		].join("\n"),
	
		color_pars_vertex: [
	
			"#ifdef USE_COLOR",
	
				"varying vec3 vColor;",
	
			"#endif"
	
		].join("\n"),
	
	
		color_vertex: [
	
			"#ifdef USE_COLOR",
	
				"#ifdef GAMMA_INPUT",
	
					"vColor = color * color;",
	
				"#else",
	
					"vColor = color;",
	
				"#endif",
	
			"#endif"
	
		].join("\n"),
	
		// SKINNING
	
		skinning_pars_vertex: [
	
			"#ifdef USE_SKINNING",
	
				"#ifdef BONE_TEXTURE",
	
					"uniform sampler2D boneTexture;",
	
					"mat4 getBoneMatrix( const in float i ) {",
	
						"float j = i * 4.0;",
						"float x = mod( j, N_BONE_PIXEL_X );",
						"float y = floor( j / N_BONE_PIXEL_X );",
	
						"const float dx = 1.0 / N_BONE_PIXEL_X;",
						"const float dy = 1.0 / N_BONE_PIXEL_Y;",
	
						"y = dy * ( y + 0.5 );",
	
						"vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );",
						"vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );",
						"vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );",
						"vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );",
	
						"mat4 bone = mat4( v1, v2, v3, v4 );",
	
						"return bone;",
	
					"}",
	
				"#else",
	
					"uniform mat4 boneGlobalMatrices[ MAX_BONES ];",
	
					"mat4 getBoneMatrix( const in float i ) {",
	
						"mat4 bone = boneGlobalMatrices[ int(i) ];",
						"return bone;",
	
					"}",
	
				"#endif",
	
			"#endif"
	
		].join("\n"),
	
		skinbase_vertex: [
	
			"#ifdef USE_SKINNING",
	
				"mat4 boneMatX = getBoneMatrix( skinIndex.x );",
				"mat4 boneMatY = getBoneMatrix( skinIndex.y );",
	
			"#endif"
	
		].join("\n"),
	
		skinning_vertex: [
	
			"#ifdef USE_SKINNING",
	
				"#ifdef USE_MORPHTARGETS",
	
				"vec4 skinVertex = vec4( morphed, 1.0 );",
	
				"#else",
	
				"vec4 skinVertex = vec4( position, 1.0 );",
	
				"#endif",
	
				"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;",
				"skinned 	  += boneMatY * skinVertex * skinWeight.y;",
	
			"#endif"
	
		].join("\n"),
	
		// MORPHING
	
		morphtarget_pars_vertex: [
	
			"#ifdef USE_MORPHTARGETS",
	
				"#ifndef USE_MORPHNORMALS",
	
				"uniform float morphTargetInfluences[ 8 ];",
	
				"#else",
	
				"uniform float morphTargetInfluences[ 4 ];",
	
				"#endif",
	
			"#endif"
	
		].join("\n"),
	
		morphtarget_vertex: [
	
			"#ifdef USE_MORPHTARGETS",
	
				"vec3 morphed = vec3( 0.0 );",
				"morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];",
				"morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];",
				"morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];",
				"morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];",
	
				"#ifndef USE_MORPHNORMALS",
	
				"morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];",
				"morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];",
				"morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];",
				"morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];",
	
				"#endif",
	
				"morphed += position;",
	
			"#endif"
	
		].join("\n"),
	
		default_vertex : [
	
			"vec4 mvPosition;",
	
			"#ifdef USE_SKINNING",
	
				"mvPosition = modelViewMatrix * skinned;",
	
			"#endif",
	
			"#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )",
	
				"mvPosition = modelViewMatrix * vec4( morphed, 1.0 );",
	
			"#endif",
	
			"#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )",
	
				"mvPosition = modelViewMatrix * vec4( position, 1.0 );",
	
			"#endif",
	
			"gl_Position = projectionMatrix * mvPosition;"
	
		].join("\n"),
	
		morphnormal_vertex: [
	
			"#ifdef USE_MORPHNORMALS",
	
				"vec3 morphedNormal = vec3( 0.0 );",
	
				"morphedNormal +=  ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];",
				"morphedNormal +=  ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];",
				"morphedNormal +=  ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];",
				"morphedNormal +=  ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];",
	
				"morphedNormal += normal;",
	
			"#endif"
	
		].join("\n"),
	
		skinnormal_vertex: [
	
			"#ifdef USE_SKINNING",
	
				"mat4 skinMatrix = skinWeight.x * boneMatX;",
				"skinMatrix 	+= skinWeight.y * boneMatY;",
	
				"#ifdef USE_MORPHNORMALS",
	
				"vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );",
	
				"#else",
	
				"vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );",
	
				"#endif",
	
			"#endif"
	
		].join("\n"),
	
		defaultnormal_vertex: [
	
			"vec3 objectNormal;",
	
			"#ifdef USE_SKINNING",
	
				"objectNormal = skinnedNormal.xyz;",
	
			"#endif",
	
			"#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )",
	
				"objectNormal = morphedNormal;",
	
			"#endif",
	
			"#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )",
	
				"objectNormal = normal;",
	
			"#endif",
	
			"#ifdef FLIP_SIDED",
	
				"objectNormal = -objectNormal;",
	
			"#endif",
	
			"vec3 transformedNormal = normalMatrix * objectNormal;"
	
		].join("\n"),
	
		// SHADOW MAP
	
		// based on SpiderGL shadow map and Fabien Sanglard's GLSL shadow mapping examples
		//  http://spidergl.org/example.php?id=6
		// 	http://fabiensanglard.net/shadowmapping
	
		shadowmap_pars_fragment: [
	
			"#ifdef USE_SHADOWMAP",
	
				"uniform sampler2D shadowMap[ MAX_SHADOWS ];",
				"uniform vec2 shadowMapSize[ MAX_SHADOWS ];",
	
				"uniform float shadowDarkness[ MAX_SHADOWS ];",
				"uniform float shadowBias[ MAX_SHADOWS ];",
	
				"varying vec4 vShadowCoord[ MAX_SHADOWS ];",
	
				"float unpackDepth( const in vec4 rgba_depth ) {",
	
					"const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );",
					"float depth = dot( rgba_depth, bit_shift );",
					"return depth;",
	
				"}",
	
			"#endif"
	
		].join("\n"),
	
		shadowmap_fragment: [
	
			"#ifdef USE_SHADOWMAP",
	
				"#ifdef SHADOWMAP_DEBUG",
	
					"vec3 frustumColors[3];",
					"frustumColors[0] = vec3( 1.0, 0.5, 0.0 );",
					"frustumColors[1] = vec3( 0.0, 1.0, 0.8 );",
					"frustumColors[2] = vec3( 0.0, 0.5, 1.0 );",
	
				"#endif",
	
				"#ifdef SHADOWMAP_CASCADE",
	
					"int inFrustumCount = 0;",
	
				"#endif",
	
				"float fDepth;",
				"vec3 shadowColor = vec3( 1.0 );",
	
				"for( int i = 0; i < MAX_SHADOWS; i ++ ) {",
	
					"vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;",
	
					// "if ( something && something )" 		 breaks ATI OpenGL shader compiler
					// "if ( all( something, something ) )"  using this instead
	
					"bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );",
					"bool inFrustum = all( inFrustumVec );",
	
					// don't shadow pixels outside of light frustum
					// use just first frustum (for cascades)
					// don't shadow pixels behind far plane of light frustum
	
					"#ifdef SHADOWMAP_CASCADE",
	
						"inFrustumCount += int( inFrustum );",
						"bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );",
	
					"#else",
	
						"bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );",
	
					"#endif",
	
					"bool frustumTest = all( frustumTestVec );",
	
					"if ( frustumTest ) {",
	
						"shadowCoord.z += shadowBias[ i ];",
	
						"#if defined( SHADOWMAP_TYPE_PCF )",
	
							// Percentage-close filtering
							// (9 pixel kernel)
							// http://fabiensanglard.net/shadowmappingPCF/
	
							"float shadow = 0.0;",
	
							/*
							// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL
							// must enroll loop manually
	
							"for ( float y = -1.25; y <= 1.25; y += 1.25 )",
								"for ( float x = -1.25; x <= 1.25; x += 1.25 ) {",
	
									"vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );",
	
									// doesn't seem to produce any noticeable visual difference compared to simple "texture2D" lookup
									//"vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );",
	
									"float fDepth = unpackDepth( rgbaDepth );",
	
									"if ( fDepth < shadowCoord.z )",
										"shadow += 1.0;",
	
							"}",
	
							"shadow /= 9.0;",
	
							*/
	
							"const float shadowDelta = 1.0 / 9.0;",
	
							"float xPixelOffset = 1.0 / shadowMapSize[ i ].x;",
							"float yPixelOffset = 1.0 / shadowMapSize[ i ].y;",
	
							"float dx0 = -1.25 * xPixelOffset;",
							"float dy0 = -1.25 * yPixelOffset;",
							"float dx1 = 1.25 * xPixelOffset;",
							"float dy1 = 1.25 * yPixelOffset;",
	
							"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );",
							"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",
	
							"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );",
							"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",
	
							"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );",
							"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",
	
							"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );",
							"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",
	
							"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );",
							"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",
	
							"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );",
							"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",
	
							"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );",
							"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",
	
							"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );",
							"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",
	
							"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );",
							"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",
	
							"shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );",
	
						"#elif defined( SHADOWMAP_TYPE_PCF_SOFT )",
	
							// Percentage-close filtering
							// (9 pixel kernel)
							// http://fabiensanglard.net/shadowmappingPCF/
	
							"float shadow = 0.0;",
	
							"float xPixelOffset = 1.0 / shadowMapSize[ i ].x;",
							"float yPixelOffset = 1.0 / shadowMapSize[ i ].y;",
	
							"float dx0 = -1.0 * xPixelOffset;",
							"float dy0 = -1.0 * yPixelOffset;",
							"float dx1 = 1.0 * xPixelOffset;",
							"float dy1 = 1.0 * yPixelOffset;",
	
							"mat3 shadowKernel;",
							"mat3 depthKernel;",
	
							"depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );",
							"if ( depthKernel[0][0] < shadowCoord.z ) shadowKernel[0][0] = 0.25;",
							"else shadowKernel[0][0] = 0.0;",
	
							"depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );",
							"if ( depthKernel[0][1] < shadowCoord.z ) shadowKernel[0][1] = 0.25;",
							"else shadowKernel[0][1] = 0.0;",
	
							"depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i], shadowCoord.xy + vec2( dx0, dy1 ) ) );",
							"if ( depthKernel[0][2] < shadowCoord.z ) shadowKernel[0][2] = 0.25;",
							"else shadowKernel[0][2] = 0.0;",
	
							"depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );",
							"if ( depthKernel[1][0] < shadowCoord.z ) shadowKernel[1][0] = 0.25;",
							"else shadowKernel[1][0] = 0.0;",
	
							"depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );",
							"if ( depthKernel[1][1] < shadowCoord.z ) shadowKernel[1][1] = 0.25;",
							"else shadowKernel[1][1] = 0.0;",
	
							"depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );",
							"if ( depthKernel[1][2] < shadowCoord.z ) shadowKernel[1][2] = 0.25;",
							"else shadowKernel[1][2] = 0.0;",
	
							"depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );",
							"if ( depthKernel[2][0] < shadowCoord.z ) shadowKernel[2][0] = 0.25;",
							"else shadowKernel[2][0] = 0.0;",
	
							"depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );",
							"if ( depthKernel[2][1] < shadowCoord.z ) shadowKernel[2][1] = 0.25;",
							"else shadowKernel[2][1] = 0.0;",
	
							"depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );",
							"if ( depthKernel[2][2] < shadowCoord.z ) shadowKernel[2][2] = 0.25;",
							"else shadowKernel[2][2] = 0.0;",
	
							"vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );",
	
							"shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );",
							"shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );",
	
							"vec4 shadowValues;",
							"shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );",
							"shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );",
							"shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );",
							"shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );",
	
							"shadow = dot( shadowValues, vec4( 1.0 ) );",
	
							"shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );",
	
						"#else",
	
							"vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );",
							"float fDepth = unpackDepth( rgbaDepth );",
	
							"if ( fDepth < shadowCoord.z )",
	
								// spot with multiple shadows is darker
	
								"shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );",
	
								// spot with multiple shadows has the same color as single shadow spot
	
								//"shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );",
	
						"#endif",
	
					"}",
	
	
					"#ifdef SHADOWMAP_DEBUG",
	
						"#ifdef SHADOWMAP_CASCADE",
	
							"if ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];",
	
						"#else",
	
							"if ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];",
	
						"#endif",
	
					"#endif",
	
				"}",
	
				"#ifdef GAMMA_OUTPUT",
	
					"shadowColor *= shadowColor;",
	
				"#endif",
	
				"gl_FragColor.xyz = gl_FragColor.xyz * shadowColor;",
	
			"#endif"
	
		].join("\n"),
	
		shadowmap_pars_vertex: [
	
			"#ifdef USE_SHADOWMAP",
	
				"varying vec4 vShadowCoord[ MAX_SHADOWS ];",
				"uniform mat4 shadowMatrix[ MAX_SHADOWS ];",
	
			"#endif"
	
		].join("\n"),
	
		shadowmap_vertex: [
	
			"#ifdef USE_SHADOWMAP",
	
				"for( int i = 0; i < MAX_SHADOWS; i ++ ) {",
	
					"vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;",
	
				"}",
	
			"#endif"
	
		].join("\n"),
	
		// ALPHATEST
	
		alphatest_fragment: [
	
			"#ifdef ALPHATEST",
	
				"if ( gl_FragColor.a < ALPHATEST ) discard;",
	
			"#endif"
	
		].join("\n"),
	
		// LINEAR SPACE
	
		linear_to_gamma_fragment: [
	
			"#ifdef GAMMA_OUTPUT",
	
				"gl_FragColor.xyz = sqrt( gl_FragColor.xyz );",
	
			"#endif"
	
		].join("\n")
	
	
	};
	
	THREE.UniformsUtils = {
	
		merge: function ( uniforms ) {
	
			var u, p, tmp, merged = {};
	
			for ( u = 0; u < uniforms.length; u ++ ) {
	
				tmp = this.clone( uniforms[ u ] );
	
				for ( p in tmp ) {
	
					merged[ p ] = tmp[ p ];
	
				}
	
			}
	
			return merged;
	
		},
	
		clone: function ( uniforms_src ) {
	
			var u, p, parameter, parameter_src, uniforms_dst = {};
	
			for ( u in uniforms_src ) {
	
				uniforms_dst[ u ] = {};
	
				for ( p in uniforms_src[ u ] ) {
	
					parameter_src = uniforms_src[ u ][ p ];
	
					if ( parameter_src instanceof THREE.Color ||
						 parameter_src instanceof THREE.Vector2 ||
						 parameter_src instanceof THREE.Vector3 ||
						 parameter_src instanceof THREE.Vector4 ||
						 parameter_src instanceof THREE.Matrix4 ||
						 parameter_src instanceof THREE.Texture ) {
	
						uniforms_dst[ u ][ p ] = parameter_src.clone();
	
					} else if ( parameter_src instanceof Array ) {
	
						uniforms_dst[ u ][ p ] = parameter_src.slice();
	
					} else {
	
						uniforms_dst[ u ][ p ] = parameter_src;
	
					}
	
				}
	
			}
	
			return uniforms_dst;
	
		}
	
	};
	
	THREE.UniformsLib = {
	
		common: {
	
			"diffuse" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
			"opacity" : { type: "f", value: 1.0 },
	
			"map" : { type: "t", value: null },
			"offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },
	
			"lightMap" : { type: "t", value: null },
			"specularMap" : { type: "t", value: null },
	
			"envMap" : { type: "t", value: null },
			"flipEnvMap" : { type: "f", value: -1 },
			"useRefract" : { type: "i", value: 0 },
			"reflectivity" : { type: "f", value: 1.0 },
			"refractionRatio" : { type: "f", value: 0.98 },
			"combine" : { type: "i", value: 0 },
	
			"morphTargetInfluences" : { type: "f", value: 0 }
	
		},
	
		bump: {
	
			"bumpMap" : { type: "t", value: null },
			"bumpScale" : { type: "f", value: 1 }
	
		},
	
		normalmap: {
	
			"normalMap" : { type: "t", value: null },
			"normalScale" : { type: "v2", value: new THREE.Vector2( 1, 1 ) }
		},
	
		fog : {
	
			"fogDensity" : { type: "f", value: 0.00025 },
			"fogNear" : { type: "f", value: 1 },
			"fogFar" : { type: "f", value: 2000 },
			"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }
	
		},
	
		lights: {
	
			"ambientLightColor" : { type: "fv", value: [] },
	
			"directionalLightDirection" : { type: "fv", value: [] },
			"directionalLightColor" : { type: "fv", value: [] },
	
			"hemisphereLightDirection" : { type: "fv", value: [] },
			"hemisphereLightSkyColor" : { type: "fv", value: [] },
			"hemisphereLightGroundColor" : { type: "fv", value: [] },
	
			"pointLightColor" : { type: "fv", value: [] },
			"pointLightPosition" : { type: "fv", value: [] },
			"pointLightDistance" : { type: "fv1", value: [] },
	
			"spotLightColor" : { type: "fv", value: [] },
			"spotLightPosition" : { type: "fv", value: [] },
			"spotLightDirection" : { type: "fv", value: [] },
			"spotLightDistance" : { type: "fv1", value: [] },
			"spotLightAngleCos" : { type: "fv1", value: [] },
			"spotLightExponent" : { type: "fv1", value: [] }
	
		},
	
		particle: {
	
			"psColor" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
			"opacity" : { type: "f", value: 1.0 },
			"size" : { type: "f", value: 1.0 },
			"scale" : { type: "f", value: 1.0 },
			"map" : { type: "t", value: null },
	
			"fogDensity" : { type: "f", value: 0.00025 },
			"fogNear" : { type: "f", value: 1 },
			"fogFar" : { type: "f", value: 2000 },
			"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }
	
		},
	
		shadowmap: {
	
			"shadowMap": { type: "tv", value: [] },
			"shadowMapSize": { type: "v2v", value: [] },
	
			"shadowBias" : { type: "fv1", value: [] },
			"shadowDarkness": { type: "fv1", value: [] },
	
			"shadowMatrix" : { type: "m4v", value: [] }
	
		}
	
	};
	
	THREE.ShaderLib = {
	
		'basic': {
	
			uniforms: THREE.UniformsUtils.merge( [
	
				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "fog" ],
				THREE.UniformsLib[ "shadowmap" ]
	
			] ),
	
			vertexShader: [
	
				THREE.ShaderChunk[ "map_pars_vertex" ],
				THREE.ShaderChunk[ "lightmap_pars_vertex" ],
				THREE.ShaderChunk[ "envmap_pars_vertex" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "map_vertex" ],
					THREE.ShaderChunk[ "lightmap_vertex" ],
					THREE.ShaderChunk[ "color_vertex" ],
					THREE.ShaderChunk[ "skinbase_vertex" ],
	
					"#ifdef USE_ENVMAP",
	
					THREE.ShaderChunk[ "morphnormal_vertex" ],
					THREE.ShaderChunk[ "skinnormal_vertex" ],
					THREE.ShaderChunk[ "defaultnormal_vertex" ],
	
					"#endif",
	
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "default_vertex" ],
	
					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "envmap_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],
	
				"}"
	
			].join("\n"),
	
			fragmentShader: [
	
				"uniform vec3 diffuse;",
				"uniform float opacity;",
	
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "map_pars_fragment" ],
				THREE.ShaderChunk[ "lightmap_pars_fragment" ],
				THREE.ShaderChunk[ "envmap_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "specularmap_pars_fragment" ],
	
				"void main() {",
	
					"gl_FragColor = vec4( diffuse, opacity );",
	
					THREE.ShaderChunk[ "map_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
					THREE.ShaderChunk[ "specularmap_fragment" ],
					THREE.ShaderChunk[ "lightmap_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "envmap_fragment" ],
					THREE.ShaderChunk[ "shadowmap_fragment" ],
	
					THREE.ShaderChunk[ "linear_to_gamma_fragment" ],
	
					THREE.ShaderChunk[ "fog_fragment" ],
	
				"}"
	
			].join("\n")
	
		},
	
		'lambert': {
	
			uniforms: THREE.UniformsUtils.merge( [
	
				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "fog" ],
				THREE.UniformsLib[ "lights" ],
				THREE.UniformsLib[ "shadowmap" ],
	
				{
					"ambient"  : { type: "c", value: new THREE.Color( 0xffffff ) },
					"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
					"wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }
				}
	
			] ),
	
			vertexShader: [
	
				"#define LAMBERT",
	
				"varying vec3 vLightFront;",
	
				"#ifdef DOUBLE_SIDED",
	
					"varying vec3 vLightBack;",
	
				"#endif",
	
				THREE.ShaderChunk[ "map_pars_vertex" ],
				THREE.ShaderChunk[ "lightmap_pars_vertex" ],
				THREE.ShaderChunk[ "envmap_pars_vertex" ],
				THREE.ShaderChunk[ "lights_lambert_pars_vertex" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "map_vertex" ],
					THREE.ShaderChunk[ "lightmap_vertex" ],
					THREE.ShaderChunk[ "color_vertex" ],
	
					THREE.ShaderChunk[ "morphnormal_vertex" ],
					THREE.ShaderChunk[ "skinbase_vertex" ],
					THREE.ShaderChunk[ "skinnormal_vertex" ],
					THREE.ShaderChunk[ "defaultnormal_vertex" ],
	
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "default_vertex" ],
	
					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "envmap_vertex" ],
					THREE.ShaderChunk[ "lights_lambert_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],
	
				"}"
	
			].join("\n"),
	
			fragmentShader: [
	
				"uniform float opacity;",
	
				"varying vec3 vLightFront;",
	
				"#ifdef DOUBLE_SIDED",
	
					"varying vec3 vLightBack;",
	
				"#endif",
	
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "map_pars_fragment" ],
				THREE.ShaderChunk[ "lightmap_pars_fragment" ],
				THREE.ShaderChunk[ "envmap_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "specularmap_pars_fragment" ],
	
				"void main() {",
	
					"gl_FragColor = vec4( vec3 ( 1.0 ), opacity );",
	
					THREE.ShaderChunk[ "map_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
					THREE.ShaderChunk[ "specularmap_fragment" ],
	
					"#ifdef DOUBLE_SIDED",
	
						//"float isFront = float( gl_FrontFacing );",
						//"gl_FragColor.xyz *= isFront * vLightFront + ( 1.0 - isFront ) * vLightBack;",
	
						"if ( gl_FrontFacing )",
							"gl_FragColor.xyz *= vLightFront;",
						"else",
							"gl_FragColor.xyz *= vLightBack;",
	
					"#else",
	
						"gl_FragColor.xyz *= vLightFront;",
	
					"#endif",
	
					THREE.ShaderChunk[ "lightmap_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "envmap_fragment" ],
					THREE.ShaderChunk[ "shadowmap_fragment" ],
	
					THREE.ShaderChunk[ "linear_to_gamma_fragment" ],
	
					THREE.ShaderChunk[ "fog_fragment" ],
	
				"}"
	
			].join("\n")
	
		},
	
		'phong': {
	
			uniforms: THREE.UniformsUtils.merge( [
	
				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "bump" ],
				THREE.UniformsLib[ "normalmap" ],
				THREE.UniformsLib[ "fog" ],
				THREE.UniformsLib[ "lights" ],
				THREE.UniformsLib[ "shadowmap" ],
	
				{
					"ambient"  : { type: "c", value: new THREE.Color( 0xffffff ) },
					"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
					"specular" : { type: "c", value: new THREE.Color( 0x111111 ) },
					"shininess": { type: "f", value: 30 },
					"wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }
				}
	
			] ),
	
			vertexShader: [
	
				"#define PHONG",
	
				"varying vec3 vViewPosition;",
				"varying vec3 vNormal;",
	
				THREE.ShaderChunk[ "map_pars_vertex" ],
				THREE.ShaderChunk[ "lightmap_pars_vertex" ],
				THREE.ShaderChunk[ "envmap_pars_vertex" ],
				THREE.ShaderChunk[ "lights_phong_pars_vertex" ],
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "map_vertex" ],
					THREE.ShaderChunk[ "lightmap_vertex" ],
					THREE.ShaderChunk[ "color_vertex" ],
	
					THREE.ShaderChunk[ "morphnormal_vertex" ],
					THREE.ShaderChunk[ "skinbase_vertex" ],
					THREE.ShaderChunk[ "skinnormal_vertex" ],
					THREE.ShaderChunk[ "defaultnormal_vertex" ],
	
					"vNormal = normalize( transformedNormal );",
	
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "default_vertex" ],
	
					"vViewPosition = -mvPosition.xyz;",
	
					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "envmap_vertex" ],
					THREE.ShaderChunk[ "lights_phong_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],
	
				"}"
	
			].join("\n"),
	
			fragmentShader: [
	
				"uniform vec3 diffuse;",
				"uniform float opacity;",
	
				"uniform vec3 ambient;",
				"uniform vec3 emissive;",
				"uniform vec3 specular;",
				"uniform float shininess;",
	
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "map_pars_fragment" ],
				THREE.ShaderChunk[ "lightmap_pars_fragment" ],
				THREE.ShaderChunk[ "envmap_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "lights_phong_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "bumpmap_pars_fragment" ],
				THREE.ShaderChunk[ "normalmap_pars_fragment" ],
				THREE.ShaderChunk[ "specularmap_pars_fragment" ],
	
				"void main() {",
	
					"gl_FragColor = vec4( vec3 ( 1.0 ), opacity );",
	
					THREE.ShaderChunk[ "map_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
					THREE.ShaderChunk[ "specularmap_fragment" ],
	
					THREE.ShaderChunk[ "lights_phong_fragment" ],
	
					THREE.ShaderChunk[ "lightmap_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "envmap_fragment" ],
					THREE.ShaderChunk[ "shadowmap_fragment" ],
	
					THREE.ShaderChunk[ "linear_to_gamma_fragment" ],
	
					THREE.ShaderChunk[ "fog_fragment" ],
	
				"}"
	
			].join("\n")
	
		},
	
		'particle_basic': {
	
			uniforms:  THREE.UniformsUtils.merge( [
	
				THREE.UniformsLib[ "particle" ],
				THREE.UniformsLib[ "shadowmap" ]
	
			] ),
	
			vertexShader: [
	
				"uniform float size;",
				"uniform float scale;",
	
				THREE.ShaderChunk[ "color_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "color_vertex" ],
	
					"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
	
					"#ifdef USE_SIZEATTENUATION",
						"gl_PointSize = size * ( scale / length( mvPosition.xyz ) );",
					"#else",
						"gl_PointSize = size;",
					"#endif",
	
					"gl_Position = projectionMatrix * mvPosition;",
	
					THREE.ShaderChunk[ "worldpos_vertex" ],
					THREE.ShaderChunk[ "shadowmap_vertex" ],
	
				"}"
	
			].join("\n"),
	
			fragmentShader: [
	
				"uniform vec3 psColor;",
				"uniform float opacity;",
	
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "map_particle_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
	
				"void main() {",
	
					"gl_FragColor = vec4( psColor, opacity );",
	
					THREE.ShaderChunk[ "map_particle_fragment" ],
					THREE.ShaderChunk[ "alphatest_fragment" ],
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "shadowmap_fragment" ],
					THREE.ShaderChunk[ "fog_fragment" ],
	
				"}"
	
			].join("\n")
	
		},
	
		'dashed': {
	
			uniforms: THREE.UniformsUtils.merge( [
	
				THREE.UniformsLib[ "common" ],
				THREE.UniformsLib[ "fog" ],
	
				{
					"scale":     { type: "f", value: 1 },
					"dashSize":  { type: "f", value: 1 },
					"totalSize": { type: "f", value: 2 }
				}
	
			] ),
	
			vertexShader: [
	
				"uniform float scale;",
				"attribute float lineDistance;",
	
				"varying float vLineDistance;",
	
				THREE.ShaderChunk[ "color_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "color_vertex" ],
	
					"vLineDistance = scale * lineDistance;",
	
					"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
					"gl_Position = projectionMatrix * mvPosition;",
	
				"}"
	
			].join("\n"),
	
			fragmentShader: [
	
				"uniform vec3 diffuse;",
				"uniform float opacity;",
	
				"uniform float dashSize;",
				"uniform float totalSize;",
	
				"varying float vLineDistance;",
	
				THREE.ShaderChunk[ "color_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
	
				"void main() {",
	
					"if ( mod( vLineDistance, totalSize ) > dashSize ) {",
	
						"discard;",
	
					"}",
	
					"gl_FragColor = vec4( diffuse, opacity );",
	
					THREE.ShaderChunk[ "color_fragment" ],
					THREE.ShaderChunk[ "fog_fragment" ],
	
				"}"
	
			].join("\n")
	
		},
	
		'depth': {
	
			uniforms: {
	
				"mNear": { type: "f", value: 1.0 },
				"mFar" : { type: "f", value: 2000.0 },
				"opacity" : { type: "f", value: 1.0 }
	
			},
	
			vertexShader: [
	
				"void main() {",
	
					"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
	
				"}"
	
			].join("\n"),
	
			fragmentShader: [
	
				"uniform float mNear;",
				"uniform float mFar;",
				"uniform float opacity;",
	
				"void main() {",
	
					"float depth = gl_FragCoord.z / gl_FragCoord.w;",
					"float color = 1.0 - smoothstep( mNear, mFar, depth );",
					"gl_FragColor = vec4( vec3( color ), opacity );",
	
				"}"
	
			].join("\n")
	
		},
	
		'normal': {
	
			uniforms: {
	
				"opacity" : { type: "f", value: 1.0 }
	
			},
	
			vertexShader: [
	
				"varying vec3 vNormal;",
	
				"void main() {",
	
					"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
					"vNormal = normalize( normalMatrix * normal );",
	
					"gl_Position = projectionMatrix * mvPosition;",
	
				"}"
	
			].join("\n"),
	
			fragmentShader: [
	
				"uniform float opacity;",
				"varying vec3 vNormal;",
	
				"void main() {",
	
					"gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );",
	
				"}"
	
			].join("\n")
	
		},
	
		/* -------------------------------------------------------------------------
		//	Normal map shader
		//		- Blinn-Phong
		//		- normal + diffuse + specular + AO + displacement + reflection + shadow maps
		//		- point and directional lights (use with "lights: true" material option)
		 ------------------------------------------------------------------------- */
	
		'normalmap' : {
	
			uniforms: THREE.UniformsUtils.merge( [
	
				THREE.UniformsLib[ "fog" ],
				THREE.UniformsLib[ "lights" ],
				THREE.UniformsLib[ "shadowmap" ],
	
				{
	
				"enableAO"		  : { type: "i", value: 0 },
				"enableDiffuse"	  : { type: "i", value: 0 },
				"enableSpecular"  : { type: "i", value: 0 },
				"enableReflection": { type: "i", value: 0 },
				"enableDisplacement": { type: "i", value: 0 },
	
				"tDisplacement": { type: "t", value: null }, // must go first as this is vertex texture
				"tDiffuse"	   : { type: "t", value: null },
				"tCube"		   : { type: "t", value: null },
				"tNormal"	   : { type: "t", value: null },
				"tSpecular"	   : { type: "t", value: null },
				"tAO"		   : { type: "t", value: null },
	
				"uNormalScale": { type: "v2", value: new THREE.Vector2( 1, 1 ) },
	
				"uDisplacementBias": { type: "f", value: 0.0 },
				"uDisplacementScale": { type: "f", value: 1.0 },
	
				"uDiffuseColor": { type: "c", value: new THREE.Color( 0xffffff ) },
				"uSpecularColor": { type: "c", value: new THREE.Color( 0x111111 ) },
				"uAmbientColor": { type: "c", value: new THREE.Color( 0xffffff ) },
				"uShininess": { type: "f", value: 30 },
				"uOpacity": { type: "f", value: 1 },
	
				"useRefract": { type: "i", value: 0 },
				"uRefractionRatio": { type: "f", value: 0.98 },
				"uReflectivity": { type: "f", value: 0.5 },
	
				"uOffset" : { type: "v2", value: new THREE.Vector2( 0, 0 ) },
				"uRepeat" : { type: "v2", value: new THREE.Vector2( 1, 1 ) },
	
				"wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }
	
				}
	
			] ),
	
			fragmentShader: [
	
				"uniform vec3 uAmbientColor;",
				"uniform vec3 uDiffuseColor;",
				"uniform vec3 uSpecularColor;",
				"uniform float uShininess;",
				"uniform float uOpacity;",
	
				"uniform bool enableDiffuse;",
				"uniform bool enableSpecular;",
				"uniform bool enableAO;",
				"uniform bool enableReflection;",
	
				"uniform sampler2D tDiffuse;",
				"uniform sampler2D tNormal;",
				"uniform sampler2D tSpecular;",
				"uniform sampler2D tAO;",
	
				"uniform samplerCube tCube;",
	
				"uniform vec2 uNormalScale;",
	
				"uniform bool useRefract;",
				"uniform float uRefractionRatio;",
				"uniform float uReflectivity;",
	
				"varying vec3 vTangent;",
				"varying vec3 vBinormal;",
				"varying vec3 vNormal;",
				"varying vec2 vUv;",
	
				"uniform vec3 ambientLightColor;",
	
				"#if MAX_DIR_LIGHTS > 0",
	
					"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
					"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];",
	
				"#endif",
	
				"#if MAX_HEMI_LIGHTS > 0",
	
					"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];",
					"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];",
					"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];",
	
				"#endif",
	
				"#if MAX_POINT_LIGHTS > 0",
	
					"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",
					"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
					"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",
	
				"#endif",
	
				"#if MAX_SPOT_LIGHTS > 0",
	
					"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];",
					"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
					"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];",
					"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];",
					"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];",
					"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",
	
				"#endif",
	
				"#ifdef WRAP_AROUND",
	
					"uniform vec3 wrapRGB;",
	
				"#endif",
	
				"varying vec3 vWorldPosition;",
				"varying vec3 vViewPosition;",
	
				THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
				THREE.ShaderChunk[ "fog_pars_fragment" ],
	
				"void main() {",
	
					"gl_FragColor = vec4( vec3( 1.0 ), uOpacity );",
	
					"vec3 specularTex = vec3( 1.0 );",
	
					"vec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;",
					"normalTex.xy *= uNormalScale;",
					"normalTex = normalize( normalTex );",
	
					"if( enableDiffuse ) {",
	
						"#ifdef GAMMA_INPUT",
	
							"vec4 texelColor = texture2D( tDiffuse, vUv );",
							"texelColor.xyz *= texelColor.xyz;",
	
							"gl_FragColor = gl_FragColor * texelColor;",
	
						"#else",
	
							"gl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );",
	
						"#endif",
	
					"}",
	
					"if( enableAO ) {",
	
						"#ifdef GAMMA_INPUT",
	
							"vec4 aoColor = texture2D( tAO, vUv );",
							"aoColor.xyz *= aoColor.xyz;",
	
							"gl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;",
	
						"#else",
	
							"gl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;",
	
						"#endif",
	
					"}",
	
					"if( enableSpecular )",
						"specularTex = texture2D( tSpecular, vUv ).xyz;",
	
					"mat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );",
					"vec3 finalNormal = tsb * normalTex;",
	
					"#ifdef FLIP_SIDED",
	
						"finalNormal = -finalNormal;",
	
					"#endif",
	
					"vec3 normal = normalize( finalNormal );",
					"vec3 viewPosition = normalize( vViewPosition );",
	
					// point lights
	
					"#if MAX_POINT_LIGHTS > 0",
	
						"vec3 pointDiffuse = vec3( 0.0 );",
						"vec3 pointSpecular = vec3( 0.0 );",
	
						"for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",
	
							"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
							"vec3 pointVector = lPosition.xyz + vViewPosition.xyz;",
	
							"float pointDistance = 1.0;",
							"if ( pointLightDistance[ i ] > 0.0 )",
								"pointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );",
	
							"pointVector = normalize( pointVector );",
	
							// diffuse
	
							"#ifdef WRAP_AROUND",
	
								"float pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );",
								"float pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );",
	
								"vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );",
	
							"#else",
	
								"float pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );",
	
							"#endif",
	
							"pointDiffuse += pointDistance * pointLightColor[ i ] * uDiffuseColor * pointDiffuseWeight;",
	
							// specular
	
							"vec3 pointHalfVector = normalize( pointVector + viewPosition );",
							"float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );",
							"float pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, uShininess ), 0.0 );",
	
							"#ifdef PHYSICALLY_BASED_SHADING",
	
								// 2.0 => 2.0001 is hack to work around ANGLE bug
	
								"float specularNormalization = ( uShininess + 2.0001 ) / 8.0;",
	
								"vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( pointVector, pointHalfVector ), 5.0 );",
								"pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;",
	
							"#else",
	
								"pointSpecular += pointDistance * pointLightColor[ i ] * uSpecularColor * pointSpecularWeight * pointDiffuseWeight;",
	
							"#endif",
	
						"}",
	
					"#endif",
	
					// spot lights
	
					"#if MAX_SPOT_LIGHTS > 0",
	
						"vec3 spotDiffuse = vec3( 0.0 );",
						"vec3 spotSpecular = vec3( 0.0 );",
	
						"for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",
	
							"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
							"vec3 spotVector = lPosition.xyz + vViewPosition.xyz;",
	
							"float spotDistance = 1.0;",
							"if ( spotLightDistance[ i ] > 0.0 )",
								"spotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );",
	
							"spotVector = normalize( spotVector );",
	
							"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );",
	
							"if ( spotEffect > spotLightAngleCos[ i ] ) {",
	
								"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );",
	
								// diffuse
	
								"#ifdef WRAP_AROUND",
	
									"float spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );",
									"float spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );",
	
									"vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );",
	
								"#else",
	
									"float spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );",
	
								"#endif",
	
								"spotDiffuse += spotDistance * spotLightColor[ i ] * uDiffuseColor * spotDiffuseWeight * spotEffect;",
	
								// specular
	
								"vec3 spotHalfVector = normalize( spotVector + viewPosition );",
								"float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );",
								"float spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, uShininess ), 0.0 );",
	
								"#ifdef PHYSICALLY_BASED_SHADING",
	
									// 2.0 => 2.0001 is hack to work around ANGLE bug
	
									"float specularNormalization = ( uShininess + 2.0001 ) / 8.0;",
	
									"vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( spotVector, spotHalfVector ), 5.0 );",
									"spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;",
	
								"#else",
	
									"spotSpecular += spotDistance * spotLightColor[ i ] * uSpecularColor * spotSpecularWeight * spotDiffuseWeight * spotEffect;",
	
								"#endif",
	
							"}",
	
						"}",
	
					"#endif",
	
					// directional lights
	
					"#if MAX_DIR_LIGHTS > 0",
	
						"vec3 dirDiffuse = vec3( 0.0 );",
						"vec3 dirSpecular = vec3( 0.0 );",
	
						"for( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {",
	
							"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",
							"vec3 dirVector = normalize( lDirection.xyz );",
	
							// diffuse
	
							"#ifdef WRAP_AROUND",
	
								"float directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );",
								"float directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );",
	
								"vec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );",
	
							"#else",
	
								"float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );",
	
							"#endif",
	
							"dirDiffuse += directionalLightColor[ i ] * uDiffuseColor * dirDiffuseWeight;",
	
							// specular
	
							"vec3 dirHalfVector = normalize( dirVector + viewPosition );",
							"float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );",
							"float dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, uShininess ), 0.0 );",
	
							"#ifdef PHYSICALLY_BASED_SHADING",
	
								// 2.0 => 2.0001 is hack to work around ANGLE bug
	
								"float specularNormalization = ( uShininess + 2.0001 ) / 8.0;",
	
								"vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );",
								"dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;",
	
							"#else",
	
								"dirSpecular += directionalLightColor[ i ] * uSpecularColor * dirSpecularWeight * dirDiffuseWeight;",
	
							"#endif",
	
						"}",
	
					"#endif",
	
					// hemisphere lights
	
					"#if MAX_HEMI_LIGHTS > 0",
	
						"vec3 hemiDiffuse  = vec3( 0.0 );",
						"vec3 hemiSpecular = vec3( 0.0 );" ,
	
						"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {",
	
							"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );",
							"vec3 lVector = normalize( lDirection.xyz );",
	
							// diffuse
	
							"float dotProduct = dot( normal, lVector );",
							"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;",
	
							"vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );",
	
							"hemiDiffuse += uDiffuseColor * hemiColor;",
	
							// specular (sky light)
	
	
							"vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );",
							"float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;",
							"float hemiSpecularWeightSky = specularTex.r * max( pow( hemiDotNormalHalfSky, uShininess ), 0.0 );",
	
							// specular (ground light)
	
							"vec3 lVectorGround = -lVector;",
	
							"vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );",
							"float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;",
							"float hemiSpecularWeightGround = specularTex.r * max( pow( hemiDotNormalHalfGround, uShininess ), 0.0 );",
	
							"#ifdef PHYSICALLY_BASED_SHADING",
	
								"float dotProductGround = dot( normal, lVectorGround );",
	
								// 2.0 => 2.0001 is hack to work around ANGLE bug
	
								"float specularNormalization = ( uShininess + 2.0001 ) / 8.0;",
	
								"vec3 schlickSky = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );",
								"vec3 schlickGround = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );",
								"hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );",
	
							"#else",
	
								"hemiSpecular += uSpecularColor * hemiColor * ( hemiSpecularWeightSky + hemiSpecularWeightGround ) * hemiDiffuseWeight;",
	
							"#endif",
	
						"}",
	
					"#endif",
	
					// all lights contribution summation
	
					"vec3 totalDiffuse = vec3( 0.0 );",
					"vec3 totalSpecular = vec3( 0.0 );",
	
					"#if MAX_DIR_LIGHTS > 0",
	
						"totalDiffuse += dirDiffuse;",
						"totalSpecular += dirSpecular;",
	
					"#endif",
	
					"#if MAX_HEMI_LIGHTS > 0",
	
						"totalDiffuse += hemiDiffuse;",
						"totalSpecular += hemiSpecular;",
	
					"#endif",
	
					"#if MAX_POINT_LIGHTS > 0",
	
						"totalDiffuse += pointDiffuse;",
						"totalSpecular += pointSpecular;",
	
					"#endif",
	
					"#if MAX_SPOT_LIGHTS > 0",
	
						"totalDiffuse += spotDiffuse;",
						"totalSpecular += spotSpecular;",
	
					"#endif",
	
					"#ifdef METAL",
	
						"gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * uAmbientColor + totalSpecular );",
	
					"#else",
	
						"gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * uAmbientColor ) + totalSpecular;",
	
					"#endif",
	
					"if ( enableReflection ) {",
	
						"vec3 vReflect;",
						"vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );",
	
						"if ( useRefract ) {",
	
							"vReflect = refract( cameraToVertex, normal, uRefractionRatio );",
	
						"} else {",
	
							"vReflect = reflect( cameraToVertex, normal );",
	
						"}",
	
						"vec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );",
	
						"#ifdef GAMMA_INPUT",
	
							"cubeColor.xyz *= cubeColor.xyz;",
	
						"#endif",
	
						"gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * uReflectivity );",
	
					"}",
	
					THREE.ShaderChunk[ "shadowmap_fragment" ],
					THREE.ShaderChunk[ "linear_to_gamma_fragment" ],
					THREE.ShaderChunk[ "fog_fragment" ],
	
				"}"
	
			].join("\n"),
	
			vertexShader: [
	
				"attribute vec4 tangent;",
	
				"uniform vec2 uOffset;",
				"uniform vec2 uRepeat;",
	
				"uniform bool enableDisplacement;",
	
				"#ifdef VERTEX_TEXTURES",
	
					"uniform sampler2D tDisplacement;",
					"uniform float uDisplacementScale;",
					"uniform float uDisplacementBias;",
	
				"#endif",
	
				"varying vec3 vTangent;",
				"varying vec3 vBinormal;",
				"varying vec3 vNormal;",
				"varying vec2 vUv;",
	
				"varying vec3 vWorldPosition;",
				"varying vec3 vViewPosition;",
	
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
				THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "skinbase_vertex" ],
					THREE.ShaderChunk[ "skinnormal_vertex" ],
	
					// normal, tangent and binormal vectors
	
					"#ifdef USE_SKINNING",
	
						"vNormal = normalize( normalMatrix * skinnedNormal.xyz );",
	
						"vec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );",
						"vTangent = normalize( normalMatrix * skinnedTangent.xyz );",
	
					"#else",
	
						"vNormal = normalize( normalMatrix * normal );",
						"vTangent = normalize( normalMatrix * tangent.xyz );",
	
					"#endif",
	
					"vBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );",
	
					"vUv = uv * uRepeat + uOffset;",
	
					// displacement mapping
	
					"vec3 displacedPosition;",
	
					"#ifdef VERTEX_TEXTURES",
	
						"if ( enableDisplacement ) {",
	
							"vec3 dv = texture2D( tDisplacement, uv ).xyz;",
							"float df = uDisplacementScale * dv.x + uDisplacementBias;",
							"displacedPosition = position + normalize( normal ) * df;",
	
						"} else {",
	
							"#ifdef USE_SKINNING",
	
								"vec4 skinVertex = vec4( position, 1.0 );",
	
								"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;",
								"skinned 	  += boneMatY * skinVertex * skinWeight.y;",
	
								"displacedPosition  = skinned.xyz;",
	
							"#else",
	
								"displacedPosition = position;",
	
							"#endif",
	
						"}",
	
					"#else",
	
						"#ifdef USE_SKINNING",
	
							"vec4 skinVertex = vec4( position, 1.0 );",
	
							"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;",
							"skinned 	  += boneMatY * skinVertex * skinWeight.y;",
	
							"displacedPosition  = skinned.xyz;",
	
						"#else",
	
							"displacedPosition = position;",
	
						"#endif",
	
					"#endif",
	
					//
	
					"vec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );",
					"vec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );",
	
					"gl_Position = projectionMatrix * mvPosition;",
	
					//
	
					"vWorldPosition = worldPosition.xyz;",
					"vViewPosition = -mvPosition.xyz;",
	
					// shadows
	
					"#ifdef USE_SHADOWMAP",
	
						"for( int i = 0; i < MAX_SHADOWS; i ++ ) {",
	
							"vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;",
	
						"}",
	
					"#endif",
	
				"}"
	
			].join("\n")
	
		},
	
		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */
	
		'cube': {
	
			uniforms: { "tCube": { type: "t", value: null },
						"tFlip": { type: "f", value: -1 } },
	
			vertexShader: [
	
				"varying vec3 vWorldPosition;",
	
				"void main() {",
	
					"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
					"vWorldPosition = worldPosition.xyz;",
	
					"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
	
				"}"
	
			].join("\n"),
	
			fragmentShader: [
	
				"uniform samplerCube tCube;",
				"uniform float tFlip;",
	
				"varying vec3 vWorldPosition;",
	
				"void main() {",
	
					"gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",
	
				"}"
	
			].join("\n")
	
		},
	
		// Depth encoding into RGBA texture
		// 	based on SpiderGL shadow map example
		// 		http://spidergl.org/example.php?id=6
		// 	originally from
		//		http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD
		// 	see also here:
		//		http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/
	
		'depthRGBA': {
	
			uniforms: {},
	
			vertexShader: [
	
				THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
				THREE.ShaderChunk[ "skinning_pars_vertex" ],
	
				"void main() {",
	
					THREE.ShaderChunk[ "skinbase_vertex" ],
					THREE.ShaderChunk[ "morphtarget_vertex" ],
					THREE.ShaderChunk[ "skinning_vertex" ],
					THREE.ShaderChunk[ "default_vertex" ],
	
				"}"
	
			].join("\n"),
	
			fragmentShader: [
	
				"vec4 pack_depth( const in float depth ) {",
	
					"const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
					"const vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
					"vec4 res = fract( depth * bit_shift );",
					"res -= res.xxyz * bit_mask;",
					"return res;",
	
				"}",
	
				"void main() {",
	
					"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );",
	
					//"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );",
					//"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );",
					//"gl_FragData[ 0 ] = pack_depth( z );",
					//"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );",
	
				"}"
	
			].join("\n")
	
		}
	
	};
	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */
	
	THREE.WebGLRenderer = function ( parameters ) {
	
		console.log( 'THREE.WebGLRenderer', THREE.REVISION );
	
		parameters = parameters || {};
	
		var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),
	
		_precision = parameters.precision !== undefined ? parameters.precision : 'highp',
	
		_alpha = parameters.alpha !== undefined ? parameters.alpha : true,
		_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
		_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
		_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
		_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
	
		_clearColor = parameters.clearColor !== undefined ? new THREE.Color( parameters.clearColor ) : new THREE.Color( 0x000000 ),
		_clearAlpha = parameters.clearAlpha !== undefined ? parameters.clearAlpha : 0;
	
		// public properties
	
		this.domElement = _canvas;
		this.context = null;
		this.devicePixelRatio = parameters.devicePixelRatio !== undefined
					? parameters.devicePixelRatio
					: window.devicePixelRatio !== undefined
						? window.devicePixelRatio
						: 1;
	
		// clearing
	
		this.autoClear = true;
		this.autoClearColor = true;
		this.autoClearDepth = true;
		this.autoClearStencil = true;
	
		// scene graph
	
		this.sortObjects = true;
	
		this.autoUpdateObjects = true;
		this.autoUpdateScene = true;
	
		// physically based shading
	
		this.gammaInput = false;
		this.gammaOutput = false;
		this.physicallyBasedShading = false;
	
		// shadow map
	
		this.shadowMapEnabled = false;
		this.shadowMapAutoUpdate = true;
		this.shadowMapType = THREE.PCFShadowMap;
		this.shadowMapCullFace = THREE.CullFaceFront;
		this.shadowMapDebug = false;
		this.shadowMapCascade = false;
	
		// morphs
	
		this.maxMorphTargets = 8;
		this.maxMorphNormals = 4;
	
		// flags
	
		this.autoScaleCubemaps = true;
	
		// custom render plugins
	
		this.renderPluginsPre = [];
		this.renderPluginsPost = [];
	
		// info
	
		this.info = {
	
			memory: {
	
				programs: 0,
				geometries: 0,
				textures: 0
	
			},
	
			render: {
	
				calls: 0,
				vertices: 0,
				faces: 0,
				points: 0
	
			}
	
		};
	
		// internal properties
	
		var _this = this,
	
		_programs = [],
		_programs_counter = 0,
	
		// internal state cache
	
		_currentProgram = null,
		_currentFramebuffer = null,
		_currentMaterialId = -1,
		_currentGeometryGroupHash = null,
		_currentCamera = null,
		_geometryGroupCounter = 0,
	
		_usedTextureUnits = 0,
	
		// GL state cache
	
		_oldDoubleSided = -1,
		_oldFlipSided = -1,
	
		_oldBlending = -1,
	
		_oldBlendEquation = -1,
		_oldBlendSrc = -1,
		_oldBlendDst = -1,
	
		_oldDepthTest = -1,
		_oldDepthWrite = -1,
	
		_oldPolygonOffset = null,
		_oldPolygonOffsetFactor = null,
		_oldPolygonOffsetUnits = null,
	
		_oldLineWidth = null,
	
		_viewportX = 0,
		_viewportY = 0,
		_viewportWidth = 0,
		_viewportHeight = 0,
		_currentWidth = 0,
		_currentHeight = 0,
	
		_enabledAttributes = {},
	
		// frustum
	
		_frustum = new THREE.Frustum(),
	
		 // camera matrices cache
	
		_projScreenMatrix = new THREE.Matrix4(),
		_projScreenMatrixPS = new THREE.Matrix4(),
	
		_vector3 = new THREE.Vector3(),
	
		// light arrays cache
	
		_direction = new THREE.Vector3(),
	
		_lightsNeedUpdate = true,
	
		_lights = {
	
			ambient: [ 0, 0, 0 ],
			directional: { length: 0, colors: new Array(), positions: new Array() },
			point: { length: 0, colors: new Array(), positions: new Array(), distances: new Array() },
			spot: { length: 0, colors: new Array(), positions: new Array(), distances: new Array(), directions: new Array(), anglesCos: new Array(), exponents: new Array() },
			hemi: { length: 0, skyColors: new Array(), groundColors: new Array(), positions: new Array() }
	
		};
	
		// initialize
	
		var _gl;
	
		var _glExtensionTextureFloat;
		var _glExtensionStandardDerivatives;
		var _glExtensionTextureFilterAnisotropic;
		var _glExtensionCompressedTextureS3TC;
	
		initGL();
	
		setDefaultGLState();
	
		this.context = _gl;
	
		// GPU capabilities
	
		var _maxTextures = _gl.getParameter( _gl.MAX_TEXTURE_IMAGE_UNITS );
		var _maxVertexTextures = _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
		var _maxTextureSize = _gl.getParameter( _gl.MAX_TEXTURE_SIZE );
		var _maxCubemapSize = _gl.getParameter( _gl.MAX_CUBE_MAP_TEXTURE_SIZE );
	
		var _maxAnisotropy = _glExtensionTextureFilterAnisotropic ? _gl.getParameter( _glExtensionTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT ) : 0;
	
		var _supportsVertexTextures = ( _maxVertexTextures > 0 );
		var _supportsBoneTextures = _supportsVertexTextures && _glExtensionTextureFloat;
	
		var _compressedTextureFormats = _glExtensionCompressedTextureS3TC ? _gl.getParameter( _gl.COMPRESSED_TEXTURE_FORMATS ) : [];
	
		//
	
		var _vertexShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_FLOAT );
		var _vertexShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_FLOAT );
		var _vertexShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.LOW_FLOAT );
	
		var _fragmentShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_FLOAT );
		var _fragmentShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_FLOAT );
		var _fragmentShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.LOW_FLOAT );
	
		var _vertexShaderPrecisionHighpInt = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_INT );
		var _vertexShaderPrecisionMediumpInt = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_INT );
		var _vertexShaderPrecisionLowpInt = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.LOW_INT );
	
		var _fragmentShaderPrecisionHighpInt = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_INT );
		var _fragmentShaderPrecisionMediumpInt = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_INT );
		var _fragmentShaderPrecisionLowpInt = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.LOW_INT );
	
		// clamp precision to maximum available
	
		var highpAvailable = _vertexShaderPrecisionHighpFloat.precision > 0 && _fragmentShaderPrecisionHighpFloat.precision > 0;
		var mediumpAvailable = _vertexShaderPrecisionMediumpFloat.precision > 0 && _fragmentShaderPrecisionMediumpFloat.precision > 0;
	
		if ( _precision === "highp" && ! highpAvailable ) {
	
			if ( mediumpAvailable ) {
	
				_precision = "mediump";
				console.warn( "WebGLRenderer: highp not supported, using mediump" );
	
			} else {
	
				_precision = "lowp";
				console.warn( "WebGLRenderer: highp and mediump not supported, using lowp" );
	
			}
	
		}
	
		if ( _precision === "mediump" && ! mediumpAvailable ) {
	
			_precision = "lowp";
			console.warn( "WebGLRenderer: mediump not supported, using lowp" );
	
		}
	
		// API
	
		this.getContext = function () {
	
			return _gl;
	
		};
	
		this.supportsVertexTextures = function () {
	
			return _supportsVertexTextures;
	
		};
	
		this.supportsFloatTextures = function () {
	
			return _glExtensionTextureFloat;
	
		};
		
		this.supportsStandardDerivatives = function () {
	
			return _glExtensionStandardDerivatives;
	
		};
		
		this.supportsCompressedTextureS3TC = function () {
	
			return _glExtensionCompressedTextureS3TC;
	
		};
		
		this.getMaxAnisotropy  = function () {
	
			return _maxAnisotropy;
	
		};
	
		this.getPrecision = function () {
	
			return _precision;
	
		};
	
		this.setSize = function ( width, height ) {
	
			_canvas.width = width * this.devicePixelRatio;
			_canvas.height = height * this.devicePixelRatio;
	
			_canvas.style.width = width + 'px';
			_canvas.style.height = height + 'px';
	
			this.setViewport( 0, 0, _canvas.width, _canvas.height );
	
		};
	
		this.setViewport = function ( x, y, width, height ) {
	
			_viewportX = x !== undefined ? x : 0;
			_viewportY = y !== undefined ? y : 0;
	
			_viewportWidth = width !== undefined ? width : _canvas.width;
			_viewportHeight = height !== undefined ? height : _canvas.height;
	
			_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );
	
		};
	
		this.setScissor = function ( x, y, width, height ) {
	
			_gl.scissor( x, y, width, height );
	
		};
	
		this.enableScissorTest = function ( enable ) {
	
			enable ? _gl.enable( _gl.SCISSOR_TEST ) : _gl.disable( _gl.SCISSOR_TEST );
	
		};
	
		// Clearing
	
		this.setClearColorHex = function ( hex, alpha ) {
	
			_clearColor.setHex( hex );
			_clearAlpha = alpha;
	
			_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );
	
		};
	
		this.setClearColor = function ( color, alpha ) {
	
			_clearColor.copy( color );
			_clearAlpha = alpha;
	
			_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );
	
		};
	
		this.getClearColor = function () {
	
			return _clearColor;
	
		};
	
		this.getClearAlpha = function () {
	
			return _clearAlpha;
	
		};
	
		this.clear = function ( color, depth, stencil ) {
	
			var bits = 0;
	
			if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
			if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
			if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;
	
			_gl.clear( bits );
	
		};
	
		this.clearTarget = function ( renderTarget, color, depth, stencil ) {
	
			this.setRenderTarget( renderTarget );
			this.clear( color, depth, stencil );
	
		};
	
		// Plugins
	
		this.addPostPlugin = function ( plugin ) {
	
			plugin.init( this );
			this.renderPluginsPost.push( plugin );
	
		};
	
		this.addPrePlugin = function ( plugin ) {
	
			plugin.init( this );
			this.renderPluginsPre.push( plugin );
	
		};
	
		// Rendering
	
		this.updateShadowMap = function ( scene, camera ) {
	
			_currentProgram = null;
			_oldBlending = -1;
			_oldDepthTest = -1;
			_oldDepthWrite = -1;
			_currentGeometryGroupHash = -1;
			_currentMaterialId = -1;
			_lightsNeedUpdate = true;
			_oldDoubleSided = -1;
			_oldFlipSided = -1;
	
			this.shadowMapPlugin.update( scene, camera );
	
		};
	
		// Internal functions
	
		// Buffer allocation
	
		function createParticleBuffers ( geometry ) {
	
			geometry.__webglVertexBuffer = _gl.createBuffer();
			geometry.__webglColorBuffer = _gl.createBuffer();
	
			_this.info.memory.geometries ++;
	
		};
	
		function createLineBuffers ( geometry ) {
	
			geometry.__webglVertexBuffer = _gl.createBuffer();
			geometry.__webglColorBuffer = _gl.createBuffer();
			geometry.__webglLineDistanceBuffer = _gl.createBuffer();
	
			_this.info.memory.geometries ++;
	
		};
	
		function createRibbonBuffers ( geometry ) {
	
			geometry.__webglVertexBuffer = _gl.createBuffer();
			geometry.__webglColorBuffer = _gl.createBuffer();
			geometry.__webglNormalBuffer = _gl.createBuffer();
	
			_this.info.memory.geometries ++;
	
		};
	
		function createMeshBuffers ( geometryGroup ) {
	
			geometryGroup.__webglVertexBuffer = _gl.createBuffer();
			geometryGroup.__webglNormalBuffer = _gl.createBuffer();
			geometryGroup.__webglTangentBuffer = _gl.createBuffer();
			geometryGroup.__webglColorBuffer = _gl.createBuffer();
			geometryGroup.__webglUVBuffer = _gl.createBuffer();
			geometryGroup.__webglUV2Buffer = _gl.createBuffer();
	
			geometryGroup.__webglSkinIndicesBuffer = _gl.createBuffer();
			geometryGroup.__webglSkinWeightsBuffer = _gl.createBuffer();
	
			geometryGroup.__webglFaceBuffer = _gl.createBuffer();
			geometryGroup.__webglLineBuffer = _gl.createBuffer();
	
			var m, ml;
	
			if ( geometryGroup.numMorphTargets ) {
	
				geometryGroup.__webglMorphTargetsBuffers = [];
	
				for ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {
	
					geometryGroup.__webglMorphTargetsBuffers.push( _gl.createBuffer() );
	
				}
	
			}
	
			if ( geometryGroup.numMorphNormals ) {
	
				geometryGroup.__webglMorphNormalsBuffers = [];
	
				for ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {
	
					geometryGroup.__webglMorphNormalsBuffers.push( _gl.createBuffer() );
	
				}
	
			}
	
			_this.info.memory.geometries ++;
	
		};
	
		// Events
	
		var onGeometryDispose = function ( event ) {
	
			var geometry = event.target;
	
			geometry.removeEventListener( 'dispose', onGeometryDispose );
	
			deallocateGeometry( geometry );
	
			_this.info.memory.geometries --;
	
		};
	
		var onTextureDispose = function ( event ) {
	
			var texture = event.target;
	
			texture.removeEventListener( 'dispose', onTextureDispose );
	
			deallocateTexture( texture );
	
			_this.info.memory.textures --;
	
	
		};
	
		var onRenderTargetDispose = function ( event ) {
	
			var renderTarget = event.target;
	
			renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );
	
			deallocateRenderTarget( renderTarget );
	
			_this.info.memory.textures --;
	
		};
	
		var onMaterialDispose = function ( event ) {
	
			var material = event.target;
	
			material.removeEventListener( 'dispose', onMaterialDispose );
	
			deallocateMaterial( material );
	
		};
	
		// Buffer deallocation
	
		var deallocateGeometry = function ( geometry ) {
	
			geometry.__webglInit = undefined;
	
			if ( geometry.__webglVertexBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglVertexBuffer );
			if ( geometry.__webglNormalBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglNormalBuffer );
			if ( geometry.__webglTangentBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglTangentBuffer );
			if ( geometry.__webglColorBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglColorBuffer );
			if ( geometry.__webglUVBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglUVBuffer );
			if ( geometry.__webglUV2Buffer !== undefined ) _gl.deleteBuffer( geometry.__webglUV2Buffer );
	
			if ( geometry.__webglSkinIndicesBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglSkinIndicesBuffer );
			if ( geometry.__webglSkinWeightsBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglSkinWeightsBuffer );
	
			if ( geometry.__webglFaceBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglFaceBuffer );
			if ( geometry.__webglLineBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglLineBuffer );
	
			if ( geometry.__webglLineDistanceBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglLineDistanceBuffer );
	
			// geometry groups
	
			if ( geometry.geometryGroups !== undefined ) {
	
				for ( var g in geometry.geometryGroups ) {
	
					var geometryGroup = geometry.geometryGroups[ g ];
	
					if ( geometryGroup.numMorphTargets !== undefined ) {
	
						for ( var m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {
	
							_gl.deleteBuffer( geometryGroup.__webglMorphTargetsBuffers[ m ] );
	
						}
	
					}
	
					if ( geometryGroup.numMorphNormals !== undefined ) {
	
						for ( var m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {
	
							_gl.deleteBuffer( geometryGroup.__webglMorphNormalsBuffers[ m ] );
	
						}
	
					}
	
					deleteCustomAttributesBuffers( geometryGroup );
	
				}
	
			}
	
			deleteCustomAttributesBuffers( geometry );
	
		};
	
		var deallocateTexture = function ( texture ) {
	
			if ( texture.image && texture.image.__webglTextureCube ) {
	
				// cube texture
	
				_gl.deleteTexture( texture.image.__webglTextureCube );
	
			} else {
	
				// 2D texture
	
				if ( ! texture.__webglInit ) return;
	
				texture.__webglInit = false;
				_gl.deleteTexture( texture.__webglTexture );
	
			}
	
		};
	
		var deallocateRenderTarget = function ( renderTarget ) {
	
			if ( !renderTarget || ! renderTarget.__webglTexture ) return;
	
			_gl.deleteTexture( renderTarget.__webglTexture );
	
			if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {
	
				for ( var i = 0; i < 6; i ++ ) {
	
					_gl.deleteFramebuffer( renderTarget.__webglFramebuffer[ i ] );
					_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer[ i ] );
	
				}
	
			} else {
	
				_gl.deleteFramebuffer( renderTarget.__webglFramebuffer );
				_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer );
	
			}
	
		};
	
		var deallocateMaterial = function ( material ) {
	
			var program = material.program;
	
			if ( program === undefined ) return;
	
			material.program = undefined;
	
			// only deallocate GL program if this was the last use of shared program
			// assumed there is only single copy of any program in the _programs list
			// (that's how it's constructed)
	
			var i, il, programInfo;
			var deleteProgram = false;
	
			for ( i = 0, il = _programs.length; i < il; i ++ ) {
	
				programInfo = _programs[ i ];
	
				if ( programInfo.program === program ) {
	
					programInfo.usedTimes --;
	
					if ( programInfo.usedTimes === 0 ) {
	
						deleteProgram = true;
	
					}
	
					break;
	
				}
	
			}
	
			if ( deleteProgram === true ) {
	
				// avoid using array.splice, this is costlier than creating new array from scratch
	
				var newPrograms = [];
	
				for ( i = 0, il = _programs.length; i < il; i ++ ) {
	
					programInfo = _programs[ i ];
	
					if ( programInfo.program !== program ) {
	
						newPrograms.push( programInfo );
	
					}
	
				}
	
				_programs = newPrograms;
	
				_gl.deleteProgram( program );
	
				_this.info.memory.programs --;
	
			}
	
		};
	
		//
	
		/*
		function deleteParticleBuffers ( geometry ) {
	
			_gl.deleteBuffer( geometry.__webglVertexBuffer );
			_gl.deleteBuffer( geometry.__webglColorBuffer );
	
			deleteCustomAttributesBuffers( geometry );
	
			_this.info.memory.geometries --;
	
		};
	
		function deleteLineBuffers ( geometry ) {
	
			_gl.deleteBuffer( geometry.__webglVertexBuffer );
			_gl.deleteBuffer( geometry.__webglColorBuffer );
			_gl.deleteBuffer( geometry.__webglLineDistanceBuffer );
	
			deleteCustomAttributesBuffers( geometry );
	
			_this.info.memory.geometries --;
	
		};
	
		function deleteRibbonBuffers ( geometry ) {
	
			_gl.deleteBuffer( geometry.__webglVertexBuffer );
			_gl.deleteBuffer( geometry.__webglColorBuffer );
			_gl.deleteBuffer( geometry.__webglNormalBuffer );
	
			deleteCustomAttributesBuffers( geometry );
	
			_this.info.memory.geometries --;
	
		};
	
		function deleteMeshBuffers ( geometryGroup ) {
	
			_gl.deleteBuffer( geometryGroup.__webglVertexBuffer );
			_gl.deleteBuffer( geometryGroup.__webglNormalBuffer );
			_gl.deleteBuffer( geometryGroup.__webglTangentBuffer );
			_gl.deleteBuffer( geometryGroup.__webglColorBuffer );
			_gl.deleteBuffer( geometryGroup.__webglUVBuffer );
			_gl.deleteBuffer( geometryGroup.__webglUV2Buffer );
	
			_gl.deleteBuffer( geometryGroup.__webglSkinIndicesBuffer );
			_gl.deleteBuffer( geometryGroup.__webglSkinWeightsBuffer );
	
			_gl.deleteBuffer( geometryGroup.__webglFaceBuffer );
			_gl.deleteBuffer( geometryGroup.__webglLineBuffer );
	
			var m, ml;
	
			if ( geometryGroup.numMorphTargets ) {
	
				for ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {
	
					_gl.deleteBuffer( geometryGroup.__webglMorphTargetsBuffers[ m ] );
	
				}
	
			}
	
			if ( geometryGroup.numMorphNormals ) {
	
				for ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {
	
					_gl.deleteBuffer( geometryGroup.__webglMorphNormalsBuffers[ m ] );
	
				}
	
			}
	
			deleteCustomAttributesBuffers( geometryGroup );
	
			_this.info.memory.geometries --;
	
		};
		*/
	
		function deleteCustomAttributesBuffers( geometry ) {
	
			if ( geometry.__webglCustomAttributesList ) {
	
				for ( var id in geometry.__webglCustomAttributesList ) {
	
					_gl.deleteBuffer( geometry.__webglCustomAttributesList[ id ].buffer );
	
				}
	
			}
	
		};
	
		// Buffer initialization
	
		function initCustomAttributes ( geometry, object ) {
	
			var nvertices = geometry.vertices.length;
	
			var material = object.material;
	
			if ( material.attributes ) {
	
				if ( geometry.__webglCustomAttributesList === undefined ) {
	
					geometry.__webglCustomAttributesList = [];
	
				}
	
				for ( var a in material.attributes ) {
	
					var attribute = material.attributes[ a ];
	
					if ( !attribute.__webglInitialized || attribute.createUniqueBuffers ) {
	
						attribute.__webglInitialized = true;
	
						var size = 1;		// "f" and "i"
	
						if ( attribute.type === "v2" ) size = 2;
						else if ( attribute.type === "v3" ) size = 3;
						else if ( attribute.type === "v4" ) size = 4;
						else if ( attribute.type === "c"  ) size = 3;
	
						attribute.size = size;
	
						attribute.array = new Float32Array( nvertices * size );
	
						attribute.buffer = _gl.createBuffer();
						attribute.buffer.belongsToAttribute = a;
	
						attribute.needsUpdate = true;
	
					}
	
					geometry.__webglCustomAttributesList.push( attribute );
	
				}
	
			}
	
		};
	
		function initParticleBuffers ( geometry, object ) {
	
			var nvertices = geometry.vertices.length;
	
			geometry.__vertexArray = new Float32Array( nvertices * 3 );
			geometry.__colorArray = new Float32Array( nvertices * 3 );
	
			geometry.__sortArray = [];
	
			geometry.__webglParticleCount = nvertices;
	
			initCustomAttributes ( geometry, object );
	
		};
	
		function initLineBuffers ( geometry, object ) {
	
			var nvertices = geometry.vertices.length;
	
			geometry.__vertexArray = new Float32Array( nvertices * 3 );
			geometry.__colorArray = new Float32Array( nvertices * 3 );
			geometry.__lineDistanceArray = new Float32Array( nvertices * 1 );
	
			geometry.__webglLineCount = nvertices;
	
			initCustomAttributes ( geometry, object );
	
		};
	
		function initRibbonBuffers ( geometry, object ) {
	
			var nvertices = geometry.vertices.length;
	
			geometry.__vertexArray = new Float32Array( nvertices * 3 );
			geometry.__colorArray = new Float32Array( nvertices * 3 );
			geometry.__normalArray = new Float32Array( nvertices * 3 );
	
			geometry.__webglVertexCount = nvertices;
	
			initCustomAttributes ( geometry, object );
	
		};
	
		function initMeshBuffers ( geometryGroup, object ) {
	
			var geometry = object.geometry,
				faces3 = geometryGroup.faces3,
				faces4 = geometryGroup.faces4,
	
				nvertices = faces3.length * 3 + faces4.length * 4,
				ntris     = faces3.length * 1 + faces4.length * 2,
				nlines    = faces3.length * 3 + faces4.length * 4,
	
				material = getBufferMaterial( object, geometryGroup ),
	
				uvType = bufferGuessUVType( material ),
				normalType = bufferGuessNormalType( material ),
				vertexColorType = bufferGuessVertexColorType( material );
	
			//console.log( "uvType", uvType, "normalType", normalType, "vertexColorType", vertexColorType, object, geometryGroup, material );
	
			geometryGroup.__vertexArray = new Float32Array( nvertices * 3 );
	
			if ( normalType ) {
	
				geometryGroup.__normalArray = new Float32Array( nvertices * 3 );
	
			}
	
			if ( geometry.hasTangents ) {
	
				geometryGroup.__tangentArray = new Float32Array( nvertices * 4 );
	
			}
	
			if ( vertexColorType ) {
	
				geometryGroup.__colorArray = new Float32Array( nvertices * 3 );
	
			}
	
			if ( uvType ) {
	
				if ( geometry.faceUvs.length > 0 || geometry.faceVertexUvs.length > 0 ) {
	
					geometryGroup.__uvArray = new Float32Array( nvertices * 2 );
	
				}
	
				if ( geometry.faceUvs.length > 1 || geometry.faceVertexUvs.length > 1 ) {
	
					geometryGroup.__uv2Array = new Float32Array( nvertices * 2 );
	
				}
	
			}
	
			if ( object.geometry.skinWeights.length && object.geometry.skinIndices.length ) {
	
				geometryGroup.__skinIndexArray = new Float32Array( nvertices * 4 );
				geometryGroup.__skinWeightArray = new Float32Array( nvertices * 4 );
	
			}
	
			geometryGroup.__faceArray = new Uint16Array( ntris * 3 );
			geometryGroup.__lineArray = new Uint16Array( nlines * 2 );
	
			var m, ml;
	
			if ( geometryGroup.numMorphTargets ) {
	
				geometryGroup.__morphTargetsArrays = [];
	
				for ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {
	
					geometryGroup.__morphTargetsArrays.push( new Float32Array( nvertices * 3 ) );
	
				}
	
			}
	
			if ( geometryGroup.numMorphNormals ) {
	
				geometryGroup.__morphNormalsArrays = [];
	
				for ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {
	
					geometryGroup.__morphNormalsArrays.push( new Float32Array( nvertices * 3 ) );
	
				}
	
			}
	
			geometryGroup.__webglFaceCount = ntris * 3;
			geometryGroup.__webglLineCount = nlines * 2;
	
	
			// custom attributes
	
			if ( material.attributes ) {
	
				if ( geometryGroup.__webglCustomAttributesList === undefined ) {
	
					geometryGroup.__webglCustomAttributesList = [];
	
				}
	
				for ( var a in material.attributes ) {
	
					// Do a shallow copy of the attribute object so different geometryGroup chunks use different
					// attribute buffers which are correctly indexed in the setMeshBuffers function
	
					var originalAttribute = material.attributes[ a ];
	
					var attribute = {};
	
					for ( var property in originalAttribute ) {
	
						attribute[ property ] = originalAttribute[ property ];
	
					}
	
					if ( !attribute.__webglInitialized || attribute.createUniqueBuffers ) {
	
						attribute.__webglInitialized = true;
	
						var size = 1;		// "f" and "i"
	
						if( attribute.type === "v2" ) size = 2;
						else if( attribute.type === "v3" ) size = 3;
						else if( attribute.type === "v4" ) size = 4;
						else if( attribute.type === "c"  ) size = 3;
	
						attribute.size = size;
	
						attribute.array = new Float32Array( nvertices * size );
	
						attribute.buffer = _gl.createBuffer();
						attribute.buffer.belongsToAttribute = a;
	
						originalAttribute.needsUpdate = true;
						attribute.__original = originalAttribute;
	
					}
	
					geometryGroup.__webglCustomAttributesList.push( attribute );
	
				}
	
			}
	
			geometryGroup.__inittedArrays = true;
	
		};
	
		function getBufferMaterial( object, geometryGroup ) {
	
			return object.material instanceof THREE.MeshFaceMaterial
				? object.material.materials[ geometryGroup.materialIndex ]
				: object.material;
	
		};
	
		function materialNeedsSmoothNormals ( material ) {
	
			return material && material.shading !== undefined && material.shading === THREE.SmoothShading;
	
		};
	
		function bufferGuessNormalType ( material ) {
	
			// only MeshBasicMaterial and MeshDepthMaterial don't need normals
	
			if ( ( material instanceof THREE.MeshBasicMaterial && !material.envMap ) || material instanceof THREE.MeshDepthMaterial ) {
	
				return false;
	
			}
	
			if ( materialNeedsSmoothNormals( material ) ) {
	
				return THREE.SmoothShading;
	
			} else {
	
				return THREE.FlatShading;
	
			}
	
		};
	
		function bufferGuessVertexColorType ( material ) {
	
			if ( material.vertexColors ) {
	
				return material.vertexColors;
	
			}
	
			return false;
	
		};
	
		function bufferGuessUVType ( material ) {
	
			// material must use some texture to require uvs
	
			if ( material.map || material.lightMap || material.bumpMap || material.normalMap || material.specularMap || material instanceof THREE.ShaderMaterial ) {
	
				return true;
	
			}
	
			return false;
	
		};
	
		//
	
		function initDirectBuffers( geometry ) {
	
			var a, attribute, type;
	
			for ( a in geometry.attributes ) {
	
				if ( a === "index" ) {
	
					type = _gl.ELEMENT_ARRAY_BUFFER;
	
				} else {
	
					type = _gl.ARRAY_BUFFER;
	
				}
	
				attribute = geometry.attributes[ a ];
	
				attribute.buffer = _gl.createBuffer();
	
				_gl.bindBuffer( type, attribute.buffer );
				_gl.bufferData( type, attribute.array, _gl.STATIC_DRAW );
	
			}
	
		};
	
		// Buffer setting
	
		function setParticleBuffers ( geometry, hint, object ) {
	
			var v, c, vertex, offset, index, color,
	
			vertices = geometry.vertices,
			vl = vertices.length,
	
			colors = geometry.colors,
			cl = colors.length,
	
			vertexArray = geometry.__vertexArray,
			colorArray = geometry.__colorArray,
	
			sortArray = geometry.__sortArray,
	
			dirtyVertices = geometry.verticesNeedUpdate,
			dirtyElements = geometry.elementsNeedUpdate,
			dirtyColors = geometry.colorsNeedUpdate,
	
			customAttributes = geometry.__webglCustomAttributesList,
			i, il,
			a, ca, cal, value,
			customAttribute;
	
			if ( object.sortParticles ) {
	
				_projScreenMatrixPS.copy( _projScreenMatrix );
				_projScreenMatrixPS.multiply( object.matrixWorld );
	
				for ( v = 0; v < vl; v ++ ) {
	
					vertex = vertices[ v ];
	
					_vector3.copy( vertex );
					_vector3.applyProjection( _projScreenMatrixPS );
	
					sortArray[ v ] = [ _vector3.z, v ];
	
				}
	
				sortArray.sort( numericalSort );
	
				for ( v = 0; v < vl; v ++ ) {
	
					vertex = vertices[ sortArray[v][1] ];
	
					offset = v * 3;
	
					vertexArray[ offset ]     = vertex.x;
					vertexArray[ offset + 1 ] = vertex.y;
					vertexArray[ offset + 2 ] = vertex.z;
	
				}
	
				for ( c = 0; c < cl; c ++ ) {
	
					offset = c * 3;
	
					color = colors[ sortArray[c][1] ];
	
					colorArray[ offset ]     = color.r;
					colorArray[ offset + 1 ] = color.g;
					colorArray[ offset + 2 ] = color.b;
	
				}
	
				if ( customAttributes ) {
	
					for ( i = 0, il = customAttributes.length; i < il; i ++ ) {
	
						customAttribute = customAttributes[ i ];
	
						if ( ! ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) ) continue;
	
						offset = 0;
	
						cal = customAttribute.value.length;
	
						if ( customAttribute.size === 1 ) {
	
							for ( ca = 0; ca < cal; ca ++ ) {
	
								index = sortArray[ ca ][ 1 ];
	
								customAttribute.array[ ca ] = customAttribute.value[ index ];
	
							}
	
						} else if ( customAttribute.size === 2 ) {
	
							for ( ca = 0; ca < cal; ca ++ ) {
	
								index = sortArray[ ca ][ 1 ];
	
								value = customAttribute.value[ index ];
	
								customAttribute.array[ offset ] 	= value.x;
								customAttribute.array[ offset + 1 ] = value.y;
	
								offset += 2;
	
							}
	
						} else if ( customAttribute.size === 3 ) {
	
							if ( customAttribute.type === "c" ) {
	
								for ( ca = 0; ca < cal; ca ++ ) {
	
									index = sortArray[ ca ][ 1 ];
	
									value = customAttribute.value[ index ];
	
									customAttribute.array[ offset ]     = value.r;
									customAttribute.array[ offset + 1 ] = value.g;
									customAttribute.array[ offset + 2 ] = value.b;
	
									offset += 3;
	
								}
	
							} else {
	
								for ( ca = 0; ca < cal; ca ++ ) {
	
									index = sortArray[ ca ][ 1 ];
	
									value = customAttribute.value[ index ];
	
									customAttribute.array[ offset ] 	= value.x;
									customAttribute.array[ offset + 1 ] = value.y;
									customAttribute.array[ offset + 2 ] = value.z;
	
									offset += 3;
	
								}
	
							}
	
						} else if ( customAttribute.size === 4 ) {
	
							for ( ca = 0; ca < cal; ca ++ ) {
	
								index = sortArray[ ca ][ 1 ];
	
								value = customAttribute.value[ index ];
	
								customAttribute.array[ offset ]      = value.x;
								customAttribute.array[ offset + 1  ] = value.y;
								customAttribute.array[ offset + 2  ] = value.z;
								customAttribute.array[ offset + 3  ] = value.w;
	
								offset += 4;
	
							}
	
						}
	
					}
	
				}
	
			} else {
	
				if ( dirtyVertices ) {
	
					for ( v = 0; v < vl; v ++ ) {
	
						vertex = vertices[ v ];
	
						offset = v * 3;
	
						vertexArray[ offset ]     = vertex.x;
						vertexArray[ offset + 1 ] = vertex.y;
						vertexArray[ offset + 2 ] = vertex.z;
	
					}
	
				}
	
				if ( dirtyColors ) {
	
					for ( c = 0; c < cl; c ++ ) {
	
						color = colors[ c ];
	
						offset = c * 3;
	
						colorArray[ offset ]     = color.r;
						colorArray[ offset + 1 ] = color.g;
						colorArray[ offset + 2 ] = color.b;
	
					}
	
				}
	
				if ( customAttributes ) {
	
					for ( i = 0, il = customAttributes.length; i < il; i ++ ) {
	
						customAttribute = customAttributes[ i ];
	
						if ( customAttribute.needsUpdate &&
							 ( customAttribute.boundTo === undefined ||
							   customAttribute.boundTo === "vertices") ) {
	
							cal = customAttribute.value.length;
	
							offset = 0;
	
							if ( customAttribute.size === 1 ) {
	
								for ( ca = 0; ca < cal; ca ++ ) {
	
									customAttribute.array[ ca ] = customAttribute.value[ ca ];
	
								}
	
							} else if ( customAttribute.size === 2 ) {
	
								for ( ca = 0; ca < cal; ca ++ ) {
	
									value = customAttribute.value[ ca ];
	
									customAttribute.array[ offset ] 	= value.x;
									customAttribute.array[ offset + 1 ] = value.y;
	
									offset += 2;
	
								}
	
							} else if ( customAttribute.size === 3 ) {
	
								if ( customAttribute.type === "c" ) {
	
									for ( ca = 0; ca < cal; ca ++ ) {
	
										value = customAttribute.value[ ca ];
	
										customAttribute.array[ offset ] 	= value.r;
										customAttribute.array[ offset + 1 ] = value.g;
										customAttribute.array[ offset + 2 ] = value.b;
	
										offset += 3;
	
									}
	
								} else {
	
									for ( ca = 0; ca < cal; ca ++ ) {
	
										value = customAttribute.value[ ca ];
	
										customAttribute.array[ offset ] 	= value.x;
										customAttribute.array[ offset + 1 ] = value.y;
										customAttribute.array[ offset + 2 ] = value.z;
	
										offset += 3;
	
									}
	
								}
	
							} else if ( customAttribute.size === 4 ) {
	
								for ( ca = 0; ca < cal; ca ++ ) {
	
									value = customAttribute.value[ ca ];
	
									customAttribute.array[ offset ]      = value.x;
									customAttribute.array[ offset + 1  ] = value.y;
									customAttribute.array[ offset + 2  ] = value.z;
									customAttribute.array[ offset + 3  ] = value.w;
	
									offset += 4;
	
								}
	
							}
	
						}
	
					}
	
				}
	
			}
	
			if ( dirtyVertices || object.sortParticles ) {
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );
	
			}
	
			if ( dirtyColors || object.sortParticles ) {
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );
	
			}
	
			if ( customAttributes ) {
	
				for ( i = 0, il = customAttributes.length; i < il; i ++ ) {
	
					customAttribute = customAttributes[ i ];
	
					if ( customAttribute.needsUpdate || object.sortParticles ) {
	
						_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
						_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );
	
					}
	
				}
	
			}
	
	
		};
	
		function setLineBuffers ( geometry, hint ) {
	
			var v, c, d, vertex, offset, color,
	
			vertices = geometry.vertices,
			colors = geometry.colors,
			lineDistances = geometry.lineDistances,
	
			vl = vertices.length,
			cl = colors.length,
			dl = lineDistances.length,
	
			vertexArray = geometry.__vertexArray,
			colorArray = geometry.__colorArray,
			lineDistanceArray = geometry.__lineDistanceArray,
	
			dirtyVertices = geometry.verticesNeedUpdate,
			dirtyColors = geometry.colorsNeedUpdate,
			dirtyLineDistances = geometry.lineDistancesNeedUpdate,
	
			customAttributes = geometry.__webglCustomAttributesList,
	
			i, il,
			a, ca, cal, value,
			customAttribute;
	
			if ( dirtyVertices ) {
	
				for ( v = 0; v < vl; v ++ ) {
	
					vertex = vertices[ v ];
	
					offset = v * 3;
	
					vertexArray[ offset ]     = vertex.x;
					vertexArray[ offset + 1 ] = vertex.y;
					vertexArray[ offset + 2 ] = vertex.z;
	
				}
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );
	
			}
	
			if ( dirtyColors ) {
	
				for ( c = 0; c < cl; c ++ ) {
	
					color = colors[ c ];
	
					offset = c * 3;
	
					colorArray[ offset ]     = color.r;
					colorArray[ offset + 1 ] = color.g;
					colorArray[ offset + 2 ] = color.b;
	
				}
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );
	
			}
	
			if ( dirtyLineDistances ) {
	
				for ( d = 0; d < dl; d ++ ) {
	
					lineDistanceArray[ d ] = lineDistances[ d ];
	
				}
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglLineDistanceBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, lineDistanceArray, hint );
	
			}
	
			if ( customAttributes ) {
	
				for ( i = 0, il = customAttributes.length; i < il; i ++ ) {
	
					customAttribute = customAttributes[ i ];
	
					if ( customAttribute.needsUpdate &&
						 ( customAttribute.boundTo === undefined ||
						   customAttribute.boundTo === "vertices" ) ) {
	
						offset = 0;
	
						cal = customAttribute.value.length;
	
						if ( customAttribute.size === 1 ) {
	
							for ( ca = 0; ca < cal; ca ++ ) {
	
								customAttribute.array[ ca ] = customAttribute.value[ ca ];
	
							}
	
						} else if ( customAttribute.size === 2 ) {
	
							for ( ca = 0; ca < cal; ca ++ ) {
	
								value = customAttribute.value[ ca ];
	
								customAttribute.array[ offset ] 	= value.x;
								customAttribute.array[ offset + 1 ] = value.y;
	
								offset += 2;
	
							}
	
						} else if ( customAttribute.size === 3 ) {
	
							if ( customAttribute.type === "c" ) {
	
								for ( ca = 0; ca < cal; ca ++ ) {
	
									value = customAttribute.value[ ca ];
	
									customAttribute.array[ offset ] 	= value.r;
									customAttribute.array[ offset + 1 ] = value.g;
									customAttribute.array[ offset + 2 ] = value.b;
	
									offset += 3;
	
								}
	
							} else {
	
								for ( ca = 0; ca < cal; ca ++ ) {
	
									value = customAttribute.value[ ca ];
	
									customAttribute.array[ offset ] 	= value.x;
									customAttribute.array[ offset + 1 ] = value.y;
									customAttribute.array[ offset + 2 ] = value.z;
	
									offset += 3;
	
								}
	
							}
	
						} else if ( customAttribute.size === 4 ) {
	
							for ( ca = 0; ca < cal; ca ++ ) {
	
								value = customAttribute.value[ ca ];
	
								customAttribute.array[ offset ] 	 = value.x;
								customAttribute.array[ offset + 1  ] = value.y;
								customAttribute.array[ offset + 2  ] = value.z;
								customAttribute.array[ offset + 3  ] = value.w;
	
								offset += 4;
	
							}
	
						}
	
						_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
						_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );
	
					}
	
				}
	
			}
	
		};
	
		function setRibbonBuffers ( geometry, hint ) {
	
			var v, c, n, vertex, offset, color, normal,
	
			i, il, ca, cal, customAttribute, value,
	
			vertices = geometry.vertices,
			colors = geometry.colors,
			normals = geometry.normals,
	
			vl = vertices.length,
			cl = colors.length,
			nl = normals.length,
	
			vertexArray = geometry.__vertexArray,
			colorArray = geometry.__colorArray,
			normalArray = geometry.__normalArray,
	
			dirtyVertices = geometry.verticesNeedUpdate,
			dirtyColors = geometry.colorsNeedUpdate,
			dirtyNormals = geometry.normalsNeedUpdate,
	
			customAttributes = geometry.__webglCustomAttributesList;
	
			if ( dirtyVertices ) {
	
				for ( v = 0; v < vl; v ++ ) {
	
					vertex = vertices[ v ];
	
					offset = v * 3;
	
					vertexArray[ offset ]     = vertex.x;
					vertexArray[ offset + 1 ] = vertex.y;
					vertexArray[ offset + 2 ] = vertex.z;
	
				}
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );
	
			}
	
			if ( dirtyColors ) {
	
				for ( c = 0; c < cl; c ++ ) {
	
					color = colors[ c ];
	
					offset = c * 3;
	
					colorArray[ offset ]     = color.r;
					colorArray[ offset + 1 ] = color.g;
					colorArray[ offset + 2 ] = color.b;
	
				}
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );
	
			}
	
			if ( dirtyNormals ) {
	
				for ( n = 0; n < nl; n ++ ) {
	
					normal = normals[ n ];
	
					offset = n * 3;
	
					normalArray[ offset ]     = normal.x;
					normalArray[ offset + 1 ] = normal.y;
					normalArray[ offset + 2 ] = normal.z;
	
				}
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglNormalBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, normalArray, hint );
	
			}
	
			if ( customAttributes ) {
	
				for ( i = 0, il = customAttributes.length; i < il; i ++ ) {
	
					customAttribute = customAttributes[ i ];
	
					if ( customAttribute.needsUpdate &&
						 ( customAttribute.boundTo === undefined ||
						   customAttribute.boundTo === "vertices" ) ) {
	
						offset = 0;
	
						cal = customAttribute.value.length;
	
						if ( customAttribute.size === 1 ) {
	
							for ( ca = 0; ca < cal; ca ++ ) {
	
								customAttribute.array[ ca ] = customAttribute.value[ ca ];
	
							}
	
						} else if ( customAttribute.size === 2 ) {
	
							for ( ca = 0; ca < cal; ca ++ ) {
	
								value = customAttribute.value[ ca ];
	
								customAttribute.array[ offset ] 	= value.x;
								customAttribute.array[ offset + 1 ] = value.y;
	
								offset += 2;
	
							}
	
						} else if ( customAttribute.size === 3 ) {
	
							if ( customAttribute.type === "c" ) {
	
								for ( ca = 0; ca < cal; ca ++ ) {
	
									value = customAttribute.value[ ca ];
	
									customAttribute.array[ offset ] 	= value.r;
									customAttribute.array[ offset + 1 ] = value.g;
									customAttribute.array[ offset + 2 ] = value.b;
	
									offset += 3;
	
								}
	
							} else {
	
								for ( ca = 0; ca < cal; ca ++ ) {
	
									value = customAttribute.value[ ca ];
	
									customAttribute.array[ offset ] 	= value.x;
									customAttribute.array[ offset + 1 ] = value.y;
									customAttribute.array[ offset + 2 ] = value.z;
	
									offset += 3;
	
								}
	
							}
	
						} else if ( customAttribute.size === 4 ) {
	
							for ( ca = 0; ca < cal; ca ++ ) {
	
								value = customAttribute.value[ ca ];
	
								customAttribute.array[ offset ] 	 = value.x;
								customAttribute.array[ offset + 1  ] = value.y;
								customAttribute.array[ offset + 2  ] = value.z;
								customAttribute.array[ offset + 3  ] = value.w;
	
								offset += 4;
	
							}
	
						}
	
						_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
						_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );
	
					}
	
				}
	
			}
	
		};
	
		function setMeshBuffers( geometryGroup, object, hint, dispose, material ) {
	
			if ( ! geometryGroup.__inittedArrays ) {
	
				return;
	
			}
	
			var normalType = bufferGuessNormalType( material ),
			vertexColorType = bufferGuessVertexColorType( material ),
			uvType = bufferGuessUVType( material ),
	
			needsSmoothNormals = ( normalType === THREE.SmoothShading );
	
			var f, fl, fi, face,
			vertexNormals, faceNormal, normal,
			vertexColors, faceColor,
			vertexTangents,
			uv, uv2, v1, v2, v3, v4, t1, t2, t3, t4, n1, n2, n3, n4,
			c1, c2, c3, c4,
			sw1, sw2, sw3, sw4,
			si1, si2, si3, si4,
			sa1, sa2, sa3, sa4,
			sb1, sb2, sb3, sb4,
			m, ml, i, il,
			vn, uvi, uv2i,
			vk, vkl, vka,
			nka, chf, faceVertexNormals,
			a,
	
			vertexIndex = 0,
	
			offset = 0,
			offset_uv = 0,
			offset_uv2 = 0,
			offset_face = 0,
			offset_normal = 0,
			offset_tangent = 0,
			offset_line = 0,
			offset_color = 0,
			offset_skin = 0,
			offset_morphTarget = 0,
			offset_custom = 0,
			offset_customSrc = 0,
	
			value,
	
			vertexArray = geometryGroup.__vertexArray,
			uvArray = geometryGroup.__uvArray,
			uv2Array = geometryGroup.__uv2Array,
			normalArray = geometryGroup.__normalArray,
			tangentArray = geometryGroup.__tangentArray,
			colorArray = geometryGroup.__colorArray,
	
			skinIndexArray = geometryGroup.__skinIndexArray,
			skinWeightArray = geometryGroup.__skinWeightArray,
	
			morphTargetsArrays = geometryGroup.__morphTargetsArrays,
			morphNormalsArrays = geometryGroup.__morphNormalsArrays,
	
			customAttributes = geometryGroup.__webglCustomAttributesList,
			customAttribute,
	
			faceArray = geometryGroup.__faceArray,
			lineArray = geometryGroup.__lineArray,
	
			geometry = object.geometry, // this is shared for all chunks
	
			dirtyVertices = geometry.verticesNeedUpdate,
			dirtyElements = geometry.elementsNeedUpdate,
			dirtyUvs = geometry.uvsNeedUpdate,
			dirtyNormals = geometry.normalsNeedUpdate,
			dirtyTangents = geometry.tangentsNeedUpdate,
			dirtyColors = geometry.colorsNeedUpdate,
			dirtyMorphTargets = geometry.morphTargetsNeedUpdate,
	
			vertices = geometry.vertices,
			chunk_faces3 = geometryGroup.faces3,
			chunk_faces4 = geometryGroup.faces4,
			obj_faces = geometry.faces,
	
			obj_uvs  = geometry.faceVertexUvs[ 0 ],
			obj_uvs2 = geometry.faceVertexUvs[ 1 ],
	
			obj_colors = geometry.colors,
	
			obj_skinIndices = geometry.skinIndices,
			obj_skinWeights = geometry.skinWeights,
	
			morphTargets = geometry.morphTargets,
			morphNormals = geometry.morphNormals;
	
			if ( dirtyVertices ) {
	
				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
					face = obj_faces[ chunk_faces3[ f ] ];
	
					v1 = vertices[ face.a ];
					v2 = vertices[ face.b ];
					v3 = vertices[ face.c ];
	
					vertexArray[ offset ]     = v1.x;
					vertexArray[ offset + 1 ] = v1.y;
					vertexArray[ offset + 2 ] = v1.z;
	
					vertexArray[ offset + 3 ] = v2.x;
					vertexArray[ offset + 4 ] = v2.y;
					vertexArray[ offset + 5 ] = v2.z;
	
					vertexArray[ offset + 6 ] = v3.x;
					vertexArray[ offset + 7 ] = v3.y;
					vertexArray[ offset + 8 ] = v3.z;
	
					offset += 9;
	
				}
	
				for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {
	
					face = obj_faces[ chunk_faces4[ f ] ];
	
					v1 = vertices[ face.a ];
					v2 = vertices[ face.b ];
					v3 = vertices[ face.c ];
					v4 = vertices[ face.d ];
	
					vertexArray[ offset ]     = v1.x;
					vertexArray[ offset + 1 ] = v1.y;
					vertexArray[ offset + 2 ] = v1.z;
	
					vertexArray[ offset + 3 ] = v2.x;
					vertexArray[ offset + 4 ] = v2.y;
					vertexArray[ offset + 5 ] = v2.z;
	
					vertexArray[ offset + 6 ] = v3.x;
					vertexArray[ offset + 7 ] = v3.y;
					vertexArray[ offset + 8 ] = v3.z;
	
					vertexArray[ offset + 9 ]  = v4.x;
					vertexArray[ offset + 10 ] = v4.y;
					vertexArray[ offset + 11 ] = v4.z;
	
					offset += 12;
	
				}
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );
	
			}
	
			if ( dirtyMorphTargets ) {
	
				for ( vk = 0, vkl = morphTargets.length; vk < vkl; vk ++ ) {
	
					offset_morphTarget = 0;
	
					for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
						chf = chunk_faces3[ f ];
						face = obj_faces[ chf ];
	
						// morph positions
	
						v1 = morphTargets[ vk ].vertices[ face.a ];
						v2 = morphTargets[ vk ].vertices[ face.b ];
						v3 = morphTargets[ vk ].vertices[ face.c ];
	
						vka = morphTargetsArrays[ vk ];
	
						vka[ offset_morphTarget ] 	  = v1.x;
						vka[ offset_morphTarget + 1 ] = v1.y;
						vka[ offset_morphTarget + 2 ] = v1.z;
	
						vka[ offset_morphTarget + 3 ] = v2.x;
						vka[ offset_morphTarget + 4 ] = v2.y;
						vka[ offset_morphTarget + 5 ] = v2.z;
	
						vka[ offset_morphTarget + 6 ] = v3.x;
						vka[ offset_morphTarget + 7 ] = v3.y;
						vka[ offset_morphTarget + 8 ] = v3.z;
	
						// morph normals
	
						if ( material.morphNormals ) {
	
							if ( needsSmoothNormals ) {
	
								faceVertexNormals = morphNormals[ vk ].vertexNormals[ chf ];
	
								n1 = faceVertexNormals.a;
								n2 = faceVertexNormals.b;
								n3 = faceVertexNormals.c;
	
							} else {
	
								n1 = morphNormals[ vk ].faceNormals[ chf ];
								n2 = n1;
								n3 = n1;
	
							}
	
							nka = morphNormalsArrays[ vk ];
	
							nka[ offset_morphTarget ] 	  = n1.x;
							nka[ offset_morphTarget + 1 ] = n1.y;
							nka[ offset_morphTarget + 2 ] = n1.z;
	
							nka[ offset_morphTarget + 3 ] = n2.x;
							nka[ offset_morphTarget + 4 ] = n2.y;
							nka[ offset_morphTarget + 5 ] = n2.z;
	
							nka[ offset_morphTarget + 6 ] = n3.x;
							nka[ offset_morphTarget + 7 ] = n3.y;
							nka[ offset_morphTarget + 8 ] = n3.z;
	
						}
	
						//
	
						offset_morphTarget += 9;
	
					}
	
					for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {
	
						chf = chunk_faces4[ f ];
						face = obj_faces[ chf ];
	
						// morph positions
	
						v1 = morphTargets[ vk ].vertices[ face.a ];
						v2 = morphTargets[ vk ].vertices[ face.b ];
						v3 = morphTargets[ vk ].vertices[ face.c ];
						v4 = morphTargets[ vk ].vertices[ face.d ];
	
						vka = morphTargetsArrays[ vk ];
	
						vka[ offset_morphTarget ] 	  = v1.x;
						vka[ offset_morphTarget + 1 ] = v1.y;
						vka[ offset_morphTarget + 2 ] = v1.z;
	
						vka[ offset_morphTarget + 3 ] = v2.x;
						vka[ offset_morphTarget + 4 ] = v2.y;
						vka[ offset_morphTarget + 5 ] = v2.z;
	
						vka[ offset_morphTarget + 6 ] = v3.x;
						vka[ offset_morphTarget + 7 ] = v3.y;
						vka[ offset_morphTarget + 8 ] = v3.z;
	
						vka[ offset_morphTarget + 9 ]  = v4.x;
						vka[ offset_morphTarget + 10 ] = v4.y;
						vka[ offset_morphTarget + 11 ] = v4.z;
	
						// morph normals
	
						if ( material.morphNormals ) {
	
							if ( needsSmoothNormals ) {
	
								faceVertexNormals = morphNormals[ vk ].vertexNormals[ chf ];
	
								n1 = faceVertexNormals.a;
								n2 = faceVertexNormals.b;
								n3 = faceVertexNormals.c;
								n4 = faceVertexNormals.d;
	
							} else {
	
								n1 = morphNormals[ vk ].faceNormals[ chf ];
								n2 = n1;
								n3 = n1;
								n4 = n1;
	
							}
	
							nka = morphNormalsArrays[ vk ];
	
							nka[ offset_morphTarget ] 	  = n1.x;
							nka[ offset_morphTarget + 1 ] = n1.y;
							nka[ offset_morphTarget + 2 ] = n1.z;
	
							nka[ offset_morphTarget + 3 ] = n2.x;
							nka[ offset_morphTarget + 4 ] = n2.y;
							nka[ offset_morphTarget + 5 ] = n2.z;
	
							nka[ offset_morphTarget + 6 ] = n3.x;
							nka[ offset_morphTarget + 7 ] = n3.y;
							nka[ offset_morphTarget + 8 ] = n3.z;
	
							nka[ offset_morphTarget + 9 ]  = n4.x;
							nka[ offset_morphTarget + 10 ] = n4.y;
							nka[ offset_morphTarget + 11 ] = n4.z;
	
						}
	
						//
	
						offset_morphTarget += 12;
	
					}
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ vk ] );
					_gl.bufferData( _gl.ARRAY_BUFFER, morphTargetsArrays[ vk ], hint );
	
					if ( material.morphNormals ) {
	
						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ vk ] );
						_gl.bufferData( _gl.ARRAY_BUFFER, morphNormalsArrays[ vk ], hint );
	
					}
	
				}
	
			}
	
			if ( obj_skinWeights.length ) {
	
				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
					face = obj_faces[ chunk_faces3[ f ]	];
	
					// weights
	
					sw1 = obj_skinWeights[ face.a ];
					sw2 = obj_skinWeights[ face.b ];
					sw3 = obj_skinWeights[ face.c ];
	
					skinWeightArray[ offset_skin ]     = sw1.x;
					skinWeightArray[ offset_skin + 1 ] = sw1.y;
					skinWeightArray[ offset_skin + 2 ] = sw1.z;
					skinWeightArray[ offset_skin + 3 ] = sw1.w;
	
					skinWeightArray[ offset_skin + 4 ] = sw2.x;
					skinWeightArray[ offset_skin + 5 ] = sw2.y;
					skinWeightArray[ offset_skin + 6 ] = sw2.z;
					skinWeightArray[ offset_skin + 7 ] = sw2.w;
	
					skinWeightArray[ offset_skin + 8 ]  = sw3.x;
					skinWeightArray[ offset_skin + 9 ]  = sw3.y;
					skinWeightArray[ offset_skin + 10 ] = sw3.z;
					skinWeightArray[ offset_skin + 11 ] = sw3.w;
	
					// indices
	
					si1 = obj_skinIndices[ face.a ];
					si2 = obj_skinIndices[ face.b ];
					si3 = obj_skinIndices[ face.c ];
	
					skinIndexArray[ offset_skin ]     = si1.x;
					skinIndexArray[ offset_skin + 1 ] = si1.y;
					skinIndexArray[ offset_skin + 2 ] = si1.z;
					skinIndexArray[ offset_skin + 3 ] = si1.w;
	
					skinIndexArray[ offset_skin + 4 ] = si2.x;
					skinIndexArray[ offset_skin + 5 ] = si2.y;
					skinIndexArray[ offset_skin + 6 ] = si2.z;
					skinIndexArray[ offset_skin + 7 ] = si2.w;
	
					skinIndexArray[ offset_skin + 8 ]  = si3.x;
					skinIndexArray[ offset_skin + 9 ]  = si3.y;
					skinIndexArray[ offset_skin + 10 ] = si3.z;
					skinIndexArray[ offset_skin + 11 ] = si3.w;
	
					offset_skin += 12;
	
				}
	
				for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {
	
					face = obj_faces[ chunk_faces4[ f ] ];
	
					// weights
	
					sw1 = obj_skinWeights[ face.a ];
					sw2 = obj_skinWeights[ face.b ];
					sw3 = obj_skinWeights[ face.c ];
					sw4 = obj_skinWeights[ face.d ];
	
					skinWeightArray[ offset_skin ]     = sw1.x;
					skinWeightArray[ offset_skin + 1 ] = sw1.y;
					skinWeightArray[ offset_skin + 2 ] = sw1.z;
					skinWeightArray[ offset_skin + 3 ] = sw1.w;
	
					skinWeightArray[ offset_skin + 4 ] = sw2.x;
					skinWeightArray[ offset_skin + 5 ] = sw2.y;
					skinWeightArray[ offset_skin + 6 ] = sw2.z;
					skinWeightArray[ offset_skin + 7 ] = sw2.w;
	
					skinWeightArray[ offset_skin + 8 ]  = sw3.x;
					skinWeightArray[ offset_skin + 9 ]  = sw3.y;
					skinWeightArray[ offset_skin + 10 ] = sw3.z;
					skinWeightArray[ offset_skin + 11 ] = sw3.w;
	
					skinWeightArray[ offset_skin + 12 ] = sw4.x;
					skinWeightArray[ offset_skin + 13 ] = sw4.y;
					skinWeightArray[ offset_skin + 14 ] = sw4.z;
					skinWeightArray[ offset_skin + 15 ] = sw4.w;
	
					// indices
	
					si1 = obj_skinIndices[ face.a ];
					si2 = obj_skinIndices[ face.b ];
					si3 = obj_skinIndices[ face.c ];
					si4 = obj_skinIndices[ face.d ];
	
					skinIndexArray[ offset_skin ]     = si1.x;
					skinIndexArray[ offset_skin + 1 ] = si1.y;
					skinIndexArray[ offset_skin + 2 ] = si1.z;
					skinIndexArray[ offset_skin + 3 ] = si1.w;
	
					skinIndexArray[ offset_skin + 4 ] = si2.x;
					skinIndexArray[ offset_skin + 5 ] = si2.y;
					skinIndexArray[ offset_skin + 6 ] = si2.z;
					skinIndexArray[ offset_skin + 7 ] = si2.w;
	
					skinIndexArray[ offset_skin + 8 ]  = si3.x;
					skinIndexArray[ offset_skin + 9 ]  = si3.y;
					skinIndexArray[ offset_skin + 10 ] = si3.z;
					skinIndexArray[ offset_skin + 11 ] = si3.w;
	
					skinIndexArray[ offset_skin + 12 ] = si4.x;
					skinIndexArray[ offset_skin + 13 ] = si4.y;
					skinIndexArray[ offset_skin + 14 ] = si4.z;
					skinIndexArray[ offset_skin + 15 ] = si4.w;
	
					offset_skin += 16;
	
				}
	
				if ( offset_skin > 0 ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, skinIndexArray, hint );
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, skinWeightArray, hint );
	
				}
	
			}
	
			if ( dirtyColors && vertexColorType ) {
	
				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
					face = obj_faces[ chunk_faces3[ f ]	];
	
					vertexColors = face.vertexColors;
					faceColor = face.color;
	
					if ( vertexColors.length === 3 && vertexColorType === THREE.VertexColors ) {
	
						c1 = vertexColors[ 0 ];
						c2 = vertexColors[ 1 ];
						c3 = vertexColors[ 2 ];
	
					} else {
	
						c1 = faceColor;
						c2 = faceColor;
						c3 = faceColor;
	
					}
	
					colorArray[ offset_color ]     = c1.r;
					colorArray[ offset_color + 1 ] = c1.g;
					colorArray[ offset_color + 2 ] = c1.b;
	
					colorArray[ offset_color + 3 ] = c2.r;
					colorArray[ offset_color + 4 ] = c2.g;
					colorArray[ offset_color + 5 ] = c2.b;
	
					colorArray[ offset_color + 6 ] = c3.r;
					colorArray[ offset_color + 7 ] = c3.g;
					colorArray[ offset_color + 8 ] = c3.b;
	
					offset_color += 9;
	
				}
	
				for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {
	
					face = obj_faces[ chunk_faces4[ f ] ];
	
					vertexColors = face.vertexColors;
					faceColor = face.color;
	
					if ( vertexColors.length === 4 && vertexColorType === THREE.VertexColors ) {
	
						c1 = vertexColors[ 0 ];
						c2 = vertexColors[ 1 ];
						c3 = vertexColors[ 2 ];
						c4 = vertexColors[ 3 ];
	
					} else {
	
						c1 = faceColor;
						c2 = faceColor;
						c3 = faceColor;
						c4 = faceColor;
	
					}
	
					colorArray[ offset_color ]     = c1.r;
					colorArray[ offset_color + 1 ] = c1.g;
					colorArray[ offset_color + 2 ] = c1.b;
	
					colorArray[ offset_color + 3 ] = c2.r;
					colorArray[ offset_color + 4 ] = c2.g;
					colorArray[ offset_color + 5 ] = c2.b;
	
					colorArray[ offset_color + 6 ] = c3.r;
					colorArray[ offset_color + 7 ] = c3.g;
					colorArray[ offset_color + 8 ] = c3.b;
	
					colorArray[ offset_color + 9 ]  = c4.r;
					colorArray[ offset_color + 10 ] = c4.g;
					colorArray[ offset_color + 11 ] = c4.b;
	
					offset_color += 12;
	
				}
	
				if ( offset_color > 0 ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );
	
				}
	
			}
	
			if ( dirtyTangents && geometry.hasTangents ) {
	
				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
					face = obj_faces[ chunk_faces3[ f ]	];
	
					vertexTangents = face.vertexTangents;
	
					t1 = vertexTangents[ 0 ];
					t2 = vertexTangents[ 1 ];
					t3 = vertexTangents[ 2 ];
	
					tangentArray[ offset_tangent ]     = t1.x;
					tangentArray[ offset_tangent + 1 ] = t1.y;
					tangentArray[ offset_tangent + 2 ] = t1.z;
					tangentArray[ offset_tangent + 3 ] = t1.w;
	
					tangentArray[ offset_tangent + 4 ] = t2.x;
					tangentArray[ offset_tangent + 5 ] = t2.y;
					tangentArray[ offset_tangent + 6 ] = t2.z;
					tangentArray[ offset_tangent + 7 ] = t2.w;
	
					tangentArray[ offset_tangent + 8 ]  = t3.x;
					tangentArray[ offset_tangent + 9 ]  = t3.y;
					tangentArray[ offset_tangent + 10 ] = t3.z;
					tangentArray[ offset_tangent + 11 ] = t3.w;
	
					offset_tangent += 12;
	
				}
	
				for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {
	
					face = obj_faces[ chunk_faces4[ f ] ];
	
					vertexTangents = face.vertexTangents;
	
					t1 = vertexTangents[ 0 ];
					t2 = vertexTangents[ 1 ];
					t3 = vertexTangents[ 2 ];
					t4 = vertexTangents[ 3 ];
	
					tangentArray[ offset_tangent ]     = t1.x;
					tangentArray[ offset_tangent + 1 ] = t1.y;
					tangentArray[ offset_tangent + 2 ] = t1.z;
					tangentArray[ offset_tangent + 3 ] = t1.w;
	
					tangentArray[ offset_tangent + 4 ] = t2.x;
					tangentArray[ offset_tangent + 5 ] = t2.y;
					tangentArray[ offset_tangent + 6 ] = t2.z;
					tangentArray[ offset_tangent + 7 ] = t2.w;
	
					tangentArray[ offset_tangent + 8 ]  = t3.x;
					tangentArray[ offset_tangent + 9 ]  = t3.y;
					tangentArray[ offset_tangent + 10 ] = t3.z;
					tangentArray[ offset_tangent + 11 ] = t3.w;
	
					tangentArray[ offset_tangent + 12 ] = t4.x;
					tangentArray[ offset_tangent + 13 ] = t4.y;
					tangentArray[ offset_tangent + 14 ] = t4.z;
					tangentArray[ offset_tangent + 15 ] = t4.w;
	
					offset_tangent += 16;
	
				}
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, tangentArray, hint );
	
			}
	
			if ( dirtyNormals && normalType ) {
	
				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
					face = obj_faces[ chunk_faces3[ f ]	];
	
					vertexNormals = face.vertexNormals;
					faceNormal = face.normal;
	
					if ( vertexNormals.length === 3 && needsSmoothNormals ) {
	
						for ( i = 0; i < 3; i ++ ) {
	
							vn = vertexNormals[ i ];
	
							normalArray[ offset_normal ]     = vn.x;
							normalArray[ offset_normal + 1 ] = vn.y;
							normalArray[ offset_normal + 2 ] = vn.z;
	
							offset_normal += 3;
	
						}
	
					} else {
	
						for ( i = 0; i < 3; i ++ ) {
	
							normalArray[ offset_normal ]     = faceNormal.x;
							normalArray[ offset_normal + 1 ] = faceNormal.y;
							normalArray[ offset_normal + 2 ] = faceNormal.z;
	
							offset_normal += 3;
	
						}
	
					}
	
				}
	
				for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {
	
					face = obj_faces[ chunk_faces4[ f ] ];
	
					vertexNormals = face.vertexNormals;
					faceNormal = face.normal;
	
					if ( vertexNormals.length === 4 && needsSmoothNormals ) {
	
						for ( i = 0; i < 4; i ++ ) {
	
							vn = vertexNormals[ i ];
	
							normalArray[ offset_normal ]     = vn.x;
							normalArray[ offset_normal + 1 ] = vn.y;
							normalArray[ offset_normal + 2 ] = vn.z;
	
							offset_normal += 3;
	
						}
	
					} else {
	
						for ( i = 0; i < 4; i ++ ) {
	
							normalArray[ offset_normal ]     = faceNormal.x;
							normalArray[ offset_normal + 1 ] = faceNormal.y;
							normalArray[ offset_normal + 2 ] = faceNormal.z;
	
							offset_normal += 3;
	
						}
	
					}
	
				}
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, normalArray, hint );
	
			}
	
			if ( dirtyUvs && obj_uvs && uvType ) {
	
				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
					fi = chunk_faces3[ f ];
	
					uv = obj_uvs[ fi ];
	
					if ( uv === undefined ) continue;
	
					for ( i = 0; i < 3; i ++ ) {
	
						uvi = uv[ i ];
	
						uvArray[ offset_uv ]     = uvi.x;
						uvArray[ offset_uv + 1 ] = uvi.y;
	
						offset_uv += 2;
	
					}
	
				}
	
				for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {
	
					fi = chunk_faces4[ f ];
	
					uv = obj_uvs[ fi ];
	
					if ( uv === undefined ) continue;
	
					for ( i = 0; i < 4; i ++ ) {
	
						uvi = uv[ i ];
	
						uvArray[ offset_uv ]     = uvi.x;
						uvArray[ offset_uv + 1 ] = uvi.y;
	
						offset_uv += 2;
	
					}
	
				}
	
				if ( offset_uv > 0 ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, uvArray, hint );
	
				}
	
			}
	
			if ( dirtyUvs && obj_uvs2 && uvType ) {
	
				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
					fi = chunk_faces3[ f ];
	
					uv2 = obj_uvs2[ fi ];
	
					if ( uv2 === undefined ) continue;
	
					for ( i = 0; i < 3; i ++ ) {
	
						uv2i = uv2[ i ];
	
						uv2Array[ offset_uv2 ]     = uv2i.x;
						uv2Array[ offset_uv2 + 1 ] = uv2i.y;
	
						offset_uv2 += 2;
	
					}
	
				}
	
				for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {
	
					fi = chunk_faces4[ f ];
	
					uv2 = obj_uvs2[ fi ];
	
					if ( uv2 === undefined ) continue;
	
					for ( i = 0; i < 4; i ++ ) {
	
						uv2i = uv2[ i ];
	
						uv2Array[ offset_uv2 ]     = uv2i.x;
						uv2Array[ offset_uv2 + 1 ] = uv2i.y;
	
						offset_uv2 += 2;
	
					}
	
				}
	
				if ( offset_uv2 > 0 ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, uv2Array, hint );
	
				}
	
			}
	
			if ( dirtyElements ) {
	
				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
					faceArray[ offset_face ] 	 = vertexIndex;
					faceArray[ offset_face + 1 ] = vertexIndex + 1;
					faceArray[ offset_face + 2 ] = vertexIndex + 2;
	
					offset_face += 3;
	
					lineArray[ offset_line ]     = vertexIndex;
					lineArray[ offset_line + 1 ] = vertexIndex + 1;
	
					lineArray[ offset_line + 2 ] = vertexIndex;
					lineArray[ offset_line + 3 ] = vertexIndex + 2;
	
					lineArray[ offset_line + 4 ] = vertexIndex + 1;
					lineArray[ offset_line + 5 ] = vertexIndex + 2;
	
					offset_line += 6;
	
					vertexIndex += 3;
	
				}
	
				for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {
	
					faceArray[ offset_face ]     = vertexIndex;
					faceArray[ offset_face + 1 ] = vertexIndex + 1;
					faceArray[ offset_face + 2 ] = vertexIndex + 3;
	
					faceArray[ offset_face + 3 ] = vertexIndex + 1;
					faceArray[ offset_face + 4 ] = vertexIndex + 2;
					faceArray[ offset_face + 5 ] = vertexIndex + 3;
	
					offset_face += 6;
	
					lineArray[ offset_line ]     = vertexIndex;
					lineArray[ offset_line + 1 ] = vertexIndex + 1;
	
					lineArray[ offset_line + 2 ] = vertexIndex;
					lineArray[ offset_line + 3 ] = vertexIndex + 3;
	
					lineArray[ offset_line + 4 ] = vertexIndex + 1;
					lineArray[ offset_line + 5 ] = vertexIndex + 2;
	
					lineArray[ offset_line + 6 ] = vertexIndex + 2;
					lineArray[ offset_line + 7 ] = vertexIndex + 3;
	
					offset_line += 8;
	
					vertexIndex += 4;
	
				}
	
				_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
				_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, faceArray, hint );
	
				_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
				_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, lineArray, hint );
	
			}
	
			if ( customAttributes ) {
	
				for ( i = 0, il = customAttributes.length; i < il; i ++ ) {
	
					customAttribute = customAttributes[ i ];
	
					if ( ! customAttribute.__original.needsUpdate ) continue;
	
					offset_custom = 0;
					offset_customSrc = 0;
	
					if ( customAttribute.size === 1 ) {
	
						if ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) {
	
							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
								face = obj_faces[ chunk_faces3[ f ]	];
	
								customAttribute.array[ offset_custom ] 	   = customAttribute.value[ face.a ];
								customAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];
								customAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];
	
								offset_custom += 3;
	
							}
	
							for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {
	
								face = obj_faces[ chunk_faces4[ f ] ];
	
								customAttribute.array[ offset_custom ] 	   = customAttribute.value[ face.a ];
								customAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];
								customAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];
								customAttribute.array[ offset_custom + 3 ] = customAttribute.value[ face.d ];
	
								offset_custom += 4;
	
							}
	
						} else if ( customAttribute.boundTo === "faces" ) {
	
							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
								value = customAttribute.value[ chunk_faces3[ f ] ];
	
								customAttribute.array[ offset_custom ] 	   = value;
								customAttribute.array[ offset_custom + 1 ] = value;
								customAttribute.array[ offset_custom + 2 ] = value;
	
								offset_custom += 3;
	
							}
	
							for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {
	
								value = customAttribute.value[ chunk_faces4[ f ] ];
	
								customAttribute.array[ offset_custom ] 	   = value;
								customAttribute.array[ offset_custom + 1 ] = value;
								customAttribute.array[ offset_custom + 2 ] = value;
								customAttribute.array[ offset_custom + 3 ] = value;
	
								offset_custom += 4;
	
							}
	
						}
	
					} else if ( customAttribute.size === 2 ) {
	
						if ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) {
	
							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
								face = obj_faces[ chunk_faces3[ f ]	];
	
								v1 = customAttribute.value[ face.a ];
								v2 = customAttribute.value[ face.b ];
								v3 = customAttribute.value[ face.c ];
	
								customAttribute.array[ offset_custom ] 	   = v1.x;
								customAttribute.array[ offset_custom + 1 ] = v1.y;
	
								customAttribute.array[ offset_custom + 2 ] = v2.x;
								customAttribute.array[ offset_custom + 3 ] = v2.y;
	
								customAttribute.array[ offset_custom + 4 ] = v3.x;
								customAttribute.array[ offset_custom + 5 ] = v3.y;
	
								offset_custom += 6;
	
							}
	
							for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {
	
								face = obj_faces[ chunk_faces4[ f ] ];
	
								v1 = customAttribute.value[ face.a ];
								v2 = customAttribute.value[ face.b ];
								v3 = customAttribute.value[ face.c ];
								v4 = customAttribute.value[ face.d ];
	
								customAttribute.array[ offset_custom ] 	   = v1.x;
								customAttribute.array[ offset_custom + 1 ] = v1.y;
	
								customAttribute.array[ offset_custom + 2 ] = v2.x;
								customAttribute.array[ offset_custom + 3 ] = v2.y;
	
								customAttribute.array[ offset_custom + 4 ] = v3.x;
								customAttribute.array[ offset_custom + 5 ] = v3.y;
	
								customAttribute.array[ offset_custom + 6 ] = v4.x;
								customAttribute.array[ offset_custom + 7 ] = v4.y;
	
								offset_custom += 8;
	
							}
	
						} else if ( customAttribute.boundTo === "faces" ) {
	
							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
								value = customAttribute.value[ chunk_faces3[ f ] ];
	
								v1 = value;
								v2 = value;
								v3 = value;
	
								customAttribute.array[ offset_custom ] 	   = v1.x;
								customAttribute.array[ offset_custom + 1 ] = v1.y;
	
								customAttribute.array[ offset_custom + 2 ] = v2.x;
								customAttribute.array[ offset_custom + 3 ] = v2.y;
	
								customAttribute.array[ offset_custom + 4 ] = v3.x;
								customAttribute.array[ offset_custom + 5 ] = v3.y;
	
								offset_custom += 6;
	
							}
	
							for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {
	
								value = customAttribute.value[ chunk_faces4[ f ] ];
	
								v1 = value;
								v2 = value;
								v3 = value;
								v4 = value;
	
								customAttribute.array[ offset_custom ] 	   = v1.x;
								customAttribute.array[ offset_custom + 1 ] = v1.y;
	
								customAttribute.array[ offset_custom + 2 ] = v2.x;
								customAttribute.array[ offset_custom + 3 ] = v2.y;
	
								customAttribute.array[ offset_custom + 4 ] = v3.x;
								customAttribute.array[ offset_custom + 5 ] = v3.y;
	
								customAttribute.array[ offset_custom + 6 ] = v4.x;
								customAttribute.array[ offset_custom + 7 ] = v4.y;
	
								offset_custom += 8;
	
							}
	
						}
	
					} else if ( customAttribute.size === 3 ) {
	
						var pp;
	
						if ( customAttribute.type === "c" ) {
	
							pp = [ "r", "g", "b" ];
	
						} else {
	
							pp = [ "x", "y", "z" ];
	
						}
	
						if ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) {
	
							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
								face = obj_faces[ chunk_faces3[ f ]	];
	
								v1 = customAttribute.value[ face.a ];
								v2 = customAttribute.value[ face.b ];
								v3 = customAttribute.value[ face.c ];
	
								customAttribute.array[ offset_custom ] 	   = v1[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];
	
								customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];
	
								customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];
	
								offset_custom += 9;
	
							}
	
							for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {
	
								face = obj_faces[ chunk_faces4[ f ] ];
	
								v1 = customAttribute.value[ face.a ];
								v2 = customAttribute.value[ face.b ];
								v3 = customAttribute.value[ face.c ];
								v4 = customAttribute.value[ face.d ];
	
								customAttribute.array[ offset_custom  ] 	= v1[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 1  ] = v1[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 2  ] = v1[ pp[ 2 ] ];
	
								customAttribute.array[ offset_custom + 3  ] = v2[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 4  ] = v2[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 5  ] = v2[ pp[ 2 ] ];
	
								customAttribute.array[ offset_custom + 6  ] = v3[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 7  ] = v3[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 8  ] = v3[ pp[ 2 ] ];
	
								customAttribute.array[ offset_custom + 9  ] = v4[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 10 ] = v4[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 11 ] = v4[ pp[ 2 ] ];
	
								offset_custom += 12;
	
							}
	
						} else if ( customAttribute.boundTo === "faces" ) {
	
							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
								value = customAttribute.value[ chunk_faces3[ f ] ];
	
								v1 = value;
								v2 = value;
								v3 = value;
	
								customAttribute.array[ offset_custom ] 	   = v1[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];
	
								customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];
	
								customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];
	
								offset_custom += 9;
	
							}
	
							for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {
	
								value = customAttribute.value[ chunk_faces4[ f ] ];
	
								v1 = value;
								v2 = value;
								v3 = value;
								v4 = value;
	
								customAttribute.array[ offset_custom  ] 	= v1[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 1  ] = v1[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 2  ] = v1[ pp[ 2 ] ];
	
								customAttribute.array[ offset_custom + 3  ] = v2[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 4  ] = v2[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 5  ] = v2[ pp[ 2 ] ];
	
								customAttribute.array[ offset_custom + 6  ] = v3[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 7  ] = v3[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 8  ] = v3[ pp[ 2 ] ];
	
								customAttribute.array[ offset_custom + 9  ] = v4[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 10 ] = v4[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 11 ] = v4[ pp[ 2 ] ];
	
								offset_custom += 12;
	
							}
	
						} else if ( customAttribute.boundTo === "faceVertices" ) {
	
							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
								value = customAttribute.value[ chunk_faces3[ f ] ];
	
								v1 = value[ 0 ];
								v2 = value[ 1 ];
								v3 = value[ 2 ];
	
								customAttribute.array[ offset_custom ] 	   = v1[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];
	
								customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];
	
								customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];
	
								offset_custom += 9;
	
							}
	
							for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {
	
								value = customAttribute.value[ chunk_faces4[ f ] ];
	
								v1 = value[ 0 ];
								v2 = value[ 1 ];
								v3 = value[ 2 ];
								v4 = value[ 3 ];
	
								customAttribute.array[ offset_custom  ] 	= v1[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 1  ] = v1[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 2  ] = v1[ pp[ 2 ] ];
	
								customAttribute.array[ offset_custom + 3  ] = v2[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 4  ] = v2[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 5  ] = v2[ pp[ 2 ] ];
	
								customAttribute.array[ offset_custom + 6  ] = v3[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 7  ] = v3[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 8  ] = v3[ pp[ 2 ] ];
	
								customAttribute.array[ offset_custom + 9  ] = v4[ pp[ 0 ] ];
								customAttribute.array[ offset_custom + 10 ] = v4[ pp[ 1 ] ];
								customAttribute.array[ offset_custom + 11 ] = v4[ pp[ 2 ] ];
	
								offset_custom += 12;
	
							}
	
						}
	
					} else if ( customAttribute.size === 4 ) {
	
						if ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) {
	
							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
								face = obj_faces[ chunk_faces3[ f ]	];
	
								v1 = customAttribute.value[ face.a ];
								v2 = customAttribute.value[ face.b ];
								v3 = customAttribute.value[ face.c ];
	
								customAttribute.array[ offset_custom  ] 	= v1.x;
								customAttribute.array[ offset_custom + 1  ] = v1.y;
								customAttribute.array[ offset_custom + 2  ] = v1.z;
								customAttribute.array[ offset_custom + 3  ] = v1.w;
	
								customAttribute.array[ offset_custom + 4  ] = v2.x;
								customAttribute.array[ offset_custom + 5  ] = v2.y;
								customAttribute.array[ offset_custom + 6  ] = v2.z;
								customAttribute.array[ offset_custom + 7  ] = v2.w;
	
								customAttribute.array[ offset_custom + 8  ] = v3.x;
								customAttribute.array[ offset_custom + 9  ] = v3.y;
								customAttribute.array[ offset_custom + 10 ] = v3.z;
								customAttribute.array[ offset_custom + 11 ] = v3.w;
	
								offset_custom += 12;
	
							}
	
							for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {
	
								face = obj_faces[ chunk_faces4[ f ] ];
	
								v1 = customAttribute.value[ face.a ];
								v2 = customAttribute.value[ face.b ];
								v3 = customAttribute.value[ face.c ];
								v4 = customAttribute.value[ face.d ];
	
								customAttribute.array[ offset_custom  ] 	= v1.x;
								customAttribute.array[ offset_custom + 1  ] = v1.y;
								customAttribute.array[ offset_custom + 2  ] = v1.z;
								customAttribute.array[ offset_custom + 3  ] = v1.w;
	
								customAttribute.array[ offset_custom + 4  ] = v2.x;
								customAttribute.array[ offset_custom + 5  ] = v2.y;
								customAttribute.array[ offset_custom + 6  ] = v2.z;
								customAttribute.array[ offset_custom + 7  ] = v2.w;
	
								customAttribute.array[ offset_custom + 8  ] = v3.x;
								customAttribute.array[ offset_custom + 9  ] = v3.y;
								customAttribute.array[ offset_custom + 10 ] = v3.z;
								customAttribute.array[ offset_custom + 11 ] = v3.w;
	
								customAttribute.array[ offset_custom + 12 ] = v4.x;
								customAttribute.array[ offset_custom + 13 ] = v4.y;
								customAttribute.array[ offset_custom + 14 ] = v4.z;
								customAttribute.array[ offset_custom + 15 ] = v4.w;
	
								offset_custom += 16;
	
							}
	
						} else if ( customAttribute.boundTo === "faces" ) {
	
							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
								value = customAttribute.value[ chunk_faces3[ f ] ];
	
								v1 = value;
								v2 = value;
								v3 = value;
	
								customAttribute.array[ offset_custom  ] 	= v1.x;
								customAttribute.array[ offset_custom + 1  ] = v1.y;
								customAttribute.array[ offset_custom + 2  ] = v1.z;
								customAttribute.array[ offset_custom + 3  ] = v1.w;
	
								customAttribute.array[ offset_custom + 4  ] = v2.x;
								customAttribute.array[ offset_custom + 5  ] = v2.y;
								customAttribute.array[ offset_custom + 6  ] = v2.z;
								customAttribute.array[ offset_custom + 7  ] = v2.w;
	
								customAttribute.array[ offset_custom + 8  ] = v3.x;
								customAttribute.array[ offset_custom + 9  ] = v3.y;
								customAttribute.array[ offset_custom + 10 ] = v3.z;
								customAttribute.array[ offset_custom + 11 ] = v3.w;
	
								offset_custom += 12;
	
							}
	
							for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {
	
								value = customAttribute.value[ chunk_faces4[ f ] ];
	
								v1 = value;
								v2 = value;
								v3 = value;
								v4 = value;
	
								customAttribute.array[ offset_custom  ] 	= v1.x;
								customAttribute.array[ offset_custom + 1  ] = v1.y;
								customAttribute.array[ offset_custom + 2  ] = v1.z;
								customAttribute.array[ offset_custom + 3  ] = v1.w;
	
								customAttribute.array[ offset_custom + 4  ] = v2.x;
								customAttribute.array[ offset_custom + 5  ] = v2.y;
								customAttribute.array[ offset_custom + 6  ] = v2.z;
								customAttribute.array[ offset_custom + 7  ] = v2.w;
	
								customAttribute.array[ offset_custom + 8  ] = v3.x;
								customAttribute.array[ offset_custom + 9  ] = v3.y;
								customAttribute.array[ offset_custom + 10 ] = v3.z;
								customAttribute.array[ offset_custom + 11 ] = v3.w;
	
								customAttribute.array[ offset_custom + 12 ] = v4.x;
								customAttribute.array[ offset_custom + 13 ] = v4.y;
								customAttribute.array[ offset_custom + 14 ] = v4.z;
								customAttribute.array[ offset_custom + 15 ] = v4.w;
	
								offset_custom += 16;
	
							}
	
						} else if ( customAttribute.boundTo === "faceVertices" ) {
	
							for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {
	
								value = customAttribute.value[ chunk_faces3[ f ] ];
	
								v1 = value[ 0 ];
								v2 = value[ 1 ];
								v3 = value[ 2 ];
	
								customAttribute.array[ offset_custom  ] 	= v1.x;
								customAttribute.array[ offset_custom + 1  ] = v1.y;
								customAttribute.array[ offset_custom + 2  ] = v1.z;
								customAttribute.array[ offset_custom + 3  ] = v1.w;
	
								customAttribute.array[ offset_custom + 4  ] = v2.x;
								customAttribute.array[ offset_custom + 5  ] = v2.y;
								customAttribute.array[ offset_custom + 6  ] = v2.z;
								customAttribute.array[ offset_custom + 7  ] = v2.w;
	
								customAttribute.array[ offset_custom + 8  ] = v3.x;
								customAttribute.array[ offset_custom + 9  ] = v3.y;
								customAttribute.array[ offset_custom + 10 ] = v3.z;
								customAttribute.array[ offset_custom + 11 ] = v3.w;
	
								offset_custom += 12;
	
							}
	
							for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {
	
								value = customAttribute.value[ chunk_faces4[ f ] ];
	
								v1 = value[ 0 ];
								v2 = value[ 1 ];
								v3 = value[ 2 ];
								v4 = value[ 3 ];
	
								customAttribute.array[ offset_custom  ] 	= v1.x;
								customAttribute.array[ offset_custom + 1  ] = v1.y;
								customAttribute.array[ offset_custom + 2  ] = v1.z;
								customAttribute.array[ offset_custom + 3  ] = v1.w;
	
								customAttribute.array[ offset_custom + 4  ] = v2.x;
								customAttribute.array[ offset_custom + 5  ] = v2.y;
								customAttribute.array[ offset_custom + 6  ] = v2.z;
								customAttribute.array[ offset_custom + 7  ] = v2.w;
	
								customAttribute.array[ offset_custom + 8  ] = v3.x;
								customAttribute.array[ offset_custom + 9  ] = v3.y;
								customAttribute.array[ offset_custom + 10 ] = v3.z;
								customAttribute.array[ offset_custom + 11 ] = v3.w;
	
								customAttribute.array[ offset_custom + 12 ] = v4.x;
								customAttribute.array[ offset_custom + 13 ] = v4.y;
								customAttribute.array[ offset_custom + 14 ] = v4.z;
								customAttribute.array[ offset_custom + 15 ] = v4.w;
	
								offset_custom += 16;
	
							}
	
						}
	
					}
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );
	
				}
	
			}
	
			if ( dispose ) {
	
				delete geometryGroup.__inittedArrays;
				delete geometryGroup.__colorArray;
				delete geometryGroup.__normalArray;
				delete geometryGroup.__tangentArray;
				delete geometryGroup.__uvArray;
				delete geometryGroup.__uv2Array;
				delete geometryGroup.__faceArray;
				delete geometryGroup.__vertexArray;
				delete geometryGroup.__lineArray;
				delete geometryGroup.__skinIndexArray;
				delete geometryGroup.__skinWeightArray;
	
			}
	
		};
	
		function setDirectBuffers ( geometry, hint, dispose ) {
	
			var attributes = geometry.attributes;
	
			var index = attributes[ "index" ];
			var position = attributes[ "position" ];
			var normal = attributes[ "normal" ];
			var uv = attributes[ "uv" ];
			var color = attributes[ "color" ];
			var tangent = attributes[ "tangent" ];
	
			if ( geometry.elementsNeedUpdate && index !== undefined ) {
	
				_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );
				_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, index.array, hint );
	
			}
	
			if ( geometry.verticesNeedUpdate && position !== undefined ) {
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, position.buffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, position.array, hint );
	
			}
	
			if ( geometry.normalsNeedUpdate && normal !== undefined ) {
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, normal.buffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, normal.array, hint );
	
			}
	
			if ( geometry.uvsNeedUpdate && uv !== undefined ) {
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, uv.buffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, uv.array, hint );
	
			}
	
			if ( geometry.colorsNeedUpdate && color !== undefined ) {
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, color.buffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, color.array, hint );
	
			}
	
			if ( geometry.tangentsNeedUpdate && tangent !== undefined ) {
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, tangent.buffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, tangent.array, hint );
	
			}
	
			if ( dispose ) {
	
				for ( var i in geometry.attributes ) {
	
					delete geometry.attributes[ i ].array;
	
				}
	
			}
	
		};
	
		// Buffer rendering
	
		this.renderBufferImmediate = function ( object, program, material ) {
	
			if ( object.hasPositions && ! object.__webglVertexBuffer ) object.__webglVertexBuffer = _gl.createBuffer();
			if ( object.hasNormals && ! object.__webglNormalBuffer ) object.__webglNormalBuffer = _gl.createBuffer();
			if ( object.hasUvs && ! object.__webglUvBuffer ) object.__webglUvBuffer = _gl.createBuffer();
			if ( object.hasColors && ! object.__webglColorBuffer ) object.__webglColorBuffer = _gl.createBuffer();
	
			if ( object.hasPositions ) {
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglVertexBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );
				_gl.enableVertexAttribArray( program.attributes.position );
				_gl.vertexAttribPointer( program.attributes.position, 3, _gl.FLOAT, false, 0, 0 );
	
			}
	
			if ( object.hasNormals ) {
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglNormalBuffer );
	
				if ( material.shading === THREE.FlatShading ) {
	
					var nx, ny, nz,
						nax, nbx, ncx, nay, nby, ncy, naz, nbz, ncz,
						normalArray,
						i, il = object.count * 3;
	
					for( i = 0; i < il; i += 9 ) {
	
						normalArray = object.normalArray;
	
						nax  = normalArray[ i ];
						nay  = normalArray[ i + 1 ];
						naz  = normalArray[ i + 2 ];
	
						nbx  = normalArray[ i + 3 ];
						nby  = normalArray[ i + 4 ];
						nbz  = normalArray[ i + 5 ];
	
						ncx  = normalArray[ i + 6 ];
						ncy  = normalArray[ i + 7 ];
						ncz  = normalArray[ i + 8 ];
	
						nx = ( nax + nbx + ncx ) / 3;
						ny = ( nay + nby + ncy ) / 3;
						nz = ( naz + nbz + ncz ) / 3;
	
						normalArray[ i ] 	 = nx;
						normalArray[ i + 1 ] = ny;
						normalArray[ i + 2 ] = nz;
	
						normalArray[ i + 3 ] = nx;
						normalArray[ i + 4 ] = ny;
						normalArray[ i + 5 ] = nz;
	
						normalArray[ i + 6 ] = nx;
						normalArray[ i + 7 ] = ny;
						normalArray[ i + 8 ] = nz;
	
					}
	
				}
	
				_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );
				_gl.enableVertexAttribArray( program.attributes.normal );
				_gl.vertexAttribPointer( program.attributes.normal, 3, _gl.FLOAT, false, 0, 0 );
	
			}
	
			if ( object.hasUvs && material.map ) {
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglUvBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );
				_gl.enableVertexAttribArray( program.attributes.uv );
				_gl.vertexAttribPointer( program.attributes.uv, 2, _gl.FLOAT, false, 0, 0 );
	
			}
	
			if ( object.hasColors && material.vertexColors !== THREE.NoColors ) {
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglColorBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );
				_gl.enableVertexAttribArray( program.attributes.color );
				_gl.vertexAttribPointer( program.attributes.color, 3, _gl.FLOAT, false, 0, 0 );
	
			}
	
			_gl.drawArrays( _gl.TRIANGLES, 0, object.count );
	
			object.count = 0;
	
		};
	
		this.renderBufferDirect = function ( camera, lights, fog, material, geometry, object ) {
	
			if ( material.visible === false ) return;
	
			var program, attributes, linewidth, primitives, a, attribute;
	
			program = setProgram( camera, lights, fog, material, object );
	
			attributes = program.attributes;
	
			var updateBuffers = false,
				wireframeBit = material.wireframe ? 1 : 0,
				geometryHash = ( geometry.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;
	
			if ( geometryHash !== _currentGeometryGroupHash ) {
	
				_currentGeometryGroupHash = geometryHash;
				updateBuffers = true;
	
			}
	
			if ( updateBuffers ) {
	
				disableAttributes();
	
			}
	
			// render mesh
	
			if ( object instanceof THREE.Mesh ) {
	
				var index = geometry.attributes[ "index" ];
	
				// indexed triangles
	
				if ( index ) {
	
					var offsets = geometry.offsets;
	
					// if there is more than 1 chunk
					// must set attribute pointers to use new offsets for each chunk
					// even if geometry and materials didn't change
	
					if ( offsets.length > 1 ) updateBuffers = true;
	
					for ( var i = 0, il = offsets.length; i < il; i ++ ) {
	
						var startIndex = offsets[ i ].index;
	
						if ( updateBuffers ) {
	
							// vertices
	
							var position = geometry.attributes[ "position" ];
							var positionSize = position.itemSize;
	
							_gl.bindBuffer( _gl.ARRAY_BUFFER, position.buffer );
							enableAttribute( attributes.position );
							_gl.vertexAttribPointer( attributes.position, positionSize, _gl.FLOAT, false, 0, startIndex * positionSize * 4 ); // 4 bytes per Float32
	
							// normals
	
							var normal = geometry.attributes[ "normal" ];
	
							if ( attributes.normal >= 0 && normal ) {
	
								var normalSize = normal.itemSize;
	
								_gl.bindBuffer( _gl.ARRAY_BUFFER, normal.buffer );
								enableAttribute( attributes.normal );
								_gl.vertexAttribPointer( attributes.normal, normalSize, _gl.FLOAT, false, 0, startIndex * normalSize * 4 );
	
							}
	
							// uvs
	
							var uv = geometry.attributes[ "uv" ];
	
							if ( attributes.uv >= 0 && uv ) {
	
								var uvSize = uv.itemSize;
	
								_gl.bindBuffer( _gl.ARRAY_BUFFER, uv.buffer );
								enableAttribute( attributes.uv );
								_gl.vertexAttribPointer( attributes.uv, uvSize, _gl.FLOAT, false, 0, startIndex * uvSize * 4 );
	
							}
	
							// colors
	
							var color = geometry.attributes[ "color" ];
	
							if ( attributes.color >= 0 && color ) {
	
								var colorSize = color.itemSize;
	
								_gl.bindBuffer( _gl.ARRAY_BUFFER, color.buffer );
								enableAttribute( attributes.color );
								_gl.vertexAttribPointer( attributes.color, colorSize, _gl.FLOAT, false, 0, startIndex * colorSize * 4 );
	
							}
	
							// tangents
	
							var tangent = geometry.attributes[ "tangent" ];
	
							if ( attributes.tangent >= 0 && tangent ) {
	
								var tangentSize = tangent.itemSize;
	
								_gl.bindBuffer( _gl.ARRAY_BUFFER, tangent.buffer );
								enableAttribute( attributes.tangent );
								_gl.vertexAttribPointer( attributes.tangent, tangentSize, _gl.FLOAT, false, 0, startIndex * tangentSize * 4 );
	
							}
	
							// indices
	
							_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );
	
						}
	
						// render indexed triangles
	
						_gl.drawElements( _gl.TRIANGLES, offsets[ i ].count, _gl.UNSIGNED_SHORT, offsets[ i ].start * 2 ); // 2 bytes per Uint16
	
						_this.info.render.calls ++;
						_this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared
						_this.info.render.faces += offsets[ i ].count / 3;
	
					}
	
				// non-indexed triangles
	
				} else {
	
					if ( updateBuffers ) {
	
						// vertices
	
						var position = geometry.attributes[ "position" ];
						var positionSize = position.itemSize;
	
						_gl.bindBuffer( _gl.ARRAY_BUFFER, position.buffer );
						enableAttribute( attributes.position );
						_gl.vertexAttribPointer( attributes.position, positionSize, _gl.FLOAT, false, 0, 0 );
	
						// normals
	
						var normal = geometry.attributes[ "normal" ];
	
						if ( attributes.normal >= 0 && normal ) {
	
							var normalSize = normal.itemSize;
	
							_gl.bindBuffer( _gl.ARRAY_BUFFER, normal.buffer );
							enableAttribute( attributes.normal );
							_gl.vertexAttribPointer( attributes.normal, normalSize, _gl.FLOAT, false, 0, 0 );
	
						}
	
						// uvs
	
						var uv = geometry.attributes[ "uv" ];
	
						if ( attributes.uv >= 0 && uv ) {
	
							var uvSize = uv.itemSize;
	
							_gl.bindBuffer( _gl.ARRAY_BUFFER, uv.buffer );
							enableAttribute( attributes.uv );
							_gl.vertexAttribPointer( attributes.uv, uvSize, _gl.FLOAT, false, 0, 0 );
	
						}
	
						// colors
	
						var color = geometry.attributes[ "color" ];
	
						if ( attributes.color >= 0 && color ) {
	
							var colorSize = color.itemSize;
	
							_gl.bindBuffer( _gl.ARRAY_BUFFER, color.buffer );
							enableAttribute( attributes.color );
							_gl.vertexAttribPointer( attributes.color, colorSize, _gl.FLOAT, false, 0, 0 );
	
						}
	
						// tangents
	
						var tangent = geometry.attributes[ "tangent" ];
	
						if ( attributes.tangent >= 0 && tangent ) {
	
							var tangentSize = tangent.itemSize;
	
							_gl.bindBuffer( _gl.ARRAY_BUFFER, tangent.buffer );
							enableAttribute( attributes.tangent );
							_gl.vertexAttribPointer( attributes.tangent, tangentSize, _gl.FLOAT, false, 0, 0 );
	
						}
	
					}
	
					// render non-indexed triangles
	
					_gl.drawArrays( _gl.TRIANGLES, 0, position.numItems / 3 );
	
					_this.info.render.calls ++;
					_this.info.render.vertices += position.numItems / 3;
					_this.info.render.faces += position.numItems / 3 / 3;
	
				}
	
			// render particles
	
			} else if ( object instanceof THREE.ParticleSystem ) {
	
				if ( updateBuffers ) {
	
					// vertices
	
					var position = geometry.attributes[ "position" ];
					var positionSize = position.itemSize;
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, position.buffer );
					enableAttribute( attributes.position );
					_gl.vertexAttribPointer( attributes.position, positionSize, _gl.FLOAT, false, 0, 0 );
	
					// colors
	
					var color = geometry.attributes[ "color" ];
	
					if ( attributes.color >= 0 && color ) {
	
						var colorSize = color.itemSize;
	
						_gl.bindBuffer( _gl.ARRAY_BUFFER, color.buffer );
						enableAttribute( attributes.color );
						_gl.vertexAttribPointer( attributes.color, colorSize, _gl.FLOAT, false, 0, 0 );
	
					}
	
					// render particles
	
					_gl.drawArrays( _gl.POINTS, 0, position.numItems / 3 );
	
					_this.info.render.calls ++;
					_this.info.render.points += position.numItems / 3;
	
				}
	
			} else if ( object instanceof THREE.Line ) {
	
				if ( updateBuffers ) {
	
					// vertices
	
					var position = geometry.attributes[ "position" ];
					var positionSize = position.itemSize;
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, position.buffer );
					enableAttribute( attributes.position );
					_gl.vertexAttribPointer( attributes.position, positionSize, _gl.FLOAT, false, 0, 0 );
	
					// colors
	
					var color = geometry.attributes[ "color" ];
	
					if ( attributes.color >= 0 && color ) {
	
						var colorSize = color.itemSize;
	
						_gl.bindBuffer( _gl.ARRAY_BUFFER, color.buffer );
						enableAttribute( attributes.color );
						_gl.vertexAttribPointer( attributes.color, colorSize, _gl.FLOAT, false, 0, 0 );
	
					}
	
					// render lines
	
					setLineWidth( material.linewidth );
	
					_gl.drawArrays( _gl.LINE_STRIP, 0, position.numItems / 3 );
	
					_this.info.render.calls ++;
					_this.info.render.points += position.numItems;
	
				}
	
	    }
	
		};
	
		this.renderBuffer = function ( camera, lights, fog, material, geometryGroup, object ) {
	
			if ( material.visible === false ) return;
	
			var program, attributes, linewidth, primitives, a, attribute, i, il;
	
			program = setProgram( camera, lights, fog, material, object );
	
			attributes = program.attributes;
	
			var updateBuffers = false,
				wireframeBit = material.wireframe ? 1 : 0,
				geometryGroupHash = ( geometryGroup.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;
	
			if ( geometryGroupHash !== _currentGeometryGroupHash ) {
	
				_currentGeometryGroupHash = geometryGroupHash;
				updateBuffers = true;
	
			}
	
			if ( updateBuffers ) {
	
				disableAttributes();
	
			}
	
			// vertices
	
			if ( !material.morphTargets && attributes.position >= 0 ) {
	
				if ( updateBuffers ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
					enableAttribute( attributes.position );
					_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );
	
				}
	
			} else {
	
				if ( object.morphTargetBase ) {
	
					setupMorphTargets( material, geometryGroup, object );
	
				}
	
			}
	
	
			if ( updateBuffers ) {
	
				// custom attributes
	
				// Use the per-geometryGroup custom attribute arrays which are setup in initMeshBuffers
	
				if ( geometryGroup.__webglCustomAttributesList ) {
	
					for ( i = 0, il = geometryGroup.__webglCustomAttributesList.length; i < il; i ++ ) {
	
						attribute = geometryGroup.__webglCustomAttributesList[ i ];
	
						if ( attributes[ attribute.buffer.belongsToAttribute ] >= 0 ) {
	
							_gl.bindBuffer( _gl.ARRAY_BUFFER, attribute.buffer );
							enableAttribute( attributes[ attribute.buffer.belongsToAttribute ] );
							_gl.vertexAttribPointer( attributes[ attribute.buffer.belongsToAttribute ], attribute.size, _gl.FLOAT, false, 0, 0 );
	
						}
	
					}
	
				}
	
	
				// colors
	
				if ( attributes.color >= 0 ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );
					enableAttribute( attributes.color );
					_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );
	
				}
	
				// normals
	
				if ( attributes.normal >= 0 ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );
					enableAttribute( attributes.normal );
					_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );
	
				}
	
				// tangents
	
				if ( attributes.tangent >= 0 ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );
					enableAttribute( attributes.tangent );
					_gl.vertexAttribPointer( attributes.tangent, 4, _gl.FLOAT, false, 0, 0 );
	
				}
	
				// uvs
	
				if ( attributes.uv >= 0 ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );
					enableAttribute( attributes.uv );
					_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );
	
				}
	
				if ( attributes.uv2 >= 0 ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );
					enableAttribute( attributes.uv2 );
					_gl.vertexAttribPointer( attributes.uv2, 2, _gl.FLOAT, false, 0, 0 );
	
				}
	
				if ( material.skinning &&
					 attributes.skinIndex >= 0 && attributes.skinWeight >= 0 ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );
					enableAttribute( attributes.skinIndex );
					_gl.vertexAttribPointer( attributes.skinIndex, 4, _gl.FLOAT, false, 0, 0 );
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );
					enableAttribute( attributes.skinWeight );
					_gl.vertexAttribPointer( attributes.skinWeight, 4, _gl.FLOAT, false, 0, 0 );
	
				}
	
				// line distances
	
				if ( attributes.lineDistance >= 0 ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglLineDistanceBuffer );
					enableAttribute( attributes.lineDistance );
					_gl.vertexAttribPointer( attributes.lineDistance, 1, _gl.FLOAT, false, 0, 0 );
	
				}
	
			}
	
			// render mesh
	
			if ( object instanceof THREE.Mesh ) {
	
				// wireframe
	
				if ( material.wireframe ) {
	
					setLineWidth( material.wireframeLinewidth );
	
					if ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
					_gl.drawElements( _gl.LINES, geometryGroup.__webglLineCount, _gl.UNSIGNED_SHORT, 0 );
	
				// triangles
	
				} else {
	
					if ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
					_gl.drawElements( _gl.TRIANGLES, geometryGroup.__webglFaceCount, _gl.UNSIGNED_SHORT, 0 );
	
				}
	
				_this.info.render.calls ++;
				_this.info.render.vertices += geometryGroup.__webglFaceCount;
				_this.info.render.faces += geometryGroup.__webglFaceCount / 3;
	
			// render lines
	
			} else if ( object instanceof THREE.Line ) {
	
				primitives = ( object.type === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;
	
				setLineWidth( material.linewidth );
	
				_gl.drawArrays( primitives, 0, geometryGroup.__webglLineCount );
	
				_this.info.render.calls ++;
	
			// render particles
	
			} else if ( object instanceof THREE.ParticleSystem ) {
	
				_gl.drawArrays( _gl.POINTS, 0, geometryGroup.__webglParticleCount );
	
				_this.info.render.calls ++;
				_this.info.render.points += geometryGroup.__webglParticleCount;
	
			// render ribbon
	
			} else if ( object instanceof THREE.Ribbon ) {
	
				_gl.drawArrays( _gl.TRIANGLE_STRIP, 0, geometryGroup.__webglVertexCount );
	
				_this.info.render.calls ++;
	
			}
	
		};
	
		function enableAttribute( attribute ) {
	
			if ( ! _enabledAttributes[ attribute ] ) {
	
				_gl.enableVertexAttribArray( attribute );
				_enabledAttributes[ attribute ] = true;
	
			}
	
		};
	
		function disableAttributes() {
	
			for ( var attribute in _enabledAttributes ) {
	
				if ( _enabledAttributes[ attribute ] ) {
	
					_gl.disableVertexAttribArray( attribute );
					_enabledAttributes[ attribute ] = false;
	
				}
	
			}
	
		};
	
		function setupMorphTargets ( material, geometryGroup, object ) {
	
			// set base
	
			var attributes = material.program.attributes;
	
			if ( object.morphTargetBase !== -1 && attributes.position >= 0 ) {
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ object.morphTargetBase ] );
				enableAttribute( attributes.position );
				_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );
	
			} else if ( attributes.position >= 0 ) {
	
				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
				enableAttribute( attributes.position );
				_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );
	
			}
	
			if ( object.morphTargetForcedOrder.length ) {
	
				// set forced order
	
				var m = 0;
				var order = object.morphTargetForcedOrder;
				var influences = object.morphTargetInfluences;
	
				while ( m < material.numSupportedMorphTargets && m < order.length ) {
	
					if ( attributes[ "morphTarget" + m ] >= 0 ) {
	
						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ order[ m ] ] );
						enableAttribute( attributes[ "morphTarget" + m ] );
						_gl.vertexAttribPointer( attributes[ "morphTarget" + m ], 3, _gl.FLOAT, false, 0, 0 );
	
					}
	
					if ( attributes[ "morphNormal" + m ] >= 0 && material.morphNormals ) {
	
						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ order[ m ] ] );
						enableAttribute( attributes[ "morphNormal" + m ] );
						_gl.vertexAttribPointer( attributes[ "morphNormal" + m ], 3, _gl.FLOAT, false, 0, 0 );
	
					}
	
					object.__webglMorphTargetInfluences[ m ] = influences[ order[ m ] ];
	
					m ++;
				}
	
			} else {
	
				// find the most influencing
	
				var influence, activeInfluenceIndices = [];
				var influences = object.morphTargetInfluences;
				var i, il = influences.length;
	
				for ( i = 0; i < il; i ++ ) {
	
					influence = influences[ i ];
	
					if ( influence > 0 ) {
	
						activeInfluenceIndices.push( [ influence, i ] );
	
					}
	
				}
	
				if ( activeInfluenceIndices.length > material.numSupportedMorphTargets ) {
	
					activeInfluenceIndices.sort( numericalSort );
					activeInfluenceIndices.length = material.numSupportedMorphTargets;
	
				} else if ( activeInfluenceIndices.length > material.numSupportedMorphNormals ) {
	
					activeInfluenceIndices.sort( numericalSort );
	
				} else if ( activeInfluenceIndices.length === 0 ) {
	
					activeInfluenceIndices.push( [ 0, 0 ] );
	
				};
	
				var influenceIndex, m = 0;
	
				while ( m < material.numSupportedMorphTargets ) {
	
					if ( activeInfluenceIndices[ m ] ) {
	
						influenceIndex = activeInfluenceIndices[ m ][ 1 ];
	
						if ( attributes[ "morphTarget" + m ] >= 0 ) {
	
							_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ influenceIndex ] );
							enableAttribute( attributes[ "morphTarget" + m ] );
							_gl.vertexAttribPointer( attributes[ "morphTarget" + m ], 3, _gl.FLOAT, false, 0, 0 );
	
						}
	
						if ( attributes[ "morphNormal" + m ] >= 0 && material.morphNormals ) {
	
							_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ influenceIndex ] );
							enableAttribute( attributes[ "morphNormal" + m ] );
							_gl.vertexAttribPointer( attributes[ "morphNormal" + m ], 3, _gl.FLOAT, false, 0, 0 );
	
	
						}
	
						object.__webglMorphTargetInfluences[ m ] = influences[ influenceIndex ];
	
					} else {
	
						/*
						_gl.vertexAttribPointer( attributes[ "morphTarget" + m ], 3, _gl.FLOAT, false, 0, 0 );
	
						if ( material.morphNormals ) {
	
							_gl.vertexAttribPointer( attributes[ "morphNormal" + m ], 3, _gl.FLOAT, false, 0, 0 );
	
						}
						*/
	
						object.__webglMorphTargetInfluences[ m ] = 0;
	
					}
	
					m ++;
	
				}
	
			}
	
			// load updated influences uniform
	
			if ( material.program.uniforms.morphTargetInfluences !== null ) {
	
				_gl.uniform1fv( material.program.uniforms.morphTargetInfluences, object.__webglMorphTargetInfluences );
	
			}
	
		};
	
		// Sorting
	
		function painterSortStable ( a, b ) {
	
			if ( a.z !== b.z ) {
	
				return b.z - a.z;
	
			} else {
	
				return b.id - a.id;
	
			}
	
		};
	
		function numericalSort ( a, b ) {
	
			return b[ 0 ] - a[ 0 ];
	
		};
	
	
		// Rendering
	
		this.render = function ( scene, camera, renderTarget, forceClear ) {
	
			if ( camera instanceof THREE.Camera === false ) {
	
				console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
				return;
	
			}
	
			var i, il,
	
			webglObject, object,
			renderList,
	
			lights = scene.__lights,
			fog = scene.fog;
	
			// reset caching for this frame
	
			_currentMaterialId = -1;
			_lightsNeedUpdate = true;
	
			// update scene graph
	
			if ( this.autoUpdateScene ) scene.updateMatrixWorld();
	
			// update camera matrices and frustum
	
			if ( camera.parent === undefined ) camera.updateMatrixWorld();
	
			camera.matrixWorldInverse.getInverse( camera.matrixWorld );
	
			_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
			_frustum.setFromMatrix( _projScreenMatrix );
	
			// update WebGL objects
	
			if ( this.autoUpdateObjects ) this.initWebGLObjects( scene );
	
			// custom render plugins (pre pass)
	
			renderPlugins( this.renderPluginsPre, scene, camera );
	
			//
	
			_this.info.render.calls = 0;
			_this.info.render.vertices = 0;
			_this.info.render.faces = 0;
			_this.info.render.points = 0;
	
			this.setRenderTarget( renderTarget );
	
			if ( this.autoClear || forceClear ) {
	
				this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );
	
			}
	
			// set matrices for regular objects (frustum culled)
	
			renderList = scene.__webglObjects;
	
			for ( i = 0, il = renderList.length; i < il; i ++ ) {
	
				webglObject = renderList[ i ];
				object = webglObject.object;
	
				webglObject.render = false;
	
				if ( object.visible ) {
	
					if ( ! ( object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.intersectsObject( object ) ) {
	
						setupMatrices( object, camera );
	
						unrollBufferMaterial( webglObject );
	
						webglObject.render = true;
	
						if ( this.sortObjects === true ) {
	
							if ( object.renderDepth !== null ) {
	
								webglObject.z = object.renderDepth;
	
							} else {
	
								_vector3.getPositionFromMatrix( object.matrixWorld );
								_vector3.applyProjection( _projScreenMatrix );
	
								webglObject.z = _vector3.z;
	
							}
	
							webglObject.id = object.id;
	
						}
	
					}
	
				}
	
			}
	
			if ( this.sortObjects ) {
	
				renderList.sort( painterSortStable );
	
			}
	
			// set matrices for immediate objects
	
			renderList = scene.__webglObjectsImmediate;
	
			for ( i = 0, il = renderList.length; i < il; i ++ ) {
	
				webglObject = renderList[ i ];
				object = webglObject.object;
	
				if ( object.visible ) {
	
					setupMatrices( object, camera );
	
					unrollImmediateBufferMaterial( webglObject );
	
				}
	
			}
	
			if ( scene.overrideMaterial ) {
	
				var material = scene.overrideMaterial;
	
				this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
				this.setDepthTest( material.depthTest );
				this.setDepthWrite( material.depthWrite );
				setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );
	
				renderObjects( scene.__webglObjects, false, "", camera, lights, fog, true, material );
				renderObjectsImmediate( scene.__webglObjectsImmediate, "", camera, lights, fog, false, material );
	
			} else {
	
				var material = null;
	
				// opaque pass (front-to-back order)
	
				this.setBlending( THREE.NoBlending );
	
				renderObjects( scene.__webglObjects, true, "opaque", camera, lights, fog, false, material );
				renderObjectsImmediate( scene.__webglObjectsImmediate, "opaque", camera, lights, fog, false, material );
	
				// transparent pass (back-to-front order)
	
				renderObjects( scene.__webglObjects, false, "transparent", camera, lights, fog, true, material );
				renderObjectsImmediate( scene.__webglObjectsImmediate, "transparent", camera, lights, fog, true, material );
	
			}
	
			// custom render plugins (post pass)
	
			renderPlugins( this.renderPluginsPost, scene, camera );
	
	
			// Generate mipmap if we're using any kind of mipmap filtering
	
			if ( renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter ) {
	
				updateRenderTargetMipmap( renderTarget );
	
			}
	
			// Ensure depth buffer writing is enabled so it can be cleared on next render
	
			this.setDepthTest( true );
			this.setDepthWrite( true );
	
			// _gl.finish();
	
		};
	
		function renderPlugins( plugins, scene, camera ) {
	
			if ( ! plugins.length ) return;
	
			for ( var i = 0, il = plugins.length; i < il; i ++ ) {
	
				// reset state for plugin (to start from clean slate)
	
				_currentProgram = null;
				_currentCamera = null;
	
				_oldBlending = -1;
				_oldDepthTest = -1;
				_oldDepthWrite = -1;
				_oldDoubleSided = -1;
				_oldFlipSided = -1;
				_currentGeometryGroupHash = -1;
				_currentMaterialId = -1;
	
				_lightsNeedUpdate = true;
	
				plugins[ i ].render( scene, camera, _currentWidth, _currentHeight );
	
				// reset state after plugin (anything could have changed)
	
				_currentProgram = null;
				_currentCamera = null;
	
				_oldBlending = -1;
				_oldDepthTest = -1;
				_oldDepthWrite = -1;
				_oldDoubleSided = -1;
				_oldFlipSided = -1;
				_currentGeometryGroupHash = -1;
				_currentMaterialId = -1;
	
				_lightsNeedUpdate = true;
	
			}
	
		};
	
		function renderObjects ( renderList, reverse, materialType, camera, lights, fog, useBlending, overrideMaterial ) {
	
			var webglObject, object, buffer, material, start, end, delta;
	
			if ( reverse ) {
	
				start = renderList.length - 1;
				end = -1;
				delta = -1;
	
			} else {
	
				start = 0;
				end = renderList.length;
				delta = 1;
			}
	
			for ( var i = start; i !== end; i += delta ) {
	
				webglObject = renderList[ i ];
	
				if ( webglObject.render ) {
	
					object = webglObject.object;
					buffer = webglObject.buffer;
	
					if ( overrideMaterial ) {
	
						material = overrideMaterial;
	
					} else {
	
						material = webglObject[ materialType ];
	
						if ( ! material ) continue;
	
						if ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
	
						_this.setDepthTest( material.depthTest );
						_this.setDepthWrite( material.depthWrite );
						setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );
	
					}
	
					_this.setMaterialFaces( material );
	
					if ( buffer instanceof THREE.BufferGeometry ) {
	
						_this.renderBufferDirect( camera, lights, fog, material, buffer, object );
	
					} else {
	
						_this.renderBuffer( camera, lights, fog, material, buffer, object );
	
					}
	
				}
	
			}
	
		};
	
		function renderObjectsImmediate ( renderList, materialType, camera, lights, fog, useBlending, overrideMaterial ) {
	
			var webglObject, object, material, program;
	
			for ( var i = 0, il = renderList.length; i < il; i ++ ) {
	
				webglObject = renderList[ i ];
				object = webglObject.object;
	
				if ( object.visible ) {
	
					if ( overrideMaterial ) {
	
						material = overrideMaterial;
	
					} else {
	
						material = webglObject[ materialType ];
	
						if ( ! material ) continue;
	
						if ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
	
						_this.setDepthTest( material.depthTest );
						_this.setDepthWrite( material.depthWrite );
						setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );
	
					}
	
					_this.renderImmediateObject( camera, lights, fog, material, object );
	
				}
	
			}
	
		};
	
		this.renderImmediateObject = function ( camera, lights, fog, material, object ) {
	
			var program = setProgram( camera, lights, fog, material, object );
	
			_currentGeometryGroupHash = -1;
	
			_this.setMaterialFaces( material );
	
			if ( object.immediateRenderCallback ) {
	
				object.immediateRenderCallback( program, _gl, _frustum );
	
			} else {
	
				object.render( function( object ) { _this.renderBufferImmediate( object, program, material ); } );
	
			}
	
		};
	
		function unrollImmediateBufferMaterial ( globject ) {
	
			var object = globject.object,
				material = object.material;
	
			if ( material.transparent ) {
	
				globject.transparent = material;
				globject.opaque = null;
	
			} else {
	
				globject.opaque = material;
				globject.transparent = null;
	
			}
	
		};
	
		function unrollBufferMaterial ( globject ) {
	
			var object = globject.object,
				buffer = globject.buffer,
				material, materialIndex, meshMaterial;
	
			meshMaterial = object.material;
	
			if ( meshMaterial instanceof THREE.MeshFaceMaterial ) {
	
				materialIndex = buffer.materialIndex;
	
				material = meshMaterial.materials[ materialIndex ];
	
				if ( material.transparent ) {
	
					globject.transparent = material;
					globject.opaque = null;
	
				} else {
	
					globject.opaque = material;
					globject.transparent = null;
	
				}
	
			} else {
	
				material = meshMaterial;
	
				if ( material ) {
	
					if ( material.transparent ) {
	
						globject.transparent = material;
						globject.opaque = null;
	
					} else {
	
						globject.opaque = material;
						globject.transparent = null;
	
					}
	
				}
	
			}
	
		};
	
		// Geometry splitting
	
		function sortFacesByMaterial ( geometry, material ) {
	
			var f, fl, face, materialIndex, vertices,
				groupHash, hash_map = {};
	
			var numMorphTargets = geometry.morphTargets.length;
			var numMorphNormals = geometry.morphNormals.length;
	
			var usesFaceMaterial = material instanceof THREE.MeshFaceMaterial;
	
			geometry.geometryGroups = {};
	
			for ( f = 0, fl = geometry.faces.length; f < fl; f ++ ) {
	
				face = geometry.faces[ f ];
				materialIndex = usesFaceMaterial ? face.materialIndex : 0;
	
				if ( hash_map[ materialIndex ] === undefined ) {
	
					hash_map[ materialIndex ] = { 'hash': materialIndex, 'counter': 0 };
	
				}
	
				groupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;
	
				if ( geometry.geometryGroups[ groupHash ] === undefined ) {
	
					geometry.geometryGroups[ groupHash ] = { 'faces3': [], 'faces4': [], 'materialIndex': materialIndex, 'vertices': 0, 'numMorphTargets': numMorphTargets, 'numMorphNormals': numMorphNormals };
	
				}
	
				vertices = face instanceof THREE.Face3 ? 3 : 4;
	
				if ( geometry.geometryGroups[ groupHash ].vertices + vertices > 65535 ) {
	
					hash_map[ materialIndex ].counter += 1;
					groupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;
	
					if ( geometry.geometryGroups[ groupHash ] === undefined ) {
	
						geometry.geometryGroups[ groupHash ] = { 'faces3': [], 'faces4': [], 'materialIndex': materialIndex, 'vertices': 0, 'numMorphTargets': numMorphTargets, 'numMorphNormals': numMorphNormals };
	
					}
	
				}
	
				if ( face instanceof THREE.Face3 ) {
	
					geometry.geometryGroups[ groupHash ].faces3.push( f );
	
				} else {
	
					geometry.geometryGroups[ groupHash ].faces4.push( f );
	
				}
	
				geometry.geometryGroups[ groupHash ].vertices += vertices;
	
			}
	
			geometry.geometryGroupsList = [];
	
			for ( var g in geometry.geometryGroups ) {
	
				geometry.geometryGroups[ g ].id = _geometryGroupCounter ++;
	
				geometry.geometryGroupsList.push( geometry.geometryGroups[ g ] );
	
			}
	
		};
	
		// Objects refresh
	
		this.initWebGLObjects = function ( scene ) {
	
			if ( !scene.__webglObjects ) {
	
				scene.__webglObjects = [];
				scene.__webglObjectsImmediate = [];
				scene.__webglSprites = [];
				scene.__webglFlares = [];
	
			}
	
			while ( scene.__objectsAdded.length ) {
	
				addObject( scene.__objectsAdded[ 0 ], scene );
				scene.__objectsAdded.splice( 0, 1 );
	
			}
	
			while ( scene.__objectsRemoved.length ) {
	
				removeObject( scene.__objectsRemoved[ 0 ], scene );
				scene.__objectsRemoved.splice( 0, 1 );
	
			}
	
			// update must be called after objects adding / removal
	
			for ( var o = 0, ol = scene.__webglObjects.length; o < ol; o ++ ) {
	
				updateObject( scene.__webglObjects[ o ].object );
	
			}
	
		};
	
		// Objects adding
	
		function addObject ( object, scene ) {
	
			var g, geometry, material, geometryGroup;
	
			if ( ! object.__webglInit ) {
	
				object.__webglInit = true;
	
				object._modelViewMatrix = new THREE.Matrix4();
				object._normalMatrix = new THREE.Matrix3();
	
				if ( object.geometry !== undefined && object.geometry.__webglInit === undefined ) {
	
					object.geometry.__webglInit = true;
					object.geometry.addEventListener( 'dispose', onGeometryDispose );
	
				}
	
				if ( object instanceof THREE.Mesh ) {
	
					geometry = object.geometry;
					material = object.material;
	
					if ( geometry instanceof THREE.Geometry ) {
	
						if ( geometry.geometryGroups === undefined ) {
	
							sortFacesByMaterial( geometry, material );
	
						}
	
						// create separate VBOs per geometry chunk
	
						for ( g in geometry.geometryGroups ) {
	
							geometryGroup = geometry.geometryGroups[ g ];
	
							// initialise VBO on the first access
	
							if ( ! geometryGroup.__webglVertexBuffer ) {
	
								createMeshBuffers( geometryGroup );
								initMeshBuffers( geometryGroup, object );
	
								geometry.verticesNeedUpdate = true;
								geometry.morphTargetsNeedUpdate = true;
								geometry.elementsNeedUpdate = true;
								geometry.uvsNeedUpdate = true;
								geometry.normalsNeedUpdate = true;
								geometry.tangentsNeedUpdate = true;
								geometry.colorsNeedUpdate = true;
	
							}
	
						}
	
					} else if ( geometry instanceof THREE.BufferGeometry ) {
	
						initDirectBuffers( geometry );
	
					}
	
				} else if ( object instanceof THREE.Ribbon ) {
	
					geometry = object.geometry;
	
					if ( ! geometry.__webglVertexBuffer ) {
	
						createRibbonBuffers( geometry );
						initRibbonBuffers( geometry, object );
	
						geometry.verticesNeedUpdate = true;
						geometry.colorsNeedUpdate = true;
						geometry.normalsNeedUpdate = true;
	
					}
	
				} else if ( object instanceof THREE.Line ) {
	
					geometry = object.geometry;
	
					if ( ! geometry.__webglVertexBuffer ) {
	
						if ( geometry instanceof THREE.Geometry ) {
	
	            createLineBuffers( geometry );
	            initLineBuffers( geometry, object );
	
	            geometry.verticesNeedUpdate = true;
	            geometry.colorsNeedUpdate = true;
	            geometry.lineDistancesNeedUpdate = true;
	
	          } else if ( geometry instanceof THREE.BufferGeometry ) {
	
							initDirectBuffers( geometry );
	
						}
	
					}
	
				} else if ( object instanceof THREE.ParticleSystem ) {
	
					geometry = object.geometry;
	
					if ( ! geometry.__webglVertexBuffer ) {
	
						if ( geometry instanceof THREE.Geometry ) {
	
							createParticleBuffers( geometry );
							initParticleBuffers( geometry, object );
	
							geometry.verticesNeedUpdate = true;
							geometry.colorsNeedUpdate = true;
	
						} else if ( geometry instanceof THREE.BufferGeometry ) {
	
							initDirectBuffers( geometry );
	
						}
	
	
					}
	
				}
	
			}
	
			if ( ! object.__webglActive ) {
	
				if ( object instanceof THREE.Mesh ) {
	
					geometry = object.geometry;
	
					if ( geometry instanceof THREE.BufferGeometry ) {
	
						addBuffer( scene.__webglObjects, geometry, object );
	
					} else if ( geometry instanceof THREE.Geometry ) {
	
						for ( g in geometry.geometryGroups ) {
	
							geometryGroup = geometry.geometryGroups[ g ];
	
							addBuffer( scene.__webglObjects, geometryGroup, object );
	
						}
	
					}
	
				} else if ( object instanceof THREE.Ribbon ||
							object instanceof THREE.Line ||
							object instanceof THREE.ParticleSystem ) {
	
					geometry = object.geometry;
					addBuffer( scene.__webglObjects, geometry, object );
	
				} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {
	
					addBufferImmediate( scene.__webglObjectsImmediate, object );
	
				} else if ( object instanceof THREE.Sprite ) {
	
					scene.__webglSprites.push( object );
	
				} else if ( object instanceof THREE.LensFlare ) {
	
					scene.__webglFlares.push( object );
	
				}
	
				object.__webglActive = true;
	
			}
	
		};
	
		function addBuffer ( objlist, buffer, object ) {
	
			objlist.push(
				{
					buffer: buffer,
					object: object,
					opaque: null,
					transparent: null
				}
			);
	
		};
	
		function addBufferImmediate ( objlist, object ) {
	
			objlist.push(
				{
					object: object,
					opaque: null,
					transparent: null
				}
			);
	
		};
	
		// Objects updates
	
		function updateObject ( object ) {
	
			var geometry = object.geometry,
				geometryGroup, customAttributesDirty, material;
	
			if ( object instanceof THREE.Mesh ) {
	
				if ( geometry instanceof THREE.BufferGeometry ) {
	
					if ( geometry.verticesNeedUpdate || geometry.elementsNeedUpdate ||
						 geometry.uvsNeedUpdate || geometry.normalsNeedUpdate ||
						 geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate ) {
	
						setDirectBuffers( geometry, _gl.DYNAMIC_DRAW, !geometry.dynamic );
	
					}
	
					geometry.verticesNeedUpdate = false;
					geometry.elementsNeedUpdate = false;
					geometry.uvsNeedUpdate = false;
					geometry.normalsNeedUpdate = false;
					geometry.colorsNeedUpdate = false;
					geometry.tangentsNeedUpdate = false;
	
				} else {
	
					// check all geometry groups
	
					for( var i = 0, il = geometry.geometryGroupsList.length; i < il; i ++ ) {
	
						geometryGroup = geometry.geometryGroupsList[ i ];
	
						material = getBufferMaterial( object, geometryGroup );
	
						if ( geometry.buffersNeedUpdate ) {
	
							initMeshBuffers( geometryGroup, object );
	
						}
	
						customAttributesDirty = material.attributes && areCustomAttributesDirty( material );
	
						if ( geometry.verticesNeedUpdate || geometry.morphTargetsNeedUpdate || geometry.elementsNeedUpdate ||
							 geometry.uvsNeedUpdate || geometry.normalsNeedUpdate ||
							 geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate || customAttributesDirty ) {
	
							setMeshBuffers( geometryGroup, object, _gl.DYNAMIC_DRAW, !geometry.dynamic, material );
	
						}
	
					}
	
					geometry.verticesNeedUpdate = false;
					geometry.morphTargetsNeedUpdate = false;
					geometry.elementsNeedUpdate = false;
					geometry.uvsNeedUpdate = false;
					geometry.normalsNeedUpdate = false;
					geometry.colorsNeedUpdate = false;
					geometry.tangentsNeedUpdate = false;
	
					geometry.buffersNeedUpdate = false;
	
					material.attributes && clearCustomAttributes( material );
	
				}
	
			} else if ( object instanceof THREE.Ribbon ) {
	
				material = getBufferMaterial( object, geometry );
	
				customAttributesDirty = material.attributes && areCustomAttributesDirty( material );
	
				if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.normalsNeedUpdate || customAttributesDirty ) {
	
					setRibbonBuffers( geometry, _gl.DYNAMIC_DRAW );
	
				}
	
				geometry.verticesNeedUpdate = false;
				geometry.colorsNeedUpdate = false;
				geometry.normalsNeedUpdate = false;
	
				material.attributes && clearCustomAttributes( material );
	
			} else if ( object instanceof THREE.Line ) {
	
	      if ( geometry instanceof THREE.BufferGeometry ) {
	
					if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate ) {
	
						setDirectBuffers( geometry, _gl.DYNAMIC_DRAW, !geometry.dynamic );
	
					}
	
					geometry.verticesNeedUpdate = false;
					geometry.colorsNeedUpdate = false;
	
				} else {
	
	        material = getBufferMaterial( object, geometry );
	
	        customAttributesDirty = material.attributes && areCustomAttributesDirty( material );
	
	        if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.lineDistancesNeedUpdate || customAttributesDirty ) {
	
	          setLineBuffers( geometry, _gl.DYNAMIC_DRAW );
	
	        }
	
	        geometry.verticesNeedUpdate = false;
	        geometry.colorsNeedUpdate = false;
	        geometry.lineDistancesNeedUpdate = false;
	
	        material.attributes && clearCustomAttributes( material );
	
	      }
	
			} else if ( object instanceof THREE.ParticleSystem ) {
	
				if ( geometry instanceof THREE.BufferGeometry ) {
	
					if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate ) {
	
						setDirectBuffers( geometry, _gl.DYNAMIC_DRAW, !geometry.dynamic );
	
					}
	
					geometry.verticesNeedUpdate = false;
					geometry.colorsNeedUpdate = false;
	
				} else {
	
					material = getBufferMaterial( object, geometry );
	
					customAttributesDirty = material.attributes && areCustomAttributesDirty( material );
	
					if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || object.sortParticles || customAttributesDirty ) {
	
						setParticleBuffers( geometry, _gl.DYNAMIC_DRAW, object );
	
					}
	
					geometry.verticesNeedUpdate = false;
					geometry.colorsNeedUpdate = false;
	
					material.attributes && clearCustomAttributes( material );
	
				}
	
			}
	
		};
	
		// Objects updates - custom attributes check
	
		function areCustomAttributesDirty ( material ) {
	
			for ( var a in material.attributes ) {
	
				if ( material.attributes[ a ].needsUpdate ) return true;
	
			}
	
			return false;
	
		};
	
		function clearCustomAttributes ( material ) {
	
			for ( var a in material.attributes ) {
	
				material.attributes[ a ].needsUpdate = false;
	
			}
	
		};
	
		// Objects removal
	
		function removeObject ( object, scene ) {
	
			if ( object instanceof THREE.Mesh  ||
				 object instanceof THREE.ParticleSystem ||
				 object instanceof THREE.Ribbon ||
				 object instanceof THREE.Line ) {
	
				removeInstances( scene.__webglObjects, object );
	
			} else if ( object instanceof THREE.Sprite ) {
	
				removeInstancesDirect( scene.__webglSprites, object );
	
			} else if ( object instanceof THREE.LensFlare ) {
	
				removeInstancesDirect( scene.__webglFlares, object );
	
			} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {
	
				removeInstances( scene.__webglObjectsImmediate, object );
	
			}
	
			object.__webglActive = false;
	
		};
	
		function removeInstances ( objlist, object ) {
	
			for ( var o = objlist.length - 1; o >= 0; o -- ) {
	
				if ( objlist[ o ].object === object ) {
	
					objlist.splice( o, 1 );
	
				}
	
			}
	
		};
	
		function removeInstancesDirect ( objlist, object ) {
	
			for ( var o = objlist.length - 1; o >= 0; o -- ) {
	
				if ( objlist[ o ] === object ) {
	
					objlist.splice( o, 1 );
	
				}
	
			}
	
		};
	
		// Materials
	
		this.initMaterial = function ( material, lights, fog, object ) {
	
			material.addEventListener( 'dispose', onMaterialDispose );
	
			var u, a, identifiers, i, parameters, maxLightCount, maxBones, maxShadows, shaderID;
	
			if ( material instanceof THREE.MeshDepthMaterial ) {
	
				shaderID = 'depth';
	
			} else if ( material instanceof THREE.MeshNormalMaterial ) {
	
				shaderID = 'normal';
	
			} else if ( material instanceof THREE.MeshBasicMaterial ) {
	
				shaderID = 'basic';
	
			} else if ( material instanceof THREE.MeshLambertMaterial ) {
	
				shaderID = 'lambert';
	
			} else if ( material instanceof THREE.MeshPhongMaterial ) {
	
				shaderID = 'phong';
	
			} else if ( material instanceof THREE.LineBasicMaterial ) {
	
				shaderID = 'basic';
	
			} else if ( material instanceof THREE.LineDashedMaterial ) {
	
				shaderID = 'dashed';
	
			} else if ( material instanceof THREE.ParticleBasicMaterial ) {
	
				shaderID = 'particle_basic';
	
			}
	
			if ( shaderID ) {
	
				setMaterialShaders( material, THREE.ShaderLib[ shaderID ] );
	
			}
	
			// heuristics to create shader parameters according to lights in the scene
			// (not to blow over maxLights budget)
	
			maxLightCount = allocateLights( lights );
	
			maxShadows = allocateShadows( lights );
	
			maxBones = allocateBones( object );
	
			parameters = {
	
				map: !!material.map,
				envMap: !!material.envMap,
				lightMap: !!material.lightMap,
				bumpMap: !!material.bumpMap,
				normalMap: !!material.normalMap,
				specularMap: !!material.specularMap,
	
				vertexColors: material.vertexColors,
	
				fog: fog,
				useFog: material.fog,
				fogExp: fog instanceof THREE.FogExp2,
	
				sizeAttenuation: material.sizeAttenuation,
	
				skinning: material.skinning,
				maxBones: maxBones,
				useVertexTexture: _supportsBoneTextures && object && object.useVertexTexture,
				boneTextureWidth: object && object.boneTextureWidth,
				boneTextureHeight: object && object.boneTextureHeight,
	
				morphTargets: material.morphTargets,
				morphNormals: material.morphNormals,
				maxMorphTargets: this.maxMorphTargets,
				maxMorphNormals: this.maxMorphNormals,
	
				maxDirLights: maxLightCount.directional,
				maxPointLights: maxLightCount.point,
				maxSpotLights: maxLightCount.spot,
				maxHemiLights: maxLightCount.hemi,
	
				maxShadows: maxShadows,
				shadowMapEnabled: this.shadowMapEnabled && object.receiveShadow,
				shadowMapType: this.shadowMapType,
				shadowMapDebug: this.shadowMapDebug,
				shadowMapCascade: this.shadowMapCascade,
	
				alphaTest: material.alphaTest,
				metal: material.metal,
				perPixel: material.perPixel,
				wrapAround: material.wrapAround,
				doubleSided: material.side === THREE.DoubleSide,
				flipSided: material.side === THREE.BackSide
	
			};
	
			material.program = buildProgram( shaderID, material.fragmentShader, material.vertexShader, material.uniforms, material.attributes, material.defines, parameters );
	
			var attributes = material.program.attributes;
	
			if ( material.morphTargets ) {
	
				material.numSupportedMorphTargets = 0;
	
				var id, base = "morphTarget";
	
				for ( i = 0; i < this.maxMorphTargets; i ++ ) {
	
					id = base + i;
	
					if ( attributes[ id ] >= 0 ) {
	
						material.numSupportedMorphTargets ++;
	
					}
	
				}
	
			}
	
			if ( material.morphNormals ) {
	
				material.numSupportedMorphNormals = 0;
	
				var id, base = "morphNormal";
	
				for ( i = 0; i < this.maxMorphNormals; i ++ ) {
	
					id = base + i;
	
					if ( attributes[ id ] >= 0 ) {
	
						material.numSupportedMorphNormals ++;
	
					}
	
				}
	
			}
	
			material.uniformsList = [];
	
			for ( u in material.uniforms ) {
	
				material.uniformsList.push( [ material.uniforms[ u ], u ] );
	
			}
	
		};
	
		function setMaterialShaders( material, shaders ) {
	
			material.uniforms = THREE.UniformsUtils.clone( shaders.uniforms );
			material.vertexShader = shaders.vertexShader;
			material.fragmentShader = shaders.fragmentShader;
	
		};
	
		function setProgram( camera, lights, fog, material, object ) {
	
			_usedTextureUnits = 0;
	
			if ( material.needsUpdate ) {
	
				if ( material.program ) deallocateMaterial( material );
	
				_this.initMaterial( material, lights, fog, object );
				material.needsUpdate = false;
	
			}
	
			if ( material.morphTargets ) {
	
				if ( ! object.__webglMorphTargetInfluences ) {
	
					object.__webglMorphTargetInfluences = new Float32Array( _this.maxMorphTargets );
	
				}
	
			}
	
			var refreshMaterial = false;
	
			var program = material.program,
				p_uniforms = program.uniforms,
				m_uniforms = material.uniforms;
	
			if ( program !== _currentProgram ) {
	
				_gl.useProgram( program );
				_currentProgram = program;
	
				refreshMaterial = true;
	
			}
	
			if ( material.id !== _currentMaterialId ) {
	
				_currentMaterialId = material.id;
				refreshMaterial = true;
	
			}
	
			if ( refreshMaterial || camera !== _currentCamera ) {
	
				_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );
	
				if ( camera !== _currentCamera ) _currentCamera = camera;
	
			}
	
			// skinning uniforms must be set even if material didn't change
			// auto-setting of texture unit for bone texture must go before other textures
			// not sure why, but otherwise weird things happen
	
			if ( material.skinning ) {
	
				if ( _supportsBoneTextures && object.useVertexTexture ) {
	
					if ( p_uniforms.boneTexture !== null ) {
	
						var textureUnit = getTextureUnit();
	
						_gl.uniform1i( p_uniforms.boneTexture, textureUnit );
						_this.setTexture( object.boneTexture, textureUnit );
	
					}
	
				} else {
	
					if ( p_uniforms.boneGlobalMatrices !== null ) {
	
						_gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.boneMatrices );
	
					}
	
				}
	
			}
	
			if ( refreshMaterial ) {
	
				// refresh uniforms common to several materials
	
				if ( fog && material.fog ) {
	
					refreshUniformsFog( m_uniforms, fog );
	
				}
	
				if ( material instanceof THREE.MeshPhongMaterial ||
					 material instanceof THREE.MeshLambertMaterial ||
					 material.lights ) {
	
					if ( _lightsNeedUpdate ) {
	
						setupLights( program, lights );
						_lightsNeedUpdate = false;
	
					}
	
					refreshUniformsLights( m_uniforms, _lights );
	
				}
	
				if ( material instanceof THREE.MeshBasicMaterial ||
					 material instanceof THREE.MeshLambertMaterial ||
					 material instanceof THREE.MeshPhongMaterial ) {
	
					refreshUniformsCommon( m_uniforms, material );
	
				}
	
				// refresh single material specific uniforms
	
				if ( material instanceof THREE.LineBasicMaterial ) {
	
					refreshUniformsLine( m_uniforms, material );
	
				} else if ( material instanceof THREE.LineDashedMaterial ) {
	
					refreshUniformsLine( m_uniforms, material );
					refreshUniformsDash( m_uniforms, material );
	
				} else if ( material instanceof THREE.ParticleBasicMaterial ) {
	
					refreshUniformsParticle( m_uniforms, material );
	
				} else if ( material instanceof THREE.MeshPhongMaterial ) {
	
					refreshUniformsPhong( m_uniforms, material );
	
				} else if ( material instanceof THREE.MeshLambertMaterial ) {
	
					refreshUniformsLambert( m_uniforms, material );
	
				} else if ( material instanceof THREE.MeshDepthMaterial ) {
	
					m_uniforms.mNear.value = camera.near;
					m_uniforms.mFar.value = camera.far;
					m_uniforms.opacity.value = material.opacity;
	
				} else if ( material instanceof THREE.MeshNormalMaterial ) {
	
					m_uniforms.opacity.value = material.opacity;
	
				}
	
				if ( object.receiveShadow && ! material._shadowPass ) {
	
					refreshUniformsShadow( m_uniforms, lights );
	
				}
	
				// load common uniforms
	
				loadUniformsGeneric( program, material.uniformsList );
	
				// load material specific uniforms
				// (shader material also gets them for the sake of genericity)
	
				if ( material instanceof THREE.ShaderMaterial ||
					 material instanceof THREE.MeshPhongMaterial ||
					 material.envMap ) {
	
					if ( p_uniforms.cameraPosition !== null ) {
	
						_vector3.getPositionFromMatrix( camera.matrixWorld );
						_gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );
	
					}
	
				}
	
				if ( material instanceof THREE.MeshPhongMaterial ||
					 material instanceof THREE.MeshLambertMaterial ||
					 material instanceof THREE.ShaderMaterial ||
					 material.skinning ) {
	
					if ( p_uniforms.viewMatrix !== null ) {
	
						_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );
	
					}
	
				}
	
			}
	
			loadUniformsMatrices( p_uniforms, object );
	
			if ( p_uniforms.modelMatrix !== null ) {
	
				_gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );
	
			}
	
			return program;
	
		};
	
		// Uniforms (refresh uniforms objects)
	
		function refreshUniformsCommon ( uniforms, material ) {
	
			uniforms.opacity.value = material.opacity;
	
			if ( _this.gammaInput ) {
	
				uniforms.diffuse.value.copyGammaToLinear( material.color );
	
			} else {
	
				uniforms.diffuse.value = material.color;
	
			}
	
			uniforms.map.value = material.map;
			uniforms.lightMap.value = material.lightMap;
			uniforms.specularMap.value = material.specularMap;
	
			if ( material.bumpMap ) {
	
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
	
			}
	
			if ( material.normalMap ) {
	
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
	
			}
	
			// uv repeat and offset setting priorities
			//	1. color map
			//	2. specular map
			//	3. normal map
			//	4. bump map
	
			var uvScaleMap;
	
			if ( material.map ) {
	
				uvScaleMap = material.map;
	
			} else if ( material.specularMap ) {
	
				uvScaleMap = material.specularMap;
	
			} else if ( material.normalMap ) {
	
				uvScaleMap = material.normalMap;
	
			} else if ( material.bumpMap ) {
	
				uvScaleMap = material.bumpMap;
	
			}
	
			if ( uvScaleMap !== undefined ) {
	
				var offset = uvScaleMap.offset;
				var repeat = uvScaleMap.repeat;
	
				uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );
	
			}
	
			uniforms.envMap.value = material.envMap;
			uniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : -1;
	
			if ( _this.gammaInput ) {
	
				//uniforms.reflectivity.value = material.reflectivity * material.reflectivity;
				uniforms.reflectivity.value = material.reflectivity;
	
			} else {
	
				uniforms.reflectivity.value = material.reflectivity;
	
			}
	
			uniforms.refractionRatio.value = material.refractionRatio;
			uniforms.combine.value = material.combine;
			uniforms.useRefract.value = material.envMap && material.envMap.mapping instanceof THREE.CubeRefractionMapping;
	
		};
	
		function refreshUniformsLine ( uniforms, material ) {
	
			uniforms.diffuse.value = material.color;
			uniforms.opacity.value = material.opacity;
	
		};
	
		function refreshUniformsDash ( uniforms, material ) {
	
			uniforms.dashSize.value = material.dashSize;
			uniforms.totalSize.value = material.dashSize + material.gapSize;
			uniforms.scale.value = material.scale;
	
		};
	
		function refreshUniformsParticle ( uniforms, material ) {
	
			uniforms.psColor.value = material.color;
			uniforms.opacity.value = material.opacity;
			uniforms.size.value = material.size;
			uniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.
	
			uniforms.map.value = material.map;
	
		};
	
		function refreshUniformsFog ( uniforms, fog ) {
	
			uniforms.fogColor.value = fog.color;
	
			if ( fog instanceof THREE.Fog ) {
	
				uniforms.fogNear.value = fog.near;
				uniforms.fogFar.value = fog.far;
	
			} else if ( fog instanceof THREE.FogExp2 ) {
	
				uniforms.fogDensity.value = fog.density;
	
			}
	
		};
	
		function refreshUniformsPhong ( uniforms, material ) {
	
			uniforms.shininess.value = material.shininess;
	
			if ( _this.gammaInput ) {
	
				uniforms.ambient.value.copyGammaToLinear( material.ambient );
				uniforms.emissive.value.copyGammaToLinear( material.emissive );
				uniforms.specular.value.copyGammaToLinear( material.specular );
	
			} else {
	
				uniforms.ambient.value = material.ambient;
				uniforms.emissive.value = material.emissive;
				uniforms.specular.value = material.specular;
	
			}
	
			if ( material.wrapAround ) {
	
				uniforms.wrapRGB.value.copy( material.wrapRGB );
	
			}
	
		};
	
		function refreshUniformsLambert ( uniforms, material ) {
	
			if ( _this.gammaInput ) {
	
				uniforms.ambient.value.copyGammaToLinear( material.ambient );
				uniforms.emissive.value.copyGammaToLinear( material.emissive );
	
			} else {
	
				uniforms.ambient.value = material.ambient;
				uniforms.emissive.value = material.emissive;
	
			}
	
			if ( material.wrapAround ) {
	
				uniforms.wrapRGB.value.copy( material.wrapRGB );
	
			}
	
		};
	
		function refreshUniformsLights ( uniforms, lights ) {
	
			uniforms.ambientLightColor.value = lights.ambient;
	
			uniforms.directionalLightColor.value = lights.directional.colors;
			uniforms.directionalLightDirection.value = lights.directional.positions;
	
			uniforms.pointLightColor.value = lights.point.colors;
			uniforms.pointLightPosition.value = lights.point.positions;
			uniforms.pointLightDistance.value = lights.point.distances;
	
			uniforms.spotLightColor.value = lights.spot.colors;
			uniforms.spotLightPosition.value = lights.spot.positions;
			uniforms.spotLightDistance.value = lights.spot.distances;
			uniforms.spotLightDirection.value = lights.spot.directions;
			uniforms.spotLightAngleCos.value = lights.spot.anglesCos;
			uniforms.spotLightExponent.value = lights.spot.exponents;
	
			uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;
			uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;
			uniforms.hemisphereLightDirection.value = lights.hemi.positions;
	
		};
	
		function refreshUniformsShadow ( uniforms, lights ) {
	
			if ( uniforms.shadowMatrix ) {
	
				var j = 0;
	
				for ( var i = 0, il = lights.length; i < il; i ++ ) {
	
					var light = lights[ i ];
	
					if ( ! light.castShadow ) continue;
	
					if ( light instanceof THREE.SpotLight || ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) ) {
	
						uniforms.shadowMap.value[ j ] = light.shadowMap;
						uniforms.shadowMapSize.value[ j ] = light.shadowMapSize;
	
						uniforms.shadowMatrix.value[ j ] = light.shadowMatrix;
	
						uniforms.shadowDarkness.value[ j ] = light.shadowDarkness;
						uniforms.shadowBias.value[ j ] = light.shadowBias;
	
						j ++;
	
					}
	
				}
	
			}
	
		};
	
		// Uniforms (load to GPU)
	
		function loadUniformsMatrices ( uniforms, object ) {
	
			_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object._modelViewMatrix.elements );
	
			if ( uniforms.normalMatrix ) {
	
				_gl.uniformMatrix3fv( uniforms.normalMatrix, false, object._normalMatrix.elements );
	
			}
	
		};
	
		function getTextureUnit() {
	
			var textureUnit = _usedTextureUnits;
	
			if ( textureUnit >= _maxTextures ) {
	
				console.warn( "WebGLRenderer: trying to use " + textureUnit + " texture units while this GPU supports only " + _maxTextures );
	
			}
	
			_usedTextureUnits += 1;
	
			return textureUnit;
	
		};
	
		function loadUniformsGeneric ( program, uniforms ) {
	
			var uniform, value, type, location, texture, textureUnit, i, il, j, jl, offset;
	
			for ( j = 0, jl = uniforms.length; j < jl; j ++ ) {
	
				location = program.uniforms[ uniforms[ j ][ 1 ] ];
				if ( !location ) continue;
	
				uniform = uniforms[ j ][ 0 ];
	
				type = uniform.type;
				value = uniform.value;
	
				if ( type === "i" ) { // single integer
	
					_gl.uniform1i( location, value );
	
				} else if ( type === "f" ) { // single float
	
					_gl.uniform1f( location, value );
	
				} else if ( type === "v2" ) { // single THREE.Vector2
	
					_gl.uniform2f( location, value.x, value.y );
	
				} else if ( type === "v3" ) { // single THREE.Vector3
	
					_gl.uniform3f( location, value.x, value.y, value.z );
	
				} else if ( type === "v4" ) { // single THREE.Vector4
	
					_gl.uniform4f( location, value.x, value.y, value.z, value.w );
	
				} else if ( type === "c" ) { // single THREE.Color
	
					_gl.uniform3f( location, value.r, value.g, value.b );
	
				} else if ( type === "iv1" ) { // flat array of integers (JS or typed array)
	
					_gl.uniform1iv( location, value );
	
				} else if ( type === "iv" ) { // flat array of integers with 3 x N size (JS or typed array)
	
					_gl.uniform3iv( location, value );
	
				} else if ( type === "fv1" ) { // flat array of floats (JS or typed array)
	
					_gl.uniform1fv( location, value );
	
				} else if ( type === "fv" ) { // flat array of floats with 3 x N size (JS or typed array)
	
					_gl.uniform3fv( location, value );
	
				} else if ( type === "v2v" ) { // array of THREE.Vector2
	
					if ( uniform._array === undefined ) {
	
						uniform._array = new Float32Array( 2 * value.length );
	
					}
	
					for ( i = 0, il = value.length; i < il; i ++ ) {
	
						offset = i * 2;
	
						uniform._array[ offset ] 	 = value[ i ].x;
						uniform._array[ offset + 1 ] = value[ i ].y;
	
					}
	
					_gl.uniform2fv( location, uniform._array );
	
				} else if ( type === "v3v" ) { // array of THREE.Vector3
	
					if ( uniform._array === undefined ) {
	
						uniform._array = new Float32Array( 3 * value.length );
	
					}
	
					for ( i = 0, il = value.length; i < il; i ++ ) {
	
						offset = i * 3;
	
						uniform._array[ offset ] 	 = value[ i ].x;
						uniform._array[ offset + 1 ] = value[ i ].y;
						uniform._array[ offset + 2 ] = value[ i ].z;
	
					}
	
					_gl.uniform3fv( location, uniform._array );
	
				} else if ( type === "v4v" ) { // array of THREE.Vector4
	
					if ( uniform._array === undefined ) {
	
						uniform._array = new Float32Array( 4 * value.length );
	
					}
	
					for ( i = 0, il = value.length; i < il; i ++ ) {
	
						offset = i * 4;
	
						uniform._array[ offset ] 	 = value[ i ].x;
						uniform._array[ offset + 1 ] = value[ i ].y;
						uniform._array[ offset + 2 ] = value[ i ].z;
						uniform._array[ offset + 3 ] = value[ i ].w;
	
					}
	
					_gl.uniform4fv( location, uniform._array );
	
				} else if ( type === "m4") { // single THREE.Matrix4
	
					if ( uniform._array === undefined ) {
	
						uniform._array = new Float32Array( 16 );
	
					}
	
					value.flattenToArray( uniform._array );
					_gl.uniformMatrix4fv( location, false, uniform._array );
	
				} else if ( type === "m4v" ) { // array of THREE.Matrix4
	
					if ( uniform._array === undefined ) {
	
						uniform._array = new Float32Array( 16 * value.length );
	
					}
	
					for ( i = 0, il = value.length; i < il; i ++ ) {
	
						value[ i ].flattenToArrayOffset( uniform._array, i * 16 );
	
					}
	
					_gl.uniformMatrix4fv( location, false, uniform._array );
	
				} else if ( type === "t" ) { // single THREE.Texture (2d or cube)
	
					texture = value;
					textureUnit = getTextureUnit();
	
					_gl.uniform1i( location, textureUnit );
	
					if ( !texture ) continue;
	
					if ( texture.image instanceof Array && texture.image.length === 6 ) {
	
						setCubeTexture( texture, textureUnit );
	
					} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {
	
						setCubeTextureDynamic( texture, textureUnit );
	
					} else {
	
						_this.setTexture( texture, textureUnit );
	
					}
	
				} else if ( type === "tv" ) { // array of THREE.Texture (2d)
	
					if ( uniform._array === undefined ) {
	
						uniform._array = [];
	
					}
	
					for( i = 0, il = uniform.value.length; i < il; i ++ ) {
	
						uniform._array[ i ] = getTextureUnit();
	
					}
	
					_gl.uniform1iv( location, uniform._array );
	
					for( i = 0, il = uniform.value.length; i < il; i ++ ) {
	
						texture = uniform.value[ i ];
						textureUnit = uniform._array[ i ];
	
						if ( !texture ) continue;
	
						_this.setTexture( texture, textureUnit );
	
					}
	
				}
	
			}
	
		};
	
		function setupMatrices ( object, camera ) {
	
			object._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
	
			object._normalMatrix.getInverse( object._modelViewMatrix );
			object._normalMatrix.transpose();
	
		};
	
		//
	
		function setColorGamma( array, offset, color, intensitySq ) {
	
			array[ offset ]     = color.r * color.r * intensitySq;
			array[ offset + 1 ] = color.g * color.g * intensitySq;
			array[ offset + 2 ] = color.b * color.b * intensitySq;
	
		};
	
		function setColorLinear( array, offset, color, intensity ) {
	
			array[ offset ]     = color.r * intensity;
			array[ offset + 1 ] = color.g * intensity;
			array[ offset + 2 ] = color.b * intensity;
	
		};
	
		function setupLights ( program, lights ) {
	
			var l, ll, light, n,
			r = 0, g = 0, b = 0,
			color, skyColor, groundColor,
			intensity,  intensitySq,
			position,
			distance,
	
			zlights = _lights,
	
			dirColors = zlights.directional.colors,
			dirPositions = zlights.directional.positions,
	
			pointColors = zlights.point.colors,
			pointPositions = zlights.point.positions,
			pointDistances = zlights.point.distances,
	
			spotColors = zlights.spot.colors,
			spotPositions = zlights.spot.positions,
			spotDistances = zlights.spot.distances,
			spotDirections = zlights.spot.directions,
			spotAnglesCos = zlights.spot.anglesCos,
			spotExponents = zlights.spot.exponents,
	
			hemiSkyColors = zlights.hemi.skyColors,
			hemiGroundColors = zlights.hemi.groundColors,
			hemiPositions = zlights.hemi.positions,
	
			dirLength = 0,
			pointLength = 0,
			spotLength = 0,
			hemiLength = 0,
	
			dirCount = 0,
			pointCount = 0,
			spotCount = 0,
			hemiCount = 0,
	
			dirOffset = 0,
			pointOffset = 0,
			spotOffset = 0,
			hemiOffset = 0;
	
			for ( l = 0, ll = lights.length; l < ll; l ++ ) {
	
				light = lights[ l ];
	
				if ( light.onlyShadow ) continue;
	
				color = light.color;
				intensity = light.intensity;
				distance = light.distance;
	
				if ( light instanceof THREE.AmbientLight ) {
	
					if ( ! light.visible ) continue;
	
					if ( _this.gammaInput ) {
	
						r += color.r * color.r;
						g += color.g * color.g;
						b += color.b * color.b;
	
					} else {
	
						r += color.r;
						g += color.g;
						b += color.b;
	
					}
	
				} else if ( light instanceof THREE.DirectionalLight ) {
	
					dirCount += 1;
	
					if ( ! light.visible ) continue;
	
					_direction.getPositionFromMatrix( light.matrixWorld );
					_vector3.getPositionFromMatrix( light.target.matrixWorld );
					_direction.sub( _vector3 );
					_direction.normalize();
	
					// skip lights with undefined direction
					// these create troubles in OpenGL (making pixel black)
	
					if ( _direction.x === 0 && _direction.y === 0 && _direction.z === 0 ) continue;
	
					dirOffset = dirLength * 3;
	
					dirPositions[ dirOffset ]     = _direction.x;
					dirPositions[ dirOffset + 1 ] = _direction.y;
					dirPositions[ dirOffset + 2 ] = _direction.z;
	
					if ( _this.gammaInput ) {
	
						setColorGamma( dirColors, dirOffset, color, intensity * intensity );
	
					} else {
	
						setColorLinear( dirColors, dirOffset, color, intensity );
	
					}
	
					dirLength += 1;
	
				} else if ( light instanceof THREE.PointLight ) {
	
					pointCount += 1;
	
					if ( ! light.visible ) continue;
	
					pointOffset = pointLength * 3;
	
					if ( _this.gammaInput ) {
	
						setColorGamma( pointColors, pointOffset, color, intensity * intensity );
	
					} else {
	
						setColorLinear( pointColors, pointOffset, color, intensity );
	
					}
	
					_vector3.getPositionFromMatrix( light.matrixWorld );
	
					pointPositions[ pointOffset ]     = _vector3.x;
					pointPositions[ pointOffset + 1 ] = _vector3.y;
					pointPositions[ pointOffset + 2 ] = _vector3.z;
	
					pointDistances[ pointLength ] = distance;
	
					pointLength += 1;
	
				} else if ( light instanceof THREE.SpotLight ) {
	
					spotCount += 1;
	
					if ( ! light.visible ) continue;
	
					spotOffset = spotLength * 3;
	
					if ( _this.gammaInput ) {
	
						setColorGamma( spotColors, spotOffset, color, intensity * intensity );
	
					} else {
	
						setColorLinear( spotColors, spotOffset, color, intensity );
	
					}
	
					_vector3.getPositionFromMatrix( light.matrixWorld );
	
					spotPositions[ spotOffset ]     = _vector3.x;
					spotPositions[ spotOffset + 1 ] = _vector3.y;
					spotPositions[ spotOffset + 2 ] = _vector3.z;
	
					spotDistances[ spotLength ] = distance;
	
					_direction.copy( _vector3 );
					_vector3.getPositionFromMatrix( light.target.matrixWorld );
					_direction.sub( _vector3 );
					_direction.normalize();
	
					spotDirections[ spotOffset ]     = _direction.x;
					spotDirections[ spotOffset + 1 ] = _direction.y;
					spotDirections[ spotOffset + 2 ] = _direction.z;
	
					spotAnglesCos[ spotLength ] = Math.cos( light.angle );
					spotExponents[ spotLength ] = light.exponent;
	
					spotLength += 1;
	
				} else if ( light instanceof THREE.HemisphereLight ) {
	
					hemiCount += 1;
	
					if ( ! light.visible ) continue;
	
					_direction.getPositionFromMatrix( light.matrixWorld );
					_direction.normalize();
	
					// skip lights with undefined direction
					// these create troubles in OpenGL (making pixel black)
	
					if ( _direction.x === 0 && _direction.y === 0 && _direction.z === 0 ) continue;
	
					hemiOffset = hemiLength * 3;
	
					hemiPositions[ hemiOffset ]     = _direction.x;
					hemiPositions[ hemiOffset + 1 ] = _direction.y;
					hemiPositions[ hemiOffset + 2 ] = _direction.z;
	
					skyColor = light.color;
					groundColor = light.groundColor;
	
					if ( _this.gammaInput ) {
	
						intensitySq = intensity * intensity;
	
						setColorGamma( hemiSkyColors, hemiOffset, skyColor, intensitySq );
						setColorGamma( hemiGroundColors, hemiOffset, groundColor, intensitySq );
	
					} else {
	
						setColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );
						setColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );
	
					}
	
					hemiLength += 1;
	
				}
	
			}
	
			// null eventual remains from removed lights
			// (this is to avoid if in shader)
	
			for ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l ++ ) dirColors[ l ] = 0.0;
			for ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l ++ ) pointColors[ l ] = 0.0;
			for ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l ++ ) spotColors[ l ] = 0.0;
			for ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;
			for ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;
	
			zlights.directional.length = dirLength;
			zlights.point.length = pointLength;
			zlights.spot.length = spotLength;
			zlights.hemi.length = hemiLength;
	
			zlights.ambient[ 0 ] = r;
			zlights.ambient[ 1 ] = g;
			zlights.ambient[ 2 ] = b;
	
		};
	
		// GL state setting
	
		this.setFaceCulling = function ( cullFace, frontFaceDirection ) {
	
			if ( cullFace === THREE.CullFaceNone ) {
	
				_gl.disable( _gl.CULL_FACE );
	
			} else {
	
				if ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {
	
					_gl.frontFace( _gl.CW );
	
				} else {
	
					_gl.frontFace( _gl.CCW );
	
				}
	
				if ( cullFace === THREE.CullFaceBack ) {
	
					_gl.cullFace( _gl.BACK );
	
				} else if ( cullFace === THREE.CullFaceFront ) {
	
					_gl.cullFace( _gl.FRONT );
	
				} else {
	
					_gl.cullFace( _gl.FRONT_AND_BACK );
	
				}
	
				_gl.enable( _gl.CULL_FACE );
	
			}
	
		};
	
		this.setMaterialFaces = function ( material ) {
	
			var doubleSided = material.side === THREE.DoubleSide;
			var flipSided = material.side === THREE.BackSide;
	
			if ( _oldDoubleSided !== doubleSided ) {
	
				if ( doubleSided ) {
	
					_gl.disable( _gl.CULL_FACE );
	
				} else {
	
					_gl.enable( _gl.CULL_FACE );
	
				}
	
				_oldDoubleSided = doubleSided;
	
			}
	
			if ( _oldFlipSided !== flipSided ) {
	
				if ( flipSided ) {
	
					_gl.frontFace( _gl.CW );
	
				} else {
	
					_gl.frontFace( _gl.CCW );
	
				}
	
				_oldFlipSided = flipSided;
	
			}
	
		};
	
		this.setDepthTest = function ( depthTest ) {
	
			if ( _oldDepthTest !== depthTest ) {
	
				if ( depthTest ) {
	
					_gl.enable( _gl.DEPTH_TEST );
	
				} else {
	
					_gl.disable( _gl.DEPTH_TEST );
	
				}
	
				_oldDepthTest = depthTest;
	
			}
	
		};
	
		this.setDepthWrite = function ( depthWrite ) {
	
			if ( _oldDepthWrite !== depthWrite ) {
	
				_gl.depthMask( depthWrite );
				_oldDepthWrite = depthWrite;
	
			}
	
		};
	
		function setLineWidth ( width ) {
	
			if ( width !== _oldLineWidth ) {
	
				_gl.lineWidth( width );
	
				_oldLineWidth = width;
	
			}
	
		};
	
		function setPolygonOffset ( polygonoffset, factor, units ) {
	
			if ( _oldPolygonOffset !== polygonoffset ) {
	
				if ( polygonoffset ) {
	
					_gl.enable( _gl.POLYGON_OFFSET_FILL );
	
				} else {
	
					_gl.disable( _gl.POLYGON_OFFSET_FILL );
	
				}
	
				_oldPolygonOffset = polygonoffset;
	
			}
	
			if ( polygonoffset && ( _oldPolygonOffsetFactor !== factor || _oldPolygonOffsetUnits !== units ) ) {
	
				_gl.polygonOffset( factor, units );
	
				_oldPolygonOffsetFactor = factor;
				_oldPolygonOffsetUnits = units;
	
			}
	
		};
	
		this.setBlending = function ( blending, blendEquation, blendSrc, blendDst ) {
	
			if ( blending !== _oldBlending ) {
	
				if ( blending === THREE.NoBlending ) {
	
					_gl.disable( _gl.BLEND );
	
				} else if ( blending === THREE.AdditiveBlending ) {
	
					_gl.enable( _gl.BLEND );
					_gl.blendEquation( _gl.FUNC_ADD );
					_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE );
	
				} else if ( blending === THREE.SubtractiveBlending ) {
	
					// TODO: Find blendFuncSeparate() combination
					_gl.enable( _gl.BLEND );
					_gl.blendEquation( _gl.FUNC_ADD );
					_gl.blendFunc( _gl.ZERO, _gl.ONE_MINUS_SRC_COLOR );
	
				} else if ( blending === THREE.MultiplyBlending ) {
	
					// TODO: Find blendFuncSeparate() combination
					_gl.enable( _gl.BLEND );
					_gl.blendEquation( _gl.FUNC_ADD );
					_gl.blendFunc( _gl.ZERO, _gl.SRC_COLOR );
	
				} else if ( blending === THREE.CustomBlending ) {
	
					_gl.enable( _gl.BLEND );
	
				} else {
	
					_gl.enable( _gl.BLEND );
					_gl.blendEquationSeparate( _gl.FUNC_ADD, _gl.FUNC_ADD );
					_gl.blendFuncSeparate( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA, _gl.ONE, _gl.ONE_MINUS_SRC_ALPHA );
	
				}
	
				_oldBlending = blending;
	
			}
	
			if ( blending === THREE.CustomBlending ) {
	
				if ( blendEquation !== _oldBlendEquation ) {
	
					_gl.blendEquation( paramThreeToGL( blendEquation ) );
	
					_oldBlendEquation = blendEquation;
	
				}
	
				if ( blendSrc !== _oldBlendSrc || blendDst !== _oldBlendDst ) {
	
					_gl.blendFunc( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ) );
	
					_oldBlendSrc = blendSrc;
					_oldBlendDst = blendDst;
	
				}
	
			} else {
	
				_oldBlendEquation = null;
				_oldBlendSrc = null;
				_oldBlendDst = null;
	
			}
	
		};
	
		// Defines
	
		function generateDefines ( defines ) {
	
			var value, chunk, chunks = [];
	
			for ( var d in defines ) {
	
				value = defines[ d ];
				if ( value === false ) continue;
	
				chunk = "#define " + d + " " + value;
				chunks.push( chunk );
	
			}
	
			return chunks.join( "\n" );
	
		};
	
		// Shaders
	
		function buildProgram ( shaderID, fragmentShader, vertexShader, uniforms, attributes, defines, parameters ) {
	
			var p, pl, d, program, code;
			var chunks = [];
	
			// Generate code
	
			if ( shaderID ) {
	
				chunks.push( shaderID );
	
			} else {
	
				chunks.push( fragmentShader );
				chunks.push( vertexShader );
	
			}
	
			for ( d in defines ) {
	
				chunks.push( d );
				chunks.push( defines[ d ] );
	
			}
	
			for ( p in parameters ) {
	
				chunks.push( p );
				chunks.push( parameters[ p ] );
	
			}
	
			code = chunks.join();
	
			// Check if code has been already compiled
	
			for ( p = 0, pl = _programs.length; p < pl; p ++ ) {
	
				var programInfo = _programs[ p ];
	
				if ( programInfo.code === code ) {
	
					//console.log( "Code already compiled." /*: \n\n" + code*/ );
	
					programInfo.usedTimes ++;
	
					return programInfo.program;
	
				}
	
			}
	
			var shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
	
			if ( parameters.shadowMapType === THREE.PCFShadowMap ) {
	
				shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
	
			} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {
	
				shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
	
			}
	
			//console.log( "building new program " );
	
			//
	
			var customDefines = generateDefines( defines );
	
			//
	
			program = _gl.createProgram();
	
			var prefix_vertex = [
	
				"precision " + _precision + " float;",
	
				customDefines,
	
				_supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
	
				_this.gammaInput ? "#define GAMMA_INPUT" : "",
				_this.gammaOutput ? "#define GAMMA_OUTPUT" : "",
				_this.physicallyBasedShading ? "#define PHYSICALLY_BASED_SHADING" : "",
	
				"#define MAX_DIR_LIGHTS " + parameters.maxDirLights,
				"#define MAX_POINT_LIGHTS " + parameters.maxPointLights,
				"#define MAX_SPOT_LIGHTS " + parameters.maxSpotLights,
				"#define MAX_HEMI_LIGHTS " + parameters.maxHemiLights,
	
				"#define MAX_SHADOWS " + parameters.maxShadows,
	
				"#define MAX_BONES " + parameters.maxBones,
	
				parameters.map ? "#define USE_MAP" : "",
				parameters.envMap ? "#define USE_ENVMAP" : "",
				parameters.lightMap ? "#define USE_LIGHTMAP" : "",
				parameters.bumpMap ? "#define USE_BUMPMAP" : "",
				parameters.normalMap ? "#define USE_NORMALMAP" : "",
				parameters.specularMap ? "#define USE_SPECULARMAP" : "",
				parameters.vertexColors ? "#define USE_COLOR" : "",
	
				parameters.skinning ? "#define USE_SKINNING" : "",
				parameters.useVertexTexture ? "#define BONE_TEXTURE" : "",
				parameters.boneTextureWidth ? "#define N_BONE_PIXEL_X " + parameters.boneTextureWidth.toFixed( 1 ) : "",
				parameters.boneTextureHeight ? "#define N_BONE_PIXEL_Y " + parameters.boneTextureHeight.toFixed( 1 ) : "",
	
				parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
				parameters.morphNormals ? "#define USE_MORPHNORMALS" : "",
				parameters.perPixel ? "#define PHONG_PER_PIXEL" : "",
				parameters.wrapAround ? "#define WRAP_AROUND" : "",
				parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
				parameters.flipSided ? "#define FLIP_SIDED" : "",
	
				parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
				parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
				parameters.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "",
				parameters.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "",
	
				parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
	
				"uniform mat4 modelMatrix;",
				"uniform mat4 modelViewMatrix;",
				"uniform mat4 projectionMatrix;",
				"uniform mat4 viewMatrix;",
				"uniform mat3 normalMatrix;",
				"uniform vec3 cameraPosition;",
	
				"attribute vec3 position;",
				"attribute vec3 normal;",
				"attribute vec2 uv;",
				"attribute vec2 uv2;",
	
				"#ifdef USE_COLOR",
	
					"attribute vec3 color;",
	
				"#endif",
	
				"#ifdef USE_MORPHTARGETS",
	
					"attribute vec3 morphTarget0;",
					"attribute vec3 morphTarget1;",
					"attribute vec3 morphTarget2;",
					"attribute vec3 morphTarget3;",
	
					"#ifdef USE_MORPHNORMALS",
	
						"attribute vec3 morphNormal0;",
						"attribute vec3 morphNormal1;",
						"attribute vec3 morphNormal2;",
						"attribute vec3 morphNormal3;",
	
					"#else",
	
						"attribute vec3 morphTarget4;",
						"attribute vec3 morphTarget5;",
						"attribute vec3 morphTarget6;",
						"attribute vec3 morphTarget7;",
	
					"#endif",
	
				"#endif",
	
				"#ifdef USE_SKINNING",
	
					"attribute vec4 skinIndex;",
					"attribute vec4 skinWeight;",
	
				"#endif",
	
				""
	
			].join("\n");
	
			var prefix_fragment = [
	
				"precision " + _precision + " float;",
	
				( parameters.bumpMap || parameters.normalMap ) ? "#extension GL_OES_standard_derivatives : enable" : "",
	
				customDefines,
	
				"#define MAX_DIR_LIGHTS " + parameters.maxDirLights,
				"#define MAX_POINT_LIGHTS " + parameters.maxPointLights,
				"#define MAX_SPOT_LIGHTS " + parameters.maxSpotLights,
				"#define MAX_HEMI_LIGHTS " + parameters.maxHemiLights,
	
				"#define MAX_SHADOWS " + parameters.maxShadows,
	
				parameters.alphaTest ? "#define ALPHATEST " + parameters.alphaTest: "",
	
				_this.gammaInput ? "#define GAMMA_INPUT" : "",
				_this.gammaOutput ? "#define GAMMA_OUTPUT" : "",
				_this.physicallyBasedShading ? "#define PHYSICALLY_BASED_SHADING" : "",
	
				( parameters.useFog && parameters.fog ) ? "#define USE_FOG" : "",
				( parameters.useFog && parameters.fogExp ) ? "#define FOG_EXP2" : "",
	
				parameters.map ? "#define USE_MAP" : "",
				parameters.envMap ? "#define USE_ENVMAP" : "",
				parameters.lightMap ? "#define USE_LIGHTMAP" : "",
				parameters.bumpMap ? "#define USE_BUMPMAP" : "",
				parameters.normalMap ? "#define USE_NORMALMAP" : "",
				parameters.specularMap ? "#define USE_SPECULARMAP" : "",
				parameters.vertexColors ? "#define USE_COLOR" : "",
	
				parameters.metal ? "#define METAL" : "",
				parameters.perPixel ? "#define PHONG_PER_PIXEL" : "",
				parameters.wrapAround ? "#define WRAP_AROUND" : "",
				parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
				parameters.flipSided ? "#define FLIP_SIDED" : "",
	
				parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
				parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
				parameters.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "",
				parameters.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "",
	
				"uniform mat4 viewMatrix;",
				"uniform vec3 cameraPosition;",
				""
	
			].join("\n");
	
			var glFragmentShader = getShader( "fragment", prefix_fragment + fragmentShader );
			var glVertexShader = getShader( "vertex", prefix_vertex + vertexShader );
	
			_gl.attachShader( program, glVertexShader );
			_gl.attachShader( program, glFragmentShader );
	
			_gl.linkProgram( program );
	
			if ( !_gl.getProgramParameter( program, _gl.LINK_STATUS ) ) {
	
				console.error( "Could not initialise shader\n" + "VALIDATE_STATUS: " + _gl.getProgramParameter( program, _gl.VALIDATE_STATUS ) + ", gl error [" + _gl.getError() + "]" );
	
			}
	
			// clean up
	
			_gl.deleteShader( glFragmentShader );
			_gl.deleteShader( glVertexShader );
	
			//console.log( prefix_fragment + fragmentShader );
			//console.log( prefix_vertex + vertexShader );
	
			program.uniforms = {};
			program.attributes = {};
	
			var identifiers, u, a, i;
	
			// cache uniform locations
	
			identifiers = [
	
				'viewMatrix', 'modelViewMatrix', 'projectionMatrix', 'normalMatrix', 'modelMatrix', 'cameraPosition',
				'morphTargetInfluences'
	
			];
	
			if ( parameters.useVertexTexture ) {
	
				identifiers.push( 'boneTexture' );
	
			} else {
	
				identifiers.push( 'boneGlobalMatrices' );
	
			}
	
			for ( u in uniforms ) {
	
				identifiers.push( u );
	
			}
	
			cacheUniformLocations( program, identifiers );
	
			// cache attributes locations
	
			identifiers = [
	
				"position", "normal", "uv", "uv2", "tangent", "color",
				"skinIndex", "skinWeight", "lineDistance"
	
			];
	
			for ( i = 0; i < parameters.maxMorphTargets; i ++ ) {
	
				identifiers.push( "morphTarget" + i );
	
			}
	
			for ( i = 0; i < parameters.maxMorphNormals; i ++ ) {
	
				identifiers.push( "morphNormal" + i );
	
			}
	
			for ( a in attributes ) {
	
				identifiers.push( a );
	
			}
	
			cacheAttributeLocations( program, identifiers );
	
			program.id = _programs_counter ++;
	
			_programs.push( { program: program, code: code, usedTimes: 1 } );
	
			_this.info.memory.programs = _programs.length;
	
			return program;
	
		};
	
		// Shader parameters cache
	
		function cacheUniformLocations ( program, identifiers ) {
	
			var i, l, id;
	
			for( i = 0, l = identifiers.length; i < l; i ++ ) {
	
				id = identifiers[ i ];
				program.uniforms[ id ] = _gl.getUniformLocation( program, id );
	
			}
	
		};
	
		function cacheAttributeLocations ( program, identifiers ) {
	
			var i, l, id;
	
			for( i = 0, l = identifiers.length; i < l; i ++ ) {
	
				id = identifiers[ i ];
				program.attributes[ id ] = _gl.getAttribLocation( program, id );
	
			}
	
		};
	
		function addLineNumbers ( string ) {
	
			var chunks = string.split( "\n" );
	
			for ( var i = 0, il = chunks.length; i < il; i ++ ) {
	
				// Chrome reports shader errors on lines
				// starting counting from 1
	
				chunks[ i ] = ( i + 1 ) + ": " + chunks[ i ];
	
			}
	
			return chunks.join( "\n" );
	
		};
	
		function getShader ( type, string ) {
	
			var shader;
	
			if ( type === "fragment" ) {
	
				shader = _gl.createShader( _gl.FRAGMENT_SHADER );
	
			} else if ( type === "vertex" ) {
	
				shader = _gl.createShader( _gl.VERTEX_SHADER );
	
			}
	
			_gl.shaderSource( shader, string );
			_gl.compileShader( shader );
	
			if ( !_gl.getShaderParameter( shader, _gl.COMPILE_STATUS ) ) {
	
				console.error( _gl.getShaderInfoLog( shader ) );
				console.error( addLineNumbers( string ) );
				return null;
	
			}
	
			return shader;
	
		};
	
		// Textures
	
	
		function isPowerOfTwo ( value ) {
	
			return ( value & ( value - 1 ) ) === 0;
	
		};
	
		function setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {
	
			if ( isImagePowerOfTwo ) {
	
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );
	
				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );
	
			} else {
	
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );
	
				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );
	
			}
	
			if ( _glExtensionTextureFilterAnisotropic && texture.type !== THREE.FloatType ) {
	
				if ( texture.anisotropy > 1 || texture.__oldAnisotropy ) {
	
					_gl.texParameterf( textureType, _glExtensionTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _maxAnisotropy ) );
					texture.__oldAnisotropy = texture.anisotropy;
	
				}
	
			}
	
		};
	
		this.setTexture = function ( texture, slot ) {
	
			if ( texture.needsUpdate ) {
	
				if ( ! texture.__webglInit ) {
	
					texture.__webglInit = true;
	
					texture.addEventListener( 'dispose', onTextureDispose );
	
					texture.__webglTexture = _gl.createTexture();
	
					_this.info.memory.textures ++;
	
				}
	
				_gl.activeTexture( _gl.TEXTURE0 + slot );
				_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );
	
				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
				_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
				_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );
	
				var image = texture.image,
				isImagePowerOfTwo = isPowerOfTwo( image.width ) && isPowerOfTwo( image.height ),
				glFormat = paramThreeToGL( texture.format ),
				glType = paramThreeToGL( texture.type );
	
				setTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );
	
				var mipmap, mipmaps = texture.mipmaps;
	
				if ( texture instanceof THREE.DataTexture ) {
	
					// use manually created mipmaps if available
					// if there are no manual mipmaps
					// set 0 level mipmap and then use GL to generate other mipmap levels
	
					if ( mipmaps.length > 0 && isImagePowerOfTwo ) {
	
						for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {
	
							mipmap = mipmaps[ i ];
							_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
	
						}
	
						texture.generateMipmaps = false;
	
					} else {
	
						_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );
	
					}
	
				} else if ( texture instanceof THREE.CompressedTexture ) {
	
					// compressed textures can only use manually created mipmaps
					// WebGL can't generate mipmaps for DDS textures
	
					for( var i = 0, il = mipmaps.length; i < il; i ++ ) {
	
						mipmap = mipmaps[ i ];
						_gl.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );
	
					}
	
				} else { // regular Texture (image, video, canvas)
	
					// use manually created mipmaps if available
					// if there are no manual mipmaps
					// set 0 level mipmap and then use GL to generate other mipmap levels
	
					if ( mipmaps.length > 0 && isImagePowerOfTwo ) {
	
						for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {
	
							mipmap = mipmaps[ i ];
							_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );
	
						}
	
						texture.generateMipmaps = false;
	
					} else {
	
						_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );
	
					}
	
				}
	
				if ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );
	
				texture.needsUpdate = false;
	
				if ( texture.onUpdate ) texture.onUpdate();
	
			} else {
	
				_gl.activeTexture( _gl.TEXTURE0 + slot );
				_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );
	
			}
	
		};
	
		function clampToMaxSize ( image, maxSize ) {
	
			if ( image.width <= maxSize && image.height <= maxSize ) {
	
				return image;
	
			}
	
			// Warning: Scaling through the canvas will only work with images that use
			// premultiplied alpha.
	
			var maxDimension = Math.max( image.width, image.height );
			var newWidth = Math.floor( image.width * maxSize / maxDimension );
			var newHeight = Math.floor( image.height * maxSize / maxDimension );
	
			var canvas = document.createElement( 'canvas' );
			canvas.width = newWidth;
			canvas.height = newHeight;
	
			var ctx = canvas.getContext( "2d" );
			ctx.drawImage( image, 0, 0, image.width, image.height, 0, 0, newWidth, newHeight );
	
			return canvas;
	
		}
	
		function setCubeTexture ( texture, slot ) {
	
			if ( texture.image.length === 6 ) {
	
				if ( texture.needsUpdate ) {
	
					if ( ! texture.image.__webglTextureCube ) {
	
						texture.image.__webglTextureCube = _gl.createTexture();
	
						_this.info.memory.textures ++;
	
					}
	
					_gl.activeTexture( _gl.TEXTURE0 + slot );
					_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );
	
					_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
	
					var isCompressed = texture instanceof THREE.CompressedTexture;
	
					var cubeImage = [];
	
					for ( var i = 0; i < 6; i ++ ) {
	
						if ( _this.autoScaleCubemaps && ! isCompressed ) {
	
							cubeImage[ i ] = clampToMaxSize( texture.image[ i ], _maxCubemapSize );
	
						} else {
	
							cubeImage[ i ] = texture.image[ i ];
	
						}
	
					}
	
					var image = cubeImage[ 0 ],
					isImagePowerOfTwo = isPowerOfTwo( image.width ) && isPowerOfTwo( image.height ),
					glFormat = paramThreeToGL( texture.format ),
					glType = paramThreeToGL( texture.type );
	
					setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );
	
					for ( var i = 0; i < 6; i ++ ) {
	
						if ( isCompressed ) {
	
							var mipmap, mipmaps = cubeImage[ i ].mipmaps;
	
							for( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {
	
								mipmap = mipmaps[ j ];
								_gl.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );
	
							}
	
						} else {
	
							_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );
	
						}
	
					}
	
					if ( texture.generateMipmaps && isImagePowerOfTwo ) {
	
						_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
	
					}
	
					texture.needsUpdate = false;
	
					if ( texture.onUpdate ) texture.onUpdate();
	
				} else {
	
					_gl.activeTexture( _gl.TEXTURE0 + slot );
					_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );
	
				}
	
			}
	
		};
	
		function setCubeTextureDynamic ( texture, slot ) {
	
			_gl.activeTexture( _gl.TEXTURE0 + slot );
			_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.__webglTexture );
	
		};
	
		// Render targets
	
		function setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {
	
			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, renderTarget.__webglTexture, 0 );
	
		};
	
		function setupRenderBuffer ( renderbuffer, renderTarget  ) {
	
			_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );
	
			if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {
	
				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
	
			/* For some reason this is not working. Defaulting to RGBA4.
			} else if( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {
	
				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
			*/
			} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {
	
				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
	
			} else {
	
				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );
	
			}
	
		};
	
		this.setRenderTarget = function ( renderTarget ) {
	
			var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );
	
			if ( renderTarget && ! renderTarget.__webglFramebuffer ) {
	
				if ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;
				if ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;
	
				renderTarget.addEventListener( 'dispose', onRenderTargetDispose );
	
				renderTarget.__webglTexture = _gl.createTexture();
	
				_this.info.memory.textures ++;
	
				// Setup texture, create render and frame buffers
	
				var isTargetPowerOfTwo = isPowerOfTwo( renderTarget.width ) && isPowerOfTwo( renderTarget.height ),
					glFormat = paramThreeToGL( renderTarget.format ),
					glType = paramThreeToGL( renderTarget.type );
	
				if ( isCube ) {
	
					renderTarget.__webglFramebuffer = [];
					renderTarget.__webglRenderbuffer = [];
	
					_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );
					setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo );
	
					for ( var i = 0; i < 6; i ++ ) {
	
						renderTarget.__webglFramebuffer[ i ] = _gl.createFramebuffer();
						renderTarget.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();
	
						_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
	
						setupFrameBuffer( renderTarget.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );
						setupRenderBuffer( renderTarget.__webglRenderbuffer[ i ], renderTarget );
	
					}
	
					if ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
	
				} else {
	
					renderTarget.__webglFramebuffer = _gl.createFramebuffer();
	
					if ( renderTarget.shareDepthFrom ) {
	
						renderTarget.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;
	
					} else {
	
						renderTarget.__webglRenderbuffer = _gl.createRenderbuffer();
	
					}
	
					_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );
					setTextureParameters( _gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo );
	
					_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
	
					setupFrameBuffer( renderTarget.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );
	
					if ( renderTarget.shareDepthFrom ) {
	
						if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {
	
							_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );
	
						} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {
	
							_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );
	
						}
	
					} else {
	
						setupRenderBuffer( renderTarget.__webglRenderbuffer, renderTarget );
	
					}
	
					if ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );
	
				}
	
				// Release everything
	
				if ( isCube ) {
	
					_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );
	
				} else {
	
					_gl.bindTexture( _gl.TEXTURE_2D, null );
	
				}
	
				_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
				_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );
	
			}
	
			var framebuffer, width, height, vx, vy;
	
			if ( renderTarget ) {
	
				if ( isCube ) {
	
					framebuffer = renderTarget.__webglFramebuffer[ renderTarget.activeCubeFace ];
	
				} else {
	
					framebuffer = renderTarget.__webglFramebuffer;
	
				}
	
				width = renderTarget.width;
				height = renderTarget.height;
	
				vx = 0;
				vy = 0;
	
			} else {
	
				framebuffer = null;
	
				width = _viewportWidth;
				height = _viewportHeight;
	
				vx = _viewportX;
				vy = _viewportY;
	
			}
	
			if ( framebuffer !== _currentFramebuffer ) {
	
				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
				_gl.viewport( vx, vy, width, height );
	
				_currentFramebuffer = framebuffer;
	
			}
	
			_currentWidth = width;
			_currentHeight = height;
	
		};
	
		function updateRenderTargetMipmap ( renderTarget ) {
	
			if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {
	
				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );
				_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );
	
			} else {
	
				_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );
				_gl.generateMipmap( _gl.TEXTURE_2D );
				_gl.bindTexture( _gl.TEXTURE_2D, null );
	
			}
	
		};
	
		// Fallback filters for non-power-of-2 textures
	
		function filterFallback ( f ) {
	
			if ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {
	
				return _gl.NEAREST;
	
			}
	
			return _gl.LINEAR;
	
		};
	
		// Map three.js constants to WebGL constants
	
		function paramThreeToGL ( p ) {
	
			if ( p === THREE.RepeatWrapping ) return _gl.REPEAT;
			if ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
			if ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;
	
			if ( p === THREE.NearestFilter ) return _gl.NEAREST;
			if ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
			if ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;
	
			if ( p === THREE.LinearFilter ) return _gl.LINEAR;
			if ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
			if ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;
	
			if ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;
			if ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
			if ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
			if ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;
	
			if ( p === THREE.ByteType ) return _gl.BYTE;
			if ( p === THREE.ShortType ) return _gl.SHORT;
			if ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;
			if ( p === THREE.IntType ) return _gl.INT;
			if ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;
			if ( p === THREE.FloatType ) return _gl.FLOAT;
	
			if ( p === THREE.AlphaFormat ) return _gl.ALPHA;
			if ( p === THREE.RGBFormat ) return _gl.RGB;
			if ( p === THREE.RGBAFormat ) return _gl.RGBA;
			if ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;
			if ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;
	
			if ( p === THREE.AddEquation ) return _gl.FUNC_ADD;
			if ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;
			if ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;
	
			if ( p === THREE.ZeroFactor ) return _gl.ZERO;
			if ( p === THREE.OneFactor ) return _gl.ONE;
			if ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;
			if ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
			if ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;
			if ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
			if ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;
			if ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;
	
			if ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;
			if ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
			if ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;
	
			if ( _glExtensionCompressedTextureS3TC !== undefined ) {
	
				if ( p === THREE.RGB_S3TC_DXT1_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGB_S3TC_DXT1_EXT;
				if ( p === THREE.RGBA_S3TC_DXT1_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT1_EXT;
				if ( p === THREE.RGBA_S3TC_DXT3_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT;
				if ( p === THREE.RGBA_S3TC_DXT5_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT;
	
			}
	
			return 0;
	
		};
	
		// Allocations
	
		function allocateBones ( object ) {
	
			if ( _supportsBoneTextures && object && object.useVertexTexture ) {
	
				return 1024;
	
			} else {
	
				// default for when object is not specified
				// ( for example when prebuilding shader
				//   to be used with multiple objects )
				//
				// 	- leave some extra space for other uniforms
				//  - limit here is ANGLE's 254 max uniform vectors
				//    (up to 54 should be safe)
	
				var nVertexUniforms = _gl.getParameter( _gl.MAX_VERTEX_UNIFORM_VECTORS );
				var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );
	
				var maxBones = nVertexMatrices;
	
				if ( object !== undefined && object instanceof THREE.SkinnedMesh ) {
	
					maxBones = Math.min( object.bones.length, maxBones );
	
					if ( maxBones < object.bones.length ) {
	
						console.warn( "WebGLRenderer: too many bones - " + object.bones.length + ", this GPU supports just " + maxBones + " (try OpenGL instead of ANGLE)" );
	
					}
	
				}
	
				return maxBones;
	
			}
	
		};
	
		function allocateLights ( lights ) {
	
			var l, ll, light, dirLights, pointLights, spotLights, hemiLights;
	
			dirLights = pointLights = spotLights = hemiLights = 0;
	
			for ( l = 0, ll = lights.length; l < ll; l ++ ) {
	
				light = lights[ l ];
	
				if ( light.onlyShadow ) continue;
	
				if ( light instanceof THREE.DirectionalLight ) dirLights ++;
				if ( light instanceof THREE.PointLight ) pointLights ++;
				if ( light instanceof THREE.SpotLight ) spotLights ++;
				if ( light instanceof THREE.HemisphereLight ) hemiLights ++;
	
			}
	
			return { 'directional' : dirLights, 'point' : pointLights, 'spot': spotLights, 'hemi': hemiLights };
	
		};
	
		function allocateShadows ( lights ) {
	
			var l, ll, light, maxShadows = 0;
	
			for ( l = 0, ll = lights.length; l < ll; l++ ) {
	
				light = lights[ l ];
	
				if ( ! light.castShadow ) continue;
	
				if ( light instanceof THREE.SpotLight ) maxShadows ++;
				if ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) maxShadows ++;
	
			}
	
			return maxShadows;
	
		};
	
		// Initialization
	
		function initGL () {
	
			try {
	
				if ( ! ( _gl = _canvas.getContext( 'experimental-webgl', { alpha: _alpha, premultipliedAlpha: _premultipliedAlpha, antialias: _antialias, stencil: _stencil, preserveDrawingBuffer: _preserveDrawingBuffer } ) ) ) {
	
					throw 'Error creating WebGL context.';
	
				}
	
			} catch ( error ) {
	
				console.error( error );
	
			}
	
			_glExtensionTextureFloat = _gl.getExtension( 'OES_texture_float' );
			_glExtensionStandardDerivatives = _gl.getExtension( 'OES_standard_derivatives' );
	
			_glExtensionTextureFilterAnisotropic = _gl.getExtension( 'EXT_texture_filter_anisotropic' ) ||
												   _gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) ||
												   _gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
	
	
			_glExtensionCompressedTextureS3TC = _gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) ||
												_gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) ||
												_gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
	
			if ( ! _glExtensionTextureFloat ) {
	
				console.log( 'THREE.WebGLRenderer: Float textures not supported.' );
	
			}
	
			if ( ! _glExtensionStandardDerivatives ) {
	
				console.log( 'THREE.WebGLRenderer: Standard derivatives not supported.' );
	
			}
	
			if ( ! _glExtensionTextureFilterAnisotropic ) {
	
				console.log( 'THREE.WebGLRenderer: Anisotropic texture filtering not supported.' );
	
			}
	
			if ( ! _glExtensionCompressedTextureS3TC ) {
	
				console.log( 'THREE.WebGLRenderer: S3TC compressed textures not supported.' );
	
			}
			
			if ( _gl.getShaderPrecisionFormat === undefined ) {
				
				_gl.getShaderPrecisionFormat = function() { 
					
					return {
						"rangeMin"  : 1,
						"rangeMax"  : 1,
						"precision" : 1
					};
					
				}
			}
	
		};
	
		function setDefaultGLState () {
	
			_gl.clearColor( 0, 0, 0, 1 );
			_gl.clearDepth( 1 );
			_gl.clearStencil( 0 );
	
			_gl.enable( _gl.DEPTH_TEST );
			_gl.depthFunc( _gl.LEQUAL );
	
			_gl.frontFace( _gl.CCW );
			_gl.cullFace( _gl.BACK );
			_gl.enable( _gl.CULL_FACE );
	
			_gl.enable( _gl.BLEND );
			_gl.blendEquation( _gl.FUNC_ADD );
			_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA );
	
			_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );
	
		};
	
		// default plugins (order is important)
	
		this.shadowMapPlugin = new THREE.ShadowMapPlugin();
		this.addPrePlugin( this.shadowMapPlugin );
	
		this.addPostPlugin( new THREE.SpritePlugin() );
		this.addPostPlugin( new THREE.LensFlarePlugin() );
	
	};
	/**
	 * @author szimek / https://github.com/szimek/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.WebGLRenderTarget = function ( width, height, options ) {
	
		THREE.EventDispatcher.call( this );
	
		this.width = width;
		this.height = height;
	
		options = options || {};
	
		this.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;
		this.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;
	
		this.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;
		this.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;
	
		this.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;
	
		this.offset = new THREE.Vector2( 0, 0 );
		this.repeat = new THREE.Vector2( 1, 1 );
	
		this.format = options.format !== undefined ? options.format : THREE.RGBAFormat;
		this.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;
	
		this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
		this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
	
		this.generateMipmaps = true;
	
		this.shareDepthFrom = null;
	
	};
	
	THREE.WebGLRenderTarget.prototype.clone = function() {
	
		var tmp = new THREE.WebGLRenderTarget( this.width, this.height );
	
		tmp.wrapS = this.wrapS;
		tmp.wrapT = this.wrapT;
	
		tmp.magFilter = this.magFilter;
		tmp.minFilter = this.minFilter;
	
		tmp.anisotropy = this.anisotropy;
	
		tmp.offset.copy( this.offset );
		tmp.repeat.copy( this.repeat );
	
		tmp.format = this.format;
		tmp.type = this.type;
	
		tmp.depthBuffer = this.depthBuffer;
		tmp.stencilBuffer = this.stencilBuffer;
	
		tmp.generateMipmaps = this.generateMipmaps;
	
		tmp.shareDepthFrom = this.shareDepthFrom;
	
		return tmp;
	
	};
	
	THREE.WebGLRenderTarget.prototype.dispose = function () {
	
		this.dispatchEvent( { type: 'dispose' } );
	
	};
	/**
	 * @author alteredq / http://alteredqualia.com
	 */
	
	THREE.WebGLRenderTargetCube = function ( width, height, options ) {
	
		THREE.WebGLRenderTarget.call( this, width, height, options );
	
		this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
	
	};
	
	THREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.RenderableVertex = function () {
	
		this.positionWorld = new THREE.Vector3();
		this.positionScreen = new THREE.Vector4();
	
		this.visible = true;
	
	};
	
	THREE.RenderableVertex.prototype.copy = function ( vertex ) {
	
		this.positionWorld.copy( vertex.positionWorld );
		this.positionScreen.copy( vertex.positionScreen );
	
	};
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.RenderableFace3 = function () {
	
		this.v1 = new THREE.RenderableVertex();
		this.v2 = new THREE.RenderableVertex();
		this.v3 = new THREE.RenderableVertex();
	
		this.centroidModel = new THREE.Vector3();
	
		this.normalModel = new THREE.Vector3();
		this.normalModelView = new THREE.Vector3();
	
		this.vertexNormalsLength = 0;
		this.vertexNormalsModel = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];
		this.vertexNormalsModelView = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];
	
		this.color = null;
		this.material = null;
		this.uvs = [[]];
	
		this.z = null;
	
	};
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.RenderableFace4 = function () {
	
		this.v1 = new THREE.RenderableVertex();
		this.v2 = new THREE.RenderableVertex();
		this.v3 = new THREE.RenderableVertex();
		this.v4 = new THREE.RenderableVertex();
	
		this.centroidModel = new THREE.Vector3();
	
		this.normalModel = new THREE.Vector3();
		this.normalModelView = new THREE.Vector3();
	
		this.vertexNormalsLength = 0;
		this.vertexNormalsModel = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];
		this.vertexNormalsModelView = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];
	
		this.color = null;
		this.material = null;
		this.uvs = [[]];
	
		this.z = null;
	
	};
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.RenderableObject = function () {
	
		this.object = null;
		this.z = null;
	
	};
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.RenderableParticle = function () {
	
		this.object = null;
	
		this.x = null;
		this.y = null;
		this.z = null;
	
		this.rotation = null;
		this.scale = new THREE.Vector2();
	
		this.material = null;
	
	};
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.RenderableLine = function () {
	
		this.z = null;
	
		this.v1 = new THREE.RenderableVertex();
		this.v2 = new THREE.RenderableVertex();
	
		this.material = null;
	
	};
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.GeometryUtils = {
	
		// Merge two geometries or geometry and geometry from object (using object's transform)
	
		merge: function ( geometry1, object2 /* mesh | geometry */ ) {
	
			var matrix, normalMatrix,
			vertexOffset = geometry1.vertices.length,
			uvPosition = geometry1.faceVertexUvs[ 0 ].length,
			geometry2 = object2 instanceof THREE.Mesh ? object2.geometry : object2,
			vertices1 = geometry1.vertices,
			vertices2 = geometry2.vertices,
			faces1 = geometry1.faces,
			faces2 = geometry2.faces,
			uvs1 = geometry1.faceVertexUvs[ 0 ],
			uvs2 = geometry2.faceVertexUvs[ 0 ];
	
			if ( object2 instanceof THREE.Mesh ) {
	
				object2.matrixAutoUpdate && object2.updateMatrix();
	
				matrix = object2.matrix;
	
				normalMatrix = new THREE.Matrix3();
				normalMatrix.getInverse( matrix );
				normalMatrix.transpose();
	
			}
	
			// vertices
	
			for ( var i = 0, il = vertices2.length; i < il; i ++ ) {
	
				var vertex = vertices2[ i ];
	
				var vertexCopy = vertex.clone();
	
				if ( matrix ) vertexCopy.applyMatrix4( matrix );
	
				vertices1.push( vertexCopy );
	
			}
	
			// faces
	
			for ( i = 0, il = faces2.length; i < il; i ++ ) {
	
				var face = faces2[ i ], faceCopy, normal, color,
				faceVertexNormals = face.vertexNormals,
				faceVertexColors = face.vertexColors;
	
				if ( face instanceof THREE.Face3 ) {
	
					faceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
	
				} else if ( face instanceof THREE.Face4 ) {
	
					faceCopy = new THREE.Face4( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset, face.d + vertexOffset );
	
				}
	
				faceCopy.normal.copy( face.normal );
	
				if ( normalMatrix ) {
	
					faceCopy.normal.applyMatrix3( normalMatrix ).normalize();
	
				}
	
				for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {
	
					normal = faceVertexNormals[ j ].clone();
	
					if ( normalMatrix ) {
	
						normal.applyMatrix3( normalMatrix ).normalize();
	
					}
	
					faceCopy.vertexNormals.push( normal );
	
				}
	
				faceCopy.color.copy( face.color );
	
				for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {
	
					color = faceVertexColors[ j ];
					faceCopy.vertexColors.push( color.clone() );
	
				}
	
				faceCopy.materialIndex = face.materialIndex;
	
				faceCopy.centroid.copy( face.centroid );
	
				if ( matrix ) {
	
					faceCopy.centroid.applyMatrix4( matrix );
	
				}
	
				faces1.push( faceCopy );
	
			}
	
			// uvs
	
			for ( i = 0, il = uvs2.length; i < il; i ++ ) {
	
				var uv = uvs2[ i ], uvCopy = [];
	
				for ( var j = 0, jl = uv.length; j < jl; j ++ ) {
	
					uvCopy.push( new THREE.Vector2( uv[ j ].x, uv[ j ].y ) );
	
				}
	
				uvs1.push( uvCopy );
	
			}
	
		},
	
		removeMaterials: function ( geometry, materialIndexArray ) {
	
			var materialIndexMap = {};
	
			for ( var i = 0, il = materialIndexArray.length; i < il; i ++ ) {
	
				materialIndexMap[ materialIndexArray[i] ] = true;
	
			}
	
			var face, newFaces = [];
	
			for ( var i = 0, il = geometry.faces.length; i < il; i ++ ) {
	
				face = geometry.faces[ i ];
				if ( ! ( face.materialIndex in materialIndexMap ) ) newFaces.push( face );
	
			}
	
			geometry.faces = newFaces;
	
		},
	
		// Get random point in triangle (via barycentric coordinates)
		// 	(uniform distribution)
		// 	http://www.cgafaq.info/wiki/Random_Point_In_Triangle
	
		randomPointInTriangle: function ( vectorA, vectorB, vectorC ) {
	
			var a, b, c,
				point = new THREE.Vector3(),
				tmp = THREE.GeometryUtils.__v1;
	
			a = THREE.GeometryUtils.random();
			b = THREE.GeometryUtils.random();
	
			if ( ( a + b ) > 1 ) {
	
				a = 1 - a;
				b = 1 - b;
	
			}
	
			c = 1 - a - b;
	
			point.copy( vectorA );
			point.multiplyScalar( a );
	
			tmp.copy( vectorB );
			tmp.multiplyScalar( b );
	
			point.add( tmp );
	
			tmp.copy( vectorC );
			tmp.multiplyScalar( c );
	
			point.add( tmp );
	
			return point;
	
		},
	
		// Get random point in face (triangle / quad)
		// (uniform distribution)
	
		randomPointInFace: function ( face, geometry, useCachedAreas ) {
	
			var vA, vB, vC, vD;
	
			if ( face instanceof THREE.Face3 ) {
	
				vA = geometry.vertices[ face.a ];
				vB = geometry.vertices[ face.b ];
				vC = geometry.vertices[ face.c ];
	
				return THREE.GeometryUtils.randomPointInTriangle( vA, vB, vC );
	
			} else if ( face instanceof THREE.Face4 ) {
	
				vA = geometry.vertices[ face.a ];
				vB = geometry.vertices[ face.b ];
				vC = geometry.vertices[ face.c ];
				vD = geometry.vertices[ face.d ];
	
				var area1, area2;
	
				if ( useCachedAreas ) {
	
					if ( face._area1 && face._area2 ) {
	
						area1 = face._area1;
						area2 = face._area2;
	
					} else {
	
						area1 = THREE.GeometryUtils.triangleArea( vA, vB, vD );
						area2 = THREE.GeometryUtils.triangleArea( vB, vC, vD );
	
						face._area1 = area1;
						face._area2 = area2;
	
					}
	
				} else {
	
					area1 = THREE.GeometryUtils.triangleArea( vA, vB, vD ),
					area2 = THREE.GeometryUtils.triangleArea( vB, vC, vD );
	
				}
	
				var r = THREE.GeometryUtils.random() * ( area1 + area2 );
	
				if ( r < area1 ) {
	
					return THREE.GeometryUtils.randomPointInTriangle( vA, vB, vD );
	
				} else {
	
					return THREE.GeometryUtils.randomPointInTriangle( vB, vC, vD );
	
				}
	
			}
	
		},
	
		// Get uniformly distributed random points in mesh
		// 	- create array with cumulative sums of face areas
		//  - pick random number from 0 to total area
		//  - find corresponding place in area array by binary search
		//	- get random point in face
	
		randomPointsInGeometry: function ( geometry, n ) {
	
			var face, i,
				faces = geometry.faces,
				vertices = geometry.vertices,
				il = faces.length,
				totalArea = 0,
				cumulativeAreas = [],
				vA, vB, vC, vD;
	
			// precompute face areas
	
			for ( i = 0; i < il; i ++ ) {
	
				face = faces[ i ];
	
				if ( face instanceof THREE.Face3 ) {
	
					vA = vertices[ face.a ];
					vB = vertices[ face.b ];
					vC = vertices[ face.c ];
	
					face._area = THREE.GeometryUtils.triangleArea( vA, vB, vC );
	
				} else if ( face instanceof THREE.Face4 ) {
	
					vA = vertices[ face.a ];
					vB = vertices[ face.b ];
					vC = vertices[ face.c ];
					vD = vertices[ face.d ];
	
					face._area1 = THREE.GeometryUtils.triangleArea( vA, vB, vD );
					face._area2 = THREE.GeometryUtils.triangleArea( vB, vC, vD );
	
					face._area = face._area1 + face._area2;
	
				}
	
				totalArea += face._area;
	
				cumulativeAreas[ i ] = totalArea;
	
			}
	
			// binary search cumulative areas array
	
			function binarySearchIndices( value ) {
	
				function binarySearch( start, end ) {
	
					// return closest larger index
					// if exact number is not found
	
					if ( end < start )
						return start;
	
					var mid = start + Math.floor( ( end - start ) / 2 );
	
					if ( cumulativeAreas[ mid ] > value ) {
	
						return binarySearch( start, mid - 1 );
	
					} else if ( cumulativeAreas[ mid ] < value ) {
	
						return binarySearch( mid + 1, end );
	
					} else {
	
						return mid;
	
					}
	
				}
	
				var result = binarySearch( 0, cumulativeAreas.length - 1 )
				return result;
	
			}
	
			// pick random face weighted by face area
	
			var r, index,
				result = [];
	
			var stats = {};
	
			for ( i = 0; i < n; i ++ ) {
	
				r = THREE.GeometryUtils.random() * totalArea;
	
				index = binarySearchIndices( r );
	
				result[ i ] = THREE.GeometryUtils.randomPointInFace( faces[ index ], geometry, true );
	
				if ( ! stats[ index ] ) {
	
					stats[ index ] = 1;
	
				} else {
	
					stats[ index ] += 1;
	
				}
	
			}
	
			return result;
	
		},
	
		// Get triangle area (half of parallelogram)
		//	http://mathworld.wolfram.com/TriangleArea.html
	
		triangleArea: function ( vectorA, vectorB, vectorC ) {
	
			var tmp1 = THREE.GeometryUtils.__v1,
				tmp2 = THREE.GeometryUtils.__v2;
	
			tmp1.subVectors( vectorB, vectorA );
			tmp2.subVectors( vectorC, vectorA );
			tmp1.cross( tmp2 );
	
			return 0.5 * tmp1.length();
	
		},
	
		// Center geometry so that 0,0,0 is in center of bounding box
	
		center: function ( geometry ) {
	
			geometry.computeBoundingBox();
	
			var bb = geometry.boundingBox;
	
			var offset = new THREE.Vector3();
	
			offset.addVectors( bb.min, bb.max );
			offset.multiplyScalar( -0.5 );
	
			geometry.applyMatrix( new THREE.Matrix4().makeTranslation( offset.x, offset.y, offset.z ) );
			geometry.computeBoundingBox();
	
			return offset;
	
		},
	
		// Normalize UVs to be from <0,1>
		// (for now just the first set of UVs)
	
		normalizeUVs: function ( geometry ) {
	
			var uvSet = geometry.faceVertexUvs[ 0 ];
	
			for ( var i = 0, il = uvSet.length; i < il; i ++ ) {
	
				var uvs = uvSet[ i ];
	
				for ( var j = 0, jl = uvs.length; j < jl; j ++ ) {
	
					// texture repeat
	
					if( uvs[ j ].x !== 1.0 ) uvs[ j ].x = uvs[ j ].x - Math.floor( uvs[ j ].x );
					if( uvs[ j ].y !== 1.0 ) uvs[ j ].y = uvs[ j ].y - Math.floor( uvs[ j ].y );
	
				}
	
			}
	
		},
	
		triangulateQuads: function ( geometry ) {
	
			var i, il, j, jl;
	
			var faces = [];
			var faceUvs = [];
			var faceVertexUvs = [];
	
			for ( i = 0, il = geometry.faceUvs.length; i < il; i ++ ) {
	
				faceUvs[ i ] = [];
	
			}
	
			for ( i = 0, il = geometry.faceVertexUvs.length; i < il; i ++ ) {
	
				faceVertexUvs[ i ] = [];
	
			}
	
			for ( i = 0, il = geometry.faces.length; i < il; i ++ ) {
	
				var face = geometry.faces[ i ];
	
				if ( face instanceof THREE.Face4 ) {
	
					var a = face.a;
					var b = face.b;
					var c = face.c;
					var d = face.d;
	
					var triA = new THREE.Face3();
					var triB = new THREE.Face3();
	
					triA.color.copy( face.color );
					triB.color.copy( face.color );
	
					triA.materialIndex = face.materialIndex;
					triB.materialIndex = face.materialIndex;
	
					triA.a = a;
					triA.b = b;
					triA.c = d;
	
					triB.a = b;
					triB.b = c;
					triB.c = d;
	
					if ( face.vertexColors.length === 4 ) {
	
						triA.vertexColors[ 0 ] = face.vertexColors[ 0 ].clone();
						triA.vertexColors[ 1 ] = face.vertexColors[ 1 ].clone();
						triA.vertexColors[ 2 ] = face.vertexColors[ 3 ].clone();
	
						triB.vertexColors[ 0 ] = face.vertexColors[ 1 ].clone();
						triB.vertexColors[ 1 ] = face.vertexColors[ 2 ].clone();
						triB.vertexColors[ 2 ] = face.vertexColors[ 3 ].clone();
	
					}
	
					faces.push( triA, triB );
	
					for ( j = 0, jl = geometry.faceVertexUvs.length; j < jl; j ++ ) {
	
						if ( geometry.faceVertexUvs[ j ].length ) {
	
							var uvs = geometry.faceVertexUvs[ j ][ i ];
	
							var uvA = uvs[ 0 ];
							var uvB = uvs[ 1 ];
							var uvC = uvs[ 2 ];
							var uvD = uvs[ 3 ];
	
							var uvsTriA = [ uvA.clone(), uvB.clone(), uvD.clone() ];
							var uvsTriB = [ uvB.clone(), uvC.clone(), uvD.clone() ];
	
							faceVertexUvs[ j ].push( uvsTriA, uvsTriB );
	
						}
	
					}
	
					for ( j = 0, jl = geometry.faceUvs.length; j < jl; j ++ ) {
	
						if ( geometry.faceUvs[ j ].length ) {
	
							var faceUv = geometry.faceUvs[ j ][ i ];
	
							faceUvs[ j ].push( faceUv, faceUv );
	
						}
	
					}
	
				} else {
	
					faces.push( face );
	
					for ( j = 0, jl = geometry.faceUvs.length; j < jl; j ++ ) {
	
						faceUvs[ j ].push( geometry.faceUvs[ j ][ i ] );
	
					}
	
					for ( j = 0, jl = geometry.faceVertexUvs.length; j < jl; j ++ ) {
	
						faceVertexUvs[ j ].push( geometry.faceVertexUvs[ j ][ i ] );
	
					}
	
				}
	
			}
	
			geometry.faces = faces;
			geometry.faceUvs = faceUvs;
			geometry.faceVertexUvs = faceVertexUvs;
	
			geometry.computeCentroids();
			geometry.computeFaceNormals();
			geometry.computeVertexNormals();
	
			if ( geometry.hasTangents ) geometry.computeTangents();
	
		},
	
		setMaterialIndex: function ( geometry, index, startFace, endFace ){
	
			var faces = geometry.faces;
			var start = startFace || 0;
			var end = endFace || faces.length - 1;
	
			for ( var i = start; i <= end; i ++ ) {
	
				faces[i].materialIndex = index;
	
			}
	
	    }
	
	};
	
	THREE.GeometryUtils.random = THREE.Math.random16;
	
	THREE.GeometryUtils.__v1 = new THREE.Vector3();
	THREE.GeometryUtils.__v2 = new THREE.Vector3();
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.ImageUtils = {
	
		crossOrigin: 'anonymous',
	
		loadTexture: function ( url, mapping, onLoad, onError ) {
	
			var image = new Image();
			var texture = new THREE.Texture( image, mapping );
	
			var loader = new THREE.ImageLoader();
	
			loader.addEventListener( 'load', function ( event ) {
	
				texture.image = event.content;
				texture.needsUpdate = true;
	
				if ( onLoad ) onLoad( texture );
	
			} );
	
			loader.addEventListener( 'error', function ( event ) {
	
				if ( onError ) onError( event.message );
	
			} );
	
			loader.crossOrigin = this.crossOrigin;
			loader.load( url, image );
	
			texture.sourceFile = url;
	
			return texture;
	
		},
	
		loadCompressedTexture: function ( url, mapping, onLoad, onError ) {
	
			var texture = new THREE.CompressedTexture();
			texture.mapping = mapping;
	
			var request = new XMLHttpRequest();
	
			request.onload = function () {
	
				var buffer = request.response;
				var dds = THREE.ImageUtils.parseDDS( buffer, true );
	
				texture.format = dds.format;
	
				texture.mipmaps = dds.mipmaps;
				texture.image.width = dds.width;
				texture.image.height = dds.height;
	
				// gl.generateMipmap fails for compressed textures
				// mipmaps must be embedded in the DDS file
				// or texture filters must not use mipmapping
	
				texture.generateMipmaps = false;
	
				texture.needsUpdate = true;
	
				if ( onLoad ) onLoad( texture );
	
			}
	
			request.onerror = onError;
	
			request.open( 'GET', url, true );
			request.responseType = "arraybuffer";
			request.send( null );
	
			return texture;
	
		},
	
		loadTextureCube: function ( array, mapping, onLoad, onError ) {
	
			var images = [];
			images.loadCount = 0;
	
			var texture = new THREE.Texture();
			texture.image = images;
			if ( mapping !== undefined ) texture.mapping = mapping;
	
			// no flipping needed for cube textures
	
			texture.flipY = false;
	
			for ( var i = 0, il = array.length; i < il; ++ i ) {
	
				var cubeImage = new Image();
				images[ i ] = cubeImage;
	
				cubeImage.onload = function () {
	
					images.loadCount += 1;
	
					if ( images.loadCount === 6 ) {
	
						texture.needsUpdate = true;
						if ( onLoad ) onLoad( texture );
	
					}
	
				};
	
				cubeImage.onerror = onError;
	
				cubeImage.crossOrigin = this.crossOrigin;
				cubeImage.src = array[ i ];
	
			}
	
			return texture;
	
		},
	
		loadCompressedTextureCube: function ( array, mapping, onLoad, onError ) {
	
			var images = [];
			images.loadCount = 0;
	
			var texture = new THREE.CompressedTexture();
			texture.image = images;
			if ( mapping !== undefined ) texture.mapping = mapping;
	
			// no flipping for cube textures
			// (also flipping doesn't work for compressed textures )
	
			texture.flipY = false;
	
			// can't generate mipmaps for compressed textures
			// mips must be embedded in DDS files
	
			texture.generateMipmaps = false;
	
			var generateCubeFaceCallback = function ( rq, img ) {
	
				return function () {
	
					var buffer = rq.response;
					var dds = THREE.ImageUtils.parseDDS( buffer, true );
	
					img.format = dds.format;
	
					img.mipmaps = dds.mipmaps;
					img.width = dds.width;
					img.height = dds.height;
	
					images.loadCount += 1;
	
					if ( images.loadCount === 6 ) {
	
						texture.format = dds.format;
						texture.needsUpdate = true;
						if ( onLoad ) onLoad( texture );
	
					}
	
				}
	
			}
	
			// compressed cubemap textures as 6 separate DDS files
	
			if ( array instanceof Array ) {
	
				for ( var i = 0, il = array.length; i < il; ++ i ) {
	
					var cubeImage = {};
					images[ i ] = cubeImage;
	
					var request = new XMLHttpRequest();
	
					request.onload = generateCubeFaceCallback( request, cubeImage );
					request.onerror = onError;
	
					var url = array[ i ];
	
					request.open( 'GET', url, true );
					request.responseType = "arraybuffer";
					request.send( null );
	
				}
	
			// compressed cubemap texture stored in a single DDS file
	
			} else {
	
				var url = array;
				var request = new XMLHttpRequest();
	
				request.onload = function( ) {
	
					var buffer = request.response;
					var dds = THREE.ImageUtils.parseDDS( buffer, true );
	
					if ( dds.isCubemap ) {
	
						var faces = dds.mipmaps.length / dds.mipmapCount;
	
						for ( var f = 0; f < faces; f ++ ) {
	
							images[ f ] = { mipmaps : [] };
	
							for ( var i = 0; i < dds.mipmapCount; i ++ ) {
	
								images[ f ].mipmaps.push( dds.mipmaps[ f * dds.mipmapCount + i ] );
								images[ f ].format = dds.format;
								images[ f ].width = dds.width;
								images[ f ].height = dds.height;
	
							}
	
						}
	
						texture.format = dds.format;
						texture.needsUpdate = true;
						if ( onLoad ) onLoad( texture );
	
					}
	
				}
	
				request.onerror = onError;
	
				request.open( 'GET', url, true );
				request.responseType = "arraybuffer";
				request.send( null );
	
			}
	
			return texture;
	
		},
	
		parseDDS: function ( buffer, loadMipmaps ) {
	
			var dds = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 };
	
			// Adapted from @toji's DDS utils
			//	https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js
	
			// All values and structures referenced from:
			// http://msdn.microsoft.com/en-us/library/bb943991.aspx/
	
			var DDS_MAGIC = 0x20534444;
	
			var DDSD_CAPS = 0x1,
				DDSD_HEIGHT = 0x2,
				DDSD_WIDTH = 0x4,
				DDSD_PITCH = 0x8,
				DDSD_PIXELFORMAT = 0x1000,
				DDSD_MIPMAPCOUNT = 0x20000,
				DDSD_LINEARSIZE = 0x80000,
				DDSD_DEPTH = 0x800000;
	
			var DDSCAPS_COMPLEX = 0x8,
				DDSCAPS_MIPMAP = 0x400000,
				DDSCAPS_TEXTURE = 0x1000;
	
			var DDSCAPS2_CUBEMAP = 0x200,
				DDSCAPS2_CUBEMAP_POSITIVEX = 0x400,
				DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,
				DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,
				DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,
				DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,
				DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,
				DDSCAPS2_VOLUME = 0x200000;
	
			var DDPF_ALPHAPIXELS = 0x1,
				DDPF_ALPHA = 0x2,
				DDPF_FOURCC = 0x4,
				DDPF_RGB = 0x40,
				DDPF_YUV = 0x200,
				DDPF_LUMINANCE = 0x20000;
	
			function fourCCToInt32( value ) {
	
				return value.charCodeAt(0) +
					(value.charCodeAt(1) << 8) +
					(value.charCodeAt(2) << 16) +
					(value.charCodeAt(3) << 24);
	
			}
	
			function int32ToFourCC( value ) {
	
				return String.fromCharCode(
					value & 0xff,
					(value >> 8) & 0xff,
					(value >> 16) & 0xff,
					(value >> 24) & 0xff
				);
			}
	
			var FOURCC_DXT1 = fourCCToInt32("DXT1");
			var FOURCC_DXT3 = fourCCToInt32("DXT3");
			var FOURCC_DXT5 = fourCCToInt32("DXT5");
	
			var headerLengthInt = 31; // The header length in 32 bit ints
	
			// Offsets into the header array
	
			var off_magic = 0;
	
			var off_size = 1;
			var off_flags = 2;
			var off_height = 3;
			var off_width = 4;
	
			var off_mipmapCount = 7;
	
			var off_pfFlags = 20;
			var off_pfFourCC = 21;
	
			var off_caps = 27;
			var off_caps2 = 28;
			var off_caps3 = 29;
			var off_caps4 = 30;
	
			// Parse header
	
			var header = new Int32Array( buffer, 0, headerLengthInt );
	
			if ( header[ off_magic ] !== DDS_MAGIC ) {
	
				console.error( "ImageUtils.parseDDS(): Invalid magic number in DDS header" );
				return dds;
	
			}
	
			if ( ! header[ off_pfFlags ] & DDPF_FOURCC ) {
	
				console.error( "ImageUtils.parseDDS(): Unsupported format, must contain a FourCC code" );
				return dds;
	
			}
	
			var blockBytes;
	
			var fourCC = header[ off_pfFourCC ];
	
			switch ( fourCC ) {
	
				case FOURCC_DXT1:
	
					blockBytes = 8;
					dds.format = THREE.RGB_S3TC_DXT1_Format;
					break;
	
				case FOURCC_DXT3:
	
					blockBytes = 16;
					dds.format = THREE.RGBA_S3TC_DXT3_Format;
					break;
	
				case FOURCC_DXT5:
	
					blockBytes = 16;
					dds.format = THREE.RGBA_S3TC_DXT5_Format;
					break;
	
				default:
	
					console.error( "ImageUtils.parseDDS(): Unsupported FourCC code: ", int32ToFourCC( fourCC ) );
					return dds;
	
			}
	
			dds.mipmapCount = 1;
	
			if ( header[ off_flags ] & DDSD_MIPMAPCOUNT && loadMipmaps !== false ) {
	
				dds.mipmapCount = Math.max( 1, header[ off_mipmapCount ] );
	
			}
	
			//TODO: Verify that all faces of the cubemap are present with DDSCAPS2_CUBEMAP_POSITIVEX, etc.
	
			dds.isCubemap = header[ off_caps2 ] & DDSCAPS2_CUBEMAP ? true : false;
	
			dds.width = header[ off_width ];
			dds.height = header[ off_height ];
	
			var dataOffset = header[ off_size ] + 4;
	
			// Extract mipmaps buffers
	
			var width = dds.width;
			var height = dds.height;
	
			var faces = dds.isCubemap ? 6 : 1;
	
			for ( var face = 0; face < faces; face ++ ) {
	
				for ( var i = 0; i < dds.mipmapCount; i ++ ) {
	
					var dataLength = Math.max( 4, width ) / 4 * Math.max( 4, height ) / 4 * blockBytes;
					var byteArray = new Uint8Array( buffer, dataOffset, dataLength );
	
					var mipmap = { "data": byteArray, "width": width, "height": height };
					dds.mipmaps.push( mipmap );
	
					dataOffset += dataLength;
	
					width = Math.max( width * 0.5, 1 );
					height = Math.max( height * 0.5, 1 );
	
				}
	
				width = dds.width;
				height = dds.height;
	
			}
	
			return dds;
	
		},
	
		getNormalMap: function ( image, depth ) {
	
			// Adapted from http://www.paulbrunt.co.uk/lab/heightnormal/
	
			var cross = function ( a, b ) {
	
				return [ a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ], a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ], a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ] ];
	
			}
	
			var subtract = function ( a, b ) {
	
				return [ a[ 0 ] - b[ 0 ], a[ 1 ] - b[ 1 ], a[ 2 ] - b[ 2 ] ];
	
			}
	
			var normalize = function ( a ) {
	
				var l = Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );
				return [ a[ 0 ] / l, a[ 1 ] / l, a[ 2 ] / l ];
	
			}
	
			depth = depth | 1;
	
			var width = image.width;
			var height = image.height;
	
			var canvas = document.createElement( 'canvas' );
			canvas.width = width;
			canvas.height = height;
	
			var context = canvas.getContext( '2d' );
			context.drawImage( image, 0, 0 );
	
			var data = context.getImageData( 0, 0, width, height ).data;
			var imageData = context.createImageData( width, height );
			var output = imageData.data;
	
			for ( var x = 0; x < width; x ++ ) {
	
				for ( var y = 0; y < height; y ++ ) {
	
					var ly = y - 1 < 0 ? 0 : y - 1;
					var uy = y + 1 > height - 1 ? height - 1 : y + 1;
					var lx = x - 1 < 0 ? 0 : x - 1;
					var ux = x + 1 > width - 1 ? width - 1 : x + 1;
	
					var points = [];
					var origin = [ 0, 0, data[ ( y * width + x ) * 4 ] / 255 * depth ];
					points.push( [ - 1, 0, data[ ( y * width + lx ) * 4 ] / 255 * depth ] );
					points.push( [ - 1, - 1, data[ ( ly * width + lx ) * 4 ] / 255 * depth ] );
					points.push( [ 0, - 1, data[ ( ly * width + x ) * 4 ] / 255 * depth ] );
					points.push( [  1, - 1, data[ ( ly * width + ux ) * 4 ] / 255 * depth ] );
					points.push( [ 1, 0, data[ ( y * width + ux ) * 4 ] / 255 * depth ] );
					points.push( [ 1, 1, data[ ( uy * width + ux ) * 4 ] / 255 * depth ] );
					points.push( [ 0, 1, data[ ( uy * width + x ) * 4 ] / 255 * depth ] );
					points.push( [ - 1, 1, data[ ( uy * width + lx ) * 4 ] / 255 * depth ] );
	
					var normals = [];
					var num_points = points.length;
	
					for ( var i = 0; i < num_points; i ++ ) {
	
						var v1 = points[ i ];
						var v2 = points[ ( i + 1 ) % num_points ];
						v1 = subtract( v1, origin );
						v2 = subtract( v2, origin );
						normals.push( normalize( cross( v1, v2 ) ) );
	
					}
	
					var normal = [ 0, 0, 0 ];
	
					for ( var i = 0; i < normals.length; i ++ ) {
	
						normal[ 0 ] += normals[ i ][ 0 ];
						normal[ 1 ] += normals[ i ][ 1 ];
						normal[ 2 ] += normals[ i ][ 2 ];
	
					}
	
					normal[ 0 ] /= normals.length;
					normal[ 1 ] /= normals.length;
					normal[ 2 ] /= normals.length;
	
					var idx = ( y * width + x ) * 4;
	
					output[ idx ] = ( ( normal[ 0 ] + 1.0 ) / 2.0 * 255 ) | 0;
					output[ idx + 1 ] = ( ( normal[ 1 ] + 1.0 ) / 2.0 * 255 ) | 0;
					output[ idx + 2 ] = ( normal[ 2 ] * 255 ) | 0;
					output[ idx + 3 ] = 255;
	
				}
	
			}
	
			context.putImageData( imageData, 0, 0 );
	
			return canvas;
	
		},
	
		generateDataTexture: function ( width, height, color ) {
	
			var size = width * height;
			var data = new Uint8Array( 3 * size );
	
			var r = Math.floor( color.r * 255 );
			var g = Math.floor( color.g * 255 );
			var b = Math.floor( color.b * 255 );
	
			for ( var i = 0; i < size; i ++ ) {
	
				data[ i * 3 ] 	  = r;
				data[ i * 3 + 1 ] = g;
				data[ i * 3 + 2 ] = b;
	
			}
	
			var texture = new THREE.DataTexture( data, width, height, THREE.RGBFormat );
			texture.needsUpdate = true;
	
			return texture;
	
		}
	
	};
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.SceneUtils = {
	
		createMultiMaterialObject: function ( geometry, materials ) {
	
			var group = new THREE.Object3D();
	
			for ( var i = 0, l = materials.length; i < l; i ++ ) {
	
				group.add( new THREE.Mesh( geometry, materials[ i ] ) );
	
			}
	
			return group;
	
		},
	
		detach : function ( child, parent, scene ) {
	
			child.applyMatrix( parent.matrixWorld );
			parent.remove( child );
			scene.add( child );
	
		},
	
		attach: function ( child, scene, parent ) {
	
			var matrixWorldInverse = new THREE.Matrix4();
			matrixWorldInverse.getInverse( parent.matrixWorld );
			child.applyMatrix( matrixWorldInverse );
	
			scene.remove( child );
			parent.add( child );
	
		}
	
	};
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * For Text operations in three.js (See TextGeometry)
	 *
	 * It uses techniques used in:
	 *
	 * 	typeface.js and canvastext
	 * 		For converting fonts and rendering with javascript
	 *		http://typeface.neocracy.org
	 *
	 *	Triangulation ported from AS3
	 *		Simple Polygon Triangulation
	 *		http://actionsnippet.com/?p=1462
	 *
	 * 	A Method to triangulate shapes with holes
	 *		http://www.sakri.net/blog/2009/06/12/an-approach-to-triangulating-polygons-with-holes/
	 *
	 */
	
	THREE.FontUtils = {
	
		faces : {},
	
		// Just for now. face[weight][style]
	
		face : "helvetiker",
		weight: "normal",
		style : "normal",
		size : 150,
		divisions : 10,
	
		getFace : function() {
	
			return this.faces[ this.face ][ this.weight ][ this.style ];
	
		},
	
		loadFace : function( data ) {
	
			var family = data.familyName.toLowerCase();
	
			var ThreeFont = this;
	
			ThreeFont.faces[ family ] = ThreeFont.faces[ family ] || {};
	
			ThreeFont.faces[ family ][ data.cssFontWeight ] = ThreeFont.faces[ family ][ data.cssFontWeight ] || {};
			ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;
	
			var face = ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;
	
			return data;
	
		},
	
		drawText : function( text ) {
	
			var characterPts = [], allPts = [];
	
			// RenderText
	
			var i, p,
				face = this.getFace(),
				scale = this.size / face.resolution,
				offset = 0,
				chars = String( text ).split( '' ),
				length = chars.length;
	
			var fontPaths = [];
	
			for ( i = 0; i < length; i ++ ) {
	
				var path = new THREE.Path();
	
				var ret = this.extractGlyphPoints( chars[ i ], face, scale, offset, path );
				offset += ret.offset;
	
				fontPaths.push( ret.path );
	
			}
	
			// get the width
	
			var width = offset / 2;
			//
			// for ( p = 0; p < allPts.length; p++ ) {
			//
			// 	allPts[ p ].x -= width;
			//
			// }
	
			//var extract = this.extractPoints( allPts, characterPts );
			//extract.contour = allPts;
	
			//extract.paths = fontPaths;
			//extract.offset = width;
	
			return { paths : fontPaths, offset : width };
	
		},
	
	
	
	
		extractGlyphPoints : function( c, face, scale, offset, path ) {
	
			var pts = [];
	
			var i, i2, divisions,
				outline, action, length,
				scaleX, scaleY,
				x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2,
				laste,
				glyph = face.glyphs[ c ] || face.glyphs[ '?' ];
	
			if ( !glyph ) return;
	
			if ( glyph.o ) {
	
				outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );
				length = outline.length;
	
				scaleX = scale;
				scaleY = scale;
	
				for ( i = 0; i < length; ) {
	
					action = outline[ i ++ ];
	
					//console.log( action );
	
					switch( action ) {
	
					case 'm':
	
						// Move To
	
						x = outline[ i++ ] * scaleX + offset;
						y = outline[ i++ ] * scaleY;
	
						path.moveTo( x, y );
						break;
	
					case 'l':
	
						// Line To
	
						x = outline[ i++ ] * scaleX + offset;
						y = outline[ i++ ] * scaleY;
						path.lineTo(x,y);
						break;
	
					case 'q':
	
						// QuadraticCurveTo
	
						cpx  = outline[ i++ ] * scaleX + offset;
						cpy  = outline[ i++ ] * scaleY;
						cpx1 = outline[ i++ ] * scaleX + offset;
						cpy1 = outline[ i++ ] * scaleY;
	
						path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
	
						laste = pts[ pts.length - 1 ];
	
						if ( laste ) {
	
							cpx0 = laste.x;
							cpy0 = laste.y;
	
							for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {
	
								var t = i2 / divisions;
								var tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
								var ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );
						  }
	
					  }
	
					  break;
	
					case 'b':
	
						// Cubic Bezier Curve
	
						cpx  = outline[ i++ ] *  scaleX + offset;
						cpy  = outline[ i++ ] *  scaleY;
						cpx1 = outline[ i++ ] *  scaleX + offset;
						cpy1 = outline[ i++ ] * -scaleY;
						cpx2 = outline[ i++ ] *  scaleX + offset;
						cpy2 = outline[ i++ ] * -scaleY;
	
						path.bezierCurveTo( cpx, cpy, cpx1, cpy1, cpx2, cpy2 );
	
						laste = pts[ pts.length - 1 ];
	
						if ( laste ) {
	
							cpx0 = laste.x;
							cpy0 = laste.y;
	
							for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {
	
								var t = i2 / divisions;
								var tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
								var ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );
	
							}
	
						}
	
						break;
	
					}
	
				}
			}
	
	
	
			return { offset: glyph.ha*scale, path:path};
		}
	
	};
	
	
	THREE.FontUtils.generateShapes = function( text, parameters ) {
	
		// Parameters 
	
		parameters = parameters || {};
	
		var size = parameters.size !== undefined ? parameters.size : 100;
		var curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments: 4;
	
		var font = parameters.font !== undefined ? parameters.font : "helvetiker";
		var weight = parameters.weight !== undefined ? parameters.weight : "normal";
		var style = parameters.style !== undefined ? parameters.style : "normal";
	
		THREE.FontUtils.size = size;
		THREE.FontUtils.divisions = curveSegments;
	
		THREE.FontUtils.face = font;
		THREE.FontUtils.weight = weight;
		THREE.FontUtils.style = style;
	
		// Get a Font data json object
	
		var data = THREE.FontUtils.drawText( text );
	
		var paths = data.paths;
		var shapes = [];
	
		for ( var p = 0, pl = paths.length; p < pl; p ++ ) {
	
			Array.prototype.push.apply( shapes, paths[ p ].toShapes() );
	
		}
	
		return shapes;
	
	};
	
	
	/**
	 * This code is a quick port of code written in C++ which was submitted to
	 * flipcode.com by John W. Ratcliff  // July 22, 2000
	 * See original code and more information here:
	 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
	 *
	 * ported to actionscript by Zevan Rosser
	 * www.actionsnippet.com
	 *
	 * ported to javascript by Joshua Koo
	 * http://www.lab4games.net/zz85/blog
	 *
	 */
	
	
	( function( namespace ) {
	
		var EPSILON = 0.0000000001;
	
		// takes in an contour array and returns
	
		var process = function( contour, indices ) {
	
			var n = contour.length;
	
			if ( n < 3 ) return null;
	
			var result = [],
				verts = [],
				vertIndices = [];
	
			/* we want a counter-clockwise polygon in verts */
	
			var u, v, w;
	
			if ( area( contour ) > 0.0 ) {
	
				for ( v = 0; v < n; v++ ) verts[ v ] = v;
	
			} else {
	
				for ( v = 0; v < n; v++ ) verts[ v ] = ( n - 1 ) - v;
	
			}
	
			var nv = n;
	
			/*  remove nv - 2 vertices, creating 1 triangle every time */
	
			var count = 2 * nv;   /* error detection */
	
			for( v = nv - 1; nv > 2; ) {
	
				/* if we loop, it is probably a non-simple polygon */
	
				if ( ( count-- ) <= 0 ) {
	
					//** Triangulate: ERROR - probable bad polygon!
	
					//throw ( "Warning, unable to triangulate polygon!" );
					//return null;
					// Sometimes warning is fine, especially polygons are triangulated in reverse.
					console.log( "Warning, unable to triangulate polygon!" );
	
					if ( indices ) return vertIndices;
					return result;
	
				}
	
				/* three consecutive vertices in current polygon, <u,v,w> */
	
				u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
				v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
				w = v + 1;  if ( nv <= w ) w = 0;     /* next     */
	
				if ( snip( contour, u, v, w, nv, verts ) ) {
	
					var a, b, c, s, t;
	
					/* true names of the vertices */
	
					a = verts[ u ];
					b = verts[ v ];
					c = verts[ w ];
	
					/* output Triangle */
	
					result.push( [ contour[ a ],
						contour[ b ],
						contour[ c ] ] );
	
	
					vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );
	
					/* remove v from the remaining polygon */
	
					for( s = v, t = v + 1; t < nv; s++, t++ ) {
	
						verts[ s ] = verts[ t ];
	
					}
	
					nv--;
	
					/* reset error detection counter */
	
					count = 2 * nv;
	
				}
	
			}
	
			if ( indices ) return vertIndices;
			return result;
	
		};
	
		// calculate area of the contour polygon
	
		var area = function ( contour ) {
	
			var n = contour.length;
			var a = 0.0;
	
			for( var p = n - 1, q = 0; q < n; p = q++ ) {
	
				a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;
	
			}
	
			return a * 0.5;
	
		};
	
		var snip = function ( contour, u, v, w, n, verts ) {
	
			var p;
			var ax, ay, bx, by;
			var cx, cy, px, py;
	
			ax = contour[ verts[ u ] ].x;
			ay = contour[ verts[ u ] ].y;
	
			bx = contour[ verts[ v ] ].x;
			by = contour[ verts[ v ] ].y;
	
			cx = contour[ verts[ w ] ].x;
			cy = contour[ verts[ w ] ].y;
	
			if ( EPSILON > (((bx-ax)*(cy-ay)) - ((by-ay)*(cx-ax))) ) return false;
	
			var aX, aY, bX, bY, cX, cY;
			var apx, apy, bpx, bpy, cpx, cpy;
			var cCROSSap, bCROSScp, aCROSSbp;
	
			aX = cx - bx;  aY = cy - by;
			bX = ax - cx;  bY = ay - cy;
			cX = bx - ax;  cY = by - ay;
	
			for ( p = 0; p < n; p++ ) {
	
				if( (p === u) || (p === v) || (p === w) ) continue;
	
				px = contour[ verts[ p ] ].x
				py = contour[ verts[ p ] ].y
	
				apx = px - ax;  apy = py - ay;
				bpx = px - bx;  bpy = py - by;
				cpx = px - cx;  cpy = py - cy;
	
				// see if p is inside triangle abc
	
				aCROSSbp = aX*bpy - aY*bpx;
				cCROSSap = cX*apy - cY*apx;
				bCROSScp = bX*cpy - bY*cpx;
	
				if ( (aCROSSbp >= 0.0) && (bCROSScp >= 0.0) && (cCROSSap >= 0.0) ) return false;
	
			}
	
			return true;
	
		};
	
	
		namespace.Triangulate = process;
		namespace.Triangulate.area = area;
	
		return namespace;
	
	})(THREE.FontUtils);
	
	// To use the typeface.js face files, hook up the API
	self._typeface_js = { faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace };/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Extensible curve object
	 *
	 * Some common of Curve methods
	 * .getPoint(t), getTangent(t)
	 * .getPointAt(u), getTagentAt(u)
	 * .getPoints(), .getSpacedPoints()
	 * .getLength()
	 * .updateArcLengths()
	 *
	 * This file contains following classes:
	 *
	 * -- 2d classes --
	 * THREE.Curve
	 * THREE.LineCurve
	 * THREE.QuadraticBezierCurve
	 * THREE.CubicBezierCurve
	 * THREE.SplineCurve
	 * THREE.ArcCurve
	 * THREE.EllipseCurve
	 *
	 * -- 3d classes --
	 * THREE.LineCurve3
	 * THREE.QuadraticBezierCurve3
	 * THREE.CubicBezierCurve3
	 * THREE.SplineCurve3
	 * THREE.ClosedSplineCurve3
	 *
	 * A series of curves can be represented as a THREE.CurvePath
	 *
	 **/
	
	/**************************************************************
	 *	Abstract Curve base class
	 **************************************************************/
	
	THREE.Curve = function () {
	
	};
	
	// Virtual base class method to overwrite and implement in subclasses
	//	- t [0 .. 1]
	
	THREE.Curve.prototype.getPoint = function ( t ) {
	
		console.log( "Warning, getPoint() not implemented!" );
		return null;
	
	};
	
	// Get point at relative position in curve according to arc length
	// - u [0 .. 1]
	
	THREE.Curve.prototype.getPointAt = function ( u ) {
	
		var t = this.getUtoTmapping( u );
		return this.getPoint( t );
	
	};
	
	// Get sequence of points using getPoint( t )
	
	THREE.Curve.prototype.getPoints = function ( divisions ) {
	
		if ( !divisions ) divisions = 5;
	
		var d, pts = [];
	
		for ( d = 0; d <= divisions; d ++ ) {
	
			pts.push( this.getPoint( d / divisions ) );
	
		}
	
		return pts;
	
	};
	
	// Get sequence of points using getPointAt( u )
	
	THREE.Curve.prototype.getSpacedPoints = function ( divisions ) {
	
		if ( !divisions ) divisions = 5;
	
		var d, pts = [];
	
		for ( d = 0; d <= divisions; d ++ ) {
	
			pts.push( this.getPointAt( d / divisions ) );
	
		}
	
		return pts;
	
	};
	
	// Get total curve arc length
	
	THREE.Curve.prototype.getLength = function () {
	
		var lengths = this.getLengths();
		return lengths[ lengths.length - 1 ];
	
	};
	
	// Get list of cumulative segment lengths
	
	THREE.Curve.prototype.getLengths = function ( divisions ) {
	
		if ( !divisions ) divisions = (this.__arcLengthDivisions) ? (this.__arcLengthDivisions): 200;
	
		if ( this.cacheArcLengths
			&& ( this.cacheArcLengths.length == divisions + 1 )
			&& !this.needsUpdate) {
	
			//console.log( "cached", this.cacheArcLengths );
			return this.cacheArcLengths;
	
		}
	
		this.needsUpdate = false;
	
		var cache = [];
		var current, last = this.getPoint( 0 );
		var p, sum = 0;
	
		cache.push( 0 );
	
		for ( p = 1; p <= divisions; p ++ ) {
	
			current = this.getPoint ( p / divisions );
			sum += current.distanceTo( last );
			cache.push( sum );
			last = current;
	
		}
	
		this.cacheArcLengths = cache;
	
		return cache; // { sums: cache, sum:sum }; Sum is in the last element.
	
	};
	
	
	THREE.Curve.prototype.updateArcLengths = function() {
		this.needsUpdate = true;
		this.getLengths();
	};
	
	// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance
	
	THREE.Curve.prototype.getUtoTmapping = function ( u, distance ) {
	
		var arcLengths = this.getLengths();
	
		var i = 0, il = arcLengths.length;
	
		var targetArcLength; // The targeted u distance value to get
	
		if ( distance ) {
	
			targetArcLength = distance;
	
		} else {
	
			targetArcLength = u * arcLengths[ il - 1 ];
	
		}
	
		//var time = Date.now();
	
		// binary search for the index with largest value smaller than target u distance
	
		var low = 0, high = il - 1, comparison;
	
		while ( low <= high ) {
	
			i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats
	
			comparison = arcLengths[ i ] - targetArcLength;
	
			if ( comparison < 0 ) {
	
				low = i + 1;
				continue;
	
			} else if ( comparison > 0 ) {
	
				high = i - 1;
				continue;
	
			} else {
	
				high = i;
				break;
	
				// DONE
	
			}
	
		}
	
		i = high;
	
		//console.log('b' , i, low, high, Date.now()- time);
	
		if ( arcLengths[ i ] == targetArcLength ) {
	
			var t = i / ( il - 1 );
			return t;
	
		}
	
		// we could get finer grain at lengths, or use simple interpolatation between two points
	
		var lengthBefore = arcLengths[ i ];
	    var lengthAfter = arcLengths[ i + 1 ];
	
	    var segmentLength = lengthAfter - lengthBefore;
	
	    // determine where we are between the 'before' and 'after' points
	
	    var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;
	
	    // add that fractional amount to t
	
	    var t = ( i + segmentFraction ) / ( il -1 );
	
		return t;
	
	};
	
	// Returns a unit vector tangent at t
	// In case any sub curve does not implement its tangent derivation,
	// 2 points a small delta apart will be used to find its gradient
	// which seems to give a reasonable approximation
	
	THREE.Curve.prototype.getTangent = function( t ) {
	
		var delta = 0.0001;
		var t1 = t - delta;
		var t2 = t + delta;
	
		// Capping in case of danger
	
		if ( t1 < 0 ) t1 = 0;
		if ( t2 > 1 ) t2 = 1;
	
		var pt1 = this.getPoint( t1 );
		var pt2 = this.getPoint( t2 );
	
		var vec = pt2.clone().sub(pt1);
		return vec.normalize();
	
	};
	
	
	THREE.Curve.prototype.getTangentAt = function ( u ) {
	
		var t = this.getUtoTmapping( u );
		return this.getTangent( t );
	
	};
	
	/**************************************************************
	 *	Line
	 **************************************************************/
	
	THREE.LineCurve = function ( v1, v2 ) {
	
		this.v1 = v1;
		this.v2 = v2;
	
	};
	
	THREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );
	
	THREE.LineCurve.prototype.getPoint = function ( t ) {
	
		var point = this.v2.clone().sub(this.v1);
		point.multiplyScalar( t ).add( this.v1 );
	
		return point;
	
	};
	
	// Line curve is linear, so we can overwrite default getPointAt
	
	THREE.LineCurve.prototype.getPointAt = function ( u ) {
	
		return this.getPoint( u );
	
	};
	
	THREE.LineCurve.prototype.getTangent = function( t ) {
	
		var tangent = this.v2.clone().sub(this.v1);
	
		return tangent.normalize();
	
	};
	
	/**************************************************************
	 *	Quadratic Bezier curve
	 **************************************************************/
	
	
	THREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {
	
		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
	
	};
	
	THREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );
	
	
	THREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {
	
		var tx, ty;
	
		tx = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
		ty = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );
	
		return new THREE.Vector2( tx, ty );
	
	};
	
	
	THREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {
	
		var tx, ty;
	
		tx = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x );
		ty = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y );
	
		// returns unit vector
	
		var tangent = new THREE.Vector2( tx, ty );
		tangent.normalize();
	
		return tangent;
	
	};
	
	
	/**************************************************************
	 *	Cubic Bezier curve
	 **************************************************************/
	
	THREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {
	
		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;
	
	};
	
	THREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );
	
	THREE.CubicBezierCurve.prototype.getPoint = function ( t ) {
	
		var tx, ty;
	
		tx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
		ty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );
	
		return new THREE.Vector2( tx, ty );
	
	};
	
	THREE.CubicBezierCurve.prototype.getTangent = function( t ) {
	
		var tx, ty;
	
		tx = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
		ty = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );
	
		var tangent = new THREE.Vector2( tx, ty );
		tangent.normalize();
	
		return tangent;
	
	};
	
	
	/**************************************************************
	 *	Spline curve
	 **************************************************************/
	
	THREE.SplineCurve = function ( points /* array of Vector2 */ ) {
	
		this.points = (points == undefined) ? [] : points;
	
	};
	
	THREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );
	
	THREE.SplineCurve.prototype.getPoint = function ( t ) {
	
		var v = new THREE.Vector2();
		var c = [];
		var points = this.points, point, intPoint, weight;
		point = ( points.length - 1 ) * t;
	
		intPoint = Math.floor( point );
		weight = point - intPoint;
	
		c[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;
		c[ 1 ] = intPoint;
		c[ 2 ] = intPoint  > points.length - 2 ? points.length -1 : intPoint + 1;
		c[ 3 ] = intPoint  > points.length - 3 ? points.length -1 : intPoint + 2;
	
		v.x = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].x, points[ c[ 1 ] ].x, points[ c[ 2 ] ].x, points[ c[ 3 ] ].x, weight );
		v.y = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].y, points[ c[ 1 ] ].y, points[ c[ 2 ] ].y, points[ c[ 3 ] ].y, weight );
	
		return v;
	
	};
	
	/**************************************************************
	 *	Ellipse curve
	 **************************************************************/
	
	THREE.EllipseCurve = function ( aX, aY, xRadius, yRadius,
								aStartAngle, aEndAngle,
								aClockwise ) {
	
		this.aX = aX;
		this.aY = aY;
	
		this.xRadius = xRadius;
		this.yRadius = yRadius;
	
		this.aStartAngle = aStartAngle;
		this.aEndAngle = aEndAngle;
	
		this.aClockwise = aClockwise;
	
	};
	
	THREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );
	
	THREE.EllipseCurve.prototype.getPoint = function ( t ) {
	
		var deltaAngle = this.aEndAngle - this.aStartAngle;
	
		if ( !this.aClockwise ) {
	
			t = 1 - t;
	
		}
	
		var angle = this.aStartAngle + t * deltaAngle;
	
		var tx = this.aX + this.xRadius * Math.cos( angle );
		var ty = this.aY + this.yRadius * Math.sin( angle );
	
		return new THREE.Vector2( tx, ty );
	
	};
	
	/**************************************************************
	 *	Arc curve
	 **************************************************************/
	
	THREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {
	
		THREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );
	};
	
	THREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );
	
	
	/**************************************************************
	 *	Utils
	 **************************************************************/
	
	THREE.Curve.Utils = {
	
		tangentQuadraticBezier: function ( t, p0, p1, p2 ) {
	
			return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );
	
		},
	
		// Puay Bing, thanks for helping with this derivative!
	
		tangentCubicBezier: function (t, p0, p1, p2, p3 ) {
	
			return -3 * p0 * (1 - t) * (1 - t)  +
				3 * p1 * (1 - t) * (1-t) - 6 *t *p1 * (1-t) +
				6 * t *  p2 * (1-t) - 3 * t * t * p2 +
				3 * t * t * p3;
		},
	
	
		tangentSpline: function ( t, p0, p1, p2, p3 ) {
	
			// To check if my formulas are correct
	
			var h00 = 6 * t * t - 6 * t; 	// derived from 2t^3 − 3t^2 + 1
			var h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t
			var h01 = -6 * t * t + 6 * t; 	// − 2t3 + 3t2
			var h11 = 3 * t * t - 2 * t;	// t3 − t2
	
			return h00 + h10 + h01 + h11;
	
		},
	
		// Catmull-Rom
	
		interpolate: function( p0, p1, p2, p3, t ) {
	
			var v0 = ( p2 - p0 ) * 0.5;
			var v1 = ( p3 - p1 ) * 0.5;
			var t2 = t * t;
			var t3 = t * t2;
			return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;
	
		}
	
	};
	
	
	// TODO: Transformation for Curves?
	
	/**************************************************************
	 *	3D Curves
	 **************************************************************/
	
	// A Factory method for creating new curve subclasses
	
	THREE.Curve.create = function ( constructor, getPointFunc ) {
	
		constructor.prototype = Object.create( THREE.Curve.prototype );
		constructor.prototype.getPoint = getPointFunc;
	
		return constructor;
	
	};
	
	
	/**************************************************************
	 *	Line3D
	 **************************************************************/
	
	THREE.LineCurve3 = THREE.Curve.create(
	
		function ( v1, v2 ) {
	
			this.v1 = v1;
			this.v2 = v2;
	
		},
	
		function ( t ) {
	
			var r = new THREE.Vector3();
	
	
			r.subVectors( this.v2, this.v1 ); // diff
			r.multiplyScalar( t );
			r.add( this.v1 );
	
			return r;
	
		}
	
	);
	
	
	/**************************************************************
	 *	Quadratic Bezier 3D curve
	 **************************************************************/
	
	THREE.QuadraticBezierCurve3 = THREE.Curve.create(
	
		function ( v0, v1, v2 ) {
	
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
	
		},
	
		function ( t ) {
	
			var tx, ty, tz;
	
			tx = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
			ty = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );
			tz = THREE.Shape.Utils.b2( t, this.v0.z, this.v1.z, this.v2.z );
	
			return new THREE.Vector3( tx, ty, tz );
	
		}
	
	);
	
	
	
	/**************************************************************
	 *	Cubic Bezier 3D curve
	 **************************************************************/
	
	THREE.CubicBezierCurve3 = THREE.Curve.create(
	
		function ( v0, v1, v2, v3 ) {
	
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;
	
		},
	
		function ( t ) {
	
			var tx, ty, tz;
	
			tx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
			ty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );
			tz = THREE.Shape.Utils.b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z );
	
			return new THREE.Vector3( tx, ty, tz );
	
		}
	
	);
	
	
	
	/**************************************************************
	 *	Spline 3D curve
	 **************************************************************/
	
	
	THREE.SplineCurve3 = THREE.Curve.create(
	
		function ( points /* array of Vector3 */) {
	
			this.points = (points == undefined) ? [] : points;
	
		},
	
		function ( t ) {
	
			var v = new THREE.Vector3();
			var c = [];
			var points = this.points, point, intPoint, weight;
			point = ( points.length - 1 ) * t;
	
			intPoint = Math.floor( point );
			weight = point - intPoint;
	
			c[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;
			c[ 1 ] = intPoint;
			c[ 2 ] = intPoint  > points.length - 2 ? points.length - 1 : intPoint + 1;
			c[ 3 ] = intPoint  > points.length - 3 ? points.length - 1 : intPoint + 2;
	
			var pt0 = points[ c[0] ],
				pt1 = points[ c[1] ],
				pt2 = points[ c[2] ],
				pt3 = points[ c[3] ];
	
			v.x = THREE.Curve.Utils.interpolate(pt0.x, pt1.x, pt2.x, pt3.x, weight);
			v.y = THREE.Curve.Utils.interpolate(pt0.y, pt1.y, pt2.y, pt3.y, weight);
			v.z = THREE.Curve.Utils.interpolate(pt0.z, pt1.z, pt2.z, pt3.z, weight);
	
			return v;
	
		}
	
	);
	
	
	// THREE.SplineCurve3.prototype.getTangent = function(t) {
	// 		var v = new THREE.Vector3();
	// 		var c = [];
	// 		var points = this.points, point, intPoint, weight;
	// 		point = ( points.length - 1 ) * t;
	
	// 		intPoint = Math.floor( point );
	// 		weight = point - intPoint;
	
	// 		c[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;
	// 		c[ 1 ] = intPoint;
	// 		c[ 2 ] = intPoint  > points.length - 2 ? points.length - 1 : intPoint + 1;
	// 		c[ 3 ] = intPoint  > points.length - 3 ? points.length - 1 : intPoint + 2;
	
	// 		var pt0 = points[ c[0] ],
	// 			pt1 = points[ c[1] ],
	// 			pt2 = points[ c[2] ],
	// 			pt3 = points[ c[3] ];
	
	// 	// t = weight;
	// 	v.x = THREE.Curve.Utils.tangentSpline( t, pt0.x, pt1.x, pt2.x, pt3.x );
	// 	v.y = THREE.Curve.Utils.tangentSpline( t, pt0.y, pt1.y, pt2.y, pt3.y );
	// 	v.z = THREE.Curve.Utils.tangentSpline( t, pt0.z, pt1.z, pt2.z, pt3.z );
	
	// 	return v;
	
	// }
	
	/**************************************************************
	 *	Closed Spline 3D curve
	 **************************************************************/
	
	
	THREE.ClosedSplineCurve3 = THREE.Curve.create(
	
		function ( points /* array of Vector3 */) {
	
			this.points = (points == undefined) ? [] : points;
	
		},
	
	    function ( t ) {
	
	        var v = new THREE.Vector3();
	        var c = [];
	        var points = this.points, point, intPoint, weight;
	        point = ( points.length - 0 ) * t;
	            // This needs to be from 0-length +1
	
	        intPoint = Math.floor( point );
	        weight = point - intPoint;
	
	        intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;
	        c[ 0 ] = ( intPoint - 1 ) % points.length;
	        c[ 1 ] = ( intPoint ) % points.length;
	        c[ 2 ] = ( intPoint + 1 ) % points.length;
	        c[ 3 ] = ( intPoint + 2 ) % points.length;
	
	        v.x = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].x, points[ c[ 1 ] ].x, points[ c[ 2 ] ].x, points[ c[ 3 ] ].x, weight );
	        v.y = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].y, points[ c[ 1 ] ].y, points[ c[ 2 ] ].y, points[ c[ 3 ] ].y, weight );
	        v.z = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].z, points[ c[ 1 ] ].z, points[ c[ 2 ] ].z, points[ c[ 3 ] ].z, weight );
	
	        return v;
	
	    }
	
	);
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 **/
	
	/**************************************************************
	 *	Curved Path - a curve path is simply a array of connected
	 *  curves, but retains the api of a curve
	 **************************************************************/
	
	THREE.CurvePath = function () {
	
		this.curves = [];
		this.bends = [];
		
		this.autoClose = false; // Automatically closes the path
	};
	
	THREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );
	
	THREE.CurvePath.prototype.add = function ( curve ) {
	
		this.curves.push( curve );
	
	};
	
	THREE.CurvePath.prototype.checkConnection = function() {
		// TODO
		// If the ending of curve is not connected to the starting
		// or the next curve, then, this is not a real path
	};
	
	THREE.CurvePath.prototype.closePath = function() {
		// TODO Test
		// and verify for vector3 (needs to implement equals)
		// Add a line curve if start and end of lines are not connected
		var startPoint = this.curves[0].getPoint(0);
		var endPoint = this.curves[this.curves.length-1].getPoint(1);
		
		if (!startPoint.equals(endPoint)) {
			this.curves.push( new THREE.LineCurve(endPoint, startPoint) );
		}
		
	};
	
	// To get accurate point with reference to
	// entire path distance at time t,
	// following has to be done:
	
	// 1. Length of each sub path have to be known
	// 2. Locate and identify type of curve
	// 3. Get t for the curve
	// 4. Return curve.getPointAt(t')
	
	THREE.CurvePath.prototype.getPoint = function( t ) {
	
		var d = t * this.getLength();
		var curveLengths = this.getCurveLengths();
		var i = 0, diff, curve;
	
		// To think about boundaries points.
	
		while ( i < curveLengths.length ) {
	
			if ( curveLengths[ i ] >= d ) {
	
				diff = curveLengths[ i ] - d;
				curve = this.curves[ i ];
	
				var u = 1 - diff / curve.getLength();
	
				return curve.getPointAt( u );
	
				break;
			}
	
			i ++;
	
		}
	
		return null;
	
		// loop where sum != 0, sum > d , sum+1 <d
	
	};
	
	/*
	THREE.CurvePath.prototype.getTangent = function( t ) {
	};*/
	
	
	// We cannot use the default THREE.Curve getPoint() with getLength() because in
	// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
	// getPoint() depends on getLength
	
	THREE.CurvePath.prototype.getLength = function() {
	
		var lens = this.getCurveLengths();
		return lens[ lens.length - 1 ];
	
	};
	
	// Compute lengths and cache them
	// We cannot overwrite getLengths() because UtoT mapping uses it.
	
	THREE.CurvePath.prototype.getCurveLengths = function() {
	
		// We use cache values if curves and cache array are same length
	
		if ( this.cacheLengths && this.cacheLengths.length == this.curves.length ) {
	
			return this.cacheLengths;
	
		};
	
		// Get length of subsurve
		// Push sums into cached array
	
		var lengths = [], sums = 0;
		var i, il = this.curves.length;
	
		for ( i = 0; i < il; i ++ ) {
	
			sums += this.curves[ i ].getLength();
			lengths.push( sums );
	
		}
	
		this.cacheLengths = lengths;
	
		return lengths;
	
	};
	
	
	
	// Returns min and max coordinates, as well as centroid
	
	THREE.CurvePath.prototype.getBoundingBox = function () {
	
		var points = this.getPoints();
	
		var maxX, maxY, maxZ;
		var minX, minY, minZ;
	
		maxX = maxY = Number.NEGATIVE_INFINITY;
		minX = minY = Number.POSITIVE_INFINITY;
	
		var p, i, il, sum;
	
		var v3 = points[0] instanceof THREE.Vector3;
	
		sum = v3 ? new THREE.Vector3() : new THREE.Vector2();
	
		for ( i = 0, il = points.length; i < il; i ++ ) {
	
			p = points[ i ];
	
			if ( p.x > maxX ) maxX = p.x;
			else if ( p.x < minX ) minX = p.x;
	
			if ( p.y > maxY ) maxY = p.y;
			else if ( p.y < minY ) minY = p.y;
	
			if ( v3 ) {
	
				if ( p.z > maxZ ) maxZ = p.z;
				else if ( p.z < minZ ) minZ = p.z;
	
			}
	
			sum.add( p );
	
		}
	
		var ret = {
	
			minX: minX,
			minY: minY,
			maxX: maxX,
			maxY: maxY,
			centroid: sum.divideScalar( il )
	
		};
	
		if ( v3 ) {
	
			ret.maxZ = maxZ;
			ret.minZ = minZ;
	
		}
	
		return ret;
	
	};
	
	/**************************************************************
	 *	Create Geometries Helpers
	 **************************************************************/
	
	/// Generate geometry from path points (for Line or ParticleSystem objects)
	
	THREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {
	
		var pts = this.getPoints( divisions, true );
		return this.createGeometry( pts );
	
	};
	
	// Generate geometry from equidistance sampling along the path
	
	THREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {
	
		var pts = this.getSpacedPoints( divisions, true );
		return this.createGeometry( pts );
	
	};
	
	THREE.CurvePath.prototype.createGeometry = function( points ) {
	
		var geometry = new THREE.Geometry();
	
		for ( var i = 0; i < points.length; i ++ ) {
	
			geometry.vertices.push( new THREE.Vector3( points[ i ].x, points[ i ].y, points[ i ].z || 0) );
	
		}
	
		return geometry;
	
	};
	
	
	/**************************************************************
	 *	Bend / Wrap Helper Methods
	 **************************************************************/
	
	// Wrap path / Bend modifiers?
	
	THREE.CurvePath.prototype.addWrapPath = function ( bendpath ) {
	
		this.bends.push( bendpath );
	
	};
	
	THREE.CurvePath.prototype.getTransformedPoints = function( segments, bends ) {
	
		var oldPts = this.getPoints( segments ); // getPoints getSpacedPoints
		var i, il;
	
		if ( !bends ) {
	
			bends = this.bends;
	
		}
	
		for ( i = 0, il = bends.length; i < il; i ++ ) {
	
			oldPts = this.getWrapPoints( oldPts, bends[ i ] );
	
		}
	
		return oldPts;
	
	};
	
	THREE.CurvePath.prototype.getTransformedSpacedPoints = function( segments, bends ) {
	
		var oldPts = this.getSpacedPoints( segments );
	
		var i, il;
	
		if ( !bends ) {
	
			bends = this.bends;
	
		}
	
		for ( i = 0, il = bends.length; i < il; i ++ ) {
	
			oldPts = this.getWrapPoints( oldPts, bends[ i ] );
	
		}
	
		return oldPts;
	
	};
	
	// This returns getPoints() bend/wrapped around the contour of a path.
	// Read http://www.planetclegg.com/projects/WarpingTextToSplines.html
	
	THREE.CurvePath.prototype.getWrapPoints = function ( oldPts, path ) {
	
		var bounds = this.getBoundingBox();
	
		var i, il, p, oldX, oldY, xNorm;
	
		for ( i = 0, il = oldPts.length; i < il; i ++ ) {
	
			p = oldPts[ i ];
	
			oldX = p.x;
			oldY = p.y;
	
			xNorm = oldX / bounds.maxX;
	
			// If using actual distance, for length > path, requires line extrusions
			//xNorm = path.getUtoTmapping(xNorm, oldX); // 3 styles. 1) wrap stretched. 2) wrap stretch by arc length 3) warp by actual distance
	
			xNorm = path.getUtoTmapping( xNorm, oldX );
	
			// check for out of bounds?
	
			var pathPt = path.getPoint( xNorm );
			var normal = path.getNormalVector( xNorm ).multiplyScalar( oldY );
	
			p.x = pathPt.x + normal.x;
			p.y = pathPt.y + normal.y;
	
		}
	
		return oldPts;
	
	};
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Gyroscope = function () {
	
		THREE.Object3D.call( this );
	
	};
	
	THREE.Gyroscope.prototype = Object.create( THREE.Object3D.prototype );
	
	THREE.Gyroscope.prototype.updateMatrixWorld = function ( force ) {
	
		this.matrixAutoUpdate && this.updateMatrix();
	
		// update matrixWorld
	
		if ( this.matrixWorldNeedsUpdate || force ) {
	
			if ( this.parent ) {
	
				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );
	
				this.matrixWorld.decompose( this.translationWorld, this.rotationWorld, this.scaleWorld );
				this.matrix.decompose( this.translationObject, this.rotationObject, this.scaleObject );
	
				this.matrixWorld.compose( this.translationWorld, this.rotationObject, this.scaleWorld );
	
	
			} else {
	
				this.matrixWorld.copy( this.matrix );
	
			}
	
	
			this.matrixWorldNeedsUpdate = false;
	
			force = true;
	
		}
	
		// update children
	
		for ( var i = 0, l = this.children.length; i < l; i ++ ) {
	
			this.children[ i ].updateMatrixWorld( force );
	
		}
	
	};
	
	THREE.Gyroscope.prototype.translationWorld = new THREE.Vector3();
	THREE.Gyroscope.prototype.translationObject = new THREE.Vector3();
	THREE.Gyroscope.prototype.rotationWorld = new THREE.Quaternion();
	THREE.Gyroscope.prototype.rotationObject = new THREE.Quaternion();
	THREE.Gyroscope.prototype.scaleWorld = new THREE.Vector3();
	THREE.Gyroscope.prototype.scaleObject = new THREE.Vector3();
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Creates free form 2d path using series of points, lines or curves.
	 *
	 **/
	
	THREE.Path = function ( points ) {
	
		THREE.CurvePath.call(this);
	
		this.actions = [];
	
		if ( points ) {
	
			this.fromPoints( points );
	
		}
	
	};
	
	THREE.Path.prototype = Object.create( THREE.CurvePath.prototype );
	
	THREE.PathActions = {
	
		MOVE_TO: 'moveTo',
		LINE_TO: 'lineTo',
		QUADRATIC_CURVE_TO: 'quadraticCurveTo', // Bezier quadratic curve
		BEZIER_CURVE_TO: 'bezierCurveTo', 		// Bezier cubic curve
		CSPLINE_THRU: 'splineThru',				// Catmull-rom spline
		ARC: 'arc',								// Circle
		ELLIPSE: 'ellipse'
	};
	
	// TODO Clean up PATH API
	
	// Create path using straight lines to connect all points
	// - vectors: array of Vector2
	
	THREE.Path.prototype.fromPoints = function ( vectors ) {
	
		this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );
	
		for ( var v = 1, vlen = vectors.length; v < vlen; v ++ ) {
	
			this.lineTo( vectors[ v ].x, vectors[ v ].y );
	
		};
	
	};
	
	// startPath() endPath()?
	
	THREE.Path.prototype.moveTo = function ( x, y ) {
	
		var args = Array.prototype.slice.call( arguments );
		this.actions.push( { action: THREE.PathActions.MOVE_TO, args: args } );
	
	};
	
	THREE.Path.prototype.lineTo = function ( x, y ) {
	
		var args = Array.prototype.slice.call( arguments );
	
		var lastargs = this.actions[ this.actions.length - 1 ].args;
	
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];
	
		var curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );
		this.curves.push( curve );
	
		this.actions.push( { action: THREE.PathActions.LINE_TO, args: args } );
	
	};
	
	THREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {
	
		var args = Array.prototype.slice.call( arguments );
	
		var lastargs = this.actions[ this.actions.length - 1 ].args;
	
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];
	
		var curve = new THREE.QuadraticBezierCurve( new THREE.Vector2( x0, y0 ),
													new THREE.Vector2( aCPx, aCPy ),
													new THREE.Vector2( aX, aY ) );
		this.curves.push( curve );
	
		this.actions.push( { action: THREE.PathActions.QUADRATIC_CURVE_TO, args: args } );
	
	};
	
	THREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y,
	                                               aCP2x, aCP2y,
	                                               aX, aY ) {
	
		var args = Array.prototype.slice.call( arguments );
	
		var lastargs = this.actions[ this.actions.length - 1 ].args;
	
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];
	
		var curve = new THREE.CubicBezierCurve( new THREE.Vector2( x0, y0 ),
												new THREE.Vector2( aCP1x, aCP1y ),
												new THREE.Vector2( aCP2x, aCP2y ),
												new THREE.Vector2( aX, aY ) );
		this.curves.push( curve );
	
		this.actions.push( { action: THREE.PathActions.BEZIER_CURVE_TO, args: args } );
	
	};
	
	THREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {
	
		var args = Array.prototype.slice.call( arguments );
		var lastargs = this.actions[ this.actions.length - 1 ].args;
	
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];
	//---
		var npts = [ new THREE.Vector2( x0, y0 ) ];
		Array.prototype.push.apply( npts, pts );
	
		var curve = new THREE.SplineCurve( npts );
		this.curves.push( curve );
	
		this.actions.push( { action: THREE.PathActions.CSPLINE_THRU, args: args } );
	
	};
	
	// FUTURE: Change the API or follow canvas API?
	
	THREE.Path.prototype.arc = function ( aX, aY, aRadius,
										  aStartAngle, aEndAngle, aClockwise ) {
	
		var lastargs = this.actions[ this.actions.length - 1].args;
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];
	
		this.absarc(aX + x0, aY + y0, aRadius,
			aStartAngle, aEndAngle, aClockwise );
		
	 };
	
	 THREE.Path.prototype.absarc = function ( aX, aY, aRadius,
										  aStartAngle, aEndAngle, aClockwise ) {
		this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
	 };
	 
	THREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius,
										  aStartAngle, aEndAngle, aClockwise ) {
	
		var lastargs = this.actions[ this.actions.length - 1].args;
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];
	
		this.absellipse(aX + x0, aY + y0, xRadius, yRadius,
			aStartAngle, aEndAngle, aClockwise );
	
	 };
	 
	
	THREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius,
										  aStartAngle, aEndAngle, aClockwise ) {
	
		var args = Array.prototype.slice.call( arguments );
		var curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius,
										aStartAngle, aEndAngle, aClockwise );
		this.curves.push( curve );
	
		var lastPoint = curve.getPoint(aClockwise ? 1 : 0);
		args.push(lastPoint.x);
		args.push(lastPoint.y);
	
		this.actions.push( { action: THREE.PathActions.ELLIPSE, args: args } );
	
	 };
	
	THREE.Path.prototype.getSpacedPoints = function ( divisions, closedPath ) {
	
		if ( ! divisions ) divisions = 40;
	
		var points = [];
	
		for ( var i = 0; i < divisions; i ++ ) {
	
			points.push( this.getPoint( i / divisions ) );
	
			//if( !this.getPoint( i / divisions ) ) throw "DIE";
	
		}
	
		// if ( closedPath ) {
		//
		// 	points.push( points[ 0 ] );
		//
		// }
	
		return points;
	
	};
	
	/* Return an array of vectors based on contour of the path */
	
	THREE.Path.prototype.getPoints = function( divisions, closedPath ) {
	
		if (this.useSpacedPoints) {
			console.log('tata');
			return this.getSpacedPoints( divisions, closedPath );
		}
	
		divisions = divisions || 12;
	
		var points = [];
	
		var i, il, item, action, args;
		var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,
			laste, j,
			t, tx, ty;
	
		for ( i = 0, il = this.actions.length; i < il; i ++ ) {
	
			item = this.actions[ i ];
	
			action = item.action;
			args = item.args;
	
			switch( action ) {
	
			case THREE.PathActions.MOVE_TO:
	
				points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );
	
				break;
	
			case THREE.PathActions.LINE_TO:
	
				points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );
	
				break;
	
			case THREE.PathActions.QUADRATIC_CURVE_TO:
	
				cpx  = args[ 2 ];
				cpy  = args[ 3 ];
	
				cpx1 = args[ 0 ];
				cpy1 = args[ 1 ];
	
				if ( points.length > 0 ) {
	
					laste = points[ points.length - 1 ];
	
					cpx0 = laste.x;
					cpy0 = laste.y;
	
				} else {
	
					laste = this.actions[ i - 1 ].args;
	
					cpx0 = laste[ laste.length - 2 ];
					cpy0 = laste[ laste.length - 1 ];
	
				}
	
				for ( j = 1; j <= divisions; j ++ ) {
	
					t = j / divisions;
	
					tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
					ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );
	
					points.push( new THREE.Vector2( tx, ty ) );
	
			  	}
	
				break;
	
			case THREE.PathActions.BEZIER_CURVE_TO:
	
				cpx  = args[ 4 ];
				cpy  = args[ 5 ];
	
				cpx1 = args[ 0 ];
				cpy1 = args[ 1 ];
	
				cpx2 = args[ 2 ];
				cpy2 = args[ 3 ];
	
				if ( points.length > 0 ) {
	
					laste = points[ points.length - 1 ];
	
					cpx0 = laste.x;
					cpy0 = laste.y;
	
				} else {
	
					laste = this.actions[ i - 1 ].args;
	
					cpx0 = laste[ laste.length - 2 ];
					cpy0 = laste[ laste.length - 1 ];
	
				}
	
	
				for ( j = 1; j <= divisions; j ++ ) {
	
					t = j / divisions;
	
					tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
					ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );
	
					points.push( new THREE.Vector2( tx, ty ) );
	
				}
	
				break;
	
			case THREE.PathActions.CSPLINE_THRU:
	
				laste = this.actions[ i - 1 ].args;
	
				var last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );
				var spts = [ last ];
	
				var n = divisions * args[ 0 ].length;
	
				spts = spts.concat( args[ 0 ] );
	
				var spline = new THREE.SplineCurve( spts );
	
				for ( j = 1; j <= n; j ++ ) {
	
					points.push( spline.getPointAt( j / n ) ) ;
	
				}
	
				break;
	
			case THREE.PathActions.ARC:
	
				var aX = args[ 0 ], aY = args[ 1 ],
					aRadius = args[ 2 ],
					aStartAngle = args[ 3 ], aEndAngle = args[ 4 ],
					aClockwise = !!args[ 5 ];
	
				var deltaAngle = aEndAngle - aStartAngle;
				var angle;
				var tdivisions = divisions * 2;
	
				for ( j = 1; j <= tdivisions; j ++ ) {
	
					t = j / tdivisions;
	
					if ( ! aClockwise ) {
	
						t = 1 - t;
	
					}
	
					angle = aStartAngle + t * deltaAngle;
	
					tx = aX + aRadius * Math.cos( angle );
					ty = aY + aRadius * Math.sin( angle );
	
					//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);
	
					points.push( new THREE.Vector2( tx, ty ) );
	
				}
	
				//console.log(points);
	
			  break;
			  
			case THREE.PathActions.ELLIPSE:
	
				var aX = args[ 0 ], aY = args[ 1 ],
					xRadius = args[ 2 ],
					yRadius = args[ 3 ],
					aStartAngle = args[ 4 ], aEndAngle = args[ 5 ],
					aClockwise = !!args[ 6 ];
	
	
				var deltaAngle = aEndAngle - aStartAngle;
				var angle;
				var tdivisions = divisions * 2;
	
				for ( j = 1; j <= tdivisions; j ++ ) {
	
					t = j / tdivisions;
	
					if ( ! aClockwise ) {
	
						t = 1 - t;
	
					}
	
					angle = aStartAngle + t * deltaAngle;
	
					tx = aX + xRadius * Math.cos( angle );
					ty = aY + yRadius * Math.sin( angle );
	
					//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);
	
					points.push( new THREE.Vector2( tx, ty ) );
	
				}
	
				//console.log(points);
	
			  break;
	
			} // end switch
	
		}
	
	
	
		// Normalize to remove the closing point by default.
		var lastPoint = points[ points.length - 1];
		var EPSILON = 0.0000000001;
		if ( Math.abs(lastPoint.x - points[ 0 ].x) < EPSILON &&
	             Math.abs(lastPoint.y - points[ 0 ].y) < EPSILON)
			points.splice( points.length - 1, 1);
		if ( closedPath ) {
	
			points.push( points[ 0 ] );
	
		}
	
		return points;
	
	};
	
	// Breaks path into shapes
	
	THREE.Path.prototype.toShapes = function() {
	
		var i, il, item, action, args;
	
		var subPaths = [], lastPath = new THREE.Path();
	
		for ( i = 0, il = this.actions.length; i < il; i ++ ) {
	
			item = this.actions[ i ];
	
			args = item.args;
			action = item.action;
	
			if ( action == THREE.PathActions.MOVE_TO ) {
	
				if ( lastPath.actions.length != 0 ) {
	
					subPaths.push( lastPath );
					lastPath = new THREE.Path();
	
				}
	
			}
	
			lastPath[ action ].apply( lastPath, args );
	
		}
	
		if ( lastPath.actions.length != 0 ) {
	
			subPaths.push( lastPath );
	
		}
	
		// console.log(subPaths);
	
		if ( subPaths.length == 0 ) return [];
	
		var tmpPath, tmpShape, shapes = [];
	
		var holesFirst = !THREE.Shape.Utils.isClockWise( subPaths[ 0 ].getPoints() );
		// console.log("Holes first", holesFirst);
	
		if ( subPaths.length == 1) {
			tmpPath = subPaths[0];
			tmpShape = new THREE.Shape();
			tmpShape.actions = tmpPath.actions;
			tmpShape.curves = tmpPath.curves;
			shapes.push( tmpShape );
			return shapes;
		};
	
		if ( holesFirst ) {
	
			tmpShape = new THREE.Shape();
	
			for ( i = 0, il = subPaths.length; i < il; i ++ ) {
	
				tmpPath = subPaths[ i ];
	
				if ( THREE.Shape.Utils.isClockWise( tmpPath.getPoints() ) ) {
	
					tmpShape.actions = tmpPath.actions;
					tmpShape.curves = tmpPath.curves;
	
					shapes.push( tmpShape );
					tmpShape = new THREE.Shape();
	
					//console.log('cw', i);
	
				} else {
	
					tmpShape.holes.push( tmpPath );
	
					//console.log('ccw', i);
	
				}
	
			}
	
		} else {
	
			// Shapes first
	
			for ( i = 0, il = subPaths.length; i < il; i ++ ) {
	
				tmpPath = subPaths[ i ];
	
				if ( THREE.Shape.Utils.isClockWise( tmpPath.getPoints() ) ) {
	
	
					if ( tmpShape ) shapes.push( tmpShape );
	
					tmpShape = new THREE.Shape();
					tmpShape.actions = tmpPath.actions;
					tmpShape.curves = tmpPath.curves;
	
				} else {
	
					tmpShape.holes.push( tmpPath );
	
				}
	
			}
	
			shapes.push( tmpShape );
	
		}
	
		//console.log("shape", shapes);
	
		return shapes;
	
	};
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Defines a 2d shape plane using paths.
	 **/
	
	// STEP 1 Create a path.
	// STEP 2 Turn path into shape.
	// STEP 3 ExtrudeGeometry takes in Shape/Shapes
	// STEP 3a - Extract points from each shape, turn to vertices
	// STEP 3b - Triangulate each shape, add faces.
	
	THREE.Shape = function () {
	
		THREE.Path.apply( this, arguments );
		this.holes = [];
	
	};
	
	THREE.Shape.prototype = Object.create( THREE.Path.prototype );
	
	// Convenience method to return ExtrudeGeometry
	
	THREE.Shape.prototype.extrude = function ( options ) {
	
		var extruded = new THREE.ExtrudeGeometry( this, options );
		return extruded;
	
	};
	
	// Convenience method to return ShapeGeometry
	
	THREE.Shape.prototype.makeGeometry = function ( options ) {
	
		var geometry = new THREE.ShapeGeometry( this, options );
		return geometry;
	
	};
	
	// Get points of holes
	
	THREE.Shape.prototype.getPointsHoles = function ( divisions ) {
	
		var i, il = this.holes.length, holesPts = [];
	
		for ( i = 0; i < il; i ++ ) {
	
			holesPts[ i ] = this.holes[ i ].getTransformedPoints( divisions, this.bends );
	
		}
	
		return holesPts;
	
	};
	
	// Get points of holes (spaced by regular distance)
	
	THREE.Shape.prototype.getSpacedPointsHoles = function ( divisions ) {
	
		var i, il = this.holes.length, holesPts = [];
	
		for ( i = 0; i < il; i ++ ) {
	
			holesPts[ i ] = this.holes[ i ].getTransformedSpacedPoints( divisions, this.bends );
	
		}
	
		return holesPts;
	
	};
	
	
	// Get points of shape and holes (keypoints based on segments parameter)
	
	THREE.Shape.prototype.extractAllPoints = function ( divisions ) {
	
		return {
	
			shape: this.getTransformedPoints( divisions ),
			holes: this.getPointsHoles( divisions )
	
		};
	
	};
	
	THREE.Shape.prototype.extractPoints = function ( divisions ) {
	
		if (this.useSpacedPoints) {
			return this.extractAllSpacedPoints(divisions);
		}
	
		return this.extractAllPoints(divisions);
	
	};
	
	//
	// THREE.Shape.prototype.extractAllPointsWithBend = function ( divisions, bend ) {
	//
	// 	return {
	//
	// 		shape: this.transform( bend, divisions ),
	// 		holes: this.getPointsHoles( divisions, bend )
	//
	// 	};
	//
	// };
	
	// Get points of shape and holes (spaced by regular distance)
	
	THREE.Shape.prototype.extractAllSpacedPoints = function ( divisions ) {
	
		return {
	
			shape: this.getTransformedSpacedPoints( divisions ),
			holes: this.getSpacedPointsHoles( divisions )
	
		};
	
	};
	
	/**************************************************************
	 *	Utils
	 **************************************************************/
	
	THREE.Shape.Utils = {
	
		/*
			contour - array of vector2 for contour
			holes   - array of array of vector2
		*/
	
		removeHoles: function ( contour, holes ) {
	
			var shape = contour.concat(); // work on this shape
			var allpoints = shape.concat();
	
			/* For each isolated shape, find the closest points and break to the hole to allow triangulation */
	
	
			var prevShapeVert, nextShapeVert,
				prevHoleVert, nextHoleVert,
				holeIndex, shapeIndex,
				shapeId, shapeGroup,
				h, h2,
				hole, shortest, d,
				p, pts1, pts2,
				tmpShape1, tmpShape2,
				tmpHole1, tmpHole2,
				verts = [];
	
			for ( h = 0; h < holes.length; h ++ ) {
	
				hole = holes[ h ];
	
				/*
				shapeholes[ h ].concat(); // preserves original
				holes.push( hole );
				*/
	
				Array.prototype.push.apply( allpoints, hole );
	
				shortest = Number.POSITIVE_INFINITY;
	
	
				// Find the shortest pair of pts between shape and hole
	
				// Note: Actually, I'm not sure now if we could optimize this to be faster than O(m*n)
				// Using distanceToSquared() intead of distanceTo() should speed a little
				// since running square roots operations are reduced.
	
				for ( h2 = 0; h2 < hole.length; h2 ++ ) {
	
					pts1 = hole[ h2 ];
					var dist = [];
	
					for ( p = 0; p < shape.length; p++ ) {
	
						pts2 = shape[ p ];
						d = pts1.distanceToSquared( pts2 );
						dist.push( d );
	
						if ( d < shortest ) {
	
							shortest = d;
							holeIndex = h2;
							shapeIndex = p;
	
						}
	
					}
	
				}
	
				//console.log("shortest", shortest, dist);
	
				prevShapeVert = ( shapeIndex - 1 ) >= 0 ? shapeIndex - 1 : shape.length - 1;
				prevHoleVert = ( holeIndex - 1 ) >= 0 ? holeIndex - 1 : hole.length - 1;
	
				var areaapts = [
	
					hole[ holeIndex ],
					shape[ shapeIndex ],
					shape[ prevShapeVert ]
	
				];
	
				var areaa = THREE.FontUtils.Triangulate.area( areaapts );
	
				var areabpts = [
	
					hole[ holeIndex ],
					hole[ prevHoleVert ],
					shape[ shapeIndex ]
	
				];
	
				var areab = THREE.FontUtils.Triangulate.area( areabpts );
	
				var shapeOffset = 1;
				var holeOffset = -1;
	
				var oldShapeIndex = shapeIndex, oldHoleIndex = holeIndex;
				shapeIndex += shapeOffset;
				holeIndex += holeOffset;
	
				if ( shapeIndex < 0 ) { shapeIndex += shape.length;  }
				shapeIndex %= shape.length;
	
				if ( holeIndex < 0 ) { holeIndex += hole.length;  }
				holeIndex %= hole.length;
	
				prevShapeVert = ( shapeIndex - 1 ) >= 0 ? shapeIndex - 1 : shape.length - 1;
				prevHoleVert = ( holeIndex - 1 ) >= 0 ? holeIndex - 1 : hole.length - 1;
	
				areaapts = [
	
					hole[ holeIndex ],
					shape[ shapeIndex ],
					shape[ prevShapeVert ]
	
				];
	
				var areaa2 = THREE.FontUtils.Triangulate.area( areaapts );
	
				areabpts = [
	
					hole[ holeIndex ],
					hole[ prevHoleVert ],
					shape[ shapeIndex ]
	
				];
	
				var areab2 = THREE.FontUtils.Triangulate.area( areabpts );
				//console.log(areaa,areab ,areaa2,areab2, ( areaa + areab ),  ( areaa2 + areab2 ));
	
				if ( ( areaa + areab ) > ( areaa2 + areab2 ) ) {
	
					// In case areas are not correct.
					//console.log("USE THIS");
	
					shapeIndex = oldShapeIndex;
					holeIndex = oldHoleIndex ;
	
					if ( shapeIndex < 0 ) { shapeIndex += shape.length;  }
					shapeIndex %= shape.length;
	
					if ( holeIndex < 0 ) { holeIndex += hole.length;  }
					holeIndex %= hole.length;
	
					prevShapeVert = ( shapeIndex - 1 ) >= 0 ? shapeIndex - 1 : shape.length - 1;
					prevHoleVert = ( holeIndex - 1 ) >= 0 ? holeIndex - 1 : hole.length - 1;
	
				} else {
	
					//console.log("USE THAT ")
	
				}
	
				tmpShape1 = shape.slice( 0, shapeIndex );
				tmpShape2 = shape.slice( shapeIndex );
				tmpHole1 = hole.slice( holeIndex );
				tmpHole2 = hole.slice( 0, holeIndex );
	
				// Should check orders here again?
	
				var trianglea = [
	
					hole[ holeIndex ],
					shape[ shapeIndex ],
					shape[ prevShapeVert ]
	
				];
	
				var triangleb = [
	
					hole[ holeIndex ] ,
					hole[ prevHoleVert ],
					shape[ shapeIndex ]
	
				];
	
				verts.push( trianglea );
				verts.push( triangleb );
	
				shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );
	
			}
	
			return {
	
				shape:shape, 		/* shape with no holes */
				isolatedPts: verts, /* isolated faces */
				allpoints: allpoints
	
			}
	
	
		},
	
		triangulateShape: function ( contour, holes ) {
	
			var shapeWithoutHoles = THREE.Shape.Utils.removeHoles( contour, holes );
	
			var shape = shapeWithoutHoles.shape,
				allpoints = shapeWithoutHoles.allpoints,
				isolatedPts = shapeWithoutHoles.isolatedPts;
	
			var triangles = THREE.FontUtils.Triangulate( shape, false ); // True returns indices for points of spooled shape
	
			// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.
	
			//console.log( "triangles",triangles, triangles.length );
			//console.log( "allpoints",allpoints, allpoints.length );
	
			var i, il, f, face,
				key, index,
				allPointsMap = {},
				isolatedPointsMap = {};
	
			// prepare all points map
	
			for ( i = 0, il = allpoints.length; i < il; i ++ ) {
	
				key = allpoints[ i ].x + ":" + allpoints[ i ].y;
	
				if ( allPointsMap[ key ] !== undefined ) {
	
					console.log( "Duplicate point", key );
	
				}
	
				allPointsMap[ key ] = i;
	
			}
	
			// check all face vertices against all points map
	
			for ( i = 0, il = triangles.length; i < il; i ++ ) {
	
				face = triangles[ i ];
	
				for ( f = 0; f < 3; f ++ ) {
	
					key = face[ f ].x + ":" + face[ f ].y;
	
					index = allPointsMap[ key ];
	
					if ( index !== undefined ) {
	
						face[ f ] = index;
	
					}
	
				}
	
			}
	
			// check isolated points vertices against all points map
	
			for ( i = 0, il = isolatedPts.length; i < il; i ++ ) {
	
				face = isolatedPts[ i ];
	
				for ( f = 0; f < 3; f ++ ) {
	
					key = face[ f ].x + ":" + face[ f ].y;
	
					index = allPointsMap[ key ];
	
					if ( index !== undefined ) {
	
						face[ f ] = index;
	
					}
	
				}
	
			}
	
			return triangles.concat( isolatedPts );
	
		}, // end triangulate shapes
	
		/*
		triangulate2 : function( pts, holes ) {
	
			// For use with Poly2Tri.js
	
			var allpts = pts.concat();
			var shape = [];
			for (var p in pts) {
				shape.push(new js.poly2tri.Point(pts[p].x, pts[p].y));
			}
	
			var swctx = new js.poly2tri.SweepContext(shape);
	
			for (var h in holes) {
				var aHole = holes[h];
				var newHole = []
				for (i in aHole) {
					newHole.push(new js.poly2tri.Point(aHole[i].x, aHole[i].y));
					allpts.push(aHole[i]);
				}
				swctx.AddHole(newHole);
			}
	
			var find;
			var findIndexForPt = function (pt) {
				find = new THREE.Vector2(pt.x, pt.y);
				var p;
				for (p=0, pl = allpts.length; p<pl; p++) {
					if (allpts[p].equals(find)) return p;
				}
				return -1;
			};
	
			// triangulate
			js.poly2tri.sweep.Triangulate(swctx);
	
			var triangles =  swctx.GetTriangles();
			var tr ;
			var facesPts = [];
			for (var t in triangles) {
				tr =  triangles[t];
				facesPts.push([
					findIndexForPt(tr.GetPoint(0)),
					findIndexForPt(tr.GetPoint(1)),
					findIndexForPt(tr.GetPoint(2))
						]);
			}
	
	
		//	console.log(facesPts);
		//	console.log("triangles", triangles.length, triangles);
	
			// Returns array of faces with 3 element each
		return facesPts;
		},
	*/
	
		isClockWise: function ( pts ) {
	
			return THREE.FontUtils.Triangulate.area( pts ) < 0;
	
		},
	
		// Bezier Curves formulas obtained from
		// http://en.wikipedia.org/wiki/B%C3%A9zier_curve
	
		// Quad Bezier Functions
	
		b2p0: function ( t, p ) {
	
			var k = 1 - t;
			return k * k * p;
	
		},
	
		b2p1: function ( t, p ) {
	
			return 2 * ( 1 - t ) * t * p;
	
		},
	
		b2p2: function ( t, p ) {
	
			return t * t * p;
	
		},
	
		b2: function ( t, p0, p1, p2 ) {
	
			return this.b2p0( t, p0 ) + this.b2p1( t, p1 ) + this.b2p2( t, p2 );
	
		},
	
		// Cubic Bezier Functions
	
		b3p0: function ( t, p ) {
	
			var k = 1 - t;
			return k * k * k * p;
	
		},
	
		b3p1: function ( t, p ) {
	
			var k = 1 - t;
			return 3 * k * k * t * p;
	
		},
	
		b3p2: function ( t, p ) {
	
			var k = 1 - t;
			return 3 * k * t * t * p;
	
		},
	
		b3p3: function ( t, p ) {
	
			return t * t * t * p;
	
		},
	
		b3: function ( t, p0, p1, p2, p3 ) {
	
			return this.b3p0( t, p0 ) + this.b3p1( t, p1 ) + this.b3p2( t, p2 ) +  this.b3p3( t, p3 );
	
		}
	
	};
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 */
	
	THREE.AnimationHandler = (function() {
	
		var playing = [];
		var library = {};
		var that    = {};
	
	
		//--- update ---
	
		that.update = function( deltaTimeMS ) {
	
			for( var i = 0; i < playing.length; i ++ )
				playing[ i ].update( deltaTimeMS );
	
		};
	
	
		//--- add ---
	
		that.addToUpdate = function( animation ) {
	
			if ( playing.indexOf( animation ) === -1 )
				playing.push( animation );
	
		};
	
	
		//--- remove ---
	
		that.removeFromUpdate = function( animation ) {
	
			var index = playing.indexOf( animation );
	
			if( index !== -1 )
				playing.splice( index, 1 );
	
		};
	
	
		//--- add ---
	
		that.add = function( data ) {
	
			if ( library[ data.name ] !== undefined )
				console.log( "THREE.AnimationHandler.add: Warning! " + data.name + " already exists in library. Overwriting." );
	
			library[ data.name ] = data;
			initData( data );
	
		};
	
	
		//--- get ---
	
		that.get = function( name ) {
	
			if ( typeof name === "string" ) {
	
				if ( library[ name ] ) {
	
					return library[ name ];
	
				} else {
	
					console.log( "THREE.AnimationHandler.get: Couldn't find animation " + name );
					return null;
	
				}
	
			} else {
	
				// todo: add simple tween library
	
			}
	
		};
	
		//--- parse ---
	
		that.parse = function( root ) {
	
			// setup hierarchy
	
			var hierarchy = [];
	
			if ( root instanceof THREE.SkinnedMesh ) {
	
				for( var b = 0; b < root.bones.length; b++ ) {
	
					hierarchy.push( root.bones[ b ] );
	
				}
	
			} else {
	
				parseRecurseHierarchy( root, hierarchy );
	
			}
	
			return hierarchy;
	
		};
	
		var parseRecurseHierarchy = function( root, hierarchy ) {
	
			hierarchy.push( root );
	
			for( var c = 0; c < root.children.length; c++ )
				parseRecurseHierarchy( root.children[ c ], hierarchy );
	
		}
	
	
		//--- init data ---
	
		var initData = function( data ) {
	
			if( data.initialized === true )
				return;
	
	
			// loop through all keys
	
			for( var h = 0; h < data.hierarchy.length; h ++ ) {
	
				for( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {
	
					// remove minus times
	
					if( data.hierarchy[ h ].keys[ k ].time < 0 )
						data.hierarchy[ h ].keys[ k ].time = 0;
	
	
					// create quaternions
	
					if( data.hierarchy[ h ].keys[ k ].rot !== undefined &&
					 !( data.hierarchy[ h ].keys[ k ].rot instanceof THREE.Quaternion ) ) {
	
						var quat = data.hierarchy[ h ].keys[ k ].rot;
						data.hierarchy[ h ].keys[ k ].rot = new THREE.Quaternion( quat[0], quat[1], quat[2], quat[3] );
	
					}
	
				}
	
	
				// prepare morph target keys
	
				if( data.hierarchy[ h ].keys.length && data.hierarchy[ h ].keys[ 0 ].morphTargets !== undefined ) {
	
					// get all used
	
					var usedMorphTargets = {};
	
					for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {
	
						for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {
	
							var morphTargetName = data.hierarchy[ h ].keys[ k ].morphTargets[ m ];
							usedMorphTargets[ morphTargetName ] = -1;
	
						}
	
					}
	
					data.hierarchy[ h ].usedMorphTargets = usedMorphTargets;
	
	
					// set all used on all frames
	
					for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {
	
						var influences = {};
	
						for ( var morphTargetName in usedMorphTargets ) {
	
							for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {
	
								if ( data.hierarchy[ h ].keys[ k ].morphTargets[ m ] === morphTargetName ) {
	
									influences[ morphTargetName ] = data.hierarchy[ h ].keys[ k ].morphTargetsInfluences[ m ];
									break;
	
								}
	
							}
	
							if ( m === data.hierarchy[ h ].keys[ k ].morphTargets.length ) {
	
								influences[ morphTargetName ] = 0;
	
							}
	
						}
	
						data.hierarchy[ h ].keys[ k ].morphTargetsInfluences = influences;
	
					}
	
				}
	
	
				// remove all keys that are on the same time
	
				for ( var k = 1; k < data.hierarchy[ h ].keys.length; k ++ ) {
	
					if ( data.hierarchy[ h ].keys[ k ].time === data.hierarchy[ h ].keys[ k - 1 ].time ) {
	
						data.hierarchy[ h ].keys.splice( k, 1 );
						k --;
	
					}
	
				}
	
	
				// set index
	
				for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {
	
					data.hierarchy[ h ].keys[ k ].index = k;
	
				}
	
			}
	
	
			// JIT
	
			var lengthInFrames = parseInt( data.length * data.fps, 10 );
	
			data.JIT = {};
			data.JIT.hierarchy = [];
	
			for( var h = 0; h < data.hierarchy.length; h ++ )
				data.JIT.hierarchy.push( new Array( lengthInFrames ) );
	
	
			// done
	
			data.initialized = true;
	
		};
	
	
		// interpolation types
	
		that.LINEAR = 0;
		that.CATMULLROM = 1;
		that.CATMULLROM_FORWARD = 2;
	
		return that;
	
	}());
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.Animation = function ( root, name, interpolationType ) {
	
		this.root = root;
		this.data = THREE.AnimationHandler.get( name );
		this.hierarchy = THREE.AnimationHandler.parse( root );
	
		this.currentTime = 0;
		this.timeScale = 1;
	
		this.isPlaying = false;
		this.isPaused = true;
		this.loop = true;
	
		this.interpolationType = interpolationType !== undefined ? interpolationType : THREE.AnimationHandler.LINEAR;
	
		this.points = [];
		this.target = new THREE.Vector3();
	
	};
	
	THREE.Animation.prototype.play = function ( loop, startTimeMS ) {
	
		if ( this.isPlaying === false ) {
	
			this.isPlaying = true;
			this.loop = loop !== undefined ? loop : true;
			this.currentTime = startTimeMS !== undefined ? startTimeMS : 0;
	
			// reset key cache
	
			var h, hl = this.hierarchy.length,
				object;
	
			for ( h = 0; h < hl; h ++ ) {
	
				object = this.hierarchy[ h ];
	
				if ( this.interpolationType !== THREE.AnimationHandler.CATMULLROM_FORWARD ) {
	
					object.useQuaternion = true;
	
				}
	
				object.matrixAutoUpdate = true;
	
				if ( object.animationCache === undefined ) {
	
					object.animationCache = {};
					object.animationCache.prevKey = { pos: 0, rot: 0, scl: 0 };
					object.animationCache.nextKey = { pos: 0, rot: 0, scl: 0 };
					object.animationCache.originalMatrix = object instanceof THREE.Bone ? object.skinMatrix : object.matrix;
	
				}
	
				var prevKey = object.animationCache.prevKey;
				var nextKey = object.animationCache.nextKey;
	
				prevKey.pos = this.data.hierarchy[ h ].keys[ 0 ];
				prevKey.rot = this.data.hierarchy[ h ].keys[ 0 ];
				prevKey.scl = this.data.hierarchy[ h ].keys[ 0 ];
	
				nextKey.pos = this.getNextKeyWith( "pos", h, 1 );
				nextKey.rot = this.getNextKeyWith( "rot", h, 1 );
				nextKey.scl = this.getNextKeyWith( "scl", h, 1 );
	
			}
	
			this.update( 0 );
	
		}
	
		this.isPaused = false;
	
		THREE.AnimationHandler.addToUpdate( this );
	
	};
	
	
	THREE.Animation.prototype.pause = function() {
	
		if ( this.isPaused === true ) {
	
			THREE.AnimationHandler.addToUpdate( this );
	
		} else {
	
			THREE.AnimationHandler.removeFromUpdate( this );
	
		}
	
		this.isPaused = !this.isPaused;
	
	};
	
	
	THREE.Animation.prototype.stop = function() {
	
		this.isPlaying = false;
		this.isPaused  = false;
		THREE.AnimationHandler.removeFromUpdate( this );
	
	};
	
	
	THREE.Animation.prototype.update = function ( deltaTimeMS ) {
	
		// early out
	
		if ( this.isPlaying === false ) return;
	
	
		// vars
	
		var types = [ "pos", "rot", "scl" ];
		var type;
		var scale;
		var vector;
		var prevXYZ, nextXYZ;
		var prevKey, nextKey;
		var object;
		var animationCache;
		var frame;
		var JIThierarchy = this.data.JIT.hierarchy;
		var currentTime, unloopedCurrentTime;
		var currentPoint, forwardPoint, angle;
	
	
		this.currentTime += deltaTimeMS * this.timeScale;
	
		unloopedCurrentTime = this.currentTime;
		currentTime = this.currentTime = this.currentTime % this.data.length;
		frame = parseInt( Math.min( currentTime * this.data.fps, this.data.length * this.data.fps ), 10 );
	
	
		for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {
	
			object = this.hierarchy[ h ];
			animationCache = object.animationCache;
	
			// loop through pos/rot/scl
	
			for ( var t = 0; t < 3; t ++ ) {
	
				// get keys
	
				type    = types[ t ];
				prevKey = animationCache.prevKey[ type ];
				nextKey = animationCache.nextKey[ type ];
	
				// switch keys?
	
				if ( nextKey.time <= unloopedCurrentTime ) {
	
					// did we loop?
	
					if ( currentTime < unloopedCurrentTime ) {
	
						if ( this.loop ) {
	
							prevKey = this.data.hierarchy[ h ].keys[ 0 ];
							nextKey = this.getNextKeyWith( type, h, 1 );
	
							while( nextKey.time < currentTime ) {
	
								prevKey = nextKey;
								nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );
	
							}
	
						} else {
	
							this.stop();
							return;
	
						}
	
					} else {
	
						do {
	
							prevKey = nextKey;
							nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );
	
						} while( nextKey.time < currentTime )
	
					}
	
					animationCache.prevKey[ type ] = prevKey;
					animationCache.nextKey[ type ] = nextKey;
	
				}
	
	
				object.matrixAutoUpdate = true;
				object.matrixWorldNeedsUpdate = true;
	
				scale = ( currentTime - prevKey.time ) / ( nextKey.time - prevKey.time );
				prevXYZ = prevKey[ type ];
				nextXYZ = nextKey[ type ];
	
	
				// check scale error
	
				if ( scale < 0 || scale > 1 ) {
	
					console.log( "THREE.Animation.update: Warning! Scale out of bounds:" + scale + " on bone " + h );
					scale = scale < 0 ? 0 : 1;
	
				}
	
				// interpolate
	
				if ( type === "pos" ) {
	
					vector = object.position;
	
					if ( this.interpolationType === THREE.AnimationHandler.LINEAR ) {
	
						vector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
						vector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
						vector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;
	
					} else if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
							    this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {
	
						this.points[ 0 ] = this.getPrevKeyWith( "pos", h, prevKey.index - 1 )[ "pos" ];
						this.points[ 1 ] = prevXYZ;
						this.points[ 2 ] = nextXYZ;
						this.points[ 3 ] = this.getNextKeyWith( "pos", h, nextKey.index + 1 )[ "pos" ];
	
						scale = scale * 0.33 + 0.33;
	
						currentPoint = this.interpolateCatmullRom( this.points, scale );
	
						vector.x = currentPoint[ 0 ];
						vector.y = currentPoint[ 1 ];
						vector.z = currentPoint[ 2 ];
	
						if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {
	
							forwardPoint = this.interpolateCatmullRom( this.points, scale * 1.01 );
	
							this.target.set( forwardPoint[ 0 ], forwardPoint[ 1 ], forwardPoint[ 2 ] );
							this.target.sub( vector );
							this.target.y = 0;
							this.target.normalize();
	
							angle = Math.atan2( this.target.x, this.target.z );
							object.rotation.set( 0, angle, 0 );
	
						}
	
					}
	
				} else if ( type === "rot" ) {
	
					THREE.Quaternion.slerp( prevXYZ, nextXYZ, object.quaternion, scale );
	
				} else if ( type === "scl" ) {
	
					vector = object.scale;
	
					vector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
					vector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
					vector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;
	
				}
	
			}
	
		}
	
	};
	
	// Catmull-Rom spline
	
	THREE.Animation.prototype.interpolateCatmullRom = function ( points, scale ) {
	
		var c = [], v3 = [],
		point, intPoint, weight, w2, w3,
		pa, pb, pc, pd;
	
		point = ( points.length - 1 ) * scale;
		intPoint = Math.floor( point );
		weight = point - intPoint;
	
		c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
		c[ 1 ] = intPoint;
		c[ 2 ] = intPoint > points.length - 2 ? intPoint : intPoint + 1;
		c[ 3 ] = intPoint > points.length - 3 ? intPoint : intPoint + 2;
	
		pa = points[ c[ 0 ] ];
		pb = points[ c[ 1 ] ];
		pc = points[ c[ 2 ] ];
		pd = points[ c[ 3 ] ];
	
		w2 = weight * weight;
		w3 = weight * w2;
	
		v3[ 0 ] = this.interpolate( pa[ 0 ], pb[ 0 ], pc[ 0 ], pd[ 0 ], weight, w2, w3 );
		v3[ 1 ] = this.interpolate( pa[ 1 ], pb[ 1 ], pc[ 1 ], pd[ 1 ], weight, w2, w3 );
		v3[ 2 ] = this.interpolate( pa[ 2 ], pb[ 2 ], pc[ 2 ], pd[ 2 ], weight, w2, w3 );
	
		return v3;
	
	};
	
	THREE.Animation.prototype.interpolate = function ( p0, p1, p2, p3, t, t2, t3 ) {
	
		var v0 = ( p2 - p0 ) * 0.5,
			v1 = ( p3 - p1 ) * 0.5;
	
		return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;
	
	};
	
	
	
	// Get next key with
	
	THREE.Animation.prototype.getNextKeyWith = function ( type, h, key ) {
	
		var keys = this.data.hierarchy[ h ].keys;
	
		if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
			 this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {
	
			key = key < keys.length - 1 ? key : keys.length - 1;
	
		} else {
	
			key = key % keys.length;
	
		}
	
		for ( ; key < keys.length; key++ ) {
	
			if ( keys[ key ][ type ] !== undefined ) {
	
				return keys[ key ];
	
			}
	
		}
	
		return this.data.hierarchy[ h ].keys[ 0 ];
	
	};
	
	// Get previous key with
	
	THREE.Animation.prototype.getPrevKeyWith = function ( type, h, key ) {
	
		var keys = this.data.hierarchy[ h ].keys;
	
		if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
			 this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {
	
			key = key > 0 ? key : 0;
	
		} else {
	
			key = key >= 0 ? key : key + keys.length;
	
		}
	
	
		for ( ; key >= 0; key -- ) {
	
			if ( keys[ key ][ type ] !== undefined ) {
	
				return keys[ key ];
	
			}
	
		}
	
		return this.data.hierarchy[ h ].keys[ keys.length - 1 ];
	
	};
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author khang duong
	 * @author erik kitson
	 */
	
	THREE.KeyFrameAnimation = function( root, data, JITCompile ) {
	
		this.root = root;
		this.data = THREE.AnimationHandler.get( data );
		this.hierarchy = THREE.AnimationHandler.parse( root );
		this.currentTime = 0;
		this.timeScale = 0.001;
		this.isPlaying = false;
		this.isPaused = true;
		this.loop = true;
		this.JITCompile = JITCompile !== undefined ? JITCompile : true;
	
		// initialize to first keyframes
	
		for ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {
	
			var keys = this.data.hierarchy[h].keys,
				sids = this.data.hierarchy[h].sids,
				obj = this.hierarchy[h];
	
			if ( keys.length && sids ) {
	
				for ( var s = 0; s < sids.length; s++ ) {
	
					var sid = sids[ s ],
						next = this.getNextKeyWith( sid, h, 0 );
	
					if ( next ) {
	
						next.apply( sid );
	
					}
	
				}
	
				obj.matrixAutoUpdate = false;
				this.data.hierarchy[h].node.updateMatrix();
				obj.matrixWorldNeedsUpdate = true;
	
			}
	
		}
	
	};
	
	// Play
	
	THREE.KeyFrameAnimation.prototype.play = function( loop, startTimeMS ) {
	
		if( !this.isPlaying ) {
	
			this.isPlaying = true;
			this.loop = loop !== undefined ? loop : true;
			this.currentTime = startTimeMS !== undefined ? startTimeMS : 0;
			this.startTimeMs = startTimeMS;
			this.startTime = 10000000;
			this.endTime = -this.startTime;
	
	
			// reset key cache
	
			var h, hl = this.hierarchy.length,
				object,
				node;
	
			for ( h = 0; h < hl; h++ ) {
	
				object = this.hierarchy[ h ];
				node = this.data.hierarchy[ h ];
				object.useQuaternion = true;
	
				if ( node.animationCache === undefined ) {
	
					node.animationCache = {};
					node.animationCache.prevKey = null;
					node.animationCache.nextKey = null;
					node.animationCache.originalMatrix = object instanceof THREE.Bone ? object.skinMatrix : object.matrix;
	
				}
	
				var keys = this.data.hierarchy[h].keys;
	
				if (keys.length) {
	
					node.animationCache.prevKey = keys[ 0 ];
					node.animationCache.nextKey = keys[ 1 ];
	
					this.startTime = Math.min( keys[0].time, this.startTime );
					this.endTime = Math.max( keys[keys.length - 1].time, this.endTime );
	
				}
	
			}
	
			this.update( 0 );
	
		}
	
		this.isPaused = false;
	
		THREE.AnimationHandler.addToUpdate( this );
	
	};
	
	
	
	// Pause
	
	THREE.KeyFrameAnimation.prototype.pause = function() {
	
		if( this.isPaused ) {
	
			THREE.AnimationHandler.addToUpdate( this );
	
		} else {
	
			THREE.AnimationHandler.removeFromUpdate( this );
	
		}
	
		this.isPaused = !this.isPaused;
	
	};
	
	
	// Stop
	
	THREE.KeyFrameAnimation.prototype.stop = function() {
	
		this.isPlaying = false;
		this.isPaused  = false;
		THREE.AnimationHandler.removeFromUpdate( this );
	
	
		// reset JIT matrix and remove cache
	
		for ( var h = 0; h < this.data.hierarchy.length; h++ ) {
	        
	        var obj = this.hierarchy[ h ];
			var node = this.data.hierarchy[ h ];
	
			if ( node.animationCache !== undefined ) {
	
				var original = node.animationCache.originalMatrix;
	
				if( obj instanceof THREE.Bone ) {
	
					original.copy( obj.skinMatrix );
					obj.skinMatrix = original;
	
				} else {
	
					original.copy( obj.matrix );
					obj.matrix = original;
	
				}
	
				delete node.animationCache;
	
			}
	
		}
	
	};
	
	
	// Update
	
	THREE.KeyFrameAnimation.prototype.update = function( deltaTimeMS ) {
	
		// early out
	
		if( !this.isPlaying ) return;
	
	
		// vars
	
		var prevKey, nextKey;
		var object;
		var node;
		var frame;
		var JIThierarchy = this.data.JIT.hierarchy;
		var currentTime, unloopedCurrentTime;
		var looped;
	
	
		// update
	
		this.currentTime += deltaTimeMS * this.timeScale;
	
		unloopedCurrentTime = this.currentTime;
		currentTime         = this.currentTime = this.currentTime % this.data.length;
	
		// if looped around, the current time should be based on the startTime
		if ( currentTime < this.startTimeMs ) {
	
			currentTime = this.currentTime = this.startTimeMs + currentTime;
	
		}
	
		frame               = parseInt( Math.min( currentTime * this.data.fps, this.data.length * this.data.fps ), 10 );
		looped 				= currentTime < unloopedCurrentTime;
	
		if ( looped && !this.loop ) {
	
			// Set the animation to the last keyframes and stop
			for ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {
	
				var keys = this.data.hierarchy[h].keys,
					sids = this.data.hierarchy[h].sids,
					end = keys.length-1,
					obj = this.hierarchy[h];
	
				if ( keys.length ) {
	
					for ( var s = 0; s < sids.length; s++ ) {
	
						var sid = sids[ s ],
							prev = this.getPrevKeyWith( sid, h, end );
	
						if ( prev ) {
							prev.apply( sid );
	
						}
	
					}
	
					this.data.hierarchy[h].node.updateMatrix();
					obj.matrixWorldNeedsUpdate = true;
	
				}
	
			}
	
			this.stop();
			return;
	
		}
	
		// check pre-infinity
		if ( currentTime < this.startTime ) {
	
			return;
	
		}
	
		// update
	
		for ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {
	
			object = this.hierarchy[ h ];
			node = this.data.hierarchy[ h ];
	
			var keys = node.keys,
				animationCache = node.animationCache;
	
			// use JIT?
	
			if ( this.JITCompile && JIThierarchy[ h ][ frame ] !== undefined ) {
	
				if( object instanceof THREE.Bone ) {
	
					object.skinMatrix = JIThierarchy[ h ][ frame ];
					object.matrixWorldNeedsUpdate = false;
	
				} else {
	
					object.matrix = JIThierarchy[ h ][ frame ];
					object.matrixWorldNeedsUpdate = true;
	
				}
	
			// use interpolation
	
			} else if ( keys.length ) {
	
				// make sure so original matrix and not JIT matrix is set
	
				if ( this.JITCompile && animationCache ) {
	
					if( object instanceof THREE.Bone ) {
	
						object.skinMatrix = animationCache.originalMatrix;
	
					} else {
	
						object.matrix = animationCache.originalMatrix;
	
					}
	
				}
	
				prevKey = animationCache.prevKey;
				nextKey = animationCache.nextKey;
	
				if ( prevKey && nextKey ) {
	
					// switch keys?
	
					if ( nextKey.time <= unloopedCurrentTime ) {
	
						// did we loop?
	
						if ( looped && this.loop ) {
	
							prevKey = keys[ 0 ];
							nextKey = keys[ 1 ];
	
							while ( nextKey.time < currentTime ) {
	
								prevKey = nextKey;
								nextKey = keys[ prevKey.index + 1 ];
	
							}
	
						} else if ( !looped ) {
	
							var lastIndex = keys.length - 1;
	
							while ( nextKey.time < currentTime && nextKey.index !== lastIndex ) {
	
								prevKey = nextKey;
								nextKey = keys[ prevKey.index + 1 ];
	
							}
	
						}
	
						animationCache.prevKey = prevKey;
						animationCache.nextKey = nextKey;
	
					}
	                if(nextKey.time >= currentTime)
	                    prevKey.interpolate( nextKey, currentTime );
	                else
	                    prevKey.interpolate( nextKey, nextKey.time);
	
				}
	
				this.data.hierarchy[h].node.updateMatrix();
				object.matrixWorldNeedsUpdate = true;
	
			}
	
		}
	
		// update JIT?
	
		if ( this.JITCompile ) {
	
			if ( JIThierarchy[ 0 ][ frame ] === undefined ) {
	
				this.hierarchy[ 0 ].updateMatrixWorld( true );
	
				for ( var h = 0; h < this.hierarchy.length; h++ ) {
	
					if( this.hierarchy[ h ] instanceof THREE.Bone ) {
	
						JIThierarchy[ h ][ frame ] = this.hierarchy[ h ].skinMatrix.clone();
	
					} else {
	
						JIThierarchy[ h ][ frame ] = this.hierarchy[ h ].matrix.clone();
	
					}
	
				}
	
			}
	
		}
	
	};
	
	// Get next key with
	
	THREE.KeyFrameAnimation.prototype.getNextKeyWith = function( sid, h, key ) {
	
		var keys = this.data.hierarchy[ h ].keys;
		key = key % keys.length;
	
		for ( ; key < keys.length; key++ ) {
	
			if ( keys[ key ].hasTarget( sid ) ) {
	
				return keys[ key ];
	
			}
	
		}
	
		return keys[ 0 ];
	
	};
	
	// Get previous key with
	
	THREE.KeyFrameAnimation.prototype.getPrevKeyWith = function( sid, h, key ) {
	
		var keys = this.data.hierarchy[ h ].keys;
		key = key >= 0 ? key : key + keys.length;
	
		for ( ; key >= 0; key-- ) {
	
			if ( keys[ key ].hasTarget( sid ) ) {
	
				return keys[ key ];
	
			}
	
		}
	
		return keys[ keys.length - 1 ];
	
	};
	/**
	 * Camera for rendering cube maps
	 *	- renders scene into axis-aligned cube
	 *
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.CubeCamera = function ( near, far, cubeResolution ) {
	
		THREE.Object3D.call( this );
	
		var fov = 90, aspect = 1;
	
		var cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraPX.up.set( 0, -1, 0 );
		cameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );
		this.add( cameraPX );
	
		var cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraNX.up.set( 0, -1, 0 );
		cameraNX.lookAt( new THREE.Vector3( -1, 0, 0 ) );
		this.add( cameraNX );
	
		var cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraPY.up.set( 0, 0, 1 );
		cameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );
		this.add( cameraPY );
	
		var cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraNY.up.set( 0, 0, -1 );
		cameraNY.lookAt( new THREE.Vector3( 0, -1, 0 ) );
		this.add( cameraNY );
	
		var cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraPZ.up.set( 0, -1, 0 );
		cameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );
		this.add( cameraPZ );
	
		var cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
		cameraNZ.up.set( 0, -1, 0 );
		cameraNZ.lookAt( new THREE.Vector3( 0, 0, -1 ) );
		this.add( cameraNZ );
	
		this.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter } );
	
		this.updateCubeMap = function ( renderer, scene ) {
	
			var renderTarget = this.renderTarget;
			var generateMipmaps = renderTarget.generateMipmaps;
	
			renderTarget.generateMipmaps = false;
	
			renderTarget.activeCubeFace = 0;
			renderer.render( scene, cameraPX, renderTarget );
	
			renderTarget.activeCubeFace = 1;
			renderer.render( scene, cameraNX, renderTarget );
	
			renderTarget.activeCubeFace = 2;
			renderer.render( scene, cameraPY, renderTarget );
	
			renderTarget.activeCubeFace = 3;
			renderer.render( scene, cameraNY, renderTarget );
	
			renderTarget.activeCubeFace = 4;
			renderer.render( scene, cameraPZ, renderTarget );
	
			renderTarget.generateMipmaps = generateMipmaps;
	
			renderTarget.activeCubeFace = 5;
			renderer.render( scene, cameraNZ, renderTarget );
	
		};
	
	};
	
	THREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );
	/*
	 *	@author zz85 / http://twitter.com/blurspline / http://www.lab4games.net/zz85/blog
	 *
	 *	A general perpose camera, for setting FOV, Lens Focal Length,
	 *		and switching between perspective and orthographic views easily.
	 *		Use this only if you do not wish to manage
	 *		both a Orthographic and Perspective Camera
	 *
	 */
	
	
	THREE.CombinedCamera = function ( width, height, fov, near, far, orthoNear, orthoFar ) {
	
		THREE.Camera.call( this );
	
		this.fov = fov;
	
		this.left = -width / 2;
		this.right = width / 2
		this.top = height / 2;
		this.bottom = -height / 2;
	
		// We could also handle the projectionMatrix internally, but just wanted to test nested camera objects
	
		this.cameraO = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 	orthoNear, orthoFar );
		this.cameraP = new THREE.PerspectiveCamera( fov, width / height, near, far );
	
		this.zoom = 1;
	
		this.toPerspective();
	
		var aspect = width/height;
	
	};
	
	THREE.CombinedCamera.prototype = Object.create( THREE.Camera.prototype );
	
	THREE.CombinedCamera.prototype.toPerspective = function () {
	
		// Switches to the Perspective Camera
	
		this.near = this.cameraP.near;
		this.far = this.cameraP.far;
	
		this.cameraP.fov =  this.fov / this.zoom ;
	
		this.cameraP.updateProjectionMatrix();
	
		this.projectionMatrix = this.cameraP.projectionMatrix;
	
		this.inPerspectiveMode = true;
		this.inOrthographicMode = false;
	
	};
	
	THREE.CombinedCamera.prototype.toOrthographic = function () {
	
		// Switches to the Orthographic camera estimating viewport from Perspective
	
		var fov = this.fov;
		var aspect = this.cameraP.aspect;
		var near = this.cameraP.near;
		var far = this.cameraP.far;
	
		// The size that we set is the mid plane of the viewing frustum
	
		var hyperfocus = ( near + far ) / 2;
	
		var halfHeight = Math.tan( fov / 2 ) * hyperfocus;
		var planeHeight = 2 * halfHeight;
		var planeWidth = planeHeight * aspect;
		var halfWidth = planeWidth / 2;
	
		halfHeight /= this.zoom;
		halfWidth /= this.zoom;
	
		this.cameraO.left = -halfWidth;
		this.cameraO.right = halfWidth;
		this.cameraO.top = halfHeight;
		this.cameraO.bottom = -halfHeight;
	
		// this.cameraO.left = -farHalfWidth;
		// this.cameraO.right = farHalfWidth;
		// this.cameraO.top = farHalfHeight;
		// this.cameraO.bottom = -farHalfHeight;
	
		// this.cameraO.left = this.left / this.zoom;
		// this.cameraO.right = this.right / this.zoom;
		// this.cameraO.top = this.top / this.zoom;
		// this.cameraO.bottom = this.bottom / this.zoom;
	
		this.cameraO.updateProjectionMatrix();
	
		this.near = this.cameraO.near;
		this.far = this.cameraO.far;
		this.projectionMatrix = this.cameraO.projectionMatrix;
	
		this.inPerspectiveMode = false;
		this.inOrthographicMode = true;
	
	};
	
	
	THREE.CombinedCamera.prototype.setSize = function( width, height ) {
	
		this.cameraP.aspect = width / height;
		this.left = -width / 2;
		this.right = width / 2
		this.top = height / 2;
		this.bottom = -height / 2;
	
	};
	
	
	THREE.CombinedCamera.prototype.setFov = function( fov ) {
	
		this.fov = fov;
	
		if ( this.inPerspectiveMode ) {
	
			this.toPerspective();
	
		} else {
	
			this.toOrthographic();
	
		}
	
	};
	
	// For mantaining similar API with PerspectiveCamera
	
	THREE.CombinedCamera.prototype.updateProjectionMatrix = function() {
	
		if ( this.inPerspectiveMode ) {
	
			this.toPerspective();
	
		} else {
	
			this.toPerspective();
			this.toOrthographic();
	
		}
	
	};
	
	/*
	* Uses Focal Length (in mm) to estimate and set FOV
	* 35mm (fullframe) camera is used if frame size is not specified;
	* Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
	*/
	THREE.CombinedCamera.prototype.setLens = function ( focalLength, frameHeight ) {
	
		if ( frameHeight === undefined ) frameHeight = 24;
	
		var fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );
	
		this.setFov( fov );
	
		return fov;
	};
	
	
	THREE.CombinedCamera.prototype.setZoom = function( zoom ) {
	
		this.zoom = zoom;
	
		if ( this.inPerspectiveMode ) {
	
			this.toPerspective();
	
		} else {
	
			this.toOrthographic();
	
		}
	
	};
	
	THREE.CombinedCamera.prototype.toFrontView = function() {
	
		this.rotation.x = 0;
		this.rotation.y = 0;
		this.rotation.z = 0;
	
		// should we be modifing the matrix instead?
	
		this.rotationAutoUpdate = false;
	
	};
	
	THREE.CombinedCamera.prototype.toBackView = function() {
	
		this.rotation.x = 0;
		this.rotation.y = Math.PI;
		this.rotation.z = 0;
		this.rotationAutoUpdate = false;
	
	};
	
	THREE.CombinedCamera.prototype.toLeftView = function() {
	
		this.rotation.x = 0;
		this.rotation.y = - Math.PI / 2;
		this.rotation.z = 0;
		this.rotationAutoUpdate = false;
	
	};
	
	THREE.CombinedCamera.prototype.toRightView = function() {
	
		this.rotation.x = 0;
		this.rotation.y = Math.PI / 2;
		this.rotation.z = 0;
		this.rotationAutoUpdate = false;
	
	};
	
	THREE.CombinedCamera.prototype.toTopView = function() {
	
		this.rotation.x = - Math.PI / 2;
		this.rotation.y = 0;
		this.rotation.z = 0;
		this.rotationAutoUpdate = false;
	
	};
	
	THREE.CombinedCamera.prototype.toBottomView = function() {
	
		this.rotation.x = Math.PI / 2;
		this.rotation.y = 0;
		this.rotation.z = 0;
		this.rotationAutoUpdate = false;
	
	};
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 *	- 3d asterisk shape (for line pieces THREE.Line)
	 */
	
	THREE.AsteriskGeometry = function ( innerRadius, outerRadius ) {
	
		THREE.Geometry.call( this );
	
		var sd = innerRadius;
		var ed = outerRadius;
	
		var sd2 = 0.707 * sd;
		var ed2 = 0.707 * ed;
	
		var rays = [ [ sd, 0, 0 ], [ ed, 0, 0 ], [ -sd, 0, 0 ], [ -ed, 0, 0 ],
					 [ 0, sd, 0 ], [ 0, ed, 0 ], [ 0, -sd, 0 ], [ 0, -ed, 0 ],
					 [ 0, 0, sd ], [ 0, 0, ed ], [ 0, 0, -sd ], [ 0, 0, -ed ],
					 [ sd2, sd2, 0 ], [ ed2, ed2, 0 ], [ -sd2, -sd2, 0 ], [ -ed2, -ed2, 0 ],
					 [ sd2, -sd2, 0 ], [ ed2, -ed2, 0 ], [ -sd2, sd2, 0 ], [ -ed2, ed2, 0 ],
					 [ sd2, 0, sd2 ], [ ed2, 0, ed2 ], [ -sd2, 0, -sd2 ], [ -ed2, 0, -ed2 ],
					 [ sd2, 0, -sd2 ], [ ed2, 0, -ed2 ], [ -sd2, 0, sd2 ], [ -ed2, 0, ed2 ],
					 [ 0, sd2, sd2 ], [ 0, ed2, ed2 ], [ 0, -sd2, -sd2 ], [ 0, -ed2, -ed2 ],
					 [ 0, sd2, -sd2 ], [ 0, ed2, -ed2 ], [ 0, -sd2, sd2 ], [ 0, -ed2, ed2 ]
		];
	
		for ( var i = 0, il = rays.length; i < il; i ++ ) {
	
			var x = rays[ i ][ 0 ];
			var y = rays[ i ][ 1 ];
			var z = rays[ i ][ 2 ];
	
			this.vertices.push( new THREE.Vector3( x, y, z ) );
	
		}
	
	};
	
	THREE.AsteriskGeometry.prototype = Object.create( THREE.Geometry.prototype );/**
	 * @author hughes
	 */
	
	THREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {
	
	    THREE.Geometry.call( this );
	
	    radius = radius || 50;
	
	    thetaStart = thetaStart !== undefined ? thetaStart : 0;
	    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
	    segments = segments !== undefined ? Math.max( 3, segments ) : 8;
	
	    var i, uvs = [],
	    center = new THREE.Vector3(), centerUV = new THREE.Vector2( 0.5, 0.5 );
	
	    this.vertices.push(center);
	    uvs.push( centerUV );
	
	    for ( i = 0; i <= segments; i ++ ) {
	
	        var vertex = new THREE.Vector3();
	
	        vertex.x = radius * Math.cos( thetaStart + i / segments * thetaLength );
	        vertex.y = radius * Math.sin( thetaStart + i / segments * thetaLength );
	
	        this.vertices.push( vertex );
	        uvs.push( new THREE.Vector2( ( vertex.x / radius + 1 ) / 2, - ( vertex.y / radius + 1 ) / 2 + 1 ) );
	
	    }
	
	    var n = new THREE.Vector3( 0, 0, -1 );
	
	    for ( i = 1; i <= segments; i ++ ) {
	
	        var v1 = i;
	        var v2 = i + 1 ;
	        var v3 = 0;
	
	        this.faces.push( new THREE.Face3( v1, v2, v3, [ n, n, n ] ) );
	        this.faceVertexUvs[ 0 ].push( [ uvs[ i ], uvs[ i + 1 ], centerUV ] );
	
	    }
	
	    this.computeCentroids();
	    this.computeFaceNormals();
	
	    this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );
	
	};
	
	THREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
	 */
	
	THREE.CubeGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {
	
		THREE.Geometry.call( this );
	
		var scope = this;
	
		this.width = width;
		this.height = height;
		this.depth = depth;
	
		this.widthSegments = widthSegments || 1;
		this.heightSegments = heightSegments || 1;
		this.depthSegments = depthSegments || 1;
	
		var width_half = this.width / 2;
		var height_half = this.height / 2;
		var depth_half = this.depth / 2;
	
		buildPlane( 'z', 'y', - 1, - 1, this.depth, this.height, width_half, 0 ); // px
		buildPlane( 'z', 'y',   1, - 1, this.depth, this.height, - width_half, 1 ); // nx
		buildPlane( 'x', 'z',   1,   1, this.width, this.depth, height_half, 2 ); // py
		buildPlane( 'x', 'z',   1, - 1, this.width, this.depth, - height_half, 3 ); // ny
		buildPlane( 'x', 'y',   1, - 1, this.width, this.height, depth_half, 4 ); // pz
		buildPlane( 'x', 'y', - 1, - 1, this.width, this.height, - depth_half, 5 ); // nz
	
		function buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {
	
			var w, ix, iy,
			gridX = scope.widthSegments,
			gridY = scope.heightSegments,
			width_half = width / 2,
			height_half = height / 2,
			offset = scope.vertices.length;
	
			if ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {
	
				w = 'z';
	
			} else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {
	
				w = 'y';
				gridY = scope.depthSegments;
	
			} else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {
	
				w = 'x';
				gridX = scope.depthSegments;
	
			}
	
			var gridX1 = gridX + 1,
			gridY1 = gridY + 1,
			segment_width = width / gridX,
			segment_height = height / gridY,
			normal = new THREE.Vector3();
	
			normal[ w ] = depth > 0 ? 1 : - 1;
	
			for ( iy = 0; iy < gridY1; iy ++ ) {
	
				for ( ix = 0; ix < gridX1; ix ++ ) {
	
					var vector = new THREE.Vector3();
					vector[ u ] = ( ix * segment_width - width_half ) * udir;
					vector[ v ] = ( iy * segment_height - height_half ) * vdir;
					vector[ w ] = depth;
	
					scope.vertices.push( vector );
	
				}
	
			}
	
			for ( iy = 0; iy < gridY; iy++ ) {
	
				for ( ix = 0; ix < gridX; ix++ ) {
	
					var a = ix + gridX1 * iy;
					var b = ix + gridX1 * ( iy + 1 );
					var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
					var d = ( ix + 1 ) + gridX1 * iy;
	
					var face = new THREE.Face4( a + offset, b + offset, c + offset, d + offset );
					face.normal.copy( normal );
					face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone(), normal.clone() );
					face.materialIndex = materialIndex;
	
					scope.faces.push( face );
					scope.faceVertexUvs[ 0 ].push( [
								new THREE.Vector2( ix / gridX, 1 - iy / gridY ),
								new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY ),
								new THREE.Vector2( ( ix + 1 ) / gridX, 1- ( iy + 1 ) / gridY ),
								new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY )
							] );
	
				}
	
			}
	
		}
	
		this.computeCentroids();
		this.mergeVertices();
	
	};
	
	THREE.CubeGeometry.prototype = Object.create( THREE.Geometry.prototype );
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded ) {
	
		THREE.Geometry.call( this );
	
		radiusTop = radiusTop !== undefined ? radiusTop : 20;
		radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
		height = height !== undefined ? height : 100;
	
		var heightHalf = height / 2;
		var segmentsX = radiusSegments || 8;
		var segmentsY = heightSegments || 1;
	
		var x, y, vertices = [], uvs = [];
	
		for ( y = 0; y <= segmentsY; y ++ ) {
	
			var verticesRow = [];
			var uvsRow = [];
	
			var v = y / segmentsY;
			var radius = v * ( radiusBottom - radiusTop ) + radiusTop;
	
			for ( x = 0; x <= segmentsX; x ++ ) {
	
				var u = x / segmentsX;
	
				var vertex = new THREE.Vector3();
				vertex.x = radius * Math.sin( u * Math.PI * 2 );
				vertex.y = - v * height + heightHalf;
				vertex.z = radius * Math.cos( u * Math.PI * 2 );
	
				this.vertices.push( vertex );
	
				verticesRow.push( this.vertices.length - 1 );
				uvsRow.push( new THREE.Vector2( u, 1 - v ) );
	
			}
	
			vertices.push( verticesRow );
			uvs.push( uvsRow );
	
		}
	
		var tanTheta = ( radiusBottom - radiusTop ) / height;
		var na, nb;
	
		for ( x = 0; x < segmentsX; x ++ ) {
	
			if ( radiusTop !== 0 ) {
	
				na = this.vertices[ vertices[ 0 ][ x ] ].clone();
				nb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();
	
			} else {
	
				na = this.vertices[ vertices[ 1 ][ x ] ].clone();
				nb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();
	
			}
	
			na.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();
			nb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();
	
			for ( y = 0; y < segmentsY; y ++ ) {
	
				var v1 = vertices[ y ][ x ];
				var v2 = vertices[ y + 1 ][ x ];
				var v3 = vertices[ y + 1 ][ x + 1 ];
				var v4 = vertices[ y ][ x + 1 ];
	
				var n1 = na.clone();
				var n2 = na.clone();
				var n3 = nb.clone();
				var n4 = nb.clone();
	
				var uv1 = uvs[ y ][ x ].clone();
				var uv2 = uvs[ y + 1 ][ x ].clone();
				var uv3 = uvs[ y + 1 ][ x + 1 ].clone();
				var uv4 = uvs[ y ][ x + 1 ].clone();
	
				this.faces.push( new THREE.Face4( v1, v2, v3, v4, [ n1, n2, n3, n4 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3, uv4 ] );
	
			}
	
		}
	
		// top cap
	
		if ( !openEnded && radiusTop > 0 ) {
	
			this.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );
	
			for ( x = 0; x < segmentsX; x ++ ) {
	
				var v1 = vertices[ 0 ][ x ];
				var v2 = vertices[ 0 ][ x + 1 ];
				var v3 = this.vertices.length - 1;
	
				var n1 = new THREE.Vector3( 0, 1, 0 );
				var n2 = new THREE.Vector3( 0, 1, 0 );
				var n3 = new THREE.Vector3( 0, 1, 0 );
	
				var uv1 = uvs[ 0 ][ x ].clone();
				var uv2 = uvs[ 0 ][ x + 1 ].clone();
				var uv3 = new THREE.Vector2( uv2.u, 0 );
	
				this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );
	
			}
	
		}
	
		// bottom cap
	
		if ( !openEnded && radiusBottom > 0 ) {
	
			this.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );
	
			for ( x = 0; x < segmentsX; x ++ ) {
	
				var v1 = vertices[ y ][ x + 1 ];
				var v2 = vertices[ y ][ x ];
				var v3 = this.vertices.length - 1;
	
				var n1 = new THREE.Vector3( 0, - 1, 0 );
				var n2 = new THREE.Vector3( 0, - 1, 0 );
				var n3 = new THREE.Vector3( 0, - 1, 0 );
	
				var uv1 = uvs[ y ][ x + 1 ].clone();
				var uv2 = uvs[ y ][ x ].clone();
				var uv3 = new THREE.Vector2( uv2.u, 1 );
	
				this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );
	
			}
	
		}
	
		this.computeCentroids();
		this.computeFaceNormals();
	
	}
	
	THREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 * Creates extruded geometry from a path shape.
	 *
	 * parameters = {
	 *
	 *  size: <float>, // size of the text
	 *  height: <float>, // thickness to extrude text
	 *  curveSegments: <int>, // number of points on the curves
	 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segements of extrude spline too
	 *  amount: <int>, // Amount
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into text bevel goes
	 *  bevelSize: <float>, // how far from text outline is bevel
	 *  bevelSegments: <int>, // number of bevel layers
	 *
	 *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
	 *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals
	 *
	 *  material: <int> // material index for front and back faces
	 *  extrudeMaterial: <int> // material index for extrusion and beveled faces
	 *  uvGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 **/
	
	THREE.ExtrudeGeometry = function ( shapes, options ) {
	
		if ( typeof( shapes ) === "undefined" ) {
			shapes = [];
			return;
		}
	
		THREE.Geometry.call( this );
	
		shapes = shapes instanceof Array ? shapes : [ shapes ];
	
		this.shapebb = shapes[ shapes.length - 1 ].getBoundingBox();
	
		this.addShapeList( shapes, options );
	
		this.computeCentroids();
		this.computeFaceNormals();
	
		// can't really use automatic vertex normals
		// as then front and back sides get smoothed too
		// should do separate smoothing just for sides
	
		//this.computeVertexNormals();
	
		//console.log( "took", ( Date.now() - startTime ) );
	
	};
	
	THREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );
	
	THREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {
		var sl = shapes.length;
	
		for ( var s = 0; s < sl; s ++ ) {
			var shape = shapes[ s ];
			this.addShape( shape, options );
		}
	};
	
	THREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {
	
		var amount = options.amount !== undefined ? options.amount : 100;
	
		var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
		var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
		var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
	
		var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false
	
		var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
	
		var steps = options.steps !== undefined ? options.steps : 1;
	
		var extrudePath = options.extrudePath;
		var extrudePts, extrudeByPath = false;
	
		var material = options.material;
		var extrudeMaterial = options.extrudeMaterial;
	
		// Use default WorldUVGenerator if no UV generators are specified.
		var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;
	
		var shapebb = this.shapebb;
		//shapebb = shape.getBoundingBox();
	
	
	
		var splineTube, binormal, normal, position2;
		if ( extrudePath ) {
	
			extrudePts = extrudePath.getSpacedPoints( steps );
	
			extrudeByPath = true;
			bevelEnabled = false; // bevels not supported for path extrusion
	
			// SETUP TNB variables
	
			// Reuse TNB from TubeGeomtry for now.
			// TODO1 - have a .isClosed in spline?
	
			splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath, steps, false);
	
			// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);
	
			binormal = new THREE.Vector3();
			normal = new THREE.Vector3();
			position2 = new THREE.Vector3();
	
		}
	
		// Safeguards if bevels are not enabled
	
		if ( ! bevelEnabled ) {
	
			bevelSegments = 0;
			bevelThickness = 0;
			bevelSize = 0;
	
		}
	
		// Variables initalization
	
		var ahole, h, hl; // looping of holes
		var scope = this;
		var bevelPoints = [];
	
		var shapesOffset = this.vertices.length;
	
		var shapePoints = shape.extractPoints( curveSegments );
	
		var vertices = shapePoints.shape;
		var holes = shapePoints.holes;
	
		var reverse = !THREE.Shape.Utils.isClockWise( vertices ) ;
	
		if ( reverse ) {
	
			vertices = vertices.reverse();
	
			// Maybe we should also check if holes are in the opposite direction, just to be safe ...
	
			for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
				ahole = holes[ h ];
	
				if ( THREE.Shape.Utils.isClockWise( ahole ) ) {
	
					holes[ h ] = ahole.reverse();
	
				}
	
			}
	
			reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!
	
		}
	
	
		var faces = THREE.Shape.Utils.triangulateShape ( vertices, holes );
	
		/* Vertices */
	
		var contour = vertices; // vertices has all points but contour has only points of circumference
	
		for ( h = 0, hl = holes.length;  h < hl; h ++ ) {
	
			ahole = holes[ h ];
	
			vertices = vertices.concat( ahole );
	
		}
	
	
		function scalePt2 ( pt, vec, size ) {
	
			if ( !vec ) console.log( "die" );
	
			return vec.clone().multiplyScalar( size ).add( pt );
	
		}
	
		var b, bs, t, z,
			vert, vlen = vertices.length,
			face, flen = faces.length,
			cont, clen = contour.length;
	
	
		// Find directions for point movement
	
		var RAD_TO_DEGREES = 180 / Math.PI;
	
	
		function getBevelVec( pt_i, pt_j, pt_k ) {
	
			// Algorithm 2
	
			return getBevelVec2( pt_i, pt_j, pt_k );
	
		}
	
		function getBevelVec1( pt_i, pt_j, pt_k ) {
	
			var anglea = Math.atan2( pt_j.y - pt_i.y, pt_j.x - pt_i.x );
			var angleb = Math.atan2( pt_k.y - pt_i.y, pt_k.x - pt_i.x );
	
			if ( anglea > angleb ) {
	
				angleb += Math.PI * 2;
	
			}
	
			var anglec = ( anglea + angleb ) / 2;
	
	
			//console.log('angle1', anglea * RAD_TO_DEGREES,'angle2', angleb * RAD_TO_DEGREES, 'anglec', anglec *RAD_TO_DEGREES);
	
			var x = - Math.cos( anglec );
			var y = - Math.sin( anglec );
	
			var vec = new THREE.Vector2( x, y ); //.normalize();
	
			return vec;
	
		}
	
		function getBevelVec2( pt_i, pt_j, pt_k ) {
	
			var a = THREE.ExtrudeGeometry.__v1,
				b = THREE.ExtrudeGeometry.__v2,
				v_hat = THREE.ExtrudeGeometry.__v3,
				w_hat = THREE.ExtrudeGeometry.__v4,
				p = THREE.ExtrudeGeometry.__v5,
				q = THREE.ExtrudeGeometry.__v6,
				v, w,
				v_dot_w_hat, q_sub_p_dot_w_hat,
				s, intersection;
	
			// good reading for line-line intersection
			// http://sputsoft.com/blog/2010/03/line-line-intersection.html
	
			// define a as vector j->i
			// define b as vectot k->i
	
			a.set( pt_i.x - pt_j.x, pt_i.y - pt_j.y );
			b.set( pt_i.x - pt_k.x, pt_i.y - pt_k.y );
	
			// get unit vectors
	
			v = a.normalize();
			w = b.normalize();
	
			// normals from pt i
	
			v_hat.set( -v.y, v.x );
			w_hat.set( w.y, -w.x );
	
			// pts from i
	
			p.copy( pt_i ).add( v_hat );
			q.copy( pt_i ).add( w_hat );
	
			if ( p.equals( q ) ) {
	
				//console.log("Warning: lines are straight");
				return w_hat.clone();
	
			}
	
			// Points from j, k. helps prevents points cross overover most of the time
	
			p.copy( pt_j ).add( v_hat );
			q.copy( pt_k ).add( w_hat );
	
			v_dot_w_hat = v.dot( w_hat );
			q_sub_p_dot_w_hat = q.sub( p ).dot( w_hat );
	
			// We should not reach these conditions
	
			if ( v_dot_w_hat === 0 ) {
	
				console.log( "Either infinite or no solutions!" );
	
				if ( q_sub_p_dot_w_hat === 0 ) {
	
					console.log( "Its finite solutions." );
	
				} else {
	
					console.log( "Too bad, no solutions." );
	
				}
	
			}
	
			s = q_sub_p_dot_w_hat / v_dot_w_hat;
	
			if ( s < 0 ) {
	
				// in case of emergecy, revert to algorithm 1.
	
				return getBevelVec1( pt_i, pt_j, pt_k );
	
			}
	
			intersection = v.multiplyScalar( s ).add( p );
	
			return intersection.sub( pt_i ).clone(); // Don't normalize!, otherwise sharp corners become ugly
	
		}
	
		var contourMovements = [];
	
		for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {
	
			if ( j === il ) j = 0;
			if ( k === il ) k = 0;
	
			//  (j)---(i)---(k)
			// console.log('i,j,k', i, j , k)
	
			var pt_i = contour[ i ];
			var pt_j = contour[ j ];
			var pt_k = contour[ k ];
	
			contourMovements[ i ]= getBevelVec( contour[ i ], contour[ j ], contour[ k ] );
	
		}
	
		var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();
	
		for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
			ahole = holes[ h ];
	
			oneHoleMovements = [];
	
			for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {
	
				if ( j === il ) j = 0;
				if ( k === il ) k = 0;
	
				//  (j)---(i)---(k)
				oneHoleMovements[ i ]= getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );
	
			}
	
			holesMovements.push( oneHoleMovements );
			verticesMovements = verticesMovements.concat( oneHoleMovements );
	
		}
	
	
		// Loop bevelSegments, 1 for the front, 1 for the back
	
		for ( b = 0; b < bevelSegments; b ++ ) {
		//for ( b = bevelSegments; b > 0; b -- ) {
	
			t = b / bevelSegments;
			z = bevelThickness * ( 1 - t );
	
			//z = bevelThickness * t;
			bs = bevelSize * ( Math.sin ( t * Math.PI/2 ) ) ; // curved
			//bs = bevelSize * t ; // linear
	
			// contract shape
	
			for ( i = 0, il = contour.length; i < il; i ++ ) {
	
				vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
				//vert = scalePt( contour[ i ], contourCentroid, bs, false );
				v( vert.x, vert.y,  - z );
	
			}
	
			// expand holes
	
			for ( h = 0, hl = holes.length; h < hl; h++ ) {
	
				ahole = holes[ h ];
				oneHoleMovements = holesMovements[ h ];
	
				for ( i = 0, il = ahole.length; i < il; i++ ) {
	
					vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );
					//vert = scalePt( ahole[ i ], holesCentroids[ h ], bs, true );
	
					v( vert.x, vert.y,  -z );
	
				}
	
			}
	
		}
	
		bs = bevelSize;
	
		// Back facing vertices
	
		for ( i = 0; i < vlen; i ++ ) {
	
			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];
	
			if ( !extrudeByPath ) {
	
				v( vert.x, vert.y, 0 );
	
			} else {
	
				// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
	
				normal.copy( splineTube.normals[0] ).multiplyScalar(vert.x);
				binormal.copy( splineTube.binormals[0] ).multiplyScalar(vert.y);
	
				position2.copy( extrudePts[0] ).add(normal).add(binormal);
	
				v( position2.x, position2.y, position2.z );
	
			}
	
		}
	
		// Add stepped vertices...
		// Including front facing vertices
	
		var s;
	
		for ( s = 1; s <= steps; s ++ ) {
	
			for ( i = 0; i < vlen; i ++ ) {
	
				vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];
	
				if ( !extrudeByPath ) {
	
					v( vert.x, vert.y, amount / steps * s );
	
				} else {
	
					// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
	
					normal.copy( splineTube.normals[s] ).multiplyScalar( vert.x );
					binormal.copy( splineTube.binormals[s] ).multiplyScalar( vert.y );
	
					position2.copy( extrudePts[s] ).add( normal ).add( binormal );
	
					v( position2.x, position2.y, position2.z );
	
				}
	
			}
	
		}
	
	
		// Add bevel segments planes
	
		//for ( b = 1; b <= bevelSegments; b ++ ) {
		for ( b = bevelSegments - 1; b >= 0; b -- ) {
	
			t = b / bevelSegments;
			z = bevelThickness * ( 1 - t );
			//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );
			bs = bevelSize * Math.sin ( t * Math.PI/2 ) ;
	
			// contract shape
	
			for ( i = 0, il = contour.length; i < il; i ++ ) {
	
				vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
				v( vert.x, vert.y,  amount + z );
	
			}
	
			// expand holes
	
			for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
				ahole = holes[ h ];
				oneHoleMovements = holesMovements[ h ];
	
				for ( i = 0, il = ahole.length; i < il; i ++ ) {
	
					vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );
	
					if ( !extrudeByPath ) {
	
						v( vert.x, vert.y,  amount + z );
	
					} else {
	
						v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );
	
					}
	
				}
	
			}
	
		}
	
		/* Faces */
	
		// Top and bottom faces
	
		buildLidFaces();
	
		// Sides faces
	
		buildSideFaces();
	
	
		/////  Internal functions
	
		function buildLidFaces() {
	
			if ( bevelEnabled ) {
	
				var layer = 0 ; // steps + 1
				var offset = vlen * layer;
	
				// Bottom faces
	
				for ( i = 0; i < flen; i ++ ) {
	
					face = faces[ i ];
					f3( face[ 2 ]+ offset, face[ 1 ]+ offset, face[ 0 ] + offset, true );
	
				}
	
				layer = steps + bevelSegments * 2;
				offset = vlen * layer;
	
				// Top faces
	
				for ( i = 0; i < flen; i ++ ) {
	
					face = faces[ i ];
					f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset, false );
	
				}
	
			} else {
	
				// Bottom faces
	
				for ( i = 0; i < flen; i++ ) {
	
					face = faces[ i ];
					f3( face[ 2 ], face[ 1 ], face[ 0 ], true );
	
				}
	
				// Top faces
	
				for ( i = 0; i < flen; i ++ ) {
	
					face = faces[ i ];
					f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps, false );
	
				}
			}
	
		}
	
		// Create faces for the z-sides of the shape
	
		function buildSideFaces() {
	
			var layeroffset = 0;
			sidewalls( contour, layeroffset );
			layeroffset += contour.length;
	
			for ( h = 0, hl = holes.length;  h < hl; h ++ ) {
	
				ahole = holes[ h ];
				sidewalls( ahole, layeroffset );
	
				//, true
				layeroffset += ahole.length;
	
			}
	
		}
	
		function sidewalls( contour, layeroffset ) {
	
			var j, k;
			i = contour.length;
	
			while ( --i >= 0 ) {
	
				j = i;
				k = i - 1;
				if ( k < 0 ) k = contour.length - 1;
	
				//console.log('b', i,j, i-1, k,vertices.length);
	
				var s = 0, sl = steps  + bevelSegments * 2;
	
				for ( s = 0; s < sl; s ++ ) {
	
					var slen1 = vlen * s;
					var slen2 = vlen * ( s + 1 );
	
					var a = layeroffset + j + slen1,
						b = layeroffset + k + slen1,
						c = layeroffset + k + slen2,
						d = layeroffset + j + slen2;
	
					f4( a, b, c, d, contour, s, sl, j, k );
	
				}
			}
	
		}
	
	
		function v( x, y, z ) {
	
			scope.vertices.push( new THREE.Vector3( x, y, z ) );
	
		}
	
		function f3( a, b, c, isBottom ) {
	
			a += shapesOffset;
			b += shapesOffset;
			c += shapesOffset;
	
			// normal, color, material
			scope.faces.push( new THREE.Face3( a, b, c, null, null, material ) );
	
			var uvs = isBottom ? uvgen.generateBottomUV( scope, shape, options, a, b, c ) : uvgen.generateTopUV( scope, shape, options, a, b, c );
	
	 		scope.faceVertexUvs[ 0 ].push( uvs );
	
		}
	
		function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {
	
			a += shapesOffset;
			b += shapesOffset;
			c += shapesOffset;
			d += shapesOffset;
	
	 		scope.faces.push( new THREE.Face4( a, b, c, d, null, null, extrudeMaterial ) );
	
	 		var uvs = uvgen.generateSideWallUV( scope, shape, wallContour, options, a, b, c, d,
	 		                                    stepIndex, stepsLength, contourIndex1, contourIndex2 );
	 		scope.faceVertexUvs[ 0 ].push( uvs );
	
		}
	
	};
	
	THREE.ExtrudeGeometry.WorldUVGenerator = {
	
		generateTopUV: function( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC ) {
			var ax = geometry.vertices[ indexA ].x,
				ay = geometry.vertices[ indexA ].y,
	
				bx = geometry.vertices[ indexB ].x,
				by = geometry.vertices[ indexB ].y,
	
				cx = geometry.vertices[ indexC ].x,
				cy = geometry.vertices[ indexC ].y;
	
			return [
				new THREE.Vector2( ax, ay ),
				new THREE.Vector2( bx, by ),
				new THREE.Vector2( cx, cy )
			];
	
		},
	
		generateBottomUV: function( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC ) {
	
			return this.generateTopUV( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC );
	
		},
	
		generateSideWallUV: function( geometry, extrudedShape, wallContour, extrudeOptions,
		                              indexA, indexB, indexC, indexD, stepIndex, stepsLength,
		                              contourIndex1, contourIndex2 ) {
	
			var ax = geometry.vertices[ indexA ].x,
				ay = geometry.vertices[ indexA ].y,
				az = geometry.vertices[ indexA ].z,
	
				bx = geometry.vertices[ indexB ].x,
				by = geometry.vertices[ indexB ].y,
				bz = geometry.vertices[ indexB ].z,
	
				cx = geometry.vertices[ indexC ].x,
				cy = geometry.vertices[ indexC ].y,
				cz = geometry.vertices[ indexC ].z,
	
				dx = geometry.vertices[ indexD ].x,
				dy = geometry.vertices[ indexD ].y,
				dz = geometry.vertices[ indexD ].z;
	
			if ( Math.abs( ay - by ) < 0.01 ) {
				return [
					new THREE.Vector2( ax, 1 - az ),
					new THREE.Vector2( bx, 1 - bz ),
					new THREE.Vector2( cx, 1 - cz ),
					new THREE.Vector2( dx, 1 - dz )
				];
			} else {
				return [
					new THREE.Vector2( ay, 1 - az ),
					new THREE.Vector2( by, 1 - bz ),
					new THREE.Vector2( cy, 1 - cz ),
					new THREE.Vector2( dy, 1 - dz )
				];
			}
		}
	};
	
	THREE.ExtrudeGeometry.__v1 = new THREE.Vector2();
	THREE.ExtrudeGeometry.__v2 = new THREE.Vector2();
	THREE.ExtrudeGeometry.__v3 = new THREE.Vector2();
	THREE.ExtrudeGeometry.__v4 = new THREE.Vector2();
	THREE.ExtrudeGeometry.__v5 = new THREE.Vector2();
	THREE.ExtrudeGeometry.__v6 = new THREE.Vector2();
	/**
	 * @author jonobr1 / http://jonobr1.com
	 *
	 * Creates a one-sided polygonal geometry from a path shape. Similar to
	 * ExtrudeGeometry.
	 *
	 * parameters = {
	 *
	 *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
	 *
	 *	material: <int> // material index for front and back faces
	 *	uvGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 **/
	
	THREE.ShapeGeometry = function ( shapes, options ) {
	
		THREE.Geometry.call( this );
	
		if ( shapes instanceof Array === false ) shapes = [ shapes ];
	
		this.shapebb = shapes[ shapes.length - 1 ].getBoundingBox();
	
		this.addShapeList( shapes, options );
	
		this.computeCentroids();
		this.computeFaceNormals();
	
	};
	
	THREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );
	
	/**
	 * Add an array of shapes to THREE.ShapeGeometry.
	 */
	THREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {
	
		for ( var i = 0, l = shapes.length; i < l; i++ ) {
	
			this.addShape( shapes[ i ], options );
	
		}
	
		return this;
	
	};
	
	/**
	 * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
	 */
	THREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {
	
		if ( options === undefined ) options = {};
		var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
	
		var material = options.material;
		var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;
	
		var shapebb = this.shapebb;
	
		//
	
		var i, l, hole, s;
	
		var shapesOffset = this.vertices.length;
		var shapePoints = shape.extractPoints( curveSegments );
	
		var vertices = shapePoints.shape;
		var holes = shapePoints.holes;
	
		var reverse = !THREE.Shape.Utils.isClockWise( vertices );
	
		if ( reverse ) {
	
			vertices = vertices.reverse();
	
			// Maybe we should also check if holes are in the opposite direction, just to be safe...
	
			for ( i = 0, l = holes.length; i < l; i++ ) {
	
				hole = holes[ i ];
	
				if ( THREE.Shape.Utils.isClockWise( hole ) ) {
	
					holes[ i ] = hole.reverse();
	
				}
	
			}
	
			reverse = false;
	
		}
	
		var faces = THREE.Shape.Utils.triangulateShape( vertices, holes );
	
		// Vertices
	
		var contour = vertices;
	
		for ( i = 0, l = holes.length; i < l; i++ ) {
	
			hole = holes[ i ];
			vertices = vertices.concat( hole );
	
		}
	
		//
	
		var vert, vlen = vertices.length;
		var face, flen = faces.length;
		var cont, clen = contour.length;
	
		for ( i = 0; i < vlen; i++ ) {
	
			vert = vertices[ i ];
	
			this.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );
	
		}
	
		for ( i = 0; i < flen; i++ ) {
	
			face = faces[ i ];
	
			var a = face[ 0 ] + shapesOffset;
			var b = face[ 1 ] + shapesOffset;
			var c = face[ 2 ] + shapesOffset;
	
			this.faces.push( new THREE.Face3( a, b, c, null, null, material ) );
			this.faceVertexUvs[ 0 ].push( uvgen.generateBottomUV( this, shape, options, a, b, c ) );
	
		}
	
	};
	/**
	 * @author astrodud / http://astrodud.isgreat.org/
	 * @author zz85 / https://github.com/zz85
	 * @author bhouston / http://exocortex.com
	 */
	
	// points - to create a closed torus, one must use a set of points 
	//    like so: [ a, b, c, d, a ], see first is the same as last.
	// segments - the number of circumference segments to create
	// phiStart - the starting radian
	// phiLength - the radian (0 to 2*PI) range of the lathed section
	//    2*pi is a closed lathe, less than 2PI is a portion.
	THREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {
	
		THREE.Geometry.call( this );
	
		segments = segments || 12;
		phiStart = phiStart || 0;
		phiLength = phiLength || 2 * Math.PI;
	
		var inversePointLength = 1.0 / ( points.length - 1 );
		var inverseSegments = 1.0 / segments;
	
		for ( var i = 0, il = segments; i <= il; i ++ ) {
	
			var phi = phiStart + i * inverseSegments * phiLength;
	
			var c = Math.cos( phi ),
				s = Math.sin( phi );
	
			for ( var j = 0, jl = points.length; j < jl; j ++ ) {
	
				var pt = points[ j ];
	
				var vertex = new THREE.Vector3();
	
				vertex.x = c * pt.x - s * pt.y;
				vertex.y = s * pt.x + c * pt.y;
				vertex.z = pt.z;
	
				this.vertices.push( vertex );
	
			}
	
		}
	
		var np = points.length;
	
		for ( var i = 0, il = segments; i < il; i ++ ) {
	
			for ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {
	
				var base = j + np * i;
				var a = base;
				var b = base + np;
				var c = base + 1 + np;
				var d = base + 1;
	
				this.faces.push( new THREE.Face4( a, b, c, d ) );
	
				var u0 = i * inverseSegments;
				var v0 = j * inversePointLength;
				var u1 = u0 + inverseSegments;
				var v1 = v0 + inversePointLength;
	
				this.faceVertexUvs[ 0 ].push( [
	
					new THREE.Vector2( u0, v0 ), 
					new THREE.Vector2( u1, v0 ),
					new THREE.Vector2( u1, v1 ),
					new THREE.Vector2( u0, v1 )
	
				] );
	
			}
	
		}
	
		this.mergeVertices();
		this.computeCentroids();
		this.computeFaceNormals();
		this.computeVertexNormals();
	
	};
	
	THREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
	 */
	
	THREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {
	
		THREE.Geometry.call( this );
	
		this.width = width;
		this.height = height;
	
		this.widthSegments = widthSegments || 1;
		this.heightSegments = heightSegments || 1;
	
		var ix, iz;
		var width_half = width / 2;
		var height_half = height / 2;
	
		var gridX = this.widthSegments;
		var gridZ = this.heightSegments;
	
		var gridX1 = gridX + 1;
		var gridZ1 = gridZ + 1;
	
		var segment_width = this.width / gridX;
		var segment_height = this.height / gridZ;
	
		var normal = new THREE.Vector3( 0, 0, 1 );
	
		for ( iz = 0; iz < gridZ1; iz ++ ) {
	
			for ( ix = 0; ix < gridX1; ix ++ ) {
	
				var x = ix * segment_width - width_half;
				var y = iz * segment_height - height_half;
	
				this.vertices.push( new THREE.Vector3( x, - y, 0 ) );
	
			}
	
		}
	
		for ( iz = 0; iz < gridZ; iz ++ ) {
	
			for ( ix = 0; ix < gridX; ix ++ ) {
	
				var a = ix + gridX1 * iz;
				var b = ix + gridX1 * ( iz + 1 );
				var c = ( ix + 1 ) + gridX1 * ( iz + 1 );
				var d = ( ix + 1 ) + gridX1 * iz;
	
				var face = new THREE.Face4( a, b, c, d );
				face.normal.copy( normal );
				face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone(), normal.clone() );
	
				this.faces.push( face );
				this.faceVertexUvs[ 0 ].push( [
					new THREE.Vector2( ix / gridX, 1 - iz / gridZ ),
					new THREE.Vector2( ix / gridX, 1 - ( iz + 1 ) / gridZ ),
					new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iz + 1 ) / gridZ ),
					new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iz / gridZ )
				] );
	
			}
	
		}
	
		this.computeCentroids();
	
	};
	
	THREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {
	
		THREE.Geometry.call( this );
	
		this.radius = radius || 50;
	
		this.widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
		this.heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );
	
		phiStart = phiStart !== undefined ? phiStart : 0;
		phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
	
		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
	
		var x, y, vertices = [], uvs = [];
	
		for ( y = 0; y <= this.heightSegments; y ++ ) {
	
			var verticesRow = [];
			var uvsRow = [];
	
			for ( x = 0; x <= this.widthSegments; x ++ ) {
	
				var u = x / this.widthSegments;
				var v = y / this.heightSegments;
	
				var vertex = new THREE.Vector3();
				vertex.x = - this.radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
				vertex.y = this.radius * Math.cos( thetaStart + v * thetaLength );
				vertex.z = this.radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
	
				this.vertices.push( vertex );
	
				verticesRow.push( this.vertices.length - 1 );
				uvsRow.push( new THREE.Vector2( u, 1 - v ) );
	
			}
	
			vertices.push( verticesRow );
			uvs.push( uvsRow );
	
		}
	
		for ( y = 0; y < this.heightSegments; y ++ ) {
	
			for ( x = 0; x < this.widthSegments; x ++ ) {
	
				var v1 = vertices[ y ][ x + 1 ];
				var v2 = vertices[ y ][ x ];
				var v3 = vertices[ y + 1 ][ x ];
				var v4 = vertices[ y + 1 ][ x + 1 ];
	
				var n1 = this.vertices[ v1 ].clone().normalize();
				var n2 = this.vertices[ v2 ].clone().normalize();
				var n3 = this.vertices[ v3 ].clone().normalize();
				var n4 = this.vertices[ v4 ].clone().normalize();
	
				var uv1 = uvs[ y ][ x + 1 ].clone();
				var uv2 = uvs[ y ][ x ].clone();
				var uv3 = uvs[ y + 1 ][ x ].clone();
				var uv4 = uvs[ y + 1 ][ x + 1 ].clone();
	
				if ( Math.abs( this.vertices[ v1 ].y ) === this.radius ) {
	
					this.faces.push( new THREE.Face3( v1, v3, v4, [ n1, n3, n4 ] ) );
					this.faceVertexUvs[ 0 ].push( [ uv1, uv3, uv4 ] );
	
				} else if ( Math.abs( this.vertices[ v3 ].y ) === this.radius ) {
	
					this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
					this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );
	
				} else {
	
					this.faces.push( new THREE.Face4( v1, v2, v3, v4, [ n1, n2, n3, n4 ] ) );
					this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3, uv4 ] );
	
				}
	
			}
	
		}
	
		this.computeCentroids();
		this.computeFaceNormals();
	
	    this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );
	
	};
	
	THREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * For creating 3D text geometry in three.js
	 *
	 * Text = 3D Text
	 *
	 * parameters = {
	 *  size: 			<float>, 	// size of the text
	 *  height: 		<float>, 	// thickness to extrude text
	 *  curveSegments: 	<int>,		// number of points on the curves
	 *
	 *  font: 			<string>,		// font name
	 *  weight: 		<string>,		// font weight (normal, bold)
	 *  style: 			<string>,		// font style  (normal, italics)
	 *
	 *  bevelEnabled:	<bool>,			// turn on bevel
	 *  bevelThickness: <float>, 		// how deep into text bevel goes
	 *  bevelSize:		<float>, 		// how far from text outline is bevel
	 *  }
	 *
	 */
	
	/*	Usage Examples
	
		// TextGeometry wrapper
	
		var text3d = new TextGeometry( text, options );
	
		// Complete manner
	
		var textShapes = THREE.FontUtils.generateShapes( text, options );
		var text3d = new ExtrudeGeometry( textShapes, options );
	
	*/
	
	
	THREE.TextGeometry = function ( text, parameters ) {
	
		var textShapes = THREE.FontUtils.generateShapes( text, parameters );
	
		// translate parameters to ExtrudeGeometry API
	
		parameters.amount = parameters.height !== undefined ? parameters.height : 50;
	
		// defaults
	
		if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
		if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
		if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;
	
		THREE.ExtrudeGeometry.call( this, textShapes, parameters );
	
	};
	
	THREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );
	/**
	 * @author oosmoxiecode
	 * @author mrdoob / http://mrdoob.com/
	 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
	 */
	
	THREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {
	
		THREE.Geometry.call( this );
	
		var scope = this;
	
		this.radius = radius || 100;
		this.tube = tube || 40;
		this.radialSegments = radialSegments || 8;
		this.tubularSegments = tubularSegments || 6;
		this.arc = arc || Math.PI * 2;
	
		var center = new THREE.Vector3(), uvs = [], normals = [];
	
		for ( var j = 0; j <= this.radialSegments; j ++ ) {
	
			for ( var i = 0; i <= this.tubularSegments; i ++ ) {
	
				var u = i / this.tubularSegments * this.arc;
				var v = j / this.radialSegments * Math.PI * 2;
	
				center.x = this.radius * Math.cos( u );
				center.y = this.radius * Math.sin( u );
	
				var vertex = new THREE.Vector3();
				vertex.x = ( this.radius + this.tube * Math.cos( v ) ) * Math.cos( u );
				vertex.y = ( this.radius + this.tube * Math.cos( v ) ) * Math.sin( u );
				vertex.z = this.tube * Math.sin( v );
	
				this.vertices.push( vertex );
	
				uvs.push( new THREE.Vector2( i / this.tubularSegments, j / this.radialSegments ) );
				normals.push( vertex.clone().sub( center ).normalize() );
	
			}
		}
	
	
		for ( var j = 1; j <= this.radialSegments; j ++ ) {
	
			for ( var i = 1; i <= this.tubularSegments; i ++ ) {
	
				var a = ( this.tubularSegments + 1 ) * j + i - 1;
				var b = ( this.tubularSegments + 1 ) * ( j - 1 ) + i - 1;
				var c = ( this.tubularSegments + 1 ) * ( j - 1 ) + i;
				var d = ( this.tubularSegments + 1 ) * j + i;
	
				var face = new THREE.Face4( a, b, c, d, [ normals[ a ], normals[ b ], normals[ c ], normals[ d ] ] );
				face.normal.add( normals[ a ] );
				face.normal.add( normals[ b ] );
				face.normal.add( normals[ c ] );
				face.normal.add( normals[ d ] );
				face.normal.normalize();
	
				this.faces.push( face );
	
				this.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );
			}
	
		}
	
		this.computeCentroids();
	
	};
	
	THREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );
	/**
	 * @author oosmoxiecode
	 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473
	 */
	
	THREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {
	
		THREE.Geometry.call( this );
	
		var scope = this;
	
		this.radius = radius || 100;
		this.tube = tube || 40;
		this.radialSegments = radialSegments || 64;
		this.tubularSegments = tubularSegments || 8;
		this.p = p || 2;
		this.q = q || 3;
		this.heightScale = heightScale || 1;
		this.grid = new Array( this.radialSegments );
	
		var tang = new THREE.Vector3();
		var n = new THREE.Vector3();
		var bitan = new THREE.Vector3();
	
		for ( var i = 0; i < this.radialSegments; ++ i ) {
	
			this.grid[ i ] = new Array( this.tubularSegments );
	
			for ( var j = 0; j < this.tubularSegments; ++ j ) {
	
				var u = i / this.radialSegments * 2 * this.p * Math.PI;
				var v = j / this.tubularSegments * 2 * Math.PI;
				var p1 = getPos( u, v, this.q, this.p, this.radius, this.heightScale );
				var p2 = getPos( u + 0.01, v, this.q, this.p, this.radius, this.heightScale );
				var cx, cy;
	
				tang.subVectors( p2, p1 );
				n.addVectors( p2, p1 );
	
				bitan.crossVectors( tang, n );
				n.crossVectors( bitan, tang );
				bitan.normalize();
				n.normalize();
	
				cx = - this.tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
				cy = this.tube * Math.sin( v );
	
				p1.x += cx * n.x + cy * bitan.x;
				p1.y += cx * n.y + cy * bitan.y;
				p1.z += cx * n.z + cy * bitan.z;
	
				this.grid[ i ][ j ] = vert( p1.x, p1.y, p1.z );
	
			}
	
		}
	
		for ( var i = 0; i < this.radialSegments; ++ i ) {
	
			for ( var j = 0; j < this.tubularSegments; ++ j ) {
	
				var ip = ( i + 1 ) % this.radialSegments;
				var jp = ( j + 1 ) % this.tubularSegments;
	
				var a = this.grid[ i ][ j ];
				var b = this.grid[ ip ][ j ];
				var c = this.grid[ ip ][ jp ];
				var d = this.grid[ i ][ jp ];
	
				var uva = new THREE.Vector2( i / this.radialSegments, j / this.tubularSegments );
				var uvb = new THREE.Vector2( ( i + 1 ) / this.radialSegments, j / this.tubularSegments );
				var uvc = new THREE.Vector2( ( i + 1 ) / this.radialSegments, ( j + 1 ) / this.tubularSegments );
				var uvd = new THREE.Vector2( i / this.radialSegments, ( j + 1 ) / this.tubularSegments );
	
				this.faces.push( new THREE.Face4( a, b, c, d ) );
				this.faceVertexUvs[ 0 ].push( [ uva,uvb,uvc, uvd ] );
	
			}
		}
	
		this.computeCentroids();
		this.computeFaceNormals();
		this.computeVertexNormals();
	
		function vert( x, y, z ) {
	
			return scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;
	
		}
	
		function getPos( u, v, in_q, in_p, radius, heightScale ) {
	
			var cu = Math.cos( u );
			var cv = Math.cos( v );
			var su = Math.sin( u );
			var quOverP = in_q / in_p * u;
			var cs = Math.cos( quOverP );
	
			var tx = radius * ( 2 + cs ) * 0.5 * cu;
			var ty = radius * ( 2 + cs ) * su * 0.5;
			var tz = heightScale * radius * Math.sin( quOverP ) * 0.5;
	
			return new THREE.Vector3( tx, ty, tz );
	
		}
	
	};
	
	THREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );
	/**
	 * @author WestLangley / https://github.com/WestLangley
	 * @author zz85 / https://github.com/zz85
	 * @author miningold / https://github.com/miningold
	 *
	 * Modified from the TorusKnotGeometry by @oosmoxiecode
	 *
	 * Creates a tube which extrudes along a 3d spline
	 *
	 * Uses parallel transport frames as described in
	 * http://www.cs.indiana.edu/pub/techreports/TR425.pdf
	 */
	
	THREE.TubeGeometry = function( path, segments, radius, radiusSegments, closed, debug ) {
	
		THREE.Geometry.call( this );
	
		this.path = path;
		this.segments = segments || 64;
		this.radius = radius || 1;
		this.radiusSegments = radiusSegments || 8;
		this.closed = closed || false;
	
		if ( debug ) this.debug = new THREE.Object3D();
	
		this.grid = [];
	
		var scope = this,
	
			tangent,
			normal,
			binormal,
	
			numpoints = this.segments + 1,
	
			x, y, z,
			tx, ty, tz,
			u, v,
	
			cx, cy,
			pos, pos2 = new THREE.Vector3(),
			i, j,
			ip, jp,
			a, b, c, d,
			uva, uvb, uvc, uvd;
	
		var frames = new THREE.TubeGeometry.FrenetFrames( this.path, this.segments, this.closed ),
			tangents = frames.tangents,
			normals = frames.normals,
			binormals = frames.binormals;
	
		// proxy internals
		this.tangents = tangents;
		this.normals = normals;
		this.binormals = binormals;
	
		function vert( x, y, z ) {
	
			return scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;
	
		}
	
	
		// consruct the grid
	
		for ( i = 0; i < numpoints; i++ ) {
	
			this.grid[ i ] = [];
	
			u = i / ( numpoints - 1 );
	
			pos = path.getPointAt( u );
	
			tangent = tangents[ i ];
			normal = normals[ i ];
			binormal = binormals[ i ];
	
			if ( this.debug ) {
	
				this.debug.add( new THREE.ArrowHelper(tangent, pos, radius, 0x0000ff ) );
				this.debug.add( new THREE.ArrowHelper(normal, pos, radius, 0xff0000 ) );
				this.debug.add( new THREE.ArrowHelper(binormal, pos, radius, 0x00ff00 ) );
	
			}
	
			for ( j = 0; j < this.radiusSegments; j++ ) {
	
				v = j / this.radiusSegments * 2 * Math.PI;
	
				cx = -this.radius * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
				cy = this.radius * Math.sin( v );
	
				pos2.copy( pos );
				pos2.x += cx * normal.x + cy * binormal.x;
				pos2.y += cx * normal.y + cy * binormal.y;
				pos2.z += cx * normal.z + cy * binormal.z;
	
				this.grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );
	
			}
		}
	
	
		// construct the mesh
	
		for ( i = 0; i < this.segments; i++ ) {
	
			for ( j = 0; j < this.radiusSegments; j++ ) {
	
				ip = ( this.closed ) ? (i + 1) % this.segments : i + 1;
				jp = (j + 1) % this.radiusSegments;
	
				a = this.grid[ i ][ j ];		// *** NOT NECESSARILY PLANAR ! ***
				b = this.grid[ ip ][ j ];
				c = this.grid[ ip ][ jp ];
				d = this.grid[ i ][ jp ];
	
				uva = new THREE.Vector2( i / this.segments, j / this.radiusSegments );
				uvb = new THREE.Vector2( ( i + 1 ) / this.segments, j / this.radiusSegments );
				uvc = new THREE.Vector2( ( i + 1 ) / this.segments, ( j + 1 ) / this.radiusSegments );
				uvd = new THREE.Vector2( i / this.segments, ( j + 1 ) / this.radiusSegments );
	
				this.faces.push( new THREE.Face4( a, b, c, d ) );
				this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvc, uvd ] );
	
			}
		}
	
		this.computeCentroids();
		this.computeFaceNormals();
		this.computeVertexNormals();
	
	};
	
	THREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );
	
	
	// For computing of Frenet frames, exposing the tangents, normals and binormals the spline
	THREE.TubeGeometry.FrenetFrames = function(path, segments, closed) {
	
		var	tangent = new THREE.Vector3(),
			normal = new THREE.Vector3(),
			binormal = new THREE.Vector3(),
	
			tangents = [],
			normals = [],
			binormals = [],
	
			vec = new THREE.Vector3(),
			mat = new THREE.Matrix4(),
	
			numpoints = segments + 1,
			theta,
			epsilon = 0.0001,
			smallest,
	
			tx, ty, tz,
			i, u, v;
	
	
		// expose internals
		this.tangents = tangents;
		this.normals = normals;
		this.binormals = binormals;
	
		// compute the tangent vectors for each segment on the path
	
		for ( i = 0; i < numpoints; i++ ) {
	
			u = i / ( numpoints - 1 );
	
			tangents[ i ] = path.getTangentAt( u );
			tangents[ i ].normalize();
	
		}
	
		initialNormal3();
	
		function initialNormal1(lastBinormal) {
			// fixed start binormal. Has dangers of 0 vectors
			normals[ 0 ] = new THREE.Vector3();
			binormals[ 0 ] = new THREE.Vector3();
			if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );
			normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
		}
	
		function initialNormal2() {
	
			// This uses the Frenet-Serret formula for deriving binormal
			var t2 = path.getTangentAt( epsilon );
	
			normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();
			binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );
	
			normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
	
		}
	
		function initialNormal3() {
			// select an initial normal vector perpenicular to the first tangent vector,
			// and in the direction of the smallest tangent xyz component
	
			normals[ 0 ] = new THREE.Vector3();
			binormals[ 0 ] = new THREE.Vector3();
			smallest = Number.MAX_VALUE;
			tx = Math.abs( tangents[ 0 ].x );
			ty = Math.abs( tangents[ 0 ].y );
			tz = Math.abs( tangents[ 0 ].z );
	
			if ( tx <= smallest ) {
				smallest = tx;
				normal.set( 1, 0, 0 );
			}
	
			if ( ty <= smallest ) {
				smallest = ty;
				normal.set( 0, 1, 0 );
			}
	
			if ( tz <= smallest ) {
				normal.set( 0, 0, 1 );
			}
	
			vec.crossVectors( tangents[ 0 ], normal ).normalize();
	
			normals[ 0 ].crossVectors( tangents[ 0 ], vec );
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );
		}
	
	
		// compute the slowly-varying normal and binormal vectors for each segment on the path
	
		for ( i = 1; i < numpoints; i++ ) {
	
			normals[ i ] = normals[ i-1 ].clone();
	
			binormals[ i ] = binormals[ i-1 ].clone();
	
			vec.crossVectors( tangents[ i-1 ], tangents[ i ] );
	
			if ( vec.length() > epsilon ) {
	
				vec.normalize();
	
				theta = Math.acos( tangents[ i-1 ].dot( tangents[ i ] ) );
	
				normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );
	
			}
	
			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );
	
		}
	
	
		// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same
	
		if ( closed ) {
	
			theta = Math.acos( normals[ 0 ].dot( normals[ numpoints-1 ] ) );
			theta /= ( numpoints - 1 );
	
			if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints-1 ] ) ) > 0 ) {
	
				theta = -theta;
	
			}
	
			for ( i = 1; i < numpoints; i++ ) {
	
				// twist a little...
				normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );
	
			}
	
		}
	};
	/**
	 * @author clockworkgeek / https://github.com/clockworkgeek
	 * @author timothypratley / https://github.com/timothypratley
	 */
	
	THREE.PolyhedronGeometry = function ( vertices, faces, radius, detail ) {
	
		THREE.Geometry.call( this );
	
		radius = radius || 1;
		detail = detail || 0;
	
		var that = this;
	
		for ( var i = 0, l = vertices.length; i < l; i ++ ) {
	
			prepare( new THREE.Vector3( vertices[ i ][ 0 ], vertices[ i ][ 1 ], vertices[ i ][ 2 ] ) );
	
		}
	
		var midpoints = [], p = this.vertices;
	
		for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
			make( p[ faces[ i ][ 0 ] ], p[ faces[ i ][ 1 ] ], p[ faces[ i ][ 2 ] ], detail );
	
		}
	
		this.mergeVertices();
	
		// Apply radius
	
		for ( var i = 0, l = this.vertices.length; i < l; i ++ ) {
	
			this.vertices[ i ].multiplyScalar( radius );
	
		}
	
	
		// Project vector onto sphere's surface
	
		function prepare( vector ) {
	
			var vertex = vector.normalize().clone();
			vertex.index = that.vertices.push( vertex ) - 1;
	
			// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.
	
			var u = azimuth( vector ) / 2 / Math.PI + 0.5;
			var v = inclination( vector ) / Math.PI + 0.5;
			vertex.uv = new THREE.Vector2( u, 1 - v );
	
			return vertex;
	
		}
	
	
		// Approximate a curved face with recursively sub-divided triangles.
	
		function make( v1, v2, v3, detail ) {
	
			if ( detail < 1 ) {
	
				var face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );
				face.centroid.add( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );
				face.normal = face.centroid.clone().normalize();
				that.faces.push( face );
	
				var azi = azimuth( face.centroid );
				that.faceVertexUvs[ 0 ].push( [
					correctUV( v1.uv, v1, azi ),
					correctUV( v2.uv, v2, azi ),
					correctUV( v3.uv, v3, azi )
				] );
	
			} else {
	
				detail -= 1;
	
				// split triangle into 4 smaller triangles
	
				make( v1, midpoint( v1, v2 ), midpoint( v1, v3 ), detail ); // top quadrant
				make( midpoint( v1, v2 ), v2, midpoint( v2, v3 ), detail ); // left quadrant
				make( midpoint( v1, v3 ), midpoint( v2, v3 ), v3, detail ); // right quadrant
				make( midpoint( v1, v2 ), midpoint( v2, v3 ), midpoint( v1, v3 ), detail ); // center quadrant
	
			}
	
		}
	
		function midpoint( v1, v2 ) {
	
			if ( !midpoints[ v1.index ] ) midpoints[ v1.index ] = [];
			if ( !midpoints[ v2.index ] ) midpoints[ v2.index ] = [];
	
			var mid = midpoints[ v1.index ][ v2.index ];
	
			if ( mid === undefined ) {
	
				// generate mean point and project to surface with prepare()
	
				midpoints[ v1.index ][ v2.index ] = midpoints[ v2.index ][ v1.index ] = mid = prepare(
					new THREE.Vector3().addVectors( v1, v2 ).divideScalar( 2 )
				);
			}
	
			return mid;
	
		}
	
	
		// Angle around the Y axis, counter-clockwise when looking from above.
	
		function azimuth( vector ) {
	
			return Math.atan2( vector.z, -vector.x );
	
		}
	
	
		// Angle above the XZ plane.
	
		function inclination( vector ) {
	
			return Math.atan2( -vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );
	
		}
	
	
		// Texture fixing helper. Spheres have some odd behaviours.
	
		function correctUV( uv, vector, azimuth ) {
	
			if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );
			if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );
			return uv;
	
		}
	
		this.computeCentroids();
	
	    this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );
	
	};
	
	THREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */
	
	THREE.IcosahedronGeometry = function ( radius, detail ) {
	
		var t = ( 1 + Math.sqrt( 5 ) ) / 2;
	
		var vertices = [
			[ -1,  t,  0 ], [  1, t, 0 ], [ -1, -t,  0 ], [  1, -t,  0 ],
			[  0, -1,  t ], [  0, 1, t ], [  0, -1, -t ], [  0,  1, -t ],
			[  t,  0, -1 ], [  t, 0, 1 ], [ -t,  0, -1 ], [ -t,  0,  1 ]
		];
	
		var faces = [
			[ 0, 11,  5 ], [ 0,  5,  1 ], [  0,  1,  7 ], [  0,  7, 10 ], [  0, 10, 11 ],
			[ 1,  5,  9 ], [ 5, 11,  4 ], [ 11, 10,  2 ], [ 10,  7,  6 ], [  7,  1,  8 ],
			[ 3,  9,  4 ], [ 3,  4,  2 ], [  3,  2,  6 ], [  3,  6,  8 ], [  3,  8,  9 ],
			[ 4,  9,  5 ], [ 2,  4, 11 ], [  6,  2, 10 ], [  8,  6,  7 ], [  9,  8,  1 ]
		];
	
		THREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );
	
	};
	
	THREE.IcosahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */
	
	THREE.OctahedronGeometry = function ( radius, detail ) {
	
		var vertices = [
			[ 1, 0, 0 ], [ -1, 0, 0 ], [ 0, 1, 0 ], [ 0, -1, 0 ], [ 0, 0, 1 ], [ 0, 0, -1 ]
		];
	
		var faces = [
			[ 0, 2, 4 ], [ 0, 4, 3 ], [ 0, 3, 5 ], [ 0, 5, 2 ], [ 1, 2, 5 ], [ 1, 5, 3 ], [ 1, 3, 4 ], [ 1, 4, 2 ]
		];
	
		THREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );
	};
	
	THREE.OctahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
	/**
	 * @author timothypratley / https://github.com/timothypratley
	 */
	
	THREE.TetrahedronGeometry = function ( radius, detail ) {
	
		var vertices = [
			[ 1,  1,  1 ], [ -1, -1, 1 ], [ -1, 1, -1 ], [ 1, -1, -1 ]
		];
	
		var faces = [
			[ 2, 1, 0 ], [ 0, 3, 2 ], [ 1, 3, 0 ], [ 2, 3, 1 ]
		];
	
		THREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );
	
	};
	
	THREE.TetrahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
	/**
	 * @author zz85 / https://github.com/zz85
	 * Parametric Surfaces Geometry
	 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
	 *
	 * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements, useTris );
	 *
	 */
	
	THREE.ParametricGeometry = function ( func, slices, stacks, useTris ) {
	
		THREE.Geometry.call( this );
	
		var verts = this.vertices;
		var faces = this.faces;
		var uvs = this.faceVertexUvs[ 0 ];
	
		useTris = (useTris === undefined) ? false : useTris;
	
		var i, il, j, p;
		var u, v;
	
		var stackCount = stacks + 1;
		var sliceCount = slices + 1;
	
		for ( i = 0; i <= stacks; i ++ ) {
	
			v = i / stacks;
	
			for ( j = 0; j <= slices; j ++ ) {
	
				u = j / slices;
	
				p = func( u, v );
				verts.push( p );
	
			}
		}
	
		var a, b, c, d;
		var uva, uvb, uvc, uvd;
	
		for ( i = 0; i < stacks; i ++ ) {
	
			for ( j = 0; j < slices; j ++ ) {
	
				a = i * sliceCount + j;
				b = i * sliceCount + j + 1;
				c = (i + 1) * sliceCount + j;
				d = (i + 1) * sliceCount + j + 1;
	
				uva = new THREE.Vector2( j / slices, i / stacks );
				uvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );
				uvc = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );
				uvd = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );
	
				if ( useTris ) {
	
					faces.push( new THREE.Face3( a, b, c ) );
					faces.push( new THREE.Face3( b, d, c ) );
	
					uvs.push( [ uva, uvb, uvc ] );
					uvs.push( [ uvb, uvd, uvc ] );
	
				} else {
	
					faces.push( new THREE.Face4( a, b, d, c ) );
					uvs.push( [ uva, uvb, uvd, uvc ] );
	
				}
	
			}
	
		}
	
		// console.log(this);
	
		// magic bullet
		// var diff = this.mergeVertices();
		// console.log('removed ', diff, ' vertices by merging');
	
		this.computeCentroids();
		this.computeFaceNormals();
		this.computeVertexNormals();
	
	};
	
	THREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );
	/**
	 * @author qiao / https://github.com/qiao
	 * @fileoverview This is a convex hull generator using the incremental method. 
	 * The complexity is O(n^2) where n is the number of vertices.
	 * O(nlogn) algorithms do exist, but they are much more complicated.
	 *
	 * Benchmark: 
	 *
	 *  Platform: CPU: P7350 @2.00GHz Engine: V8
	 *
	 *  Num Vertices	Time(ms)
	 *
	 *     10           1
	 *     20           3
	 *     30           19
	 *     40           48
	 *     50           107
	 */
	
	THREE.ConvexGeometry = function( vertices ) {
	
		THREE.Geometry.call( this );
	
		var faces = [ [ 0, 1, 2 ], [ 0, 2, 1 ] ]; 
	
		for ( var i = 3; i < vertices.length; i++ ) {
	
			addPoint( i );
	
		}
	
	
		function addPoint( vertexId ) {
	
			var vertex = vertices[ vertexId ].clone();
	
			var mag = vertex.length();
			vertex.x += mag * randomOffset();
			vertex.y += mag * randomOffset();
			vertex.z += mag * randomOffset();
	
			var hole = [];
	
			for ( var f = 0; f < faces.length; ) {
	
				var face = faces[ f ];
	
				// for each face, if the vertex can see it,
				// then we try to add the face's edges into the hole.
				if ( visible( face, vertex ) ) {
	
					for ( var e = 0; e < 3; e++ ) {
	
						var edge = [ face[ e ], face[ ( e + 1 ) % 3 ] ];
						var boundary = true;
	
						// remove duplicated edges.
						for ( var h = 0; h < hole.length; h++ ) {
	
							if ( equalEdge( hole[ h ], edge ) ) {
	
								hole[ h ] = hole[ hole.length - 1 ];
								hole.pop();
								boundary = false;
								break;
	
							}
	
						}
	
						if ( boundary ) {
	
							hole.push( edge );
	
						}
	
					}
	
					// remove faces[ f ]
					faces[ f ] = faces[ faces.length - 1 ];
					faces.pop();
	
				} else { // not visible
	
					f++;
	
				}
			}
	
			// construct the new faces formed by the edges of the hole and the vertex
			for ( var h = 0; h < hole.length; h++ ) {
	
				faces.push( [ 
					hole[ h ][ 0 ],
					hole[ h ][ 1 ],
					vertexId
				] );
	
			}
		}
	
		/**
		 * Whether the face is visible from the vertex
		 */
		function visible( face, vertex ) {
	
			var va = vertices[ face[ 0 ] ];
			var vb = vertices[ face[ 1 ] ];
			var vc = vertices[ face[ 2 ] ];
	
			var n = normal( va, vb, vc );
	
			// distance from face to origin
			var dist = n.dot( va );
	
			return n.dot( vertex ) >= dist; 
	
		}
	
		/**
		 * Face normal
		 */
		function normal( va, vb, vc ) {
	
			var cb = new THREE.Vector3();
			var ab = new THREE.Vector3();
	
			cb.subVectors( vc, vb );
			ab.subVectors( va, vb );
			cb.cross( ab );
	
			cb.normalize();
	
			return cb;
	
		}
	
		/**
		 * Detect whether two edges are equal.
		 * Note that when constructing the convex hull, two same edges can only
		 * be of the negative direction.
		 */
		function equalEdge( ea, eb ) {
	
			return ea[ 0 ] === eb[ 1 ] && ea[ 1 ] === eb[ 0 ]; 
	
		}
	
		/**
		 * Create a random offset between -1e-6 and 1e-6.
		 */
		function randomOffset() {
	
			return ( Math.random() - 0.5 ) * 2 * 1e-6;
	
		}
	
	
		/**
		 * XXX: Not sure if this is the correct approach. Need someone to review.
		 */
		function vertexUv( vertex ) {
	
			var mag = vertex.length();
			return new THREE.Vector2( vertex.x / mag, vertex.y / mag );
	
		}
	
		// Push vertices into `this.vertices`, skipping those inside the hull
		var id = 0;
		var newId = new Array( vertices.length ); // map from old vertex id to new id
	
		for ( var i = 0; i < faces.length; i++ ) {
	
			 var face = faces[ i ];
	
			 for ( var j = 0; j < 3; j++ ) {
	
					if ( newId[ face[ j ] ] === undefined ) {
	
							newId[ face[ j ] ] = id++;
							this.vertices.push( vertices[ face[ j ] ] );
	
					}
	
					face[ j ] = newId[ face[ j ] ];
	
			 }
	
		}
	
		// Convert faces into instances of THREE.Face3
		for ( var i = 0; i < faces.length; i++ ) {
	
			this.faces.push( new THREE.Face3( 
					faces[ i ][ 0 ],
					faces[ i ][ 1 ],
					faces[ i ][ 2 ]
			) );
	
		}
	
		// Compute UVs
		for ( var i = 0; i < this.faces.length; i++ ) {
	
			var face = this.faces[ i ];
	
			this.faceVertexUvs[ 0 ].push( [
				vertexUv( this.vertices[ face.a ] ),
				vertexUv( this.vertices[ face.b ] ),
				vertexUv( this.vertices[ face.c ])
			] );
	
		}
	
	
		this.computeCentroids();
		this.computeFaceNormals();
		this.computeVertexNormals();
	
	};
	
	THREE.ConvexGeometry.prototype = Object.create( THREE.Geometry.prototype );
	/**
	 * @author sroucheray / http://sroucheray.org/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	THREE.AxisHelper = function ( size ) {
	
		var geometry = new THREE.Geometry();
	
		geometry.vertices.push(
			new THREE.Vector3(), new THREE.Vector3( size || 1, 0, 0 ),
			new THREE.Vector3(), new THREE.Vector3( 0, size || 1, 0 ),
			new THREE.Vector3(), new THREE.Vector3( 0, 0, size || 1 )
		);
	
		geometry.colors.push(
			new THREE.Color( 0xff0000 ), new THREE.Color( 0xffaa00 ),
			new THREE.Color( 0x00ff00 ), new THREE.Color( 0xaaff00 ),
			new THREE.Color( 0x0000ff ), new THREE.Color( 0x00aaff )
		);
	
		var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );
	
		THREE.Line.call( this, geometry, material, THREE.LinePieces );
	
	};
	
	THREE.AxisHelper.prototype = Object.create( THREE.Line.prototype );
	/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @author zz85 / https://github.com/zz85
	 * @author bhouston / https://exocortex.com
	 *
	 * Creates an arrow for visualizing directions
	 *
	 * Parameters:
	 *  dir - Vector3
	 *  origin - Vector3
	 *  length - Number
	 *  hex - color in hex value
	 */
	
	THREE.ArrowHelper = function ( dir, origin, length, hex ) {
	
		THREE.Object3D.call( this );
	
		if ( length === undefined ) length = 20;
		if ( hex === undefined ) hex = 0xffff00;
	
		var lineGeometry = new THREE.Geometry();
		lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ) );
		lineGeometry.vertices.push( new THREE.Vector3( 0, 1, 0 ) );
	
		this.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: hex } ) );
		this.add( this.line );
	
		var coneGeometry = new THREE.CylinderGeometry( 0, 0.05, 0.25, 5, 1 );
	
		this.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: hex } ) );
		this.cone.position.set( 0, 1, 0 );
		this.add( this.cone );
	
		if ( origin instanceof THREE.Vector3 ) this.position = origin;
	
		this.setDirection( dir );
		this.setLength( length );
	
	};
	
	THREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );
	
	THREE.ArrowHelper.prototype.setDirection = function ( dir ) {
	
	    var d = THREE.ArrowHelper.__v1.copy( dir ).normalize();
	
	    if ( d.y > 0.999 ) {
	
	        this.rotation.set( 0, 0, 0 );
	 
	    } else if ( d.y < - 0.999 ) {
	
	        this.rotation.set( Math.PI, 0, 0 );
	
	    } else {
	
		    var axis = THREE.ArrowHelper.__v2.set( d.z, 0, - d.x ).normalize();
		    var radians = Math.acos( d.y );
		    var quaternion = THREE.ArrowHelper.__q1.setFromAxisAngle( axis, radians );
	
		    this.rotation.setEulerFromQuaternion( quaternion, this.eulerOrder );
	
		}
	
	};
	
	THREE.ArrowHelper.prototype.setLength = function ( length ) {
	
		this.scale.set( length, length, length );
	
	};
	
	THREE.ArrowHelper.prototype.setColor = function ( hex ) {
	
		this.line.material.color.setHex( hex );
		this.cone.material.color.setHex( hex );
	
	};
	
	THREE.ArrowHelper.__v1 = new THREE.Vector3();
	THREE.ArrowHelper.__v2 = new THREE.Vector3();
	THREE.ArrowHelper.__q1 = new THREE.Quaternion();
	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 *	- shows frustum, line of sight and up of the camera
	 *	- suitable for fast updates
	 * 	- based on frustum visualization in lightgl.js shadowmap example
	 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
	 */
	
	THREE.CameraHelper = function ( camera ) {
	
		THREE.Line.call( this );
	
		var scope = this;
	
		this.geometry = new THREE.Geometry();
		this.material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );
		this.type = THREE.LinePieces;
	
		this.matrixWorld = camera.matrixWorld;
		this.matrixAutoUpdate = false;
	
		this.pointMap = {};
	
		// colors
	
		var hexFrustum = 0xffaa00;
		var hexCone = 0xff0000;
		var hexUp = 0x00aaff;
		var hexTarget = 0xffffff;
		var hexCross = 0x333333;
	
		// near
	
		addLine( "n1", "n2", hexFrustum );
		addLine( "n2", "n4", hexFrustum );
		addLine( "n4", "n3", hexFrustum );
		addLine( "n3", "n1", hexFrustum );
	
		// far
	
		addLine( "f1", "f2", hexFrustum );
		addLine( "f2", "f4", hexFrustum );
		addLine( "f4", "f3", hexFrustum );
		addLine( "f3", "f1", hexFrustum );
	
		// sides
	
		addLine( "n1", "f1", hexFrustum );
		addLine( "n2", "f2", hexFrustum );
		addLine( "n3", "f3", hexFrustum );
		addLine( "n4", "f4", hexFrustum );
	
		// cone
	
		addLine( "p", "n1", hexCone );
		addLine( "p", "n2", hexCone );
		addLine( "p", "n3", hexCone );
		addLine( "p", "n4", hexCone );
	
		// up
	
		addLine( "u1", "u2", hexUp );
		addLine( "u2", "u3", hexUp );
		addLine( "u3", "u1", hexUp );
	
		// target
	
		addLine( "c", "t", hexTarget );
		addLine( "p", "c", hexCross );
	
		// cross
	
		addLine( "cn1", "cn2", hexCross );
		addLine( "cn3", "cn4", hexCross );
	
		addLine( "cf1", "cf2", hexCross );
		addLine( "cf3", "cf4", hexCross );
	
		this.camera = camera;
	
		function addLine( a, b, hex ) {
	
			addPoint( a, hex );
			addPoint( b, hex );
	
		}
	
		function addPoint( id, hex ) {
	
			scope.geometry.vertices.push( new THREE.Vector3() );
			scope.geometry.colors.push( new THREE.Color( hex ) );
	
			if ( scope.pointMap[ id ] === undefined ) scope.pointMap[ id ] = [];
	
			scope.pointMap[ id ].push( scope.geometry.vertices.length - 1 );
	
		}
	
		this.update( camera );
	
	};
	
	THREE.CameraHelper.prototype = Object.create( THREE.Line.prototype );
	
	THREE.CameraHelper.prototype.update = function () {
	
		var scope = this;
	
		var w = 1, h = 1;
	
		// we need just camera projection matrix
		// world matrix must be identity
	
		THREE.CameraHelper.__c.projectionMatrix.copy( this.camera.projectionMatrix );
	
		// center / target
	
		setPoint( "c", 0, 0, -1 );
		setPoint( "t", 0, 0,  1 );
	
		// near
	
		setPoint( "n1", -w, -h, -1 );
		setPoint( "n2",  w, -h, -1 );
		setPoint( "n3", -w,  h, -1 );
		setPoint( "n4",  w,  h, -1 );
	
		// far
	
		setPoint( "f1", -w, -h, 1 );
		setPoint( "f2",  w, -h, 1 );
		setPoint( "f3", -w,  h, 1 );
		setPoint( "f4",  w,  h, 1 );
	
		// up
	
		setPoint( "u1",  w * 0.7, h * 1.1, -1 );
		setPoint( "u2", -w * 0.7, h * 1.1, -1 );
		setPoint( "u3",        0, h * 2,   -1 );
	
		// cross
	
		setPoint( "cf1", -w,  0, 1 );
		setPoint( "cf2",  w,  0, 1 );
		setPoint( "cf3",  0, -h, 1 );
		setPoint( "cf4",  0,  h, 1 );
	
		setPoint( "cn1", -w,  0, -1 );
		setPoint( "cn2",  w,  0, -1 );
		setPoint( "cn3",  0, -h, -1 );
		setPoint( "cn4",  0,  h, -1 );
	
		function setPoint( point, x, y, z ) {
	
			THREE.CameraHelper.__v.set( x, y, z );
			THREE.CameraHelper.__projector.unprojectVector( THREE.CameraHelper.__v, THREE.CameraHelper.__c );
	
			var points = scope.pointMap[ point ];
	
			if ( points !== undefined ) {
	
				for ( var i = 0, il = points.length; i < il; i ++ ) {
	
					scope.geometry.vertices[ points[ i ] ].copy( THREE.CameraHelper.__v );
	
				}
	
			}
	
		}
	
		this.geometry.verticesNeedUpdate = true;
	
	};
	
	THREE.CameraHelper.__projector = new THREE.Projector();
	THREE.CameraHelper.__v = new THREE.Vector3();
	THREE.CameraHelper.__c = new THREE.Camera();
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 *	- shows directional light color, intensity, position, orientation and target
	 */
	
	THREE.DirectionalLightHelper = function ( light, sphereSize ) {
	
		THREE.Object3D.call( this );
	
		this.light = light;
	
		// position
	
		this.position = light.position;
	
		// direction
	
		this.direction = new THREE.Vector3();
		this.direction.subVectors( light.target.position, light.position );
	
		// color
	
		var intensity = THREE.Math.clamp( light.intensity, 0, 1 );
	
		this.color = light.color.clone();
		this.color.multiplyScalar( intensity );
	
		var hexColor = this.color.getHex();
	
		// light helper
	
		var bulbGeometry = new THREE.SphereGeometry( sphereSize, 16, 8 );
		var raysGeometry = new THREE.AsteriskGeometry( sphereSize * 1.25, sphereSize * 2.25 );
	
		var bulbMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false } );
		var raysMaterial = new THREE.LineBasicMaterial( { color: hexColor, fog: false } );
	
		this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	
		this.lightRays = new THREE.Line( raysGeometry, raysMaterial, THREE.LinePieces );
	
		this.add( this.lightSphere );
		this.add( this.lightRays );
	
		this.lightSphere.properties.isGizmo = true;
		this.lightSphere.properties.gizmoSubject = light;
		this.lightSphere.properties.gizmoRoot = this;
	
		// light target helper
	
		this.targetSphere = null;
	
		if ( light.target.properties.targetInverse !== undefined ) {
	
			var targetGeo = new THREE.SphereGeometry( sphereSize, 8, 4 );
			var targetMaterial = new THREE.MeshBasicMaterial( { color: hexColor, wireframe: true, fog: false } );
	
			this.targetSphere = new THREE.Mesh( targetGeo, targetMaterial );
			this.targetSphere.position = light.target.position;
	
			this.targetSphere.properties.isGizmo = true;
			this.targetSphere.properties.gizmoSubject = light.target;
			this.targetSphere.properties.gizmoRoot = this.targetSphere;
	
			var lineMaterial = new THREE.LineDashedMaterial( { color: hexColor, dashSize: 4, gapSize: 4, opacity: 0.75, transparent: true, fog: false } );
			var lineGeometry = new THREE.Geometry();
			lineGeometry.vertices.push( this.position.clone() );
			lineGeometry.vertices.push( this.targetSphere.position.clone() );
			lineGeometry.computeLineDistances();
	
			this.targetLine = new THREE.Line( lineGeometry, lineMaterial );
			this.targetLine.properties.isGizmo = true;
	
		}
	
		//
	
		this.properties.isGizmo = true;
	
	}
	
	THREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );
	
	THREE.DirectionalLightHelper.prototype.update = function () {
	
		// update arrow orientation
		// pointing from light to target
	
		this.direction.subVectors( this.light.target.position, this.light.position );
	
		// update arrow, spheres, rays and line colors to light color * light intensity
	
		var intensity = THREE.Math.clamp( this.light.intensity, 0, 1 );
	
		this.color.copy( this.light.color );
		this.color.multiplyScalar( intensity );
	
		this.lightSphere.material.color.copy( this.color );
		this.lightRays.material.color.copy( this.color );
	
		// Only update targetSphere and targetLine if available
		if ( this.targetSphere !== null ) {
	
			this.targetSphere.material.color.copy( this.color );
			this.targetLine.material.color.copy( this.color );
	
			// update target line vertices
	
			this.targetLine.geometry.vertices[ 0 ].copy( this.light.position );
			this.targetLine.geometry.vertices[ 1 ].copy( this.light.target.position );
	
			this.targetLine.geometry.computeLineDistances();
			this.targetLine.geometry.verticesNeedUpdate = true;
	
		}
	
	}
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 *	- shows hemisphere light intensity, sky and ground colors and directions
	 */
	
	THREE.HemisphereLightHelper = function ( light, sphereSize, arrowLength, domeSize ) {
	
		THREE.Object3D.call( this );
	
		this.light = light;
	
		// position
	
		this.position = light.position;
	
		//
	
		var intensity = THREE.Math.clamp( light.intensity, 0, 1 );
	
		// sky color
	
		this.color = light.color.clone();
		this.color.multiplyScalar( intensity );
	
		var hexColor = this.color.getHex();
	
		// ground color
	
		this.groundColor = light.groundColor.clone();
		this.groundColor.multiplyScalar( intensity );
	
		var hexColorGround = this.groundColor.getHex();
	
		// double colored light bulb
	
		var bulbGeometry = new THREE.SphereGeometry( sphereSize, 16, 8, 0, Math.PI * 2, 0, Math.PI * 0.5 );
		var bulbGroundGeometry = new THREE.SphereGeometry( sphereSize, 16, 8, 0, Math.PI * 2, Math.PI * 0.5, Math.PI );
	
		var bulbSkyMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false } );
		var bulbGroundMaterial = new THREE.MeshBasicMaterial( { color: hexColorGround, fog: false } );
	
		for ( var i = 0, il = bulbGeometry.faces.length; i < il; i ++ ) {
	
			bulbGeometry.faces[ i ].materialIndex = 0;
	
		}
	
		for ( var i = 0, il = bulbGroundGeometry.faces.length; i < il; i ++ ) {
	
			bulbGroundGeometry.faces[ i ].materialIndex = 1;
	
		}
	
		THREE.GeometryUtils.merge( bulbGeometry, bulbGroundGeometry );
	
		this.lightSphere = new THREE.Mesh( bulbGeometry, new THREE.MeshFaceMaterial( [ bulbSkyMaterial, bulbGroundMaterial ] ) );
	
		// arrows for sky and ground light directions
	
		this.lightArrow = new THREE.ArrowHelper( new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, ( sphereSize + arrowLength ) * 1.1, 0 ), arrowLength, hexColor );
		this.lightArrow.rotation.x = Math.PI;
	
		this.lightArrowGround = new THREE.ArrowHelper( new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, ( sphereSize + arrowLength ) * -1.1, 0 ), arrowLength, hexColorGround );
	
		var joint = new THREE.Object3D();
		joint.rotation.x = -Math.PI * 0.5;
	
		joint.add( this.lightSphere );
		joint.add( this.lightArrow );
		joint.add( this.lightArrowGround );
	
		this.add( joint );
	
		//
	
		this.lightSphere.properties.isGizmo = true;
		this.lightSphere.properties.gizmoSubject = light;
		this.lightSphere.properties.gizmoRoot = this;
	
		//
	
		this.properties.isGizmo = true;
	
		//
	
		this.target = new THREE.Vector3();
		this.lookAt( this.target );
	
	}
	
	THREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );
	
	THREE.HemisphereLightHelper.prototype.update = function () {
	
		// update sphere sky and ground colors to light color * light intensity
	
		var intensity = THREE.Math.clamp( this.light.intensity, 0, 1 );
	
		this.color.copy( this.light.color );
		this.color.multiplyScalar( intensity );
	
		this.groundColor.copy( this.light.groundColor );
		this.groundColor.multiplyScalar( intensity );
	
		this.lightSphere.material.materials[ 0 ].color.copy( this.color );
		this.lightSphere.material.materials[ 1 ].color.copy( this.groundColor );
	
		this.lightArrow.setColor( this.color.getHex() );
		this.lightArrowGround.setColor( this.groundColor.getHex() );
	
		this.lookAt( this.target );
	
	}
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 *	- shows point light color, intensity, position and distance
	 */
	
	THREE.PointLightHelper = function ( light, sphereSize ) {
	
		THREE.Object3D.call( this );
	
		this.light = light;
	
		// position
	
		this.position = light.position;
	
		// color
	
		var intensity = THREE.Math.clamp( light.intensity, 0, 1 );
	
		this.color = light.color.clone();
		this.color.multiplyScalar( intensity );
	
		var hexColor = this.color.getHex();
	
		// light helper
	
		var bulbGeometry = new THREE.SphereGeometry( sphereSize, 16, 8 );
		var raysGeometry = new THREE.AsteriskGeometry( sphereSize * 1.25, sphereSize * 2.25 );
		var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
	
		var bulbMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false } );
		var raysMaterial = new THREE.LineBasicMaterial( { color: hexColor, fog: false } );
		var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );
	
		this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
		this.lightRays = new THREE.Line( raysGeometry, raysMaterial, THREE.LinePieces );
		this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );
	
		var d = light.distance;
	
		if ( d === 0.0 ) {
	
			this.lightDistance.visible = false;
	
		} else {
	
			this.lightDistance.scale.set( d, d, d );
	
		}
	
		this.add( this.lightSphere );
		this.add( this.lightRays );
		this.add( this.lightDistance );
	
		//
	
		this.lightSphere.properties.isGizmo = true;
		this.lightSphere.properties.gizmoSubject = light;
		this.lightSphere.properties.gizmoRoot = this;
	
		//
	
		this.properties.isGizmo = true;
	
	}
	
	THREE.PointLightHelper.prototype = Object.create( THREE.Object3D.prototype );
	
	THREE.PointLightHelper.prototype.update = function () {
	
		// update sphere and rays colors to light color * light intensity
	
		var intensity = THREE.Math.clamp( this.light.intensity, 0, 1 );
	
		this.color.copy( this.light.color );
		this.color.multiplyScalar( intensity );
	
		this.lightSphere.material.color.copy( this.color );
		this.lightRays.material.color.copy( this.color );
		this.lightDistance.material.color.copy( this.color );
	
		//
	
		var d = this.light.distance;
	
		if ( d === 0.0 ) {
	
			this.lightDistance.visible = false;
	
		} else {
	
			this.lightDistance.visible = true;
			this.lightDistance.scale.set( d, d, d );
	
		}
	
	}
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 *	- shows spot light color, intensity, position, orientation, light cone and target
	 */
	
	THREE.SpotLightHelper = function ( light, sphereSize ) {
	
		THREE.Object3D.call( this );
	
		this.light = light;
	
		// position
	
		this.position = light.position;
	
		// direction
	
		this.direction = new THREE.Vector3();
		this.direction.subVectors( light.target.position, light.position );
	
		// color
	
		var intensity = THREE.Math.clamp( light.intensity, 0, 1 );
	
		this.color = light.color.clone();
		this.color.multiplyScalar( intensity );
	
		var hexColor = this.color.getHex();
	
		// light helper
	
		var bulbGeometry = new THREE.SphereGeometry( sphereSize, 16, 8 );
		var raysGeometry = new THREE.AsteriskGeometry( sphereSize * 1.25, sphereSize * 2.25 );
		var coneGeometry = new THREE.CylinderGeometry( 0.0001, 1, 1, 8, 1, true );
	
		var coneMatrix = new THREE.Matrix4();
		coneMatrix.rotateX( -Math.PI/2 );
		coneMatrix.translate( new THREE.Vector3( 0, -0.5, 0 ) );
		coneGeometry.applyMatrix( coneMatrix );
	
		var bulbMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false } );
		var raysMaterial = new THREE.LineBasicMaterial( { color: hexColor, fog: false } );
		var coneMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.3, transparent: true } );
	
		this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
		this.lightCone = new THREE.Mesh( coneGeometry, coneMaterial );
	
		var coneLength = light.distance ? light.distance : 10000;
		var coneWidth = coneLength * Math.tan( light.angle * 0.5 ) * 2;
		this.lightCone.scale.set( coneWidth, coneWidth, coneLength );
	
		this.lightRays = new THREE.Line( raysGeometry, raysMaterial, THREE.LinePieces );
	
		this.gyroscope = new THREE.Gyroscope();
	
		this.gyroscope.add( this.lightSphere );
		this.gyroscope.add( this.lightRays );
	
		this.add( this.gyroscope );
		this.add( this.lightCone );
	
		this.lookAt( light.target.position );
	
		this.lightSphere.properties.isGizmo = true;
		this.lightSphere.properties.gizmoSubject = light;
		this.lightSphere.properties.gizmoRoot = this;
	
		// light target helper
	
		this.targetSphere = null;
	
		if ( light.target.properties.targetInverse !== undefined ) {
	
			var targetGeo = new THREE.SphereGeometry( sphereSize, 8, 4 );
			var targetMaterial = new THREE.MeshBasicMaterial( { color: hexColor, wireframe: true, fog: false } );
	
			this.targetSphere = new THREE.Mesh( targetGeo, targetMaterial );
			this.targetSphere.position = light.target.position;
	
			this.targetSphere.properties.isGizmo = true;
			this.targetSphere.properties.gizmoSubject = light.target;
			this.targetSphere.properties.gizmoRoot = this.targetSphere;
	
			var lineMaterial = new THREE.LineDashedMaterial( { color: hexColor, dashSize: 4, gapSize: 4, opacity: 0.75, transparent: true, fog: false } );
			var lineGeometry = new THREE.Geometry();
			lineGeometry.vertices.push( this.position.clone() );
			lineGeometry.vertices.push( this.targetSphere.position.clone() );
			lineGeometry.computeLineDistances();
	
			this.targetLine = new THREE.Line( lineGeometry, lineMaterial );
			this.targetLine.properties.isGizmo = true;
	
		}
	
		//
	
		this.properties.isGizmo = true;
	
	}
	
	THREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );
	
	THREE.SpotLightHelper.prototype.update = function () {
	
		// update arrow orientation
		// pointing from light to target
	
		this.direction.subVectors( this.light.target.position, this.light.position );
	
		// update light cone orientation and size
	
		this.lookAt( this.light.target.position );
	
		var coneLength = this.light.distance ? this.light.distance : 10000;
		var coneWidth = coneLength * Math.tan( this.light.angle * 0.5 ) * 2;
		this.lightCone.scale.set( coneWidth, coneWidth, coneLength );
	
		// update arrow, spheres, rays and line colors to light color * light intensity
	
		var intensity = THREE.Math.clamp( this.light.intensity, 0, 1 );
	
		this.color.copy( this.light.color );
		this.color.multiplyScalar( intensity );
	
		this.lightSphere.material.color.copy( this.color );
		this.lightRays.material.color.copy( this.color );
		this.lightCone.material.color.copy( this.color );
	
		// Only update targetSphere and targetLine if available
		if ( this.targetSphere !== null ) {
	
			this.targetSphere.material.color.copy( this.color );
			this.targetLine.material.color.copy( this.color );
	
			// update target line vertices
	
			this.targetLine.geometry.vertices[ 0 ].copy( this.light.position );
			this.targetLine.geometry.vertices[ 1 ].copy( this.light.target.position );
	
			this.targetLine.geometry.computeLineDistances();
			this.targetLine.geometry.verticesNeedUpdate = true;
	
		}
	
	};
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.ImmediateRenderObject = function () {
	
		THREE.Object3D.call( this );
	
		this.render = function ( renderCallback ) { };
	
	};
	
	THREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.LensFlare = function ( texture, size, distance, blending, color ) {
	
		THREE.Object3D.call( this );
	
		this.lensFlares = [];
	
		this.positionScreen = new THREE.Vector3();
		this.customUpdateCallback = undefined;
	
		if( texture !== undefined ) {
	
			this.add( texture, size, distance, blending, color );
	
		}
	
	};
	
	THREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );
	
	
	/*
	 * Add: adds another flare
	 */
	
	THREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {
	
		if( size === undefined ) size = -1;
		if( distance === undefined ) distance = 0;
		if( opacity === undefined ) opacity = 1;
		if( color === undefined ) color = new THREE.Color( 0xffffff );
		if( blending === undefined ) blending = THREE.NormalBlending;
	
		distance = Math.min( distance, Math.max( 0, distance ) );
	
		this.lensFlares.push( { texture: texture, 			// THREE.Texture
			                    size: size, 				// size in pixels (-1 = use texture.width)
			                    distance: distance, 		// distance (0-1) from light source (0=at light source)
			                    x: 0, y: 0, z: 0,			// screen position (-1 => 1) z = 0 is ontop z = 1 is back
			                    scale: 1, 					// scale
			                    rotation: 1, 				// rotation
			                    opacity: opacity,			// opacity
								color: color,				// color
			                    blending: blending } );		// blending
	
	};
	
	
	/*
	 * Update lens flares update positions on all flares based on the screen position
	 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
	 */
	
	THREE.LensFlare.prototype.updateLensFlares = function () {
	
		var f, fl = this.lensFlares.length;
		var flare;
		var vecX = -this.positionScreen.x * 2;
		var vecY = -this.positionScreen.y * 2;
	
		for( f = 0; f < fl; f ++ ) {
	
			flare = this.lensFlares[ f ];
	
			flare.x = this.positionScreen.x + vecX * flare.distance;
			flare.y = this.positionScreen.y + vecY * flare.distance;
	
			flare.wantedRotation = flare.x * Math.PI * 0.25;
			flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;
	
		}
	
	};
	
	
	
	
	
	
	
	
	
	
	
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.MorphBlendMesh = function( geometry, material ) {
	
		THREE.Mesh.call( this, geometry, material );
	
		this.animationsMap = {};
		this.animationsList = [];
	
		// prepare default animation
		// (all frames played together in 1 second)
	
		var numFrames = this.geometry.morphTargets.length;
	
		var name = "__default";
	
		var startFrame = 0;
		var endFrame = numFrames - 1;
	
		var fps = numFrames / 1;
	
		this.createAnimation( name, startFrame, endFrame, fps );
		this.setAnimationWeight( name, 1 );
	
	};
	
	THREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );
	
	THREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {
	
		var animation = {
	
			startFrame: start,
			endFrame: end,
	
			length: end - start + 1,
	
			fps: fps,
			duration: ( end - start ) / fps,
	
			lastFrame: 0,
			currentFrame: 0,
	
			active: false,
	
			time: 0,
			direction: 1,
			weight: 1,
	
			directionBackwards: false,
			mirroredLoop: false
	
		};
	
		this.animationsMap[ name ] = animation;
		this.animationsList.push( animation );
	
	};
	
	THREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {
	
		var pattern = /([a-z]+)(\d+)/;
	
		var firstAnimation, frameRanges = {};
	
		var geometry = this.geometry;
	
		for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {
	
			var morph = geometry.morphTargets[ i ];
			var chunks = morph.name.match( pattern );
	
			if ( chunks && chunks.length > 1 ) {
	
				var name = chunks[ 1 ];
				var num = chunks[ 2 ];
	
				if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: -Infinity };
	
				var range = frameRanges[ name ];
	
				if ( i < range.start ) range.start = i;
				if ( i > range.end ) range.end = i;
	
				if ( ! firstAnimation ) firstAnimation = name;
	
			}
	
		}
	
		for ( var name in frameRanges ) {
	
			var range = frameRanges[ name ];
			this.createAnimation( name, range.start, range.end, fps );
	
		}
	
		this.firstAnimation = firstAnimation;
	
	};
	
	THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.direction = 1;
			animation.directionBackwards = false;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.direction = -1;
			animation.directionBackwards = true;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.fps = fps;
			animation.duration = ( animation.end - animation.start ) / animation.fps;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.duration = duration;
			animation.fps = ( animation.end - animation.start ) / animation.duration;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.weight = weight;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.time = time;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {
	
		var time = 0;
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			time = animation.time;
	
		}
	
		return time;
	
	};
	
	THREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {
	
		var duration = -1;
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			duration = animation.duration;
	
		}
	
		return duration;
	
	};
	
	THREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.time = 0;
			animation.active = true;
	
		} else {
	
			console.warn( "animation[" + name + "] undefined" );
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {
	
		var animation = this.animationsMap[ name ];
	
		if ( animation ) {
	
			animation.active = false;
	
		}
	
	};
	
	THREE.MorphBlendMesh.prototype.update = function ( delta ) {
	
		for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {
	
			var animation = this.animationsList[ i ];
	
			if ( ! animation.active ) continue;
	
			var frameTime = animation.duration / animation.length;
	
			animation.time += animation.direction * delta;
	
			if ( animation.mirroredLoop ) {
	
				if ( animation.time > animation.duration || animation.time < 0 ) {
	
					animation.direction *= -1;
	
					if ( animation.time > animation.duration ) {
	
						animation.time = animation.duration;
						animation.directionBackwards = true;
	
					}
	
					if ( animation.time < 0 ) {
	
						animation.time = 0;
						animation.directionBackwards = false;
	
					}
	
				}
	
			} else {
	
				animation.time = animation.time % animation.duration;
	
				if ( animation.time < 0 ) animation.time += animation.duration;
	
			}
	
			var keyframe = animation.startFrame + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
			var weight = animation.weight;
	
			if ( keyframe !== animation.currentFrame ) {
	
				this.morphTargetInfluences[ animation.lastFrame ] = 0;
				this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;
	
				this.morphTargetInfluences[ keyframe ] = 0;
	
				animation.lastFrame = animation.currentFrame;
				animation.currentFrame = keyframe;
	
			}
	
			var mix = ( animation.time % frameTime ) / frameTime;
	
			if ( animation.directionBackwards ) mix = 1 - mix;
	
			this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
			this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;
	
		}
	
	};
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.LensFlarePlugin = function () {
	
		var _gl, _renderer, _precision, _lensFlare = {};
	
		this.init = function ( renderer ) {
	
			_gl = renderer.context;
			_renderer = renderer;
	
			_precision = renderer.getPrecision();
	
			_lensFlare.vertices = new Float32Array( 8 + 8 );
			_lensFlare.faces = new Uint16Array( 6 );
	
			var i = 0;
			_lensFlare.vertices[ i++ ] = -1; _lensFlare.vertices[ i++ ] = -1;	// vertex
			_lensFlare.vertices[ i++ ] = 0;  _lensFlare.vertices[ i++ ] = 0;	// uv... etc.
	
			_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = -1;
			_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 0;
	
			_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 1;
			_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 1;
	
			_lensFlare.vertices[ i++ ] = -1; _lensFlare.vertices[ i++ ] = 1;
			_lensFlare.vertices[ i++ ] = 0;  _lensFlare.vertices[ i++ ] = 1;
	
			i = 0;
			_lensFlare.faces[ i++ ] = 0; _lensFlare.faces[ i++ ] = 1; _lensFlare.faces[ i++ ] = 2;
			_lensFlare.faces[ i++ ] = 0; _lensFlare.faces[ i++ ] = 2; _lensFlare.faces[ i++ ] = 3;
	
			// buffers
	
			_lensFlare.vertexBuffer     = _gl.createBuffer();
			_lensFlare.elementBuffer    = _gl.createBuffer();
	
			_gl.bindBuffer( _gl.ARRAY_BUFFER, _lensFlare.vertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, _lensFlare.vertices, _gl.STATIC_DRAW );
	
			_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.elementBuffer );
			_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.faces, _gl.STATIC_DRAW );
	
			// textures
	
			_lensFlare.tempTexture      = _gl.createTexture();
			_lensFlare.occlusionTexture = _gl.createTexture();
	
			_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );
			_gl.texImage2D( _gl.TEXTURE_2D, 0, _gl.RGB, 16, 16, 0, _gl.RGB, _gl.UNSIGNED_BYTE, null );
			_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
			_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );
			_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, _gl.NEAREST );
			_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, _gl.NEAREST );
	
			_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.occlusionTexture );
			_gl.texImage2D( _gl.TEXTURE_2D, 0, _gl.RGBA, 16, 16, 0, _gl.RGBA, _gl.UNSIGNED_BYTE, null );
			_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
			_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );
			_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, _gl.NEAREST );
			_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, _gl.NEAREST );
	
			if ( _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) <= 0 ) {
	
				_lensFlare.hasVertexTexture = false;
				_lensFlare.program = createProgram( THREE.ShaderFlares[ "lensFlare" ], _precision );
	
			} else {
	
				_lensFlare.hasVertexTexture = true;
				_lensFlare.program = createProgram( THREE.ShaderFlares[ "lensFlareVertexTexture" ], _precision );
	
			}
	
			_lensFlare.attributes = {};
			_lensFlare.uniforms = {};
	
			_lensFlare.attributes.vertex       = _gl.getAttribLocation ( _lensFlare.program, "position" );
			_lensFlare.attributes.uv           = _gl.getAttribLocation ( _lensFlare.program, "uv" );
	
			_lensFlare.uniforms.renderType     = _gl.getUniformLocation( _lensFlare.program, "renderType" );
			_lensFlare.uniforms.map            = _gl.getUniformLocation( _lensFlare.program, "map" );
			_lensFlare.uniforms.occlusionMap   = _gl.getUniformLocation( _lensFlare.program, "occlusionMap" );
			_lensFlare.uniforms.opacity        = _gl.getUniformLocation( _lensFlare.program, "opacity" );
			_lensFlare.uniforms.color          = _gl.getUniformLocation( _lensFlare.program, "color" );
			_lensFlare.uniforms.scale          = _gl.getUniformLocation( _lensFlare.program, "scale" );
			_lensFlare.uniforms.rotation       = _gl.getUniformLocation( _lensFlare.program, "rotation" );
			_lensFlare.uniforms.screenPosition = _gl.getUniformLocation( _lensFlare.program, "screenPosition" );
	
		};
	
	
		/*
		 * Render lens flares
		 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
		 *         reads these back and calculates occlusion.
		 *         Then _lensFlare.update_lensFlares() is called to re-position and
		 *         update transparency of flares. Then they are rendered.
		 *
		 */
	
		this.render = function ( scene, camera, viewportWidth, viewportHeight ) {
	
			var flares = scene.__webglFlares,
				nFlares = flares.length;
	
			if ( ! nFlares ) return;
	
			var tempPosition = new THREE.Vector3();
	
			var invAspect = viewportHeight / viewportWidth,
				halfViewportWidth = viewportWidth * 0.5,
				halfViewportHeight = viewportHeight * 0.5;
	
			var size = 16 / viewportHeight,
				scale = new THREE.Vector2( size * invAspect, size );
	
			var screenPosition = new THREE.Vector3( 1, 1, 0 ),
				screenPositionPixels = new THREE.Vector2( 1, 1 );
	
			var uniforms = _lensFlare.uniforms,
				attributes = _lensFlare.attributes;
	
			// set _lensFlare program and reset blending
	
			_gl.useProgram( _lensFlare.program );
	
			_gl.enableVertexAttribArray( _lensFlare.attributes.vertex );
			_gl.enableVertexAttribArray( _lensFlare.attributes.uv );
	
			// loop through all lens flares to update their occlusion and positions
			// setup gl and common used attribs/unforms
	
			_gl.uniform1i( uniforms.occlusionMap, 0 );
			_gl.uniform1i( uniforms.map, 1 );
	
			_gl.bindBuffer( _gl.ARRAY_BUFFER, _lensFlare.vertexBuffer );
			_gl.vertexAttribPointer( attributes.vertex, 2, _gl.FLOAT, false, 2 * 8, 0 );
			_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 2 * 8, 8 );
	
			_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.elementBuffer );
	
			_gl.disable( _gl.CULL_FACE );
			_gl.depthMask( false );
	
			var i, j, jl, flare, sprite;
	
			for ( i = 0; i < nFlares; i ++ ) {
	
				size = 16 / viewportHeight;
				scale.set( size * invAspect, size );
	
				// calc object screen position
	
				flare = flares[ i ];
	
				tempPosition.set( flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14] );
	
				tempPosition.applyMatrix4( camera.matrixWorldInverse );
				tempPosition.applyProjection( camera.projectionMatrix );
	
				// setup arrays for gl programs
	
				screenPosition.copy( tempPosition )
	
				screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;
				screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;
	
				// screen cull
	
				if ( _lensFlare.hasVertexTexture || (
					screenPositionPixels.x > 0 &&
					screenPositionPixels.x < viewportWidth &&
					screenPositionPixels.y > 0 &&
					screenPositionPixels.y < viewportHeight ) ) {
	
					// save current RGB to temp texture
	
					_gl.activeTexture( _gl.TEXTURE1 );
					_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );
					_gl.copyTexImage2D( _gl.TEXTURE_2D, 0, _gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );
	
	
					// render pink quad
	
					_gl.uniform1i( uniforms.renderType, 0 );
					_gl.uniform2f( uniforms.scale, scale.x, scale.y );
					_gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
	
					_gl.disable( _gl.BLEND );
					_gl.enable( _gl.DEPTH_TEST );
	
					_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );
	
	
					// copy result to occlusionMap
	
					_gl.activeTexture( _gl.TEXTURE0 );
					_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.occlusionTexture );
					_gl.copyTexImage2D( _gl.TEXTURE_2D, 0, _gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );
	
	
					// restore graphics
	
					_gl.uniform1i( uniforms.renderType, 1 );
					_gl.disable( _gl.DEPTH_TEST );
	
					_gl.activeTexture( _gl.TEXTURE1 );
					_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );
					_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );
	
	
					// update object positions
	
					flare.positionScreen.copy( screenPosition )
	
					if ( flare.customUpdateCallback ) {
	
						flare.customUpdateCallback( flare );
	
					} else {
	
						flare.updateLensFlares();
	
					}
	
					// render flares
	
					_gl.uniform1i( uniforms.renderType, 2 );
					_gl.enable( _gl.BLEND );
	
					for ( j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {
	
						sprite = flare.lensFlares[ j ];
	
						if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {
	
							screenPosition.x = sprite.x;
							screenPosition.y = sprite.y;
							screenPosition.z = sprite.z;
	
							size = sprite.size * sprite.scale / viewportHeight;
	
							scale.x = size * invAspect;
							scale.y = size;
	
							_gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
							_gl.uniform2f( uniforms.scale, scale.x, scale.y );
							_gl.uniform1f( uniforms.rotation, sprite.rotation );
	
							_gl.uniform1f( uniforms.opacity, sprite.opacity );
							_gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );
	
							_renderer.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
							_renderer.setTexture( sprite.texture, 1 );
	
							_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );
	
						}
	
					}
	
				}
	
			}
	
			// restore gl
	
			_gl.enable( _gl.CULL_FACE );
			_gl.enable( _gl.DEPTH_TEST );
			_gl.depthMask( true );
	
		};
	
		function createProgram ( shader, precision ) {
	
			var program = _gl.createProgram();
	
			var fragmentShader = _gl.createShader( _gl.FRAGMENT_SHADER );
			var vertexShader = _gl.createShader( _gl.VERTEX_SHADER );
	
			var prefix = "precision " + precision + " float;\n";
	
			_gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
			_gl.shaderSource( vertexShader, prefix + shader.vertexShader );
	
			_gl.compileShader( fragmentShader );
			_gl.compileShader( vertexShader );
	
			_gl.attachShader( program, fragmentShader );
			_gl.attachShader( program, vertexShader );
	
			_gl.linkProgram( program );
	
			return program;
	
		};
	
	};
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.ShadowMapPlugin = function () {
	
		var _gl,
		_renderer,
		_depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin,
	
		_frustum = new THREE.Frustum(),
		_projScreenMatrix = new THREE.Matrix4(),
	
		_min = new THREE.Vector3(),
		_max = new THREE.Vector3(),
	
		_matrixPosition = new THREE.Vector3();
	
		this.init = function ( renderer ) {
	
			_gl = renderer.context;
			_renderer = renderer;
	
			var depthShader = THREE.ShaderLib[ "depthRGBA" ];
			var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );
	
			_depthMaterial = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms } );
			_depthMaterialMorph = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true } );
			_depthMaterialSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, skinning: true } );
			_depthMaterialMorphSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true, skinning: true } );
	
			_depthMaterial._shadowPass = true;
			_depthMaterialMorph._shadowPass = true;
			_depthMaterialSkin._shadowPass = true;
			_depthMaterialMorphSkin._shadowPass = true;
	
		};
	
		this.render = function ( scene, camera ) {
	
			if ( ! ( _renderer.shadowMapEnabled && _renderer.shadowMapAutoUpdate ) ) return;
	
			this.update( scene, camera );
	
		};
	
		this.update = function ( scene, camera ) {
	
			var i, il, j, jl, n,
	
			shadowMap, shadowMatrix, shadowCamera,
			program, buffer, material,
			webglObject, object, light,
			renderList,
	
			lights = [],
			k = 0,
	
			fog = null;
	
			// set GL state for depth map
	
			_gl.clearColor( 1, 1, 1, 1 );
			_gl.disable( _gl.BLEND );
	
			_gl.enable( _gl.CULL_FACE );
			_gl.frontFace( _gl.CCW );
	
			if ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {
	
				_gl.cullFace( _gl.FRONT );
	
			} else {
	
				_gl.cullFace( _gl.BACK );
	
			}
	
			_renderer.setDepthTest( true );
	
			// preprocess lights
			// 	- skip lights that are not casting shadows
			//	- create virtual lights for cascaded shadow maps
	
			for ( i = 0, il = scene.__lights.length; i < il; i ++ ) {
	
				light = scene.__lights[ i ];
	
				if ( ! light.castShadow ) continue;
	
				if ( ( light instanceof THREE.DirectionalLight ) && light.shadowCascade ) {
	
					for ( n = 0; n < light.shadowCascadeCount; n ++ ) {
	
						var virtualLight;
	
						if ( ! light.shadowCascadeArray[ n ] ) {
	
							virtualLight = createVirtualLight( light, n );
							virtualLight.originalCamera = camera;
	
							var gyro = new THREE.Gyroscope();
							gyro.position = light.shadowCascadeOffset;
	
							gyro.add( virtualLight );
							gyro.add( virtualLight.target );
	
							camera.add( gyro );
	
							light.shadowCascadeArray[ n ] = virtualLight;
	
							console.log( "Created virtualLight", virtualLight );
	
						} else {
	
							virtualLight = light.shadowCascadeArray[ n ];
	
						}
	
						updateVirtualLight( light, n );
	
						lights[ k ] = virtualLight;
						k ++;
	
					}
	
				} else {
	
					lights[ k ] = light;
					k ++;
	
				}
	
			}
	
			// render depth map
	
			for ( i = 0, il = lights.length; i < il; i ++ ) {
	
				light = lights[ i ];
	
				if ( ! light.shadowMap ) {
	
					var shadowFilter = THREE.LinearFilter;
	
					if ( _renderer.shadowMapType === THREE.PCFSoftShadowMap ) {
	
						shadowFilter = THREE.NearestFilter;
	
					}
	
					var pars = { minFilter: shadowFilter, magFilter: shadowFilter, format: THREE.RGBAFormat };
	
					light.shadowMap = new THREE.WebGLRenderTarget( light.shadowMapWidth, light.shadowMapHeight, pars );
					light.shadowMapSize = new THREE.Vector2( light.shadowMapWidth, light.shadowMapHeight );
	
					light.shadowMatrix = new THREE.Matrix4();
	
				}
	
				if ( ! light.shadowCamera ) {
	
					if ( light instanceof THREE.SpotLight ) {
	
						light.shadowCamera = new THREE.PerspectiveCamera( light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar );
	
					} else if ( light instanceof THREE.DirectionalLight ) {
	
						light.shadowCamera = new THREE.OrthographicCamera( light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar );
	
					} else {
	
						console.error( "Unsupported light type for shadow" );
						continue;
	
					}
	
					scene.add( light.shadowCamera );
	
					if ( _renderer.autoUpdateScene ) scene.updateMatrixWorld();
	
				}
	
				if ( light.shadowCameraVisible && ! light.cameraHelper ) {
	
					light.cameraHelper = new THREE.CameraHelper( light.shadowCamera );
					light.shadowCamera.add( light.cameraHelper );
	
				}
	
				if ( light.isVirtual && virtualLight.originalCamera == camera ) {
	
					updateShadowCamera( camera, light );
	
				}
	
				shadowMap = light.shadowMap;
				shadowMatrix = light.shadowMatrix;
				shadowCamera = light.shadowCamera;
	
				shadowCamera.position.getPositionFromMatrix( light.matrixWorld );
				_matrixPosition.getPositionFromMatrix( light.target.matrixWorld );
				shadowCamera.lookAt( _matrixPosition );
				shadowCamera.updateMatrixWorld();
	
				shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );
	
				if ( light.cameraHelper ) light.cameraHelper.visible = light.shadowCameraVisible;
				if ( light.shadowCameraVisible ) light.cameraHelper.update();
	
				// compute shadow matrix
	
				shadowMatrix.set( 0.5, 0.0, 0.0, 0.5,
								  0.0, 0.5, 0.0, 0.5,
								  0.0, 0.0, 0.5, 0.5,
								  0.0, 0.0, 0.0, 1.0 );
	
				shadowMatrix.multiply( shadowCamera.projectionMatrix );
				shadowMatrix.multiply( shadowCamera.matrixWorldInverse );
	
				// update camera matrices and frustum
	
				_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
				_frustum.setFromMatrix( _projScreenMatrix );
	
				// render shadow map
	
				_renderer.setRenderTarget( shadowMap );
				_renderer.clear();
	
				// set object matrices & frustum culling
	
				renderList = scene.__webglObjects;
	
				for ( j = 0, jl = renderList.length; j < jl; j ++ ) {
	
					webglObject = renderList[ j ];
					object = webglObject.object;
	
					webglObject.render = false;
	
					if ( object.visible && object.castShadow ) {
	
						if ( ! ( object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.intersectsObject( object ) ) {
	
							object._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );
	
							webglObject.render = true;
	
						}
	
					}
	
				}
	
				// render regular objects
	
				var objectMaterial, useMorphing, useSkinning;
	
				for ( j = 0, jl = renderList.length; j < jl; j ++ ) {
	
					webglObject = renderList[ j ];
	
					if ( webglObject.render ) {
	
						object = webglObject.object;
						buffer = webglObject.buffer;
	
						// culling is overriden globally for all objects
						// while rendering depth map
	
						// need to deal with MeshFaceMaterial somehow
						// in that case just use the first of material.materials for now
						// (proper solution would require to break objects by materials
						//  similarly to regular rendering and then set corresponding
						//  depth materials per each chunk instead of just once per object)
	
						objectMaterial = getObjectMaterial( object );
	
						useMorphing = object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;
						useSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;
	
						if ( object.customDepthMaterial ) {
	
							material = object.customDepthMaterial;
	
						} else if ( useSkinning ) {
	
							material = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;
	
						} else if ( useMorphing ) {
	
							material = _depthMaterialMorph;
	
						} else {
	
							material = _depthMaterial;
	
						}
	
						if ( buffer instanceof THREE.BufferGeometry ) {
	
							_renderer.renderBufferDirect( shadowCamera, scene.__lights, fog, material, buffer, object );
	
						} else {
	
							_renderer.renderBuffer( shadowCamera, scene.__lights, fog, material, buffer, object );
	
						}
	
					}
	
				}
	
				// set matrices and render immediate objects
	
				renderList = scene.__webglObjectsImmediate;
	
				for ( j = 0, jl = renderList.length; j < jl; j ++ ) {
	
					webglObject = renderList[ j ];
					object = webglObject.object;
	
					if ( object.visible && object.castShadow ) {
	
						object._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );
	
						_renderer.renderImmediateObject( shadowCamera, scene.__lights, fog, _depthMaterial, object );
	
					}
	
				}
	
			}
	
			// restore GL state
	
			var clearColor = _renderer.getClearColor(),
			clearAlpha = _renderer.getClearAlpha();
	
			_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );
			_gl.enable( _gl.BLEND );
	
			if ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {
	
				_gl.cullFace( _gl.BACK );
	
			}
	
		};
	
		function createVirtualLight( light, cascade ) {
	
			var virtualLight = new THREE.DirectionalLight();
	
			virtualLight.isVirtual = true;
	
			virtualLight.onlyShadow = true;
			virtualLight.castShadow = true;
	
			virtualLight.shadowCameraNear = light.shadowCameraNear;
			virtualLight.shadowCameraFar = light.shadowCameraFar;
	
			virtualLight.shadowCameraLeft = light.shadowCameraLeft;
			virtualLight.shadowCameraRight = light.shadowCameraRight;
			virtualLight.shadowCameraBottom = light.shadowCameraBottom;
			virtualLight.shadowCameraTop = light.shadowCameraTop;
	
			virtualLight.shadowCameraVisible = light.shadowCameraVisible;
	
			virtualLight.shadowDarkness = light.shadowDarkness;
	
			virtualLight.shadowBias = light.shadowCascadeBias[ cascade ];
			virtualLight.shadowMapWidth = light.shadowCascadeWidth[ cascade ];
			virtualLight.shadowMapHeight = light.shadowCascadeHeight[ cascade ];
	
			virtualLight.pointsWorld = [];
			virtualLight.pointsFrustum = [];
	
			var pointsWorld = virtualLight.pointsWorld,
				pointsFrustum = virtualLight.pointsFrustum;
	
			for ( var i = 0; i < 8; i ++ ) {
	
				pointsWorld[ i ] = new THREE.Vector3();
				pointsFrustum[ i ] = new THREE.Vector3();
	
			}
	
			var nearZ = light.shadowCascadeNearZ[ cascade ];
			var farZ = light.shadowCascadeFarZ[ cascade ];
	
			pointsFrustum[ 0 ].set( -1, -1, nearZ );
			pointsFrustum[ 1 ].set(  1, -1, nearZ );
			pointsFrustum[ 2 ].set( -1,  1, nearZ );
			pointsFrustum[ 3 ].set(  1,  1, nearZ );
	
			pointsFrustum[ 4 ].set( -1, -1, farZ );
			pointsFrustum[ 5 ].set(  1, -1, farZ );
			pointsFrustum[ 6 ].set( -1,  1, farZ );
			pointsFrustum[ 7 ].set(  1,  1, farZ );
	
			return virtualLight;
	
		}
	
		// Synchronize virtual light with the original light
	
		function updateVirtualLight( light, cascade ) {
	
			var virtualLight = light.shadowCascadeArray[ cascade ];
	
			virtualLight.position.copy( light.position );
			virtualLight.target.position.copy( light.target.position );
			virtualLight.lookAt( virtualLight.target );
	
			virtualLight.shadowCameraVisible = light.shadowCameraVisible;
			virtualLight.shadowDarkness = light.shadowDarkness;
	
			virtualLight.shadowBias = light.shadowCascadeBias[ cascade ];
	
			var nearZ = light.shadowCascadeNearZ[ cascade ];
			var farZ = light.shadowCascadeFarZ[ cascade ];
	
			var pointsFrustum = virtualLight.pointsFrustum;
	
			pointsFrustum[ 0 ].z = nearZ;
			pointsFrustum[ 1 ].z = nearZ;
			pointsFrustum[ 2 ].z = nearZ;
			pointsFrustum[ 3 ].z = nearZ;
	
			pointsFrustum[ 4 ].z = farZ;
			pointsFrustum[ 5 ].z = farZ;
			pointsFrustum[ 6 ].z = farZ;
			pointsFrustum[ 7 ].z = farZ;
	
		}
	
		// Fit shadow camera's ortho frustum to camera frustum
	
		function updateShadowCamera( camera, light ) {
	
			var shadowCamera = light.shadowCamera,
				pointsFrustum = light.pointsFrustum,
				pointsWorld = light.pointsWorld;
	
			_min.set( Infinity, Infinity, Infinity );
			_max.set( -Infinity, -Infinity, -Infinity );
	
			for ( var i = 0; i < 8; i ++ ) {
	
				var p = pointsWorld[ i ];
	
				p.copy( pointsFrustum[ i ] );
				THREE.ShadowMapPlugin.__projector.unprojectVector( p, camera );
	
				p.applyMatrix4( shadowCamera.matrixWorldInverse );
	
				if ( p.x < _min.x ) _min.x = p.x;
				if ( p.x > _max.x ) _max.x = p.x;
	
				if ( p.y < _min.y ) _min.y = p.y;
				if ( p.y > _max.y ) _max.y = p.y;
	
				if ( p.z < _min.z ) _min.z = p.z;
				if ( p.z > _max.z ) _max.z = p.z;
	
			}
	
			shadowCamera.left = _min.x;
			shadowCamera.right = _max.x;
			shadowCamera.top = _max.y;
			shadowCamera.bottom = _min.y;
	
			// can't really fit near/far
			//shadowCamera.near = _min.z;
			//shadowCamera.far = _max.z;
	
			shadowCamera.updateProjectionMatrix();
	
		}
	
		// For the moment just ignore objects that have multiple materials with different animation methods
		// Only the first material will be taken into account for deciding which depth material to use for shadow maps
	
		function getObjectMaterial( object ) {
	
			return object.material instanceof THREE.MeshFaceMaterial
				? object.material.materials[ 0 ]
				: object.material;
	
		};
	
	};
	
	THREE.ShadowMapPlugin.__projector = new THREE.Projector();
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.SpritePlugin = function () {
	
		var _gl, _renderer, _precision, _sprite = {};
	
		this.init = function ( renderer ) {
	
			_gl = renderer.context;
			_renderer = renderer;
	
			_precision = renderer.getPrecision();
	
			_sprite.vertices = new Float32Array( 8 + 8 );
			_sprite.faces    = new Uint16Array( 6 );
	
			var i = 0;
	
			_sprite.vertices[ i++ ] = -1; _sprite.vertices[ i++ ] = -1;	// vertex 0
			_sprite.vertices[ i++ ] = 0;  _sprite.vertices[ i++ ] = 0;	// uv 0
	
			_sprite.vertices[ i++ ] = 1;  _sprite.vertices[ i++ ] = -1;	// vertex 1
			_sprite.vertices[ i++ ] = 1;  _sprite.vertices[ i++ ] = 0;	// uv 1
	
			_sprite.vertices[ i++ ] = 1;  _sprite.vertices[ i++ ] = 1;	// vertex 2
			_sprite.vertices[ i++ ] = 1;  _sprite.vertices[ i++ ] = 1;	// uv 2
	
			_sprite.vertices[ i++ ] = -1; _sprite.vertices[ i++ ] = 1;	// vertex 3
			_sprite.vertices[ i++ ] = 0;  _sprite.vertices[ i++ ] = 1;	// uv 3
	
			i = 0;
	
			_sprite.faces[ i++ ] = 0; _sprite.faces[ i++ ] = 1; _sprite.faces[ i++ ] = 2;
			_sprite.faces[ i++ ] = 0; _sprite.faces[ i++ ] = 2; _sprite.faces[ i++ ] = 3;
	
			_sprite.vertexBuffer  = _gl.createBuffer();
			_sprite.elementBuffer = _gl.createBuffer();
	
			_gl.bindBuffer( _gl.ARRAY_BUFFER, _sprite.vertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, _sprite.vertices, _gl.STATIC_DRAW );
	
			_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _sprite.elementBuffer );
			_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, _sprite.faces, _gl.STATIC_DRAW );
	
			_sprite.program = createProgram( THREE.ShaderSprite[ "sprite" ], _precision );
	
			_sprite.attributes = {};
			_sprite.uniforms = {};
	
			_sprite.attributes.position           = _gl.getAttribLocation ( _sprite.program, "position" );
			_sprite.attributes.uv                 = _gl.getAttribLocation ( _sprite.program, "uv" );
	
			_sprite.uniforms.uvOffset             = _gl.getUniformLocation( _sprite.program, "uvOffset" );
			_sprite.uniforms.uvScale              = _gl.getUniformLocation( _sprite.program, "uvScale" );
	
			_sprite.uniforms.rotation             = _gl.getUniformLocation( _sprite.program, "rotation" );
			_sprite.uniforms.scale                = _gl.getUniformLocation( _sprite.program, "scale" );
			_sprite.uniforms.alignment            = _gl.getUniformLocation( _sprite.program, "alignment" );
	
			_sprite.uniforms.color                = _gl.getUniformLocation( _sprite.program, "color" );
			_sprite.uniforms.map                  = _gl.getUniformLocation( _sprite.program, "map" );
			_sprite.uniforms.opacity              = _gl.getUniformLocation( _sprite.program, "opacity" );
	
			_sprite.uniforms.useScreenCoordinates = _gl.getUniformLocation( _sprite.program, "useScreenCoordinates" );
			_sprite.uniforms.sizeAttenuation   	  = _gl.getUniformLocation( _sprite.program, "sizeAttenuation" );
			_sprite.uniforms.screenPosition    	  = _gl.getUniformLocation( _sprite.program, "screenPosition" );
			_sprite.uniforms.modelViewMatrix      = _gl.getUniformLocation( _sprite.program, "modelViewMatrix" );
			_sprite.uniforms.projectionMatrix     = _gl.getUniformLocation( _sprite.program, "projectionMatrix" );
	
			_sprite.uniforms.fogType 		  	  = _gl.getUniformLocation( _sprite.program, "fogType" );
			_sprite.uniforms.fogDensity 		  = _gl.getUniformLocation( _sprite.program, "fogDensity" );
			_sprite.uniforms.fogNear 		  	  = _gl.getUniformLocation( _sprite.program, "fogNear" );
			_sprite.uniforms.fogFar 		  	  = _gl.getUniformLocation( _sprite.program, "fogFar" );
			_sprite.uniforms.fogColor 		  	  = _gl.getUniformLocation( _sprite.program, "fogColor" );
	
			_sprite.uniforms.alphaTest 		  	  = _gl.getUniformLocation( _sprite.program, "alphaTest" );
	
		};
	
		this.render = function ( scene, camera, viewportWidth, viewportHeight ) {
	
			var sprites = scene.__webglSprites,
				nSprites = sprites.length;
	
			if ( ! nSprites ) return;
	
			var attributes = _sprite.attributes,
				uniforms = _sprite.uniforms;
	
			var invAspect = viewportHeight / viewportWidth;
	
			var halfViewportWidth = viewportWidth * 0.5,
				halfViewportHeight = viewportHeight * 0.5;
	
			// setup gl
	
			_gl.useProgram( _sprite.program );
	
			_gl.enableVertexAttribArray( attributes.position );
			_gl.enableVertexAttribArray( attributes.uv );
	
			_gl.disable( _gl.CULL_FACE );
			_gl.enable( _gl.BLEND );
	
			_gl.bindBuffer( _gl.ARRAY_BUFFER, _sprite.vertexBuffer );
			_gl.vertexAttribPointer( attributes.position, 2, _gl.FLOAT, false, 2 * 8, 0 );
			_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 2 * 8, 8 );
	
			_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _sprite.elementBuffer );
	
			_gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );
	
			_gl.activeTexture( _gl.TEXTURE0 );
			_gl.uniform1i( uniforms.map, 0 );
	
			var oldFogType = 0;
			var sceneFogType = 0;
			var fog = scene.fog;
	
			if ( fog ) {
	
				_gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );
	
				if ( fog instanceof THREE.Fog ) {
	
					_gl.uniform1f( uniforms.fogNear, fog.near );
					_gl.uniform1f( uniforms.fogFar, fog.far );
	
					_gl.uniform1i( uniforms.fogType, 1 );
					oldFogType = 1;
					sceneFogType = 1;
	
				} else if ( fog instanceof THREE.FogExp2 ) {
	
					_gl.uniform1f( uniforms.fogDensity, fog.density );
	
					_gl.uniform1i( uniforms.fogType, 2 );
					oldFogType = 2;
					sceneFogType = 2;
	
				}
	
			} else {
	
				_gl.uniform1i( uniforms.fogType, 0 );
				oldFogType = 0;
				sceneFogType = 0;
	
			}
	
	
			// update positions and sort
	
			var i, sprite, material, screenPosition, size, fogType, scale = [];
	
			for( i = 0; i < nSprites; i ++ ) {
	
				sprite = sprites[ i ];
				material = sprite.material;
	
				if ( ! sprite.visible || material.opacity === 0 ) continue;
	
				if ( ! material.useScreenCoordinates ) {
	
					sprite._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
					sprite.z = - sprite._modelViewMatrix.elements[ 14 ];
	
				} else {
	
					sprite.z = - sprite.position.z;
	
				}
	
			}
	
			sprites.sort( painterSortStable );
	
			// render all sprites
	
			for( i = 0; i < nSprites; i ++ ) {
	
				sprite = sprites[ i ];
				material = sprite.material;
	
				if ( ! sprite.visible || material.opacity === 0 ) continue;
	
				if ( material.map && material.map.image && material.map.image.width ) {
	
					_gl.uniform1f( uniforms.alphaTest, material.alphaTest );
	
					if ( material.useScreenCoordinates === true ) {
	
						_gl.uniform1i( uniforms.useScreenCoordinates, 1 );
						_gl.uniform3f(
							uniforms.screenPosition,
							( ( sprite.position.x * _renderer.devicePixelRatio ) - halfViewportWidth  ) / halfViewportWidth,
							( halfViewportHeight - ( sprite.position.y * _renderer.devicePixelRatio ) ) / halfViewportHeight,
							Math.max( 0, Math.min( 1, sprite.position.z ) )
						);
	
						scale[ 0 ] = _renderer.devicePixelRatio;
						scale[ 1 ] = _renderer.devicePixelRatio;
	
					} else {
	
						_gl.uniform1i( uniforms.useScreenCoordinates, 0 );
						_gl.uniform1i( uniforms.sizeAttenuation, material.sizeAttenuation ? 1 : 0 );
						_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite._modelViewMatrix.elements );
	
						scale[ 0 ] = 1;
						scale[ 1 ] = 1;
	
					}
	
					if ( scene.fog && material.fog ) {
	
						fogType = sceneFogType;
	
					} else {
	
						fogType = 0;
	
					}
	
					if ( oldFogType !== fogType ) {
	
						_gl.uniform1i( uniforms.fogType, fogType );
						oldFogType = fogType;
	
					}
	
					size = 1 / ( material.scaleByViewport ? viewportHeight : 1 );
	
					scale[ 0 ] *= size * invAspect * sprite.scale.x
					scale[ 1 ] *= size * sprite.scale.y;
	
					_gl.uniform2f( uniforms.uvScale, material.uvScale.x, material.uvScale.y );
					_gl.uniform2f( uniforms.uvOffset, material.uvOffset.x, material.uvOffset.y );
					_gl.uniform2f( uniforms.alignment, material.alignment.x, material.alignment.y );
	
					_gl.uniform1f( uniforms.opacity, material.opacity );
					_gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );
	
					_gl.uniform1f( uniforms.rotation, sprite.rotation );
					_gl.uniform2fv( uniforms.scale, scale );
	
					_renderer.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
					_renderer.setDepthTest( material.depthTest );
					_renderer.setDepthWrite( material.depthWrite );
					_renderer.setTexture( material.map, 0 );
	
					_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );
	
				}
	
			}
	
			// restore gl
	
			_gl.enable( _gl.CULL_FACE );
	
		};
	
		function createProgram ( shader, precision ) {
	
			var program = _gl.createProgram();
	
			var fragmentShader = _gl.createShader( _gl.FRAGMENT_SHADER );
			var vertexShader = _gl.createShader( _gl.VERTEX_SHADER );
	
			var prefix = "precision " + precision + " float;\n";
	
			_gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
			_gl.shaderSource( vertexShader, prefix + shader.vertexShader );
	
			_gl.compileShader( fragmentShader );
			_gl.compileShader( vertexShader );
	
			_gl.attachShader( program, fragmentShader );
			_gl.attachShader( program, vertexShader );
	
			_gl.linkProgram( program );
	
			return program;
	
		};
	
		function painterSortStable ( a, b ) {
	
			if ( a.z !== b.z ) {
	
				return b.z - a.z;
	
			} else {
	
				return b.id - a.id;
	
			}
	
		};
	
	};
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	THREE.DepthPassPlugin = function () {
	
		this.enabled = false;
		this.renderTarget = null;
	
		var _gl,
		_renderer,
		_depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin,
	
		_frustum = new THREE.Frustum(),
		_projScreenMatrix = new THREE.Matrix4();
	
		this.init = function ( renderer ) {
	
			_gl = renderer.context;
			_renderer = renderer;
	
			var depthShader = THREE.ShaderLib[ "depthRGBA" ];
			var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );
	
			_depthMaterial = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms } );
			_depthMaterialMorph = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true } );
			_depthMaterialSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, skinning: true } );
			_depthMaterialMorphSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true, skinning: true } );
	
			_depthMaterial._shadowPass = true;
			_depthMaterialMorph._shadowPass = true;
			_depthMaterialSkin._shadowPass = true;
			_depthMaterialMorphSkin._shadowPass = true;
	
		};
	
		this.render = function ( scene, camera ) {
	
			if ( ! this.enabled ) return;
	
			this.update( scene, camera );
	
		};
	
		this.update = function ( scene, camera ) {
	
			var i, il, j, jl, n,
	
			program, buffer, material,
			webglObject, object, light,
			renderList,
	
			fog = null;
	
			// set GL state for depth map
	
			_gl.clearColor( 1, 1, 1, 1 );
			_gl.disable( _gl.BLEND );
	
			_renderer.setDepthTest( true );
	
			// update scene
	
			if ( _renderer.autoUpdateScene ) scene.updateMatrixWorld();
	
			// update camera matrices and frustum
	
			camera.matrixWorldInverse.getInverse( camera.matrixWorld );
	
			_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
			_frustum.setFromMatrix( _projScreenMatrix );
	
			// render depth map
	
			_renderer.setRenderTarget( this.renderTarget );
			_renderer.clear();
	
			// set object matrices & frustum culling
	
			renderList = scene.__webglObjects;
	
			for ( j = 0, jl = renderList.length; j < jl; j ++ ) {
	
				webglObject = renderList[ j ];
				object = webglObject.object;
	
				webglObject.render = false;
	
				if ( object.visible ) {
	
					if ( ! ( object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.intersectsObject( object ) ) {
	
						object._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
	
						webglObject.render = true;
	
					}
	
				}
	
			}
	
			// render regular objects
	
			var objectMaterial, useMorphing, useSkinning;
	
			for ( j = 0, jl = renderList.length; j < jl; j ++ ) {
	
				webglObject = renderList[ j ];
	
				if ( webglObject.render ) {
	
					object = webglObject.object;
					buffer = webglObject.buffer;
	
					// todo: create proper depth material for particles
	
					if ( object instanceof THREE.ParticleSystem && !object.customDepthMaterial ) continue;
	
					objectMaterial = getObjectMaterial( object );
	
					if ( objectMaterial ) _renderer.setMaterialFaces( object.material );
	
					useMorphing = object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;
					useSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;
	
					if ( object.customDepthMaterial ) {
	
						material = object.customDepthMaterial;
	
					} else if ( useSkinning ) {
	
						material = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;
	
					} else if ( useMorphing ) {
	
						material = _depthMaterialMorph;
	
					} else {
	
						material = _depthMaterial;
	
					}
	
					if ( buffer instanceof THREE.BufferGeometry ) {
	
						_renderer.renderBufferDirect( camera, scene.__lights, fog, material, buffer, object );
	
					} else {
	
						_renderer.renderBuffer( camera, scene.__lights, fog, material, buffer, object );
	
					}
	
				}
	
			}
	
			// set matrices and render immediate objects
	
			renderList = scene.__webglObjectsImmediate;
	
			for ( j = 0, jl = renderList.length; j < jl; j ++ ) {
	
				webglObject = renderList[ j ];
				object = webglObject.object;
	
				if ( object.visible ) {
	
					object._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
	
					_renderer.renderImmediateObject( camera, scene.__lights, fog, _depthMaterial, object );
	
				}
	
			}
	
			// restore GL state
	
			var clearColor = _renderer.getClearColor(),
			clearAlpha = _renderer.getClearAlpha();
	
			_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );
			_gl.enable( _gl.BLEND );
	
		};
	
		// For the moment just ignore objects that have multiple materials with different animation methods
		// Only the first material will be taken into account for deciding which depth material to use
	
		function getObjectMaterial( object ) {
	
			return object.material instanceof THREE.MeshFaceMaterial
				? object.material.materials[ 0 ]
				: object.material;
	
		};
	
	};
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 *
	 */
	
	THREE.ShaderFlares = {
	
		'lensFlareVertexTexture': {
	
			vertexShader: [
	
				"uniform lowp int renderType;",
	
				"uniform vec3 screenPosition;",
				"uniform vec2 scale;",
				"uniform float rotation;",
	
				"uniform sampler2D occlusionMap;",
	
				"attribute vec2 position;",
				"attribute vec2 uv;",
	
				"varying vec2 vUV;",
				"varying float vVisibility;",
	
				"void main() {",
	
					"vUV = uv;",
	
					"vec2 pos = position;",
	
					"if( renderType == 2 ) {",
	
						"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) ) +",
										  "texture2D( occlusionMap, vec2( 0.5, 0.1 ) ) +",
										  "texture2D( occlusionMap, vec2( 0.9, 0.1 ) ) +",
										  "texture2D( occlusionMap, vec2( 0.9, 0.5 ) ) +",
										  "texture2D( occlusionMap, vec2( 0.9, 0.9 ) ) +",
										  "texture2D( occlusionMap, vec2( 0.5, 0.9 ) ) +",
										  "texture2D( occlusionMap, vec2( 0.1, 0.9 ) ) +",
										  "texture2D( occlusionMap, vec2( 0.1, 0.5 ) ) +",
										  "texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",
	
						"vVisibility = (       visibility.r / 9.0 ) *",
									  "( 1.0 - visibility.g / 9.0 ) *",
									  "(       visibility.b / 9.0 ) *",
									  "( 1.0 - visibility.a / 9.0 );",
	
						"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
						"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",
	
					"}",
	
					"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",
	
				"}"
	
			].join( "\n" ),
	
			fragmentShader: [
	
				"uniform lowp int renderType;",
	
				"uniform sampler2D map;",
				"uniform float opacity;",
				"uniform vec3 color;",
	
				"varying vec2 vUV;",
				"varying float vVisibility;",
	
				"void main() {",
	
					// pink square
	
					"if( renderType == 0 ) {",
	
						"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",
	
					// restore
	
					"} else if( renderType == 1 ) {",
	
						"gl_FragColor = texture2D( map, vUV );",
	
					// flare
	
					"} else {",
	
						"vec4 texture = texture2D( map, vUV );",
						"texture.a *= opacity * vVisibility;",
						"gl_FragColor = texture;",
						"gl_FragColor.rgb *= color;",
	
					"}",
	
				"}"
			].join( "\n" )
	
		},
	
	
		'lensFlare': {
	
			vertexShader: [
	
				"uniform lowp int renderType;",
	
				"uniform vec3 screenPosition;",
				"uniform vec2 scale;",
				"uniform float rotation;",
	
				"attribute vec2 position;",
				"attribute vec2 uv;",
	
				"varying vec2 vUV;",
	
				"void main() {",
	
					"vUV = uv;",
	
					"vec2 pos = position;",
	
					"if( renderType == 2 ) {",
	
						"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
						"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",
	
					"}",
	
					"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",
	
				"}"
	
			].join( "\n" ),
	
			fragmentShader: [
	
				"precision mediump float;",
	
				"uniform lowp int renderType;",
	
				"uniform sampler2D map;",
				"uniform sampler2D occlusionMap;",
				"uniform float opacity;",
				"uniform vec3 color;",
	
				"varying vec2 vUV;",
	
				"void main() {",
	
					// pink square
	
					"if( renderType == 0 ) {",
	
						"gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );",
	
					// restore
	
					"} else if( renderType == 1 ) {",
	
						"gl_FragColor = texture2D( map, vUV );",
	
					// flare
	
					"} else {",
	
						"float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a +",
										   "texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a +",
										   "texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a +",
										   "texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;",
	
						"visibility = ( 1.0 - visibility / 4.0 );",
	
						"vec4 texture = texture2D( map, vUV );",
						"texture.a *= opacity * visibility;",
						"gl_FragColor = texture;",
						"gl_FragColor.rgb *= color;",
	
					"}",
	
				"}"
	
			].join( "\n" )
	
		}
	
	};
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 */
	
	THREE.ShaderSprite = {
	
		'sprite': {
	
			vertexShader: [
	
				"uniform int useScreenCoordinates;",
				"uniform int sizeAttenuation;",
				"uniform vec3 screenPosition;",
				"uniform mat4 modelViewMatrix;",
				"uniform mat4 projectionMatrix;",
				"uniform float rotation;",
				"uniform vec2 scale;",
				"uniform vec2 alignment;",
				"uniform vec2 uvOffset;",
				"uniform vec2 uvScale;",
	
				"attribute vec2 position;",
				"attribute vec2 uv;",
	
				"varying vec2 vUV;",
	
				"void main() {",
	
					"vUV = uvOffset + uv * uvScale;",
	
					"vec2 alignedPosition = position + alignment;",
	
					"vec2 rotatedPosition;",
					"rotatedPosition.x = ( cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y ) * scale.x;",
					"rotatedPosition.y = ( sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y ) * scale.y;",
	
					"vec4 finalPosition;",
	
					"if( useScreenCoordinates != 0 ) {",
	
						"finalPosition = vec4( screenPosition.xy + rotatedPosition, screenPosition.z, 1.0 );",
	
					"} else {",
	
						"finalPosition = projectionMatrix * modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );",
						"finalPosition.xy += rotatedPosition * ( sizeAttenuation == 1 ? 1.0 : finalPosition.z );",
	
					"}",
	
					"gl_Position = finalPosition;",
	
				"}"
	
			].join( "\n" ),
	
			fragmentShader: [
	
				"uniform vec3 color;",
				"uniform sampler2D map;",
				"uniform float opacity;",
	
				"uniform int fogType;",
				"uniform vec3 fogColor;",
				"uniform float fogDensity;",
				"uniform float fogNear;",
				"uniform float fogFar;",
				"uniform float alphaTest;",
	
				"varying vec2 vUV;",
	
				"void main() {",
	
					"vec4 texture = texture2D( map, vUV );",
	
					"if ( texture.a < alphaTest ) discard;",
	
					"gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );",
	
					"if ( fogType > 0 ) {",
	
						"float depth = gl_FragCoord.z / gl_FragCoord.w;",
						"float fogFactor = 0.0;",
	
						"if ( fogType == 1 ) {",
	
							"fogFactor = smoothstep( fogNear, fogFar, depth );",
	
						"} else {",
	
							"const float LOG2 = 1.442695;",
							"float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );",
							"fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );",
	
						"}",
	
						"gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );",
	
					"}",
	
				"}"
	
			].join( "\n" )
	
		}
	
	};
	
	// Export the THREE object for **Node.js**, with
	// backwards-compatibility for the old `require()` API. If we're in
	// the browser, add `_` as a global object via a string identifier,
	// for Closure Compiler "advanced" mode.
	if (true) {
	  if (typeof module !== 'undefined' && module.exports) {
	    exports = module.exports = THREE;
	  }
	  exports.THREE = THREE;
	} else {
	  this['THREE'] = THREE;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

/***/ },
/* 12 */
/***/ function(module, exports) {

	// shim for using process in browser
	
	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(11);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _voxelMesh = __webpack_require__(14);
	
	var _voxelMesh2 = _interopRequireDefault(_voxelMesh);
	
	var _voxelTexture = __webpack_require__(15);
	
	var _voxelTexture2 = _interopRequireDefault(_voxelTexture);
	
	var _voxel = __webpack_require__(20);
	
	var _voxel2 = _interopRequireDefault(_voxel);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var TerrainView = function () {
		_createClass(TerrainView, null, [{
			key: 'create',
			value: function create(terrain) {
				return new TerrainView(terrain);
			}
		}]);
	
		function TerrainView(terrain) {
			_classCallCheck(this, TerrainView);
	
			this.terrain = terrain;
			this.three = new _three2.default.Object3D();
			this.materials = new _voxelTexture2.default({
				game: {
					THREE: _three2.default
				},
				texturePath: '/client/textures/',
				materialType: _three2.default.MeshLambertMaterial,
				materialParams: {},
				materialFlatColor: false
			});
	
			this.materialNames = [['grass', 'dirt', 'grass_dirt'], 'brick', 'dirt', 'obsidian', 'plank', 'shama', 'whitewool'];
			this.materials.load(this.materialNames);
	
			this.showAllChunks();
		}
	
		_createClass(TerrainView, [{
			key: 'showChunkAtPosition',
			value: function showChunkAtPosition(pos) {
				var voxels = this.terrain.get('voxels'),
				    chunkID = voxels.chunkAtPosition(pos).join('|'),
				    chunk = voxels.chunks[chunkID];
				this.showChunk(chunk);
			}
		}, {
			key: 'showAllChunks',
			value: function showAllChunks() {
				var chunks = this.terrain.get('voxels').chunks;
				for (var chunkIndex in chunks) {
					this.showChunk(chunks[chunkIndex]);
				}
			}
		}, {
			key: 'showChunk',
			value: function showChunk(chunk) {
				var chunkIndex = chunk.position.join('|');
	
				var voxels = this.terrain.get('voxels'),
				    bounds = voxels.getBounds.apply(this.voxels, chunk.position),
				    scale = new _three2.default.Vector3(1, 1, 1),
				    mesher = _voxel2.default.meshers.culled,
				    mesh = (0, _voxelMesh2.default)(chunk, mesher, scale, _three2.default);
				voxels.chunks[chunkIndex] = chunk;
				if (voxels.meshes[chunkIndex]) {
					if (voxels.meshes[chunkIndex].surfaceMesh) {
						this.three.remove(voxels.meshes[chunkIndex].surfaceMesh);
					}
					if (voxels.meshes[chunkIndex].wireMesh) {
						this.three.remove(voxels.meshes[chunkIndex].wireMesh);
					}
				}
				voxels.meshes[chunkIndex] = mesh;
	
				if (this.meshType === 'wireMesh') {
					mesh.createWireMesh(0x111111);
				} else {
					mesh.createSurfaceMesh(this.materials.material);
					mesh.surfaceMesh.castShadow = mesh.surfaceMesh.receiveShadow = true;
				}
	
				this.materials.paint(mesh);
	
				mesh.setPosition(bounds[0][0] * 32, bounds[0][1] * 32, bounds[0][2] * 32);
	
				mesh.addToScene(this.three);
	
				return mesh;
			}
		}]);
	
		return TerrainView;
	}();
	
	exports.default = TerrainView;
	;

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	var THREE = __webpack_require__(11)
	
	module.exports = function(data, mesher, scaleFactor, three) {
	  return new Mesh(data, mesher, scaleFactor, three)
	}
	
	module.exports.Mesh = Mesh
	
	function Mesh(data, mesher, scaleFactor, three) {
	  this.THREE = three || THREE
	  this.data = data
	  var geometry = this.geometry = new this.THREE.Geometry()
	  this.scale = scaleFactor || new this.THREE.Vector3(10, 10, 10)
	  
	  var result = mesher( data.voxels, data.dims )
	  this.meshed = result
	
	  geometry.vertices.length = 0
	  geometry.faces.length = 0
	
	  for (var i = 0; i < result.vertices.length; ++i) {
	    var q = result.vertices[i]
	    geometry.vertices.push(new this.THREE.Vector3(q[0], q[1], q[2]))
	  } 
	  
	  for (var i = 0; i < result.faces.length; ++i) {
	    geometry.faceVertexUvs[0].push(this.faceVertexUv(i))
	    
	    var q = result.faces[i]
	    if (q.length === 5) {
	      var f = new this.THREE.Face4(q[0], q[1], q[2], q[3])
	      f.color = new this.THREE.Color(q[4])
	      geometry.faces.push(f)
	    } else if (q.length == 4) {
	      var f = new this.THREE.Face3(q[0], q[1], q[2])
	      f.color = new this.THREE.Color(q[3])
	      geometry.faces.push(f)
	    }
	  }
	  
	  geometry.computeFaceNormals()
	
	  geometry.verticesNeedUpdate = true
	  geometry.elementsNeedUpdate = true
	  geometry.normalsNeedUpdate = true
	
	  geometry.computeBoundingBox()
	  geometry.computeBoundingSphere()
	
	}
	
	Mesh.prototype.createWireMesh = function(hexColor) {    
	  var wireMaterial = new this.THREE.MeshBasicMaterial({
	    color : hexColor || 0xffffff,
	    wireframe : true
	  })
	  wireMesh = new this.THREE.Mesh(this.geometry, wireMaterial)
	  wireMesh.scale = this.scale
	  wireMesh.doubleSided = true
	  this.wireMesh = wireMesh
	  return wireMesh
	}
	
	Mesh.prototype.createSurfaceMesh = function(material) {
	  material = material || new this.THREE.MeshNormalMaterial()
	  var surfaceMesh  = new this.THREE.Mesh( this.geometry, material )
	  surfaceMesh.scale = this.scale
	  surfaceMesh.doubleSided = false
	  this.surfaceMesh = surfaceMesh
	  return surfaceMesh
	}
	
	Mesh.prototype.addToScene = function(scene) {
	  if (this.wireMesh) scene.add( this.wireMesh )
	  if (this.surfaceMesh) scene.add( this.surfaceMesh )
	}
	
	Mesh.prototype.setPosition = function(x, y, z) {
	  if (this.wireMesh) this.wireMesh.position = new this.THREE.Vector3(x, y, z)
	  if (this.surfaceMesh) this.surfaceMesh.position = new this.THREE.Vector3(x, y, z)
	}
	
	Mesh.prototype.faceVertexUv = function(i) {
	  var vs = [
	    this.meshed.vertices[i*4+0],
	    this.meshed.vertices[i*4+1],
	    this.meshed.vertices[i*4+2],
	    this.meshed.vertices[i*4+3]
	  ]
	  var spans = {
	    x0: vs[0][0] - vs[1][0],
	    x1: vs[1][0] - vs[2][0],
	    y0: vs[0][1] - vs[1][1],
	    y1: vs[1][1] - vs[2][1],
	    z0: vs[0][2] - vs[1][2],
	    z1: vs[1][2] - vs[2][2]
	  }
	  var size = {
	    x: Math.max(Math.abs(spans.x0), Math.abs(spans.x1)),
	    y: Math.max(Math.abs(spans.y0), Math.abs(spans.y1)),
	    z: Math.max(Math.abs(spans.z0), Math.abs(spans.z1))
	  }
	  if (size.x === 0) {
	    if (spans.y0 > spans.y1) {
	      var width = size.y
	      var height = size.z
	    }
	    else {
	      var width = size.z
	      var height = size.y
	    }
	  }
	  if (size.y === 0) {
	    if (spans.x0 > spans.x1) {
	      var width = size.x
	      var height = size.z
	    }
	    else {
	      var width = size.z
	      var height = size.x
	    }
	  }
	  if (size.z === 0) {
	    if (spans.x0 > spans.x1) {
	      var width = size.x
	      var height = size.y
	    }
	    else {
	      var width = size.y
	      var height = size.x
	    }
	  }
	  if ((size.z === 0 && spans.x0 < spans.x1) || (size.x === 0 && spans.y0 > spans.y1)) {
	    return [
	      new this.THREE.Vector2(height, 0),
	      new this.THREE.Vector2(0, 0),
	      new this.THREE.Vector2(0, width),
	      new this.THREE.Vector2(height, width)
	    ]
	  } else {
	    return [
	      new this.THREE.Vector2(0, 0),
	      new this.THREE.Vector2(0, height),
	      new this.THREE.Vector2(width, height),
	      new this.THREE.Vector2(width, 0)
	    ]
	  }
	}
	;


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	var tic = __webpack_require__(16)();
	var createAtlas = __webpack_require__(17);
	var isTransparent = __webpack_require__(18).transparent;
	
	function Texture(opts) {
	  if (!(this instanceof Texture)) return new Texture(opts || {});
	  var self = this;
	  this.game = opts.game; delete opts.game;
	  this.THREE = this.game.THREE;
	  this.materials = [];
	  this.transparents = [];
	  this.texturePath = opts.texturePath || '/textures/';
	  this.loading = 0;
	  this.ao = __webpack_require__(19)(this.game);
	
	  var useFlatColors = opts.materialFlatColor === true;
	  delete opts.materialFlatColor;
	
	  this.options = defaults(opts || {}, {
	    crossOrigin: 'Anonymous',
	    materialParams: defaults(opts.materialParams || {}, {
	      ambient: 0xbbbbbb,
	      transparent: false,
	      side: this.THREE.DoubleSide,
	    }),
	    materialTransparentParams: defaults(opts.materialTransparentParams || {}, {
	      ambient: 0xbbbbbb,
	      transparent: true,
	      side: this.THREE.DoubleSide,
	      //depthWrite: false,
	      //depthTest: false
	    }),
	    materialType: this.THREE.MeshLambertMaterial,
	    applyTextureParams: function(map) {
	      map.magFilter = self.THREE.NearestFilter;
	      map.minFilter = self.THREE.LinearMipMapLinearFilter;
	    }
	  });
	
	  // create a canvas for the texture atlas
	  this.canvas = (typeof document !== 'undefined') ? document.createElement('canvas') : {};
	  this.canvas.width = opts.atlasWidth || 512;
	  this.canvas.height = opts.atlasHeight || 512;
	  var ctx = this.canvas.getContext('2d');
	  ctx.fillStyle = 'black';
	  ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
	
	  // create core atlas and texture
	  this.atlas = createAtlas(this.canvas);
	  this.atlas.tilepad = true;
	  this._atlasuv = false;
	  this._atlaskey = false;
	  this.texture = new this.THREE.Texture(this.canvas);
	  this.options.applyTextureParams(this.texture);
	
	  if (useFlatColors) {
	    // If were using simple colors
	    this.material = new this.THREE.MeshBasicMaterial({
	      vertexColors: this.THREE.VertexColors
	    });
	  } else {
	    var opaque = new this.options.materialType(this.options.materialParams);
	    opaque.map = this.texture;
	    var transparent = new this.options.materialType(this.options.materialTransparentParams);
	    transparent.map = this.texture;
	    this.material = new this.THREE.MeshFaceMaterial([
	      opaque,
	      transparent
	    ]);
	  }
	
	  // a place for meshes to wait while textures are loading
	  this._meshQueue = [];
	}
	module.exports = Texture;
	
	Texture.prototype.load = function(names, done) {
	  var self = this;
	  if (!Array.isArray(names)) names = [names];
	  done = done || function() {};
	  this.loading++;
	
	  var materialSlice = names.map(self._expandName);
	  self.materials = self.materials.concat(materialSlice);
	
	  // load onto the texture atlas
	  var load = Object.create(null);
	  materialSlice.forEach(function(mats) {
	    mats.forEach(function(mat) {
	      if (mat.slice(0, 1) === '#') return;
	      // todo: check if texture already exists
	      load[mat] = true;
	    });
	  });
	  if (Object.keys(load).length > 0) {
	    each(Object.keys(load), self.pack.bind(self), function() {
	      self._afterLoading();
	      done(materialSlice);
	    });
	  } else {
	    self._afterLoading();
	  }
	};
	
	Texture.prototype.pack = function(name, done) {
	  var self = this;
	  function pack(img) {
	    var node = self.atlas.pack(img);
	    if (node === false) {
	      self.atlas = self.atlas.expand(img);
	      self.atlas.tilepad = true;
	    }
	    done();
	  }
	  if (typeof name === 'string') {
	    var img = new Image();
	    img.id = name;
	    img.crossOrigin = self.options.crossOrigin;
	    img.src = self.texturePath + ext(name);
	    img.onload = function() {
	      if (isTransparent(img)) {
	        self.transparents.push(name);
	      }
	      pack(img);
	    };
	    img.onerror = function() {
	      console.error('Couldn\'t load URL [' + img.src + ']');
	      done();
	    };
	  } else {
	    pack(name);
	  }
	  return self;
	};
	
	Texture.prototype.find = function(name) {
	  var self = this;
	  var type = 0;
	  self.materials.forEach(function(mats, i) {
	    mats.forEach(function(mat) {
	      if (mat === name) {
	        type = i + 1;
	        return false;
	      }
	    });
	    if (type !== 0) return false;
	  });
	  return type;
	};
	
	Texture.prototype._expandName = function(name) {
	  if (name === null) return Array(6);
	  if (name.top) return [name.back, name.front, name.top, name.bottom, name.left, name.right];
	  if (!Array.isArray(name)) name = [name];
	  // load the 0 texture to all
	  if (name.length === 1) name = [name[0],name[0],name[0],name[0],name[0],name[0]];
	  // 0 is top/bottom, 1 is sides
	  if (name.length === 2) name = [name[1],name[1],name[0],name[0],name[1],name[1]];
	  // 0 is top, 1 is bottom, 2 is sides
	  if (name.length === 3) name = [name[2],name[2],name[0],name[1],name[2],name[2]];
	  // 0 is top, 1 is bottom, 2 is front/back, 3 is left/right
	  if (name.length === 4) name = [name[2],name[2],name[0],name[1],name[3],name[3]];
	  return name;
	};
	
	Texture.prototype._afterLoading = function() {
	  var self = this;
	  function alldone() {
	    self.loading--;
	    self._atlasuv = self.atlas.uv(self.canvas.width, self.canvas.height);
	    self._atlaskey = Object.create(null);
	    self.atlas.index().forEach(function(key) {
	      self._atlaskey[key.name] = key;
	    });
	    self.texture.needsUpdate = true;
	    self.material.needsUpdate = true;
	    //window.open(self.canvas.toDataURL());
	    if (self._meshQueue.length > 0) {
	      self._meshQueue.forEach(function(queue, i) {
	        self.paint.apply(queue.self, queue.args);
	        delete self._meshQueue[i];
	      });
	    }
	  }
	  self._powerof2(function() {
	    setTimeout(alldone, 100);
	  });
	};
	
	// Ensure the texture stays at a power of 2 for mipmaps
	// this is cheating :D
	Texture.prototype._powerof2 = function(done) {
	  var w = this.canvas.width;
	  var h = this.canvas.height;
	  function pow2(x) {
	    x--;
	    x |= x >> 1;
	    x |= x >> 2;
	    x |= x >> 4;
	    x |= x >> 8;
	    x |= x >> 16;
	    x++;
	    return x;
	  }
	  if (h > w) w = h;
	  var old = this.canvas.getContext('2d').getImageData(0, 0, this.canvas.width, this.canvas.height);
	  this.canvas.width = this.canvas.height = pow2(w);
	  this.canvas.getContext('2d').putImageData(old, 0, 0);
	  done();
	};
	
	Texture.prototype.paint = function(mesh, materials) {
	  var self = this;
	
	  // if were loading put into queue
	  if (self.loading > 0) {
	    self._meshQueue.push({self: self, args: arguments});
	    return false;
	  }
	
	  var isVoxelMesh = (materials) ? false : true;
	  if (!isVoxelMesh) materials = self._expandName(materials);
	
	  mesh.geometry.faces.forEach(function(face, i) {
	    if (mesh.geometry.faceVertexUvs[0].length < 1) return;
	
	    if (isVoxelMesh) {
	      var index = Math.floor(face.color.b*255 + face.color.g*255*255 + face.color.r*255*255*255);
	      materials = self.materials[index - 1];
	      if (!materials) materials = self.materials[0];
	    }
	
	    // BACK, FRONT, TOP, BOTTOM, LEFT, RIGHT
	    var name = materials[0] || '';
	    if      (face.normal.z === 1)  name = materials[1] || '';
	    else if (face.normal.y === 1)  name = materials[2] || '';
	    else if (face.normal.y === -1) name = materials[3] || '';
	    else if (face.normal.x === -1) name = materials[4] || '';
	    else if (face.normal.x === 1)  name = materials[5] || '';
	
	    // if just a simple color
	    if (name.slice(0, 1) === '#') {
	      self.ao(face, name);
	      return;
	    }
	
	    var atlasuv = self._atlasuv[name];
	    if (!atlasuv) return;
	
	    // If a transparent texture use transparent material
	    face.materialIndex = (self.transparents.indexOf(name) !== -1) ? 1 : 0;
	
	    // 0 -- 1
	    // |    |
	    // 3 -- 2
	    // faces on these meshes are flipped vertically, so we map in reverse
	    // TODO: tops need rotate
	    if (isVoxelMesh) {
	      if (face.normal.z === -1 || face.normal.x === 1) {
	        atlasuv = uvrot(atlasuv, 90);
	      }
	      atlasuv = uvinvert(atlasuv);
	    } else {
	      atlasuv = uvrot(atlasuv, -90);
	    }
	    for (var j = 0; j < mesh.geometry.faceVertexUvs[0][i].length; j++) {
	      mesh.geometry.faceVertexUvs[0][i][j].set(atlasuv[j][0], 1 - atlasuv[j][1]);
	    }
	  });
	
	  mesh.geometry.uvsNeedUpdate = true;
	};
	
	Texture.prototype.sprite = function(name, w, h, cb) {
	  var self = this;
	  if (typeof w === 'function') { cb = w; w = null; }
	  if (typeof h === 'function') { cb = h; h = null; }
	  w = w || 16; h = h || w;
	  self.loading++;
	  var img = new Image();
	  img.src = self.texturePath + ext(name);
	  img.onerror = cb;
	  img.onload = function() {
	    var canvases = [];
	    for (var x = 0; x < img.width; x += w) {
	      for (var y = 0; y < img.height; y += h) {
	        var canvas = document.createElement('canvas');
	        canvas.width = w; canvas.height = h;
	        canvas.name = name + '_' + x + '_' + y;
	        canvas.getContext('2d').drawImage(img, x, y, w, h, 0, 0, w, h);
	        canvases.push(canvas);
	      }
	    }
	    var textures = [];
	    each(canvases, function(canvas, next) {
	      var tex = new Image();
	      tex.name = canvas.name;
	      tex.src = canvas.toDataURL();
	      tex.onload = function() {
	        self.pack(tex, next);
	      };
	      tex.onerror = next;
	      textures.push([
	        tex.name, tex.name, tex.name,
	        tex.name, tex.name, tex.name
	      ]);
	    }, function() {
	      self._afterLoading();
	      delete canvases;
	      self.materials = self.materials.concat(textures);
	      cb(textures);
	    });
	  };
	  return self;
	};
	
	Texture.prototype.animate = function(mesh, names, delay) {
	  var self = this;
	  delay = delay || 1000;
	  if (!Array.isArray(names) || names.length < 2) return false;
	  var i = 0;
	  var mat = new this.options.materialType(this.options.materialParams);
	  mat.map = this.texture;
	  mat.transparent = true;
	  mat.needsUpdate = true;
	  tic.interval(function() {
	    self.paint(mesh, names[i % names.length]);
	    i++;
	  }, delay);
	  return mat;
	};
	
	Texture.prototype.tick = function(dt) {
	  tic.tick(dt);
	};
	
	function uvrot(coords, deg) {
	  if (deg === 0) return coords;
	  var c = [];
	  var i = (4 - Math.ceil(deg / 90)) % 4;
	  for (var j = 0; j < 4; j++) {
	    c.push(coords[i]);
	    if (i === 3) i = 0; else i++;
	  }
	  return c;
	}
	
	function uvinvert(coords) {
	  var c = coords.slice(0);
	  return [c[3], c[2], c[1], c[0]];
	}
	
	function ext(name) {
	  return (String(name).indexOf('.') !== -1) ? name : name + '.png';
	}
	
	function defaults(obj) {
	  [].slice.call(arguments, 1).forEach(function(from) {
	    if (from) for (var k in from) if (obj[k] == null) obj[k] = from[k];
	  });
	  return obj;
	}
	
	function each(arr, it, done) {
	  var count = 0;
	  arr.forEach(function(a) {
	    it(a, function() {
	      count++;
	      if (count >= arr.length) done();
	    });
	  });
	}


/***/ },
/* 16 */
/***/ function(module, exports) {

	/*
	 * tic
	 * https://github.com/shama/tic
	 *
	 * Copyright (c) 2013 Kyle Robinson Young
	 * Licensed under the MIT license.
	 */
	
	function Tic() { this._things = []; }
	module.exports = function() { return new Tic(); };
	
	Tic.prototype._stack = function(thing) {
	  var self = this;
	  self._things.push(thing);
	  var i = self._things.length - 1;
	  return function() { delete self._things[i]; }
	};
	
	Tic.prototype.interval = Tic.prototype.setInterval = function(fn, at) {
	  return this._stack({
	    fn: fn, at: at, args: Array.prototype.slice.call(arguments, 2),
	    elapsed: 0, once: false
	  });
	};
	
	Tic.prototype.timeout = Tic.prototype.setTimeout = function(fn, at) {
	  return this._stack({
	    fn: fn, at: at, args: Array.prototype.slice.call(arguments, 2),
	    elapsed: 0, once: true
	  });
	};
	
	Tic.prototype.tick = function(dt) {
	  var self = this;
	  self._things.forEach(function(thing, i) {
	    thing.elapsed += dt;
	    if (thing.elapsed > thing.at) {
	      thing.elapsed -= thing.at;
	      thing.fn.apply(thing.fn, thing.args || []);
	      if (thing.once) {
	        delete self._things[i];
	      }
	    }
	  });
	};


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	var require;var require;!function(e){if(true)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.atlaspack=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
	/*
	 * atlaspack
	 * https://github.com/shama/atlaspack
	 *
	 * Copyright (c) 2014 Kyle Robinson Young
	 * Licensed under the MIT license.
	 *
	 * Based on Nick Welch's binpack: https://github.com/mackstann/binpack
	 */
	
	function Rect(x, y, w, h) {
	  this.x = x; this.y = y;
	  this.w = w; this.h = h;
	}
	
	Rect.prototype.fitsIn = function(outer) {
	  return outer.w >= this.w && outer.h >= this.h;
	};
	
	Rect.prototype.sameSizeAs = function(other) {
	  return this.w === other.w && this.h === other.h;
	};
	
	function Atlas(x, y, w, h) {
	  if (arguments.length === 1) {
	    this.canvas = x;
	    x = y = 0;
	    w = this.canvas.width;
	    h = this.canvas.height;
	  }
	  if (arguments.length === 2) {
	    w = x; h = y; x = y = 0;
	  }
	  this.left = this.right = null;
	  this.rect = new Rect(x, y, w, h);
	  this.filled = false;
	  this.tilepad = false;
	  this._cache = [];
	  this._uvcache = Object.create(null);
	}
	module.exports = function() {
	  if (arguments.length === 1) { return new Atlas(arguments[0]); }
	  if (arguments.length === 2) { return new Atlas(arguments[0], arguments[1]); }
	  return new Atlas(arguments[0], arguments[1], arguments[2], arguments[3]);
	};
	module.exports.Atlas = Atlas;
	module.exports.Rect = Rect;
	
	// pack image/rect to the atlas
	Atlas.prototype.pack = function(rect) {
	  this._cache = [];
	  this._uvcache = Object.create(null);
	  rect = this._toRect(rect);
	
	  if (this.img && this.tilepad) {
	    rect = this._tilepad(rect);
	  }
	
	  if (this.left !== null) {
	    return this._ontoCanvas(this.left.pack(rect) || this.right.pack(rect));
	  }
	  // if atlas filled or wont fit
	  if (this.filled || !rect.fitsIn(this.rect)) {
	    return false;
	  }
	  // if this atlas has been filled
	  if (rect.sameSizeAs(this.rect)) {
	    this.filled = true;
	    return this._ontoCanvas(this);
	  }
	  if ((this.rect.w - rect.w) > (this.rect.h - rect.h)) {
	    this.left = new Atlas(this.rect.x, this.rect.y, rect.w, this.rect.h);
	    this.right = new Atlas(this.rect.x + rect.w, this.rect.y, this.rect.w - rect.w, this.rect.h);
	  } else {
	    this.left = new Atlas(this.rect.x, this.rect.y, this.rect.w, rect.h);
	    this.right = new Atlas(this.rect.x, this.rect.y + rect.h, this.rect.w, this.rect.h - rect.h);
	  }
	  return this._ontoCanvas(this.left.pack(rect));
	};
	
	Atlas.prototype.expand = function(rect) {
	  var self = this;
	  rect = this._toRect(rect);
	
	  if (this.img && this.tilepad) {
	    rect = this._tilepad(rect);
	  }
	
	  var atlas;
	  if (this.rect.w < this.rect.h) {
	    atlas = new Atlas(0, 0, this.rect.w + rect.w, this.rect.h);
	    atlas.right = new Atlas(this.rect.w, 0, rect.w, this.rect.h);
	    atlas.left = this;
	  } else {
	    atlas = new Atlas(0, 0, this.rect.w, this.rect.h + rect.h);
	    atlas.right = new Atlas(0, this.rect.h, this.rect.w, rect.h);
	    atlas.left = this;
	  }
	
	  ['canvas', 'context', 'img'].forEach(function(p) {
	    if (self[p]) {
	      atlas[p] = self[p];
	      self[p] = null;
	    }
	  });
	
	  // resize canvas
	  if (atlas.canvas) {
	    if (!atlas.context) {
	      atlas.context = atlas.canvas.getContext('2d');
	    }
	    var old = atlas.context.getImageData(0, 0, atlas.canvas.width, atlas.canvas.height);
	    atlas.canvas.width = atlas.rect.w;
	    atlas.canvas.height = atlas.rect.h;
	    atlas.context.putImageData(old, 0, 0);
	  }
	
	  return (atlas.pack(rect) === false) ? atlas.expand(rect) : atlas;
	};
	
	Atlas.prototype.index = function() {
	  var self = this;
	  if (self._cache.length > 0) {
	    return self._cache;
	  }
	  (function loop(atlas) {
	    if (atlas.left !== null) {
	      loop(atlas.left);
	      loop(atlas.right);
	    } else if (atlas.rect.name) {
	      self._cache.push(atlas.rect);
	    }
	  }(self));
	  return self._cache;
	};
	
	Atlas.prototype.uv = function(w, h) {
	  var self = this;
	  w = w || self.rect.w;
	  h = h || self.rect.h;
	  var isPad = this.tilepad;
	  (function loop(atlas) {
	    if (atlas.left !== null) {
	      loop(atlas.left);
	      loop(atlas.right);
	    } else if (typeof atlas.rect.name !== 'undefined') {
	      var p = (isPad) ? atlas.rect.w / 4 : 0;
	      self._uvcache[atlas.rect.name] = [
	        [atlas.rect.x + p, atlas.rect.y + p],
	        [(atlas.rect.x + p) + (atlas.rect.w - (p * 2)), atlas.rect.y + p],
	        [(atlas.rect.x + p) + (atlas.rect.w - (p * 2)), (atlas.rect.y + p) + (atlas.rect.h - (p * 2))],
	        [(atlas.rect.x + p), (atlas.rect.y + p) + (atlas.rect.h - (p * 2))],
	      ].map(function(uv) {
	        if (uv[0] !== 0) {
	          uv[0] = uv[0] / w;
	        }
	        if (uv[1] !== 0) {
	          uv[1] = uv[1] / h;
	        }
	        return uv;
	      });
	    }
	  }(self));
	  return self._uvcache;
	};
	
	Atlas.prototype.json = function(input) {
	  var self = this;
	  if (input) {
	    if (typeof input === 'string') input = JSON.parse(input);
	    return (function loop(obj) {
	      if (!obj || !obj.rect) return;
	      var atlas = new Atlas(obj.rect.x, obj.rect.y, obj.rect.w, obj.rect.h);
	      if (obj.left) atlas.left = loop(obj.left);
	      if (obj.right) atlas.right = loop(obj.right);
	      return atlas;
	    }(input));
	  } else {
	    return JSON.stringify(function loop(atlas) {
	      var obj = {
	        left: null, right: null,
	        rect: atlas.rect, filled: atlas.filled
	      };
	      if (atlas.left !== null) {
	        obj.left = loop(atlas.left);
	        obj.right = loop(atlas.right);
	      }
	      return obj;
	    }(self), null, 2);
	  }
	};
	
	// Pads the image by tiling itself around itself
	Atlas.prototype._tilepad = function(rect) {
	  var img = this.img;
	  if (!img) return rect;
	
	  var p = img.width / 2;
	
	  var canvas = document.createElement('canvas');
	  canvas.name = img.name || img.src;
	  canvas.id = img.id || '';
	  canvas.width = img.width + img.width;
	  canvas.height = img.height + img.height;
	  var ctx = canvas.getContext('2d');
	
	  var pattern = ctx.createPattern(img, 'repeat');
	  ctx.fillStyle = pattern;
	  ctx.translate(p, p);
	  ctx.fillRect(-p, -p, canvas.width + p, canvas.height + p);
	  ctx.translate(-p, -p);
	
	  this.img = canvas;
	
	  return new Rect(rect.x, rect.y, this.img.width, this.img.height);
	};
	
	// if has an image and canvas, draw to the canvas as we go
	Atlas.prototype._ontoCanvas = function(node) {
	  if (node && this.img && this.canvas) {
	    if (!this.context) {
	      this.context = this.canvas.getContext('2d');
	    }
	    this.context.clearRect(node.rect.x, node.rect.y, node.rect.w, node.rect.h);
	    this.context.drawImage(this.img, node.rect.x, node.rect.y, node.rect.w, node.rect.h);
	    node.rect.name = this.img.id || this.img.name || this.img.src || null;
	  }
	  return node;
	};
	
	// make sure we're always working with rects
	Atlas.prototype._toRect = function(rect) {
	  // if rect is an image
	  if (rect.nodeName && rect.nodeName === 'IMG') {
	    this.img = rect;
	    rect = new Rect(rect.x, rect.y, rect.width, rect.height);
	  }
	  // if rect is an object
	  if (!(rect instanceof Rect)) {
	    rect = new Rect(rect.x || 0, rect.y || 0, rect.w || rect.width, rect.h || rect.height);
	  }
	  return rect;
	};
	
	Atlas.prototype._debug = function() {
	  if (!this.canvas) { return; }
	  var context = this.canvas.getContext('2d');
	  this.index().forEach(function(rect) {
	    context.lineWidth = 1;
	    context.strokeStyle = 'red';
	    context.strokeRect(rect.x, rect.y, rect.w, rect.h);
	  });
	};
	
	},{}]},{},[1])
	(1)
	});;


/***/ },
/* 18 */
/***/ function(module, exports) {

	function opaque(image) {
	  var canvas, ctx
	
	  if (image.nodeName.toLowerCase() === 'img') {
	    canvas = document.createElement('canvas')
	    canvas.width = image.width
	    canvas.height = image.height
	    ctx = canvas.getContext('2d')
	    ctx.drawImage(image, 0, 0)
	  } else {
	    canvas = image
	    ctx = canvas.getContext('2d')
	  }
	
	  var imageData = ctx.getImageData(0, 0, canvas.height, canvas.width)
	    , data = imageData.data
	
	  for (var i = 3, l = data.length; i < l; i += 4)
	    if (data[i] !== 255)
	      return false
	
	  return true
	};
	
	module.exports = opaque
	module.exports.opaque = opaque
	module.exports.transparent = function(image) {
	  return !opaque(image)
	};

/***/ },
/* 19 */
/***/ function(module, exports) {

	module.exports = function(game) {
	  var THREE = game.THREE;
	  var colorCache = Object.create(null);
	
	  var ao = function(face, light, dark) {
	    if (arguments.length === 1) {
	      light = face.color;
	      dark = getDark(light);
	    } else if (arguments.length === 2) {
	      light = convertColor(light);
	      dark = getDark(light);
	    } else {
	      light = convertColor(light);
	      dark = convertColor(dark);
	    }
	    face.color = light;
	
	    // TODO: AO should be figured better than this
	    if (face.normal.y === 1)       face.vertexColors = [light, light, light, light];
	    else if (face.normal.y === -1) face.vertexColors = [dark,  dark,  dark,  dark];
	    else if (face.normal.x === 1)  face.vertexColors = [dark,  light, light, dark];
	    else if (face.normal.x === -1) face.vertexColors = [dark,  dark,  light, light];
	    else if (face.normal.z === 1)  face.vertexColors = [dark,  dark,  light, light];
	    else                           face.vertexColors = [dark,  light, light, dark];
	  };
	
	  ao.onGeometry = function(geom, light, dark) {
	    for (var i = 0; i < geom.faces.length; ++i) {
	      ao(geom.faces[i], light, dark);
	    }
	  };
	
	  ao.onChunk = function(chunk, light, dark) {
	    var pos = ('position' in chunk) ? chunk.position : chunk;
	    var mesh = game.voxels.meshes[pos.join('|')];
	    if (mesh) {
	      ao.onGeometry(mesh.geometry, light, dark);
	    }
	  };
	
	  var getDark = function(light) {
	    var hex = light.getHexString();
	    if (colorCache[hex]) return colorCache[hex];
	    var hsl = light.getHSL();
	    var dark = light.clone();
	    dark.setHSL(hsl.h, hsl.s, hsl.l - 0.1);
	    return colorCache[hex] = dark;
	  };
	
	  var convertColor = function(color) {
	    if (color instanceof THREE.Color) return color;
	    if (colorCache[color]) return colorCache[color];
	    return colorCache[color] = new THREE.Color(color);
	  };
	
	  return ao;
	};


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	var chunker = __webpack_require__(21)
	
	module.exports = function(opts) {
	  if (!opts.generateVoxelChunk) opts.generateVoxelChunk = function(low, high) {
	    return generate(low, high, module.exports.generator['Valley'])
	  }
	  return chunker(opts)
	}
	
	module.exports.meshers = {
	  culled: __webpack_require__(24).mesher,
	  greedy: __webpack_require__(25).mesher,
	  transgreedy: __webpack_require__(26).mesher,
	  monotone: __webpack_require__(27).mesher,
	  stupid: __webpack_require__(28).mesher
	}
	
	module.exports.Chunker = chunker.Chunker
	module.exports.geometry = {}
	module.exports.generator = {}
	module.exports.generate = generate
	
	// from https://github.com/mikolalysenko/mikolalysenko.github.com/blob/master/MinecraftMeshes2/js/testdata.js#L4
	function generate(l, h, f, game) {
	  var d = [ h[0]-l[0], h[1]-l[1], h[2]-l[2] ]
	  var v = new Int8Array(d[0]*d[1]*d[2])
	  var n = 0
	  for(var k=l[2]; k<h[2]; ++k)
	  for(var j=l[1]; j<h[1]; ++j)
	  for(var i=l[0]; i<h[0]; ++i, ++n) {
	    v[n] = f(i,j,k,n,game)
	  }
	  return {voxels:v, dims:d}
	}
	
	// shape and terrain generator functions
	module.exports.generator['Sphere'] = function(i,j,k) {
	  return i*i+j*j+k*k <= 16*16 ? 1 : 0
	}
	
	module.exports.generator['Noise'] = function(i,j,k) {
	  return Math.random() < 0.1 ? Math.random() * 0xffffff : 0;
	}
	
	module.exports.generator['Dense Noise'] = function(i,j,k) {
	  return Math.round(Math.random() * 0xffffff);
	}
	
	module.exports.generator['Checker'] = function(i,j,k) {
	  return !!((i+j+k)&1) ? (((i^j^k)&2) ? 1 : 0xffffff) : 0;
	}
	
	module.exports.generator['Hill'] = function(i,j,k) {
	  return j <= 16 * Math.exp(-(i*i + k*k) / 64) ? 1 : 0;
	}
	
	module.exports.generator['Valley'] = function(i,j,k) {
	  return j <= (i*i + k*k) * 31 / (32*32*2) + 1 ? 1 : 0;
	}
	
	module.exports.generator['Hilly Terrain'] = function(i,j,k) {
	  var h0 = 3.0 * Math.sin(Math.PI * i / 12.0 - Math.PI * k * 0.1) + 27;    
	  if(j > h0+1) {
	    return 0;
	  }
	  if(h0 <= j) {
	    return 1;
	  }
	  var h1 = 2.0 * Math.sin(Math.PI * i * 0.25 - Math.PI * k * 0.3) + 20;
	  if(h1 <= j) {
	    return 2;
	  }
	  if(2 < j) {
	    return Math.random() < 0.1 ? 0x222222 : 0xaaaaaa;
	  }
	  return 3;
	}
	
	module.exports.scale = function ( x, fromLow, fromHigh, toLow, toHigh ) {
	  return ( x - fromLow ) * ( toHigh - toLow ) / ( fromHigh - fromLow ) + toLow
	}
	
	// convenience function that uses the above functions to prebake some simple voxel geometries
	module.exports.generateExamples = function() {
	  return {
	    'Sphere': generate([-16,-16,-16], [16,16,16], module.exports.generator['Sphere']),
	    'Noise': generate([0,0,0], [16,16,16], module.exports.generator['Noise']),
	    'Dense Noise': generate([0,0,0], [16,16,16], module.exports.generator['Dense Noise']),
	    'Checker': generate([0,0,0], [8,8,8], module.exports.generator['Checker']),
	    'Hill': generate([-16, 0, -16], [16,16,16], module.exports.generator['Hill']),
	    'Valley': generate([0,0,0], [32,32,32], module.exports.generator['Valley']),
	    'Hilly Terrain': generate([0, 0, 0], [32,32,32], module.exports.generator['Hilly Terrain'])
	  }
	}
	


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	var events = __webpack_require__(22)
	var inherits = __webpack_require__(23)
	
	module.exports = function(opts) {
	  return new Chunker(opts)
	}
	
	module.exports.Chunker = Chunker
	
	function Chunker(opts) {
	  this.distance = opts.chunkDistance || 2
	  this.chunkSize = opts.chunkSize || 32
	  this.cubeSize = opts.cubeSize || 25
	  this.generateVoxelChunk = opts.generateVoxelChunk
	  this.chunks = {}
	  this.meshes = {}
	
	  if (this.chunkSize & this.chunkSize-1 !== 0)
	    throw new Error('chunkSize must be a power of 2')
	  var bits = 0;
	  for (var size = this.chunkSize; size > 0; size >>= 1) bits++;
	  this.chunkBits = bits - 1;
	}
	
	inherits(Chunker, events.EventEmitter)
	
	Chunker.prototype.nearbyChunks = function(position, distance) {
	  var current = this.chunkAtPosition(position)
	  var x = current[0]
	  var y = current[1]
	  var z = current[2]
	  var dist = distance || this.distance
	  var nearby = []
	  for (var cx = (x - dist); cx !== (x + dist); ++cx) {
	    for (var cy = (y - dist); cy !== (y + dist); ++cy) {
	      for (var cz = (z - dist); cz !== (z + dist); ++cz) {
	        nearby.push([cx, cy, cz])
	      }
	    }
	  }
	  return nearby
	}
	
	Chunker.prototype.requestMissingChunks = function(position) {
	  var self = this
	  this.nearbyChunks(position).map(function(chunk) {
	    if (!self.chunks[chunk.join('|')]) {
	      self.emit('missingChunk', chunk)
	    }
	  })
	}
	
	Chunker.prototype.getBounds = function(x, y, z) {
	  var bits = this.chunkBits
	  var low = [x << bits, y << bits, z << bits]
	  var high = [(x+1) << bits, (y+1) << bits, (z+1) << bits]
	  return [low, high]
	}
	
	Chunker.prototype.generateChunk = function(x, y, z) {
	  var self = this
	  var bounds = this.getBounds(x, y, z)
	  var chunk = this.generateVoxelChunk(bounds[0], bounds[1], x, y, z)
	  var position = [x, y, z]
	  chunk.position = position
	  this.chunks[position.join('|')] = chunk
	  return chunk
	}
	
	Chunker.prototype.chunkAtCoordinates = function(x, y, z) {
	  var bits = this.chunkBits;
	  var cx = x >> bits;
	  var cy = y >> bits;
	  var cz = z >> bits;
	  var chunkPos = [cx, cy, cz];
	  return chunkPos;
	}
	
	Chunker.prototype.chunkAtPosition = function(position) {
	  var cubeSize = this.cubeSize;
	  var x = Math.floor(position[0] / cubeSize)
	  var y = Math.floor(position[1] / cubeSize)
	  var z = Math.floor(position[2] / cubeSize)
	  var chunkPos = this.chunkAtCoordinates(x, y, z)
	  return chunkPos
	};
	
	Chunker.prototype.voxelIndexFromCoordinates = function(x, y, z) {
	  var bits = this.chunkBits
	  var mask = (1 << bits) - 1
	  var vidx = (x & mask) + ((y & mask) << bits) + ((z & mask) << bits * 2)
	  return vidx
	}
	
	Chunker.prototype.voxelIndexFromPosition = function(pos) {
	  var v = this.voxelVector(pos)
	  return this.voxelIndex(v)
	}
	
	Chunker.prototype.voxelAtCoordinates = function(x, y, z, val) {
	  var ckey = this.chunkAtCoordinates(x, y, z).join('|')
	  var chunk = this.chunks[ckey]
	  if (!chunk) return false
	  var vidx = this.voxelIndexFromCoordinates(x, y, z)
	  var v = chunk.voxels[vidx]
	  if (typeof val !== 'undefined') {
	    chunk.voxels[vidx] = val
	  }
	  return v
	}
	
	Chunker.prototype.voxelAtPosition = function(pos, val) {
	  var cubeSize = this.cubeSize;
	  var x = Math.floor(pos[0] / cubeSize)
	  var y = Math.floor(pos[1] / cubeSize)
	  var z = Math.floor(pos[2] / cubeSize)
	  var v = this.voxelAtCoordinates(x, y, z, val)
	  return v;
	}
	
	// deprecated
	Chunker.prototype.voxelIndex = function(voxelVector) {
	  var vidx = this.voxelIndexFromCoordinates(voxelVector[0], voxelVector[1], voxelVector[2])
	  return vidx
	}
	
	// deprecated
	Chunker.prototype.voxelVector = function(pos) {
	  var cubeSize = this.cubeSize
	  var mask = (1 << this.chunkBits) - 1
	  var vx = (Math.floor(pos[0] / cubeSize)) & mask
	  var vy = (Math.floor(pos[1] / cubeSize)) & mask
	  var vz = (Math.floor(pos[2] / cubeSize)) & mask
	  return [vx, vy, vz]
	};


/***/ },
/* 22 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;
	
	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;
	
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;
	
	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;
	
	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};
	
	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;
	
	  if (!this._events)
	    this._events = {};
	
	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      }
	      throw TypeError('Uncaught, unspecified "error" event.');
	    }
	  }
	
	  handler = this._events[type];
	
	  if (isUndefined(handler))
	    return false;
	
	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }
	
	  return true;
	};
	
	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events)
	    this._events = {};
	
	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);
	
	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];
	
	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }
	
	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	
	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  var fired = false;
	
	  function g() {
	    this.removeListener(type, g);
	
	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }
	
	  g.listener = listener;
	  this.on(type, g);
	
	  return this;
	};
	
	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events || !this._events[type])
	    return this;
	
	  list = this._events[type];
	  length = list.length;
	  position = -1;
	
	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	
	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }
	
	    if (position < 0)
	      return this;
	
	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }
	
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;
	
	  if (!this._events)
	    return this;
	
	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }
	
	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }
	
	  listeners = this._events[type];
	
	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];
	
	  return this;
	};
	
	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};
	
	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];
	
	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};
	
	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	
	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 23 */
/***/ function(module, exports) {

	module.exports = inherits
	
	function inherits (c, p, proto) {
	  proto = proto || {}
	  var e = {}
	  ;[c.prototype, proto].forEach(function (s) {
	    Object.getOwnPropertyNames(s).forEach(function (k) {
	      e[k] = Object.getOwnPropertyDescriptor(s, k)
	    })
	  })
	  c.prototype = Object.create(p.prototype, e)
	  c.super = p
	}
	
	//function Child () {
	//  Child.super.call(this)
	//  console.error([this
	//                ,this.constructor
	//                ,this.constructor === Child
	//                ,this.constructor.super === Parent
	//                ,Object.getPrototypeOf(this) === Child.prototype
	//                ,Object.getPrototypeOf(Object.getPrototypeOf(this))
	//                 === Parent.prototype
	//                ,this instanceof Child
	//                ,this instanceof Parent])
	//}
	//function Parent () {}
	//inherits(Child, Parent)
	//new Child


/***/ },
/* 24 */
/***/ function(module, exports) {

	//Naive meshing (with face culling)
	function CulledMesh(volume, dims) {
	  //Precalculate direction vectors for convenience
	  var dir = new Array(3);
	  for(var i=0; i<3; ++i) {
	    dir[i] = [[0,0,0], [0,0,0]];
	    dir[i][0][(i+1)%3] = 1;
	    dir[i][1][(i+2)%3] = 1;
	  }
	  //March over the volume
	  var vertices = []
	    , faces = []
	    , x = [0,0,0]
	    , B = [[false,true]    //Incrementally update bounds (this is a bit ugly)
	          ,[false,true]
	          ,[false,true]]
	    , n = -dims[0]*dims[1];
	  for(           B[2]=[false,true],x[2]=-1; x[2]<dims[2]; B[2]=[true,(++x[2]<dims[2]-1)])
	  for(n-=dims[0],B[1]=[false,true],x[1]=-1; x[1]<dims[1]; B[1]=[true,(++x[1]<dims[1]-1)])
	  for(n-=1,      B[0]=[false,true],x[0]=-1; x[0]<dims[0]; B[0]=[true,(++x[0]<dims[0]-1)], ++n) {
	    //Read current voxel and 3 neighboring voxels using bounds check results
	    var p =   (B[0][0] && B[1][0] && B[2][0]) ? volume[n]                 : 0
	      , b = [ (B[0][1] && B[1][0] && B[2][0]) ? volume[n+1]               : 0
	            , (B[0][0] && B[1][1] && B[2][0]) ? volume[n+dims[0]]         : 0
	            , (B[0][0] && B[1][0] && B[2][1]) ? volume[n+dims[0]*dims[1]] : 0
	          ];
	    //Generate faces
	    for(var d=0; d<3; ++d)
	    if((!!p) !== (!!b[d])) {
	      var s = !p ? 1 : 0;
	      var t = [x[0],x[1],x[2]]
	        , u = dir[d][s]
	        , v = dir[d][s^1];
	      ++t[d];
	      
	      var vertex_count = vertices.length;
	      vertices.push([t[0],           t[1],           t[2]          ]);
	      vertices.push([t[0]+u[0],      t[1]+u[1],      t[2]+u[2]     ]);
	      vertices.push([t[0]+u[0]+v[0], t[1]+u[1]+v[1], t[2]+u[2]+v[2]]);
	      vertices.push([t[0]     +v[0], t[1]     +v[1], t[2]     +v[2]]);
	      faces.push([vertex_count, vertex_count+1, vertex_count+2, vertex_count+3, s ? b[d] : p]);
	    }
	  }
	  return { vertices:vertices, faces:faces };
	}
	
	
	if(exports) {
	  exports.mesher = CulledMesh;
	}


/***/ },
/* 25 */
/***/ function(module, exports) {

	var GreedyMesh = (function() {
	//Cache buffer internally
	var mask = new Int32Array(4096);
	
	return function(volume, dims) {
	  var vertices = [], faces = []
	    , dimsX = dims[0]
	    , dimsY = dims[1]
	    , dimsXY = dimsX * dimsY;
	
	  //Sweep over 3-axes
	  for(var d=0; d<3; ++d) {
	    var i, j, k, l, w, W, h, n, c
	      , u = (d+1)%3
	      , v = (d+2)%3
	      , x = [0,0,0]
	      , q = [0,0,0]
	      , du = [0,0,0]
	      , dv = [0,0,0]
	      , dimsD = dims[d]
	      , dimsU = dims[u]
	      , dimsV = dims[v]
	      , qdimsX, qdimsXY
	      , xd
	
	    if (mask.length < dimsU * dimsV) {
	      mask = new Int32Array(dimsU * dimsV);
	    }
	
	    q[d] =  1;
	    x[d] = -1;
	
	    qdimsX  = dimsX  * q[1]
	    qdimsXY = dimsXY * q[2]
	
	    // Compute mask
	    while (x[d] < dimsD) {
	      xd = x[d]
	      n = 0;
	
	      for(x[v] = 0; x[v] < dimsV; ++x[v]) {
	        for(x[u] = 0; x[u] < dimsU; ++x[u], ++n) {
	          var a = xd >= 0      && volume[x[0]      + dimsX * x[1]          + dimsXY * x[2]          ]
	            , b = xd < dimsD-1 && volume[x[0]+q[0] + dimsX * x[1] + qdimsX + dimsXY * x[2] + qdimsXY]
	          if (a ? b : !b) {
	            mask[n] = 0; continue;
	          }
	          mask[n] = a ? a : -b;
	        }
	      }
	
	      ++x[d];
	
	      // Generate mesh for mask using lexicographic ordering
	      n = 0;
	      for (j=0; j < dimsV; ++j) {
	        for (i=0; i < dimsU; ) {
	          c = mask[n];
	          if (!c) {
	            i++;  n++; continue;
	          }
	
	          //Compute width
	          w = 1;
	          while (c === mask[n+w] && i+w < dimsU) w++;
	
	          //Compute height (this is slightly awkward)
	          for (h=1; j+h < dimsV; ++h) {
	            k = 0;
	            while (k < w && c === mask[n+k+h*dimsU]) k++
	            if (k < w) break;
	          }
	
	          // Add quad
	          // The du/dv arrays are reused/reset
	          // for each iteration.
	          du[d] = 0; dv[d] = 0;
	          x[u]  = i;  x[v] = j;
	
	          if (c > 0) {
	            dv[v] = h; dv[u] = 0;
	            du[u] = w; du[v] = 0;
	          } else {
	            c = -c;
	            du[v] = h; du[u] = 0;
	            dv[u] = w; dv[v] = 0;
	          }
	          var vertex_count = vertices.length;
	          vertices.push([x[0],             x[1],             x[2]            ]);
	          vertices.push([x[0]+du[0],       x[1]+du[1],       x[2]+du[2]      ]);
	          vertices.push([x[0]+du[0]+dv[0], x[1]+du[1]+dv[1], x[2]+du[2]+dv[2]]);
	          vertices.push([x[0]      +dv[0], x[1]      +dv[1], x[2]      +dv[2]]);
	          faces.push([vertex_count, vertex_count+1, vertex_count+2, vertex_count+3, c]);
	
	          //Zero-out mask
	          W = n + w;
	          for(l=0; l<h; ++l) {
	            for(k=n; k<W; ++k) {
	              mask[k+l*dimsU] = 0;
	            }
	          }
	
	          //Increment counters and continue
	          i += w; n += w;
	        }
	      }
	    }
	  }
	  return { vertices:vertices, faces:faces };
	}
	})();
	
	if(exports) {
	  exports.mesher = GreedyMesh;
	}


/***/ },
/* 26 */
/***/ function(module, exports) {

	var GreedyMesh = (function greedyLoader() {
	    
	// contains all forward faces (in terms of scan direction)
	var mask = new Int32Array(4096);
	// and all backwards faces. needed when there are two transparent blocks
	// next to each other.
	var invMask = new Int32Array(4096);
	
	// setting 16th bit if transparent
	var kTransparentMask    = 0x8000;
	var kNoFlagsMask        = 0x7FFF;
	var kTransparentTypes   = [];
	
	kTransparentTypes[16] = true
	
	function isTransparent(v) {
	  return (v & kTransparentMask) === kTransparentMask;
	}
	
	function removeFlags(v) {
	  return (v & kNoFlagsMask);
	}
	
	return function ohSoGreedyMesher(volume, dims, mesherExtraData) {
	  var vertices = [], faces = []
	    , dimsX = dims[0]
	    , dimsY = dims[1]
	    , dimsXY = dimsX * dimsY;
	
	  var tVertices = [], tFaces = []
	
	  var transparentTypes = mesherExtraData ? (mesherExtraData.transparentTypes || {}) : {};
	  var getType = function(voxels, offset) {
	    var type = voxels[offset];
	    return type | (type in transparentTypes ? kTransparentMask : 0);
	  }
	
	
	  //Sweep over 3-axes
	  for(var d=0; d<3; ++d) {
	    var i, j, k, l, w, W, h, n, c
	      , u = (d+1)%3
	      , v = (d+2)%3
	      , x = [0,0,0]
	      , q = [0,0,0]
	      , du = [0,0,0]
	      , dv = [0,0,0]
	      , dimsD = dims[d]
	      , dimsU = dims[u]
	      , dimsV = dims[v]
	      , qdimsX, qdimsXY
	      , xd
	
	    if (mask.length < dimsU * dimsV) {
	      mask = new Int32Array(dimsU * dimsV);
	      invMask = new Int32Array(dimsU * dimsV);
	    }
	
	    q[d] =  1;
	    x[d] = -1;
	
	    qdimsX  = dimsX  * q[1]
	    qdimsXY = dimsXY * q[2]
	
	    // Compute mask
	    while (x[d] < dimsD) {
	      xd = x[d]
	      n = 0;
	
	      for(x[v] = 0; x[v] < dimsV; ++x[v]) {
	        for(x[u] = 0; x[u] < dimsU; ++x[u], ++n) {
	          // Modified to read through getType()
	          var a = xd >= 0      && getType(volume, x[0]      + dimsX * x[1]          + dimsXY * x[2]          )
	            , b = xd < dimsD-1 && getType(volume, x[0]+q[0] + dimsX * x[1] + qdimsX + dimsXY * x[2] + qdimsXY)
	
	          // both are transparent, add to both directions
	          if (isTransparent(a) && isTransparent(b)) {
	            mask[n] = a;
	            invMask[n] = b;
	          // if a is solid and b is not there or transparent
	          } else if (a && (!b || isTransparent(b))) {
	            mask[n] = a;
	            invMask[n] = 0
	          // if b is solid and a is not there or transparent
	          } else if (b && (!a || isTransparent(a))) {
	            mask[n] = 0
	            invMask[n] = b;
	          // dont draw this face
	          } else {
	            mask[n] = 0
	            invMask[n] = 0
	          }
	        }
	      }
	
	      ++x[d];
	
	      // Generate mesh for mask using lexicographic ordering
	      function generateMesh(mask, dimsV, dimsU, vertices, faces, clockwise) {
	        clockwise = clockwise === undefined ? true : clockwise;
	        var n, j, i, c, w, h, k, du = [0,0,0], dv = [0,0,0];
	        n = 0;
	        for (j=0; j < dimsV; ++j) {
	          for (i=0; i < dimsU; ) {
	            c = mask[n];
	            if (!c) {
	              i++;  n++; continue;
	            }
	
	            //Compute width
	            w = 1;
	            while (c === mask[n+w] && i+w < dimsU) w++;
	
	            //Compute height (this is slightly awkward)
	            for (h=1; j+h < dimsV; ++h) {
	              k = 0;
	              while (k < w && c === mask[n+k+h*dimsU]) k++
	              if (k < w) break;
	            }
	
	            // Add quad
	            // The du/dv arrays are reused/reset
	            // for each iteration.
	            du[d] = 0; dv[d] = 0;
	            x[u]  = i;  x[v] = j;
	
	            if (clockwise) {
	            // if (c > 0) {
	              dv[v] = h; dv[u] = 0;
	              du[u] = w; du[v] = 0;
	            } else {
	              // c = -c;
	              du[v] = h; du[u] = 0;
	              dv[u] = w; dv[v] = 0;
	            }
	            
	            // ## enable code to ensure that transparent faces are last in the list
	            // if (!isTransparent(c)) {
	              var vertex_count = vertices.length;
	              vertices.push([x[0],             x[1],             x[2]            ]);
	              vertices.push([x[0]+du[0],       x[1]+du[1],       x[2]+du[2]      ]);
	              vertices.push([x[0]+du[0]+dv[0], x[1]+du[1]+dv[1], x[2]+du[2]+dv[2]]);
	              vertices.push([x[0]      +dv[0], x[1]      +dv[1], x[2]      +dv[2]]);
	              faces.push([vertex_count, vertex_count+1, vertex_count+2, vertex_count+3, removeFlags(c)]);
	            // } else {
	            //   var vertex_count = tVertices.length;
	            //   tVertices.push([x[0],             x[1],             x[2]            ]);
	            //   tVertices.push([x[0]+du[0],       x[1]+du[1],       x[2]+du[2]      ]);
	            //   tVertices.push([x[0]+du[0]+dv[0], x[1]+du[1]+dv[1], x[2]+du[2]+dv[2]]);
	            //   tVertices.push([x[0]      +dv[0], x[1]      +dv[1], x[2]      +dv[2]]);
	            //   tFaces.push([vertex_count, vertex_count+1, vertex_count+2, vertex_count+3, removeFlags(c)]);
	            // }
	
	            //Zero-out mask
	            W = n + w;
	            for(l=0; l<h; ++l) {
	              for(k=n; k<W; ++k) {
	                mask[k+l*dimsU] = 0;
	              }
	            }
	
	            //Increment counters and continue
	            i += w; n += w;
	          }
	        }
	      }
	      generateMesh(mask, dimsV, dimsU, vertices, faces, true)
	      generateMesh(invMask, dimsV, dimsU, vertices, faces, false)
	    }
	  }
	  
	  // ## enable code to ensure that transparent faces are last in the list
	  // var vertex_count = vertices.length;
	  // var newFaces = tFaces.map(function(v) {
	  //   return [vertex_count+v[0], vertex_count+v[1], vertex_count+v[2], vertex_count+v[3], v[4]]
	  // })
	  // 
	  // return { vertices:vertices.concat(tVertices), faces:faces.concat(newFaces) };
	  
	  // TODO: Try sorting by texture to see if we can reduce draw calls.
	  // faces.sort(function sortFaces(a, b) {
	  //   return b[4] - a[4];
	  // })
	  return { vertices:vertices, faces:faces };
	}
	})();
	
	if(exports) {
	  exports.mesher = GreedyMesh;
	}


/***/ },
/* 27 */
/***/ function(module, exports) {

	"use strict";
	
	var MonotoneMesh = (function(){
	
	function MonotonePolygon(c, v, ul, ur) {
	  this.color  = c;
	  this.left   = [[ul, v]];
	  this.right  = [[ur, v]];
	};
	
	MonotonePolygon.prototype.close_off = function(v) {
	  this.left.push([ this.left[this.left.length-1][0], v ]);
	  this.right.push([ this.right[this.right.length-1][0], v ]);
	};
	
	MonotonePolygon.prototype.merge_run = function(v, u_l, u_r) {
	  var l = this.left[this.left.length-1][0]
	    , r = this.right[this.right.length-1][0]; 
	  if(l !== u_l) {
	    this.left.push([ l, v ]);
	    this.left.push([ u_l, v ]);
	  }
	  if(r !== u_r) {
	    this.right.push([ r, v ]);
	    this.right.push([ u_r, v ]);
	  }
	};
	
	
	return function(volume, dims) {
	  function f(i,j,k) {
	    return volume[i + dims[0] * (j + dims[1] * k)];
	  }
	  //Sweep over 3-axes
	  var vertices = [], faces = [];
	  for(var d=0; d<3; ++d) {
	    var i, j, k
	      , u = (d+1)%3   //u and v are orthogonal directions to d
	      , v = (d+2)%3
	      , x = new Int32Array(3)
	      , q = new Int32Array(3)
	      , runs = new Int32Array(2 * (dims[u]+1))
	      , frontier = new Int32Array(dims[u])  //Frontier is list of pointers to polygons
	      , next_frontier = new Int32Array(dims[u])
	      , left_index = new Int32Array(2 * dims[v])
	      , right_index = new Int32Array(2 * dims[v])
	      , stack = new Int32Array(24 * dims[v])
	      , delta = [[0,0], [0,0]];
	    //q points along d-direction
	    q[d] = 1;
	    //Initialize sentinel
	    for(x[d]=-1; x[d]<dims[d]; ) {
	      // --- Perform monotone polygon subdivision ---
	      var n = 0
	        , polygons = []
	        , nf = 0;
	      for(x[v]=0; x[v]<dims[v]; ++x[v]) {
	        //Make one pass over the u-scan line of the volume to run-length encode polygon
	        var nr = 0, p = 0, c = 0;
	        for(x[u]=0; x[u]<dims[u]; ++x[u], p = c) {
	          //Compute the type for this face
	          var a = (0    <= x[d]      ? f(x[0],      x[1],      x[2])      : 0)
	            , b = (x[d] <  dims[d]-1 ? f(x[0]+q[0], x[1]+q[1], x[2]+q[2]) : 0);
	          c = a;
	          if((!a) === (!b)) {
	            c = 0;
	          } else if(!a) {
	            c = -b;
	          }
	          //If cell type doesn't match, start a new run
	          if(p !== c) {
	            runs[nr++] = x[u];
	            runs[nr++] = c;
	          }
	        }
	        //Add sentinel run
	        runs[nr++] = dims[u];
	        runs[nr++] = 0;
	        //Update frontier by merging runs
	        var fp = 0;
	        for(var i=0, j=0; i<nf && j<nr-2; ) {
	          var p    = polygons[frontier[i]]
	            , p_l  = p.left[p.left.length-1][0]
	            , p_r  = p.right[p.right.length-1][0]
	            , p_c  = p.color
	            , r_l  = runs[j]    //Start of run
	            , r_r  = runs[j+2]  //End of run
	            , r_c  = runs[j+1]; //Color of run
	          //Check if we can merge run with polygon
	          if(r_r > p_l && p_r > r_l && r_c === p_c) {
	            //Merge run
	            p.merge_run(x[v], r_l, r_r);
	            //Insert polygon into frontier
	            next_frontier[fp++] = frontier[i];
	            ++i;
	            j += 2;
	          } else {
	            //Check if we need to advance the run pointer
	            if(r_r <= p_r) {
	              if(!!r_c) {
	                var n_poly = new MonotonePolygon(r_c, x[v], r_l, r_r);
	                next_frontier[fp++] = polygons.length;
	                polygons.push(n_poly);
	              }
	              j += 2;
	            }
	            //Check if we need to advance the frontier pointer
	            if(p_r <= r_r) {
	              p.close_off(x[v]);
	              ++i;
	            }
	          }
	        }
	        //Close off any residual polygons
	        for(; i<nf; ++i) {
	          polygons[frontier[i]].close_off(x[v]);
	        }
	        //Add any extra runs to frontier
	        for(; j<nr-2; j+=2) {
	          var r_l  = runs[j]
	            , r_r  = runs[j+2]
	            , r_c  = runs[j+1];
	          if(!!r_c) {
	            var n_poly = new MonotonePolygon(r_c, x[v], r_l, r_r);
	            next_frontier[fp++] = polygons.length;
	            polygons.push(n_poly);
	          }
	        }
	        //Swap frontiers
	        var tmp = next_frontier;
	        next_frontier = frontier;
	        frontier = tmp;
	        nf = fp;
	      }
	      //Close off frontier
	      for(var i=0; i<nf; ++i) {
	        var p = polygons[frontier[i]];
	        p.close_off(dims[v]);
	      }
	      // --- Monotone subdivision of polygon is complete at this point ---
	      
	      x[d]++;
	      
	      //Now we just need to triangulate each monotone polygon
	      for(var i=0; i<polygons.length; ++i) {
	        var p = polygons[i]
	          , c = p.color
	          , flipped = false;
	        if(c < 0) {
	          flipped = true;
	          c = -c;
	        }
	        for(var j=0; j<p.left.length; ++j) {
	          left_index[j] = vertices.length;
	          var y = [0.0,0.0,0.0]
	            , z = p.left[j];
	          y[d] = x[d];
	          y[u] = z[0];
	          y[v] = z[1];
	          vertices.push(y);
	        }
	        for(var j=0; j<p.right.length; ++j) {
	          right_index[j] = vertices.length;
	          var y = [0.0,0.0,0.0]
	            , z = p.right[j];
	          y[d] = x[d];
	          y[u] = z[0];
	          y[v] = z[1];
	          vertices.push(y);
	        }
	        //Triangulate the monotone polygon
	        var bottom = 0
	          , top = 0
	          , l_i = 1
	          , r_i = 1
	          , side = true;  //true = right, false = left
	        
	        stack[top++] = left_index[0];
	        stack[top++] = p.left[0][0];
	        stack[top++] = p.left[0][1];
	        
	        stack[top++] = right_index[0];
	        stack[top++] = p.right[0][0];
	        stack[top++] = p.right[0][1];
	        
	        while(l_i < p.left.length || r_i < p.right.length) {
	          //Compute next side
	          var n_side = false;
	          if(l_i === p.left.length) {
	            n_side = true;
	          } else if(r_i !== p.right.length) {
	            var l = p.left[l_i]
	              , r = p.right[r_i];
	            n_side = l[1] > r[1];
	          }
	          var idx = n_side ? right_index[r_i] : left_index[l_i]
	            , vert = n_side ? p.right[r_i] : p.left[l_i];
	          if(n_side !== side) {
	            //Opposite side
	            while(bottom+3 < top) {
	              if(flipped === n_side) {
	                faces.push([ stack[bottom], stack[bottom+3], idx, c]);
	              } else {
	                faces.push([ stack[bottom+3], stack[bottom], idx, c]);              
	              }
	              bottom += 3;
	            }
	          } else {
	            //Same side
	            while(bottom+3 < top) {
	              //Compute convexity
	              for(var j=0; j<2; ++j)
	              for(var k=0; k<2; ++k) {
	                delta[j][k] = stack[top-3*(j+1)+k+1] - vert[k];
	              }
	              var det = delta[0][0] * delta[1][1] - delta[1][0] * delta[0][1];
	              if(n_side === (det > 0)) {
	                break;
	              }
	              if(det !== 0) {
	                if(flipped === n_side) {
	                  faces.push([ stack[top-3], stack[top-6], idx, c ]);
	                } else {
	                  faces.push([ stack[top-6], stack[top-3], idx, c ]);
	                }
	              }
	              top -= 3;
	            }
	          }
	          //Push vertex
	          stack[top++] = idx;
	          stack[top++] = vert[0];
	          stack[top++] = vert[1];
	          //Update loop index
	          if(n_side) {
	            ++r_i;
	          } else {
	            ++l_i;
	          }
	          side = n_side;
	        }
	      }
	    }
	  }
	  return { vertices:vertices, faces:faces };
	}
	})();
	
	if(exports) {
	  exports.mesher = MonotoneMesh;
	}


/***/ },
/* 28 */
/***/ function(module, exports) {

	//The stupidest possible way to generate a Minecraft mesh (I think)
	function StupidMesh(volume, dims) {
	  var vertices = [], faces = [], x = [0,0,0], n = 0;
	  for(x[2]=0; x[2]<dims[2]; ++x[2])
	  for(x[1]=0; x[1]<dims[1]; ++x[1])
	  for(x[0]=0; x[0]<dims[0]; ++x[0], ++n)
	  if(!!volume[n]) {
	    for(var d=0; d<3; ++d) {
	      var t = [x[0], x[1], x[2]]
	        , u = [0,0,0]
	        , v = [0,0,0];
	      u[(d+1)%3] = 1;
	      v[(d+2)%3] = 1;
	      for(var s=0; s<2; ++s) {
	        t[d] = x[d] + s;
	        var tmp = u;
	        u = v;
	        v = tmp;
	        var vertex_count = vertices.length;
	        vertices.push([t[0],           t[1],           t[2]          ]);
	        vertices.push([t[0]+u[0],      t[1]+u[1],      t[2]+u[2]     ]);
	        vertices.push([t[0]+u[0]+v[0], t[1]+u[1]+v[1], t[2]+u[2]+v[2]]);
	        vertices.push([t[0]     +v[0], t[1]     +v[1], t[2]     +v[2]]);
	        faces.push([vertex_count, vertex_count+1, vertex_count+2, vertex_count+3, volume[n]]);
	      }
	    }
	  }
	  return { vertices:vertices, faces:faces };
	}
	
	
	if(exports) {
	  exports.mesher = StupidMesh;
	}


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _three = __webpack_require__(11);
	
	var _three2 = _interopRequireDefault(_three);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var MeshComponent = function () {
		_createClass(MeshComponent, null, [{
			key: 'create',
			value: function create() {
				return new MeshComponent();
			}
		}]);
	
		function MeshComponent() {
			_classCallCheck(this, MeshComponent);
	
			var geometry = new _three2.default.CubeGeometry(1, 1, 1);
			var material = new _three2.default.MeshLambertMaterial({ color: 0x0000ff, wireframe: false });
			this.three = new _three2.default.Mesh(geometry, material);
			this.three.castShadow = this.three.receiveShadow = true;
			this.three.useQuaternion = true;
		}
	
		return MeshComponent;
	}();
	
	exports.default = MeshComponent;

/***/ },
/* 30 */,
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _Entity = __webpack_require__(32);
	
	var _Entity2 = _interopRequireDefault(_Entity);
	
	var _PiecesComponent = __webpack_require__(33);
	
	var _PiecesComponent2 = _interopRequireDefault(_PiecesComponent);
	
	var _Terrain = __webpack_require__(34);
	
	var _Terrain2 = _interopRequireDefault(_Terrain);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Level = _Entity2.default.createClass({
	
		constructor: function constructor() {
			var pieces = _PiecesComponent2.default.create();
			this.set('pieces', pieces);
			this.terrain = _Terrain2.default.create({
				solver: this.generateSolver
			});
			if (this.exported) {
				var x = new XMLHttpRequest();
				x.open('GET', this.exported, false);
				x.send();
				this.import(JSON.parse(x.responseText));
			}
			if (this.generate) {
				this.terrain.generateRange(this.generateRange.low, this.generateRange.high);
			}
			pieces.add(this.terrain);
		},
	
		generate: true,
	
		generateSolver: function generateSolver(x, y, z) {
			return 0;
		},
	
		generateRange: {
			low: {
				x: -1,
				y: -1,
				z: -1
			},
			high: {
				x: 1,
				y: 1,
				z: 1
			}
		},
	
		exported: null,
	
		export: function _export() {
			return {
				terrain: this.terrain.export()
			};
		},
	
		import: function _import(exported) {
			if (!this.generate) {
				this.terrain.import(exported.terrain);
			}
		}
	
	});
	
	Level.createClass = function (props) {
		function Klass() {
			Level.call(this);
			props.constructor.apply(this, arguments);
		};
		Klass.prototype = props;
		props.__proto__ = Level.prototype;
		return Klass;
	};
	
	exports.default = Level;

/***/ },
/* 32 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Entity = function () {
		_createClass(Entity, null, [{
			key: "createClass",
			value: function createClass(props) {
				function Klass() {
					Entity.call(this);
					props.constructor.apply(this, arguments);
				};
				Klass.prototype = props;
				props.__proto__ = Entity.prototype;
				return Klass;
			}
		}, {
			key: "create",
			value: function create() {
				return new Entity();
			}
		}]);
	
		function Entity() {
			_classCallCheck(this, Entity);
	
			this.components = {};
		}
	
		_createClass(Entity, [{
			key: "set",
			value: function set(name, value) {
				this.components[name] = value;
			}
		}, {
			key: "get",
			value: function get(name) {
				return this.components[name];
			}
		}]);
	
		return Entity;
	}();
	
	exports.default = Entity;

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _EntityCollection = __webpack_require__(6);
	
	var _EntityCollection2 = _interopRequireDefault(_EntityCollection);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _EntityCollection2.default;

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _Entity = __webpack_require__(32);
	
	var _Entity2 = _interopRequireDefault(_Entity);
	
	var _voxel = __webpack_require__(20);
	
	var _voxel2 = _interopRequireDefault(_voxel);
	
	var _TerrainPhysics = __webpack_require__(35);
	
	var _TerrainPhysics2 = _interopRequireDefault(_TerrainPhysics);
	
	var _PiecesComponent = __webpack_require__(33);
	
	var _PiecesComponent2 = _interopRequireDefault(_PiecesComponent);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Terrain = _Entity2.default.createClass({
	
		constructor: function constructor(options) {
	
			this.set('voxels', (0, _voxel2.default)({
				generateVoxelChunk: function (low, high) {
					return _voxel2.default.generate(low, high, options.solver);
				}.bind(this),
				cubeSize: 1
			}));
	
			this.set('pieces', _PiecesComponent2.default.create());
		},
	
		generateRange: function generateRange(low, high) {
			var voxels = this.get('voxels');
			var chunkLow = voxels.chunkAtCoordinates(low.x, low.y, low.z);
			var chunkHigh = voxels.chunkAtCoordinates(high.x, high.y, high.z);
			this.generateChunkBlock({
				x: chunkLow[0],
				y: chunkLow[1],
				z: chunkLow[2]
			}, {
				x: chunkHigh[0],
				y: chunkHigh[1],
				z: chunkHigh[2]
			});
		},
	
		generateChunkBlock: function generateChunkBlock(low, high) {
			var voxels = this.get('voxels');
			for (var x = low.x; x <= high.x; x++) {
				for (var y = low.y; y <= high.y; y++) {
					for (var z = low.z; z <= high.z; z++) {
						voxels.generateChunk(x, y, z);
					}
				}
			}
			this.set('terrain-physics', _TerrainPhysics2.default.create(this));
		},
	
		getBlockAt: function getBlockAt(pos) {
			pos = this._parseVectorArguments(arguments);
			return this.get('voxels').voxelAtPosition(pos);
		},
	
		export: function _export() {
			var voxels = this.get('voxels');
			var result = {
				chunkSize: voxels.chunkSize,
				chunks: JSON.parse(JSON.stringify(voxels.chunks))
			};
			// discard empty chunks
			for (var chunkId in result.chunks) {
				var remove = true;
				for (var voxelId in result.chunks[chunkId].voxels) {
					if (result.chunks[chunkId].voxels[voxelId]) {
						remove = false;
						break;
					}
				}
				if (remove) {
					delete result.chunks[chunkId];
				}
			}
	
			return result;
		},
	
		import: function _import(exported) {
			var voxels = this.get('voxels');
			voxels.chunkSize = exported.chunkSize;
			voxels.chunks = exported.chunks;
			this.set('terrain-physics', _TerrainPhysics2.default.create(this));
		},
	
		_parseVectorArguments: function _parseVectorArguments(args) {
			if (!args) return false;
			if (args[0] instanceof Array) return args[0];
			return [args[0], args[1], args[2]];
		}
	});
	
	Terrain.create = function (opts) {
		return new Terrain(opts);
	};
	
	exports.default = Terrain;

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _cannon = __webpack_require__(9);
	
	var _cannon2 = _interopRequireDefault(_cannon);
	
	var _terrainPhysicsMerge = __webpack_require__(36);
	
	var _terrainPhysicsMerge2 = _interopRequireDefault(_terrainPhysicsMerge);
	
	var _Terrain = __webpack_require__(34);
	
	var _Terrain2 = _interopRequireDefault(_Terrain);
	
	var _TerrainPiece = __webpack_require__(37);
	
	var _TerrainPiece2 = _interopRequireDefault(_TerrainPiece);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var X = 0;
	var Y = 1;
	var Z = 2;
	
	var WIDTH = 0;
	var HEIGHT = 1;
	var DEPTH = 2;
	
	var TerrainPhysics = function () {
		_createClass(TerrainPhysics, null, [{
			key: 'create',
			value: function create(terrain) {
				return new TerrainPhysics(terrain);
			}
		}]);
	
		function TerrainPhysics(terrain) {
			_classCallCheck(this, TerrainPhysics);
	
			this.terrain = terrain;
	
			var voxels = terrain.get('voxels');
	
			for (var chunkPos in voxels.chunks) {
				var chunk = voxels.chunks[chunkPos];
				if (chunk) {
					this.createChunkPhysics(chunk);
				}
			}
		}
	
		_createClass(TerrainPhysics, [{
			key: 'createChunkPhysics',
			value: function createChunkPhysics(chunk) {
				var cache = {};
				var pieces = this.terrain.get('pieces');
	
				function isProcessed(pos) {
					return cache[pos.join('|')] || false;
				}
	
				function markProcessed(pos) {
					return cache[pos.join('|')] = true;
				}
	
				this.createChunkPhysics.items = this.createChunkPhysics.items || {};
				var chunkItems = this.createChunkPhysics.items[chunk.position.join('|')];
				if (chunkItems) {
					chunkItems.forEach(function (item) {
						if (item.mesh) {
							this.scene.remove(item.mesh);
						}
						//this.world.remove(item.body);
					}.bind(this));
				}
				chunkItems = this.createChunkPhysics.items[chunk.position.join('|')] = [];
	
				_terrainPhysicsMerge2.default.all(function (pos) {
					return this.terrain.getBlockAt(pos) && !isProcessed(pos);
				}.bind(this), chunk, function (result) {
	
					_terrainPhysicsMerge2.default.voxelsIn(result).forEach(function (pos) {
						markProcessed(pos);
					});
					var position = result.position.map(function (v, i) {
						return v + result.dims[i] / 2;
					});
	
					var boxShape = new _cannon2.default.Box(new _cannon2.default.Vec3(result.dims[WIDTH] / 2, result.dims[HEIGHT] / 2, result.dims[DEPTH] / 2));
					var box = new _cannon2.default.Body({
						mass: 0
					});
					box.addShape(boxShape);
					box.position.set.apply(box.position, position);
	
					var item = {
						mesh: null,
						body: box
					};
	
					chunkItems.push(item);
	
					var piece = _TerrainPiece2.default.create({
						cannon: box
					});
	
					pieces.add(piece);
				}.bind(this));
			}
		}]);
	
		return TerrainPhysics;
	}();

	exports.default = TerrainPhysics;

/***/ },
/* 36 */
/***/ function(module, exports) {

	"use strict";
	
	var X = 0;
	var Y = 1;
	var Z = 2;
	
	var WIDTH = 0;
	var HEIGHT = 1;
	var DEPTH = 2;
	
	function findConvexBox(check, startPos, chunk) {
	  if (arguments.length === 2) {
	    chunk = startPos;
	    startPos = chunk.position.map(function (v, i) {
	      return v * chunk.dims[i];
	    });
	  }
	  if (!chunk.voxels) throw new Error('Requires game chunk');
	
	  var endPos = chunk.position.map(function (v, i) {
	    return v * chunk.dims[i] + chunk.dims[i];
	  });
	
	  var box = {
	    dims: startPos.map(function (v, i) {
	      return endPos[i] - v;
	    }),
	    position: [0, 0, 0]
	  };
	  if (!check(startPos)) {
	    return false;
	  }
	  var found = false;
	  for (var x = startPos[X]; !found && x < endPos[X]; x++) {
	    var y = startPos[Y];
	    var z = startPos[Z];
	    if (!check([x, y, z])) {
	      if (box.dims[WIDTH] > x - startPos[X]) box.dims[WIDTH] = x - startPos[X];
	    }
	  }
	
	  var found = false;
	  for (var z = startPos[Z] + 1; !found && z < endPos[Z]; z++) {
	    for (var x = startPos[X]; !found && x < startPos[X] + box.dims[WIDTH]; x++) {
	      var y = startPos[Y];
	      if (!check([x, y, z])) {
	        if (box.dims[DEPTH] > z - startPos[Z]) box.dims[DEPTH] = z - startPos[Z];
	      }
	    }
	  }
	
	  var found = false;
	  for (var y = startPos[Y] + 1; !found && y < endPos[Y]; y++) {
	    for (var x = startPos[X]; !found && x < startPos[X] + box.dims[WIDTH]; x++) {
	      for (var z = startPos[Z]; !found && z < startPos[Z] + box.dims[DEPTH]; z++) {
	        if (!check([x, y, z])) {
	          if (box.dims[HEIGHT] > y - startPos[Y]) box.dims[HEIGHT] = y - startPos[Y];
	        }
	      }
	    }
	  }
	
	  if (box.dims[WIDTH] == 0) box.dims[WIDTH] = 1;
	  if (box.dims[HEIGHT] == 0) box.dims[HEIGHT] = 1;
	  if (box.dims[DEPTH] == 0) box.dims[DEPTH] = 1;
	  box.position[X] = startPos[X]; //+ box.dims[WIDTH]
	  box.position[Y] = startPos[Y]; //+ box.dims[HEIGHT]
	  box.position[Z] = startPos[Z]; //+ box.dims[DEPTH]
	  return box;
	}
	
	findConvexBox.all = function (check, chunk, done) {
	  var results = [];
	  findConvexBox.voxelsIn(chunk).forEach(function (pos) {
	    var result = findConvexBox(check, pos, chunk);
	    if (result) {
	      done(result);
	      results.push(result);
	    }
	  });
	  return results;
	};
	
	findConvexBox.voxelsIn = function voxelsIn(chunk) {
	  if (chunk.voxels) {
	    chunk = {
	      dims: chunk.dims.map(function (v) {
	        return v;
	      }),
	      position: chunk.position.map(function (v, i) {
	        return v * chunk.dims[i];
	      })
	    };
	  }
	
	  var points = [];
	  for (var x = chunk.position[X]; x < chunk.position[X] + chunk.dims[WIDTH]; x++) {
	    for (var y = chunk.position[Y]; y < chunk.position[Y] + chunk.dims[HEIGHT]; y++) {
	      for (var z = chunk.position[Z]; z < chunk.position[Z] + chunk.dims[DEPTH]; z++) {
	        points.push([x, y, z]);
	      }
	    }
	  }
	  return points;
	};
	
	module.exports = findConvexBox;

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _Entity = __webpack_require__(32);
	
	var _Entity2 = _interopRequireDefault(_Entity);
	
	var _PhysicsComponent = __webpack_require__(38);
	
	var _PhysicsComponent2 = _interopRequireDefault(_PhysicsComponent);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var TerrainPiece = _Entity2.default.createClass({
		constructor: function constructor(options) {
			var physics = _PhysicsComponent2.default.create();
			physics.cannon = options.cannon;
			this.set('physics', physics);
		}
	});
	
	TerrainPiece.create = function (options) {
		return new TerrainPiece(options);
	};
	
	exports.default = TerrainPiece;

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _cannon = __webpack_require__(9);
	
	var _cannon2 = _interopRequireDefault(_cannon);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var PhysicsComponent = function () {
		_createClass(PhysicsComponent, null, [{
			key: 'create',
			value: function create(opts) {
				return new PhysicsComponent(opts);
			}
		}]);
	
		function PhysicsComponent(options) {
			_classCallCheck(this, PhysicsComponent);
	
			options = options || {};
			var shape = new _cannon2.default.Box(new _cannon2.default.Vec3(.5, .5, .5));
			var body = new _cannon2.default.Body({
				mass: 1
			});
			body.addShape(shape);
			if (options.position) {
				body.position.set(options.position.x, options.position.y, options.position.z);
			}
			this.cannon = body;
		}
	
		_createClass(PhysicsComponent, [{
			key: 'position',
			get: function get() {
				var position = this.cannon.position;
				return {
					x: position.x,
					y: position.y,
					z: position.z
				};
			},
			set: function set(vals) {
				if (vals) {
					var _position = this.position;
					if (!vals.x && vals.x !== 0) {
						vals.x = _position.x;
					}
					if (!vals.y && vals.y !== 0) {
						vals.y = _position.y;
					}
					if (!vals.z && vals.z !== 0) {
						vals.z = _position.z;
					}
					this.cannon.position.set(vals.x, vals.y, vals.z);
				}
			}
		}, {
			key: 'rotation',
			get: function get() {
				var rotation = this.cannon.quaternion;
				return {
					w: rotation.w,
					x: rotation.x,
					y: rotation.y,
					z: rotation.z
				};
			},
			set: function set(vals) {
				if (vals) {
					var rotation = this.rotation;
					if (!vals.w && vals.w !== 0) {
						vals.w = position.w;
					}
					if (!vals.x && vals.x !== 0) {
						vals.x = position.x;
					}
					if (!vals.y && vals.y !== 0) {
						vals.y = position.y;
					}
					if (!vals.z && vals.z !== 0) {
						vals.z = position.z;
					}
					this.cannon.quaternion.set(vals.x, vals.y, vals.z, vals.w);
				}
			}
		}]);
	
		return PhysicsComponent;
	}();
	
	exports.default = PhysicsComponent;

/***/ },
/* 39 */,
/* 40 */,
/* 41 */,
/* 42 */,
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _three = __webpack_require__(11);
	
	var _three2 = _interopRequireDefault(_three);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * @author qiao / https://github.com/qiao
	 * @author mrdoob / http://mrdoob.com
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / https://github.com/WestLangley
	 */
	
	_three2.default.OrbitControls = function (object, domElement) {
	
		_three2.default.EventDispatcher.call(this);
	
		this.object = object;
		this.domElement = domElement !== undefined ? domElement : document;
	
		// API
	
		this.center = new _three2.default.Vector3();
	
		this.userZoom = true;
		this.userZoomSpeed = 1.0;
	
		this.userRotate = true;
		this.userRotateSpeed = 1.0;
	
		this.autoRotate = false;
		this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60
	
		this.minPolarAngle = 0; // radians
		this.maxPolarAngle = Math.PI; // radians
	
		this.minDistance = 0;
		this.maxDistance = Infinity;
	
		// internals
	
		var scope = this;
	
		var EPS = 0.000001;
		var PIXELS_PER_ROUND = 1800;
	
		var rotateStart = new _three2.default.Vector2();
		var rotateEnd = new _three2.default.Vector2();
		var rotateDelta = new _three2.default.Vector2();
	
		var zoomStart = new _three2.default.Vector2();
		var zoomEnd = new _three2.default.Vector2();
		var zoomDelta = new _three2.default.Vector2();
	
		var phiDelta = 0;
		var thetaDelta = 0;
		var scale = 1;
	
		var lastPosition = new _three2.default.Vector3();
	
		var STATE = { NONE: -1, ROTATE: 0, ZOOM: 1 };
		var state = STATE.NONE;
	
		// events
	
		var changeEvent = { type: 'change' };
	
		this.rotateLeft = function (angle) {
	
			if (angle === undefined) {
	
				angle = getAutoRotationAngle();
			}
	
			thetaDelta -= angle;
		};
	
		this.rotateRight = function (angle) {
	
			if (angle === undefined) {
	
				angle = getAutoRotationAngle();
			}
	
			thetaDelta += angle;
		};
	
		this.rotateUp = function (angle) {
	
			if (angle === undefined) {
	
				angle = getAutoRotationAngle();
			}
	
			phiDelta -= angle;
		};
	
		this.rotateDown = function (angle) {
	
			if (angle === undefined) {
	
				angle = getAutoRotationAngle();
			}
	
			phiDelta += angle;
		};
	
		this.zoomIn = function (zoomScale) {
	
			if (zoomScale === undefined) {
	
				zoomScale = getZoomScale();
			}
	
			scale /= zoomScale;
		};
	
		this.zoomOut = function (zoomScale) {
	
			if (zoomScale === undefined) {
	
				zoomScale = getZoomScale();
			}
	
			scale *= zoomScale;
		};
	
		this.update = function () {
	
			var position = this.object.position;
			var offset = position.clone().sub(this.center);
	
			// angle from z-axis around y-axis
	
			var theta = Math.atan2(offset.x, offset.z);
	
			// angle from y-axis
	
			var phi = Math.atan2(Math.sqrt(offset.x * offset.x + offset.z * offset.z), offset.y);
	
			if (this.autoRotate) {
	
				this.rotateLeft(getAutoRotationAngle());
			}
	
			theta += thetaDelta;
			phi += phiDelta;
	
			// restrict phi to be between desired limits
			phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, phi));
	
			// restrict phi to be betwee EPS and PI-EPS
			phi = Math.max(EPS, Math.min(Math.PI - EPS, phi));
	
			var radius = offset.length() * scale;
	
			// restrict radius to be between desired limits
			radius = Math.max(this.minDistance, Math.min(this.maxDistance, radius));
	
			offset.x = radius * Math.sin(phi) * Math.sin(theta);
			offset.y = radius * Math.cos(phi);
			offset.z = radius * Math.sin(phi) * Math.cos(theta);
	
			position.copy(this.center).add(offset);
	
			this.object.lookAt(this.center);
	
			thetaDelta = 0;
			phiDelta = 0;
			scale = 1;
	
			if (lastPosition.distanceTo(this.object.position) > 0) {
	
				this.dispatchEvent(changeEvent);
	
				lastPosition.copy(this.object.position);
			}
		};
	
		function getAutoRotationAngle() {
	
			return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
		}
	
		function getZoomScale() {
	
			return Math.pow(0.95, scope.userZoomSpeed);
		}
	
		function onMouseDown(event) {
	
			if (!scope.userRotate) return;
	
			event.preventDefault();
	
			if (event.button === 0 || event.button === 2) {
	
				state = STATE.ROTATE;
	
				rotateStart.set(event.clientX, event.clientY);
			} else if (event.button === 1) {
	
				state = STATE.ZOOM;
	
				zoomStart.set(event.clientX, event.clientY);
			}
	
			document.addEventListener('mousemove', onMouseMove, false);
			document.addEventListener('mouseup', onMouseUp, false);
		}
	
		function onMouseMove(event) {
	
			event.preventDefault();
	
			if (state === STATE.ROTATE) {
	
				rotateEnd.set(event.clientX, event.clientY);
				rotateDelta.subVectors(rotateEnd, rotateStart);
	
				scope.rotateLeft(2 * Math.PI * rotateDelta.x / PIXELS_PER_ROUND * scope.userRotateSpeed);
				scope.rotateUp(2 * Math.PI * rotateDelta.y / PIXELS_PER_ROUND * scope.userRotateSpeed);
	
				rotateStart.copy(rotateEnd);
			} else if (state === STATE.ZOOM) {
	
				zoomEnd.set(event.clientX, event.clientY);
				zoomDelta.subVectors(zoomEnd, zoomStart);
	
				if (zoomDelta.y > 0) {
	
					scope.zoomIn();
				} else {
	
					scope.zoomOut();
				}
	
				zoomStart.copy(zoomEnd);
			}
		}
	
		function onMouseUp(event) {
	
			if (!scope.userRotate) return;
	
			document.removeEventListener('mousemove', onMouseMove, false);
			document.removeEventListener('mouseup', onMouseUp, false);
	
			state = STATE.NONE;
		}
	
		function onMouseWheel(event) {
	
			if (!scope.userZoom) return;
	
			var delta = 0;
	
			if (event.wheelDelta) {
				// WebKit / Opera / Explorer 9
	
				delta = event.wheelDelta;
			} else if (event.detail) {
				// Firefox
	
				delta = -event.detail;
			}
	
			if (delta > 0) {
	
				scope.zoomOut();
			} else {
	
				scope.zoomIn();
			}
		}
	
		this.domElement.addEventListener('contextmenu', function (event) {
			event.preventDefault();
		}, false);
		this.domElement.addEventListener('mousedown', onMouseDown, false);
		this.domElement.addEventListener('mousewheel', onMouseWheel, false);
		this.domElement.addEventListener('DOMMouseScroll', onMouseWheel, false); // firefox
	};
	
	exports.default = _three2.default.OrbitControls;

/***/ },
/* 44 */,
/* 45 */,
/* 46 */,
/* 47 */,
/* 48 */,
/* 49 */,
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _three = __webpack_require__(11);
	
	var _three2 = _interopRequireDefault(_three);
	
	var _THREE = __webpack_require__(43);
	
	var _THREE2 = _interopRequireDefault(_THREE);
	
	var _TerrainBuilder = __webpack_require__(51);
	
	var _TerrainBuilder2 = _interopRequireDefault(_TerrainBuilder);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var demo = _TerrainBuilder2.default.create();
	window.demo = demo;
	
	document.body.appendChild(demo.view.element);
	
	var light = new _three2.default.DirectionalLight(0xdfebff, 1.75);
	light.position.set(300, 400, 50);
	light.position.multiplyScalar(1.3);
	
	light.castShadow = true;
	light.shadowCameraVisible = true;
	
	var lightTarget = new _three2.default.Object3D();
	lightTarget.position.set(-10, 10, 0);
	demo.view.scene.add(lightTarget);
	
	light.target = lightTarget;
	demo.view.scene.add(light);
	
	window.light = light;
	window.THREE = _three2.default;
	
	demo.view.camera.position.set(100, 10, 0);
	
	var orbitControls = new _THREE2.default(demo.view.camera);
	setInterval(orbitControls.update.bind(orbitControls), 40);
	
	var ball = new _three2.default.Mesh(new _three2.default.SphereGeometry(5), new _three2.default.MeshLambertMaterial({
		color: 'red'
	}));
	ball.position.set(-20, 30, 0);
	ball.castShadow = true;
	
	window.ball = ball;
	demo.view.scene.add(ball);

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _FPTGame = __webpack_require__(3);
	
	var _FPTGame2 = _interopRequireDefault(_FPTGame);
	
	var _FPTGameView = __webpack_require__(10);
	
	var _FPTGameView2 = _interopRequireDefault(_FPTGameView);
	
	var _StarterLevel = __webpack_require__(52);
	
	var _StarterLevel2 = _interopRequireDefault(_StarterLevel);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var TerrainBuilder = function () {
		function TerrainBuilder() {
			_classCallCheck(this, TerrainBuilder);
	
			this.game = _FPTGame2.default.create();
			this.game.setLevel(_StarterLevel2.default.create());
			this.view = _FPTGameView2.default.create(this.game);
		}
	
		_createClass(TerrainBuilder, null, [{
			key: 'create',
			value: function create() {
				return new TerrainBuilder();
			}
		}]);
	
		return TerrainBuilder;
	}();
	
	exports.default = TerrainBuilder;
	;

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	
	var _Level = __webpack_require__(31);
	
	var _Level2 = _interopRequireDefault(_Level);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var GROUND_LEVEL = 1;
	var RADIUS = 60;
	
	var StarterLevel = _Level2.default.createClass({
	
		generate: true,
	
		generateSolver: function generateSolver(x, y, z) {
			if (y === GROUND_LEVEL) {
				return Math.sqrt(x * x + z * z) <= RADIUS ? 1 : 0;
			}
			return 0;
		},
	
		generateRange: {
			low: {
				x: -40,
				y: 0,
				z: -40
			},
			high: {
				x: 40,
				y: 20,
				z: 40
			}
		},
	
		exported: false //'/client/tools/terrain-builder/starterLevel.exported.json'
	
	});
	
	StarterLevel.create = function () {
		return new StarterLevel();
	};
	
	exports.default = StarterLevel;

/***/ }
/******/ ]);
//# sourceMappingURL=terrain-builder.packed.js.map