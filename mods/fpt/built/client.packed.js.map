{"version":3,"sources":["webpack:///webpack/bootstrap 97e545b406c0cd44ee7e","webpack:///./start.js","webpack:///./FPTClient.js","webpack:///../game/FPTGame.js","webpack:///../game/ecs/System.js","webpack:///../game/ecs/SystemCollection.js","webpack:///../game/ecs/EntityCollection.js","webpack:///../game/Ticker.js","webpack:///../game/physics/Physics.js","webpack:////Users/dmillet/Projects/fpt/fpt/~/cannon/build/cannon.js","webpack:///../levels/Level.js","webpack:///../game/PiecesComponent.js","webpack:///../game/terrain/Terrain.js","webpack:///../game/ecs/Entity.js","webpack:////Users/dmillet/Projects/fpt/fpt/~/voxel/index.js","webpack:////Users/dmillet/Projects/fpt/fpt/~/voxel/chunker.js","webpack:///(webpack)/~/node-libs-browser/~/events/events.js","webpack:////Users/dmillet/Projects/fpt/fpt/~/voxel/~/inherits/inherits.js","webpack:////Users/dmillet/Projects/fpt/fpt/~/voxel/meshers/culled.js","webpack:////Users/dmillet/Projects/fpt/fpt/~/voxel/meshers/greedy.js","webpack:////Users/dmillet/Projects/fpt/fpt/~/voxel/meshers/transgreedy.js","webpack:////Users/dmillet/Projects/fpt/fpt/~/voxel/meshers/monotone.js","webpack:////Users/dmillet/Projects/fpt/fpt/~/voxel/meshers/stupid.js","webpack:///../game/terrain/TerrainPhysics.js","webpack:///../game/terrain/terrainPhysics-merge.js","webpack:///../game/terrain/TerrainPiece.js","webpack:///../game/physics/PhysicsComponent.js","webpack:///./view/FPTGameView.js","webpack:////Users/dmillet/Projects/fpt/fpt/~/three/three.js","webpack:///(webpack)/~/node-libs-browser/~/process/browser.js","webpack:///./view/TerrainView.js","webpack:////Users/dmillet/Projects/fpt/fpt/~/voxel-mesh/index.js","webpack:////Users/dmillet/Projects/fpt/fpt/~/voxel-texture/index.js","webpack:////Users/dmillet/Projects/fpt/fpt/~/voxel-texture/~/tic/index.js","webpack:////Users/dmillet/Projects/fpt/fpt/~/voxel-texture/~/atlaspack/index.js","webpack:////Users/dmillet/Projects/fpt/fpt/~/voxel-texture/~/opaque/index.js","webpack:////Users/dmillet/Projects/fpt/fpt/~/voxel-texture/~/voxel-fakeao/index.js","webpack:///./view/MeshComponent.js","webpack:///../levels/TestLevel1.js","webpack:///./ClientConnection.js","webpack:///../shared/EventObject.js","webpack:///./ClientSession.js","webpack:///../server/ServerSession.js","webpack:///./THREE.OrbitControls.js","webpack:///../game/testBall/TestBall.js","webpack:///../game/view/ViewComponent.js","webpack:///./view/PhysicsDebugView.js","webpack:///./view/PhysicsDebugComponent.js","webpack:///../game/physics/Position.js","webpack:///../game/physics/Vector.js","webpack:///../game/physics/Rotation.js","webpack:///../game/physics/Velocity.js","webpack:///../shared/compare.js","webpack:///../shared/clone.js","webpack:///./view/debug/ConstraintDebugView.js"],"names":[],"mappings":"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aCtEf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAa,2BAA2E,2DAA2D,KAAK,MAAM,yHAAyH,YAAY,0BAA0B,0BAA0B,gBAAgB,UAAU,UAAU,0CAA0C,8BAAwB,oBAAoB,8CAA8C,YAAY,YAAY,mCAAmC,iBAAiB,gBAAgB,sBAAsB,oBAAoB,0CAA0C,YAAY,WAAW,YAAY,SAAS,GAAG;AAC9tB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA,EAAC,GAAG;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAC,EAAE,8pCAA8pC;AACjqC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAkB,iBAAiB;AACnC;;AAEA;AACA;AACA;AACA;;AAEA,uBAAsB,WAAW;AACjC,uBAAsB,WAAW;AACjC,uBAAsB,WAAW;AACjC,uBAAsB,WAAW;AACjC,uBAAsB,WAAW;AACjC,uBAAsB,WAAW;AACjC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,KAAK;AACjB,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,EAAC,EAAE,sCAAsC;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,OAAO;AACnB,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qCAAoC,OAAO;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA,EAAC,GAAG;AACJ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,aAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB;AACA,wCAAuC,UAAU;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAgB,OAAO;AACvB;AACA;AACA;;AAEA;AACA;;AAEA,iBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,MAAM;AAClB,aAAY,KAAK;AACjB,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA,EAAC,EAAE,yGAAyG;AAC5G;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB;AACtB;AACA;AACA,eAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAgB,WAAW;AAC3B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAkB,WAAW,EAAE,wBAAwB,gBAAgB;AACvE,mBAAkB,WAAW,EAAE,wBAAwB,gBAAgB;AACvE,mBAAkB,WAAW,EAAE,wBAAwB,gBAAgB;AACvE,mBAAkB,WAAW,EAAE,wBAAwB,gBAAgB;AACvE,mBAAkB,WAAW,EAAE,wBAAwB,gBAAgB;AACvE,mBAAkB,WAAW,EAAE,wBAAwB,gBAAgB;;AAEvE;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAwB,eAAe;AACvC,0BAAyB,eAAe;AACxC,2BAA0B,eAAe;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAgB,OAAO;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,8BAA6B,WAAW;AACxC,+BAA8B,WAAW;AACzC,gCAA+B,WAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAgB,WAAW;AAC3B;AACA;AACA;AACA;;AAEA;AACA,iBAAgB,gBAAgB;AAChC;AACA,kBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA2B,SAAS;AACpC;AACA,6BAA4B,SAAS;AACrC;AACA,8BAA6B,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,EAAC,EAAE,wDAAwD;AAC3D;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAY,OAAO;AACnB,iBAAgB,OAAO;;AAEvB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAY,MAAM;AAClB,aAAY,KAAK;AACjB,YAAW,MAAM;AACjB,aAAY;AACZ;AACA;AACA;;AAEA;AACA,mBAAkB,yBAAyB;AAC3C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAC,EAAE,4BAA4B;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,OAAO;AACnB,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,OAAO;AACnB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;;AAEA,EAAC,GAAG;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB;AACA;AACA;AACA,mBAAkB,KAAK;AACvB;AACA;;AAEA;AACA,mBAAkB,KAAK;AACvB;AACA;;AAEA;;AAEA;AACA;AACA,mBAAkB,OAAO;AACzB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,wBAAwB;;AAE3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,MAAM;AACjB,aAAY,MAAM;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wCAAuC,OAAO;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,WAAW;AACtB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,aAAY,MAAM;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAiD,kBAAkB;AACnE,kDAAiD,kBAAkB;AACnE,kDAAiD,kBAAkB;AACnE,kDAAiD,kBAAkB;AACnE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAsB,YAAY;AAClC,2BAA0B,YAAY;;AAEtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAmB,YAAY;AAC/B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA0B,qBAAqB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA,EAAC,EAAE,+LAA+L;AAClM;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,EAAE,kBAAkB;AACrB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,MAAM;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,MAAM;AAClB;AACA;AACA;AACA;;AAEA;AACA,iBAAgB,uBAAuB;AACvC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,MAAM;AAClB,aAAY;AACZ;AACA;AACA,4BAA2B,IAAI;AAC/B;AACA,yBAAwB,KAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,MAAM;AAClB,aAAY;AACZ;AACA;AACA,4BAA2B,IAAI;AAC/B;AACA,yBAAwB,KAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,MAAM;AAClB,aAAY;AACZ;AACA;AACA,4BAA2B,IAAI;AAC/B;AACA,yBAAwB,KAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,MAAM;AAClB,aAAY,MAAM;AAClB,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAY,SAAS;AACrB;;AAEA,mBAAkB,OAAO;AACzB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAY,KAAK;AACjB,aAAY,KAAK;AACjB,aAAY,OAAO;AACnB,aAAY;AACZ;AACA;AACA;AACA,yBAAwB,YAAY;AACpC,yBAAwB,YAAY;AACpC,yBAAwB,YAAY;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAgB,OAAO;AACvB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,MAAM;AAClB,aAAY,KAAK;AACjB,YAAW,MAAM;AACjB,aAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,yBAAwB,YAAY;AACpC,yBAAwB,YAAY;;AAEpC;AACA;AACA;AACA,mBAAkB,qBAAqB;AACvC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAC,EAAE,iDAAiD;AACpD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA,mBAAkB,KAAK;AACvB;AACA;;AAEA;AACA,mBAAkB,KAAK;AACvB;AACA;;AAEA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,EAAC,EAAE,oBAAoB;AACvB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kDAAiD;AACjD;AACA;AACA;AACA;AACA;;AAEA,EAAC,EAAE,oDAAoD;AACvD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,UAAU;AACrB,YAAW,UAAU;AACrB,YAAW,OAAO;AAClB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB;AACA;AACA,iDAAgD;AAChD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAc;;AAEd;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,wCAAuC;AACvC;AACA;AACA;AACA;AACA,wCAAuC;AACvC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAuC;AACvC;AACA;AACA;AACA;AACA,wCAAuC;AACvC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAgE,0BAA0B;AAC1F,iEAAgE,0BAA0B;AAC1F,iEAAgE,0BAA0B;AAC1F,iEAAgE,0BAA0B;AAC1F,iEAAgE,0BAA0B;;AAE1F,EAAC,EAAE,qJAAqJ;AACxJ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB;AACA;AACA,8BAA6B,UAAU;AACvC,8BAA6B,UAAU;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAC,EAAE,oDAAoD;AACvD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA,4BAA2B;;AAE3B;AACA;AACA,mBAAkB,KAAK;AACvB;AACA;;AAEA;AACA;AACA,mBAAkB,KAAK;AACvB;AACA;;AAEA;;AAEA;AACA;AACA,mBAAkB,KAAK;AACvB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAAkC;;AAElC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAC,EAAE,oDAAoD;AACvD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;;AAEA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA,mBAAkB,gBAAgB;AAClC;AACA;;AAEA;AACA,mBAAkB,gBAAgB;AAClC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAgC,oDAAoD;AACpF,WAAU,6BAA6B;AACvC,iCAAgC,oDAAoD;AACpF,WAAU,6BAA6B;;AAEvC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,OAAO;AACnB,aAAY;AACZ;AACA;AACA;AACA;;AAEA,EAAC,EAAE,+CAA+C;AAClD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB;;;AAGxB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA2B,iDAAiD;AAC5E,WAAU,6BAA6B;AACvC,4BAA2B,iDAAiD;AAC5E,WAAU,6BAA6B;;AAEvC,+BAA8B;AAC9B,mCAAkC;;AAElC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAC,EAAE,oDAAoD;AACvD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,UAAU;AACrB,YAAW,KAAK;AAChB,YAAW,UAAU;AACrB,YAAW,KAAK;AAChB;AACA;AACA;AACA;AACA,0BAAyB;AACzB,0BAAyB;;AAEzB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAkC;;AAElC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAC,EAAE,oDAAoD;AACvD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,UAAU;AACrB,YAAW,UAAU;AACrB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,6BAA4B;AAC5B,6BAA4B;;AAE5B;AACA;;AAEA;AACA;AACA,mBAAkB,OAAO;AACzB;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mCAAkC;;AAElC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAC,EAAE,oDAAoD;AACvD;;AAEA;;AAEA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB,YAAW,SAAS;AACpB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA,mBAAkB,MAAM;AACxB;AACA;AACA;;AAEA;AACA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA,mBAAkB,OAAO;AACzB;AACA;AACA;;AAEA;;AAEA,EAAC,EAAE,oBAAoB;AACvB;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;;AAEA,EAAC,GAAG;AACJ;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAkB,KAAK;AACvB;AACA;;AAEA;AACA,mBAAkB,KAAK;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,gBAAgB;AAC5B,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,KAAK;AACjB,aAAY,KAAK;AACjB,aAAY;AACZ;AACA;AACA;AACA;;AAEA,EAAC,EAAE,YAAY;AACf;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,MAAM;AACxB;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,iBAAgB,wBAAwB;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,aAAY,KAAK;AACjB;AACA;AACA;AACA,iBAAgB,KAAK;AACrB,qBAAoB,KAAK;AACzB;AACA,yBAAwB,KAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,aAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,aAAY,KAAK;AACjB;AACA;AACA;AACA;;AAEA;AACA,gBAAe;AACf,gBAAe;AACf;AACA,iBAAgB,SAAS;AACzB;AACA;AACA;AACA,aAAY,KAAK;AACjB,iBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA;AACA;AACA,4BAA2B,OAAO;AAClC;AACA;AACA,yBAAwB;AACxB;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,4BAA2B,OAAO;AAClC;AACA;AACA,qBAAoB;AACpB;AACA;AACA,kBAAiB;AACjB;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,aAAY,KAAK;AACjB;AACA;AACA,iBAAgB,4BAA4B;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,KAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,aAAY,KAAK;AACjB;AACA;;AAEA;;AAEA;AACA,gBAAe;AACf,gBAAe;AACf;AACA,iBAAgB,SAAS;AACzB;AACA;AACA;AACA,aAAY,KAAK;AACjB,iBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,4BAA2B,OAAO;AAClC;AACA;AACA,yBAAwB;AACxB;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,4BAA2B,OAAO;AAClC;AACA;AACA,qBAAoB;AACpB;AACA;AACA,kBAAiB;AACjB;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;AACT,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,YAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAY,KAAK;AACjB,aAAY,KAAK;AACjB;AACA;AACA;;AAEA;AACA;;AAEA,iBAAgB,OAAO;AACvB,qBAAoB,OAAO;AAC3B;AACA;AACA;;AAEA;AACA;;AAEA,EAAC,EAAE,YAAY;AACf;;AAEA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA,mBAAkB,OAAO;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA,wCAAuC;AACvC,qBAAoB;AACpB;AACA,+BAA8B,qEAAqE;AACnG;AACA;AACA,MAAK;AACL,mCAAkC;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,WAAW;AACtB,YAAW,WAAW;AACtB,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,WAAW;AACtB,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,WAAW;AACtB,aAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,aAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,WAAW;AACtB,aAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,4BAA2B;AAC3B;AACA;AACA;AACA;AACA,6BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAoE;AACpE,0CAAyC;AACzC,kEAAiE;AACjE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,EAAC,EAAE,YAAY;AACf;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAC,EAAE,8BAA8B;AACjC;;AAEA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA,gCAA+B;AAC/B;AACA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,aAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,KAAK;AACjB,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,KAAK;AAChB,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,KAAK;AAChB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,aAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,YAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAY,KAAK;AACjB,aAAY,OAAO;AACnB,aAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA,EAAC,EAAE,YAAY;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;;AAEA;;AAEA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAkB,KAAK;AACvB;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA,mBAAkB,KAAK;AACvB;AACA;;AAEA;AACA,mBAAkB,KAAK;AACvB;AACA;;AAEA;;AAEA;AACA,mBAAkB,KAAK;AACvB;AACA;;AAEA;AACA,mBAAkB,KAAK;AACvB;AACA;;AAEA;AACA;AACA,mBAAkB,QAAQ;AAC1B;AACA;;AAEA;AACA,mBAAkB,OAAO;AACzB;AACA,gCAA+B;;AAE/B;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;;;;AAIA;AACA;AACA;AACA,WAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,WAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,WAAU;AACV;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA4B,cAAc;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA0C;AAC1C;AACA;AACA,UAAS;AACT,2BAA0B;AAC1B,UAAS;AACT,0BAAyB;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,KAAK;AACjB,aAAY,KAAK;AACjB,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,KAAK;AACjB,aAAY,KAAK;AACjB,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,KAAK;AACjB,aAAY,KAAK;AACjB,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAgB,OAAO;AACvB;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,KAAK;AACjB,aAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,KAAK;AACjB,aAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,KAAK;AACjB,aAAY,KAAK;AACjB,aAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAC,EAAE,8KAA8K;AACjL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;;AAEA;AACA,mBAAkB,KAAK;AACvB;AACA;;AAEA;AACA,mBAAkB,MAAM;AACxB;AACA;;AAEA;AACA;AACA,mBAAkB,QAAQ;AAC1B;AACA;;AAEA;AACA,mBAAkB,MAAM;AACxB;AACA;;AAEA;AACA;AACA,mBAAkB,QAAQ;AAC1B;AACA;AACA;;AAEA;AACA;AACA,mBAAkB,QAAQ;AAC1B;AACA;AACA;;AAEA;AACA;AACA,mBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,QAAQ;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAmB,eAAe;AAClC;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAmB,eAAe;AAClC;AACA;;AAEA;;AAEA;AACA;AACA,oBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,gBAAe,eAAe;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,+CAA8C;AAC9C,qCAAoC;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,uBAAsB,kBAAkB;AACxC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,oBAAmB,eAAe;AAClC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAmB,eAAe;AAClC;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oBAAmB,eAAe;AAClC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,oDAAmD;;AAEnD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAmB,eAAe;AAClC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,EAAC,EAAE,qIAAqI;AACxI;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA,mBAAkB,KAAK;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB;AACA;AACA;AACA;;AAEA,oBAAmB,mBAAmB;AACtC;AACA;;AAEA,oBAAmB,wBAAwB;AAC3C;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAmB,wBAAwB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB;AACA;AACA;AACA;;AAEA,oBAAmB,mBAAmB;AACtC;AACA;;AAEA,oBAAmB,wBAAwB;AAC3C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAC,EAAE,2GAA2G;AAC9G;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB,8BAA6B;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC;AACpC;AACA;AACA;AACA;AACA;;AAEA,iBAAgB,OAAO;AACvB,mCAAkC;AAClC;;AAEA;AACA;AACA;AACA,2CAA0C;AAC1C;;AAEA;AACA;AACA,qBAAoB,kBAAkB;;AAEtC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAgB,OAAO;;AAEvB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAoB,kBAAkB;;AAEtC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAC,EAAE,sIAAsI;AACzI;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAC,EAAE,kBAAkB;AACrB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA,mBAAkB,QAAQ;AAC1B;AACA;;AAEA;AACA,mBAAkB,QAAQ;AAC1B;AACA;;AAEA;AACA,mBAAkB,KAAK;AACvB;AACA;;AAEA;AACA,mBAAkB,KAAK;AACvB;AACA;;AAEA;AACA,mBAAkB,KAAK;AACvB;AACA;;AAEA;AACA,mBAAkB,KAAK;AACvB;AACA;;AAEA;AACA,mBAAkB,KAAK;AACvB;AACA;;AAEA;AACA,mBAAkB,KAAK;AACvB;AACA;;AAEA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA,mBAAkB,cAAc;AAChC;AACA;;AAEA;AACA;AACA,mBAAkB,UAAU;AAC5B;AACA;;AAEA;AACA,mBAAkB,QAAQ;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,EAAE,6FAA6F;AAChG;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,KAAK;AACjB,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,QAAQ;AACnB,YAAW,WAAW;AACtB,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAoB,kBAAkB;AACtC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;;AAEA,EAAC,EAAE,uDAAuD;AAC1D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA,6BAA4B;AAC5B;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA,gCAA+B;;AAE/B;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAgB,gBAAgB;AAChC;AACA;AACA,uBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA;AACA,yBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAgB,qBAAqB;;AAErC;AACA,qBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,WAAW;AACtB,YAAW,iBAAiB;AAC5B,YAAW,KAAK;AAChB,YAAW,WAAW;AACtB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,iBAAiB;AAC5B,YAAW,KAAK;AAChB,YAAW,WAAW;AACtB,YAAW,KAAK;AAChB,YAAW,WAAW;AACtB,YAAW,KAAK;AAChB,aAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAgB,aAAa;AAC7B;AACA;AACA;AACA,oDAAmD;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,kBAAiB,6BAA6B;AAC9C;AACA;AACA;AACA,4CAA2C;;AAE3C;;AAEA,sBAAqB,6BAA6B;AAClD;AACA;AACA,gDAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,iBAAiB;AAC5B,YAAW,KAAK;AAChB,YAAW,WAAW;AACtB,YAAW,KAAK;AAChB,YAAW,WAAW;AACtB,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY,OAAO;AACnB,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,WAAW;AACtB,YAAW,MAAM;AACjB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,sBAAsB;AACtC,qBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,iEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAiB,iBAAiB;AAClC,8DAA6D;AAC7D,0JAAyJ;AACzJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,oBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAgB,OAAO;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAgB,KAAK;AACrB;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAgB,OAAO;AACvB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,WAAW;AACtB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB;AACA;AACA;AACA;AACA,iBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,KAAK;AACjB,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA,iBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,KAAK;AACjB,aAAY,WAAW;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAoB,KAAK;AACzB;AACA;AACA;AACA;AACA,qBAAoB,2BAA2B;AAC/C;AACA;AACA;AACA;AACA;AACA,qBAAoB,2BAA2B;AAC/C;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA,qBAAoB,KAAK;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,KAAK;AACjB,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,KAAK;AACrB;AACA;AACA,oCAAmC;;AAEnC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0BAAyB;AACzB,UAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,iBAAiB;AAC5B,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,WAAW;AACtB,YAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAkB,OAAO;AACzB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAC,EAAE,8EAA8E;AACjF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,2CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,EAAC,EAAE,+EAA+E;AAClF;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,sBAAqB,UAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,mBAAkB,MAAM;AACxB;AACA;;AAEA;AACA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA,mBAAkB,OAAO;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,0BAAyB;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,mBAAmB;AACnC,qBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,mBAAmB;AACnC,qBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,QAAQ;AACnB,YAAW,QAAQ;AACnB,YAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,QAAQ;AACpB,aAAY,QAAQ;AACpB,aAAY,QAAQ;AACpB,aAAY,QAAQ;AACpB,aAAY,MAAM;AAClB,aAAY,MAAM;AAClB;AACA;AACA;;AAEA;AACA;AACA,6BAA4B;AAC5B,uBAAsB,WAAW;AACjC,2BAA0B,WAAW;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,OAAO;AACnB,aAAY,MAAM;AAClB,aAAY,QAAQ;AACpB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAmB,QAAQ;AAC3B,oBAAmB,QAAQ;AAC3B,mCAAkC,sBAAsB;AACxD,sCAAqC,yBAAyB;AAC9D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wCAAuC;AACvC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,QAAQ;AACpB,aAAY,QAAQ;AACpB,aAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,OAAO;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,OAAO;AAC1B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA4B;AAC5B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,EAAE,2EAA2E;AAC9E;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,KAAK;AACjB,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,EAAC,EAAE,+BAA+B;AAClC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6BAA4B;AAC5B;;AAEA;AACA;AACA;AACA,2BAA0B;AAC1B;AACA;AACA;AACA;;AAEA,4BAA2B,eAAe;AAC1C,4BAA2B,eAAe;AAC1C,4BAA2B,eAAe;;AAE1C,6BAA4B,eAAe;AAC3C,6BAA4B,eAAe;AAC3C,6BAA4B,eAAe;AAC3C;;AAEA;AACA;AACA;AACA,EAAC,EAAE,+BAA+B;AAClC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA,mBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,EAAC,EAAE,iFAAiF;AACpF;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA,mBAAkB,OAAO;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAgB,eAAe;AAC/B;AACA;AACA;AACA;AACA;;AAEA,EAAC,EAAE,+BAA+B;AAClC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,gCAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAoB,aAAa;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,qBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAmB,gBAAgB;;AAEnC;AACA;;AAEA,yBAAwB,SAAS;;AAEjC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA,kFAAiF;;AAEjF;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,EAAC,EAAE,wDAAwD;AAC3D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,MAAM;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,EAAC,GAAG;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAiC;AACjC,gCAA+B;AAC/B,gCAA+B;AAC/B,qCAAoC,aAAa;;AAEjD;AACA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB,gDAAgD;AACpE;;AAEA;AACA,iBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAoB,UAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAoB,UAAU;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,EAAC,EAAE,6EAA6E;AAChF;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAgB,OAAO;AACvB,iBAAgB,SAAS;AACzB,iBAAgB,YAAY;AAC5B;AACA;AACA,8CAA6C,sBAAsB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,iBAAgB,OAAO;AACvB,iBAAgB,SAAS;AACzB,iBAAgB;AAChB;AACA;AACA,8CAA6C,cAAc;AAC3D;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,iBAAgB,OAAO;AACvB,iBAAgB,SAAS;AACzB,iBAAgB,YAAY;AAC5B;AACA;AACA,8CAA6C,aAAa;AAC1D;AACA,8CAA6C,aAAa;AAC1D;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,iBAAgB,OAAO;AACvB,iBAAgB,OAAO;AACvB,iBAAgB,YAAY;AAC5B;AACA;AACA,8CAA6C,aAAa;AAC1D;AACA;AACA;AACA;AACA,uDAAsD,OAAO;AAC7D;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAC,GAAG;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,MAAM;AACxB;AACA;;AAEA;AACA;AACA,mBAAkB,MAAM;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA,iBAAgB,WAAW;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA,EAAC,GAAG;AACJ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA,kBAAiB;AACjB;;AAEA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,OAAO;AACnB,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,OAAO;AACnB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAC,GAAG;AACJ;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,OAAO;AACnB,aAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,EAAC,GAAG;AACJ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA,EAAC,EAAE,8BAA8B;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAkB,MAAM;AACxB;AACA;;AAEA;AACA;AACA,mBAAkB,SAAS;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,8BAA6B,OAAO;;AAEpC;AACA;AACA;;AAEA,wBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;;AAEA,4BAA2B,sBAAsB;;AAEjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,WAAW;AACtB,YAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yCAAwC,yBAAyB;AACjE;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY,MAAM;AAClB,aAAY,MAAM;AAClB,aAAY,MAAM;AAClB,aAAY,KAAK;AACjB,aAAY,KAAK;AACjB,aAAY,WAAW;AACvB,aAAY,WAAW;AACvB,aAAY,KAAK;AACjB,aAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAY,MAAM;AAClB,aAAY,MAAM;AAClB,aAAY,MAAM;AAClB,aAAY,KAAK;AACjB,aAAY,KAAK;AACjB,aAAY,WAAW;AACvB,aAAY,WAAW;AACvB,aAAY,KAAK;AACjB,aAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAsB;AACtB,sBAAqB;;AAErB;AACA;;AAEA;AACA;AACA;AACA,+DAA8D;;AAE9D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,OAAO;AACvB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,0BAAyB;AACzB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY,MAAM;AAClB,aAAY,MAAM;AAClB,aAAY,MAAM;AAClB,aAAY,KAAK;AACjB,aAAY,KAAK;AACjB,aAAY,WAAW;AACvB,aAAY,WAAW;AACvB,aAAY,KAAK;AACjB,aAAY,KAAK;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAsC,+BAA+B;AACrE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA8B;AAC9B;AACA,2BAA0B;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAgB,iBAAiB;AACjC,qBAAoB,iBAAiB;AACrC,yBAAwB,iBAAiB;AACzC;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA,iBAAgB,sBAAsB;AACtC,qBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAmD;AACnD,wDAAuD;;AAEvD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,wDAAuD;AACvD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY,MAAM;AAClB,aAAY,MAAM;AAClB,aAAY,MAAM;AAClB,aAAY,KAAK;AACjB,aAAY,KAAK;AACjB,aAAY,WAAW;AACvB,aAAY,WAAW;AACvB,aAAY,KAAK;AACjB,aAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAgB,kBAAkB;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAqC,6BAA6B;AAClE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gCAA+B;AAC/B,6CAA4C,YAAY;AACxD;AACA;AACA;AACA;AACA;;AAEA,0DAAyD;AACzD;AACA;;AAEA,4CAA2C;AAC3C,0CAAyC;;AAEzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,0DAAyD,gBAAgB;AACzE;AACA;;AAEA,wBAAuB;AACvB,cAAa;AACb;AACA,6BAA4B,iBAAiB;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kFAAiF;AACjF;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,kEAAiE,gBAAgB;AACjF;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sDAAqD,gBAAgB;AACrE;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAY,MAAM;AAClB,aAAY,MAAM;AAClB,aAAY,MAAM;AAClB,aAAY,KAAK;AACjB,aAAY,KAAK;AACjB,aAAY,WAAW;AACvB,aAAY,WAAW;AACvB,aAAY,KAAK;AACjB,aAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY,MAAM;AAClB,aAAY,MAAM;AAClB,aAAY,MAAM;AAClB,aAAY,KAAK;AACjB,aAAY,KAAK;AACjB,aAAY,WAAW;AACvB,aAAY,WAAW;AACvB,aAAY,KAAK;AACjB,aAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C;;AAE7C;AACA,mBAAkB,mCAAmC;;AAErD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iDAAgD;;AAEhD,oCAAmC;;AAEnC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAY,MAAM;AAClB,aAAY,MAAM;AAClB,aAAY,MAAM;AAClB,aAAY,KAAK;AACjB,aAAY,KAAK;AACjB,aAAY,WAAW;AACvB,aAAY,WAAW;AACvB,aAAY,KAAK;AACjB,aAAY,KAAK;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAY,MAAM;AAClB,aAAY,MAAM;AAClB,aAAY,MAAM;AAClB,aAAY,KAAK;AACjB,aAAY,KAAK;AACjB,aAAY,WAAW;AACvB,aAAY,WAAW;AACvB,aAAY,KAAK;AACjB,aAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA,wCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,2BAA0B;AAC1B;AACA,yBAAwB;;AAExB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAY,MAAM;AAClB,aAAY,MAAM;AAClB,aAAY,MAAM;AAClB,aAAY,KAAK;AACjB,aAAY,KAAK;AACjB,aAAY,WAAW;AACvB,aAAY,WAAW;AACvB,aAAY,KAAK;AACjB,aAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA0B;AAC1B;AACA,yBAAwB;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY,MAAM;AAClB,aAAY,MAAM;AAClB,aAAY,MAAM;AAClB,aAAY,KAAK;AACjB,aAAY,KAAK;AACjB,aAAY,WAAW;AACvB,aAAY,WAAW;AACvB,aAAY,KAAK;AACjB,aAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4CAA2C,YAAY;;AAEvD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iDAAgD;AAChD,6BAA4B;;AAE5B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAkB,WAAW;AAC7B,mBAAkB,WAAW;AAC7B,mBAAkB,WAAW;AAC7B,mBAAkB,WAAW;AAC7B,8BAA6B,yBAAyB;AACtD,8BAA6B,yBAAyB;AACtD,iCAAgC,4BAA4B;AAC5D,iCAAgC,4BAA4B;;AAE5D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAsB,WAAW;AACjC,2BAA0B,WAAW;;AAErC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAkB,WAAW;AAC7B,mBAAkB,WAAW;AAC7B,mBAAkB,WAAW;AAC7B,mBAAkB,WAAW;AAC7B,8BAA6B,yBAAyB;AACtD,8BAA6B,yBAAyB;AACtD,iCAAgC,4BAA4B;AAC5D,iCAAgC,4BAA4B;;AAE5D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAsB,WAAW;AACjC,2BAA0B,WAAW;;AAErC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,4BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,EAAE,qMAAqM;AACxM;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA,mBAAkB,qBAAqB;AACvC,YAAW;AACX;AACA;;AAEA;AACA;AACA,mBAAkB,qBAAqB;AACvC,YAAW;AACX;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA,mBAAkB,gBAAgB;AAClC;AACA;;AAEA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA,oGAAmG,kCAAkC;;AAErI;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,SAAS;AACpB,YAAW,SAAS;AACpB,aAAY,gBAAgB;AAC5B;AACA;AACA,uDAAsD;AACtD;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,WAAW;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,uBAAuB;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA8B;;AAE9B;AACA,qBAAoB,mBAAmB;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,gBAAgB;AAC3B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAkC;;AAElC;;AAEA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA,qBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qBAAoB,qBAAqB;AACzC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,cAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA,iCAAgC,gBAAgB;AAChD,gCAA+B,eAAe;AAC9C,gCAA+B,yCAAyC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAY,OAAO;AACnB;AACA,+BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qDAAoD,iBAAiB;AACrE;AACA;;AAEA;AACA,qBAAoB,oCAAoC;AACxD,mBAAkB;AAClB;AACA;AACA,qBAAoB,yDAAyD;;AAE7E;AACA;AACA,aAAY,kBAAkB;AAC9B;AACA;AACA,qCAAoC,MAAM;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,qBAAoB,oCAAoC;AACxD;AACA;;AAEA,aAAY,kBAAkB;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY,2BAA2B;AACvC;AACA;AACA;;AAEA,iBAAgB,eAAe;;AAE/B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gCAA+B;;AAE/B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY,kBAAkB;AAC9B;AACA;AACA,6CAA4C,SAAS;AACrD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAY,OAAO;AACnB;AACA,+BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA,+EAA8E;AAC9E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA,EAAC,EAAE,geAAge,EAAE,GAAG;AACxe;AACA,EAAC,E;;;;;;;;;;;;AC13WD;;;;AACA;;;;AACA;;;;AACA;;;;;;AAEA,KAAI,QAAQ,iBAAO,WAAP,CAAmB;;AAE9B,eAAa,uBAAW;AACvB,OAAI,SAAS,KAAK,MAAL,GAAc,iBAAO,MAAP,EAAd,CADU;AAEvB,OAAI,SAAS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;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7FA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAiC,UAAU;AAC3C;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,mBAAmB;AAC9C,8BAA6B,mBAAmB;AAChD,gCAA+B,mBAAmB;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,gBAAe,SAAS;AACxB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH,qBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACzSA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC5BA;AACA;AACA;AACA;AACA,eAAc,KAAK;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C,cAAc;AACzD,4CAA2C,cAAc;AACzD,4CAA2C,cAAc;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;;;AAGA;AACA;AACA;;;;;;;ACjDA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc,KAAK;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAmB,cAAc;AACjC,sBAAqB,cAAc;AACnC;AACA;AACA;AACA,yBAAwB;AACxB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,gBAAe,WAAW;AAC1B,kBAAiB,WAAW;AAC5B;AACA;AACA,iBAAgB,MAAM;AACtB;;AAEA;AACA;AACA;;AAEA;AACA,oBAAmB,aAAa;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAoB;AACpB,qBAAoB;;AAEpB;AACA,uBAAsB;AACtB,uBAAsB;AACtB,YAAW;AACX;AACA,uBAAsB;AACtB,uBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAkB,KAAK;AACvB,qBAAoB,KAAK;AACzB;AACA;AACA;;AAEA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA,WAAU;AACV;AACA,EAAC;;AAED;AACA;AACA;;;;;;;AClHA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mFAAkF;AAClF;AACA;AACA;AACA;;;AAGA;AACA,eAAc,KAAK;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAmB,cAAc;AACjC,sBAAqB,cAAc;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB,WAAW;AAC5B,oBAAmB,WAAW;AAC9B;AACA;AACA,mBAAkB,MAAM;AACxB;;AAEA;AACA;AACA;;AAEA;AACA,sBAAqB,aAAa;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAsB;AACtB,uBAAsB;;AAEtB;AACA;AACA,yBAAwB;AACxB,yBAAwB;AACxB,cAAa;AACb;AACA,yBAAwB;AACxB,yBAAwB;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAoB,KAAK;AACzB,uBAAsB,KAAK;AAC3B;AACA;AACA;;AAEA;AACA,oBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA,cAAa;;AAEb;AACA;AACA;AACA,OAAM;AACN,WAAU;AACV;AACA,EAAC;;AAED;AACA;AACA;;;;;;;AC7LA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,8C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc,KAAK;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA,kBAAiB,cAAc;AAC/B;AACA;AACA,oBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,gBAAgB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,MAAM;AACnB;AACA;AACA;AACA,cAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,MAAM;AACxB;AACA;AACA;AACA;;AAEA;;AAEA;AACA,mBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB;;AAExB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf,uE;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,2BAA0B,KAAK;AAC/B,2BAA0B,KAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA,EAAC;;AAED;AACA;AACA;;;;;;;AC1PA;AACA;AACA;AACA,cAAa,cAAc;AAC3B,cAAa,cAAc;AAC3B,cAAa,cAAc;AAC3B;AACA,iBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA,mBAAkB,KAAK;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU;AA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A;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA;AACA,2DAA0D;;AAE1D;AACA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;;AAEA,IAAG;;AAEH;AACA;AACA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA,IAAG;;AAEH;;AAEA;;AAEA;;AAEA;;AAEA,IAAG;;AAEH;;AAEA;;AAEA;;AAEA;;AAEA,IAAG;;AAEH;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,KAAI;;AAEJ;AACA;;AAEA;;AAEA,IAAG;;AAEH;;AAEA;;AAEA;AACA;;AAEA,KAAI;;AAEJ;AACA;;AAEA;;AAEA,IAAG;;AAEH;;AAEA;;AAEA;AACA;;AAEA,KAAI;;AAEJ;AACA;;AAEA;;AAEA,IAAG;;AAEH;;AAEA;;AAEA;AACA;;AAEA,KAAI;;AAEJ;AACA;;AAEA;;AAEA,IAAG;;AAEH;;AAEA;;AAEA;AACA;;AAEA,KAAI;;AAEJ;AACA;;AAEA;;AAEA,IAAG;;AAEH;;AAEA;;AAEA;AACA;;AAEA,KAAI;;AAEJ;AACA;;AAEA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,IAAG;;AAEH;AACA;AACA;;AAEA,IAAG;;AAEH;AACA;AACA;;AAEA,IAAG;;AAEH;AACA;AACA;;AAEA,IAAG;;AAEH;AACA;AACA;;AAEA,IAAG;;AAEH;AACA;AACA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAE;;AAEF;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA,2BAA0B;AAC1B,2BAA0B;AAC1B,2BAA0B;AAC1B,2BAA0B;AAC1B;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,IAAG;;AAEH;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,IAAG;;AAEH;AACA;AACA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,iBAAgB;;AAEhB;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAsC;;AAEtC;;AAEA;AACA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA;;AAEA;;AAEA,KAAI,sBAAsB;;AAE1B;;AAEA;AACA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA;;AAEA;;AAEA,KAAI,OAAO;;AAEX;;AAEA;AACA;AACA;;AAEA,MAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,gBAAe;;AAEf;;AAEA;;AAEA;AACA;AACA,0CAAyC;;AAEzC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA,IAAG;;AAEH;;AAEA;;AAEA;;AAEA;;AAEA,IAAG;;AAEH;;AAEA;;AAEA;;AAEA;;AAEA,IAAG;;AAEH;;AAEA;;AAEA;;AAEA;;AAEA,IAAG;;AAEH;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA,EAAC;AACD;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA;AACA;;AAEA,wCAAuC,QAAQ;;AAE/C;;AAEA;;AAEA;;AAEA,MAAK;;AAEL;;AAEA;;AAEA;;AAEA;;AAEA,MAAK;;AAEL;;AAEA;;AAEA;;AAEA,IAAG;;AAEH;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;;AAEA,GAAE;;AAEF;;AAEA;AACA;;AAEA,GAAE;;AAEF;;AAEA;AACA;;AAEA;AACA,GAAE;;AAEF;;AAEA;AACA;;AAEA;AACA,GAAE;;AAEF;;AAEA;AACA;;AAEA;AACA,GAAE;;AAEF;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA,EAAC;AACD;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA;AACA;;AAEA,wCAAuC,QAAQ;;AAE/C;;AAEA;;AAEA;;AAEA,MAAK;;AAEL;;AAEA;;AAEA;;AAEA;;AAEA,MAAK;;AAEL;;AAEA;;AAEA;;AAEA;;AAEA,MAAK;;AAEL;;AAEA;;AAEA;;AAEA,IAAG;;AAEH;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;;AAEA,GAAE;;AAEF;;AAEA;AACA;;AAEA,GAAE;;AAEF;;AAEA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,+EAA8E;AAC9E,+EAA8E;AAC9E,+EAA8E;AAC9E,+EAA8E;AAC9E,+EAA8E;AAC9E,+EAA8E;AAC9E,+EAA8E;AAC9E,+EAA8E;;AAE9E;AACA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA,EAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,eAAc,aAAa;AAC3B,eAAc,aAAa;AAC3B,eAAc,aAAa;;AAE3B;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA,mCAAkC,QAAQ;;AAE1C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA,cAAa,YAAY;AACzB,cAAa,YAAY;AACzB,cAAa,YAAY;;AAEzB;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,4B;;AAEA,KAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA,cAAa,aAAa;AAC1B,cAAa,aAAa;AAC1B,cAAa,aAAa;;AAE1B;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA;AACA;;AAEA,0CAAyC,kBAAkB,kBAAkB;AAC7E,mBAAkB,yCAAyC,kBAAkB;AAC7E,mBAAkB,kBAAkB,0CAA0C;AAC9E,mBAAkB,kBAAkB,mBAAmB;;AAEvD;;AAEA;;AAEA;;AAEA;;AAEA,eAAc,aAAa,aAAa;AACxC,eAAc,aAAa,aAAa;AACxC,eAAc,aAAa,cAAc;AACzC,eAAc,aAAa,cAAc;;AAEzC;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,IAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,IAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,IAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,IAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,IAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;;AAGA,gBAAe,aAAa;AAC5B,gBAAe,aAAa;AAC5B,gBAAe,aAAa;;AAE5B;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA,kBAAiB,gBAAgB,gBAAgB;AACjD,kBAAiB,gBAAgB,gBAAgB;AACjD,mBAAkB,iBAAiB,kBAAkB;AACrD,oBAAmB,kBAAkB,kBAAkB;;AAEvD;;AAEA,GAAE;;AAEF;;AAEA;;AAEA,cAAa,YAAY,YAAY;AACrC,cAAa,YAAY,YAAY;AACrC,cAAa,YAAY,aAAa;AACtC,cAAa,YAAY,aAAa;;AAEtC;;AAEA,GAAE;;AAEF;;AAEA;AACA;;AAEA,GAAE;;AAEF;;AAEA;AACA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA,mCAAkC,QAAQ;;AAE1C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;;AAEA,eAAc,eAAe;AAC7B,eAAc,eAAe;AAC7B,eAAc,eAAe;;AAE7B,eAAc,gBAAgB;AAC9B,eAAc,gBAAgB;AAC9B,gBAAe,iBAAiB;;AAEhC;;AAEA,GAAE;;AAEF;;AAEA;AACA,qBAAoB,mBAAmB,mBAAmB;AAC1D,qBAAoB,mBAAmB,mBAAmB;AAC1D,qBAAoB,mBAAmB,qBAAqB;AAC5D,uBAAsB,qBAAqB,qBAAqB;;AAEhE;;AAEA,GAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,4B;;AAEA,KAAI;;AAEJ;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAG;;AAEH;;AAEA,IAAG;;AAEH;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;;AAEA,cAAa,YAAY;AACzB,cAAa,YAAY;AACzB,cAAa,YAAY;AACzB,cAAa,YAAY;;AAEzB;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAE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AEA;;AAEA;;AAEA,EAAC;AACD;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA,8CAA6C;;AAE7C;;AAEA,GAAE;;AAEF;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,GAAE;;;AAGF;;AAEA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;AACA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;AACA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,GAAE;;;AAGF;;AAEA;AACA;;AAEA,GAAE;;AAEF;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA,EAAC;AACD;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;AACA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;AACA;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA,GAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,GAAE;;A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AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,2CAA0C;;AAE1C;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,2CAA0C;AAC1C;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,2CAA0C;AAC1C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,gBAAgB,wBAAwB,iBAAiB,sBAAsB,EAAE;AAChG;AACA,eAAc,oBAAoB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,uCAAsC;AACtC,qCAAoC;A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EpD;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,6CAA4C,QAAQ;;AAEpD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,MAAK;;AAEL;;AAEA;;AAEA;;AAEA,OAAM;;AAEN;;AAEA;;AAEA;;AAEA,6CAA4C,QAAQ;;AAEpD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,6CAA4C,QAAQ;;AAEpD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,OAAM;;AAEN,6CAA4C,QAAQ;;AAEpD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,6CAA4C,QAAQ;;AAEpD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,OAAM;;AAEN,6CAA4C,QAAQ;;AAEpD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,6CAA4C,QAAQ;;AAEpD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,MAAK;;AAEL;;AAEA,6CAA4C,QAAQ;;AAEpD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,6CAA4C,QAAQ;;AAEpD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,OAAM;;AAEN,6CAA4C,QAAQ;;AAEpD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,6CAA4C,QAAQ;;AAEpD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,OAAM;;AAEN,6CAA4C,QAAQ;;AAEpD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,6CAA4C,QAAQ;;AAEpD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,gBAAe,QAAQ;;AAEvB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AAC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G;;AAEH;;AAEA,IAAG;;AAEH;;AAEA,IAAG;;AAEH;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,gBAAe,0BAA0B;;AAEzC;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,gBAAe,0BAA0B;;AAEzC;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,KAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,KAAI;;AAEJ;AACA;;AAEA,KAAI;;AAEJ;;AAEA,KAAI;;AAEJ;;AAEA,KAAI;;AAEJ;;AAEA,KAAI;;AAEJ;AACA;AACA;;AAEA,KAAI;;AAEJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;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;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACpJA;AACA;AACA;;AAEA;AACA,gEAA+D;AAC/D;AACA,yBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qCAAoC;AACpC;AACA,uDAAsD;AACtD;AACA;AACA;AACA,MAAK;AACL,6EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,2BAA0B,4BAA4B;AACtD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,oBAAmB,8CAA8C;AACjE;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA,iCAAgC,QAAQ,UAAU;AAClD,iCAAgC,QAAQ,UAAU;AAClD,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,eAAe;AAClC,sBAAqB,gBAAgB;AACrC;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB,OAAO;AACxB;AACA,wBAAuB;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;;;;;;;ACnXA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAgB,mBAAmB;AACnC,8BAA6B,kBAAkB;;AAE/C;AACA;AACA;AACA;AACA,sBAAqB,wBAAwB;AAC7C;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;;;;;;aC5CA,yBAAa,2BAA2E,2DAA2D,KAAK,MAAM,4HAA4H,YAAY,0BAA0B,0BAA0B,gBAAgB,UAAU,UAAU,0CAA0C,8BAAwB,oBAAoB,8CAA8C,YAAY,YAAY,mCAAmC,iBAAiB,gBAAgB,sBAAsB,oBAAoB,0CAA0C,YAAY,WAAW,YAAY,SAAS,GAAG;AACjuB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAa;AACb,cAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU,OAAO;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B,gCAAgC;AAC/D,gCAA+B,8CAA8C;AAC7E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA,EAAC,GAAG,EAAE,GAAG;AACT;AACA,EAAC;;;;;;;ACjQD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA,mCAAkC,OAAO;AACzC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,G;;;;;;AC5BA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAmB,uBAAuB;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;ACvDA;;;;;;;;KAEM;;;4BAEW;AACf,WAAO,IAAI,aAAJ,EAAP,CADe;;;;AAIhB,WANK,aAML,GAAc;yBANT,eAMS;;AACb,OAAI,WAAW,IAAI,gBAAM,YAAN,CAAmB,CAAvB,EAA0B,CAA1B,EAA6B,CAA7B,CAAX,CADS;A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","file":"client.packed.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 97e545b406c0cd44ee7e\n **/","\nimport FPTClient from './FPTClient';\nimport THREE from 'three';\nimport CANNON from 'cannon';\nimport OrbitControls from './THREE.OrbitControls';\nimport TestBall from '../game/testBall/TestBall';\nimport PhysicsDebugView from './view/PhysicsDebugView';\n\nvar client = FPTClient.create();\n\ndocument.body.appendChild(client.view.element);\n\n\n\n// debugging stuff\n\nconsole.debug('dummybuild', 1);\n\nwindow.THREE = THREE;\nwindow.CANNON = CANNON;\nwindow.client = client;\n\nlet orbitControls = new OrbitControls(client.view.camera);\nsetInterval(orbitControls.update.bind(orbitControls), 40);\n\n\nlet lamp = new THREE.HemisphereLight(0xffffff, .5);\nlamp.position.set(0, 10, 0);\nclient.view.scene.add(lamp);\n\nlet ball = TestBall.create(\n\t{\n\t\tposition: {x: .7, y: 200, z: 0}\n\t}\n);\nball.debug = true;\nclient.game.entities.add(ball);\nwindow.ball = ball;\n\nlet physicsDebugView = PhysicsDebugView.create(client.view);\nclient.view.systems.add(physicsDebugView);\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./start.js\n **/","\nimport FPTGame from '../game/FPTGame';\nimport FPTGameView from './view/FPTGameView';\nimport TestLevel1 from '../levels/TestLevel1';\nimport ClientConnection from './ClientConnection';\nimport ClientSession from './ClientSession';\n\nexport default class FPTClient {\n\n\tconstructor() {\n\t\tthis.game = FPTGame.create();\n\t\tthis.game.setLevel(TestLevel1.create());\n\t\tthis.view = FPTGameView.create(this.game);\n\n\t\tthis.connection = ClientConnection.create();\n\t\tthis.session = ClientSession.create(this.connection);\n\t}\n\n\tstatic create() {\n\t\treturn new FPTClient();\n\t}\n\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./FPTClient.js\n **/","\nimport System from './ecs/System';\nimport EntityCollection from './ecs/EntityCollection';\nimport Ticker from './Ticker';\nimport Physics from './physics/Physics';\nimport Level from '../levels/Level';\n\nvar FPTGame = System.createClass({\n\n\tconstructor: function() {\n\t\tthis.entities = EntityCollection.create();\n\n\t\tthis.physics = Physics.create(this);\n\n\t\tthis.systems.add(this.physics);\n\n\t\tthis._ticker = Ticker.create(1000/60, this.tick.bind(this));\n\t},\n\n\tsetLevel: function(level) {\n\t\tthis.level = level;\n\t\tthis.systems.add(level);\n\t\tthis.entities.add(level.entity);\n\t\tthis.level.onLoaded(this.start.bind(this));\n\t},\n\n\tstart: function() {\n\t\tthis.physics.playing = true;\n\t}\n\n});\n\nFPTGame.create = function() {\n\treturn new FPTGame();\n};\n\nexport default FPTGame;\n\n\n\n/** WEBPACK FOOTER **\n ** ../game/FPTGame.js\n **/","\nimport SystemCollection from './SystemCollection';\n\nclass System {\n\t\n\tstatic createClass(props) {\n\t\tfunction Klass() {\n\t\t\tSystem.call(this);\n\t\t\tprops.constructor.apply(this,arguments);\n\t\t};\n\t\tKlass.prototype = props;\n\t\tprops.__proto__ = System.prototype;\n\t\treturn Klass;\n\t}\n\n\tstatic create() {\n\t\treturn new System();\n\t}\n\n\tconstructor() {\n\t\tthis.systems = SystemCollection.create();\n\t}\n\n\ttick(ms) {\n\t\tif (this.entities) {\n\t\t\tthis.entities.forEach(function(entity) {\n\t\t\t\tthis.tickEntity(entity, ms);\n\t\t\t}.bind(this));\n\t\t}\n\t\tthis.tickSubsystems(ms);\n\t}\n\n\ttickEntity(entity, ms) {}\n\n\ttickSubsystems(ms) {\n\t\tthis.systems.forEach(system => system.tick(ms));\n\t}\n\n}\n\nexport default System;\n\n\n\n/** WEBPACK FOOTER **\n ** ../game/ecs/System.js\n **/","\nexport default class SystemCollection {\n\t\n\tstatic create() {\n\t\treturn new SystemCollection();\n\t}\n\n\tconstructor() {\n\t\tthis._systems = [];\n\t}\n\n\tadd(system) {\n\t\tthis._systems.push(system);\n\t}\n\n\tforEach(callback) {\n\t\tthis._systems.forEach(callback);\n\t}\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ../game/ecs/SystemCollection.js\n **/","\nexport default class EntityCollection {\n\t\n\tstatic create() {\n\t\treturn new EntityCollection();\n\t}\n\n\tconstructor() {\n\t\tthis._hash = {};\n\t\tthis._entities = [];\n\t}\n\n\tadd(name, entity) {\n\t\tif (typeof name === 'string') {\n\t\t\tthis._hash[name] = entity;\n\t\t} else {\n\t\t\tentity = name;\n\t\t}\n\t\tthis._entities.push(entity);\n\t}\n\n\tget(name) {\n\t\treturn this._hash[name];\n\t}\n\n\tforEach(callback) {\n\t\tthis._entities.forEach(callback);\n\t}\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ../game/ecs/EntityCollection.js\n **/","\nexport default class Ticker {\n\n\tstatic create(ms, callback) {\n\t\treturn new Ticker(ms, callback);\n\t}\n\n\tconstructor(ms, callback) {\n\t\tthis._time = +(new Date());\n\t\tthis._callback = callback;\n\t\tsetInterval(this._nextTick.bind(this), ms);\n\t}\n\n\t_nextTick() {\n\t\tlet now = +(new Date());\n\t\tlet ms = now - this._time;\n\t\tthis._time = now;\n\t\tthis._callback(ms);\n\t}\n\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ../game/Ticker.js\n **/","\nimport System from '../ecs/System';\nimport CANNON from 'cannon';\nimport FPTGame from '../FPTGame';\n\n\nvar Physics = System.createClass({\n\n\tconstructor: function(fptGame) {\n\n\t\tthis.playing = false;\n\n\t\tthis.entities = fptGame.entities;\n\n\t\tvar world = new CANNON.World();\n\t\tworld.gravity = new CANNON.Vec3(0, -9.8, 0);\n\t\tworld.broadphase = new CANNON.NaiveBroadphase();\n\t\tvar solver = new CANNON.GSSolver();\n\t\tsolver.iterations = 7;\n\t\tworld.defaultContactMaterial.contactEquationRegularizationTime = 0.55;\n\t\tsolver.tolerance = 0.01;\n\t\tworld.solver = solver;\n\n\t\tworld.quatNormalizeFast = true;\n\t\tworld.quatNormalizeSkip = 0;\n\n\t\tworld.defaultContactMaterial.friction = 0.7;\n\t\tworld.defaultContactMaterial.restitution = 0.0;\n\t\tworld.defaultContactMaterial.contactEquationStiffness = 1e9;\n\t\tworld.defaultContactMaterial.contactEquationRegularizationTime = 4;\n\t\tworld.broadphase.useBoundingBoxes = true;\n\t\tworld.allowSleep = false;\n\n\t\tthis.world = world;\n\t},\n\n\ttick: function(ms, entityCollection) {\n\t\tthis.entities.forEach(this._prepareEntity.bind(this));\n\t\tif (this.playing) {\n\t\t\tthis.world.step(ms/1000);\n\t\t}\n\t\tthis.tickSubsystems(ms);\n\t},\n\n\t_prepareEntity: function(entity) {\n\t\tlet pieces = entity.get('pieces');\n\t\tif (pieces) {\n\t\t\tpieces.forEach(function(piece) {\n\t\t\t\tthis._prepareEntity(piece);\n\t\t\t}.bind(this));\n\t\t}\n\t\tlet physics = entity.get('physics');\n\t\tif (physics) {\n\t\t\tif (!physics.ready) {\n\t\t\t\tthis.world.add(physics.cannon);\n\t\t\t\tphysics.constraints.forEach(function(constraint) {\n\t\t\t\t\tconsole.info('adding constraint');\n\t\t\t\t\tthis.world.addConstraint(constraint);\n\t\t\t\t}.bind(this));\n\t\t\t}\n\t\t\tphysics.ready = true;\n\t\t}\n\t}\n\n});\n\nPhysics.create = function(fptGame) {\n\treturn new Physics(fptGame);\n}\n\nexport default Physics;\n\n\n\n/** WEBPACK FOOTER **\n ** ../game/physics/Physics.js\n **/","/*\n * Copyright (c) 2014 cannon.js Authors\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use, copy,\n * modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n!function(e){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define([],e);else{var f;\"undefined\"!=typeof window?f=window:\"undefined\"!=typeof global?f=global:\"undefined\"!=typeof self&&(f=self),f.CANNON=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\nmodule.exports={\n  \"name\": \"cannon\",\n  \"version\": \"0.6.0\",\n  \"description\": \"A lightweight 3D physics engine written in JavaScript.\",\n  \"homepage\": \"https://github.com/schteppe/cannon.js\",\n  \"author\": \"Stefan Hedman <schteppe@gmail.com> (http://steffe.se)\",\n  \"keywords\": [\n    \"cannon.js\",\n    \"cannon\",\n    \"physics\",\n    \"engine\",\n    \"3d\"\n  ],\n  \"main\": \"./build/cannon.js\",\n  \"engines\": {\n    \"node\": \"*\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/schteppe/cannon.js.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/schteppe/cannon.js/issues\"\n  },\n  \"licenses\": [\n    {\n      \"type\": \"MIT\"\n    }\n  ],\n  \"devDependencies\": {\n    \"jshint\": \"latest\",\n    \"uglify-js\": \"latest\",\n    \"nodeunit\": \"^0.9.0\",\n    \"grunt\": \"~0.4.0\",\n    \"grunt-contrib-jshint\": \"~0.1.1\",\n    \"grunt-contrib-nodeunit\": \"^0.4.1\",\n    \"grunt-contrib-concat\": \"~0.1.3\",\n    \"grunt-contrib-uglify\": \"^0.5.1\",\n    \"grunt-browserify\": \"^2.1.4\",\n    \"grunt-contrib-yuidoc\": \"^0.5.2\",\n    \"browserify\": \"*\"\n  },\n  \"dependencies\": {}\n}\n\n},{}],2:[function(_dereq_,module,exports){\n// Export classes\nmodule.exports = {\n    version :                       _dereq_('../package.json').version,\n\n    ArrayCollisionMatrix :          _dereq_('./collision/ArrayCollisionMatrix'),\n    Body :                          _dereq_('./objects/Body'),\n    Box :                           _dereq_('./shapes/Box'),\n    Broadphase :                    _dereq_('./collision/Broadphase'),\n    Constraint :                    _dereq_('./constraints/Constraint'),\n    ContactEquation :               _dereq_('./equations/ContactEquation'),\n    Narrowphase :                   _dereq_('./world/Narrowphase'),\n    ContactMaterial :               _dereq_('./material/ContactMaterial'),\n    ConvexPolyhedron :              _dereq_('./shapes/ConvexPolyhedron'),\n    Cylinder :                      _dereq_('./shapes/Cylinder'),\n    DistanceConstraint :            _dereq_('./constraints/DistanceConstraint'),\n    Equation :                      _dereq_('./equations/Equation'),\n    EventTarget :                   _dereq_('./utils/EventTarget'),\n    FrictionEquation :              _dereq_('./equations/FrictionEquation'),\n    GSSolver :                      _dereq_('./solver/GSSolver'),\n    GridBroadphase :                _dereq_('./collision/GridBroadphase'),\n    Heightfield :                   _dereq_('./shapes/Heightfield'),\n    HingeConstraint :               _dereq_('./constraints/HingeConstraint'),\n    Mat3 :                          _dereq_('./math/Mat3'),\n    Material :                      _dereq_('./material/Material'),\n    NaiveBroadphase :               _dereq_('./collision/NaiveBroadphase'),\n    ObjectCollisionMatrix :         _dereq_('./collision/ObjectCollisionMatrix'),\n    Pool :                          _dereq_('./utils/Pool'),\n    Particle :                      _dereq_('./shapes/Particle'),\n    Plane :                         _dereq_('./shapes/Plane'),\n    PointToPointConstraint :        _dereq_('./constraints/PointToPointConstraint'),\n    Quaternion :                    _dereq_('./math/Quaternion'),\n    Ray :                           _dereq_('./collision/Ray'),\n    RaycastVehicle :                _dereq_('./objects/RaycastVehicle'),\n    RaycastResult :                 _dereq_('./collision/RaycastResult'),\n    RigidVehicle :                  _dereq_('./objects/RigidVehicle'),\n    RotationalEquation :            _dereq_('./equations/RotationalEquation'),\n    RotationalMotorEquation :       _dereq_('./equations/RotationalMotorEquation'),\n    SAPBroadphase :                 _dereq_('./collision/SAPBroadphase'),\n    SPHSystem :                     _dereq_('./objects/SPHSystem'),\n    Shape :                         _dereq_('./shapes/Shape'),\n    Solver :                        _dereq_('./solver/Solver'),\n    Sphere :                        _dereq_('./shapes/Sphere'),\n    SplitSolver :                   _dereq_('./solver/SplitSolver'),\n    Spring :                        _dereq_('./objects/Spring'),\n    Vec3 :                          _dereq_('./math/Vec3'),\n    Vec3Pool :                      _dereq_('./utils/Vec3Pool'),\n    World :                         _dereq_('./world/World'),\n};\n\n},{\"../package.json\":1,\"./collision/ArrayCollisionMatrix\":4,\"./collision/Broadphase\":5,\"./collision/GridBroadphase\":6,\"./collision/NaiveBroadphase\":7,\"./collision/ObjectCollisionMatrix\":8,\"./collision/Ray\":9,\"./collision/RaycastResult\":10,\"./collision/SAPBroadphase\":11,\"./constraints/Constraint\":12,\"./constraints/DistanceConstraint\":13,\"./constraints/HingeConstraint\":14,\"./constraints/PointToPointConstraint\":15,\"./equations/ContactEquation\":16,\"./equations/Equation\":17,\"./equations/FrictionEquation\":18,\"./equations/RotationalEquation\":19,\"./equations/RotationalMotorEquation\":20,\"./material/ContactMaterial\":21,\"./material/Material\":22,\"./math/Mat3\":24,\"./math/Quaternion\":25,\"./math/Vec3\":27,\"./objects/Body\":28,\"./objects/RaycastVehicle\":29,\"./objects/RigidVehicle\":30,\"./objects/SPHSystem\":31,\"./objects/Spring\":32,\"./shapes/Box\":34,\"./shapes/ConvexPolyhedron\":35,\"./shapes/Cylinder\":36,\"./shapes/Heightfield\":37,\"./shapes/Particle\":38,\"./shapes/Plane\":39,\"./shapes/Shape\":40,\"./shapes/Sphere\":41,\"./solver/GSSolver\":42,\"./solver/Solver\":43,\"./solver/SplitSolver\":44,\"./utils/EventTarget\":45,\"./utils/Pool\":46,\"./utils/Vec3Pool\":49,\"./world/Narrowphase\":50,\"./world/World\":51}],3:[function(_dereq_,module,exports){\nvar Vec3 = _dereq_('../math/Vec3');\nvar Utils = _dereq_('../utils/Utils');\n\nmodule.exports = AABB;\n\n/**\n * Axis aligned bounding box class.\n * @class AABB\n * @constructor\n * @param {Object}  [options]\n * @param {Array}   [options.upperBound]\n * @param {Array}   [options.lowerBound]\n */\nfunction AABB(options){\n    options = options || {};\n\n    /**\n     * The lower bound of the bounding box.\n     * @property lowerBound\n     * @type {Array}\n     */\n    this.lowerBound = new Vec3();\n    if(options.lowerBound){\n        this.lowerBound.copy(options.lowerBound);\n    }\n\n    /**\n     * The upper bound of the bounding box.\n     * @property upperBound\n     * @type {Array}\n     */\n    this.upperBound = new Vec3();\n    if(options.upperBound){\n        this.upperBound.copy(options.upperBound);\n    }\n}\n\nvar tmp = new Vec3();\n\n/**\n * Set the AABB bounds from a set of points.\n * @method setFromPoints\n * @param {Array} points An array of Vec3's.\n * @todo\n */\nAABB.prototype.setFromPoints = function(points, position, quaternion, skinSize){\n    var l = this.lowerBound,\n        u = this.upperBound,\n        q = quaternion;\n\n    // Set to the first point\n    l.copy(points[0]);\n    if(q){\n        q.vmult(l, l);\n    }\n    u.copy(l);\n\n    for(var i = 1; i<points.length; i++){\n        var p = points[i];\n\n        if(q){\n            q.vmult(p, tmp);\n            p = tmp;\n        }\n\n        if(p.x > u.x){ u.x = p.x; }\n        if(p.x < l.x){ l.x = p.x; }\n        if(p.y > u.y){ u.y = p.y; }\n        if(p.y < l.y){ l.y = p.y; }\n        if(p.z > u.z){ u.z = p.z; }\n        if(p.z < l.z){ l.z = p.z; }\n    }\n\n    // Add offset\n    if (position) {\n        position.vadd(l, l);\n        position.vadd(u, u);\n    }\n\n    if(skinSize){\n        l.x -= skinSize;\n        l.y -= skinSize;\n        l.z -= skinSize;\n        u.x += skinSize;\n        u.y += skinSize;\n        u.z += skinSize;\n    }\n};\n\n/**\n * Copy bounds from an AABB to this AABB\n * @method copy\n * @param  {AABB} aabb\n */\nAABB.prototype.copy = function(aabb){\n    // vectors copy is the other direction... bad!\n    this.lowerBound.copy(aabb.lowerBound);\n    this.upperBound.copy(aabb.upperBound);\n};\n\n/**\n * Extend this AABB so that it covers the given AABB too.\n * @method extend\n * @param  {AABB} aabb\n * @todo\n */\nAABB.prototype.extend = function(aabb){\n    // Extend lower bound\n    var l = aabb.lowerBound.x;\n    if(this.lowerBound.x > l){\n        this.lowerBound.x = l;\n    }\n\n    // Upper\n    var u = aabb.upperBound.x;\n    if(this.upperBound.x < u){\n        this.upperBound.x = u;\n    }\n\n    // Extend lower bound\n    var l = aabb.lowerBound.y;\n    if(this.lowerBound.y > l){\n        this.lowerBound.y = l;\n    }\n\n    // Upper\n    var u = aabb.upperBound.y;\n    if(this.upperBound.y < u){\n        this.upperBound.y = u;\n    }\n};\n\n/**\n * Returns true if the given AABB overlaps this AABB.\n * @method overlaps\n * @param  {AABB} aabb\n * @return {Boolean}\n */\nAABB.prototype.overlaps = function(aabb){\n    var l1 = this.lowerBound,\n        u1 = this.upperBound,\n        l2 = aabb.lowerBound,\n        u2 = aabb.upperBound;\n\n    //      l2        u2\n    //      |---------|\n    // |--------|\n    // l1       u1\n\n    return ((l2.x <= u1.x && u1.x <= u2.x) || (l1.x <= u2.x && u2.x <= u1.x)) &&\n           ((l2.y <= u1.y && u1.y <= u2.y) || (l1.y <= u2.y && u2.y <= u1.y));\n};\n\n},{\"../math/Vec3\":27,\"../utils/Utils\":48}],4:[function(_dereq_,module,exports){\nmodule.exports = ArrayCollisionMatrix;\n\n/**\n * Collision \"matrix\". It's actually a triangular-shaped array of whether two bodies are touching this step, for reference next step\n * @class ArrayCollisionMatrix\n * @constructor\n */\nfunction ArrayCollisionMatrix() {\n\n    /**\n     * The matrix storage\n     * @property matrix\n     * @type {Array}\n     */\n\tthis.matrix = [];\n}\n\n/**\n * Get an element\n * @method get\n * @param  {Number} i\n * @param  {Number} j\n * @return {Number}\n */\nArrayCollisionMatrix.prototype.get = function(i, j) {\n\ti = i.index;\n\tj = j.index;\n    if (j > i) {\n        var temp = j;\n        j = i;\n        i = temp;\n    }\n\treturn this.matrix[(i*(i + 1)>>1) + j-1];\n};\n\n/**\n * Set an element\n * @method set\n * @param {Number} i\n * @param {Number} j\n * @param {Number} value\n */\nArrayCollisionMatrix.prototype.set = function(i, j, value) {\n\ti = i.index;\n\tj = j.index;\n    if (j > i) {\n        var temp = j;\n        j = i;\n        i = temp;\n    }\n\tthis.matrix[(i*(i + 1)>>1) + j-1] = value ? 1 : 0;\n};\n\n/**\n * Sets all elements to zero\n * @method reset\n */\nArrayCollisionMatrix.prototype.reset = function() {\n\tfor (var i=0, l=this.matrix.length; i!==l; i++) {\n\t\tthis.matrix[i]=0;\n\t}\n};\n\n/**\n * Sets the max number of objects\n * @method setNumObjects\n * @param {Number} n\n */\nArrayCollisionMatrix.prototype.setNumObjects = function(n) {\n\tthis.matrix.length = n*(n-1)>>1;\n};\n\n},{}],5:[function(_dereq_,module,exports){\nvar Body = _dereq_('../objects/Body');\nvar Vec3 = _dereq_('../math/Vec3');\nvar Quaternion = _dereq_('../math/Quaternion');\nvar Shape = _dereq_('../shapes/Shape');\nvar Plane = _dereq_('../shapes/Plane');\n\nmodule.exports = Broadphase;\n\n/**\n * Base class for broadphase implementations\n * @class Broadphase\n * @constructor\n * @author schteppe\n */\nfunction Broadphase(){\n    /**\n    * The world to search for collisions in.\n    * @property world\n    * @type {World}\n    */\n    this.world = null;\n\n    /**\n     * If set to true, the broadphase uses bounding boxes for intersection test, else it uses bounding spheres.\n     * @property useBoundingBoxes\n     * @type {Boolean}\n     */\n    this.useBoundingBoxes = false;\n\n    this.dirty = true;\n}\n\n/**\n * Get the collision pairs from the world\n * @method collisionPairs\n * @param {World} world The world to search in\n * @param Array p1 Empty array to be filled with body objects\n * @param Array p2 Empty array to be filled with body objects\n * @return array An array with two subarrays of body indices\n */\nBroadphase.prototype.collisionPairs = function(world,p1,p2){\n    throw new Error(\"collisionPairs not implemented for this BroadPhase class!\");\n};\n\n/**\n * Check if a body pair needs to be intersection tested at all.\n * @method needBroadphaseCollision\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @return {bool}\n */\nvar Broadphase_needBroadphaseCollision_STATIC_OR_KINEMATIC = Body.STATIC | Body.KINEMATIC;\nBroadphase.prototype.needBroadphaseCollision = function(bodyA,bodyB){\n\n    // Check collision filter masks\n    if( (bodyA.collisionFilterGroup & bodyB.collisionFilterMask)===0 || (bodyB.collisionFilterGroup & bodyA.collisionFilterMask)===0){\n        return false;\n    }\n\n    // Check types\n    if(((bodyA.type & Broadphase_needBroadphaseCollision_STATIC_OR_KINEMATIC)!==0 || bodyA.sleepState === Body.SLEEPING) &&\n       ((bodyB.type & Broadphase_needBroadphaseCollision_STATIC_OR_KINEMATIC)!==0 || bodyB.sleepState === Body.SLEEPING)) {\n        // Both bodies are static, kinematic or sleeping. Skip.\n        return false;\n    }\n\n    // Two particles don't collide\n    /*\n    if(!bodyA.shape && !bodyB.shape){\n        return false;\n    }\n    */\n\n    // Two planes don't collide\n    /*\n    if(bodyA.shape instanceof Plane && bodyB.shape instanceof Plane){\n        return false;\n    }\n    */\n\n    return true;\n};\n\n/**\n * Check if the bounding volumes of two bodies intersect.\n * @method intersectionTest\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {array} pairs1\n * @param {array} pairs2\n  */\nBroadphase.prototype.intersectionTest = function(bi, bj, pairs1, pairs2){\n    if(this.useBoundingBoxes){\n        this.doBoundingBoxBroadphase(bi,bj,pairs1,pairs2);\n    } else {\n        this.doBoundingSphereBroadphase(bi,bj,pairs1,pairs2);\n    }\n};\n\n/**\n * Check if the bounding spheres of two bodies are intersecting.\n * @method doBoundingSphereBroadphase\n * @param {Body} bi\n * @param {Body} bj\n * @param {Array} pairs1 bi is appended to this array if intersection\n * @param {Array} pairs2 bj is appended to this array if intersection\n */\nvar Broadphase_collisionPairs_r = new Vec3(), // Temp objects\n    Broadphase_collisionPairs_normal =  new Vec3(),\n    Broadphase_collisionPairs_quat =  new Quaternion(),\n    Broadphase_collisionPairs_relpos  =  new Vec3();\nBroadphase.prototype.doBoundingSphereBroadphase = function(bi,bj,pairs1,pairs2){\n    var r = Broadphase_collisionPairs_r;\n    bj.position.vsub(bi.position,r);\n    var boundingRadiusSum2 = Math.pow(bi.boundingRadius + bj.boundingRadius, 2);\n    var norm2 = r.norm2();\n    if(norm2 < boundingRadiusSum2){\n        pairs1.push(bi);\n        pairs2.push(bj);\n    }\n};\n\n/**\n * Check if the bounding boxes of two bodies are intersecting.\n * @method doBoundingBoxBroadphase\n * @param Body bi\n * @param Body bj\n * @param {Array} pairs1\n * @param {Array} pairs2\n */\nBroadphase.prototype.doBoundingBoxBroadphase = function(bi,bj,pairs1,pairs2){\n    if(bi.aabbNeedsUpdate){\n        bi.computeAABB();\n    }\n    if(bj.aabbNeedsUpdate){\n        bj.computeAABB();\n    }\n\n    // Check AABB / AABB\n    if(bi.aabb.overlaps(bj.aabb)){\n        pairs1.push(bi);\n        pairs2.push(bj);\n    }\n};\n\n/**\n * Removes duplicate pairs from the pair arrays.\n * @method makePairsUnique\n * @param {Array} pairs1\n * @param {Array} pairs2\n */\nvar Broadphase_makePairsUnique_temp = { keys:[] },\n    Broadphase_makePairsUnique_p1 = [],\n    Broadphase_makePairsUnique_p2 = [];\nBroadphase.prototype.makePairsUnique = function(pairs1,pairs2){\n    var t = Broadphase_makePairsUnique_temp,\n        p1 = Broadphase_makePairsUnique_p1,\n        p2 = Broadphase_makePairsUnique_p2,\n        N = pairs1.length;\n\n    for(var i=0; i!==N; i++){\n        p1[i] = pairs1[i];\n        p2[i] = pairs2[i];\n    }\n\n    pairs1.length = 0;\n    pairs2.length = 0;\n\n    for(var i=0; i!==N; i++){\n        var id1 = p1[i].id,\n            id2 = p2[i].id;\n        var key = id1 < id2 ? id1+\",\"+id2 :  id2+\",\"+id1;\n        t[key] = i;\n        t.keys.push(key);\n    }\n\n    for(var i=0; i!==t.keys.length; i++){\n        var key = t.keys.pop(),\n            pairIndex = t[key];\n        pairs1.push(p1[pairIndex]);\n        pairs2.push(p2[pairIndex]);\n        delete t[key];\n    }\n};\n\n/**\n * To be implemented by subcasses\n * @method setWorld\n * @param {World} world\n */\nBroadphase.prototype.setWorld = function(world){\n};\n\nvar bsc_dist = new Vec3();\nBroadphase.boundingSphereCheck = function(bi,bj){\n    var dist = bsc_dist;\n    bi.position.vsub(bj.position,dist);\n    return Math.pow(bi.shape.boundingSphereRadius + bj.shape.boundingSphereRadius,2) > dist.norm2();\n};\n\n/**\n * Returns all the bodies within the AABB.\n * @method aabbQuery\n * @param  {World} world\n * @param  {AABB} aabb\n * @return {array}\n */\nBroadphase.prototype.aabbQuery = function(world, aabb){\n    console.warn('.aabbQuery is not implemented in this Broadphase subclass.');\n    return [];\n};\n},{\"../math/Quaternion\":25,\"../math/Vec3\":27,\"../objects/Body\":28,\"../shapes/Plane\":39,\"../shapes/Shape\":40}],6:[function(_dereq_,module,exports){\nmodule.exports = GridBroadphase;\n\nvar Broadphase = _dereq_('./Broadphase');\nvar Vec3 = _dereq_('../math/Vec3');\nvar Shape = _dereq_('../shapes/Shape');\n\n/**\n * Axis aligned uniform grid broadphase.\n * @class GridBroadphase\n * @constructor\n * @extends Broadphase\n * @todo Needs support for more than just planes and spheres.\n * @param {Vec3} aabbMin\n * @param {Vec3} aabbMax\n * @param {Number} nx Number of boxes along x\n * @param {Number} ny Number of boxes along y\n * @param {Number} nz Number of boxes along z\n */\nfunction GridBroadphase(aabbMin,aabbMax,nx,ny,nz){\n    Broadphase.apply(this);\n    this.nx = nx || 10;\n    this.ny = ny || 10;\n    this.nz = nz || 10;\n    this.aabbMin = aabbMin || new Vec3(100,100,100);\n    this.aabbMax = aabbMax || new Vec3(-100,-100,-100);\n\tvar nbins = this.nx * this.ny * this.nz;\n\tif (nbins <= 0) {\n\t\tthrow \"GridBroadphase: Each dimension's n must be >0\";\n\t}\n    this.bins = [];\n\tthis.binLengths = []; //Rather than continually resizing arrays (thrashing the memory), just record length and allow them to grow\n\tthis.bins.length = nbins;\n\tthis.binLengths.length = nbins;\n\tfor (var i=0;i<nbins;i++) {\n\t\tthis.bins[i]=[];\n\t\tthis.binLengths[i]=0;\n\t}\n}\nGridBroadphase.prototype = new Broadphase();\nGridBroadphase.prototype.constructor = GridBroadphase;\n\n/**\n * Get all the collision pairs in the physics world\n * @method collisionPairs\n * @param {World} world\n * @param {Array} pairs1\n * @param {Array} pairs2\n */\nvar GridBroadphase_collisionPairs_d = new Vec3();\nvar GridBroadphase_collisionPairs_binPos = new Vec3();\nGridBroadphase.prototype.collisionPairs = function(world,pairs1,pairs2){\n    var N = world.numObjects(),\n        bodies = world.bodies;\n\n    var max = this.aabbMax,\n        min = this.aabbMin,\n        nx = this.nx,\n        ny = this.ny,\n        nz = this.nz;\n\n\tvar xstep = ny*nz;\n\tvar ystep = nz;\n\tvar zstep = 1;\n\n    var xmax = max.x,\n        ymax = max.y,\n        zmax = max.z,\n        xmin = min.x,\n        ymin = min.y,\n        zmin = min.z;\n\n    var xmult = nx / (xmax-xmin),\n        ymult = ny / (ymax-ymin),\n        zmult = nz / (zmax-zmin);\n\n    var binsizeX = (xmax - xmin) / nx,\n        binsizeY = (ymax - ymin) / ny,\n        binsizeZ = (zmax - zmin) / nz;\n\n\tvar binRadius = Math.sqrt(binsizeX*binsizeX + binsizeY*binsizeY + binsizeZ*binsizeZ) * 0.5;\n\n    var types = Shape.types;\n    var SPHERE =            types.SPHERE,\n        PLANE =             types.PLANE,\n        BOX =               types.BOX,\n        COMPOUND =          types.COMPOUND,\n        CONVEXPOLYHEDRON =  types.CONVEXPOLYHEDRON;\n\n    var bins=this.bins,\n\t\tbinLengths=this.binLengths,\n        Nbins=this.bins.length;\n\n    // Reset bins\n    for(var i=0; i!==Nbins; i++){\n        binLengths[i] = 0;\n    }\n\n    var ceil = Math.ceil;\n\tvar min = Math.min;\n\tvar max = Math.max;\n\n\tfunction addBoxToBins(x0,y0,z0,x1,y1,z1,bi) {\n\t\tvar xoff0 = ((x0 - xmin) * xmult)|0,\n\t\t\tyoff0 = ((y0 - ymin) * ymult)|0,\n\t\t\tzoff0 = ((z0 - zmin) * zmult)|0,\n\t\t\txoff1 = ceil((x1 - xmin) * xmult),\n\t\t\tyoff1 = ceil((y1 - ymin) * ymult),\n\t\t\tzoff1 = ceil((z1 - zmin) * zmult);\n\n\t\tif (xoff0 < 0) { xoff0 = 0; } else if (xoff0 >= nx) { xoff0 = nx - 1; }\n\t\tif (yoff0 < 0) { yoff0 = 0; } else if (yoff0 >= ny) { yoff0 = ny - 1; }\n\t\tif (zoff0 < 0) { zoff0 = 0; } else if (zoff0 >= nz) { zoff0 = nz - 1; }\n\t\tif (xoff1 < 0) { xoff1 = 0; } else if (xoff1 >= nx) { xoff1 = nx - 1; }\n\t\tif (yoff1 < 0) { yoff1 = 0; } else if (yoff1 >= ny) { yoff1 = ny - 1; }\n\t\tif (zoff1 < 0) { zoff1 = 0; } else if (zoff1 >= nz) { zoff1 = nz - 1; }\n\n\t\txoff0 *= xstep;\n\t\tyoff0 *= ystep;\n\t\tzoff0 *= zstep;\n\t\txoff1 *= xstep;\n\t\tyoff1 *= ystep;\n\t\tzoff1 *= zstep;\n\n\t\tfor (var xoff = xoff0; xoff <= xoff1; xoff += xstep) {\n\t\t\tfor (var yoff = yoff0; yoff <= yoff1; yoff += ystep) {\n\t\t\t\tfor (var zoff = zoff0; zoff <= zoff1; zoff += zstep) {\n\t\t\t\t\tvar idx = xoff+yoff+zoff;\n\t\t\t\t\tbins[idx][binLengths[idx]++] = bi;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n    // Put all bodies into the bins\n    for(var i=0; i!==N; i++){\n        var bi = bodies[i];\n        var si = bi.shape;\n\n        switch(si.type){\n        case SPHERE:\n            // Put in bin\n            // check if overlap with other bins\n            var x = bi.position.x,\n                y = bi.position.y,\n                z = bi.position.z;\n            var r = si.radius;\n\n\t\t\taddBoxToBins(x-r, y-r, z-r, x+r, y+r, z+r, bi);\n            break;\n\n        case PLANE:\n            if(si.worldNormalNeedsUpdate){\n                si.computeWorldNormal(bi.quaternion);\n            }\n            var planeNormal = si.worldNormal;\n\n\t\t\t//Relative position from origin of plane object to the first bin\n\t\t\t//Incremented as we iterate through the bins\n\t\t\tvar xreset = xmin + binsizeX*0.5 - bi.position.x,\n\t\t\t\tyreset = ymin + binsizeY*0.5 - bi.position.y,\n\t\t\t\tzreset = zmin + binsizeZ*0.5 - bi.position.z;\n\n            var d = GridBroadphase_collisionPairs_d;\n\t\t\td.set(xreset, yreset, zreset);\n\n\t\t\tfor (var xi = 0, xoff = 0; xi !== nx; xi++, xoff += xstep, d.y = yreset, d.x += binsizeX) {\n\t\t\t\tfor (var yi = 0, yoff = 0; yi !== ny; yi++, yoff += ystep, d.z = zreset, d.y += binsizeY) {\n\t\t\t\t\tfor (var zi = 0, zoff = 0; zi !== nz; zi++, zoff += zstep, d.z += binsizeZ) {\n\t\t\t\t\t\tif (d.dot(planeNormal) < binRadius) {\n\t\t\t\t\t\t\tvar idx = xoff + yoff + zoff;\n\t\t\t\t\t\t\tbins[idx][binLengths[idx]++] = bi;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        default:\n\t\t\tif (bi.aabbNeedsUpdate) {\n\t\t\t\tbi.computeAABB();\n\t\t\t}\n\n\t\t\taddBoxToBins(\n\t\t\t\tbi.aabb.lowerBound.x,\n\t\t\t\tbi.aabb.lowerBound.y,\n\t\t\t\tbi.aabb.lowerBound.z,\n\t\t\t\tbi.aabb.upperBound.x,\n\t\t\t\tbi.aabb.upperBound.y,\n\t\t\t\tbi.aabb.upperBound.z,\n\t\t\t\tbi);\n            break;\n        }\n    }\n\n    // Check each bin\n    for(var i=0; i!==Nbins; i++){\n\t\tvar binLength = binLengths[i];\n\t\t//Skip bins with no potential collisions\n\t\tif (binLength > 1) {\n\t\t\tvar bin = bins[i];\n\n\t\t\t// Do N^2 broadphase inside\n\t\t\tfor(var xi=0; xi!==binLength; xi++){\n\t\t\t\tvar bi = bin[xi];\n\t\t\t\tfor(var yi=0; yi!==xi; yi++){\n\t\t\t\t\tvar bj = bin[yi];\n\t\t\t\t\tif(this.needBroadphaseCollision(bi,bj)){\n\t\t\t\t\t\tthis.intersectionTest(bi,bj,pairs1,pairs2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    }\n\n//\tfor (var zi = 0, zoff=0; zi < nz; zi++, zoff+= zstep) {\n//\t\tconsole.log(\"layer \"+zi);\n//\t\tfor (var yi = 0, yoff=0; yi < ny; yi++, yoff += ystep) {\n//\t\t\tvar row = '';\n//\t\t\tfor (var xi = 0, xoff=0; xi < nx; xi++, xoff += xstep) {\n//\t\t\t\tvar idx = xoff + yoff + zoff;\n//\t\t\t\trow += ' ' + binLengths[idx];\n//\t\t\t}\n//\t\t\tconsole.log(row);\n//\t\t}\n//\t}\n\n    this.makePairsUnique(pairs1,pairs2);\n};\n\n},{\"../math/Vec3\":27,\"../shapes/Shape\":40,\"./Broadphase\":5}],7:[function(_dereq_,module,exports){\nmodule.exports = NaiveBroadphase;\n\nvar Broadphase = _dereq_('./Broadphase');\nvar AABB = _dereq_('./AABB');\n\n/**\n * Naive broadphase implementation, used in lack of better ones.\n * @class NaiveBroadphase\n * @constructor\n * @description The naive broadphase looks at all possible pairs without restriction, therefore it has complexity N^2 (which is bad)\n * @extends Broadphase\n */\nfunction NaiveBroadphase(){\n    Broadphase.apply(this);\n}\nNaiveBroadphase.prototype = new Broadphase();\nNaiveBroadphase.prototype.constructor = NaiveBroadphase;\n\n/**\n * Get all the collision pairs in the physics world\n * @method collisionPairs\n * @param {World} world\n * @param {Array} pairs1\n * @param {Array} pairs2\n */\nNaiveBroadphase.prototype.collisionPairs = function(world,pairs1,pairs2){\n    var bodies = world.bodies,\n        n = bodies.length,\n        i,j,bi,bj;\n\n    // Naive N^2 ftw!\n    for(i=0; i!==n; i++){\n        for(j=0; j!==i; j++){\n\n            bi = bodies[i];\n            bj = bodies[j];\n\n            if(!this.needBroadphaseCollision(bi,bj)){\n                continue;\n            }\n\n            this.intersectionTest(bi,bj,pairs1,pairs2);\n        }\n    }\n};\n\nvar tmpAABB = new AABB();\n\n/**\n * Returns all the bodies within an AABB.\n * @method aabbQuery\n * @param  {World} world\n * @param  {AABB} aabb\n * @param {array} result An array to store resulting bodies in.\n * @return {array}\n */\nNaiveBroadphase.prototype.aabbQuery = function(world, aabb, result){\n    result = result || [];\n\n    // Naive loop\n    for(var i = 0; i < world.bodies.length; i++){\n        var b = world.bodies[i];\n\n        // Ugly hack until RigidBody gets aabb\n        if(b.aabb.overlaps(aabb)){\n            result.push(b);\n        }\n    }\n\n    return result;\n};\n},{\"./AABB\":3,\"./Broadphase\":5}],8:[function(_dereq_,module,exports){\nmodule.exports = ObjectCollisionMatrix;\n\n/**\n * Records what objects are colliding with each other\n * @class ObjectCollisionMatrix\n * @constructor\n */\nfunction ObjectCollisionMatrix() {\n\n    /**\n     * The matrix storage\n     * @property matrix\n     * @type {Object}\n     */\n\tthis.matrix = {};\n}\n\n/**\n * @method get\n * @param  {Number} i\n * @param  {Number} j\n * @return {Number}\n */\nObjectCollisionMatrix.prototype.get = function(i, j) {\n\ti = i.id;\n\tj = j.id;\n    if (j > i) {\n        var temp = j;\n        j = i;\n        i = temp;\n    }\n\treturn i+'-'+j in this.matrix;\n};\n\n/**\n * @method set\n * @param  {Number} i\n * @param  {Number} j\n * @param {Number} value\n */\nObjectCollisionMatrix.prototype.set = function(i, j, value) {\n\ti = i.id;\n\tj = j.id;\n    if (j > i) {\n        var temp = j;\n        j = i;\n        i = temp;\n\t}\n\tif (value) {\n\t\tthis.matrix[i+'-'+j] = true;\n\t}\n\telse {\n\t\tdelete this.matrix[i+'-'+j];\n\t}\n};\n\n/**\n * Empty the matrix\n * @method reset\n */\nObjectCollisionMatrix.prototype.reset = function() {\n\tthis.matrix = {};\n};\n\n/**\n * Set max number of objects\n * @method setNumObjects\n * @param {Number} n\n */\nObjectCollisionMatrix.prototype.setNumObjects = function(n) {\n};\n\n},{}],9:[function(_dereq_,module,exports){\nmodule.exports = Ray;\n\nvar Vec3 = _dereq_('../math/Vec3');\nvar Quaternion = _dereq_('../math/Quaternion');\nvar Transform = _dereq_('../math/Transform');\nvar ConvexPolyhedron = _dereq_('../shapes/ConvexPolyhedron');\nvar Box = _dereq_('../shapes/Box');\nvar RaycastResult = _dereq_('../collision/RaycastResult');\nvar Shape = _dereq_('../shapes/Shape');\nvar AABB = _dereq_('../collision/AABB');\n\n/**\n * A line in 3D space that intersects bodies and return points.\n * @class Ray\n * @constructor\n * @param {Vec3} from\n * @param {Vec3} to\n */\nfunction Ray(from, to){\n    /**\n     * @property {Vec3} from\n     */\n    this.from = from ? from.clone() : new Vec3();\n\n    /**\n     * @property {Vec3} to\n     */\n    this.to = to ? to.clone() : new Vec3();\n\n    this._direction = new Vec3();\n\n    /**\n     * The precision of the ray. Used when checking parallelity etc.\n     * @property {Number} precision\n     */\n    this.precision = 0.0001;\n}\nRay.prototype.constructor = Ray;\n\nvar v1 = new Vec3(),\n    v2 = new Vec3();\n\n/*\n * As per \"Barycentric Technique\" as named here http://www.blackpawn.com/texts/pointinpoly/default.html But without the division\n */\nfunction pointInTriangle(p, a, b, c) {\n    c.vsub(a,v0);\n    b.vsub(a,v1);\n    p.vsub(a,v2);\n\n    var dot00 = v0.dot( v0 );\n    var dot01 = v0.dot( v1 );\n    var dot02 = v0.dot( v2 );\n    var dot11 = v1.dot( v1 );\n    var dot12 = v1.dot( v2 );\n\n    var u,v;\n\n    return  ( (u = dot11 * dot02 - dot01 * dot12) >= 0 ) &&\n            ( (v = dot00 * dot12 - dot01 * dot02) >= 0 ) &&\n            ( u + v < ( dot00 * dot11 - dot01 * dot01 ) );\n}\n\n/**\n * Shoot a ray at a body, get back information about the hit.\n * @method intersectBody\n * @param {Body} body\n * @return {Array} An array of results. The result objects has properties: distance (float), point (Vec3) and body (Body).\n */\nRay.prototype.intersectBody = function (body, result, direction) {\n    if(!direction){\n        this._updateDirection();\n        direction = this._direction;\n    }\n\n    var xi = new Vec3();\n    var qi = new Quaternion();\n    for (var i = 0; i < body.shapes.length; i++) {\n\n        body.quaternion.mult(body.shapeOrientations[i], qi);\n        body.quaternion.vmult(body.shapeOffsets[i], xi);\n        xi.vadd(body.position, xi);\n\n        return this.intersectShape(\n            body.shapes[i],\n            qi,\n            xi,\n            body,\n            direction,\n            result\n        );\n    }\n};\n\n/**\n * @method intersectBodies\n * @param {Array} bodies An array of Body objects.\n * @return {Array} See intersectBody\n */\nRay.prototype.intersectBodies = function (bodies, result) {\n    this._updateDirection();\n    var direction = this._direction;\n\n    if(result instanceof RaycastResult){\n        result.reset();\n    }\n\n    for ( var i = 0, l = bodies.length; i < l; i ++ ) {\n        this.intersectBody(bodies[i], result, direction);\n    }\n};\n\nRay.prototype._updateDirection = function(){\n    this.to.vsub(this.from, this._direction);\n    this._direction.normalize();\n};\n\n/**\n * @method intersectShape\n * @param {Shape} shape\n * @param {Quaternion} quat\n * @param {Vec3} position\n * @param {Body} body\n * @return {Array} See intersectBody()\n */\nRay.prototype.intersectShape = function(shape, quat, position, body, direction, result){\n    var from = this.from;\n\n    // Checking boundingSphere\n    var distance = distanceFromIntersection(from, direction, position);\n    if ( distance > shape.boundingSphereRadius ) {\n        return result;\n    }\n\n    this[shape.type](shape, quat, position, body, direction, result);\n\n    return result;\n};\n\nvar vector = new Vec3();\nvar normal = new Vec3();\nvar intersectPoint = new Vec3();\n\nvar a = new Vec3();\nvar b = new Vec3();\nvar c = new Vec3();\nvar d = new Vec3();\n\nvar tmpRaycastResult = new RaycastResult();\n\n\nRay.prototype.intersectBox = function(shape, quat, position, body, direction, result){\n    return this.intersectConvex(shape.convexPolyhedronRepresentation, quat, position, body, direction, result);\n};\nRay.prototype[Shape.types.BOX] = Ray.prototype.intersectBox;\n\n\nRay.prototype.intersectPlane = function(shape, quat, position, body, direction, result){\n    var from = this.from;\n    var to = this.to;\n\n    // Get plane normal\n    var worldNormal = new Vec3(0, 0, 1);\n    quat.vmult(worldNormal, worldNormal);\n\n    var len = new Vec3();\n    from.vsub(position, len);\n    var planeToFrom = len.dot(worldNormal);\n    to.vsub(position, len);\n    var planeToTo = len.dot(worldNormal);\n\n    if(planeToFrom * planeToTo > 0){\n        // \"from\" and \"to\" are on the same side of the plane... bail out\n        return result;\n    }\n\n    if(from.distanceTo(to) < planeToFrom){\n        return result;\n    }\n\n    var n_dot_dir = worldNormal.dot(direction);\n\n    if (Math.abs(n_dot_dir) < this.precision) {\n        // No intersection\n        return result;\n    }\n\n    var planePointToFrom = new Vec3();\n    var dir_scaled_with_t = new Vec3();\n    var hitPointWorld = new Vec3();\n\n    from.vsub(position, planePointToFrom);\n    var t = -worldNormal.dot(planePointToFrom) / n_dot_dir;\n    direction.scale(t, dir_scaled_with_t);\n    from.vadd(dir_scaled_with_t, hitPointWorld);\n\n    if(this.reportIntersection(worldNormal, hitPointWorld, shape, body, result)){\n        return result;\n    }\n\n    return result;\n};\nRay.prototype[Shape.types.PLANE] = Ray.prototype.intersectPlane;\n\nRay.prototype.getAABB = function(result){\n    var to = this.to;\n    var from = this.from;\n    result.lowerBound.x = Math.min(to.x, from.x);\n    result.lowerBound.y = Math.min(to.y, from.y);\n    result.upperBound.x = Math.max(to.x, from.x);\n    result.upperBound.y = Math.max(to.y, from.y);\n};\n\nvar intersectConvexOptions = {\n    faceList: [0]\n};\nRay.prototype.intersectHeightfield = function(shape, quat, position, body, direction, result){\n    var data = shape.data,\n        w = shape.elementSize,\n        worldPillarOffset = new Vec3();\n\n    // Convert the ray to local heightfield coordinates\n    var localRay = new Ray(this.from, this.to);\n    Transform.pointToLocalFrame(position, quat, localRay.from, localRay.from);\n    Transform.pointToLocalFrame(position, quat, localRay.to, localRay.to);\n\n    // Get the index of the data points to test against\n    var index = [];\n    var iMinX = null;\n    var iMinY = null;\n    var iMaxX = null;\n    var iMaxY = null;\n\n    var inside = shape.getIndexOfPosition(localRay.from.x, localRay.from.y, index, false);\n    if(inside){\n        iMinX = index[0];\n        iMinY = index[1];\n        iMaxX = index[0];\n        iMaxY = index[1];\n    }\n    inside = shape.getIndexOfPosition(localRay.to.x, localRay.to.y, index, false);\n    if(inside){\n        if (iMinX === null || index[0] < iMinX) { iMinX = index[0]; }\n        if (iMaxX === null || index[0] > iMaxX) { iMaxX = index[0]; }\n        if (iMinY === null || index[1] < iMinY) { iMinY = index[1]; }\n        if (iMaxY === null || index[1] > iMaxY) { iMaxY = index[1]; }\n    }\n\n    if(iMinX === null){\n        return result;\n    }\n\n    var minMax = [];\n    shape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);\n    var min = minMax[0];\n    var max = minMax[1];\n\n    // // Bail out if the ray can't touch the bounding box\n    // // TODO\n    // var aabb = new AABB();\n    // this.getAABB(aabb);\n    // if(aabb.intersects()){\n    //     return;\n    // }\n\n    for(var i = iMinX; i <= iMaxX; i++){\n        for(var j = iMinY; j <= iMaxY; j++){\n\n            // Lower triangle\n            shape.getConvexTrianglePillar(i, j, false);\n            Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset);\n            this.intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, direction, result, intersectConvexOptions);\n\n            // Upper triangle\n            shape.getConvexTrianglePillar(i, j, true);\n            Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset);\n            this.intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, direction, result, intersectConvexOptions);\n        }\n    }\n\n    return result;\n};\nRay.prototype[Shape.types.HEIGHTFIELD] = Ray.prototype.intersectHeightfield;\n\n\nRay.prototype.intersectSphere = function(shape, quat, position, body, direction, result){\n    var from = this.from,\n        to = this.to,\n        r = shape.radius;\n\n    var a = Math.pow(to.x - from.x, 2) + Math.pow(to.y - from.y, 2) + Math.pow(to.z - from.z, 2);\n    var b = 2 * ((to.x - from.x) * (from.x - position.x) + (to.y - from.y) * (from.y - position.y) + (to.z - from.z) * (from.z - position.z));\n    var c = Math.pow(from.x - position.x, 2) + Math.pow(from.y - position.y, 2) + Math.pow(from.z - position.z, 2) - Math.pow(r, 2);\n\n    var delta = Math.pow(b, 2) - 4 * a * c;\n\n    if(delta < 0){\n        // No intersection\n        return result;\n\n    } else if(delta === 0){\n        // single intersection point\n        var intersectionPoint = new Vec3();\n        from.lerp(to, delta, intersectionPoint);\n\n        var normal = new Vec3();\n        intersectionPoint.vsub(position, normal);\n        normal.normalize();\n\n        if(this.reportIntersection(normal, intersectionPoint, shape, body, result)){\n            return result;\n        }\n    } else {\n        var d1 = (- b - Math.sqrt(delta)) / (2 * a);\n        var d2 = (- b + Math.sqrt(delta)) / (2 * a);\n\n        var intersectionPoint = new Vec3();\n        from.lerp(to, d1, intersectionPoint);\n        var normal = new Vec3();\n        intersectionPoint.vsub(position, normal);\n        normal.normalize();\n        if(this.reportIntersection(normal, intersectionPoint, shape, body, result)){\n            return result;\n        }\n\n        from.lerp(to, d2, intersectionPoint);\n        var normal = new Vec3();\n        intersectionPoint.vsub(position, normal);\n        normal.normalize();\n        if(this.reportIntersection(normal, intersectionPoint, shape, body, result)){\n            return result;\n        }\n    }\n\n    return result;\n};\nRay.prototype[Shape.types.SPHERE] = Ray.prototype.intersectSphere;\n\n\nvar intersectConvex_minDistNormal = new Vec3();\nvar intersectConvex_minDistIntersect = new Vec3();\nRay.prototype.intersectConvex = function intersectConvex(shape, quat, position, body, direction, result, options){\n    var minDistNormal = intersectConvex_minDistNormal;\n    var minDistIntersect = intersectConvex_minDistIntersect;\n    var faceList = (options && options.faceList) || null;\n\n    // Checking faces\n    var faces = shape.faces,\n        vertices = shape.vertices,\n        normals = shape.faceNormals;\n\n    var from = this.from;\n    var to = this.to;\n    var fromToDistance = from.distanceTo(to);\n\n    var reportClosest = result instanceof RaycastResult;\n    var minDist = -1;\n    var Nfaces = faceList ? faceList.length : faces.length;\n\n    for (var j = 0; j < Nfaces; j++) {\n        var fi = faceList ? faceList[j] : j;\n\n        var face = faces[fi];\n        var faceNormal = normals[fi];\n        var q = quat;\n        var x = position;\n\n        // determine if ray intersects the plane of the face\n        // note: this works regardless of the direction of the face normal\n\n        // Get plane point in world coordinates...\n        vector.copy(vertices[face[0]]);\n        q.vmult(vector,vector);\n        vector.vadd(x,vector);\n\n        // ...but make it relative to the ray from. We'll fix this later.\n        vector.vsub(from,vector);\n\n        // Get plane normal\n        q.vmult(faceNormal,normal);\n\n        // If this dot product is negative, we have something interesting\n        var dot = direction.dot(normal);\n\n        // Bail out if ray and plane are parallel\n        if ( Math.abs( dot ) < this.precision ){\n            continue;\n        }\n\n        // calc distance to plane\n        var scalar = normal.dot(vector) / dot;\n\n        // if negative distance, then plane is behind ray\n        if (scalar < 0){\n            continue;\n        }\n\n        if (dot < 0) {\n\n            // Intersection point is from + direction * scalar\n            direction.mult(scalar,intersectPoint);\n            intersectPoint.vadd(from,intersectPoint);\n\n            // a is the point we compare points b and c with.\n            a.copy(vertices[face[0]]);\n            q.vmult(a,a);\n            x.vadd(a,a);\n\n            for(var i = 1; i < face.length - 1; i++){\n                // Transform 3 vertices to world coords\n                b.copy(vertices[face[i]]);\n                c.copy(vertices[face[i+1]]);\n                q.vmult(b,b);\n                q.vmult(c,c);\n                x.vadd(b,b);\n                x.vadd(c,c);\n\n                var distance = intersectPoint.distanceTo(from);\n\n                if(!pointInTriangle(intersectPoint, a, b, c) || distance > fromToDistance){\n                    continue;\n                }\n\n                if(minDist === -1 || distance < minDist){\n                    minDist = distance;\n                    minDistNormal.copy(normal);\n                    minDistIntersect.copy(intersectPoint);\n                }\n            }\n        }\n    }\n\n    if(minDist !== -1 && this.reportIntersection(minDistNormal, minDistIntersect, shape, body, result)){\n        return result;\n    }\n\n    return result;\n};\n\nRay.prototype[Shape.types.CONVEXPOLYHEDRON] = Ray.prototype.intersectConvex;\n\n\nRay.prototype.reportIntersection = function(normal, hitPointWorld, shape, body, result){\n    var from = this.from;\n    var to = this.to;\n    var distance = from.distanceTo(hitPointWorld);\n\n    if(!(result instanceof RaycastResult)){\n        // Got a callback\n        tmpRaycastResult.set(\n            from,\n            to,\n            normal,\n            hitPointWorld,\n            shape,\n            body,\n            distance\n        );\n        tmpRaycastResult.hasHit = true;\n        result(tmpRaycastResult);\n\n        return true;\n\n    } else {\n\n        // Store if closer than current cloest\n        if(distance < result.distance || !result.hasHit){\n            result.hasHit = true;\n            result.set(\n                from,\n                to,\n                normal,\n                hitPointWorld,\n                shape,\n                body,\n                distance\n            );\n        }\n\n        return false;\n    }\n};\n\nvar v0 = new Vec3(),\n    intersect = new Vec3();\nfunction distanceFromIntersection(from, direction, position) {\n\n    // v0 is vector from from to position\n    position.vsub(from,v0);\n    var dot = v0.dot( direction );\n\n    // intersect = direction*dot + from\n    direction.mult(dot,intersect);\n    intersect.vadd(from,intersect);\n\n    var distance = position.distanceTo(intersect);\n\n    return distance;\n}\n\n\n},{\"../collision/AABB\":3,\"../collision/RaycastResult\":10,\"../math/Quaternion\":25,\"../math/Transform\":26,\"../math/Vec3\":27,\"../shapes/Box\":34,\"../shapes/ConvexPolyhedron\":35,\"../shapes/Shape\":40}],10:[function(_dereq_,module,exports){\nvar Vec3 = _dereq_('../math/Vec3');\n\nmodule.exports = RaycastResult;\n\nfunction RaycastResult(){\n\tthis.rayFromWorld = new Vec3();\n\tthis.rayToWorld = new Vec3();\n\tthis.hitNormalWorld = new Vec3();\n\tthis.hitPointWorld = new Vec3();\n\tthis.hasHit = false;\n\tthis.shape = null;\n\tthis.body = null;\n\tthis.distance = -1;\n}\n\nRaycastResult.prototype.reset = function () {\n\tthis.rayFromWorld.setZero();\n\tthis.rayToWorld.setZero();\n\tthis.hitNormalWorld.setZero();\n\tthis.hitPointWorld.setZero();\n\tthis.hasHit = false;\n\tthis.shape = null;\n\tthis.body = null;\n\tthis.distance = -1;\n};\n\nRaycastResult.prototype.set = function(\n\trayFromWorld,\n\trayToWorld,\n\thitNormalWorld,\n\thitPointWorld,\n\tshape,\n\tbody,\n\tdistance\n){\n\tthis.rayFromWorld.copy(rayFromWorld);\n\tthis.rayToWorld.copy(rayToWorld);\n\tthis.hitNormalWorld.copy(hitNormalWorld);\n\tthis.hitPointWorld.copy(hitPointWorld);\n\tthis.shape = shape;\n\tthis.body = body;\n\tthis.distance = distance;\n};\n},{\"../math/Vec3\":27}],11:[function(_dereq_,module,exports){\nvar Shape = _dereq_('../shapes/Shape');\nvar Broadphase = _dereq_('../collision/Broadphase');\n\nmodule.exports = SAPBroadphase;\n\n/**\n * Sweep and prune broadphase along one axis.\n *\n * @class SAPBroadphase\n * @constructor\n * @param {World} world\n * @extends Broadphase\n */\nfunction SAPBroadphase(world){\n    Broadphase.apply(this);\n\n    /**\n     * List of bodies currently in the broadphase.\n     * @property axisList\n     * @type {Array}\n     */\n    this.axisList = [];\n\n    /**\n     * The world to search in.\n     * @property world\n     * @type {World}\n     */\n    this.world = null;\n\n    /**\n     * Axis to sort the bodies along. Set to 0 for x axis, and 1 for y axis. For best performance, choose an axis that the bodies are spread out more on.\n     * @property axisIndex\n     * @type {Number}\n     */\n    this.axisIndex = 0;\n\n    var axisList = this.axisList;\n\n    this._addBodyHandler = function(e){\n        axisList.push(e.body);\n    };\n\n    this._removeBodyHandler = function(e){\n        var idx = axisList.indexOf(e.body);\n        if(idx !== -1){\n            axisList.splice(idx,1);\n        }\n    };\n\n    if(world){\n        this.setWorld(world);\n    }\n}\nSAPBroadphase.prototype = new Broadphase();\n\n/**\n * Change the world\n * @method setWorld\n * @param  {World} world\n */\nSAPBroadphase.prototype.setWorld = function(world){\n    // Clear the old axis array\n    this.axisList.length = 0;\n\n    // Add all bodies from the new world\n    for(var i=0; i<world.bodies.length; i++){\n        this.axisList.push(world.bodies[i]);\n    }\n\n    // Remove old handlers, if any\n    world.removeEventListener(\"addBody\", this._addBodyHandler);\n    world.removeEventListener(\"removeBody\", this._removeBodyHandler);\n\n    // Add handlers to update the list of bodies.\n    world.addEventListener(\"addBody\", this._addBodyHandler);\n    world.addEventListener(\"removeBody\", this._removeBodyHandler);\n\n    this.world = world;\n    this.dirty = true;\n};\n\n/**\n * @static\n * @method insertionSortX\n * @param  {Array} a\n * @return {Array}\n */\nSAPBroadphase.insertionSortX = function(a) {\n    for(var i=1,l=a.length;i<l;i++) {\n        var v = a[i];\n        for(var j=i - 1;j>=0;j--) {\n            if(a[j].aabb.lowerBound.x <= v.aabb.lowerBound.x){\n                break;\n            }\n            a[j+1] = a[j];\n        }\n        a[j+1] = v;\n    }\n    return a;\n};\n\n/**\n * @static\n * @method insertionSortY\n * @param  {Array} a\n * @return {Array}\n */\nSAPBroadphase.insertionSortY = function(a) {\n    for(var i=1,l=a.length;i<l;i++) {\n        var v = a[i];\n        for(var j=i - 1;j>=0;j--) {\n            if(a[j].aabb.lowerBound.y <= v.aabb.lowerBound.y){\n                break;\n            }\n            a[j+1] = a[j];\n        }\n        a[j+1] = v;\n    }\n    return a;\n};\n\n/**\n * @static\n * @method insertionSortZ\n * @param  {Array} a\n * @return {Array}\n */\nSAPBroadphase.insertionSortZ = function(a) {\n    for(var i=1,l=a.length;i<l;i++) {\n        var v = a[i];\n        for(var j=i - 1;j>=0;j--) {\n            if(a[j].aabb.lowerBound.z <= v.aabb.lowerBound.z){\n                break;\n            }\n            a[j+1] = a[j];\n        }\n        a[j+1] = v;\n    }\n    return a;\n};\n\n/**\n * Collect all collision pairs\n * @method collisionPairs\n * @param  {World} world\n * @param  {Array} p1\n * @param  {Array} p2\n */\nSAPBroadphase.prototype.collisionPairs = function(world,p1,p2){\n    var bodies = this.axisList,\n        N = bodies.length,\n        axisIndex = this.axisIndex,\n        i, j;\n\n    if(this.dirty){\n        this.sortList();\n        this.dirty = false;\n    }\n\n    // Look through the list\n    for(i=0; i !== N; i++){\n        var bi = bodies[i];\n\n        for(j=i+1; j < N; j++){\n            var bj = bodies[j];\n\n            if(!this.needBroadphaseCollision(bi,bj)){\n                continue;\n            }\n\n            if(!SAPBroadphase.checkBounds(bi,bj,axisIndex)){\n                break;\n            }\n\n            this.intersectionTest(bi,bj,p1,p2);\n        }\n    }\n};\n\nSAPBroadphase.prototype.sortList = function(){\n    var axisList = this.axisList;\n    var axisIndex = this.axisIndex;\n    var N = axisList.length;\n\n    // Update AABBs\n    for(var i = 0; i!==N; i++){\n        var bi = axisList[i];\n        if(bi.aabbNeedsUpdate){\n            bi.computeAABB();\n        }\n    }\n\n    // Sort the list\n    if(axisIndex === 0){\n        SAPBroadphase.insertionSortX(axisList);\n    } else if(axisIndex === 1){\n        SAPBroadphase.insertionSortY(axisList);\n    } else if(axisIndex === 2){\n        SAPBroadphase.insertionSortZ(axisList);\n    }\n};\n\n/**\n * Check if the bounds of two bodies overlap, along the given SAP axis.\n * @static\n * @method checkBounds\n * @param  {Body} bi\n * @param  {Body} bj\n * @param  {Number} axisIndex\n * @return {Boolean}\n */\nSAPBroadphase.checkBounds = function(bi, bj, axisIndex){\n    var axis;\n    if(axisIndex === 0){ axis = 'x'; }\n    if(axisIndex === 1){ axis = 'y'; }\n    if(axisIndex === 2){ axis = 'z'; }\n\n    var biPos = bi.position[axis],\n        ri = bi.boundingRadius,\n        bjPos = bj.position[axis],\n        rj = bj.boundingRadius,\n        boundA1 = biPos - ri,\n        boundA2 = biPos + ri,\n        boundB1 = bjPos - rj,\n        boundB2 = bjPos + rj;\n\n    return boundB1 < boundA2;\n};\n\n/**\n * Computes the variance of the body positions and estimates the best\n * axis to use. Will automatically set property .axisIndex.\n * @method autoDetectAxis\n */\nSAPBroadphase.prototype.autoDetectAxis = function(){\n    var sumX=0,\n        sumX2=0,\n        sumY=0,\n        sumY2=0,\n        sumZ=0,\n        sumZ2=0,\n        bodies = this.axisList,\n        N = bodies.length,\n        invN=1/N;\n\n    for(var i=0; i!==N; i++){\n        var b = bodies[i];\n\n        var centerX = b.position.x;\n        sumX += centerX;\n        sumX2 += centerX*centerX;\n\n        var centerY = b.position.y;\n        sumY += centerY;\n        sumY2 += centerY*centerY;\n\n        var centerZ = b.position.z;\n        sumZ += centerZ;\n        sumZ2 += centerZ*centerZ;\n    }\n\n    var varianceX = sumX2 - sumX*sumX*invN,\n        varianceY = sumY2 - sumY*sumY*invN,\n        varianceZ = sumZ2 - sumZ*sumZ*invN;\n\n    if(varianceX > varianceY){\n        if(varianceX > varianceZ){\n            this.axisIndex = 0;\n        } else{\n            this.axisIndex = 2;\n        }\n    } else if(varianceY > varianceZ){\n        this.axisIndex = 1;\n    } else{\n        this.axisIndex = 2;\n    }\n};\n\n/**\n * Returns all the bodies within an AABB.\n * @method aabbQuery\n * @param  {World} world\n * @param  {AABB} aabb\n * @param {array} result An array to store resulting bodies in.\n * @return {array}\n */\nSAPBroadphase.prototype.aabbQuery = function(world, aabb, result){\n    result = result || [];\n\n    if(this.dirty){\n        this.sortList();\n        this.dirty = false;\n    }\n\n    var axisIndex = this.axisIndex, axis = 'x';\n    if(axisIndex === 1){ axis = 'y'; }\n    if(axisIndex === 2){ axis = 'z'; }\n\n    var axisList = this.axisList;\n    var lower = aabb.lowerBound[axis];\n    var upper = aabb.upperBound[axis];\n    for(var i = 0; i < axisList.length; i++){\n        var b = axisList[i];\n\n        if(b.aabb.upperBound[axis] > lower && b.aabb.lowerBound[axis] < upper && b.aabb.overlaps(aabb)){\n            result.push(b);\n        }\n    }\n\n    return result;\n};\n},{\"../collision/Broadphase\":5,\"../shapes/Shape\":40}],12:[function(_dereq_,module,exports){\nmodule.exports = Constraint;\n\nvar Utils = _dereq_('../utils/Utils');\n\n/**\n * Constraint base class\n * @class Constraint\n * @author schteppe\n * @constructor\n * @param {Body} bodyA\n * @param {Body} bodyB\n */\nfunction Constraint(bodyA, bodyB, options){\n    options = Utils.defaults(options,{\n        collideConnected : true,\n        wakeUpBodies : true,\n    });\n\n    /**\n     * Equations to be solved in this constraint\n     * @property equations\n     * @type {Array}\n     */\n    this.equations = [];\n\n    /**\n     * @property {Body} bodyA\n     */\n    this.bodyA = bodyA;\n\n    /**\n     * @property {Body} bodyB\n     */\n    this.bodyB = bodyB;\n\n    /**\n     * @property {Number} id\n     */\n    this.id = Constraint.idCounter++;\n\n    /**\n     * Set to true if you want the bodies to collide when they are connected.\n     * @property collideConnected\n     * @type {boolean}\n     */\n    this.collideConnected = options.collideConnected;\n\n    if(options.wakeUpBodies){\n        if(bodyA){\n            bodyA.wakeUp();\n        }\n        if(bodyB){\n            bodyB.wakeUp();\n        }\n    }\n}\n\n/**\n * @method update\n */\nConstraint.prototype.update = function(){\n    throw new Error(\"method update() not implmemented in this Constraint subclass!\");\n};\n\nConstraint.idCounter = 0;\n\n},{\"../utils/Utils\":48}],13:[function(_dereq_,module,exports){\nmodule.exports = DistanceConstraint;\n\nvar Constraint = _dereq_('./Constraint');\nvar ContactEquation = _dereq_('../equations/ContactEquation');\n\n/**\n * Constrains two bodies to be at a constant distance from each other.\n * @class DistanceConstraint\n * @constructor\n * @author schteppe\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Number} distance\n * @param {Number} maxForce\n * @extends Constraint\n */\nfunction DistanceConstraint(bodyA,bodyB,distance,maxForce){\n    Constraint.call(this,bodyA,bodyB);\n\n    if(typeof(maxForce)===\"undefined\" ) {\n        maxForce = 1e6;\n    }\n\n    // Equations to be fed to the solver\n    var eqs = this.equations = [\n        new ContactEquation(bodyA,bodyB), // Just in the normal direction\n    ];\n\n    var normal = eqs[0];\n\n    normal.minForce = -maxForce;\n    normal.maxForce =  maxForce;\n\n    // Update\n    this.update = function(){\n        bodyB.position.vsub(bodyA.position,normal.ni);\n        normal.ni.normalize();\n        /*bodyA.quaternion.vmult(pivotA,normal.ri);\n        bodyB.quaternion.vmult(pivotB,normal.rj);*/\n        normal.ni.mult( distance*0.5,normal.ri);\n        normal.ni.mult( -distance*0.5,normal.rj);\n    };\n}\nDistanceConstraint.prototype = new Constraint();\n\n},{\"../equations/ContactEquation\":16,\"./Constraint\":12}],14:[function(_dereq_,module,exports){\nmodule.exports = HingeConstraint;\n\nvar Constraint = _dereq_('./Constraint');\nvar RotationalEquation = _dereq_('../equations/RotationalEquation');\nvar RotationalMotorEquation = _dereq_('../equations/RotationalMotorEquation');\nvar ContactEquation = _dereq_('../equations/ContactEquation');\nvar Vec3 = _dereq_('../math/Vec3');\n\n/**\n * Hinge constraint. Tries to keep the local body axes equal.\n * @class HingeConstraint\n * @constructor\n * @author schteppe\n * @param {RigidBody} bodyA\n * @param {RigidBody} bodyB\n * @param {object} [options]\n * @param {Vec3} [options.pivotA] A point defined locally in bodyA. This defines the offset of axisA.\n * @param {Vec3} [options.axisA] an axis that bodyA can rotate around.\n * @param {Vec3} [options.pivotB]\n * @param {Vec3} [options.axisB]\n * @param {Number} [options.maxForce=1e6]\n * @extends Constraint\n */\nfunction HingeConstraint(bodyA, bodyB, options){ // bodyA, pivotA, axisA, bodyB, pivotB, axisB, maxForce\n    Constraint.call(this, bodyA, bodyB, options);\n\n    var maxForce = typeof(options.maxForce) !== 'undefined' ? options.maxForce : 1e6;\n\n    // TODO: use a clever default setup... how?\n    var pivotA = this.pivotA = typeof(options.pivotA) !== 'undefined' ? options.pivotA.clone() : new Vec3();\n    var pivotB = this.pivotB = typeof(options.pivotB) !== 'undefined' ? options.pivotB.clone() : new Vec3();\n    var axisA = this.axisA = typeof(options.axisA) !== 'undefined' ? options.axisA.clone() : new Vec3(1,0,0);\n    var axisB = this.axisB = typeof(options.axisB) !== 'undefined' ? options.axisB.clone() : new Vec3(1,0,0);\n\n    var that = this;\n\n    // Equations to be fed to the solver\n    var eqs = this.equations = [\n        new RotationalEquation(bodyA,bodyB), // rotational1\n        new RotationalEquation(bodyA,bodyB), // rotational2\n        new ContactEquation(bodyA,bodyB),    // p2pNormal\n        new ContactEquation(bodyA,bodyB),    // p2pTangent1\n        new ContactEquation(bodyA,bodyB),    // p2pTangent2\n    ];\n\n    var r1 =        this.getRotationalEquation1();\n    var r2 =        this.getRotationalEquation2();\n    var normal =    this.getPointToPointEquation1();\n    var t1 =        this.getPointToPointEquation2();\n    var t2 =        this.getPointToPointEquation3();\n    var motor; // not activated by default\n\n    t1.minForce = t2.minForce = normal.minForce = -maxForce;\n    t1.maxForce = t2.maxForce = normal.maxForce =  maxForce;\n\n    var unitPivotA = pivotA.unit();\n    var unitPivotB = pivotB.unit();\n\n    var axisA_x_pivotA = this.axisA_x_pivotA = new Vec3();\n    var axisA_x_axisA_x_pivotA = this.axisA_x_axisA_x_pivotA = new Vec3();\n    var axisB_x_pivotB = this.axisB_x_pivotB = new Vec3();\n    axisA.cross(unitPivotA,axisA_x_pivotA);\n    if(axisA_x_pivotA.norm2() < 0.001){ // pivotA is along the same line as axisA\n        unitPivotA.tangents(axisA_x_pivotA,axisA_x_pivotA);\n    }\n    axisA.cross(axisA_x_pivotA,axisA_x_axisA_x_pivotA);\n    axisB.cross(unitPivotB,axisB_x_pivotB);\n    if(axisB_x_pivotB.norm2() < 0.001){ // pivotB is along the same line as axisB\n        axisB.tangents(axisB_x_pivotB,axisB_x_pivotB);\n    }\n\n    axisA_x_pivotA.normalize();\n    axisB_x_pivotB.normalize();\n\n    // Motor stuff\n    this.motorEnabled = false;\n    this.motorTargetVelocity = 0;\n    this.motorMinForce = -maxForce;\n    this.motorMaxForce = maxForce;\n    this.motorEquation = new RotationalMotorEquation(bodyA,bodyB,maxForce);\n}\nHingeConstraint.prototype = new Constraint();\n\n/**\n * @method enableMotor\n */\nHingeConstraint.prototype.enableMotor = function(){\n    if(!this.motorEnabled){\n        this.equations.push(this.motorEquation);\n        this.motorEnabled = true;\n    }\n};\n\n/**\n * @method disableMotor\n */\nHingeConstraint.prototype.disableMotor = function(){\n    if(this.motorEnabled){\n        this.motorEnabled = false;\n        this.equations.pop();\n    }\n};\n\nHingeConstraint.prototype.update = function(){\n    var bodyA = this.bodyA,\n        bodyB = this.bodyB,\n        eqs = this.equations,\n        motor = this.motorEquation,\n        r1 = eqs[0],\n        r2 = eqs[1],\n        normal = eqs[2],\n        t1 = eqs[3],\n        t2 = eqs[4];\n    var axisA_x_pivotA = this.axisA_x_pivotA;\n    var axisA = this.axisA;\n    var axisB = this.axisB;\n    var pivotA = this.pivotA;\n    var pivotB = this.pivotB;\n    var axisA_x_axisA_x_pivotA = this.axisA_x_axisA_x_pivotA;\n    var axisB_x_pivotB = this.axisB_x_pivotB;\n\n    // Update world positions of pivots\n    /*\n    bodyB.position.vsub(bodyA.position,normal.ni);\n    normal.ni.normalize();\n    */\n    normal.ni.set(1,0,0);\n    t1.ni.set(0,1,0);\n    t2.ni.set(0,0,1);\n    bodyA.quaternion.vmult(this.pivotA,normal.ri);\n    bodyB.quaternion.vmult(this.pivotB,normal.rj);\n\n    //normal.ni.tangents(t1.ni,t2.ni);\n    t1.ri.copy(normal.ri);\n    t1.rj.copy(normal.rj);\n    t2.ri.copy(normal.ri);\n    t2.rj.copy(normal.rj);\n\n    axisA.cross(pivotA, axisA_x_pivotA);\n    if(axisA_x_pivotA.norm2() < 0.001){ // pivotA is along the same line as axisA\n        pivotA.tangents(axisA_x_pivotA, axisA_x_pivotA);\n    }\n    axisA.cross(axisA_x_pivotA, axisA_x_axisA_x_pivotA);\n    axisB.cross(pivotB, axisB_x_pivotB);\n    if(axisB_x_pivotB.norm2() < 0.001){ // pivotB is along the same line as axisB\n        axisB.tangents(axisB_x_pivotB,axisB_x_pivotB);\n    }\n\n    axisA_x_pivotA.normalize();\n    axisB_x_pivotB.normalize();\n\n    // update rotational constraints\n    bodyA.quaternion.vmult(axisA_x_pivotA, r1.ni);\n    bodyB.quaternion.vmult(axisB, r1.nj);\n    bodyA.quaternion.vmult(axisA_x_axisA_x_pivotA, r2.ni);\n    bodyB.quaternion.vmult(axisB, r2.nj);\n\n    if(this.motorEnabled){\n        bodyA.quaternion.vmult(this.axisA, motor.axisA);\n        bodyB.quaternion.vmult(this.axisB, motor.axisB);\n        motor.targetVelocity = this.motorTargetVelocity;\n        motor.maxForce = this.motorMaxForce;\n        motor.minForce = this.motorMinForce;\n    }\n};\n\nHingeConstraint.prototype.getRotationalEquation1 =   function(){ return this.equations[0]; };\nHingeConstraint.prototype.getRotationalEquation2 =   function(){ return this.equations[1]; };\nHingeConstraint.prototype.getPointToPointEquation1 = function(){ return this.equations[2]; };\nHingeConstraint.prototype.getPointToPointEquation2 = function(){ return this.equations[3]; };\nHingeConstraint.prototype.getPointToPointEquation3 = function(){ return this.equations[4]; };\n\n},{\"../equations/ContactEquation\":16,\"../equations/RotationalEquation\":19,\"../equations/RotationalMotorEquation\":20,\"../math/Vec3\":27,\"./Constraint\":12}],15:[function(_dereq_,module,exports){\nmodule.exports = PointToPointConstraint;\n\nvar Constraint = _dereq_('./Constraint');\nvar ContactEquation = _dereq_('../equations/ContactEquation');\n\n/**\n * Connects two bodies at given offset points.\n * @class PointToPointConstraint\n * @extends Constraint\n * @constructor\n * @param {Body} bodyA\n * @param {Vec3} pivotA The point relative to the center of mass of bodyA which bodyA is constrained to.\n * @param {Body} bodyB Body that will be constrained in a similar way to the same point as bodyA. We will therefore get sort of a link between bodyA and bodyB. If not specified, bodyA will be constrained to a static point.\n * @param {Vec3} pivotB See pivotA.\n * @param {Number} maxForce The maximum force that should be applied to constrain the bodies.\n *\n * @example\n *     var bodyA = new Body({ mass: 1 });\n *     var bodyB = new Body({ mass: 1 });\n *     bodyA.position.set(-1, 0, 0);\n *     bodyB.position.set(1, 0, 0);\n *     bodyA.addShape(shapeA);\n *     bodyB.addShape(shapeB);\n *     world.addBody(bodyA);\n *     world.addBody(bodyB);\n *     var localPivotA = new Vec3(1, 0, 0);\n *     var localPivotB = new Vec3(-1, 0, 0);\n *     var constraint = new PointToPointConstraint(bodyA, localPivotA, bodyB, localPivotB);\n *     world.addConstraint(constraint);\n */\nfunction PointToPointConstraint(bodyA,pivotA,bodyB,pivotB,maxForce){\n    Constraint.call(this,bodyA,bodyB);\n\n    // Equations to be fed to the solver\n    var eqs = this.equations = [\n        new ContactEquation(bodyA,bodyB), // Normal\n        new ContactEquation(bodyA,bodyB), // Tangent2\n        new ContactEquation(bodyA,bodyB), // Tangent2\n    ];\n\n    var normal = eqs[0];\n    var t1 = eqs[1];\n    var t2 = eqs[2];\n\n    t1.minForce = t2.minForce = normal.minForce = -maxForce;\n    t1.maxForce = t2.maxForce = normal.maxForce =  maxForce;\n\n    // Update\n    this.update = function(){\n        bodyB.position.vsub(bodyA.position,normal.ni);\n        normal.ni.normalize();\n        bodyA.quaternion.vmult(pivotA,normal.ri);\n        bodyB.quaternion.vmult(pivotB,normal.rj);\n\n        normal.ni.tangents(t1.ni,t2.ni);\n        t1.ri.copy(normal.ri);\n        t1.rj.copy(normal.rj);\n        t2.ri.copy(normal.ri);\n        t2.rj.copy(normal.rj);\n    };\n}\nPointToPointConstraint.prototype = new Constraint();\n\n},{\"../equations/ContactEquation\":16,\"./Constraint\":12}],16:[function(_dereq_,module,exports){\nmodule.exports = ContactEquation;\n\nvar Equation = _dereq_('./Equation');\nvar Vec3 = _dereq_('../math/Vec3');\nvar Mat3 = _dereq_('../math/Mat3');\n\n/**\n * Contact/non-penetration constraint equation\n * @class ContactEquation\n * @constructor\n * @author schteppe\n * @param {Body} bj\n * @param {Body} bi\n * @extends Equation\n */\nfunction ContactEquation(bi,bj){\n    Equation.call(this,bi,bj,0,1e6);\n\n    /**\n     * @property restitution\n     * @type {Number}\n     */\n    this.restitution = 0.0; // \"bounciness\": u1 = -e*u0\n\n    /**\n     * World-oriented vector that goes from the center of bi to the contact point.\n     * @property {Vec3} ri\n     */\n    this.ri = new Vec3();\n\n    /**\n     * World-oriented vector that starts in body j position and goes to the contact point.\n     * @property {Vec3} rj\n     */\n    this.rj = new Vec3();\n\n    this.penetrationVec = new Vec3();\n\n    /**\n     * Contact normal, pointing out of body i.\n     * @property {Vec3} ni\n     */\n    this.ni = new Vec3();\n\n    this.rixn = new Vec3();\n    this.rjxn = new Vec3();\n\n    this.invIi = new Mat3();\n    this.invIj = new Mat3();\n\n    // Cache\n    this.biInvInertiaTimesRixn =  new Vec3();\n    this.bjInvInertiaTimesRjxn =  new Vec3();\n}\n\nContactEquation.prototype = new Equation();\nContactEquation.prototype.constructor = ContactEquation;\n\nvar ContactEquation_computeB_temp1 = new Vec3(); // Temp vectors\nvar ContactEquation_computeB_temp2 = new Vec3();\nvar ContactEquation_computeB_zero = new Vec3();\nContactEquation.prototype.computeB = function(h){\n    var a = this.a,\n        b = this.b,\n        bi = this.bi,\n        bj = this.bj,\n        ri = this.ri,\n        rj = this.rj,\n        rixn = this.rixn,\n        rjxn = this.rjxn,\n\n        zero = ContactEquation_computeB_zero,\n\n        vi = bi.velocity,\n        wi = bi.angularVelocity ? bi.angularVelocity : zero,\n        fi = bi.force,\n        taui = bi.tau ? bi.tau : zero,\n\n        vj = bj.velocity,\n        wj = bj.angularVelocity ? bj.angularVelocity : zero,\n        fj = bj.force,\n        tauj = bj.tau ? bj.tau : zero,\n\n        penetrationVec = this.penetrationVec,\n        invMassi = bi.invMass,\n        invMassj = bj.invMass,\n\n        invIi = this.invIi,\n        invIj = this.invIj,\n\n        GA = this.jacobianElementA,\n        GB = this.jacobianElementB,\n\n        n = this.ni;\n\n    // Caluclate cross products\n    ri.cross(n,rixn);\n    rj.cross(n,rjxn);\n\n    // g = xj+rj -(xi+ri)\n    // G = [ -ni  -rixn  ni  rjxn ]\n    n.negate(GA.spatial);\n    rixn.negate(GA.rotational);\n    GB.spatial.copy(n);\n    GB.rotational.copy(rjxn);\n\n    // Calculate the penetration vector\n    var penetrationVec = this.penetrationVec;\n    penetrationVec.set(0,0,0);\n    penetrationVec.vadd(bj.position,penetrationVec);\n    penetrationVec.vadd(rj,penetrationVec);\n    penetrationVec.vsub(bi.position,penetrationVec);\n    penetrationVec.vsub(ri,penetrationVec);\n\n    var g = n.dot(penetrationVec);\n\n    var invIi_vmult_taui = ContactEquation_computeB_temp1;\n    var invIj_vmult_tauj = ContactEquation_computeB_temp2;\n    if(bi.invInertiaWorld){\n        bi.invInertiaWorld.vmult(taui,invIi_vmult_taui);\n    } else {\n        invIi_vmult_taui.set(0,0,0);\n    }\n    if(bj.invInertiaWorld){\n        bj.invInertiaWorld.vmult(tauj,invIj_vmult_tauj);\n    } else {\n        invIj_vmult_tauj.set(0,0,0);\n    }\n\n    // Compute iteration\n    var ePlusOne = this.restitution+1;\n    var GW = ePlusOne*vj.dot(n) - ePlusOne*vi.dot(n) + wj.dot(rjxn) - wi.dot(rixn);\n    var GiMf = this.computeGiMf();//fj.dot(n)*invMassj - fi.dot(n)*invMassi + rjxn.dot(invIj_vmult_tauj) - rixn.dot(invIi_vmult_taui);\n\n    var B = - g * a - GW * b - h*GiMf;\n\n    return B;\n};\n\n// Compute C = GMG+eps in the SPOOK equation\n/*\nvar computeC_temp1 = new Vec3();\nvar computeC_temp2 = new Vec3();\nContactEquation.prototype.computeC = function(){\n    var bi = this.bi;\n    var bj = this.bj;\n    var rixn = this.rixn;\n    var rjxn = this.rjxn;\n    var invMassi = bi.invMass;\n    var invMassj = bj.invMass;\n\n    var C = invMassi + invMassj + this.eps;\n\n    var invIi = this.invIi;\n    var invIj = this.invIj;\n\n    // Compute rxn * I * rxn for each body\n    if(bi.invInertiaWorld) bi.invInertiaWorld.vmult(rixn, this.biInvInertiaTimesRixn);\n    if(bj.invInertiaWorld) bj.invInertiaWorld.vmult(rjxn, this.bjInvInertiaTimesRjxn);\n\n    C += this.biInvInertiaTimesRixn.dot(rixn);\n    C += this.bjInvInertiaTimesRjxn.dot(rjxn);\n\n    return C;\n};\n\nvar computeGWlambda_ulambda = new Vec3();\nContactEquation.prototype.computeGWlambda = function(){\n    var bi = this.bi;\n    var bj = this.bj;\n    var ulambda = computeGWlambda_ulambda;\n\n    var GWlambda = 0.0;\n\n    bj.vlambda.vsub(bi.vlambda, ulambda);\n    GWlambda += ulambda.dot(this.ni);\n\n    // Angular\n    if(bi.wlambda){\n        GWlambda -= bi.wlambda.dot(this.rixn);\n    }\n    if(bj.wlambda){\n        GWlambda += bj.wlambda.dot(this.rjxn);\n    }\n\n    return GWlambda;\n};\n\nvar ContactEquation_addToWlambda_temp1 = new Vec3();\nvar ContactEquation_addToWlambda_temp2 = new Vec3();\nContactEquation.prototype.addToWlambda = function(deltalambda){\n    var bi = this.bi,\n        bj = this.bj,\n        rixn = this.rixn,\n        rjxn = this.rjxn,\n        invMassi = bi.invMass,\n        invMassj = bj.invMass,\n        n = this.ni,\n        temp1 = ContactEquation_addToWlambda_temp1,\n        temp2 = ContactEquation_addToWlambda_temp2;\n\n\n    // Add to linear velocity\n    n.mult(invMassi * deltalambda, temp2);\n    bi.vlambda.vsub(temp2,bi.vlambda);\n    n.mult(invMassj * deltalambda, temp2);\n    bj.vlambda.vadd(temp2,bj.vlambda);\n\n    // Add to angular velocity\n    if(bi.wlambda !== undefined){\n        this.biInvInertiaTimesRixn.mult(deltalambda,temp1);\n\n        bi.wlambda.vsub(temp1,bi.wlambda);\n    }\n    if(bj.wlambda !== undefined){\n        this.bjInvInertiaTimesRjxn.mult(deltalambda,temp1);\n        bj.wlambda.vadd(temp1,bj.wlambda);\n    }\n};\n*/\n\n},{\"../math/Mat3\":24,\"../math/Vec3\":27,\"./Equation\":17}],17:[function(_dereq_,module,exports){\nmodule.exports = Equation;\n\nvar JacobianElement = _dereq_('../math/JacobianElement'),\n    Vec3 = _dereq_('../math/Vec3');\n\n/**\n * Equation base class\n * @class Equation\n * @constructor\n * @author schteppe\n * @param {Body} bi\n * @param {Body} bj\n * @param {Number} minForce Minimum (read: negative max) force to be applied by the constraint.\n * @param {Number} maxForce Maximum (read: positive max) force to be applied by the constraint.\n */\nfunction Equation(bi,bj,minForce,maxForce){\n    this.id = -1;\n\n    /**\n     * @property {number} minForce\n     */\n    this.minForce = typeof(minForce)===\"undefined\" ? -1e6 : minForce;\n\n    /**\n     * @property {number} maxForce\n     */\n    this.maxForce = typeof(maxForce)===\"undefined\" ? 1e6 : maxForce;\n\n    /**\n     * @property bi\n     * @type {Body}\n     */\n    this.bi = bi;\n\n    /**\n     * @property bj\n     * @type {Body}\n     */\n    this.bj = bj;\n\n    /**\n     * SPOOK parameter\n     * @property {number} a\n     */\n    this.a = 0.0;\n\n    /**\n     * SPOOK parameter\n     * @property {number} b\n     */\n    this.b = 0.0;\n\n    /**\n     * SPOOK parameter\n     * @property {number} eps\n     */\n    this.eps = 0.0;\n\n    /**\n     * @property {JacobianElement} jacobianElementA\n     */\n    this.jacobianElementA = new JacobianElement();\n\n    /**\n     * @property {JacobianElement} jacobianElementA\n     */\n    this.jacobianElementB = new JacobianElement();\n\n    // Set typical spook params\n    this.setSpookParams(1e7,4,1/60);\n\n    this.enabled = true;\n}\nEquation.prototype.constructor = Equation;\n\n/**\n * Recalculates a,b,eps.\n * @method setSpookParams\n */\nEquation.prototype.setSpookParams = function(stiffness,relaxation,timeStep){\n    var d = relaxation,\n        k = stiffness,\n        h = timeStep;\n    this.a = 4.0 / (h * (1 + 4 * d));\n    this.b = (4.0 * d) / (1 + 4 * d);\n    this.eps = 4.0 / (h * h * k * (1 + 4 * d));\n};\n\n/**\n * Computes the RHS of the SPOOK equation\n * @method computeB\n * @return {Number}\n */\nEquation.prototype.computeB = function(a,b,h){\n    var GW = this.computeGW(),\n        Gq = this.computeGq(),\n        GiMf = this.computeGiMf();\n    return - Gq * a - GW * b - GiMf*h;\n};\n\n/**\n * Computes G*q, where q are the generalized body coordinates\n * @method computeGq\n * @return {Number}\n */\nEquation.prototype.computeGq = function(){\n    var GA = this.jacobianElementA,\n        GB = this.jacobianElementB,\n        bi = this.bi,\n        bj = this.bj,\n        xi = bi.position,\n        xj = bj.position;\n    return GA.spatial.dot(xi) + GB.spatial.dot(xj);\n};\n\nvar zero = new Vec3();\n\n/**\n * Computes G*W, where W are the body velocities\n * @method computeGW\n * @return {Number}\n */\nEquation.prototype.computeGW = function(){\n    var GA = this.jacobianElementA,\n        GB = this.jacobianElementB,\n        bi = this.bi,\n        bj = this.bj,\n        vi = bi.velocity,\n        vj = bj.velocity,\n        wi = bi.angularVelocity || zero,\n        wj = bj.angularVelocity || zero;\n    return GA.multiplyVectors(vi,wi) + GB.multiplyVectors(vj,wj);\n};\n\n\n/**\n * Computes G*Wlambda, where W are the body velocities\n * @method computeGWlambda\n * @return {Number}\n */\nEquation.prototype.computeGWlambda = function(){\n    var GA = this.jacobianElementA,\n        GB = this.jacobianElementB,\n        bi = this.bi,\n        bj = this.bj,\n        vi = bi.vlambda,\n        vj = bj.vlambda,\n        wi = bi.wlambda || zero,\n        wj = bj.wlambda || zero;\n    return GA.multiplyVectors(vi,wi) + GB.multiplyVectors(vj,wj);\n};\n\n/**\n * Computes G*inv(M)*f, where M is the mass matrix with diagonal blocks for each body, and f are the forces on the bodies.\n * @method computeGiMf\n * @return {Number}\n */\nvar iMfi = new Vec3(),\n    iMfj = new Vec3(),\n    invIi_vmult_taui = new Vec3(),\n    invIj_vmult_tauj = new Vec3();\nEquation.prototype.computeGiMf = function(){\n    var GA = this.jacobianElementA,\n        GB = this.jacobianElementB,\n        bi = this.bi,\n        bj = this.bj,\n        fi = bi.force,\n        ti = bi.tau,\n        fj = bj.force,\n        tj = bj.tau,\n        invMassi = bi.invMassSolve,\n        invMassj = bj.invMassSolve;\n\n    if(bi.invInertiaWorldSolve){ bi.invInertiaWorldSolve.vmult(ti,invIi_vmult_taui); }\n    else { invIi_vmult_taui.set(0,0,0); }\n    if(bj.invInertiaWorldSolve){ bj.invInertiaWorldSolve.vmult(tj,invIj_vmult_tauj); }\n    else { invIj_vmult_tauj.set(0,0,0); }\n\n    fi.mult(invMassi,iMfi);\n    fj.mult(invMassj,iMfj);\n\n    return GA.multiplyVectors(iMfi,invIi_vmult_taui) + GB.multiplyVectors(iMfj,invIj_vmult_tauj);\n};\n\n/**\n * Computes G*inv(M)*G'\n * @method computeGiMGt\n * @return {Number}\n */\nvar tmp = new Vec3();\nEquation.prototype.computeGiMGt = function(){\n    var GA = this.jacobianElementA,\n        GB = this.jacobianElementB,\n        bi = this.bi,\n        bj = this.bj,\n        invMassi = bi.invMassSolve,\n        invMassj = bj.invMassSolve,\n        invIi = bi.invInertiaWorldSolve,\n        invIj = bj.invInertiaWorldSolve,\n        result = invMassi + invMassj;\n\n    if(invIi){\n        invIi.vmult(GA.rotational,tmp);\n        result += tmp.dot(GA.rotational);\n    }\n\n    if(invIj){\n        invIj.vmult(GB.rotational,tmp);\n        result += tmp.dot(GB.rotational);\n    }\n\n    return  result;\n};\n\nvar addToWlambda_temp = new Vec3(),\n    addToWlambda_Gi = new Vec3(),\n    addToWlambda_Gj = new Vec3(),\n    addToWlambda_ri = new Vec3(),\n    addToWlambda_rj = new Vec3(),\n    addToWlambda_Mdiag = new Vec3();\n\n/**\n * Add constraint velocity to the bodies.\n * @method addToWlambda\n * @param {Number} deltalambda\n */\nEquation.prototype.addToWlambda = function(deltalambda){\n    var GA = this.jacobianElementA,\n        GB = this.jacobianElementB,\n        bi = this.bi,\n        bj = this.bj,\n        temp = addToWlambda_temp;\n\n    // Add to linear velocity\n    // v_lambda += inv(M) * delta_lamba * G\n    GA.spatial.mult(bi.invMassSolve * deltalambda,temp);\n    bi.vlambda.vadd(temp, bi.vlambda);\n\n    GB.spatial.mult(bj.invMassSolve * deltalambda,temp);\n    bj.vlambda.vadd(temp, bj.vlambda);\n\n    // Add to angular velocity\n    if(bi.invInertiaWorldSolve){\n        bi.invInertiaWorldSolve.vmult(GA.rotational,temp);\n        temp.mult(deltalambda,temp);\n        bi.wlambda.vadd(temp,bi.wlambda);\n    }\n\n    if(bj.invInertiaWorldSolve){\n        bj.invInertiaWorldSolve.vmult(GB.rotational,temp);\n        temp.mult(deltalambda,temp);\n        bj.wlambda.vadd(temp,bj.wlambda);\n    }\n};\n\n/**\n * Compute the denominator part of the SPOOK equation: C = G*inv(M)*G' + eps\n * @method computeInvC\n * @param  {Number} eps\n * @return {Number}\n */\nEquation.prototype.computeC = function(){\n    return this.computeGiMGt() + this.eps;\n};\n\n},{\"../math/JacobianElement\":23,\"../math/Vec3\":27}],18:[function(_dereq_,module,exports){\nmodule.exports = FrictionEquation;\n\nvar Equation = _dereq_('./Equation');\nvar Vec3 = _dereq_('../math/Vec3');\nvar Mat3 = _dereq_('../math/Mat3');\n\n/**\n * Constrains the slipping in a contact along a tangent\n * @class FrictionEquation\n * @constructor\n * @author schteppe\n * @param {Body} bi\n * @param {Body} bj\n * @param {Number} slipForce should be +-F_friction = +-mu * F_normal = +-mu * m * g\n * @extends Equation\n */\nfunction FrictionEquation(bi,bj,slipForce){\n    Equation.call(this,bi,bj,-slipForce,slipForce);\n    this.ri = new Vec3();\n    this.rj = new Vec3();\n    this.t = new Vec3(); // tangent\n\n\n    // The following is just cache\n    this.rixt = new Vec3();\n    this.rjxt = new Vec3();\n    this.wixri = new Vec3();\n    this.wjxrj = new Vec3();\n\n    this.invIi = new Mat3();\n    this.invIj = new Mat3();\n\n    this.relVel = new Vec3();\n    this.relForce = new Vec3();\n\n    this.biInvInertiaTimesRixt =  new Vec3();\n    this.bjInvInertiaTimesRjxt =  new Vec3();\n}\n\nFrictionEquation.prototype = new Equation();\nFrictionEquation.prototype.constructor = FrictionEquation;\n\nvar FrictionEquation_computeB_temp1 = new Vec3();\nvar FrictionEquation_computeB_temp2 = new Vec3();\nvar FrictionEquation_computeB_zero = new Vec3();\nFrictionEquation.prototype.computeB = function(h){\n    var a = this.a,\n        b = this.b,\n        bi = this.bi,\n        bj = this.bj,\n        ri = this.ri,\n        rj = this.rj,\n        rixt = this.rixt,\n        rjxt = this.rjxt,\n        wixri = this.wixri,\n        wjxrj = this.wjxrj,\n        zero = FrictionEquation_computeB_zero;\n\n    var vi = bi.velocity,\n        wi = bi.angularVelocity ? bi.angularVelocity : zero,\n        fi = bi.force,\n        taui = bi.tau ? bi.tau : zero,\n\n        vj = bj.velocity,\n        wj = bj.angularVelocity ? bj.angularVelocity : zero,\n        fj = bj.force,\n        tauj = bj.tau ? bj.tau : zero,\n\n        relVel = this.relVel,\n        relForce = this.relForce,\n        invMassi = bi.invMass,\n        invMassj = bj.invMass,\n\n        invIi = this.invIi,\n        invIj = this.invIj,\n\n        t = this.t,\n\n        invIi_vmult_taui = FrictionEquation_computeB_temp1,\n        invIj_vmult_tauj = FrictionEquation_computeB_temp2;\n\n    // Caluclate cross products\n    ri.cross(t,rixt);\n    rj.cross(t,rjxt);\n\n    wi.cross(ri,wixri);\n    wj.cross(rj,wjxrj);\n\n    // G = [-t -rixt t rjxt]\n    // And remember, this is a pure velocity constraint, g is always zero!\n    var GA = this.jacobianElementA,\n        GB = this.jacobianElementB;\n    t.negate(GA.spatial);\n    rixt.negate(GA.rotational);\n    GB.spatial.copy(t);\n    GB.rotational.copy(rjxt);\n\n    if(bi.invInertiaWorld){ bi.invInertiaWorld.vmult(taui,invIi_vmult_taui); }\n    else { invIi_vmult_taui.set(0,0,0); }\n    if(bj.invInertiaWorld){ bj.invInertiaWorld.vmult(tauj,invIj_vmult_tauj); }\n    else { invIj_vmult_tauj.set(0,0,0); }\n\n    var GW = this.computeGW();//vj.dot(t) - vi.dot(t) + wjxrj.dot(t) - wixri.dot(t), // eq. 40\n    var GiMf = this.computeGiMf();//fj.dot(t)*invMassj - fi.dot(t)*invMassi + rjxt.dot(invIj_vmult_tauj) - rixt.dot(invIi_vmult_taui);\n\n    // we do only want to constrain velocity, so g=0\n    var B = - GW * b - h*GiMf;\n\n    return B;\n};\n\n/*\n// Compute C = G * Minv * G + eps\n//var FEcomputeC_temp1 = new Vec3();\n//var FEcomputeC_temp2 = new Vec3();\nFrictionEquation.prototype.computeC = function(){\n    var bi = this.bi,\n        bj = this.bj,\n        rixt = this.rixt,\n        rjxt = this.rjxt,\n        invMassi = bi.invMass,\n        invMassj = bj.invMass,\n        C = invMassi + invMassj + this.eps,\n        invIi = this.invIi,\n        invIj = this.invIj;\n\n    // Compute rxt * I * rxt for each body\n    if(bi.invInertiaWorld) bi.invInertiaWorld.vmult(rixt,this.biInvInertiaTimesRixt);\n    if(bj.invInertiaWorld) bj.invInertiaWorld.vmult(rjxt,this.bjInvInertiaTimesRjxt);\n    C += this.biInvInertiaTimesRixt.dot(rixt);\n    C += this.bjInvInertiaTimesRjxt.dot(rjxt);\n\n    return C;\n};\n\nvar FrictionEquation_computeGWlambda_ulambda = new Vec3();\nFrictionEquation.prototype.computeGWlambda = function(){\n    var bi = this.bi;\n    var bj = this.bj;\n\n    var GWlambda = 0.0;\n    var ulambda = FrictionEquation_computeGWlambda_ulambda;\n    bj.vlambda.vsub(bi.vlambda,ulambda);\n    GWlambda += ulambda.dot(this.t);\n\n    // Angular\n    if(bi.wlambda){\n        GWlambda -= bi.wlambda.dot(this.rixt);\n    }\n    if(bj.wlambda){\n        GWlambda += bj.wlambda.dot(this.rjxt);\n    }\n\n    return GWlambda;\n};\n\nvar FrictionEquation_addToWlambda_tmp = new Vec3();\nFrictionEquation.prototype.addToWlambda = function(deltalambda){\n    var bi = this.bi,\n        bj = this.bj,\n        rixt = this.rixt,\n        rjxt = this.rjxt,\n        invMassi = bi.invMass,\n        invMassj = bj.invMass,\n        t = this.t,\n        tmp = FrictionEquation_addToWlambda_tmp,\n        wi = bi.wlambda,\n        wj = bj.wlambda;\n\n    // Add to linear velocity\n    t.mult(invMassi * deltalambda, tmp);\n    bi.vlambda.vsub(tmp,bi.vlambda);\n\n    t.mult(invMassj * deltalambda, tmp);\n    bj.vlambda.vadd(tmp,bj.vlambda);\n\n    // Add to angular velocity\n    if(wi){\n        this.biInvInertiaTimesRixt.mult(deltalambda,tmp);\n        wi.vsub(tmp,wi);\n    }\n    if(wj){\n        this.bjInvInertiaTimesRjxt.mult(deltalambda,tmp);\n        wj.vadd(tmp,wj);\n    }\n};\n*/\n\n},{\"../math/Mat3\":24,\"../math/Vec3\":27,\"./Equation\":17}],19:[function(_dereq_,module,exports){\nmodule.exports = RotationalEquation;\n\nvar Vec3 = _dereq_('../math/Vec3');\nvar Mat3 = _dereq_('../math/Mat3');\nvar Equation = _dereq_('./Equation');\n\n/**\n * Rotational constraint. Works to keep the local vectors orthogonal to each other.\n * @class RotationalEquation\n * @constructor\n * @author schteppe\n * @param {RigidBody} bj\n * @param {Vec3} localVectorInBodyA\n * @param {RigidBody} bi\n * @param {Vec3} localVectorInBodyB\n * @extends Equation\n */\nfunction RotationalEquation(bodyA, bodyB){\n    Equation.call(this,bodyA,bodyB,-1e6,1e6);\n    this.ni = new Vec3(); // World oriented localVectorInBodyA\n    this.nj = new Vec3(); // ...and B\n\n    this.nixnj = new Vec3();\n    this.njxni = new Vec3();\n\n    this.invIi = new Mat3();\n    this.invIj = new Mat3();\n\n    this.relVel = new Vec3();\n    this.relForce = new Vec3();\n}\n\nRotationalEquation.prototype = new Equation();\nRotationalEquation.prototype.constructor = RotationalEquation;\n\nvar zero = new Vec3();\n\nRotationalEquation.prototype.computeB = function(h){\n    var a = this.a,\n        b = this.b,\n        bi = this.bi,\n        bj = this.bj,\n\n        ni = this.ni,\n        nj = this.nj,\n\n        nixnj = this.nixnj,\n        njxni = this.njxni,\n\n        vi = bi.velocity,\n        wi = bi.angularVelocity ? bi.angularVelocity : zero,\n        fi = bi.force,\n        taui = bi.tau ? bi.tau : zero,\n\n        vj = bj.velocity,\n        wj = bj.angularVelocity ? bj.angularVelocity : zero,\n        fj = bj.force,\n        tauj = bj.tau ? bj.tau : zero,\n\n        invMassi = bi.invMass,\n        invMassj = bj.invMass,\n\n        GA = this.jacobianElementA,\n        GB = this.jacobianElementB,\n\n        invIi = this.invIi,\n        invIj = this.invIj;\n\n    // Caluclate cross products\n    ni.cross(nj,nixnj);\n    nj.cross(ni,njxni);\n\n    // g = ni * nj\n    // gdot = (nj x ni) * wi + (ni x nj) * wj\n    // G = [0 njxni 0 nixnj]\n    // W = [vi wi vj wj]\n    GA.rotational.copy(njxni);\n    GB.rotational.copy(nixnj);\n\n    var g = -ni.dot(nj),\n        GW = this.computeGW(),//njxni.dot(wi) + nixnj.dot(wj),\n        GiMf = this.computeGiMf();//njxni.dot(invIi.vmult(taui)) + nixnj.dot(invIj.vmult(tauj));\n\n    var B = - g * a - GW * b - h*GiMf;\n\n    return B;\n};\n\n/*\n// Compute C = GMG+eps\nRotationalEquation.prototype.computeC = function(){\n    var bi = this.bi;\n    var bj = this.bj;\n    var nixnj = this.nixnj;\n    var njxni = this.njxni;\n    var invMassi = bi.invMass;\n    var invMassj = bj.invMass;\n\n    var C = this.eps;\n\n\n    C += bi.invInertiaWorld.vmult(njxni).dot(njxni);\n    C += bj.invInertiaWorld.vmult(nixnj).dot(nixnj);\n\n    return C;\n};\n\nvar computeGWlambda_ulambda = new Vec3();\nRotationalEquation.prototype.computeGWlambda = function(){\n    var bi = this.bi;\n    var bj = this.bj;\n    var ulambda = computeGWlambda_ulambda;\n\n    var GWlambda = 0.0;\n    //bj.vlambda.vsub(bi.vlambda, ulambda);\n    //GWlambda += ulambda.dot(this.ni);\n\n    // Angular\n    if(bi.wlambda){\n        GWlambda += bi.wlambda.dot(this.njxni);\n    }\n    if(bj.wlambda){\n        GWlambda += bj.wlambda.dot(this.nixnj);\n    }\n\n    //console.log(\"GWlambda:\",GWlambda);\n\n    return GWlambda;\n};\n\nRotationalEquation.prototype.addToWlambda = function(deltalambda){\n    var bi = this.bi;\n    var bj = this.bj;\n    var nixnj = this.nixnj;\n    var njxni = this.njxni;\n    var invMassi = bi.invMass;\n    var invMassj = bj.invMass;\n\n    // Add to linear velocity\n    //bi.vlambda.vsub(n.mult(invMassi * deltalambda),bi.vlambda);\n    //bj.vlambda.vadd(n.mult(invMassj * deltalambda),bj.vlambda);\n\n    // Add to angular velocity\n    if(bi.wlambda){\n        var I = bi.invInertiaWorld;\n        bi.wlambda.vsub(I.vmult(nixnj).mult(deltalambda),bi.wlambda);\n    }\n    if(bj.wlambda){\n        var I = bj.invInertiaWorld;\n        bj.wlambda.vadd(I.vmult(nixnj).mult(deltalambda),bj.wlambda);\n    }\n};\n*/\n\n},{\"../math/Mat3\":24,\"../math/Vec3\":27,\"./Equation\":17}],20:[function(_dereq_,module,exports){\nmodule.exports = RotationalMotorEquation;\n\nvar Vec3 = _dereq_('../math/Vec3');\nvar Mat3 = _dereq_('../math/Mat3');\nvar Equation = _dereq_('./Equation');\n\n/**\n * Rotational motor constraint. Works to keep the relative angular velocity of the bodies to a given value\n * @class RotationalMotorEquation\n * @constructor\n * @author schteppe\n * @param {RigidBody} bodyA\n * @param {RigidBody} bodyB\n * @param {Number} maxForce\n * @extends Equation\n */\nfunction RotationalMotorEquation(bodyA, bodyB, maxForce){\n    maxForce = maxForce || 1e6;\n    Equation.call(this,bodyA,bodyB,-maxForce,maxForce);\n    this.axisA = new Vec3(); // World oriented rotational axis\n    this.axisB = new Vec3(); // World oriented rotational axis\n\n    this.invIi = new Mat3();\n    this.invIj = new Mat3();\n\n    /**\n     * Motor velocity\n     * @property {Number} targetVelocity\n     */\n    this.targetVelocity = 0;\n}\n\nRotationalMotorEquation.prototype = new Equation();\nRotationalMotorEquation.prototype.constructor = RotationalMotorEquation;\n\nvar zero = new Vec3();\n\nRotationalMotorEquation.prototype.computeB = function(h){\n    var a = this.a,\n        b = this.b,\n        bi = this.bi,\n        bj = this.bj,\n\n        axisA = this.axisA,\n        axisB = this.axisB,\n\n        vi = bi.velocity,\n        wi = bi.angularVelocity ? bi.angularVelocity : zero,\n        fi = bi.force,\n        taui = bi.tau ? bi.tau : zero,\n\n        vj = bj.velocity,\n        wj = bj.angularVelocity ? bj.angularVelocity : zero,\n        fj = bj.force,\n        tauj = bj.tau ? bj.tau : zero,\n\n        GA = this.jacobianElementA,\n        GB = this.jacobianElementB,\n\n        invMassi = bi.invMass,\n        invMassj = bj.invMass;\n\n    // g = 0\n    // gdot = axisA * wi - axisB * wj\n    // G = [0 axisA 0 -axisB]\n    // W = [vi wi vj wj]\n\n    GA.rotational.copy(axisA);\n    axisB.negate(GB.rotational);\n\n    var GW = this.computeGW() - this.targetVelocity,\n        GiMf = this.computeGiMf();//axis.dot(invIi.vmult(taui)) + axis.dot(invIj.vmult(tauj));\n\n    var B = - GW * b - h*GiMf;\n\n    return B;\n};\n\n/*\n// Compute C = GMG+eps\nRotationalMotorEquation.prototype.computeC = function(){\n    var bi = this.bi;\n    var bj = this.bj;\n    var axisA = this.axisA;\n    var axisB = this.axisB;\n    var invMassi = bi.invMass;\n    var invMassj = bj.invMass;\n\n    var C = this.eps;\n\n    C += bi.invInertiaWorld.vmult(axisA).dot(axisB);\n    C += bj.invInertiaWorld.vmult(axisB).dot(axisB);\n\n    return C;\n};\n\nvar computeGWlambda_ulambda = new Vec3();\nRotationalMotorEquation.prototype.computeGWlambda = function(){\n    var bi = this.bi;\n    var bj = this.bj;\n    var ulambda = computeGWlambda_ulambda;\n    var axisA = this.axisA;\n    var axisB = this.axisB;\n\n    var GWlambda = 0.0;\n    //bj.vlambda.vsub(bi.vlambda, ulambda);\n    //GWlambda += ulambda.dot(this.ni);\n\n    // Angular\n    if(bi.wlambda){\n        GWlambda += bi.wlambda.dot(axisA);\n    }\n    if(bj.wlambda){\n        GWlambda += bj.wlambda.dot(axisB);\n    }\n\n    //console.log(\"GWlambda:\",GWlambda);\n\n    return GWlambda;\n};\n\nRotationalMotorEquation.prototype.addToWlambda = function(deltalambda){\n    var bi = this.bi;\n    var bj = this.bj;\n    var axisA = this.axisA;\n    var axisB = this.axisB;\n    var invMassi = bi.invMass;\n    var invMassj = bj.invMass;\n\n    // Add to linear velocity\n    //bi.vlambda.vsub(n.mult(invMassi * deltalambda),bi.vlambda);\n    //bj.vlambda.vadd(n.mult(invMassj * deltalambda),bj.vlambda);\n\n    // Add to angular velocity\n    if(bi.wlambda){\n        var I = bi.invInertiaWorld;\n        bi.wlambda.vsub(I.vmult(axisA).mult(deltalambda),bi.wlambda);\n    }\n    if(bj.wlambda){\n        var I = bj.invInertiaWorld;\n        bj.wlambda.vadd(I.vmult(axisB).mult(deltalambda),bj.wlambda);\n    }\n};\n*/\n\n},{\"../math/Mat3\":24,\"../math/Vec3\":27,\"./Equation\":17}],21:[function(_dereq_,module,exports){\nvar Utils = _dereq_('../utils/Utils');\n\nmodule.exports = ContactMaterial;\n\n/**\n * Defines what happens when two materials meet.\n * @class ContactMaterial\n * @constructor\n * @param {Material} m1\n * @param {Material} m2\n * @param {Number} friction\n * @param {Number} restitution\n */\nfunction ContactMaterial(m1, m2, options){\n    options = Utils.defaults(options, {\n        friction: 0.3,\n        restitution: 0.3,\n        contactEquationStiffness: 1e7,\n        contactEquationRelaxation: 3,\n        frictionEquationStiffness: 1e7,\n        frictionEquationRelaxation: 3\n    });\n\n    /**\n     * Identifier of this material\n     * @property {Number} id\n     */\n    this.id = ContactMaterial.idCounter++;\n\n    /**\n     * Participating materials\n     * @property {Array} materials\n     * @todo  Should be .materialA and .materialB instead\n     */\n    this.materials = [m1, m2];\n\n    /**\n     * Friction coefficient\n     * @property {Number} friction\n     */\n    this.friction = options.friction;\n\n    /**\n     * Restitution coefficient\n     * @property {Number} restitution\n     */\n    this.restitution = options.restitution;\n\n    /**\n     * Stiffness of the produced contact equations\n     * @property {Number} contactEquationStiffness\n     */\n    this.contactEquationStiffness = options.contactEquationStiffness;\n\n    /**\n     * Relaxation time of the produced contact equations\n     * @property {Number} contactEquationRelaxation\n     */\n    this.contactEquationRelaxation = options.contactEquationRelaxation;\n\n    /**\n     * Stiffness of the produced friction equations\n     * @property {Number} frictionEquationStiffness\n     */\n    this.frictionEquationStiffness = options.frictionEquationStiffness;\n\n    /**\n     * Relaxation time of the produced friction equations\n     * @property {Number} frictionEquationRelaxation\n     */\n    this.frictionEquationRelaxation = options.frictionEquationRelaxation;\n}\n\nContactMaterial.idCounter = 0;\n\n},{\"../utils/Utils\":48}],22:[function(_dereq_,module,exports){\nmodule.exports = Material;\n\n/**\n * Defines a physics material.\n * @class Material\n * @constructor\n * @param {String} name\n * @author schteppe\n */\nfunction Material(name){\n    /**\n     * @property name\n     * @type {String}\n     */\n    this.name = name;\n    this.id = Material.idCounter++;\n}\n\nMaterial.idCounter = 0;\n\n},{}],23:[function(_dereq_,module,exports){\nmodule.exports = JacobianElement;\n\nvar Vec3 = _dereq_('./Vec3');\n\n/**\n * An element containing 6 entries, 3 spatial and 3 rotational degrees of freedom.\n * @class JacobianElement\n * @constructor\n */\nfunction JacobianElement(){\n\n    /**\n     * @property {Vec3} spatial\n     */\n    this.spatial = new Vec3();\n\n    /**\n     * @property {Vec3} rotational\n     */\n    this.rotational = new Vec3();\n}\n\n/**\n * Multiply with other JacobianElement\n * @method multiplyElement\n * @param  {JacobianElement} element\n * @return {Number}\n */\nJacobianElement.prototype.multiplyElement = function(element){\n    return element.spatial.dot(this.spatial) + element.rotational.dot(this.rotational);\n};\n\n/**\n * Multiply with two vectors\n * @method multiplyVectors\n * @param  {Vec3} spatial\n * @param  {Vec3} rotational\n * @return {Number}\n */\nJacobianElement.prototype.multiplyVectors = function(spatial,rotational){\n    return spatial.dot(this.spatial) + rotational.dot(this.rotational);\n};\n\n},{\"./Vec3\":27}],24:[function(_dereq_,module,exports){\nmodule.exports = Mat3;\n\nvar Vec3 = _dereq_('./Vec3');\n\n/**\n * A 3x3 matrix.\n * @class Mat3\n * @constructor\n * @param array elements Array of nine elements. Optional.\n * @author schteppe / http://github.com/schteppe\n */\nfunction Mat3(elements){\n    /**\n     * A vector of length 9, containing all matrix elements\n     * @property {Array} elements\n     */\n    if(elements){\n        this.elements = elements;\n    } else {\n        this.elements = [0,0,0,0,0,0,0,0,0];\n    }\n}\n\n/**\n * Sets the matrix to identity\n * @method identity\n * @todo Should perhaps be renamed to setIdentity() to be more clear.\n * @todo Create another function that immediately creates an identity matrix eg. eye()\n */\nMat3.prototype.identity = function(){\n    this.elements[0] = 1;\n    this.elements[1] = 0;\n    this.elements[2] = 0;\n\n    this.elements[3] = 0;\n    this.elements[4] = 1;\n    this.elements[5] = 0;\n\n    this.elements[6] = 0;\n    this.elements[7] = 0;\n    this.elements[8] = 1;\n};\n\n/**\n * Set all elements to zero\n * @method setZero\n */\nMat3.prototype.setZero = function(){\n    var e = this.elements;\n    e[0] = 0;\n    e[1] = 0;\n    e[2] = 0;\n    e[3] = 0;\n    e[4] = 0;\n    e[5] = 0;\n    e[6] = 0;\n    e[7] = 0;\n    e[8] = 0;\n};\n\n/**\n * Sets the matrix diagonal elements from a Vec3\n * @method setTrace\n */\nMat3.prototype.setTrace = function(vec3){\n    var e = this.elements;\n    e[0] = vec3.x;\n    e[4] = vec3.y;\n    e[8] = vec3.z;\n};\n\n/**\n * Sets the matrix diagonal elements from a Vec3\n * @method setTrace\n */\nMat3.prototype.getTrace = function(target){\n    var target = target || new Vec3();\n    var e = this.elements;\n    target.x = e[0];\n    target.y = e[4];\n    target.z = e[8];\n};\n\n/**\n * Matrix-Vector multiplication\n * @method vmult\n * @param {Vec3} v The vector to multiply with\n * @param {Vec3} target Optional, target to save the result in.\n */\nMat3.prototype.vmult = function(v,target){\n    target = target || new Vec3();\n\n    var e = this.elements,\n        x = v.x,\n        y = v.y,\n        z = v.z;\n    target.x = e[0]*x + e[1]*y + e[2]*z;\n    target.y = e[3]*x + e[4]*y + e[5]*z;\n    target.z = e[6]*x + e[7]*y + e[8]*z;\n\n    return target;\n};\n\n/**\n * Matrix-scalar multiplication\n * @method smult\n * @param {Number} s\n */\nMat3.prototype.smult = function(s){\n    for(var i=0; i<this.elements.length; i++){\n        this.elements[i] *= s;\n    }\n};\n\n/**\n * Matrix multiplication\n * @method mmult\n * @param {Mat3} m Matrix to multiply with from left side.\n * @return {Mat3} The result.\n */\nMat3.prototype.mmult = function(m,target){\n    var r = target || new Mat3();\n    for(var i=0; i<3; i++){\n        for(var j=0; j<3; j++){\n            var sum = 0.0;\n            for(var k=0; k<3; k++){\n                sum += m.elements[i+k*3] * this.elements[k+j*3];\n            }\n            r.elements[i+j*3] = sum;\n        }\n    }\n    return r;\n};\n\n/**\n * Scale each column of the matrix\n * @method scale\n * @param {Vec3} v\n * @return {Mat3} The result.\n */\nMat3.prototype.scale = function(v,target){\n    target = target || new Mat3();\n    var e = this.elements,\n        t = target.elements;\n    for(var i=0; i!==3; i++){\n        t[3*i + 0] = v.x * e[3*i + 0];\n        t[3*i + 1] = v.y * e[3*i + 1];\n        t[3*i + 2] = v.z * e[3*i + 2];\n    }\n    return target;\n};\n\n/**\n * Solve Ax=b\n * @method solve\n * @param {Vec3} b The right hand side\n * @param {Vec3} target Optional. Target vector to save in.\n * @return {Vec3} The solution x\n * @todo should reuse arrays\n */\nMat3.prototype.solve = function(b,target){\n    target = target || new Vec3();\n\n    // Construct equations\n    var nr = 3; // num rows\n    var nc = 4; // num cols\n    var eqns = [];\n    for(var i=0; i<nr*nc; i++){\n        eqns.push(0);\n    }\n    var i,j;\n    for(i=0; i<3; i++){\n        for(j=0; j<3; j++){\n            eqns[i+nc*j] = this.elements[i+3*j];\n        }\n    }\n    eqns[3+4*0] = b.x;\n    eqns[3+4*1] = b.y;\n    eqns[3+4*2] = b.z;\n\n    // Compute right upper triangular version of the matrix - Gauss elimination\n    var n = 3, k = n, np;\n    var kp = 4; // num rows\n    var p, els;\n    do {\n        i = k - n;\n        if (eqns[i+nc*i] === 0) {\n            // the pivot is null, swap lines\n            for (j = i + 1; j < k; j++) {\n                if (eqns[i+nc*j] !== 0) {\n                    np = kp;\n                    do {  // do ligne( i ) = ligne( i ) + ligne( k )\n                        p = kp - np;\n                        eqns[p+nc*i] += eqns[p+nc*j];\n                    } while (--np);\n                    break;\n                }\n            }\n        }\n        if (eqns[i+nc*i] !== 0) {\n            for (j = i + 1; j < k; j++) {\n                var multiplier = eqns[i+nc*j] / eqns[i+nc*i];\n                np = kp;\n                do {  // do ligne( k ) = ligne( k ) - multiplier * ligne( i )\n                    p = kp - np;\n                    eqns[p+nc*j] = p <= i ? 0 : eqns[p+nc*j] - eqns[p+nc*i] * multiplier ;\n                } while (--np);\n            }\n        }\n    } while (--n);\n\n    // Get the solution\n    target.z = eqns[2*nc+3] / eqns[2*nc+2];\n    target.y = (eqns[1*nc+3] - eqns[1*nc+2]*target.z) / eqns[1*nc+1];\n    target.x = (eqns[0*nc+3] - eqns[0*nc+2]*target.z - eqns[0*nc+1]*target.y) / eqns[0*nc+0];\n\n    if(isNaN(target.x) || isNaN(target.y) || isNaN(target.z) || target.x===Infinity || target.y===Infinity || target.z===Infinity){\n        throw \"Could not solve equation! Got x=[\"+target.toString()+\"], b=[\"+b.toString()+\"], A=[\"+this.toString()+\"]\";\n    }\n\n    return target;\n};\n\n/**\n * Get an element in the matrix by index. Index starts at 0, not 1!!!\n * @method e\n * @param {Number} row\n * @param {Number} column\n * @param {Number} value Optional. If provided, the matrix element will be set to this value.\n * @return {Number}\n */\nMat3.prototype.e = function( row , column ,value){\n    if(value===undefined){\n        return this.elements[column+3*row];\n    } else {\n        // Set value\n        this.elements[column+3*row] = value;\n    }\n};\n\n/**\n * Copy another matrix into this matrix object.\n * @method copy\n * @param {Mat3} source\n * @return {Mat3} this\n */\nMat3.prototype.copy = function(source){\n    for(var i=0; i < source.elements.length; i++){\n        this.elements[i] = source.elements[i];\n    }\n    return this;\n};\n\n/**\n * Returns a string representation of the matrix.\n * @method toString\n * @return string\n */\nMat3.prototype.toString = function(){\n    var r = \"\";\n    var sep = \",\";\n    for(var i=0; i<9; i++){\n        r += this.elements[i] + sep;\n    }\n    return r;\n};\n\n/**\n * reverse the matrix\n * @method reverse\n * @param {Mat3} target Optional. Target matrix to save in.\n * @return {Mat3} The solution x\n */\nMat3.prototype.reverse = function(target){\n\n    target = target || new Mat3();\n\n    // Construct equations\n    var nr = 3; // num rows\n    var nc = 6; // num cols\n    var eqns = [];\n    for(var i=0; i<nr*nc; i++){\n        eqns.push(0);\n    }\n    var i,j;\n    for(i=0; i<3; i++){\n        for(j=0; j<3; j++){\n            eqns[i+nc*j] = this.elements[i+3*j];\n        }\n    }\n    eqns[3+6*0] = 1;\n    eqns[3+6*1] = 0;\n    eqns[3+6*2] = 0;\n    eqns[4+6*0] = 0;\n    eqns[4+6*1] = 1;\n    eqns[4+6*2] = 0;\n    eqns[5+6*0] = 0;\n    eqns[5+6*1] = 0;\n    eqns[5+6*2] = 1;\n\n    // Compute right upper triangular version of the matrix - Gauss elimination\n    var n = 3, k = n, np;\n    var kp = nc; // num rows\n    var p;\n    do {\n        i = k - n;\n        if (eqns[i+nc*i] === 0) {\n            // the pivot is null, swap lines\n            for (j = i + 1; j < k; j++) {\n                if (eqns[i+nc*j] !== 0) {\n                    np = kp;\n                    do { // do line( i ) = line( i ) + line( k )\n                        p = kp - np;\n                        eqns[p+nc*i] += eqns[p+nc*j];\n                    } while (--np);\n                    break;\n                }\n            }\n        }\n        if (eqns[i+nc*i] !== 0) {\n            for (j = i + 1; j < k; j++) {\n                var multiplier = eqns[i+nc*j] / eqns[i+nc*i];\n                np = kp;\n                do { // do line( k ) = line( k ) - multiplier * line( i )\n                    p = kp - np;\n                    eqns[p+nc*j] = p <= i ? 0 : eqns[p+nc*j] - eqns[p+nc*i] * multiplier ;\n                } while (--np);\n            }\n        }\n    } while (--n);\n\n    // eliminate the upper left triangle of the matrix\n    i = 2;\n    do {\n        j = i-1;\n        do {\n            var multiplier = eqns[i+nc*j] / eqns[i+nc*i];\n            np = nc;\n            do {\n                p = nc - np;\n                eqns[p+nc*j] =  eqns[p+nc*j] - eqns[p+nc*i] * multiplier ;\n            } while (--np);\n        } while (j--);\n    } while (--i);\n\n    // operations on the diagonal\n    i = 2;\n    do {\n        var multiplier = 1 / eqns[i+nc*i];\n        np = nc;\n        do {\n            p = nc - np;\n            eqns[p+nc*i] = eqns[p+nc*i] * multiplier ;\n        } while (--np);\n    } while (i--);\n\n    i = 2;\n    do {\n        j = 2;\n        do {\n            p = eqns[nr+j+nc*i];\n            if( isNaN( p ) || p ===Infinity ){\n                throw \"Could not reverse! A=[\"+this.toString()+\"]\";\n            }\n            target.e( i , j , p );\n        } while (j--);\n    } while (i--);\n\n    return target;\n};\n\n/**\n * Set the matrix from a quaterion\n * @method setRotationFromQuaternion\n * @param {Quaternion} q\n */\nMat3.prototype.setRotationFromQuaternion = function( q ) {\n    var x = q.x, y = q.y, z = q.z, w = q.w,\n        x2 = x + x, y2 = y + y, z2 = z + z,\n        xx = x * x2, xy = x * y2, xz = x * z2,\n        yy = y * y2, yz = y * z2, zz = z * z2,\n        wx = w * x2, wy = w * y2, wz = w * z2,\n        e = this.elements;\n\n    e[3*0 + 0] = 1 - ( yy + zz );\n    e[3*0 + 1] = xy - wz;\n    e[3*0 + 2] = xz + wy;\n\n    e[3*1 + 0] = xy + wz;\n    e[3*1 + 1] = 1 - ( xx + zz );\n    e[3*1 + 2] = yz - wx;\n\n    e[3*2 + 0] = xz - wy;\n    e[3*2 + 1] = yz + wx;\n    e[3*2 + 2] = 1 - ( xx + yy );\n\n    return this;\n};\n\n/**\n * Transpose the matrix\n * @method transpose\n * @param  {Mat3} target Where to store the result.\n * @return {Mat3} The target Mat3, or a new Mat3 if target was omitted.\n */\nMat3.prototype.transpose = function( target ) {\n    target = target || new Mat3();\n\n    var Mt = target.elements,\n        M = this.elements;\n\n    for(var i=0; i!==3; i++){\n        for(var j=0; j!==3; j++){\n            Mt[3*i + j] = M[3*j + i];\n        }\n    }\n\n    return target;\n};\n\n},{\"./Vec3\":27}],25:[function(_dereq_,module,exports){\nmodule.exports = Quaternion;\n\nvar Vec3 = _dereq_('./Vec3');\n\n/**\n * A Quaternion describes a rotation in 3D space. The Quaternion is mathematically defined as Q = x*i + y*j + z*k + w, where (i,j,k) are imaginary basis vectors. (x,y,z) can be seen as a vector related to the axis of rotation, while the real multiplier, w, is related to the amount of rotation.\n * @class Quaternion\n * @constructor\n * @param {Number} x Multiplier of the imaginary basis vector i.\n * @param {Number} y Multiplier of the imaginary basis vector j.\n * @param {Number} z Multiplier of the imaginary basis vector k.\n * @param {Number} w Multiplier of the real part.\n * @see http://en.wikipedia.org/wiki/Quaternion\n */\nfunction Quaternion(x,y,z,w){\n    /**\n     * @property {Number} x\n     */\n    this.x = x!==undefined ? x : 0;\n\n    /**\n     * @property {Number} y\n     */\n    this.y = y!==undefined ? y : 0;\n\n    /**\n     * @property {Number} z\n     */\n    this.z = z!==undefined ? z : 0;\n\n    /**\n     * The multiplier of the real quaternion basis vector.\n     * @property {Number} w\n     */\n    this.w = w!==undefined ? w : 1;\n}\n\n/**\n * Set the value of the quaternion.\n * @method set\n * @param {Number} x\n * @param {Number} y\n * @param {Number} z\n * @param {Number} w\n */\nQuaternion.prototype.set = function(x,y,z,w){\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n};\n\n/**\n * Convert to a readable format\n * @method toString\n * @return string\n */\nQuaternion.prototype.toString = function(){\n    return this.x+\",\"+this.y+\",\"+this.z+\",\"+this.w;\n};\n\n/**\n * Convert to an Array\n * @method toArray\n * @return Array\n */\nQuaternion.prototype.toArray = function(){\n    return [this.x, this.y, this.z, this.w];\n};\n\n/**\n * Set the quaternion components given an axis and an angle.\n * @method setFromAxisAngle\n * @param {Vec3} axis\n * @param {Number} angle in radians\n */\nQuaternion.prototype.setFromAxisAngle = function(axis,angle){\n    var s = Math.sin(angle*0.5);\n    this.x = axis.x * s;\n    this.y = axis.y * s;\n    this.z = axis.z * s;\n    this.w = Math.cos(angle*0.5);\n};\n\n/**\n * Converts the quaternion to axis/angle representation.\n * @method setFromAxisAngle\n * @param {Vec3} targetAxis Optional. A vector object to reuse for storing the axis.\n * @return Array An array, first elemnt is the axis and the second is the angle in radians.\n */\nQuaternion.prototype.toAxisAngle = function(targetAxis){\n    targetAxis = targetAxis || new Vec3();\n    this.normalize(); // if w>1 acos and sqrt will produce errors, this cant happen if quaternion is normalised\n    var angle = 2 * Math.acos(this.w);\n    var s = Math.sqrt(1-this.w*this.w); // assuming quaternion normalised then w is less than 1, so term always positive.\n    if (s < 0.001) { // test to avoid divide by zero, s is always positive due to sqrt\n        // if s close to zero then direction of axis not important\n        targetAxis.x = this.x; // if it is important that axis is normalised then replace with x=1; y=z=0;\n        targetAxis.y = this.y;\n        targetAxis.z = this.z;\n    } else {\n        targetAxis.x = this.x / s; // normalise axis\n        targetAxis.y = this.y / s;\n        targetAxis.z = this.z / s;\n    }\n    return [targetAxis,angle];\n};\n\nvar sfv_t1 = new Vec3(),\n    sfv_t2 = new Vec3();\n\n/**\n * Set the quaternion value given two vectors. The resulting rotation will be the needed rotation to rotate u to v.\n * @method setFromVectors\n * @param {Vec3} u\n * @param {Vec3} v\n */\nQuaternion.prototype.setFromVectors = function(u,v){\n    if(u.isAntiparallelTo(v)){\n        var t1 = sfv_t1;\n        var t2 = sfv_t2;\n\n        u.tangents(t1,t2);\n        this.setFromAxisAngle(t1,Math.PI);\n    } else {\n        var a = u.cross(v);\n        this.x = a.x;\n        this.y = a.y;\n        this.z = a.z;\n        this.w = Math.sqrt(Math.pow(u.norm(),2) * Math.pow(v.norm(),2)) + u.dot(v);\n        this.normalize();\n    }\n};\n\n/**\n * Quaternion multiplication\n * @method mult\n * @param {Quaternion} q\n * @param {Quaternion} target Optional.\n * @return {Quaternion}\n */\nvar Quaternion_mult_va = new Vec3();\nvar Quaternion_mult_vb = new Vec3();\nvar Quaternion_mult_vaxvb = new Vec3();\nQuaternion.prototype.mult = function(q,target){\n    target = target || new Quaternion();\n    var w = this.w,\n        va = Quaternion_mult_va,\n        vb = Quaternion_mult_vb,\n        vaxvb = Quaternion_mult_vaxvb;\n\n    va.set(this.x,this.y,this.z);\n    vb.set(q.x,q.y,q.z);\n    target.w = w*q.w - va.dot(vb);\n    va.cross(vb,vaxvb);\n\n    target.x = w * vb.x + q.w*va.x + vaxvb.x;\n    target.y = w * vb.y + q.w*va.y + vaxvb.y;\n    target.z = w * vb.z + q.w*va.z + vaxvb.z;\n\n    return target;\n};\n\n/**\n * Get the inverse quaternion rotation.\n * @method inverse\n * @param {Quaternion} target\n * @return {Quaternion}\n */\nQuaternion.prototype.inverse = function(target){\n    var x = this.x, y = this.y, z = this.z, w = this.w;\n    target = target || new Quaternion();\n\n    this.conjugate(target);\n    var inorm2 = 1/(x*x + y*y + z*z + w*w);\n    target.x *= inorm2;\n    target.y *= inorm2;\n    target.z *= inorm2;\n    target.w *= inorm2;\n\n    return target;\n};\n\n/**\n * Get the quaternion conjugate\n * @method conjugate\n * @param {Quaternion} target\n * @return {Quaternion}\n */\nQuaternion.prototype.conjugate = function(target){\n    target = target || new Quaternion();\n\n    target.x = -this.x;\n    target.y = -this.y;\n    target.z = -this.z;\n    target.w = this.w;\n\n    return target;\n};\n\n/**\n * Normalize the quaternion. Note that this changes the values of the quaternion.\n * @method normalize\n */\nQuaternion.prototype.normalize = function(){\n    var l = Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);\n    if ( l === 0 ) {\n        this.x = 0;\n        this.y = 0;\n        this.z = 0;\n        this.w = 0;\n    } else {\n        l = 1 / l;\n        this.x *= l;\n        this.y *= l;\n        this.z *= l;\n        this.w *= l;\n    }\n};\n\n/**\n * Approximation of quaternion normalization. Works best when quat is already almost-normalized.\n * @method normalizeFast\n * @see http://jsperf.com/fast-quaternion-normalization\n * @author unphased, https://github.com/unphased\n */\nQuaternion.prototype.normalizeFast = function () {\n    var f = (3.0-(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w))/2.0;\n    if ( f === 0 ) {\n        this.x = 0;\n        this.y = 0;\n        this.z = 0;\n        this.w = 0;\n    } else {\n        this.x *= f;\n        this.y *= f;\n        this.z *= f;\n        this.w *= f;\n    }\n};\n\n/**\n * Multiply the quaternion by a vector\n * @method vmult\n * @param {Vec3} v\n * @param {Vec3} target Optional\n * @return {Vec3}\n */\nQuaternion.prototype.vmult = function(v,target){\n    target = target || new Vec3();\n\n    var x = v.x,\n        y = v.y,\n        z = v.z;\n\n    var qx = this.x,\n        qy = this.y,\n        qz = this.z,\n        qw = this.w;\n\n    // q*v\n    var ix =  qw * x + qy * z - qz * y,\n    iy =  qw * y + qz * x - qx * z,\n    iz =  qw * z + qx * y - qy * x,\n    iw = -qx * x - qy * y - qz * z;\n\n    target.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n    target.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n    target.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n\n    return target;\n};\n\n/**\n * Copies value of source to this quaternion.\n * @method copy\n * @param {Quaternion} source\n * @return {Quaternion} this\n */\nQuaternion.prototype.copy = function(source){\n    this.x = source.x;\n    this.y = source.y;\n    this.z = source.z;\n    this.w = source.w;\n    return this;\n};\n\n/**\n * Convert the quaternion to euler angle representation. Order: YZX, as this page describes: http://www.euclideanspace.com/maths/standards/index.htm\n * @method toEuler\n * @param {Vec3} target\n * @param string order Three-character string e.g. \"YZX\", which also is default.\n */\nQuaternion.prototype.toEuler = function(target,order){\n    order = order || \"YZX\";\n\n    var heading, attitude, bank;\n    var x = this.x, y = this.y, z = this.z, w = this.w;\n\n    switch(order){\n    case \"YZX\":\n        var test = x*y + z*w;\n        if (test > 0.499) { // singularity at north pole\n            heading = 2 * Math.atan2(x,w);\n            attitude = Math.PI/2;\n            bank = 0;\n        }\n        if (test < -0.499) { // singularity at south pole\n            heading = -2 * Math.atan2(x,w);\n            attitude = - Math.PI/2;\n            bank = 0;\n        }\n        if(isNaN(heading)){\n            var sqx = x*x;\n            var sqy = y*y;\n            var sqz = z*z;\n            heading = Math.atan2(2*y*w - 2*x*z , 1 - 2*sqy - 2*sqz); // Heading\n            attitude = Math.asin(2*test); // attitude\n            bank = Math.atan2(2*x*w - 2*y*z , 1 - 2*sqx - 2*sqz); // bank\n        }\n        break;\n    default:\n        throw new Error(\"Euler order \"+order+\" not supported yet.\");\n    }\n\n    target.y = heading;\n    target.z = attitude;\n    target.x = bank;\n};\n\n/**\n * See http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m\n * @method setFromEuler\n * @param {Number} x\n * @param {Number} y\n * @param {Number} z\n * @param {String} order The order to apply angles: 'XYZ' or 'YXZ' or any other combination\n */\nQuaternion.prototype.setFromEuler = function ( x, y, z, order ) {\n    order = order || \"XYZ\";\n\n    var c1 = Math.cos( x / 2 );\n    var c2 = Math.cos( y / 2 );\n    var c3 = Math.cos( z / 2 );\n    var s1 = Math.sin( x / 2 );\n    var s2 = Math.sin( y / 2 );\n    var s3 = Math.sin( z / 2 );\n\n    if ( order === 'XYZ' ) {\n\n        this.x = s1 * c2 * c3 + c1 * s2 * s3;\n        this.y = c1 * s2 * c3 - s1 * c2 * s3;\n        this.z = c1 * c2 * s3 + s1 * s2 * c3;\n        this.w = c1 * c2 * c3 - s1 * s2 * s3;\n\n    } else if ( order === 'YXZ' ) {\n\n        this.x = s1 * c2 * c3 + c1 * s2 * s3;\n        this.y = c1 * s2 * c3 - s1 * c2 * s3;\n        this.z = c1 * c2 * s3 - s1 * s2 * c3;\n        this.w = c1 * c2 * c3 + s1 * s2 * s3;\n\n    } else if ( order === 'ZXY' ) {\n\n        this.x = s1 * c2 * c3 - c1 * s2 * s3;\n        this.y = c1 * s2 * c3 + s1 * c2 * s3;\n        this.z = c1 * c2 * s3 + s1 * s2 * c3;\n        this.w = c1 * c2 * c3 - s1 * s2 * s3;\n\n    } else if ( order === 'ZYX' ) {\n\n        this.x = s1 * c2 * c3 - c1 * s2 * s3;\n        this.y = c1 * s2 * c3 + s1 * c2 * s3;\n        this.z = c1 * c2 * s3 - s1 * s2 * c3;\n        this.w = c1 * c2 * c3 + s1 * s2 * s3;\n\n    } else if ( order === 'YZX' ) {\n\n        this.x = s1 * c2 * c3 + c1 * s2 * s3;\n        this.y = c1 * s2 * c3 + s1 * c2 * s3;\n        this.z = c1 * c2 * s3 - s1 * s2 * c3;\n        this.w = c1 * c2 * c3 - s1 * s2 * s3;\n\n    } else if ( order === 'XZY' ) {\n\n        this.x = s1 * c2 * c3 - c1 * s2 * s3;\n        this.y = c1 * s2 * c3 - s1 * c2 * s3;\n        this.z = c1 * c2 * s3 + s1 * s2 * c3;\n        this.w = c1 * c2 * c3 + s1 * s2 * s3;\n\n    }\n\n    return this;\n\n};\n\nQuaternion.prototype.clone = function(){\n    return new Quaternion(this.x, this.y, this.z, this.w);\n};\n},{\"./Vec3\":27}],26:[function(_dereq_,module,exports){\nvar Vec3 = _dereq_('./Vec3');\nvar Quaternion = _dereq_('./Quaternion');\n\nmodule.exports = Transform;\n\nfunction Transform() {\n\tthis.position = new Vec3();\n\tthis.quaternion = new Quaternion();\n}\n\nvar tmpQuat = new Quaternion();\nTransform.pointToLocalFrame = function(position, quaternion, worldPoint, result){\n    var result = result || new Vec3();\n    worldPoint.vsub(position, result);\n    quaternion.conjugate(tmpQuat);\n    tmpQuat.vmult(result, result);\n    return result;\n};\n\nTransform.pointToWorldFrame = function(position, quaternion, localPoint, result){\n    var result = result || new Vec3();\n    quaternion.vmult(localPoint, result);\n    result.vadd(position, result);\n    return result;\n};\n\nTransform.prototype.vectorToWorldFrame = function(localVector, result){\n    var result = result || new Vec3();\n    this.quaternion.vmult(localVector, result);\n    return result;\n};\n\nTransform.vectorToLocalFrame = function(position, quaternion, worldVector, result){\n    var result = result || new Vec3();\n    quaternion.w *= -1;\n    quaternion.vmult(worldVector, result);\n    quaternion.w *= -1;\n    return result;\n};\n\n},{\"./Quaternion\":25,\"./Vec3\":27}],27:[function(_dereq_,module,exports){\nmodule.exports = Vec3;\n\nvar Mat3 = _dereq_('./Mat3');\n\n/**\n * 3-dimensional vector\n * @class Vec3\n * @constructor\n * @param {Number} x\n * @param {Number} y\n * @param {Number} z\n * @author schteppe\n * @example\n *     var v = new Vec3(1, 2, 3);\n *     console.log('x=' + v.x); // x=1\n */\nfunction Vec3(x,y,z){\n    /**\n     * @property x\n     * @type {Number}\n     */\n    this.x = x||0.0;\n\n    /**\n     * @property y\n     * @type {Number}\n     */\n    this.y = y||0.0;\n\n    /**\n     * @property z\n     * @type {Number}\n     */\n    this.z = z||0.0;\n}\n\nVec3.ZERO = new Vec3(0, 0, 0);\n\n/**\n * Vector cross product\n * @method cross\n * @param {Vec3} v\n * @param {Vec3} target Optional. Target to save in.\n * @return {Vec3}\n */\nVec3.prototype.cross = function(v,target){\n    var vx=v.x, vy=v.y, vz=v.z, x=this.x, y=this.y, z=this.z;\n    target = target || new Vec3();\n\n    target.x = (y * vz) - (z * vy);\n    target.y = (z * vx) - (x * vz);\n    target.z = (x * vy) - (y * vx);\n\n    return target;\n};\n\n/**\n * Set the vectors' 3 elements\n * @method set\n * @param {Number} x\n * @param {Number} y\n * @param {Number} z\n * @return Vec3\n */\nVec3.prototype.set = function(x,y,z){\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    return this;\n};\n\n/**\n * Set all components of the vector to zero.\n * @method setZero\n */\nVec3.prototype.setZero = function(){\n    this.x = this.y = this.z = 0;\n};\n\n/**\n * Vector addition\n * @method vadd\n * @param {Vec3} v\n * @param {Vec3} target Optional.\n * @return {Vec3}\n */\nVec3.prototype.vadd = function(v,target){\n    if(target){\n        target.x = v.x + this.x;\n        target.y = v.y + this.y;\n        target.z = v.z + this.z;\n    } else {\n        return new Vec3(this.x + v.x,\n                               this.y + v.y,\n                               this.z + v.z);\n    }\n};\n\n/**\n * Vector subtraction\n * @method vsub\n * @param {Vec3} v\n * @param {Vec3} target Optional. Target to save in.\n * @return {Vec3}\n */\nVec3.prototype.vsub = function(v,target){\n    if(target){\n        target.x = this.x - v.x;\n        target.y = this.y - v.y;\n        target.z = this.z - v.z;\n    } else {\n        return new Vec3(this.x-v.x,\n                               this.y-v.y,\n                               this.z-v.z);\n    }\n};\n\n/**\n * Get the cross product matrix a_cross from a vector, such that a x b = a_cross * b = c\n * @method crossmat\n * @see http://www8.cs.umu.se/kurser/TDBD24/VT06/lectures/Lecture6.pdf\n * @return {Mat3}\n */\nVec3.prototype.crossmat = function(){\n    return new Mat3([     0,  -this.z,   this.y,\n                            this.z,        0,  -this.x,\n                           -this.y,   this.x,        0]);\n};\n\n/**\n * Normalize the vector. Note that this changes the values in the vector.\n * @method normalize\n * @return {Number} Returns the norm of the vector\n */\nVec3.prototype.normalize = function(){\n    var x=this.x, y=this.y, z=this.z;\n    var n = Math.sqrt(x*x + y*y + z*z);\n    if(n>0.0){\n        var invN = 1/n;\n        this.x *= invN;\n        this.y *= invN;\n        this.z *= invN;\n    } else {\n        // Make something up\n        this.x = 0;\n        this.y = 0;\n        this.z = 0;\n    }\n    return n;\n};\n\n/**\n * Get the version of this vector that is of length 1.\n * @method unit\n * @param {Vec3} target Optional target to save in\n * @return {Vec3} Returns the unit vector\n */\nVec3.prototype.unit = function(target){\n    target = target || new Vec3();\n    var x=this.x, y=this.y, z=this.z;\n    var ninv = Math.sqrt(x*x + y*y + z*z);\n    if(ninv>0.0){\n        ninv = 1.0/ninv;\n        target.x = x * ninv;\n        target.y = y * ninv;\n        target.z = z * ninv;\n    } else {\n        target.x = 1;\n        target.y = 0;\n        target.z = 0;\n    }\n    return target;\n};\n\n/**\n * Get the 2-norm (length) of the vector\n * @method norm\n * @return {Number}\n */\nVec3.prototype.norm = function(){\n    var x=this.x, y=this.y, z=this.z;\n    return Math.sqrt(x*x + y*y + z*z);\n};\n\n/**\n * Get the squared length of the vector\n * @method norm2\n * @return {Number}\n */\nVec3.prototype.norm2 = function(){\n    return this.dot(this);\n};\n\n/**\n * Get distance from this point to another point\n * @method distanceTo\n * @param  {Vec3} p\n * @return {Number}\n */\nVec3.prototype.distanceTo = function(p){\n    var x=this.x, y=this.y, z=this.z;\n    var px=p.x, py=p.y, pz=p.z;\n    return Math.sqrt((px-x)*(px-x)+\n                     (py-y)*(py-y)+\n                     (pz-z)*(pz-z));\n};\n\n/**\n * Multiply the vector with a scalar\n * @deprecated Use .scale instead\n * @method mult\n * @param {Number} scalar\n * @param {Vec3} target\n * @return {Vec3}\n */\nVec3.prototype.mult = function(scalar,target){\n    target = target || new Vec3();\n    var x = this.x,\n        y = this.y,\n        z = this.z;\n    target.x = scalar * x;\n    target.y = scalar * y;\n    target.z = scalar * z;\n    return target;\n};\n\n/**\n * Multiply the vector with a scalar.\n * @method scale\n * @param {Number} scalar\n * @param {Vec3} target\n * @return {Vec3}\n */\nVec3.prototype.scale = Vec3.prototype.mult;\n\n/**\n * Calculate dot product\n * @method dot\n * @param {Vec3} v\n * @return {Number}\n */\nVec3.prototype.dot = function(v){\n    return this.x * v.x + this.y * v.y + this.z * v.z;\n};\n\n/**\n * @method isZero\n * @return bool\n */\nVec3.prototype.isZero = function(){\n    return this.x===0 && this.y===0 && this.z===0;\n};\n\n/**\n * Make the vector point in the opposite direction.\n * @method negate\n * @param {Vec3} target Optional target to save in\n * @return {Vec3}\n */\nVec3.prototype.negate = function(target){\n    target = target || new Vec3();\n    target.x = -this.x;\n    target.y = -this.y;\n    target.z = -this.z;\n    return target;\n};\n\n/**\n * Compute two artificial tangents to the vector\n * @method tangents\n * @param {Vec3} t1 Vector object to save the first tangent in\n * @param {Vec3} t2 Vector object to save the second tangent in\n */\nvar Vec3_tangents_n = new Vec3();\nvar Vec3_tangents_randVec = new Vec3();\nVec3.prototype.tangents = function(t1,t2){\n    var norm = this.norm();\n    if(norm>0.0){\n        var n = Vec3_tangents_n;\n        var inorm = 1/norm;\n        n.set(this.x*inorm,this.y*inorm,this.z*inorm);\n        var randVec = Vec3_tangents_randVec;\n        if(Math.abs(n.x) < 0.9){\n            randVec.set(1,0,0);\n            n.cross(randVec,t1);\n        } else {\n            randVec.set(0,1,0);\n            n.cross(randVec,t1);\n        }\n        n.cross(t1,t2);\n    } else {\n        // The normal length is zero, make something up\n        t1.set(1,0,0).normalize();\n        t2.set(0,1,0).normalize();\n    }\n};\n\n/**\n * Converts to a more readable format\n * @method toString\n * @return string\n */\nVec3.prototype.toString = function(){\n    return this.x+\",\"+this.y+\",\"+this.z;\n};\n\n/**\n * Converts to an array\n * @method toArray\n * @return Array\n */\nVec3.prototype.toArray = function(){\n    return [this.x, this.y, this.z];\n};\n\n/**\n * Copies value of source to this vector.\n * @method copy\n * @param {Vec3} source\n * @return {Vec3} this\n */\nVec3.prototype.copy = function(source){\n    this.x = source.x;\n    this.y = source.y;\n    this.z = source.z;\n    return this;\n};\n\n\n/**\n * Do a linear interpolation between two vectors\n * @method lerp\n * @param {Vec3} v\n * @param {Number} t A number between 0 and 1. 0 will make this function return u, and 1 will make it return v. Numbers in between will generate a vector in between them.\n * @param {Vec3} target\n */\nVec3.prototype.lerp = function(v,t,target){\n    var x=this.x, y=this.y, z=this.z;\n    target.x = x + (v.x-x)*t;\n    target.y = y + (v.y-y)*t;\n    target.z = z + (v.z-z)*t;\n};\n\n/**\n * Check if a vector equals is almost equal to another one.\n * @method almostEquals\n * @param {Vec3} v\n * @param {Number} precision\n * @return bool\n */\nVec3.prototype.almostEquals = function(v,precision){\n    if(precision===undefined){\n        precision = 1e-6;\n    }\n    if( Math.abs(this.x-v.x)>precision ||\n        Math.abs(this.y-v.y)>precision ||\n        Math.abs(this.z-v.z)>precision){\n        return false;\n    }\n    return true;\n};\n\n/**\n * Check if a vector is almost zero\n * @method almostZero\n * @param {Number} precision\n */\nVec3.prototype.almostZero = function(precision){\n    if(precision===undefined){\n        precision = 1e-6;\n    }\n    if( Math.abs(this.x)>precision ||\n        Math.abs(this.y)>precision ||\n        Math.abs(this.z)>precision){\n        return false;\n    }\n    return true;\n};\n\nvar antip_neg = new Vec3();\n\n/**\n * Check if the vector is anti-parallel to another vector.\n * @method isAntiparallelTo\n * @param  {Vec3}  v\n * @param  {Number}  precision Set to zero for exact comparisons\n * @return {Boolean}\n */\nVec3.prototype.isAntiparallelTo = function(v,precision){\n    this.negate(antip_neg);\n    return antip_neg.almostEquals(v,precision);\n};\n\n/**\n * Clone the vector\n * @method clone\n * @return {Vec3}\n */\nVec3.prototype.clone = function(){\n    return new Vec3(this.x, this.y, this.z);\n};\n},{\"./Mat3\":24}],28:[function(_dereq_,module,exports){\nmodule.exports = Body;\n\nvar EventTarget = _dereq_('../utils/EventTarget');\nvar Shape = _dereq_('../shapes/Shape');\nvar Vec3 = _dereq_('../math/Vec3');\nvar Mat3 = _dereq_('../math/Mat3');\nvar Quaternion = _dereq_('../math/Quaternion');\nvar Material = _dereq_('../material/Material');\nvar AABB = _dereq_('../collision/AABB');\nvar Box = _dereq_('../shapes/Box');\n\n/**\n * Base class for all body types.\n * @class Body\n * @constructor\n * @extends EventTarget\n * @param {object} [options]\n * @param {Vec3} [options.position]\n * @param {number} [options.mass]\n * @param {number} [options.type]\n * @param {number} [options.linearDamping]\n * @example\n *     var body = new Body({\n *         mass: 1\n *     });\n *     var shape = new Sphere(1);\n *     body.addShape(shape);\n *     world.add(body);\n */\nfunction Body(options){\n    options = options || {};\n\n    EventTarget.apply(this);\n\n    this.id = Body.idCounter++;\n\n    /**\n     * Reference to the world the body is living in\n     * @property world\n     * @type {World}\n     */\n    this.world = null;\n\n    /**\n     * Callback function that is used BEFORE stepping the system. Use it to apply forces, for example. Inside the function, \"this\" will refer to this Body object.\n     * @property preStep\n     * @type {Function}\n     * @deprecated Use World events instead\n     */\n    this.preStep = null;\n\n    /**\n     * Callback function that is used AFTER stepping the system. Inside the function, \"this\" will refer to this Body object.\n     * @property postStep\n     * @type {Function}\n     * @deprecated Use World events instead\n     */\n    this.postStep = null;\n\n    this.vlambda = new Vec3();\n\n    /**\n     * @property {Number} collisionFilterGroup\n     */\n    this.collisionFilterGroup = 1;\n\n    /**\n     * @property {Number} collisionFilterMask\n     */\n    this.collisionFilterMask = 1;\n\n    /**\n     * Whether to produce contact forces\n     * @property {Number} collisionResponse\n     */\n\tthis.collisionResponse = true;\n\n    /**\n     * @property position\n     * @type {Vec3}\n     */\n    this.position = new Vec3();\n\n    if(options.position){\n        this.position.copy(options.position);\n    }\n\n    /**\n     * @property {Vec3} previousPosition\n     */\n    this.previousPosition = new Vec3();\n\n    /**\n     * Initial position of the body\n     * @property initPosition\n     * @type {Vec3}\n     */\n    this.initPosition = new Vec3();\n\n    /**\n     * @property velocity\n     * @type {Vec3}\n     */\n    this.velocity = new Vec3();\n\n    /**\n     * @property initVelocity\n     * @type {Vec3}\n     */\n    this.initVelocity = new Vec3();\n\n    /**\n     * Linear force on the body\n     * @property force\n     * @type {Vec3}\n     */\n    this.force = new Vec3();\n\n    var mass = typeof(options.mass) === 'number' ? options.mass : 0;\n\n    /**\n     * @property mass\n     * @type {Number}\n     */\n    this.mass = mass;\n\n    /**\n     * @property invMass\n     * @type {Number}\n     */\n    this.invMass = mass > 0 ? 1.0 / mass : 0;\n\n    /**\n     * @property material\n     * @type {Material}\n     */\n    this.material = options.material || null;\n\n    /**\n     * @property float linearDamping\n     * @type {Number}\n     */\n    this.linearDamping = typeof(options.linearDamping) === 'number' ? options.linearDamping : 0.01;\n\n    /**\n     * One of the states Body.DYNAMIC, Body.STATIC and Body.KINEMATIC\n     * @property type\n     * @type {Number}\n     */\n    this.type = (mass <= 0.0 ? Body.STATIC : Body.DYNAMIC);\n    if(typeof(options.type) === typeof(Body.STATIC)){\n        this.type = options.type;\n    }\n\n    /**\n     * If true, the body will automatically fall to sleep.\n     * @property allowSleep\n     * @type {Boolean}\n     */\n    this.allowSleep = true;\n\n    /**\n     * Current sleep state.\n     * @property sleepState\n     * @type {Number}\n     */\n    this.sleepState = 0;\n\n    /**\n     * If the speed (the norm of the velocity) is smaller than this value, the body is considered sleepy.\n     * @property sleepSpeedLimit\n     * @type {Number}\n     */\n    this.sleepSpeedLimit = 0.1;\n\n    /**\n     * If the body has been sleepy for this sleepTimeLimit seconds, it is considered sleeping.\n     * @property sleepTimeLimit\n     * @type {Number}\n     */\n    this.sleepTimeLimit = 1;\n\n    this.timeLastSleepy = 0;\n\n    this._wakeUpAfterNarrowphase = false;\n\n\n    /**\n     * Rotational force on the body, around center of mass\n     * @property Vec3 tau\n     * @todo should be renamed to .angularForce\n     */\n    this.tau = new Vec3();\n\n    /**\n     * Orientation of the body\n     * @property quaternion\n     * @type {Quaternion}\n     */\n    this.quaternion = new Quaternion();\n\n    /**\n     * @property initQuaternion\n     * @type {Quaternion}\n     */\n    this.initQuaternion = new Quaternion();\n\n    /**\n     * @property angularVelocity\n     * @type {Vec3}\n     */\n    this.angularVelocity = new Vec3();\n\n    /**\n     * @property initAngularVelocity\n     * @type {Vec3}\n     */\n    this.initAngularVelocity = new Vec3();\n\n    this.interpolatedPosition = new Vec3();\n    this.interpolatedQuaternion = new Quaternion();\n\n    /**\n     * @property shapes\n     * @type {array}\n     */\n    this.shapes = [];\n\n    /**\n     * @property shapeOffsets\n     * @type {array}\n     */\n    this.shapeOffsets = [];\n\n    /**\n     * @property shapeOrientations\n     * @type {array}\n     */\n    this.shapeOrientations = [];\n\n    /**\n     * @property inertia\n     * @type {Vec3}\n     */\n    this.inertia = new Vec3();\n\n    /**\n     * @property {Vec3} invInertia\n     */\n    this.invInertia = new Vec3();\n\n    /**\n     * @property {Mat3} invInertiaWorld\n     */\n    this.invInertiaWorld = new Mat3();\n\n    this.invMassSolve = 0;\n\n    /**\n     * @property {Vec3} invInertiaSolve\n     */\n    this.invInertiaSolve = new Vec3();\n\n    /**\n     * @property {Mat3} invInertiaWorldSolve\n     */\n    this.invInertiaWorldSolve = new Mat3();\n\n    /**\n     * Set to true if you don't want the body to rotate. Make sure to run .updateMassProperties() after changing this.\n     * @property {Boolean} fixedRotation\n     */\n    this.fixedRotation = false;\n\n    /**\n     * @property {Number} angularDamping\n     */\n    this.angularDamping = 0.01; // Perhaps default should be zero here?\n\n    /**\n     * @property aabb\n     * @type {Vec3}\n     */\n    this.aabb = new AABB();\n\n    /**\n     * Indicates if the AABB needs to be updated before use.\n     * @property aabbNeedsUpdate\n     * @type {Boolean}\n     */\n    this.aabbNeedsUpdate = true;\n\n    this.wlambda = new Vec3();\n\n    this.updateMassProperties();\n}\nBody.prototype = new EventTarget();\nBody.prototype.constructor = Body;\n\n/**\n * A dynamic body is fully simulated. Can be moved manually by the user, but normally they move according to forces. A dynamic body can collide with all body types. A dynamic body always has finite, non-zero mass.\n * @static\n * @property DYNAMIC\n * @type {Number}\n */\nBody.DYNAMIC = 1;\n\n/**\n * A static body does not move during simulation and behaves as if it has infinite mass. Static bodies can be moved manually by setting the position of the body. The velocity of a static body is always zero. Static bodies do not collide with other static or kinematic bodies.\n * @static\n * @property DYNAMIC\n * @type {Number}\n */\nBody.STATIC = 2;\n\n/**\n * A kinematic body moves under simulation according to its velocity. They do not respond to forces. They can be moved manually, but normally a kinematic body is moved by setting its velocity. A kinematic body behaves as if it has infinite mass. Kinematic bodies do not collide with other static or kinematic bodies.\n * @static\n * @property DYNAMIC\n * @type {Number}\n */\nBody.KINEMATIC = 4;\n\n\n\n/**\n * @static\n * @property AWAKE\n * @type {number}\n */\nBody.AWAKE = 0;\n\n/**\n * @static\n * @property SLEEPY\n * @type {number}\n */\nBody.SLEEPY = 1;\n\n/**\n * @static\n * @property SLEEPING\n * @type {number}\n */\nBody.SLEEPING = 2;\n\nBody.idCounter = 0;\n\n/**\n * Wake the body up.\n * @method wakeUp\n */\nBody.prototype.wakeUp = function(){\n    var s = this.sleepState;\n    this.sleepState = 0;\n    if(s === Body.SLEEPING){\n        this.dispatchEvent({type:\"wakeup\"});\n    }\n};\n\n/**\n * Force body sleep\n * @method sleep\n */\nBody.prototype.sleep = function(){\n    this.sleepState = Body.SLEEPING;\n    this.velocity.set(0,0,0);\n    this.angularVelocity.set(0,0,0);\n};\n\nBody.sleepyEvent = {\n    type: \"sleepy\"\n};\n\nBody.sleepEvent = {\n    type: \"sleep\"\n};\n\n/**\n * Called every timestep to update internal sleep timer and change sleep state if needed.\n * @method sleepTick\n * @param {Number} time The world time in seconds\n */\nBody.prototype.sleepTick = function(time){\n    if(this.allowSleep){\n        var sleepState = this.sleepState;\n        var speedSquared = this.velocity.norm2() + this.angularVelocity.norm2();\n        var speedLimitSquared = Math.pow(this.sleepSpeedLimit,2);\n        if(sleepState===Body.AWAKE && speedSquared < speedLimitSquared){\n            this.sleepState = Body.SLEEPY; // Sleepy\n            this.timeLastSleepy = time;\n            this.dispatchEvent(Body.sleepyEvent);\n        } else if(sleepState===Body.SLEEPY && speedSquared > speedLimitSquared){\n            this.wakeUp(); // Wake up\n        } else if(sleepState===Body.SLEEPY && (time - this.timeLastSleepy ) > this.sleepTimeLimit){\n            this.sleep(); // Sleeping\n            this.dispatchEvent(Body.sleepEvent);\n        }\n    }\n};\n\n/**\n * If the body is sleeping, it should be immovable / have infinite mass during solve. We solve it by having a separate \"solve mass\".\n * @method updateSolveMassProperties\n */\nBody.prototype.updateSolveMassProperties = function(){\n    if(this.sleepState === Body.SLEEPING || this.type === Body.KINEMATIC){\n        this.invMassSolve = 0;\n        this.invInertiaSolve.setZero();\n        this.invInertiaWorldSolve.setZero();\n    } else {\n        this.invMassSolve = this.invMass;\n        this.invInertiaSolve.copy(this.invInertia);\n        this.invInertiaWorldSolve.copy(this.invInertiaWorld);\n    }\n};\n\n/**\n * Convert a world point to local body frame.\n * @method pointToLocalFrame\n * @param  {Vec3} worldPoint\n * @param  {Vec3} result\n * @return {Vec3}\n */\nBody.prototype.pointToLocalFrame = function(worldPoint,result){\n    var result = result || new Vec3();\n    worldPoint.vsub(this.position,result);\n    this.quaternion.conjugate().vmult(result,result);\n    return result;\n};\n\n/**\n * Convert a local body point to world frame.\n * @method pointToWorldFrame\n * @param  {Vec3} worldPoint\n * @param  {Vec3} result\n * @return {Vec3}\n */\nBody.prototype.pointToWorldFrame = function(localPoint,result){\n    var result = result || new Vec3();\n    this.quaternion.vmult(localPoint,result);\n    result.vadd(this.position,result);\n    return result;\n};\n\n/**\n * Convert a local body point to world frame.\n * @method pointToWorldFrame\n * @param  {Vec3} worldPoint\n * @param  {Vec3} result\n * @return {Vec3}\n */\nBody.prototype.vectorToWorldFrame = function(localVector, result){\n    var result = result || new Vec3();\n    this.quaternion.vmult(localVector, result);\n    return result;\n};\n\nvar tmpVec = new Vec3();\nvar tmpQuat = new Quaternion();\n\n\nBody.prototype.addShape = function(shape, _offset, _orientation){\n    var offset = new Vec3();\n    var orientation = new Quaternion();\n\n    if(_offset){\n        offset.copy(_offset);\n    }\n    if(_orientation){\n        orientation.copy(_orientation);\n    }\n\n    this.shapes.push(shape);\n    this.shapeOffsets.push(offset);\n    this.shapeOrientations.push(orientation);\n    this.updateMassProperties();\n    this.updateBoundingRadius();\n\n    this.aabbNeedsUpdate = true;\n};\n\n/**\n * Update the bounding radius of the body. Should be done if any of the shapes are changed.\n * @method updateBoundingRadius\n */\nBody.prototype.updateBoundingRadius = function(){\n    var shapes = this.shapes,\n        shapeOffsets = this.shapeOffsets,\n        N = shapes.length,\n        radius = 0;\n\n    for(var i=0; i!==N; i++){\n        var shape = shapes[i];\n        shape.updateBoundingSphereRadius();\n        var offset = shapeOffsets[i].norm(),\n            r = shape.boundingSphereRadius;\n        if(offset + r > radius){\n            radius = offset + r;\n        }\n    }\n\n    this.boundingRadius = radius;\n};\n\n/**\n * Updates the .aabb\n * @method computeAABB\n * @todo rename to updateAABB()\n */\nBody.prototype.computeAABB = function(){\n    var shapes = this.shapes,\n        shapeOffsets = this.shapeOffsets,\n        shapeOrientations = this.shapeOrientations,\n        N = shapes.length,\n        offset = tmpVec,\n        orientation = tmpQuat,\n        bodyQuat = this.quaternion,\n        aabb = this.aabb,\n        shapeAABB = new AABB();\n\n    for(var i=0; i!==N; i++){\n        var shape = shapes[i];\n\n        // Get shape world quaternion\n        shapeOrientations[i].mult(bodyQuat, orientation);\n\n        // Get shape world position\n        orientation.vmult(shapeOffsets[i], offset);\n        offset.vadd(this.position, offset);\n\n        // vec2.rotate(offset, shapeOffsets[i], bodyAngle);\n        // vec2.add(offset, offset, this.position);\n\n        // Get shape AABB\n        shape.calculateWorldAABB(offset, orientation, shapeAABB.lowerBound, shapeAABB.upperBound);\n\n        if(i === 0){\n            aabb.copy(shapeAABB);\n        } else {\n            aabb.extend(shapeAABB);\n        }\n    }\n\n    this.aabbNeedsUpdate = false;\n};\n\nvar uiw_m1 = new Mat3(),\n    uiw_m2 = new Mat3(),\n    uiw_m3 = new Mat3();\n\n/**\n * Update .inertiaWorld and .invInertiaWorld\n * @method updateInertiaWorld\n */\nBody.prototype.updateInertiaWorld = function(force){\n    var I = this.invInertia;\n    if (I.x === I.y && I.y === I.z && !force) {\n        // If inertia M = s*I, where I is identity and s a scalar, then\n        //    R*M*R' = R*(s*I)*R' = s*R*I*R' = s*R*R' = s*I = M\n        // where R is the rotation matrix.\n        // In other words, we don't have to transform the inertia if all\n        // inertia diagonal entries are equal.\n    } else {\n        var m1 = uiw_m1,\n            m2 = uiw_m2,\n            m3 = uiw_m3;\n        m1.setRotationFromQuaternion(this.quaternion);\n        m1.transpose(m2);\n        m1.scale(I,m1);\n        m1.mmult(m2,this.invInertiaWorld);\n        //m3.getTrace(this.invInertiaWorld);\n    }\n\n    /*\n    this.quaternion.vmult(this.inertia,this.inertiaWorld);\n    this.quaternion.vmult(this.invInertia,this.invInertiaWorld);\n    */\n};\n\n/**\n * Apply force to a world point. This could for example be a point on the Body surface. Applying force this way will add to Body.force and Body.tau.\n * @method applyForce\n * @param  {Vec3} force The amount of force to add.\n * @param  {Vec3} worldPoint A world point to apply the force on.\n */\nvar Body_applyForce_r = new Vec3();\nvar Body_applyForce_rotForce = new Vec3();\nBody.prototype.applyForce = function(force,worldPoint){\n    if(this.type !== Body.DYNAMIC){\n        return;\n    }\n\n    // Compute point position relative to the body center\n    var r = Body_applyForce_r;\n    worldPoint.vsub(this.position,r);\n\n    // Compute produced rotational force\n    var rotForce = Body_applyForce_rotForce;\n    r.cross(force,rotForce);\n\n    // Add linear force\n    this.force.vadd(force,this.force);\n\n    // Add rotational force\n    this.tau.vadd(rotForce,this.tau);\n};\n\n/**\n * Apply impulse to a world point. This could for example be a point on the Body surface. An impulse is a force added to a body during a short period of time (impulse = force * time). Impulses will be added to Body.velocity and Body.angularVelocity.\n * @method applyImpulse\n * @param  {Vec3} impulse The amount of impulse to add.\n * @param  {Vec3} worldPoint A world point to apply the force on.\n */\nvar Body_applyImpulse_r = new Vec3();\nvar Body_applyImpulse_velo = new Vec3();\nvar Body_applyImpulse_rotVelo = new Vec3();\nBody.prototype.applyImpulse = function(impulse, worldPoint){\n    if(this.type !== Body.DYNAMIC){\n        return;\n    }\n\n    // Compute point position relative to the body center\n    var r = Body_applyImpulse_r;\n    worldPoint.vsub(this.position,r);\n\n    // Compute produced central impulse velocity\n    var velo = Body_applyImpulse_velo;\n    velo.copy(impulse);\n    velo.mult(this.invMass,velo);\n\n    // Add linear impulse\n    this.velocity.vadd(velo, this.velocity);\n\n    // Compute produced rotational impulse velocity\n    var rotVelo = Body_applyImpulse_rotVelo;\n    r.cross(impulse,rotVelo);\n\n    /*\n    rotVelo.x *= this.invInertia.x;\n    rotVelo.y *= this.invInertia.y;\n    rotVelo.z *= this.invInertia.z;\n    */\n    this.invInertiaWorld.vmult(rotVelo,rotVelo);\n\n    // Add rotational Impulse\n    this.angularVelocity.vadd(rotVelo, this.angularVelocity);\n};\n\n/**\n * Should be called whenever you change the body mass.\n * @method updateMassProperties\n */\n/*Body.prototype.updateMassProperties = function(){\n    this.invMass = this.mass>0 ? 1.0/this.mass : 0;\n    this.shape.calculateLocalInertia(this.mass, this.inertia);\n    var I = this.inertia;\n    var fixed = this.fixedRotation;\n    this.invInertia.set(\n        I.x > 0 && !fixed ? 1.0 / I.x : 0,\n        I.y > 0 && !fixed ? 1.0 / I.y : 0,\n        I.z > 0 && !fixed ? 1.0 / I.z : 0\n    );\n    this.updateInertiaWorld(true);\n};\n*/\n\nBody.prototype.updateMassProperties = function(){\n    var target = new Vec3();\n\n    // TODO: check if only 1 shape at origin, use shape inertia in that case\n\n    this.invMass = this.mass > 0 ? 1.0 / this.mass : 0;\n    var I = this.inertia;\n    var fixed = this.fixedRotation;\n\n    // Approximate with AABB\n    this.computeAABB();\n    Box.calculateInertia(new Vec3(\n        (this.aabb.upperBound.x-this.aabb.lowerBound.x) / 2,\n        (this.aabb.upperBound.y-this.aabb.lowerBound.y) / 2,\n        (this.aabb.upperBound.z-this.aabb.lowerBound.z) / 2\n    ), this.mass, I);\n\n    this.invInertia.set(\n        I.x > 0 && !fixed ? 1.0 / I.x : 0,\n        I.y > 0 && !fixed ? 1.0 / I.y : 0,\n        I.z > 0 && !fixed ? 1.0 / I.z : 0\n    );\n    this.updateInertiaWorld(true);\n};\n\n/**\n * Get world velocity of a point in the body.\n * @method getVelocityAtWorldPoint\n * @param  {Vec3} worldPoint\n * @param  {Vec3} result\n * @return {Vec3} The result vector.\n */\nBody.prototype.getVelocityAtWorldPoint = function(worldPoint, result){\n    var r = new Vec3();\n    worldPoint.vsub(this.position, r);\n    this.angularVelocity.cross(r, result);\n    this.velocity.vadd(result, result);\n    return result;\n};\n\n},{\"../collision/AABB\":3,\"../material/Material\":22,\"../math/Mat3\":24,\"../math/Quaternion\":25,\"../math/Vec3\":27,\"../shapes/Box\":34,\"../shapes/Shape\":40,\"../utils/EventTarget\":45}],29:[function(_dereq_,module,exports){\nvar Body = _dereq_('./Body');\nvar Vec3 = _dereq_('../math/Vec3');\nvar Quaternion = _dereq_('../math/Quaternion');\nvar RaycastResult = _dereq_('../collision/RaycastResult');\nvar Ray = _dereq_('../collision/Ray');\nvar WheelInfo = _dereq_('../objects/WheelInfo');\n\nmodule.exports = RaycastVehicle;\n\n/**\n * Vehicle helper class that casts rays from the wheel positions towards the ground and applies forces.\n * @class RaycastVehicle\n * @constructor\n * @param {object} [options.chassisBody]\n * @param {object} [options.indexRightAxis]\n * @param {object} [options.indexLeftAxis]\n * @param {object} [options.indexUpAxis]\n */\nfunction RaycastVehicle(options){\n\n    /**\n     * @property {Body} chassisBody\n     */\n    this.chassisBody = options.chassisBody;\n\n    /**\n     * @property {array} wheelInfos An array of WheelInfo objects.\n     */\n    this.wheelInfos = [];\n\n    /**\n     * Will be set to true if the car is sliding.\n     * @property {boolean} sliding\n     */\n    this.sliding = false;\n\n    /**\n     * @property {World} world\n     */\n    this.world = null;\n\n    /**\n     * Index of the right axis, 0=x, 1=y, 2=z\n     * @property {integer} indexRightAxis\n     * @default 1\n     */\n    this.indexRightAxis = typeof(options.indexRightAxis) !== 'undefined' ? options.indexRightAxis : 1;\n\n    /**\n     * Index of the forward axis, 0=x, 1=y, 2=z\n     * @property {integer} indexForwardAxis\n     * @default 0\n     */\n    this.indexForwardAxis = typeof(options.indexForwardAxis) !== 'undefined' ? options.indexForwardAxis : 0;\n\n    /**\n     * Index of the up axis, 0=x, 1=y, 2=z\n     * @property {integer} indexUpAxis\n     * @default 2\n     */\n    this.indexUpAxis = typeof(options.indexUpAxis) !== 'undefined' ? options.indexUpAxis : 2;\n}\n\nvar tmpVec1 = new Vec3();\nvar tmpVec2 = new Vec3();\nvar tmpVec3 = new Vec3();\nvar tmpVec4 = new Vec3();\nvar tmpVec5 = new Vec3();\nvar tmpVec6 = new Vec3();\nvar tmpRay = new Ray();\n\n/**\n * Add a wheel. For information about the options, see WheelInfo.\n * @param {object} [options]\n * @method addWheel\n */\nRaycastVehicle.prototype.addWheel = function(options){\n    options = options || {};\n\n    var info = new WheelInfo(options);\n    var index = this.wheelInfos.length;\n    this.wheelInfos.push(info);\n\n    return index;\n};\n\n/**\n * Set the steering value of a wheel.\n * @method setSteeringValue\n * @param {number} value\n * @param {integer} wheelIndex\n */\nRaycastVehicle.prototype.setSteeringValue = function(value, wheelIndex){\n    var wheel = this.wheelInfos[wheelIndex];\n    wheel.steering = value;\n};\n\nvar torque = new Vec3();\n\n/**\n * Set the wheel force to apply on one of the wheels each time step\n * @method applyEngineForce\n * @param  {number} value\n * @param  {integer} wheelIndex\n */\nRaycastVehicle.prototype.applyEngineForce = function(value, wheelIndex){\n    this.wheelInfos[wheelIndex].engineForce = value;\n};\n\n/**\n * Set the braking force of a wheel\n * @method setBrake\n * @param {number} brake\n * @param {integer} wheelIndex\n */\nRaycastVehicle.prototype.setBrake = function(brake, wheelIndex){\n    this.wheelInfos[wheelIndex].brake = brake;\n};\n\n/**\n * Add the vehicle including its constraints to the world.\n * @method addToWorld\n * @param {World} world\n */\nRaycastVehicle.prototype.addToWorld = function(world){\n    var constraints = this.constraints;\n    world.add(this.chassisBody);\n    var that = this;\n    world.addEventListener('preStep', function(){\n        that.updateVehicle(world.dt);\n    });\n    this.world = world;\n};\n\nRaycastVehicle.prototype.getVehicleAxisWorld = function(axisIndex, result){\n    result.set(\n        axisIndex === 0 ? 1 : 0,\n        axisIndex === 1 ? 1 : 0,\n        axisIndex === 2 ? 1 : 0\n    );\n    this.chassisBody.vectorToWorldFrame(result, result);\n};\n\nRaycastVehicle.prototype.updateVehicle = function(timeStep){\n    var wheelInfos = this.wheelInfos;\n    var numWheels = wheelInfos.length;\n    var chassisBody = this.chassisBody;\n\n    for (var i = 0; i < numWheels; i++) {\n        this.updateWheelTransform(i, false);\n    }\n\n    this.currentVehicleSpeedKmHour = 3.6 * chassisBody.velocity.norm();\n\n    var forwardWorld = new Vec3();\n    this.getVehicleAxisWorld(this.indexForwardAxis, forwardWorld);\n\n    if (forwardWorld.dot(chassisBody.velocity) < 0){\n        this.currentVehicleSpeedKmHour *= -1;\n    }\n\n    // simulate suspension\n    for (var i = 0; i < numWheels; i++) {\n        this.castRay(wheelInfos[i]);\n    }\n\n    this.updateSuspension(timeStep);\n\n    var impulse = new Vec3();\n    var relpos = new Vec3();\n    for (var i = 0; i < numWheels; i++) {\n        //apply suspension force\n        var wheel = wheelInfos[i];\n        var suspensionForce = wheel.suspensionForce;\n        if (suspensionForce > wheel.maxSuspensionForce) {\n            suspensionForce = wheel.maxSuspensionForce;\n        }\n        wheel.raycastResult.hitNormalWorld.scale(suspensionForce * timeStep, impulse);\n\n        wheel.raycastResult.hitPointWorld.vsub(chassisBody.position, relpos);\n        chassisBody.applyImpulse(impulse, wheel.raycastResult.hitPointWorld/*relpos*/);\n    }\n\n    this.updateFriction(timeStep);\n\n    var hitNormalWorldScaledWithProj = new Vec3();\n    var fwd  = new Vec3();\n    var vel = new Vec3();\n    for (i = 0; i < numWheels; i++) {\n        var wheel = wheelInfos[i];\n        //var relpos = new Vec3();\n        //wheel.chassisConnectionPointWorld.vsub(chassisBody.position, relpos);\n        chassisBody.getVelocityAtWorldPoint(wheel.chassisConnectionPointWorld, vel);\n\n        // Hack to get the rotation in the correct direction\n        var m = 1;\n        switch(this.indexUpAxis){\n        case 1:\n            m = -1;\n            break;\n        }\n\n        if (wheel.isInContact) {\n\n            this.getVehicleAxisWorld(this.indexForwardAxis, fwd);\n            var proj = fwd.dot(wheel.raycastResult.hitNormalWorld);\n            wheel.raycastResult.hitNormalWorld.scale(proj, hitNormalWorldScaledWithProj);\n\n            fwd.vsub(hitNormalWorldScaledWithProj, fwd);\n\n            var proj2 = fwd.dot(vel);\n            wheel.deltaRotation = m * proj2 * timeStep / wheel.radius;\n        }\n\n        if((wheel.sliding || !wheel.isInContact) && wheel.engineForce !== 0 && wheel.useCustomSlidingRotationalSpeed){\n            // Apply custom rotation when accelerating and sliding\n            wheel.deltaRotation = (wheel.engineForce > 0 ? 1 : -1) * wheel.customSlidingRotationalSpeed * timeStep;\n        }\n\n        // Lock wheels\n        if(Math.abs(wheel.brake) > Math.abs(wheel.engineForce)){\n            wheel.deltaRotation = 0;\n        }\n\n        wheel.rotation += wheel.deltaRotation; // Use the old value\n        wheel.deltaRotation *= 0.99; // damping of rotation when not in contact\n    }\n};\n\nRaycastVehicle.prototype.updateSuspension = function(deltaTime) {\n    var chassisBody = this.chassisBody;\n    var chassisMass = chassisBody.mass;\n    var wheelInfos = this.wheelInfos;\n    var numWheels = wheelInfos.length;\n\n    for (var w_it = 0; w_it < numWheels; w_it++){\n        var wheel = wheelInfos[w_it];\n\n        if (wheel.isInContact){\n            var force;\n\n            // Spring\n            var susp_length = wheel.suspensionRestLength;\n            var current_length = wheel.suspensionLength;\n            var length_diff = (susp_length - current_length);\n\n            force = wheel.suspensionStiffness * length_diff * wheel.clippedInvContactDotSuspension;\n\n            // Damper\n            var projected_rel_vel = wheel.suspensionRelativeVelocity;\n            var susp_damping;\n            if (projected_rel_vel < 0) {\n                susp_damping = wheel.dampingCompression;\n            } else {\n                susp_damping = wheel.dampingRelaxation;\n            }\n            force -= susp_damping * projected_rel_vel;\n\n            wheel.suspensionForce = force * chassisMass;\n            if (wheel.suspensionForce < 0) {\n                wheel.suspensionForce = 0;\n            }\n        } else {\n            wheel.suspensionForce = 0;\n        }\n    }\n};\n\n/**\n * Remove the vehicle including its constraints from the world.\n * @method removeFromWorld\n * @param {World} world\n */\nRaycastVehicle.prototype.removeFromWorld = function(world){\n    var constraints = this.constraints;\n    world.remove(this.chassisBody);\n    world.removeEventListener('preStep', this.updateVehicle);\n    this.world = null;\n};\n\n// var from = new Vec3();\n// var to = new Vec3();\nvar castRay_rayvector = new Vec3();\nvar castRay_target = new Vec3();\nRaycastVehicle.prototype.castRay = function(wheel) {\n    var rayvector = castRay_rayvector;\n    var target = castRay_target;\n\n    this.updateWheelTransformWorld(wheel);\n    var chassisBody = this.chassisBody;\n\n    var depth = -1;\n\n    var raylen = wheel.suspensionRestLength + wheel.radius;\n\n    wheel.directionWorld.scale(raylen, rayvector);\n    var source = wheel.chassisConnectionPointWorld;\n    source.vadd(rayvector, target);\n    var raycastResult = wheel.raycastResult;\n\n    var param = 0;\n\n    raycastResult.reset();\n    this.world.rayTest(source, target, raycastResult);\n    var object = raycastResult.body;\n\n    wheel.raycastResult.groundObject = 0;\n\n    if (object) {\n        depth = raycastResult.distance;\n        wheel.raycastResult.hitNormalWorld  = raycastResult.hitNormalWorld;\n        wheel.isInContact = true;\n\n        var hitDistance = raycastResult.distance;\n        wheel.suspensionLength = hitDistance - wheel.radius;\n\n        // clamp on max suspension travel\n        var minSuspensionLength = wheel.suspensionRestLength - wheel.maxSuspensionTravel;\n        var maxSuspensionLength = wheel.suspensionRestLength + wheel.maxSuspensionTravel;\n        if (wheel.suspensionLength < minSuspensionLength) {\n            wheel.suspensionLength = minSuspensionLength;\n        }\n        if (wheel.suspensionLength > maxSuspensionLength) {\n            wheel.suspensionLength = maxSuspensionLength;\n            wheel.raycastResult.reset();\n        }\n\n        var denominator = wheel.raycastResult.hitNormalWorld.dot(wheel.directionWorld);\n\n        var chassis_velocity_at_contactPoint = new Vec3();\n        chassisBody.getVelocityAtWorldPoint(wheel.raycastResult.hitPointWorld, chassis_velocity_at_contactPoint);\n\n        var projVel = wheel.raycastResult.hitNormalWorld.dot( chassis_velocity_at_contactPoint );\n\n        if (denominator >= -0.1) {\n            wheel.suspensionRelativeVelocity = 0;\n            wheel.clippedInvContactDotSuspension = 1 / 0.1;\n        } else {\n            var inv = -1 / denominator;\n            wheel.suspensionRelativeVelocity = projVel * inv;\n            wheel.clippedInvContactDotSuspension = inv;\n        }\n\n    } else {\n\n        //put wheel info as in rest position\n        wheel.suspensionLength = wheel.suspensionRestLength + 0 * wheel.maxSuspensionTravel;\n        wheel.suspensionRelativeVelocity = 0.0;\n        wheel.directionWorld.scale(-1, wheel.raycastResult.hitNormalWorld);\n        wheel.clippedInvContactDotSuspension = 1.0;\n    }\n\n    return depth;\n};\n\nRaycastVehicle.prototype.updateWheelTransformWorld = function(wheel){\n    wheel.isInContact = false;\n    var chassisBody = this.chassisBody;\n    chassisBody.pointToWorldFrame(wheel.chassisConnectionPointLocal, wheel.chassisConnectionPointWorld);\n    chassisBody.vectorToWorldFrame(wheel.directionLocal, wheel.directionWorld);\n    chassisBody.vectorToWorldFrame(wheel.axleLocal, wheel.axleWorld);\n};\n\nRaycastVehicle.prototype.updateWheelTransform = function(wheelIndex){\n    var up = tmpVec4;\n    var right = tmpVec5;\n    var fwd = tmpVec6;\n\n    var wheel = this.wheelInfos[wheelIndex];\n    this.updateWheelTransformWorld(wheel);\n\n    wheel.directionLocal.scale(-1, up);\n    right.copy(wheel.axleLocal);\n    up.cross(right, fwd);\n    fwd.normalize();\n    right.normalize();\n\n    // Rotate around steering over the wheelAxle\n    var steering = wheel.steering;\n    var steeringOrn = new Quaternion();\n    steeringOrn.setFromAxisAngle(up, steering);\n\n    var rotatingOrn = new Quaternion();\n    rotatingOrn.setFromAxisAngle(right, wheel.rotation);\n\n    // World rotation of the wheel\n    var q = wheel.worldTransform.quaternion;\n    this.chassisBody.quaternion.mult(steeringOrn, q);\n    q.mult(rotatingOrn, q);\n\n    q.normalize();\n\n    // world position of the wheel\n    var p = wheel.worldTransform.position;\n    p.copy(wheel.directionWorld);\n    p.scale(wheel.suspensionLength, p);\n    p.vadd(wheel.chassisConnectionPointWorld, p);\n};\n\nvar directions = [\n    new Vec3(1, 0, 0),\n    new Vec3(0, 1, 0),\n    new Vec3(0, 0, 1)\n];\n\n\nRaycastVehicle.prototype.getWheelTransformWorld = function(wheelIndex) {\n    return this.wheelInfos[wheelIndex].worldTransform;\n};\n\n\nvar updateFriction_surfNormalWS_scaled_proj = new Vec3();\nvar updateFriction_axle = [];\nvar updateFriction_forwardWS = [];\nvar sideFrictionStiffness2 = 1;\nRaycastVehicle.prototype.updateFriction = function(timeStep) {\n    var surfNormalWS_scaled_proj = updateFriction_surfNormalWS_scaled_proj;\n\n    //calculate the impulse, so that the wheels don't move sidewards\n    var wheelInfos = this.wheelInfos;\n    var numWheels = wheelInfos.length;\n    var chassisBody = this.chassisBody;\n    var forwardWS = updateFriction_forwardWS;\n    var axle = updateFriction_axle;\n\n    var numWheelsOnGround = 0;\n\n    for (var i = 0; i < numWheels; i++) {\n        var wheel = wheelInfos[i];\n\n        var groundObject = wheel.raycastResult.body;\n        if (groundObject){\n            numWheelsOnGround++;\n        }\n\n        wheel.sideImpulse = 0;\n        wheel.forwardImpulse = 0;\n        if(!forwardWS[i]){\n            forwardWS[i] = new Vec3();\n        }\n        if(!axle[i]){\n            axle[i] = new Vec3();\n        }\n    }\n\n    for (var i = 0; i < numWheels; i++){\n        var wheel = wheelInfos[i];\n\n        var groundObject = wheel.raycastResult.body;\n\n        if (groundObject) {\n            var axlei = axle[i];\n            var wheelTrans = this.getWheelTransformWorld(i);\n\n            // Get world axle\n            wheelTrans.vectorToWorldFrame(directions[this.indexRightAxis], axlei);\n\n            var surfNormalWS = wheel.raycastResult.hitNormalWorld;\n            var proj = axlei.dot(surfNormalWS);\n            surfNormalWS.scale(proj, surfNormalWS_scaled_proj);\n            axlei.vsub(surfNormalWS_scaled_proj, axlei);\n            axlei.normalize();\n\n            surfNormalWS.cross(axlei, forwardWS[i]);\n            forwardWS[i].normalize();\n\n            wheel.sideImpulse = resolveSingleBilateral(\n                chassisBody,\n                wheel.raycastResult.hitPointWorld,\n                groundObject,\n                wheel.raycastResult.hitPointWorld,\n                axlei\n            );\n\n            wheel.sideImpulse *= sideFrictionStiffness2;\n        }\n    }\n\n    var sideFactor = 1;\n    var fwdFactor = 0.5;\n\n    this.sliding = false;\n    for (var i = 0; i < numWheels; i++) {\n        var wheel = wheelInfos[i];\n        var groundObject = wheel.raycastResult.body;\n\n        var rollingFriction = 0;\n\n        wheel.slipInfo = 1;\n        if (groundObject) {\n            var defaultRollingFrictionImpulse = 0;\n            var maxImpulse = wheel.brake ? wheel.brake : defaultRollingFrictionImpulse;\n\n            // btWheelContactPoint contactPt(chassisBody,groundObject,wheelInfraycastInfo.hitPointWorld,forwardWS[wheel],maxImpulse);\n            // rollingFriction = calcRollingFriction(contactPt);\n            rollingFriction = calcRollingFriction(chassisBody, groundObject, wheel.raycastResult.hitPointWorld, forwardWS[i], maxImpulse);\n\n            rollingFriction += wheel.engineForce * timeStep;\n\n            // rollingFriction = 0;\n            var factor = maxImpulse / rollingFriction;\n            wheel.slipInfo *= factor;\n        }\n\n        //switch between active rolling (throttle), braking and non-active rolling friction (nthrottle/break)\n\n        wheel.forwardImpulse = 0;\n        wheel.skidInfo = 1;\n\n        if (groundObject) {\n            wheel.skidInfo = 1;\n\n            var maximp = wheel.suspensionForce * timeStep * wheel.frictionSlip;\n            var maximpSide = maximp;\n\n            var maximpSquared = maximp * maximpSide;\n\n            wheel.forwardImpulse = rollingFriction;//wheelInfo.engineForce* timeStep;\n\n            var x = wheel.forwardImpulse * fwdFactor;\n            var y = wheel.sideImpulse * sideFactor;\n\n            var impulseSquared = x * x + y * y;\n\n            wheel.sliding = false;\n            if (impulseSquared > maximpSquared) {\n                this.sliding = true;\n                wheel.sliding = true;\n\n                var factor = maximp / Math.sqrt(impulseSquared);\n\n                wheel.skidInfo *= factor;\n            }\n        }\n    }\n\n    if (this.sliding) {\n        for (var i = 0; i < numWheels; i++) {\n            var wheel = wheelInfos[i];\n            if (wheel.sideImpulse !== 0) {\n                if (wheel.skidInfo < 1){\n                    wheel.forwardImpulse *= wheel.skidInfo;\n                    wheel.sideImpulse *= wheel.skidInfo;\n                }\n            }\n        }\n    }\n\n    // apply the impulses\n    for (var i = 0; i < numWheels; i++) {\n        var wheel = wheelInfos[i];\n\n        var rel_pos = new Vec3();\n        //wheel.raycastResult.hitPointWorld.vsub(chassisBody.position, rel_pos);\n        // cannons applyimpulse is using world coord for the position\n        rel_pos.copy(wheel.raycastResult.hitPointWorld);\n\n        if (wheel.forwardImpulse !== 0) {\n            var impulse = new Vec3();\n            forwardWS[i].scale(wheel.forwardImpulse, impulse);\n            chassisBody.applyImpulse(impulse, rel_pos);\n        }\n\n        if (wheel.sideImpulse !== 0){\n            var groundObject = wheel.raycastResult.body;\n\n            var rel_pos2 = new Vec3();\n            //wheel.raycastResult.hitPointWorld.vsub(groundObject.position, rel_pos2);\n            rel_pos2.copy(wheel.raycastResult.hitPointWorld);\n            var sideImp = new Vec3();\n            axle[i].scale(wheel.sideImpulse, sideImp);\n\n            // Scale the relative position in the up direction with rollInfluence.\n            // If rollInfluence is 1, the impulse will be applied on the hitPoint (easy to roll over), if it is zero it will be applied in the same plane as the center of mass (not easy to roll over).\n            chassisBody.pointToLocalFrame(rel_pos, rel_pos);\n            rel_pos['xyz'[this.indexUpAxis]] *= wheel.rollInfluence;\n            chassisBody.pointToWorldFrame(rel_pos, rel_pos);\n            chassisBody.applyImpulse(sideImp, rel_pos);\n\n            //apply friction impulse on the ground\n            sideImp.scale(-1, sideImp);\n            groundObject.applyImpulse(sideImp, rel_pos2);\n        }\n    }\n};\n\nvar calcRollingFriction_vel1 = new Vec3();\nvar calcRollingFriction_vel2 = new Vec3();\nvar calcRollingFriction_vel = new Vec3();\n\nfunction calcRollingFriction(body0, body1, frictionPosWorld, frictionDirectionWorld, maxImpulse) {\n    var j1 = 0;\n    var contactPosWorld = frictionPosWorld;\n\n    // var rel_pos1 = new Vec3();\n    // var rel_pos2 = new Vec3();\n    var vel1 = calcRollingFriction_vel1;\n    var vel2 = calcRollingFriction_vel2;\n    var vel = calcRollingFriction_vel;\n    // contactPosWorld.vsub(body0.position, rel_pos1);\n    // contactPosWorld.vsub(body1.position, rel_pos2);\n\n    body0.getVelocityAtWorldPoint(contactPosWorld, vel1);\n    body1.getVelocityAtWorldPoint(contactPosWorld, vel2);\n    vel1.vsub(vel2, vel);\n\n    var vrel = frictionDirectionWorld.dot(vel);\n\n    var denom0 = computeImpulseDenominator(body0, frictionPosWorld, frictionDirectionWorld);\n    var denom1 = computeImpulseDenominator(body1, frictionPosWorld, frictionDirectionWorld);\n    var relaxation = 1;\n    var jacDiagABInv = relaxation / (denom0 + denom1);\n\n    // calculate j that moves us to zero relative velocity\n    j1 = -vrel * jacDiagABInv;\n\n    if (maxImpulse < j1) {\n        j1 = maxImpulse;\n    }\n    if (j1 < -maxImpulse) {\n        j1 = -maxImpulse;\n    }\n\n    return j1;\n}\n\nvar computeImpulseDenominator_r0 = new Vec3();\nvar computeImpulseDenominator_c0 = new Vec3();\nvar computeImpulseDenominator_vec = new Vec3();\nvar computeImpulseDenominator_m = new Vec3();\nfunction computeImpulseDenominator(body, pos, normal) {\n    var r0 = computeImpulseDenominator_r0;\n    var c0 = computeImpulseDenominator_c0;\n    var vec = computeImpulseDenominator_vec;\n    var m = computeImpulseDenominator_m;\n\n    pos.vsub(body.position, r0);\n    r0.cross(normal, c0);\n    body.invInertiaWorld.vmult(c0, m);\n    m.cross(r0, vec);\n\n    return body.invMass + normal.dot(vec);\n}\n\n\nvar resolveSingleBilateral_vel1 = new Vec3();\nvar resolveSingleBilateral_vel2 = new Vec3();\nvar resolveSingleBilateral_vel = new Vec3();\n\n//bilateral constraint between two dynamic objects\nfunction resolveSingleBilateral(body1, pos1, body2, pos2, normal, impulse){\n    var normalLenSqr = normal.norm2();\n    if (normalLenSqr > 1.1){\n        return 0; // no impulse\n    }\n    // var rel_pos1 = new Vec3();\n    // var rel_pos2 = new Vec3();\n    // pos1.vsub(body1.position, rel_pos1);\n    // pos2.vsub(body2.position, rel_pos2);\n\n    var vel1 = resolveSingleBilateral_vel1;\n    var vel2 = resolveSingleBilateral_vel2;\n    var vel = resolveSingleBilateral_vel;\n    body1.getVelocityAtWorldPoint(pos1, vel1);\n    body2.getVelocityAtWorldPoint(pos2, vel2);\n\n    vel1.vsub(vel2, vel);\n\n    var rel_vel = normal.dot(vel);\n\n    var contactDamping = 0.2;\n    var massTerm = 1 / (body1.invMass + body2.invMass);\n    var impulse = - contactDamping * rel_vel * massTerm;\n\n    return impulse;\n}\n},{\"../collision/Ray\":9,\"../collision/RaycastResult\":10,\"../math/Quaternion\":25,\"../math/Vec3\":27,\"../objects/WheelInfo\":33,\"./Body\":28}],30:[function(_dereq_,module,exports){\nvar Body = _dereq_('./Body');\nvar Sphere = _dereq_('../shapes/Sphere');\nvar Box = _dereq_('../shapes/Box');\nvar Vec3 = _dereq_('../math/Vec3');\nvar HingeConstraint = _dereq_('../constraints/HingeConstraint');\n\nmodule.exports = RigidVehicle;\n\n/**\n * Simple vehicle helper class with spherical rigid body wheels.\n * @class RigidVehicle\n * @constructor\n * @param {object} [options.chassisBody]\n */\nfunction RigidVehicle(options){\n    this.wheelBodies = [];\n\n    /**\n     * @property coordinateSystem\n     * @type {Vec3}\n     */\n    this.coordinateSystem = typeof(options.coordinateSystem)==='undefined' ? new Vec3(1, 2, 3) : options.coordinateSystem.clone();\n\n    /**\n     * @property {Body} chassisBody\n     */\n    this.chassisBody = options.chassisBody;\n\n    if(!this.chassisBody){\n        // No chassis body given. Create it!\n        var chassisShape = new Box(new Vec3(5, 2, 0.5));\n        this.chassisBody = new Body(1, chassisShape);\n    }\n\n    /**\n     * @property constraints\n     * @type {Array}\n     */\n    this.constraints = [];\n\n    this.wheelAxes = [];\n    this.wheelForces = [];\n}\n\n/**\n * Add a wheel\n * @method addWheel\n * @param {object} options\n * @param {object} [options.isFrontWheel]\n * @param {Vec3} [options.position] Position of the wheel, locally in the chassis body.\n * @param {Vec3} [options.direction] Slide direction of the wheel along the suspension.\n * @param {Vec3} [options.axis] Axis of rotation of the wheel, locally defined in the chassis.\n * @param {Body} [options.body] The wheel body.\n */\nRigidVehicle.prototype.addWheel = function(options){\n    options = options || {};\n    var wheelBody = options.body;\n    if(!wheelBody){\n        wheelBody =  new Body(1, new Sphere(1.2));\n    }\n    this.wheelBodies.push(wheelBody);\n    this.wheelForces.push(0);\n\n    // Position constrain wheels\n    var zero = new Vec3();\n    var position = typeof(options.position) !== 'undefined' ? options.position.clone() : new Vec3();\n\n    // Set position locally to the chassis\n    var worldPosition = new Vec3();\n    this.chassisBody.pointToWorldFrame(position, worldPosition);\n    wheelBody.position.set(worldPosition.x, worldPosition.y, worldPosition.z);\n\n    // Constrain wheel\n    var axis = typeof(options.axis) !== 'undefined' ? options.axis.clone() : new Vec3(0, 1, 0);\n    this.wheelAxes.push(axis);\n\n    var hingeConstraint = new HingeConstraint(this.chassisBody, wheelBody, {\n        pivotA: position,\n        axisA: axis,\n        pivotB: Vec3.ZERO,\n        axisB: axis,\n        collideConnected: false\n    });\n    this.constraints.push(hingeConstraint);\n\n    return this.wheelBodies.length - 1;\n};\n\n/**\n * Set the steering value of a wheel.\n * @method setSteeringValue\n * @param {number} value\n * @param {integer} wheelIndex\n * @todo check coordinateSystem\n */\nRigidVehicle.prototype.setSteeringValue = function(value, wheelIndex){\n    // Set angle of the hinge axis\n    var axis = this.wheelAxes[wheelIndex];\n\n    var c = Math.cos(value),\n        s = Math.sin(value),\n        x = axis.x,\n        y = axis.y;\n    this.constraints[wheelIndex].axisA.set(\n        c*x -s*y,\n        s*x +c*y,\n        0\n    );\n};\n\n/**\n * Set the target rotational speed of the hinge constraint.\n * @method setMotorSpeed\n * @param {number} value\n * @param {integer} wheelIndex\n */\nRigidVehicle.prototype.setMotorSpeed = function(value, wheelIndex){\n    var hingeConstraint = this.constraints[wheelIndex];\n    hingeConstraint.enableMotor();\n    hingeConstraint.motorTargetVelocity = value;\n};\n\n/**\n * Set the target rotational speed of the hinge constraint.\n * @method disableMotor\n * @param {number} value\n * @param {integer} wheelIndex\n */\nRigidVehicle.prototype.disableMotor = function(wheelIndex){\n    var hingeConstraint = this.constraints[wheelIndex];\n    hingeConstraint.disableMotor();\n};\n\nvar torque = new Vec3();\n\n/**\n * Set the wheel force to apply on one of the wheels each time step\n * @method setWheelForce\n * @param  {number} value\n * @param  {integer} wheelIndex\n */\nRigidVehicle.prototype.setWheelForce = function(value, wheelIndex){\n    this.wheelForces[wheelIndex] = value;\n};\n\n/**\n * Apply a torque on one of the wheels.\n * @method applyWheelForce\n * @param  {number} value\n * @param  {integer} wheelIndex\n */\nRigidVehicle.prototype.applyWheelForce = function(value, wheelIndex){\n    var axis = this.wheelAxes[wheelIndex];\n    var wheelBody = this.wheelBodies[wheelIndex];\n    var bodyTorque = wheelBody.tau;\n\n    axis.scale(value, torque);\n    wheelBody.vectorToWorldFrame(torque, torque);\n    bodyTorque.vadd(torque, bodyTorque);\n};\n\n/**\n * Add the vehicle including its constraints to the world.\n * @method addToWorld\n * @param {World} world\n */\nRigidVehicle.prototype.addToWorld = function(world){\n    var constraints = this.constraints;\n    var bodies = this.wheelBodies.concat([this.chassisBody]);\n\n    for (var i = 0; i < bodies.length; i++) {\n        world.add(bodies[i]);\n    }\n\n    for (var i = 0; i < constraints.length; i++) {\n        world.addConstraint(constraints[i]);\n    }\n\n    world.addEventListener('preStep', this._update.bind(this));\n};\n\nRigidVehicle.prototype._update = function(){\n    var wheelForces = this.wheelForces;\n    for (var i = 0; i < wheelForces.length; i++) {\n        this.applyWheelForce(wheelForces[i], i);\n    }\n};\n\n/**\n * Remove the vehicle including its constraints from the world.\n * @method removeFromWorld\n * @param {World} world\n */\nRigidVehicle.prototype.removeFromWorld = function(world){\n    var constraints = this.constraints;\n    var bodies = this.wheelBodies.concat([this.chassisBody]);\n\n    for (var i = 0; i < bodies.length; i++) {\n        world.remove(bodies[i]);\n    }\n\n    for (var i = 0; i < constraints.length; i++) {\n        world.removeConstraint(constraints[i]);\n    }\n};\n\nvar worldAxis = new Vec3();\n\n/**\n * Get current rotational velocity of a wheel\n * @method getWheelSpeed\n * @param {integer} wheelIndex\n */\nRigidVehicle.prototype.getWheelSpeed = function(wheelIndex){\n    var axis = this.wheelAxes[wheelIndex];\n    var wheelBody = this.wheelBodies[wheelIndex];\n    var w = wheelBody.angularVelocity;\n    this.chassisBody.vectorToWorldFrame(axis, worldAxis);\n    return w.dot(worldAxis);\n};\n\n},{\"../constraints/HingeConstraint\":14,\"../math/Vec3\":27,\"../shapes/Box\":34,\"../shapes/Sphere\":41,\"./Body\":28}],31:[function(_dereq_,module,exports){\nmodule.exports = SPHSystem;\n\nvar Shape = _dereq_('../shapes/Shape');\nvar Vec3 = _dereq_('../math/Vec3');\nvar Quaternion = _dereq_('../math/Quaternion');\nvar Particle = _dereq_('../shapes/Particle');\nvar Body = _dereq_('../objects/Body');\nvar Material = _dereq_('../material/Material');\n\n/**\n * Smoothed-particle hydrodynamics system\n * @class SPHSystem\n * @constructor\n */\nfunction SPHSystem(){\n    this.particles = [];\n    this.density = 1; // kg/m3\n    this.smoothingRadius = 1; // Adjust so there are about 15-20 neighbor particles within this radius\n    this.speedOfSound = 1;\n    this.viscosity = 0.01;\n    this.eps = 0.000001;\n\n    // Stuff Computed per particle\n    this.pressures = [];\n    this.densities = [];\n    this.neighbors = [];\n}\n\nSPHSystem.prototype.add = function(particle){\n    this.particles.push(particle);\n    if(this.neighbors.length < this.particles.length){\n        this.neighbors.push([]);\n    }\n};\n\nSPHSystem.prototype.remove = function(particle){\n    var idx = this.particles.indexOf(particle);\n    if(idx !== -1){\n        this.particles.splice(idx,1);\n        if(this.neighbors.length > this.particles.length){\n            this.neighbors.pop();\n        }\n    }\n};\n\n/**\n * Get neighbors within smoothing volume, save in the array neighbors\n * @method getNeighbors\n * @param {Body} particle\n * @param {Array} neighbors\n */\nvar SPHSystem_getNeighbors_dist = new Vec3();\nSPHSystem.prototype.getNeighbors = function(particle,neighbors){\n    var N = this.particles.length,\n        id = particle.id,\n        R2 = this.smoothingRadius * this.smoothingRadius,\n        dist = SPHSystem_getNeighbors_dist;\n    for(var i=0; i!==N; i++){\n        var p = this.particles[i];\n        p.position.vsub(particle.position,dist);\n        if(id!==p.id && dist.norm2() < R2){\n            neighbors.push(p);\n        }\n    }\n};\n\n// Temp vectors for calculation\nvar SPHSystem_update_dist = new Vec3(),\n    SPHSystem_update_a_pressure = new Vec3(),\n    SPHSystem_update_a_visc = new Vec3(),\n    SPHSystem_update_gradW = new Vec3(),\n    SPHSystem_update_r_vec = new Vec3(),\n    SPHSystem_update_u = new Vec3(); // Relative velocity\nSPHSystem.prototype.update = function(){\n    var N = this.particles.length,\n        dist = SPHSystem_update_dist,\n        cs = this.speedOfSound,\n        eps = this.eps;\n\n    for(var i=0; i!==N; i++){\n        var p = this.particles[i]; // Current particle\n        var neighbors = this.neighbors[i];\n\n        // Get neighbors\n        neighbors.length = 0;\n        this.getNeighbors(p,neighbors);\n        neighbors.push(this.particles[i]); // Add current too\n        var numNeighbors = neighbors.length;\n\n        // Accumulate density for the particle\n        var sum = 0.0;\n        for(var j=0; j!==numNeighbors; j++){\n\n            //printf(\"Current particle has position %f %f %f\\n\",objects[id].pos.x(),objects[id].pos.y(),objects[id].pos.z());\n            p.position.vsub(neighbors[j].position, dist);\n            var len = dist.norm();\n\n            var weight = this.w(len);\n            sum += neighbors[j].mass * weight;\n        }\n\n        // Save\n        this.densities[i] = sum;\n        this.pressures[i] = cs * cs * (this.densities[i] - this.density);\n    }\n\n    // Add forces\n\n    // Sum to these accelerations\n    var a_pressure= SPHSystem_update_a_pressure;\n    var a_visc =    SPHSystem_update_a_visc;\n    var gradW =     SPHSystem_update_gradW;\n    var r_vec =     SPHSystem_update_r_vec;\n    var u =         SPHSystem_update_u;\n\n    for(var i=0; i!==N; i++){\n\n        var particle = this.particles[i];\n\n        a_pressure.set(0,0,0);\n        a_visc.set(0,0,0);\n\n        // Init vars\n        var Pij;\n        var nabla;\n        var Vij;\n\n        // Sum up for all other neighbors\n        var neighbors = this.neighbors[i];\n        var numNeighbors = neighbors.length;\n\n        //printf(\"Neighbors: \");\n        for(var j=0; j!==numNeighbors; j++){\n\n            var neighbor = neighbors[j];\n            //printf(\"%d \",nj);\n\n            // Get r once for all..\n            particle.position.vsub(neighbor.position,r_vec);\n            var r = r_vec.norm();\n\n            // Pressure contribution\n            Pij = -neighbor.mass * (this.pressures[i] / (this.densities[i]*this.densities[i] + eps) + this.pressures[j] / (this.densities[j]*this.densities[j] + eps));\n            this.gradw(r_vec, gradW);\n            // Add to pressure acceleration\n            gradW.mult(Pij , gradW);\n            a_pressure.vadd(gradW, a_pressure);\n\n            // Viscosity contribution\n            neighbor.velocity.vsub(particle.velocity, u);\n            u.mult( 1.0 / (0.0001+this.densities[i] * this.densities[j]) * this.viscosity * neighbor.mass , u );\n            nabla = this.nablaw(r);\n            u.mult(nabla,u);\n            // Add to viscosity acceleration\n            a_visc.vadd( u, a_visc );\n        }\n\n        // Calculate force\n        a_visc.mult(particle.mass, a_visc);\n        a_pressure.mult(particle.mass, a_pressure);\n\n        // Add force to particles\n        particle.force.vadd(a_visc, particle.force);\n        particle.force.vadd(a_pressure, particle.force);\n    }\n};\n\n// Calculate the weight using the W(r) weightfunction\nSPHSystem.prototype.w = function(r){\n    // 315\n    var h = this.smoothingRadius;\n    return 315.0/(64.0*Math.PI*Math.pow(h,9)) * Math.pow(h*h-r*r,3);\n};\n\n// calculate gradient of the weight function\nSPHSystem.prototype.gradw = function(rVec,resultVec){\n    var r = rVec.norm(),\n        h = this.smoothingRadius;\n    rVec.mult(945.0/(32.0*Math.PI*Math.pow(h,9)) * Math.pow((h*h-r*r),2) , resultVec);\n};\n\n// Calculate nabla(W)\nSPHSystem.prototype.nablaw = function(r){\n    var h = this.smoothingRadius;\n    var nabla = 945.0/(32.0*Math.PI*Math.pow(h,9)) * (h*h-r*r)*(7*r*r - 3*h*h);\n    return nabla;\n};\n\n},{\"../material/Material\":22,\"../math/Quaternion\":25,\"../math/Vec3\":27,\"../objects/Body\":28,\"../shapes/Particle\":38,\"../shapes/Shape\":40}],32:[function(_dereq_,module,exports){\nvar Vec3 = _dereq_('../math/Vec3');\n\nmodule.exports = Spring;\n\n/**\n * A spring, connecting two bodies.\n *\n * @class Spring\n * @constructor\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Object} [options]\n * @param {number} [options.restLength]   A number > 0. Default: 1\n * @param {number} [options.stiffness]    A number >= 0. Default: 100\n * @param {number} [options.damping]      A number >= 0. Default: 1\n * @param {Vec3}  [options.worldAnchorA] Where to hook the spring to body A, in world coordinates.\n * @param {Vec3}  [options.worldAnchorB]\n * @param {Vec3}  [options.localAnchorA] Where to hook the spring to body A, in local body coordinates.\n * @param {Vec3}  [options.localAnchorB]\n */\nfunction Spring(bodyA,bodyB,options){\n    options = options || {};\n\n    /**\n     * Rest length of the spring.\n     * @property restLength\n     * @type {number}\n     */\n    this.restLength = typeof(options.restLength) === \"number\" ? options.restLength : 1;\n\n    /**\n     * Stiffness of the spring.\n     * @property stiffness\n     * @type {number}\n     */\n    this.stiffness = options.stiffness || 100;\n\n    /**\n     * Damping of the spring.\n     * @property damping\n     * @type {number}\n     */\n    this.damping = options.damping || 1;\n\n    /**\n     * First connected body.\n     * @property bodyA\n     * @type {Body}\n     */\n    this.bodyA = bodyA;\n\n    /**\n     * Second connected body.\n     * @property bodyB\n     * @type {Body}\n     */\n    this.bodyB = bodyB;\n\n    /**\n     * Anchor for bodyA in local bodyA coordinates.\n     * @property localAnchorA\n     * @type {Vec3}\n     */\n    this.localAnchorA = new Vec3();\n\n    /**\n     * Anchor for bodyB in local bodyB coordinates.\n     * @property localAnchorB\n     * @type {Vec3}\n     */\n    this.localAnchorB = new Vec3();\n\n    if(options.localAnchorA){\n        this.localAnchorA.copy(options.localAnchorA);\n    }\n    if(options.localAnchorB){\n        this.localAnchorB.copy(options.localAnchorB);\n    }\n    if(options.worldAnchorA){\n        this.setWorldAnchorA(options.worldAnchorA);\n    }\n    if(options.worldAnchorB){\n        this.setWorldAnchorB(options.worldAnchorB);\n    }\n}\n\n/**\n * Set the anchor point on body A, using world coordinates.\n * @method setWorldAnchorA\n * @param {Vec3} worldAnchorA\n */\nSpring.prototype.setWorldAnchorA = function(worldAnchorA){\n    this.bodyA.pointToLocalFrame(worldAnchorA,this.localAnchorA);\n};\n\n/**\n * Set the anchor point on body B, using world coordinates.\n * @method setWorldAnchorB\n * @param {Vec3} worldAnchorB\n */\nSpring.prototype.setWorldAnchorB = function(worldAnchorB){\n    this.bodyB.pointToLocalFrame(worldAnchorB,this.localAnchorB);\n};\n\n/**\n * Get the anchor point on body A, in world coordinates.\n * @method getWorldAnchorA\n * @param {Vec3} result The vector to store the result in.\n */\nSpring.prototype.getWorldAnchorA = function(result){\n    this.bodyA.pointToWorldFrame(this.localAnchorA,result);\n};\n\n/**\n * Get the anchor point on body B, in world coordinates.\n * @method getWorldAnchorB\n * @param {Vec3} result The vector to store the result in.\n */\nSpring.prototype.getWorldAnchorB = function(result){\n    this.bodyB.pointToWorldFrame(this.localAnchorB,result);\n};\n\nvar applyForce_r =              new Vec3(),\n    applyForce_r_unit =         new Vec3(),\n    applyForce_u =              new Vec3(),\n    applyForce_f =              new Vec3(),\n    applyForce_worldAnchorA =   new Vec3(),\n    applyForce_worldAnchorB =   new Vec3(),\n    applyForce_ri =             new Vec3(),\n    applyForce_rj =             new Vec3(),\n    applyForce_ri_x_f =         new Vec3(),\n    applyForce_rj_x_f =         new Vec3(),\n    applyForce_tmp =            new Vec3();\n\n/**\n * Apply the spring force to the connected bodies.\n * @method applyForce\n */\nSpring.prototype.applyForce = function(){\n    var k = this.stiffness,\n        d = this.damping,\n        l = this.restLength,\n        bodyA = this.bodyA,\n        bodyB = this.bodyB,\n        r = applyForce_r,\n        r_unit = applyForce_r_unit,\n        u = applyForce_u,\n        f = applyForce_f,\n        tmp = applyForce_tmp;\n\n    var worldAnchorA = applyForce_worldAnchorA,\n        worldAnchorB = applyForce_worldAnchorB,\n        ri = applyForce_ri,\n        rj = applyForce_rj,\n        ri_x_f = applyForce_ri_x_f,\n        rj_x_f = applyForce_rj_x_f;\n\n    // Get world anchors\n    this.getWorldAnchorA(worldAnchorA);\n    this.getWorldAnchorB(worldAnchorB);\n\n    // Get offset points\n    worldAnchorA.vsub(bodyA.position,ri);\n    worldAnchorB.vsub(bodyB.position,rj);\n\n    // Compute distance vector between world anchor points\n    worldAnchorB.vsub(worldAnchorA,r);\n    var rlen = r.norm();\n    r_unit.copy(r);\n    r_unit.normalize();\n\n    // Compute relative velocity of the anchor points, u\n    bodyB.velocity.vsub(bodyA.velocity,u);\n    // Add rotational velocity\n\n    bodyB.angularVelocity.cross(rj,tmp);\n    u.vadd(tmp,u);\n    bodyA.angularVelocity.cross(ri,tmp);\n    u.vsub(tmp,u);\n\n    // F = - k * ( x - L ) - D * ( u )\n    r_unit.mult(-k*(rlen-l) - d*u.dot(r_unit), f);\n\n    // Add forces to bodies\n    bodyA.force.vsub(f,bodyA.force);\n    bodyB.force.vadd(f,bodyB.force);\n\n    // Angular force\n    ri.cross(f,ri_x_f);\n    rj.cross(f,rj_x_f);\n    bodyA.tau.vsub(ri_x_f,bodyA.tau);\n    bodyB.tau.vadd(rj_x_f,bodyB.tau);\n};\n\n},{\"../math/Vec3\":27}],33:[function(_dereq_,module,exports){\nvar Vec3 = _dereq_('../math/Vec3');\nvar Transform = _dereq_('../math/Transform');\nvar RaycastResult = _dereq_('../collision/RaycastResult');\nvar Utils = _dereq_('../utils/Utils');\n\nmodule.exports = WheelInfo;\n\n/**\n * @class WheelInfo\n * @constructor\n * @param {Object} [options]\n *\n * @param {Vec3} [options.chassisConnectionPointLocal]\n * @param {Vec3} [options.chassisConnectionPointWorld]\n * @param {Vec3} [options.directionLocal]\n * @param {Vec3} [options.directionWorld]\n * @param {Vec3} [options.axleLocal]\n * @param {Vec3} [options.axleWorld]\n * @param {number} [options.suspensionRestLength=1]\n * @param {number} [options.suspensionMaxLength=2]\n * @param {number} [options.radius=1]\n * @param {number} [options.suspensionStiffness=100]\n * @param {number} [options.dampingCompression=10]\n * @param {number} [options.dampingRelaxation=10]\n * @param {number} [options.frictionSlip=10000]\n * @param {number} [options.steering=0]\n * @param {number} [options.rotation=0]\n * @param {number} [options.deltaRotation=0]\n * @param {number} [options.rollInfluence=0.01]\n * @param {number} [options.maxSuspensionForce]\n * @param {number} [options.isFrontWheel=true]\n * @param {number} [options.clippedInvContactDotSuspension=1]\n * @param {number} [options.suspensionRelativeVelocity=0]\n * @param {number} [options.suspensionForce=0]\n * @param {number} [options.skidInfo=0]\n * @param {number} [options.suspensionLength=0]\n * @param {number} [options.maxSuspensionTravel=1]\n * @param {number} [options.useCustomSlidingRotationalSpeed=false]\n * @param {number} [options.customSlidingRotationalSpeed=-0.1]\n */\nfunction WheelInfo(options){\n    options = Utils.defaults(options, {\n        chassisConnectionPointLocal: new Vec3(),\n        chassisConnectionPointWorld: new Vec3(),\n        directionLocal: new Vec3(),\n        directionWorld: new Vec3(),\n        axleLocal: new Vec3(),\n        axleWorld: new Vec3(),\n        suspensionRestLength: 1,\n        suspensionMaxLength: 2,\n        radius: 1,\n        suspensionStiffness: 100,\n        dampingCompression: 10,\n        dampingRelaxation: 10,\n        frictionSlip: 10000,\n        steering: 0,\n        rotation: 0,\n        deltaRotation: 0,\n        rollInfluence: 0.01,\n        maxSuspensionForce: Number.MAX_VALUE,\n        isFrontWheel: true,\n        clippedInvContactDotSuspension: 1,\n        suspensionRelativeVelocity: 0,\n        suspensionForce: 0,\n        skidInfo: 0,\n        suspensionLength: 0,\n        maxSuspensionTravel: 1,\n        useCustomSlidingRotationalSpeed: false,\n        customSlidingRotationalSpeed: -0.1\n    });\n\n    /**\n     * @property {number} maxSuspensionTravel\n     */\n    this.maxSuspensionTravel = options.maxSuspensionTravel;\n\n    /**\n     * @property {number} customSlidingRotationalSpeed\n     */\n    this.customSlidingRotationalSpeed = options.customSlidingRotationalSpeed;\n\n    /**\n     * @property {Boolean} useCustomSlidingRotationalSpeed]\n     */\n    this.useCustomSlidingRotationalSpeed = options.useCustomSlidingRotationalSpeed;\n\n    /**\n     * @property {Boolean} sliding\n     */\n    this.sliding = false;\n\n    /**\n     * @property {Vec3} chassisConnectionPointLocal\n     */\n    this.chassisConnectionPointLocal = options.chassisConnectionPointLocal.clone();\n\n    /**\n     * @property {Vec3} chassisConnectionPointWorld\n     */\n    this.chassisConnectionPointWorld = options.chassisConnectionPointWorld.clone();\n\n    /**\n     * @property {Vec3} directionLocal\n     */\n    this.directionLocal = options.directionLocal.clone();\n\n    /**\n     * @property {Vec3} directionWorld\n     */\n    this.directionWorld = options.directionWorld.clone();\n\n    /**\n     * @property {Vec3} axleLocal\n     */\n    this.axleLocal = options.axleLocal.clone();\n\n    /**\n     * @property {Vec3} axleWorld\n     */\n    this.axleWorld = options.axleWorld.clone();\n\n    /**\n     * @property {number} suspensionRestLength\n     */\n    this.suspensionRestLength = options.suspensionRestLength;\n\n    /**\n     * @property {number} suspensionMaxLength\n     */\n    this.suspensionMaxLength = options.suspensionMaxLength;\n\n    /**\n     * @property {number} radius\n     */\n    this.radius = options.radius;\n\n    /**\n     * @property {number} suspensionStiffness\n     */\n    this.suspensionStiffness = options.suspensionStiffness;\n\n    /**\n     * @property {number} dampingCompression\n     */\n    this.dampingCompression = options.dampingCompression;\n\n    /**\n     * @property {number} dampingRelaxation\n     */\n    this.dampingRelaxation = options.dampingRelaxation;\n\n    /**\n     * @property {number} frictionSlip\n     */\n    this.frictionSlip = options.frictionSlip;\n\n    /**\n     * @property {number} steering\n     */\n    this.steering = 0;\n\n    /**\n     * @property {number} rotation\n     */\n    this.rotation = 0;\n\n    /**\n     * @property {number} deltaRotation\n     */\n    this.deltaRotation = 0;\n\n    /**\n     * @property {number} rollInfluence\n     */\n    this.rollInfluence = options.rollInfluence;\n\n    /**\n     * @property {number} maxSuspensionForce\n     */\n    this.maxSuspensionForce = options.maxSuspensionForce;\n\n    /**\n     * @property {number} engineForce\n     */\n    this.engineForce = 0;\n\n    /**\n     * @property {number} brake\n     */\n    this.brake = 0;\n\n    /**\n     * @property {number} isFrontWheel\n     */\n    this.isFrontWheel = options.isFrontWheel;\n\n    /**\n     * @property {number} clippedInvContactDotSuspension\n     */\n    this.clippedInvContactDotSuspension = 1;\n\n    /**\n     * @property {number} suspensionRelativeVelocity\n     */\n    this.suspensionRelativeVelocity = 0;\n\n    /**\n     * @property {number} suspensionForce\n     */\n    this.suspensionForce = 0;\n\n    /**\n     * @property {number} skidInfo\n     */\n    this.skidInfo = 0;\n\n    /**\n     * @property {number} suspensionLength\n     */\n    this.suspensionLength = 0;\n\n    /**\n     * @property {number} sideImpulse\n     */\n    this.sideImpulse = 0;\n\n    /**\n     * @property {number} forwardImpulse\n     */\n    this.forwardImpulse = 0;\n\n    /**\n     * The result from raycasting\n     * @property {RaycastResult} raycastResult\n     */\n    this.raycastResult = new RaycastResult();\n\n    /**\n     * Wheel world transform\n     * @property {Transform} worldTransform\n     */\n    this.worldTransform = new Transform();\n\n    /**\n     * @property {boolean} isInContact\n     */\n    this.isInContact = false;\n}\n\nvar chassis_velocity_at_contactPoint = new Vec3();\nvar relpos = new Vec3();\nvar chassis_velocity_at_contactPoint = new Vec3();\nWheelInfo.prototype.updateWheel = function(chassis){\n    var raycastResult = this.raycastResult;\n\n    if (this.isInContact){\n        var project= raycastResult.hitNormalWorld.dot(raycastResult.directionWorld);\n        raycastResult.hitPointWorld.vsub(chassis.position, relpos);\n        chassis.getVelocityAtWorldPoint(relpos, chassis_velocity_at_contactPoint);\n        var projVel = raycastResult.hitNormalWorld.dot( chassis_velocity_at_contactPoint );\n        if (project >= -0.1) {\n            this.suspensionRelativeVelocity = 0.0;\n            this.clippedInvContactDotSuspension = 1.0 / 0.1;\n        } else {\n            var inv = -1 / project;\n            this.suspensionRelativeVelocity = projVel * inv;\n            this.clippedInvContactDotSuspension = inv;\n        }\n\n    } else {\n        // Not in contact : position wheel in a nice (rest length) position\n        raycastResult.suspensionLength = this.suspensionRestLength;\n        this.suspensionRelativeVelocity = 0.0;\n        raycastResult.directionWorld.scale(-1, raycastResult.hitNormalWorld);\n        this.clippedInvContactDotSuspension = 1.0;\n    }\n};\n},{\"../collision/RaycastResult\":10,\"../math/Transform\":26,\"../math/Vec3\":27,\"../utils/Utils\":48}],34:[function(_dereq_,module,exports){\nmodule.exports = Box;\n\nvar Shape = _dereq_('./Shape');\nvar Vec3 = _dereq_('../math/Vec3');\nvar ConvexPolyhedron = _dereq_('./ConvexPolyhedron');\n\n/**\n * A 3d box shape.\n * @class Box\n * @constructor\n * @param {Vec3} halfExtents\n * @author schteppe\n * @extends Shape\n */\nfunction Box(halfExtents){\n    Shape.call(this);\n\n    this.type = Shape.types.BOX;\n\n    /**\n     * @property halfExtents\n     * @type {Vec3}\n     */\n    this.halfExtents = halfExtents;\n\n    /**\n     * Used by the contact generator to make contacts with other convex polyhedra for example\n     * @property convexPolyhedronRepresentation\n     * @type {ConvexPolyhedron}\n     */\n    this.convexPolyhedronRepresentation = null;\n\n    this.updateConvexPolyhedronRepresentation();\n    this.updateBoundingSphereRadius();\n}\nBox.prototype = new Shape();\nBox.prototype.constructor = Box;\n\n/**\n * Updates the local convex polyhedron representation used for some collisions.\n * @method updateConvexPolyhedronRepresentation\n */\nBox.prototype.updateConvexPolyhedronRepresentation = function(){\n    var sx = this.halfExtents.x;\n    var sy = this.halfExtents.y;\n    var sz = this.halfExtents.z;\n    var V = Vec3;\n\n    var h = new ConvexPolyhedron([new V(-sx,-sy,-sz),\n                                         new V( sx,-sy,-sz),\n                                         new V( sx, sy,-sz),\n                                         new V(-sx, sy,-sz),\n                                         new V(-sx,-sy, sz),\n                                         new V( sx,-sy, sz),\n                                         new V( sx, sy, sz),\n                                         new V(-sx, sy, sz)],\n                                         [[3,2,1,0], // -z\n                                          [4,5,6,7], // +z\n                                          [5,4,0,1], // -y\n                                          [2,3,7,6], // +y\n                                          [0,4,7,3], // -x\n                                          [1,2,6,5], // +x\n                                          ],\n                                        [new V( 0, 0,-1),\n                                         new V( 0, 0, 1),\n                                         new V( 0,-1, 0),\n                                         new V( 0, 1, 0),\n                                         new V(-1, 0, 0),\n                                         new V( 1, 0, 0)]);\n    this.convexPolyhedronRepresentation = h;\n};\n\n/**\n * @method calculateLocalInertia\n * @param  {Number} mass\n * @param  {Vec3} target\n * @return {Vec3}\n */\nBox.prototype.calculateLocalInertia = function(mass,target){\n    target = target || new Vec3();\n    Box.calculateInertia(this.halfExtents, mass, target);\n    return target;\n};\n\nBox.calculateInertia = function(halfExtents,mass,target){\n    var e = halfExtents;\n    target.x = 1.0 / 12.0 * mass * (   2*e.y*2*e.y + 2*e.z*2*e.z );\n    target.y = 1.0 / 12.0 * mass * (   2*e.x*2*e.x + 2*e.z*2*e.z );\n    target.z = 1.0 / 12.0 * mass * (   2*e.y*2*e.y + 2*e.x*2*e.x );\n};\n\n/**\n * Get the box 6 side normals\n * @method getSideNormals\n * @param {Boolean}     includeNegative If true, this function returns 6 vectors. If false, it only returns 3 (but you get 6 by reversing those 3)\n * @param {Quaternion}  quat            Orientation to apply to the normal vectors. If not provided, the vectors will be in respect to the local frame.\n * @return {array}\n */\nBox.prototype.getSideNormals = function(sixTargetVectors,quat){\n    var sides = sixTargetVectors;\n    var ex = this.halfExtents;\n    sides[0].set(  ex.x,     0,     0);\n    sides[1].set(     0,  ex.y,     0);\n    sides[2].set(     0,     0,  ex.z);\n    sides[3].set( -ex.x,     0,     0);\n    sides[4].set(     0, -ex.y,     0);\n    sides[5].set(     0,     0, -ex.z);\n\n    if(quat!==undefined){\n        for(var i=0; i!==sides.length; i++){\n            quat.vmult(sides[i],sides[i]);\n        }\n    }\n\n    return sides;\n};\n\nBox.prototype.volume = function(){\n    return 8.0 * this.halfExtents.x * this.halfExtents.y * this.halfExtents.z;\n};\n\nBox.prototype.updateBoundingSphereRadius = function(){\n    this.boundingSphereRadius = this.halfExtents.norm();\n};\n\nvar worldCornerTempPos = new Vec3();\nvar worldCornerTempNeg = new Vec3();\nBox.prototype.forEachWorldCorner = function(pos,quat,callback){\n\n    var e = this.halfExtents;\n    var corners = [[  e.x,  e.y,  e.z],\n                   [ -e.x,  e.y,  e.z],\n                   [ -e.x, -e.y,  e.z],\n                   [ -e.x, -e.y, -e.z],\n                   [  e.x, -e.y, -e.z],\n                   [  e.x,  e.y, -e.z],\n                   [ -e.x,  e.y, -e.z],\n                   [  e.x, -e.y,  e.z]];\n    for(var i=0; i<corners.length; i++){\n        worldCornerTempPos.set(corners[i][0],corners[i][1],corners[i][2]);\n        quat.vmult(worldCornerTempPos,worldCornerTempPos);\n        pos.vadd(worldCornerTempPos,worldCornerTempPos);\n        callback(worldCornerTempPos.x,\n                 worldCornerTempPos.y,\n                 worldCornerTempPos.z);\n    }\n};\n\nvar worldCornersTemp = [\n    new Vec3(),\n    new Vec3(),\n    new Vec3(),\n    new Vec3(),\n    new Vec3(),\n    new Vec3(),\n    new Vec3(),\n    new Vec3()\n];\nBox.prototype.calculateWorldAABB = function(pos,quat,min,max){\n\n    var e = this.halfExtents;\n    worldCornersTemp[0].set(e.x, e.y, e.z);\n    worldCornersTemp[1].set(-e.x,  e.y, e.z);\n    worldCornersTemp[2].set(-e.x, -e.y, e.z);\n    worldCornersTemp[3].set(-e.x, -e.y, -e.z);\n    worldCornersTemp[4].set(e.x, -e.y, -e.z);\n    worldCornersTemp[5].set(e.x,  e.y, -e.z);\n    worldCornersTemp[6].set(-e.x,  e.y, -e.z);\n    worldCornersTemp[7].set(e.x, -e.y,  e.z);\n\n    var wc = worldCornersTemp[0];\n    quat.vmult(wc, wc);\n    pos.vadd(wc, wc);\n    max.copy(wc);\n    min.copy(wc);\n    for(var i=1; i<8; i++){\n        var wc = worldCornersTemp[i];\n        quat.vmult(wc, wc);\n        pos.vadd(wc, wc);\n        var x = wc.x;\n        var y = wc.y;\n        var z = wc.z;\n        if(x > max.x){\n            max.x = x;\n        }\n        if(y > max.y){\n            max.y = y;\n        }\n        if(z > max.z){\n            max.z = z;\n        }\n\n        if(x < min.x){\n            min.x = x;\n        }\n        if(y < min.y){\n            min.y = y;\n        }\n        if(z < min.z){\n            min.z = z;\n        }\n    }\n\n    // Get each axis max\n    // min.set(Infinity,Infinity,Infinity);\n    // max.set(-Infinity,-Infinity,-Infinity);\n    // this.forEachWorldCorner(pos,quat,function(x,y,z){\n    //     if(x > max.x){\n    //         max.x = x;\n    //     }\n    //     if(y > max.y){\n    //         max.y = y;\n    //     }\n    //     if(z > max.z){\n    //         max.z = z;\n    //     }\n\n    //     if(x < min.x){\n    //         min.x = x;\n    //     }\n    //     if(y < min.y){\n    //         min.y = y;\n    //     }\n    //     if(z < min.z){\n    //         min.z = z;\n    //     }\n    // });\n};\n\n},{\"../math/Vec3\":27,\"./ConvexPolyhedron\":35,\"./Shape\":40}],35:[function(_dereq_,module,exports){\nmodule.exports = ConvexPolyhedron;\n\nvar Shape = _dereq_('./Shape');\nvar Vec3 = _dereq_('../math/Vec3');\nvar Quaternion = _dereq_('../math/Quaternion');\nvar Transform = _dereq_('../math/Transform');\n\n/**\n * A set of polygons describing a convex shape.\n * @class ConvexPolyhedron\n * @constructor\n * @extends Shape\n * @description The shape MUST be convex for the code to work properly. No polygons may be coplanar (contained\n * in the same 3D plane), instead these should be merged into one polygon.\n *\n * @param {array} points An array of Vec3's\n * @param {array} faces Array of integer arrays, describing which vertices that is included in each face.\n * @param {array} normals Deprecated. Normals are now automatically generated from polygons.\n *\n * @author qiao / https://github.com/qiao (original author, see https://github.com/qiao/three.js/commit/85026f0c769e4000148a67d45a9e9b9c5108836f)\n * @author schteppe / https://github.com/schteppe\n * @see http://www.altdevblogaday.com/2011/05/13/contact-generation-between-3d-convex-meshes/\n * @see http://bullet.googlecode.com/svn/trunk/src/BulletCollision/NarrowPhaseCollision/btPolyhedralContactClipping.cpp\n *\n * @todo Move the clipping functions to ContactGenerator?\n * @todo Automatically merge coplanar polygons in constructor.\n */\nfunction ConvexPolyhedron( points , faces , normals ) {\n    var that = this;\n    Shape.call( this );\n    this.type = Shape.types.CONVEXPOLYHEDRON;\n\n    /**\n     * Array of Vec3\n     * @property vertices\n     * @type {Array}\n     */\n    this.vertices = points||[];\n\n    this.worldVertices = []; // World transformed version of .vertices\n    this.worldVerticesNeedsUpdate = true;\n\n    /**\n     * Array of integer arrays, indicating which vertices each face consists of\n     * @property faces\n     * @type {Array}\n     */\n    this.faces = faces||[];\n\n    /**\n     * Array of Vec3\n     * @property faceNormals\n     * @type {Array}\n     */\n    this.faceNormals = [];\n    this.computeNormals();\n\n    this.worldFaceNormalsNeedsUpdate = true;\n    this.worldFaceNormals = []; // World transformed version of .faceNormals\n\n    /**\n     * Array of Vec3\n     * @property uniqueEdges\n     * @type {Array}\n     */\n    this.uniqueEdges = [];\n\n    this.computeEdges();\n    this.updateBoundingSphereRadius();\n}\nConvexPolyhedron.prototype = new Shape();\nConvexPolyhedron.prototype.constructor = ConvexPolyhedron;\n\n/**\n * Computes uniqueEdges\n * @method computeEdges\n */\nConvexPolyhedron.prototype.computeEdges = function(){\n    var faces = this.faces;\n    var vertices = this.vertices;\n    var nv = vertices.length;\n    var edges = this.uniqueEdges;\n\n    edges.length = 0;\n\n    for(var pi=0; pi<nv; pi++){\n        var p = vertices[pi];\n        if(!(p instanceof Vec3)){\n            throw \"Argument 1 must be instance of Vec3\";\n        }\n        this.uniqueEdges.push(p);\n    }\n\n    for(var i=0; i<faces.length; i++){\n        var face = faces[i];\n        var numVertices = face.length;\n        for(var j = 0; j < numVertices; j++){\n            var k = ( j+1 ) % numVertices;\n            var edge = new Vec3();\n            vertices[face[j]].vsub(vertices[face[k]], edge);\n            edge.normalize();\n            var found = false;\n            for(var p=0; p < edges.length; p++){\n                if (edges[p].almostEquals(edge) || edges[p].almostEquals(edge)){\n                    found = true;\n                    break;\n                }\n            }\n\n            if (!found){\n                edges.push(edge);\n            }\n\n            if (edge) {\n                edge.face1 = i;\n            } else {\n                /*\n                var ed;\n                ed.m_face0 = i;\n                edges.insert(vp,ed);\n                 */\n            }\n        }\n    }\n};\n\n/**\n * Compute the normals of the faces. Will reuse existing Vec3 objects in the .faceNormals array if they exist.\n * @method computeNormals\n */\nConvexPolyhedron.prototype.computeNormals = function(){\n    this.faceNormals.length = this.faces.length;\n\n    // Generate normals\n    for(var i=0; i<this.faces.length; i++){\n\n        // Check so all vertices exists for this face\n        for(var j=0; j<this.faces[i].length; j++){\n            if(!this.vertices[this.faces[i][j]]){\n                throw new Error(\"Vertex \"+this.faces[i][j]+\" not found!\");\n            }\n        }\n\n        var n = this.faceNormals[i] || new Vec3();\n        this.getFaceNormal(i,n);\n        n.negate(n);\n        this.faceNormals[i] = n;\n        var vertex = this.vertices[this.faces[i][0]];\n        if(n.dot(vertex) < 0){\n            console.error(\".faceNormals[\" + i + \"] = Vec3(\"+n.toString()+\") looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.\");\n            for(var j=0; j<this.faces[i].length; j++){\n                console.warn(\".vertices[\"+this.faces[i][j]+\"] = Vec3(\"+this.vertices[this.faces[i][j]].toString()+\")\");\n            }\n        }\n    }\n};\n\n/**\n * Get face normal given 3 vertices\n * @static\n * @method getFaceNormal\n * @param {Vec3} va\n * @param {Vec3} vb\n * @param {Vec3} vc\n * @param {Vec3} target\n */\nvar cb = new Vec3();\nvar ab = new Vec3();\nConvexPolyhedron.computeNormal = function ( va, vb, vc, target ) {\n    vb.vsub(va,ab);\n    vc.vsub(vb,cb);\n    cb.cross(ab,target);\n    if ( !target.isZero() ) {\n        target.normalize();\n    }\n};\n\n/**\n * Compute the normal of a face from its vertices\n * @method getFaceNormal\n * @param  {Number} i\n * @param  {Vec3} target\n */\nConvexPolyhedron.prototype.getFaceNormal = function(i,target){\n    var f = this.faces[i];\n    var va = this.vertices[f[0]];\n    var vb = this.vertices[f[1]];\n    var vc = this.vertices[f[2]];\n    return ConvexPolyhedron.computeNormal(va,vb,vc,target);\n};\n\n/**\n * @method clipAgainstHull\n * @param {Vec3} posA\n * @param {Quaternion} quatA\n * @param {ConvexPolyhedron} hullB\n * @param {Vec3} posB\n * @param {Quaternion} quatB\n * @param {Vec3} separatingNormal\n * @param {Number} minDist Clamp distance\n * @param {Number} maxDist\n * @param {array} result The an array of contact point objects, see clipFaceAgainstHull\n * @see http://bullet.googlecode.com/svn/trunk/src/BulletCollision/NarrowPhaseCollision/btPolyhedralContactClipping.cpp\n */\nvar cah_WorldNormal = new Vec3();\nConvexPolyhedron.prototype.clipAgainstHull = function(posA,quatA,hullB,posB,quatB,separatingNormal,minDist,maxDist,result){\n    var WorldNormal = cah_WorldNormal;\n    if(!(posA instanceof Vec3)){\n        throw new Error(\"posA must be Vec3\");\n    }\n    if(!(quatA instanceof Quaternion)){\n        throw new Error(\"quatA must be Quaternion\");\n    }\n    var hullA = this;\n    var curMaxDist = maxDist;\n    var closestFaceB = -1;\n    var dmax = -Infinity;\n    for(var face=0; face < hullB.faces.length; face++){\n        WorldNormal.copy(hullB.faceNormals[face]);\n        quatB.vmult(WorldNormal,WorldNormal);\n        //posB.vadd(WorldNormal,WorldNormal);\n        var d = WorldNormal.dot(separatingNormal);\n        if (d > dmax){\n            dmax = d;\n            closestFaceB = face;\n        }\n    }\n    var worldVertsB1 = [];\n    var polyB = hullB.faces[closestFaceB];\n    var numVertices = polyB.length;\n    for(var e0=0; e0<numVertices; e0++){\n        var b = hullB.vertices[polyB[e0]];\n        var worldb = new Vec3();\n        worldb.copy(b);\n        quatB.vmult(worldb,worldb);\n        posB.vadd(worldb,worldb);\n        worldVertsB1.push(worldb);\n    }\n\n    if (closestFaceB>=0){\n        this.clipFaceAgainstHull(separatingNormal,\n                                 posA,\n                                 quatA,\n                                 worldVertsB1,\n                                 minDist,\n                                 maxDist,\n                                 result);\n    }\n};\n\n/**\n * Find the separating axis between this hull and another\n * @method findSeparatingAxis\n * @param {ConvexPolyhedron} hullB\n * @param {Vec3} posA\n * @param {Quaternion} quatA\n * @param {Vec3} posB\n * @param {Quaternion} quatB\n * @param {Vec3} target The target vector to save the axis in\n * @return {bool} Returns false if a separation is found, else true\n */\nvar fsa_faceANormalWS3 = new Vec3(),\n    fsa_Worldnormal1 = new Vec3(),\n    fsa_deltaC = new Vec3(),\n    fsa_worldEdge0 = new Vec3(),\n    fsa_worldEdge1 = new Vec3(),\n    fsa_Cross = new Vec3();\nConvexPolyhedron.prototype.findSeparatingAxis = function(hullB,posA,quatA,posB,quatB,target){\n    var faceANormalWS3 = fsa_faceANormalWS3,\n        Worldnormal1 = fsa_Worldnormal1,\n        deltaC = fsa_deltaC,\n        worldEdge0 = fsa_worldEdge0,\n        worldEdge1 = fsa_worldEdge1,\n        Cross = fsa_Cross;\n\n    var dmin = Infinity;\n    var hullA = this;\n    var curPlaneTests=0;\n    var numFacesA = hullA.faces.length;\n\n    // Test normals from hullA\n    for(var i=0; i<numFacesA; i++){\n        // Get world face normal\n        faceANormalWS3.copy(hullA.faceNormals[i]);\n        quatA.vmult(faceANormalWS3,faceANormalWS3);\n        //posA.vadd(faceANormalWS3,faceANormalWS3); // Needed?\n        //console.log(\"face normal:\",hullA.faceNormals[i].toString(),\"world face normal:\",faceANormalWS3);\n        var d = hullA.testSepAxis(faceANormalWS3, hullB, posA, quatA, posB, quatB);\n        if(d===false){\n            return false;\n        }\n\n        if(d<dmin){\n            dmin = d;\n            target.copy(faceANormalWS3);\n        }\n    }\n\n    // Test normals from hullB\n    var numFacesB = hullB.faces.length;\n    for(var i=0;i<numFacesB;i++){\n        Worldnormal1.copy(hullB.faceNormals[i]);\n        quatB.vmult(Worldnormal1,Worldnormal1);\n        //posB.vadd(Worldnormal1,Worldnormal1);\n        //console.log(\"facenormal\",hullB.faceNormals[i].toString(),\"world:\",Worldnormal1.toString());\n        curPlaneTests++;\n        var d = hullA.testSepAxis(Worldnormal1, hullB,posA,quatA,posB,quatB);\n        if(d===false){\n            return false;\n        }\n\n        if(d<dmin){\n            dmin = d;\n            target.copy(Worldnormal1);\n        }\n    }\n\n    var edgeAstart,edgeAend,edgeBstart,edgeBend;\n\n    var curEdgeEdge = 0;\n    // Test edges\n    for(var e0=0; e0<hullA.uniqueEdges.length; e0++){\n        // Get world edge\n        worldEdge0.copy(hullA.uniqueEdges[e0]);\n        quatA.vmult(worldEdge0,worldEdge0);\n        //posA.vadd(worldEdge0,worldEdge0); // needed?\n\n        //console.log(\"edge0:\",worldEdge0.toString());\n\n        for(var e1=0; e1<hullB.uniqueEdges.length; e1++){\n            worldEdge1.copy(hullB.uniqueEdges[e1]);\n            quatB.vmult(worldEdge1,worldEdge1);\n            //posB.vadd(worldEdge1,worldEdge1); // needed?\n            //console.log(\"edge1:\",worldEdge1.toString());\n            worldEdge0.cross(worldEdge1,Cross);\n            curEdgeEdge++;\n            if(!Cross.almostZero()){\n                Cross.normalize();\n                var dist = hullA.testSepAxis( Cross, hullB, posA,quatA,posB,quatB);\n                if(dist===false){\n                    return false;\n                }\n                if(dist<dmin){\n                    dmin = dist;\n                    target.copy(Cross);\n                }\n            }\n        }\n    }\n\n    posB.vsub(posA,deltaC);\n    if((deltaC.dot(target))>0.0){\n        target.negate(target);\n    }\n    return true;\n};\n\n/**\n * Test separating axis against two hulls. Both hulls are projected onto the axis and the overlap size is returned if there is one.\n * @method testSepAxis\n * @param {Vec3} axis\n * @param {ConvexPolyhedron} hullB\n * @param {Vec3} posA\n * @param {Quaternion} quatA\n * @param {Vec3} posB\n * @param {Quaternion} quatB\n * @return {float} The overlap depth, or FALSE if no penetration.\n */\nConvexPolyhedron.prototype.testSepAxis = function(axis, hullB, posA, quatA, posB, quatB){\n    var maxminA=[], maxminB=[], hullA=this;\n    ConvexPolyhedron.project(hullA, axis, posA, quatA, maxminA);\n    ConvexPolyhedron.project(hullB, axis, posB, quatB, maxminB);\n    var maxA = maxminA[0];\n    var minA = maxminA[1];\n    var maxB = maxminB[0];\n    var minB = maxminB[1];\n    if(maxA<minB || maxB<minA){\n        //console.log(minA,maxA,minB,maxB);\n        return false; // Separated\n    }\n    var d0 = maxA - minB;\n    var d1 = maxB - minA;\n    var depth = d0<d1 ? d0:d1;\n    return depth;\n};\n\nvar cli_aabbmin = new Vec3(),\n    cli_aabbmax = new Vec3();\n\n/**\n * @method calculateLocalInertia\n * @param  {Number} mass\n * @param  {Vec3} target\n */\nConvexPolyhedron.prototype.calculateLocalInertia = function(mass,target){\n    // Approximate with box inertia\n    // Exact inertia calculation is overkill, but see http://geometrictools.com/Documentation/PolyhedralMassProperties.pdf for the correct way to do it\n    this.computeLocalAABB(cli_aabbmin,cli_aabbmax);\n    var x = cli_aabbmax.x - cli_aabbmin.x,\n        y = cli_aabbmax.y - cli_aabbmin.y,\n        z = cli_aabbmax.z - cli_aabbmin.z;\n    target.x = 1.0 / 12.0 * mass * ( 2*y*2*y + 2*z*2*z );\n    target.y = 1.0 / 12.0 * mass * ( 2*x*2*x + 2*z*2*z );\n    target.z = 1.0 / 12.0 * mass * ( 2*y*2*y + 2*x*2*x );\n};\n\n/**\n * @method getPlaneConstantOfFace\n * @param  {Number} face_i Index of the face\n * @return {Number}\n */\nConvexPolyhedron.prototype.getPlaneConstantOfFace = function(face_i){\n    var f = this.faces[face_i];\n    var n = this.faceNormals[face_i];\n    var v = this.vertices[f[0]];\n    var c = -n.dot(v);\n    return c;\n};\n\n/**\n * Clip a face against a hull.\n * @method clipFaceAgainstHull\n * @param {Vec3} separatingNormal\n * @param {Vec3} posA\n * @param {Quaternion} quatA\n * @param {Array} worldVertsB1 An array of Vec3 with vertices in the world frame.\n * @param {Number} minDist Distance clamping\n * @param {Number} maxDist\n * @param Array result Array to store resulting contact points in. Will be objects with properties: point, depth, normal. These are represented in world coordinates.\n */\nvar cfah_faceANormalWS = new Vec3(),\n    cfah_edge0 = new Vec3(),\n    cfah_WorldEdge0 = new Vec3(),\n    cfah_worldPlaneAnormal1 = new Vec3(),\n    cfah_planeNormalWS1 = new Vec3(),\n    cfah_worldA1 = new Vec3(),\n    cfah_localPlaneNormal = new Vec3(),\n    cfah_planeNormalWS = new Vec3();\nConvexPolyhedron.prototype.clipFaceAgainstHull = function(separatingNormal, posA, quatA, worldVertsB1, minDist, maxDist,result){\n    if(!(separatingNormal instanceof Vec3)){\n        throw new Error(\"sep normal must be vector\");\n    }\n    if(!(worldVertsB1 instanceof Array)){\n        throw new Error(\"world verts must be array\");\n    }\n\n    var faceANormalWS = cfah_faceANormalWS,\n        edge0 = cfah_edge0,\n        WorldEdge0 = cfah_WorldEdge0,\n        worldPlaneAnormal1 = cfah_worldPlaneAnormal1,\n        planeNormalWS1 = cfah_planeNormalWS1,\n        worldA1 = cfah_worldA1,\n        localPlaneNormal = cfah_localPlaneNormal,\n        planeNormalWS = cfah_planeNormalWS;\n\n    minDist = Number(minDist);\n    maxDist = Number(maxDist);\n    var hullA = this;\n    var worldVertsB2 = [];\n    var pVtxIn = worldVertsB1;\n    var pVtxOut = worldVertsB2;\n    // Find the face with normal closest to the separating axis\n    var closestFaceA = -1;\n    var dmin = Infinity;\n    for(var face=0; face<hullA.faces.length; face++){\n        faceANormalWS.copy(hullA.faceNormals[face]);\n        quatA.vmult(faceANormalWS,faceANormalWS);\n        //posA.vadd(faceANormalWS,faceANormalWS);\n        var d = faceANormalWS.dot(separatingNormal);\n        if (d < dmin){\n            dmin = d;\n            closestFaceA = face;\n        }\n    }\n    if (closestFaceA<0){\n        console.log(\"--- did not find any closest face... ---\");\n        return;\n    }\n    //console.log(\"closest A: \",closestFaceA);\n    // Get the face and construct connected faces\n    var polyA = hullA.faces[closestFaceA];\n    polyA.connectedFaces = [];\n    for(var i=0; i<hullA.faces.length; i++){\n        for(var j=0; j<hullA.faces[i].length; j++){\n            if(polyA.indexOf(hullA.faces[i][j])!==-1 /* Sharing a vertex*/ && i!==closestFaceA /* Not the one we are looking for connections from */ && polyA.connectedFaces.indexOf(i)===-1 /* Not already added */ ){\n                polyA.connectedFaces.push(i);\n            }\n        }\n    }\n    // Clip the polygon to the back of the planes of all faces of hull A, that are adjacent to the witness face\n    var numContacts = pVtxIn.length;\n    var numVerticesA = polyA.length;\n    var res = [];\n    for(var e0=0; e0<numVerticesA; e0++){\n        var a = hullA.vertices[polyA[e0]];\n        var b = hullA.vertices[polyA[(e0+1)%numVerticesA]];\n        a.vsub(b,edge0);\n        WorldEdge0.copy(edge0);\n        quatA.vmult(WorldEdge0,WorldEdge0);\n        posA.vadd(WorldEdge0,WorldEdge0);\n        worldPlaneAnormal1.copy(this.faceNormals[closestFaceA]);//transA.getBasis()* btVector3(polyA.m_plane[0],polyA.m_plane[1],polyA.m_plane[2]);\n        quatA.vmult(worldPlaneAnormal1,worldPlaneAnormal1);\n        posA.vadd(worldPlaneAnormal1,worldPlaneAnormal1);\n        WorldEdge0.cross(worldPlaneAnormal1,planeNormalWS1);\n        planeNormalWS1.negate(planeNormalWS1);\n        worldA1.copy(a);\n        quatA.vmult(worldA1,worldA1);\n        posA.vadd(worldA1,worldA1);\n        var planeEqWS1 = -worldA1.dot(planeNormalWS1);\n        var planeEqWS;\n        if(true){\n            var otherFace = polyA.connectedFaces[e0];\n            localPlaneNormal.copy(this.faceNormals[otherFace]);\n            var localPlaneEq = this.getPlaneConstantOfFace(otherFace);\n\n            planeNormalWS.copy(localPlaneNormal);\n            quatA.vmult(planeNormalWS,planeNormalWS);\n            //posA.vadd(planeNormalWS,planeNormalWS);\n            var planeEqWS = localPlaneEq - planeNormalWS.dot(posA);\n        } else  {\n            planeNormalWS.copy(planeNormalWS1);\n            planeEqWS = planeEqWS1;\n        }\n\n        // Clip face against our constructed plane\n        this.clipFaceAgainstPlane(pVtxIn, pVtxOut, planeNormalWS, planeEqWS);\n\n        // Throw away all clipped points, but save the reamining until next clip\n        while(pVtxIn.length){\n            pVtxIn.shift();\n        }\n        while(pVtxOut.length){\n            pVtxIn.push(pVtxOut.shift());\n        }\n    }\n\n    //console.log(\"Resulting points after clip:\",pVtxIn);\n\n    // only keep contact points that are behind the witness face\n    localPlaneNormal.copy(this.faceNormals[closestFaceA]);\n\n    var localPlaneEq = this.getPlaneConstantOfFace(closestFaceA);\n    planeNormalWS.copy(localPlaneNormal);\n    quatA.vmult(planeNormalWS,planeNormalWS);\n\n    var planeEqWS = localPlaneEq - planeNormalWS.dot(posA);\n    for (var i=0; i<pVtxIn.length; i++){\n        var depth = planeNormalWS.dot(pVtxIn[i]) + planeEqWS; //???\n        /*console.log(\"depth calc from normal=\",planeNormalWS.toString(),\" and constant \"+planeEqWS+\" and vertex \",pVtxIn[i].toString(),\" gives \"+depth);*/\n        if (depth <=minDist){\n            console.log(\"clamped: depth=\"+depth+\" to minDist=\"+(minDist+\"\"));\n            depth = minDist;\n        }\n\n        if (depth <=maxDist){\n            var point = pVtxIn[i];\n            if(depth<=0){\n                /*console.log(\"Got contact point \",point.toString(),\n                  \", depth=\",depth,\n                  \"contact normal=\",separatingNormal.toString(),\n                  \"plane\",planeNormalWS.toString(),\n                  \"planeConstant\",planeEqWS);*/\n                var p = {\n                    point:point,\n                    normal:planeNormalWS,\n                    depth: depth,\n                };\n                result.push(p);\n            }\n        }\n    }\n};\n\n/**\n * Clip a face in a hull against the back of a plane.\n * @method clipFaceAgainstPlane\n * @param {Array} inVertices\n * @param {Array} outVertices\n * @param {Vec3} planeNormal\n * @param {Number} planeConstant The constant in the mathematical plane equation\n */\nConvexPolyhedron.prototype.clipFaceAgainstPlane = function(inVertices,outVertices, planeNormal, planeConstant){\n    if(!(planeNormal instanceof Vec3)){\n        throw new Error(\"planeNormal must be Vec3, \"+planeNormal+\" given\");\n    }\n    if(!(inVertices instanceof Array)) {\n        throw new Error(\"invertices must be Array, \"+inVertices+\" given\");\n    }\n    if(!(outVertices instanceof Array)){\n        throw new Error(\"outvertices must be Array, \"+outVertices+\" given\");\n    }\n    var n_dot_first, n_dot_last;\n    var numVerts = inVertices.length;\n\n    if(numVerts < 2){\n        return outVertices;\n    }\n\n    var firstVertex = inVertices[inVertices.length-1],\n        lastVertex =   inVertices[0];\n\n    n_dot_first = planeNormal.dot(firstVertex) + planeConstant;\n\n    for(var vi = 0; vi < numVerts; vi++){\n        lastVertex = inVertices[vi];\n        n_dot_last = planeNormal.dot(lastVertex) + planeConstant;\n        if(n_dot_first < 0){\n            if(n_dot_last < 0){\n                // Start < 0, end < 0, so output lastVertex\n                var newv = new Vec3();\n                newv.copy(lastVertex);\n                outVertices.push(newv);\n            } else {\n                // Start < 0, end >= 0, so output intersection\n                var newv = new Vec3();\n                firstVertex.lerp(lastVertex,\n                                 n_dot_first / (n_dot_first - n_dot_last),\n                                 newv);\n                outVertices.push(newv);\n            }\n        } else {\n            if(n_dot_last<0){\n                // Start >= 0, end < 0 so output intersection and end\n                var newv = new Vec3();\n                firstVertex.lerp(lastVertex,\n                                 n_dot_first / (n_dot_first - n_dot_last),\n                                 newv);\n                outVertices.push(newv);\n                outVertices.push(lastVertex);\n            }\n        }\n        firstVertex = lastVertex;\n        n_dot_first = n_dot_last;\n    }\n    return outVertices;\n};\n\n// Updates .worldVertices and sets .worldVerticesNeedsUpdate to false.\nConvexPolyhedron.prototype.computeWorldVertices = function(position,quat){\n    var N = this.vertices.length;\n    while(this.worldVertices.length < N){\n        this.worldVertices.push( new Vec3() );\n    }\n\n    var verts = this.vertices,\n        worldVerts = this.worldVertices;\n    for(var i=0; i!==N; i++){\n        quat.vmult( verts[i] , worldVerts[i] );\n        position.vadd( worldVerts[i] , worldVerts[i] );\n    }\n\n    this.worldVerticesNeedsUpdate = false;\n};\n\nvar computeLocalAABB_worldVert = new Vec3();\nConvexPolyhedron.prototype.computeLocalAABB = function(aabbmin,aabbmax){\n    var n = this.vertices.length,\n        vertices = this.vertices,\n        worldVert = computeLocalAABB_worldVert;\n\n    aabbmin.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    aabbmax.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n\n    for(var i=0; i<n; i++){\n        var v = vertices[i];\n        if     (v.x < aabbmin.x){\n            aabbmin.x = v.x;\n        } else if(v.x > aabbmax.x){\n            aabbmax.x = v.x;\n        }\n        if     (v.y < aabbmin.y){\n            aabbmin.y = v.y;\n        } else if(v.y > aabbmax.y){\n            aabbmax.y = v.y;\n        }\n        if     (v.z < aabbmin.z){\n            aabbmin.z = v.z;\n        } else if(v.z > aabbmax.z){\n            aabbmax.z = v.z;\n        }\n    }\n};\n\n/**\n * Updates .worldVertices and sets .worldVerticesNeedsUpdate to false.\n * @method computeWorldFaceNormals\n * @param  {Quaternion} quat\n */\nConvexPolyhedron.prototype.computeWorldFaceNormals = function(quat){\n    var N = this.faceNormals.length;\n    while(this.worldFaceNormals.length < N){\n        this.worldFaceNormals.push( new Vec3() );\n    }\n\n    var normals = this.faceNormals,\n        worldNormals = this.worldFaceNormals;\n    for(var i=0; i!==N; i++){\n        quat.vmult( normals[i] , worldNormals[i] );\n    }\n\n    this.worldFaceNormalsNeedsUpdate = false;\n};\n\n/**\n * @method updateBoundingSphereRadius\n */\nConvexPolyhedron.prototype.updateBoundingSphereRadius = function(){\n    // Assume points are distributed with local (0,0,0) as center\n    var max2 = 0;\n    var verts = this.vertices;\n    for(var i=0, N=verts.length; i!==N; i++) {\n        var norm2 = verts[i].norm2();\n        if(norm2 > max2){\n            max2 = norm2;\n        }\n    }\n    this.boundingSphereRadius = Math.sqrt(max2);\n};\n\nvar tempWorldVertex = new Vec3();\n\n/**\n * @method calculateWorldAABB\n * @param {Vec3}        pos\n * @param {Quaternion}  quat\n * @param {Vec3}        min\n * @param {Vec3}        max\n */\nConvexPolyhedron.prototype.calculateWorldAABB = function(pos,quat,min,max){\n    var n = this.vertices.length, verts = this.vertices;\n    var minx,miny,minz,maxx,maxy,maxz;\n    for(var i=0; i<n; i++){\n        tempWorldVertex.copy(verts[i]);\n        quat.vmult(tempWorldVertex,tempWorldVertex);\n        pos.vadd(tempWorldVertex,tempWorldVertex);\n        var v = tempWorldVertex;\n        if     (v.x < minx || minx===undefined){\n            minx = v.x;\n        } else if(v.x > maxx || maxx===undefined){\n            maxx = v.x;\n        }\n\n        if     (v.y < miny || miny===undefined){\n            miny = v.y;\n        } else if(v.y > maxy || maxy===undefined){\n            maxy = v.y;\n        }\n\n        if     (v.z < minz || minz===undefined){\n            minz = v.z;\n        } else if(v.z > maxz || maxz===undefined){\n            maxz = v.z;\n        }\n    }\n    min.set(minx,miny,minz);\n    max.set(maxx,maxy,maxz);\n};\n\n/**\n * Get approximate convex volume\n * @method volume\n * @return {Number}\n */\nConvexPolyhedron.prototype.volume = function(){\n    return 4.0 * Math.PI * this.boundingSphereRadius / 3.0;\n};\n\n/**\n * Get an average of all the vertices positions\n * @method getAveragePointLocal\n * @param  {Vec3} target\n * @return {Vec3}\n */\nConvexPolyhedron.prototype.getAveragePointLocal = function(target){\n    target = target || new Vec3();\n    var n = this.vertices.length,\n        verts = this.vertices;\n    for(var i=0; i<n; i++){\n        target.vadd(verts[i],target);\n    }\n    target.mult(1/n,target);\n    return target;\n};\n\n/**\n * Transform all local points. Will change the .vertices\n * @method transformAllPoints\n * @param  {Vec3} offset\n * @param  {Quaternion} quat\n */\nConvexPolyhedron.prototype.transformAllPoints = function(offset,quat){\n    var n = this.vertices.length,\n        verts = this.vertices;\n\n    // Apply rotation\n    if(quat){\n        // Rotate vertices\n        for(var i=0; i<n; i++){\n            var v = verts[i];\n            quat.vmult(v,v);\n        }\n        // Rotate face normals\n        for(var i=0; i<this.faceNormals.length; i++){\n            var v = this.faceNormals[i];\n            quat.vmult(v,v);\n        }\n        /*\n        // Rotate edges\n        for(var i=0; i<this.uniqueEdges.length; i++){\n            var v = this.uniqueEdges[i];\n            quat.vmult(v,v);\n        }*/\n    }\n\n    // Apply offset\n    if(offset){\n        for(var i=0; i<n; i++){\n            var v = verts[i];\n            v.vadd(offset,v);\n        }\n    }\n};\n\n/**\n * Checks whether p is inside the polyhedra. Must be in local coords. The point lies outside of the convex hull of the other points if and only if the direction of all the vectors from it to those other points are on less than one half of a sphere around it.\n * @method pointIsInside\n * @param  {Vec3} p      A point given in local coordinates\n * @return {Boolean}\n */\nvar ConvexPolyhedron_pointIsInside = new Vec3();\nvar ConvexPolyhedron_vToP = new Vec3();\nvar ConvexPolyhedron_vToPointInside = new Vec3();\nConvexPolyhedron.prototype.pointIsInside = function(p){\n    var n = this.vertices.length,\n        verts = this.vertices,\n        faces = this.faces,\n        normals = this.faceNormals;\n    var positiveResult = null;\n    var N = this.faces.length;\n    var pointInside = ConvexPolyhedron_pointIsInside;\n    this.getAveragePointLocal(pointInside);\n    for(var i=0; i<N; i++){\n        var numVertices = this.faces[i].length;\n        var n = normals[i];\n        var v = verts[faces[i][0]]; // We only need one point in the face\n\n        // This dot product determines which side of the edge the point is\n        var vToP = ConvexPolyhedron_vToP;\n        p.vsub(v,vToP);\n        var r1 = n.dot(vToP);\n\n        var vToPointInside = ConvexPolyhedron_vToPointInside;\n        pointInside.vsub(v,vToPointInside);\n        var r2 = n.dot(vToPointInside);\n\n        if((r1<0 && r2>0) || (r1>0 && r2<0)){\n            return false; // Encountered some other sign. Exit.\n        } else {\n        }\n    }\n\n    // If we got here, all dot products were of the same sign.\n    return positiveResult ? 1 : -1;\n};\n\n/**\n * Get max and min dot product of a convex hull at position (pos,quat) projected onto an axis. Results are saved in the array maxmin.\n * @static\n * @method project\n * @param {ConvexPolyhedron} hull\n * @param {Vec3} axis\n * @param {Vec3} pos\n * @param {Quaternion} quat\n * @param {array} result result[0] and result[1] will be set to maximum and minimum, respectively.\n */\nvar project_worldVertex = new Vec3();\nvar project_localAxis = new Vec3();\nvar project_localOrigin = new Vec3();\nConvexPolyhedron.project = function(hull, axis, pos, quat, result){\n    var n = hull.vertices.length,\n        worldVertex = project_worldVertex,\n        localAxis = project_localAxis,\n        max = 0,\n        min = 0,\n        localOrigin = project_localOrigin,\n        vs = hull.vertices;\n\n    localOrigin.setZero();\n\n    // Transform the axis to local\n    Transform.vectorToLocalFrame(pos, quat, axis, localAxis);\n    Transform.pointToLocalFrame(pos, quat, localOrigin, localOrigin);\n    var add = localOrigin.dot(localAxis);\n\n    min = max = vs[0].dot(localAxis);\n\n    for(var i = 1; i < n; i++){\n        var val = vs[i].dot(localAxis);\n\n        if(val > max){\n            max = val;\n        }\n\n        if(val < min){\n            min = val;\n        }\n    }\n\n    min -= add;\n    max -= add;\n\n    if(min > max){\n        // Inconsistent - swap\n        var temp = min;\n        min = max;\n        max = temp;\n    }\n    // Output\n    result[0] = max;\n    result[1] = min;\n};\n\n},{\"../math/Quaternion\":25,\"../math/Transform\":26,\"../math/Vec3\":27,\"./Shape\":40}],36:[function(_dereq_,module,exports){\nmodule.exports = Cylinder;\n\nvar Shape = _dereq_('./Shape');\nvar Vec3 = _dereq_('../math/Vec3');\nvar Quaternion = _dereq_('../math/Quaternion');\nvar ConvexPolyhedron = _dereq_('./ConvexPolyhedron');\n\n/**\n * @class Cylinder\n * @constructor\n * @extends ConvexPolyhedron\n * @author schteppe / https://github.com/schteppe\n * @param {Number} radiusTop\n * @param {Number} radiusBottom\n * @param {Number} height\n * @param {Number} numSegments The number of segments to build the cylinder out of\n */\nfunction Cylinder( radiusTop, radiusBottom, height , numSegments ) {\n    var N = numSegments,\n        verts = [],\n        normals = [],\n        faces = [],\n        bottomface = [],\n        topface = [],\n        cos = Math.cos,\n        sin = Math.sin;\n\n    // First bottom point\n    verts.push(new Vec3(radiusBottom*cos(0),\n                               radiusBottom*sin(0),\n                               -height*0.5));\n    bottomface.push(0);\n\n    // First top point\n    verts.push(new Vec3(radiusTop*cos(0),\n                               radiusTop*sin(0),\n                               height*0.5));\n    topface.push(1);\n\n    for(var i=0; i<N; i++){\n        var theta = 2*Math.PI/N * (i+1);\n        var thetaN = 2*Math.PI/N * (i+0.5);\n        if(i<N-1){\n            // Bottom\n            verts.push(new Vec3(radiusBottom*cos(theta),\n                                       radiusBottom*sin(theta),\n                                       -height*0.5));\n            bottomface.push(2*i+2);\n            // Top\n            verts.push(new Vec3(radiusTop*cos(theta),\n                                       radiusTop*sin(theta),\n                                       height*0.5));\n            topface.push(2*i+3);\n            // Normal\n            normals.push(new Vec3(cos(thetaN),\n                                         sin(thetaN),\n                                         0));\n            // Face\n            faces.push([2*i+2, 2*i+3, 2*i+1,2*i]);\n        } else {\n            faces.push([0,1, 2*i+1, 2*i]); // Connect\n            // Normal\n            normals.push(new Vec3(cos(thetaN),sin(thetaN),0));\n        }\n    }\n    faces.push(topface);\n    normals.push(new Vec3(0,0,1));\n\n    // Reorder bottom face\n    var temp = [];\n    for(var i=0; i<bottomface.length; i++){\n        temp.push(bottomface[bottomface.length - i - 1]);\n    }\n    faces.push(temp);\n    normals.push(new Vec3(0,0,-1));\n\n    this.type = Shape.types.CONVEXPOLYHEDRON;\n    ConvexPolyhedron.call( this, verts, faces, normals );\n}\n\nCylinder.prototype = new ConvexPolyhedron();\n\n},{\"../math/Quaternion\":25,\"../math/Vec3\":27,\"./ConvexPolyhedron\":35,\"./Shape\":40}],37:[function(_dereq_,module,exports){\nvar Shape = _dereq_('./Shape');\nvar ConvexPolyhedron = _dereq_('./ConvexPolyhedron');\nvar Vec3 = _dereq_('../math/Vec3');\nvar Utils = _dereq_('../utils/Utils');\n\nmodule.exports = Heightfield;\n\n/**\n * Heightfield shape class. Height data is given as an array. These data points are spread out evenly with a given distance.\n * @class Heightfield\n * @extends Shape\n * @constructor\n * @param {Array} data An array of Y values that will be used to construct the terrain.\n * @param {object} options\n * @param {Number} [options.minValue] Minimum value of the data points in the data array. Will be computed automatically if not given.\n * @param {Number} [options.maxValue] Maximum value.\n * @param {Number} [options.elementSize=0.1] World spacing between the data points in X direction.\n * @todo Should be possible to use along all axes, not just y\n *\n * @example\n *     // Generate some height data (y-values).\n *     var data = [];\n *     for(var i = 0; i < 1000; i++){\n *         var y = 0.5 * Math.cos(0.2 * i);\n *         data.push(y);\n *     }\n *\n *     // Create the heightfield shape\n *     var heightfieldShape = new Heightfield(data, {\n *         elementSize: 1 // Distance between the data points in X and Y directions\n *     });\n *     var heightfieldBody = new Body();\n *     heightfieldBody.addShape(heightfieldShape);\n *     world.addBody(heightfieldBody);\n */\nfunction Heightfield(data, options){\n    options = Utils.defaults(options, {\n        maxValue : null,\n        minValue : null,\n        elementSize : 1\n    });\n\n    /**\n     * An array of numbers, or height values, that are spread out along the x axis.\n     * @property {array} data\n     */\n    this.data = data;\n\n    /**\n     * Max value of the data\n     * @property {number} maxValue\n     */\n    this.maxValue = options.maxValue;\n\n    /**\n     * Max value of the data\n     * @property {number} minValue\n     */\n    this.minValue = options.minValue;\n\n    /**\n     * The width of each element\n     * @property {number} elementSize\n     * @todo elementSizeX and Y\n     */\n    this.elementSize = options.elementSize;\n\n    if(options.minValue === null){\n        this.updateMinValue();\n    }\n    if(options.maxValue === null){\n        this.updateMaxValue();\n    }\n\n    this.cacheEnabled = true;\n\n    Shape.call(this);\n\n    this.pillarConvex = new ConvexPolyhedron();\n    this.pillarOffset = new Vec3();\n\n    this.type = Shape.types.HEIGHTFIELD;\n    this.updateBoundingSphereRadius();\n\n    // \"i_j_isUpper\" => { convex: ..., offset: ... }\n    // for example:\n    // _cachedPillars[\"0_2_1\"]\n    this._cachedPillars = {};\n}\nHeightfield.prototype = new Shape();\n\n/**\n * Call whenever you change the data array.\n * @method update\n */\nHeightfield.prototype.update = function(){\n    this._cachedPillars = {};\n};\n\n/**\n * @method updateMinValue\n * Update the .minValue property\n */\nHeightfield.prototype.updateMinValue = function(){\n    var data = this.data;\n    var minValue = data[0][0];\n    for(var i=0; i !== data.length; i++){\n        for(var j=0; j !== data[i].length; j++){\n            var v = data[i][j];\n            if(v < minValue){\n                minValue = v;\n            }\n        }\n    }\n    this.minValue = minValue;\n};\n\n/**\n * Update the .maxValue property\n * @method updateMaxValue\n */\nHeightfield.prototype.updateMaxValue = function(){\n    var data = this.data;\n    var maxValue = data[0][0];\n    for(var i=0; i !== data.length; i++){\n        for(var j=0; j !== data[i].length; j++){\n            var v = data[i][j];\n            if(v > maxValue){\n                maxValue = v;\n            }\n        }\n    }\n    this.maxValue = maxValue;\n};\n\n/**\n * Set the height value at an index. Don't forget to update maxValue and minValue after you're done.\n * @method setHeightValueAtIndex\n * @param {integer} xi\n * @param {integer} yi\n * @param {number} value\n */\nHeightfield.prototype.setHeightValueAtIndex = function(xi, yi, value){\n    var data = this.data;\n    data[xi][yi] = value;\n\n    // Invalidate cache\n    this.clearCachedConvexTrianglePillar(xi, yi, false);\n    if(xi > 0){\n        this.clearCachedConvexTrianglePillar(xi - 1, yi, true);\n        this.clearCachedConvexTrianglePillar(xi - 1, yi, false);\n    }\n    if(yi > 0){\n        this.clearCachedConvexTrianglePillar(xi, yi - 1, true);\n        this.clearCachedConvexTrianglePillar(xi, yi - 1, false);\n    }\n    if(yi > 0 && xi > 0){\n        this.clearCachedConvexTrianglePillar(xi - 1, yi - 1, true);\n    }\n};\n\n/**\n * Get max/min in a rectangle in the matrix data\n * @method getRectMinMax\n * @param  {integer} iMinX\n * @param  {integer} iMinY\n * @param  {integer} iMaxX\n * @param  {integer} iMaxY\n * @param  {array} [result] An array to store the results in.\n * @return {array} The result array, if it was passed in. Minimum will be at position 0 and max at 1.\n */\nHeightfield.prototype.getRectMinMax = function (iMinX, iMinY, iMaxX, iMaxY, result) {\n    result = result || [];\n\n    // Get max and min of the data\n    var data = this.data,\n        max = this.minValue; // Set first value\n    for(var i = iMinX; i < iMaxX; i++){\n        for(var j = iMinY; j < iMaxY; j++){\n            var height = data[i][j];\n            if(height > max){\n                max = height;\n            }\n        }\n    }\n\n    result[0] = this.minValue;\n    result[1] = max;\n};\n\n/**\n * Get the index of a local position on the heightfield. The indexes indicate the rectangles, so if your terrain is made of N x N height data points, you will have rectangle indexes ranging from 0 to N-1.\n * @method getIndexOfPosition\n * @param  {number} x\n * @param  {number} y\n * @param  {array} result Two-element array\n * @param  {boolean} clamp If the position should be clamped to the heightfield edge.\n * @return {boolean}\n */\nHeightfield.prototype.getIndexOfPosition = function (x, y, result, clamp) {\n\n    // Get the index of the data points to test against\n    var w = this.elementSize;\n    var data = this.data;\n    var xi = Math.floor(x / w);\n    var yi = Math.floor(y / w);\n\n    result[0] = xi;\n    result[1] = yi;\n\n    if(clamp){\n        // Clamp index to edges\n        if(xi < 0){ xi = 0; }\n        if(yi < 0){ yi = 0; }\n        if(xi >= data.length - 1){ xi = data.length - 1; }\n        if(yi >= data[0].length - 1){ yi = data[0].length - 1; }\n    }\n\n    // Bail out if we are out of the terrain\n    if(xi < 0 || yi < 0 || xi >= data.length-1 || yi >= data[0].length-1){\n        return false;\n    }\n\n    return true;\n};\n\nHeightfield.prototype.getHeightAt = function(x, y, edgeClamp){\n    var idx = [];\n    this.getIndexOfPosition(x, y, idx, edgeClamp);\n\n    // TODO: do it better\n    var minmax = [];\n    this.getRectMinMax(idx[0], idx[1] + 1, idx[0], idx[1] + 1, minmax);\n\n    return (minmax[0] + minmax[1]) / 2; // average\n};\n\nHeightfield.prototype.getCacheConvexTrianglePillarKey = function(xi, yi, getUpperTriangle){\n    return xi + '_' + yi + '_' + (getUpperTriangle ? 1 : 0);\n};\n\nHeightfield.prototype.getCachedConvexTrianglePillar = function(xi, yi, getUpperTriangle){\n    return this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)];\n};\n\nHeightfield.prototype.setCachedConvexTrianglePillar = function(xi, yi, getUpperTriangle, convex, offset){\n    this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)] = {\n        convex: convex,\n        offset: offset\n    };\n};\n\nHeightfield.prototype.clearCachedConvexTrianglePillar = function(xi, yi, getUpperTriangle){\n    delete this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)];\n};\n\n/**\n * Get a triangle in the terrain in the form of a triangular convex shape.\n * @method getConvexTrianglePillar\n * @param  {integer} i\n * @param  {integer} j\n * @param  {boolean} getUpperTriangle\n */\nHeightfield.prototype.getConvexTrianglePillar = function(xi, yi, getUpperTriangle){\n    var result = this.pillarConvex;\n    var offsetResult = this.pillarOffset;\n\n    if(this.cacheEnabled){\n        var data = this.getCachedConvexTrianglePillar(xi, yi, getUpperTriangle);\n        if(data){\n            this.pillarConvex = data.convex;\n            this.pillarOffset = data.offset;\n            return;\n        }\n\n        result = new ConvexPolyhedron();\n        offsetResult = new Vec3();\n\n        this.pillarConvex = result;\n        this.pillarOffset = offsetResult;\n    }\n\n    var data = this.data;\n    var elementSize = this.elementSize;\n    var faces = result.faces;\n\n    // Reuse verts if possible\n    result.vertices.length = 6;\n    for (var i = 0; i < 6; i++) {\n        if(!result.vertices[i]){\n            result.vertices[i] = new Vec3();\n        }\n    }\n\n    // Reuse faces if possible\n    faces.length = 5;\n    for (var i = 0; i < 5; i++) {\n        if(!faces[i]){\n            faces[i] = [];\n        }\n    }\n\n    var verts = result.vertices;\n\n    var h = (Math.min(\n        data[xi][yi],\n        data[xi+1][yi],\n        data[xi][yi+1],\n        data[xi+1][yi+1]\n    ) - this.minValue ) / 2 + this.minValue;\n\n    if (!getUpperTriangle) {\n\n        // Center of the triangle pillar - all polygons are given relative to this one\n        offsetResult.set(\n            (xi + 0.25) * elementSize, // sort of center of a triangle\n            (yi + 0.25) * elementSize,\n            h // vertical center\n        );\n\n        // Top triangle verts\n        verts[0].set(\n            -0.25 * elementSize,\n            -0.25 * elementSize,\n            data[xi][yi] - h\n        );\n        verts[1].set(\n            0.75 * elementSize,\n            -0.25 * elementSize,\n            data[xi + 1][yi] - h\n        );\n        verts[2].set(\n            -0.25 * elementSize,\n            0.75 * elementSize,\n            data[xi][yi + 1] - h\n        );\n\n        // bottom triangle verts\n        verts[3].set(\n            -0.25 * elementSize,\n            -0.25 * elementSize,\n            -h\n        );\n        verts[4].set(\n            0.75 * elementSize,\n            -0.25 * elementSize,\n            -h\n        );\n        verts[5].set(\n            -0.25 * elementSize,\n            0.75  * elementSize,\n            -h\n        );\n\n        // top triangle\n        faces[0][0] = 0;\n        faces[0][1] = 1;\n        faces[0][2] = 2;\n\n        // bottom triangle\n        faces[1][0] = 5;\n        faces[1][1] = 4;\n        faces[1][2] = 3;\n\n        // -x facing quad\n        faces[2][0] = 0;\n        faces[2][1] = 2;\n        faces[2][2] = 5;\n        faces[2][3] = 3;\n\n        // -y facing quad\n        faces[3][0] = 1;\n        faces[3][1] = 0;\n        faces[3][2] = 3;\n        faces[3][3] = 4;\n\n        // +xy facing quad\n        faces[4][0] = 4;\n        faces[4][1] = 5;\n        faces[4][2] = 2;\n        faces[4][3] = 1;\n\n\n    } else {\n\n        // Center of the triangle pillar - all polygons are given relative to this one\n        offsetResult.set(\n            (xi + 0.75) * elementSize, // sort of center of a triangle\n            (yi + 0.75) * elementSize,\n            h // vertical center\n        );\n\n        // Top triangle verts\n        verts[0].set(\n            0.25 * elementSize,\n            0.25 * elementSize,\n            data[xi + 1][yi + 1] - h\n        );\n        verts[1].set(\n            -0.75 * elementSize,\n            0.25 * elementSize,\n            data[xi][yi + 1] - h\n        );\n        verts[2].set(\n            0.25 * elementSize,\n            -0.75 * elementSize,\n            data[xi + 1][yi] - h\n        );\n\n        // bottom triangle verts\n        verts[3].set(\n            0.25 * elementSize,\n            0.25 * elementSize,\n            - h\n        );\n        verts[4].set(\n            -0.75 * elementSize,\n            0.25 * elementSize,\n            - h\n        );\n        verts[5].set(\n            0.25 * elementSize,\n            -0.75 * elementSize,\n            - h\n        );\n\n        // Top triangle\n        faces[0][0] = 0;\n        faces[0][1] = 1;\n        faces[0][2] = 2;\n\n        // bottom triangle\n        faces[1][0] = 5;\n        faces[1][1] = 4;\n        faces[1][2] = 3;\n\n        // +x facing quad\n        faces[2][0] = 2;\n        faces[2][1] = 5;\n        faces[2][2] = 3;\n        faces[2][3] = 0;\n\n        // +y facing quad\n        faces[3][0] = 3;\n        faces[3][1] = 4;\n        faces[3][2] = 1;\n        faces[3][3] = 0;\n\n        // -xy facing quad\n        faces[4][0] = 1;\n        faces[4][1] = 4;\n        faces[4][2] = 5;\n        faces[4][3] = 2;\n    }\n\n    result.computeNormals();\n    result.computeEdges();\n    result.updateBoundingSphereRadius();\n\n    this.setCachedConvexTrianglePillar(xi, yi, getUpperTriangle, result, offsetResult);\n};\n\nHeightfield.prototype.calculateLocalInertia = function(mass, target){\n    target = target || new Vec3();\n    target.set(0, 0, 0);\n    return target;\n};\n\nHeightfield.prototype.volume = function(){\n    return Number.MAX_VALUE; // The terrain is infinite\n};\n\nHeightfield.prototype.calculateWorldAABB = function(pos, quat, min, max){\n    // TODO: do it properly\n    min.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n    max.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n};\n\nHeightfield.prototype.updateBoundingSphereRadius = function(){\n    // Use the bounding box of the min/max values\n    var data = this.data,\n        s = this.elementSize;\n    this.boundingSphereRadius = new Vec3(data.length * s, data[0].length * s, Math.max(Math.abs(this.maxValue), Math.abs(this.minValue))).norm();\n};\n},{\"../math/Vec3\":27,\"../utils/Utils\":48,\"./ConvexPolyhedron\":35,\"./Shape\":40}],38:[function(_dereq_,module,exports){\nmodule.exports = Particle;\n\nvar Shape = _dereq_('./Shape');\nvar Vec3 = _dereq_('../math/Vec3');\n\n/**\n * A 3d box shape.\n * @class Particle\n * @constructor\n * @author schteppe\n * @extends Shape\n */\nfunction Particle(){\n    Shape.call(this);\n\n    this.type = Shape.types.PARTICLE;\n}\nParticle.prototype = new Shape();\nParticle.prototype.constructor = Particle;\n\n/**\n * @method calculateLocalInertia\n * @param  {Number} mass\n * @param  {Vec3} target\n * @return {Vec3}\n */\nParticle.prototype.calculateLocalInertia = function(mass,target){\n    target = target || new Vec3();\n    target.set(0, 0, 0);\n    return target;\n};\n\nParticle.prototype.volume = function(){\n    return 0;\n};\n\nParticle.prototype.updateBoundingSphereRadius = function(){\n    this.boundingSphereRadius = 0;\n};\n\nParticle.prototype.calculateWorldAABB = function(pos,quat,min,max){\n    // Get each axis max\n    min.copy(pos);\n    max.copy(pos);\n};\n\n},{\"../math/Vec3\":27,\"./Shape\":40}],39:[function(_dereq_,module,exports){\nmodule.exports = Plane;\n\nvar Shape = _dereq_('./Shape');\nvar Vec3 = _dereq_('../math/Vec3');\n\n/**\n * A plane, facing in the Z direction. The plane has its surface at z=0 and everything below z=0 is assumed to be solid plane. To make the plane face in some other direction than z, you must put it inside a RigidBody and rotate that body. See the demos.\n * @class Plane\n * @constructor\n * @extends Shape\n * @author schteppe\n */\nfunction Plane(){\n    Shape.call(this);\n    this.type = Shape.types.PLANE;\n\n    // World oriented normal\n    this.worldNormal = new Vec3();\n    this.worldNormalNeedsUpdate = true;\n\n    this.boundingSphereRadius = Number.MAX_VALUE;\n}\nPlane.prototype = new Shape();\nPlane.prototype.constructor = Plane;\n\nPlane.prototype.computeWorldNormal = function(quat){\n    var n = this.worldNormal;\n    n.set(0,0,1);\n    quat.vmult(n,n);\n    this.worldNormalNeedsUpdate = false;\n};\n\nPlane.prototype.calculateLocalInertia = function(mass,target){\n    target = target || new Vec3();\n    return target;\n};\n\nPlane.prototype.volume = function(){\n    return Number.MAX_VALUE; // The plane is infinite...\n};\n\nvar tempNormal = new Vec3();\nPlane.prototype.calculateWorldAABB = function(pos, quat, min, max){\n    // The plane AABB is infinite, except if the normal is pointing along any axis\n    tempNormal.set(0,0,1); // Default plane normal is z\n    quat.vmult(tempNormal,tempNormal);\n    var maxVal = Number.MAX_VALUE;\n    min.set(-maxVal, -maxVal, -maxVal);\n    max.set(maxVal, maxVal, maxVal);\n\n    if(tempNormal.x === 1){ max.x = pos.x; }\n    if(tempNormal.y === 1){ max.y = pos.y; }\n    if(tempNormal.z === 1){ max.z = pos.z; }\n\n    if(tempNormal.x === -1){ min.x = pos.x; }\n    if(tempNormal.y === -1){ min.y = pos.y; }\n    if(tempNormal.z === -1){ min.z = pos.z; }\n};\n\nPlane.prototype.updateBoundingSphereRadius = function(){\n    this.boundingSphereRadius = Number.MAX_VALUE;\n};\n},{\"../math/Vec3\":27,\"./Shape\":40}],40:[function(_dereq_,module,exports){\nmodule.exports = Shape;\n\nvar Shape = _dereq_('./Shape');\nvar Vec3 = _dereq_('../math/Vec3');\nvar Quaternion = _dereq_('../math/Quaternion');\nvar Material = _dereq_('../material/Material');\n\n/**\n * Base class for shapes\n * @class Shape\n * @constructor\n * @author schteppe\n * @todo Should have a mechanism for caching bounding sphere radius instead of calculating it each time\n */\nfunction Shape(){\n\n    /**\n     * The type of this shape. Must be set to an int > 0 by subclasses.\n     * @property type\n     * @type {Number}\n     * @see Shape.types\n     */\n    this.type = 0;\n\n    /**\n     * The local bounding sphere radius of this shape.\n     * @property {Number} boundingSphereRadius\n     */\n    this.boundingSphereRadius = 0;\n\n    /**\n     * @property {boolean} collisionResponse\n     */\n    this.collisionResponse = true;\n}\nShape.prototype.constructor = Shape;\n\n/**\n * Computes the bounding sphere radius. The result is stored in the property .boundingSphereRadius\n * @method updateBoundingSphereRadius\n * @return {Number}\n */\nShape.prototype.updateBoundingSphereRadius = function(){\n    throw \"computeBoundingSphereRadius() not implemented for shape type \"+this.type;\n};\n\n/**\n * Get the volume of this shape\n * @method volume\n * @return {Number}\n */\nShape.prototype.volume = function(){\n    throw \"volume() not implemented for shape type \"+this.type;\n};\n\n/**\n * Calculates the inertia in the local frame for this shape.\n * @method calculateLocalInertia\n * @return {Vec3}\n * @see http://en.wikipedia.org/wiki/List_of_moments_of_inertia\n */\nShape.prototype.calculateLocalInertia = function(mass,target){\n    throw \"calculateLocalInertia() not implemented for shape type \"+this.type;\n};\n\n/**\n * The available shape types.\n * @static\n * @property types\n * @type {Object}\n */\nShape.types = {\n    SPHERE:1,\n    PLANE:2,\n    BOX:4,\n    COMPOUND:8,\n    CONVEXPOLYHEDRON:16,\n    HEIGHTFIELD:32,\n    PARTICLE:64,\n    CYLINDER:128\n};\n\n\n},{\"../material/Material\":22,\"../math/Quaternion\":25,\"../math/Vec3\":27,\"./Shape\":40}],41:[function(_dereq_,module,exports){\nmodule.exports = Sphere;\n\nvar Shape = _dereq_('./Shape');\nvar Vec3 = _dereq_('../math/Vec3');\n\n/**\n * Spherical shape\n * @class Sphere\n * @constructor\n * @extends Shape\n * @param {Number} radius\n * @author schteppe / http://github.com/schteppe\n */\nfunction Sphere(radius){\n    Shape.call(this);\n\n    /**\n     * @property {Number} radius\n     */\n    this.radius = radius!==undefined ? Number(radius) : 1.0;\n    this.type = Shape.types.SPHERE;\n\n    this.updateBoundingSphereRadius();\n}\nSphere.prototype = new Shape();\nSphere.prototype.constructor = Sphere;\n\nSphere.prototype.calculateLocalInertia = function(mass,target){\n    target = target || new Vec3();\n    var I = 2.0*mass*this.radius*this.radius/5.0;\n    target.x = I;\n    target.y = I;\n    target.z = I;\n    return target;\n};\n\nSphere.prototype.volume = function(){\n    return 4.0 * Math.PI * this.radius / 3.0;\n};\n\nSphere.prototype.updateBoundingSphereRadius = function(){\n    this.boundingSphereRadius = this.radius;\n};\n\nSphere.prototype.calculateWorldAABB = function(pos,quat,min,max){\n    var r = this.radius;\n    var axes = ['x','y','z'];\n    for(var i=0; i<axes.length; i++){\n        var ax = axes[i];\n        min[ax] = pos[ax] - r;\n        max[ax] = pos[ax] + r;\n    }\n};\n\n},{\"../math/Vec3\":27,\"./Shape\":40}],42:[function(_dereq_,module,exports){\nmodule.exports = GSSolver;\n\nvar Vec3 = _dereq_('../math/Vec3');\nvar Quaternion = _dereq_('../math/Quaternion');\nvar Solver = _dereq_('./Solver');\n\n/**\n * Constraint equation Gauss-Seidel solver.\n * @class GSSolver\n * @constructor\n * @todo The spook parameters should be specified for each constraint, not globally.\n * @author schteppe / https://github.com/schteppe\n * @see https://www8.cs.umu.se/kurser/5DV058/VT09/lectures/spooknotes.pdf\n * @extends Solver\n */\nfunction GSSolver(){\n    Solver.call(this);\n\n    /**\n     * The number of solver iterations determines quality of the constraints in the world. The more iterations, the more correct simulation. More iterations need more computations though. If you have a large gravity force in your world, you will need more iterations.\n     * @property iterations\n     * @type {Number}\n     * @todo write more about solver and iterations in the wiki\n     */\n    this.iterations = 10;\n\n    /**\n     * When tolerance is reached, the system is assumed to be converged.\n     * @property tolerance\n     * @type {Number}\n     */\n    this.tolerance = 0;\n}\nGSSolver.prototype = new Solver();\n\nvar GSSolver_solve_lambda = []; // Just temporary number holders that we want to reuse each solve.\nvar GSSolver_solve_invCs = [];\nvar GSSolver_solve_Bs = [];\nGSSolver.prototype.solve = function(dt,world){\n    var iter = 0,\n        maxIter = this.iterations,\n        tolSquared = this.tolerance*this.tolerance,\n        equations = this.equations,\n        Neq = equations.length,\n        bodies = world.bodies,\n        Nbodies = bodies.length,\n        h = dt,\n        q, B, invC, deltalambda, deltalambdaTot, GWlambda, lambdaj;\n\n    // Update solve mass\n    if(Neq !== 0){\n        for(var i=0; i!==Nbodies; i++){\n            bodies[i].updateSolveMassProperties();\n        }\n    }\n\n    // Things that does not change during iteration can be computed once\n    var invCs = GSSolver_solve_invCs,\n        Bs = GSSolver_solve_Bs,\n        lambda = GSSolver_solve_lambda;\n    invCs.length = Neq;\n    Bs.length = Neq;\n    lambda.length = Neq;\n    for(var i=0; i!==Neq; i++){\n        var c = equations[i];\n        lambda[i] = 0.0;\n        Bs[i] = c.computeB(h);\n        invCs[i] = 1.0 / c.computeC();\n    }\n\n    if(Neq !== 0){\n\n        // Reset vlambda\n        for(var i=0; i!==Nbodies; i++){\n            var b=bodies[i],\n                vlambda=b.vlambda,\n                wlambda=b.wlambda;\n            vlambda.set(0,0,0);\n            if(wlambda){\n                wlambda.set(0,0,0);\n            }\n        }\n\n        // Iterate over equations\n        for(iter=0; iter!==maxIter; iter++){\n\n            // Accumulate the total error for each iteration.\n            deltalambdaTot = 0.0;\n\n            for(var j=0; j!==Neq; j++){\n\n                var c = equations[j];\n\n                // Compute iteration\n                B = Bs[j];\n                invC = invCs[j];\n                lambdaj = lambda[j];\n                GWlambda = c.computeGWlambda();\n                deltalambda = invC * ( B - GWlambda - c.eps * lambdaj );\n\n                // Clamp if we are not within the min/max interval\n                if(lambdaj + deltalambda < c.minForce){\n                    deltalambda = c.minForce - lambdaj;\n                } else if(lambdaj + deltalambda > c.maxForce){\n                    deltalambda = c.maxForce - lambdaj;\n                }\n                lambda[j] += deltalambda;\n\n                deltalambdaTot += deltalambda > 0.0 ? deltalambda : -deltalambda; // abs(deltalambda)\n\n                c.addToWlambda(deltalambda);\n            }\n\n            // If the total error is small enough - stop iterate\n            if(deltalambdaTot*deltalambdaTot < tolSquared){\n                break;\n            }\n        }\n\n        // Add result to velocity\n        for(var i=0; i!==Nbodies; i++){\n            var b=bodies[i],\n                v=b.velocity,\n                w=b.angularVelocity;\n            v.vadd(b.vlambda, v);\n            if(w){\n                w.vadd(b.wlambda, w);\n            }\n        }\n    }\n\n    return iter;\n};\n\n},{\"../math/Quaternion\":25,\"../math/Vec3\":27,\"./Solver\":43}],43:[function(_dereq_,module,exports){\nmodule.exports = Solver;\n\n/**\n * Constraint equation solver base class.\n * @class Solver\n * @constructor\n * @author schteppe / https://github.com/schteppe\n */\nfunction Solver(){\n    /**\n     * All equations to be solved\n     * @property {Array} equations\n     */\n    this.equations = [];\n}\n\n/**\n * Should be implemented in subclasses!\n * @method solve\n * @param  {Number} dt\n * @param  {World} world\n */\nSolver.prototype.solve = function(dt,world){\n    // Should return the number of iterations done!\n    return 0;\n};\n\n/**\n * Add an equation\n * @method addEquation\n * @param {Equation} eq\n */\nSolver.prototype.addEquation = function(eq){\n    if (eq.enabled) {\n        this.equations.push(eq);\n    }\n};\n\n/**\n * Remove an equation\n * @method removeEquation\n * @param {Equation} eq\n */\nSolver.prototype.removeEquation = function(eq){\n    var eqs = this.equations;\n    var i = eqs.indexOf(eq);\n    if(i !== -1){\n        eqs.splice(i,1);\n    }\n};\n\n/**\n * Add all equations\n * @method removeAllEquations\n */\nSolver.prototype.removeAllEquations = function(){\n    this.equations.length = 0;\n};\n\n\n},{}],44:[function(_dereq_,module,exports){\nmodule.exports = SplitSolver;\n\nvar Vec3 = _dereq_('../math/Vec3');\nvar Quaternion = _dereq_('../math/Quaternion');\nvar Solver = _dereq_('./Solver');\nvar Body = _dereq_('../objects/Body');\n\n/**\n * Splits the equations into islands and solves them independently. Can improve performance.\n * @class SplitSolver\n * @constructor\n * @extends Solver\n * @param {Solver} subsolver\n */\nfunction SplitSolver(subsolver){\n    Solver.call(this);\n    this.subsolver = subsolver;\n}\nSplitSolver.prototype = new Solver();\n\n// Returns the number of subsystems\nvar SplitSolver_solve_nodes = []; // All allocated node objects\nvar SplitSolver_solve_eqs = [];   // Temp array\nvar SplitSolver_solve_bds = [];   // Temp array\nvar SplitSolver_solve_dummyWorld = {bodies:null}; // Temp object\n\n/**\n * Solve the subsystems\n * @method solve\n * @param  {Number} dt\n * @param  {World} world\n */\nSplitSolver.prototype.solve = function(dt,world){\n    var nodes=SplitSolver_solve_nodes,\n        bodies=world.bodies,\n        equations=this.equations,\n        Neq=equations.length,\n        Nbodies=bodies.length,\n        subsolver=this.subsolver;\n    // Create needed nodes, reuse if possible\n    if(nodes.length>Nbodies){\n        nodes.length = Nbodies;\n    }\n    while(nodes.length<Nbodies){\n        nodes.push({ body:null, children:[], eqs:[], visited:false });\n    }\n\n    // Reset node values\n    for(var i=0; i!==Nbodies; i++){\n        var node = nodes[i];\n        node.body = bodies[i];\n        node.children.length = 0;\n        node.eqs.length = 0;\n        node.visited = false;\n    }\n    for(var k=0; k!==Neq; k++){\n        var eq=equations[k],\n            i=bodies.indexOf(eq.bi),\n            j=bodies.indexOf(eq.bj),\n            ni=nodes[i],\n            nj=nodes[j];\n        ni.children.push(nj);\n        ni.eqs.push(eq);\n        nj.children.push(ni);\n        nj.eqs.push(eq);\n    }\n\n    var STATIC = Body.STATIC;\n    function getUnvisitedNode(nodes){\n        var Nnodes = nodes.length;\n        for(var i=0; i!==Nnodes; i++){\n            var node = nodes[i];\n            if(!node.visited && !(node.body.type & STATIC)){\n                return node;\n            }\n        }\n        return false;\n    }\n\n    function bfs(root,visitFunc){\n        var queue = [];\n        queue.push(root);\n        root.visited = true;\n        visitFunc(root);\n        while(queue.length) {\n            var node = queue.pop();\n            // Loop over unvisited child nodes\n            var child;\n            while((child = getUnvisitedNode(node.children))) {\n                child.visited = true;\n                visitFunc(child);\n                queue.push(child);\n            }\n        }\n    }\n\n    var child, n=0, eqs=SplitSolver_solve_eqs, bds=SplitSolver_solve_bds;\n    function visitFunc(node){\n        bds.push(node.body);\n        var Neqs = node.eqs.length;\n        for(var i=0; i!==Neqs; i++){\n            var eq = node.eqs[i];\n            if(eqs.indexOf(eq) === -1){\n                eqs.push(eq);\n            }\n        }\n    }\n    var dummyWorld = SplitSolver_solve_dummyWorld;\n    while((child = getUnvisitedNode(nodes))){\n        eqs.length = 0;\n        bds.length = 0;\n        bfs(child,visitFunc);\n\n        var Neqs = eqs.length;\n        for(var i=0; i!==Neqs; i++){\n            subsolver.addEquation(eqs[i]);\n        }\n\n        dummyWorld.bodies = bds;\n        var iter = subsolver.solve(dt,dummyWorld);\n        subsolver.removeAllEquations();\n        n++;\n    }\n\n    return n;\n};\n\n},{\"../math/Quaternion\":25,\"../math/Vec3\":27,\"../objects/Body\":28,\"./Solver\":43}],45:[function(_dereq_,module,exports){\n/**\n * Base class for objects that dispatches events.\n * @class EventTarget\n * @constructor\n */\nvar EventTarget = function () {\n\n};\n\nmodule.exports = EventTarget;\n\nEventTarget.prototype = {\n    constructor: EventTarget,\n\n    /**\n     * Add an event listener\n     * @method addEventListener\n     * @param  {String} type\n     * @param  {Function} listener\n     * @return {EventTarget} The self object, for chainability.\n     */\n    addEventListener: function ( type, listener ) {\n        if ( this._listeners === undefined ){ this._listeners = {}; }\n        var listeners = this._listeners;\n        if ( listeners[ type ] === undefined ) {\n            listeners[ type ] = [];\n        }\n        if ( listeners[ type ].indexOf( listener ) === - 1 ) {\n            listeners[ type ].push( listener );\n        }\n        return this;\n    },\n\n    /**\n     * Check if an event listener is added\n     * @method hasEventListener\n     * @param  {String} type\n     * @param  {Function} listener\n     * @return {Boolean}\n     */\n    hasEventListener: function ( type, listener ) {\n        if ( this._listeners === undefined ){ return false; }\n        var listeners = this._listeners;\n        if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {\n            return true;\n        }\n        return false;\n    },\n\n    /**\n     * Remove an event listener\n     * @method removeEventListener\n     * @param  {String} type\n     * @param  {Function} listener\n     * @return {EventTarget} The self object, for chainability.\n     */\n    removeEventListener: function ( type, listener ) {\n        if ( this._listeners === undefined ){ return this; }\n        var listeners = this._listeners;\n        if ( listeners[type] === undefined ){ return this; }\n        var index = listeners[ type ].indexOf( listener );\n        if ( index !== - 1 ) {\n            listeners[ type ].splice( index, 1 );\n        }\n        return this;\n    },\n\n    /**\n     * Emit an event.\n     * @method dispatchEvent\n     * @param  {Object} event\n     * @param  {String} event.type\n     * @return {EventTarget} The self object, for chainability.\n     */\n    dispatchEvent: function ( event ) {\n        if ( this._listeners === undefined ){ return this; }\n        var listeners = this._listeners;\n        var listenerArray = listeners[ event.type ];\n        if ( listenerArray !== undefined ) {\n            event.target = this;\n            for ( var i = 0, l = listenerArray.length; i < l; i ++ ) {\n                listenerArray[ i ].call( this, event );\n            }\n        }\n        return this;\n    }\n};\n\n},{}],46:[function(_dereq_,module,exports){\nmodule.exports = Pool;\n\n/**\n * For pooling objects that can be reused.\n * @class Pool\n * @constructor\n */\nfunction Pool(){\n    /**\n     * The pooled objects\n     * @property {Array} objects\n     */\n    this.objects = [];\n\n    /**\n     * Constructor of the objects\n     * @property {mixed} type\n     */\n    this.type = Object;\n}\n\n/**\n * Release an object after use\n * @method release\n * @param {Object} obj\n */\nPool.prototype.release = function(){\n    var Nargs = arguments.length;\n    for(var i=0; i!==Nargs; i++){\n        this.objects.push(arguments[i]);\n    }\n};\n\n/**\n * Get an object\n * @method get\n * @return {mixed}\n */\nPool.prototype.get = function(){\n    if(this.objects.length===0){\n        return this.constructObject();\n    } else {\n        return this.objects.pop();\n    }\n};\n\n/**\n * Construct an object. Should be implmented in each subclass.\n * @method constructObject\n * @return {mixed}\n */\nPool.prototype.constructObject = function(){\n    throw new Error(\"constructObject() not implemented in this Pool subclass yet!\");\n};\n\n},{}],47:[function(_dereq_,module,exports){\nmodule.exports = TupleDictionary;\n\n/**\n * @class TupleDictionary\n * @constructor\n */\nfunction TupleDictionary() {\n\n    /**\n     * The data storage\n     * @property data\n     * @type {Object}\n     */\n    this.data = { keys:[] };\n}\n\n/**\n * @method get\n * @param  {Number} i\n * @param  {Number} j\n * @return {Number}\n */\nTupleDictionary.prototype.get = function(i, j) {\n    if (i > j) {\n        // swap\n        var temp = j;\n        j = i;\n        i = temp;\n    }\n    return this.data[i+'-'+j];\n};\n\n/**\n * @method set\n * @param  {Number} i\n * @param  {Number} j\n * @param {Number} value\n */\nTupleDictionary.prototype.set = function(i, j, value) {\n    if (i > j) {\n        var temp = j;\n        j = i;\n        i = temp;\n    }\n    var key = i+'-'+j;\n\n    // Check if key already exists\n    if(!this.get(i,j)){\n        this.data.keys.push(key);\n    }\n\n    this.data[key] = value;\n};\n\n/**\n * @method reset\n */\nTupleDictionary.prototype.reset = function() {\n    var data = this.data,\n        keys = data.keys;\n    while(keys.length > 0){\n        var key = keys.pop();\n        delete data[key];\n    }\n};\n\n},{}],48:[function(_dereq_,module,exports){\nfunction Utils(){}\n\nmodule.exports = Utils;\n\n/**\n * Extend an options object with default values.\n * @static\n * @method defaults\n * @param  {object} options The options object. May be falsy: in this case, a new object is created and returned.\n * @param  {object} defaults An object containing default values.\n * @return {object} The modified options object.\n */\nUtils.defaults = function(options, defaults){\n    options = options || {};\n\n    for(var key in defaults){\n        if(!(key in options)){\n            options[key] = defaults[key];\n        }\n    }\n\n    return options;\n};\n\n},{}],49:[function(_dereq_,module,exports){\nmodule.exports = Vec3Pool;\n\nvar Vec3 = _dereq_('../math/Vec3');\nvar Pool = _dereq_('./Pool');\n\n/**\n * @class Vec3Pool\n * @constructor\n * @extends Pool\n */\nfunction Vec3Pool(){\n    Pool.call(this);\n    this.type = Vec3;\n}\nVec3Pool.prototype = new Pool();\n\n/**\n * Construct a vector\n * @method constructObject\n * @return {Vec3}\n */\nVec3Pool.prototype.constructObject = function(){\n    return new Vec3();\n};\n\n},{\"../math/Vec3\":27,\"./Pool\":46}],50:[function(_dereq_,module,exports){\nmodule.exports = Narrowphase;\n\nvar Shape = _dereq_('../shapes/Shape');\nvar Vec3 = _dereq_('../math/Vec3');\nvar Transform = _dereq_('../math/Transform');\nvar ConvexPolyhedron = _dereq_('../shapes/ConvexPolyhedron');\nvar Quaternion = _dereq_('../math/Quaternion');\nvar Solver = _dereq_('../solver/Solver');\nvar Vec3Pool = _dereq_('../utils/Vec3Pool');\nvar ContactEquation = _dereq_('../equations/ContactEquation');\n\n/**\n * Helper class for the World. Generates ContactEquations.\n * @class Narrowphase\n * @constructor\n * @todo Sphere-ConvexPolyhedron contacts\n * @todo Contact reduction\n * @todo  should move methods to prototype\n */\nfunction Narrowphase(){\n\n    /**\n     * Turns on or off contact reduction. Can be handy to turn off when debugging new collision types.\n     * @property bool contactReduction\n     */\n    this.contactReduction = false;\n\n    /**\n     * Internal storage of pooled contact points.\n     * @property {Array} contactPointPool\n     */\n    this.contactPointPool = [];\n\n    /**\n     * Pooled vectors.\n     * @property {Vec3Pool} v3pool\n     */\n    this.v3pool = new Vec3Pool();\n}\n\n/**\n * Swaps the body references in the contact\n * @method swapResult\n * @param object r\n */\nNarrowphase.prototype.swapResult = function(r){\n    var temp;\n    temp = r.ri;\n    r.ri = r.rj;\n    r.rj = temp;\n    r.ni.negate(r.ni);\n    temp = r.bi;\n    r.bi = r.bj;\n    r.bj = temp;\n};\n\n/**\n * Removes unnecessary members of an array of ContactEquation.\n * @method reduceContacts\n * @param {Array} contacts\n */\nNarrowphase.prototype.reduceContacts = function(contacts){\n\n};\n\n/**\n * Make a contact object, by using the internal pool or creating a new one.\n * @method makeResult\n * @return {ContactEquation}\n */\nNarrowphase.prototype.makeResult = function(bi, bj, si, sj, rsi, rsj){\n    var c;\n    if(this.contactPointPool.length){\n        c = this.contactPointPool.pop();\n        c.bi = bi;\n        c.bj = bj;\n    } else {\n        c = new ContactEquation(bi, bj);\n    }\n\n    c.enabled = true;\n    c.si = rsi || si;\n    c.sj = rsj || sj;\n\n    return c;\n};\n\nvar tmpVec1 = new Vec3();\nvar tmpVec2 = new Vec3();\nvar tmpQuat1 = new Quaternion();\nvar tmpQuat2 = new Quaternion();\n\n/**\n * Generate all contacts between a list of body pairs\n * @method getContacts\n * @param {array} p1 Array of body indices\n * @param {array} p2 Array of body indices\n * @param {World} world\n * @param {array} result Array to store generated contacts\n * @param {array} oldcontacts Optional. Array of reusable contact objects\n */\nNarrowphase.prototype.getContacts = function(p1,p2,world,result,oldcontacts){\n    // Save old contact objects\n    this.contactPointPool = oldcontacts;\n\n    var qi = tmpQuat1;\n    var qj = tmpQuat2;\n    var xi = tmpVec1;\n    var xj = tmpVec2;\n\n    for(var k=0, N=p1.length; k!==N; k++){\n\n        // Get current collision bodies\n        var bi = p1[k],\n            bj = p2[k];\n\n        for (var i = 0; i < bi.shapes.length; i++) {\n            bi.quaternion.mult(bi.shapeOrientations[i], qi);\n            bi.quaternion.vmult(bi.shapeOffsets[i], xi);\n            xi.vadd(bi.position, xi);\n            var si = bi.shapes[i];\n\n            for (var j = 0; j < bj.shapes.length; j++) {\n\n                // Compute world transform of shapes\n                bj.quaternion.mult(bj.shapeOrientations[j], qj);\n                bj.quaternion.vmult(bj.shapeOffsets[j], xj);\n                xj.vadd(bj.position, xj);\n                var sj = bj.shapes[j];\n\n                if(xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius){\n                    break;\n                }\n\n                // Get contacts\n                var resolver = this[si.type | sj.type];\n                if(resolver){\n                    if (si.type < sj.type) {\n                        resolver.call(this, result, si,sj,xi,xj,qi,qj,bi,bj,si,sj);\n                    } else {\n                        resolver.call(this, result, sj,si,xj,xi,qj,qi,bj,bi,si,sj);\n                    }\n                }\n                /*\n                this.narrowphase(\n                    result,\n                    bi.shapes[i],\n                    bj.shapes[j],\n                    xi, xj,\n                    qi, qj,\n                    bi, bj\n                );\n                */\n            }\n        }\n    }\n};\n\nvar numWarnings = 0;\nvar maxWarnings = 10;\n\nfunction warn(msg){\n    if(numWarnings > maxWarnings){\n        return;\n    }\n\n    numWarnings++;\n\n    console.warn(msg);\n}\n\n/**\n * Narrowphase calculation. Get the ContactEquations given two shapes: i and j\n * @method narrowphase\n * @param {array} result The result one will get back with all the contact point information\n * @param {Shape} si Colliding shape. If not given, particle is assumed.\n * @param {Shape} sj\n * @param {Vec3} xi Position of the center of mass\n * @param {Vec3} xj\n * @param {Quaternion} qi Rotation around the center of mass\n * @param {Quaternion} qj\n */\n/*\nNarrowphase.prototype.narrowphase = function(result,si,sj,xi,xj,qi,qj,bi,bj){\n    var swapped = false,\n        types = Shape.types,\n        SPHERE = types.SPHERE,\n        PLANE = types.PLANE,\n        PARTICLE = types.PARTICLE,\n        BOX = types.BOX,\n        COMPOUND = types.COMPOUND,\n        CONVEXPOLYHEDRON = types.CONVEXPOLYHEDRON,\n        HEIGHTFIELD = types.HEIGHTFIELD;\n\n    if(si.type > sj.type){\n        var temp;\n\n        temp = sj;\n        sj = si;\n        si = temp;\n\n        temp = xj;\n        xj = xi;\n        xi = temp;\n\n        temp = qj;\n        qj = qi;\n        qi = temp;\n\n        temp = bj;\n        bj = bi;\n        bi = temp;\n\n        swapped = true;\n    }\n\n    if(si && sj){\n        if(si.type === SPHERE){\n\n            switch(sj.type){\n            case SPHERE: // sphere-sphere\n                this.sphereSphere(result,si,sj,xi,xj,qi,qj,bi,bj);\n                break;\n            case PLANE: // sphere-plane\n                this.spherePlane(result,si,sj,xi,xj,qi,qj,bi,bj);\n                break;\n            case BOX: // sphere-box\n                this.sphereBox(result,si,sj,xi,xj,qi,qj,bi,bj);\n                break;\n            case CONVEXPOLYHEDRON: // sphere-convexpolyhedron\n                this.sphereConvex(result,si,sj,xi,xj,qi,qj,bi,bj);\n                break;\n            case HEIGHTFIELD: // sphere-heightfield\n                this.sphereHeightfield(result,si,sj,xi,xj,qi,qj,bi,bj);\n                break;\n            case PARTICLE: // Particle vs sphere\n                this.particleSphere(result,sj,si,xj,xi,qj,qi,bj,bi);\n                break;\n            default:\n                warn(\"Collision between Shape.types.SPHERE and \"+sj.type+\" not implemented yet.\");\n                break;\n            }\n\n        } else if(si.type === types.PLANE){\n\n            switch(sj.type){\n            case PLANE: // plane-plane\n                // Should not give collision\n                break;\n            case BOX: // plane-box\n                this.planeBox(result,si,sj,xi,xj,qi,qj,bi,bj);\n                break;\n            case CONVEXPOLYHEDRON: // plane-convex polyhedron\n                this.planeConvex(result,si,sj,xi,xj,qi,qj,bi,bj);\n                break;\n            case PARTICLE: // plane-convex polyhedron\n                this.particlePlane(result,sj,si,xj,xi,qj,qi,bj,bi);\n                break;\n            default:\n                warn(\"Collision between Shape.types.PLANE and \"+sj.type+\" not implemented yet.\");\n                break;\n            }\n\n        } else if(si.type===types.BOX){\n\n            switch(sj.type){\n            case BOX: // box-box\n                // Do convex/convex instead\n                this.convexConvex(result,si.convexPolyhedronRepresentation,sj.convexPolyhedronRepresentation,xi,xj,qi,qj,bi,bj,si,sj);\n                break;\n            case CONVEXPOLYHEDRON: // box-convexpolyhedron\n                // Do convex/convex instead\n                this.convexConvex(result,si.convexPolyhedronRepresentation,sj,xi,xj,qi,qj,bi,bj,si,sj);\n                break;\n            case PARTICLE: // Particle vs box\n                this.convexParticle(result,sj,si.convexPolyhedronRepresentation,xj,xi,qj,qi,bj,bi,si,sj);\n                break;\n            case HEIGHTFIELD: // Box vs heightfield\n                this.convexHeightfield(result,si.convexPolyhedronRepresentation,sj,xi,xj,qi,qj,bi,bj,si,sj);\n                break;\n            default:\n                warn(\"Collision between Shape.BOX and \"+sj.type+\" not implemented yet.\");\n                break;\n            }\n\n        } else if(si.type===types.CONVEXPOLYHEDRON){\n\n            switch(sj.type){\n            case types.CONVEXPOLYHEDRON: // convex polyhedron - convex polyhedron\n                this.convexConvex(result,si,sj,xi,xj,qi,qj,bi,bj);\n                break;\n            case types.PARTICLE: // particle-convex\n                this.convexParticle(result,sj,si,xj,xi,qj,qi,bj,bi);\n                break;\n            default:\n                warn(\"Collision between Shape.types.CONVEXPOLYHEDRON and \"+sj.type+\" not implemented yet.\");\n                break;\n            }\n\n        } else if(si.type===types.HEIGHTFIELD){\n\n            switch(sj.type){\n            case types.SPHERE: // heightfield/sphere\n                this.sphereHeightfield(result,si,sj,xi,xj,qi,qj,bi,bj);\n                break;\n            default:\n                warn(\"Collision between Shape.types.HEIGHTFIELD and \"+sj.type+\" not implemented yet.\");\n                break;\n            }\n\n        } else if(si.type === PARTICLE){\n\n            // Particle!\n            switch(sj.type){\n            case types.PLANE: // Particle vs plane\n                this.particlePlane(result,si,sj,xi,xj,qi,qj,bi,bj);\n                break;\n            case types.SPHERE: // Particle vs sphere\n                this.particleSphere(result,si,sj,xi,xj,qi,qj,bi,bj);\n                break;\n            case types.BOX: // Particle vs box\n                this.convexParticle(result,si,sj.convexPolyhedronRepresentation,xi,xj,qi,qj,bi,bj);\n                break;\n            case types.CONVEXPOLYHEDRON: // particle-convex\n                this.convexParticle(result,si,sj,xi,xj,qi,qj,bi,bj);\n                break;\n            default:\n                console.warn(\"Collision between Particle and \"+sj.type+\" not implemented yet.\");\n                break;\n            }\n        }\n    }\n\n    // Swap back if we swapped bodies in the beginning\n    for(var i=0, Nresults=result.length; swapped && i!==Nresults; i++){\n        this.swapResult(result[i]);\n    }\n};\n*/\n\n\nNarrowphase.prototype[Shape.types.BOX | Shape.types.BOX] =\nNarrowphase.prototype.boxBox = function(result,si,sj,xi,xj,qi,qj,bi,bj){\n    this.convexConvex(result,si.convexPolyhedronRepresentation,sj.convexPolyhedronRepresentation,xi,xj,qi,qj,bi,bj,si,sj);\n};\n\nNarrowphase.prototype[Shape.types.BOX | Shape.types.CONVEXPOLYHEDRON] =\nNarrowphase.prototype.boxConvex = function(result,si,sj,xi,xj,qi,qj,bi,bj){\n    this.convexConvex(result,si.convexPolyhedronRepresentation,sj,xi,xj,qi,qj,bi,bj,si,sj);\n};\n\nNarrowphase.prototype[Shape.types.BOX | Shape.types.PARTICLE] =\nNarrowphase.prototype.boxParticle = function(result,si,sj,xi,xj,qi,qj,bi,bj){\n    this.convexParticle(result,si.convexPolyhedronRepresentation,sj,xi,xj,qi,qj,bi,bj,si,sj);\n};\n\n/**\n * @method sphereSphere\n * @param  {Array}      result\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\nNarrowphase.prototype[Shape.types.SPHERE] =\nNarrowphase.prototype.sphereSphere = function(result,si,sj,xi,xj,qi,qj,bi,bj){\n    // We will have only one contact in this case\n    var r = this.makeResult(bi,bj,si,sj);\n\n    // Contact normal\n    bj.position.vsub(xi, r.ni);\n    r.ni.normalize();\n\n    // Contact point locations\n    r.ri.copy(r.ni);\n    r.rj.copy(r.ni);\n    r.ri.mult(si.radius, r.ri);\n    r.rj.mult(-sj.radius, r.rj);\n    result.push(r);\n};\n\nvar point_on_plane_to_sphere = new Vec3();\nvar plane_to_sphere_ortho = new Vec3();\n\n/**\n * @method spherePlane\n * @param  {Array}      result\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\nNarrowphase.prototype[Shape.types.SPHERE | Shape.types.PLANE] =\nNarrowphase.prototype.spherePlane = function(result,si,sj,xi,xj,qi,qj,bi,bj){\n    // We will have one contact in this case\n    var r = this.makeResult(bi,bj,si,sj);\n\n    // Contact normal\n    r.ni.set(0,0,1);\n    qj.vmult(r.ni, r.ni);\n    r.ni.negate(r.ni); // body i is the sphere, flip normal\n    r.ni.normalize(); // Needed?\n\n    // Vector from sphere center to contact point\n    r.ni.mult(si.radius, r.ri);\n\n    // Project down sphere on plane\n    xi.vsub(xj, point_on_plane_to_sphere);\n    r.ni.mult(r.ni.dot(point_on_plane_to_sphere), plane_to_sphere_ortho);\n    point_on_plane_to_sphere.vsub(plane_to_sphere_ortho,r.rj); // The sphere position projected to plane\n\n    if(plane_to_sphere_ortho.norm2() <= si.radius * si.radius){\n        result.push(r);\n\n        // Make it relative to the body\n        var ri = r.ri;\n        var rj = r.rj;\n        ri.vadd(xi, ri);\n        ri.vsub(bi.position, ri);\n        rj.vadd(xj, rj);\n        rj.vsub(bj.position, rj);\n    }\n};\n\n// See http://bulletphysics.com/Bullet/BulletFull/SphereTriangleDetector_8cpp_source.html\nvar pointInPolygon_edge = new Vec3();\nvar pointInPolygon_edge_x_normal = new Vec3();\nvar pointInPolygon_vtp = new Vec3();\nfunction pointInPolygon(verts, normal, p){\n    var positiveResult = null;\n    var N = verts.length;\n    for(var i=0; i!==N; i++){\n        var v = verts[i];\n\n        // Get edge to the next vertex\n        var edge = pointInPolygon_edge;\n        verts[(i+1) % (N)].vsub(v,edge);\n\n        // Get cross product between polygon normal and the edge\n        var edge_x_normal = pointInPolygon_edge_x_normal;\n        //var edge_x_normal = new Vec3();\n        edge.cross(normal,edge_x_normal);\n\n        // Get vector between point and current vertex\n        var vertex_to_p = pointInPolygon_vtp;\n        p.vsub(v,vertex_to_p);\n\n        // This dot product determines which side of the edge the point is\n        var r = edge_x_normal.dot(vertex_to_p);\n\n        // If all such dot products have same sign, we are inside the polygon.\n        if(positiveResult===null || (r>0 && positiveResult===true) || (r<=0 && positiveResult===false)){\n            if(positiveResult===null){\n                positiveResult = r>0;\n            }\n            continue;\n        } else {\n            return false; // Encountered some other sign. Exit.\n        }\n    }\n\n    // If we got here, all dot products were of the same sign.\n    return true;\n}\n\nvar box_to_sphere = new Vec3();\nvar sphereBox_ns = new Vec3();\nvar sphereBox_ns1 = new Vec3();\nvar sphereBox_ns2 = new Vec3();\nvar sphereBox_sides = [new Vec3(),new Vec3(),new Vec3(),new Vec3(),new Vec3(),new Vec3()];\nvar sphereBox_sphere_to_corner = new Vec3();\nvar sphereBox_side_ns = new Vec3();\nvar sphereBox_side_ns1 = new Vec3();\nvar sphereBox_side_ns2 = new Vec3();\n\n/**\n * @method sphereBox\n * @param  {Array}      result\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\nNarrowphase.prototype[Shape.types.SPHERE | Shape.types.BOX] =\nNarrowphase.prototype.sphereBox = function(result,si,sj,xi,xj,qi,qj,bi,bj){\n    var v3pool = this.v3pool;\n\n    // we refer to the box as body j\n    var sides = sphereBox_sides;\n    xi.vsub(xj,box_to_sphere);\n    sj.getSideNormals(sides,qj);\n    var R =     si.radius;\n    var penetrating_sides = [];\n\n    // Check side (plane) intersections\n    var found = false;\n\n    // Store the resulting side penetration info\n    var side_ns = sphereBox_side_ns;\n    var side_ns1 = sphereBox_side_ns1;\n    var side_ns2 = sphereBox_side_ns2;\n    var side_h = null;\n    var side_penetrations = 0;\n    var side_dot1 = 0;\n    var side_dot2 = 0;\n    var side_distance = null;\n    for(var idx=0,nsides=sides.length; idx!==nsides && found===false; idx++){\n        // Get the plane side normal (ns)\n        var ns = sphereBox_ns;\n        ns.copy(sides[idx]);\n\n        var h = ns.norm();\n        ns.normalize();\n\n        // The normal/distance dot product tells which side of the plane we are\n        var dot = box_to_sphere.dot(ns);\n\n        if(dot<h+R && dot>0){\n            // Intersects plane. Now check the other two dimensions\n            var ns1 = sphereBox_ns1;\n            var ns2 = sphereBox_ns2;\n            ns1.copy(sides[(idx+1)%3]);\n            ns2.copy(sides[(idx+2)%3]);\n            var h1 = ns1.norm();\n            var h2 = ns2.norm();\n            ns1.normalize();\n            ns2.normalize();\n            var dot1 = box_to_sphere.dot(ns1);\n            var dot2 = box_to_sphere.dot(ns2);\n            if(dot1<h1 && dot1>-h1 && dot2<h2 && dot2>-h2){\n                var dist = Math.abs(dot-h-R);\n                if(side_distance===null || dist < side_distance){\n                    side_distance = dist;\n                    side_dot1 = dot1;\n                    side_dot2 = dot2;\n                    side_h = h;\n                    side_ns.copy(ns);\n                    side_ns1.copy(ns1);\n                    side_ns2.copy(ns2);\n                    side_penetrations++;\n                }\n            }\n        }\n    }\n    if(side_penetrations){\n        found = true;\n        var r = this.makeResult(bi,bj,si,sj);\n        side_ns.mult(-R,r.ri); // Sphere r\n        r.ni.copy(side_ns);\n        r.ni.negate(r.ni); // Normal should be out of sphere\n        side_ns.mult(side_h,side_ns);\n        side_ns1.mult(side_dot1,side_ns1);\n        side_ns.vadd(side_ns1,side_ns);\n        side_ns2.mult(side_dot2,side_ns2);\n        side_ns.vadd(side_ns2,r.rj);\n\n        // Make relative to bodies\n        r.ri.vadd(xi, r.ri);\n        r.ri.vsub(bi.position, r.ri);\n        r.rj.vadd(xj, r.rj);\n        r.rj.vsub(bj.position, r.rj);\n\n        result.push(r);\n    }\n\n    // Check corners\n    var rj = v3pool.get();\n    var sphere_to_corner = sphereBox_sphere_to_corner;\n    for(var j=0; j!==2 && !found; j++){\n        for(var k=0; k!==2 && !found; k++){\n            for(var l=0; l!==2 && !found; l++){\n                rj.set(0,0,0);\n                if(j){\n                    rj.vadd(sides[0],rj);\n                } else {\n                    rj.vsub(sides[0],rj);\n                }\n                if(k){\n                    rj.vadd(sides[1],rj);\n                } else {\n                    rj.vsub(sides[1],rj);\n                }\n                if(l){\n                    rj.vadd(sides[2],rj);\n                } else {\n                    rj.vsub(sides[2],rj);\n                }\n\n                // World position of corner\n                xj.vadd(rj,sphere_to_corner);\n                sphere_to_corner.vsub(xi,sphere_to_corner);\n\n                if(sphere_to_corner.norm2() < R*R){\n                    found = true;\n                    var r = this.makeResult(bi,bj,si,sj);\n                    r.ri.copy(sphere_to_corner);\n                    r.ri.normalize();\n                    r.ni.copy(r.ri);\n                    r.ri.mult(R,r.ri);\n                    r.rj.copy(rj);\n\n                    // Make relative to bodies\n                    r.ri.vadd(xi, r.ri);\n                    r.ri.vsub(bi.position, r.ri);\n                    r.rj.vadd(xj, r.rj);\n                    r.rj.vsub(bj.position, r.rj);\n\n                    result.push(r);\n                }\n            }\n        }\n    }\n    v3pool.release(rj);\n    rj = null;\n\n    // Check edges\n    var edgeTangent = v3pool.get();\n    var edgeCenter = v3pool.get();\n    var r = v3pool.get(); // r = edge center to sphere center\n    var orthogonal = v3pool.get();\n    var dist = v3pool.get();\n    var Nsides = sides.length;\n    for(var j=0; j!==Nsides && !found; j++){\n        for(var k=0; k!==Nsides && !found; k++){\n            if(j%3 !== k%3){\n                // Get edge tangent\n                sides[k].cross(sides[j],edgeTangent);\n                edgeTangent.normalize();\n                sides[j].vadd(sides[k], edgeCenter);\n                r.copy(xi);\n                r.vsub(edgeCenter,r);\n                r.vsub(xj,r);\n                var orthonorm = r.dot(edgeTangent); // distance from edge center to sphere center in the tangent direction\n                edgeTangent.mult(orthonorm,orthogonal); // Vector from edge center to sphere center in the tangent direction\n\n                // Find the third side orthogonal to this one\n                var l = 0;\n                while(l===j%3 || l===k%3){\n                    l++;\n                }\n\n                // vec from edge center to sphere projected to the plane orthogonal to the edge tangent\n                dist.copy(xi);\n                dist.vsub(orthogonal,dist);\n                dist.vsub(edgeCenter,dist);\n                dist.vsub(xj,dist);\n\n                // Distances in tangent direction and distance in the plane orthogonal to it\n                var tdist = Math.abs(orthonorm);\n                var ndist = dist.norm();\n\n                if(tdist < sides[l].norm() && ndist<R){\n                    found = true;\n                    var res = this.makeResult(bi,bj,si,sj);\n                    edgeCenter.vadd(orthogonal,res.rj); // box rj\n                    res.rj.copy(res.rj);\n                    dist.negate(res.ni);\n                    res.ni.normalize();\n\n                    res.ri.copy(res.rj);\n                    res.ri.vadd(xj,res.ri);\n                    res.ri.vsub(xi,res.ri);\n                    res.ri.normalize();\n                    res.ri.mult(R,res.ri);\n\n                    // Make relative to bodies\n                    res.ri.vadd(xi, res.ri);\n                    res.ri.vsub(bi.position, res.ri);\n                    res.rj.vadd(xj, res.rj);\n                    res.rj.vsub(bj.position, res.rj);\n\n                    result.push(res);\n                }\n            }\n        }\n    }\n    v3pool.release(edgeTangent,edgeCenter,r,orthogonal,dist);\n};\n\nvar convex_to_sphere = new Vec3();\nvar sphereConvex_edge = new Vec3();\nvar sphereConvex_edgeUnit = new Vec3();\nvar sphereConvex_sphereToCorner = new Vec3();\nvar sphereConvex_worldCorner = new Vec3();\nvar sphereConvex_worldNormal = new Vec3();\nvar sphereConvex_worldPoint = new Vec3();\nvar sphereConvex_worldSpherePointClosestToPlane = new Vec3();\nvar sphereConvex_penetrationVec = new Vec3();\nvar sphereConvex_sphereToWorldPoint = new Vec3();\n\n/**\n * @method sphereConvex\n * @param  {Array}      result\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\nNarrowphase.prototype[Shape.types.SPHERE | Shape.types.CONVEXPOLYHEDRON] =\nNarrowphase.prototype.sphereConvex = function(result,si,sj,xi,xj,qi,qj,bi,bj){\n    var v3pool = this.v3pool;\n    xi.vsub(xj,convex_to_sphere);\n    var normals = sj.faceNormals;\n    var faces = sj.faces;\n    var verts = sj.vertices;\n    var R =     si.radius;\n    var penetrating_sides = [];\n\n    if(convex_to_sphere.norm2() > si.boundingSphereRadius + sj.boundingSphereRadius){\n        return;\n    }\n\n    // Check corners\n    for(var i=0; i!==verts.length; i++){\n        var v = verts[i];\n\n        // World position of corner\n        var worldCorner = sphereConvex_worldCorner;\n        qj.vmult(v,worldCorner);\n        xj.vadd(worldCorner,worldCorner);\n        var sphere_to_corner = sphereConvex_sphereToCorner;\n        worldCorner.vsub(xi, sphere_to_corner);\n        if(sphere_to_corner.norm2() < R * R){\n            found = true;\n            var r = this.makeResult(bi,bj,si,sj);\n            r.ri.copy(sphere_to_corner);\n            r.ri.normalize();\n            r.ni.copy(r.ri);\n            r.ri.mult(R,r.ri);\n            worldCorner.vsub(xj,r.rj);\n\n            // Should be relative to the body.\n            r.ri.vadd(xi, r.ri);\n            r.ri.vsub(bi.position, r.ri);\n\n            // Should be relative to the body.\n            r.rj.vadd(xj, r.rj);\n            r.rj.vsub(bj.position, r.rj);\n\n            result.push(r);\n            return;\n        }\n    }\n\n    // Check side (plane) intersections\n    var found = false;\n    for(var i=0, nfaces=faces.length; i!==nfaces && found===false; i++){\n        var normal = normals[i];\n        var face = faces[i];\n\n        // Get world-transformed normal of the face\n        var worldNormal = sphereConvex_worldNormal;\n        qj.vmult(normal,worldNormal);\n\n        // Get a world vertex from the face\n        var worldPoint = sphereConvex_worldPoint;\n        qj.vmult(verts[face[0]],worldPoint);\n        worldPoint.vadd(xj,worldPoint);\n\n        // Get a point on the sphere, closest to the face normal\n        var worldSpherePointClosestToPlane = sphereConvex_worldSpherePointClosestToPlane;\n        worldNormal.mult(-R, worldSpherePointClosestToPlane);\n        xi.vadd(worldSpherePointClosestToPlane, worldSpherePointClosestToPlane);\n\n        // Vector from a face point to the closest point on the sphere\n        var penetrationVec = sphereConvex_penetrationVec;\n        worldSpherePointClosestToPlane.vsub(worldPoint,penetrationVec);\n\n        // The penetration. Negative value means overlap.\n        var penetration = penetrationVec.dot(worldNormal);\n\n        var worldPointToSphere = sphereConvex_sphereToWorldPoint;\n        xi.vsub(worldPoint, worldPointToSphere);\n\n        if(penetration < 0 && worldPointToSphere.dot(worldNormal)>0){\n            // Intersects plane. Now check if the sphere is inside the face polygon\n            var faceVerts = []; // Face vertices, in world coords\n            for(var j=0, Nverts=face.length; j!==Nverts; j++){\n                var worldVertex = v3pool.get();\n                qj.vmult(verts[face[j]], worldVertex);\n                xj.vadd(worldVertex,worldVertex);\n                faceVerts.push(worldVertex);\n            }\n\n            if(pointInPolygon(faceVerts,worldNormal,xi)){ // Is the sphere center in the face polygon?\n                found = true;\n                var r = this.makeResult(bi,bj,si,sj);\n\n                worldNormal.mult(-R, r.ri); // Contact offset, from sphere center to contact\n                worldNormal.negate(r.ni); // Normal pointing out of sphere\n\n                var penetrationVec2 = v3pool.get();\n                worldNormal.mult(-penetration, penetrationVec2);\n                var penetrationSpherePoint = v3pool.get();\n                worldNormal.mult(-R, penetrationSpherePoint);\n\n                //xi.vsub(xj).vadd(penetrationSpherePoint).vadd(penetrationVec2 , r.rj);\n                xi.vsub(xj,r.rj);\n                r.rj.vadd(penetrationSpherePoint,r.rj);\n                r.rj.vadd(penetrationVec2 , r.rj);\n\n                // Should be relative to the body.\n                r.rj.vadd(xj, r.rj);\n                r.rj.vsub(bj.position, r.rj);\n\n                // Should be relative to the body.\n                r.ri.vadd(xi, r.ri);\n                r.ri.vsub(bi.position, r.ri);\n\n                v3pool.release(penetrationVec2);\n                v3pool.release(penetrationSpherePoint);\n\n                result.push(r);\n\n                // Release world vertices\n                for(var j=0, Nfaceverts=faceVerts.length; j!==Nfaceverts; j++){\n                    v3pool.release(faceVerts[j]);\n                }\n\n                return; // We only expect *one* face contact\n            } else {\n                // Edge?\n                for(var j=0; j!==face.length; j++){\n\n                    // Get two world transformed vertices\n                    var v1 = v3pool.get();\n                    var v2 = v3pool.get();\n                    qj.vmult(verts[face[(j+1)%face.length]], v1);\n                    qj.vmult(verts[face[(j+2)%face.length]], v2);\n                    xj.vadd(v1, v1);\n                    xj.vadd(v2, v2);\n\n                    // Construct edge vector\n                    var edge = sphereConvex_edge;\n                    v2.vsub(v1,edge);\n\n                    // Construct the same vector, but normalized\n                    var edgeUnit = sphereConvex_edgeUnit;\n                    edge.unit(edgeUnit);\n\n                    // p is xi projected onto the edge\n                    var p = v3pool.get();\n                    var v1_to_xi = v3pool.get();\n                    xi.vsub(v1, v1_to_xi);\n                    var dot = v1_to_xi.dot(edgeUnit);\n                    edgeUnit.mult(dot, p);\n                    p.vadd(v1, p);\n\n                    // Compute a vector from p to the center of the sphere\n                    var xi_to_p = v3pool.get();\n                    p.vsub(xi, xi_to_p);\n\n                    // Collision if the edge-sphere distance is less than the radius\n                    // AND if p is in between v1 and v2\n                    if(dot > 0 && dot*dot<edge.norm2() && xi_to_p.norm2() < R*R){ // Collision if the edge-sphere distance is less than the radius\n                        // Edge contact!\n                        var r = this.makeResult(bi,bj,si,sj);\n                        p.vsub(xj,r.rj);\n\n                        p.vsub(xi,r.ni);\n                        r.ni.normalize();\n\n                        r.ni.mult(R,r.ri);\n\n                        // Should be relative to the body.\n                        r.rj.vadd(xj, r.rj);\n                        r.rj.vsub(bj.position, r.rj);\n\n                        // Should be relative to the body.\n                        r.ri.vadd(xi, r.ri);\n                        r.ri.vsub(bi.position, r.ri);\n\n                        result.push(r);\n\n                        // Release world vertices\n                        for(var j=0, Nfaceverts=faceVerts.length; j!==Nfaceverts; j++){\n                            v3pool.release(faceVerts[j]);\n                        }\n\n                        v3pool.release(v1);\n                        v3pool.release(v2);\n                        v3pool.release(p);\n                        v3pool.release(xi_to_p);\n                        v3pool.release(v1_to_xi);\n\n                        return;\n                    }\n\n                    v3pool.release(v1);\n                    v3pool.release(v2);\n                    v3pool.release(p);\n                    v3pool.release(xi_to_p);\n                    v3pool.release(v1_to_xi);\n                }\n            }\n\n            // Release world vertices\n            for(var j=0, Nfaceverts=faceVerts.length; j!==Nfaceverts; j++){\n                v3pool.release(faceVerts[j]);\n            }\n        }\n    }\n};\n\nvar planeBox_normal = new Vec3();\nvar plane_to_corner = new Vec3();\n\n/**\n * @method planeBox\n * @param  {Array}      result\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\nNarrowphase.prototype[Shape.types.PLANE | Shape.types.BOX] =\nNarrowphase.prototype.planeBox = function(result,si,sj,xi,xj,qi,qj,bi,bj){\n    this.planeConvex(result,si,sj.convexPolyhedronRepresentation,xi,xj,qi,qj,bi,bj);\n};\n\nvar planeConvex_v = new Vec3();\nvar planeConvex_normal = new Vec3();\nvar planeConvex_relpos = new Vec3();\nvar planeConvex_projected = new Vec3();\n\n/**\n * @method planeConvex\n * @param  {Array}      result\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\nNarrowphase.prototype[Shape.types.PLANE | Shape.types.CONVEXPOLYHEDRON] =\nNarrowphase.prototype.planeConvex = function(\n    result,\n    planeShape,\n    convexShape,\n    planePosition,\n    convexPosition,\n    planeQuat,\n    convexQuat,\n    planeBody,\n    convexBody\n){\n    // Simply return the points behind the plane.\n    var worldVertex = planeConvex_v,\n        worldNormal = planeConvex_normal;\n    worldNormal.set(0,0,1);\n    planeQuat.vmult(worldNormal,worldNormal); // Turn normal according to plane orientation\n\n    var relpos = planeConvex_relpos;\n    for(var i = 0; i !== convexShape.vertices.length; i++){\n\n        // Get world convex vertex\n        worldVertex.copy(convexShape.vertices[i]);\n        convexQuat.vmult(worldVertex, worldVertex);\n        convexPosition.vadd(worldVertex, worldVertex);\n        worldVertex.vsub(planePosition, relpos);\n\n        var dot = worldNormal.dot(relpos);\n        if(dot <= 0.0){\n\n            var r = this.makeResult(planeBody, convexBody, planeShape, convexShape);\n\n            // Get vertex position projected on plane\n            var projected = planeConvex_projected;\n            worldNormal.mult(worldNormal.dot(relpos),projected);\n            worldVertex.vsub(projected, projected);\n            projected.vsub(planePosition, r.ri); // From plane to vertex projected on plane\n\n            r.ni.copy(worldNormal); // Contact normal is the plane normal out from plane\n\n            // rj is now just the vector from the convex center to the vertex\n            worldVertex.vsub(convexPosition, r.rj);\n\n            // Make it relative to the body\n            r.ri.vadd(planePosition, r.ri);\n            r.ri.vsub(planeBody.position, r.ri);\n            r.rj.vadd(convexPosition, r.rj);\n            r.rj.vsub(convexBody.position, r.rj);\n\n            result.push(r);\n        }\n    }\n};\n\nvar convexConvex_sepAxis = new Vec3();\nvar convexConvex_q = new Vec3();\n\n/**\n * @method convexConvex\n * @param  {Array}      result\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\nNarrowphase.prototype[Shape.types.CONVEXPOLYHEDRON] =\nNarrowphase.prototype.convexConvex = function(result,si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj){\n    var sepAxis = convexConvex_sepAxis;\n\n    if(xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius){\n        return;\n    }\n\n    if(si.findSeparatingAxis(sj,xi,qi,xj,qj,sepAxis)){\n        var res = [];\n        var q = convexConvex_q;\n        si.clipAgainstHull(xi,qi,sj,xj,qj,sepAxis,-100,100,res);\n        for(var j = 0; j !== res.length; j++){\n            var r = this.makeResult(bi,bj,si,sj,rsi,rsj),\n                ri = r.ri,\n                rj = r.rj;\n            sepAxis.negate(r.ni);\n            res[j].normal.negate(q);\n            q.mult(res[j].depth, q);\n            res[j].point.vadd(q, ri);\n            rj.copy(res[j].point);\n\n            // Contact points are in world coordinates. Transform back to relative\n            ri.vsub(xi,ri);\n            rj.vsub(xj,rj);\n\n            // Make relative to bodies\n            ri.vadd(xi, ri);\n            ri.vsub(bi.position, ri);\n            rj.vadd(xj, rj);\n            rj.vsub(bj.position, rj);\n\n            result.push(r);\n        }\n    }\n};\n\nvar particlePlane_normal = new Vec3();\nvar particlePlane_relpos = new Vec3();\nvar particlePlane_projected = new Vec3();\n\n/**\n * @method particlePlane\n * @param  {Array}      result\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\nNarrowphase.prototype[Shape.types.PLANE | Shape.types.PARTICLE] =\nNarrowphase.prototype.planeParticle = function(result,sj,si,xj,xi,qj,qi,bj,bi){\n    var normal = particlePlane_normal;\n    normal.set(0,0,1);\n    bj.quaternion.vmult(normal,normal); // Turn normal according to plane orientation\n    var relpos = particlePlane_relpos;\n    xi.vsub(bj.position,relpos);\n    var dot = normal.dot(relpos);\n    if(dot <= 0.0){\n        var r = this.makeResult(bi,bj,si,sj);\n        r.ni.copy(normal); // Contact normal is the plane normal\n        r.ni.negate(r.ni);\n        r.ri.set(0,0,0); // Center of particle\n\n        // Get particle position projected on plane\n        var projected = particlePlane_projected;\n        normal.mult(normal.dot(xi),projected);\n        xi.vsub(projected,projected);\n        //projected.vadd(bj.position,projected);\n\n        // rj is now the projected world position minus plane position\n        r.rj.copy(projected);\n        result.push(r);\n    }\n};\n\nvar particleSphere_normal = new Vec3();\n\n/**\n * @method particleSphere\n * @param  {Array}      result\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\nNarrowphase.prototype[Shape.types.PARTICLE | Shape.types.SPHERE] =\nNarrowphase.prototype.sphereParticle = function(result,sj,si,xj,xi,qj,qi,bj,bi){\n    // The normal is the unit vector from sphere center to particle center\n    var normal = particleSphere_normal;\n    normal.set(0,0,1);\n    xi.vsub(xj,normal);\n    var lengthSquared = normal.norm2();\n\n    if(lengthSquared <= sj.radius * sj.radius){\n        var r = this.makeResult(bi,bj,si,sj);\n        normal.normalize();\n        r.rj.copy(normal);\n        r.rj.mult(sj.radius,r.rj);\n        r.ni.copy(normal); // Contact normal\n        r.ni.negate(r.ni);\n        r.ri.set(0,0,0); // Center of particle\n        result.push(r);\n    }\n};\n\n// WIP\nvar cqj = new Quaternion();\nvar convexParticle_local = new Vec3();\nvar convexParticle_normal = new Vec3();\nvar convexParticle_penetratedFaceNormal = new Vec3();\nvar convexParticle_vertexToParticle = new Vec3();\nvar convexParticle_worldPenetrationVec = new Vec3();\n\n/**\n * @method convexParticle\n * @param  {Array}      result\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\nNarrowphase.prototype[Shape.types.PARTICLE | Shape.types.CONVEXPOLYHEDRON] =\nNarrowphase.prototype.convexParticle = function(result,sj,si,xj,xi,qj,qi,bj,bi){\n    var penetratedFaceIndex = -1;\n    var penetratedFaceNormal = convexParticle_penetratedFaceNormal;\n    var worldPenetrationVec = convexParticle_worldPenetrationVec;\n    var minPenetration = null;\n    var numDetectedFaces = 0;\n\n    // Convert particle position xi to local coords in the convex\n    var local = convexParticle_local;\n    local.copy(xi);\n    local.vsub(xj,local); // Convert position to relative the convex origin\n    qj.conjugate(cqj);\n    cqj.vmult(local,local);\n\n    if(sj.pointIsInside(local)){\n\n        if(sj.worldVerticesNeedsUpdate){\n            sj.computeWorldVertices(xj,qj);\n        }\n        if(sj.worldFaceNormalsNeedsUpdate){\n            sj.computeWorldFaceNormals(qj);\n        }\n\n        // For each world polygon in the polyhedra\n        for(var i=0,nfaces=sj.faces.length; i!==nfaces; i++){\n\n            // Construct world face vertices\n            var verts = [ sj.worldVertices[ sj.faces[i][0] ] ];\n            var normal = sj.worldFaceNormals[i];\n\n            // Check how much the particle penetrates the polygon plane.\n            xi.vsub(verts[0],convexParticle_vertexToParticle);\n            var penetration = -normal.dot(convexParticle_vertexToParticle);\n            if(minPenetration===null || Math.abs(penetration)<Math.abs(minPenetration)){\n                minPenetration = penetration;\n                penetratedFaceIndex = i;\n                penetratedFaceNormal.copy(normal);\n                numDetectedFaces++;\n            }\n        }\n\n        if(penetratedFaceIndex!==-1){\n            // Setup contact\n            var r = this.makeResult(bi,bj,si,sj);\n            penetratedFaceNormal.mult(minPenetration, worldPenetrationVec);\n\n            // rj is the particle position projected to the face\n            worldPenetrationVec.vadd(xi,worldPenetrationVec);\n            worldPenetrationVec.vsub(xj,worldPenetrationVec);\n            r.rj.copy(worldPenetrationVec);\n            //var projectedToFace = xi.vsub(xj).vadd(worldPenetrationVec);\n            //projectedToFace.copy(r.rj);\n\n            //qj.vmult(r.rj,r.rj);\n            penetratedFaceNormal.negate( r.ni ); // Contact normal\n            r.ri.set(0,0,0); // Center of particle\n\n            var ri = r.ri,\n                rj = r.rj;\n\n            // Make relative to bodies\n            ri.vadd(xi, ri);\n            ri.vsub(bi.position, ri);\n            rj.vadd(xj, rj);\n            rj.vsub(bj.position, rj);\n\n            result.push(r);\n        } else {\n            console.warn(\"Point found inside convex, but did not find penetrating face!\");\n        }\n    }\n};\n\nNarrowphase.prototype[Shape.types.BOX | Shape.types.HEIGHTFIELD] =\nNarrowphase.prototype.boxHeightfield = function (result,si,sj,xi,xj,qi,qj,bi,bj){\n    this.convexHeightfield(result,si.convexPolyhedronRepresentation,sj,xi,xj,qi,qj,bi,bj);\n};\n\nvar convexHeightfield_tmp1 = new Vec3();\nvar convexHeightfield_tmp2 = new Vec3();\n\n/**\n * @method sphereHeightfield\n */\nNarrowphase.prototype[Shape.types.CONVEXPOLYHEDRON | Shape.types.HEIGHTFIELD] =\nNarrowphase.prototype.convexHeightfield = function (\n    result,\n    convexShape,\n    hfShape,\n    convexPos,\n    hfPos,\n    convexQuat,\n    hfQuat,\n    convexBody,\n    hfBody\n){\n    var data = hfShape.data,\n        w = hfShape.elementSize,\n        radius = convexShape.boundingSphereRadius,\n        worldPillarOffset = convexHeightfield_tmp2;\n\n    // Get sphere position to heightfield local!\n    var localConvexPos = convexHeightfield_tmp1;\n    Transform.pointToLocalFrame(hfPos, hfQuat, convexPos, localConvexPos);\n\n    // Get the index of the data points to test against\n    var iMinX = Math.floor((localConvexPos.x - radius) / w) - 1,\n        iMaxX = Math.ceil((localConvexPos.x + radius) / w) + 1,\n        iMinY = Math.floor((localConvexPos.y - radius) / w) - 1,\n        iMaxY = Math.ceil((localConvexPos.y + radius) / w) + 1;\n\n    // Bail out if we are out of the terrain\n    if(iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMaxY > data[0].length){\n        return;\n    }\n\n    // Clamp index to edges\n    if(iMinX < 0){ iMinX = 0; }\n    if(iMaxX < 0){ iMaxX = 0; }\n    if(iMinY < 0){ iMinY = 0; }\n    if(iMaxY < 0){ iMaxY = 0; }\n    if(iMinX >= data.length){ iMinX = data.length - 1; }\n    if(iMaxX >= data.length){ iMaxX = data.length - 1; }\n    if(iMaxY >= data[0].length){ iMaxY = data[0].length - 1; }\n    if(iMinY >= data[0].length){ iMinY = data[0].length - 1; }\n\n    var minMax = [];\n    hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);\n    var min = minMax[0];\n    var max = minMax[1];\n\n    // Bail out if we're cant touch the bounding height box\n    if(localConvexPos.z - radius > max || localConvexPos.z + radius < min){\n        return;\n    }\n\n    for(var i = iMinX; i < iMaxX; i++){\n        for(var j = iMinY; j < iMaxY; j++){\n\n            // Lower triangle\n            hfShape.getConvexTrianglePillar(i, j, false);\n            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);\n            this.convexConvex(result, convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset, convexQuat, hfQuat, convexBody, hfBody);\n\n            // Upper triangle\n            hfShape.getConvexTrianglePillar(i, j, true);\n            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);\n            this.convexConvex(result, convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset, convexQuat, hfQuat, convexBody, hfBody);\n        }\n    }\n};\n\n\n\n\nvar sphereHeightfield_tmp1 = new Vec3();\nvar sphereHeightfield_tmp2 = new Vec3();\n\n/**\n * @method sphereHeightfield\n */\nNarrowphase.prototype[Shape.types.SPHERE | Shape.types.HEIGHTFIELD] =\nNarrowphase.prototype.sphereHeightfield = function (\n    result,\n    sphereShape,\n    hfShape,\n    spherePos,\n    hfPos,\n    sphereQuat,\n    hfQuat,\n    sphereBody,\n    hfBody\n){\n    var data = hfShape.data,\n        radius = sphereShape.radius,\n        w = hfShape.elementSize,\n        worldPillarOffset = sphereHeightfield_tmp2;\n\n    // Get sphere position to heightfield local!\n    var localSpherePos = sphereHeightfield_tmp1;\n    Transform.pointToLocalFrame(hfPos, hfQuat, spherePos, localSpherePos);\n\n    // Get the index of the data points to test against\n    var iMinX = Math.floor((localSpherePos.x - radius) / w) - 1,\n        iMaxX = Math.ceil((localSpherePos.x + radius) / w) + 1,\n        iMinY = Math.floor((localSpherePos.y - radius) / w) - 1,\n        iMaxY = Math.ceil((localSpherePos.y + radius) / w) + 1;\n\n    // Bail out if we are out of the terrain\n    if(iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMaxY > data[0].length){\n        return;\n    }\n\n    // Clamp index to edges\n    if(iMinX < 0){ iMinX = 0; }\n    if(iMaxX < 0){ iMaxX = 0; }\n    if(iMinY < 0){ iMinY = 0; }\n    if(iMaxY < 0){ iMaxY = 0; }\n    if(iMinX >= data.length){ iMinX = data.length - 1; }\n    if(iMaxX >= data.length){ iMaxX = data.length - 1; }\n    if(iMaxY >= data[0].length){ iMaxY = data[0].length - 1; }\n    if(iMinY >= data[0].length){ iMinY = data[0].length - 1; }\n\n    var minMax = [];\n    hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);\n    var min = minMax[0];\n    var max = minMax[1];\n\n    // Bail out if we're cant touch the bounding height box\n    if(localSpherePos.z - radius > max || localSpherePos.z + radius < min){\n        return;\n    }\n\n    for(var i = iMinX; i < iMaxX; i++){\n        for(var j = iMinY; j < iMaxY; j++){\n\n            var numContactsBefore = result.length;\n\n            // Lower triangle\n            hfShape.getConvexTrianglePillar(i, j, false);\n            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);\n            this.sphereConvex(result, sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset, sphereQuat, hfQuat, sphereBody, hfBody);\n\n            // Upper triangle\n            hfShape.getConvexTrianglePillar(i, j, true);\n            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);\n            this.sphereConvex(result, sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset, sphereQuat, hfQuat, sphereBody, hfBody);\n\n            var numContacts = result.length - numContactsBefore;\n\n            if(numContacts > 2){\n                return;\n            }\n            /*\n            // Skip all but 1\n            for (var k = 0; k < numContacts - 1; k++) {\n                result.pop();\n            }\n            */\n        }\n    }\n};\n},{\"../equations/ContactEquation\":16,\"../math/Quaternion\":25,\"../math/Transform\":26,\"../math/Vec3\":27,\"../shapes/ConvexPolyhedron\":35,\"../shapes/Shape\":40,\"../solver/Solver\":43,\"../utils/Vec3Pool\":49}],51:[function(_dereq_,module,exports){\n/* global performance */\n\nmodule.exports = World;\n\nvar Shape = _dereq_('../shapes/Shape');\nvar Vec3 = _dereq_('../math/Vec3');\nvar Quaternion = _dereq_('../math/Quaternion');\nvar GSSolver = _dereq_('../solver/GSSolver');\nvar Vec3Pool = _dereq_('../utils/Vec3Pool');\nvar ContactEquation = _dereq_('../equations/ContactEquation');\nvar FrictionEquation = _dereq_('../equations/FrictionEquation');\nvar Narrowphase = _dereq_('./Narrowphase');\nvar EventTarget = _dereq_('../utils/EventTarget');\nvar ArrayCollisionMatrix = _dereq_('../collision/ArrayCollisionMatrix');\nvar Material = _dereq_('../material/Material');\nvar ContactMaterial = _dereq_('../material/ContactMaterial');\nvar Body = _dereq_('../objects/Body');\nvar TupleDictionary = _dereq_('../utils/TupleDictionary');\nvar RaycastResult = _dereq_('../collision/RaycastResult');\nvar AABB = _dereq_('../collision/AABB');\nvar Ray = _dereq_('../collision/Ray');\nvar NaiveBroadphase = _dereq_('../collision/NaiveBroadphase');\n\n/**\n * The physics world\n * @class World\n * @constructor\n * @extends EventTarget\n */\nfunction World(){\n    EventTarget.apply(this);\n\n    /**\n     * Last used timestep. Is set to -1 if not available.\n     * @property {Number} dt\n     */\n    this.dt = -1;\n\n    /**\n     * Makes bodies go to sleep when they've been inactive\n     * @property allowSleep\n     * @type {Boolean}\n     */\n    this.allowSleep = false;\n\n    /**\n     * All the current contacts (instances of ContactEquation) in the world.\n     * @property contacts\n     * @type {Array}\n     */\n    this.contacts = [];\n    this.frictionEquations = [];\n\n    /**\n     * How often to normalize quaternions. Set to 0 for every step, 1 for every second etc.. A larger value increases performance. If bodies tend to explode, set to a smaller value (zero to be sure nothing can go wrong).\n     * @property quatNormalizeSkip\n     * @type {Number}\n     */\n    this.quatNormalizeSkip = 0;\n\n    /**\n     * Set to true to use fast quaternion normalization. It is often enough accurate to use. If bodies tend to explode, set to false.\n     * @property quatNormalizeFast\n     * @type {Boolean}\n     * @see Quaternion.normalizeFast\n     * @see Quaternion.normalize\n     */\n    this.quatNormalizeFast = false;\n\n    /**\n     * The wall-clock time since simulation start\n     * @property time\n     * @type {Number}\n     */\n    this.time = 0.0;\n\n    /**\n     * Number of timesteps taken since start\n     * @property stepnumber\n     * @type {Number}\n     */\n    this.stepnumber = 0;\n\n    /// Default and last timestep sizes\n    this.default_dt = 1/60;\n\n    this.nextId = 0;\n    /**\n     * @property gravity\n     * @type {Vec3}\n     */\n    this.gravity = new Vec3();\n\n    /**\n     * @property broadphase\n     * @type {Broadphase}\n     */\n    this.broadphase = new NaiveBroadphase();\n\n    /**\n     * @property bodies\n     * @type {Array}\n     */\n    this.bodies = [];\n\n    /**\n     * @property solver\n     * @type {Solver}\n     */\n    this.solver = new GSSolver();\n\n    /**\n     * @property constraints\n     * @type {Array}\n     */\n    this.constraints = [];\n\n    /**\n     * @property narrowphase\n     * @type {Narrowphase}\n     */\n    this.narrowphase = new Narrowphase();\n\n    /**\n     * @property {ArrayCollisionMatrix} collisionMatrix\n\t * @type {ArrayCollisionMatrix}\n\t */\n\tthis.collisionMatrix = new ArrayCollisionMatrix();\n\n    /**\n     * CollisionMatrix from the previous step.\n     * @property {ArrayCollisionMatrix} collisionMatrixPrevious\n\t * @type {ArrayCollisionMatrix}\n\t */\n\tthis.collisionMatrixPrevious = new ArrayCollisionMatrix();\n\n    /**\n     * All added materials\n     * @property materials\n     * @type {Array}\n     */\n    this.materials = [];\n\n    /**\n     * @property contactmaterials\n     * @type {Array}\n     */\n    this.contactmaterials = [];\n\n    /**\n     * Used to look up a ContactMaterial given two instances of Material.\n     * @property {TupleDictionary} contactMaterialTable\n     */\n    this.contactMaterialTable = new TupleDictionary();\n\n    this.defaultMaterial = new Material(\"default\");\n\n    /**\n     * This contact material is used if no suitable contactmaterial is found for a contact.\n     * @property defaultContactMaterial\n     * @type {ContactMaterial}\n     */\n    this.defaultContactMaterial = new ContactMaterial(this.defaultMaterial, this.defaultMaterial, { friction: 0.3, restitution: 0.0 });\n\n    /**\n     * @property doProfiling\n     * @type {Boolean}\n     */\n    this.doProfiling = false;\n\n    /**\n     * @property profile\n     * @type {Object}\n     */\n    this.profile = {\n        solve:0,\n        makeContactConstraints:0,\n        broadphase:0,\n        integrate:0,\n        narrowphase:0,\n    };\n\n    /**\n     * @property subystems\n     * @type {Array}\n     */\n    this.subsystems = [];\n\n    this.addBodyEvent = {\n        type:\"addBody\",\n        body : null,\n    };\n\n    this.removeBodyEvent = {\n        type:\"removeBody\",\n        body : null,\n    };\n}\nWorld.prototype = new EventTarget();\n\n// Temp stuff\nvar tmpAABB1 = new AABB();\nvar tmpArray1 = [];\nvar tmpRay = new Ray();\n\n/**\n * Get the contact material between materials m1 and m2\n * @method getContactMaterial\n * @param {Material} m1\n * @param {Material} m2\n * @return {Contactmaterial} The contact material if it was found.\n */\nWorld.prototype.getContactMaterial = function(m1,m2){\n    return this.contactMaterialTable.get(m1.id,m2.id); //this.contactmaterials[this.mats2cmat[i+j*this.materials.length]];\n};\n\n/**\n * Get number of objects in the world.\n * @method numObjects\n * @return {Number}\n * @deprecated\n */\nWorld.prototype.numObjects = function(){\n    return this.bodies.length;\n};\n\n/**\n * Store old collision state info\n * @method collisionMatrixTick\n */\nWorld.prototype.collisionMatrixTick = function(){\n\tvar temp = this.collisionMatrixPrevious;\n\tthis.collisionMatrixPrevious = this.collisionMatrix;\n\tthis.collisionMatrix = temp;\n\tthis.collisionMatrix.reset();\n};\n\n/**\n * Add a rigid body to the simulation.\n * @method add\n * @param {Body} body\n * @todo If the simulation has not yet started, why recrete and copy arrays for each body? Accumulate in dynamic arrays in this case.\n * @todo Adding an array of bodies should be possible. This would save some loops too\n * @deprecated Use .addBody instead\n */\nWorld.prototype.add = World.prototype.addBody = function(body){\n    if(this.bodies.indexOf(body) !== -1){\n        return;\n    }\n    body.index = this.bodies.length;\n    this.bodies.push(body);\n    body.world = this;\n    body.initPosition.copy(body.position);\n    body.initVelocity.copy(body.velocity);\n    body.timeLastSleepy = this.time;\n    if(body instanceof Body){\n        body.initAngularVelocity.copy(body.angularVelocity);\n        body.initQuaternion.copy(body.quaternion);\n    }\n\tthis.collisionMatrix.setNumObjects(this.bodies.length);\n    this.addBodyEvent.body = body;\n    this.dispatchEvent(this.addBodyEvent);\n};\n\n/**\n * Add a constraint to the simulation.\n * @method addConstraint\n * @param {Constraint} c\n */\nWorld.prototype.addConstraint = function(c){\n    this.constraints.push(c);\n};\n\n/**\n * Removes a constraint\n * @method removeConstraint\n * @param {Constraint} c\n */\nWorld.prototype.removeConstraint = function(c){\n    var idx = this.constraints.indexOf(c);\n    if(idx!==-1){\n        this.constraints.splice(idx,1);\n    }\n};\n\n/**\n * Raycast test\n * @method rayTest\n * @param {Vec3} from\n * @param {Vec3} to\n * @param {Function|RaycastResult} result\n */\nWorld.prototype.rayTest = function(from, to, result){\n    // result = result || new RaycastResult();\n\n    tmpArray1[0] = from;\n    tmpArray1[1] = to;\n    tmpAABB1.setFromPoints(tmpArray1);\n    tmpArray1.length = 0;\n\n    this.broadphase.aabbQuery(this, tmpAABB1, tmpArray1);\n\n    tmpRay.from.copy(from);\n    tmpRay.to.copy(to);\n\n    tmpRay.intersectBodies(tmpArray1, result);\n};\n\n/**\n * Remove a rigid body from the simulation.\n * @method remove\n * @param {Body} body\n * @todo Rename to .removeBody\n */\nWorld.prototype.remove = function(body){\n    body.world = null;\n    var n = this.bodies.length-1,\n        bodies = this.bodies,\n        idx = bodies.indexOf(body);\n    if(idx !== -1){\n        bodies.splice(idx, 1); // Todo: should use a garbage free method\n\n        // Recompute index\n        for(var i=0; i!==bodies.length; i++){\n            bodies[i].index = i;\n        }\n\n        this.collisionMatrix.setNumObjects(n);\n        this.removeBodyEvent.body = body;\n        this.dispatchEvent(this.removeBodyEvent);\n    }\n};\n\n/**\n * Adds a material to the World.\n * @method addMaterial\n * @param {Material} m\n * @todo Necessary?\n */\nWorld.prototype.addMaterial = function(m){\n    this.materials.push(m);\n};\n\n/**\n * Adds a contact material to the World\n * @method addContactMaterial\n * @param {ContactMaterial} cmat\n */\nWorld.prototype.addContactMaterial = function(cmat) {\n\n    // Add contact material\n    this.contactmaterials.push(cmat);\n\n    // Add current contact material to the material table\n    this.contactMaterialTable.set(cmat.materials[0].id,cmat.materials[1].id,cmat);\n};\n\n// performance.now()\nif(typeof performance === 'undefined'){\n    performance = {};\n}\nif(!performance.now){\n    var nowOffset = Date.now();\n    if (performance.timing && performance.timing.navigationStart){\n        nowOffset = performance.timing.navigationStart;\n    }\n    performance.now = function(){\n        return Date.now() - nowOffset;\n    };\n}\n\nvar step_tmp1 = new Vec3();\n\n/**\n * Step the physics world forward in time.\n *\n * There are two modes. The simple mode is fixed timestepping without interpolation. In this case you only use the first argument. The second case uses interpolation. In that you also provide the time since the function was last used, as well as the maximum fixed timesteps to take.\n *\n * @method step\n * @param {Number} dt                       The fixed time step size to use.\n * @param {Number} [timeSinceLastCalled]    The time elapsed since the function was last called.\n * @param {Number} [maxSubSteps=10]         Maximum number of fixed steps to take per function call.\n *\n * @example\n *     // fixed timestepping without interpolation\n *     world.step(1/60);\n *\n * @see http://bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World\n */\nWorld.prototype.step = function(dt, timeSinceLastCalled, maxSubSteps){\n    maxSubSteps = maxSubSteps || 10;\n    timeSinceLastCalled = timeSinceLastCalled || 0;\n\n    if(timeSinceLastCalled === 0){ // Fixed, simple stepping\n\n        this.internalStep(dt);\n\n        // Increment time\n        this.time += dt;\n\n    } else {\n\n        // Compute the number of fixed steps we should have taken since the last step\n        var internalSteps = Math.floor((this.time + timeSinceLastCalled) / dt) - Math.floor(this.time / dt);\n        internalSteps = Math.min(internalSteps,maxSubSteps);\n\n        // Do some fixed steps to catch up\n        var t0 = performance.now();\n        for(var i=0; i!==internalSteps; i++){\n            this.internalStep(dt);\n            if(performance.now() - t0 > dt * 1000){\n                // We are slower than real-time. Better bail out.\n                break;\n            }\n        }\n\n        // Increment internal clock\n        this.time += timeSinceLastCalled;\n\n        // Compute \"Left over\" time step\n        var h = this.time % dt;\n        var h_div_dt = h / dt;\n        var interpvelo = step_tmp1;\n        var bodies = this.bodies;\n\n        for(var j=0; j !== bodies.length; j++){\n            var b = bodies[j];\n            if(b.type !== Body.STATIC && b.sleepState !== Body.SLEEPING){\n\n                // Interpolate\n                b.position.vsub(b.previousPosition, interpvelo);\n                interpvelo.scale(h_div_dt, interpvelo);\n                b.position.vadd(interpvelo, b.interpolatedPosition);\n\n                // TODO: interpolate quaternion\n                // b.interpolatedAngle = b.angle + (b.angle - b.previousAngle) * h_div_dt;\n\n            } else {\n\n                // For static bodies, just copy. Who else will do it?\n                b.interpolatedPosition.copy(b.position);\n                b.interpolatedQuaternion.copy(b.quaternion);\n            }\n        }\n    }\n};\n\n/**\n * Step the simulation\n * @method step\n * @param {Number} dt\n */\nvar World_step_postStepEvent = {type:\"postStep\"}, // Reusable event objects to save memory\n    World_step_preStepEvent = {type:\"preStep\"},\n    World_step_collideEvent = {type:\"collide\", body:null, contact:null },\n    World_step_oldContacts = [], // Pools for unused objects\n    World_step_frictionEquationPool = [],\n    World_step_p1 = [], // Reusable arrays for collision pairs\n    World_step_p2 = [],\n    World_step_gvec = new Vec3(), // Temporary vectors and quats\n    World_step_vi = new Vec3(),\n    World_step_vj = new Vec3(),\n    World_step_wi = new Vec3(),\n    World_step_wj = new Vec3(),\n    World_step_t1 = new Vec3(),\n    World_step_t2 = new Vec3(),\n    World_step_rixn = new Vec3(),\n    World_step_rjxn = new Vec3(),\n    World_step_step_q = new Quaternion(),\n    World_step_step_w = new Quaternion(),\n    World_step_step_wq = new Quaternion(),\n    invI_tau_dt = new Vec3();\nWorld.prototype.internalStep = function(dt){\n    this.dt = dt;\n\n    var world = this,\n        that = this,\n        contacts = this.contacts,\n        p1 = World_step_p1,\n        p2 = World_step_p2,\n        N = this.numObjects(),\n        bodies = this.bodies,\n        solver = this.solver,\n        gravity = this.gravity,\n        doProfiling = this.doProfiling,\n        profile = this.profile,\n        DYNAMIC = Body.DYNAMIC,\n        profilingStart,\n        constraints = this.constraints,\n        frictionEquationPool = World_step_frictionEquationPool,\n        gnorm = gravity.norm(),\n        gx = gravity.x,\n        gy = gravity.y,\n        gz = gravity.z,\n        i=0;\n\n    if(doProfiling){\n        profilingStart = performance.now();\n    }\n\n    // Add gravity to all objects\n    for(i=0; i!==N; i++){\n        var bi = bodies[i];\n        if(bi.type & DYNAMIC){ // Only for dynamic bodies\n            var f = bi.force, m = bi.mass;\n            f.x += m*gx;\n            f.y += m*gy;\n            f.z += m*gz;\n        }\n    }\n\n    // Update subsystems\n    for(var i=0, Nsubsystems=this.subsystems.length; i!==Nsubsystems; i++){\n        this.subsystems[i].update();\n    }\n\n    // Collision detection\n    if(doProfiling){ profilingStart = performance.now(); }\n    p1.length = 0; // Clean up pair arrays from last step\n    p2.length = 0;\n    this.broadphase.collisionPairs(this,p1,p2);\n    if(doProfiling){ profile.broadphase = performance.now() - profilingStart; }\n\n    // Remove constrained pairs with collideConnected == false\n    var Nconstraints = constraints.length;\n    for(i=0; i!==Nconstraints; i++){\n        var c = constraints[i];\n        if(!c.collideConnected){\n            for(var j = p1.length-1; j>=0; j-=1){\n                if( (c.bodyA === p1[j] && c.bodyB === p2[j]) ||\n                    (c.bodyB === p1[j] && c.bodyA === p2[j])){\n                    p1.splice(j, 1);\n                    p2.splice(j, 1);\n                }\n            }\n        }\n    }\n\n    this.collisionMatrixTick();\n\n    // Generate contacts\n    if(doProfiling){ profilingStart = performance.now(); }\n    var oldcontacts = World_step_oldContacts;\n    var NoldContacts = contacts.length;\n\n    for(i=0; i!==NoldContacts; i++){\n        oldcontacts.push(contacts[i]);\n    }\n    contacts.length = 0;\n\n    this.narrowphase.getContacts(p1,p2,\n                                this,\n                                contacts,\n                                oldcontacts // To be reused\n                                );\n    if(doProfiling){\n        profile.narrowphase = performance.now() - profilingStart;\n    }\n\n    // Loop over all collisions\n    if(doProfiling){\n        profilingStart = performance.now();\n    }\n    var ncontacts = contacts.length;\n\n    // Transfer FrictionEquation from current list to the pool for reuse\n    var NoldFrictionEquations = this.frictionEquations.length;\n    for(i=0; i!==NoldFrictionEquations; i++){\n        frictionEquationPool.push(this.frictionEquations[i]);\n    }\n    this.frictionEquations.length = 0;\n\n    for(var k=0; k!==ncontacts; k++){\n\n        // Current contact\n        var c = contacts[k];\n\n        // Get current collision indeces\n        var bi = c.bi,\n            bj = c.bj,\n            si = c.si,\n            sj = c.sj;\n\n        // Resolve indices\n        var i = bodies.indexOf(bi), j = bodies.indexOf(bj);\n\n        // Get collision properties\n        var cm;\n        if(bi.material && bj.material){\n            cm = this.getContactMaterial(bi.material,bj.material) || this.defaultContactMaterial;\n        } else {\n            cm = this.defaultContactMaterial;\n        }\n        var mu = cm.friction;\n\n        // g = ( xj + rj - xi - ri ) .dot ( ni )\n        var gvec = World_step_gvec;\n        gvec.set(bj.position.x + c.rj.x - bi.position.x - c.ri.x,\n                 bj.position.y + c.rj.y - bi.position.y - c.ri.y,\n                 bj.position.z + c.rj.z - bi.position.z - c.ri.z);\n        var g = gvec.dot(c.ni); // Gap, negative if penetration\n\n        // Action if penetration\n        if(g < 0.0){\n\n            c.enabled = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;\n\n\t\t\tc.restitution = cm.restitution;\n\t\t\tc.penetration = g;\n\t\t\tc.setSpookParams(cm.contactEquationStiffness,\n                             cm.contactEquationRelaxation,\n                             dt);\n\n\t\t\tsolver.addEquation(c);\n\n\t\t\t// Add friction constraint equation\n\t\t\tif(mu > 0){\n\n\t\t\t\t// Create 2 tangent equations\n\t\t\t\tvar mug = mu*gnorm;\n\t\t\t\tvar reducedMass = (bi.invMass + bj.invMass);\n\t\t\t\tif(reducedMass > 0){\n\t\t\t\t\treducedMass = 1/reducedMass;\n\t\t\t\t}\n\t\t\t\tvar pool = frictionEquationPool;\n\t\t\t\tvar c1 = pool.length ? pool.pop() : new FrictionEquation(bi,bj,mug*reducedMass);\n\t\t\t\tvar c2 = pool.length ? pool.pop() : new FrictionEquation(bi,bj,mug*reducedMass);\n\t\t\t\tthis.frictionEquations.push(c1);\n\t\t\t\tthis.frictionEquations.push(c2);\n\n\t\t\t\tc1.bi = c2.bi = bi;\n\t\t\t\tc1.bj = c2.bj = bj;\n\t\t\t\tc1.minForce = c2.minForce = -mug*reducedMass;\n\t\t\t\tc1.maxForce = c2.maxForce = mug*reducedMass;\n\n\t\t\t\t// Copy over the relative vectors\n\t\t\t\tc1.ri.copy(c.ri);\n\t\t\t\tc1.rj.copy(c.rj);\n\t\t\t\tc2.ri.copy(c.ri);\n\t\t\t\tc2.rj.copy(c.rj);\n\n\t\t\t\t// Construct tangents\n\t\t\t\tc.ni.tangents(c1.t, c2.t);\n\n                // Set spook params\n                c1.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, dt);\n                c2.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, dt);\n\n                c1.enabled = c2.enabled = c.enabled;\n\n\t\t\t\t// Add equations to solver\n\t\t\t\tsolver.addEquation(c1);\n\t\t\t\tsolver.addEquation(c2);\n\t\t\t}\n\n            if( bi.allowSleep &&\n                bi.type === Body.DYNAMIC &&\n                bi.sleepState  === Body.SLEEPING &&\n                bj.sleepState  === Body.AWAKE &&\n                bj.type !== Body.STATIC\n            ){\n                var speedSquaredB = bj.velocity.norm2() + bj.angularVelocity.norm2();\n                var speedLimitSquaredB = Math.pow(bj.sleepSpeedLimit,2);\n                if(speedSquaredB >= speedLimitSquaredB*2){\n                    bi._wakeUpAfterNarrowphase = true;\n                }\n            }\n\n            if( bj.allowSleep &&\n                bj.type === Body.DYNAMIC &&\n                bj.sleepState  === Body.SLEEPING &&\n                bi.sleepState  === Body.AWAKE &&\n                bi.type !== Body.STATIC\n            ){\n                var speedSquaredA = bi.velocity.norm2() + bi.angularVelocity.norm2();\n                var speedLimitSquaredA = Math.pow(bi.sleepSpeedLimit,2);\n                if(speedSquaredA >= speedLimitSquaredA*2){\n                    bj._wakeUpAfterNarrowphase = true;\n                }\n            }\n\n            // Now we know that i and j are in contact. Set collision matrix state\n\t\t\tthis.collisionMatrix.set(bi, bj, true);\n\n            if (this.collisionMatrix.get(bi, bj) !== this.collisionMatrixPrevious.get(bi, bj)) {\n                // First contact!\n                // We reuse the collideEvent object, otherwise we will end up creating new objects for each new contact, even if there's no event listener attached.\n                World_step_collideEvent.body = bj;\n                World_step_collideEvent.contact = c;\n                bi.dispatchEvent(World_step_collideEvent);\n\n                World_step_collideEvent.body = bi;\n                bj.dispatchEvent(World_step_collideEvent);\n\n                /*\n                bi.wakeUp();\n                bj.wakeUp();\n                */\n            }\n        }\n    }\n    if(doProfiling){\n        profile.makeContactConstraints = performance.now() - profilingStart;\n        profilingStart = performance.now();\n    }\n\n    // Wake up bodies\n    for(i=0; i!==N; i++){\n        var bi = bodies[i];\n        if(bi._wakeUpAfterNarrowphase){\n            bi.wakeUp();\n            bi._wakeUpAfterNarrowphase = false;\n        }\n    }\n\n    // Add user-added constraints\n    var Nconstraints = constraints.length;\n    for(i=0; i!==Nconstraints; i++){\n        var c = constraints[i];\n        c.update();\n        for(var j=0, Neq=c.equations.length; j!==Neq; j++){\n            var eq = c.equations[j];\n            solver.addEquation(eq);\n        }\n    }\n\n    // Solve the constrained system\n    solver.solve(dt,this);\n\n    if(doProfiling){\n        profile.solve = performance.now() - profilingStart;\n    }\n\n    // Remove all contacts from solver\n    solver.removeAllEquations();\n\n    // Apply damping, see http://code.google.com/p/bullet/issues/detail?id=74 for details\n    var pow = Math.pow;\n    for(i=0; i!==N; i++){\n        var bi = bodies[i];\n        if(bi.type & DYNAMIC){ // Only for dynamic bodies\n            var ld = pow(1.0 - bi.linearDamping,dt);\n            var v = bi.velocity;\n            v.mult(ld,v);\n            var av = bi.angularVelocity;\n            if(av){\n                var ad = pow(1.0 - bi.angularDamping,dt);\n                av.mult(ad,av);\n            }\n        }\n    }\n\n    this.dispatchEvent(World_step_preStepEvent);\n\n    // Invoke pre-step callbacks\n    for(i=0; i!==N; i++){\n        var bi = bodies[i];\n        if(bi.preStep){\n            bi.preStep.call(bi);\n        }\n    }\n\n    // Leap frog\n    // vnew = v + h*f/m\n    // xnew = x + h*vnew\n    if(doProfiling){\n        profilingStart = performance.now();\n    }\n    var q = World_step_step_q;\n    var w = World_step_step_w;\n    var wq = World_step_step_wq;\n    var stepnumber = this.stepnumber;\n    var DYNAMIC_OR_KINEMATIC = Body.DYNAMIC | Body.KINEMATIC;\n    var quatNormalize = stepnumber % (this.quatNormalizeSkip+1) === 0;\n    var quatNormalizeFast = this.quatNormalizeFast;\n    var half_dt = dt * 0.5;\n    var PLANE = Shape.types.PLANE,\n        CONVEX = Shape.types.CONVEXPOLYHEDRON;\n\n    for(i=0; i!==N; i++){\n        var b = bodies[i],\n            s = b.shape,\n            force = b.force,\n            tau = b.tau;\n        if((b.type & DYNAMIC_OR_KINEMATIC) && b.sleepState !== Body.SLEEPING){ // Only for dynamic\n            var velo = b.velocity,\n                angularVelo = b.angularVelocity,\n                pos = b.position,\n                quat = b.quaternion,\n                invMass = b.invMass,\n                invInertia = b.invInertiaWorld;\n\n            velo.x += force.x * invMass * dt;\n            velo.y += force.y * invMass * dt;\n            velo.z += force.z * invMass * dt;\n\n            if(b.angularVelocity){\n                invInertia.vmult(tau,invI_tau_dt);\n                invI_tau_dt.mult(dt,invI_tau_dt);\n                invI_tau_dt.vadd(angularVelo,angularVelo);\n                //console.log(invI_tau_dt);\n                /*\n                angularVelo.x += tau.x * invInertia.x * dt;\n                angularVelo.y += tau.y * invInertia.y * dt;\n                angularVelo.z += tau.z * invInertia.z * dt;\n                */\n            }\n\n            // Use new velocity  - leap frog\n            pos.x += velo.x * dt;\n            pos.y += velo.y * dt;\n            pos.z += velo.z * dt;\n\n            if(b.angularVelocity){\n                w.set(angularVelo.x, angularVelo.y, angularVelo.z, 0);\n                w.mult(quat,wq);\n                quat.x += half_dt * wq.x;\n                quat.y += half_dt * wq.y;\n                quat.z += half_dt * wq.z;\n                quat.w += half_dt * wq.w;\n                if(quatNormalize){\n                    if(quatNormalizeFast){\n                        quat.normalizeFast();\n                    } else {\n                        quat.normalize();\n                    }\n                }\n            }\n\n            if(b.aabb){\n                b.aabbNeedsUpdate = true;\n            }\n\n            if(s){\n                switch(s.type){\n                case PLANE:\n                    s.worldNormalNeedsUpdate = true;\n                    break;\n                case CONVEX:\n                    s.worldFaceNormalsNeedsUpdate = true;\n                    s.worldVerticesNeedsUpdate = true;\n                    break;\n                }\n            }\n\n            // Update world inertia\n            if(b.updateInertiaWorld){\n                b.updateInertiaWorld();\n            }\n        }\n        b.force.set(0,0,0);\n        if(b.tau){\n            b.tau.set(0,0,0);\n        }\n\n    }\n\n    this.broadphase.dirty = true;\n\n    if(doProfiling){\n        profile.integrate = performance.now() - profilingStart;\n    }\n\n    // Update world time\n    this.time += dt;\n    this.stepnumber += 1;\n\n    this.dispatchEvent(World_step_postStepEvent);\n\n    // Invoke post-step callbacks\n    for(i=0; i!==N; i++){\n        var bi = bodies[i];\n        var postStep = bi.postStep;\n        if(postStep){\n            postStep.call(bi);\n        }\n    }\n\n    // Sleeping update\n    if(this.allowSleep){\n        for(i=0; i!==N; i++){\n            bodies[i].sleepTick(this.time);\n        }\n    }\n};\n\n},{\"../collision/AABB\":3,\"../collision/ArrayCollisionMatrix\":4,\"../collision/NaiveBroadphase\":7,\"../collision/Ray\":9,\"../collision/RaycastResult\":10,\"../equations/ContactEquation\":16,\"../equations/FrictionEquation\":18,\"../material/ContactMaterial\":21,\"../material/Material\":22,\"../math/Quaternion\":25,\"../math/Vec3\":27,\"../objects/Body\":28,\"../shapes/Shape\":40,\"../solver/GSSolver\":42,\"../utils/EventTarget\":45,\"../utils/TupleDictionary\":47,\"../utils/Vec3Pool\":49,\"./Narrowphase\":50}]},{},[2])\n(2)\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/dmillet/Projects/fpt/fpt/~/cannon/build/cannon.js\n ** module id = 9\n ** module chunks = 0 1 2\n **/","\nimport System from '../game/ecs/System';\nimport PiecesComponent from '../game/PiecesComponent';\nimport Terrain from '../game/terrain/Terrain';\nimport Entity from '../game/ecs/Entity';\n\nlet Level = System.createClass({\n\n\tconstructor: function() {\n\t\tlet entity = this.entity = Entity.create();\n\t\tlet pieces = PiecesComponent.create();\n\t\tentity.set('pieces', pieces);\n\t\tthis.terrain = Terrain.create({\n\t\t\tsolver: this.generateSolver\n\t\t});\n\t\tif (this.exported) {\n\t\t\tlet x = new XMLHttpRequest();\n\t\t\tx.open('GET', this.exported, false);\n\t\t\tx.send();\n\t\t\tthis.import(JSON.parse(x.responseText));\n\t\t}\n\t\tif (this.generate) {\n\t\t\tthis.terrain.generateRange(this.generateRange.low, this.generateRange.high);\n\t\t}\n\t\tpieces.add(this.terrain);\n\t},\n\n\tgenerate: true,\n\n\tgenerateSolver: function(x, y, z) {\n\t\treturn 0;\n\t},\n\n\tgenerateRange: {\n\t\tlow: {\n\t\t\tx: -1,\n\t\t\ty: -1,\n\t\t\tz: -1\n\t\t},\n\t\thigh: {\n\t\t\tx: 1,\n\t\t\ty: 1,\n\t\t\tz: 1\n\t\t}\n\t},\n\n\texported: null,\n\n\texport: function() {\n\t\treturn {\n\t\t\tterrain: this.terrain.export()\n\t\t};\n\t},\n\n\timport: function(exported) {\n\t\tif (!this.generate) {\n\t\t\tthis.terrain.import(exported.terrain);\n\t\t}\n\t},\n\n\tonLoaded: function(callback) {\n\t\tsetTimeout(callback, 3000);\n\t}\n\n});\n\nLevel.createClass = function(props) {\n\tfunction Klass() {\n\t\tLevel.call(this);\n\t\tprops.constructor.apply(this,arguments);\n\t};\n\tKlass.prototype = props;\n\tprops.__proto__ = Level.prototype;\n\treturn Klass;\n};\n\nexport default Level;\n\n\n\n/** WEBPACK FOOTER **\n ** ../levels/Level.js\n **/","\nimport EntityCollection from './ecs/EntityCollection';\n\nlet PiecesCollection = EntityCollection;\n\nexport default PiecesCollection;\n\n\n\n/** WEBPACK FOOTER **\n ** ../game/PiecesComponent.js\n **/","\nimport Entity from '../ecs/Entity';\nimport voxel from 'voxel';\nimport TerrainPhysics from './TerrainPhysics';\nimport PiecesComponent from '../PiecesComponent';\n\nlet Terrain = Entity.createClass({\n\n\tconstructor: function(options) {\n\n\t\tthis.set(\n\t\t\t'voxels',\n\t\t\tvoxel({\n\t\t\t\tgenerateVoxelChunk: function(low, high) {\n\t\t\t\t\treturn voxel.generate(low, high, options.solver);\n\t\t\t\t}.bind(this),\n\t\t\t\tcubeSize: 1\n\t\t\t})\n\t\t);\n\n\t\tthis.set(\n\t\t\t'pieces',\n\t\t\tPiecesComponent.create()\n\t\t);\n\n\t},\n\n\tgenerateRange: function(low, high) {\n\t\tlet voxels = this.get('voxels');\n\t\tlet chunkLow = voxels.chunkAtCoordinates(low.x, low.y, low.z);\n\t\tlet chunkHigh = voxels.chunkAtCoordinates(high.x, high.y, high.z);\n\t\tthis.generateChunkBlock(\n\t\t\t{\n\t\t\t\tx: chunkLow[0],\n\t\t\t\ty: chunkLow[1],\n\t\t\t\tz: chunkLow[2]\n\t\t\t},\n\t\t\t{\n\t\t\t\tx: chunkHigh[0],\n\t\t\t\ty: chunkHigh[1],\n\t\t\t\tz: chunkHigh[2]\n\t\t\t}\n\t\t);\n\n\t},\n\n\tgenerateChunkBlock: function(low, high) {\n\t\tlet voxels = this.get('voxels');\n\t\tfor (let x = low.x; x <= high.x; x++) {\n\t\t\tfor (let y = low.y; y <= high.y; y++) {\n\t\t\t\tfor (let z = low.z; z <= high.z; z++) {\n\t\t\t\t\tvoxels.generateChunk(x, y, z);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.set(\n\t\t\t'terrain-physics',\n\t\t\tTerrainPhysics.create(this)\n\t\t);\n\t},\n\n\tgetBlockAt: function(pos) {\n\t\tpos = this._parseVectorArguments(arguments);\n\t\treturn this.get('voxels').voxelAtPosition(pos);\n\t},\n\n\texport: function() {\n\t\tlet voxels = this.get('voxels');\n\t\tlet result = {\n\t\t\tchunkSize: voxels.chunkSize,\n\t\t\tchunks: JSON.parse(JSON.stringify(voxels.chunks))\n\t\t};\n\t\t// discard empty chunks\n\t\tfor (let chunkId in result.chunks) {\n\t\t\tlet remove = true;\n\t\t\tfor (let voxelId in result.chunks[chunkId].voxels) {\n\t\t\t\tif (result.chunks[chunkId].voxels[voxelId]) {\n\t\t\t\t\tremove = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (remove) {\n\t\t\t\tdelete result.chunks[chunkId];\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t},\n\n\timport: function(exported) {\n\t\tlet voxels = this.get('voxels');\n\t\tvoxels.chunkSize = exported.chunkSize;\n\t\tvoxels.chunks = exported.chunks;\n\t\tthis.set(\n\t\t\t'terrain-physics',\n\t\t\tTerrainPhysics.create(this)\n\t\t);\n\t},\n\n\t_parseVectorArguments: function(args) {\n\t\tif (!args) return false;\n\t\tif (args[0] instanceof Array) return args[0];\n\t\treturn [args[0], args[1], args[2]];\n\t}\n});\n\nTerrain.create = function(opts) {\n\treturn new Terrain(opts);\n};\n\nexport default Terrain;\n\n\n/** WEBPACK FOOTER **\n ** ../game/terrain/Terrain.js\n **/","\nclass Entity {\n\t\n\tstatic createClass(props) {\n\t\tfunction Klass() {\n\t\t\tEntity.call(this);\n\t\t\tprops.constructor.apply(this,arguments);\n\t\t};\n\t\tKlass.prototype = props;\n\t\tprops.__proto__ = Entity.prototype;\n\t\treturn Klass;\n\t}\n\n\tstatic create() {\n\t\treturn new Entity();\n\t}\n\n\tconstructor() {\n\t\tthis.components = {};\n\t}\n\n\tset(name, value) {\n\t\tthis.components[name] = value;\n\t}\n\n\tget(name) {\n\t\treturn this.components[name];\n\t}\n\n}\n\nexport default Entity;\n\n\n\n/** WEBPACK FOOTER **\n ** ../game/ecs/Entity.js\n **/","var chunker = require('./chunker')\n\nmodule.exports = function(opts) {\n  if (!opts.generateVoxelChunk) opts.generateVoxelChunk = function(low, high) {\n    return generate(low, high, module.exports.generator['Valley'])\n  }\n  return chunker(opts)\n}\n\nmodule.exports.meshers = {\n  culled: require('./meshers/culled').mesher,\n  greedy: require('./meshers/greedy').mesher,\n  transgreedy: require('./meshers/transgreedy').mesher,\n  monotone: require('./meshers/monotone').mesher,\n  stupid: require('./meshers/stupid').mesher\n}\n\nmodule.exports.Chunker = chunker.Chunker\nmodule.exports.geometry = {}\nmodule.exports.generator = {}\nmodule.exports.generate = generate\n\n// from https://github.com/mikolalysenko/mikolalysenko.github.com/blob/master/MinecraftMeshes2/js/testdata.js#L4\nfunction generate(l, h, f, game) {\n  var d = [ h[0]-l[0], h[1]-l[1], h[2]-l[2] ]\n  var v = new Int8Array(d[0]*d[1]*d[2])\n  var n = 0\n  for(var k=l[2]; k<h[2]; ++k)\n  for(var j=l[1]; j<h[1]; ++j)\n  for(var i=l[0]; i<h[0]; ++i, ++n) {\n    v[n] = f(i,j,k,n,game)\n  }\n  return {voxels:v, dims:d}\n}\n\n// shape and terrain generator functions\nmodule.exports.generator['Sphere'] = function(i,j,k) {\n  return i*i+j*j+k*k <= 16*16 ? 1 : 0\n}\n\nmodule.exports.generator['Noise'] = function(i,j,k) {\n  return Math.random() < 0.1 ? Math.random() * 0xffffff : 0;\n}\n\nmodule.exports.generator['Dense Noise'] = function(i,j,k) {\n  return Math.round(Math.random() * 0xffffff);\n}\n\nmodule.exports.generator['Checker'] = function(i,j,k) {\n  return !!((i+j+k)&1) ? (((i^j^k)&2) ? 1 : 0xffffff) : 0;\n}\n\nmodule.exports.generator['Hill'] = function(i,j,k) {\n  return j <= 16 * Math.exp(-(i*i + k*k) / 64) ? 1 : 0;\n}\n\nmodule.exports.generator['Valley'] = function(i,j,k) {\n  return j <= (i*i + k*k) * 31 / (32*32*2) + 1 ? 1 : 0;\n}\n\nmodule.exports.generator['Hilly Terrain'] = function(i,j,k) {\n  var h0 = 3.0 * Math.sin(Math.PI * i / 12.0 - Math.PI * k * 0.1) + 27;    \n  if(j > h0+1) {\n    return 0;\n  }\n  if(h0 <= j) {\n    return 1;\n  }\n  var h1 = 2.0 * Math.sin(Math.PI * i * 0.25 - Math.PI * k * 0.3) + 20;\n  if(h1 <= j) {\n    return 2;\n  }\n  if(2 < j) {\n    return Math.random() < 0.1 ? 0x222222 : 0xaaaaaa;\n  }\n  return 3;\n}\n\nmodule.exports.scale = function ( x, fromLow, fromHigh, toLow, toHigh ) {\n  return ( x - fromLow ) * ( toHigh - toLow ) / ( fromHigh - fromLow ) + toLow\n}\n\n// convenience function that uses the above functions to prebake some simple voxel geometries\nmodule.exports.generateExamples = function() {\n  return {\n    'Sphere': generate([-16,-16,-16], [16,16,16], module.exports.generator['Sphere']),\n    'Noise': generate([0,0,0], [16,16,16], module.exports.generator['Noise']),\n    'Dense Noise': generate([0,0,0], [16,16,16], module.exports.generator['Dense Noise']),\n    'Checker': generate([0,0,0], [8,8,8], module.exports.generator['Checker']),\n    'Hill': generate([-16, 0, -16], [16,16,16], module.exports.generator['Hill']),\n    'Valley': generate([0,0,0], [32,32,32], module.exports.generator['Valley']),\n    'Hilly Terrain': generate([0, 0, 0], [32,32,32], module.exports.generator['Hilly Terrain'])\n  }\n}\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/dmillet/Projects/fpt/fpt/~/voxel/index.js\n ** module id = 14\n ** module chunks = 0 1 2\n **/","var events = require('events')\nvar inherits = require('inherits')\n\nmodule.exports = function(opts) {\n  return new Chunker(opts)\n}\n\nmodule.exports.Chunker = Chunker\n\nfunction Chunker(opts) {\n  this.distance = opts.chunkDistance || 2\n  this.chunkSize = opts.chunkSize || 32\n  this.cubeSize = opts.cubeSize || 25\n  this.generateVoxelChunk = opts.generateVoxelChunk\n  this.chunks = {}\n  this.meshes = {}\n\n  if (this.chunkSize & this.chunkSize-1 !== 0)\n    throw new Error('chunkSize must be a power of 2')\n  var bits = 0;\n  for (var size = this.chunkSize; size > 0; size >>= 1) bits++;\n  this.chunkBits = bits - 1;\n}\n\ninherits(Chunker, events.EventEmitter)\n\nChunker.prototype.nearbyChunks = function(position, distance) {\n  var current = this.chunkAtPosition(position)\n  var x = current[0]\n  var y = current[1]\n  var z = current[2]\n  var dist = distance || this.distance\n  var nearby = []\n  for (var cx = (x - dist); cx !== (x + dist); ++cx) {\n    for (var cy = (y - dist); cy !== (y + dist); ++cy) {\n      for (var cz = (z - dist); cz !== (z + dist); ++cz) {\n        nearby.push([cx, cy, cz])\n      }\n    }\n  }\n  return nearby\n}\n\nChunker.prototype.requestMissingChunks = function(position) {\n  var self = this\n  this.nearbyChunks(position).map(function(chunk) {\n    if (!self.chunks[chunk.join('|')]) {\n      self.emit('missingChunk', chunk)\n    }\n  })\n}\n\nChunker.prototype.getBounds = function(x, y, z) {\n  var bits = this.chunkBits\n  var low = [x << bits, y << bits, z << bits]\n  var high = [(x+1) << bits, (y+1) << bits, (z+1) << bits]\n  return [low, high]\n}\n\nChunker.prototype.generateChunk = function(x, y, z) {\n  var self = this\n  var bounds = this.getBounds(x, y, z)\n  var chunk = this.generateVoxelChunk(bounds[0], bounds[1], x, y, z)\n  var position = [x, y, z]\n  chunk.position = position\n  this.chunks[position.join('|')] = chunk\n  return chunk\n}\n\nChunker.prototype.chunkAtCoordinates = function(x, y, z) {\n  var bits = this.chunkBits;\n  var cx = x >> bits;\n  var cy = y >> bits;\n  var cz = z >> bits;\n  var chunkPos = [cx, cy, cz];\n  return chunkPos;\n}\n\nChunker.prototype.chunkAtPosition = function(position) {\n  var cubeSize = this.cubeSize;\n  var x = Math.floor(position[0] / cubeSize)\n  var y = Math.floor(position[1] / cubeSize)\n  var z = Math.floor(position[2] / cubeSize)\n  var chunkPos = this.chunkAtCoordinates(x, y, z)\n  return chunkPos\n};\n\nChunker.prototype.voxelIndexFromCoordinates = function(x, y, z) {\n  var bits = this.chunkBits\n  var mask = (1 << bits) - 1\n  var vidx = (x & mask) + ((y & mask) << bits) + ((z & mask) << bits * 2)\n  return vidx\n}\n\nChunker.prototype.voxelIndexFromPosition = function(pos) {\n  var v = this.voxelVector(pos)\n  return this.voxelIndex(v)\n}\n\nChunker.prototype.voxelAtCoordinates = function(x, y, z, val) {\n  var ckey = this.chunkAtCoordinates(x, y, z).join('|')\n  var chunk = this.chunks[ckey]\n  if (!chunk) return false\n  var vidx = this.voxelIndexFromCoordinates(x, y, z)\n  var v = chunk.voxels[vidx]\n  if (typeof val !== 'undefined') {\n    chunk.voxels[vidx] = val\n  }\n  return v\n}\n\nChunker.prototype.voxelAtPosition = function(pos, val) {\n  var cubeSize = this.cubeSize;\n  var x = Math.floor(pos[0] / cubeSize)\n  var y = Math.floor(pos[1] / cubeSize)\n  var z = Math.floor(pos[2] / cubeSize)\n  var v = this.voxelAtCoordinates(x, y, z, val)\n  return v;\n}\n\n// deprecated\nChunker.prototype.voxelIndex = function(voxelVector) {\n  var vidx = this.voxelIndexFromCoordinates(voxelVector[0], voxelVector[1], voxelVector[2])\n  return vidx\n}\n\n// deprecated\nChunker.prototype.voxelVector = function(pos) {\n  var cubeSize = this.cubeSize\n  var mask = (1 << this.chunkBits) - 1\n  var vx = (Math.floor(pos[0] / cubeSize)) & mask\n  var vy = (Math.floor(pos[1] / cubeSize)) & mask\n  var vz = (Math.floor(pos[2] / cubeSize)) & mask\n  return [vx, vy, vz]\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/dmillet/Projects/fpt/fpt/~/voxel/chunker.js\n ** module id = 15\n ** module chunks = 0 1 2\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      }\n      throw TypeError('Uncaught, unspecified \"error\" event.');\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/events/events.js\n ** module id = 16\n ** module chunks = 0 1 2\n **/","module.exports = inherits\n\nfunction inherits (c, p, proto) {\n  proto = proto || {}\n  var e = {}\n  ;[c.prototype, proto].forEach(function (s) {\n    Object.getOwnPropertyNames(s).forEach(function (k) {\n      e[k] = Object.getOwnPropertyDescriptor(s, k)\n    })\n  })\n  c.prototype = Object.create(p.prototype, e)\n  c.super = p\n}\n\n//function Child () {\n//  Child.super.call(this)\n//  console.error([this\n//                ,this.constructor\n//                ,this.constructor === Child\n//                ,this.constructor.super === Parent\n//                ,Object.getPrototypeOf(this) === Child.prototype\n//                ,Object.getPrototypeOf(Object.getPrototypeOf(this))\n//                 === Parent.prototype\n//                ,this instanceof Child\n//                ,this instanceof Parent])\n//}\n//function Parent () {}\n//inherits(Child, Parent)\n//new Child\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/dmillet/Projects/fpt/fpt/~/voxel/~/inherits/inherits.js\n ** module id = 17\n ** module chunks = 0 1 2\n **/","//Naive meshing (with face culling)\nfunction CulledMesh(volume, dims) {\n  //Precalculate direction vectors for convenience\n  var dir = new Array(3);\n  for(var i=0; i<3; ++i) {\n    dir[i] = [[0,0,0], [0,0,0]];\n    dir[i][0][(i+1)%3] = 1;\n    dir[i][1][(i+2)%3] = 1;\n  }\n  //March over the volume\n  var vertices = []\n    , faces = []\n    , x = [0,0,0]\n    , B = [[false,true]    //Incrementally update bounds (this is a bit ugly)\n          ,[false,true]\n          ,[false,true]]\n    , n = -dims[0]*dims[1];\n  for(           B[2]=[false,true],x[2]=-1; x[2]<dims[2]; B[2]=[true,(++x[2]<dims[2]-1)])\n  for(n-=dims[0],B[1]=[false,true],x[1]=-1; x[1]<dims[1]; B[1]=[true,(++x[1]<dims[1]-1)])\n  for(n-=1,      B[0]=[false,true],x[0]=-1; x[0]<dims[0]; B[0]=[true,(++x[0]<dims[0]-1)], ++n) {\n    //Read current voxel and 3 neighboring voxels using bounds check results\n    var p =   (B[0][0] && B[1][0] && B[2][0]) ? volume[n]                 : 0\n      , b = [ (B[0][1] && B[1][0] && B[2][0]) ? volume[n+1]               : 0\n            , (B[0][0] && B[1][1] && B[2][0]) ? volume[n+dims[0]]         : 0\n            , (B[0][0] && B[1][0] && B[2][1]) ? volume[n+dims[0]*dims[1]] : 0\n          ];\n    //Generate faces\n    for(var d=0; d<3; ++d)\n    if((!!p) !== (!!b[d])) {\n      var s = !p ? 1 : 0;\n      var t = [x[0],x[1],x[2]]\n        , u = dir[d][s]\n        , v = dir[d][s^1];\n      ++t[d];\n      \n      var vertex_count = vertices.length;\n      vertices.push([t[0],           t[1],           t[2]          ]);\n      vertices.push([t[0]+u[0],      t[1]+u[1],      t[2]+u[2]     ]);\n      vertices.push([t[0]+u[0]+v[0], t[1]+u[1]+v[1], t[2]+u[2]+v[2]]);\n      vertices.push([t[0]     +v[0], t[1]     +v[1], t[2]     +v[2]]);\n      faces.push([vertex_count, vertex_count+1, vertex_count+2, vertex_count+3, s ? b[d] : p]);\n    }\n  }\n  return { vertices:vertices, faces:faces };\n}\n\n\nif(exports) {\n  exports.mesher = CulledMesh;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/dmillet/Projects/fpt/fpt/~/voxel/meshers/culled.js\n ** module id = 18\n ** module chunks = 0 1 2\n **/","var GreedyMesh = (function() {\n//Cache buffer internally\nvar mask = new Int32Array(4096);\n\nreturn function(volume, dims) {\n  var vertices = [], faces = []\n    , dimsX = dims[0]\n    , dimsY = dims[1]\n    , dimsXY = dimsX * dimsY;\n\n  //Sweep over 3-axes\n  for(var d=0; d<3; ++d) {\n    var i, j, k, l, w, W, h, n, c\n      , u = (d+1)%3\n      , v = (d+2)%3\n      , x = [0,0,0]\n      , q = [0,0,0]\n      , du = [0,0,0]\n      , dv = [0,0,0]\n      , dimsD = dims[d]\n      , dimsU = dims[u]\n      , dimsV = dims[v]\n      , qdimsX, qdimsXY\n      , xd\n\n    if (mask.length < dimsU * dimsV) {\n      mask = new Int32Array(dimsU * dimsV);\n    }\n\n    q[d] =  1;\n    x[d] = -1;\n\n    qdimsX  = dimsX  * q[1]\n    qdimsXY = dimsXY * q[2]\n\n    // Compute mask\n    while (x[d] < dimsD) {\n      xd = x[d]\n      n = 0;\n\n      for(x[v] = 0; x[v] < dimsV; ++x[v]) {\n        for(x[u] = 0; x[u] < dimsU; ++x[u], ++n) {\n          var a = xd >= 0      && volume[x[0]      + dimsX * x[1]          + dimsXY * x[2]          ]\n            , b = xd < dimsD-1 && volume[x[0]+q[0] + dimsX * x[1] + qdimsX + dimsXY * x[2] + qdimsXY]\n          if (a ? b : !b) {\n            mask[n] = 0; continue;\n          }\n          mask[n] = a ? a : -b;\n        }\n      }\n\n      ++x[d];\n\n      // Generate mesh for mask using lexicographic ordering\n      n = 0;\n      for (j=0; j < dimsV; ++j) {\n        for (i=0; i < dimsU; ) {\n          c = mask[n];\n          if (!c) {\n            i++;  n++; continue;\n          }\n\n          //Compute width\n          w = 1;\n          while (c === mask[n+w] && i+w < dimsU) w++;\n\n          //Compute height (this is slightly awkward)\n          for (h=1; j+h < dimsV; ++h) {\n            k = 0;\n            while (k < w && c === mask[n+k+h*dimsU]) k++\n            if (k < w) break;\n          }\n\n          // Add quad\n          // The du/dv arrays are reused/reset\n          // for each iteration.\n          du[d] = 0; dv[d] = 0;\n          x[u]  = i;  x[v] = j;\n\n          if (c > 0) {\n            dv[v] = h; dv[u] = 0;\n            du[u] = w; du[v] = 0;\n          } else {\n            c = -c;\n            du[v] = h; du[u] = 0;\n            dv[u] = w; dv[v] = 0;\n          }\n          var vertex_count = vertices.length;\n          vertices.push([x[0],             x[1],             x[2]            ]);\n          vertices.push([x[0]+du[0],       x[1]+du[1],       x[2]+du[2]      ]);\n          vertices.push([x[0]+du[0]+dv[0], x[1]+du[1]+dv[1], x[2]+du[2]+dv[2]]);\n          vertices.push([x[0]      +dv[0], x[1]      +dv[1], x[2]      +dv[2]]);\n          faces.push([vertex_count, vertex_count+1, vertex_count+2, vertex_count+3, c]);\n\n          //Zero-out mask\n          W = n + w;\n          for(l=0; l<h; ++l) {\n            for(k=n; k<W; ++k) {\n              mask[k+l*dimsU] = 0;\n            }\n          }\n\n          //Increment counters and continue\n          i += w; n += w;\n        }\n      }\n    }\n  }\n  return { vertices:vertices, faces:faces };\n}\n})();\n\nif(exports) {\n  exports.mesher = GreedyMesh;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/dmillet/Projects/fpt/fpt/~/voxel/meshers/greedy.js\n ** module id = 19\n ** module chunks = 0 1 2\n **/","var GreedyMesh = (function greedyLoader() {\n    \n// contains all forward faces (in terms of scan direction)\nvar mask = new Int32Array(4096);\n// and all backwards faces. needed when there are two transparent blocks\n// next to each other.\nvar invMask = new Int32Array(4096);\n\n// setting 16th bit if transparent\nvar kTransparentMask    = 0x8000;\nvar kNoFlagsMask        = 0x7FFF;\nvar kTransparentTypes   = [];\n\nkTransparentTypes[16] = true\n\nfunction isTransparent(v) {\n  return (v & kTransparentMask) === kTransparentMask;\n}\n\nfunction removeFlags(v) {\n  return (v & kNoFlagsMask);\n}\n\nreturn function ohSoGreedyMesher(volume, dims, mesherExtraData) {\n  var vertices = [], faces = []\n    , dimsX = dims[0]\n    , dimsY = dims[1]\n    , dimsXY = dimsX * dimsY;\n\n  var tVertices = [], tFaces = []\n\n  var transparentTypes = mesherExtraData ? (mesherExtraData.transparentTypes || {}) : {};\n  var getType = function(voxels, offset) {\n    var type = voxels[offset];\n    return type | (type in transparentTypes ? kTransparentMask : 0);\n  }\n\n\n  //Sweep over 3-axes\n  for(var d=0; d<3; ++d) {\n    var i, j, k, l, w, W, h, n, c\n      , u = (d+1)%3\n      , v = (d+2)%3\n      , x = [0,0,0]\n      , q = [0,0,0]\n      , du = [0,0,0]\n      , dv = [0,0,0]\n      , dimsD = dims[d]\n      , dimsU = dims[u]\n      , dimsV = dims[v]\n      , qdimsX, qdimsXY\n      , xd\n\n    if (mask.length < dimsU * dimsV) {\n      mask = new Int32Array(dimsU * dimsV);\n      invMask = new Int32Array(dimsU * dimsV);\n    }\n\n    q[d] =  1;\n    x[d] = -1;\n\n    qdimsX  = dimsX  * q[1]\n    qdimsXY = dimsXY * q[2]\n\n    // Compute mask\n    while (x[d] < dimsD) {\n      xd = x[d]\n      n = 0;\n\n      for(x[v] = 0; x[v] < dimsV; ++x[v]) {\n        for(x[u] = 0; x[u] < dimsU; ++x[u], ++n) {\n          // Modified to read through getType()\n          var a = xd >= 0      && getType(volume, x[0]      + dimsX * x[1]          + dimsXY * x[2]          )\n            , b = xd < dimsD-1 && getType(volume, x[0]+q[0] + dimsX * x[1] + qdimsX + dimsXY * x[2] + qdimsXY)\n\n          // both are transparent, add to both directions\n          if (isTransparent(a) && isTransparent(b)) {\n            mask[n] = a;\n            invMask[n] = b;\n          // if a is solid and b is not there or transparent\n          } else if (a && (!b || isTransparent(b))) {\n            mask[n] = a;\n            invMask[n] = 0\n          // if b is solid and a is not there or transparent\n          } else if (b && (!a || isTransparent(a))) {\n            mask[n] = 0\n            invMask[n] = b;\n          // dont draw this face\n          } else {\n            mask[n] = 0\n            invMask[n] = 0\n          }\n        }\n      }\n\n      ++x[d];\n\n      // Generate mesh for mask using lexicographic ordering\n      function generateMesh(mask, dimsV, dimsU, vertices, faces, clockwise) {\n        clockwise = clockwise === undefined ? true : clockwise;\n        var n, j, i, c, w, h, k, du = [0,0,0], dv = [0,0,0];\n        n = 0;\n        for (j=0; j < dimsV; ++j) {\n          for (i=0; i < dimsU; ) {\n            c = mask[n];\n            if (!c) {\n              i++;  n++; continue;\n            }\n\n            //Compute width\n            w = 1;\n            while (c === mask[n+w] && i+w < dimsU) w++;\n\n            //Compute height (this is slightly awkward)\n            for (h=1; j+h < dimsV; ++h) {\n              k = 0;\n              while (k < w && c === mask[n+k+h*dimsU]) k++\n              if (k < w) break;\n            }\n\n            // Add quad\n            // The du/dv arrays are reused/reset\n            // for each iteration.\n            du[d] = 0; dv[d] = 0;\n            x[u]  = i;  x[v] = j;\n\n            if (clockwise) {\n            // if (c > 0) {\n              dv[v] = h; dv[u] = 0;\n              du[u] = w; du[v] = 0;\n            } else {\n              // c = -c;\n              du[v] = h; du[u] = 0;\n              dv[u] = w; dv[v] = 0;\n            }\n            \n            // ## enable code to ensure that transparent faces are last in the list\n            // if (!isTransparent(c)) {\n              var vertex_count = vertices.length;\n              vertices.push([x[0],             x[1],             x[2]            ]);\n              vertices.push([x[0]+du[0],       x[1]+du[1],       x[2]+du[2]      ]);\n              vertices.push([x[0]+du[0]+dv[0], x[1]+du[1]+dv[1], x[2]+du[2]+dv[2]]);\n              vertices.push([x[0]      +dv[0], x[1]      +dv[1], x[2]      +dv[2]]);\n              faces.push([vertex_count, vertex_count+1, vertex_count+2, vertex_count+3, removeFlags(c)]);\n            // } else {\n            //   var vertex_count = tVertices.length;\n            //   tVertices.push([x[0],             x[1],             x[2]            ]);\n            //   tVertices.push([x[0]+du[0],       x[1]+du[1],       x[2]+du[2]      ]);\n            //   tVertices.push([x[0]+du[0]+dv[0], x[1]+du[1]+dv[1], x[2]+du[2]+dv[2]]);\n            //   tVertices.push([x[0]      +dv[0], x[1]      +dv[1], x[2]      +dv[2]]);\n            //   tFaces.push([vertex_count, vertex_count+1, vertex_count+2, vertex_count+3, removeFlags(c)]);\n            // }\n\n            //Zero-out mask\n            W = n + w;\n            for(l=0; l<h; ++l) {\n              for(k=n; k<W; ++k) {\n                mask[k+l*dimsU] = 0;\n              }\n            }\n\n            //Increment counters and continue\n            i += w; n += w;\n          }\n        }\n      }\n      generateMesh(mask, dimsV, dimsU, vertices, faces, true)\n      generateMesh(invMask, dimsV, dimsU, vertices, faces, false)\n    }\n  }\n  \n  // ## enable code to ensure that transparent faces are last in the list\n  // var vertex_count = vertices.length;\n  // var newFaces = tFaces.map(function(v) {\n  //   return [vertex_count+v[0], vertex_count+v[1], vertex_count+v[2], vertex_count+v[3], v[4]]\n  // })\n  // \n  // return { vertices:vertices.concat(tVertices), faces:faces.concat(newFaces) };\n  \n  // TODO: Try sorting by texture to see if we can reduce draw calls.\n  // faces.sort(function sortFaces(a, b) {\n  //   return b[4] - a[4];\n  // })\n  return { vertices:vertices, faces:faces };\n}\n})();\n\nif(exports) {\n  exports.mesher = GreedyMesh;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/dmillet/Projects/fpt/fpt/~/voxel/meshers/transgreedy.js\n ** module id = 20\n ** module chunks = 0 1 2\n **/","\"use strict\";\n\nvar MonotoneMesh = (function(){\n\nfunction MonotonePolygon(c, v, ul, ur) {\n  this.color  = c;\n  this.left   = [[ul, v]];\n  this.right  = [[ur, v]];\n};\n\nMonotonePolygon.prototype.close_off = function(v) {\n  this.left.push([ this.left[this.left.length-1][0], v ]);\n  this.right.push([ this.right[this.right.length-1][0], v ]);\n};\n\nMonotonePolygon.prototype.merge_run = function(v, u_l, u_r) {\n  var l = this.left[this.left.length-1][0]\n    , r = this.right[this.right.length-1][0]; \n  if(l !== u_l) {\n    this.left.push([ l, v ]);\n    this.left.push([ u_l, v ]);\n  }\n  if(r !== u_r) {\n    this.right.push([ r, v ]);\n    this.right.push([ u_r, v ]);\n  }\n};\n\n\nreturn function(volume, dims) {\n  function f(i,j,k) {\n    return volume[i + dims[0] * (j + dims[1] * k)];\n  }\n  //Sweep over 3-axes\n  var vertices = [], faces = [];\n  for(var d=0; d<3; ++d) {\n    var i, j, k\n      , u = (d+1)%3   //u and v are orthogonal directions to d\n      , v = (d+2)%3\n      , x = new Int32Array(3)\n      , q = new Int32Array(3)\n      , runs = new Int32Array(2 * (dims[u]+1))\n      , frontier = new Int32Array(dims[u])  //Frontier is list of pointers to polygons\n      , next_frontier = new Int32Array(dims[u])\n      , left_index = new Int32Array(2 * dims[v])\n      , right_index = new Int32Array(2 * dims[v])\n      , stack = new Int32Array(24 * dims[v])\n      , delta = [[0,0], [0,0]];\n    //q points along d-direction\n    q[d] = 1;\n    //Initialize sentinel\n    for(x[d]=-1; x[d]<dims[d]; ) {\n      // --- Perform monotone polygon subdivision ---\n      var n = 0\n        , polygons = []\n        , nf = 0;\n      for(x[v]=0; x[v]<dims[v]; ++x[v]) {\n        //Make one pass over the u-scan line of the volume to run-length encode polygon\n        var nr = 0, p = 0, c = 0;\n        for(x[u]=0; x[u]<dims[u]; ++x[u], p = c) {\n          //Compute the type for this face\n          var a = (0    <= x[d]      ? f(x[0],      x[1],      x[2])      : 0)\n            , b = (x[d] <  dims[d]-1 ? f(x[0]+q[0], x[1]+q[1], x[2]+q[2]) : 0);\n          c = a;\n          if((!a) === (!b)) {\n            c = 0;\n          } else if(!a) {\n            c = -b;\n          }\n          //If cell type doesn't match, start a new run\n          if(p !== c) {\n            runs[nr++] = x[u];\n            runs[nr++] = c;\n          }\n        }\n        //Add sentinel run\n        runs[nr++] = dims[u];\n        runs[nr++] = 0;\n        //Update frontier by merging runs\n        var fp = 0;\n        for(var i=0, j=0; i<nf && j<nr-2; ) {\n          var p    = polygons[frontier[i]]\n            , p_l  = p.left[p.left.length-1][0]\n            , p_r  = p.right[p.right.length-1][0]\n            , p_c  = p.color\n            , r_l  = runs[j]    //Start of run\n            , r_r  = runs[j+2]  //End of run\n            , r_c  = runs[j+1]; //Color of run\n          //Check if we can merge run with polygon\n          if(r_r > p_l && p_r > r_l && r_c === p_c) {\n            //Merge run\n            p.merge_run(x[v], r_l, r_r);\n            //Insert polygon into frontier\n            next_frontier[fp++] = frontier[i];\n            ++i;\n            j += 2;\n          } else {\n            //Check if we need to advance the run pointer\n            if(r_r <= p_r) {\n              if(!!r_c) {\n                var n_poly = new MonotonePolygon(r_c, x[v], r_l, r_r);\n                next_frontier[fp++] = polygons.length;\n                polygons.push(n_poly);\n              }\n              j += 2;\n            }\n            //Check if we need to advance the frontier pointer\n            if(p_r <= r_r) {\n              p.close_off(x[v]);\n              ++i;\n            }\n          }\n        }\n        //Close off any residual polygons\n        for(; i<nf; ++i) {\n          polygons[frontier[i]].close_off(x[v]);\n        }\n        //Add any extra runs to frontier\n        for(; j<nr-2; j+=2) {\n          var r_l  = runs[j]\n            , r_r  = runs[j+2]\n            , r_c  = runs[j+1];\n          if(!!r_c) {\n            var n_poly = new MonotonePolygon(r_c, x[v], r_l, r_r);\n            next_frontier[fp++] = polygons.length;\n            polygons.push(n_poly);\n          }\n        }\n        //Swap frontiers\n        var tmp = next_frontier;\n        next_frontier = frontier;\n        frontier = tmp;\n        nf = fp;\n      }\n      //Close off frontier\n      for(var i=0; i<nf; ++i) {\n        var p = polygons[frontier[i]];\n        p.close_off(dims[v]);\n      }\n      // --- Monotone subdivision of polygon is complete at this point ---\n      \n      x[d]++;\n      \n      //Now we just need to triangulate each monotone polygon\n      for(var i=0; i<polygons.length; ++i) {\n        var p = polygons[i]\n          , c = p.color\n          , flipped = false;\n        if(c < 0) {\n          flipped = true;\n          c = -c;\n        }\n        for(var j=0; j<p.left.length; ++j) {\n          left_index[j] = vertices.length;\n          var y = [0.0,0.0,0.0]\n            , z = p.left[j];\n          y[d] = x[d];\n          y[u] = z[0];\n          y[v] = z[1];\n          vertices.push(y);\n        }\n        for(var j=0; j<p.right.length; ++j) {\n          right_index[j] = vertices.length;\n          var y = [0.0,0.0,0.0]\n            , z = p.right[j];\n          y[d] = x[d];\n          y[u] = z[0];\n          y[v] = z[1];\n          vertices.push(y);\n        }\n        //Triangulate the monotone polygon\n        var bottom = 0\n          , top = 0\n          , l_i = 1\n          , r_i = 1\n          , side = true;  //true = right, false = left\n        \n        stack[top++] = left_index[0];\n        stack[top++] = p.left[0][0];\n        stack[top++] = p.left[0][1];\n        \n        stack[top++] = right_index[0];\n        stack[top++] = p.right[0][0];\n        stack[top++] = p.right[0][1];\n        \n        while(l_i < p.left.length || r_i < p.right.length) {\n          //Compute next side\n          var n_side = false;\n          if(l_i === p.left.length) {\n            n_side = true;\n          } else if(r_i !== p.right.length) {\n            var l = p.left[l_i]\n              , r = p.right[r_i];\n            n_side = l[1] > r[1];\n          }\n          var idx = n_side ? right_index[r_i] : left_index[l_i]\n            , vert = n_side ? p.right[r_i] : p.left[l_i];\n          if(n_side !== side) {\n            //Opposite side\n            while(bottom+3 < top) {\n              if(flipped === n_side) {\n                faces.push([ stack[bottom], stack[bottom+3], idx, c]);\n              } else {\n                faces.push([ stack[bottom+3], stack[bottom], idx, c]);              \n              }\n              bottom += 3;\n            }\n          } else {\n            //Same side\n            while(bottom+3 < top) {\n              //Compute convexity\n              for(var j=0; j<2; ++j)\n              for(var k=0; k<2; ++k) {\n                delta[j][k] = stack[top-3*(j+1)+k+1] - vert[k];\n              }\n              var det = delta[0][0] * delta[1][1] - delta[1][0] * delta[0][1];\n              if(n_side === (det > 0)) {\n                break;\n              }\n              if(det !== 0) {\n                if(flipped === n_side) {\n                  faces.push([ stack[top-3], stack[top-6], idx, c ]);\n                } else {\n                  faces.push([ stack[top-6], stack[top-3], idx, c ]);\n                }\n              }\n              top -= 3;\n            }\n          }\n          //Push vertex\n          stack[top++] = idx;\n          stack[top++] = vert[0];\n          stack[top++] = vert[1];\n          //Update loop index\n          if(n_side) {\n            ++r_i;\n          } else {\n            ++l_i;\n          }\n          side = n_side;\n        }\n      }\n    }\n  }\n  return { vertices:vertices, faces:faces };\n}\n})();\n\nif(exports) {\n  exports.mesher = MonotoneMesh;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/dmillet/Projects/fpt/fpt/~/voxel/meshers/monotone.js\n ** module id = 21\n ** module chunks = 0 1 2\n **/","//The stupidest possible way to generate a Minecraft mesh (I think)\nfunction StupidMesh(volume, dims) {\n  var vertices = [], faces = [], x = [0,0,0], n = 0;\n  for(x[2]=0; x[2]<dims[2]; ++x[2])\n  for(x[1]=0; x[1]<dims[1]; ++x[1])\n  for(x[0]=0; x[0]<dims[0]; ++x[0], ++n)\n  if(!!volume[n]) {\n    for(var d=0; d<3; ++d) {\n      var t = [x[0], x[1], x[2]]\n        , u = [0,0,0]\n        , v = [0,0,0];\n      u[(d+1)%3] = 1;\n      v[(d+2)%3] = 1;\n      for(var s=0; s<2; ++s) {\n        t[d] = x[d] + s;\n        var tmp = u;\n        u = v;\n        v = tmp;\n        var vertex_count = vertices.length;\n        vertices.push([t[0],           t[1],           t[2]          ]);\n        vertices.push([t[0]+u[0],      t[1]+u[1],      t[2]+u[2]     ]);\n        vertices.push([t[0]+u[0]+v[0], t[1]+u[1]+v[1], t[2]+u[2]+v[2]]);\n        vertices.push([t[0]     +v[0], t[1]     +v[1], t[2]     +v[2]]);\n        faces.push([vertex_count, vertex_count+1, vertex_count+2, vertex_count+3, volume[n]]);\n      }\n    }\n  }\n  return { vertices:vertices, faces:faces };\n}\n\n\nif(exports) {\n  exports.mesher = StupidMesh;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/dmillet/Projects/fpt/fpt/~/voxel/meshers/stupid.js\n ** module id = 22\n ** module chunks = 0 1 2\n **/","\nimport CANNON from 'cannon';\nimport merge from './terrainPhysics-merge';\nimport Terrain from './Terrain';\nimport TerrainPiece from './TerrainPiece';\n\nvar X = 0;\nvar Y = 1;\nvar Z = 2;\n\nvar WIDTH = 0;\nvar HEIGHT = 1;\nvar DEPTH = 2;\n\nexport default class TerrainPhysics {\n\n\tstatic create(terrain) {\n\t\treturn new TerrainPhysics(terrain);\n\t}\n\n\tconstructor(terrain) {\n\n\t\tthis.terrain = terrain;\n\n\t\tlet voxels = terrain.get('voxels');\n\n\t\tfor (var chunkPos in voxels.chunks) {\n\t\t\tvar chunk = voxels.chunks[chunkPos];\n\t\t\tif (chunk) {\n\t\t\t\tthis.createChunkPhysics(chunk);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tcreateChunkPhysics(chunk) {\n\t\tvar cache = {};\n\t\tvar pieces = this.terrain.get('pieces');\n\n\t\tfunction isProcessed(pos) {\n\t\t\treturn cache[pos.join('|')] || false;\n\t\t}\n\n\t\tfunction markProcessed(pos) {\n\t\t\treturn cache[pos.join('|')] = true;\n\t\t}\n\n\t\tthis.createChunkPhysics.items = this.createChunkPhysics.items || {};\n\t\tvar chunkItems = this.createChunkPhysics.items[chunk.position.join('|')];\n\t\tif (chunkItems) {\n\t\t\tchunkItems.forEach(function(item) {\n\t\t\t\tif(item.mesh) {\n\t\t\t\t\tthis.scene.remove(item.mesh);\n\t\t\t\t}\n\t\t\t\t//this.world.remove(item.body);\n\t\t\t}.bind(this));\n\t\t}\n\t\tchunkItems = this.createChunkPhysics.items[chunk.position.join('|')] = []\n\n\t\tmerge.all(\n\n\t\t\tfunction(pos) {\n\t\t\t\treturn this.terrain.getBlockAt(pos) && !isProcessed(pos)\n\t\t\t}.bind(this),\n\n\t\t\tchunk,\n\n\t\t\tfunction(result) {\n\n\t\t\t\tmerge.voxelsIn(result).forEach(function(pos) {\n\t\t\t\t\tmarkProcessed(pos);\n\t\t\t\t});\n\t\t\t\tvar position = result.position.map(function(v, i) {return v + result.dims[i] / 2;});\n\n\t\t\t\tvar boxShape = new CANNON.Box(new CANNON.Vec3(result.dims[WIDTH] / 2, result.dims[HEIGHT] / 2, result.dims[DEPTH] / 2));\n\t\t\t\tvar box = new CANNON.Body({\n\t\t\t\t\tmass: 0\n\t\t\t\t});\n\t\t\t\tbox.addShape(boxShape);\n\t\t\t\tbox.position.set.apply(box.position, position);\n\n\t\t\t\tvar item = {\n\t\t\t\t\tmesh: null,\n\t\t\t\t\tbody: box\n\t\t\t\t};\n\n\t\t\t\tchunkItems.push(item);\n\n\t\t\t\tlet piece = TerrainPiece.create({\n\t\t\t\t\tcannon: box\n\t\t\t\t});\n\n\t\t\t\tpieces.add(piece);\n\n\t\t\t}.bind(this)\n\t\t);\n\t}\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ../game/terrain/TerrainPhysics.js\n **/","\"use strict\"\n\nvar X = 0\nvar Y = 1\nvar Z = 2\n\nvar WIDTH = 0\nvar HEIGHT = 1\nvar DEPTH = 2\n\nfunction findConvexBox(check, startPos, chunk) {\n  if (arguments.length === 2) {\n    chunk = startPos\n    startPos = chunk.position.map(function(v, i) {\n      return v * chunk.dims[i]\n    })\n  }\n  if (!chunk.voxels) throw new Error('Requires game chunk')\n\n  var endPos = chunk.position.map(function(v, i) {\n    return v * chunk.dims[i] + chunk.dims[i]\n  })\n\n  var box = {\n    dims: startPos.map(function(v, i) {return endPos[i] - v}),\n    position: [0,0,0]\n  }\n  if (!check(startPos)) {\n    return false\n  }\n  var found = false\n  for (var x = startPos[X]; !found && x < endPos[X]; x++) {\n    var y = startPos[Y]\n    var z = startPos[Z]\n    if (!check([x, y, z])) {\n      if (box.dims[WIDTH] > x - startPos[X]) box.dims[WIDTH] = x - startPos[X]\n    }\n  }\n\n  var found = false\n  for (var z = startPos[Z] + 1; !found && z < endPos[Z]; z++) {\n    for (var x = startPos[X]; !found && x < startPos[X] + box.dims[WIDTH]; x++) {\n      var y = startPos[Y]\n      if (!check([x, y, z])) {\n        if (box.dims[DEPTH] > z - startPos[Z]) box.dims[DEPTH] = z - startPos[Z]\n      }\n    }\n  }\n\n  var found = false\n  for (var y = startPos[Y] + 1; !found && y < endPos[Y]; y++) {\n    for (var x = startPos[X]; !found && x < startPos[X] + box.dims[WIDTH]; x++) {\n      for (var z = startPos[Z]; !found && z < startPos[Z] + box.dims[DEPTH]; z++) {\n        if (!check([x, y, z])) {\n          if (box.dims[HEIGHT] > y - startPos[Y]) box.dims[HEIGHT] = y - startPos[Y]\n        }\n      }\n    }\n  }\n\n  if (box.dims[WIDTH] == 0) box.dims[WIDTH] = 1;\n  if (box.dims[HEIGHT] == 0) box.dims[HEIGHT] = 1;\n  if (box.dims[DEPTH] == 0) box.dims[DEPTH] = 1;\n  box.position[X] = startPos[X] //+ box.dims[WIDTH]\n  box.position[Y] = startPos[Y] //+ box.dims[HEIGHT]\n  box.position[Z] = startPos[Z] //+ box.dims[DEPTH]\n  return box\n}\n\nfindConvexBox.all = function(check, chunk, done) {\n  var results = []\n  findConvexBox.voxelsIn(chunk).forEach(function(pos) {\n    var result = findConvexBox(check, pos, chunk)\n    if (result) {\n      done(result)\n      results.push(result)\n    }\n  })\n  return results\n}\n\n\nfindConvexBox.voxelsIn = function voxelsIn(chunk) {\n  if (chunk.voxels) {\n    chunk = {\n      dims: chunk.dims.map(function(v) {return v}),\n      position: chunk.position.map(function(v, i) {return v * chunk.dims[i]})\n    }\n  }\n\n  var points = []\n  for (var x = chunk.position[X]; x < chunk.position[X] + chunk.dims[WIDTH]; x++) {\n    for (var y = chunk.position[Y]; y < chunk.position[Y] + chunk.dims[HEIGHT]; y++) {\n      for (var z = chunk.position[Z]; z < chunk.position[Z] + chunk.dims[DEPTH]; z++) {\n        points.push([x, y, z])\n      }\n    }\n  }\n  return points\n}\n\nmodule.exports = findConvexBox;\n\n\n\n/** WEBPACK FOOTER **\n ** ../game/terrain/terrainPhysics-merge.js\n **/","\nimport Entity from '../ecs/Entity';\nimport PhysicsComponent from '../physics/PhysicsComponent';\n\nlet TerrainPiece = Entity.createClass({\n\tconstructor: function(options) {\n\t\tvar physics = PhysicsComponent.create();\n\t\tphysics.cannon = options.cannon;\n\t\tthis.set('physics', physics);\n\t}\n});\n\nTerrainPiece.create = function(options) {\n\treturn new TerrainPiece(options);\n};\n\nexport default TerrainPiece;\n\n\n\n/** WEBPACK FOOTER **\n ** ../game/terrain/TerrainPiece.js\n **/","\nimport CANNON from 'cannon';\nimport Position from './Position';\nimport Rotation from './Rotation';\nimport Velocity from './Velocity';\n\nclass PhysicsComponent {\n\n\tstatic create(opts) {\n\t\treturn new PhysicsComponent(opts);\n\t}\n\n\tconstructor(options) {\n\t\toptions = options || {};\n\t\tlet shape = new CANNON.Box(new CANNON.Vec3(.5, .5, .5));\n\t\tlet body = new CANNON.Body({\n\t\t\tmass: 1\n\t\t});\n\t\tbody.addShape(shape);\n\t\tif (options.position) {\n\t\t\tbody.position.set(options.position.x, options.position.y, options.position.z);\n\t\t}\n\t\tthis.cannon = body;\n\t\tPosition.shim(this, body.position);\n\t\tRotation.shim(this, body.quaternion);\n\t\tVelocity.shim(this, body.velocity);\n\t\tthis.constraints = [];\n\t}\n\n\tget dynamicRotation() {\n\t\treturn !this.cannon.fixedRotation;\n\t}\n\n\tset dynamicRotation(bool) {\n\t\tthis.cannon.fixedRotation = !bool;\n\t\tthis.cannon.updateMassProperties();\n\t}\n\n}\n\nexport default PhysicsComponent;\n\n\n\n/** WEBPACK FOOTER **\n ** ../game/physics/PhysicsComponent.js\n **/","\nimport THREE from 'three';\nimport TerrainView from './TerrainView';\nimport System from '../../game/ecs/System';\nimport MeshComponent from './MeshComponent';\n\nlet FPTGameView = System.createClass({\n\n\tconstructor: function(fptGame) {\n\t\tthis.game = fptGame;\n\n\t\tthis.scene = new THREE.Scene();\n\t\tthis.camera = new THREE.PerspectiveCamera(\n\t\t\t75, window.innerWidth / window.innerHeight, 0.1, 1000\n\t\t);\n\t\tthis.camera.position.setZ(10);\n\t\tthis.scene.add(this.camera);\n\n\t\tthis.renderer = new THREE.WebGLRenderer();\n\t\tthis.renderer.shadowMapType = THREE.PCFSoftShadowMap;\n\t    this.renderer.shadowMapEnabled = true;\n\t    this.renderer.shadowMapSoft = true;\n\t\tthis.renderer.setClearColorHex( 0xffffff );\n\t\tthis.renderer.setSize( window.innerWidth, window.innerHeight );\n\t\tthis.element = this.renderer.domElement;\n\n\t\tthis.terrain = TerrainView.create(fptGame.level.terrain);\n\t\tthis.scene.add(this.terrain.three);\n\n\t\tlet tick = function() {\n\t\t\tthis.tick();\n\t\t\trequestAnimationFrame(tick);\n\t\t}.bind(this);\n\n\t\trequestAnimationFrame(tick);\n\n\t},\n\n\ttick() {\n\t\tthis.tickSubsystems();\n\t\tthis.game.entities.forEach(this.tickEntity.bind(this));\n\t\tthis.renderer.render(this.scene, this.camera);\n\t},\n\n\ttickEntity(entity) {\n\t\tvar view = entity.get('view');\n\t\tvar physics = entity.get('physics');\n\t\tlet mesh = entity.get('mesh');\n\t\tif (view && physics) {\n\t\t\tif (!mesh) {\n\t\t\t\tmesh = MeshComponent.create();\n\t\t\t\tthis.scene.add(mesh.three);\n\t\t\t\tentity.set('mesh', mesh);\n\t\t\t}\n\t\t\tvar position = physics.position;\n\t\t\tvar rotation = physics.rotation;\n\t\t\tmesh.three.position.set(position.x, position.y, position.z);\n\t\t\tmesh.three.useQuaternion = true;\n\t\t\tmesh.three.quaternion.set(rotation.x, rotation.y, rotation.z, rotation.w);\n\t\t}\n\t\tlet pieces = entity.get('pieces');\n\t\tif (pieces) {\n\t\t\tpieces.forEach(this.tickEntity.bind(this));\n\t\t}\n\t},\n\n\texportLevel() {\n\t\tlet w = window.open(\"\",\"\");\n\t\tw.document.write(JSON.stringify(this.game.level.export()));\n\t\tw.document.close();\n\t}\n\n});\n\nFPTGameView.create = function(fptGame) {\n\treturn new FPTGameView(fptGame);\n};\n\nexport default FPTGameView;\n\n\n\n/** WEBPACK FOOTER **\n ** ./view/FPTGameView.js\n **/","\r\nvar window = window || {};\r\nvar self = self || {};\r\n\r\n// High-resulution counter: emulate window.performance.now() for THREE.CLOCK\r\nif( window.performance === undefined ) {\r\n\r\n\twindow.performance = { };\r\n\r\n}\r\n\r\nif( window.performance.now === undefined ) {\r\n\r\n\twindow.performance.now = function () {\r\n\r\n\t\tvar time = process.hrtime();\r\n\t\treturn ( time[0] + time[1] / 1e9 ) * 1000;\r\n\r\n\t};\r\n\r\n}\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author Larry Battle / http://bateru.com/news\r\n */\r\n\r\nvar THREE = THREE || { REVISION: '56' };\r\n\r\nself.console = self.console || {\r\n\r\n\tinfo: function () {},\r\n\tlog: function () {},\r\n\tdebug: function () {},\r\n\twarn: function () {},\r\n\terror: function () {}\r\n\r\n};\r\n\r\nself.Int32Array = self.Int32Array || Array;\r\nself.Float32Array = self.Float32Array || Array;\r\n\r\nString.prototype.trim = String.prototype.trim || function () {\r\n\r\n\treturn this.replace( /^\\s+|\\s+$/g, '' );\r\n\r\n};\r\n\r\n// based on https://github.com/documentcloud/underscore/blob/bf657be243a075b5e72acc8a83e6f12a564d8f55/underscore.js#L767\r\nTHREE.extend = function ( obj, source ) {\r\n\r\n\t// ECMAScript5 compatibility based on: http://www.nczonline.net/blog/2012/12/11/are-your-mixins-ecmascript-5-compatible/\r\n\tif ( Object.keys ) {\r\n\r\n\t\tvar keys = Object.keys( source );\r\n\r\n\t\tfor (var i = 0, il = keys.length; i < il; i++) {\r\n\r\n\t\t\tvar prop = keys[i];\r\n\t\t\tObject.defineProperty( obj, prop, Object.getOwnPropertyDescriptor( source, prop ) );\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tvar safeHasOwnProperty = {}.hasOwnProperty;\r\n\r\n\t\tfor ( var prop in source ) {\r\n\r\n\t\t\tif ( safeHasOwnProperty.call( source, prop ) ) {\r\n\r\n\t\t\t\tobj[prop] = source[prop];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn obj;\r\n\r\n};\r\n\r\n// http://paulirish.com/2011/requestanimationframe-for-smart-animating/\r\n// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\r\n\r\n// requestAnimationFrame polyfill by Erik Möller\r\n// fixes from Paul Irish and Tino Zijdel\r\n\r\n( function () {\r\n\r\n\tvar lastTime = 0;\r\n\tvar vendors = [ 'ms', 'moz', 'webkit', 'o' ];\r\n\r\n\tfor ( var x = 0; x < vendors.length && !window.requestAnimationFrame; ++ x ) {\r\n\r\n\t\twindow.requestAnimationFrame = window[ vendors[ x ] + 'RequestAnimationFrame' ];\r\n\t\twindow.cancelAnimationFrame = window[ vendors[ x ] + 'CancelAnimationFrame' ] || window[ vendors[ x ] + 'CancelRequestAnimationFrame' ];\r\n\r\n\t}\r\n\r\n\tif ( window.requestAnimationFrame === undefined ) {\r\n\r\n\t\twindow.requestAnimationFrame = function ( callback ) {\r\n\r\n\t\t\tvar currTime = Date.now(), timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );\r\n\t\t\tvar id = window.setTimeout( function() { callback( currTime + timeToCall ); }, timeToCall );\r\n\t\t\tlastTime = currTime + timeToCall;\r\n\t\t\treturn id;\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n\twindow.cancelAnimationFrame = window.cancelAnimationFrame || function ( id ) { window.clearTimeout( id ) };\r\n\r\n}() );\r\n\r\n// GL STATE CONSTANTS\r\n\r\nTHREE.CullFaceNone = 0;\r\nTHREE.CullFaceBack = 1;\r\nTHREE.CullFaceFront = 2;\r\nTHREE.CullFaceFrontBack = 3;\r\n\r\nTHREE.FrontFaceDirectionCW = 0;\r\nTHREE.FrontFaceDirectionCCW = 1;\r\n\r\n// SHADOWING TYPES\r\n\r\nTHREE.BasicShadowMap = 0;\r\nTHREE.PCFShadowMap = 1;\r\nTHREE.PCFSoftShadowMap = 2;\r\n\r\n// MATERIAL CONSTANTS\r\n\r\n// side\r\n\r\nTHREE.FrontSide = 0;\r\nTHREE.BackSide = 1;\r\nTHREE.DoubleSide = 2;\r\n\r\n// shading\r\n\r\nTHREE.NoShading = 0;\r\nTHREE.FlatShading = 1;\r\nTHREE.SmoothShading = 2;\r\n\r\n// colors\r\n\r\nTHREE.NoColors = 0;\r\nTHREE.FaceColors = 1;\r\nTHREE.VertexColors = 2;\r\n\r\n// blending modes\r\n\r\nTHREE.NoBlending = 0;\r\nTHREE.NormalBlending = 1;\r\nTHREE.AdditiveBlending = 2;\r\nTHREE.SubtractiveBlending = 3;\r\nTHREE.MultiplyBlending = 4;\r\nTHREE.CustomBlending = 5;\r\n\r\n// custom blending equations\r\n// (numbers start from 100 not to clash with other\r\n//  mappings to OpenGL constants defined in Texture.js)\r\n\r\nTHREE.AddEquation = 100;\r\nTHREE.SubtractEquation = 101;\r\nTHREE.ReverseSubtractEquation = 102;\r\n\r\n// custom blending destination factors\r\n\r\nTHREE.ZeroFactor = 200;\r\nTHREE.OneFactor = 201;\r\nTHREE.SrcColorFactor = 202;\r\nTHREE.OneMinusSrcColorFactor = 203;\r\nTHREE.SrcAlphaFactor = 204;\r\nTHREE.OneMinusSrcAlphaFactor = 205;\r\nTHREE.DstAlphaFactor = 206;\r\nTHREE.OneMinusDstAlphaFactor = 207;\r\n\r\n// custom blending source factors\r\n\r\n//THREE.ZeroFactor = 200;\r\n//THREE.OneFactor = 201;\r\n//THREE.SrcAlphaFactor = 204;\r\n//THREE.OneMinusSrcAlphaFactor = 205;\r\n//THREE.DstAlphaFactor = 206;\r\n//THREE.OneMinusDstAlphaFactor = 207;\r\nTHREE.DstColorFactor = 208;\r\nTHREE.OneMinusDstColorFactor = 209;\r\nTHREE.SrcAlphaSaturateFactor = 210;\r\n\r\n\r\n// TEXTURE CONSTANTS\r\n\r\nTHREE.MultiplyOperation = 0;\r\nTHREE.MixOperation = 1;\r\nTHREE.AddOperation = 2;\r\n\r\n// Mapping modes\r\n\r\nTHREE.UVMapping = function () {};\r\n\r\nTHREE.CubeReflectionMapping = function () {};\r\nTHREE.CubeRefractionMapping = function () {};\r\n\r\nTHREE.SphericalReflectionMapping = function () {};\r\nTHREE.SphericalRefractionMapping = function () {};\r\n\r\n// Wrapping modes\r\n\r\nTHREE.RepeatWrapping = 1000;\r\nTHREE.ClampToEdgeWrapping = 1001;\r\nTHREE.MirroredRepeatWrapping = 1002;\r\n\r\n// Filters\r\n\r\nTHREE.NearestFilter = 1003;\r\nTHREE.NearestMipMapNearestFilter = 1004;\r\nTHREE.NearestMipMapLinearFilter = 1005;\r\nTHREE.LinearFilter = 1006;\r\nTHREE.LinearMipMapNearestFilter = 1007;\r\nTHREE.LinearMipMapLinearFilter = 1008;\r\n\r\n// Data types\r\n\r\nTHREE.UnsignedByteType = 1009;\r\nTHREE.ByteType = 1010;\r\nTHREE.ShortType = 1011;\r\nTHREE.UnsignedShortType = 1012;\r\nTHREE.IntType = 1013;\r\nTHREE.UnsignedIntType = 1014;\r\nTHREE.FloatType = 1015;\r\n\r\n// Pixel types\r\n\r\n//THREE.UnsignedByteType = 1009;\r\nTHREE.UnsignedShort4444Type = 1016;\r\nTHREE.UnsignedShort5551Type = 1017;\r\nTHREE.UnsignedShort565Type = 1018;\r\n\r\n// Pixel formats\r\n\r\nTHREE.AlphaFormat = 1019;\r\nTHREE.RGBFormat = 1020;\r\nTHREE.RGBAFormat = 1021;\r\nTHREE.LuminanceFormat = 1022;\r\nTHREE.LuminanceAlphaFormat = 1023;\r\n\r\n// Compressed texture formats\r\n\r\nTHREE.RGB_S3TC_DXT1_Format = 2001;\r\nTHREE.RGBA_S3TC_DXT1_Format = 2002;\r\nTHREE.RGBA_S3TC_DXT3_Format = 2003;\r\nTHREE.RGBA_S3TC_DXT5_Format = 2004;\r\n\r\n/*\r\n// Potential future PVRTC compressed texture formats\r\nTHREE.RGB_PVRTC_4BPPV1_Format = 2100;\r\nTHREE.RGB_PVRTC_2BPPV1_Format = 2101;\r\nTHREE.RGBA_PVRTC_4BPPV1_Format = 2102;\r\nTHREE.RGBA_PVRTC_2BPPV1_Format = 2103;\r\n*/\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Color = function ( value ) {\r\n\r\n\tif ( value !== undefined ) this.set( value );\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nTHREE.extend( THREE.Color.prototype, {\r\n\r\n\tr: 1, g: 1, b: 1,\r\n\r\n\tset: function ( value ) {\r\n\r\n\t\tswitch ( typeof value ) {\r\n\r\n\t\t\tcase \"number\":\r\n\t\t\t\tthis.setHex( value );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase \"string\":\r\n\t\t\t\tthis.setStyle( value );\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tsetHex: function ( hex ) {\r\n\r\n\t\thex = Math.floor( hex );\r\n\r\n\t\tthis.r = ( hex >> 16 & 255 ) / 255;\r\n\t\tthis.g = ( hex >> 8 & 255 ) / 255;\r\n\t\tthis.b = ( hex & 255 ) / 255;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetRGB: function ( r, g, b ) {\r\n\r\n\t\tthis.r = r;\r\n\t\tthis.g = g;\r\n\t\tthis.b = b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetHSV: function ( h, s, v ) {\r\n\r\n\t\tconsole.log( 'DEPRECATED: Color\\'s .setHSV() will be removed. Use .setHSL( h, s, l ) instead.' );\r\n\t\treturn this.setHSL(h,s*v/((h=(2-s)*v)<1?h:2-h),h/2); // https://gist.github.com/xpansive/1337890\r\n\r\n\t},\r\n\r\n\tsetHSL: function ( h, s, l ) {\r\n\r\n\t\t// h,s,l ranges are in 0.0 - 1.0\r\n\r\n\t\tif ( s === 0 ) {\r\n\r\n\t\t\tthis.r = this.g = this.b = l;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar hue2rgb = function ( p, q, t ) {\r\n\r\n\t\t\t\tif ( t < 0 ) t += 1;\r\n\t\t\t\tif ( t > 1 ) t -= 1;\r\n\t\t\t\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\r\n\t\t\t\tif ( t < 1 / 2 ) return q;\r\n\t\t\t\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\r\n\t\t\t\treturn p;\r\n\r\n\t\t\t};\r\n\r\n\t\t\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\r\n\t\t\tvar q = ( 2 * l ) - p;\r\n\r\n\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\r\n\t\t\tthis.g = hue2rgb( q, p, h );\r\n\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetStyle: function ( style ) {\r\n\r\n\t\t// rgb(255,0,0)\r\n\r\n\t\tif ( /^rgb\\((\\d+),(\\d+),(\\d+)\\)$/i.test( style ) ) {\r\n\r\n\t\t\tvar color = /^rgb\\((\\d+),(\\d+),(\\d+)\\)$/i.exec( style );\r\n\r\n\t\t\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\r\n\t\t\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\r\n\t\t\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t// rgb(100%,0%,0%)\r\n\r\n\t\tif ( /^rgb\\((\\d+)\\%,(\\d+)\\%,(\\d+)\\%\\)$/i.test( style ) ) {\r\n\r\n\t\t\tvar color = /^rgb\\((\\d+)\\%,(\\d+)\\%,(\\d+)\\%\\)$/i.exec( style );\r\n\r\n\t\t\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\r\n\t\t\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\r\n\t\t\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t// #ff0000\r\n\r\n\t\tif ( /^\\#([0-9a-f]{6})$/i.test( style ) ) {\r\n\r\n\t\t\tvar color = /^\\#([0-9a-f]{6})$/i.exec( style );\r\n\r\n\t\t\tthis.setHex( parseInt( color[ 1 ], 16 ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t// #f00\r\n\r\n\t\tif ( /^\\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test( style ) ) {\r\n\r\n\t\t\tvar color = /^\\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec( style );\r\n\r\n\t\t\tthis.setHex( parseInt( color[ 1 ] + color[ 1 ] + color[ 2 ] + color[ 2 ] + color[ 3 ] + color[ 3 ], 16 ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t// red\r\n\r\n\t\tif ( /^(\\w+)$/i.test( style ) ) {\r\n\r\n\t\t\tthis.setHex( THREE.ColorKeywords[ style ] );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\r\n\t},\r\n\r\n\tcopy: function ( color ) {\r\n\r\n\t\tthis.r = color.r;\r\n\t\tthis.g = color.g;\r\n\t\tthis.b = color.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyGammaToLinear: function ( color ) {\r\n\r\n\t\tthis.r = color.r * color.r;\r\n\t\tthis.g = color.g * color.g;\r\n\t\tthis.b = color.b * color.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyLinearToGamma: function ( color ) {\r\n\r\n\t\tthis.r = Math.sqrt( color.r );\r\n\t\tthis.g = Math.sqrt( color.g );\r\n\t\tthis.b = Math.sqrt( color.b );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tconvertGammaToLinear: function () {\r\n\r\n\t\tvar r = this.r, g = this.g, b = this.b;\r\n\r\n\t\tthis.r = r * r;\r\n\t\tthis.g = g * g;\r\n\t\tthis.b = b * b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tconvertLinearToGamma: function () {\r\n\r\n\t\tthis.r = Math.sqrt( this.r );\r\n\t\tthis.g = Math.sqrt( this.g );\r\n\t\tthis.b = Math.sqrt( this.b );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetHex: function () {\r\n\r\n\t\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\r\n\r\n\t},\r\n\r\n\tgetHexString: function () {\r\n\r\n\t\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\r\n\r\n\t},\r\n\r\n\tgetHSL: function () {\r\n\r\n\t\tvar hsl = { h: 0, s: 0, l: 0 };\r\n\r\n\t\treturn function () {\r\n\r\n\t\t\t// h,s,l ranges are in 0.0 - 1.0\r\n\r\n\t\t\tvar r = this.r, g = this.g, b = this.b;\r\n\r\n\t\t\tvar max = Math.max( r, g, b );\r\n\t\t\tvar min = Math.min( r, g, b );\r\n\r\n\t\t\tvar hue, saturation;\r\n\t\t\tvar lightness = ( min + max ) / 2.0;\r\n\r\n\t\t\tif ( min === max ) {\r\n\r\n\t\t\t\thue = 0;\r\n\t\t\t\tsaturation = 0;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar delta = max - min;\r\n\r\n\t\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\r\n\r\n\t\t\t\tswitch ( max ) {\r\n\r\n\t\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\r\n\t\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\r\n\t\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\thue /= 6;\r\n\r\n\t\t\t}\r\n\r\n\t\t\thsl.h = hue;\r\n\t\t\thsl.s = saturation;\r\n\t\t\thsl.l = lightness;\r\n\r\n\t\t\treturn hsl;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tgetStyle: function () {\r\n\r\n\t\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\r\n\r\n\t},\r\n\r\n\toffsetHSL: function ( h, s, l ) {\r\n\r\n\t\tvar hsl = this.getHSL();\r\n\r\n\t\thsl.h += h; hsl.s += s; hsl.l += l;\r\n\r\n\t\tthis.setHSL( hsl.h, hsl.s, hsl.l );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tadd: function ( color ) {\r\n\r\n\t\tthis.r += color.r;\r\n\t\tthis.g += color.g;\r\n\t\tthis.b += color.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddColors: function ( color1, color2 ) {\r\n\r\n\t\tthis.r = color1.r + color2.r;\r\n\t\tthis.g = color1.g + color2.g;\r\n\t\tthis.b = color1.b + color2.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.r += s;\r\n\t\tthis.g += s;\r\n\t\tthis.b += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiply: function ( color ) {\r\n\r\n\t\tthis.r *= color.r;\r\n\t\tthis.g *= color.g;\r\n\t\tthis.b *= color.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( s ) {\r\n\r\n\t\tthis.r *= s;\r\n\t\tthis.g *= s;\r\n\t\tthis.b *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerp: function ( color, alpha ) {\r\n\r\n\t\tthis.r += ( color.r - this.r ) * alpha;\r\n\t\tthis.g += ( color.g - this.g ) * alpha;\r\n\t\tthis.b += ( color.b - this.b ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Color().setRGB( this.r, this.g, this.b );\r\n\r\n\t}\r\n\r\n} );\r\n\r\nTHREE.ColorKeywords = { \"aliceblue\": 0xF0F8FF, \"antiquewhite\": 0xFAEBD7, \"aqua\": 0x00FFFF, \"aquamarine\": 0x7FFFD4, \"azure\": 0xF0FFFF,\r\n\"beige\": 0xF5F5DC, \"bisque\": 0xFFE4C4, \"black\": 0x000000, \"blanchedalmond\": 0xFFEBCD, \"blue\": 0x0000FF, \"blueviolet\": 0x8A2BE2,\r\n\"brown\": 0xA52A2A, \"burlywood\": 0xDEB887, \"cadetblue\": 0x5F9EA0, \"chartreuse\": 0x7FFF00, \"chocolate\": 0xD2691E, \"coral\": 0xFF7F50,\r\n\"cornflowerblue\": 0x6495ED, \"cornsilk\": 0xFFF8DC, \"crimson\": 0xDC143C, \"cyan\": 0x00FFFF, \"darkblue\": 0x00008B, \"darkcyan\": 0x008B8B,\r\n\"darkgoldenrod\": 0xB8860B, \"darkgray\": 0xA9A9A9, \"darkgreen\": 0x006400, \"darkgrey\": 0xA9A9A9, \"darkkhaki\": 0xBDB76B, \"darkmagenta\": 0x8B008B,\r\n\"darkolivegreen\": 0x556B2F, \"darkorange\": 0xFF8C00, \"darkorchid\": 0x9932CC, \"darkred\": 0x8B0000, \"darksalmon\": 0xE9967A, \"darkseagreen\": 0x8FBC8F,\r\n\"darkslateblue\": 0x483D8B, \"darkslategray\": 0x2F4F4F, \"darkslategrey\": 0x2F4F4F, \"darkturquoise\": 0x00CED1, \"darkviolet\": 0x9400D3,\r\n\"deeppink\": 0xFF1493, \"deepskyblue\": 0x00BFFF, \"dimgray\": 0x696969, \"dimgrey\": 0x696969, \"dodgerblue\": 0x1E90FF, \"firebrick\": 0xB22222,\r\n\"floralwhite\": 0xFFFAF0, \"forestgreen\": 0x228B22, \"fuchsia\": 0xFF00FF, \"gainsboro\": 0xDCDCDC, \"ghostwhite\": 0xF8F8FF, \"gold\": 0xFFD700,\r\n\"goldenrod\": 0xDAA520, \"gray\": 0x808080, \"green\": 0x008000, \"greenyellow\": 0xADFF2F, \"grey\": 0x808080, \"honeydew\": 0xF0FFF0, \"hotpink\": 0xFF69B4,\r\n\"indianred\": 0xCD5C5C, \"indigo\": 0x4B0082, \"ivory\": 0xFFFFF0, \"khaki\": 0xF0E68C, \"lavender\": 0xE6E6FA, \"lavenderblush\": 0xFFF0F5, \"lawngreen\": 0x7CFC00,\r\n\"lemonchiffon\": 0xFFFACD, \"lightblue\": 0xADD8E6, \"lightcoral\": 0xF08080, \"lightcyan\": 0xE0FFFF, \"lightgoldenrodyellow\": 0xFAFAD2, \"lightgray\": 0xD3D3D3,\r\n\"lightgreen\": 0x90EE90, \"lightgrey\": 0xD3D3D3, \"lightpink\": 0xFFB6C1, \"lightsalmon\": 0xFFA07A, \"lightseagreen\": 0x20B2AA, \"lightskyblue\": 0x87CEFA,\r\n\"lightslategray\": 0x778899, \"lightslategrey\": 0x778899, \"lightsteelblue\": 0xB0C4DE, \"lightyellow\": 0xFFFFE0, \"lime\": 0x00FF00, \"limegreen\": 0x32CD32,\r\n\"linen\": 0xFAF0E6, \"magenta\": 0xFF00FF, \"maroon\": 0x800000, \"mediumaquamarine\": 0x66CDAA, \"mediumblue\": 0x0000CD, \"mediumorchid\": 0xBA55D3,\r\n\"mediumpurple\": 0x9370DB, \"mediumseagreen\": 0x3CB371, \"mediumslateblue\": 0x7B68EE, \"mediumspringgreen\": 0x00FA9A, \"mediumturquoise\": 0x48D1CC,\r\n\"mediumvioletred\": 0xC71585, \"midnightblue\": 0x191970, \"mintcream\": 0xF5FFFA, \"mistyrose\": 0xFFE4E1, \"moccasin\": 0xFFE4B5, \"navajowhite\": 0xFFDEAD,\r\n\"navy\": 0x000080, \"oldlace\": 0xFDF5E6, \"olive\": 0x808000, \"olivedrab\": 0x6B8E23, \"orange\": 0xFFA500, \"orangered\": 0xFF4500, \"orchid\": 0xDA70D6,\r\n\"palegoldenrod\": 0xEEE8AA, \"palegreen\": 0x98FB98, \"paleturquoise\": 0xAFEEEE, \"palevioletred\": 0xDB7093, \"papayawhip\": 0xFFEFD5, \"peachpuff\": 0xFFDAB9,\r\n\"peru\": 0xCD853F, \"pink\": 0xFFC0CB, \"plum\": 0xDDA0DD, \"powderblue\": 0xB0E0E6, \"purple\": 0x800080, \"red\": 0xFF0000, \"rosybrown\": 0xBC8F8F,\r\n\"royalblue\": 0x4169E1, \"saddlebrown\": 0x8B4513, \"salmon\": 0xFA8072, \"sandybrown\": 0xF4A460, \"seagreen\": 0x2E8B57, \"seashell\": 0xFFF5EE,\r\n\"sienna\": 0xA0522D, \"silver\": 0xC0C0C0, \"skyblue\": 0x87CEEB, \"slateblue\": 0x6A5ACD, \"slategray\": 0x708090, \"slategrey\": 0x708090, \"snow\": 0xFFFAFA,\r\n\"springgreen\": 0x00FF7F, \"steelblue\": 0x4682B4, \"tan\": 0xD2B48C, \"teal\": 0x008080, \"thistle\": 0xD8BFD8, \"tomato\": 0xFF6347, \"turquoise\": 0x40E0D0,\r\n\"violet\": 0xEE82EE, \"wheat\": 0xF5DEB3, \"white\": 0xFFFFFF, \"whitesmoke\": 0xF5F5F5, \"yellow\": 0xFFFF00, \"yellowgreen\": 0x9ACD32 };\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Quaternion = function( x, y, z, w ) {\r\n\r\n\tthis.x = x || 0;\r\n\tthis.y = y || 0;\r\n\tthis.z = z || 0;\r\n\tthis.w = ( w !== undefined ) ? w : 1;\r\n\r\n};\r\n\r\nTHREE.extend( THREE.Quaternion.prototype, {\r\n\r\n\tset: function ( x, y, z, w ) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.z = z;\r\n\t\tthis.w = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( q ) {\r\n\r\n\t\tthis.x = q.x;\r\n\t\tthis.y = q.y;\r\n\t\tthis.z = q.z;\r\n\t\tthis.w = q.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromEuler: function ( v, order ) {\r\n\r\n\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\r\n\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\r\n\t\t//\tcontent/SpinCalc.m\r\n\r\n\t\tvar c1 = Math.cos( v.x / 2 );\r\n\t\tvar c2 = Math.cos( v.y / 2 );\r\n\t\tvar c3 = Math.cos( v.z / 2 );\r\n\t\tvar s1 = Math.sin( v.x / 2 );\r\n\t\tvar s2 = Math.sin( v.y / 2 );\r\n\t\tvar s3 = Math.sin( v.z / 2 );\r\n\r\n\t\tif ( order === undefined || order === 'XYZ' ) {\r\n\r\n\t\t\tthis.x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\tthis.y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\tthis.z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\tthis.w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n\t\t} else if ( order === 'YXZ' ) {\r\n\r\n\t\t\tthis.x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\tthis.y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\tthis.z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\tthis.w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n\t\t} else if ( order === 'ZXY' ) {\r\n\r\n\t\t\tthis.x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\tthis.y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\tthis.z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\tthis.w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n\t\t} else if ( order === 'ZYX' ) {\r\n\r\n\t\t\tthis.x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\tthis.y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\tthis.z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\tthis.w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n\t\t} else if ( order === 'YZX' ) {\r\n\r\n\t\t\tthis.x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\tthis.y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\tthis.z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\tthis.w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n\t\t} else if ( order === 'XZY' ) {\r\n\r\n\t\t\tthis.x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\tthis.y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\tthis.z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\tthis.w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromAxisAngle: function ( axis, angle ) {\r\n\r\n\t\t// from http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\r\n\t\t// axis have to be normalized\r\n\r\n\t\tvar halfAngle = angle / 2,\r\n\t\t\ts = Math.sin( halfAngle );\r\n\r\n\t\tthis.x = axis.x * s;\r\n\t\tthis.y = axis.y * s;\r\n\t\tthis.z = axis.z * s;\r\n\t\tthis.w = Math.cos( halfAngle );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromRotationMatrix: function ( m ) {\r\n\r\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\tvar te = m.elements,\r\n\r\n\t\t\tm11 = te[0], m12 = te[4], m13 = te[8],\r\n\t\t\tm21 = te[1], m22 = te[5], m23 = te[9],\r\n\t\t\tm31 = te[2], m32 = te[6], m33 = te[10],\r\n\r\n\t\t\ttrace = m11 + m22 + m33,\r\n\t\t\ts;\r\n\r\n\t\tif ( trace > 0 ) {\r\n\r\n\t\t\ts = 0.5 / Math.sqrt( trace + 1.0 );\r\n\r\n\t\t\tthis.w = 0.25 / s;\r\n\t\t\tthis.x = ( m32 - m23 ) * s;\r\n\t\t\tthis.y = ( m13 - m31 ) * s;\r\n\t\t\tthis.z = ( m21 - m12 ) * s;\r\n\r\n\t\t} else if ( m11 > m22 && m11 > m33 ) {\r\n\r\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\r\n\r\n\t\t\tthis.w = (m32 - m23 ) / s;\r\n\t\t\tthis.x = 0.25 * s;\r\n\t\t\tthis.y = (m12 + m21 ) / s;\r\n\t\t\tthis.z = (m13 + m31 ) / s;\r\n\r\n\t\t} else if ( m22 > m33 ) {\r\n\r\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\r\n\r\n\t\t\tthis.w = (m13 - m31 ) / s;\r\n\t\t\tthis.x = (m12 + m21 ) / s;\r\n\t\t\tthis.y = 0.25 * s;\r\n\t\t\tthis.z = (m23 + m32 ) / s;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\r\n\r\n\t\t\tthis.w = ( m21 - m12 ) / s;\r\n\t\t\tthis.x = ( m13 + m31 ) / s;\r\n\t\t\tthis.y = ( m23 + m32 ) / s;\r\n\t\t\tthis.z = 0.25 * s;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tinverse: function () {\r\n\r\n\t\tthis.conjugate().normalize();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tconjugate: function () {\r\n\r\n\t\tthis.x *= -1;\r\n\t\tthis.y *= -1;\r\n\t\tthis.z *= -1;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\tvar l = this.length();\r\n\r\n\t\tif ( l === 0 ) {\r\n\r\n\t\t\tthis.x = 0;\r\n\t\t\tthis.y = 0;\r\n\t\t\tthis.z = 0;\r\n\t\t\tthis.w = 1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tl = 1 / l;\r\n\r\n\t\t\tthis.x = this.x * l;\r\n\t\t\tthis.y = this.y * l;\r\n\t\t\tthis.z = this.z * l;\r\n\t\t\tthis.w = this.w * l;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiply: function ( q, p ) {\r\n\r\n\t\tif ( p !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'DEPRECATED: Quaternion\\'s .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\r\n\t\t\treturn this.multiplyQuaternions( q, p );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.multiplyQuaternions( this, q );\r\n\r\n\t},\r\n\r\n\tmultiplyQuaternions: function ( a, b ) {\r\n\r\n\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\r\n\r\n\t\tvar qax = a.x, qay = a.y, qaz = a.z, qaw = a.w;\r\n\t\tvar qbx = b.x, qby = b.y, qbz = b.z, qbw = b.w;\r\n\r\n\t\tthis.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\r\n\t\tthis.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\r\n\t\tthis.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\r\n\t\tthis.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyVector3: function ( vector ) {\r\n\r\n\t\tconsole.warn( 'DEPRECATED: Quaternion\\'s .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\r\n\t\treturn vector.applyQuaternion( this );\r\n\r\n\t},\r\n\r\n\tslerp: function ( qb, t ) {\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z, w = this.w;\r\n\r\n\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\r\n\r\n\t\tvar cosHalfTheta = w * qb.w + x * qb.x + y * qb.y + z * qb.z;\r\n\r\n\t\tif ( cosHalfTheta < 0 ) {\r\n\r\n\t\t\tthis.w = -qb.w;\r\n\t\t\tthis.x = -qb.x;\r\n\t\t\tthis.y = -qb.y;\r\n\t\t\tthis.z = -qb.z;\r\n\r\n\t\t\tcosHalfTheta = -cosHalfTheta;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.copy( qb );\r\n\r\n\t\t}\r\n\r\n\t\tif ( cosHalfTheta >= 1.0 ) {\r\n\r\n\t\t\tthis.w = w;\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\t\tthis.z = z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tvar halfTheta = Math.acos( cosHalfTheta );\r\n\t\tvar sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\r\n\r\n\t\tif ( Math.abs( sinHalfTheta ) < 0.001 ) {\r\n\r\n\t\t\tthis.w = 0.5 * ( w + this.w );\r\n\t\t\tthis.x = 0.5 * ( x + this.x );\r\n\t\t\tthis.y = 0.5 * ( y + this.y );\r\n\t\t\tthis.z = 0.5 * ( z + this.z );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\r\n\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\r\n\r\n\t\tthis.w = ( w * ratioA + this.w * ratioB );\r\n\t\tthis.x = ( x * ratioA + this.x * ratioB );\r\n\t\tthis.y = ( y * ratioA + this.y * ratioB );\r\n\t\tthis.z = ( z * ratioA + this.z * ratioB );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( v ) {\r\n\r\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Quaternion( this.x, this.y, this.z, this.w );\r\n\r\n\t}\r\n\r\n} );\r\n\r\nTHREE.Quaternion.slerp = function ( qa, qb, qm, t ) {\r\n\r\n\treturn qm.copy( qa ).slerp( qb, t );\r\n\r\n}\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author egraether / http://egraether.com/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n */\r\n\r\nTHREE.Vector2 = function ( x, y ) {\r\n\r\n\tthis.x = x || 0;\r\n\tthis.y = y || 0;\r\n\r\n};\r\n\r\nTHREE.extend( THREE.Vector2.prototype, {\r\n\r\n\tset: function ( x, y ) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetX: function ( x ) {\r\n\r\n\t\tthis.x = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetY: function ( y ) {\r\n\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\r\n\tsetComponent: function ( index, value ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: this.x = value; break;\r\n\t\t\tcase 1: this.y = value; break;\r\n\t\t\tdefault: throw new Error( \"index is out of range: \" + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetComponent: function ( index ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: return this.x;\r\n\t\t\tcase 1: return this.y;\r\n\t\t\tdefault: throw new Error( \"index is out of range: \" + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcopy: function ( v ) {\r\n\r\n\t\tthis.x = v.x;\r\n\t\tthis.y = v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tadd: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'DEPRECATED: Vector2\\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\treturn this.addVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x += v.x;\r\n\t\tthis.y += v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x + b.x;\r\n\t\tthis.y = a.y + b.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.x += s;\r\n\t\tthis.y += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsub: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'DEPRECATED: Vector2\\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\treturn this.subVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x -= v.x;\r\n\t\tthis.y -= v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x - b.x;\r\n\t\tthis.y = a.y - b.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( s ) {\r\n\r\n\t\tthis.x *= s;\r\n\t\tthis.y *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivideScalar: function ( s ) {\r\n\r\n\t\tif ( s !== 0 ) {\r\n\r\n\t\t\tthis.x /= s;\r\n\t\t\tthis.y /= s;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.set( 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmin: function ( v ) {\r\n\r\n\t\tif ( this.x > v.x ) {\r\n\r\n\t\t\tthis.x = v.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y > v.y ) {\r\n\r\n\t\t\tthis.y = v.y;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmax: function ( v ) {\r\n\r\n\t\tif ( this.x < v.x ) {\r\n\r\n\t\t\tthis.x = v.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y < v.y ) {\r\n\r\n\t\t\tthis.y = v.y;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclamp: function ( min, max ) {\r\n\r\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\r\n\t\tif ( this.x < min.x ) {\r\n\r\n\t\t\tthis.x = min.x;\r\n\r\n\t\t} else if ( this.x > max.x ) {\r\n\r\n\t\t\tthis.x = max.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y < min.y ) {\r\n\r\n\t\t\tthis.y = min.y;\r\n\r\n\t\t} else if ( this.y > max.y ) {\r\n\r\n\t\t\tthis.y = max.y;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnegate: function() {\r\n\r\n\t\treturn this.multiplyScalar( - 1 );\r\n\r\n\t},\r\n\r\n\tdot: function ( v ) {\r\n\r\n\t\treturn this.x * v.x + this.y * v.y;\r\n\r\n\t},\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this.x * this.x + this.y * this.y;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\treturn this.divideScalar( this.length() );\r\n\r\n\t},\r\n\r\n\tdistanceTo: function ( v ) {\r\n\r\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\r\n\r\n\t},\r\n\r\n\tdistanceToSquared: function ( v ) {\r\n\r\n\t\tvar dx = this.x - v.x, dy = this.y - v.y;\r\n\t\treturn dx * dx + dy * dy;\r\n\r\n\t},\r\n\r\n\tsetLength: function ( l ) {\r\n\r\n\t\tvar oldLength = this.length();\r\n\r\n\t\tif ( oldLength !== 0 && l !== oldLength ) {\r\n\r\n\t\t\tthis.multiplyScalar( l / oldLength );\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerp: function ( v, alpha ) {\r\n\r\n\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function( v ) {\r\n\r\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\r\n\r\n\t},\r\n\r\n\ttoArray: function () {\r\n\r\n\t\treturn [ this.x, this.y ];\r\n\t\t\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Vector2( this.x, this.y );\r\n\r\n\t}\r\n\r\n} );\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author *kile / http://kile.stravaganza.org/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author egraether / http://egraether.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.Vector3 = function ( x, y, z ) {\r\n\r\n\tthis.x = x || 0;\r\n\tthis.y = y || 0;\r\n\tthis.z = z || 0;\r\n\r\n};\r\n\r\nTHREE.extend( THREE.Vector3.prototype, {\r\n\r\n\tset: function ( x, y, z ) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.z = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetX: function ( x ) {\r\n\r\n\t\tthis.x = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetY: function ( y ) {\r\n\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetZ: function ( z ) {\r\n\r\n\t\tthis.z = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetComponent: function ( index, value ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: this.x = value; break;\r\n\t\t\tcase 1: this.y = value; break;\r\n\t\t\tcase 2: this.z = value; break;\r\n\t\t\tdefault: throw new Error( \"index is out of range: \" + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetComponent: function ( index ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: return this.x;\r\n\t\t\tcase 1: return this.y;\r\n\t\t\tcase 2: return this.z;\r\n\t\t\tdefault: throw new Error( \"index is out of range: \" + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcopy: function ( v ) {\r\n\r\n\t\tthis.x = v.x;\r\n\t\tthis.y = v.y;\r\n\t\tthis.z = v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tadd: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'DEPRECATED: Vector3\\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\treturn this.addVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x += v.x;\r\n\t\tthis.y += v.y;\r\n\t\tthis.z += v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.x += s;\r\n\t\tthis.y += s;\r\n\t\tthis.z += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x + b.x;\r\n\t\tthis.y = a.y + b.y;\r\n\t\tthis.z = a.z + b.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsub: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'DEPRECATED: Vector3\\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\treturn this.subVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x -= v.x;\r\n\t\tthis.y -= v.y;\r\n\t\tthis.z -= v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x - b.x;\r\n\t\tthis.y = a.y - b.y;\r\n\t\tthis.z = a.z - b.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiply: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'DEPRECATED: Vector3\\'s .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\r\n\t\t\treturn this.multiplyVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x *= v.x;\r\n\t\tthis.y *= v.y;\r\n\t\tthis.z *= v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( s ) {\r\n\r\n\t\tthis.x *= s;\r\n\t\tthis.y *= s;\r\n\t\tthis.z *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x * b.x;\r\n\t\tthis.y = a.y * b.y;\r\n\t\tthis.z = a.z * b.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyMatrix3: function ( m ) {\r\n\r\n\t\tvar x = this.x;\r\n\t\tvar y = this.y;\r\n\t\tvar z = this.z;\r\n\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[0] * x + e[3] * y + e[6] * z;\r\n\t\tthis.y = e[1] * x + e[4] * y + e[7] * z;\r\n\t\tthis.z = e[2] * x + e[5] * y + e[8] * z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function ( m ) {\r\n\r\n\t\t// input: THREE.Matrix4 affine matrix\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[0] * x + e[4] * y + e[8]  * z + e[12];\r\n\t\tthis.y = e[1] * x + e[5] * y + e[9]  * z + e[13];\r\n\t\tthis.z = e[2] * x + e[6] * y + e[10] * z + e[14];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyProjection: function ( m ) {\r\n\r\n\t\t// input: THREE.Matrix4 projection matrix\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\r\n\t\tvar e = m.elements;\r\n\t\tvar d = 1 / ( e[3] * x + e[7] * y + e[11] * z + e[15] ); // perspective divide\r\n\r\n\t\tthis.x = ( e[0] * x + e[4] * y + e[8]  * z + e[12] ) * d;\r\n\t\tthis.y = ( e[1] * x + e[5] * y + e[9]  * z + e[13] ) * d;\r\n\t\tthis.z = ( e[2] * x + e[6] * y + e[10] * z + e[14] ) * d;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyQuaternion: function ( q ) {\r\n\r\n\t\tvar x = this.x;\r\n\t\tvar y = this.y;\r\n\t\tvar z = this.z;\r\n\r\n\t\tvar qx = q.x;\r\n\t\tvar qy = q.y;\r\n\t\tvar qz = q.z;\r\n\t\tvar qw = q.w;\r\n\r\n\t\t// calculate quat * vector\r\n\r\n\t\tvar ix =  qw * x + qy * z - qz * y;\r\n\t\tvar iy =  qw * y + qz * x - qx * z;\r\n\t\tvar iz =  qw * z + qx * y - qy * x;\r\n\t\tvar iw = -qx * x - qy * y - qz * z;\r\n\r\n\t\t// calculate result * inverse quat\r\n\r\n\t\tthis.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\r\n\t\tthis.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\r\n\t\tthis.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyEuler: function () {\r\n\r\n\t\tvar q1 = new THREE.Quaternion();\r\n\r\n\t\treturn function ( v, eulerOrder ) {\r\n\r\n\t\t\tvar quaternion = q1.setFromEuler( v, eulerOrder );\r\n\r\n\t\t\tthis.applyQuaternion( quaternion );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tapplyAxisAngle: function () {\r\n\r\n\t\tvar q1 = new THREE.Quaternion();\r\n\r\n\t\treturn function ( axis, angle ) {\r\n\r\n\t\t\tvar quaternion = q1.setFromAxisAngle( axis, angle );\r\n\r\n\t\t\tthis.applyQuaternion( quaternion );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttransformDirection: function ( m ) {\r\n\r\n\t\t// input: THREE.Matrix4 affine matrix\r\n\t\t// vector interpreted as a direction\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[0] * x + e[4] * y + e[8]  * z;\r\n\t\tthis.y = e[1] * x + e[5] * y + e[9]  * z;\r\n\t\tthis.z = e[2] * x + e[6] * y + e[10] * z;\r\n\r\n\t\tthis.normalize();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivide: function ( v ) {\r\n\r\n\t\tthis.x /= v.x;\r\n\t\tthis.y /= v.y;\r\n\t\tthis.z /= v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivideScalar: function ( s ) {\r\n\r\n\t\tif ( s !== 0 ) {\r\n\r\n\t\t\tthis.x /= s;\r\n\t\t\tthis.y /= s;\r\n\t\t\tthis.z /= s;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.x = 0;\r\n\t\t\tthis.y = 0;\r\n\t\t\tthis.z = 0;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmin: function ( v ) {\r\n\r\n\t\tif ( this.x > v.x ) {\r\n\r\n\t\t\tthis.x = v.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y > v.y ) {\r\n\r\n\t\t\tthis.y = v.y;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.z > v.z ) {\r\n\r\n\t\t\tthis.z = v.z;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmax: function ( v ) {\r\n\r\n\t\tif ( this.x < v.x ) {\r\n\r\n\t\t\tthis.x = v.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y < v.y ) {\r\n\r\n\t\t\tthis.y = v.y;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.z < v.z ) {\r\n\r\n\t\t\tthis.z = v.z;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclamp: function ( min, max ) {\r\n\r\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\r\n\t\tif ( this.x < min.x ) {\r\n\r\n\t\t\tthis.x = min.x;\r\n\r\n\t\t} else if ( this.x > max.x ) {\r\n\r\n\t\t\tthis.x = max.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y < min.y ) {\r\n\r\n\t\t\tthis.y = min.y;\r\n\r\n\t\t} else if ( this.y > max.y ) {\r\n\r\n\t\t\tthis.y = max.y;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.z < min.z ) {\r\n\r\n\t\t\tthis.z = min.z;\r\n\r\n\t\t} else if ( this.z > max.z ) {\r\n\r\n\t\t\tthis.z = max.z;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnegate: function () {\r\n\r\n\t\treturn this.multiplyScalar( - 1 );\r\n\r\n\t},\r\n\r\n\tdot: function ( v ) {\r\n\r\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\r\n\r\n\t},\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\r\n\r\n\t},\r\n\r\n\tlengthManhattan: function () {\r\n\r\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\treturn this.divideScalar( this.length() );\r\n\r\n\t},\r\n\r\n\tsetLength: function ( l ) {\r\n\r\n\t\tvar oldLength = this.length();\r\n\r\n\t\tif ( oldLength !== 0 && l !== oldLength  ) {\r\n\r\n\t\t\tthis.multiplyScalar( l / oldLength );\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerp: function ( v, alpha ) {\r\n\r\n\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\t\tthis.z += ( v.z - this.z ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcross: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'DEPRECATED: Vector3\\'s .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\r\n\t\t\treturn this.crossVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\r\n\t\tthis.x = y * v.z - z * v.y;\r\n\t\tthis.y = z * v.x - x * v.z;\r\n\t\tthis.z = x * v.y - y * v.x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcrossVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.y * b.z - a.z * b.y;\r\n\t\tthis.y = a.z * b.x - a.x * b.z;\r\n\t\tthis.z = a.x * b.y - a.y * b.x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tprojectOnVector: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function( vector ) {\r\n\r\n\t\t\tv1.copy( vector ).normalize();\r\n\t\t\tvar d = this.dot( v1 );\r\n\t\t\treturn this.copy( v1 ).multiplyScalar( d );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tprojectOnPlane: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function( planeNormal ) {\r\n\r\n\t\t\tv1.copy( this ).projectOnVector( planeNormal );\r\n\r\n\t\t\treturn this.sub( v1 );\r\n\r\n\t\t}\r\n\r\n\t}(),\r\n\r\n\treflect: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( vector ) {\r\n\r\n\t\t    v1.copy( this ).projectOnVector( vector ).multiplyScalar( 2 );\r\n\r\n\t\t    return this.subVectors( v1, this );\r\n\r\n\t\t}\r\n\r\n\t}(),\r\n\r\n\tangleTo: function ( v ) {\r\n\r\n\t\tvar theta = this.dot( v ) / ( this.length() * v.length() );\r\n\r\n\t\t// clamp, to handle numerical problems\r\n\r\n\t\treturn Math.acos( THREE.Math.clamp( theta, -1, 1 ) );\r\n\r\n\t},\r\n\r\n\tdistanceTo: function ( v ) {\r\n\r\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\r\n\r\n\t},\r\n\r\n\tdistanceToSquared: function ( v ) {\r\n\r\n\t\tvar dx = this.x - v.x;\r\n\t\tvar dy = this.y - v.y;\r\n\t\tvar dz = this.z - v.z;\r\n\r\n\t\treturn dx * dx + dy * dy + dz * dz;\r\n\r\n\t},\r\n\r\n\tgetPositionFromMatrix: function ( m ) {\r\n\r\n\t\tthis.x = m.elements[12];\r\n\t\tthis.y = m.elements[13];\r\n\t\tthis.z = m.elements[14];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetEulerFromRotationMatrix: function ( m, order ) {\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\t// clamp, to handle numerical problems\r\n\r\n\t\tfunction clamp( x ) {\r\n\r\n\t\t\treturn Math.min( Math.max( x, -1 ), 1 );\r\n\r\n\t\t}\r\n\r\n\t\tvar te = m.elements;\r\n\t\tvar m11 = te[0], m12 = te[4], m13 = te[8];\r\n\t\tvar m21 = te[1], m22 = te[5], m23 = te[9];\r\n\t\tvar m31 = te[2], m32 = te[6], m33 = te[10];\r\n\r\n\t\tif ( order === undefined || order === 'XYZ' ) {\r\n\r\n\t\t\tthis.y = Math.asin( clamp( m13 ) );\r\n\r\n\t\t\tif ( Math.abs( m13 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis.x = Math.atan2( - m23, m33 );\r\n\t\t\t\tthis.z = Math.atan2( - m12, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.x = Math.atan2( m32, m22 );\r\n\t\t\t\tthis.z = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'YXZ' ) {\r\n\r\n\t\t\tthis.x = Math.asin( - clamp( m23 ) );\r\n\r\n\t\t\tif ( Math.abs( m23 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis.y = Math.atan2( m13, m33 );\r\n\t\t\t\tthis.z = Math.atan2( m21, m22 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.y = Math.atan2( - m31, m11 );\r\n\t\t\t\tthis.z = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'ZXY' ) {\r\n\r\n\t\t\tthis.x = Math.asin( clamp( m32 ) );\r\n\r\n\t\t\tif ( Math.abs( m32 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis.y = Math.atan2( - m31, m33 );\r\n\t\t\t\tthis.z = Math.atan2( - m12, m22 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.y = 0;\r\n\t\t\t\tthis.z = Math.atan2( m21, m11 );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'ZYX' ) {\r\n\r\n\t\t\tthis.y = Math.asin( - clamp( m31 ) );\r\n\r\n\t\t\tif ( Math.abs( m31 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis.x = Math.atan2( m32, m33 );\r\n\t\t\t\tthis.z = Math.atan2( m21, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.x = 0;\r\n\t\t\t\tthis.z = Math.atan2( - m12, m22 );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'YZX' ) {\r\n\r\n\t\t\tthis.z = Math.asin( clamp( m21 ) );\r\n\r\n\t\t\tif ( Math.abs( m21 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis.x = Math.atan2( - m23, m22 );\r\n\t\t\t\tthis.y = Math.atan2( - m31, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.x = 0;\r\n\t\t\t\tthis.y = Math.atan2( m13, m33 );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'XZY' ) {\r\n\r\n\t\t\tthis.z = Math.asin( - clamp( m12 ) );\r\n\r\n\t\t\tif ( Math.abs( m12 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis.x = Math.atan2( m32, m22 );\r\n\t\t\t\tthis.y = Math.atan2( m13, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.x = Math.atan2( - m23, m33 );\r\n\t\t\t\tthis.y = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetEulerFromQuaternion: function ( q, order ) {\r\n\r\n\t\t// q is assumed to be normalized\r\n\r\n\t\t// clamp, to handle numerical problems\r\n\r\n\t\tfunction clamp( x ) {\r\n\r\n\t\t\treturn Math.min( Math.max( x, -1 ), 1 );\r\n\r\n\t\t}\r\n\r\n\t\t// http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m\r\n\r\n\t\tvar sqx = q.x * q.x;\r\n\t\tvar sqy = q.y * q.y;\r\n\t\tvar sqz = q.z * q.z;\r\n\t\tvar sqw = q.w * q.w;\r\n\r\n\t\tif ( order === undefined || order === 'XYZ' ) {\r\n\r\n\t\t\tthis.x = Math.atan2( 2 * ( q.x * q.w - q.y * q.z ), ( sqw - sqx - sqy + sqz ) );\r\n\t\t\tthis.y = Math.asin(  clamp( 2 * ( q.x * q.z + q.y * q.w ) ) );\r\n\t\t\tthis.z = Math.atan2( 2 * ( q.z * q.w - q.x * q.y ), ( sqw + sqx - sqy - sqz ) );\r\n\r\n\t\t} else if ( order ===  'YXZ' ) {\r\n\r\n\t\t\tthis.x = Math.asin(  clamp( 2 * ( q.x * q.w - q.y * q.z ) ) );\r\n\t\t\tthis.y = Math.atan2( 2 * ( q.x * q.z + q.y * q.w ), ( sqw - sqx - sqy + sqz ) );\r\n\t\t\tthis.z = Math.atan2( 2 * ( q.x * q.y + q.z * q.w ), ( sqw - sqx + sqy - sqz ) );\r\n\r\n\t\t} else if ( order === 'ZXY' ) {\r\n\r\n\t\t\tthis.x = Math.asin(  clamp( 2 * ( q.x * q.w + q.y * q.z ) ) );\r\n\t\t\tthis.y = Math.atan2( 2 * ( q.y * q.w - q.z * q.x ), ( sqw - sqx - sqy + sqz ) );\r\n\t\t\tthis.z = Math.atan2( 2 * ( q.z * q.w - q.x * q.y ), ( sqw - sqx + sqy - sqz ) );\r\n\r\n\t\t} else if ( order === 'ZYX' ) {\r\n\r\n\t\t\tthis.x = Math.atan2( 2 * ( q.x * q.w + q.z * q.y ), ( sqw - sqx - sqy + sqz ) );\r\n\t\t\tthis.y = Math.asin(  clamp( 2 * ( q.y * q.w - q.x * q.z ) ) );\r\n\t\t\tthis.z = Math.atan2( 2 * ( q.x * q.y + q.z * q.w ), ( sqw + sqx - sqy - sqz ) );\r\n\r\n\t\t} else if ( order === 'YZX' ) {\r\n\r\n\t\t\tthis.x = Math.atan2( 2 * ( q.x * q.w - q.z * q.y ), ( sqw - sqx + sqy - sqz ) );\r\n\t\t\tthis.y = Math.atan2( 2 * ( q.y * q.w - q.x * q.z ), ( sqw + sqx - sqy - sqz ) );\r\n\t\t\tthis.z = Math.asin(  clamp( 2 * ( q.x * q.y + q.z * q.w ) ) );\r\n\r\n\t\t} else if ( order === 'XZY' ) {\r\n\r\n\t\t\tthis.x = Math.atan2( 2 * ( q.x * q.w + q.y * q.z ), ( sqw - sqx + sqy - sqz ) );\r\n\t\t\tthis.y = Math.atan2( 2 * ( q.x * q.z + q.y * q.w ), ( sqw + sqx - sqy - sqz ) );\r\n\t\t\tthis.z = Math.asin(  clamp( 2 * ( q.z * q.w - q.x * q.y ) ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetScaleFromMatrix: function ( m ) {\r\n\r\n\t\tvar sx = this.set( m.elements[0], m.elements[1], m.elements[2] ).length();\r\n\t\tvar sy = this.set( m.elements[4], m.elements[5], m.elements[6] ).length();\r\n\t\tvar sz = this.set( m.elements[8], m.elements[9], m.elements[10] ).length();\r\n\r\n\t\tthis.x = sx;\r\n\t\tthis.y = sy;\r\n\t\tthis.z = sz;\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tequals: function ( v ) {\r\n\r\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\r\n\r\n\t},\r\n\r\n\ttoArray: function () {\r\n\r\n\t\treturn [ this.x, this.y, this.z ];\r\n\t\t\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Vector3( this.x, this.y, this.z );\r\n\r\n\t}\r\n\r\n} );\r\n/**\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author egraether / http://egraether.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.Vector4 = function ( x, y, z, w ) {\r\n\r\n\tthis.x = x || 0;\r\n\tthis.y = y || 0;\r\n\tthis.z = z || 0;\r\n\tthis.w = ( w !== undefined ) ? w : 1;\r\n\r\n};\r\n\r\nTHREE.extend( THREE.Vector4.prototype, {\r\n\r\n\tset: function ( x, y, z, w ) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.z = z;\r\n\t\tthis.w = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetX: function ( x ) {\r\n\r\n\t\tthis.x = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetY: function ( y ) {\r\n\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetZ: function ( z ) {\r\n\r\n\t\tthis.z = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetW: function ( w ) {\r\n\r\n\t\tthis.w = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetComponent: function ( index, value ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: this.x = value; break;\r\n\t\t\tcase 1: this.y = value; break;\r\n\t\t\tcase 2: this.z = value; break;\r\n\t\t\tcase 3: this.w = value; break;\r\n\t\t\tdefault: throw new Error( \"index is out of range: \" + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetComponent: function ( index ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: return this.x;\r\n\t\t\tcase 1: return this.y;\r\n\t\t\tcase 2: return this.z;\r\n\t\t\tcase 3: return this.w;\r\n\t\t\tdefault: throw new Error( \"index is out of range: \" + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcopy: function ( v ) {\r\n\r\n\t\tthis.x = v.x;\r\n\t\tthis.y = v.y;\r\n\t\tthis.z = v.z;\r\n\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tadd: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'DEPRECATED: Vector4\\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\treturn this.addVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x += v.x;\r\n\t\tthis.y += v.y;\r\n\t\tthis.z += v.z;\r\n\t\tthis.w += v.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.x += s;\r\n\t\tthis.y += s;\r\n\t\tthis.z += s;\r\n\t\tthis.w += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x + b.x;\r\n\t\tthis.y = a.y + b.y;\r\n\t\tthis.z = a.z + b.z;\r\n\t\tthis.w = a.w + b.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsub: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'DEPRECATED: Vector4\\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\treturn this.subVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x -= v.x;\r\n\t\tthis.y -= v.y;\r\n\t\tthis.z -= v.z;\r\n\t\tthis.w -= v.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x - b.x;\r\n\t\tthis.y = a.y - b.y;\r\n\t\tthis.z = a.z - b.z;\r\n\t\tthis.w = a.w - b.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( s ) {\r\n\r\n\t\tthis.x *= s;\r\n\t\tthis.y *= s;\r\n\t\tthis.z *= s;\r\n\t\tthis.w *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function ( m ) {\r\n\r\n\t\tvar x = this.x;\r\n\t\tvar y = this.y;\r\n\t\tvar z = this.z;\r\n\t\tvar w = this.w;\r\n\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;\r\n\t\tthis.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;\r\n\t\tthis.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;\r\n\t\tthis.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivideScalar: function ( s ) {\r\n\r\n\t\tif ( s !== 0 ) {\r\n\r\n\t\t\tthis.x /= s;\r\n\t\t\tthis.y /= s;\r\n\t\t\tthis.z /= s;\r\n\t\t\tthis.w /= s;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.x = 0;\r\n\t\t\tthis.y = 0;\r\n\t\t\tthis.z = 0;\r\n\t\t\tthis.w = 1;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetAxisAngleFromQuaternion: function ( q ) {\r\n\r\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\r\n\r\n\t\t// q is assumed to be normalized\r\n\r\n\t\tthis.w = 2 * Math.acos( q.w );\r\n\r\n\t\tvar s = Math.sqrt( 1 - q.w * q.w );\r\n\r\n\t\tif ( s < 0.0001 ) {\r\n\r\n\t\t\t this.x = 1;\r\n\t\t\t this.y = 0;\r\n\t\t\t this.z = 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t this.x = q.x / s;\r\n\t\t\t this.y = q.y / s;\r\n\t\t\t this.z = q.z / s;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetAxisAngleFromRotationMatrix: function ( m ) {\r\n\r\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\tvar angle, x, y, z,\t\t// variables for result\r\n\t\t\tepsilon = 0.01,\t\t// margin to allow for rounding errors\r\n\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\r\n\r\n\t\t\tte = m.elements,\r\n\r\n\t\t\tm11 = te[0], m12 = te[4], m13 = te[8],\r\n\t\t\tm21 = te[1], m22 = te[5], m23 = te[9],\r\n\t\t\tm31 = te[2], m32 = te[6], m33 = te[10];\r\n\r\n\t\tif ( ( Math.abs( m12 - m21 ) < epsilon )\r\n\t\t  && ( Math.abs( m13 - m31 ) < epsilon )\r\n\t\t  && ( Math.abs( m23 - m32 ) < epsilon ) ) {\r\n\r\n\t\t\t// singularity found\r\n\t\t\t// first check for identity matrix which must have +1 for all terms\r\n\t\t\t// in leading diagonal and zero in other terms\r\n\r\n\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 )\r\n\t\t\t  && ( Math.abs( m13 + m31 ) < epsilon2 )\r\n\t\t\t  && ( Math.abs( m23 + m32 ) < epsilon2 )\r\n\t\t\t  && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\r\n\r\n\t\t\t\t// this singularity is identity matrix so angle = 0\r\n\r\n\t\t\t\tthis.set( 1, 0, 0, 0 );\r\n\r\n\t\t\t\treturn this; // zero angle, arbitrary axis\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// otherwise this singularity is angle = 180\r\n\r\n\t\t\tangle = Math.PI;\r\n\r\n\t\t\tvar xx = ( m11 + 1 ) / 2;\r\n\t\t\tvar yy = ( m22 + 1 ) / 2;\r\n\t\t\tvar zz = ( m33 + 1 ) / 2;\r\n\t\t\tvar xy = ( m12 + m21 ) / 4;\r\n\t\t\tvar xz = ( m13 + m31 ) / 4;\r\n\t\t\tvar yz = ( m23 + m32 ) / 4;\r\n\r\n\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) { // m11 is the largest diagonal term\r\n\r\n\t\t\t\tif ( xx < epsilon ) {\r\n\r\n\t\t\t\t\tx = 0;\r\n\t\t\t\t\ty = 0.707106781;\r\n\t\t\t\t\tz = 0.707106781;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tx = Math.sqrt( xx );\r\n\t\t\t\t\ty = xy / x;\r\n\t\t\t\t\tz = xz / x;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( yy > zz ) { // m22 is the largest diagonal term\r\n\r\n\t\t\t\tif ( yy < epsilon ) {\r\n\r\n\t\t\t\t\tx = 0.707106781;\r\n\t\t\t\t\ty = 0;\r\n\t\t\t\t\tz = 0.707106781;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ty = Math.sqrt( yy );\r\n\t\t\t\t\tx = xy / y;\r\n\t\t\t\t\tz = yz / y;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else { // m33 is the largest diagonal term so base result on this\r\n\r\n\t\t\t\tif ( zz < epsilon ) {\r\n\r\n\t\t\t\t\tx = 0.707106781;\r\n\t\t\t\t\ty = 0.707106781;\r\n\t\t\t\t\tz = 0;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tz = Math.sqrt( zz );\r\n\t\t\t\t\tx = xz / z;\r\n\t\t\t\t\ty = yz / z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.set( x, y, z, angle );\r\n\r\n\t\t\treturn this; // return 180 deg rotation\r\n\r\n\t\t}\r\n\r\n\t\t// as we have reached here there are no singularities so we can handle normally\r\n\r\n\t\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )\r\n\t\t\t\t\t\t + ( m13 - m31 ) * ( m13 - m31 )\r\n\t\t\t\t\t\t + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\r\n\r\n\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\r\n\r\n\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\r\n\t\t// caught by singularity test above, but I've left it in just in case\r\n\r\n\t\tthis.x = ( m32 - m23 ) / s;\r\n\t\tthis.y = ( m13 - m31 ) / s;\r\n\t\tthis.z = ( m21 - m12 ) / s;\r\n\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmin: function ( v ) {\r\n\r\n\t\tif ( this.x > v.x ) {\r\n\r\n\t\t\tthis.x = v.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y > v.y ) {\r\n\r\n\t\t\tthis.y = v.y;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.z > v.z ) {\r\n\r\n\t\t\tthis.z = v.z;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.w > v.w ) {\r\n\r\n\t\t\tthis.w = v.w;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmax: function ( v ) {\r\n\r\n\t\tif ( this.x < v.x ) {\r\n\r\n\t\t\tthis.x = v.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y < v.y ) {\r\n\r\n\t\t\tthis.y = v.y;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.z < v.z ) {\r\n\r\n\t\t\tthis.z = v.z;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.w < v.w ) {\r\n\r\n\t\t\tthis.w = v.w;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclamp: function ( min, max ) {\r\n\r\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\r\n\t\tif ( this.x < min.x ) {\r\n\r\n\t\t\tthis.x = min.x;\r\n\r\n\t\t} else if ( this.x > max.x ) {\r\n\r\n\t\t\tthis.x = max.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y < min.y ) {\r\n\r\n\t\t\tthis.y = min.y;\r\n\r\n\t\t} else if ( this.y > max.y ) {\r\n\r\n\t\t\tthis.y = max.y;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.z < min.z ) {\r\n\r\n\t\t\tthis.z = min.z;\r\n\r\n\t\t} else if ( this.z > max.z ) {\r\n\r\n\t\t\tthis.z = max.z;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.w < min.w ) {\r\n\r\n\t\t\tthis.w = min.w;\r\n\r\n\t\t} else if ( this.w > max.w ) {\r\n\r\n\t\t\tthis.w = max.w;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnegate: function() {\r\n\r\n\t\treturn this.multiplyScalar( -1 );\r\n\r\n\t},\r\n\r\n\tdot: function ( v ) {\r\n\r\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\r\n\r\n\t},\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\r\n\r\n\t},\r\n\r\n\tlengthManhattan: function () {\r\n\r\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\treturn this.divideScalar( this.length() );\r\n\r\n\t},\r\n\r\n\tsetLength: function ( l ) {\r\n\r\n\t\tvar oldLength = this.length();\r\n\r\n\t\tif ( oldLength !== 0 && l !== oldLength ) {\r\n\r\n\t\t\tthis.multiplyScalar( l / oldLength );\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerp: function ( v, alpha ) {\r\n\r\n\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\t\tthis.z += ( v.z - this.z ) * alpha;\r\n\t\tthis.w += ( v.w - this.w ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( v ) {\r\n\r\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\r\n\r\n\t},\r\n\r\n\ttoArray: function () {\r\n\r\n\t\treturn [ this.x, this.y, this.z, this.w ];\r\n\t\t\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Vector4( this.x, this.y, this.z, this.w );\r\n\r\n\t}\r\n\r\n} );\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Box2 = function ( min, max ) {\r\n\r\n\tthis.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );\r\n\tthis.max = ( max !== undefined ) ? max : new THREE.Vector2( -Infinity, -Infinity );\r\n\r\n};\r\n\r\nTHREE.extend( THREE.Box2.prototype, {\r\n\r\n\tset: function ( min, max ) {\r\n\r\n\t\tthis.min.copy( min );\r\n\t\tthis.max.copy( max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromPoints: function ( points ) {\r\n\r\n\t\tif ( points.length > 0 ) {\r\n\r\n\t\t\tvar point = points[ 0 ];\r\n\r\n\t\t\tthis.min.copy( point );\r\n\t\t\tthis.max.copy( point );\r\n\r\n\t\t\tfor ( var i = 1, il = points.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tpoint = points[ i ];\r\n\r\n\t\t\t\tif ( point.x < this.min.x ) {\r\n\r\n\t\t\t\t\tthis.min.x = point.x;\r\n\r\n\t\t\t\t} else if ( point.x > this.max.x ) {\r\n\r\n\t\t\t\t\tthis.max.x = point.x;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( point.y < this.min.y ) {\r\n\r\n\t\t\t\t\tthis.min.y = point.y;\r\n\r\n\t\t\t\t} else if ( point.y > this.max.y ) {\r\n\r\n\t\t\t\t\tthis.max.y = point.y;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.makeEmpty();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromCenterAndSize: function() {\r\n\r\n\t\tvar v1 = new THREE.Vector2();\r\n\r\n\t\treturn function ( center, size ) {\r\n\r\n\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\r\n\t\t\tthis.min.copy( center ).sub( halfSize );\r\n\t\t\tthis.max.copy( center ).add( halfSize );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tcopy: function ( box ) {\r\n\r\n\t\tthis.min.copy( box.min );\r\n\t\tthis.max.copy( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeEmpty: function () {\r\n\r\n\t\tthis.min.x = this.min.y = Infinity;\r\n\t\tthis.max.x = this.max.y = -Infinity;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tempty: function () {\r\n\r\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\r\n\r\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\r\n\r\n\t},\r\n\r\n\tcenter: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\r\n\r\n\t},\r\n\r\n\tsize: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\treturn result.subVectors( this.max, this.min );\r\n\r\n\t},\r\n\r\n\texpandByPoint: function ( point ) {\r\n\r\n\t\tthis.min.min( point );\r\n\t\tthis.max.max( point );\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\texpandByVector: function ( vector ) {\r\n\r\n\t\tthis.min.sub( vector );\r\n\t\tthis.max.add( vector );\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\texpandByScalar: function ( scalar ) {\r\n\r\n\t\tthis.min.addScalar( -scalar );\r\n\t\tthis.max.addScalar( scalar );\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\tif ( point.x < this.min.x || point.x > this.max.x ||\r\n\t\t     point.y < this.min.y || point.y > this.max.y ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tcontainsBox: function ( box ) {\r\n\r\n\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\r\n\t\t     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t},\r\n\r\n\tgetParameter: function ( point ) {\r\n\r\n\t\t// This can potentially have a divide by zero if the box\r\n\t\t// has a size dimension of 0.\r\n\r\n\t\treturn new THREE.Vector2(\r\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\r\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\r\n\t\t);\r\n\r\n\t},\r\n\r\n\tisIntersectionBox: function ( box ) {\r\n\r\n\t\t// using 6 splitting planes to rule out intersections.\r\n\r\n\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\r\n\t\t     box.max.y < this.min.y || box.min.y > this.max.y ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tclampPoint: function ( point, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\treturn result.copy( point ).clamp( this.min, this.max );\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function() {\r\n\r\n\t\tvar v1 = new THREE.Vector2();\r\n\r\n\t\treturn function ( point ) {\r\n\r\n\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\r\n\t\t\treturn clampedPoint.sub( point ).length();\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersect: function ( box ) {\r\n\r\n\t\tthis.min.max( box.min );\r\n\t\tthis.max.min( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tunion: function ( box ) {\r\n\r\n\t\tthis.min.min( box.min );\r\n\t\tthis.max.max( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttranslate: function ( offset ) {\r\n\r\n\t\tthis.min.add( offset );\r\n\t\tthis.max.add( offset );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( box ) {\r\n\r\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Box2().copy( this );\r\n\r\n\t}\r\n\r\n} );\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Box3 = function ( min, max ) {\r\n\r\n\tthis.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );\r\n\tthis.max = ( max !== undefined ) ? max : new THREE.Vector3( -Infinity, -Infinity, -Infinity );\r\n\r\n};\r\n\r\nTHREE.extend( THREE.Box3.prototype, {\r\n\r\n\tset: function ( min, max ) {\r\n\r\n\t\tthis.min.copy( min );\r\n\t\tthis.max.copy( max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromPoints: function ( points ) {\r\n\r\n\t\tif ( points.length > 0 ) {\r\n\r\n\t\t\tvar point = points[ 0 ];\r\n\r\n\t\t\tthis.min.copy( point );\r\n\t\t\tthis.max.copy( point );\r\n\r\n\t\t\tfor ( var i = 1, il = points.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tpoint = points[ i ];\r\n\r\n\t\t\t\tif ( point.x < this.min.x ) {\r\n\r\n\t\t\t\t\tthis.min.x = point.x;\r\n\r\n\t\t\t\t} else if ( point.x > this.max.x ) {\r\n\r\n\t\t\t\t\tthis.max.x = point.x;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( point.y < this.min.y ) {\r\n\r\n\t\t\t\t\tthis.min.y = point.y;\r\n\r\n\t\t\t\t} else if ( point.y > this.max.y ) {\r\n\r\n\t\t\t\t\tthis.max.y = point.y;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( point.z < this.min.z ) {\r\n\r\n\t\t\t\t\tthis.min.z = point.z;\r\n\r\n\t\t\t\t} else if ( point.z > this.max.z ) {\r\n\r\n\t\t\t\t\tthis.max.z = point.z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.makeEmpty();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromCenterAndSize: function() {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( center, size ) {\r\n\r\n\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\r\n\r\n\t\t\tthis.min.copy( center ).sub( halfSize );\r\n\t\t\tthis.max.copy( center ).add( halfSize );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tcopy: function ( box ) {\r\n\r\n\t\tthis.min.copy( box.min );\r\n\t\tthis.max.copy( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeEmpty: function () {\r\n\r\n\t\tthis.min.x = this.min.y = this.min.z = Infinity;\r\n\t\tthis.max.x = this.max.y = this.max.z = -Infinity;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tempty: function () {\r\n\r\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\r\n\r\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\r\n\r\n\t},\r\n\r\n\tcenter: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\r\n\r\n\t},\r\n\r\n\tsize: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.subVectors( this.max, this.min );\r\n\r\n\t},\r\n\r\n\texpandByPoint: function ( point ) {\r\n\r\n\t\tthis.min.min( point );\r\n\t\tthis.max.max( point );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\texpandByVector: function ( vector ) {\r\n\r\n\t\tthis.min.sub( vector );\r\n\t\tthis.max.add( vector );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\texpandByScalar: function ( scalar ) {\r\n\r\n\t\tthis.min.addScalar( -scalar );\r\n\t\tthis.max.addScalar( scalar );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\tif ( point.x < this.min.x || point.x > this.max.x ||\r\n\t\t     point.y < this.min.y || point.y > this.max.y ||\r\n\t\t     point.z < this.min.z || point.z > this.max.z ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tcontainsBox: function ( box ) {\r\n\r\n\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\r\n\t\t\t ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&\r\n\t\t\t ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t},\r\n\r\n\tgetParameter: function ( point ) {\r\n\r\n\t\t// This can potentially have a divide by zero if the box\r\n\t\t// has a size dimension of 0.\r\n\r\n\t\treturn new THREE.Vector3(\r\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\r\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\r\n\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\r\n\t\t);\r\n\r\n\t},\r\n\r\n\tisIntersectionBox: function ( box ) {\r\n\r\n\t\t// using 6 splitting planes to rule out intersections.\r\n\r\n\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\r\n\t\t     box.max.y < this.min.y || box.min.y > this.max.y ||\r\n\t\t     box.max.z < this.min.z || box.min.z > this.max.z ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tclampPoint: function ( point, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.copy( point ).clamp( this.min, this.max );\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function() {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( point ) {\r\n\r\n\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\r\n\t\t\treturn clampedPoint.sub( point ).length();\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tgetBoundingSphere: function() {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( optionalTarget ) {\r\n\r\n\t\t\tvar result = optionalTarget || new THREE.Sphere();\r\n\r\n\t\t\tresult.center = this.center();\r\n\t\t\tresult.radius = this.size( v1 ).length() * 0.5;\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersect: function ( box ) {\r\n\r\n\t\tthis.min.max( box.min );\r\n\t\tthis.max.min( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tunion: function ( box ) {\r\n\r\n\t\tthis.min.min( box.min );\r\n\t\tthis.max.max( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function() {\r\n\r\n\t\tvar points = [\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3()\r\n\t\t\t];\r\n\r\n\t\treturn function ( matrix ) {\r\n\r\n\t\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\r\n\t\t\tpoints[0].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\r\n\t\t\tpoints[1].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\r\n\t\t\tpoints[2].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\r\n\t\t\tpoints[3].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\r\n\t\t\tpoints[4].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\r\n\t\t\tpoints[5].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\r\n\t\t\tpoints[6].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\r\n\t\t\tpoints[7].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );  // 111\r\n\r\n\t\t\tthis.makeEmpty();\r\n\t\t\tthis.setFromPoints( points );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslate: function ( offset ) {\r\n\r\n\t\tthis.min.add( offset );\r\n\t\tthis.max.add( offset );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( box ) {\r\n\r\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Box3().copy( this );\r\n\r\n\t}\r\n\r\n} );\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Matrix3 = function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\r\n\r\n\tthis.elements = new Float32Array(9);\r\n\r\n\tthis.set(\r\n\r\n\t\t( n11 !== undefined ) ? n11 : 1, n12 || 0, n13 || 0,\r\n\t\tn21 || 0, ( n22 !== undefined ) ? n22 : 1, n23 || 0,\r\n\t\tn31 || 0, n32 || 0, ( n33 !== undefined ) ? n33 : 1\r\n\r\n\t);\r\n};\r\n\r\nTHREE.extend( THREE.Matrix3.prototype, {\r\n\r\n\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[0] = n11; te[3] = n12; te[6] = n13;\r\n\t\tte[1] = n21; te[4] = n22; te[7] = n23;\r\n\t\tte[2] = n31; te[5] = n32; te[8] = n33;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tidentity: function () {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0,\r\n\t\t\t0, 1, 0,\r\n\t\t\t0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( m ) {\r\n\r\n\t\tvar me = m.elements;\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tme[0], me[3], me[6],\r\n\t\t\tme[1], me[4], me[7],\r\n\t\t\tme[2], me[5], me[8]\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyVector3: function ( vector ) {\r\n\r\n\t\tconsole.warn( 'DEPRECATED: Matrix3\\'s .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\r\n\t\treturn vector.applyMatrix3( this );\r\n\r\n\t},\r\n\r\n\tmultiplyVector3Array: function() {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( a ) {\r\n\r\n\t\t\tfor ( var i = 0, il = a.length; i < il; i += 3 ) {\r\n\r\n\t\t\t\tv1.x = a[ i ];\r\n\t\t\t\tv1.y = a[ i + 1 ];\r\n\t\t\t\tv1.z = a[ i + 2 ];\r\n\r\n\t\t\t\tv1.applyMatrix3(this);\r\n\r\n\t\t\t\ta[ i ]     = v1.x;\r\n\t\t\t\ta[ i + 1 ] = v1.y;\r\n\t\t\t\ta[ i + 2 ] = v1.z;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn a;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmultiplyScalar: function ( s ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[0] *= s; te[3] *= s; te[6] *= s;\r\n\t\tte[1] *= s; te[4] *= s; te[7] *= s;\r\n\t\tte[2] *= s; te[5] *= s; te[8] *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdeterminant: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar a = te[0], b = te[1], c = te[2],\r\n\t\t\td = te[3], e = te[4], f = te[5],\r\n\t\t\tg = te[6], h = te[7], i = te[8];\r\n\r\n\t\treturn a*e*i - a*f*h - b*d*i + b*f*g + c*d*h - c*e*g;\r\n\r\n\t},\r\n\r\n\tgetInverse: function ( matrix, throwOnInvertible ) {\r\n\r\n\t\t// input: THREE.Matrix4\r\n\t\t// ( based on http://code.google.com/p/webgl-mjs/ )\r\n\r\n\t\tvar me = matrix.elements;\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 0 ] =   me[10] * me[5] - me[6] * me[9];\r\n\t\tte[ 1 ] = - me[10] * me[1] + me[2] * me[9];\r\n\t\tte[ 2 ] =   me[6] * me[1] - me[2] * me[5];\r\n\t\tte[ 3 ] = - me[10] * me[4] + me[6] * me[8];\r\n\t\tte[ 4 ] =   me[10] * me[0] - me[2] * me[8];\r\n\t\tte[ 5 ] = - me[6] * me[0] + me[2] * me[4];\r\n\t\tte[ 6 ] =   me[9] * me[4] - me[5] * me[8];\r\n\t\tte[ 7 ] = - me[9] * me[0] + me[1] * me[8];\r\n\t\tte[ 8 ] =   me[5] * me[0] - me[1] * me[4];\r\n\r\n\t\tvar det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];\r\n\r\n\t\t// no inverse\r\n\r\n\t\tif ( det === 0 ) {\r\n\r\n\t\t\tvar msg = \"Matrix3.getInverse(): can't invert matrix, determinant is 0\";\r\n\r\n\t\t\tif ( throwOnInvertible || false ) {\r\n\r\n\t\t\t\tthrow new Error( msg ); \r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.warn( msg );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.identity();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tthis.multiplyScalar( 1.0 / det );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttranspose: function () {\r\n\r\n\t\tvar tmp, m = this.elements;\r\n\r\n\t\ttmp = m[1]; m[1] = m[3]; m[3] = tmp;\r\n\t\ttmp = m[2]; m[2] = m[6]; m[6] = tmp;\r\n\t\ttmp = m[5]; m[5] = m[7]; m[7] = tmp;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetNormalMatrix: function ( m ) {\r\n\r\n\t\t// input: THREE.Matrix4\r\n\r\n\t\tthis.getInverse( m ).transpose();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttransposeIntoArray: function ( r ) {\r\n\r\n\t\tvar m = this.elements;\r\n\r\n\t\tr[ 0 ] = m[ 0 ];\r\n\t\tr[ 1 ] = m[ 3 ];\r\n\t\tr[ 2 ] = m[ 6 ];\r\n\t\tr[ 3 ] = m[ 1 ];\r\n\t\tr[ 4 ] = m[ 4 ];\r\n\t\tr[ 5 ] = m[ 7 ];\r\n\t\tr[ 6 ] = m[ 2 ];\r\n\t\tr[ 7 ] = m[ 5 ];\r\n\t\tr[ 8 ] = m[ 8 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\treturn new THREE.Matrix3(\r\n\r\n\t\t\tte[0], te[3], te[6],\r\n\t\t\tte[1], te[4], te[7],\r\n\t\t\tte[2], te[5], te[8]\r\n\r\n\t\t);\r\n\r\n\t}\r\n\r\n} );\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author jordi_ros / http://plattsoft.com\r\n * @author D1plo1d / http://github.com/D1plo1d\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author timknip / http://www.floorplanner.com/\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\n\r\nTHREE.Matrix4 = function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\r\n\r\n\tvar te = this.elements = new Float32Array( 16 );\r\n\r\n\t// TODO: if n11 is undefined, then just set to identity, otherwise copy all other values into matrix\r\n\t//   we should not support semi specification of Matrix4, it is just weird.\r\n\r\n\tte[0] = ( n11 !== undefined ) ? n11 : 1; te[4] = n12 || 0; te[8] = n13 || 0; te[12] = n14 || 0;\r\n\tte[1] = n21 || 0; te[5] = ( n22 !== undefined ) ? n22 : 1; te[9] = n23 || 0; te[13] = n24 || 0;\r\n\tte[2] = n31 || 0; te[6] = n32 || 0; te[10] = ( n33 !== undefined ) ? n33 : 1; te[14] = n34 || 0;\r\n\tte[3] = n41 || 0; te[7] = n42 || 0; te[11] = n43 || 0; te[15] = ( n44 !== undefined ) ? n44 : 1;\r\n\r\n};\r\n\r\nTHREE.extend( THREE.Matrix4.prototype, {\r\n\r\n\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[0] = n11; te[4] = n12; te[8] = n13; te[12] = n14;\r\n\t\tte[1] = n21; te[5] = n22; te[9] = n23; te[13] = n24;\r\n\t\tte[2] = n31; te[6] = n32; te[10] = n33; te[14] = n34;\r\n\t\tte[3] = n41; te[7] = n42; te[11] = n43; te[15] = n44;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tidentity: function () {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0, 0,\r\n\t\t\t0, 1, 0, 0,\r\n\t\t\t0, 0, 1, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( m ) {\r\n\r\n\t\tvar me = m.elements;\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tme[0], me[4], me[8], me[12],\r\n\t\t\tme[1], me[5], me[9], me[13],\r\n\t\t\tme[2], me[6], me[10], me[14],\r\n\t\t\tme[3], me[7], me[11], me[15]\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetRotationFromEuler: function ( v, order ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar x = v.x, y = v.y, z = v.z;\r\n\t\tvar a = Math.cos( x ), b = Math.sin( x );\r\n\t\tvar c = Math.cos( y ), d = Math.sin( y );\r\n\t\tvar e = Math.cos( z ), f = Math.sin( z );\r\n\r\n\t\tif ( order === undefined || order === 'XYZ' ) {\r\n\r\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\r\n\t\t\tte[0] = c * e;\r\n\t\t\tte[4] = - c * f;\r\n\t\t\tte[8] = d;\r\n\r\n\t\t\tte[1] = af + be * d;\r\n\t\t\tte[5] = ae - bf * d;\r\n\t\t\tte[9] = - b * c;\r\n\r\n\t\t\tte[2] = bf - ae * d;\r\n\t\t\tte[6] = be + af * d;\r\n\t\t\tte[10] = a * c;\r\n\r\n\t\t} else if ( order === 'YXZ' ) {\r\n\r\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\r\n\t\t\tte[0] = ce + df * b;\r\n\t\t\tte[4] = de * b - cf;\r\n\t\t\tte[8] = a * d;\r\n\r\n\t\t\tte[1] = a * f;\r\n\t\t\tte[5] = a * e;\r\n\t\t\tte[9] = - b;\r\n\r\n\t\t\tte[2] = cf * b - de;\r\n\t\t\tte[6] = df + ce * b;\r\n\t\t\tte[10] = a * c;\r\n\r\n\t\t} else if ( order === 'ZXY' ) {\r\n\r\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\r\n\t\t\tte[0] = ce - df * b;\r\n\t\t\tte[4] = - a * f;\r\n\t\t\tte[8] = de + cf * b;\r\n\r\n\t\t\tte[1] = cf + de * b;\r\n\t\t\tte[5] = a * e;\r\n\t\t\tte[9] = df - ce * b;\r\n\r\n\t\t\tte[2] = - a * d;\r\n\t\t\tte[6] = b;\r\n\t\t\tte[10] = a * c;\r\n\r\n\t\t} else if ( order === 'ZYX' ) {\r\n\r\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\r\n\t\t\tte[0] = c * e;\r\n\t\t\tte[4] = be * d - af;\r\n\t\t\tte[8] = ae * d + bf;\r\n\r\n\t\t\tte[1] = c * f;\r\n\t\t\tte[5] = bf * d + ae;\r\n\t\t\tte[9] = af * d - be;\r\n\r\n\t\t\tte[2] = - d;\r\n\t\t\tte[6] = b * c;\r\n\t\t\tte[10] = a * c;\r\n\r\n\t\t} else if ( order === 'YZX' ) {\r\n\r\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\r\n\t\t\tte[0] = c * e;\r\n\t\t\tte[4] = bd - ac * f;\r\n\t\t\tte[8] = bc * f + ad;\r\n\r\n\t\t\tte[1] = f;\r\n\t\t\tte[5] = a * e;\r\n\t\t\tte[9] = - b * e;\r\n\r\n\t\t\tte[2] = - d * e;\r\n\t\t\tte[6] = ad * f + bc;\r\n\t\t\tte[10] = ac - bd * f;\r\n\r\n\t\t} else if ( order === 'XZY' ) {\r\n\r\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\r\n\t\t\tte[0] = c * e;\r\n\t\t\tte[4] = - f;\r\n\t\t\tte[8] = d * e;\r\n\r\n\t\t\tte[1] = ac * f + bd;\r\n\t\t\tte[5] = a * e;\r\n\t\t\tte[9] = ad * f - bc;\r\n\r\n\t\t\tte[2] = bc * f - ad;\r\n\t\t\tte[6] = b * e;\r\n\t\t\tte[10] = bd * f + ac;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetRotationFromQuaternion: function ( q ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar x = q.x, y = q.y, z = q.z, w = q.w;\r\n\t\tvar x2 = x + x, y2 = y + y, z2 = z + z;\r\n\t\tvar xx = x * x2, xy = x * y2, xz = x * z2;\r\n\t\tvar yy = y * y2, yz = y * z2, zz = z * z2;\r\n\t\tvar wx = w * x2, wy = w * y2, wz = w * z2;\r\n\r\n\t\tte[0] = 1 - ( yy + zz );\r\n\t\tte[4] = xy - wz;\r\n\t\tte[8] = xz + wy;\r\n\r\n\t\tte[1] = xy + wz;\r\n\t\tte[5] = 1 - ( xx + zz );\r\n\t\tte[9] = yz - wx;\r\n\r\n\t\tte[2] = xz - wy;\r\n\t\tte[6] = yz + wx;\r\n\t\tte[10] = 1 - ( xx + yy );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlookAt: function() {\r\n\r\n\t\tvar x = new THREE.Vector3();\r\n\t\tvar y = new THREE.Vector3();\r\n\t\tvar z = new THREE.Vector3();\r\n\r\n\t\treturn function ( eye, target, up ) {\r\n\r\n\t\t\tvar te = this.elements;\r\n\r\n\t\t\tz.subVectors( eye, target ).normalize();\r\n\r\n\t\t\tif ( z.length() === 0 ) {\r\n\r\n\t\t\t\tz.z = 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tx.crossVectors( up, z ).normalize();\r\n\r\n\t\t\tif ( x.length() === 0 ) {\r\n\r\n\t\t\t\tz.x += 0.0001;\r\n\t\t\t\tx.crossVectors( up, z ).normalize();\r\n\r\n\t\t\t}\r\n\r\n\t\t\ty.crossVectors( z, x );\r\n\r\n\r\n\t\t\tte[0] = x.x; te[4] = y.x; te[8] = z.x;\r\n\t\t\tte[1] = x.y; te[5] = y.y; te[9] = z.y;\r\n\t\t\tte[2] = x.z; te[6] = y.z; te[10] = z.z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmultiply: function ( m, n ) {\r\n\r\n\t\tif ( n !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\r\n\t\t\treturn this.multiplyMatrices( m, n );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.multiplyMatrices( this, m );\r\n\r\n\t},\r\n\r\n\tmultiplyMatrices: function ( a, b ) {\r\n\r\n\t\tvar ae = a.elements;\r\n\t\tvar be = b.elements;\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];\r\n\t\tvar a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];\r\n\t\tvar a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];\r\n\t\tvar a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];\r\n\r\n\t\tvar b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];\r\n\t\tvar b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];\r\n\t\tvar b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];\r\n\t\tvar b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];\r\n\r\n\t\tte[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\r\n\t\tte[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\r\n\t\tte[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\r\n\t\tte[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\r\n\r\n\t\tte[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\r\n\t\tte[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\r\n\t\tte[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\r\n\t\tte[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\r\n\r\n\t\tte[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\r\n\t\tte[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\r\n\t\tte[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\r\n\t\tte[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\r\n\r\n\t\tte[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\r\n\t\tte[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\r\n\t\tte[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\r\n\t\tte[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyToArray: function ( a, b, r ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tthis.multiplyMatrices( a, b );\r\n\r\n\t\tr[ 0 ] = te[0]; r[ 1 ] = te[1]; r[ 2 ] = te[2]; r[ 3 ] = te[3];\r\n\t\tr[ 4 ] = te[4]; r[ 5 ] = te[5]; r[ 6 ] = te[6]; r[ 7 ] = te[7];\r\n\t\tr[ 8 ]  = te[8]; r[ 9 ]  = te[9]; r[ 10 ] = te[10]; r[ 11 ] = te[11];\r\n\t\tr[ 12 ] = te[12]; r[ 13 ] = te[13]; r[ 14 ] = te[14]; r[ 15 ] = te[15];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( s ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[0] *= s; te[4] *= s; te[8] *= s; te[12] *= s;\r\n\t\tte[1] *= s; te[5] *= s; te[9] *= s; te[13] *= s;\r\n\t\tte[2] *= s; te[6] *= s; te[10] *= s; te[14] *= s;\r\n\t\tte[3] *= s; te[7] *= s; te[11] *= s; te[15] *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyVector3: function ( vector ) {\r\n\r\n\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );\r\n\t\treturn vector.applyProjection( this );\r\n\r\n\t},\r\n\r\n\tmultiplyVector4: function ( vector ) {\r\n\r\n\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\r\n\t\treturn vector.applyMatrix4( this );\r\n\r\n\t},\r\n\r\n\tmultiplyVector3Array: function() {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( a ) {\r\n\r\n\t\t\tfor ( var i = 0, il = a.length; i < il; i += 3 ) {\r\n\r\n\t\t\t\tv1.x = a[ i ];\r\n\t\t\t\tv1.y = a[ i + 1 ];\r\n\t\t\t\tv1.z = a[ i + 2 ];\r\n\r\n\t\t\t\tv1.applyProjection( this );\r\n\r\n\t\t\t\ta[ i ]     = v1.x;\r\n\t\t\t\ta[ i + 1 ] = v1.y;\r\n\t\t\t\ta[ i + 2 ] = v1.z;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn a;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateAxis: function ( v ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar vx = v.x, vy = v.y, vz = v.z;\r\n\r\n\t\tv.x = vx * te[0] + vy * te[4] + vz * te[8];\r\n\t\tv.y = vx * te[1] + vy * te[5] + vz * te[9];\r\n\t\tv.z = vx * te[2] + vy * te[6] + vz * te[10];\r\n\r\n\t\tv.normalize();\r\n\r\n\t\treturn v;\r\n\r\n\t},\r\n\r\n\tcrossVector: function ( a ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar v = new THREE.Vector4();\r\n\r\n\t\tv.x = te[0] * a.x + te[4] * a.y + te[8] * a.z + te[12] * a.w;\r\n\t\tv.y = te[1] * a.x + te[5] * a.y + te[9] * a.z + te[13] * a.w;\r\n\t\tv.z = te[2] * a.x + te[6] * a.y + te[10] * a.z + te[14] * a.w;\r\n\r\n\t\tv.w = ( a.w ) ? te[3] * a.x + te[7] * a.y + te[11] * a.z + te[15] * a.w : 1;\r\n\r\n\t\treturn v;\r\n\r\n\t},\r\n\r\n\tdeterminant: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];\r\n\t\tvar n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];\r\n\t\tvar n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];\r\n\t\tvar n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];\r\n\r\n\t\t//TODO: make this more efficient\r\n\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\r\n\r\n\t\treturn (\r\n\t\t\tn41 * (\r\n\t\t\t\t+n14 * n23 * n32\r\n\t\t\t\t-n13 * n24 * n32\r\n\t\t\t\t-n14 * n22 * n33\r\n\t\t\t\t+n12 * n24 * n33\r\n\t\t\t\t+n13 * n22 * n34\r\n\t\t\t\t-n12 * n23 * n34\r\n\t\t\t) +\r\n\t\t\tn42 * (\r\n\t\t\t\t+n11 * n23 * n34\r\n\t\t\t\t-n11 * n24 * n33\r\n\t\t\t\t+n14 * n21 * n33\r\n\t\t\t\t-n13 * n21 * n34\r\n\t\t\t\t+n13 * n24 * n31\r\n\t\t\t\t-n14 * n23 * n31\r\n\t\t\t) +\r\n\t\t\tn43 * (\r\n\t\t\t\t+n11 * n24 * n32\r\n\t\t\t\t-n11 * n22 * n34\r\n\t\t\t\t-n14 * n21 * n32\r\n\t\t\t\t+n12 * n21 * n34\r\n\t\t\t\t+n14 * n22 * n31\r\n\t\t\t\t-n12 * n24 * n31\r\n\t\t\t) +\r\n\t\t\tn44 * (\r\n\t\t\t\t-n13 * n22 * n31\r\n\t\t\t\t-n11 * n23 * n32\r\n\t\t\t\t+n11 * n22 * n33\r\n\t\t\t\t+n13 * n21 * n32\r\n\t\t\t\t-n12 * n21 * n33\r\n\t\t\t\t+n12 * n23 * n31\r\n\t\t\t)\r\n\r\n\t\t);\r\n\r\n\t},\r\n\r\n\ttranspose: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar tmp;\r\n\r\n\t\ttmp = te[1]; te[1] = te[4]; te[4] = tmp;\r\n\t\ttmp = te[2]; te[2] = te[8]; te[8] = tmp;\r\n\t\ttmp = te[6]; te[6] = te[9]; te[9] = tmp;\r\n\r\n\t\ttmp = te[3]; te[3] = te[12]; te[12] = tmp;\r\n\t\ttmp = te[7]; te[7] = te[13]; te[13] = tmp;\r\n\t\ttmp = te[11]; te[11] = te[14]; te[14] = tmp;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tflattenToArray: function ( flat ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tflat[ 0 ] = te[0]; flat[ 1 ] = te[1]; flat[ 2 ] = te[2]; flat[ 3 ] = te[3];\r\n\t\tflat[ 4 ] = te[4]; flat[ 5 ] = te[5]; flat[ 6 ] = te[6]; flat[ 7 ] = te[7];\r\n\t\tflat[ 8 ] = te[8]; flat[ 9 ] = te[9]; flat[ 10 ] = te[10]; flat[ 11 ] = te[11];\r\n\t\tflat[ 12 ] = te[12]; flat[ 13 ] = te[13]; flat[ 14 ] = te[14]; flat[ 15 ] = te[15];\r\n\r\n\t\treturn flat;\r\n\r\n\t},\r\n\r\n\tflattenToArrayOffset: function( flat, offset ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tflat[ offset ] = te[0];\r\n\t\tflat[ offset + 1 ] = te[1];\r\n\t\tflat[ offset + 2 ] = te[2];\r\n\t\tflat[ offset + 3 ] = te[3];\r\n\r\n\t\tflat[ offset + 4 ] = te[4];\r\n\t\tflat[ offset + 5 ] = te[5];\r\n\t\tflat[ offset + 6 ] = te[6];\r\n\t\tflat[ offset + 7 ] = te[7];\r\n\r\n\t\tflat[ offset + 8 ]  = te[8];\r\n\t\tflat[ offset + 9 ]  = te[9];\r\n\t\tflat[ offset + 10 ] = te[10];\r\n\t\tflat[ offset + 11 ] = te[11];\r\n\r\n\t\tflat[ offset + 12 ] = te[12];\r\n\t\tflat[ offset + 13 ] = te[13];\r\n\t\tflat[ offset + 14 ] = te[14];\r\n\t\tflat[ offset + 15 ] = te[15];\r\n\r\n\t\treturn flat;\r\n\r\n\t},\r\n\r\n\tgetPosition: function() {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function () {\r\n\r\n\t\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .getPosition() has been removed. Use Vector3.getPositionFromMatrix( matrix ) instead.' );\r\n\r\n\t\t\tvar te = this.elements;\r\n\t\t\treturn v1.set( te[12], te[13], te[14] );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tsetPosition: function ( v ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[12] = v.x;\r\n\t\tte[13] = v.y;\r\n\t\tte[14] = v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetInverse: function ( m, throwOnInvertible ) {\r\n\r\n\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\r\n\t\tvar te = this.elements;\r\n\t\tvar me = m.elements;\r\n\r\n\t\tvar n11 = me[0], n12 = me[4], n13 = me[8], n14 = me[12];\r\n\t\tvar n21 = me[1], n22 = me[5], n23 = me[9], n24 = me[13];\r\n\t\tvar n31 = me[2], n32 = me[6], n33 = me[10], n34 = me[14];\r\n\t\tvar n41 = me[3], n42 = me[7], n43 = me[11], n44 = me[15];\r\n\r\n\t\tte[0] = n23*n34*n42 - n24*n33*n42 + n24*n32*n43 - n22*n34*n43 - n23*n32*n44 + n22*n33*n44;\r\n\t\tte[4] = n14*n33*n42 - n13*n34*n42 - n14*n32*n43 + n12*n34*n43 + n13*n32*n44 - n12*n33*n44;\r\n\t\tte[8] = n13*n24*n42 - n14*n23*n42 + n14*n22*n43 - n12*n24*n43 - n13*n22*n44 + n12*n23*n44;\r\n\t\tte[12] = n14*n23*n32 - n13*n24*n32 - n14*n22*n33 + n12*n24*n33 + n13*n22*n34 - n12*n23*n34;\r\n\t\tte[1] = n24*n33*n41 - n23*n34*n41 - n24*n31*n43 + n21*n34*n43 + n23*n31*n44 - n21*n33*n44;\r\n\t\tte[5] = n13*n34*n41 - n14*n33*n41 + n14*n31*n43 - n11*n34*n43 - n13*n31*n44 + n11*n33*n44;\r\n\t\tte[9] = n14*n23*n41 - n13*n24*n41 - n14*n21*n43 + n11*n24*n43 + n13*n21*n44 - n11*n23*n44;\r\n\t\tte[13] = n13*n24*n31 - n14*n23*n31 + n14*n21*n33 - n11*n24*n33 - n13*n21*n34 + n11*n23*n34;\r\n\t\tte[2] = n22*n34*n41 - n24*n32*n41 + n24*n31*n42 - n21*n34*n42 - n22*n31*n44 + n21*n32*n44;\r\n\t\tte[6] = n14*n32*n41 - n12*n34*n41 - n14*n31*n42 + n11*n34*n42 + n12*n31*n44 - n11*n32*n44;\r\n\t\tte[10] = n12*n24*n41 - n14*n22*n41 + n14*n21*n42 - n11*n24*n42 - n12*n21*n44 + n11*n22*n44;\r\n\t\tte[14] = n14*n22*n31 - n12*n24*n31 - n14*n21*n32 + n11*n24*n32 + n12*n21*n34 - n11*n22*n34;\r\n\t\tte[3] = n23*n32*n41 - n22*n33*n41 - n23*n31*n42 + n21*n33*n42 + n22*n31*n43 - n21*n32*n43;\r\n\t\tte[7] = n12*n33*n41 - n13*n32*n41 + n13*n31*n42 - n11*n33*n42 - n12*n31*n43 + n11*n32*n43;\r\n\t\tte[11] = n13*n22*n41 - n12*n23*n41 - n13*n21*n42 + n11*n23*n42 + n12*n21*n43 - n11*n22*n43;\r\n\t\tte[15] = n12*n23*n31 - n13*n22*n31 + n13*n21*n32 - n11*n23*n32 - n12*n21*n33 + n11*n22*n33;\r\n\r\n\t\tvar det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 4 ] + me[ 2 ] * te[ 8 ] + me[ 3 ] * te[ 12 ];\r\n\r\n\t\tif ( det == 0 ) {\r\n\r\n\t\t\tvar msg = \"Matrix4.getInverse(): can't invert matrix, determinant is 0\";\r\n\r\n\t\t\tif ( throwOnInvertible || false ) {\r\n\r\n\t\t\t\tthrow new Error( msg ); \r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.warn( msg );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.identity();\r\n\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tthis.multiplyScalar( 1 / det );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcompose: function() {\r\n\r\n\t\tvar mRotation = new THREE.Matrix4(),\r\n\t\t\tmScale = new THREE.Matrix4();\r\n\t\t\r\n\t\treturn function ( translation, rotation, scale ) {\r\n\r\n\t\t\tvar te = this.elements;\r\n\r\n\t\t\tmRotation.identity();\r\n\t\t\tmRotation.setRotationFromQuaternion( rotation );\r\n\r\n\t\t\tmScale.makeScale( scale.x, scale.y, scale.z );\r\n\r\n\t\t\tthis.multiplyMatrices( mRotation, mScale );\r\n\r\n\t\t\tte[12] = translation.x;\r\n\t\t\tte[13] = translation.y;\r\n\t\t\tte[14] = translation.z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tdecompose: function() {\r\n\r\n\t\tvar x = new THREE.Vector3(),\r\n\t\t\ty = new THREE.Vector3(),\r\n\t\t\tz = new THREE.Vector3(),\r\n\t\t\tmatrix = new THREE.Matrix4();\r\n\r\n\t\treturn function ( translation, rotation, scale ) {\r\n\r\n\t\t\tvar te = this.elements;\r\n\r\n\t\t\t// grab the axis vectors\r\n\t\t\tx.set( te[0], te[1], te[2] );\r\n\t\t\ty.set( te[4], te[5], te[6] );\r\n\t\t\tz.set( te[8], te[9], te[10] );\r\n\r\n\t\t\ttranslation = ( translation instanceof THREE.Vector3 ) ? translation : new THREE.Vector3();\r\n\t\t\trotation = ( rotation instanceof THREE.Quaternion ) ? rotation : new THREE.Quaternion();\r\n\t\t\tscale = ( scale instanceof THREE.Vector3 ) ? scale : new THREE.Vector3();\r\n\r\n\t\t\tscale.x = x.length();\r\n\t\t\tscale.y = y.length();\r\n\t\t\tscale.z = z.length();\r\n\r\n\t\t\ttranslation.x = te[12];\r\n\t\t\ttranslation.y = te[13];\r\n\t\t\ttranslation.z = te[14];\r\n\r\n\t\t\t// scale the rotation part\r\n\r\n\t\t\tmatrix.copy( this );\r\n\r\n\t\t\tmatrix.elements[0] /= scale.x;\r\n\t\t\tmatrix.elements[1] /= scale.x;\r\n\t\t\tmatrix.elements[2] /= scale.x;\r\n\r\n\t\t\tmatrix.elements[4] /= scale.y;\r\n\t\t\tmatrix.elements[5] /= scale.y;\r\n\t\t\tmatrix.elements[6] /= scale.y;\r\n\r\n\t\t\tmatrix.elements[8] /= scale.z;\r\n\t\t\tmatrix.elements[9] /= scale.z;\r\n\t\t\tmatrix.elements[10] /= scale.z;\r\n\r\n\t\t\trotation.setFromRotationMatrix( matrix );\r\n\r\n\t\t\treturn [ translation, rotation, scale ];\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\textractPosition: function ( m ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar me = m.elements;\r\n\r\n\t\tte[12] = me[12];\r\n\t\tte[13] = me[13];\r\n\t\tte[14] = me[14];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\textractRotation: function() {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( m ) {\r\n\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar me = m.elements;\r\n\r\n\t\t\tvar scaleX = 1 / v1.set( me[0], me[1], me[2] ).length();\r\n\t\t\tvar scaleY = 1 / v1.set( me[4], me[5], me[6] ).length();\r\n\t\t\tvar scaleZ = 1 / v1.set( me[8], me[9], me[10] ).length();\r\n\r\n\t\t\tte[0] = me[0] * scaleX;\r\n\t\t\tte[1] = me[1] * scaleX;\r\n\t\t\tte[2] = me[2] * scaleX;\r\n\r\n\t\t\tte[4] = me[4] * scaleY;\r\n\t\t\tte[5] = me[5] * scaleY;\r\n\t\t\tte[6] = me[6] * scaleY;\r\n\r\n\t\t\tte[8] = me[8] * scaleZ;\r\n\t\t\tte[9] = me[9] * scaleZ;\r\n\t\t\tte[10] = me[10] * scaleZ;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslate: function ( v ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar x = v.x, y = v.y, z = v.z;\r\n\r\n\t\tte[12] = te[0] * x + te[4] * y + te[8] * z + te[12];\r\n\t\tte[13] = te[1] * x + te[5] * y + te[9] * z + te[13];\r\n\t\tte[14] = te[2] * x + te[6] * y + te[10] * z + te[14];\r\n\t\tte[15] = te[3] * x + te[7] * y + te[11] * z + te[15];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\trotateX: function ( angle ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar m12 = te[4];\r\n\t\tvar m22 = te[5];\r\n\t\tvar m32 = te[6];\r\n\t\tvar m42 = te[7];\r\n\t\tvar m13 = te[8];\r\n\t\tvar m23 = te[9];\r\n\t\tvar m33 = te[10];\r\n\t\tvar m43 = te[11];\r\n\t\tvar c = Math.cos( angle );\r\n\t\tvar s = Math.sin( angle );\r\n\r\n\t\tte[4] = c * m12 + s * m13;\r\n\t\tte[5] = c * m22 + s * m23;\r\n\t\tte[6] = c * m32 + s * m33;\r\n\t\tte[7] = c * m42 + s * m43;\r\n\r\n\t\tte[8] = c * m13 - s * m12;\r\n\t\tte[9] = c * m23 - s * m22;\r\n\t\tte[10] = c * m33 - s * m32;\r\n\t\tte[11] = c * m43 - s * m42;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\trotateY: function ( angle ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar m11 = te[0];\r\n\t\tvar m21 = te[1];\r\n\t\tvar m31 = te[2];\r\n\t\tvar m41 = te[3];\r\n\t\tvar m13 = te[8];\r\n\t\tvar m23 = te[9];\r\n\t\tvar m33 = te[10];\r\n\t\tvar m43 = te[11];\r\n\t\tvar c = Math.cos( angle );\r\n\t\tvar s = Math.sin( angle );\r\n\r\n\t\tte[0] = c * m11 - s * m13;\r\n\t\tte[1] = c * m21 - s * m23;\r\n\t\tte[2] = c * m31 - s * m33;\r\n\t\tte[3] = c * m41 - s * m43;\r\n\r\n\t\tte[8] = c * m13 + s * m11;\r\n\t\tte[9] = c * m23 + s * m21;\r\n\t\tte[10] = c * m33 + s * m31;\r\n\t\tte[11] = c * m43 + s * m41;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\trotateZ: function ( angle ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar m11 = te[0];\r\n\t\tvar m21 = te[1];\r\n\t\tvar m31 = te[2];\r\n\t\tvar m41 = te[3];\r\n\t\tvar m12 = te[4];\r\n\t\tvar m22 = te[5];\r\n\t\tvar m32 = te[6];\r\n\t\tvar m42 = te[7];\r\n\t\tvar c = Math.cos( angle );\r\n\t\tvar s = Math.sin( angle );\r\n\r\n\t\tte[0] = c * m11 + s * m12;\r\n\t\tte[1] = c * m21 + s * m22;\r\n\t\tte[2] = c * m31 + s * m32;\r\n\t\tte[3] = c * m41 + s * m42;\r\n\r\n\t\tte[4] = c * m12 - s * m11;\r\n\t\tte[5] = c * m22 - s * m21;\r\n\t\tte[6] = c * m32 - s * m31;\r\n\t\tte[7] = c * m42 - s * m41;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\trotateByAxis: function ( axis, angle ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\t// optimize by checking axis\r\n\r\n\t\tif ( axis.x === 1 && axis.y === 0 && axis.z === 0 ) {\r\n\r\n\t\t\treturn this.rotateX( angle );\r\n\r\n\t\t} else if ( axis.x === 0 && axis.y === 1 && axis.z === 0 ) {\r\n\r\n\t\t\treturn this.rotateY( angle );\r\n\r\n\t\t} else if ( axis.x === 0 && axis.y === 0 && axis.z === 1 ) {\r\n\r\n\t\t\treturn this.rotateZ( angle );\r\n\r\n\t\t}\r\n\r\n\t\tvar x = axis.x, y = axis.y, z = axis.z;\r\n\t\tvar n = Math.sqrt(x * x + y * y + z * z);\r\n\r\n\t\tx /= n;\r\n\t\ty /= n;\r\n\t\tz /= n;\r\n\r\n\t\tvar xx = x * x, yy = y * y, zz = z * z;\r\n\t\tvar c = Math.cos( angle );\r\n\t\tvar s = Math.sin( angle );\r\n\t\tvar oneMinusCosine = 1 - c;\r\n\t\tvar xy = x * y * oneMinusCosine;\r\n\t\tvar xz = x * z * oneMinusCosine;\r\n\t\tvar yz = y * z * oneMinusCosine;\r\n\t\tvar xs = x * s;\r\n\t\tvar ys = y * s;\r\n\t\tvar zs = z * s;\r\n\r\n\t\tvar r11 = xx + (1 - xx) * c;\r\n\t\tvar r21 = xy + zs;\r\n\t\tvar r31 = xz - ys;\r\n\t\tvar r12 = xy - zs;\r\n\t\tvar r22 = yy + (1 - yy) * c;\r\n\t\tvar r32 = yz + xs;\r\n\t\tvar r13 = xz + ys;\r\n\t\tvar r23 = yz - xs;\r\n\t\tvar r33 = zz + (1 - zz) * c;\r\n\r\n\t\tvar m11 = te[0], m21 = te[1], m31 = te[2], m41 = te[3];\r\n\t\tvar m12 = te[4], m22 = te[5], m32 = te[6], m42 = te[7];\r\n\t\tvar m13 = te[8], m23 = te[9], m33 = te[10], m43 = te[11];\r\n\r\n\t\tte[0] = r11 * m11 + r21 * m12 + r31 * m13;\r\n\t\tte[1] = r11 * m21 + r21 * m22 + r31 * m23;\r\n\t\tte[2] = r11 * m31 + r21 * m32 + r31 * m33;\r\n\t\tte[3] = r11 * m41 + r21 * m42 + r31 * m43;\r\n\r\n\t\tte[4] = r12 * m11 + r22 * m12 + r32 * m13;\r\n\t\tte[5] = r12 * m21 + r22 * m22 + r32 * m23;\r\n\t\tte[6] = r12 * m31 + r22 * m32 + r32 * m33;\r\n\t\tte[7] = r12 * m41 + r22 * m42 + r32 * m43;\r\n\r\n\t\tte[8] = r13 * m11 + r23 * m12 + r33 * m13;\r\n\t\tte[9] = r13 * m21 + r23 * m22 + r33 * m23;\r\n\t\tte[10] = r13 * m31 + r23 * m32 + r33 * m33;\r\n\t\tte[11] = r13 * m41 + r23 * m42 + r33 * m43;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tscale: function ( v ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar x = v.x, y = v.y, z = v.z;\r\n\r\n\t\tte[0] *= x; te[4] *= y; te[8] *= z;\r\n\t\tte[1] *= x; te[5] *= y; te[9] *= z;\r\n\t\tte[2] *= x; te[6] *= y; te[10] *= z;\r\n\t\tte[3] *= x; te[7] *= y; te[11] *= z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetMaxScaleOnAxis: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];\r\n\t\tvar scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];\r\n\t\tvar scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];\r\n\r\n\t\treturn Math.sqrt( Math.max( scaleXSq, Math.max( scaleYSq, scaleZSq ) ) );\r\n\r\n\t},\r\n\r\n\tmakeTranslation: function ( x, y, z ) {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0, x,\r\n\t\t\t0, 1, 0, y,\r\n\t\t\t0, 0, 1, z,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationX: function ( theta ) {\r\n\r\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0,  0, 0,\r\n\t\t\t0, c, -s, 0,\r\n\t\t\t0, s,  c, 0,\r\n\t\t\t0, 0,  0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationY: function ( theta ) {\r\n\r\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t c, 0, s, 0,\r\n\t\t\t 0, 1, 0, 0,\r\n\t\t\t-s, 0, c, 0,\r\n\t\t\t 0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationZ: function ( theta ) {\r\n\r\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tc, -s, 0, 0,\r\n\t\t\ts,  c, 0, 0,\r\n\t\t\t0,  0, 1, 0,\r\n\t\t\t0,  0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationAxis: function ( axis, angle ) {\r\n\r\n\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\r\n\r\n\t\tvar c = Math.cos( angle );\r\n\t\tvar s = Math.sin( angle );\r\n\t\tvar t = 1 - c;\r\n\t\tvar x = axis.x, y = axis.y, z = axis.z;\r\n\t\tvar tx = t * x, ty = t * y;\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\r\n\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\r\n\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\t return this;\r\n\r\n\t},\r\n\r\n\tmakeScale: function ( x, y, z ) {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tx, 0, 0, 0,\r\n\t\t\t0, y, 0, 0,\r\n\t\t\t0, 0, z, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeFrustum: function ( left, right, bottom, top, near, far ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar x = 2 * near / ( right - left );\r\n\t\tvar y = 2 * near / ( top - bottom );\r\n\r\n\t\tvar a = ( right + left ) / ( right - left );\r\n\t\tvar b = ( top + bottom ) / ( top - bottom );\r\n\t\tvar c = - ( far + near ) / ( far - near );\r\n\t\tvar d = - 2 * far * near / ( far - near );\r\n\r\n\t\tte[0] = x;\tte[4] = 0;\tte[8] = a;\tte[12] = 0;\r\n\t\tte[1] = 0;\tte[5] = y;\tte[9] = b;\tte[13] = 0;\r\n\t\tte[2] = 0;\tte[6] = 0;\tte[10] = c;\tte[14] = d;\r\n\t\tte[3] = 0;\tte[7] = 0;\tte[11] = - 1;\tte[15] = 0;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakePerspective: function ( fov, aspect, near, far ) {\r\n\r\n\t\tvar ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );\r\n\t\tvar ymin = - ymax;\r\n\t\tvar xmin = ymin * aspect;\r\n\t\tvar xmax = ymax * aspect;\r\n\r\n\t\treturn this.makeFrustum( xmin, xmax, ymin, ymax, near, far );\r\n\r\n\t},\r\n\r\n\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar w = right - left;\r\n\t\tvar h = top - bottom;\r\n\t\tvar p = far - near;\r\n\r\n\t\tvar x = ( right + left ) / w;\r\n\t\tvar y = ( top + bottom ) / h;\r\n\t\tvar z = ( far + near ) / p;\r\n\r\n\t\tte[0] = 2 / w;\tte[4] = 0;\tte[8] = 0;\tte[12] = -x;\r\n\t\tte[1] = 0;\tte[5] = 2 / h;\tte[9] = 0;\tte[13] = -y;\r\n\t\tte[2] = 0;\tte[6] = 0;\tte[10] = -2/p;\tte[14] = -z;\r\n\t\tte[3] = 0;\tte[7] = 0;\tte[11] = 0;\tte[15] = 1;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\treturn new THREE.Matrix4(\r\n\r\n\t\t\tte[0], te[4], te[8], te[12],\r\n\t\t\tte[1], te[5], te[9], te[13],\r\n\t\t\tte[2], te[6], te[10], te[14],\r\n\t\t\tte[3], te[7], te[11], te[15]\r\n\r\n\t\t);\r\n\r\n\t}\r\n\r\n} );\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Ray = function ( origin, direction ) {\r\n\r\n\tthis.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();\r\n\tthis.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();\r\n\r\n};\r\n\r\nTHREE.extend( THREE.Ray.prototype, {\r\n\r\n\tset: function ( origin, direction ) {\r\n\r\n\t\tthis.origin.copy( origin );\r\n\t\tthis.direction.copy( direction );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( ray ) {\r\n\r\n\t\tthis.origin.copy( ray.origin );\r\n\t\tthis.direction.copy( ray.direction );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tat: function( t, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\treturn result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\r\n\r\n\t},\r\n\r\n\trecast: function() {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( t ) {\r\n\r\n\t\t\tthis.origin.copy( this.at( t, v1 ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclosestPointToPoint: function ( point, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\tresult.subVectors( point, this.origin );\r\n\t\tvar directionDistance = result.dot( this.direction );\r\n\r\n\t\treturn result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function() {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( point ) {\r\n\r\n\t\t\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\r\n\t\t\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\r\n\r\n\t\t\treturn v1.distanceTo( point );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tisIntersectionSphere: function( sphere ) {\r\n\r\n\t\treturn ( this.distanceToPoint( sphere.center ) <= sphere.radius );\r\n\r\n\t},\r\n\r\n\tisIntersectionPlane: function ( plane ) {\r\n\r\n\t\t// check if the line and plane are non-perpendicular, if they\r\n\t\t// eventually they will intersect.\r\n\t\tvar denominator = plane.normal.dot( this.direction );\r\n\t\tif ( denominator != 0 ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\t// line is coplanar, return origin\r\n\t\tif( plane.distanceToPoint( this.origin ) == 0 ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t},\r\n\r\n\tdistanceToPlane: function ( plane ) {\r\n\r\n\t\tvar denominator = plane.normal.dot( this.direction );\r\n\t\tif ( denominator == 0 ) {\r\n\r\n\t\t\t// line is coplanar, return origin\r\n\t\t\tif( plane.distanceToPoint( this.origin ) == 0 ) {\r\n\r\n\t\t\t\treturn 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Unsure if this is the correct method to handle this case.\r\n\t\t\treturn undefined;\r\n\r\n\t\t}\r\n\r\n\t\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\r\n\r\n\t\treturn t;\r\n\r\n\t},\r\n\r\n\tintersectPlane: function ( plane, optionalTarget ) {\r\n\r\n\t\tvar t = this.distanceToPlane( plane );\r\n\r\n\t\tif ( t === undefined ) {\r\n\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\r\n\t\treturn this.at( t, optionalTarget );\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function ( matrix4 ) {\r\n\r\n\t\tthis.direction.add( this.origin ).applyMatrix4( matrix4 );\r\n\t\tthis.origin.applyMatrix4( matrix4 );\r\n\t\tthis.direction.sub( this.origin );\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tequals: function ( ray ) {\r\n\r\n\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Ray().copy( this );\r\n\r\n\t}\r\n\r\n} );\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Sphere = function ( center, radius ) {\r\n\r\n\tthis.center = ( center !== undefined ) ? center : new THREE.Vector3();\r\n\tthis.radius = ( radius !== undefined ) ? radius : 0;\r\n\r\n};\r\n\r\nTHREE.extend( THREE.Sphere.prototype, {\r\n\r\n\tset: function ( center, radius ) {\r\n\r\n\t\tthis.center.copy( center );\r\n\t\tthis.radius = radius;\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetFromCenterAndPoints: function ( center, points ) {\r\n\r\n\t\tvar maxRadiusSq = 0;\r\n\r\n\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar radiusSq = center.distanceToSquared( points[ i ] );\r\n\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, radiusSq );\r\n\r\n\t\t}\r\n\r\n\t\tthis.center = center;\r\n\t\tthis.radius = Math.sqrt( maxRadiusSq );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( sphere ) {\r\n\r\n\t\tthis.center.copy( sphere.center );\r\n\t\tthis.radius = sphere.radius;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tempty: function () {\r\n\r\n\t\treturn ( this.radius <= 0 );\r\n\r\n\t},\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function ( point ) {\r\n\r\n\t\treturn ( point.distanceTo( this.center ) - this.radius );\r\n\r\n\t},\r\n\r\n\tintersectsSphere: function ( sphere ) {\r\n\r\n\t\tvar radiusSum = this.radius + sphere.radius;\r\n\r\n\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\r\n\r\n\t},\r\n\r\n\tclampPoint: function ( point, optionalTarget ) {\r\n\r\n\t\tvar deltaLengthSq = this.center.distanceToSquared( point );\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\tresult.copy( point );\r\n\r\n\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\r\n\r\n\t\t\tresult.sub( this.center ).normalize();\r\n\t\t\tresult.multiplyScalar( this.radius ).add( this.center );\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t},\r\n\r\n\tgetBoundingBox: function ( optionalTarget ) {\r\n\r\n\t\tvar box = optionalTarget || new THREE.Box3();\r\n\r\n\t\tbox.set( this.center, this.center );\r\n\t\tbox.expandByScalar( this.radius );\r\n\r\n\t\treturn box;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function ( matrix ) {\r\n\r\n\t\tthis.center.applyMatrix4( matrix );\r\n\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttranslate: function ( offset ) {\r\n\r\n\t\tthis.center.add( offset );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( sphere ) {\r\n\r\n\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Sphere().copy( this );\r\n\r\n\t}\r\n\r\n} );\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {\r\n\r\n\tthis.planes = [\r\n\r\n\t\t( p0 !== undefined ) ? p0 : new THREE.Plane(),\r\n\t\t( p1 !== undefined ) ? p1 : new THREE.Plane(),\r\n\t\t( p2 !== undefined ) ? p2 : new THREE.Plane(),\r\n\t\t( p3 !== undefined ) ? p3 : new THREE.Plane(),\r\n\t\t( p4 !== undefined ) ? p4 : new THREE.Plane(),\r\n\t\t( p5 !== undefined ) ? p5 : new THREE.Plane()\r\n\r\n\t];\r\n\r\n};\r\n\r\nTHREE.extend( THREE.Frustum.prototype, {\r\n\r\n\tset: function ( p0, p1, p2, p3, p4, p5 ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\r\n\t\tplanes[0].copy( p0 );\r\n\t\tplanes[1].copy( p1 );\r\n\t\tplanes[2].copy( p2 );\r\n\t\tplanes[3].copy( p3 );\r\n\t\tplanes[4].copy( p4 );\r\n\t\tplanes[5].copy( p5 );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( frustum ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\r\n\t\tfor( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tplanes[i].copy( frustum.planes[i] );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromMatrix: function ( m ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\t\tvar me = m.elements;\r\n\t\tvar me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];\r\n\t\tvar me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];\r\n\t\tvar me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];\r\n\t\tvar me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];\r\n\r\n\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\r\n\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\r\n\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\r\n\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\r\n\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\r\n\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tintersectsObject: function () {\r\n\r\n\t\tvar center = new THREE.Vector3();\r\n\r\n\t\treturn function ( object ) {\r\n\r\n\t\t\t// this method is expanded inlined for performance reasons.\r\n\r\n\t\t\tvar matrix = object.matrixWorld;\r\n\t\t\tvar planes = this.planes;\r\n\t\t\tvar negRadius = - object.geometry.boundingSphere.radius * matrix.getMaxScaleOnAxis();\r\n\r\n\t\t\tcenter.getPositionFromMatrix( matrix );\r\n\r\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\tvar distance = planes[ i ].distanceToPoint( center );\r\n\r\n\t\t\t\tif ( distance < negRadius ) {\r\n\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersectsSphere: function ( sphere ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\t\tvar center = sphere.center;\r\n\t\tvar negRadius = -sphere.radius;\r\n\r\n\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tvar distance = planes[ i ].distanceToPoint( center );\r\n\r\n\t\t\tif ( distance < negRadius ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\r\n\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Frustum().copy( this );\r\n\r\n\t}\r\n\r\n} );\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Plane = function ( normal, constant ) {\r\n\r\n\tthis.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );\r\n\tthis.constant = ( constant !== undefined ) ? constant : 0;\r\n\r\n};\r\n\r\nTHREE.extend( THREE.Plane.prototype, {\r\n\r\n\tset: function ( normal, constant ) {\r\n\r\n\t\tthis.normal.copy( normal );\r\n\t\tthis.constant = constant;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetComponents: function ( x, y, z, w ) {\r\n\r\n\t\tthis.normal.set( x, y, z );\r\n\t\tthis.constant = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\r\n\r\n\t\tthis.normal.copy( normal );\r\n\t\tthis.constant = - point.dot( this.normal );\t// must be this.normal, not normal, as this.normal is normalized\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromCoplanarPoints: function() {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\tvar v2 = new THREE.Vector3();\r\n\r\n\t\treturn function ( a, b, c ) {\r\n\r\n\t\t\tvar normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\r\n\r\n\t\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\r\n\r\n\t\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\r\n\tcopy: function ( plane ) {\r\n\r\n\t\tthis.normal.copy( plane.normal );\r\n\t\tthis.constant = plane.constant;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\t// Note: will lead to a divide by zero if the plane is invalid.\r\n\r\n\t\tvar inverseNormalLength = 1.0 / this.normal.length();\r\n\t\tthis.normal.multiplyScalar( inverseNormalLength );\r\n\t\tthis.constant *= inverseNormalLength;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnegate: function () {\r\n\r\n\t\tthis.constant *= -1;\r\n\t\tthis.normal.negate();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function ( point ) {\r\n\r\n\t\treturn this.normal.dot( point ) + this.constant;\r\n\r\n\t},\r\n\r\n\tdistanceToSphere: function ( sphere ) {\r\n\r\n\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\r\n\r\n\t},\r\n\r\n\tprojectPoint: function ( point, optionalTarget ) {\r\n\r\n\t\treturn this.orthoPoint( point, optionalTarget ).sub( point ).negate();\r\n\r\n\t},\r\n\r\n\torthoPoint: function ( point, optionalTarget ) {\r\n\r\n\t\tvar perpendicularMagnitude = this.distanceToPoint( point );\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );\r\n\r\n\t},\r\n\r\n\tisIntersectionLine: function ( line ) {\r\n\r\n\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\r\n\r\n\t\tvar startSign = this.distanceToPoint( line.start );\r\n\t\tvar endSign = this.distanceToPoint( line.end );\r\n\r\n\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\r\n\r\n\t},\r\n\r\n\tintersectLine: function() {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( line, optionalTarget ) {\r\n\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\t\tvar direction = line.delta( v1 );\r\n\r\n\t\t\tvar denominator = this.normal.dot( direction );\r\n\r\n\t\t\tif ( denominator == 0 ) {\r\n\r\n\t\t\t\t// line is coplanar, return origin\r\n\t\t\t\tif( this.distanceToPoint( line.start ) == 0 ) {\r\n\r\n\t\t\t\t\treturn result.copy( line.start );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Unsure if this is the correct method to handle this case.\r\n\t\t\t\treturn undefined;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\r\n\r\n\t\t\tif( t < 0 || t > 1 ) {\r\n\r\n\t\t\t\treturn undefined;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn result.copy( direction ).multiplyScalar( t ).add( line.start );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\r\n\tcoplanarPoint: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.copy( this.normal ).multiplyScalar( - this.constant );\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function() {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\tvar v2 = new THREE.Vector3();\r\n\r\n\t\treturn function ( matrix, optionalNormalMatrix ) {\r\n\r\n\t\t\t// compute new normal based on theory here:\r\n\t\t\t// http://www.songho.ca/opengl/gl_normaltransform.html\r\n\t\t\toptionalNormalMatrix = optionalNormalMatrix || new THREE.Matrix3().getInverse( matrix ).transpose();\r\n\t\t\tvar newNormal = v1.copy( this.normal ).applyMatrix3( optionalNormalMatrix );\r\n\r\n\t\t\tvar newCoplanarPoint = this.coplanarPoint( v2 );\r\n\t\t\tnewCoplanarPoint.applyMatrix4( matrix );\r\n\r\n\t\t\tthis.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslate: function ( offset ) {\r\n\r\n\t\tthis.constant = this.constant - offset.dot( this.normal );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( plane ) {\r\n\r\n\t\treturn plane.normal.equals( this.normal ) && ( plane.constant == this.constant );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Plane().copy( this );\r\n\r\n\t}\r\n\r\n} );\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Math = {\r\n\r\n\t// Clamp value to range <a, b>\r\n\r\n\tclamp: function ( x, a, b ) {\r\n\r\n\t\treturn ( x < a ) ? a : ( ( x > b ) ? b : x );\r\n\r\n\t},\r\n\r\n\t// Clamp value to range <a, inf)\r\n\r\n\tclampBottom: function ( x, a ) {\r\n\r\n\t\treturn x < a ? a : x;\r\n\r\n\t},\r\n\r\n\t// Linear mapping from range <a1, a2> to range <b1, b2>\r\n\r\n\tmapLinear: function ( x, a1, a2, b1, b2 ) {\r\n\r\n\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\r\n\r\n\t},\r\n\r\n\t// http://en.wikipedia.org/wiki/Smoothstep\r\n\r\n\tsmoothstep: function ( x, min, max ) {\r\n\r\n\t\tif ( x <= min ) return 0;\r\n\t\tif ( x >= max ) return 1;\r\n\r\n\t\tx = ( x - min )/( max - min );\r\n\r\n\t\treturn x*x*(3 - 2*x);\r\n\r\n\t},\r\n\r\n\tsmootherstep: function ( x, min, max ) {\r\n\r\n\t\tif ( x <= min ) return 0;\r\n\t\tif ( x >= max ) return 1;\r\n\r\n\t\tx = ( x - min )/( max - min );\r\n\r\n\t\treturn x*x*x*(x*(x*6 - 15) + 10);\r\n\r\n\t},\r\n\r\n\t// Random float from <0, 1> with 16 bits of randomness\r\n\t// (standard Math.random() creates repetitive patterns when applied over larger space)\r\n\r\n\trandom16: function () {\r\n\r\n\t\treturn ( 65280 * Math.random() + 255 * Math.random() ) / 65535;\r\n\r\n\t},\r\n\r\n\t// Random integer from <low, high> interval\r\n\r\n\trandInt: function ( low, high ) {\r\n\r\n\t\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\r\n\r\n\t},\r\n\r\n\t// Random float from <low, high> interval\r\n\r\n\trandFloat: function ( low, high ) {\r\n\r\n\t\treturn low + Math.random() * ( high - low );\r\n\r\n\t},\r\n\r\n\t// Random float from <-range/2, range/2> interval\r\n\r\n\trandFloatSpread: function ( range ) {\r\n\r\n\t\treturn range * ( 0.5 - Math.random() );\r\n\r\n\t},\r\n\r\n\tsign: function ( x ) {\r\n\r\n\t\treturn ( x < 0 ) ? -1 : ( ( x > 0 ) ? 1 : 0 );\r\n\r\n\t},\r\n\r\n\tdegToRad: function() {\r\n\r\n\t\tvar degreeToRadiansFactor = Math.PI / 180;\r\n\r\n\t\treturn function ( degrees ) {\r\n\r\n\t\t\treturn degrees * degreeToRadiansFactor;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tradToDeg: function() {\r\n\r\n\t\tvar radianToDegreesFactor = 180 / Math.PI;\r\n\r\n\t\treturn function ( radians ) {\r\n\r\n\t\t\treturn radians * radianToDegreesFactor;\r\n\r\n\t\t};\r\n\r\n\t}()\r\n\r\n};\r\n/**\r\n * Spline from Tween.js, slightly optimized (and trashed)\r\n * http://sole.github.com/tween.js/examples/05_spline.html\r\n *\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Spline = function ( points ) {\r\n\r\n\tthis.points = points;\r\n\r\n\tvar c = [], v3 = { x: 0, y: 0, z: 0 },\r\n\tpoint, intPoint, weight, w2, w3,\r\n\tpa, pb, pc, pd;\r\n\r\n\tthis.initFromArray = function( a ) {\r\n\r\n\t\tthis.points = [];\r\n\r\n\t\tfor ( var i = 0; i < a.length; i++ ) {\r\n\r\n\t\t\tthis.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.getPoint = function ( k ) {\r\n\r\n\t\tpoint = ( this.points.length - 1 ) * k;\r\n\t\tintPoint = Math.floor( point );\r\n\t\tweight = point - intPoint;\r\n\r\n\t\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\r\n\t\tc[ 1 ] = intPoint;\r\n\t\tc[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;\r\n\t\tc[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;\r\n\r\n\t\tpa = this.points[ c[ 0 ] ];\r\n\t\tpb = this.points[ c[ 1 ] ];\r\n\t\tpc = this.points[ c[ 2 ] ];\r\n\t\tpd = this.points[ c[ 3 ] ];\r\n\r\n\t\tw2 = weight * weight;\r\n\t\tw3 = weight * w2;\r\n\r\n\t\tv3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );\r\n\t\tv3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );\r\n\t\tv3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );\r\n\r\n\t\treturn v3;\r\n\r\n\t};\r\n\r\n\tthis.getControlPointsArray = function () {\r\n\r\n\t\tvar i, p, l = this.points.length,\r\n\t\t\tcoords = [];\r\n\r\n\t\tfor ( i = 0; i < l; i ++ ) {\r\n\r\n\t\t\tp = this.points[ i ];\r\n\t\t\tcoords[ i ] = [ p.x, p.y, p.z ];\r\n\r\n\t\t}\r\n\r\n\t\treturn coords;\r\n\r\n\t};\r\n\r\n\t// approximate length by summing linear segments\r\n\r\n\tthis.getLength = function ( nSubDivisions ) {\r\n\r\n\t\tvar i, index, nSamples, position,\r\n\t\t\tpoint = 0, intPoint = 0, oldIntPoint = 0,\r\n\t\t\toldPosition = new THREE.Vector3(),\r\n\t\t\ttmpVec = new THREE.Vector3(),\r\n\t\t\tchunkLengths = [],\r\n\t\t\ttotalLength = 0;\r\n\r\n\t\t// first point has 0 length\r\n\r\n\t\tchunkLengths[ 0 ] = 0;\r\n\r\n\t\tif ( !nSubDivisions ) nSubDivisions = 100;\r\n\r\n\t\tnSamples = this.points.length * nSubDivisions;\r\n\r\n\t\toldPosition.copy( this.points[ 0 ] );\r\n\r\n\t\tfor ( i = 1; i < nSamples; i ++ ) {\r\n\r\n\t\t\tindex = i / nSamples;\r\n\r\n\t\t\tposition = this.getPoint( index );\r\n\t\t\ttmpVec.copy( position );\r\n\r\n\t\t\ttotalLength += tmpVec.distanceTo( oldPosition );\r\n\r\n\t\t\toldPosition.copy( position );\r\n\r\n\t\t\tpoint = ( this.points.length - 1 ) * index;\r\n\t\t\tintPoint = Math.floor( point );\r\n\r\n\t\t\tif ( intPoint != oldIntPoint ) {\r\n\r\n\t\t\t\tchunkLengths[ intPoint ] = totalLength;\r\n\t\t\t\toldIntPoint = intPoint;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// last point ends with total length\r\n\r\n\t\tchunkLengths[ chunkLengths.length ] = totalLength;\r\n\r\n\t\treturn { chunks: chunkLengths, total: totalLength };\r\n\r\n\t};\r\n\r\n\tthis.reparametrizeByArcLength = function ( samplingCoef ) {\r\n\r\n\t\tvar i, j,\r\n\t\t\tindex, indexCurrent, indexNext,\r\n\t\t\tlinearDistance, realDistance,\r\n\t\t\tsampling, position,\r\n\t\t\tnewpoints = [],\r\n\t\t\ttmpVec = new THREE.Vector3(),\r\n\t\t\tsl = this.getLength();\r\n\r\n\t\tnewpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );\r\n\r\n\t\tfor ( i = 1; i < this.points.length; i++ ) {\r\n\r\n\t\t\t//tmpVec.copy( this.points[ i - 1 ] );\r\n\t\t\t//linearDistance = tmpVec.distanceTo( this.points[ i ] );\r\n\r\n\t\t\trealDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];\r\n\r\n\t\t\tsampling = Math.ceil( samplingCoef * realDistance / sl.total );\r\n\r\n\t\t\tindexCurrent = ( i - 1 ) / ( this.points.length - 1 );\r\n\t\t\tindexNext = i / ( this.points.length - 1 );\r\n\r\n\t\t\tfor ( j = 1; j < sampling - 1; j++ ) {\r\n\r\n\t\t\t\tindex = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );\r\n\r\n\t\t\t\tposition = this.getPoint( index );\r\n\t\t\t\tnewpoints.push( tmpVec.copy( position ).clone() );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tnewpoints.push( tmpVec.copy( this.points[ i ] ).clone() );\r\n\r\n\t\t}\r\n\r\n\t\tthis.points = newpoints;\r\n\r\n\t};\r\n\r\n\t// Catmull-Rom\r\n\r\n\tfunction interpolate( p0, p1, p2, p3, t, t2, t3 ) {\r\n\r\n\t\tvar v0 = ( p2 - p0 ) * 0.5,\r\n\t\t\tv1 = ( p3 - p1 ) * 0.5;\r\n\r\n\t\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\r\n\t};\r\n\r\n};\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Triangle = function ( a, b, c ) {\r\n\r\n\tthis.a = ( a !== undefined ) ? a : new THREE.Vector3();\r\n\tthis.b = ( b !== undefined ) ? b : new THREE.Vector3();\r\n\tthis.c = ( c !== undefined ) ? c : new THREE.Vector3();\r\n\r\n};\r\n\r\nTHREE.Triangle.normal = function() {\r\n\r\n\tvar v0 = new THREE.Vector3();\r\n\r\n\treturn function( a, b, c, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\tresult.subVectors( c, b );\r\n\t\tv0.subVectors( a, b );\r\n\t\tresult.cross( v0 );\r\n\r\n\t\tvar resultLengthSq = result.lengthSq();\r\n\t\tif( resultLengthSq > 0 ) {\r\n\r\n\t\t\treturn result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn result.set( 0, 0, 0 );\r\n\r\n\t};\r\n\r\n}();\r\n\r\n// static/instance method to calculate barycoordinates\r\n// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\r\nTHREE.Triangle.barycoordFromPoint = function() {\r\n\r\n\tvar v0 = new THREE.Vector3(),\r\n\t\tv1 = new THREE.Vector3(),\r\n\t\tv2 = new THREE.Vector3();\r\n\r\n\treturn function ( point, a, b, c, optionalTarget ) {\r\n\r\n\t\tv0.subVectors( c, a );\r\n\t\tv1.subVectors( b, a );\r\n\t\tv2.subVectors( point, a );\r\n\r\n\t\tvar dot00 = v0.dot( v0 );\r\n\t\tvar dot01 = v0.dot( v1 );\r\n\t\tvar dot02 = v0.dot( v2 );\r\n\t\tvar dot11 = v1.dot( v1 );\r\n\t\tvar dot12 = v1.dot( v2 );\r\n\r\n\t\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\t// colinear or singular triangle\r\n\t\tif( denom == 0 ) {\r\n\t\t\t// arbitrary location outside of triangle?\r\n\t\t\t// not sure if this is the best idea, maybe should be returning undefined\r\n\t\t\treturn result.set( -2, -1, -1 );\r\n\t\t}\r\n\r\n\t\tvar invDenom = 1 / denom;\r\n\t\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\r\n\t\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\r\n\r\n\t\t// barycoordinates must always sum to 1\r\n\t\treturn result.set( 1 - u - v, v, u );\r\n\r\n\t};\r\n\r\n}();\r\n\r\nTHREE.Triangle.containsPoint = function() {\r\n\r\n\tvar v1 = new THREE.Vector3();\r\n\r\n\treturn function ( point, a, b, c ) {\r\n\r\n\t\tvar result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );\r\n\r\n\t\treturn ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );\r\n\r\n\t};\r\n\r\n}();\r\n\r\nTHREE.extend( THREE.Triangle.prototype, {\r\n\r\n\tconstructor: THREE.Triangle,\r\n\r\n\tset: function ( a, b, c ) {\r\n\r\n\t\tthis.a.copy( a );\r\n\t\tthis.b.copy( b );\r\n\t\tthis.c.copy( c );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\r\n\r\n\t\tthis.a.copy( points[i0] );\r\n\t\tthis.b.copy( points[i1] );\r\n\t\tthis.c.copy( points[i2] );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( triangle ) {\r\n\r\n\t\tthis.a.copy( triangle.a );\r\n\t\tthis.b.copy( triangle.b );\r\n\t\tthis.c.copy( triangle.c );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tarea: function() {\r\n\r\n\t\tvar v0 = new THREE.Vector3();\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function () {\r\n\r\n\t\t\tv0.subVectors( this.c, this.b );\r\n\t\t\tv1.subVectors( this.a, this.b );\r\n\r\n\t\t\treturn v0.cross( v1 ).length() * 0.5;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmidpoint: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\r\n\r\n\t},\r\n\r\n\tnormal: function ( optionalTarget ) {\r\n\r\n\t\treturn THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );\r\n\r\n\t},\r\n\r\n\tplane: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Plane();\r\n\r\n\t\treturn result.setFromCoplanarPoints( this.a, this.b, this.c );\r\n\r\n\t},\r\n\r\n\tbarycoordFromPoint: function ( point, optionalTarget ) {\r\n\r\n\t\treturn THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );\r\n\r\n\t},\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\treturn THREE.Triangle.containsPoint( point, this.a, this.b, this.c );\r\n\r\n\t},\r\n\r\n\tequals: function ( triangle ) {\r\n\r\n\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Triangle().copy( this );\r\n\r\n\t}\r\n\r\n} );\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Vertex = function ( v ) {\r\n\r\n\tconsole.warn( 'THREE.Vertex has been DEPRECATED. Use THREE.Vector3 instead.')\r\n\treturn v;\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.UV = function ( u, v ) {\r\n\r\n\tconsole.warn( 'THREE.UV has been DEPRECATED. Use THREE.Vector2 instead.')\r\n\treturn new THREE.Vector2( u, v );\r\n\r\n};\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Clock = function ( autoStart ) {\r\n\r\n\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\r\n\r\n\tthis.startTime = 0;\r\n\tthis.oldTime = 0;\r\n\tthis.elapsedTime = 0;\r\n\r\n\tthis.running = false;\r\n\r\n};\r\n\r\nTHREE.extend( THREE.Clock.prototype, {\r\n\r\n\tstart: function () {\r\n\r\n\t\tthis.startTime = window.performance !== undefined && window.performance.now !== undefined\r\n\t\t\t\t\t? window.performance.now()\r\n\t\t\t\t\t: Date.now();\r\n\r\n\t\tthis.oldTime = this.startTime;\r\n\t\tthis.running = true;\r\n\t},\r\n\r\n\tstop: function () {\r\n\r\n\t\tthis.getElapsedTime();\r\n\t\tthis.running = false;\r\n\r\n\t},\r\n\r\n\tgetElapsedTime: function () {\r\n\r\n\t\tthis.getDelta();\r\n\t\treturn this.elapsedTime;\r\n\r\n\t},\r\n\r\n\tgetDelta: function () {\r\n\r\n\t\tvar diff = 0;\r\n\r\n\t\tif ( this.autoStart && ! this.running ) {\r\n\r\n\t\t\tthis.start();\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.running ) {\r\n\r\n\t\t\tvar newTime = window.performance !== undefined && window.performance.now !== undefined\r\n\t\t\t\t\t? window.performance.now()\r\n\t\t\t\t\t: Date.now();\r\n\r\n\t\t\tdiff = 0.001 * ( newTime - this.oldTime );\r\n\t\t\tthis.oldTime = newTime;\r\n\r\n\t\t\tthis.elapsedTime += diff;\r\n\r\n\t\t}\r\n\r\n\t\treturn diff;\r\n\r\n\t}\r\n\r\n} );\r\n/**\r\n * https://github.com/mrdoob/eventdispatcher.js/\r\n */\r\n\r\nTHREE.EventDispatcher = function () {\r\n\r\n\tvar listeners = {};\r\n\r\n\tthis.addEventListener = function ( type, listener ) {\r\n\r\n\t\tif ( listeners[ type ] === undefined ) {\r\n\r\n\t\t\tlisteners[ type ] = [];\r\n\r\n\t\t}\r\n\r\n\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\r\n\r\n\t\t\tlisteners[ type ].push( listener );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.removeEventListener = function ( type, listener ) {\r\n\r\n\t\tvar index = listeners[ type ].indexOf( listener );\r\n\r\n\t\tif ( index !== - 1 ) {\r\n\r\n\t\t\tlisteners[ type ].splice( index, 1 );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.dispatchEvent = function ( event ) {\r\n\r\n\t\tvar listenerArray = listeners[ event.type ];\r\n\r\n\t\tif ( listenerArray !== undefined ) {\r\n\r\n\t\t\tevent.target = this;\r\n\r\n\t\t\tfor ( var i = 0, l = listenerArray.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tlistenerArray[ i ].call( this, event );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author bhouston / http://exocortex.com/\r\n */\r\n\r\n( function ( THREE ) {\r\n\r\n\tTHREE.Raycaster = function ( origin, direction, near, far ) {\r\n\r\n\t\tthis.ray = new THREE.Ray( origin, direction );\r\n\r\n\t\t// normalized ray.direction required for accurate distance calculations\r\n\t\tif( this.ray.direction.lengthSq() > 0 ) {\r\n\r\n\t\t\tthis.ray.direction.normalize();\r\n\r\n\t\t}\r\n\r\n\t\tthis.near = near || 0;\r\n\t\tthis.far = far || Infinity;\r\n\r\n\t};\r\n\r\n\tvar sphere = new THREE.Sphere();\r\n\tvar localRay = new THREE.Ray();\r\n\tvar facePlane = new THREE.Plane();\r\n\tvar intersectPoint = new THREE.Vector3();\r\n\tvar matrixPosition = new THREE.Vector3();\r\n\r\n\tvar inverseMatrix = new THREE.Matrix4();\r\n\r\n\tvar descSort = function ( a, b ) {\r\n\r\n\t\treturn a.distance - b.distance;\r\n\r\n\t};\r\n\r\n\tvar intersectObject = function ( object, raycaster, intersects ) {\r\n\r\n\t\tif ( object instanceof THREE.Particle ) {\r\n\r\n\t\t\tmatrixPosition.getPositionFromMatrix( object.matrixWorld );\r\n\t\t\tvar distance = raycaster.ray.distanceToPoint( matrixPosition );\r\n\r\n\t\t\tif ( distance > object.scale.x ) {\r\n\r\n\t\t\t\treturn intersects;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tintersects.push( {\r\n\r\n\t\t\t\tdistance: distance,\r\n\t\t\t\tpoint: object.position,\r\n\t\t\t\tface: null,\r\n\t\t\t\tobject: object\r\n\r\n\t\t\t} );\r\n\r\n\t\t} else if ( object instanceof THREE.Mesh ) {\r\n\r\n\t\t\t// Checking boundingSphere distance to ray\r\n\t\t\tmatrixPosition.getPositionFromMatrix( object.matrixWorld );\r\n\t\t\tsphere.set(\r\n\t\t\t\tmatrixPosition,\r\n\t\t\t\tobject.geometry.boundingSphere.radius * object.matrixWorld.getMaxScaleOnAxis() );\r\n\r\n\t\t\tif ( ! raycaster.ray.isIntersectionSphere( sphere ) ) {\r\n\r\n\t\t\t\treturn intersects;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Checking faces\r\n\r\n\t\t\tvar geometry = object.geometry;\r\n\t\t\tvar vertices = geometry.vertices;\r\n\r\n\t\t\tvar isFaceMaterial = object.material instanceof THREE.MeshFaceMaterial;\r\n\t\t\tvar objectMaterials = isFaceMaterial === true ? object.material.materials : null;\r\n\r\n\t\t\tvar side = object.material.side;\r\n\r\n\t\t\tvar a, b, c, d;\r\n\t\t\tvar precision = raycaster.precision;\r\n\r\n\t\t\tobject.matrixRotationWorld.extractRotation( object.matrixWorld );\r\n\r\n\t\t\tinverseMatrix.getInverse( object.matrixWorld );\r\n\r\n\t\t\tlocalRay.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\r\n\t\t\tfor ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tvar face = geometry.faces[ f ];\r\n\r\n\t\t\t\tvar material = isFaceMaterial === true ? objectMaterials[ face.materialIndex ] : object.material;\r\n\r\n\t\t\t\tif ( material === undefined ) continue;\r\n\r\n\t\t\t\tfacePlane.setFromNormalAndCoplanarPoint( face.normal, vertices[face.a] );\r\n\r\n\t\t\t\tvar planeDistance = localRay.distanceToPlane( facePlane );\r\n\r\n\t\t\t\t// bail if raycaster and plane are parallel\r\n\t\t\t\tif ( Math.abs( planeDistance ) < precision ) continue;\r\n\r\n\t\t\t\t// if negative distance, then plane is behind raycaster\r\n\t\t\t\tif ( planeDistance < 0 ) continue;\r\n\r\n\t\t\t\t// check if we hit the wrong side of a single sided face\r\n\t\t\t\tside = material.side;\r\n\t\t\t\tif( side !== THREE.DoubleSide ) {\r\n\r\n\t\t\t\t\tvar planeSign = localRay.direction.dot( facePlane.normal );\r\n\r\n\t\t\t\t\tif( ! ( side === THREE.FrontSide ? planeSign < 0 : planeSign > 0 ) ) continue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// this can be done using the planeDistance from localRay because localRay wasn't normalized, but ray was\r\n\t\t\t\tif ( planeDistance < raycaster.near || planeDistance > raycaster.far ) continue;\r\n\r\n\t\t\t\tintersectPoint = localRay.at( planeDistance, intersectPoint ); // passing in intersectPoint avoids a copy\r\n\r\n\t\t\t\tif ( face instanceof THREE.Face3 ) {\r\n\r\n\t\t\t\t\ta = vertices[ face.a ];\r\n\t\t\t\t\tb = vertices[ face.b ];\r\n\t\t\t\t\tc = vertices[ face.c ];\r\n\r\n\t\t\t\t\tif ( ! THREE.Triangle.containsPoint( intersectPoint, a, b, c ) ) continue;\r\n\r\n\t\t\t\t} else if ( face instanceof THREE.Face4 ) {\r\n\r\n\t\t\t\t\ta = vertices[ face.a ];\r\n\t\t\t\t\tb = vertices[ face.b ];\r\n\t\t\t\t\tc = vertices[ face.c ];\r\n\t\t\t\t\td = vertices[ face.d ];\r\n\r\n\t\t\t\t\tif ( ( ! THREE.Triangle.containsPoint( intersectPoint, a, b, d ) ) &&\r\n\t\t\t\t\t\t ( ! THREE.Triangle.containsPoint( intersectPoint, b, c, d ) ) ) continue;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// This is added because if we call out of this if/else group when none of the cases\r\n\t\t\t\t\t//    match it will add a point to the intersection list erroneously.\r\n\t\t\t\t\tthrow Error( \"face type not supported\" );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tintersects.push( {\r\n\r\n\t\t\t\t\tdistance: planeDistance,\t// this works because the original ray was normalized, and the transformed localRay wasn't\r\n\t\t\t\t\tpoint: raycaster.ray.at( planeDistance ),\r\n\t\t\t\t\tface: face,\r\n\t\t\t\t\tfaceIndex: f,\r\n\t\t\t\t\tobject: object\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar intersectDescendants = function ( object, raycaster, intersects ) {\r\n\r\n\t\tvar descendants = object.getDescendants();\r\n\r\n\t\tfor ( var i = 0, l = descendants.length; i < l; i ++ ) {\r\n\r\n\t\t\tintersectObject( descendants[ i ], raycaster, intersects );\r\n\r\n\t\t}\r\n\t};\r\n\r\n\t//\r\n\r\n\tTHREE.Raycaster.prototype.precision = 0.0001;\r\n\r\n\tTHREE.Raycaster.prototype.set = function ( origin, direction ) {\r\n\r\n\t\tthis.ray.set( origin, direction );\r\n\r\n\t\t// normalized ray.direction required for accurate distance calculations\r\n\t\tif( this.ray.direction.length() > 0 ) {\r\n\r\n\t\t\tthis.ray.direction.normalize();\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tTHREE.Raycaster.prototype.intersectObject = function ( object, recursive ) {\r\n\r\n\t\tvar intersects = [];\r\n\r\n\t\tif ( recursive === true ) {\r\n\r\n\t\t\tintersectDescendants( object, this, intersects );\r\n\r\n\t\t}\r\n\r\n\t\tintersectObject( object, this, intersects );\r\n\r\n\t\tintersects.sort( descSort );\r\n\r\n\t\treturn intersects;\r\n\r\n\t};\r\n\r\n\tTHREE.Raycaster.prototype.intersectObjects = function ( objects, recursive ) {\r\n\r\n\t\tvar intersects = [];\r\n\r\n\t\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\r\n\r\n\t\t\tintersectObject( objects[ i ], this, intersects );\r\n\r\n\t\t\tif ( recursive === true ) {\r\n\r\n\t\t\t\tintersectDescendants( objects[ i ], this, intersects );\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tintersects.sort( descSort );\r\n\r\n\t\treturn intersects;\r\n\r\n\t};\r\n\r\n}( THREE ) );\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Object3D = function () {\r\n\r\n\tthis.id = THREE.Object3DIdCount ++;\r\n\r\n\tthis.name = '';\r\n\tthis.properties = {};\r\n\r\n\tthis.parent = undefined;\r\n\tthis.children = [];\r\n\r\n\tthis.up = new THREE.Vector3( 0, 1, 0 );\r\n\r\n\tthis.position = new THREE.Vector3();\r\n\tthis.rotation = new THREE.Vector3();\r\n\tthis.eulerOrder = THREE.Object3D.defaultEulerOrder;\r\n\tthis.scale = new THREE.Vector3( 1, 1, 1 );\r\n\r\n\tthis.renderDepth = null;\r\n\r\n\tthis.rotationAutoUpdate = true;\r\n\r\n\tthis.matrix = new THREE.Matrix4();\r\n\tthis.matrixWorld = new THREE.Matrix4();\r\n\tthis.matrixRotationWorld = new THREE.Matrix4();\r\n\r\n\tthis.matrixAutoUpdate = true;\r\n\tthis.matrixWorldNeedsUpdate = true;\r\n\r\n\tthis.quaternion = new THREE.Quaternion();\r\n\tthis.useQuaternion = false;\r\n\r\n\tthis.visible = true;\r\n\r\n\tthis.castShadow = false;\r\n\tthis.receiveShadow = false;\r\n\r\n\tthis.frustumCulled = true;\r\n\r\n\tthis._vector = new THREE.Vector3();\r\n\r\n};\r\n\r\n\r\nTHREE.Object3D.prototype = {\r\n\r\n\tconstructor: THREE.Object3D,\r\n\r\n\tapplyMatrix: function ( matrix ) {\r\n\r\n\t\tthis.matrix.multiplyMatrices( matrix, this.matrix );\r\n\r\n\t\tthis.scale.getScaleFromMatrix( this.matrix );\r\n\r\n\t\tvar mat = new THREE.Matrix4().extractRotation( this.matrix );\r\n\t\tthis.rotation.setEulerFromRotationMatrix( mat, this.eulerOrder );\r\n\r\n\t\tthis.position.getPositionFromMatrix( this.matrix );\r\n\r\n\t},\r\n\r\n\ttranslate: function ( distance, axis ) {\r\n\r\n\t\tthis.matrix.rotateAxis( axis );\r\n\t\tthis.position.add( axis.multiplyScalar( distance ) );\r\n\r\n\t},\r\n\r\n\ttranslateX: function ( distance ) {\r\n\r\n\t\tthis.translate( distance, this._vector.set( 1, 0, 0 ) );\r\n\r\n\t},\r\n\r\n\ttranslateY: function ( distance ) {\r\n\r\n\t\tthis.translate( distance, this._vector.set( 0, 1, 0 ) );\r\n\r\n\t},\r\n\r\n\ttranslateZ: function ( distance ) {\r\n\r\n\t\tthis.translate( distance, this._vector.set( 0, 0, 1 ) );\r\n\r\n\t},\r\n\r\n\tlocalToWorld: function ( vector ) {\r\n\r\n\t\treturn vector.applyMatrix4( this.matrixWorld );\r\n\r\n\t},\r\n\r\n\tworldToLocal: function ( vector ) {\r\n\r\n\t\treturn vector.applyMatrix4( THREE.Object3D.__m1.getInverse( this.matrixWorld ) );\r\n\r\n\t},\r\n\r\n\tlookAt: function ( vector ) {\r\n\r\n\t\t// TODO: Add hierarchy support.\r\n\r\n\t\tthis.matrix.lookAt( vector, this.position, this.up );\r\n\r\n\t\tif ( this.rotationAutoUpdate ) {\r\n\r\n\t\t\tif ( this.useQuaternion === false )  {\r\n\r\n\t\t\t\tthis.rotation.setEulerFromRotationMatrix( this.matrix, this.eulerOrder );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.quaternion.copy( this.matrix.decompose()[ 1 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tadd: function ( object ) {\r\n\r\n\t\tif ( object === this ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Object3D.add: An object can\\'t be added as a child of itself.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( object instanceof THREE.Object3D ) {\r\n\r\n\t\t\tif ( object.parent !== undefined ) {\r\n\r\n\t\t\t\tobject.parent.remove( object );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobject.parent = this;\r\n\t\t\tthis.children.push( object );\r\n\r\n\t\t\t// add to scene\r\n\r\n\t\t\tvar scene = this;\r\n\r\n\t\t\twhile ( scene.parent !== undefined ) {\r\n\r\n\t\t\t\tscene = scene.parent;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( scene !== undefined && scene instanceof THREE.Scene )  {\r\n\r\n\t\t\t\tscene.__addObject( object );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tremove: function ( object ) {\r\n\r\n\t\tvar index = this.children.indexOf( object );\r\n\r\n\t\tif ( index !== - 1 ) {\r\n\r\n\t\t\tobject.parent = undefined;\r\n\t\t\tthis.children.splice( index, 1 );\r\n\r\n\t\t\t// remove from scene\r\n\r\n\t\t\tvar scene = this;\r\n\r\n\t\t\twhile ( scene.parent !== undefined ) {\r\n\r\n\t\t\t\tscene = scene.parent;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( scene !== undefined && scene instanceof THREE.Scene ) {\r\n\r\n\t\t\t\tscene.__removeObject( object );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ttraverse: function ( callback ) {\r\n\r\n\t\tcallback( this );\r\n\r\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n\t\t\tthis.children[ i ].traverse( callback );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetChildByName: function ( name, recursive ) {\r\n\r\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar child = this.children[ i ];\r\n\r\n\t\t\tif ( child.name === name ) {\r\n\r\n\t\t\t\treturn child;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( recursive === true ) {\r\n\r\n\t\t\t\tchild = child.getChildByName( name, recursive );\r\n\r\n\t\t\t\tif ( child !== undefined ) {\r\n\r\n\t\t\t\t\treturn child;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn undefined;\r\n\r\n\t},\r\n\r\n\tgetDescendants: function ( array ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\r\n\t\tArray.prototype.push.apply( array, this.children );\r\n\r\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n\t\t\tthis.children[ i ].getDescendants( array );\r\n\r\n\t\t}\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tupdateMatrix: function () {\r\n\r\n\t\tthis.matrix.setPosition( this.position );\r\n\r\n\t\tif ( this.useQuaternion === false )  {\r\n\r\n\t\t\tthis.matrix.setRotationFromEuler( this.rotation, this.eulerOrder );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.matrix.setRotationFromQuaternion( this.quaternion );\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.scale.x !== 1 || this.scale.y !== 1 || this.scale.z !== 1 ) {\r\n\r\n\t\t\tthis.matrix.scale( this.scale );\r\n\r\n\t\t}\r\n\r\n\t\tthis.matrixWorldNeedsUpdate = true;\r\n\r\n\t},\r\n\r\n\tupdateMatrixWorld: function ( force ) {\r\n\r\n\t\tif ( this.matrixAutoUpdate === true ) this.updateMatrix();\r\n\r\n\t\tif ( this.matrixWorldNeedsUpdate === true || force === true ) {\r\n\r\n\t\t\tif ( this.parent === undefined ) {\r\n\r\n\t\t\t\tthis.matrixWorld.copy( this.matrix );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.matrixWorldNeedsUpdate = false;\r\n\r\n\t\t\tforce = true;\r\n\r\n\t\t}\r\n\r\n\t\t// update children\r\n\r\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n\t\t\tthis.children[ i ].updateMatrixWorld( force );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tclone: function ( object ) {\r\n\r\n\t\tif ( object === undefined ) object = new THREE.Object3D();\r\n\r\n\t\tobject.name = this.name;\r\n\r\n\t\tobject.up.copy( this.up );\r\n\r\n\t\tobject.position.copy( this.position );\r\n\t\tif ( object.rotation instanceof THREE.Vector3 ) object.rotation.copy( this.rotation ); // because of Sprite madness\r\n\t\tobject.eulerOrder = this.eulerOrder;\r\n\t\tobject.scale.copy( this.scale );\r\n\r\n\t\tobject.renderDepth = this.renderDepth;\r\n\r\n\t\tobject.rotationAutoUpdate = this.rotationAutoUpdate;\r\n\r\n\t\tobject.matrix.copy( this.matrix );\r\n\t\tobject.matrixWorld.copy( this.matrixWorld );\r\n\t\tobject.matrixRotationWorld.copy( this.matrixRotationWorld );\r\n\r\n\t\tobject.matrixAutoUpdate = this.matrixAutoUpdate;\r\n\t\tobject.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;\r\n\r\n\t\tobject.quaternion.copy( this.quaternion );\r\n\t\tobject.useQuaternion = this.useQuaternion;\r\n\r\n\t\tobject.visible = this.visible;\r\n\r\n\t\tobject.castShadow = this.castShadow;\r\n\t\tobject.receiveShadow = this.receiveShadow;\r\n\r\n\t\tobject.frustumCulled = this.frustumCulled;\r\n\r\n\t\tfor ( var i = 0; i < this.children.length; i ++ ) {\r\n\r\n\t\t\tvar child = this.children[ i ];\r\n\t\t\tobject.add( child.clone() );\r\n\r\n\t\t}\r\n\r\n\t\treturn object;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Object3D.__m1 = new THREE.Matrix4();\r\nTHREE.Object3D.defaultEulerOrder = 'XYZ',\r\n\r\nTHREE.Object3DIdCount = 0;\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author julianwa / https://github.com/julianwa\r\n */\r\n\r\nTHREE.Projector = function () {\r\n\r\n\tvar _object, _objectCount, _objectPool = [], _objectPoolLength = 0,\r\n\t_vertex, _vertexCount, _vertexPool = [], _vertexPoolLength = 0,\r\n\t_face, _face3Count, _face3Pool = [], _face3PoolLength = 0,\r\n\t_face4Count, _face4Pool = [], _face4PoolLength = 0,\r\n\t_line, _lineCount, _linePool = [], _linePoolLength = 0,\r\n\t_particle, _particleCount, _particlePool = [], _particlePoolLength = 0,\r\n\r\n\t_renderData = { objects: [], sprites: [], lights: [], elements: [] },\r\n\r\n\t_vector3 = new THREE.Vector3(),\r\n\t_vector4 = new THREE.Vector4(),\r\n\r\n\t_clipBox = new THREE.Box3( new THREE.Vector3( -1, -1, -1 ), new THREE.Vector3( 1, 1, 1 ) ),\r\n\t_boundingBox = new THREE.Box3(),\r\n\t_points3 = new Array( 3 ),\r\n\t_points4 = new Array( 4 ),\r\n\r\n\t_viewMatrix = new THREE.Matrix4(),\r\n\t_viewProjectionMatrix = new THREE.Matrix4(),\r\n\r\n\t_modelMatrix,\r\n\t_modelViewProjectionMatrix = new THREE.Matrix4(),\r\n\r\n\t_normalMatrix = new THREE.Matrix3(),\r\n\t_normalViewMatrix = new THREE.Matrix3(),\r\n\r\n\t_centroid = new THREE.Vector3(),\r\n\r\n\t_frustum = new THREE.Frustum(),\r\n\r\n\t_clippedVertex1PositionScreen = new THREE.Vector4(),\r\n\t_clippedVertex2PositionScreen = new THREE.Vector4();\r\n\r\n\tthis.projectVector = function ( vector, camera ) {\r\n\r\n\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\r\n\r\n\t\t_viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\r\n\r\n\t\treturn vector.applyProjection( _viewProjectionMatrix );\r\n\r\n\t};\r\n\r\n\tthis.unprojectVector = function ( vector, camera ) {\r\n\r\n\t\tcamera.projectionMatrixInverse.getInverse( camera.projectionMatrix );\r\n\r\n\t\t_viewProjectionMatrix.multiplyMatrices( camera.matrixWorld, camera.projectionMatrixInverse );\r\n\r\n\t\treturn vector.applyProjection( _viewProjectionMatrix );\r\n\r\n\t};\r\n\r\n\tthis.pickingRay = function ( vector, camera ) {\r\n\r\n\t\t// set two vectors with opposing z values\r\n\t\tvector.z = -1.0;\r\n\t\tvar end = new THREE.Vector3( vector.x, vector.y, 1.0 );\r\n\r\n\t\tthis.unprojectVector( vector, camera );\r\n\t\tthis.unprojectVector( end, camera );\r\n\r\n\t\t// find direction from vector to end\r\n\t\tend.sub( vector ).normalize();\r\n\r\n\t\treturn new THREE.Raycaster( vector, end );\r\n\r\n\t};\r\n\r\n\tvar projectGraph = function ( root, sortObjects ) {\r\n\r\n\t\t_objectCount = 0;\r\n\r\n\t\t_renderData.objects.length = 0;\r\n\t\t_renderData.sprites.length = 0;\r\n\t\t_renderData.lights.length = 0;\r\n\r\n\t\tvar projectObject = function ( parent ) {\r\n\r\n\t\t\tfor ( var c = 0, cl = parent.children.length; c < cl; c ++ ) {\r\n\r\n\t\t\t\tvar object = parent.children[ c ];\r\n\r\n\t\t\t\tif ( object.visible === false ) continue;\r\n\r\n\t\t\t\tif ( object instanceof THREE.Light ) {\r\n\r\n\t\t\t\t\t_renderData.lights.push( object );\r\n\r\n\t\t\t\t} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line ) {\r\n\r\n\t\t\t\t\tif ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {\r\n\r\n\t\t\t\t\t\t_object = getNextObjectInPool();\r\n\t\t\t\t\t\t_object.object = object;\r\n\r\n\t\t\t\t\t\tif ( object.renderDepth !== null ) {\r\n\r\n\t\t\t\t\t\t\t_object.z = object.renderDepth;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t_vector3.getPositionFromMatrix( object.matrixWorld );\r\n\t\t\t\t\t\t\t_vector3.applyProjection( _viewProjectionMatrix );\r\n\t\t\t\t\t\t\t_object.z = _vector3.z;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t_renderData.objects.push( _object );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( object instanceof THREE.Sprite || object instanceof THREE.Particle ) {\r\n\r\n\t\t\t\t\t_object = getNextObjectInPool();\r\n\t\t\t\t\t_object.object = object;\r\n\r\n\t\t\t\t\t// TODO: Find an elegant and performant solution and remove this dupe code.\r\n\r\n\t\t\t\t\tif ( object.renderDepth !== null ) {\r\n\r\n\t\t\t\t\t\t_object.z = object.renderDepth;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t_vector3.getPositionFromMatrix( object.matrixWorld );\r\n\t\t\t\t\t\t_vector3.applyProjection( _viewProjectionMatrix );\r\n\t\t\t\t\t\t_object.z = _vector3.z;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t_renderData.sprites.push( _object );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t_object = getNextObjectInPool();\r\n\t\t\t\t\t_object.object = object;\r\n\r\n\t\t\t\t\tif ( object.renderDepth !== null ) {\r\n\r\n\t\t\t\t\t\t_object.z = object.renderDepth;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t_vector3.getPositionFromMatrix( object.matrixWorld );\r\n\t\t\t\t\t\t_vector3.applyProjection( _viewProjectionMatrix );\r\n\t\t\t\t\t\t_object.z = _vector3.z;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t_renderData.objects.push( _object );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tprojectObject( object );\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tprojectObject( root );\r\n\r\n\t\tif ( sortObjects === true ) _renderData.objects.sort( painterSort );\r\n\r\n\t\treturn _renderData;\r\n\r\n\t};\r\n\r\n\tthis.projectScene = function ( scene, camera, sortObjects, sortElements ) {\r\n\r\n\t\tvar visible = false,\r\n\t\to, ol, v, vl, f, fl, n, nl, c, cl, u, ul, object,\r\n\t\tgeometry, vertices, faces, face, faceVertexNormals, faceVertexUvs, uvs,\r\n\t\tv1, v2, v3, v4, isFaceMaterial, objectMaterials;\r\n\r\n\t\t_face3Count = 0;\r\n\t\t_face4Count = 0;\r\n\t\t_lineCount = 0;\r\n\t\t_particleCount = 0;\r\n\r\n\t\t_renderData.elements.length = 0;\r\n\r\n\t\tscene.updateMatrixWorld();\r\n\r\n\t\tif ( camera.parent === undefined ) camera.updateMatrixWorld();\r\n\r\n\t\t_viewMatrix.copy( camera.matrixWorldInverse.getInverse( camera.matrixWorld ) );\r\n\t\t_viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, _viewMatrix );\r\n\r\n\t\t_normalViewMatrix.getInverse( _viewMatrix );\r\n\t\t_normalViewMatrix.transpose();\r\n\r\n\t\t_frustum.setFromMatrix( _viewProjectionMatrix );\r\n\r\n\t\t_renderData = projectGraph( scene, sortObjects );\r\n\r\n\t\tfor ( o = 0, ol = _renderData.objects.length; o < ol; o ++ ) {\r\n\r\n\t\t\tobject = _renderData.objects[ o ].object;\r\n\r\n\t\t\t_modelMatrix = object.matrixWorld;\r\n\r\n\t\t\t_vertexCount = 0;\r\n\r\n\t\t\tif ( object instanceof THREE.Mesh ) {\r\n\r\n\t\t\t\tgeometry = object.geometry;\r\n\r\n\t\t\t\tvertices = geometry.vertices;\r\n\t\t\t\tfaces = geometry.faces;\r\n\t\t\t\tfaceVertexUvs = geometry.faceVertexUvs;\r\n\r\n\t\t\t\t_normalMatrix.getInverse( _modelMatrix );\r\n\t\t\t\t_normalMatrix.transpose();\r\n\r\n\t\t\t\tisFaceMaterial = object.material instanceof THREE.MeshFaceMaterial;\r\n\t\t\t\tobjectMaterials = isFaceMaterial === true ? object.material : null;\r\n\r\n\t\t\t\tfor ( v = 0, vl = vertices.length; v < vl; v ++ ) {\r\n\r\n\t\t\t\t\t_vertex = getNextVertexInPool();\r\n\r\n\t\t\t\t\t_vertex.positionWorld.copy( vertices[ v ] ).applyMatrix4( _modelMatrix );\r\n\t\t\t\t\t_vertex.positionScreen.copy( _vertex.positionWorld ).applyMatrix4( _viewProjectionMatrix );\r\n\r\n\t\t\t\t\t_vertex.positionScreen.x /= _vertex.positionScreen.w;\r\n\t\t\t\t\t_vertex.positionScreen.y /= _vertex.positionScreen.w;\r\n\t\t\t\t\t_vertex.positionScreen.z /= _vertex.positionScreen.w;\r\n\r\n\t\t\t\t\t_vertex.visible = ! ( _vertex.positionScreen.x < -1 || _vertex.positionScreen.x > 1 ||\r\n\t\t\t\t\t\t\t      _vertex.positionScreen.y < -1 || _vertex.positionScreen.y > 1 ||\r\n\t\t\t\t\t\t\t      _vertex.positionScreen.z < -1 || _vertex.positionScreen.z > 1 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( f = 0, fl = faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\tface = faces[ f ];\r\n\r\n\t\t\t\t\tvar material = isFaceMaterial === true\r\n\t\t\t\t\t\t? objectMaterials.materials[ face.materialIndex ]\r\n\t\t\t\t\t\t: object.material;\r\n\r\n\t\t\t\t\tif ( material === undefined ) continue;\r\n\r\n\t\t\t\t\tvar side = material.side;\r\n\r\n\t\t\t\t\tif ( face instanceof THREE.Face3 ) {\r\n\r\n\t\t\t\t\t\tv1 = _vertexPool[ face.a ];\r\n\t\t\t\t\t\tv2 = _vertexPool[ face.b ];\r\n\t\t\t\t\t\tv3 = _vertexPool[ face.c ];\r\n\r\n\t\t\t\t\t\t_points3[ 0 ] = v1.positionScreen;\r\n\t\t\t\t\t\t_points3[ 1 ] = v2.positionScreen;\r\n\t\t\t\t\t\t_points3[ 2 ] = v3.positionScreen;\r\n\r\n\t\t\t\t\t\tif ( v1.visible === true || v2.visible === true || v3.visible === true ||\r\n\t\t\t\t\t\t\t_clipBox.isIntersectionBox( _boundingBox.setFromPoints( _points3 ) ) ) {\r\n\r\n\t\t\t\t\t\t\tvisible = ( ( v3.positionScreen.x - v1.positionScreen.x ) * ( v2.positionScreen.y - v1.positionScreen.y ) -\r\n\t\t\t\t\t\t\t\t( v3.positionScreen.y - v1.positionScreen.y ) * ( v2.positionScreen.x - v1.positionScreen.x ) ) < 0;\r\n\r\n\t\t\t\t\t\t\tif ( side === THREE.DoubleSide || visible === ( side === THREE.FrontSide ) ) {\r\n\r\n\t\t\t\t\t\t\t\t_face = getNextFace3InPool();\r\n\r\n\t\t\t\t\t\t\t\t_face.v1.copy( v1 );\r\n\t\t\t\t\t\t\t\t_face.v2.copy( v2 );\r\n\t\t\t\t\t\t\t\t_face.v3.copy( v3 );\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( face instanceof THREE.Face4 ) {\r\n\r\n\t\t\t\t\t\tv1 = _vertexPool[ face.a ];\r\n\t\t\t\t\t\tv2 = _vertexPool[ face.b ];\r\n\t\t\t\t\t\tv3 = _vertexPool[ face.c ];\r\n\t\t\t\t\t\tv4 = _vertexPool[ face.d ];\r\n\r\n\t\t\t\t\t\t_points4[ 0 ] = v1.positionScreen;\r\n\t\t\t\t\t\t_points4[ 1 ] = v2.positionScreen;\r\n\t\t\t\t\t\t_points4[ 2 ] = v3.positionScreen;\r\n\t\t\t\t\t\t_points4[ 3 ] = v4.positionScreen;\r\n\r\n\t\t\t\t\t\tif ( v1.visible === true || v2.visible === true || v3.visible === true || v4.visible === true ||\r\n\t\t\t\t\t\t\t_clipBox.isIntersectionBox( _boundingBox.setFromPoints( _points4 ) ) ) {\r\n\r\n\t\t\t\t\t\t\tvisible = ( v4.positionScreen.x - v1.positionScreen.x ) * ( v2.positionScreen.y - v1.positionScreen.y ) -\r\n\t\t\t\t\t\t\t\t( v4.positionScreen.y - v1.positionScreen.y ) * ( v2.positionScreen.x - v1.positionScreen.x ) < 0 ||\r\n\t\t\t\t\t\t\t\t( v2.positionScreen.x - v3.positionScreen.x ) * ( v4.positionScreen.y - v3.positionScreen.y ) -\r\n\t\t\t\t\t\t\t\t( v2.positionScreen.y - v3.positionScreen.y ) * ( v4.positionScreen.x - v3.positionScreen.x ) < 0;\r\n\r\n\r\n\t\t\t\t\t\t\tif ( side === THREE.DoubleSide || visible === ( side === THREE.FrontSide ) ) {\r\n\r\n\t\t\t\t\t\t\t\t_face = getNextFace4InPool();\r\n\r\n\t\t\t\t\t\t\t\t_face.v1.copy( v1 );\r\n\t\t\t\t\t\t\t\t_face.v2.copy( v2 );\r\n\t\t\t\t\t\t\t\t_face.v3.copy( v3 );\r\n\t\t\t\t\t\t\t\t_face.v4.copy( v4 );\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t_face.normalModel.copy( face.normal );\r\n\r\n\t\t\t\t\tif ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {\r\n\r\n\t\t\t\t\t\t_face.normalModel.negate();\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t_face.normalModel.applyMatrix3( _normalMatrix ).normalize();\r\n\r\n\t\t\t\t\t_face.normalModelView.copy( _face.normalModel ).applyMatrix3( _normalViewMatrix );\r\n\r\n\t\t\t\t\t_face.centroidModel.copy( face.centroid ).applyMatrix4( _modelMatrix );\r\n\r\n\t\t\t\t\tfaceVertexNormals = face.vertexNormals;\r\n\r\n\t\t\t\t\tfor ( n = 0, nl = faceVertexNormals.length; n < nl; n ++ ) {\r\n\r\n\t\t\t\t\t\tvar normalModel = _face.vertexNormalsModel[ n ];\r\n\t\t\t\t\t\tnormalModel.copy( faceVertexNormals[ n ] );\r\n\r\n\t\t\t\t\t\tif ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {\r\n\r\n\t\t\t\t\t\t\tnormalModel.negate();\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tnormalModel.applyMatrix3( _normalMatrix ).normalize();\r\n\r\n\t\t\t\t\t\tvar normalModelView = _face.vertexNormalsModelView[ n ];\r\n\t\t\t\t\t\tnormalModelView.copy( normalModel ).applyMatrix3( _normalViewMatrix );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t_face.vertexNormalsLength = faceVertexNormals.length;\r\n\r\n\t\t\t\t\tfor ( c = 0, cl = faceVertexUvs.length; c < cl; c ++ ) {\r\n\r\n\t\t\t\t\t\tuvs = faceVertexUvs[ c ][ f ];\r\n\r\n\t\t\t\t\t\tif ( uvs === undefined ) continue;\r\n\r\n\t\t\t\t\t\tfor ( u = 0, ul = uvs.length; u < ul; u ++ ) {\r\n\r\n\t\t\t\t\t\t\t_face.uvs[ c ][ u ] = uvs[ u ];\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t_face.color = face.color;\r\n\t\t\t\t\t_face.material = material;\r\n\r\n\t\t\t\t\t_centroid.copy( _face.centroidModel ).applyProjection( _viewProjectionMatrix );\r\n\r\n\t\t\t\t\t_face.z = _centroid.z;\r\n\r\n\t\t\t\t\t_renderData.elements.push( _face );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( object instanceof THREE.Line ) {\r\n\r\n\t\t\t\t_modelViewProjectionMatrix.multiplyMatrices( _viewProjectionMatrix, _modelMatrix );\r\n\r\n\t\t\t\tvertices = object.geometry.vertices;\r\n\r\n\t\t\t\tv1 = getNextVertexInPool();\r\n\t\t\t\tv1.positionScreen.copy( vertices[ 0 ] ).applyMatrix4( _modelViewProjectionMatrix );\r\n\r\n\t\t\t\t// Handle LineStrip and LinePieces\r\n\t\t\t\tvar step = object.type === THREE.LinePieces ? 2 : 1;\r\n\r\n\t\t\t\tfor ( v = 1, vl = vertices.length; v < vl; v ++ ) {\r\n\r\n\t\t\t\t\tv1 = getNextVertexInPool();\r\n\t\t\t\t\tv1.positionScreen.copy( vertices[ v ] ).applyMatrix4( _modelViewProjectionMatrix );\r\n\r\n\t\t\t\t\tif ( ( v + 1 ) % step > 0 ) continue;\r\n\r\n\t\t\t\t\tv2 = _vertexPool[ _vertexCount - 2 ];\r\n\r\n\t\t\t\t\t_clippedVertex1PositionScreen.copy( v1.positionScreen );\r\n\t\t\t\t\t_clippedVertex2PositionScreen.copy( v2.positionScreen );\r\n\r\n\t\t\t\t\tif ( clipLine( _clippedVertex1PositionScreen, _clippedVertex2PositionScreen ) === true ) {\r\n\r\n\t\t\t\t\t\t// Perform the perspective divide\r\n\t\t\t\t\t\t_clippedVertex1PositionScreen.multiplyScalar( 1 / _clippedVertex1PositionScreen.w );\r\n\t\t\t\t\t\t_clippedVertex2PositionScreen.multiplyScalar( 1 / _clippedVertex2PositionScreen.w );\r\n\r\n\t\t\t\t\t\t_line = getNextLineInPool();\r\n\t\t\t\t\t\t_line.v1.positionScreen.copy( _clippedVertex1PositionScreen );\r\n\t\t\t\t\t\t_line.v2.positionScreen.copy( _clippedVertex2PositionScreen );\r\n\r\n\t\t\t\t\t\t_line.z = Math.max( _clippedVertex1PositionScreen.z, _clippedVertex2PositionScreen.z );\r\n\r\n\t\t\t\t\t\t_line.material = object.material;\r\n\r\n\t\t\t\t\t\t_renderData.elements.push( _line );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( o = 0, ol = _renderData.sprites.length; o < ol; o++ ) {\r\n\r\n\t\t\tobject = _renderData.sprites[ o ].object;\r\n\r\n\t\t\t_modelMatrix = object.matrixWorld;\r\n\r\n\t\t\tif ( object instanceof THREE.Particle ) {\r\n\r\n\t\t\t\t_vector4.set( _modelMatrix.elements[12], _modelMatrix.elements[13], _modelMatrix.elements[14], 1 );\r\n\t\t\t\t_vector4.applyMatrix4( _viewProjectionMatrix );\r\n\r\n\t\t\t\t_vector4.z /= _vector4.w;\r\n\r\n\t\t\t\tif ( _vector4.z > 0 && _vector4.z < 1 ) {\r\n\r\n\t\t\t\t\t_particle = getNextParticleInPool();\r\n\t\t\t\t\t_particle.object = object;\r\n\t\t\t\t\t_particle.x = _vector4.x / _vector4.w;\r\n\t\t\t\t\t_particle.y = _vector4.y / _vector4.w;\r\n\t\t\t\t\t_particle.z = _vector4.z;\r\n\r\n\t\t\t\t\t_particle.rotation = object.rotation.z;\r\n\r\n\t\t\t\t\t_particle.scale.x = object.scale.x * Math.abs( _particle.x - ( _vector4.x + camera.projectionMatrix.elements[0] ) / ( _vector4.w + camera.projectionMatrix.elements[12] ) );\r\n\t\t\t\t\t_particle.scale.y = object.scale.y * Math.abs( _particle.y - ( _vector4.y + camera.projectionMatrix.elements[5] ) / ( _vector4.w + camera.projectionMatrix.elements[13] ) );\r\n\r\n\t\t\t\t\t_particle.material = object.material;\r\n\r\n\t\t\t\t\t_renderData.elements.push( _particle );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( sortElements === true ) _renderData.elements.sort( painterSort );\r\n\r\n\t\treturn _renderData;\r\n\r\n\t};\r\n\r\n\t// Pools\r\n\r\n\tfunction getNextObjectInPool() {\r\n\r\n\t\tif ( _objectCount === _objectPoolLength ) {\r\n\r\n\t\t\tvar object = new THREE.RenderableObject();\r\n\t\t\t_objectPool.push( object );\r\n\t\t\t_objectPoolLength ++;\r\n\t\t\t_objectCount ++;\r\n\t\t\treturn object;\r\n\r\n\t\t}\r\n\r\n\t\treturn _objectPool[ _objectCount ++ ];\r\n\r\n\t}\r\n\r\n\tfunction getNextVertexInPool() {\r\n\r\n\t\tif ( _vertexCount === _vertexPoolLength ) {\r\n\r\n\t\t\tvar vertex = new THREE.RenderableVertex();\r\n\t\t\t_vertexPool.push( vertex );\r\n\t\t\t_vertexPoolLength ++;\r\n\t\t\t_vertexCount ++;\r\n\t\t\treturn vertex;\r\n\r\n\t\t}\r\n\r\n\t\treturn _vertexPool[ _vertexCount ++ ];\r\n\r\n\t}\r\n\r\n\tfunction getNextFace3InPool() {\r\n\r\n\t\tif ( _face3Count === _face3PoolLength ) {\r\n\r\n\t\t\tvar face = new THREE.RenderableFace3();\r\n\t\t\t_face3Pool.push( face );\r\n\t\t\t_face3PoolLength ++;\r\n\t\t\t_face3Count ++;\r\n\t\t\treturn face;\r\n\r\n\t\t}\r\n\r\n\t\treturn _face3Pool[ _face3Count ++ ];\r\n\r\n\r\n\t}\r\n\r\n\tfunction getNextFace4InPool() {\r\n\r\n\t\tif ( _face4Count === _face4PoolLength ) {\r\n\r\n\t\t\tvar face = new THREE.RenderableFace4();\r\n\t\t\t_face4Pool.push( face );\r\n\t\t\t_face4PoolLength ++;\r\n\t\t\t_face4Count ++;\r\n\t\t\treturn face;\r\n\r\n\t\t}\r\n\r\n\t\treturn _face4Pool[ _face4Count ++ ];\r\n\r\n\t}\r\n\r\n\tfunction getNextLineInPool() {\r\n\r\n\t\tif ( _lineCount === _linePoolLength ) {\r\n\r\n\t\t\tvar line = new THREE.RenderableLine();\r\n\t\t\t_linePool.push( line );\r\n\t\t\t_linePoolLength ++;\r\n\t\t\t_lineCount ++\r\n\t\t\treturn line;\r\n\r\n\t\t}\r\n\r\n\t\treturn _linePool[ _lineCount ++ ];\r\n\r\n\t}\r\n\r\n\tfunction getNextParticleInPool() {\r\n\r\n\t\tif ( _particleCount === _particlePoolLength ) {\r\n\r\n\t\t\tvar particle = new THREE.RenderableParticle();\r\n\t\t\t_particlePool.push( particle );\r\n\t\t\t_particlePoolLength ++;\r\n\t\t\t_particleCount ++\r\n\t\t\treturn particle;\r\n\r\n\t\t}\r\n\r\n\t\treturn _particlePool[ _particleCount ++ ];\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tfunction painterSort( a, b ) {\r\n\r\n\t\treturn b.z - a.z;\r\n\r\n\t}\r\n\r\n\tfunction clipLine( s1, s2 ) {\r\n\r\n\t\tvar alpha1 = 0, alpha2 = 1,\r\n\r\n\t\t// Calculate the boundary coordinate of each vertex for the near and far clip planes,\r\n\t\t// Z = -1 and Z = +1, respectively.\r\n\t\tbc1near =  s1.z + s1.w,\r\n\t\tbc2near =  s2.z + s2.w,\r\n\t\tbc1far =  - s1.z + s1.w,\r\n\t\tbc2far =  - s2.z + s2.w;\r\n\r\n\t\tif ( bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0 ) {\r\n\r\n\t\t\t// Both vertices lie entirely within all clip planes.\r\n\t\t\treturn true;\r\n\r\n\t\t} else if ( ( bc1near < 0 && bc2near < 0) || (bc1far < 0 && bc2far < 0 ) ) {\r\n\r\n\t\t\t// Both vertices lie entirely outside one of the clip planes.\r\n\t\t\treturn false;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// The line segment spans at least one clip plane.\r\n\r\n\t\t\tif ( bc1near < 0 ) {\r\n\r\n\t\t\t\t// v1 lies outside the near plane, v2 inside\r\n\t\t\t\talpha1 = Math.max( alpha1, bc1near / ( bc1near - bc2near ) );\r\n\r\n\t\t\t} else if ( bc2near < 0 ) {\r\n\r\n\t\t\t\t// v2 lies outside the near plane, v1 inside\r\n\t\t\t\talpha2 = Math.min( alpha2, bc1near / ( bc1near - bc2near ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( bc1far < 0 ) {\r\n\r\n\t\t\t\t// v1 lies outside the far plane, v2 inside\r\n\t\t\t\talpha1 = Math.max( alpha1, bc1far / ( bc1far - bc2far ) );\r\n\r\n\t\t\t} else if ( bc2far < 0 ) {\r\n\r\n\t\t\t\t// v2 lies outside the far plane, v2 inside\r\n\t\t\t\talpha2 = Math.min( alpha2, bc1far / ( bc1far - bc2far ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( alpha2 < alpha1 ) {\r\n\r\n\t\t\t\t// The line segment spans two boundaries, but is outside both of them.\r\n\t\t\t\t// (This can't happen when we're only clipping against just near/far but good\r\n\t\t\t\t//  to leave the check here for future usage if other clip planes are added.)\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Update the s1 and s2 vertices to match the clipped line segment.\r\n\t\t\t\ts1.lerp( s2, alpha1 );\r\n\t\t\t\ts2.lerp( s1, 1 - alpha2 );\r\n\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {\r\n\r\n\tthis.a = a;\r\n\tthis.b = b;\r\n\tthis.c = c;\r\n\r\n\tthis.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();\r\n\tthis.vertexNormals = normal instanceof Array ? normal : [ ];\r\n\r\n\tthis.color = color instanceof THREE.Color ? color : new THREE.Color();\r\n\tthis.vertexColors = color instanceof Array ? color : [];\r\n\r\n\tthis.vertexTangents = [];\r\n\r\n\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\r\n\r\n\tthis.centroid = new THREE.Vector3();\r\n\r\n};\r\n\r\nTHREE.Face3.prototype = {\r\n\r\n\tconstructor: THREE.Face3,\r\n\r\n\tclone: function () {\r\n\r\n\t\tvar face = new THREE.Face3( this.a, this.b, this.c );\r\n\r\n\t\tface.normal.copy( this.normal );\r\n\t\tface.color.copy( this.color );\r\n\t\tface.centroid.copy( this.centroid );\r\n\r\n\t\tface.materialIndex = this.materialIndex;\r\n\r\n\t\tvar i, il;\r\n\t\tfor ( i = 0, il = this.vertexNormals.length; i < il; i ++ ) face.vertexNormals[ i ] = this.vertexNormals[ i ].clone();\r\n\t\tfor ( i = 0, il = this.vertexColors.length; i < il; i ++ ) face.vertexColors[ i ] = this.vertexColors[ i ].clone();\r\n\t\tfor ( i = 0, il = this.vertexTangents.length; i < il; i ++ ) face.vertexTangents[ i ] = this.vertexTangents[ i ].clone();\r\n\r\n\t\treturn face;\r\n\r\n\t}\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {\r\n\r\n\tthis.a = a;\r\n\tthis.b = b;\r\n\tthis.c = c;\r\n\tthis.d = d;\r\n\r\n\tthis.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();\r\n\tthis.vertexNormals = normal instanceof Array ? normal : [ ];\r\n\r\n\tthis.color = color instanceof THREE.Color ? color : new THREE.Color();\r\n\tthis.vertexColors = color instanceof Array ? color : [];\r\n\r\n\tthis.vertexTangents = [];\r\n\r\n\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\r\n\r\n\tthis.centroid = new THREE.Vector3();\r\n\r\n};\r\n\r\nTHREE.Face4.prototype = {\r\n\r\n\tconstructor: THREE.Face4,\r\n\r\n\tclone: function () {\r\n\r\n\t\tvar face = new THREE.Face4( this.a, this.b, this.c, this.d );\r\n\r\n\t\tface.normal.copy( this.normal );\r\n\t\tface.color.copy( this.color );\r\n\t\tface.centroid.copy( this.centroid );\r\n\r\n\t\tface.materialIndex = this.materialIndex;\r\n\r\n\t\tvar i, il;\r\n\t\tfor ( i = 0, il = this.vertexNormals.length; i < il; i ++ ) face.vertexNormals[ i ] = this.vertexNormals[ i ].clone();\r\n\t\tfor ( i = 0, il = this.vertexColors.length; i < il; i ++ ) face.vertexColors[ i ] = this.vertexColors[ i ].clone();\r\n\t\tfor ( i = 0, il = this.vertexTangents.length; i < il; i ++ ) face.vertexTangents[ i ] = this.vertexTangents[ i ].clone();\r\n\r\n\t\treturn face;\r\n\r\n\t}\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author kile / http://kile.stravaganza.org/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Geometry = function () {\r\n\r\n\tTHREE.EventDispatcher.call( this );\r\n\r\n\tthis.id = THREE.GeometryIdCount ++;\r\n\r\n\tthis.name = '';\r\n\r\n\tthis.vertices = [];\r\n\tthis.colors = [];  // one-to-one vertex colors, used in ParticleSystem, Line and Ribbon\r\n\tthis.normals = []; // one-to-one vertex normals, used in Ribbon\r\n\r\n\tthis.faces = [];\r\n\r\n\tthis.faceUvs = [[]];\r\n\tthis.faceVertexUvs = [[]];\r\n\r\n\tthis.morphTargets = [];\r\n\tthis.morphColors = [];\r\n\tthis.morphNormals = [];\r\n\r\n\tthis.skinWeights = [];\r\n\tthis.skinIndices = [];\r\n\r\n\tthis.lineDistances = [];\r\n\r\n\tthis.boundingBox = null;\r\n\tthis.boundingSphere = null;\r\n\r\n\tthis.hasTangents = false;\r\n\r\n\tthis.dynamic = true; // the intermediate typed arrays will be deleted when set to false\r\n\r\n\t// update flags\r\n\r\n\tthis.verticesNeedUpdate = false;\r\n\tthis.elementsNeedUpdate = false;\r\n\tthis.uvsNeedUpdate = false;\r\n\tthis.normalsNeedUpdate = false;\r\n\tthis.tangentsNeedUpdate = false;\r\n\tthis.colorsNeedUpdate = false;\r\n\tthis.lineDistancesNeedUpdate = false;\r\n\r\n\tthis.buffersNeedUpdate = false;\r\n\r\n};\r\n\r\nTHREE.Geometry.prototype = {\r\n\r\n\tconstructor: THREE.Geometry,\r\n\r\n\tapplyMatrix: function ( matrix ) {\r\n\r\n\t\tvar normalMatrix = new THREE.Matrix3().getInverse( matrix ).transpose();\r\n\r\n\t\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar vertex = this.vertices[ i ];\r\n\t\t\tvertex.applyMatrix4( matrix );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar face = this.faces[ i ];\r\n\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tface.centroid.applyMatrix4( matrix );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeCentroids: function () {\r\n\r\n\t\tvar f, fl, face;\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\t\t\tface.centroid.set( 0, 0, 0 );\r\n\r\n\t\t\tif ( face instanceof THREE.Face3 ) {\r\n\r\n\t\t\t\tface.centroid.add( this.vertices[ face.a ] );\r\n\t\t\t\tface.centroid.add( this.vertices[ face.b ] );\r\n\t\t\t\tface.centroid.add( this.vertices[ face.c ] );\r\n\t\t\t\tface.centroid.divideScalar( 3 );\r\n\r\n\t\t\t} else if ( face instanceof THREE.Face4 ) {\r\n\r\n\t\t\t\tface.centroid.add( this.vertices[ face.a ] );\r\n\t\t\t\tface.centroid.add( this.vertices[ face.b ] );\r\n\t\t\t\tface.centroid.add( this.vertices[ face.c ] );\r\n\t\t\t\tface.centroid.add( this.vertices[ face.d ] );\r\n\t\t\t\tface.centroid.divideScalar( 4 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeFaceNormals: function () {\r\n\r\n\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\r\n\r\n\t\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tvar face = this.faces[ f ];\r\n\r\n\t\t\tvar vA = this.vertices[ face.a ];\r\n\t\t\tvar vB = this.vertices[ face.b ];\r\n\t\t\tvar vC = this.vertices[ face.c ];\r\n\r\n\t\t\tcb.subVectors( vC, vB );\r\n\t\t\tab.subVectors( vA, vB );\r\n\t\t\tcb.cross( ab );\r\n\r\n\t\t\tcb.normalize();\r\n\r\n\t\t\tface.normal.copy( cb );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeVertexNormals: function ( areaWeighted ) {\r\n\r\n\t\tvar v, vl, f, fl, face, vertices;\r\n\r\n\t\t// create internal buffers for reuse when calling this method repeatedly\r\n\t\t// (otherwise memory allocation / deallocation every frame is big resource hog)\r\n\r\n\t\tif ( this.__tmpVertices === undefined ) {\r\n\r\n\t\t\tthis.__tmpVertices = new Array( this.vertices.length );\r\n\t\t\tvertices = this.__tmpVertices;\r\n\r\n\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\r\n\t\t\t\tvertices[ v ] = new THREE.Vector3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\t\tif ( face instanceof THREE.Face3 ) {\r\n\r\n\t\t\t\t\tface.vertexNormals = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];\r\n\r\n\t\t\t\t} else if ( face instanceof THREE.Face4 ) {\r\n\r\n\t\t\t\t\tface.vertexNormals = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvertices = this.__tmpVertices;\r\n\r\n\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\r\n\t\t\t\tvertices[ v ].set( 0, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( areaWeighted ) {\r\n\r\n\t\t\t// vertex normals weighted by triangle areas\r\n\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\r\n\r\n\t\t\tvar vA, vB, vC, vD;\r\n\t\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3(),\r\n\t\t\t\tdb = new THREE.Vector3(), dc = new THREE.Vector3(), bc = new THREE.Vector3();\r\n\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\t\tif ( face instanceof THREE.Face3 ) {\r\n\r\n\t\t\t\t\tvA = this.vertices[ face.a ];\r\n\t\t\t\t\tvB = this.vertices[ face.b ];\r\n\t\t\t\t\tvC = this.vertices[ face.c ];\r\n\r\n\t\t\t\t\tcb.subVectors( vC, vB );\r\n\t\t\t\t\tab.subVectors( vA, vB );\r\n\t\t\t\t\tcb.cross( ab );\r\n\r\n\t\t\t\t\tvertices[ face.a ].add( cb );\r\n\t\t\t\t\tvertices[ face.b ].add( cb );\r\n\t\t\t\t\tvertices[ face.c ].add( cb );\r\n\r\n\t\t\t\t} else if ( face instanceof THREE.Face4 ) {\r\n\r\n\t\t\t\t\tvA = this.vertices[ face.a ];\r\n\t\t\t\t\tvB = this.vertices[ face.b ];\r\n\t\t\t\t\tvC = this.vertices[ face.c ];\r\n\t\t\t\t\tvD = this.vertices[ face.d ];\r\n\r\n\t\t\t\t\t// abd\r\n\r\n\t\t\t\t\tdb.subVectors( vD, vB );\r\n\t\t\t\t\tab.subVectors( vA, vB );\r\n\t\t\t\t\tdb.cross( ab );\r\n\r\n\t\t\t\t\tvertices[ face.a ].add( db );\r\n\t\t\t\t\tvertices[ face.b ].add( db );\r\n\t\t\t\t\tvertices[ face.d ].add( db );\r\n\r\n\t\t\t\t\t// bcd\r\n\r\n\t\t\t\t\tdc.subVectors( vD, vC );\r\n\t\t\t\t\tbc.subVectors( vB, vC );\r\n\t\t\t\t\tdc.cross( bc );\r\n\r\n\t\t\t\t\tvertices[ face.b ].add( dc );\r\n\t\t\t\t\tvertices[ face.c ].add( dc );\r\n\t\t\t\t\tvertices[ face.d ].add( dc );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\t\tif ( face instanceof THREE.Face3 ) {\r\n\r\n\t\t\t\t\tvertices[ face.a ].add( face.normal );\r\n\t\t\t\t\tvertices[ face.b ].add( face.normal );\r\n\t\t\t\t\tvertices[ face.c ].add( face.normal );\r\n\r\n\t\t\t\t} else if ( face instanceof THREE.Face4 ) {\r\n\r\n\t\t\t\t\tvertices[ face.a ].add( face.normal );\r\n\t\t\t\t\tvertices[ face.b ].add( face.normal );\r\n\t\t\t\t\tvertices[ face.c ].add( face.normal );\r\n\t\t\t\t\tvertices[ face.d ].add( face.normal );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\r\n\t\t\tvertices[ v ].normalize();\r\n\r\n\t\t}\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\tif ( face instanceof THREE.Face3 ) {\r\n\r\n\t\t\t\tface.vertexNormals[ 0 ].copy( vertices[ face.a ] );\r\n\t\t\t\tface.vertexNormals[ 1 ].copy( vertices[ face.b ] );\r\n\t\t\t\tface.vertexNormals[ 2 ].copy( vertices[ face.c ] );\r\n\r\n\t\t\t} else if ( face instanceof THREE.Face4 ) {\r\n\r\n\t\t\t\tface.vertexNormals[ 0 ].copy( vertices[ face.a ] );\r\n\t\t\t\tface.vertexNormals[ 1 ].copy( vertices[ face.b ] );\r\n\t\t\t\tface.vertexNormals[ 2 ].copy( vertices[ face.c ] );\r\n\t\t\t\tface.vertexNormals[ 3 ].copy( vertices[ face.d ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeMorphNormals: function () {\r\n\r\n\t\tvar i, il, f, fl, face;\r\n\r\n\t\t// save original normals\r\n\t\t// - create temp variables on first access\r\n\t\t//   otherwise just copy (for faster repeated calls)\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\tif ( ! face.__originalFaceNormal ) {\r\n\r\n\t\t\t\tface.__originalFaceNormal = face.normal.clone();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tface.__originalFaceNormal.copy( face.normal );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\r\n\r\n\t\t\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\r\n\r\n\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// use temp geometry to compute face and vertex normals for each morph\r\n\r\n\t\tvar tmpGeo = new THREE.Geometry();\r\n\t\ttmpGeo.faces = this.faces;\r\n\r\n\t\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\r\n\r\n\t\t\t// create on first access\r\n\r\n\t\t\tif ( ! this.morphNormals[ i ] ) {\r\n\r\n\t\t\t\tthis.morphNormals[ i ] = {};\r\n\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\r\n\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\r\n\r\n\t\t\t\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\r\n\t\t\t\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\r\n\r\n\t\t\t\tvar faceNormal, vertexNormals;\r\n\r\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\t\t\tfaceNormal = new THREE.Vector3();\r\n\r\n\t\t\t\t\tif ( face instanceof THREE.Face3 ) {\r\n\r\n\t\t\t\t\t\tvertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tvertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3(), d: new THREE.Vector3() };\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tdstNormalsFace.push( faceNormal );\r\n\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar morphNormals = this.morphNormals[ i ];\r\n\r\n\t\t\t// set vertices to morph target\r\n\r\n\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\r\n\r\n\t\t\t// compute morph normals\r\n\r\n\t\t\ttmpGeo.computeFaceNormals();\r\n\t\t\ttmpGeo.computeVertexNormals();\r\n\r\n\t\t\t// store morph normals\r\n\r\n\t\t\tvar faceNormal, vertexNormals;\r\n\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\t\tfaceNormal = morphNormals.faceNormals[ f ];\r\n\t\t\t\tvertexNormals = morphNormals.vertexNormals[ f ];\r\n\r\n\t\t\t\tfaceNormal.copy( face.normal );\r\n\r\n\t\t\t\tif ( face instanceof THREE.Face3 ) {\r\n\r\n\t\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\r\n\t\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\r\n\t\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\r\n\t\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\r\n\t\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\r\n\t\t\t\t\tvertexNormals.d.copy( face.vertexNormals[ 3 ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// restore original normals\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\tface.normal = face.__originalFaceNormal;\r\n\t\t\tface.vertexNormals = face.__originalVertexNormals;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeTangents: function () {\r\n\r\n\t\t// based on http://www.terathon.com/code/tangent.html\r\n\t\t// tangents go to vertices\r\n\r\n\t\tvar f, fl, v, vl, i, il, vertexIndex,\r\n\t\t\tface, uv, vA, vB, vC, uvA, uvB, uvC,\r\n\t\t\tx1, x2, y1, y2, z1, z2,\r\n\t\t\ts1, s2, t1, t2, r, t, test,\r\n\t\t\ttan1 = [], tan2 = [],\r\n\t\t\tsdir = new THREE.Vector3(), tdir = new THREE.Vector3(),\r\n\t\t\ttmp = new THREE.Vector3(), tmp2 = new THREE.Vector3(),\r\n\t\t\tn = new THREE.Vector3(), w;\r\n\r\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\r\n\t\t\ttan1[ v ] = new THREE.Vector3();\r\n\t\t\ttan2[ v ] = new THREE.Vector3();\r\n\r\n\t\t}\r\n\r\n\t\tfunction handleTriangle( context, a, b, c, ua, ub, uc ) {\r\n\r\n\t\t\tvA = context.vertices[ a ];\r\n\t\t\tvB = context.vertices[ b ];\r\n\t\t\tvC = context.vertices[ c ];\r\n\r\n\t\t\tuvA = uv[ ua ];\r\n\t\t\tuvB = uv[ ub ];\r\n\t\t\tuvC = uv[ uc ];\r\n\r\n\t\t\tx1 = vB.x - vA.x;\r\n\t\t\tx2 = vC.x - vA.x;\r\n\t\t\ty1 = vB.y - vA.y;\r\n\t\t\ty2 = vC.y - vA.y;\r\n\t\t\tz1 = vB.z - vA.z;\r\n\t\t\tz2 = vC.z - vA.z;\r\n\r\n\t\t\ts1 = uvB.x - uvA.x;\r\n\t\t\ts2 = uvC.x - uvA.x;\r\n\t\t\tt1 = uvB.y - uvA.y;\r\n\t\t\tt2 = uvC.y - uvA.y;\r\n\r\n\t\t\tr = 1.0 / ( s1 * t2 - s2 * t1 );\r\n\t\t\tsdir.set( ( t2 * x1 - t1 * x2 ) * r,\r\n\t\t\t\t\t  ( t2 * y1 - t1 * y2 ) * r,\r\n\t\t\t\t\t  ( t2 * z1 - t1 * z2 ) * r );\r\n\t\t\ttdir.set( ( s1 * x2 - s2 * x1 ) * r,\r\n\t\t\t\t\t  ( s1 * y2 - s2 * y1 ) * r,\r\n\t\t\t\t\t  ( s1 * z2 - s2 * z1 ) * r );\r\n\r\n\t\t\ttan1[ a ].add( sdir );\r\n\t\t\ttan1[ b ].add( sdir );\r\n\t\t\ttan1[ c ].add( sdir );\r\n\r\n\t\t\ttan2[ a ].add( tdir );\r\n\t\t\ttan2[ b ].add( tdir );\r\n\t\t\ttan2[ c ].add( tdir );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\t\t\tuv = this.faceVertexUvs[ 0 ][ f ]; // use UV layer 0 for tangents\r\n\r\n\t\t\tif ( face instanceof THREE.Face3 ) {\r\n\r\n\t\t\t\thandleTriangle( this, face.a, face.b, face.c, 0, 1, 2 );\r\n\r\n\t\t\t} else if ( face instanceof THREE.Face4 ) {\r\n\r\n\t\t\t\thandleTriangle( this, face.a, face.b, face.d, 0, 1, 3 );\r\n\t\t\t\thandleTriangle( this, face.b, face.c, face.d, 1, 2, 3 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar faceIndex = [ 'a', 'b', 'c', 'd' ];\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\tfor ( i = 0; i < face.vertexNormals.length; i++ ) {\r\n\r\n\t\t\t\tn.copy( face.vertexNormals[ i ] );\r\n\r\n\t\t\t\tvertexIndex = face[ faceIndex[ i ] ];\r\n\r\n\t\t\t\tt = tan1[ vertexIndex ];\r\n\r\n\t\t\t\t// Gram-Schmidt orthogonalize\r\n\r\n\t\t\t\ttmp.copy( t );\r\n\t\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\r\n\r\n\t\t\t\t// Calculate handedness\r\n\r\n\t\t\t\ttmp2.crossVectors( face.vertexNormals[ i ], t );\r\n\t\t\t\ttest = tmp2.dot( tan2[ vertexIndex ] );\r\n\t\t\t\tw = (test < 0.0) ? -1.0 : 1.0;\r\n\r\n\t\t\t\tface.vertexTangents[ i ] = new THREE.Vector4( tmp.x, tmp.y, tmp.z, w );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.hasTangents = true;\r\n\r\n\t},\r\n\r\n\tcomputeLineDistances: function ( ) {\r\n\r\n\t\tvar d = 0;\r\n\t\tvar vertices = this.vertices;\r\n\r\n\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tif ( i > 0 ) {\r\n\r\n\t\t\t\td += vertices[ i ].distanceTo( vertices[ i - 1 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.lineDistances[ i ] = d;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeBoundingBox: function () {\r\n\r\n\t\tif ( this.boundingBox === null ) {\r\n\r\n\t\t\tthis.boundingBox = new THREE.Box3();\r\n\r\n\t\t}\r\n\r\n\t\tthis.boundingBox.setFromPoints( this.vertices );\r\n\r\n\t},\r\n\r\n\tcomputeBoundingSphere: function () {\r\n\r\n\t\tif ( this.boundingSphere === null ) {\r\n\r\n\t\t\tthis.boundingSphere = new THREE.Sphere();\r\n\r\n\t\t}\r\n\r\n\t\tthis.boundingSphere.setFromCenterAndPoints( this.boundingSphere.center, this.vertices );\r\n\r\n\t},\r\n\r\n\t/*\r\n\t * Checks for duplicate vertices with hashmap.\r\n\t * Duplicated vertices are removed\r\n\t * and faces' vertices are updated.\r\n\t */\r\n\r\n\tmergeVertices: function () {\r\n\r\n\t\tvar verticesMap = {}; // Hashmap for looking up vertice by position coordinates (and making sure they are unique)\r\n\t\tvar unique = [], changes = [];\r\n\r\n\t\tvar v, key;\r\n\t\tvar precisionPoints = 4; // number of decimal points, eg. 4 for epsilon of 0.0001\r\n\t\tvar precision = Math.pow( 10, precisionPoints );\r\n\t\tvar i,il, face;\r\n\t\tvar indices, k, j, jl, u;\r\n\r\n\t\t// reset cache of vertices as it now will be changing.\r\n\t\tthis.__tmpVertices = undefined;\r\n\r\n\t\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tv = this.vertices[ i ];\r\n\t\t\tkey = [ Math.round( v.x * precision ), Math.round( v.y * precision ), Math.round( v.z * precision ) ].join( '_' );\r\n\r\n\t\t\tif ( verticesMap[ key ] === undefined ) {\r\n\r\n\t\t\t\tverticesMap[ key ] = i;\r\n\t\t\t\tunique.push( this.vertices[ i ] );\r\n\t\t\t\tchanges[ i ] = unique.length - 1;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\r\n\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\r\n\t\t// if faces are completely degenerate after merging vertices, we\r\n\t\t// have to remove them from the geometry.\r\n\t\tvar faceIndicesToRemove = [];\r\n\r\n\t\tfor( i = 0, il = this.faces.length; i < il; i ++ ) {\r\n\r\n\t\t\tface = this.faces[ i ];\r\n\r\n\t\t\tif ( face instanceof THREE.Face3 ) {\r\n\r\n\t\t\t\tface.a = changes[ face.a ];\r\n\t\t\t\tface.b = changes[ face.b ];\r\n\t\t\t\tface.c = changes[ face.c ];\r\n\r\n\t\t\t\tindices = [ face.a, face.b, face.c ];\r\n\r\n\t\t\t\tvar dupIndex = -1;\r\n\r\n\t\t\t\t// if any duplicate vertices are found in a Face3\r\n\t\t\t\t// we have to remove the face as nothing can be saved\r\n\t\t\t\tfor ( var n = 0; n < 3; n ++ ) {\r\n\t\t\t\t\tif ( indices[ n ] == indices[ ( n + 1 ) % 3 ] ) {\r\n\r\n\t\t\t\t\t\tdupIndex = n;\r\n\t\t\t\t\t\tfaceIndicesToRemove.push( i );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( face instanceof THREE.Face4 ) {\r\n\r\n\t\t\t\tface.a = changes[ face.a ];\r\n\t\t\t\tface.b = changes[ face.b ];\r\n\t\t\t\tface.c = changes[ face.c ];\r\n\t\t\t\tface.d = changes[ face.d ];\r\n\r\n\t\t\t\t// check dups in (a, b, c, d) and convert to -> face3\r\n\r\n\t\t\t\tindices = [ face.a, face.b, face.c, face.d ];\r\n\r\n\t\t\t\tvar dupIndex = -1;\r\n\r\n\t\t\t\tfor ( var n = 0; n < 4; n ++ ) {\r\n\r\n\t\t\t\t\tif ( indices[ n ] == indices[ ( n + 1 ) % 4 ] ) {\r\n\r\n\t\t\t\t\t\t// if more than one duplicated vertex is found\r\n\t\t\t\t\t\t// we can't generate any valid Face3's, thus\r\n\t\t\t\t\t\t// we need to remove this face complete.\r\n\t\t\t\t\t\tif ( dupIndex >= 0 ) {\r\n\r\n\t\t\t\t\t\t\tfaceIndicesToRemove.push( i );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tdupIndex = n;\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( dupIndex >= 0 ) {\r\n\r\n\t\t\t\t\tindices.splice( dupIndex, 1 );\r\n\r\n\t\t\t\t\tvar newFace = new THREE.Face3( indices[0], indices[1], indices[2], face.normal, face.color, face.materialIndex );\r\n\r\n\t\t\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\tu = this.faceVertexUvs[ j ][ i ];\r\n\r\n\t\t\t\t\t\tif ( u ) {\r\n\t\t\t\t\t\t\tu.splice( dupIndex, 1 );\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif( face.vertexNormals && face.vertexNormals.length > 0) {\r\n\r\n\t\t\t\t\t\tnewFace.vertexNormals = face.vertexNormals;\r\n\t\t\t\t\t\tnewFace.vertexNormals.splice( dupIndex, 1 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif( face.vertexColors && face.vertexColors.length > 0 ) {\r\n\r\n\t\t\t\t\t\tnewFace.vertexColors = face.vertexColors;\r\n\t\t\t\t\t\tnewFace.vertexColors.splice( dupIndex, 1 );\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis.faces[ i ] = newFace;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\r\n\r\n\t\t\tthis.faces.splice( i, 1 );\r\n\r\n\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tthis.faceVertexUvs[ j ].splice( i, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Use unique set of vertices\r\n\r\n\t\tvar diff = this.vertices.length - unique.length;\r\n\t\tthis.vertices = unique;\r\n\t\treturn diff;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\tvar geometry = new THREE.Geometry();\r\n\r\n\t\tvar vertices = this.vertices;\r\n\r\n\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tgeometry.vertices.push( vertices[ i ].clone() );\r\n\r\n\t\t}\r\n\r\n\t\tvar faces = this.faces;\r\n\r\n\t\tfor ( var i = 0, il = faces.length; i < il; i ++ ) {\r\n\r\n\t\t\tgeometry.faces.push( faces[ i ].clone() );\r\n\r\n\t\t}\r\n\r\n\t\tvar uvs = this.faceVertexUvs[ 0 ];\r\n\r\n\t\tfor ( var i = 0, il = uvs.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar uv = uvs[ i ], uvCopy = [];\r\n\r\n\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tuvCopy.push( new THREE.Vector2( uv[ j ].x, uv[ j ].y ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.faceVertexUvs[ 0 ].push( uvCopy );\r\n\r\n\t\t}\r\n\r\n\t\treturn geometry;\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.GeometryIdCount = 0;\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.BufferGeometry = function () {\r\n\r\n\tTHREE.EventDispatcher.call( this );\r\n\r\n\tthis.id = THREE.GeometryIdCount ++;\r\n\r\n\t// attributes\r\n\r\n\tthis.attributes = {};\r\n\r\n\t// attributes typed arrays are kept only if dynamic flag is set\r\n\r\n\tthis.dynamic = false;\r\n\r\n\t// offsets for chunks when using indexed elements\r\n\r\n\tthis.offsets = [];\r\n\r\n\t// boundings\r\n\r\n\tthis.boundingBox = null;\r\n\tthis.boundingSphere = null;\r\n\r\n\tthis.hasTangents = false;\r\n\r\n\t// for compatibility\r\n\r\n\tthis.morphTargets = [];\r\n\r\n};\r\n\r\nTHREE.BufferGeometry.prototype = {\r\n\r\n\tconstructor : THREE.BufferGeometry,\r\n\r\n\tapplyMatrix: function ( matrix ) {\r\n\r\n\t\tvar positionArray;\r\n\t\tvar normalArray;\r\n\r\n\t\tif ( this.attributes[ \"position\" ] ) positionArray = this.attributes[ \"position\" ].array;\r\n\t\tif ( this.attributes[ \"normal\" ] ) normalArray = this.attributes[ \"normal\" ].array;\r\n\r\n\t\tif ( positionArray !== undefined ) {\r\n\r\n\t\t\tmatrix.multiplyVector3Array( positionArray );\r\n\t\t\tthis.verticesNeedUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( normalArray !== undefined ) {\r\n\r\n\t\t\tvar normalMatrix = new THREE.Matrix3();\r\n\t\t\tnormalMatrix.getInverse( matrix ).transpose();\r\n\r\n\t\t\tnormalMatrix.multiplyVector3Array( normalArray );\r\n\r\n\t\t\tthis.normalizeNormals();\r\n\r\n\t\t\tthis.normalsNeedUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeBoundingBox: function () {\r\n\r\n\t\tif ( this.boundingBox === null ) {\r\n\r\n\t\t\tthis.boundingBox = new THREE.Box3();\r\n\r\n\t\t}\r\n\r\n\t\tvar positions = this.attributes[ \"position\" ].array;\r\n\r\n\t\tif ( positions ) {\r\n\r\n\t\t\tvar bb = this.boundingBox;\r\n\t\t\tvar x, y, z;\r\n\r\n\t\t\tif( positions.length >= 3 ) {\r\n\t\t\t\tbb.min.x = bb.max.x = positions[ 0 ];\r\n\t\t\t\tbb.min.y = bb.max.y = positions[ 1 ];\r\n\t\t\t\tbb.min.z = bb.max.z = positions[ 2 ];\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 3, il = positions.length; i < il; i += 3 ) {\r\n\r\n\t\t\t\tx = positions[ i ];\r\n\t\t\t\ty = positions[ i + 1 ];\r\n\t\t\t\tz = positions[ i + 2 ];\r\n\r\n\t\t\t\t// bounding box\r\n\r\n\t\t\t\tif ( x < bb.min.x ) {\r\n\r\n\t\t\t\t\tbb.min.x = x;\r\n\r\n\t\t\t\t} else if ( x > bb.max.x ) {\r\n\r\n\t\t\t\t\tbb.max.x = x;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( y < bb.min.y ) {\r\n\r\n\t\t\t\t\tbb.min.y = y;\r\n\r\n\t\t\t\t} else if ( y > bb.max.y ) {\r\n\r\n\t\t\t\t\tbb.max.y = y;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( z < bb.min.z ) {\r\n\r\n\t\t\t\t\tbb.min.z = z;\r\n\r\n\t\t\t\t} else if ( z > bb.max.z ) {\r\n\r\n\t\t\t\t\tbb.max.z = z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( positions === undefined || positions.length === 0 ) {\r\n\r\n\t\t\tthis.boundingBox.min.set( 0, 0, 0 );\r\n\t\t\tthis.boundingBox.max.set( 0, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeBoundingSphere: function () {\r\n\r\n\t\tif ( this.boundingSphere === null ) {\r\n\r\n\t\t\tthis.boundingSphere = new THREE.Sphere();\r\n\r\n\t\t}\r\n\r\n\t\tvar positions = this.attributes[ \"position\" ].array;\r\n\r\n\t\tif ( positions ) {\r\n\r\n\t\t\tvar radiusSq, maxRadiusSq = 0;\r\n\t\t\tvar x, y, z;\r\n\r\n\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\r\n\r\n\t\t\t\tx = positions[ i ];\r\n\t\t\t\ty = positions[ i + 1 ];\r\n\t\t\t\tz = positions[ i + 2 ];\r\n\r\n\t\t\t\tradiusSq =  x * x + y * y + z * z;\r\n\t\t\t\tif ( radiusSq > maxRadiusSq ) maxRadiusSq = radiusSq;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeVertexNormals: function () {\r\n\r\n\t\tif ( this.attributes[ \"position\" ] ) {\r\n\r\n\t\t\tvar i, il;\r\n\t\t\tvar j, jl;\r\n\r\n\t\t\tvar nVertexElements = this.attributes[ \"position\" ].array.length;\r\n\r\n\t\t\tif ( this.attributes[ \"normal\" ] === undefined ) {\r\n\r\n\t\t\t\tthis.attributes[ \"normal\" ] = {\r\n\r\n\t\t\t\t\titemSize: 3,\r\n\t\t\t\t\tarray: new Float32Array( nVertexElements ),\r\n\t\t\t\t\tnumItems: nVertexElements\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// reset existing normals to zero\r\n\r\n\t\t\t\tfor ( i = 0, il = this.attributes[ \"normal\" ].array.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tthis.attributes[ \"normal\" ].array[ i ] = 0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar positions = this.attributes[ \"position\" ].array;\r\n\t\t\tvar normals = this.attributes[ \"normal\" ].array;\r\n\r\n\t\t\tvar vA, vB, vC, x, y, z,\r\n\r\n\t\t\tpA = new THREE.Vector3(),\r\n\t\t\tpB = new THREE.Vector3(),\r\n\t\t\tpC = new THREE.Vector3(),\r\n\r\n\t\t\tcb = new THREE.Vector3(),\r\n\t\t\tab = new THREE.Vector3();\r\n\r\n\t\t\t// indexed elements\r\n\r\n\t\t\tif ( this.attributes[ \"index\" ] ) {\r\n\r\n\t\t\t\tvar indices = this.attributes[ \"index\" ].array;\r\n\r\n\t\t\t\tvar offsets = this.offsets;\r\n\r\n\t\t\t\tfor ( j = 0, jl = offsets.length; j < jl; ++ j ) {\r\n\r\n\t\t\t\t\tvar start = offsets[ j ].start;\r\n\t\t\t\t\tvar count = offsets[ j ].count;\r\n\t\t\t\t\tvar index = offsets[ j ].index;\r\n\r\n\t\t\t\t\tfor ( i = start, il = start + count; i < il; i += 3 ) {\r\n\r\n\t\t\t\t\t\tvA = index + indices[ i ];\r\n\t\t\t\t\t\tvB = index + indices[ i + 1 ];\r\n\t\t\t\t\t\tvC = index + indices[ i + 2 ];\r\n\r\n\t\t\t\t\t\tx = positions[ vA * 3 ];\r\n\t\t\t\t\t\ty = positions[ vA * 3 + 1 ];\r\n\t\t\t\t\t\tz = positions[ vA * 3 + 2 ];\r\n\t\t\t\t\t\tpA.set( x, y, z );\r\n\r\n\t\t\t\t\t\tx = positions[ vB * 3 ];\r\n\t\t\t\t\t\ty = positions[ vB * 3 + 1 ];\r\n\t\t\t\t\t\tz = positions[ vB * 3 + 2 ];\r\n\t\t\t\t\t\tpB.set( x, y, z );\r\n\r\n\t\t\t\t\t\tx = positions[ vC * 3 ];\r\n\t\t\t\t\t\ty = positions[ vC * 3 + 1 ];\r\n\t\t\t\t\t\tz = positions[ vC * 3 + 2 ];\r\n\t\t\t\t\t\tpC.set( x, y, z );\r\n\r\n\t\t\t\t\t\tcb.subVectors( pC, pB );\r\n\t\t\t\t\t\tab.subVectors( pA, pB );\r\n\t\t\t\t\t\tcb.cross( ab );\r\n\r\n\t\t\t\t\t\tnormals[ vA * 3 ]     += cb.x;\r\n\t\t\t\t\t\tnormals[ vA * 3 + 1 ] += cb.y;\r\n\t\t\t\t\t\tnormals[ vA * 3 + 2 ] += cb.z;\r\n\r\n\t\t\t\t\t\tnormals[ vB * 3 ]     += cb.x;\r\n\t\t\t\t\t\tnormals[ vB * 3 + 1 ] += cb.y;\r\n\t\t\t\t\t\tnormals[ vB * 3 + 2 ] += cb.z;\r\n\r\n\t\t\t\t\t\tnormals[ vC * 3 ]     += cb.x;\r\n\t\t\t\t\t\tnormals[ vC * 3 + 1 ] += cb.y;\r\n\t\t\t\t\t\tnormals[ vC * 3 + 2 ] += cb.z;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t// non-indexed elements (unconnected triangle soup)\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfor ( i = 0, il = positions.length; i < il; i += 9 ) {\r\n\r\n\t\t\t\t\tx = positions[ i ];\r\n\t\t\t\t\ty = positions[ i + 1 ];\r\n\t\t\t\t\tz = positions[ i + 2 ];\r\n\t\t\t\t\tpA.set( x, y, z );\r\n\r\n\t\t\t\t\tx = positions[ i + 3 ];\r\n\t\t\t\t\ty = positions[ i + 4 ];\r\n\t\t\t\t\tz = positions[ i + 5 ];\r\n\t\t\t\t\tpB.set( x, y, z );\r\n\r\n\t\t\t\t\tx = positions[ i + 6 ];\r\n\t\t\t\t\ty = positions[ i + 7 ];\r\n\t\t\t\t\tz = positions[ i + 8 ];\r\n\t\t\t\t\tpC.set( x, y, z );\r\n\r\n\t\t\t\t\tcb.subVectors( pC, pB );\r\n\t\t\t\t\tab.subVectors( pA, pB );\r\n\t\t\t\t\tcb.cross( ab );\r\n\r\n\t\t\t\t\tnormals[ i ] \t = cb.x;\r\n\t\t\t\t\tnormals[ i + 1 ] = cb.y;\r\n\t\t\t\t\tnormals[ i + 2 ] = cb.z;\r\n\r\n\t\t\t\t\tnormals[ i + 3 ] = cb.x;\r\n\t\t\t\t\tnormals[ i + 4 ] = cb.y;\r\n\t\t\t\t\tnormals[ i + 5 ] = cb.z;\r\n\r\n\t\t\t\t\tnormals[ i + 6 ] = cb.x;\r\n\t\t\t\t\tnormals[ i + 7 ] = cb.y;\r\n\t\t\t\t\tnormals[ i + 8 ] = cb.z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.normalizeNormals();\r\n\r\n\t\t\tthis.normalsNeedUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tnormalizeNormals: function () {\r\n\r\n\t\tvar normals = this.attributes[ \"normal\" ].array;\r\n\r\n\t\tvar x, y, z, n;\r\n\r\n\t\tfor ( var i = 0, il = normals.length; i < il; i += 3 ) {\r\n\r\n\t\t\tx = normals[ i ];\r\n\t\t\ty = normals[ i + 1 ];\r\n\t\t\tz = normals[ i + 2 ];\r\n\r\n\t\t\tn = 1.0 / Math.sqrt( x * x + y * y + z * z );\r\n\r\n\t\t\tnormals[ i ] \t *= n;\r\n\t\t\tnormals[ i + 1 ] *= n;\r\n\t\t\tnormals[ i + 2 ] *= n;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeTangents: function () {\r\n\r\n\t\t// based on http://www.terathon.com/code/tangent.html\r\n\t\t// (per vertex tangents)\r\n\r\n\t\tif ( this.attributes[ \"index\" ] === undefined ||\r\n\t\t\t this.attributes[ \"position\" ] === undefined ||\r\n\t\t\t this.attributes[ \"normal\" ] === undefined ||\r\n\t\t\t this.attributes[ \"uv\" ] === undefined ) {\r\n\r\n\t\t\tconsole.warn( \"Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()\" );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar indices = this.attributes[ \"index\" ].array;\r\n\t\tvar positions = this.attributes[ \"position\" ].array;\r\n\t\tvar normals = this.attributes[ \"normal\" ].array;\r\n\t\tvar uvs = this.attributes[ \"uv\" ].array;\r\n\r\n\t\tvar nVertices = positions.length / 3;\r\n\r\n\t\tif ( this.attributes[ \"tangent\" ] === undefined ) {\r\n\r\n\t\t\tvar nTangentElements = 4 * nVertices;\r\n\r\n\t\t\tthis.attributes[ \"tangent\" ] = {\r\n\r\n\t\t\t\titemSize: 4,\r\n\t\t\t\tarray: new Float32Array( nTangentElements ),\r\n\t\t\t\tnumItems: nTangentElements\r\n\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tvar tangents = this.attributes[ \"tangent\" ].array;\r\n\r\n\t\tvar tan1 = [], tan2 = [];\r\n\r\n\t\tfor ( var k = 0; k < nVertices; k ++ ) {\r\n\r\n\t\t\ttan1[ k ] = new THREE.Vector3();\r\n\t\t\ttan2[ k ] = new THREE.Vector3();\r\n\r\n\t\t}\r\n\r\n\t\tvar xA, yA, zA,\r\n\t\t\txB, yB, zB,\r\n\t\t\txC, yC, zC,\r\n\r\n\t\t\tuA, vA,\r\n\t\t\tuB, vB,\r\n\t\t\tuC, vC,\r\n\r\n\t\t\tx1, x2, y1, y2, z1, z2,\r\n\t\t\ts1, s2, t1, t2, r;\r\n\r\n\t\tvar sdir = new THREE.Vector3(), tdir = new THREE.Vector3();\r\n\r\n\t\tfunction handleTriangle( a, b, c ) {\r\n\r\n\t\t\txA = positions[ a * 3 ];\r\n\t\t\tyA = positions[ a * 3 + 1 ];\r\n\t\t\tzA = positions[ a * 3 + 2 ];\r\n\r\n\t\t\txB = positions[ b * 3 ];\r\n\t\t\tyB = positions[ b * 3 + 1 ];\r\n\t\t\tzB = positions[ b * 3 + 2 ];\r\n\r\n\t\t\txC = positions[ c * 3 ];\r\n\t\t\tyC = positions[ c * 3 + 1 ];\r\n\t\t\tzC = positions[ c * 3 + 2 ];\r\n\r\n\t\t\tuA = uvs[ a * 2 ];\r\n\t\t\tvA = uvs[ a * 2 + 1 ];\r\n\r\n\t\t\tuB = uvs[ b * 2 ];\r\n\t\t\tvB = uvs[ b * 2 + 1 ];\r\n\r\n\t\t\tuC = uvs[ c * 2 ];\r\n\t\t\tvC = uvs[ c * 2 + 1 ];\r\n\r\n\t\t\tx1 = xB - xA;\r\n\t\t\tx2 = xC - xA;\r\n\r\n\t\t\ty1 = yB - yA;\r\n\t\t\ty2 = yC - yA;\r\n\r\n\t\t\tz1 = zB - zA;\r\n\t\t\tz2 = zC - zA;\r\n\r\n\t\t\ts1 = uB - uA;\r\n\t\t\ts2 = uC - uA;\r\n\r\n\t\t\tt1 = vB - vA;\r\n\t\t\tt2 = vC - vA;\r\n\r\n\t\t\tr = 1.0 / ( s1 * t2 - s2 * t1 );\r\n\r\n\t\t\tsdir.set(\r\n\t\t\t\t( t2 * x1 - t1 * x2 ) * r,\r\n\t\t\t\t( t2 * y1 - t1 * y2 ) * r,\r\n\t\t\t\t( t2 * z1 - t1 * z2 ) * r\r\n\t\t\t);\r\n\r\n\t\t\ttdir.set(\r\n\t\t\t\t( s1 * x2 - s2 * x1 ) * r,\r\n\t\t\t\t( s1 * y2 - s2 * y1 ) * r,\r\n\t\t\t\t( s1 * z2 - s2 * z1 ) * r\r\n\t\t\t);\r\n\r\n\t\t\ttan1[ a ].add( sdir );\r\n\t\t\ttan1[ b ].add( sdir );\r\n\t\t\ttan1[ c ].add( sdir );\r\n\r\n\t\t\ttan2[ a ].add( tdir );\r\n\t\t\ttan2[ b ].add( tdir );\r\n\t\t\ttan2[ c ].add( tdir );\r\n\r\n\t\t}\r\n\r\n\t\tvar i, il;\r\n\t\tvar j, jl;\r\n\t\tvar iA, iB, iC;\r\n\r\n\t\tvar offsets = this.offsets;\r\n\r\n\t\tfor ( j = 0, jl = offsets.length; j < jl; ++ j ) {\r\n\r\n\t\t\tvar start = offsets[ j ].start;\r\n\t\t\tvar count = offsets[ j ].count;\r\n\t\t\tvar index = offsets[ j ].index;\r\n\r\n\t\t\tfor ( i = start, il = start + count; i < il; i += 3 ) {\r\n\r\n\t\t\t\tiA = index + indices[ i ];\r\n\t\t\t\tiB = index + indices[ i + 1 ];\r\n\t\t\t\tiC = index + indices[ i + 2 ];\r\n\r\n\t\t\t\thandleTriangle( iA, iB, iC );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3();\r\n\t\tvar n = new THREE.Vector3(), n2 = new THREE.Vector3();\r\n\t\tvar w, t, test;\r\n\r\n\t\tfunction handleVertex( v ) {\r\n\r\n\t\t\tn.x = normals[ v * 3 ];\r\n\t\t\tn.y = normals[ v * 3 + 1 ];\r\n\t\t\tn.z = normals[ v * 3 + 2 ];\r\n\r\n\t\t\tn2.copy( n );\r\n\r\n\t\t\tt = tan1[ v ];\r\n\r\n\t\t\t// Gram-Schmidt orthogonalize\r\n\r\n\t\t\ttmp.copy( t );\r\n\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\r\n\r\n\t\t\t// Calculate handedness\r\n\r\n\t\t\ttmp2.crossVectors( n2, t );\r\n\t\t\ttest = tmp2.dot( tan2[ v ] );\r\n\t\t\tw = ( test < 0.0 ) ? -1.0 : 1.0;\r\n\r\n\t\t\ttangents[ v * 4 ] \t  = tmp.x;\r\n\t\t\ttangents[ v * 4 + 1 ] = tmp.y;\r\n\t\t\ttangents[ v * 4 + 2 ] = tmp.z;\r\n\t\t\ttangents[ v * 4 + 3 ] = w;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( j = 0, jl = offsets.length; j < jl; ++ j ) {\r\n\r\n\t\t\tvar start = offsets[ j ].start;\r\n\t\t\tvar count = offsets[ j ].count;\r\n\t\t\tvar index = offsets[ j ].index;\r\n\r\n\t\t\tfor ( i = start, il = start + count; i < il; i += 3 ) {\r\n\r\n\t\t\t\tiA = index + indices[ i ];\r\n\t\t\t\tiB = index + indices[ i + 1 ];\r\n\t\t\t\tiC = index + indices[ i + 2 ];\r\n\r\n\t\t\t\thandleVertex( iA );\r\n\t\t\t\thandleVertex( iB );\r\n\t\t\t\thandleVertex( iC );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.hasTangents = true;\r\n\t\tthis.tangentsNeedUpdate = true;\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n */\r\n\r\nTHREE.Camera = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.matrixWorldInverse = new THREE.Matrix4();\r\n\r\n\tthis.projectionMatrix = new THREE.Matrix4();\r\n\tthis.projectionMatrixInverse = new THREE.Matrix4();\r\n\r\n};\r\n\r\nTHREE.Camera.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.Camera.prototype.lookAt = function ( vector ) {\r\n\r\n\t// TODO: Add hierarchy support.\r\n\r\n\tthis.matrix.lookAt( this.position, vector, this.up );\r\n\r\n\tif ( this.rotationAutoUpdate === true ) {\r\n\r\n\t\tif ( this.useQuaternion === false )  {\r\n\r\n\t\t\tthis.rotation.setEulerFromRotationMatrix( this.matrix, this.eulerOrder );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.quaternion.copy( this.matrix.decompose()[ 1 ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {\r\n\r\n\tTHREE.Camera.call( this );\r\n\r\n\tthis.left = left;\r\n\tthis.right = right;\r\n\tthis.top = top;\r\n\tthis.bottom = bottom;\r\n\r\n\tthis.near = ( near !== undefined ) ? near : 0.1;\r\n\tthis.far = ( far !== undefined ) ? far : 2000;\r\n\r\n\tthis.updateProjectionMatrix();\r\n\r\n};\r\n\r\nTHREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );\r\n\r\nTHREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {\r\n\r\n\tthis.projectionMatrix.makeOrthographic( this.left, this.right, this.top, this.bottom, this.near, this.far );\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author greggman / http://games.greggman.com/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n */\r\n\r\nTHREE.PerspectiveCamera = function ( fov, aspect, near, far ) {\r\n\r\n\tTHREE.Camera.call( this );\r\n\r\n\tthis.fov = fov !== undefined ? fov : 50;\r\n\tthis.aspect = aspect !== undefined ? aspect : 1;\r\n\tthis.near = near !== undefined ? near : 0.1;\r\n\tthis.far = far !== undefined ? far : 2000;\r\n\r\n\tthis.updateProjectionMatrix();\r\n\r\n};\r\n\r\nTHREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );\r\n\r\n\r\n/**\r\n * Uses Focal Length (in mm) to estimate and set FOV\r\n * 35mm (fullframe) camera is used if frame size is not specified;\r\n * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html\r\n */\r\n\r\nTHREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {\r\n\r\n\tif ( frameHeight === undefined ) frameHeight = 24;\r\n\r\n\tthis.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );\r\n\tthis.updateProjectionMatrix();\r\n\r\n}\r\n\r\n\r\n/**\r\n * Sets an offset in a larger frustum. This is useful for multi-window or\r\n * multi-monitor/multi-machine setups.\r\n *\r\n * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\r\n * the monitors are in grid like this\r\n *\r\n *   +---+---+---+\r\n *   | A | B | C |\r\n *   +---+---+---+\r\n *   | D | E | F |\r\n *   +---+---+---+\r\n *\r\n * then for each monitor you would call it like this\r\n *\r\n *   var w = 1920;\r\n *   var h = 1080;\r\n *   var fullWidth = w * 3;\r\n *   var fullHeight = h * 2;\r\n *\r\n *   --A--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\r\n *   --B--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\r\n *   --C--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\r\n *   --D--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\r\n *   --E--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\r\n *   --F--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\r\n *\r\n *   Note there is no reason monitors have to be the same size or in a grid.\r\n */\r\n\r\nTHREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {\r\n\r\n\tthis.fullWidth = fullWidth;\r\n\tthis.fullHeight = fullHeight;\r\n\tthis.x = x;\r\n\tthis.y = y;\r\n\tthis.width = width;\r\n\tthis.height = height;\r\n\r\n\tthis.updateProjectionMatrix();\r\n\r\n};\r\n\r\n\r\nTHREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {\r\n\r\n\tif ( this.fullWidth ) {\r\n\r\n\t\tvar aspect = this.fullWidth / this.fullHeight;\r\n\t\tvar top = Math.tan( THREE.Math.degToRad( this.fov * 0.5 ) ) * this.near;\r\n\t\tvar bottom = -top;\r\n\t\tvar left = aspect * bottom;\r\n\t\tvar right = aspect * top;\r\n\t\tvar width = Math.abs( right - left );\r\n\t\tvar height = Math.abs( top - bottom );\r\n\r\n\t\tthis.projectionMatrix.makeFrustum(\r\n\t\t\tleft + this.x * width / this.fullWidth,\r\n\t\t\tleft + ( this.x + this.width ) * width / this.fullWidth,\r\n\t\t\ttop - ( this.y + this.height ) * height / this.fullHeight,\r\n\t\t\ttop - this.y * height / this.fullHeight,\r\n\t\t\tthis.near,\r\n\t\t\tthis.far\r\n\t\t);\r\n\r\n\t} else {\r\n\r\n\t\tthis.projectionMatrix.makePerspective( this.fov, this.aspect, this.near, this.far );\r\n\r\n\t}\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n \r\nTHREE.Light = function ( hex ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.color = new THREE.Color( hex );\r\n\r\n};\r\n\r\nTHREE.Light.prototype = Object.create( THREE.Object3D.prototype );\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.AmbientLight = function ( hex ) {\r\n\r\n\tTHREE.Light.call( this, hex );\r\n\r\n};\r\n\r\nTHREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );\r\n/**\r\n * @author MPanknin / http://www.redplant.de/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.AreaLight = function ( hex, intensity ) {\r\n\r\n\tTHREE.Light.call( this, hex );\r\n\r\n\tthis.normal = new THREE.Vector3( 0, -1, 0 );\r\n\tthis.right = new THREE.Vector3( 1, 0, 0 );\r\n\r\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n\r\n\tthis.width = 1.0;\r\n\tthis.height = 1.0;\r\n\r\n\tthis.constantAttenuation = 1.5;\r\n\tthis.linearAttenuation = 0.5;\r\n\tthis.quadraticAttenuation = 0.1;\r\n\r\n};\r\n\r\nTHREE.AreaLight.prototype = Object.create( THREE.Light.prototype );\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.DirectionalLight = function ( hex, intensity ) {\r\n\r\n\tTHREE.Light.call( this, hex );\r\n\r\n\tthis.position = new THREE.Vector3( 0, 1, 0 );\r\n\tthis.target = new THREE.Object3D();\r\n\r\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n\r\n\tthis.castShadow = false;\r\n\tthis.onlyShadow = false;\r\n\r\n\t//\r\n\r\n\tthis.shadowCameraNear = 50;\r\n\tthis.shadowCameraFar = 5000;\r\n\r\n\tthis.shadowCameraLeft = -500;\r\n\tthis.shadowCameraRight = 500;\r\n\tthis.shadowCameraTop = 500;\r\n\tthis.shadowCameraBottom = -500;\r\n\r\n\tthis.shadowCameraVisible = false;\r\n\r\n\tthis.shadowBias = 0;\r\n\tthis.shadowDarkness = 0.5;\r\n\r\n\tthis.shadowMapWidth = 512;\r\n\tthis.shadowMapHeight = 512;\r\n\r\n\t//\r\n\r\n\tthis.shadowCascade = false;\r\n\r\n\tthis.shadowCascadeOffset = new THREE.Vector3( 0, 0, -1000 );\r\n\tthis.shadowCascadeCount = 2;\r\n\r\n\tthis.shadowCascadeBias = [ 0, 0, 0 ];\r\n\tthis.shadowCascadeWidth = [ 512, 512, 512 ];\r\n\tthis.shadowCascadeHeight = [ 512, 512, 512 ];\r\n\r\n\tthis.shadowCascadeNearZ = [ -1.000, 0.990, 0.998 ];\r\n\tthis.shadowCascadeFarZ  = [  0.990, 0.998, 1.000 ];\r\n\r\n\tthis.shadowCascadeArray = [];\r\n\r\n\t//\r\n\r\n\tthis.shadowMap = null;\r\n\tthis.shadowMapSize = null;\r\n\tthis.shadowCamera = null;\r\n\tthis.shadowMatrix = null;\r\n\r\n};\r\n\r\nTHREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.HemisphereLight = function ( skyColorHex, groundColorHex, intensity ) {\r\n\r\n\tTHREE.Light.call( this, skyColorHex );\r\n\r\n\tthis.groundColor = new THREE.Color( groundColorHex );\r\n\r\n\tthis.position = new THREE.Vector3( 0, 100, 0 );\r\n\r\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n\r\n};\r\n\r\nTHREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.PointLight = function ( hex, intensity, distance ) {\r\n\r\n\tTHREE.Light.call( this, hex );\r\n\r\n\tthis.position = new THREE.Vector3( 0, 0, 0 );\r\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\r\n\r\n};\r\n\r\nTHREE.PointLight.prototype = Object.create( THREE.Light.prototype );\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.SpotLight = function ( hex, intensity, distance, angle, exponent ) {\r\n\r\n\tTHREE.Light.call( this, hex );\r\n\r\n\tthis.position = new THREE.Vector3( 0, 1, 0 );\r\n\tthis.target = new THREE.Object3D();\r\n\r\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\r\n\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 2;\r\n\tthis.exponent = ( exponent !== undefined ) ? exponent : 10;\r\n\r\n\tthis.castShadow = false;\r\n\tthis.onlyShadow = false;\r\n\r\n\t//\r\n\r\n\tthis.shadowCameraNear = 50;\r\n\tthis.shadowCameraFar = 5000;\r\n\tthis.shadowCameraFov = 50;\r\n\r\n\tthis.shadowCameraVisible = false;\r\n\r\n\tthis.shadowBias = 0;\r\n\tthis.shadowDarkness = 0.5;\r\n\r\n\tthis.shadowMapWidth = 512;\r\n\tthis.shadowMapHeight = 512;\r\n\r\n\t//\r\n\r\n\tthis.shadowMap = null;\r\n\tthis.shadowMapSize = null;\r\n\tthis.shadowCamera = null;\r\n\tthis.shadowMatrix = null;\r\n\r\n};\r\n\r\nTHREE.SpotLight.prototype = Object.create( THREE.Light.prototype );\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Loader = function ( showStatus ) {\r\n\r\n\tthis.showStatus = showStatus;\r\n\tthis.statusDomElement = showStatus ? THREE.Loader.prototype.addStatusElement() : null;\r\n\r\n\tthis.onLoadStart = function () {};\r\n\tthis.onLoadProgress = function () {};\r\n\tthis.onLoadComplete = function () {};\r\n\r\n};\r\n\r\nTHREE.Loader.prototype = {\r\n\r\n\tconstructor: THREE.Loader,\r\n\r\n\tcrossOrigin: 'anonymous',\r\n\r\n\taddStatusElement: function () {\r\n\r\n\t\tvar e = document.createElement( \"div\" );\r\n\r\n\t\te.style.position = \"absolute\";\r\n\t\te.style.right = \"0px\";\r\n\t\te.style.top = \"0px\";\r\n\t\te.style.fontSize = \"0.8em\";\r\n\t\te.style.textAlign = \"left\";\r\n\t\te.style.background = \"rgba(0,0,0,0.25)\";\r\n\t\te.style.color = \"#fff\";\r\n\t\te.style.width = \"120px\";\r\n\t\te.style.padding = \"0.5em 0.5em 0.5em 0.5em\";\r\n\t\te.style.zIndex = 1000;\r\n\r\n\t\te.innerHTML = \"Loading ...\";\r\n\r\n\t\treturn e;\r\n\r\n\t},\r\n\r\n\tupdateProgress: function ( progress ) {\r\n\r\n\t\tvar message = \"Loaded \";\r\n\r\n\t\tif ( progress.total ) {\r\n\r\n\t\t\tmessage += ( 100 * progress.loaded / progress.total ).toFixed(0) + \"%\";\r\n\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmessage += ( progress.loaded / 1000 ).toFixed(2) + \" KB\";\r\n\r\n\t\t}\r\n\r\n\t\tthis.statusDomElement.innerHTML = message;\r\n\r\n\t},\r\n\r\n\textractUrlBase: function ( url ) {\r\n\r\n\t\tvar parts = url.split( '/' );\r\n\t\tparts.pop();\r\n\t\treturn ( parts.length < 1 ? '.' : parts.join( '/' ) ) + '/';\r\n\r\n\t},\r\n\r\n\tinitMaterials: function ( materials, texturePath ) {\r\n\r\n\t\tvar array = [];\r\n\r\n\t\tfor ( var i = 0; i < materials.length; ++ i ) {\r\n\r\n\t\t\tarray[ i ] = THREE.Loader.prototype.createMaterial( materials[ i ], texturePath );\r\n\r\n\t\t}\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tneedsTangents: function ( materials ) {\r\n\r\n\t\tfor( var i = 0, il = materials.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar m = materials[ i ];\r\n\r\n\t\t\tif ( m instanceof THREE.ShaderMaterial ) return true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t},\r\n\r\n\tcreateMaterial: function ( m, texturePath ) {\r\n\r\n\t\tvar _this = this;\r\n\r\n\t\tfunction is_pow2( n ) {\r\n\r\n\t\t\tvar l = Math.log( n ) / Math.LN2;\r\n\t\t\treturn Math.floor( l ) == l;\r\n\r\n\t\t}\r\n\r\n\t\tfunction nearest_pow2( n ) {\r\n\r\n\t\t\tvar l = Math.log( n ) / Math.LN2;\r\n\t\t\treturn Math.pow( 2, Math.round(  l ) );\r\n\r\n\t\t}\r\n\r\n\t\tfunction load_image( where, url ) {\r\n\r\n\t\t\tvar image = new Image();\r\n\r\n\t\t\timage.onload = function () {\r\n\r\n\t\t\t\tif ( !is_pow2( this.width ) || !is_pow2( this.height ) ) {\r\n\r\n\t\t\t\t\tvar width = nearest_pow2( this.width );\r\n\t\t\t\t\tvar height = nearest_pow2( this.height );\r\n\r\n\t\t\t\t\twhere.image.width = width;\r\n\t\t\t\t\twhere.image.height = height;\r\n\t\t\t\t\twhere.image.getContext( '2d' ).drawImage( this, 0, 0, width, height );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\twhere.image = this;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\twhere.needsUpdate = true;\r\n\r\n\t\t\t};\r\n\r\n\t\t\timage.crossOrigin = _this.crossOrigin;\r\n\t\t\timage.src = url;\r\n\r\n\t\t}\r\n\r\n\t\tfunction create_texture( where, name, sourceFile, repeat, offset, wrap, anisotropy ) {\r\n\r\n\t\t\tvar isCompressed = /\\.dds$/i.test( sourceFile );\r\n\t\t\tvar fullPath = texturePath + \"/\" + sourceFile;\r\n\r\n\t\t\tif ( isCompressed ) {\r\n\r\n\t\t\t\tvar texture = THREE.ImageUtils.loadCompressedTexture( fullPath );\r\n\r\n\t\t\t\twhere[ name ] = texture;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar texture = document.createElement( 'canvas' );\r\n\r\n\t\t\t\twhere[ name ] = new THREE.Texture( texture );\r\n\r\n\t\t\t}\r\n\r\n\t\t\twhere[ name ].sourceFile = sourceFile;\r\n\r\n\t\t\tif( repeat ) {\r\n\r\n\t\t\t\twhere[ name ].repeat.set( repeat[ 0 ], repeat[ 1 ] );\r\n\r\n\t\t\t\tif ( repeat[ 0 ] !== 1 ) where[ name ].wrapS = THREE.RepeatWrapping;\r\n\t\t\t\tif ( repeat[ 1 ] !== 1 ) where[ name ].wrapT = THREE.RepeatWrapping;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( offset ) {\r\n\r\n\t\t\t\twhere[ name ].offset.set( offset[ 0 ], offset[ 1 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( wrap ) {\r\n\r\n\t\t\t\tvar wrapMap = {\r\n\t\t\t\t\t\"repeat\": THREE.RepeatWrapping,\r\n\t\t\t\t\t\"mirror\": THREE.MirroredRepeatWrapping\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( wrapMap[ wrap[ 0 ] ] !== undefined ) where[ name ].wrapS = wrapMap[ wrap[ 0 ] ];\r\n\t\t\t\tif ( wrapMap[ wrap[ 1 ] ] !== undefined ) where[ name ].wrapT = wrapMap[ wrap[ 1 ] ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( anisotropy ) {\r\n\r\n\t\t\t\twhere[ name ].anisotropy = anisotropy;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! isCompressed ) {\r\n\r\n\t\t\t\tload_image( where[ name ], fullPath );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction rgb2hex( rgb ) {\r\n\r\n\t\t\treturn ( rgb[ 0 ] * 255 << 16 ) + ( rgb[ 1 ] * 255 << 8 ) + rgb[ 2 ] * 255;\r\n\r\n\t\t}\r\n\r\n\t\t// defaults\r\n\r\n\t\tvar mtype = \"MeshLambertMaterial\";\r\n\t\tvar mpars = { color: 0xeeeeee, opacity: 1.0, map: null, lightMap: null, normalMap: null, bumpMap: null, wireframe: false };\r\n\r\n\t\t// parameters from model file\r\n\r\n\t\tif ( m.shading ) {\r\n\r\n\t\t\tvar shading = m.shading.toLowerCase();\r\n\r\n\t\t\tif ( shading === \"phong\" ) mtype = \"MeshPhongMaterial\";\r\n\t\t\telse if ( shading === \"basic\" ) mtype = \"MeshBasicMaterial\";\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.blending !== undefined && THREE[ m.blending ] !== undefined ) {\r\n\r\n\t\t\tmpars.blending = THREE[ m.blending ];\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.transparent !== undefined || m.opacity < 1.0 ) {\r\n\r\n\t\t\tmpars.transparent = m.transparent;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.depthTest !== undefined ) {\r\n\r\n\t\t\tmpars.depthTest = m.depthTest;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.depthWrite !== undefined ) {\r\n\r\n\t\t\tmpars.depthWrite = m.depthWrite;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.visible !== undefined ) {\r\n\r\n\t\t\tmpars.visible = m.visible;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.flipSided !== undefined ) {\r\n\r\n\t\t\tmpars.side = THREE.BackSide;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.doubleSided !== undefined ) {\r\n\r\n\t\t\tmpars.side = THREE.DoubleSide;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.wireframe !== undefined ) {\r\n\r\n\t\t\tmpars.wireframe = m.wireframe;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.vertexColors !== undefined ) {\r\n\r\n\t\t\tif ( m.vertexColors === \"face\" ) {\r\n\r\n\t\t\t\tmpars.vertexColors = THREE.FaceColors;\r\n\r\n\t\t\t} else if ( m.vertexColors ) {\r\n\r\n\t\t\t\tmpars.vertexColors = THREE.VertexColors;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// colors\r\n\r\n\t\tif ( m.colorDiffuse ) {\r\n\r\n\t\t\tmpars.color = rgb2hex( m.colorDiffuse );\r\n\r\n\t\t} else if ( m.DbgColor ) {\r\n\r\n\t\t\tmpars.color = m.DbgColor;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.colorSpecular ) {\r\n\r\n\t\t\tmpars.specular = rgb2hex( m.colorSpecular );\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.colorAmbient ) {\r\n\r\n\t\t\tmpars.ambient = rgb2hex( m.colorAmbient );\r\n\r\n\t\t}\r\n\r\n\t\t// modifiers\r\n\r\n\t\tif ( m.transparency ) {\r\n\r\n\t\t\tmpars.opacity = m.transparency;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.specularCoef ) {\r\n\r\n\t\t\tmpars.shininess = m.specularCoef;\r\n\r\n\t\t}\r\n\r\n\t\t// textures\r\n\r\n\t\tif ( m.mapDiffuse && texturePath ) {\r\n\r\n\t\t\tcreate_texture( mpars, \"map\", m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.mapLight && texturePath ) {\r\n\r\n\t\t\tcreate_texture( mpars, \"lightMap\", m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.mapBump && texturePath ) {\r\n\r\n\t\t\tcreate_texture( mpars, \"bumpMap\", m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.mapNormal && texturePath ) {\r\n\r\n\t\t\tcreate_texture( mpars, \"normalMap\", m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.mapSpecular && texturePath ) {\r\n\r\n\t\t\tcreate_texture( mpars, \"specularMap\", m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tif ( m.mapBumpScale ) {\r\n\r\n\t\t\tmpars.bumpScale = m.mapBumpScale;\r\n\r\n\t\t}\r\n\r\n\t\t// special case for normal mapped material\r\n\r\n\t\tif ( m.mapNormal ) {\r\n\r\n\t\t\tvar shader = THREE.ShaderLib[ \"normalmap\" ];\r\n\t\t\tvar uniforms = THREE.UniformsUtils.clone( shader.uniforms );\r\n\r\n\t\t\tuniforms[ \"tNormal\" ].value = mpars.normalMap;\r\n\r\n\t\t\tif ( m.mapNormalFactor ) {\r\n\r\n\t\t\t\tuniforms[ \"uNormalScale\" ].value.set( m.mapNormalFactor, m.mapNormalFactor );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( mpars.map ) {\r\n\r\n\t\t\t\tuniforms[ \"tDiffuse\" ].value = mpars.map;\r\n\t\t\t\tuniforms[ \"enableDiffuse\" ].value = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( mpars.specularMap ) {\r\n\r\n\t\t\t\tuniforms[ \"tSpecular\" ].value = mpars.specularMap;\r\n\t\t\t\tuniforms[ \"enableSpecular\" ].value = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( mpars.lightMap ) {\r\n\r\n\t\t\t\tuniforms[ \"tAO\" ].value = mpars.lightMap;\r\n\t\t\t\tuniforms[ \"enableAO\" ].value = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// for the moment don't handle displacement texture\r\n\r\n\t\t\tuniforms[ \"uDiffuseColor\" ].value.setHex( mpars.color );\r\n\t\t\tuniforms[ \"uSpecularColor\" ].value.setHex( mpars.specular );\r\n\t\t\tuniforms[ \"uAmbientColor\" ].value.setHex( mpars.ambient );\r\n\r\n\t\t\tuniforms[ \"uShininess\" ].value = mpars.shininess;\r\n\r\n\t\t\tif ( mpars.opacity !== undefined ) {\r\n\r\n\t\t\t\tuniforms[ \"uOpacity\" ].value = mpars.opacity;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms, lights: true, fog: true };\r\n\t\t\tvar material = new THREE.ShaderMaterial( parameters );\r\n\r\n\t\t\tif ( mpars.transparent ) {\r\n\r\n\t\t\t\tmaterial.transparent = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar material = new THREE[ mtype ]( mpars );\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.DbgName !== undefined ) material.name = m.DbgName;\r\n\r\n\t\treturn material;\r\n\r\n\t}\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.ImageLoader = function () {\r\n\r\n\tTHREE.EventDispatcher.call( this );\r\n\r\n\tthis.crossOrigin = null;\r\n\r\n};\r\n\r\nTHREE.ImageLoader.prototype = {\r\n\r\n\tconstructor: THREE.ImageLoader,\r\n\r\n\tload: function ( url, image ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tif ( image === undefined ) image = new Image();\r\n\r\n\t\timage.addEventListener( 'load', function () {\r\n\r\n\t\t\tscope.dispatchEvent( { type: 'load', content: image } );\r\n\r\n\t\t}, false );\r\n\r\n\t\timage.addEventListener( 'error', function () {\r\n\r\n\t\t\tscope.dispatchEvent( { type: 'error', message: 'Couldn\\'t load URL [' + url + ']' } );\r\n\r\n\t\t}, false );\r\n\r\n\t\tif ( scope.crossOrigin ) image.crossOrigin = scope.crossOrigin;\r\n\r\n\t\timage.src = url;\r\n\r\n\t}\r\n\r\n}\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.JSONLoader = function ( showStatus ) {\r\n\r\n\tTHREE.Loader.call( this, showStatus );\r\n\r\n\tthis.withCredentials = false;\r\n\r\n};\r\n\r\nTHREE.JSONLoader.prototype = Object.create( THREE.Loader.prototype );\r\n\r\nTHREE.JSONLoader.prototype.load = function ( url, callback, texturePath ) {\r\n\r\n\tvar scope = this;\r\n\r\n\t// todo: unify load API to for easier SceneLoader use\r\n\r\n\ttexturePath = texturePath && ( typeof texturePath === \"string\" ) ? texturePath : this.extractUrlBase( url );\r\n\r\n\tthis.onLoadStart();\r\n\tthis.loadAjaxJSON( this, url, callback, texturePath );\r\n\r\n};\r\n\r\nTHREE.JSONLoader.prototype.loadAjaxJSON = function ( context, url, callback, texturePath, callbackProgress ) {\r\n\r\n\tvar xhr = new XMLHttpRequest();\r\n\r\n\tvar length = 0;\r\n\r\n\txhr.onreadystatechange = function () {\r\n\r\n\t\tif ( xhr.readyState === xhr.DONE ) {\r\n\r\n\t\t\tif ( xhr.status === 200 || xhr.status === 0 ) {\r\n\r\n\t\t\t\tif ( xhr.responseText ) {\r\n\r\n\t\t\t\t\tvar json = JSON.parse( xhr.responseText );\r\n\t\t\t\t\tcontext.createModel( json, callback, texturePath );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.warn( \"THREE.JSONLoader: [\" + url + \"] seems to be unreachable or file there is empty\" );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// in context of more complex asset initialization\r\n\t\t\t\t// do not block on single failed file\r\n\t\t\t\t// maybe should go even one more level up\r\n\r\n\t\t\t\tcontext.onLoadComplete();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.error( \"THREE.JSONLoader: Couldn't load [\" + url + \"] [\" + xhr.status + \"]\" );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( xhr.readyState === xhr.LOADING ) {\r\n\r\n\t\t\tif ( callbackProgress ) {\r\n\r\n\t\t\t\tif ( length === 0 ) {\r\n\r\n\t\t\t\t\tlength = xhr.getResponseHeader( \"Content-Length\" );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcallbackProgress( { total: length, loaded: xhr.responseText.length } );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( xhr.readyState === xhr.HEADERS_RECEIVED ) {\r\n\r\n\t\t\tlength = xhr.getResponseHeader( \"Content-Length\" );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\txhr.open( \"GET\", url, true );\r\n\txhr.withCredentials = this.withCredentials;\r\n\txhr.send( null );\r\n\r\n};\r\n\r\nTHREE.JSONLoader.prototype.createModel = function ( json, callback, texturePath ) {\r\n\r\n\tvar scope = this,\r\n\tgeometry = new THREE.Geometry(),\r\n\tscale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;\r\n\r\n\tparseModel( scale );\r\n\r\n\tparseSkin();\r\n\tparseMorphing( scale );\r\n\r\n\tgeometry.computeCentroids();\r\n\tgeometry.computeFaceNormals();\r\n\r\n\tfunction parseModel( scale ) {\r\n\r\n\t\tfunction isBitSet( value, position ) {\r\n\r\n\t\t\treturn value & ( 1 << position );\r\n\r\n\t\t}\r\n\r\n\t\tvar i, j, fi,\r\n\r\n\t\toffset, zLength, nVertices,\r\n\r\n\t\tcolorIndex, normalIndex, uvIndex, materialIndex,\r\n\r\n\t\ttype,\r\n\t\tisQuad,\r\n\t\thasMaterial,\r\n\t\thasFaceUv, hasFaceVertexUv,\r\n\t\thasFaceNormal, hasFaceVertexNormal,\r\n\t\thasFaceColor, hasFaceVertexColor,\r\n\r\n\t\tvertex, face, color, normal,\r\n\r\n\t\tuvLayer, uvs, u, v,\r\n\r\n\t\tfaces = json.faces,\r\n\t\tvertices = json.vertices,\r\n\t\tnormals = json.normals,\r\n\t\tcolors = json.colors,\r\n\r\n\t\tnUvLayers = 0;\r\n\r\n\t\t// disregard empty arrays\r\n\r\n\t\tfor ( i = 0; i < json.uvs.length; i++ ) {\r\n\r\n\t\t\tif ( json.uvs[ i ].length ) nUvLayers ++;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( i = 0; i < nUvLayers; i++ ) {\r\n\r\n\t\t\tgeometry.faceUvs[ i ] = [];\r\n\t\t\tgeometry.faceVertexUvs[ i ] = [];\r\n\r\n\t\t}\r\n\r\n\t\toffset = 0;\r\n\t\tzLength = vertices.length;\r\n\r\n\t\twhile ( offset < zLength ) {\r\n\r\n\t\t\tvertex = new THREE.Vector3();\r\n\r\n\t\t\tvertex.x = vertices[ offset ++ ] * scale;\r\n\t\t\tvertex.y = vertices[ offset ++ ] * scale;\r\n\t\t\tvertex.z = vertices[ offset ++ ] * scale;\r\n\r\n\t\t\tgeometry.vertices.push( vertex );\r\n\r\n\t\t}\r\n\r\n\t\toffset = 0;\r\n\t\tzLength = faces.length;\r\n\r\n\t\twhile ( offset < zLength ) {\r\n\r\n\t\t\ttype = faces[ offset ++ ];\r\n\r\n\r\n\t\t\tisQuad          \t= isBitSet( type, 0 );\r\n\t\t\thasMaterial         = isBitSet( type, 1 );\r\n\t\t\thasFaceUv           = isBitSet( type, 2 );\r\n\t\t\thasFaceVertexUv     = isBitSet( type, 3 );\r\n\t\t\thasFaceNormal       = isBitSet( type, 4 );\r\n\t\t\thasFaceVertexNormal = isBitSet( type, 5 );\r\n\t\t\thasFaceColor\t    = isBitSet( type, 6 );\r\n\t\t\thasFaceVertexColor  = isBitSet( type, 7 );\r\n\r\n\t\t\t//console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceUv, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\r\n\r\n\t\t\tif ( isQuad ) {\r\n\r\n\t\t\t\tface = new THREE.Face4();\r\n\r\n\t\t\t\tface.a = faces[ offset ++ ];\r\n\t\t\t\tface.b = faces[ offset ++ ];\r\n\t\t\t\tface.c = faces[ offset ++ ];\r\n\t\t\t\tface.d = faces[ offset ++ ];\r\n\r\n\t\t\t\tnVertices = 4;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tface = new THREE.Face3();\r\n\r\n\t\t\t\tface.a = faces[ offset ++ ];\r\n\t\t\t\tface.b = faces[ offset ++ ];\r\n\t\t\t\tface.c = faces[ offset ++ ];\r\n\r\n\t\t\t\tnVertices = 3;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasMaterial ) {\r\n\r\n\t\t\t\tmaterialIndex = faces[ offset ++ ];\r\n\t\t\t\tface.materialIndex = materialIndex;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// to get face <=> uv index correspondence\r\n\r\n\t\t\tfi = geometry.faces.length;\r\n\r\n\t\t\tif ( hasFaceUv ) {\r\n\r\n\t\t\t\tfor ( i = 0; i < nUvLayers; i++ ) {\r\n\r\n\t\t\t\t\tuvLayer = json.uvs[ i ];\r\n\r\n\t\t\t\t\tuvIndex = faces[ offset ++ ];\r\n\r\n\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\r\n\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\r\n\r\n\t\t\t\t\tgeometry.faceUvs[ i ][ fi ] = new THREE.Vector2( u, v );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceVertexUv ) {\r\n\r\n\t\t\t\tfor ( i = 0; i < nUvLayers; i++ ) {\r\n\r\n\t\t\t\t\tuvLayer = json.uvs[ i ];\r\n\r\n\t\t\t\t\tuvs = [];\r\n\r\n\t\t\t\t\tfor ( j = 0; j < nVertices; j ++ ) {\r\n\r\n\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\r\n\r\n\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\r\n\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\r\n\r\n\t\t\t\t\t\tuvs[ j ] = new THREE.Vector2( u, v );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = uvs;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceNormal ) {\r\n\r\n\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\r\n\t\t\t\tnormal = new THREE.Vector3();\r\n\r\n\t\t\t\tnormal.x = normals[ normalIndex ++ ];\r\n\t\t\t\tnormal.y = normals[ normalIndex ++ ];\r\n\t\t\t\tnormal.z = normals[ normalIndex ];\r\n\r\n\t\t\t\tface.normal = normal;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceVertexNormal ) {\r\n\r\n\t\t\t\tfor ( i = 0; i < nVertices; i++ ) {\r\n\r\n\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\r\n\t\t\t\t\tnormal = new THREE.Vector3();\r\n\r\n\t\t\t\t\tnormal.x = normals[ normalIndex ++ ];\r\n\t\t\t\t\tnormal.y = normals[ normalIndex ++ ];\r\n\t\t\t\t\tnormal.z = normals[ normalIndex ];\r\n\r\n\t\t\t\t\tface.vertexNormals.push( normal );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tif ( hasFaceColor ) {\r\n\r\n\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\r\n\t\t\t\tcolor = new THREE.Color( colors[ colorIndex ] );\r\n\t\t\t\tface.color = color;\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tif ( hasFaceVertexColor ) {\r\n\r\n\t\t\t\tfor ( i = 0; i < nVertices; i++ ) {\r\n\r\n\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\r\n\t\t\t\t\tcolor = new THREE.Color( colors[ colorIndex ] );\r\n\t\t\t\t\tface.vertexColors.push( color );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.faces.push( face );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction parseSkin() {\r\n\r\n\t\tvar i, l, x, y, z, w, a, b, c, d;\r\n\r\n\t\tif ( json.skinWeights ) {\r\n\r\n\t\t\tfor ( i = 0, l = json.skinWeights.length; i < l; i += 2 ) {\r\n\r\n\t\t\t\tx = json.skinWeights[ i     ];\r\n\t\t\t\ty = json.skinWeights[ i + 1 ];\r\n\t\t\t\tz = 0;\r\n\t\t\t\tw = 0;\r\n\r\n\t\t\t\tgeometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( json.skinIndices ) {\r\n\r\n\t\t\tfor ( i = 0, l = json.skinIndices.length; i < l; i += 2 ) {\r\n\r\n\t\t\t\ta = json.skinIndices[ i     ];\r\n\t\t\t\tb = json.skinIndices[ i + 1 ];\r\n\t\t\t\tc = 0;\r\n\t\t\t\td = 0;\r\n\r\n\t\t\t\tgeometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tgeometry.bones = json.bones;\r\n\t\tgeometry.animation = json.animation;\r\n\r\n\t};\r\n\r\n\tfunction parseMorphing( scale ) {\r\n\r\n\t\tif ( json.morphTargets !== undefined ) {\r\n\r\n\t\t\tvar i, l, v, vl, dstVertices, srcVertices;\r\n\r\n\t\t\tfor ( i = 0, l = json.morphTargets.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tgeometry.morphTargets[ i ] = {};\r\n\t\t\t\tgeometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\r\n\t\t\t\tgeometry.morphTargets[ i ].vertices = [];\r\n\r\n\t\t\t\tdstVertices = geometry.morphTargets[ i ].vertices;\r\n\t\t\t\tsrcVertices = json.morphTargets [ i ].vertices;\r\n\r\n\t\t\t\tfor( v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\r\n\r\n\t\t\t\t\tvar vertex = new THREE.Vector3();\r\n\t\t\t\t\tvertex.x = srcVertices[ v ] * scale;\r\n\t\t\t\t\tvertex.y = srcVertices[ v + 1 ] * scale;\r\n\t\t\t\t\tvertex.z = srcVertices[ v + 2 ] * scale;\r\n\r\n\t\t\t\t\tdstVertices.push( vertex );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( json.morphColors !== undefined ) {\r\n\r\n\t\t\tvar i, l, c, cl, dstColors, srcColors, color;\r\n\r\n\t\t\tfor ( i = 0, l = json.morphColors.length; i < l; i++ ) {\r\n\r\n\t\t\t\tgeometry.morphColors[ i ] = {};\r\n\t\t\t\tgeometry.morphColors[ i ].name = json.morphColors[ i ].name;\r\n\t\t\t\tgeometry.morphColors[ i ].colors = [];\r\n\r\n\t\t\t\tdstColors = geometry.morphColors[ i ].colors;\r\n\t\t\t\tsrcColors = json.morphColors [ i ].colors;\r\n\r\n\t\t\t\tfor ( c = 0, cl = srcColors.length; c < cl; c += 3 ) {\r\n\r\n\t\t\t\t\tcolor = new THREE.Color( 0xffaa00 );\r\n\t\t\t\t\tcolor.setRGB( srcColors[ c ], srcColors[ c + 1 ], srcColors[ c + 2 ] );\r\n\t\t\t\t\tdstColors.push( color );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar materials = this.initMaterials( json.materials, texturePath );\r\n\r\n\tif ( this.needsTangents( materials ) ) geometry.computeTangents();\r\n\r\n\tcallback( geometry, materials );\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.LoadingMonitor = function () {\r\n\r\n\tTHREE.EventDispatcher.call( this );\r\n\r\n\tvar scope = this;\r\n\r\n\tvar loaded = 0;\r\n\tvar total = 0;\r\n\r\n\tvar onLoad = function ( event ) {\r\n\r\n\t\tloaded ++;\r\n\r\n\t\tscope.dispatchEvent( { type: 'progress', loaded: loaded, total: total } );\r\n\r\n\t\tif ( loaded === total ) {\r\n\r\n\t\t\tscope.dispatchEvent( { type: 'load' } );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.add = function ( loader ) {\r\n\r\n\t\ttotal ++;\r\n\r\n\t\tloader.addEventListener( 'load', onLoad, false );\r\n\r\n\t};\r\n\r\n};\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.SceneLoader = function () {\r\n\r\n\tthis.onLoadStart = function () {};\r\n\tthis.onLoadProgress = function() {};\r\n\tthis.onLoadComplete = function () {};\r\n\r\n\tthis.callbackSync = function () {};\r\n\tthis.callbackProgress = function () {};\r\n\r\n\tthis.geometryHandlerMap = {};\r\n\tthis.hierarchyHandlerMap = {};\r\n\r\n\tthis.addGeometryHandler( \"ascii\", THREE.JSONLoader );\r\n\r\n};\r\n\r\nTHREE.SceneLoader.prototype.constructor = THREE.SceneLoader;\r\n\r\nTHREE.SceneLoader.prototype.load = function ( url, callbackFinished ) {\r\n\r\n\tvar scope = this;\r\n\r\n\tvar xhr = new XMLHttpRequest();\r\n\r\n\txhr.onreadystatechange = function () {\r\n\r\n\t\tif ( xhr.readyState === 4 ) {\r\n\r\n\t\t\tif ( xhr.status === 200 || xhr.status === 0 ) {\r\n\r\n\t\t\t\tvar json = JSON.parse( xhr.responseText );\r\n\t\t\t\tscope.parse( json, callbackFinished, url );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.error( \"THREE.SceneLoader: Couldn't load [\" + url + \"] [\" + xhr.status + \"]\" );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\txhr.open( \"GET\", url, true );\r\n\txhr.send( null );\r\n\r\n};\r\n\r\nTHREE.SceneLoader.prototype.addGeometryHandler = function ( typeID, loaderClass ) {\r\n\r\n\tthis.geometryHandlerMap[ typeID ] = { \"loaderClass\": loaderClass };\r\n\r\n};\r\n\r\nTHREE.SceneLoader.prototype.addHierarchyHandler = function ( typeID, loaderClass ) {\r\n\r\n\tthis.hierarchyHandlerMap[ typeID ] = { \"loaderClass\": loaderClass };\r\n\r\n};\r\n\r\nTHREE.SceneLoader.prototype.parse = function ( json, callbackFinished, url ) {\r\n\r\n\tvar scope = this;\r\n\r\n\tvar urlBase = THREE.Loader.prototype.extractUrlBase( url );\r\n\r\n\tvar geometry, material, camera, fog,\r\n\t\ttexture, images, color,\r\n\t\tlight, hex, intensity,\r\n\t\tcounter_models, counter_textures,\r\n\t\ttotal_models, total_textures,\r\n\t\tresult;\r\n\r\n\tvar target_array = [];\r\n\r\n\tvar data = json;\r\n\r\n\t// async geometry loaders\r\n\r\n\tfor ( var typeID in this.geometryHandlerMap ) {\r\n\r\n\t\tvar loaderClass = this.geometryHandlerMap[ typeID ][ \"loaderClass\" ];\r\n\t\tthis.geometryHandlerMap[ typeID ][ \"loaderObject\" ] = new loaderClass();\r\n\r\n\t}\r\n\r\n\t// async hierachy loaders\r\n\r\n\tfor ( var typeID in this.hierarchyHandlerMap ) {\r\n\r\n\t\tvar loaderClass = this.hierarchyHandlerMap[ typeID ][ \"loaderClass\" ];\r\n\t\tthis.hierarchyHandlerMap[ typeID ][ \"loaderObject\" ] = new loaderClass();\r\n\r\n\t}\r\n\r\n\tcounter_models = 0;\r\n\tcounter_textures = 0;\r\n\r\n\tresult = {\r\n\r\n\t\tscene: new THREE.Scene(),\r\n\t\tgeometries: {},\r\n\t\tface_materials: {},\r\n\t\tmaterials: {},\r\n\t\ttextures: {},\r\n\t\tobjects: {},\r\n\t\tcameras: {},\r\n\t\tlights: {},\r\n\t\tfogs: {},\r\n\t\tempties: {},\r\n\t\tgroups: {}\r\n\r\n\t};\r\n\r\n\tif ( data.transform ) {\r\n\r\n\t\tvar position = data.transform.position,\r\n\t\t\trotation = data.transform.rotation,\r\n\t\t\tscale = data.transform.scale;\r\n\r\n\t\tif ( position )\r\n\t\t\tresult.scene.position.set( position[ 0 ], position[ 1 ], position [ 2 ] );\r\n\r\n\t\tif ( rotation )\r\n\t\t\tresult.scene.rotation.set( rotation[ 0 ], rotation[ 1 ], rotation [ 2 ] );\r\n\r\n\t\tif ( scale )\r\n\t\t\tresult.scene.scale.set( scale[ 0 ], scale[ 1 ], scale [ 2 ] );\r\n\r\n\t\tif ( position || rotation || scale ) {\r\n\r\n\t\t\tresult.scene.updateMatrix();\r\n\t\t\tresult.scene.updateMatrixWorld();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction get_url( source_url, url_type ) {\r\n\r\n\t\tif ( url_type == \"relativeToHTML\" ) {\r\n\r\n\t\t\treturn source_url;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn urlBase + \"/\" + source_url;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// toplevel loader function, delegates to handle_children\r\n\r\n\tfunction handle_objects() {\r\n\r\n\t\thandle_children( result.scene, data.objects );\r\n\r\n\t}\r\n\r\n\t// handle all the children from the loaded json and attach them to given parent\r\n\r\n\tfunction handle_children( parent, children ) {\r\n\r\n\t\tvar mat, dst, pos, rot, scl, quat;\r\n\r\n\t\tfor ( var objID in children ) {\r\n\r\n\t\t\t// check by id if child has already been handled,\r\n\t\t\t// if not, create new object\r\n\r\n\t\t\tif ( result.objects[ objID ] === undefined ) {\r\n\r\n\t\t\t\tvar objJSON = children[ objID ];\r\n\r\n\t\t\t\tvar object = null;\r\n\r\n\t\t\t\t// meshes\r\n\r\n\t\t\t\tif ( objJSON.type && ( objJSON.type in scope.hierarchyHandlerMap ) ) {\r\n\r\n\t\t\t\t\tif ( objJSON.loading === undefined ) {\r\n\r\n\t\t\t\t\t\tvar reservedTypes = { \"type\": 1, \"url\": 1, \"material\": 1,\r\n\t\t\t\t\t\t\t\t\t\t\t  \"position\": 1, \"rotation\": 1, \"scale\" : 1,\r\n\t\t\t\t\t\t\t\t\t\t\t  \"visible\": 1, \"children\": 1, \"properties\": 1,\r\n\t\t\t\t\t\t\t\t\t\t\t  \"skin\": 1, \"morph\": 1, \"mirroredLoop\": 1, \"duration\": 1 };\r\n\r\n\t\t\t\t\t\tvar loaderParameters = {};\r\n\r\n\t\t\t\t\t\tfor ( var parType in objJSON ) {\r\n\r\n\t\t\t\t\t\t\tif ( ! ( parType in reservedTypes ) ) {\r\n\r\n\t\t\t\t\t\t\t\tloaderParameters[ parType ] = objJSON[ parType ];\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tmaterial = result.materials[ objJSON.material ];\r\n\r\n\t\t\t\t\t\tobjJSON.loading = true;\r\n\r\n\t\t\t\t\t\tvar loader = scope.hierarchyHandlerMap[ objJSON.type ][ \"loaderObject\" ];\r\n\r\n\t\t\t\t\t\t// ColladaLoader\r\n\r\n\t\t\t\t\t\tif ( loader.options ) {\r\n\r\n\t\t\t\t\t\t\tloader.load( get_url( objJSON.url, data.urlBaseType ), create_callback_hierachy( objID, parent, material, objJSON ) );\r\n\r\n\t\t\t\t\t\t// UTF8Loader\r\n\t\t\t\t\t\t// OBJLoader\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tloader.load( get_url( objJSON.url, data.urlBaseType ), create_callback_hierachy( objID, parent, material, objJSON ), loaderParameters );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( objJSON.geometry !== undefined ) {\r\n\r\n\t\t\t\t\tgeometry = result.geometries[ objJSON.geometry ];\r\n\r\n\t\t\t\t\t// geometry already loaded\r\n\r\n\t\t\t\t\tif ( geometry ) {\r\n\r\n\t\t\t\t\t\tvar needsTangents = false;\r\n\r\n\t\t\t\t\t\tmaterial = result.materials[ objJSON.material ];\r\n\t\t\t\t\t\tneedsTangents = material instanceof THREE.ShaderMaterial;\r\n\r\n\t\t\t\t\t\tpos = objJSON.position;\r\n\t\t\t\t\t\trot = objJSON.rotation;\r\n\t\t\t\t\t\tscl = objJSON.scale;\r\n\t\t\t\t\t\tmat = objJSON.matrix;\r\n\t\t\t\t\t\tquat = objJSON.quaternion;\r\n\r\n\t\t\t\t\t\t// use materials from the model file\r\n\t\t\t\t\t\t// if there is no material specified in the object\r\n\r\n\t\t\t\t\t\tif ( ! objJSON.material ) {\r\n\r\n\t\t\t\t\t\t\tmaterial = new THREE.MeshFaceMaterial( result.face_materials[ objJSON.geometry ] );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// use materials from the model file\r\n\t\t\t\t\t\t// if there is just empty face material\r\n\t\t\t\t\t\t// (must create new material as each model has its own face material)\r\n\r\n\t\t\t\t\t\tif ( ( material instanceof THREE.MeshFaceMaterial ) && material.materials.length === 0 ) {\r\n\r\n\t\t\t\t\t\t\tmaterial = new THREE.MeshFaceMaterial( result.face_materials[ objJSON.geometry ] );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( material instanceof THREE.MeshFaceMaterial ) {\r\n\r\n\t\t\t\t\t\t\tfor ( var i = 0; i < material.materials.length; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tneedsTangents = needsTangents || ( material.materials[ i ] instanceof THREE.ShaderMaterial );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( needsTangents ) {\r\n\r\n\t\t\t\t\t\t\tgeometry.computeTangents();\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( objJSON.skin ) {\r\n\r\n\t\t\t\t\t\t\tobject = new THREE.SkinnedMesh( geometry, material );\r\n\r\n\t\t\t\t\t\t} else if ( objJSON.morph ) {\r\n\r\n\t\t\t\t\t\t\tobject = new THREE.MorphAnimMesh( geometry, material );\r\n\r\n\t\t\t\t\t\t\tif ( objJSON.duration !== undefined ) {\r\n\r\n\t\t\t\t\t\t\t\tobject.duration = objJSON.duration;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( objJSON.time !== undefined ) {\r\n\r\n\t\t\t\t\t\t\t\tobject.time = objJSON.time;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( objJSON.mirroredLoop !== undefined ) {\r\n\r\n\t\t\t\t\t\t\t\tobject.mirroredLoop = objJSON.mirroredLoop;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( material.morphNormals ) {\r\n\r\n\t\t\t\t\t\t\t\tgeometry.computeMorphNormals();\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tobject = new THREE.Mesh( geometry, material );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tobject.name = objID;\r\n\r\n\t\t\t\t\t\tif ( mat ) {\r\n\r\n\t\t\t\t\t\t\tobject.matrixAutoUpdate = false;\r\n\t\t\t\t\t\t\tobject.matrix.set(\r\n\t\t\t\t\t\t\t\tmat[0],  mat[1],  mat[2],  mat[3],\r\n\t\t\t\t\t\t\t\tmat[4],  mat[5],  mat[6],  mat[7],\r\n\t\t\t\t\t\t\t\tmat[8],  mat[9],  mat[10], mat[11],\r\n\t\t\t\t\t\t\t\tmat[12], mat[13], mat[14], mat[15]\r\n\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tobject.position.set( pos[0], pos[1], pos[2] );\r\n\r\n\t\t\t\t\t\t\tif ( quat ) {\r\n\r\n\t\t\t\t\t\t\t\tobject.quaternion.set( quat[0], quat[1], quat[2], quat[3] );\r\n\t\t\t\t\t\t\t\tobject.useQuaternion = true;\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tobject.rotation.set( rot[0], rot[1], rot[2] );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tobject.scale.set( scl[0], scl[1], scl[2] );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tobject.visible = objJSON.visible;\r\n\t\t\t\t\t\tobject.castShadow = objJSON.castShadow;\r\n\t\t\t\t\t\tobject.receiveShadow = objJSON.receiveShadow;\r\n\r\n\t\t\t\t\t\tparent.add( object );\r\n\r\n\t\t\t\t\t\tresult.objects[ objID ] = object;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t// lights\r\n\r\n\t\t\t\t} else if ( objJSON.type === \"DirectionalLight\" || objJSON.type === \"PointLight\" || objJSON.type === \"AmbientLight\" ) {\r\n\r\n\t\t\t\t\thex = ( objJSON.color !== undefined ) ? objJSON.color : 0xffffff;\r\n\t\t\t\t\tintensity = ( objJSON.intensity !== undefined ) ? objJSON.intensity : 1;\r\n\r\n\t\t\t\t\tif ( objJSON.type === \"DirectionalLight\" ) {\r\n\r\n\t\t\t\t\t\tpos = objJSON.direction;\r\n\r\n\t\t\t\t\t\tlight = new THREE.DirectionalLight( hex, intensity );\r\n\t\t\t\t\t\tlight.position.set( pos[0], pos[1], pos[2] );\r\n\r\n\t\t\t\t\t\tif ( objJSON.target ) {\r\n\r\n\t\t\t\t\t\t\ttarget_array.push( { \"object\": light, \"targetName\" : objJSON.target } );\r\n\r\n\t\t\t\t\t\t\t// kill existing default target\r\n\t\t\t\t\t\t\t// otherwise it gets added to scene when parent gets added\r\n\r\n\t\t\t\t\t\t\tlight.target = null;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( objJSON.type === \"PointLight\" ) {\r\n\r\n\t\t\t\t\t\tpos = objJSON.position;\r\n\t\t\t\t\t\tdst = objJSON.distance;\r\n\r\n\t\t\t\t\t\tlight = new THREE.PointLight( hex, intensity, dst );\r\n\t\t\t\t\t\tlight.position.set( pos[0], pos[1], pos[2] );\r\n\r\n\t\t\t\t\t} else if ( objJSON.type === \"AmbientLight\" ) {\r\n\r\n\t\t\t\t\t\tlight = new THREE.AmbientLight( hex );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tparent.add( light );\r\n\r\n\t\t\t\t\tlight.name = objID;\r\n\t\t\t\t\tresult.lights[ objID ] = light;\r\n\t\t\t\t\tresult.objects[ objID ] = light;\r\n\r\n\t\t\t\t// cameras\r\n\r\n\t\t\t\t} else if ( objJSON.type === \"PerspectiveCamera\" || objJSON.type === \"OrthographicCamera\" ) {\r\n\r\n\t\t\t\t\tif ( objJSON.type === \"PerspectiveCamera\" ) {\r\n\r\n\t\t\t\t\t\tcamera = new THREE.PerspectiveCamera( objJSON.fov, objJSON.aspect, objJSON.near, objJSON.far );\r\n\r\n\t\t\t\t\t} else if ( objJSON.type === \"OrthographicCamera\" ) {\r\n\r\n\t\t\t\t\t\tcamera = new THREE.OrthographicCamera( objJSON.left, objJSON.right, objJSON.top, objJSON.bottom, objJSON.near, objJSON.far );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tpos = objJSON.position;\r\n\t\t\t\t\tcamera.position.set( pos[0], pos[1], pos[2] );\r\n\t\t\t\t\tparent.add( camera );\r\n\r\n\t\t\t\t\tcamera.name = objID;\r\n\t\t\t\t\tresult.cameras[ objID ] = camera;\r\n\t\t\t\t\tresult.objects[ objID ] = camera;\r\n\r\n\t\t\t\t// pure Object3D\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tpos = objJSON.position;\r\n\t\t\t\t\trot = objJSON.rotation;\r\n\t\t\t\t\tscl = objJSON.scale;\r\n\t\t\t\t\tquat = objJSON.quaternion;\r\n\r\n\t\t\t\t\tobject = new THREE.Object3D();\r\n\t\t\t\t\tobject.name = objID;\r\n\t\t\t\t\tobject.position.set( pos[0], pos[1], pos[2] );\r\n\r\n\t\t\t\t\tif ( quat ) {\r\n\r\n\t\t\t\t\t\tobject.quaternion.set( quat[0], quat[1], quat[2], quat[3] );\r\n\t\t\t\t\t\tobject.useQuaternion = true;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tobject.rotation.set( rot[0], rot[1], rot[2] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tobject.scale.set( scl[0], scl[1], scl[2] );\r\n\t\t\t\t\tobject.visible = ( objJSON.visible !== undefined ) ? objJSON.visible : false;\r\n\r\n\t\t\t\t\tparent.add( object );\r\n\r\n\t\t\t\t\tresult.objects[ objID ] = object;\r\n\t\t\t\t\tresult.empties[ objID ] = object;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( object ) {\r\n\r\n\t\t\t\t\tif ( objJSON.properties !== undefined )  {\r\n\r\n\t\t\t\t\t\tfor ( var key in objJSON.properties ) {\r\n\r\n\t\t\t\t\t\t\tvar value = objJSON.properties[ key ];\r\n\t\t\t\t\t\t\tobject.properties[ key ] = value;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( objJSON.groups !== undefined ) {\r\n\r\n\t\t\t\t\t\tfor ( var i = 0; i < objJSON.groups.length; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tvar groupID = objJSON.groups[ i ];\r\n\r\n\t\t\t\t\t\t\tif ( result.groups[ groupID ] === undefined ) {\r\n\r\n\t\t\t\t\t\t\t\tresult.groups[ groupID ] = [];\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tresult.groups[ groupID ].push( objID );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( objJSON.children !== undefined ) {\r\n\r\n\t\t\t\t\t\thandle_children( object, objJSON.children );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction handle_mesh( geo, mat, id ) {\r\n\r\n\t\tresult.geometries[ id ] = geo;\r\n\t\tresult.face_materials[ id ] = mat;\r\n\t\thandle_objects();\r\n\r\n\t};\r\n\r\n\tfunction handle_hierarchy( node, id, parent, material, obj ) {\r\n\r\n\t\tvar p = obj.position;\r\n\t\tvar r = obj.rotation;\r\n\t\tvar q = obj.quaternion;\r\n\t\tvar s = obj.scale;\r\n\r\n\t\tnode.position.set( p[0], p[1], p[2] );\r\n\r\n\t\tif ( q ) {\r\n\r\n\t\t\tnode.quaternion.set( q[0], q[1], q[2], q[3] );\r\n\t\t\tnode.useQuaternion = true;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tnode.rotation.set( r[0], r[1], r[2] );\r\n\r\n\t\t}\r\n\r\n\t\tnode.scale.set( s[0], s[1], s[2] );\r\n\r\n\t\t// override children materials\r\n\t\t// if object material was specified in JSON explicitly\r\n\r\n\t\tif ( material ) {\r\n\r\n\t\t\tnode.traverse( function ( child )  {\r\n\r\n\t\t\t\tchild.material = material;\r\n\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\t// override children visibility\r\n\t\t// with root node visibility as specified in JSON\r\n\r\n\t\tvar visible = ( obj.visible !== undefined ) ? obj.visible : true;\r\n\r\n\t\tnode.traverse( function ( child )  {\r\n\r\n\t\t\tchild.visible = visible;\r\n\r\n\t\t} );\r\n\r\n\t\tparent.add( node );\r\n\r\n\t\tnode.name = id;\r\n\r\n\t\tresult.objects[ id ] = node;\r\n\t\thandle_objects();\r\n\r\n\t};\r\n\r\n\tfunction create_callback_geometry( id ) {\r\n\r\n\t\treturn function( geo, mat ) {\r\n\r\n\t\t\thandle_mesh( geo, mat, id );\r\n\r\n\t\t\tcounter_models -= 1;\r\n\r\n\t\t\tscope.onLoadComplete();\r\n\r\n\t\t\tasync_callback_gate();\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction create_callback_hierachy( id, parent, material, obj ) {\r\n\r\n\t\treturn function( event ) {\r\n\r\n\t\t\tvar result;\r\n\r\n\t\t\t// loaders which use EventDispatcher\r\n\r\n\t\t\tif ( event.content ) {\r\n\r\n\t\t\t\tresult = event.content;\r\n\r\n\t\t\t// ColladaLoader\r\n\r\n\t\t\t} else if ( event.dae ) {\r\n\r\n\t\t\t\tresult = event.scene;\r\n\r\n\r\n\t\t\t// UTF8Loader\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tresult = event;\r\n\r\n\t\t\t}\r\n\r\n\t\t\thandle_hierarchy( result, id, parent, material, obj );\r\n\r\n\t\t\tcounter_models -= 1;\r\n\r\n\t\t\tscope.onLoadComplete();\r\n\r\n\t\t\tasync_callback_gate();\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction create_callback_embed( id ) {\r\n\r\n\t\treturn function( geo, mat ) {\r\n\r\n\t\t\tresult.geometries[ id ] = geo;\r\n\t\t\tresult.face_materials[ id ] = mat;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction async_callback_gate() {\r\n\r\n\t\tvar progress = {\r\n\r\n\t\t\ttotalModels : total_models,\r\n\t\t\ttotalTextures : total_textures,\r\n\t\t\tloadedModels : total_models - counter_models,\r\n\t\t\tloadedTextures : total_textures - counter_textures\r\n\r\n\t\t};\r\n\r\n\t\tscope.callbackProgress( progress, result );\r\n\r\n\t\tscope.onLoadProgress();\r\n\r\n\t\tif ( counter_models === 0 && counter_textures === 0 ) {\r\n\r\n\t\t\tfinalize();\r\n\t\t\tcallbackFinished( result );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction finalize() {\r\n\r\n\t\t// take care of targets which could be asynchronously loaded objects\r\n\r\n\t\tfor ( var i = 0; i < target_array.length; i ++ ) {\r\n\r\n\t\t\tvar ta = target_array[ i ];\r\n\r\n\t\t\tvar target = result.objects[ ta.targetName ];\r\n\r\n\t\t\tif ( target ) {\r\n\r\n\t\t\t\tta.object.target = target;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// if there was error and target of specified name doesn't exist in the scene file\r\n\t\t\t\t// create instead dummy target\r\n\t\t\t\t// (target must be added to scene explicitly as parent is already added)\r\n\r\n\t\t\t\tta.object.target = new THREE.Object3D();\r\n\t\t\t\tresult.scene.add( ta.object.target );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tta.object.target.properties.targetInverse = ta.object;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar callbackTexture = function ( count ) {\r\n\r\n\t\tcounter_textures -= count;\r\n\t\tasync_callback_gate();\r\n\r\n\t\tscope.onLoadComplete();\r\n\r\n\t};\r\n\r\n\t// must use this instead of just directly calling callbackTexture\r\n\t// because of closure in the calling context loop\r\n\r\n\tvar generateTextureCallback = function ( count ) {\r\n\r\n\t\treturn function() {\r\n\r\n\t\t\tcallbackTexture( count );\r\n\r\n\t\t};\r\n\r\n\t};\r\n\r\n\t// first go synchronous elements\r\n\r\n\t// fogs\r\n\r\n\tvar fogID, fogJSON;\r\n\r\n\tfor ( fogID in data.fogs ) {\r\n\r\n\t\tfogJSON = data.fogs[ fogID ];\r\n\r\n\t\tif ( fogJSON.type === \"linear\" ) {\r\n\r\n\t\t\tfog = new THREE.Fog( 0x000000, fogJSON.near, fogJSON.far );\r\n\r\n\t\t} else if ( fogJSON.type === \"exp2\" ) {\r\n\r\n\t\t\tfog = new THREE.FogExp2( 0x000000, fogJSON.density );\r\n\r\n\t\t}\r\n\r\n\t\tcolor = fogJSON.color;\r\n\t\tfog.color.setRGB( color[0], color[1], color[2] );\r\n\r\n\t\tresult.fogs[ fogID ] = fog;\r\n\r\n\t}\r\n\r\n\t// now come potentially asynchronous elements\r\n\r\n\t// geometries\r\n\r\n\t// count how many geometries will be loaded asynchronously\r\n\r\n\tvar geoID, geoJSON;\r\n\r\n\tfor ( geoID in data.geometries ) {\r\n\r\n\t\tgeoJSON = data.geometries[ geoID ];\r\n\r\n\t\tif ( geoJSON.type in this.geometryHandlerMap ) {\r\n\r\n\t\t\tcounter_models += 1;\r\n\r\n\t\t\tscope.onLoadStart();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// count how many hierarchies will be loaded asynchronously\r\n\r\n\tvar objID, objJSON;\r\n\r\n\tfor ( objID in data.objects ) {\r\n\r\n\t\tobjJSON = data.objects[ objID ];\r\n\r\n\t\tif ( objJSON.type && ( objJSON.type in this.hierarchyHandlerMap ) ) {\r\n\r\n\t\t\tcounter_models += 1;\r\n\r\n\t\t\tscope.onLoadStart();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\ttotal_models = counter_models;\r\n\r\n\tfor ( geoID in data.geometries ) {\r\n\r\n\t\tgeoJSON = data.geometries[ geoID ];\r\n\r\n\t\tif ( geoJSON.type === \"cube\" ) {\r\n\r\n\t\t\tgeometry = new THREE.CubeGeometry( geoJSON.width, geoJSON.height, geoJSON.depth, geoJSON.widthSegments, geoJSON.heightSegments, geoJSON.depthSegments );\r\n\t\t\tresult.geometries[ geoID ] = geometry;\r\n\r\n\t\t} else if ( geoJSON.type === \"plane\" ) {\r\n\r\n\t\t\tgeometry = new THREE.PlaneGeometry( geoJSON.width, geoJSON.height, geoJSON.widthSegments, geoJSON.heightSegments );\r\n\t\t\tresult.geometries[ geoID ] = geometry;\r\n\r\n\t\t} else if ( geoJSON.type === \"sphere\" ) {\r\n\r\n\t\t\tgeometry = new THREE.SphereGeometry( geoJSON.radius, geoJSON.widthSegments, geoJSON.heightSegments );\r\n\t\t\tresult.geometries[ geoID ] = geometry;\r\n\r\n\t\t} else if ( geoJSON.type === \"cylinder\" ) {\r\n\r\n\t\t\tgeometry = new THREE.CylinderGeometry( geoJSON.topRad, geoJSON.botRad, geoJSON.height, geoJSON.radSegs, geoJSON.heightSegs );\r\n\t\t\tresult.geometries[ geoID ] = geometry;\r\n\r\n\t\t} else if ( geoJSON.type === \"torus\" ) {\r\n\r\n\t\t\tgeometry = new THREE.TorusGeometry( geoJSON.radius, geoJSON.tube, geoJSON.segmentsR, geoJSON.segmentsT );\r\n\t\t\tresult.geometries[ geoID ] = geometry;\r\n\r\n\t\t} else if ( geoJSON.type === \"icosahedron\" ) {\r\n\r\n\t\t\tgeometry = new THREE.IcosahedronGeometry( geoJSON.radius, geoJSON.subdivisions );\r\n\t\t\tresult.geometries[ geoID ] = geometry;\r\n\r\n\t\t} else if ( geoJSON.type in this.geometryHandlerMap ) {\r\n\r\n\t\t\tvar loaderParameters = {};\r\n\r\n\t\t\tfor ( var parType in geoJSON ) {\r\n\r\n\t\t\t\tif ( parType !== \"type\" && parType !== \"url\" ) {\r\n\r\n\t\t\t\t\tloaderParameters[ parType ] = geoJSON[ parType ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar loader = this.geometryHandlerMap[ geoJSON.type ][ \"loaderObject\" ];\r\n\t\t\tloader.load( get_url( geoJSON.url, data.urlBaseType ), create_callback_geometry( geoID ), loaderParameters );\r\n\r\n\t\t} else if ( geoJSON.type === \"embedded\" ) {\r\n\r\n\t\t\tvar modelJson = data.embeds[ geoJSON.id ],\r\n\t\t\t\ttexture_path = \"\";\r\n\r\n\t\t\t// pass metadata along to jsonLoader so it knows the format version\r\n\r\n\t\t\tmodelJson.metadata = data.metadata;\r\n\r\n\t\t\tif ( modelJson ) {\r\n\r\n\t\t\t\tvar jsonLoader = this.geometryHandlerMap[ \"ascii\" ][ \"loaderObject\" ];\r\n\t\t\t\tjsonLoader.createModel( modelJson, create_callback_embed( geoID ), texture_path );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// textures\r\n\r\n\t// count how many textures will be loaded asynchronously\r\n\r\n\tvar textureID, textureJSON;\r\n\r\n\tfor ( textureID in data.textures ) {\r\n\r\n\t\ttextureJSON = data.textures[ textureID ];\r\n\r\n\t\tif ( textureJSON.url instanceof Array ) {\r\n\r\n\t\t\tcounter_textures += textureJSON.url.length;\r\n\r\n\t\t\tfor( var n = 0; n < textureJSON.url.length; n ++ ) {\r\n\r\n\t\t\t\tscope.onLoadStart();\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tcounter_textures += 1;\r\n\r\n\t\t\tscope.onLoadStart();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\ttotal_textures = counter_textures;\r\n\r\n\tfor ( textureID in data.textures ) {\r\n\r\n\t\ttextureJSON = data.textures[ textureID ];\r\n\r\n\t\tif ( textureJSON.mapping !== undefined && THREE[ textureJSON.mapping ] !== undefined  ) {\r\n\r\n\t\t\ttextureJSON.mapping = new THREE[ textureJSON.mapping ]();\r\n\r\n\t\t}\r\n\r\n\t\tif ( textureJSON.url instanceof Array ) {\r\n\r\n\t\t\tvar count = textureJSON.url.length;\r\n\t\t\tvar url_array = [];\r\n\r\n\t\t\tfor( var i = 0; i < count; i ++ ) {\r\n\r\n\t\t\t\turl_array[ i ] = get_url( textureJSON.url[ i ], data.urlBaseType );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar isCompressed = /\\.dds$/i.test( url_array[ 0 ] );\r\n\r\n\t\t\tif ( isCompressed ) {\r\n\r\n\t\t\t\ttexture = THREE.ImageUtils.loadCompressedTextureCube( url_array, textureJSON.mapping, generateTextureCallback( count ) );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ttexture = THREE.ImageUtils.loadTextureCube( url_array, textureJSON.mapping, generateTextureCallback( count ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar isCompressed = /\\.dds$/i.test( textureJSON.url );\r\n\t\t\tvar fullUrl = get_url( textureJSON.url, data.urlBaseType );\r\n\t\t\tvar textureCallback = generateTextureCallback( 1 );\r\n\r\n\t\t\tif ( isCompressed ) {\r\n\r\n\t\t\t\ttexture = THREE.ImageUtils.loadCompressedTexture( fullUrl, textureJSON.mapping, textureCallback );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ttexture = THREE.ImageUtils.loadTexture( fullUrl, textureJSON.mapping, textureCallback );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( THREE[ textureJSON.minFilter ] !== undefined )\r\n\t\t\t\ttexture.minFilter = THREE[ textureJSON.minFilter ];\r\n\r\n\t\t\tif ( THREE[ textureJSON.magFilter ] !== undefined )\r\n\t\t\t\ttexture.magFilter = THREE[ textureJSON.magFilter ];\r\n\r\n\t\t\tif ( textureJSON.anisotropy ) texture.anisotropy = textureJSON.anisotropy;\r\n\r\n\t\t\tif ( textureJSON.repeat ) {\r\n\r\n\t\t\t\ttexture.repeat.set( textureJSON.repeat[ 0 ], textureJSON.repeat[ 1 ] );\r\n\r\n\t\t\t\tif ( textureJSON.repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;\r\n\t\t\t\tif ( textureJSON.repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( textureJSON.offset ) {\r\n\r\n\t\t\t\ttexture.offset.set( textureJSON.offset[ 0 ], textureJSON.offset[ 1 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// handle wrap after repeat so that default repeat can be overriden\r\n\r\n\t\t\tif ( textureJSON.wrap ) {\r\n\r\n\t\t\t\tvar wrapMap = {\r\n\t\t\t\t\"repeat\" \t: THREE.RepeatWrapping,\r\n\t\t\t\t\"mirror\"\t: THREE.MirroredRepeatWrapping\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( wrapMap[ textureJSON.wrap[ 0 ] ] !== undefined ) texture.wrapS = wrapMap[ textureJSON.wrap[ 0 ] ];\r\n\t\t\t\tif ( wrapMap[ textureJSON.wrap[ 1 ] ] !== undefined ) texture.wrapT = wrapMap[ textureJSON.wrap[ 1 ] ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tresult.textures[ textureID ] = texture;\r\n\r\n\t}\r\n\r\n\t// materials\r\n\r\n\tvar matID, matJSON;\r\n\tvar parID;\r\n\r\n\tfor ( matID in data.materials ) {\r\n\r\n\t\tmatJSON = data.materials[ matID ];\r\n\r\n\t\tfor ( parID in matJSON.parameters ) {\r\n\r\n\t\t\tif ( parID === \"envMap\" || parID === \"map\" || parID === \"lightMap\" || parID === \"bumpMap\" ) {\r\n\r\n\t\t\t\tmatJSON.parameters[ parID ] = result.textures[ matJSON.parameters[ parID ] ];\r\n\r\n\t\t\t} else if ( parID === \"shading\" ) {\r\n\r\n\t\t\t\tmatJSON.parameters[ parID ] = ( matJSON.parameters[ parID ] === \"flat\" ) ? THREE.FlatShading : THREE.SmoothShading;\r\n\r\n\t\t\t} else if ( parID === \"side\" ) {\r\n\r\n\t\t\t\tif ( matJSON.parameters[ parID ] == \"double\" ) {\r\n\r\n\t\t\t\t\tmatJSON.parameters[ parID ] = THREE.DoubleSide;\r\n\r\n\t\t\t\t} else if ( matJSON.parameters[ parID ] == \"back\" ) {\r\n\r\n\t\t\t\t\tmatJSON.parameters[ parID ] = THREE.BackSide;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tmatJSON.parameters[ parID ] = THREE.FrontSide;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( parID === \"blending\" ) {\r\n\r\n\t\t\t\tmatJSON.parameters[ parID ] = matJSON.parameters[ parID ] in THREE ? THREE[ matJSON.parameters[ parID ] ] : THREE.NormalBlending;\r\n\r\n\t\t\t} else if ( parID === \"combine\" ) {\r\n\r\n\t\t\t\tmatJSON.parameters[ parID ] = matJSON.parameters[ parID ] in THREE ? THREE[ matJSON.parameters[ parID ] ] : THREE.MultiplyOperation;\r\n\r\n\t\t\t} else if ( parID === \"vertexColors\" ) {\r\n\r\n\t\t\t\tif ( matJSON.parameters[ parID ] == \"face\" ) {\r\n\r\n\t\t\t\t\tmatJSON.parameters[ parID ] = THREE.FaceColors;\r\n\r\n\t\t\t\t// default to vertex colors if \"vertexColors\" is anything else face colors or 0 / null / false\r\n\r\n\t\t\t\t} else if ( matJSON.parameters[ parID ] )   {\r\n\r\n\t\t\t\t\tmatJSON.parameters[ parID ] = THREE.VertexColors;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( parID === \"wrapRGB\" ) {\r\n\r\n\t\t\t\tvar v3 = matJSON.parameters[ parID ];\r\n\t\t\t\tmatJSON.parameters[ parID ] = new THREE.Vector3( v3[ 0 ], v3[ 1 ], v3[ 2 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( matJSON.parameters.opacity !== undefined && matJSON.parameters.opacity < 1.0 ) {\r\n\r\n\t\t\tmatJSON.parameters.transparent = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( matJSON.parameters.normalMap ) {\r\n\r\n\t\t\tvar shader = THREE.ShaderLib[ \"normalmap\" ];\r\n\t\t\tvar uniforms = THREE.UniformsUtils.clone( shader.uniforms );\r\n\r\n\t\t\tvar diffuse = matJSON.parameters.color;\r\n\t\t\tvar specular = matJSON.parameters.specular;\r\n\t\t\tvar ambient = matJSON.parameters.ambient;\r\n\t\t\tvar shininess = matJSON.parameters.shininess;\r\n\r\n\t\t\tuniforms[ \"tNormal\" ].value = result.textures[ matJSON.parameters.normalMap ];\r\n\r\n\t\t\tif ( matJSON.parameters.normalScale ) {\r\n\r\n\t\t\t\tuniforms[ \"uNormalScale\" ].value.set( matJSON.parameters.normalScale[ 0 ], matJSON.parameters.normalScale[ 1 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( matJSON.parameters.map ) {\r\n\r\n\t\t\t\tuniforms[ \"tDiffuse\" ].value = matJSON.parameters.map;\r\n\t\t\t\tuniforms[ \"enableDiffuse\" ].value = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( matJSON.parameters.envMap ) {\r\n\r\n\t\t\t\tuniforms[ \"tCube\" ].value = matJSON.parameters.envMap;\r\n\t\t\t\tuniforms[ \"enableReflection\" ].value = true;\r\n\t\t\t\tuniforms[ \"uReflectivity\" ].value = matJSON.parameters.reflectivity;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( matJSON.parameters.lightMap ) {\r\n\r\n\t\t\t\tuniforms[ \"tAO\" ].value = matJSON.parameters.lightMap;\r\n\t\t\t\tuniforms[ \"enableAO\" ].value = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( matJSON.parameters.specularMap ) {\r\n\r\n\t\t\t\tuniforms[ \"tSpecular\" ].value = result.textures[ matJSON.parameters.specularMap ];\r\n\t\t\t\tuniforms[ \"enableSpecular\" ].value = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( matJSON.parameters.displacementMap ) {\r\n\r\n\t\t\t\tuniforms[ \"tDisplacement\" ].value = result.textures[ matJSON.parameters.displacementMap ];\r\n\t\t\t\tuniforms[ \"enableDisplacement\" ].value = true;\r\n\r\n\t\t\t\tuniforms[ \"uDisplacementBias\" ].value = matJSON.parameters.displacementBias;\r\n\t\t\t\tuniforms[ \"uDisplacementScale\" ].value = matJSON.parameters.displacementScale;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tuniforms[ \"uDiffuseColor\" ].value.setHex( diffuse );\r\n\t\t\tuniforms[ \"uSpecularColor\" ].value.setHex( specular );\r\n\t\t\tuniforms[ \"uAmbientColor\" ].value.setHex( ambient );\r\n\r\n\t\t\tuniforms[ \"uShininess\" ].value = shininess;\r\n\r\n\t\t\tif ( matJSON.parameters.opacity ) {\r\n\r\n\t\t\t\tuniforms[ \"uOpacity\" ].value = matJSON.parameters.opacity;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms, lights: true, fog: true };\r\n\r\n\t\t\tmaterial = new THREE.ShaderMaterial( parameters );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmaterial = new THREE[ matJSON.type ]( matJSON.parameters );\r\n\r\n\t\t}\r\n\r\n\t\tresult.materials[ matID ] = material;\r\n\r\n\t}\r\n\r\n\t// second pass through all materials to initialize MeshFaceMaterials\r\n\t// that could be referring to other materials out of order\r\n\r\n\tfor ( matID in data.materials ) {\r\n\r\n\t\tmatJSON = data.materials[ matID ];\r\n\r\n\t\tif ( matJSON.parameters.materials ) {\r\n\r\n\t\t\tvar materialArray = [];\r\n\r\n\t\t\tfor ( var i = 0; i < matJSON.parameters.materials.length; i ++ ) {\r\n\r\n\t\t\t\tvar label = matJSON.parameters.materials[ i ];\r\n\t\t\t\tmaterialArray.push( result.materials[ label ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tresult.materials[ matID ].materials = materialArray;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// objects ( synchronous init of procedural primitives )\r\n\r\n\thandle_objects();\r\n\r\n\t// defaults\r\n\r\n\tif ( result.cameras && data.defaults.camera ) {\r\n\r\n\t\tresult.currentCamera = result.cameras[ data.defaults.camera ];\r\n\r\n\t}\r\n\r\n\tif ( result.fogs && data.defaults.fog ) {\r\n\r\n\t\tresult.scene.fog = result.fogs[ data.defaults.fog ];\r\n\r\n\t}\r\n\r\n\t// synchronous callback\r\n\r\n\tscope.callbackSync( result );\r\n\r\n\t// just in case there are no async elements\r\n\r\n\tasync_callback_gate();\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.TextureLoader = function () {\r\n\r\n\tTHREE.EventDispatcher.call( this );\r\n\r\n\tthis.crossOrigin = null;\r\n\r\n};\r\n\r\nTHREE.TextureLoader.prototype = {\r\n\r\n\tconstructor: THREE.TextureLoader,\r\n\r\n\tload: function ( url ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar image = new Image();\r\n\r\n\t\timage.addEventListener( 'load', function () {\r\n\r\n\t\t\tvar texture = new THREE.Texture( image );\r\n\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\tscope.dispatchEvent( { type: 'load', content: texture } );\r\n\r\n\t\t}, false );\r\n\r\n\t\timage.addEventListener( 'error', function () {\r\n\r\n\t\t\tscope.dispatchEvent( { type: 'error', message: 'Couldn\\'t load URL [' + url + ']' } );\r\n\r\n\t\t}, false );\r\n\r\n\t\tif ( scope.crossOrigin ) image.crossOrigin = scope.crossOrigin;\r\n\r\n\t\timage.src = url;\r\n\r\n\t}\r\n\r\n}\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Material = function () {\r\n\r\n\tTHREE.EventDispatcher.call( this );\r\n\r\n\tthis.id = THREE.MaterialIdCount ++;\r\n\r\n\tthis.name = '';\r\n\r\n\tthis.side = THREE.FrontSide;\r\n\r\n\tthis.opacity = 1;\r\n\tthis.transparent = false;\r\n\r\n\tthis.blending = THREE.NormalBlending;\r\n\r\n\tthis.blendSrc = THREE.SrcAlphaFactor;\r\n\tthis.blendDst = THREE.OneMinusSrcAlphaFactor;\r\n\tthis.blendEquation = THREE.AddEquation;\r\n\r\n\tthis.depthTest = true;\r\n\tthis.depthWrite = true;\r\n\r\n\tthis.polygonOffset = false;\r\n\tthis.polygonOffsetFactor = 0;\r\n\tthis.polygonOffsetUnits = 0;\r\n\r\n\tthis.alphaTest = 0;\r\n\r\n\tthis.overdraw = false; // Boolean for fixing antialiasing gaps in CanvasRenderer\r\n\r\n\tthis.visible = true;\r\n\r\n\tthis.needsUpdate = true;\r\n\r\n};\r\n\r\nTHREE.Material.prototype.setValues = function ( values ) {\r\n\r\n\tif ( values === undefined ) return;\r\n\r\n\tfor ( var key in values ) {\r\n\r\n\t\tvar newValue = values[ key ];\r\n\r\n\t\tif ( newValue === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Material: \\'' + key + '\\' parameter is undefined.' );\r\n\t\t\tcontinue;\r\n\r\n\t\t}\r\n\r\n\t\tif ( key in this ) {\r\n\r\n\t\t\tvar currentValue = this[ key ];\r\n\r\n\t\t\tif ( currentValue instanceof THREE.Color && newValue instanceof THREE.Color ) {\r\n\r\n\t\t\t\tcurrentValue.copy( newValue );\r\n\r\n\t\t\t} else if ( currentValue instanceof THREE.Color ) {\r\n\r\n\t\t\t\tcurrentValue.set( newValue );\r\n\r\n\t\t\t} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {\r\n\r\n\t\t\t\tcurrentValue.copy( newValue );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis[ key ] = newValue;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Material.prototype.clone = function ( material ) {\r\n\r\n\tif ( material === undefined ) material = new THREE.Material();\r\n\r\n\tmaterial.name = this.name;\r\n\r\n\tmaterial.side = this.side;\r\n\r\n\tmaterial.opacity = this.opacity;\r\n\tmaterial.transparent = this.transparent;\r\n\r\n\tmaterial.blending = this.blending;\r\n\r\n\tmaterial.blendSrc = this.blendSrc;\r\n\tmaterial.blendDst = this.blendDst;\r\n\tmaterial.blendEquation = this.blendEquation;\r\n\r\n\tmaterial.depthTest = this.depthTest;\r\n\tmaterial.depthWrite = this.depthWrite;\r\n\r\n\tmaterial.polygonOffset = this.polygonOffset;\r\n\tmaterial.polygonOffsetFactor = this.polygonOffsetFactor;\r\n\tmaterial.polygonOffsetUnits = this.polygonOffsetUnits;\r\n\r\n\tmaterial.alphaTest = this.alphaTest;\r\n\r\n\tmaterial.overdraw = this.overdraw;\r\n\r\n\tmaterial.visible = this.visible;\r\n\r\n\treturn material;\r\n\r\n};\r\n\r\nTHREE.Material.prototype.dispose = function () {\r\n\r\n\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n};\r\n\r\nTHREE.MaterialIdCount = 0;\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  linewidth: <float>,\r\n *  linecap: \"round\",\r\n *  linejoin: \"round\",\r\n *\r\n *  vertexColors: <bool>\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.LineBasicMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.color = new THREE.Color( 0xffffff );\r\n\r\n\tthis.linewidth = 1;\r\n\tthis.linecap = 'round';\r\n\tthis.linejoin = 'round';\r\n\r\n\tthis.vertexColors = false;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\r\nTHREE.LineBasicMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.LineBasicMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.color.copy( this.color );\r\n\r\n\tmaterial.linewidth = this.linewidth;\r\n\tmaterial.linecap = this.linecap;\r\n\tmaterial.linejoin = this.linejoin;\r\n\r\n\tmaterial.vertexColors = this.vertexColors;\r\n\r\n\tmaterial.fog = this.fog;\r\n\r\n\treturn material;\r\n\r\n};\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  linewidth: <float>,\r\n *\r\n *  scale: <float>,\r\n *  dashSize: <float>,\r\n *  gapSize: <float>,\r\n *\r\n *  vertexColors: <bool>\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.LineDashedMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.color = new THREE.Color( 0xffffff );\r\n\r\n\tthis.linewidth = 1;\r\n\r\n\tthis.scale = 1;\r\n\tthis.dashSize = 3;\r\n\tthis.gapSize = 1;\r\n\r\n\tthis.vertexColors = false;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\r\nTHREE.LineDashedMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.LineDashedMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.color.copy( this.color );\r\n\r\n\tmaterial.linewidth = this.linewidth;\r\n\r\n\tmaterial.scale = this.scale;\r\n\tmaterial.dashSize = this.dashSize;\r\n\tmaterial.gapSize = this.gapSize;\r\n\r\n\tmaterial.vertexColors = this.vertexColors;\r\n\r\n\tmaterial.fog = this.fog;\r\n\r\n\treturn material;\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  lightMap: new THREE.Texture( <Image> ),\r\n *\r\n *  specularMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n *  combine: THREE.Multiply,\r\n *  reflectivity: <float>,\r\n *  refractionRatio: <float>,\r\n *\r\n *  shading: THREE.SmoothShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.MeshBasicMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.color = new THREE.Color( 0xffffff ); // emissive\r\n\r\n\tthis.map = null;\r\n\r\n\tthis.lightMap = null;\r\n\r\n\tthis.specularMap = null;\r\n\r\n\tthis.envMap = null;\r\n\tthis.combine = THREE.MultiplyOperation;\r\n\tthis.reflectivity = 1;\r\n\tthis.refractionRatio = 0.98;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.shading = THREE.SmoothShading;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\tthis.wireframeLinecap = 'round';\r\n\tthis.wireframeLinejoin = 'round';\r\n\r\n\tthis.vertexColors = THREE.NoColors;\r\n\r\n\tthis.skinning = false;\r\n\tthis.morphTargets = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\r\nTHREE.MeshBasicMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.MeshBasicMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.color.copy( this.color );\r\n\r\n\tmaterial.map = this.map;\r\n\r\n\tmaterial.lightMap = this.lightMap;\r\n\r\n\tmaterial.specularMap = this.specularMap;\r\n\r\n\tmaterial.envMap = this.envMap;\r\n\tmaterial.combine = this.combine;\r\n\tmaterial.reflectivity = this.reflectivity;\r\n\tmaterial.refractionRatio = this.refractionRatio;\r\n\r\n\tmaterial.fog = this.fog;\r\n\r\n\tmaterial.shading = this.shading;\r\n\r\n\tmaterial.wireframe = this.wireframe;\r\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\r\n\tmaterial.wireframeLinecap = this.wireframeLinecap;\r\n\tmaterial.wireframeLinejoin = this.wireframeLinejoin;\r\n\r\n\tmaterial.vertexColors = this.vertexColors;\r\n\r\n\tmaterial.skinning = this.skinning;\r\n\tmaterial.morphTargets = this.morphTargets;\r\n\r\n\treturn material;\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  ambient: <hex>,\r\n *  emissive: <hex>,\r\n *  opacity: <float>,\r\n *\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  lightMap: new THREE.Texture( <Image> ),\r\n *\r\n *  specularMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n *  combine: THREE.Multiply,\r\n *  reflectivity: <float>,\r\n *  refractionRatio: <float>,\r\n *\r\n *  shading: THREE.SmoothShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>,\r\n *\r\n *\tfog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.MeshLambertMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\r\n\tthis.ambient = new THREE.Color( 0xffffff );\r\n\tthis.emissive = new THREE.Color( 0x000000 );\r\n\r\n\tthis.wrapAround = false;\r\n\tthis.wrapRGB = new THREE.Vector3( 1, 1, 1 );\r\n\r\n\tthis.map = null;\r\n\r\n\tthis.lightMap = null;\r\n\r\n\tthis.specularMap = null;\r\n\r\n\tthis.envMap = null;\r\n\tthis.combine = THREE.MultiplyOperation;\r\n\tthis.reflectivity = 1;\r\n\tthis.refractionRatio = 0.98;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.shading = THREE.SmoothShading;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\tthis.wireframeLinecap = 'round';\r\n\tthis.wireframeLinejoin = 'round';\r\n\r\n\tthis.vertexColors = THREE.NoColors;\r\n\r\n\tthis.skinning = false;\r\n\tthis.morphTargets = false;\r\n\tthis.morphNormals = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\r\nTHREE.MeshLambertMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.MeshLambertMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.color.copy( this.color );\r\n\tmaterial.ambient.copy( this.ambient );\r\n\tmaterial.emissive.copy( this.emissive );\r\n\r\n\tmaterial.wrapAround = this.wrapAround;\r\n\tmaterial.wrapRGB.copy( this.wrapRGB );\r\n\r\n\tmaterial.map = this.map;\r\n\r\n\tmaterial.lightMap = this.lightMap;\r\n\r\n\tmaterial.specularMap = this.specularMap;\r\n\r\n\tmaterial.envMap = this.envMap;\r\n\tmaterial.combine = this.combine;\r\n\tmaterial.reflectivity = this.reflectivity;\r\n\tmaterial.refractionRatio = this.refractionRatio;\r\n\r\n\tmaterial.fog = this.fog;\r\n\r\n\tmaterial.shading = this.shading;\r\n\r\n\tmaterial.wireframe = this.wireframe;\r\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\r\n\tmaterial.wireframeLinecap = this.wireframeLinecap;\r\n\tmaterial.wireframeLinejoin = this.wireframeLinejoin;\r\n\r\n\tmaterial.vertexColors = this.vertexColors;\r\n\r\n\tmaterial.skinning = this.skinning;\r\n\tmaterial.morphTargets = this.morphTargets;\r\n\tmaterial.morphNormals = this.morphNormals;\r\n\r\n\treturn material;\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  ambient: <hex>,\r\n *  emissive: <hex>,\r\n *  specular: <hex>,\r\n *  shininess: <float>,\r\n *  opacity: <float>,\r\n *\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  lightMap: new THREE.Texture( <Image> ),\r\n *\r\n *  bumpMap: new THREE.Texture( <Image> ),\r\n *  bumpScale: <float>,\r\n *\r\n *  normalMap: new THREE.Texture( <Image> ),\r\n *  normalScale: <Vector2>,\r\n *\r\n *  specularMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n *  combine: THREE.Multiply,\r\n *  reflectivity: <float>,\r\n *  refractionRatio: <float>,\r\n *\r\n *  shading: THREE.SmoothShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>,\r\n *\r\n *\tfog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.MeshPhongMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\r\n\tthis.ambient = new THREE.Color( 0xffffff );\r\n\tthis.emissive = new THREE.Color( 0x000000 );\r\n\tthis.specular = new THREE.Color( 0x111111 );\r\n\tthis.shininess = 30;\r\n\r\n\tthis.metal = false;\r\n\tthis.perPixel = true;\r\n\r\n\tthis.wrapAround = false;\r\n\tthis.wrapRGB = new THREE.Vector3( 1, 1, 1 );\r\n\r\n\tthis.map = null;\r\n\r\n\tthis.lightMap = null;\r\n\r\n\tthis.bumpMap = null;\r\n\tthis.bumpScale = 1;\r\n\r\n\tthis.normalMap = null;\r\n\tthis.normalScale = new THREE.Vector2( 1, 1 );\r\n\r\n\tthis.specularMap = null;\r\n\r\n\tthis.envMap = null;\r\n\tthis.combine = THREE.MultiplyOperation;\r\n\tthis.reflectivity = 1;\r\n\tthis.refractionRatio = 0.98;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.shading = THREE.SmoothShading;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\tthis.wireframeLinecap = 'round';\r\n\tthis.wireframeLinejoin = 'round';\r\n\r\n\tthis.vertexColors = THREE.NoColors;\r\n\r\n\tthis.skinning = false;\r\n\tthis.morphTargets = false;\r\n\tthis.morphNormals = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\r\nTHREE.MeshPhongMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.MeshPhongMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.color.copy( this.color );\r\n\tmaterial.ambient.copy( this.ambient );\r\n\tmaterial.emissive.copy( this.emissive );\r\n\tmaterial.specular.copy( this.specular );\r\n\tmaterial.shininess = this.shininess;\r\n\r\n\tmaterial.metal = this.metal;\r\n\tmaterial.perPixel = this.perPixel;\r\n\r\n\tmaterial.wrapAround = this.wrapAround;\r\n\tmaterial.wrapRGB.copy( this.wrapRGB );\r\n\r\n\tmaterial.map = this.map;\r\n\r\n\tmaterial.lightMap = this.lightMap;\r\n\r\n\tmaterial.bumpMap = this.bumpMap;\r\n\tmaterial.bumpScale = this.bumpScale;\r\n\r\n\tmaterial.normalMap = this.normalMap;\r\n\tmaterial.normalScale.copy( this.normalScale );\r\n\r\n\tmaterial.specularMap = this.specularMap;\r\n\r\n\tmaterial.envMap = this.envMap;\r\n\tmaterial.combine = this.combine;\r\n\tmaterial.reflectivity = this.reflectivity;\r\n\tmaterial.refractionRatio = this.refractionRatio;\r\n\r\n\tmaterial.fog = this.fog;\r\n\r\n\tmaterial.shading = this.shading;\r\n\r\n\tmaterial.wireframe = this.wireframe;\r\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\r\n\tmaterial.wireframeLinecap = this.wireframeLinecap;\r\n\tmaterial.wireframeLinejoin = this.wireframeLinejoin;\r\n\r\n\tmaterial.vertexColors = this.vertexColors;\r\n\r\n\tmaterial.skinning = this.skinning;\r\n\tmaterial.morphTargets = this.morphTargets;\r\n\tmaterial.morphNormals = this.morphNormals;\r\n\r\n\treturn material;\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  opacity: <float>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>\r\n * }\r\n */\r\n\r\nTHREE.MeshDepthMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\r\nTHREE.MeshDepthMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.LineBasicMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.wireframe = this.wireframe;\r\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\r\n\r\n\treturn material;\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n *\r\n * parameters = {\r\n *  opacity: <float>,\r\n *\r\n *  shading: THREE.FlatShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>\r\n * }\r\n */\r\n\r\nTHREE.MeshNormalMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this, parameters );\r\n\r\n\tthis.shading = THREE.FlatShading;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\r\nTHREE.MeshNormalMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.MeshNormalMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.shading = this.shading;\r\n\r\n\tmaterial.wireframe = this.wireframe;\r\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\r\n\r\n\treturn material;\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.MeshFaceMaterial = function ( materials ) {\r\n\r\n\tthis.materials = materials instanceof Array ? materials : [];\r\n\r\n};\r\n\r\nTHREE.MeshFaceMaterial.prototype.clone = function () {\r\n\r\n\treturn new THREE.MeshFaceMaterial( this.materials.slice( 0 ) );\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  size: <float>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  vertexColors: <bool>,\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.ParticleBasicMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.color = new THREE.Color( 0xffffff );\r\n\r\n\tthis.map = null;\r\n\r\n\tthis.size = 1;\r\n\tthis.sizeAttenuation = true;\r\n\r\n\tthis.vertexColors = false;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.ParticleBasicMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\r\nTHREE.ParticleBasicMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.ParticleBasicMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.color.copy( this.color );\r\n\r\n\tmaterial.map = this.map;\r\n\r\n\tmaterial.size = this.size;\r\n\tmaterial.sizeAttenuation = this.sizeAttenuation;\r\n\r\n\tmaterial.vertexColors = this.vertexColors;\r\n\r\n\tmaterial.fog = this.fog;\r\n\r\n\treturn material;\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  program: <function>,\r\n *  opacity: <float>,\r\n *  blending: THREE.NormalBlending\r\n * }\r\n */\r\n\r\nTHREE.ParticleCanvasMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.color = new THREE.Color( 0xffffff );\r\n\tthis.program = function ( context, color ) {};\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.ParticleCanvasMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\r\nTHREE.ParticleCanvasMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.ParticleCanvasMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.color.copy( this.color );\r\n\tmaterial.program = this.program;\r\n\r\n\treturn material;\r\n\r\n};\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  fragmentShader: <string>,\r\n *  vertexShader: <string>,\r\n *\r\n *  uniforms: { \"parameter1\": { type: \"f\", value: 1.0 }, \"parameter2\": { type: \"i\" value2: 2 } },\r\n *\r\n *  defines: { \"label\" : \"value\" },\r\n *\r\n *  shading: THREE.SmoothShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  lights: <bool>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>,\r\n *\r\n *\tfog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.ShaderMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.fragmentShader = \"void main() {}\";\r\n\tthis.vertexShader = \"void main() {}\";\r\n\tthis.uniforms = {};\r\n\tthis.defines = {};\r\n\tthis.attributes = null;\r\n\r\n\tthis.shading = THREE.SmoothShading;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\r\n\tthis.fog = false; // set to use scene fog\r\n\r\n\tthis.lights = false; // set to use scene lights\r\n\r\n\tthis.vertexColors = THREE.NoColors; // set to use \"color\" attribute stream\r\n\r\n\tthis.skinning = false; // set to use skinning attribute streams\r\n\r\n\tthis.morphTargets = false; // set to use morph targets\r\n\tthis.morphNormals = false; // set to use morph normals\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\r\nTHREE.ShaderMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.ShaderMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.fragmentShader = this.fragmentShader;\r\n\tmaterial.vertexShader = this.vertexShader;\r\n\r\n\tmaterial.uniforms = THREE.UniformsUtils.clone( this.uniforms );\r\n\r\n\tmaterial.attributes = this.attributes;\r\n\tmaterial.defines = this.defines;\r\n\r\n\tmaterial.shading = this.shading;\r\n\r\n\tmaterial.wireframe = this.wireframe;\r\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\r\n\r\n\tmaterial.fog = this.fog;\r\n\r\n\tmaterial.lights = this.lights;\r\n\r\n\tmaterial.vertexColors = this.vertexColors;\r\n\r\n\tmaterial.skinning = this.skinning;\r\n\r\n\tmaterial.morphTargets = this.morphTargets;\r\n\tmaterial.morphNormals = this.morphNormals;\r\n\r\n\treturn material;\r\n\r\n};\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  useScreenCoordinates: <bool>,\r\n *  sizeAttenuation: <bool>,\r\n *  scaleByViewport: <bool>,\r\n *  alignment: THREE.SpriteAlignment.center,\r\n *\r\n *\tuvOffset: new THREE.Vector2(),\r\n *\tuvScale: new THREE.Vector2(),\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.SpriteMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\t// defaults\r\n\r\n\tthis.color = new THREE.Color( 0xffffff );\r\n\tthis.map = new THREE.Texture();\r\n\r\n\tthis.useScreenCoordinates = true;\r\n\tthis.depthTest = !this.useScreenCoordinates;\r\n\tthis.sizeAttenuation = !this.useScreenCoordinates;\r\n\tthis.scaleByViewport = !this.sizeAttenuation;\r\n\tthis.alignment = THREE.SpriteAlignment.center.clone();\r\n\r\n\tthis.fog = false;\r\n\r\n\tthis.uvOffset = new THREE.Vector2( 0, 0 );\r\n\tthis.uvScale  = new THREE.Vector2( 1, 1 );\r\n\r\n\t// set parameters\r\n\r\n\tthis.setValues( parameters );\r\n\r\n\t// override coupled defaults if not specified explicitly by parameters\r\n\r\n\tparameters = parameters || {};\r\n\r\n\tif ( parameters.depthTest === undefined ) this.depthTest = !this.useScreenCoordinates;\r\n\tif ( parameters.sizeAttenuation === undefined ) this.sizeAttenuation = !this.useScreenCoordinates;\r\n\tif ( parameters.scaleByViewport === undefined ) this.scaleByViewport = !this.sizeAttenuation;\r\n\r\n};\r\n\r\nTHREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\r\nTHREE.SpriteMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.SpriteMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.color.copy( this.color );\r\n\tmaterial.map = this.map;\r\n\r\n\tmaterial.useScreenCoordinates = this.useScreenCoordinates;\r\n\tmaterial.sizeAttenuation = this.sizeAttenuation;\r\n\tmaterial.scaleByViewport = this.scaleByViewport;\r\n\tmaterial.alignment.copy( this.alignment );\r\n\r\n\tmaterial.uvOffset.copy( this.uvOffset );\r\n\tmaterial.uvScale.copy( this.uvScale );\r\n\r\n\tmaterial.fog = this.fog;\r\n\r\n\treturn material;\r\n\r\n};\r\n\r\n// Alignment enums\r\n\r\nTHREE.SpriteAlignment = {};\r\nTHREE.SpriteAlignment.topLeft = new THREE.Vector2( 1, -1 );\r\nTHREE.SpriteAlignment.topCenter = new THREE.Vector2( 0, -1 );\r\nTHREE.SpriteAlignment.topRight = new THREE.Vector2( -1, -1 );\r\nTHREE.SpriteAlignment.centerLeft = new THREE.Vector2( 1, 0 );\r\nTHREE.SpriteAlignment.center = new THREE.Vector2( 0, 0 );\r\nTHREE.SpriteAlignment.centerRight = new THREE.Vector2( -1, 0 );\r\nTHREE.SpriteAlignment.bottomLeft = new THREE.Vector2( 1, 1 );\r\nTHREE.SpriteAlignment.bottomCenter = new THREE.Vector2( 0, 1 );\r\nTHREE.SpriteAlignment.bottomRight = new THREE.Vector2( -1, 1 );\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author szimek / https://github.com/szimek/\r\n */\r\n\r\nTHREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\r\n\tTHREE.EventDispatcher.call( this );\r\n\r\n\tthis.id = THREE.TextureIdCount ++;\r\n\r\n\tthis.name = '';\r\n\r\n\tthis.image = image;\r\n\tthis.mipmaps = [];\r\n\r\n\tthis.mapping = mapping !== undefined ? mapping : new THREE.UVMapping();\r\n\r\n\tthis.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;\r\n\tthis.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;\r\n\r\n\tthis.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;\r\n\tthis.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;\r\n\r\n\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\r\n\r\n\tthis.format = format !== undefined ? format : THREE.RGBAFormat;\r\n\tthis.type = type !== undefined ? type : THREE.UnsignedByteType;\r\n\r\n\tthis.offset = new THREE.Vector2( 0, 0 );\r\n\tthis.repeat = new THREE.Vector2( 1, 1 );\r\n\r\n\tthis.generateMipmaps = true;\r\n\tthis.premultiplyAlpha = false;\r\n\tthis.flipY = true;\r\n\tthis.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\r\n\r\n\tthis.needsUpdate = false;\r\n\tthis.onUpdate = null;\r\n\r\n};\r\n\r\nTHREE.Texture.prototype = {\r\n\r\n\tconstructor: THREE.Texture,\r\n\r\n\tclone: function ( texture ) {\r\n\r\n\t\tif ( texture === undefined ) texture = new THREE.Texture();\r\n\r\n\t\ttexture.image = this.image;\r\n\t\ttexture.mipmaps = this.mipmaps.slice(0);\r\n\r\n\t\ttexture.mapping = this.mapping;\r\n\r\n\t\ttexture.wrapS = this.wrapS;\r\n\t\ttexture.wrapT = this.wrapT;\r\n\r\n\t\ttexture.magFilter = this.magFilter;\r\n\t\ttexture.minFilter = this.minFilter;\r\n\r\n\t\ttexture.anisotropy = this.anisotropy;\r\n\r\n\t\ttexture.format = this.format;\r\n\t\ttexture.type = this.type;\r\n\r\n\t\ttexture.offset.copy( this.offset );\r\n\t\ttexture.repeat.copy( this.repeat );\r\n\r\n\t\ttexture.generateMipmaps = this.generateMipmaps;\r\n\t\ttexture.premultiplyAlpha = this.premultiplyAlpha;\r\n\t\ttexture.flipY = this.flipY;\r\n\t\ttexture.unpackAlignment = this.unpackAlignment;\r\n\r\n\t\treturn texture;\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.TextureIdCount = 0;\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\r\n\r\n\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\r\n\tthis.image = { width: width, height: height };\r\n\tthis.mipmaps = mipmaps;\r\n\r\n\tthis.generateMipmaps = false; // WebGL currently can't generate mipmaps for compressed textures, they must be embedded in DDS file\r\n\r\n};\r\n\r\nTHREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );\r\n\r\nTHREE.CompressedTexture.prototype.clone = function () {\r\n\r\n\tvar texture = new THREE.CompressedTexture();\r\n\r\n\tTHREE.Texture.prototype.clone.call( this, texture );\r\n\r\n\treturn texture;\r\n\r\n};\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\r\n\r\n\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\r\n\tthis.image = { data: data, width: width, height: height };\r\n\r\n};\r\n\r\nTHREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );\r\n\r\nTHREE.DataTexture.prototype.clone = function () {\r\n\r\n\tvar texture = new THREE.DataTexture();\r\n\r\n\tTHREE.Texture.prototype.clone.call( this, texture );\r\n\r\n\treturn texture;\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Particle = function ( material ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.material = material;\r\n\r\n};\r\n\r\nTHREE.Particle.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.Particle.prototype.clone = function ( object ) {\r\n\r\n\tif ( object === undefined ) object = new THREE.Particle( this.material );\r\n\r\n\tTHREE.Object3D.prototype.clone.call( this, object );\r\n\r\n\treturn object;\r\n\r\n};\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.ParticleSystem = function ( geometry, material ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.geometry = geometry;\r\n\tthis.material = ( material !== undefined ) ? material : new THREE.ParticleBasicMaterial( { color: Math.random() * 0xffffff } );\r\n\r\n\tthis.sortParticles = false;\r\n\r\n\tif ( this.geometry ) {\r\n\r\n\t\t// calc bound radius\r\n\r\n\t\tif( this.geometry.boundingSphere === null ) {\r\n\r\n\t\t\tthis.geometry.computeBoundingSphere();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.frustumCulled = false;\r\n\r\n};\r\n\r\nTHREE.ParticleSystem.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.ParticleSystem.prototype.clone = function ( object ) {\r\n\r\n\tif ( object === undefined ) object = new THREE.ParticleSystem( this.geometry, this.material );\r\n\tobject.sortParticles = this.sortParticles;\r\n\r\n\tTHREE.Object3D.prototype.clone.call( this, object );\r\n\r\n\treturn object;\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Line = function ( geometry, material, type ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.geometry = geometry;\r\n\tthis.material = ( material !== undefined ) ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );\r\n\tthis.type = ( type !== undefined ) ? type : THREE.LineStrip;\r\n\r\n\tif ( this.geometry ) {\r\n\r\n\t\tif ( ! this.geometry.boundingSphere ) {\r\n\r\n\t\t\tthis.geometry.computeBoundingSphere();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.LineStrip = 0;\r\nTHREE.LinePieces = 1;\r\n\r\nTHREE.Line.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.Line.prototype.clone = function ( object ) {\r\n\r\n\tif ( object === undefined ) object = new THREE.Line( this.geometry, this.material, this.type );\r\n\r\n\tTHREE.Object3D.prototype.clone.call( this, object );\r\n\r\n\treturn object;\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author jonobr1 / http://jonobr1.com/\r\n */\r\n\r\nTHREE.Mesh = function ( geometry, material ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.geometry = geometry;\r\n\tthis.material = ( material !== undefined ) ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff, wireframe: true } );\r\n\r\n\tif ( this.geometry !== undefined ) {\r\n\r\n\t\tif ( this.geometry.boundingSphere === null ) {\r\n\r\n\t\t\tthis.geometry.computeBoundingSphere();\r\n\r\n\t\t}\r\n\r\n\t\tthis.updateMorphTargets();\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.Mesh.prototype.updateMorphTargets = function () {\r\n\r\n\tif ( this.geometry.morphTargets.length > 0 ) {\r\n\r\n\t\tthis.morphTargetBase = -1;\r\n\t\tthis.morphTargetForcedOrder = [];\r\n\t\tthis.morphTargetInfluences = [];\r\n\t\tthis.morphTargetDictionary = {};\r\n\r\n\t\tfor ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {\r\n\r\n\t\t\tthis.morphTargetInfluences.push( 0 );\r\n\t\t\tthis.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {\r\n\r\n\tif ( this.morphTargetDictionary[ name ] !== undefined ) {\r\n\r\n\t\treturn this.morphTargetDictionary[ name ];\r\n\r\n\t}\r\n\r\n\tconsole.log( \"THREE.Mesh.getMorphTargetIndexByName: morph target \" + name + \" does not exist. Returning 0.\" );\r\n\r\n\treturn 0;\r\n\r\n};\r\n\r\nTHREE.Mesh.prototype.clone = function ( object ) {\r\n\r\n\tif ( object === undefined ) object = new THREE.Mesh( this.geometry, this.material );\r\n\r\n\tTHREE.Object3D.prototype.clone.call( this, object );\r\n\r\n\treturn object;\r\n\r\n};\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Bone = function( belongsToSkin ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.skin = belongsToSkin;\r\n\tthis.skinMatrix = new THREE.Matrix4();\r\n\r\n};\r\n\r\nTHREE.Bone.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.Bone.prototype.update = function ( parentSkinMatrix, forceUpdate ) {\r\n\r\n\t// update local\r\n\r\n\tif ( this.matrixAutoUpdate ) {\r\n\r\n\t\tforceUpdate |= this.updateMatrix();\r\n\r\n\t}\r\n\r\n\t// update skin matrix\r\n\r\n\tif ( forceUpdate || this.matrixWorldNeedsUpdate ) {\r\n\r\n\t\tif( parentSkinMatrix ) {\r\n\r\n\t\t\tthis.skinMatrix.multiplyMatrices( parentSkinMatrix, this.matrix );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.skinMatrix.copy( this.matrix );\r\n\r\n\t\t}\r\n\r\n\t\tthis.matrixWorldNeedsUpdate = false;\r\n\t\tforceUpdate = true;\r\n\r\n\t}\r\n\r\n\t// update children\r\n\r\n\tvar child, i, l = this.children.length;\r\n\r\n\tfor ( i = 0; i < l; i ++ ) {\r\n\r\n\t\tthis.children[ i ].update( this.skinMatrix, forceUpdate );\r\n\r\n\t}\r\n\r\n};\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {\r\n\r\n\tTHREE.Mesh.call( this, geometry, material );\r\n\r\n\t//\r\n\r\n\tthis.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;\r\n\r\n\t// init bones\r\n\r\n\tthis.identityMatrix = new THREE.Matrix4();\r\n\r\n\tthis.bones = [];\r\n\tthis.boneMatrices = [];\r\n\r\n\tvar b, bone, gbone, p, q, s;\r\n\r\n\tif ( this.geometry && this.geometry.bones !== undefined ) {\r\n\r\n\t\tfor ( b = 0; b < this.geometry.bones.length; b ++ ) {\r\n\r\n\t\t\tgbone = this.geometry.bones[ b ];\r\n\r\n\t\t\tp = gbone.pos;\r\n\t\t\tq = gbone.rotq;\r\n\t\t\ts = gbone.scl;\r\n\r\n\t\t\tbone = this.addBone();\r\n\r\n\t\t\tbone.name = gbone.name;\r\n\t\t\tbone.position.set( p[0], p[1], p[2] );\r\n\t\t\tbone.quaternion.set( q[0], q[1], q[2], q[3] );\r\n\t\t\tbone.useQuaternion = true;\r\n\r\n\t\t\tif ( s !== undefined ) {\r\n\r\n\t\t\t\tbone.scale.set( s[0], s[1], s[2] );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbone.scale.set( 1, 1, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( b = 0; b < this.bones.length; b ++ ) {\r\n\r\n\t\t\tgbone = this.geometry.bones[ b ];\r\n\t\t\tbone = this.bones[ b ];\r\n\r\n\t\t\tif ( gbone.parent === -1 ) {\r\n\r\n\t\t\t\tthis.add( bone );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.bones[ gbone.parent ].add( bone );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tvar nBones = this.bones.length;\r\n\r\n\t\tif ( this.useVertexTexture ) {\r\n\r\n\t\t\t// layout (1 matrix = 4 pixels)\r\n\t\t\t//\tRGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\r\n\t\t\t//  with  8x8  pixel texture max   16 bones  (8 * 8  / 4)\r\n\t\t\t//  \t 16x16 pixel texture max   64 bones (16 * 16 / 4)\r\n\t\t\t//  \t 32x32 pixel texture max  256 bones (32 * 32 / 4)\r\n\t\t\t//  \t 64x64 pixel texture max 1024 bones (64 * 64 / 4)\r\n\r\n\t\t\tvar size;\r\n\r\n\t\t\tif ( nBones > 256 )\r\n\t\t\t\tsize = 64;\r\n\t\t\telse if ( nBones > 64 )\r\n\t\t\t\tsize = 32;\r\n\t\t\telse if ( nBones > 16 )\r\n\t\t\t\tsize = 16;\r\n\t\t\telse\r\n\t\t\t\tsize = 8;\r\n\r\n\t\t\tthis.boneTextureWidth = size;\r\n\t\t\tthis.boneTextureHeight = size;\r\n\r\n\t\t\tthis.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel\r\n\t\t\tthis.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );\r\n\t\t\tthis.boneTexture.minFilter = THREE.NearestFilter;\r\n\t\t\tthis.boneTexture.magFilter = THREE.NearestFilter;\r\n\t\t\tthis.boneTexture.generateMipmaps = false;\r\n\t\t\tthis.boneTexture.flipY = false;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.boneMatrices = new Float32Array( 16 * nBones );\r\n\r\n\t\t}\r\n\r\n\t\tthis.pose();\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );\r\n\r\nTHREE.SkinnedMesh.prototype.addBone = function( bone ) {\r\n\r\n\tif ( bone === undefined ) {\r\n\r\n\t\tbone = new THREE.Bone( this );\r\n\r\n\t}\r\n\r\n\tthis.bones.push( bone );\r\n\r\n\treturn bone;\r\n\r\n};\r\n\r\nTHREE.SkinnedMesh.prototype.updateMatrixWorld = function ( force ) {\r\n\r\n\tthis.matrixAutoUpdate && this.updateMatrix();\r\n\r\n\t// update matrixWorld\r\n\r\n\tif ( this.matrixWorldNeedsUpdate || force ) {\r\n\r\n\t\tif ( this.parent ) {\r\n\r\n\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.matrixWorld.copy( this.matrix );\r\n\r\n\t\t}\r\n\r\n\t\tthis.matrixWorldNeedsUpdate = false;\r\n\r\n\t\tforce = true;\r\n\r\n\t}\r\n\r\n\t// update children\r\n\r\n\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n\t\tvar child = this.children[ i ];\r\n\r\n\t\tif ( child instanceof THREE.Bone ) {\r\n\r\n\t\t\tchild.update( this.identityMatrix, false );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tchild.updateMatrixWorld( true );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// make a snapshot of the bones' rest position\r\n\r\n\tif ( this.boneInverses == undefined ) {\r\n\r\n\t\tthis.boneInverses = [];\r\n\r\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n\t\t\tvar inverse = new THREE.Matrix4();\r\n\r\n\t\t\tinverse.getInverse( this.bones[ b ].skinMatrix );\r\n\r\n\t\t\tthis.boneInverses.push( inverse );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// flatten bone matrices to array\r\n\r\n\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n\t\t// compute the offset between the current and the original transform;\r\n\r\n\t\t//TODO: we could get rid of this multiplication step if the skinMatrix\r\n\t\t// was already representing the offset; however, this requires some\r\n\t\t// major changes to the animation system\r\n\r\n\t\tTHREE.SkinnedMesh.offsetMatrix.multiplyMatrices( this.bones[ b ].skinMatrix, this.boneInverses[ b ] );\r\n\r\n\t\tTHREE.SkinnedMesh.offsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );\r\n\r\n\t}\r\n\r\n\tif ( this.useVertexTexture ) {\r\n\r\n\t\tthis.boneTexture.needsUpdate = true;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.SkinnedMesh.prototype.pose = function () {\r\n\r\n\tthis.updateMatrixWorld( true );\r\n\r\n\tfor ( var i = 0; i < this.geometry.skinIndices.length; i ++ ) {\r\n\r\n\t\t// normalize weights\r\n\r\n\t\tvar sw = this.geometry.skinWeights[ i ];\r\n\r\n\t\tvar scale = 1.0 / sw.lengthManhattan();\r\n\r\n\t\tif ( scale !== Infinity ) {\r\n\r\n\t\t\tsw.multiplyScalar( scale );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tsw.set( 1 ); // this will be normalized by the shader anyway\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.SkinnedMesh.prototype.clone = function ( object ) {\r\n\r\n\tif ( object === undefined ) object = new THREE.SkinnedMesh( this.geometry, this.material, this.useVertexTexture );\r\n\r\n\tTHREE.Mesh.prototype.clone.call( this, object );\r\n\r\n\treturn object;\r\n\r\n};\r\n\r\nTHREE.SkinnedMesh.offsetMatrix = new THREE.Matrix4();\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.MorphAnimMesh = function ( geometry, material ) {\r\n\r\n\tTHREE.Mesh.call( this, geometry, material );\r\n\r\n\t// API\r\n\r\n\tthis.duration = 1000; // milliseconds\r\n\tthis.mirroredLoop = false;\r\n\tthis.time = 0;\r\n\r\n\t// internals\r\n\r\n\tthis.lastKeyframe = 0;\r\n\tthis.currentKeyframe = 0;\r\n\r\n\tthis.direction = 1;\r\n\tthis.directionBackwards = false;\r\n\r\n\tthis.setFrameRange( 0, this.geometry.morphTargets.length - 1 );\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype = Object.create( THREE.Mesh.prototype );\r\n\r\nTHREE.MorphAnimMesh.prototype.setFrameRange = function ( start, end ) {\r\n\r\n\tthis.startKeyframe = start;\r\n\tthis.endKeyframe = end;\r\n\r\n\tthis.length = this.endKeyframe - this.startKeyframe + 1;\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.setDirectionForward = function () {\r\n\r\n\tthis.direction = 1;\r\n\tthis.directionBackwards = false;\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.setDirectionBackward = function () {\r\n\r\n\tthis.direction = -1;\r\n\tthis.directionBackwards = true;\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.parseAnimations = function () {\r\n\r\n\tvar geometry = this.geometry;\r\n\r\n\tif ( ! geometry.animations ) geometry.animations = {};\r\n\r\n\tvar firstAnimation, animations = geometry.animations;\r\n\r\n\tvar pattern = /([a-z]+)(\\d+)/;\r\n\r\n\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\r\n\r\n\t\tvar morph = geometry.morphTargets[ i ];\r\n\t\tvar parts = morph.name.match( pattern );\r\n\r\n\t\tif ( parts && parts.length > 1 ) {\r\n\r\n\t\t\tvar label = parts[ 1 ];\r\n\t\t\tvar num = parts[ 2 ];\r\n\r\n\t\t\tif ( ! animations[ label ] ) animations[ label ] = { start: Infinity, end: -Infinity };\r\n\r\n\t\t\tvar animation = animations[ label ];\r\n\r\n\t\t\tif ( i < animation.start ) animation.start = i;\r\n\t\t\tif ( i > animation.end ) animation.end = i;\r\n\r\n\t\t\tif ( ! firstAnimation ) firstAnimation = label;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgeometry.firstAnimation = firstAnimation;\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.setAnimationLabel = function ( label, start, end ) {\r\n\r\n\tif ( ! this.geometry.animations ) this.geometry.animations = {};\r\n\r\n\tthis.geometry.animations[ label ] = { start: start, end: end };\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.playAnimation = function ( label, fps ) {\r\n\r\n\tvar animation = this.geometry.animations[ label ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tthis.setFrameRange( animation.start, animation.end );\r\n\t\tthis.duration = 1000 * ( ( animation.end - animation.start ) / fps );\r\n\t\tthis.time = 0;\r\n\r\n\t} else {\r\n\r\n\t\tconsole.warn( \"animation[\" + label + \"] undefined\" );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.updateAnimation = function ( delta ) {\r\n\r\n\tvar frameTime = this.duration / this.length;\r\n\r\n\tthis.time += this.direction * delta;\r\n\r\n\tif ( this.mirroredLoop ) {\r\n\r\n\t\tif ( this.time > this.duration || this.time < 0 ) {\r\n\r\n\t\t\tthis.direction *= -1;\r\n\r\n\t\t\tif ( this.time > this.duration ) {\r\n\r\n\t\t\t\tthis.time = this.duration;\r\n\t\t\t\tthis.directionBackwards = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( this.time < 0 ) {\r\n\r\n\t\t\t\tthis.time = 0;\r\n\t\t\t\tthis.directionBackwards = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tthis.time = this.time % this.duration;\r\n\r\n\t\tif ( this.time < 0 ) this.time += this.duration;\r\n\r\n\t}\r\n\r\n\tvar keyframe = this.startKeyframe + THREE.Math.clamp( Math.floor( this.time / frameTime ), 0, this.length - 1 );\r\n\r\n\tif ( keyframe !== this.currentKeyframe ) {\r\n\r\n\t\tthis.morphTargetInfluences[ this.lastKeyframe ] = 0;\r\n\t\tthis.morphTargetInfluences[ this.currentKeyframe ] = 1;\r\n\r\n\t\tthis.morphTargetInfluences[ keyframe ] = 0;\r\n\r\n\t\tthis.lastKeyframe = this.currentKeyframe;\r\n\t\tthis.currentKeyframe = keyframe;\r\n\r\n\t}\r\n\r\n\tvar mix = ( this.time % frameTime ) / frameTime;\r\n\r\n\tif ( this.directionBackwards ) {\r\n\r\n\t\tmix = 1 - mix;\r\n\r\n\t}\r\n\r\n\tthis.morphTargetInfluences[ this.currentKeyframe ] = mix;\r\n\tthis.morphTargetInfluences[ this.lastKeyframe ] = 1 - mix;\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.clone = function ( object ) {\r\n\r\n\tif ( object === undefined ) object = new THREE.MorphAnimMesh( this.geometry, this.material );\r\n\r\n\tobject.duration = this.duration;\r\n\tobject.mirroredLoop = this.mirroredLoop;\r\n\tobject.time = this.time;\r\n\r\n\tobject.lastKeyframe = this.lastKeyframe;\r\n\tobject.currentKeyframe = this.currentKeyframe;\r\n\r\n\tobject.direction = this.direction;\r\n\tobject.directionBackwards = this.directionBackwards;\r\n\r\n\tTHREE.Mesh.prototype.clone.call( this, object );\r\n\r\n\treturn object;\r\n\r\n};\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Ribbon = function ( geometry, material ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.geometry = geometry;\r\n\tthis.material = material;\r\n\r\n};\r\n\r\nTHREE.Ribbon.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.Ribbon.prototype.clone = function ( object ) {\r\n\r\n\tif ( object === undefined ) object = new THREE.Ribbon( this.geometry, this.material );\r\n\r\n\tTHREE.Object3D.prototype.clone.call( this, object );\r\n\r\n\treturn object;\r\n\r\n};\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.LOD = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.LODs = [];\r\n\r\n};\r\n\r\n\r\nTHREE.LOD.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.LOD.prototype.addLevel = function ( object3D, visibleAtDistance ) {\r\n\r\n\tif ( visibleAtDistance === undefined ) {\r\n\r\n\t\tvisibleAtDistance = 0;\r\n\r\n\t}\r\n\r\n\tvisibleAtDistance = Math.abs( visibleAtDistance );\r\n\r\n\tfor ( var l = 0; l < this.LODs.length; l ++ ) {\r\n\r\n\t\tif ( visibleAtDistance < this.LODs[ l ].visibleAtDistance ) {\r\n\r\n\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.LODs.splice( l, 0, { visibleAtDistance: visibleAtDistance, object3D: object3D } );\r\n\tthis.add( object3D );\r\n\r\n};\r\n\r\nTHREE.LOD.prototype.update = function ( camera ) {\r\n\r\n\tif ( this.LODs.length > 1 ) {\r\n\r\n\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\r\n\r\n\t\tvar inverse  = camera.matrixWorldInverse;\r\n\t\tvar distance = -( inverse.elements[2] * this.matrixWorld.elements[12] + inverse.elements[6] * this.matrixWorld.elements[13] + inverse.elements[10] * this.matrixWorld.elements[14] + inverse.elements[14] );\r\n\r\n\t\tthis.LODs[ 0 ].object3D.visible = true;\r\n\r\n\t\tfor ( var l = 1; l < this.LODs.length; l ++ ) {\r\n\r\n\t\t\tif( distance >= this.LODs[ l ].visibleAtDistance ) {\r\n\r\n\t\t\t\tthis.LODs[ l - 1 ].object3D.visible = false;\r\n\t\t\t\tthis.LODs[ l     ].object3D.visible = true;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor( ; l < this.LODs.length; l ++ ) {\r\n\r\n\t\t\tthis.LODs[ l ].object3D.visible = false;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.LOD.prototype.clone = function () {\r\n\r\n\t// TODO\r\n\r\n};\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Sprite = function ( material ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();\r\n\r\n\tthis.rotation3d = this.rotation;\r\n\tthis.rotation = 0;\r\n\r\n};\r\n\r\nTHREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\n/*\r\n * Custom update matrix\r\n */\r\n\r\nTHREE.Sprite.prototype.updateMatrix = function () {\r\n\r\n\tthis.matrix.setPosition( this.position );\r\n\r\n\tthis.rotation3d.set( 0, 0, this.rotation );\r\n\tthis.matrix.setRotationFromEuler( this.rotation3d );\r\n\r\n\tif ( this.scale.x !== 1 || this.scale.y !== 1 ) {\r\n\r\n\t\tthis.matrix.scale( this.scale );\r\n\r\n\t}\r\n\r\n\tthis.matrixWorldNeedsUpdate = true;\r\n\r\n};\r\n\r\nTHREE.Sprite.prototype.clone = function ( object ) {\r\n\r\n\tif ( object === undefined ) object = new THREE.Sprite( this.material );\r\n\r\n\tTHREE.Object3D.prototype.clone.call( this, object );\r\n\r\n\treturn object;\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Scene = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.fog = null;\r\n\tthis.overrideMaterial = null;\r\n\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tthis.__objects = [];\r\n\tthis.__lights = [];\r\n\r\n\tthis.__objectsAdded = [];\r\n\tthis.__objectsRemoved = [];\r\n\r\n};\r\n\r\nTHREE.Scene.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.Scene.prototype.__addObject = function ( object ) {\r\n\r\n\tif ( object instanceof THREE.Light ) {\r\n\r\n\t\tif ( this.__lights.indexOf( object ) === - 1 ) {\r\n\r\n\t\t\tthis.__lights.push( object );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.target && object.target.parent === undefined ) {\r\n\r\n\t\t\tthis.add( object.target );\r\n\r\n\t\t}\r\n\r\n\t} else if ( !( object instanceof THREE.Camera || object instanceof THREE.Bone ) ) {\r\n\r\n\t\tif ( this.__objects.indexOf( object ) === - 1 ) {\r\n\r\n\t\t\tthis.__objects.push( object );\r\n\t\t\tthis.__objectsAdded.push( object );\r\n\r\n\t\t\t// check if previously removed\r\n\r\n\t\t\tvar i = this.__objectsRemoved.indexOf( object );\r\n\r\n\t\t\tif ( i !== -1 ) {\r\n\r\n\t\t\t\tthis.__objectsRemoved.splice( i, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfor ( var c = 0; c < object.children.length; c ++ ) {\r\n\r\n\t\tthis.__addObject( object.children[ c ] );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Scene.prototype.__removeObject = function ( object ) {\r\n\r\n\tif ( object instanceof THREE.Light ) {\r\n\r\n\t\tvar i = this.__lights.indexOf( object );\r\n\r\n\t\tif ( i !== -1 ) {\r\n\r\n\t\t\tthis.__lights.splice( i, 1 );\r\n\r\n\t\t}\r\n\r\n\t} else if ( !( object instanceof THREE.Camera ) ) {\r\n\r\n\t\tvar i = this.__objects.indexOf( object );\r\n\r\n\t\tif( i !== -1 ) {\r\n\r\n\t\t\tthis.__objects.splice( i, 1 );\r\n\t\t\tthis.__objectsRemoved.push( object );\r\n\r\n\t\t\t// check if previously added\r\n\r\n\t\t\tvar ai = this.__objectsAdded.indexOf( object );\r\n\r\n\t\t\tif ( ai !== -1 ) {\r\n\r\n\t\t\t\tthis.__objectsAdded.splice( ai, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfor ( var c = 0; c < object.children.length; c ++ ) {\r\n\r\n\t\tthis.__removeObject( object.children[ c ] );\r\n\r\n\t}\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Fog = function ( hex, near, far ) {\r\n\r\n\tthis.name = '';\r\n\r\n\tthis.color = new THREE.Color( hex );\r\n\r\n\tthis.near = ( near !== undefined ) ? near : 1;\r\n\tthis.far = ( far !== undefined ) ? far : 1000;\r\n\r\n};\r\n\r\nTHREE.Fog.prototype.clone = function () {\r\n\r\n\treturn new THREE.Fog( this.color.getHex(), this.near, this.far );\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.FogExp2 = function ( hex, density ) {\r\n\r\n\tthis.name = '';\r\n\tthis.color = new THREE.Color( hex );\r\n\tthis.density = ( density !== undefined ) ? density : 0.00025;\r\n\r\n};\r\n\r\nTHREE.FogExp2.prototype.clone = function () {\r\n\r\n\treturn new THREE.FogExp2( this.color.getHex(), this.density );\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.CanvasRenderer = function ( parameters ) {\r\n\r\n\tconsole.log( 'THREE.CanvasRenderer', THREE.REVISION );\r\n\r\n\tvar smoothstep = THREE.Math.smoothstep;\r\n\r\n\tparameters = parameters || {};\r\n\r\n\tvar _this = this,\r\n\t_renderData, _elements, _lights,\r\n\t_projector = new THREE.Projector(),\r\n\r\n\t_canvas = parameters.canvas !== undefined\r\n\t\t\t? parameters.canvas\r\n\t\t\t: document.createElement( 'canvas' ),\r\n\r\n\t_canvasWidth, _canvasHeight, _canvasWidthHalf, _canvasHeightHalf,\r\n\t_context = _canvas.getContext( '2d' ),\r\n\r\n\t_clearColor = new THREE.Color( 0x000000 ),\r\n\t_clearOpacity = 0,\r\n\r\n\t_contextGlobalAlpha = 1,\r\n\t_contextGlobalCompositeOperation = 0,\r\n\t_contextStrokeStyle = null,\r\n\t_contextFillStyle = null,\r\n\t_contextLineWidth = null,\r\n\t_contextLineCap = null,\r\n\t_contextLineJoin = null,\r\n\t_contextDashSize = null,\r\n\t_contextGapSize = 0,\r\n\r\n\t_v1, _v2, _v3, _v4,\r\n\t_v5 = new THREE.RenderableVertex(),\r\n\t_v6 = new THREE.RenderableVertex(),\r\n\r\n\t_v1x, _v1y, _v2x, _v2y, _v3x, _v3y,\r\n\t_v4x, _v4y, _v5x, _v5y, _v6x, _v6y,\r\n\r\n\t_color = new THREE.Color(),\r\n\t_color1 = new THREE.Color(),\r\n\t_color2 = new THREE.Color(),\r\n\t_color3 = new THREE.Color(),\r\n\t_color4 = new THREE.Color(),\r\n\r\n\t_diffuseColor = new THREE.Color(),\r\n\t_emissiveColor = new THREE.Color(),\r\n\r\n\t_lightColor = new THREE.Color(),\r\n\r\n\t_patterns = {}, _imagedatas = {},\r\n\r\n\t_near, _far,\r\n\r\n\t_image, _uvs,\r\n\t_uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y,\r\n\r\n\t_clipBox = new THREE.Box2(),\r\n\t_clearBox = new THREE.Box2(),\r\n\t_elemBox = new THREE.Box2(),\r\n\r\n\t_enableLighting = false,\r\n\t_ambientLight = new THREE.Color(),\r\n\t_directionalLights = new THREE.Color(),\r\n\t_pointLights = new THREE.Color(),\r\n\r\n\t_vector3 = new THREE.Vector3(), // Needed for PointLight\r\n\r\n\t_pixelMap, _pixelMapContext, _pixelMapImage, _pixelMapData,\r\n\t_gradientMap, _gradientMapContext, _gradientMapQuality = 16;\r\n\r\n\t_pixelMap = document.createElement( 'canvas' );\r\n\t_pixelMap.width = _pixelMap.height = 2;\r\n\r\n\t_pixelMapContext = _pixelMap.getContext( '2d' );\r\n\t_pixelMapContext.fillStyle = 'rgba(0,0,0,1)';\r\n\t_pixelMapContext.fillRect( 0, 0, 2, 2 );\r\n\r\n\t_pixelMapImage = _pixelMapContext.getImageData( 0, 0, 2, 2 );\r\n\t_pixelMapData = _pixelMapImage.data;\r\n\r\n\t_gradientMap = document.createElement( 'canvas' );\r\n\t_gradientMap.width = _gradientMap.height = _gradientMapQuality;\r\n\r\n\t_gradientMapContext = _gradientMap.getContext( '2d' );\r\n\t_gradientMapContext.translate( - _gradientMapQuality / 2, - _gradientMapQuality / 2 );\r\n\t_gradientMapContext.scale( _gradientMapQuality, _gradientMapQuality );\r\n\r\n\t_gradientMapQuality --; // Fix UVs\r\n\r\n\t// dash+gap fallbacks for Firefox and everything else\r\n\r\n\tif ( _context.setLineDash === undefined ) {\r\n\r\n\t\tif ( _context.mozDash !== undefined ) {\r\n\r\n\t\t\t_context.setLineDash = function ( values ) {\r\n\r\n\t\t\t\t_context.mozDash = values[ 0 ] !== null ? values : null;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_context.setLineDash = function () {}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.domElement = _canvas;\r\n\r\n\tthis.devicePixelRatio = parameters.devicePixelRatio !== undefined\r\n\t\t\t\t? parameters.devicePixelRatio\r\n\t\t\t\t: window.devicePixelRatio !== undefined\r\n\t\t\t\t\t? window.devicePixelRatio\r\n\t\t\t\t\t: 1;\r\n\r\n\tthis.autoClear = true;\r\n\tthis.sortObjects = true;\r\n\tthis.sortElements = true;\r\n\r\n\tthis.info = {\r\n\r\n\t\trender: {\r\n\r\n\t\t\tvertices: 0,\r\n\t\t\tfaces: 0\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// WebGLRenderer compatibility\r\n\r\n\tthis.supportsVertexTextures = function () {};\r\n\tthis.setFaceCulling = function () {};\r\n\r\n\tthis.setSize = function ( width, height ) {\r\n\r\n\t\t_canvasWidth = width * this.devicePixelRatio;\r\n\t\t_canvasHeight = height * this.devicePixelRatio;\r\n\r\n\t\t_canvasWidthHalf = Math.floor( _canvasWidth / 2 );\r\n\t\t_canvasHeightHalf = Math.floor( _canvasHeight / 2 );\r\n\r\n\t\t_canvas.width = _canvasWidth;\r\n\t\t_canvas.height = _canvasHeight;\r\n\r\n\t\t_canvas.style.width = width + 'px';\r\n\t\t_canvas.style.height = height + 'px';\r\n\r\n\t\t_clipBox.set(\r\n\t\t\tnew THREE.Vector2( - _canvasWidthHalf, - _canvasHeightHalf ),\r\n\t\t\tnew THREE.Vector2( _canvasWidthHalf, _canvasHeightHalf )\r\n\t\t);\r\n\r\n\t\t_clearBox.set(\r\n\t\t\tnew THREE.Vector2( - _canvasWidthHalf, - _canvasHeightHalf ),\r\n\t\t\tnew THREE.Vector2( _canvasWidthHalf, _canvasHeightHalf )\r\n\t\t);\r\n\r\n\t\t_contextGlobalAlpha = 1;\r\n\t\t_contextGlobalCompositeOperation = 0;\r\n\t\t_contextStrokeStyle = null;\r\n\t\t_contextFillStyle = null;\r\n\t\t_contextLineWidth = null;\r\n\t\t_contextLineCap = null;\r\n\t\t_contextLineJoin = null;\r\n\r\n\t};\r\n\r\n\tthis.setClearColor = function ( color, opacity ) {\r\n\r\n\t\t_clearColor.copy( color );\r\n\t\t_clearOpacity = opacity !== undefined ? opacity : 1;\r\n\r\n\t\t_clearBox.set(\r\n\t\t\tnew THREE.Vector2( - _canvasWidthHalf, - _canvasHeightHalf ),\r\n\t\t\tnew THREE.Vector2( _canvasWidthHalf, _canvasHeightHalf )\r\n\t\t);\r\n\r\n\t};\r\n\r\n\tthis.setClearColorHex = function ( hex, opacity ) {\r\n\r\n\t\t_clearColor.setHex( hex );\r\n\t\t_clearOpacity = opacity !== undefined ? opacity : 1;\r\n\r\n\t\t_clearBox.set(\r\n\t\t\tnew THREE.Vector2( - _canvasWidthHalf, - _canvasHeightHalf ),\r\n\t\t\tnew THREE.Vector2( _canvasWidthHalf, _canvasHeightHalf )\r\n\t\t);\r\n\r\n\t};\r\n\r\n\tthis.getMaxAnisotropy  = function () {\r\n\r\n\t\treturn 0;\r\n\r\n\t};\r\n\r\n\tthis.clear = function () {\r\n\r\n\t\t_context.setTransform( 1, 0, 0, - 1, _canvasWidthHalf, _canvasHeightHalf );\r\n\r\n\t\tif ( _clearBox.empty() === false ) {\r\n\r\n\t\t\t_clearBox.intersect( _clipBox );\r\n\t\t\t_clearBox.expandByScalar( 2 );\r\n\r\n\t\t\tif ( _clearOpacity < 1 ) {\r\n\r\n\t\t\t\t_context.clearRect(\r\n\t\t\t\t\t_clearBox.min.x | 0,\r\n\t\t\t\t\t_clearBox.min.y | 0,\r\n\t\t\t\t\t( _clearBox.max.x - _clearBox.min.x ) | 0,\r\n\t\t\t\t\t( _clearBox.max.y - _clearBox.min.y ) | 0\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( _clearOpacity > 0 ) {\r\n\r\n\t\t\t\tsetBlending( THREE.NormalBlending );\r\n\t\t\t\tsetOpacity( 1 );\r\n\r\n\t\t\t\tsetFillStyle( 'rgba(' + Math.floor( _clearColor.r * 255 ) + ',' + Math.floor( _clearColor.g * 255 ) + ',' + Math.floor( _clearColor.b * 255 ) + ',' + _clearOpacity + ')' );\r\n\r\n\t\t\t\t_context.fillRect(\r\n\t\t\t\t\t_clearBox.min.x | 0,\r\n\t\t\t\t\t_clearBox.min.y | 0,\r\n\t\t\t\t\t( _clearBox.max.x - _clearBox.min.x ) | 0,\r\n\t\t\t\t\t( _clearBox.max.y - _clearBox.min.y ) | 0\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_clearBox.makeEmpty();\r\n\r\n\t\t}\r\n\r\n\r\n\t};\r\n\r\n\tthis.render = function ( scene, camera ) {\r\n\r\n\t\tif ( camera instanceof THREE.Camera === false ) {\r\n\r\n\t\t\tconsole.error( 'THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.autoClear === true ) {\r\n\r\n\t\t\tthis.clear();\r\n\r\n\t\t}\r\n\r\n\t\t_context.setTransform( 1, 0, 0, - 1, _canvasWidthHalf, _canvasHeightHalf );\r\n\r\n\t\t_this.info.render.vertices = 0;\r\n\t\t_this.info.render.faces = 0;\r\n\r\n\t\t_renderData = _projector.projectScene( scene, camera, this.sortObjects, this.sortElements );\r\n\t\t_elements = _renderData.elements;\r\n\t\t_lights = _renderData.lights;\r\n\r\n\t\t/* DEBUG\r\n\t\tsetFillStyle( 'rgba( 0, 255, 255, 0.5 )' );\r\n\t\t_context.fillRect( _clipBox.min.x, _clipBox.min.y, _clipBox.max.x - _clipBox.min.x, _clipBox.max.y - _clipBox.min.y );\r\n\t\t*/\r\n\r\n\t\t_enableLighting = _lights.length > 0;\r\n\r\n\t\tif ( _enableLighting === true ) {\r\n\r\n\t\t\t calculateLights();\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var e = 0, el = _elements.length; e < el; e++ ) {\r\n\r\n\t\t\tvar element = _elements[ e ];\r\n\r\n\t\t\tvar material = element.material;\r\n\r\n\t\t\tif ( material === undefined || material.visible === false ) continue;\r\n\r\n\t\t\t_elemBox.makeEmpty();\r\n\r\n\t\t\tif ( element instanceof THREE.RenderableParticle ) {\r\n\r\n\t\t\t\t_v1 = element;\r\n\t\t\t\t_v1.x *= _canvasWidthHalf; _v1.y *= _canvasHeightHalf;\r\n\r\n\t\t\t\trenderParticle( _v1, element, material );\r\n\r\n\t\t\t} else if ( element instanceof THREE.RenderableLine ) {\r\n\r\n\t\t\t\t_v1 = element.v1; _v2 = element.v2;\r\n\r\n\t\t\t\t_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;\r\n\t\t\t\t_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;\r\n\r\n\t\t\t\t_elemBox.setFromPoints( [ _v1.positionScreen, _v2.positionScreen ] );\r\n\r\n\t\t\t\tif ( _clipBox.isIntersectionBox( _elemBox ) === true ) {\r\n\r\n\t\t\t\t\trenderLine( _v1, _v2, element, material );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( element instanceof THREE.RenderableFace3 ) {\r\n\r\n\t\t\t\t_v1 = element.v1; _v2 = element.v2; _v3 = element.v3;\r\n\r\n\t\t\t\tif ( _v1.positionScreen.z < -1 || _v1.positionScreen.z > 1 ) continue;\r\n\t\t\t\tif ( _v2.positionScreen.z < -1 || _v2.positionScreen.z > 1 ) continue;\r\n\t\t\t\tif ( _v3.positionScreen.z < -1 || _v3.positionScreen.z > 1 ) continue;\r\n\r\n\t\t\t\t_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;\r\n\t\t\t\t_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;\r\n\t\t\t\t_v3.positionScreen.x *= _canvasWidthHalf; _v3.positionScreen.y *= _canvasHeightHalf;\r\n\r\n\t\t\t\tif ( material.overdraw === true ) {\r\n\r\n\t\t\t\t\texpand( _v1.positionScreen, _v2.positionScreen );\r\n\t\t\t\t\texpand( _v2.positionScreen, _v3.positionScreen );\r\n\t\t\t\t\texpand( _v3.positionScreen, _v1.positionScreen );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_elemBox.setFromPoints( [ _v1.positionScreen, _v2.positionScreen, _v3.positionScreen ] );\r\n\r\n\t\t\t\trenderFace3( _v1, _v2, _v3, 0, 1, 2, element, material );\r\n\r\n\t\t\t} else if ( element instanceof THREE.RenderableFace4 ) {\r\n\r\n\t\t\t\t_v1 = element.v1; _v2 = element.v2; _v3 = element.v3; _v4 = element.v4;\r\n\r\n\t\t\t\tif ( _v1.positionScreen.z < -1 || _v1.positionScreen.z > 1 ) continue;\r\n\t\t\t\tif ( _v2.positionScreen.z < -1 || _v2.positionScreen.z > 1 ) continue;\r\n\t\t\t\tif ( _v3.positionScreen.z < -1 || _v3.positionScreen.z > 1 ) continue;\r\n\t\t\t\tif ( _v4.positionScreen.z < -1 || _v4.positionScreen.z > 1 ) continue;\r\n\r\n\t\t\t\t_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;\r\n\t\t\t\t_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;\r\n\t\t\t\t_v3.positionScreen.x *= _canvasWidthHalf; _v3.positionScreen.y *= _canvasHeightHalf;\r\n\t\t\t\t_v4.positionScreen.x *= _canvasWidthHalf; _v4.positionScreen.y *= _canvasHeightHalf;\r\n\r\n\t\t\t\t_v5.positionScreen.copy( _v2.positionScreen );\r\n\t\t\t\t_v6.positionScreen.copy( _v4.positionScreen );\r\n\r\n\t\t\t\tif ( material.overdraw === true ) {\r\n\r\n\t\t\t\t\texpand( _v1.positionScreen, _v2.positionScreen );\r\n\t\t\t\t\texpand( _v2.positionScreen, _v4.positionScreen );\r\n\t\t\t\t\texpand( _v4.positionScreen, _v1.positionScreen );\r\n\r\n\t\t\t\t\texpand( _v3.positionScreen, _v5.positionScreen );\r\n\t\t\t\t\texpand( _v3.positionScreen, _v6.positionScreen );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_elemBox.setFromPoints( [ _v1.positionScreen, _v2.positionScreen, _v3.positionScreen, _v4.positionScreen ] );\r\n\r\n\t\t\t\trenderFace4( _v1, _v2, _v3, _v4, _v5, _v6, element, material, scene );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t/* DEBUG\r\n\t\t\tsetLineWidth( 1 );\r\n\t\t\tsetStrokeStyle( 'rgba( 0, 255, 0, 0.5 )' );\r\n\t\t\t_context.strokeRect( _elemBox.min.x, _elemBox.min.y, _elemBox.max.x - _elemBox.min.x, _elemBox.max.y - _elemBox.min.y );\r\n\t\t\t*/\r\n\r\n\t\t\t_clearBox.union( _elemBox );\r\n\r\n\t\t}\r\n\r\n\t\t/* DEBUG\r\n\t\tsetLineWidth( 1 );\r\n\t\tsetStrokeStyle( 'rgba( 255, 0, 0, 0.5 )' );\r\n\t\t_context.strokeRect( _clearBox.min.x, _clearBox.min.y, _clearBox.max.x - _clearBox.min.x, _clearBox.max.y - _clearBox.min.y );\r\n\t\t*/\r\n\r\n\t\t_context.setTransform( 1, 0, 0, 1, 0, 0 );\r\n\r\n\t\t//\r\n\r\n\t\tfunction calculateLights() {\r\n\r\n\t\t\t_ambientLight.setRGB( 0, 0, 0 );\r\n\t\t\t_directionalLights.setRGB( 0, 0, 0 );\r\n\t\t\t_pointLights.setRGB( 0, 0, 0 );\r\n\r\n\t\t\tfor ( var l = 0, ll = _lights.length; l < ll; l ++ ) {\r\n\r\n\t\t\t\tvar light = _lights[ l ];\r\n\t\t\t\tvar lightColor = light.color;\r\n\r\n\t\t\t\tif ( light instanceof THREE.AmbientLight ) {\r\n\r\n\t\t\t\t\t_ambientLight.add( lightColor );\r\n\r\n\t\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\r\n\r\n\t\t\t\t\t// for particles\r\n\r\n\t\t\t\t\t_directionalLights.add( lightColor );\r\n\r\n\t\t\t\t} else if ( light instanceof THREE.PointLight ) {\r\n\r\n\t\t\t\t\t// for particles\r\n\r\n\t\t\t\t\t_pointLights.add( lightColor );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction calculateLight( position, normal, color ) {\r\n\r\n\t\t\tfor ( var l = 0, ll = _lights.length; l < ll; l ++ ) {\r\n\r\n\t\t\t\tvar light = _lights[ l ];\r\n\r\n\t\t\t\t_lightColor.copy( light.color );\r\n\r\n\t\t\t\tif ( light instanceof THREE.DirectionalLight ) {\r\n\r\n\t\t\t\t\tvar lightPosition = _vector3.getPositionFromMatrix( light.matrixWorld ).normalize();\r\n\r\n\t\t\t\t\tvar amount = normal.dot( lightPosition );\r\n\r\n\t\t\t\t\tif ( amount <= 0 ) continue;\r\n\r\n\t\t\t\t\tamount *= light.intensity;\r\n\r\n\t\t\t\t\tcolor.add( _lightColor.multiplyScalar( amount ) );\r\n\r\n\t\t\t\t} else if ( light instanceof THREE.PointLight ) {\r\n\r\n\t\t\t\t\tvar lightPosition = _vector3.getPositionFromMatrix( light.matrixWorld );\r\n\r\n\t\t\t\t\tvar amount = normal.dot( _vector3.subVectors( lightPosition, position ).normalize() );\r\n\r\n\t\t\t\t\tif ( amount <= 0 ) continue;\r\n\r\n\t\t\t\t\tamount *= light.distance == 0 ? 1 : 1 - Math.min( position.distanceTo( lightPosition ) / light.distance, 1 );\r\n\r\n\t\t\t\t\tif ( amount == 0 ) continue;\r\n\r\n\t\t\t\t\tamount *= light.intensity;\r\n\r\n\t\t\t\t\tcolor.add( _lightColor.multiplyScalar( amount ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction renderParticle( v1, element, material ) {\r\n\r\n\t\t\tsetOpacity( material.opacity );\r\n\t\t\tsetBlending( material.blending );\r\n\r\n\t\t\tvar width, height, scaleX, scaleY,\r\n\t\t\tbitmap, bitmapWidth, bitmapHeight;\r\n\r\n\t\t\tif ( material instanceof THREE.ParticleBasicMaterial ) {\r\n\r\n\t\t\t\tif ( material.map === null ) {\r\n\r\n\t\t\t\t\tscaleX = element.object.scale.x;\r\n\t\t\t\t\tscaleY = element.object.scale.y;\r\n\r\n\t\t\t\t\t// TODO: Be able to disable this\r\n\r\n\t\t\t\t\tscaleX *= element.scale.x * _canvasWidthHalf;\r\n\t\t\t\t\tscaleY *= element.scale.y * _canvasHeightHalf;\r\n\r\n\t\t\t\t\t_elemBox.min.set( v1.x - scaleX, v1.y - scaleY );\r\n\t\t\t\t\t_elemBox.max.set( v1.x + scaleX, v1.y + scaleY );\r\n\r\n\t\t\t\t\tif ( _clipBox.isIntersectionBox( _elemBox ) === false ) {\r\n\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tsetFillStyle( material.color.getStyle() );\r\n\r\n\t\t\t\t\t_context.save();\r\n\t\t\t\t\t_context.translate( v1.x, v1.y );\r\n\t\t\t\t\t_context.rotate( - element.rotation );\r\n\t\t\t\t\t_context.scale( scaleX, scaleY );\r\n\t\t\t\t\t_context.fillRect( -1, -1, 2, 2 );\r\n\t\t\t\t\t_context.restore();\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tbitmap = material.map.image;\r\n\t\t\t\t\tbitmapWidth = bitmap.width >> 1;\r\n\t\t\t\t\tbitmapHeight = bitmap.height >> 1;\r\n\r\n\t\t\t\t\tscaleX = element.scale.x * _canvasWidthHalf;\r\n\t\t\t\t\tscaleY = element.scale.y * _canvasHeightHalf;\r\n\r\n\t\t\t\t\twidth = scaleX * bitmapWidth;\r\n\t\t\t\t\theight = scaleY * bitmapHeight;\r\n\r\n\t\t\t\t\t// TODO: Rotations break this...\r\n\r\n\t\t\t\t\t_elemBox.min.set( v1.x - width, v1.y - height );\r\n\t\t\t\t\t_elemBox.max.set( v1.x + width, v1.y + height );\r\n\r\n\t\t\t\t\tif ( _clipBox.isIntersectionBox( _elemBox ) === false ) {\r\n\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t_context.save();\r\n\t\t\t\t\t_context.translate( v1.x, v1.y );\r\n\t\t\t\t\t_context.rotate( - element.rotation );\r\n\t\t\t\t\t_context.scale( scaleX, - scaleY );\r\n\r\n\t\t\t\t\t_context.translate( - bitmapWidth, - bitmapHeight );\r\n\t\t\t\t\t_context.drawImage( bitmap, 0, 0 );\r\n\t\t\t\t\t_context.restore();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/* DEBUG\r\n\t\t\t\tsetStrokeStyle( 'rgb(255,255,0)' );\r\n\t\t\t\t_context.beginPath();\r\n\t\t\t\t_context.moveTo( v1.x - 10, v1.y );\r\n\t\t\t\t_context.lineTo( v1.x + 10, v1.y );\r\n\t\t\t\t_context.moveTo( v1.x, v1.y - 10 );\r\n\t\t\t\t_context.lineTo( v1.x, v1.y + 10 );\r\n\t\t\t\t_context.stroke();\r\n\t\t\t\t*/\r\n\r\n\t\t\t} else if ( material instanceof THREE.ParticleCanvasMaterial ) {\r\n\r\n\t\t\t\twidth = element.scale.x * _canvasWidthHalf;\r\n\t\t\t\theight = element.scale.y * _canvasHeightHalf;\r\n\r\n\t\t\t\t_elemBox.min.set( v1.x - width, v1.y - height );\r\n\t\t\t\t_elemBox.max.set( v1.x + width, v1.y + height );\r\n\r\n\t\t\t\tif ( _clipBox.isIntersectionBox( _elemBox ) === false ) {\r\n\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tsetStrokeStyle( material.color.getStyle() );\r\n\t\t\t\tsetFillStyle( material.color.getStyle() );\r\n\r\n\t\t\t\t_context.save();\r\n\t\t\t\t_context.translate( v1.x, v1.y );\r\n\t\t\t\t_context.rotate( - element.rotation );\r\n\t\t\t\t_context.scale( width, height );\r\n\r\n\t\t\t\tmaterial.program( _context );\r\n\r\n\t\t\t\t_context.restore();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction renderLine( v1, v2, element, material ) {\r\n\r\n\t\t\tsetOpacity( material.opacity );\r\n\t\t\tsetBlending( material.blending );\r\n\r\n\t\t\t_context.beginPath();\r\n\t\t\t_context.moveTo( v1.positionScreen.x, v1.positionScreen.y );\r\n\t\t\t_context.lineTo( v2.positionScreen.x, v2.positionScreen.y );\r\n\r\n\t\t\tif ( material instanceof THREE.LineBasicMaterial ) {\r\n\r\n\t\t\t\tsetLineWidth( material.linewidth );\r\n\t\t\t\tsetLineCap( material.linecap );\r\n\t\t\t\tsetLineJoin( material.linejoin );\r\n\t\t\t\tsetStrokeStyle( material.color.getStyle() );\r\n\t\t\t\tsetDashAndGap( null, null );\r\n\r\n\t\t\t\t_context.stroke();\r\n\t\t\t\t_elemBox.expandByScalar( material.linewidth * 2 );\r\n\r\n\t\t\t} else if ( material instanceof THREE.LineDashedMaterial ) {\r\n\r\n\t\t\t\tsetLineWidth( material.linewidth );\r\n\t\t\t\tsetLineCap( material.linecap );\r\n\t\t\t\tsetLineJoin( material.linejoin );\r\n\t\t\t\tsetStrokeStyle( material.color.getStyle() );\r\n\t\t\t\tsetDashAndGap( material.dashSize, material.gapSize );\r\n\r\n\t\t\t\t_context.stroke();\r\n\t\t\t\t_elemBox.expandByScalar( material.linewidth * 2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction renderFace3( v1, v2, v3, uv1, uv2, uv3, element, material ) {\r\n\r\n\t\t\t_this.info.render.vertices += 3;\r\n\t\t\t_this.info.render.faces ++;\r\n\r\n\t\t\tsetOpacity( material.opacity );\r\n\t\t\tsetBlending( material.blending );\r\n\r\n\t\t\t_v1x = v1.positionScreen.x; _v1y = v1.positionScreen.y;\r\n\t\t\t_v2x = v2.positionScreen.x; _v2y = v2.positionScreen.y;\r\n\t\t\t_v3x = v3.positionScreen.x; _v3y = v3.positionScreen.y;\r\n\r\n\t\t\tdrawTriangle( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y );\r\n\r\n\t\t\tif ( ( material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial ) && material.map === null ) {\r\n\r\n\t\t\t\t_diffuseColor.copy( material.color );\r\n\t\t\t\t_emissiveColor.copy( material.emissive );\r\n\r\n\t\t\t\tif ( material.vertexColors === THREE.FaceColors ) {\r\n\r\n\t\t\t\t\t_diffuseColor.multiply( element.color );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( _enableLighting === true ) {\r\n\r\n\t\t\t\t\tif ( material.wireframe === false && material.shading == THREE.SmoothShading && element.vertexNormalsLength == 3 ) {\r\n\r\n\t\t\t\t\t\t_color1.copy( _ambientLight );\r\n\t\t\t\t\t\t_color2.copy( _ambientLight );\r\n\t\t\t\t\t\t_color3.copy( _ambientLight );\r\n\r\n\t\t\t\t\t\tcalculateLight( element.v1.positionWorld, element.vertexNormalsModel[ 0 ], _color1 );\r\n\t\t\t\t\t\tcalculateLight( element.v2.positionWorld, element.vertexNormalsModel[ 1 ], _color2 );\r\n\t\t\t\t\t\tcalculateLight( element.v3.positionWorld, element.vertexNormalsModel[ 2 ], _color3 );\r\n\r\n\t\t\t\t\t\t_color1.multiply( _diffuseColor ).add( _emissiveColor );\r\n\t\t\t\t\t\t_color2.multiply( _diffuseColor ).add( _emissiveColor );\r\n\t\t\t\t\t\t_color3.multiply( _diffuseColor ).add( _emissiveColor );\r\n\t\t\t\t\t\t_color4.addColors( _color2, _color3 ).multiplyScalar( 0.5 );\r\n\r\n\t\t\t\t\t\t_image = getGradientTexture( _color1, _color2, _color3, _color4 );\r\n\r\n\t\t\t\t\t\tclipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t_color.copy( _ambientLight );\r\n\r\n\t\t\t\t\t\tcalculateLight( element.centroidModel, element.normalModel, _color );\r\n\r\n\t\t\t\t\t\t_color.multiply( _diffuseColor ).add( _emissiveColor );\r\n\r\n\t\t\t\t\t\tmaterial.wireframe === true\r\n\t\t\t\t\t\t\t? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\r\n\t\t\t\t\t\t\t: fillPath( _color );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tmaterial.wireframe === true\r\n\t\t\t\t\t\t? strokePath( material.color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\r\n\t\t\t\t\t\t: fillPath( material.color );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshBasicMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial ) {\r\n\r\n\t\t\t\tif ( material.map !== null ) {\r\n\r\n\t\t\t\t\tif ( material.map.mapping instanceof THREE.UVMapping ) {\r\n\r\n\t\t\t\t\t\t_uvs = element.uvs[ 0 ];\r\n\t\t\t\t\t\tpatternPath( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uvs[ uv1 ].x, _uvs[ uv1 ].y, _uvs[ uv2 ].x, _uvs[ uv2 ].y, _uvs[ uv3 ].x, _uvs[ uv3 ].y, material.map );\r\n\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t} else if ( material.envMap !== null ) {\r\n\r\n\t\t\t\t\tif ( material.envMap.mapping instanceof THREE.SphericalReflectionMapping ) {\r\n\r\n\t\t\t\t\t\t_vector3.copy( element.vertexNormalsModelView[ uv1 ] );\r\n\t\t\t\t\t\t_uv1x = 0.5 * _vector3.x + 0.5;\r\n\t\t\t\t\t\t_uv1y = 0.5 * _vector3.y + 0.5;\r\n\r\n\t\t\t\t\t\t_vector3.copy( element.vertexNormalsModelView[ uv2 ] );\r\n\t\t\t\t\t\t_uv2x = 0.5 * _vector3.x + 0.5;\r\n\t\t\t\t\t\t_uv2y = 0.5 * _vector3.y + 0.5;\r\n\r\n\t\t\t\t\t\t_vector3.copy( element.vertexNormalsModelView[ uv3 ] );\r\n\t\t\t\t\t\t_uv3x = 0.5 * _vector3.x + 0.5;\r\n\t\t\t\t\t\t_uv3y = 0.5 * _vector3.y + 0.5;\r\n\r\n\t\t\t\t\t\tpatternPath( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y, material.envMap );\r\n\r\n\t\t\t\t\t}/* else if ( material.envMap.mapping == THREE.SphericalRefractionMapping ) {\r\n\r\n\r\n\r\n\t\t\t\t\t}*/\r\n\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t_color.copy( material.color );\r\n\r\n\t\t\t\t\tif ( material.vertexColors === THREE.FaceColors ) {\r\n\r\n\t\t\t\t\t\t_color.multiply( element.color );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tmaterial.wireframe === true\r\n\t\t\t\t\t\t? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\r\n\t\t\t\t\t\t: fillPath( _color );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshDepthMaterial ) {\r\n\r\n\t\t\t\t_near = camera.near;\r\n\t\t\t\t_far = camera.far;\r\n\r\n\t\t\t\t_color1.r = _color1.g = _color1.b = 1 - smoothstep( v1.positionScreen.z * v1.positionScreen.w, _near, _far );\r\n\t\t\t\t_color2.r = _color2.g = _color2.b = 1 - smoothstep( v2.positionScreen.z * v2.positionScreen.w, _near, _far );\r\n\t\t\t\t_color3.r = _color3.g = _color3.b = 1 - smoothstep( v3.positionScreen.z * v3.positionScreen.w, _near, _far );\r\n\t\t\t\t_color4.addColors( _color2, _color3 ).multiplyScalar( 0.5 );\r\n\r\n\t\t\t\t_image = getGradientTexture( _color1, _color2, _color3, _color4 );\r\n\r\n\t\t\t\tclipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\r\n\r\n\t\t\t\tvar normal;\r\n\r\n\t\t\t\tif ( material.shading == THREE.FlatShading ) {\r\n\r\n\t\t\t\t\tnormal = element.normalModelView;\r\n\r\n\t\t\t\t\t_color.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\r\n\r\n\t\t\t\t\tmaterial.wireframe === true\r\n\t\t\t\t\t\t? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\r\n\t\t\t\t\t\t: fillPath( _color );\r\n\r\n\t\t\t\t} else if ( material.shading == THREE.SmoothShading ) {\r\n\r\n\t\t\t\t\tnormal = element.vertexNormalsModelView[ uv1 ];\r\n\t\t\t\t\t_color1.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\r\n\r\n\t\t\t\t\tnormal = element.vertexNormalsModelView[ uv2 ];\r\n\t\t\t\t\t_color2.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\r\n\r\n\t\t\t\t\tnormal = element.vertexNormalsModelView[ uv3 ];\r\n\t\t\t\t\t_color3.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\r\n\r\n\t\t\t\t\t_color4.addColors( _color2, _color3 ).multiplyScalar( 0.5 );\r\n\r\n\t\t\t\t\t_image = getGradientTexture( _color1, _color2, _color3, _color4 );\r\n\r\n\t\t\t\t\tclipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction renderFace4( v1, v2, v3, v4, v5, v6, element, material ) {\r\n\r\n\t\t\t_this.info.render.vertices += 4;\r\n\t\t\t_this.info.render.faces ++;\r\n\r\n\t\t\tsetOpacity( material.opacity );\r\n\t\t\tsetBlending( material.blending );\r\n\r\n\t\t\tif ( ( material.map !== undefined && material.map !== null ) || ( material.envMap !== undefined && material.envMap !== null ) ) {\r\n\r\n\t\t\t\t// Let renderFace3() handle this\r\n\r\n\t\t\t\trenderFace3( v1, v2, v4, 0, 1, 3, element, material );\r\n\t\t\t\trenderFace3( v5, v3, v6, 1, 2, 3, element, material );\r\n\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_v1x = v1.positionScreen.x; _v1y = v1.positionScreen.y;\r\n\t\t\t_v2x = v2.positionScreen.x; _v2y = v2.positionScreen.y;\r\n\t\t\t_v3x = v3.positionScreen.x; _v3y = v3.positionScreen.y;\r\n\t\t\t_v4x = v4.positionScreen.x; _v4y = v4.positionScreen.y;\r\n\t\t\t_v5x = v5.positionScreen.x; _v5y = v5.positionScreen.y;\r\n\t\t\t_v6x = v6.positionScreen.x; _v6y = v6.positionScreen.y;\r\n\r\n\t\t\tif ( material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial ) {\r\n\r\n\t\t\t\t_diffuseColor.copy( material.color );\r\n\t\t\t\t_emissiveColor.copy( material.emissive );\r\n\r\n\t\t\t\tif ( material.vertexColors === THREE.FaceColors ) {\r\n\r\n\t\t\t\t\t_diffuseColor.multiply( element.color );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( _enableLighting === true ) {\r\n\r\n\t\t\t\t\tif ( material.wireframe === false && material.shading == THREE.SmoothShading && element.vertexNormalsLength == 4 ) {\r\n\r\n\t\t\t\t\t\t_color1.copy( _ambientLight );\r\n\t\t\t\t\t\t_color2.copy( _ambientLight );\r\n\t\t\t\t\t\t_color3.copy( _ambientLight );\r\n\t\t\t\t\t\t_color4.copy( _ambientLight );\r\n\r\n\t\t\t\t\t\tcalculateLight( element.v1.positionWorld, element.vertexNormalsModel[ 0 ], _color1 );\r\n\t\t\t\t\t\tcalculateLight( element.v2.positionWorld, element.vertexNormalsModel[ 1 ], _color2 );\r\n\t\t\t\t\t\tcalculateLight( element.v4.positionWorld, element.vertexNormalsModel[ 3 ], _color3 );\r\n\t\t\t\t\t\tcalculateLight( element.v3.positionWorld, element.vertexNormalsModel[ 2 ], _color4 );\r\n\r\n\t\t\t\t\t\t_color1.multiply( _diffuseColor ).add( _emissiveColor );\r\n\t\t\t\t\t\t_color2.multiply( _diffuseColor ).add( _emissiveColor );\r\n\t\t\t\t\t\t_color3.multiply( _diffuseColor ).add( _emissiveColor );\r\n\t\t\t\t\t\t_color4.multiply( _diffuseColor ).add( _emissiveColor );\r\n\r\n\t\t\t\t\t\t_image = getGradientTexture( _color1, _color2, _color3, _color4 );\r\n\r\n\t\t\t\t\t\t// TODO: UVs are incorrect, v4->v3?\r\n\r\n\t\t\t\t\t\tdrawTriangle( _v1x, _v1y, _v2x, _v2y, _v4x, _v4y );\r\n\t\t\t\t\t\tclipImage( _v1x, _v1y, _v2x, _v2y, _v4x, _v4y, 0, 0, 1, 0, 0, 1, _image );\r\n\r\n\t\t\t\t\t\tdrawTriangle( _v5x, _v5y, _v3x, _v3y, _v6x, _v6y );\r\n\t\t\t\t\t\tclipImage( _v5x, _v5y, _v3x, _v3y, _v6x, _v6y, 1, 0, 1, 1, 0, 1, _image );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t_color.copy( _ambientLight );\r\n\r\n\t\t\t\t\t\tcalculateLight( element.centroidModel, element.normalModel, _color );\r\n\r\n\t\t\t\t\t\t_color.multiply( _diffuseColor ).add( _emissiveColor );\r\n\r\n\t\t\t\t\t\tdrawQuad( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _v4x, _v4y );\r\n\r\n\t\t\t\t\t\tmaterial.wireframe === true\r\n\t\t\t\t\t\t\t? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\r\n\t\t\t\t\t\t\t: fillPath( _color );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t_color.addColors( _diffuseColor, _emissiveColor );\r\n\r\n\t\t\t\t\tdrawQuad( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _v4x, _v4y );\r\n\r\n\t\t\t\t\tmaterial.wireframe === true\r\n\t\t\t\t\t\t? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\r\n\t\t\t\t\t\t: fillPath( _color );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshBasicMaterial ) {\r\n\r\n\t\t\t\t_color.copy( material.color );\r\n\r\n\t\t\t\tif ( material.vertexColors === THREE.FaceColors ) {\r\n\r\n\t\t\t\t\t_color.multiply( element.color );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdrawQuad( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _v4x, _v4y );\r\n\r\n\t\t\t\tmaterial.wireframe === true\r\n\t\t\t\t\t? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\r\n\t\t\t\t\t: fillPath( _color );\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\r\n\r\n\t\t\t\tvar normal;\r\n\r\n\t\t\t\tif ( material.shading == THREE.FlatShading ) {\r\n\r\n\t\t\t\t\tnormal = element.normalModelView;\r\n\t\t\t\t\t_color.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\r\n\r\n\t\t\t\t\tdrawQuad( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _v4x, _v4y );\r\n\r\n\t\t\t\t\tmaterial.wireframe === true\r\n\t\t\t\t\t\t? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\r\n\t\t\t\t\t\t: fillPath( _color );\r\n\r\n\t\t\t\t} else if ( material.shading == THREE.SmoothShading ) {\r\n\r\n\t\t\t\t\tnormal = element.vertexNormalsModelView[ 0 ];\r\n\t\t\t\t\t_color1.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\r\n\r\n\t\t\t\t\tnormal = element.vertexNormalsModelView[ 1 ];\r\n\t\t\t\t\t_color2.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\r\n\r\n\t\t\t\t\tnormal = element.vertexNormalsModelView[ 3 ];\r\n\t\t\t\t\t_color3.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\r\n\r\n\t\t\t\t\tnormal = element.vertexNormalsModelView[ 2 ];\r\n\t\t\t\t\t_color4.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\r\n\r\n\t\t\t\t\t_image = getGradientTexture( _color1, _color2, _color3, _color4 );\r\n\r\n\t\t\t\t\tdrawTriangle( _v1x, _v1y, _v2x, _v2y, _v4x, _v4y );\r\n\t\t\t\t\tclipImage( _v1x, _v1y, _v2x, _v2y, _v4x, _v4y, 0, 0, 1, 0, 0, 1, _image );\r\n\r\n\t\t\t\t\tdrawTriangle( _v5x, _v5y, _v3x, _v3y, _v6x, _v6y );\r\n\t\t\t\t\tclipImage( _v5x, _v5y, _v3x, _v3y, _v6x, _v6y, 1, 0, 1, 1, 0, 1, _image );\r\n\r\n\t\t\t\t}\r\n\r\n\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshDepthMaterial ) {\r\n\r\n\t\t\t\t_near = camera.near;\r\n\t\t\t\t_far = camera.far;\r\n\r\n\t\t\t\t_color1.r = _color1.g = _color1.b = 1 - smoothstep( v1.positionScreen.z * v1.positionScreen.w, _near, _far );\r\n\t\t\t\t_color2.r = _color2.g = _color2.b = 1 - smoothstep( v2.positionScreen.z * v2.positionScreen.w, _near, _far );\r\n\t\t\t\t_color3.r = _color3.g = _color3.b = 1 - smoothstep( v4.positionScreen.z * v4.positionScreen.w, _near, _far );\r\n\t\t\t\t_color4.r = _color4.g = _color4.b = 1 - smoothstep( v3.positionScreen.z * v3.positionScreen.w, _near, _far );\r\n\r\n\t\t\t\t_image = getGradientTexture( _color1, _color2, _color3, _color4 );\r\n\r\n\t\t\t\t// TODO: UVs are incorrect, v4->v3?\r\n\r\n\t\t\t\tdrawTriangle( _v1x, _v1y, _v2x, _v2y, _v4x, _v4y );\r\n\t\t\t\tclipImage( _v1x, _v1y, _v2x, _v2y, _v4x, _v4y, 0, 0, 1, 0, 0, 1, _image );\r\n\r\n\t\t\t\tdrawTriangle( _v5x, _v5y, _v3x, _v3y, _v6x, _v6y );\r\n\t\t\t\tclipImage( _v5x, _v5y, _v3x, _v3y, _v6x, _v6y, 1, 0, 1, 1, 0, 1, _image );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tfunction drawTriangle( x0, y0, x1, y1, x2, y2 ) {\r\n\r\n\t\t\t_context.beginPath();\r\n\t\t\t_context.moveTo( x0, y0 );\r\n\t\t\t_context.lineTo( x1, y1 );\r\n\t\t\t_context.lineTo( x2, y2 );\r\n\t\t\t_context.closePath();\r\n\r\n\t\t}\r\n\r\n\t\tfunction drawQuad( x0, y0, x1, y1, x2, y2, x3, y3 ) {\r\n\r\n\t\t\t_context.beginPath();\r\n\t\t\t_context.moveTo( x0, y0 );\r\n\t\t\t_context.lineTo( x1, y1 );\r\n\t\t\t_context.lineTo( x2, y2 );\r\n\t\t\t_context.lineTo( x3, y3 );\r\n\t\t\t_context.closePath();\r\n\r\n\t\t}\r\n\r\n\t\tfunction strokePath( color, linewidth, linecap, linejoin ) {\r\n\r\n\t\t\tsetLineWidth( linewidth );\r\n\t\t\tsetLineCap( linecap );\r\n\t\t\tsetLineJoin( linejoin );\r\n\t\t\tsetStrokeStyle( color.getStyle() );\r\n\r\n\t\t\t_context.stroke();\r\n\r\n\t\t\t_elemBox.expandByScalar( linewidth * 2 );\r\n\r\n\t\t}\r\n\r\n\t\tfunction fillPath( color ) {\r\n\r\n\t\t\tsetFillStyle( color.getStyle() );\r\n\t\t\t_context.fill();\r\n\r\n\t\t}\r\n\r\n\t\tfunction patternPath( x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, texture ) {\r\n\r\n\t\t\tif ( texture instanceof THREE.DataTexture || texture.image === undefined || texture.image.width == 0 ) return;\r\n\r\n\t\t\tif ( texture.needsUpdate === true ) {\r\n\r\n\t\t\t\tvar repeatX = texture.wrapS == THREE.RepeatWrapping;\r\n\t\t\t\tvar repeatY = texture.wrapT == THREE.RepeatWrapping;\r\n\r\n\t\t\t\t_patterns[ texture.id ] = _context.createPattern(\r\n\t\t\t\t\ttexture.image, repeatX === true && repeatY === true\r\n\t\t\t\t\t\t? 'repeat'\r\n\t\t\t\t\t\t: repeatX === true && repeatY === false\r\n\t\t\t\t\t\t\t? 'repeat-x'\r\n\t\t\t\t\t\t\t: repeatX === false && repeatY === true\r\n\t\t\t\t\t\t\t\t? 'repeat-y'\r\n\t\t\t\t\t\t\t\t: 'no-repeat'\r\n\t\t\t\t);\r\n\r\n\t\t\t\ttexture.needsUpdate = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_patterns[ texture.id ] === undefined\r\n\t\t\t\t? setFillStyle( 'rgba(0,0,0,1)' )\r\n\t\t\t\t: setFillStyle( _patterns[ texture.id ] );\r\n\r\n\t\t\t// http://extremelysatisfactorytotalitarianism.com/blog/?p=2120\r\n\r\n\t\t\tvar a, b, c, d, e, f, det, idet,\r\n\t\t\toffsetX = texture.offset.x / texture.repeat.x,\r\n\t\t\toffsetY = texture.offset.y / texture.repeat.y,\r\n\t\t\twidth = texture.image.width * texture.repeat.x,\r\n\t\t\theight = texture.image.height * texture.repeat.y;\r\n\r\n\t\t\tu0 = ( u0 + offsetX ) * width;\r\n\t\t\tv0 = ( 1.0 - v0 + offsetY ) * height;\r\n\r\n\t\t\tu1 = ( u1 + offsetX ) * width;\r\n\t\t\tv1 = ( 1.0 - v1 + offsetY ) * height;\r\n\r\n\t\t\tu2 = ( u2 + offsetX ) * width;\r\n\t\t\tv2 = ( 1.0 - v2 + offsetY ) * height;\r\n\r\n\t\t\tx1 -= x0; y1 -= y0;\r\n\t\t\tx2 -= x0; y2 -= y0;\r\n\r\n\t\t\tu1 -= u0; v1 -= v0;\r\n\t\t\tu2 -= u0; v2 -= v0;\r\n\r\n\t\t\tdet = u1 * v2 - u2 * v1;\r\n\r\n\t\t\tif ( det === 0 ) {\r\n\r\n\t\t\t\tif ( _imagedatas[ texture.id ] === undefined ) {\r\n\r\n\t\t\t\t\tvar canvas = document.createElement( 'canvas' )\r\n\t\t\t\t\tcanvas.width = texture.image.width;\r\n\t\t\t\t\tcanvas.height = texture.image.height;\r\n\r\n\t\t\t\t\tvar context = canvas.getContext( '2d' );\r\n\t\t\t\t\tcontext.drawImage( texture.image, 0, 0 );\r\n\r\n\t\t\t\t\t_imagedatas[ texture.id ] = context.getImageData( 0, 0, texture.image.width, texture.image.height ).data;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar data = _imagedatas[ texture.id ];\r\n\t\t\t\tvar index = ( Math.floor( u0 ) + Math.floor( v0 ) * texture.image.width ) * 4;\r\n\r\n\t\t\t\t_color.setRGB( data[ index ] / 255, data[ index + 1 ] / 255, data[ index + 2 ] / 255 );\r\n\t\t\t\tfillPath( _color );\r\n\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tidet = 1 / det;\r\n\r\n\t\t\ta = ( v2 * x1 - v1 * x2 ) * idet;\r\n\t\t\tb = ( v2 * y1 - v1 * y2 ) * idet;\r\n\t\t\tc = ( u1 * x2 - u2 * x1 ) * idet;\r\n\t\t\td = ( u1 * y2 - u2 * y1 ) * idet;\r\n\r\n\t\t\te = x0 - a * u0 - c * v0;\r\n\t\t\tf = y0 - b * u0 - d * v0;\r\n\r\n\t\t\t_context.save();\r\n\t\t\t_context.transform( a, b, c, d, e, f );\r\n\t\t\t_context.fill();\r\n\t\t\t_context.restore();\r\n\r\n\t\t}\r\n\r\n\t\tfunction clipImage( x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, image ) {\r\n\r\n\t\t\t// http://extremelysatisfactorytotalitarianism.com/blog/?p=2120\r\n\r\n\t\t\tvar a, b, c, d, e, f, det, idet,\r\n\t\t\twidth = image.width - 1,\r\n\t\t\theight = image.height - 1;\r\n\r\n\t\t\tu0 *= width; v0 *= height;\r\n\t\t\tu1 *= width; v1 *= height;\r\n\t\t\tu2 *= width; v2 *= height;\r\n\r\n\t\t\tx1 -= x0; y1 -= y0;\r\n\t\t\tx2 -= x0; y2 -= y0;\r\n\r\n\t\t\tu1 -= u0; v1 -= v0;\r\n\t\t\tu2 -= u0; v2 -= v0;\r\n\r\n\t\t\tdet = u1 * v2 - u2 * v1;\r\n\r\n\t\t\tidet = 1 / det;\r\n\r\n\t\t\ta = ( v2 * x1 - v1 * x2 ) * idet;\r\n\t\t\tb = ( v2 * y1 - v1 * y2 ) * idet;\r\n\t\t\tc = ( u1 * x2 - u2 * x1 ) * idet;\r\n\t\t\td = ( u1 * y2 - u2 * y1 ) * idet;\r\n\r\n\t\t\te = x0 - a * u0 - c * v0;\r\n\t\t\tf = y0 - b * u0 - d * v0;\r\n\r\n\t\t\t_context.save();\r\n\t\t\t_context.transform( a, b, c, d, e, f );\r\n\t\t\t_context.clip();\r\n\t\t\t_context.drawImage( image, 0, 0 );\r\n\t\t\t_context.restore();\r\n\r\n\t\t}\r\n\r\n\t\tfunction getGradientTexture( color1, color2, color3, color4 ) {\r\n\r\n\t\t\t// http://mrdoob.com/blog/post/710\r\n\r\n\t\t\t_pixelMapData[ 0 ] = ( color1.r * 255 ) | 0;\r\n\t\t\t_pixelMapData[ 1 ] = ( color1.g * 255 ) | 0;\r\n\t\t\t_pixelMapData[ 2 ] = ( color1.b * 255 ) | 0;\r\n\r\n\t\t\t_pixelMapData[ 4 ] = ( color2.r * 255 ) | 0;\r\n\t\t\t_pixelMapData[ 5 ] = ( color2.g * 255 ) | 0;\r\n\t\t\t_pixelMapData[ 6 ] = ( color2.b * 255 ) | 0;\r\n\r\n\t\t\t_pixelMapData[ 8 ] = ( color3.r * 255 ) | 0;\r\n\t\t\t_pixelMapData[ 9 ] = ( color3.g * 255 ) | 0;\r\n\t\t\t_pixelMapData[ 10 ] = ( color3.b * 255 ) | 0;\r\n\r\n\t\t\t_pixelMapData[ 12 ] = ( color4.r * 255 ) | 0;\r\n\t\t\t_pixelMapData[ 13 ] = ( color4.g * 255 ) | 0;\r\n\t\t\t_pixelMapData[ 14 ] = ( color4.b * 255 ) | 0;\r\n\r\n\t\t\t_pixelMapContext.putImageData( _pixelMapImage, 0, 0 );\r\n\t\t\t_gradientMapContext.drawImage( _pixelMap, 0, 0 );\r\n\r\n\t\t\treturn _gradientMap;\r\n\r\n\t\t}\r\n\r\n\t\t// Hide anti-alias gaps\r\n\r\n\t\tfunction expand( v1, v2 ) {\r\n\r\n\t\t\tvar x = v2.x - v1.x, y =  v2.y - v1.y,\r\n\t\t\tdet = x * x + y * y, idet;\r\n\r\n\t\t\tif ( det === 0 ) return;\r\n\r\n\t\t\tidet = 1 / Math.sqrt( det );\r\n\r\n\t\t\tx *= idet; y *= idet;\r\n\r\n\t\t\tv2.x += x; v2.y += y;\r\n\t\t\tv1.x -= x; v1.y -= y;\r\n\r\n\t\t}\r\n\t};\r\n\r\n\t// Context cached methods.\r\n\r\n\tfunction setOpacity( value ) {\r\n\r\n\t\tif ( _contextGlobalAlpha !== value ) {\r\n\r\n\t\t\t_context.globalAlpha = value;\r\n\t\t\t_contextGlobalAlpha = value;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setBlending( value ) {\r\n\r\n\t\tif ( _contextGlobalCompositeOperation !== value ) {\r\n\r\n\t\t\tif ( value === THREE.NormalBlending ) {\r\n\r\n\t\t\t\t_context.globalCompositeOperation = 'source-over';\r\n\r\n\t\t\t} else if ( value === THREE.AdditiveBlending ) {\r\n\r\n\t\t\t\t_context.globalCompositeOperation = 'lighter';\r\n\r\n\t\t\t} else if ( value === THREE.SubtractiveBlending ) {\r\n\r\n\t\t\t\t_context.globalCompositeOperation = 'darker';\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_contextGlobalCompositeOperation = value;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setLineWidth( value ) {\r\n\r\n\t\tif ( _contextLineWidth !== value ) {\r\n\r\n\t\t\t_context.lineWidth = value;\r\n\t\t\t_contextLineWidth = value;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setLineCap( value ) {\r\n\r\n\t\t// \"butt\", \"round\", \"square\"\r\n\r\n\t\tif ( _contextLineCap !== value ) {\r\n\r\n\t\t\t_context.lineCap = value;\r\n\t\t\t_contextLineCap = value;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setLineJoin( value ) {\r\n\r\n\t\t// \"round\", \"bevel\", \"miter\"\r\n\r\n\t\tif ( _contextLineJoin !== value ) {\r\n\r\n\t\t\t_context.lineJoin = value;\r\n\t\t\t_contextLineJoin = value;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setStrokeStyle( value ) {\r\n\r\n\t\tif ( _contextStrokeStyle !== value ) {\r\n\r\n\t\t\t_context.strokeStyle = value;\r\n\t\t\t_contextStrokeStyle = value;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setFillStyle( value ) {\r\n\r\n\t\tif ( _contextFillStyle !== value ) {\r\n\r\n\t\t\t_context.fillStyle = value;\r\n\t\t\t_contextFillStyle = value;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setDashAndGap( dashSizeValue, gapSizeValue ) {\r\n\r\n\t\tif ( _contextDashSize !== dashSizeValue || _contextGapSize !== gapSizeValue ) {\r\n\r\n\t\t\t_context.setLineDash( [ dashSizeValue, gapSizeValue ] );\r\n\t\t\t_contextDashSize = dashSizeValue;\r\n\t\t\t_contextGapSize = gapSizeValue;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n */\r\n\r\nTHREE.ShaderChunk = {\r\n\r\n\t// FOG\r\n\r\n\tfog_pars_fragment: [\r\n\r\n\t\t\"#ifdef USE_FOG\",\r\n\r\n\t\t\t\"uniform vec3 fogColor;\",\r\n\r\n\t\t\t\"#ifdef FOG_EXP2\",\r\n\r\n\t\t\t\t\"uniform float fogDensity;\",\r\n\r\n\t\t\t\"#else\",\r\n\r\n\t\t\t\t\"uniform float fogNear;\",\r\n\t\t\t\t\"uniform float fogFar;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tfog_fragment: [\r\n\r\n\t\t\"#ifdef USE_FOG\",\r\n\r\n\t\t\t\"float depth = gl_FragCoord.z / gl_FragCoord.w;\",\r\n\r\n\t\t\t\"#ifdef FOG_EXP2\",\r\n\r\n\t\t\t\t\"const float LOG2 = 1.442695;\",\r\n\t\t\t\t\"float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\",\r\n\t\t\t\t\"fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\",\r\n\r\n\t\t\t\"#else\",\r\n\r\n\t\t\t\t\"float fogFactor = smoothstep( fogNear, fogFar, depth );\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// ENVIRONMENT MAP\r\n\r\n\tenvmap_pars_fragment: [\r\n\r\n\t\t\"#ifdef USE_ENVMAP\",\r\n\r\n\t\t\t\"uniform float reflectivity;\",\r\n\t\t\t\"uniform samplerCube envMap;\",\r\n\t\t\t\"uniform float flipEnvMap;\",\r\n\t\t\t\"uniform int combine;\",\r\n\r\n\t\t\t\"#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\",\r\n\r\n\t\t\t\t\"uniform bool useRefract;\",\r\n\t\t\t\t\"uniform float refractionRatio;\",\r\n\r\n\t\t\t\"#else\",\r\n\r\n\t\t\t\t\"varying vec3 vReflect;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tenvmap_fragment: [\r\n\r\n\t\t\"#ifdef USE_ENVMAP\",\r\n\r\n\t\t\t\"vec3 reflectVec;\",\r\n\r\n\t\t\t\"#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\",\r\n\r\n\t\t\t\t\"vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\",\r\n\r\n\t\t\t\t\"if ( useRefract ) {\",\r\n\r\n\t\t\t\t\t\"reflectVec = refract( cameraToVertex, normal, refractionRatio );\",\r\n\r\n\t\t\t\t\"} else { \",\r\n\r\n\t\t\t\t\t\"reflectVec = reflect( cameraToVertex, normal );\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\"#else\",\r\n\r\n\t\t\t\t\"reflectVec = vReflect;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\"float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\",\r\n\t\t\t\t\"vec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\",\r\n\r\n\t\t\t\"#else\",\r\n\r\n\t\t\t\t\"vec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#ifdef GAMMA_INPUT\",\r\n\r\n\t\t\t\t\"cubeColor.xyz *= cubeColor.xyz;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"if ( combine == 1 ) {\",\r\n\r\n\t\t\t\t\"gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );\",\r\n\r\n\t\t\t\"} else if ( combine == 2 ) {\",\r\n\r\n\t\t\t\t\"gl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;\",\r\n\r\n\t\t\t\"} else {\",\r\n\r\n\t\t\t\t\"gl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tenvmap_pars_vertex: [\r\n\r\n\t\t\"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\",\r\n\r\n\t\t\t\"varying vec3 vReflect;\",\r\n\r\n\t\t\t\"uniform float refractionRatio;\",\r\n\t\t\t\"uniform bool useRefract;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tworldpos_vertex : [\r\n\r\n\t\t\"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\",\r\n\r\n\t\t\t\"#ifdef USE_SKINNING\",\r\n\r\n\t\t\t\t\"vec4 worldPosition = modelMatrix * skinned;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\",\r\n\r\n\t\t\t\t\"vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\",\r\n\r\n\t\t\t\t\"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tenvmap_vertex : [\r\n\r\n\t\t\"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\",\r\n\r\n\t\t\t\"vec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;\",\r\n\t\t\t\"worldNormal = normalize( worldNormal );\",\r\n\r\n\t\t\t\"vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\",\r\n\r\n\t\t\t\"if ( useRefract ) {\",\r\n\r\n\t\t\t\t\"vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\",\r\n\r\n\t\t\t\"} else {\",\r\n\r\n\t\t\t\t\"vReflect = reflect( cameraToVertex, worldNormal );\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// COLOR MAP (particles)\r\n\r\n\tmap_particle_pars_fragment: [\r\n\r\n\t\t\"#ifdef USE_MAP\",\r\n\r\n\t\t\t\"uniform sampler2D map;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\r\n\tmap_particle_fragment: [\r\n\r\n\t\t\"#ifdef USE_MAP\",\r\n\r\n\t\t\t\"gl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// COLOR MAP (triangles)\r\n\r\n\tmap_pars_vertex: [\r\n\r\n\t\t\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\",\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\t\t\t\"uniform vec4 offsetRepeat;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tmap_pars_fragment: [\r\n\r\n\t\t\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\",\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#ifdef USE_MAP\",\r\n\r\n\t\t\t\"uniform sampler2D map;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tmap_vertex: [\r\n\r\n\t\t\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\",\r\n\r\n\t\t\t\"vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tmap_fragment: [\r\n\r\n\t\t\"#ifdef USE_MAP\",\r\n\r\n\t\t\t\"vec4 texelColor = texture2D( map, vUv );\",\r\n\r\n\t\t\t\"#ifdef GAMMA_INPUT\",\r\n\r\n\t\t\t\t\"texelColor.xyz *= texelColor.xyz;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"gl_FragColor = gl_FragColor * texelColor;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// LIGHT MAP\r\n\r\n\tlightmap_pars_fragment: [\r\n\r\n\t\t\"#ifdef USE_LIGHTMAP\",\r\n\r\n\t\t\t\"varying vec2 vUv2;\",\r\n\t\t\t\"uniform sampler2D lightMap;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tlightmap_pars_vertex: [\r\n\r\n\t\t\"#ifdef USE_LIGHTMAP\",\r\n\r\n\t\t\t\"varying vec2 vUv2;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tlightmap_fragment: [\r\n\r\n\t\t\"#ifdef USE_LIGHTMAP\",\r\n\r\n\t\t\t\"gl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tlightmap_vertex: [\r\n\r\n\t\t\"#ifdef USE_LIGHTMAP\",\r\n\r\n\t\t\t\"vUv2 = uv2;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// BUMP MAP\r\n\r\n\tbumpmap_pars_fragment: [\r\n\r\n\t\t\"#ifdef USE_BUMPMAP\",\r\n\r\n\t\t\t\"uniform sampler2D bumpMap;\",\r\n\t\t\t\"uniform float bumpScale;\",\r\n\r\n\t\t\t// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\r\n\t\t\t//\thttp://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\r\n\r\n\t\t\t// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\r\n\r\n\t\t\t\"vec2 dHdxy_fwd() {\",\r\n\r\n\t\t\t\t\"vec2 dSTdx = dFdx( vUv );\",\r\n\t\t\t\t\"vec2 dSTdy = dFdy( vUv );\",\r\n\r\n\t\t\t\t\"float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\",\r\n\t\t\t\t\"float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\",\r\n\t\t\t\t\"float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\",\r\n\r\n\t\t\t\t\"return vec2( dBx, dBy );\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\",\r\n\r\n\t\t\t\t\"vec3 vSigmaX = dFdx( surf_pos );\",\r\n\t\t\t\t\"vec3 vSigmaY = dFdy( surf_pos );\",\r\n\t\t\t\t\"vec3 vN = surf_norm;\",\t\t// normalized\r\n\r\n\t\t\t\t\"vec3 R1 = cross( vSigmaY, vN );\",\r\n\t\t\t\t\"vec3 R2 = cross( vN, vSigmaX );\",\r\n\r\n\t\t\t\t\"float fDet = dot( vSigmaX, R1 );\",\r\n\r\n\t\t\t\t\"vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\",\r\n\t\t\t\t\"return normalize( abs( fDet ) * surf_norm - vGrad );\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// NORMAL MAP\r\n\r\n\tnormalmap_pars_fragment: [\r\n\r\n\t\t\"#ifdef USE_NORMALMAP\",\r\n\r\n\t\t\t\"uniform sampler2D normalMap;\",\r\n\t\t\t\"uniform vec2 normalScale;\",\r\n\r\n\t\t\t// Per-Pixel Tangent Space Normal Mapping\r\n\t\t\t// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\r\n\r\n\t\t\t\"vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\",\r\n\r\n\t\t\t\t\"vec3 q0 = dFdx( eye_pos.xyz );\",\r\n\t\t\t\t\"vec3 q1 = dFdy( eye_pos.xyz );\",\r\n\t\t\t\t\"vec2 st0 = dFdx( vUv.st );\",\r\n\t\t\t\t\"vec2 st1 = dFdy( vUv.st );\",\r\n\r\n\t\t\t\t\"vec3 S = normalize(  q0 * st1.t - q1 * st0.t );\",\r\n\t\t\t\t\"vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\",\r\n\t\t\t\t\"vec3 N = normalize( surf_norm );\",\r\n\r\n\t\t\t\t\"vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\",\r\n\t\t\t\t\"mapN.xy = normalScale * mapN.xy;\",\r\n\t\t\t\t\"mat3 tsn = mat3( S, T, N );\",\r\n\t\t\t\t\"return normalize( tsn * mapN );\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// SPECULAR MAP\r\n\r\n\tspecularmap_pars_fragment: [\r\n\r\n\t\t\"#ifdef USE_SPECULARMAP\",\r\n\r\n\t\t\t\"uniform sampler2D specularMap;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tspecularmap_fragment: [\r\n\r\n\t\t\"float specularStrength;\",\r\n\r\n\t\t\"#ifdef USE_SPECULARMAP\",\r\n\r\n\t\t\t\"vec4 texelSpecular = texture2D( specularMap, vUv );\",\r\n\t\t\t\"specularStrength = texelSpecular.r;\",\r\n\r\n\t\t\"#else\",\r\n\r\n\t\t\t\"specularStrength = 1.0;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// LIGHTS LAMBERT\r\n\r\n\tlights_lambert_pars_vertex: [\r\n\r\n\t\t\"uniform vec3 ambient;\",\r\n\t\t\"uniform vec3 diffuse;\",\r\n\t\t\"uniform vec3 emissive;\",\r\n\r\n\t\t\"uniform vec3 ambientLightColor;\",\r\n\r\n\t\t\"#if MAX_DIR_LIGHTS > 0\",\r\n\r\n\t\t\t\"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_HEMI_LIGHTS > 0\",\r\n\r\n\t\t\t\"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\r\n\r\n\t\t\t\"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\",\r\n\t\t\t\"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\r\n\r\n\t\t\t\"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\"uniform vec3 wrapRGB;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tlights_lambert_vertex: [\r\n\r\n\t\t\"vLightFront = vec3( 0.0 );\",\r\n\r\n\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\"vLightBack = vec3( 0.0 );\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"transformedNormal = normalize( transformedNormal );\",\r\n\r\n\t\t\"#if MAX_DIR_LIGHTS > 0\",\r\n\r\n\t\t\"for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\",\r\n\t\t\t\"vec3 dirVector = normalize( lDirection.xyz );\",\r\n\r\n\t\t\t\"float dotProduct = dot( transformedNormal, dirVector );\",\r\n\t\t\t\"vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\",\r\n\r\n\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\"vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\",\r\n\r\n\t\t\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\t\t\"vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\t\"vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\",\r\n\t\t\t\t\"directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\",\r\n\r\n\t\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\t\"directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"vLightFront += directionalLightColor[ i ] * directionalLightWeighting;\",\r\n\r\n\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\"vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\"}\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\r\n\r\n\t\t\t\"for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\",\r\n\t\t\t\t\"vec3 lVector = lPosition.xyz - mvPosition.xyz;\",\r\n\r\n\t\t\t\t\"float lDistance = 1.0;\",\r\n\t\t\t\t\"if ( pointLightDistance[ i ] > 0.0 )\",\r\n\t\t\t\t\t\"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\",\r\n\r\n\t\t\t\t\"lVector = normalize( lVector );\",\r\n\t\t\t\t\"float dotProduct = dot( transformedNormal, lVector );\",\r\n\r\n\t\t\t\t\"vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\",\r\n\r\n\t\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\t\"vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\",\r\n\r\n\t\t\t\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\t\t\t\"vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\t\t\"vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\",\r\n\t\t\t\t\t\"pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\",\r\n\r\n\t\t\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\t\t\"pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;\",\r\n\r\n\t\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\t\"vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\r\n\r\n\t\t\t\"for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\",\r\n\t\t\t\t\"vec3 lVector = lPosition.xyz - mvPosition.xyz;\",\r\n\r\n\t\t\t\t\"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\",\r\n\r\n\t\t\t\t\"if ( spotEffect > spotLightAngleCos[ i ] ) {\",\r\n\r\n\t\t\t\t\t\"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\",\r\n\r\n\t\t\t\t\t\"float lDistance = 1.0;\",\r\n\t\t\t\t\t\"if ( spotLightDistance[ i ] > 0.0 )\",\r\n\t\t\t\t\t\t\"lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\",\r\n\r\n\t\t\t\t\t\"lVector = normalize( lVector );\",\r\n\r\n\t\t\t\t\t\"float dotProduct = dot( transformedNormal, lVector );\",\r\n\t\t\t\t\t\"vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\",\r\n\r\n\t\t\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\t\t\"vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\",\r\n\r\n\t\t\t\t\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\t\t\t\t\"vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\",\r\n\r\n\t\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\t\t\t\"vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\",\r\n\t\t\t\t\t\t\"spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\",\r\n\r\n\t\t\t\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\t\t\t\"spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\",\r\n\r\n\t\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\t\"vLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;\",\r\n\r\n\t\t\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\t\t\"vLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_HEMI_LIGHTS > 0\",\r\n\r\n\t\t\t\"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\",\r\n\t\t\t\t\"vec3 lVector = normalize( lDirection.xyz );\",\r\n\r\n\t\t\t\t\"float dotProduct = dot( transformedNormal, lVector );\",\r\n\r\n\t\t\t\t\"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\",\r\n\t\t\t\t\"float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\",\r\n\r\n\t\t\t\t\"vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\",\r\n\r\n\t\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\t\"vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"vLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;\",\r\n\r\n\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\"vLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// LIGHTS PHONG\r\n\r\n\tlights_phong_pars_vertex: [\r\n\r\n\t\t\"#ifndef PHONG_PER_PIXEL\",\r\n\r\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\r\n\r\n\t\t\t\"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\",\r\n\t\t\t\"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\",\r\n\r\n\t\t\t\"varying vec4 vPointLight[ MAX_POINT_LIGHTS ];\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\r\n\r\n\t\t\t\"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\",\r\n\r\n\t\t\t\"varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\",\r\n\r\n\t\t\t\"varying vec3 vWorldPosition;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\r\n\tlights_phong_vertex: [\r\n\r\n\t\t\"#ifndef PHONG_PER_PIXEL\",\r\n\r\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\r\n\r\n\t\t\t\"for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\",\r\n\t\t\t\t\"vec3 lVector = lPosition.xyz - mvPosition.xyz;\",\r\n\r\n\t\t\t\t\"float lDistance = 1.0;\",\r\n\t\t\t\t\"if ( pointLightDistance[ i ] > 0.0 )\",\r\n\t\t\t\t\t\"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\",\r\n\r\n\t\t\t\t\"vPointLight[ i ] = vec4( lVector, lDistance );\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\r\n\r\n\t\t\t\"for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\",\r\n\t\t\t\t\"vec3 lVector = lPosition.xyz - mvPosition.xyz;\",\r\n\r\n\t\t\t\t\"float lDistance = 1.0;\",\r\n\t\t\t\t\"if ( spotLightDistance[ i ] > 0.0 )\",\r\n\t\t\t\t\t\"lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\",\r\n\r\n\t\t\t\t\"vSpotLight[ i ] = vec4( lVector, lDistance );\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\",\r\n\r\n\t\t\t\"vWorldPosition = worldPosition.xyz;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tlights_phong_pars_fragment: [\r\n\r\n\t\t\"uniform vec3 ambientLightColor;\",\r\n\r\n\t\t\"#if MAX_DIR_LIGHTS > 0\",\r\n\r\n\t\t\t\"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_HEMI_LIGHTS > 0\",\r\n\r\n\t\t\t\"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\r\n\r\n\t\t\t\"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\",\r\n\r\n\t\t\t\"#ifdef PHONG_PER_PIXEL\",\r\n\r\n\t\t\t\t\"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\",\r\n\t\t\t\t\"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\",\r\n\r\n\t\t\t\"#else\",\r\n\r\n\t\t\t\t\"varying vec4 vPointLight[ MAX_POINT_LIGHTS ];\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\r\n\r\n\t\t\t\"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\",\r\n\r\n\t\t\t\"#ifdef PHONG_PER_PIXEL\",\r\n\r\n\t\t\t\t\"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\",\r\n\r\n\t\t\t\"#else\",\r\n\r\n\t\t\t\t\"varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\",\r\n\r\n\t\t\t\"varying vec3 vWorldPosition;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\"uniform vec3 wrapRGB;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"varying vec3 vViewPosition;\",\r\n\t\t\"varying vec3 vNormal;\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tlights_phong_fragment: [\r\n\r\n\t\t\"vec3 normal = normalize( vNormal );\",\r\n\t\t\"vec3 viewPosition = normalize( vViewPosition );\",\r\n\r\n\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\"normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#ifdef USE_NORMALMAP\",\r\n\r\n\t\t\t\"normal = perturbNormal2Arb( -viewPosition, normal );\",\r\n\r\n\t\t\"#elif defined( USE_BUMPMAP )\",\r\n\r\n\t\t\t\"normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\r\n\r\n\t\t\t\"vec3 pointDiffuse  = vec3( 0.0 );\",\r\n\t\t\t\"vec3 pointSpecular = vec3( 0.0 );\",\r\n\r\n\t\t\t\"for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\"#ifdef PHONG_PER_PIXEL\",\r\n\r\n\t\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\",\r\n\t\t\t\t\t\"vec3 lVector = lPosition.xyz + vViewPosition.xyz;\",\r\n\r\n\t\t\t\t\t\"float lDistance = 1.0;\",\r\n\t\t\t\t\t\"if ( pointLightDistance[ i ] > 0.0 )\",\r\n\t\t\t\t\t\t\"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\",\r\n\r\n\t\t\t\t\t\"lVector = normalize( lVector );\",\r\n\r\n\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\"vec3 lVector = normalize( vPointLight[ i ].xyz );\",\r\n\t\t\t\t\t\"float lDistance = vPointLight[ i ].w;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t// diffuse\r\n\r\n\t\t\t\t\"float dotProduct = dot( normal, lVector );\",\r\n\r\n\t\t\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\t\t\"float pointDiffuseWeightFull = max( dotProduct, 0.0 );\",\r\n\t\t\t\t\t\"float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\",\r\n\r\n\t\t\t\t\t\"vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\",\r\n\r\n\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\"float pointDiffuseWeight = max( dotProduct, 0.0 );\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"pointDiffuse  += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\",\r\n\r\n\t\t\t\t// specular\r\n\r\n\t\t\t\t\"vec3 pointHalfVector = normalize( lVector + viewPosition );\",\r\n\t\t\t\t\"float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\",\r\n\t\t\t\t\"float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\",\r\n\r\n\t\t\t\t\"#ifdef PHYSICALLY_BASED_SHADING\",\r\n\r\n\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\r\n\r\n\t\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\r\n\r\n\t\t\t\t\t\"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, pointHalfVector ), 5.0 );\",\r\n\t\t\t\t\t\"pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\",\r\n\r\n\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\"pointSpecular += specular * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\r\n\r\n\t\t\t\"vec3 spotDiffuse  = vec3( 0.0 );\",\r\n\t\t\t\"vec3 spotSpecular = vec3( 0.0 );\",\r\n\r\n\t\t\t\"for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\"#ifdef PHONG_PER_PIXEL\",\r\n\r\n\t\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\",\r\n\t\t\t\t\t\"vec3 lVector = lPosition.xyz + vViewPosition.xyz;\",\r\n\r\n\t\t\t\t\t\"float lDistance = 1.0;\",\r\n\t\t\t\t\t\"if ( spotLightDistance[ i ] > 0.0 )\",\r\n\t\t\t\t\t\t\"lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\",\r\n\r\n\t\t\t\t\t\"lVector = normalize( lVector );\",\r\n\r\n\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\"vec3 lVector = normalize( vSpotLight[ i ].xyz );\",\r\n\t\t\t\t\t\"float lDistance = vSpotLight[ i ].w;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\",\r\n\r\n\t\t\t\t\"if ( spotEffect > spotLightAngleCos[ i ] ) {\",\r\n\r\n\t\t\t\t\t\"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\",\r\n\r\n\t\t\t\t\t// diffuse\r\n\r\n\t\t\t\t\t\"float dotProduct = dot( normal, lVector );\",\r\n\r\n\t\t\t\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\t\t\t\"float spotDiffuseWeightFull = max( dotProduct, 0.0 );\",\r\n\t\t\t\t\t\t\"float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\",\r\n\r\n\t\t\t\t\t\t\"vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\",\r\n\r\n\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\"float spotDiffuseWeight = max( dotProduct, 0.0 );\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\t\"spotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;\",\r\n\r\n\t\t\t\t\t// specular\r\n\r\n\t\t\t\t\t\"vec3 spotHalfVector = normalize( lVector + viewPosition );\",\r\n\t\t\t\t\t\"float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\",\r\n\t\t\t\t\t\"float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\",\r\n\r\n\t\t\t\t\t\"#ifdef PHYSICALLY_BASED_SHADING\",\r\n\r\n\t\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\r\n\r\n\t\t\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\r\n\r\n\t\t\t\t\t\t\"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, spotHalfVector ), 5.0 );\",\r\n\t\t\t\t\t\t\"spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;\",\r\n\r\n\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\"spotSpecular += specular * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * spotEffect;\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_DIR_LIGHTS > 0\",\r\n\r\n\t\t\t\"vec3 dirDiffuse  = vec3( 0.0 );\",\r\n\t\t\t\"vec3 dirSpecular = vec3( 0.0 );\" ,\r\n\r\n\t\t\t\"for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\",\r\n\t\t\t\t\"vec3 dirVector = normalize( lDirection.xyz );\",\r\n\r\n\t\t\t\t// diffuse\r\n\r\n\t\t\t\t\"float dotProduct = dot( normal, dirVector );\",\r\n\r\n\t\t\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\t\t\"float dirDiffuseWeightFull = max( dotProduct, 0.0 );\",\r\n\t\t\t\t\t\"float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\",\r\n\r\n\t\t\t\t\t\"vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\",\r\n\r\n\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\"float dirDiffuseWeight = max( dotProduct, 0.0 );\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"dirDiffuse  += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\",\r\n\r\n\t\t\t\t// specular\r\n\r\n\t\t\t\t\"vec3 dirHalfVector = normalize( dirVector + viewPosition );\",\r\n\t\t\t\t\"float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\",\r\n\t\t\t\t\"float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\",\r\n\r\n\t\t\t\t\"#ifdef PHYSICALLY_BASED_SHADING\",\r\n\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t// fresnel term from skin shader\r\n\t\t\t\t\t\"const float F0 = 0.128;\",\r\n\r\n\t\t\t\t\t\"float base = 1.0 - dot( viewPosition, dirHalfVector );\",\r\n\t\t\t\t\t\"float exponential = pow( base, 5.0 );\",\r\n\r\n\t\t\t\t\t\"float fresnel = exponential + F0 * ( 1.0 - exponential );\",\r\n\t\t\t\t\t*/\r\n\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t// fresnel term from fresnel shader\r\n\t\t\t\t\t\"const float mFresnelBias = 0.08;\",\r\n\t\t\t\t\t\"const float mFresnelScale = 0.3;\",\r\n\t\t\t\t\t\"const float mFresnelPower = 5.0;\",\r\n\r\n\t\t\t\t\t\"float fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\",\r\n\t\t\t\t\t*/\r\n\r\n\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\r\n\r\n\t\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\r\n\r\n\t\t\t\t\t//\"dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\",\r\n\r\n\t\t\t\t\t\"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );\",\r\n\t\t\t\t\t\"dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\",\r\n\r\n\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\"dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_HEMI_LIGHTS > 0\",\r\n\r\n\t\t\t\"vec3 hemiDiffuse  = vec3( 0.0 );\",\r\n\t\t\t\"vec3 hemiSpecular = vec3( 0.0 );\" ,\r\n\r\n\t\t\t\"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\",\r\n\t\t\t\t\"vec3 lVector = normalize( lDirection.xyz );\",\r\n\r\n\t\t\t\t// diffuse\r\n\r\n\t\t\t\t\"float dotProduct = dot( normal, lVector );\",\r\n\t\t\t\t\"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\",\r\n\r\n\t\t\t\t\"vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\",\r\n\r\n\t\t\t\t\"hemiDiffuse += diffuse * hemiColor;\",\r\n\r\n\t\t\t\t// specular (sky light)\r\n\r\n\t\t\t\t\"vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\",\r\n\t\t\t\t\"float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\",\r\n\t\t\t\t\"float hemiSpecularWeightSky = specularStrength * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );\",\r\n\r\n\t\t\t\t// specular (ground light)\r\n\r\n\t\t\t\t\"vec3 lVectorGround = -lVector;\",\r\n\r\n\t\t\t\t\"vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\",\r\n\t\t\t\t\"float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\",\r\n\t\t\t\t\"float hemiSpecularWeightGround = specularStrength * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );\",\r\n\r\n\t\t\t\t\"#ifdef PHYSICALLY_BASED_SHADING\",\r\n\r\n\t\t\t\t\t\"float dotProductGround = dot( normal, lVectorGround );\",\r\n\r\n\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\r\n\r\n\t\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\r\n\r\n\t\t\t\t\t\"vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );\",\r\n\t\t\t\t\t\"vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );\",\r\n\t\t\t\t\t\"hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\",\r\n\r\n\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\"hemiSpecular += specular * hemiColor * ( hemiSpecularWeightSky + hemiSpecularWeightGround ) * hemiDiffuseWeight;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"vec3 totalDiffuse = vec3( 0.0 );\",\r\n\t\t\"vec3 totalSpecular = vec3( 0.0 );\",\r\n\r\n\t\t\"#if MAX_DIR_LIGHTS > 0\",\r\n\r\n\t\t\t\"totalDiffuse += dirDiffuse;\",\r\n\t\t\t\"totalSpecular += dirSpecular;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_HEMI_LIGHTS > 0\",\r\n\r\n\t\t\t\"totalDiffuse += hemiDiffuse;\",\r\n\t\t\t\"totalSpecular += hemiSpecular;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\r\n\r\n\t\t\t\"totalDiffuse += pointDiffuse;\",\r\n\t\t\t\"totalSpecular += pointSpecular;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\r\n\r\n\t\t\t\"totalDiffuse += spotDiffuse;\",\r\n\t\t\t\"totalSpecular += spotSpecular;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#ifdef METAL\",\r\n\r\n\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );\",\r\n\r\n\t\t\"#else\",\r\n\r\n\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// VERTEX COLORS\r\n\r\n\tcolor_pars_fragment: [\r\n\r\n\t\t\"#ifdef USE_COLOR\",\r\n\r\n\t\t\t\"varying vec3 vColor;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\r\n\tcolor_fragment: [\r\n\r\n\t\t\"#ifdef USE_COLOR\",\r\n\r\n\t\t\t\"gl_FragColor = gl_FragColor * vec4( vColor, opacity );\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tcolor_pars_vertex: [\r\n\r\n\t\t\"#ifdef USE_COLOR\",\r\n\r\n\t\t\t\"varying vec3 vColor;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\r\n\tcolor_vertex: [\r\n\r\n\t\t\"#ifdef USE_COLOR\",\r\n\r\n\t\t\t\"#ifdef GAMMA_INPUT\",\r\n\r\n\t\t\t\t\"vColor = color * color;\",\r\n\r\n\t\t\t\"#else\",\r\n\r\n\t\t\t\t\"vColor = color;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// SKINNING\r\n\r\n\tskinning_pars_vertex: [\r\n\r\n\t\t\"#ifdef USE_SKINNING\",\r\n\r\n\t\t\t\"#ifdef BONE_TEXTURE\",\r\n\r\n\t\t\t\t\"uniform sampler2D boneTexture;\",\r\n\r\n\t\t\t\t\"mat4 getBoneMatrix( const in float i ) {\",\r\n\r\n\t\t\t\t\t\"float j = i * 4.0;\",\r\n\t\t\t\t\t\"float x = mod( j, N_BONE_PIXEL_X );\",\r\n\t\t\t\t\t\"float y = floor( j / N_BONE_PIXEL_X );\",\r\n\r\n\t\t\t\t\t\"const float dx = 1.0 / N_BONE_PIXEL_X;\",\r\n\t\t\t\t\t\"const float dy = 1.0 / N_BONE_PIXEL_Y;\",\r\n\r\n\t\t\t\t\t\"y = dy * ( y + 0.5 );\",\r\n\r\n\t\t\t\t\t\"vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\",\r\n\t\t\t\t\t\"vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\",\r\n\t\t\t\t\t\"vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\",\r\n\t\t\t\t\t\"vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\",\r\n\r\n\t\t\t\t\t\"mat4 bone = mat4( v1, v2, v3, v4 );\",\r\n\r\n\t\t\t\t\t\"return bone;\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\"#else\",\r\n\r\n\t\t\t\t\"uniform mat4 boneGlobalMatrices[ MAX_BONES ];\",\r\n\r\n\t\t\t\t\"mat4 getBoneMatrix( const in float i ) {\",\r\n\r\n\t\t\t\t\t\"mat4 bone = boneGlobalMatrices[ int(i) ];\",\r\n\t\t\t\t\t\"return bone;\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tskinbase_vertex: [\r\n\r\n\t\t\"#ifdef USE_SKINNING\",\r\n\r\n\t\t\t\"mat4 boneMatX = getBoneMatrix( skinIndex.x );\",\r\n\t\t\t\"mat4 boneMatY = getBoneMatrix( skinIndex.y );\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tskinning_vertex: [\r\n\r\n\t\t\"#ifdef USE_SKINNING\",\r\n\r\n\t\t\t\"#ifdef USE_MORPHTARGETS\",\r\n\r\n\t\t\t\"vec4 skinVertex = vec4( morphed, 1.0 );\",\r\n\r\n\t\t\t\"#else\",\r\n\r\n\t\t\t\"vec4 skinVertex = vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;\",\r\n\t\t\t\"skinned \t  += boneMatY * skinVertex * skinWeight.y;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// MORPHING\r\n\r\n\tmorphtarget_pars_vertex: [\r\n\r\n\t\t\"#ifdef USE_MORPHTARGETS\",\r\n\r\n\t\t\t\"#ifndef USE_MORPHNORMALS\",\r\n\r\n\t\t\t\"uniform float morphTargetInfluences[ 8 ];\",\r\n\r\n\t\t\t\"#else\",\r\n\r\n\t\t\t\"uniform float morphTargetInfluences[ 4 ];\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tmorphtarget_vertex: [\r\n\r\n\t\t\"#ifdef USE_MORPHTARGETS\",\r\n\r\n\t\t\t\"vec3 morphed = vec3( 0.0 );\",\r\n\t\t\t\"morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\",\r\n\t\t\t\"morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\",\r\n\t\t\t\"morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\",\r\n\t\t\t\"morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\",\r\n\r\n\t\t\t\"#ifndef USE_MORPHNORMALS\",\r\n\r\n\t\t\t\"morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\",\r\n\t\t\t\"morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\",\r\n\t\t\t\"morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\",\r\n\t\t\t\"morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"morphed += position;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tdefault_vertex : [\r\n\r\n\t\t\"vec4 mvPosition;\",\r\n\r\n\t\t\"#ifdef USE_SKINNING\",\r\n\r\n\t\t\t\"mvPosition = modelViewMatrix * skinned;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )\",\r\n\r\n\t\t\t\"mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )\",\r\n\r\n\t\t\t\"mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"gl_Position = projectionMatrix * mvPosition;\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tmorphnormal_vertex: [\r\n\r\n\t\t\"#ifdef USE_MORPHNORMALS\",\r\n\r\n\t\t\t\"vec3 morphedNormal = vec3( 0.0 );\",\r\n\r\n\t\t\t\"morphedNormal +=  ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\",\r\n\t\t\t\"morphedNormal +=  ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\",\r\n\t\t\t\"morphedNormal +=  ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\",\r\n\t\t\t\"morphedNormal +=  ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\",\r\n\r\n\t\t\t\"morphedNormal += normal;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tskinnormal_vertex: [\r\n\r\n\t\t\"#ifdef USE_SKINNING\",\r\n\r\n\t\t\t\"mat4 skinMatrix = skinWeight.x * boneMatX;\",\r\n\t\t\t\"skinMatrix \t+= skinWeight.y * boneMatY;\",\r\n\r\n\t\t\t\"#ifdef USE_MORPHNORMALS\",\r\n\r\n\t\t\t\"vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\",\r\n\r\n\t\t\t\"#else\",\r\n\r\n\t\t\t\"vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tdefaultnormal_vertex: [\r\n\r\n\t\t\"vec3 objectNormal;\",\r\n\r\n\t\t\"#ifdef USE_SKINNING\",\r\n\r\n\t\t\t\"objectNormal = skinnedNormal.xyz;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )\",\r\n\r\n\t\t\t\"objectNormal = morphedNormal;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )\",\r\n\r\n\t\t\t\"objectNormal = normal;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#ifdef FLIP_SIDED\",\r\n\r\n\t\t\t\"objectNormal = -objectNormal;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"vec3 transformedNormal = normalMatrix * objectNormal;\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// SHADOW MAP\r\n\r\n\t// based on SpiderGL shadow map and Fabien Sanglard's GLSL shadow mapping examples\r\n\t//  http://spidergl.org/example.php?id=6\r\n\t// \thttp://fabiensanglard.net/shadowmapping\r\n\r\n\tshadowmap_pars_fragment: [\r\n\r\n\t\t\"#ifdef USE_SHADOWMAP\",\r\n\r\n\t\t\t\"uniform sampler2D shadowMap[ MAX_SHADOWS ];\",\r\n\t\t\t\"uniform vec2 shadowMapSize[ MAX_SHADOWS ];\",\r\n\r\n\t\t\t\"uniform float shadowDarkness[ MAX_SHADOWS ];\",\r\n\t\t\t\"uniform float shadowBias[ MAX_SHADOWS ];\",\r\n\r\n\t\t\t\"varying vec4 vShadowCoord[ MAX_SHADOWS ];\",\r\n\r\n\t\t\t\"float unpackDepth( const in vec4 rgba_depth ) {\",\r\n\r\n\t\t\t\t\"const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\",\r\n\t\t\t\t\"float depth = dot( rgba_depth, bit_shift );\",\r\n\t\t\t\t\"return depth;\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tshadowmap_fragment: [\r\n\r\n\t\t\"#ifdef USE_SHADOWMAP\",\r\n\r\n\t\t\t\"#ifdef SHADOWMAP_DEBUG\",\r\n\r\n\t\t\t\t\"vec3 frustumColors[3];\",\r\n\t\t\t\t\"frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\",\r\n\t\t\t\t\"frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\",\r\n\t\t\t\t\"frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#ifdef SHADOWMAP_CASCADE\",\r\n\r\n\t\t\t\t\"int inFrustumCount = 0;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"float fDepth;\",\r\n\t\t\t\"vec3 shadowColor = vec3( 1.0 );\",\r\n\r\n\t\t\t\"for( int i = 0; i < MAX_SHADOWS; i ++ ) {\",\r\n\r\n\t\t\t\t\"vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\",\r\n\r\n\t\t\t\t// \"if ( something && something )\" \t\t breaks ATI OpenGL shader compiler\r\n\t\t\t\t// \"if ( all( something, something ) )\"  using this instead\r\n\r\n\t\t\t\t\"bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\",\r\n\t\t\t\t\"bool inFrustum = all( inFrustumVec );\",\r\n\r\n\t\t\t\t// don't shadow pixels outside of light frustum\r\n\t\t\t\t// use just first frustum (for cascades)\r\n\t\t\t\t// don't shadow pixels behind far plane of light frustum\r\n\r\n\t\t\t\t\"#ifdef SHADOWMAP_CASCADE\",\r\n\r\n\t\t\t\t\t\"inFrustumCount += int( inFrustum );\",\r\n\t\t\t\t\t\"bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\",\r\n\r\n\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\"bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"bool frustumTest = all( frustumTestVec );\",\r\n\r\n\t\t\t\t\"if ( frustumTest ) {\",\r\n\r\n\t\t\t\t\t\"shadowCoord.z += shadowBias[ i ];\",\r\n\r\n\t\t\t\t\t\"#if defined( SHADOWMAP_TYPE_PCF )\",\r\n\r\n\t\t\t\t\t\t// Percentage-close filtering\r\n\t\t\t\t\t\t// (9 pixel kernel)\r\n\t\t\t\t\t\t// http://fabiensanglard.net/shadowmappingPCF/\r\n\r\n\t\t\t\t\t\t\"float shadow = 0.0;\",\r\n\r\n\t\t\t\t\t\t/*\r\n\t\t\t\t\t\t// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\r\n\t\t\t\t\t\t// must enroll loop manually\r\n\r\n\t\t\t\t\t\t\"for ( float y = -1.25; y <= 1.25; y += 1.25 )\",\r\n\t\t\t\t\t\t\t\"for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\",\r\n\r\n\t\t\t\t\t\t\t\t\"vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\",\r\n\r\n\t\t\t\t\t\t\t\t// doesn't seem to produce any noticeable visual difference compared to simple \"texture2D\" lookup\r\n\t\t\t\t\t\t\t\t//\"vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\",\r\n\r\n\t\t\t\t\t\t\t\t\"float fDepth = unpackDepth( rgbaDepth );\",\r\n\r\n\t\t\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z )\",\r\n\t\t\t\t\t\t\t\t\t\"shadow += 1.0;\",\r\n\r\n\t\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\t\t\"shadow /= 9.0;\",\r\n\r\n\t\t\t\t\t\t*/\r\n\r\n\t\t\t\t\t\t\"const float shadowDelta = 1.0 / 9.0;\",\r\n\r\n\t\t\t\t\t\t\"float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\",\r\n\t\t\t\t\t\t\"float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\",\r\n\r\n\t\t\t\t\t\t\"float dx0 = -1.25 * xPixelOffset;\",\r\n\t\t\t\t\t\t\"float dy0 = -1.25 * yPixelOffset;\",\r\n\t\t\t\t\t\t\"float dx1 = 1.25 * xPixelOffset;\",\r\n\t\t\t\t\t\t\"float dy1 = 1.25 * yPixelOffset;\",\r\n\r\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\",\r\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\r\n\r\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\",\r\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\r\n\r\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\",\r\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\r\n\r\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\",\r\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\r\n\r\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\",\r\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\r\n\r\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\",\r\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\r\n\r\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\",\r\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\r\n\r\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\",\r\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\r\n\r\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\",\r\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\r\n\r\n\t\t\t\t\t\t\"shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\",\r\n\r\n\t\t\t\t\t\"#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\",\r\n\r\n\t\t\t\t\t\t// Percentage-close filtering\r\n\t\t\t\t\t\t// (9 pixel kernel)\r\n\t\t\t\t\t\t// http://fabiensanglard.net/shadowmappingPCF/\r\n\r\n\t\t\t\t\t\t\"float shadow = 0.0;\",\r\n\r\n\t\t\t\t\t\t\"float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\",\r\n\t\t\t\t\t\t\"float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\",\r\n\r\n\t\t\t\t\t\t\"float dx0 = -1.0 * xPixelOffset;\",\r\n\t\t\t\t\t\t\"float dy0 = -1.0 * yPixelOffset;\",\r\n\t\t\t\t\t\t\"float dx1 = 1.0 * xPixelOffset;\",\r\n\t\t\t\t\t\t\"float dy1 = 1.0 * yPixelOffset;\",\r\n\r\n\t\t\t\t\t\t\"mat3 shadowKernel;\",\r\n\t\t\t\t\t\t\"mat3 depthKernel;\",\r\n\r\n\t\t\t\t\t\t\"depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\",\r\n\t\t\t\t\t\t\"if ( depthKernel[0][0] < shadowCoord.z ) shadowKernel[0][0] = 0.25;\",\r\n\t\t\t\t\t\t\"else shadowKernel[0][0] = 0.0;\",\r\n\r\n\t\t\t\t\t\t\"depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\",\r\n\t\t\t\t\t\t\"if ( depthKernel[0][1] < shadowCoord.z ) shadowKernel[0][1] = 0.25;\",\r\n\t\t\t\t\t\t\"else shadowKernel[0][1] = 0.0;\",\r\n\r\n\t\t\t\t\t\t\"depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i], shadowCoord.xy + vec2( dx0, dy1 ) ) );\",\r\n\t\t\t\t\t\t\"if ( depthKernel[0][2] < shadowCoord.z ) shadowKernel[0][2] = 0.25;\",\r\n\t\t\t\t\t\t\"else shadowKernel[0][2] = 0.0;\",\r\n\r\n\t\t\t\t\t\t\"depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\",\r\n\t\t\t\t\t\t\"if ( depthKernel[1][0] < shadowCoord.z ) shadowKernel[1][0] = 0.25;\",\r\n\t\t\t\t\t\t\"else shadowKernel[1][0] = 0.0;\",\r\n\r\n\t\t\t\t\t\t\"depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\",\r\n\t\t\t\t\t\t\"if ( depthKernel[1][1] < shadowCoord.z ) shadowKernel[1][1] = 0.25;\",\r\n\t\t\t\t\t\t\"else shadowKernel[1][1] = 0.0;\",\r\n\r\n\t\t\t\t\t\t\"depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\",\r\n\t\t\t\t\t\t\"if ( depthKernel[1][2] < shadowCoord.z ) shadowKernel[1][2] = 0.25;\",\r\n\t\t\t\t\t\t\"else shadowKernel[1][2] = 0.0;\",\r\n\r\n\t\t\t\t\t\t\"depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\",\r\n\t\t\t\t\t\t\"if ( depthKernel[2][0] < shadowCoord.z ) shadowKernel[2][0] = 0.25;\",\r\n\t\t\t\t\t\t\"else shadowKernel[2][0] = 0.0;\",\r\n\r\n\t\t\t\t\t\t\"depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\",\r\n\t\t\t\t\t\t\"if ( depthKernel[2][1] < shadowCoord.z ) shadowKernel[2][1] = 0.25;\",\r\n\t\t\t\t\t\t\"else shadowKernel[2][1] = 0.0;\",\r\n\r\n\t\t\t\t\t\t\"depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\",\r\n\t\t\t\t\t\t\"if ( depthKernel[2][2] < shadowCoord.z ) shadowKernel[2][2] = 0.25;\",\r\n\t\t\t\t\t\t\"else shadowKernel[2][2] = 0.0;\",\r\n\r\n\t\t\t\t\t\t\"vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\",\r\n\r\n\t\t\t\t\t\t\"shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\",\r\n\t\t\t\t\t\t\"shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\",\r\n\r\n\t\t\t\t\t\t\"vec4 shadowValues;\",\r\n\t\t\t\t\t\t\"shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\",\r\n\t\t\t\t\t\t\"shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\",\r\n\t\t\t\t\t\t\"shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\",\r\n\t\t\t\t\t\t\"shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\",\r\n\r\n\t\t\t\t\t\t\"shadow = dot( shadowValues, vec4( 1.0 ) );\",\r\n\r\n\t\t\t\t\t\t\"shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\",\r\n\r\n\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\"vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\",\r\n\t\t\t\t\t\t\"float fDepth = unpackDepth( rgbaDepth );\",\r\n\r\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z )\",\r\n\r\n\t\t\t\t\t\t\t// spot with multiple shadows is darker\r\n\r\n\t\t\t\t\t\t\t\"shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\",\r\n\r\n\t\t\t\t\t\t\t// spot with multiple shadows has the same color as single shadow spot\r\n\r\n\t\t\t\t\t\t\t//\"shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\r\n\t\t\t\t\"#ifdef SHADOWMAP_DEBUG\",\r\n\r\n\t\t\t\t\t\"#ifdef SHADOWMAP_CASCADE\",\r\n\r\n\t\t\t\t\t\t\"if ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];\",\r\n\r\n\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\"if ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"#ifdef GAMMA_OUTPUT\",\r\n\r\n\t\t\t\t\"shadowColor *= shadowColor;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * shadowColor;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tshadowmap_pars_vertex: [\r\n\r\n\t\t\"#ifdef USE_SHADOWMAP\",\r\n\r\n\t\t\t\"varying vec4 vShadowCoord[ MAX_SHADOWS ];\",\r\n\t\t\t\"uniform mat4 shadowMatrix[ MAX_SHADOWS ];\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tshadowmap_vertex: [\r\n\r\n\t\t\"#ifdef USE_SHADOWMAP\",\r\n\r\n\t\t\t\"for( int i = 0; i < MAX_SHADOWS; i ++ ) {\",\r\n\r\n\t\t\t\t\"vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// ALPHATEST\r\n\r\n\talphatest_fragment: [\r\n\r\n\t\t\"#ifdef ALPHATEST\",\r\n\r\n\t\t\t\"if ( gl_FragColor.a < ALPHATEST ) discard;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// LINEAR SPACE\r\n\r\n\tlinear_to_gamma_fragment: [\r\n\r\n\t\t\"#ifdef GAMMA_OUTPUT\",\r\n\r\n\t\t\t\"gl_FragColor.xyz = sqrt( gl_FragColor.xyz );\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\")\r\n\r\n\r\n};\r\n\r\nTHREE.UniformsUtils = {\r\n\r\n\tmerge: function ( uniforms ) {\r\n\r\n\t\tvar u, p, tmp, merged = {};\r\n\r\n\t\tfor ( u = 0; u < uniforms.length; u ++ ) {\r\n\r\n\t\t\ttmp = this.clone( uniforms[ u ] );\r\n\r\n\t\t\tfor ( p in tmp ) {\r\n\r\n\t\t\t\tmerged[ p ] = tmp[ p ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn merged;\r\n\r\n\t},\r\n\r\n\tclone: function ( uniforms_src ) {\r\n\r\n\t\tvar u, p, parameter, parameter_src, uniforms_dst = {};\r\n\r\n\t\tfor ( u in uniforms_src ) {\r\n\r\n\t\t\tuniforms_dst[ u ] = {};\r\n\r\n\t\t\tfor ( p in uniforms_src[ u ] ) {\r\n\r\n\t\t\t\tparameter_src = uniforms_src[ u ][ p ];\r\n\r\n\t\t\t\tif ( parameter_src instanceof THREE.Color ||\r\n\t\t\t\t\t parameter_src instanceof THREE.Vector2 ||\r\n\t\t\t\t\t parameter_src instanceof THREE.Vector3 ||\r\n\t\t\t\t\t parameter_src instanceof THREE.Vector4 ||\r\n\t\t\t\t\t parameter_src instanceof THREE.Matrix4 ||\r\n\t\t\t\t\t parameter_src instanceof THREE.Texture ) {\r\n\r\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.clone();\r\n\r\n\t\t\t\t} else if ( parameter_src instanceof Array ) {\r\n\r\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.slice();\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn uniforms_dst;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.UniformsLib = {\r\n\r\n\tcommon: {\r\n\r\n\t\t\"diffuse\" : { type: \"c\", value: new THREE.Color( 0xeeeeee ) },\r\n\t\t\"opacity\" : { type: \"f\", value: 1.0 },\r\n\r\n\t\t\"map\" : { type: \"t\", value: null },\r\n\t\t\"offsetRepeat\" : { type: \"v4\", value: new THREE.Vector4( 0, 0, 1, 1 ) },\r\n\r\n\t\t\"lightMap\" : { type: \"t\", value: null },\r\n\t\t\"specularMap\" : { type: \"t\", value: null },\r\n\r\n\t\t\"envMap\" : { type: \"t\", value: null },\r\n\t\t\"flipEnvMap\" : { type: \"f\", value: -1 },\r\n\t\t\"useRefract\" : { type: \"i\", value: 0 },\r\n\t\t\"reflectivity\" : { type: \"f\", value: 1.0 },\r\n\t\t\"refractionRatio\" : { type: \"f\", value: 0.98 },\r\n\t\t\"combine\" : { type: \"i\", value: 0 },\r\n\r\n\t\t\"morphTargetInfluences\" : { type: \"f\", value: 0 }\r\n\r\n\t},\r\n\r\n\tbump: {\r\n\r\n\t\t\"bumpMap\" : { type: \"t\", value: null },\r\n\t\t\"bumpScale\" : { type: \"f\", value: 1 }\r\n\r\n\t},\r\n\r\n\tnormalmap: {\r\n\r\n\t\t\"normalMap\" : { type: \"t\", value: null },\r\n\t\t\"normalScale\" : { type: \"v2\", value: new THREE.Vector2( 1, 1 ) }\r\n\t},\r\n\r\n\tfog : {\r\n\r\n\t\t\"fogDensity\" : { type: \"f\", value: 0.00025 },\r\n\t\t\"fogNear\" : { type: \"f\", value: 1 },\r\n\t\t\"fogFar\" : { type: \"f\", value: 2000 },\r\n\t\t\"fogColor\" : { type: \"c\", value: new THREE.Color( 0xffffff ) }\r\n\r\n\t},\r\n\r\n\tlights: {\r\n\r\n\t\t\"ambientLightColor\" : { type: \"fv\", value: [] },\r\n\r\n\t\t\"directionalLightDirection\" : { type: \"fv\", value: [] },\r\n\t\t\"directionalLightColor\" : { type: \"fv\", value: [] },\r\n\r\n\t\t\"hemisphereLightDirection\" : { type: \"fv\", value: [] },\r\n\t\t\"hemisphereLightSkyColor\" : { type: \"fv\", value: [] },\r\n\t\t\"hemisphereLightGroundColor\" : { type: \"fv\", value: [] },\r\n\r\n\t\t\"pointLightColor\" : { type: \"fv\", value: [] },\r\n\t\t\"pointLightPosition\" : { type: \"fv\", value: [] },\r\n\t\t\"pointLightDistance\" : { type: \"fv1\", value: [] },\r\n\r\n\t\t\"spotLightColor\" : { type: \"fv\", value: [] },\r\n\t\t\"spotLightPosition\" : { type: \"fv\", value: [] },\r\n\t\t\"spotLightDirection\" : { type: \"fv\", value: [] },\r\n\t\t\"spotLightDistance\" : { type: \"fv1\", value: [] },\r\n\t\t\"spotLightAngleCos\" : { type: \"fv1\", value: [] },\r\n\t\t\"spotLightExponent\" : { type: \"fv1\", value: [] }\r\n\r\n\t},\r\n\r\n\tparticle: {\r\n\r\n\t\t\"psColor\" : { type: \"c\", value: new THREE.Color( 0xeeeeee ) },\r\n\t\t\"opacity\" : { type: \"f\", value: 1.0 },\r\n\t\t\"size\" : { type: \"f\", value: 1.0 },\r\n\t\t\"scale\" : { type: \"f\", value: 1.0 },\r\n\t\t\"map\" : { type: \"t\", value: null },\r\n\r\n\t\t\"fogDensity\" : { type: \"f\", value: 0.00025 },\r\n\t\t\"fogNear\" : { type: \"f\", value: 1 },\r\n\t\t\"fogFar\" : { type: \"f\", value: 2000 },\r\n\t\t\"fogColor\" : { type: \"c\", value: new THREE.Color( 0xffffff ) }\r\n\r\n\t},\r\n\r\n\tshadowmap: {\r\n\r\n\t\t\"shadowMap\": { type: \"tv\", value: [] },\r\n\t\t\"shadowMapSize\": { type: \"v2v\", value: [] },\r\n\r\n\t\t\"shadowBias\" : { type: \"fv1\", value: [] },\r\n\t\t\"shadowDarkness\": { type: \"fv1\", value: [] },\r\n\r\n\t\t\"shadowMatrix\" : { type: \"m4v\", value: [] }\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.ShaderLib = {\r\n\r\n\t'basic': {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ \"common\" ],\r\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\r\n\t\t\tTHREE.UniformsLib[ \"shadowmap\" ]\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"map_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n\r\n\t\t\t\t\"#ifdef USE_ENVMAP\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphnormal_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"defaultnormal_vertex\" ],\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform vec3 diffuse;\",\r\n\t\t\t\"uniform float opacity;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"map_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"gl_FragColor = vec4( diffuse, opacity );\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"specularmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t'lambert': {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ \"common\" ],\r\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\r\n\t\t\tTHREE.UniformsLib[ \"lights\" ],\r\n\t\t\tTHREE.UniformsLib[ \"shadowmap\" ],\r\n\r\n\t\t\t{\r\n\t\t\t\t\"ambient\"  : { type: \"c\", value: new THREE.Color( 0xffffff ) },\r\n\t\t\t\t\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\r\n\t\t\t\t\"wrapRGB\"  : { type: \"v3\", value: new THREE.Vector3( 1, 1, 1 ) }\r\n\t\t\t}\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"#define LAMBERT\",\r\n\r\n\t\t\t\"varying vec3 vLightFront;\",\r\n\r\n\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\"varying vec3 vLightBack;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"map_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lights_lambert_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphnormal_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"defaultnormal_vertex\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lights_lambert_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform float opacity;\",\r\n\r\n\t\t\t\"varying vec3 vLightFront;\",\r\n\r\n\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\"varying vec3 vLightBack;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"map_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"gl_FragColor = vec4( vec3 ( 1.0 ), opacity );\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"specularmap_fragment\" ],\r\n\r\n\t\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\t//\"float isFront = float( gl_FrontFacing );\",\r\n\t\t\t\t\t//\"gl_FragColor.xyz *= isFront * vLightFront + ( 1.0 - isFront ) * vLightBack;\",\r\n\r\n\t\t\t\t\t\"if ( gl_FrontFacing )\",\r\n\t\t\t\t\t\t\"gl_FragColor.xyz *= vLightFront;\",\r\n\t\t\t\t\t\"else\",\r\n\t\t\t\t\t\t\"gl_FragColor.xyz *= vLightBack;\",\r\n\r\n\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\"gl_FragColor.xyz *= vLightFront;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t'phong': {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ \"common\" ],\r\n\t\t\tTHREE.UniformsLib[ \"bump\" ],\r\n\t\t\tTHREE.UniformsLib[ \"normalmap\" ],\r\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\r\n\t\t\tTHREE.UniformsLib[ \"lights\" ],\r\n\t\t\tTHREE.UniformsLib[ \"shadowmap\" ],\r\n\r\n\t\t\t{\r\n\t\t\t\t\"ambient\"  : { type: \"c\", value: new THREE.Color( 0xffffff ) },\r\n\t\t\t\t\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\r\n\t\t\t\t\"specular\" : { type: \"c\", value: new THREE.Color( 0x111111 ) },\r\n\t\t\t\t\"shininess\": { type: \"f\", value: 30 },\r\n\t\t\t\t\"wrapRGB\"  : { type: \"v3\", value: new THREE.Vector3( 1, 1, 1 ) }\r\n\t\t\t}\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"#define PHONG\",\r\n\r\n\t\t\t\"varying vec3 vViewPosition;\",\r\n\t\t\t\"varying vec3 vNormal;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"map_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lights_phong_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphnormal_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"defaultnormal_vertex\" ],\r\n\r\n\t\t\t\t\"vNormal = normalize( transformedNormal );\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\r\n\r\n\t\t\t\t\"vViewPosition = -mvPosition.xyz;\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lights_phong_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform vec3 diffuse;\",\r\n\t\t\t\"uniform float opacity;\",\r\n\r\n\t\t\t\"uniform vec3 ambient;\",\r\n\t\t\t\"uniform vec3 emissive;\",\r\n\t\t\t\"uniform vec3 specular;\",\r\n\t\t\t\"uniform float shininess;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"map_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lights_phong_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"bumpmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"normalmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"gl_FragColor = vec4( vec3 ( 1.0 ), opacity );\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"specularmap_fragment\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"lights_phong_fragment\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t'particle_basic': {\r\n\r\n\t\tuniforms:  THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ \"particle\" ],\r\n\t\t\tTHREE.UniformsLib[ \"shadowmap\" ]\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"uniform float size;\",\r\n\t\t\t\"uniform float scale;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\r\n\r\n\t\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\t\"#ifdef USE_SIZEATTENUATION\",\r\n\t\t\t\t\t\"gl_PointSize = size * ( scale / length( mvPosition.xyz ) );\",\r\n\t\t\t\t\"#else\",\r\n\t\t\t\t\t\"gl_PointSize = size;\",\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"gl_Position = projectionMatrix * mvPosition;\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform vec3 psColor;\",\r\n\t\t\t\"uniform float opacity;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"map_particle_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"gl_FragColor = vec4( psColor, opacity );\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_particle_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t'dashed': {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ \"common\" ],\r\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\r\n\r\n\t\t\t{\r\n\t\t\t\t\"scale\":     { type: \"f\", value: 1 },\r\n\t\t\t\t\"dashSize\":  { type: \"f\", value: 1 },\r\n\t\t\t\t\"totalSize\": { type: \"f\", value: 2 }\r\n\t\t\t}\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"uniform float scale;\",\r\n\t\t\t\"attribute float lineDistance;\",\r\n\r\n\t\t\t\"varying float vLineDistance;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\r\n\r\n\t\t\t\t\"vLineDistance = scale * lineDistance;\",\r\n\r\n\t\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\r\n\t\t\t\t\"gl_Position = projectionMatrix * mvPosition;\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform vec3 diffuse;\",\r\n\t\t\t\"uniform float opacity;\",\r\n\r\n\t\t\t\"uniform float dashSize;\",\r\n\t\t\t\"uniform float totalSize;\",\r\n\r\n\t\t\t\"varying float vLineDistance;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"if ( mod( vLineDistance, totalSize ) > dashSize ) {\",\r\n\r\n\t\t\t\t\t\"discard;\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"gl_FragColor = vec4( diffuse, opacity );\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t'depth': {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\t\"mNear\": { type: \"f\", value: 1.0 },\r\n\t\t\t\"mFar\" : { type: \"f\", value: 2000.0 },\r\n\t\t\t\"opacity\" : { type: \"f\", value: 1.0 }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform float mNear;\",\r\n\t\t\t\"uniform float mFar;\",\r\n\t\t\t\"uniform float opacity;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"float depth = gl_FragCoord.z / gl_FragCoord.w;\",\r\n\t\t\t\t\"float color = 1.0 - smoothstep( mNear, mFar, depth );\",\r\n\t\t\t\t\"gl_FragColor = vec4( vec3( color ), opacity );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t'normal': {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\t\"opacity\" : { type: \"f\", value: 1.0 }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec3 vNormal;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\r\n\t\t\t\t\"vNormal = normalize( normalMatrix * normal );\",\r\n\r\n\t\t\t\t\"gl_Position = projectionMatrix * mvPosition;\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform float opacity;\",\r\n\t\t\t\"varying vec3 vNormal;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t/* -------------------------------------------------------------------------\r\n\t//\tNormal map shader\r\n\t//\t\t- Blinn-Phong\r\n\t//\t\t- normal + diffuse + specular + AO + displacement + reflection + shadow maps\r\n\t//\t\t- point and directional lights (use with \"lights: true\" material option)\r\n\t ------------------------------------------------------------------------- */\r\n\r\n\t'normalmap' : {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\r\n\t\t\tTHREE.UniformsLib[ \"lights\" ],\r\n\t\t\tTHREE.UniformsLib[ \"shadowmap\" ],\r\n\r\n\t\t\t{\r\n\r\n\t\t\t\"enableAO\"\t\t  : { type: \"i\", value: 0 },\r\n\t\t\t\"enableDiffuse\"\t  : { type: \"i\", value: 0 },\r\n\t\t\t\"enableSpecular\"  : { type: \"i\", value: 0 },\r\n\t\t\t\"enableReflection\": { type: \"i\", value: 0 },\r\n\t\t\t\"enableDisplacement\": { type: \"i\", value: 0 },\r\n\r\n\t\t\t\"tDisplacement\": { type: \"t\", value: null }, // must go first as this is vertex texture\r\n\t\t\t\"tDiffuse\"\t   : { type: \"t\", value: null },\r\n\t\t\t\"tCube\"\t\t   : { type: \"t\", value: null },\r\n\t\t\t\"tNormal\"\t   : { type: \"t\", value: null },\r\n\t\t\t\"tSpecular\"\t   : { type: \"t\", value: null },\r\n\t\t\t\"tAO\"\t\t   : { type: \"t\", value: null },\r\n\r\n\t\t\t\"uNormalScale\": { type: \"v2\", value: new THREE.Vector2( 1, 1 ) },\r\n\r\n\t\t\t\"uDisplacementBias\": { type: \"f\", value: 0.0 },\r\n\t\t\t\"uDisplacementScale\": { type: \"f\", value: 1.0 },\r\n\r\n\t\t\t\"uDiffuseColor\": { type: \"c\", value: new THREE.Color( 0xffffff ) },\r\n\t\t\t\"uSpecularColor\": { type: \"c\", value: new THREE.Color( 0x111111 ) },\r\n\t\t\t\"uAmbientColor\": { type: \"c\", value: new THREE.Color( 0xffffff ) },\r\n\t\t\t\"uShininess\": { type: \"f\", value: 30 },\r\n\t\t\t\"uOpacity\": { type: \"f\", value: 1 },\r\n\r\n\t\t\t\"useRefract\": { type: \"i\", value: 0 },\r\n\t\t\t\"uRefractionRatio\": { type: \"f\", value: 0.98 },\r\n\t\t\t\"uReflectivity\": { type: \"f\", value: 0.5 },\r\n\r\n\t\t\t\"uOffset\" : { type: \"v2\", value: new THREE.Vector2( 0, 0 ) },\r\n\t\t\t\"uRepeat\" : { type: \"v2\", value: new THREE.Vector2( 1, 1 ) },\r\n\r\n\t\t\t\"wrapRGB\"  : { type: \"v3\", value: new THREE.Vector3( 1, 1, 1 ) }\r\n\r\n\t\t\t}\r\n\r\n\t\t] ),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform vec3 uAmbientColor;\",\r\n\t\t\t\"uniform vec3 uDiffuseColor;\",\r\n\t\t\t\"uniform vec3 uSpecularColor;\",\r\n\t\t\t\"uniform float uShininess;\",\r\n\t\t\t\"uniform float uOpacity;\",\r\n\r\n\t\t\t\"uniform bool enableDiffuse;\",\r\n\t\t\t\"uniform bool enableSpecular;\",\r\n\t\t\t\"uniform bool enableAO;\",\r\n\t\t\t\"uniform bool enableReflection;\",\r\n\r\n\t\t\t\"uniform sampler2D tDiffuse;\",\r\n\t\t\t\"uniform sampler2D tNormal;\",\r\n\t\t\t\"uniform sampler2D tSpecular;\",\r\n\t\t\t\"uniform sampler2D tAO;\",\r\n\r\n\t\t\t\"uniform samplerCube tCube;\",\r\n\r\n\t\t\t\"uniform vec2 uNormalScale;\",\r\n\r\n\t\t\t\"uniform bool useRefract;\",\r\n\t\t\t\"uniform float uRefractionRatio;\",\r\n\t\t\t\"uniform float uReflectivity;\",\r\n\r\n\t\t\t\"varying vec3 vTangent;\",\r\n\t\t\t\"varying vec3 vBinormal;\",\r\n\t\t\t\"varying vec3 vNormal;\",\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"uniform vec3 ambientLightColor;\",\r\n\r\n\t\t\t\"#if MAX_DIR_LIGHTS > 0\",\r\n\r\n\t\t\t\t\"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\",\r\n\t\t\t\t\"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#if MAX_HEMI_LIGHTS > 0\",\r\n\r\n\t\t\t\t\"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\",\r\n\t\t\t\t\"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\",\r\n\t\t\t\t\"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#if MAX_POINT_LIGHTS > 0\",\r\n\r\n\t\t\t\t\"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\",\r\n\t\t\t\t\"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\",\r\n\t\t\t\t\"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#if MAX_SPOT_LIGHTS > 0\",\r\n\r\n\t\t\t\t\"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\t\"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\t\"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\t\"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\t\"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\t\"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\t\"uniform vec3 wrapRGB;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"varying vec3 vWorldPosition;\",\r\n\t\t\t\"varying vec3 vViewPosition;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"gl_FragColor = vec4( vec3( 1.0 ), uOpacity );\",\r\n\r\n\t\t\t\t\"vec3 specularTex = vec3( 1.0 );\",\r\n\r\n\t\t\t\t\"vec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;\",\r\n\t\t\t\t\"normalTex.xy *= uNormalScale;\",\r\n\t\t\t\t\"normalTex = normalize( normalTex );\",\r\n\r\n\t\t\t\t\"if( enableDiffuse ) {\",\r\n\r\n\t\t\t\t\t\"#ifdef GAMMA_INPUT\",\r\n\r\n\t\t\t\t\t\t\"vec4 texelColor = texture2D( tDiffuse, vUv );\",\r\n\t\t\t\t\t\t\"texelColor.xyz *= texelColor.xyz;\",\r\n\r\n\t\t\t\t\t\t\"gl_FragColor = gl_FragColor * texelColor;\",\r\n\r\n\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\"gl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"if( enableAO ) {\",\r\n\r\n\t\t\t\t\t\"#ifdef GAMMA_INPUT\",\r\n\r\n\t\t\t\t\t\t\"vec4 aoColor = texture2D( tAO, vUv );\",\r\n\t\t\t\t\t\t\"aoColor.xyz *= aoColor.xyz;\",\r\n\r\n\t\t\t\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;\",\r\n\r\n\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"if( enableSpecular )\",\r\n\t\t\t\t\t\"specularTex = texture2D( tSpecular, vUv ).xyz;\",\r\n\r\n\t\t\t\t\"mat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );\",\r\n\t\t\t\t\"vec3 finalNormal = tsb * normalTex;\",\r\n\r\n\t\t\t\t\"#ifdef FLIP_SIDED\",\r\n\r\n\t\t\t\t\t\"finalNormal = -finalNormal;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"vec3 normal = normalize( finalNormal );\",\r\n\t\t\t\t\"vec3 viewPosition = normalize( vViewPosition );\",\r\n\r\n\t\t\t\t// point lights\r\n\r\n\t\t\t\t\"#if MAX_POINT_LIGHTS > 0\",\r\n\r\n\t\t\t\t\t\"vec3 pointDiffuse = vec3( 0.0 );\",\r\n\t\t\t\t\t\"vec3 pointSpecular = vec3( 0.0 );\",\r\n\r\n\t\t\t\t\t\"for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\",\r\n\t\t\t\t\t\t\"vec3 pointVector = lPosition.xyz + vViewPosition.xyz;\",\r\n\r\n\t\t\t\t\t\t\"float pointDistance = 1.0;\",\r\n\t\t\t\t\t\t\"if ( pointLightDistance[ i ] > 0.0 )\",\r\n\t\t\t\t\t\t\t\"pointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );\",\r\n\r\n\t\t\t\t\t\t\"pointVector = normalize( pointVector );\",\r\n\r\n\t\t\t\t\t\t// diffuse\r\n\r\n\t\t\t\t\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\t\t\t\t\"float pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );\",\r\n\t\t\t\t\t\t\t\"float pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );\",\r\n\r\n\t\t\t\t\t\t\t\"vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\",\r\n\r\n\t\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\t\"float pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );\",\r\n\r\n\t\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\t\t\"pointDiffuse += pointDistance * pointLightColor[ i ] * uDiffuseColor * pointDiffuseWeight;\",\r\n\r\n\t\t\t\t\t\t// specular\r\n\r\n\t\t\t\t\t\t\"vec3 pointHalfVector = normalize( pointVector + viewPosition );\",\r\n\t\t\t\t\t\t\"float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\",\r\n\t\t\t\t\t\t\"float pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, uShininess ), 0.0 );\",\r\n\r\n\t\t\t\t\t\t\"#ifdef PHYSICALLY_BASED_SHADING\",\r\n\r\n\t\t\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\r\n\r\n\t\t\t\t\t\t\t\"float specularNormalization = ( uShininess + 2.0001 ) / 8.0;\",\r\n\r\n\t\t\t\t\t\t\t\"vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( pointVector, pointHalfVector ), 5.0 );\",\r\n\t\t\t\t\t\t\t\"pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;\",\r\n\r\n\t\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\t\"pointSpecular += pointDistance * pointLightColor[ i ] * uSpecularColor * pointSpecularWeight * pointDiffuseWeight;\",\r\n\r\n\t\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t// spot lights\r\n\r\n\t\t\t\t\"#if MAX_SPOT_LIGHTS > 0\",\r\n\r\n\t\t\t\t\t\"vec3 spotDiffuse = vec3( 0.0 );\",\r\n\t\t\t\t\t\"vec3 spotSpecular = vec3( 0.0 );\",\r\n\r\n\t\t\t\t\t\"for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\",\r\n\t\t\t\t\t\t\"vec3 spotVector = lPosition.xyz + vViewPosition.xyz;\",\r\n\r\n\t\t\t\t\t\t\"float spotDistance = 1.0;\",\r\n\t\t\t\t\t\t\"if ( spotLightDistance[ i ] > 0.0 )\",\r\n\t\t\t\t\t\t\t\"spotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );\",\r\n\r\n\t\t\t\t\t\t\"spotVector = normalize( spotVector );\",\r\n\r\n\t\t\t\t\t\t\"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\",\r\n\r\n\t\t\t\t\t\t\"if ( spotEffect > spotLightAngleCos[ i ] ) {\",\r\n\r\n\t\t\t\t\t\t\t\"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\",\r\n\r\n\t\t\t\t\t\t\t// diffuse\r\n\r\n\t\t\t\t\t\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\t\t\t\t\t\"float spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );\",\r\n\t\t\t\t\t\t\t\t\"float spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );\",\r\n\r\n\t\t\t\t\t\t\t\t\"vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\",\r\n\r\n\t\t\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\t\t\"float spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );\",\r\n\r\n\t\t\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\t\t\t\"spotDiffuse += spotDistance * spotLightColor[ i ] * uDiffuseColor * spotDiffuseWeight * spotEffect;\",\r\n\r\n\t\t\t\t\t\t\t// specular\r\n\r\n\t\t\t\t\t\t\t\"vec3 spotHalfVector = normalize( spotVector + viewPosition );\",\r\n\t\t\t\t\t\t\t\"float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\",\r\n\t\t\t\t\t\t\t\"float spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, uShininess ), 0.0 );\",\r\n\r\n\t\t\t\t\t\t\t\"#ifdef PHYSICALLY_BASED_SHADING\",\r\n\r\n\t\t\t\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\r\n\r\n\t\t\t\t\t\t\t\t\"float specularNormalization = ( uShininess + 2.0001 ) / 8.0;\",\r\n\r\n\t\t\t\t\t\t\t\t\"vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( spotVector, spotHalfVector ), 5.0 );\",\r\n\t\t\t\t\t\t\t\t\"spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;\",\r\n\r\n\t\t\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\t\t\"spotSpecular += spotDistance * spotLightColor[ i ] * uSpecularColor * spotSpecularWeight * spotDiffuseWeight * spotEffect;\",\r\n\r\n\t\t\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t// directional lights\r\n\r\n\t\t\t\t\"#if MAX_DIR_LIGHTS > 0\",\r\n\r\n\t\t\t\t\t\"vec3 dirDiffuse = vec3( 0.0 );\",\r\n\t\t\t\t\t\"vec3 dirSpecular = vec3( 0.0 );\",\r\n\r\n\t\t\t\t\t\"for( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {\",\r\n\r\n\t\t\t\t\t\t\"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\",\r\n\t\t\t\t\t\t\"vec3 dirVector = normalize( lDirection.xyz );\",\r\n\r\n\t\t\t\t\t\t// diffuse\r\n\r\n\t\t\t\t\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\t\t\t\t\"float directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );\",\r\n\t\t\t\t\t\t\t\"float directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );\",\r\n\r\n\t\t\t\t\t\t\t\"vec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );\",\r\n\r\n\t\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\t\"float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );\",\r\n\r\n\t\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\t\t\"dirDiffuse += directionalLightColor[ i ] * uDiffuseColor * dirDiffuseWeight;\",\r\n\r\n\t\t\t\t\t\t// specular\r\n\r\n\t\t\t\t\t\t\"vec3 dirHalfVector = normalize( dirVector + viewPosition );\",\r\n\t\t\t\t\t\t\"float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\",\r\n\t\t\t\t\t\t\"float dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, uShininess ), 0.0 );\",\r\n\r\n\t\t\t\t\t\t\"#ifdef PHYSICALLY_BASED_SHADING\",\r\n\r\n\t\t\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\r\n\r\n\t\t\t\t\t\t\t\"float specularNormalization = ( uShininess + 2.0001 ) / 8.0;\",\r\n\r\n\t\t\t\t\t\t\t\"vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );\",\r\n\t\t\t\t\t\t\t\"dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\",\r\n\r\n\t\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\t\"dirSpecular += directionalLightColor[ i ] * uSpecularColor * dirSpecularWeight * dirDiffuseWeight;\",\r\n\r\n\t\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t// hemisphere lights\r\n\r\n\t\t\t\t\"#if MAX_HEMI_LIGHTS > 0\",\r\n\r\n\t\t\t\t\t\"vec3 hemiDiffuse  = vec3( 0.0 );\",\r\n\t\t\t\t\t\"vec3 hemiSpecular = vec3( 0.0 );\" ,\r\n\r\n\t\t\t\t\t\"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\t\t\"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\",\r\n\t\t\t\t\t\t\"vec3 lVector = normalize( lDirection.xyz );\",\r\n\r\n\t\t\t\t\t\t// diffuse\r\n\r\n\t\t\t\t\t\t\"float dotProduct = dot( normal, lVector );\",\r\n\t\t\t\t\t\t\"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\",\r\n\r\n\t\t\t\t\t\t\"vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\",\r\n\r\n\t\t\t\t\t\t\"hemiDiffuse += uDiffuseColor * hemiColor;\",\r\n\r\n\t\t\t\t\t\t// specular (sky light)\r\n\r\n\r\n\t\t\t\t\t\t\"vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\",\r\n\t\t\t\t\t\t\"float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\",\r\n\t\t\t\t\t\t\"float hemiSpecularWeightSky = specularTex.r * max( pow( hemiDotNormalHalfSky, uShininess ), 0.0 );\",\r\n\r\n\t\t\t\t\t\t// specular (ground light)\r\n\r\n\t\t\t\t\t\t\"vec3 lVectorGround = -lVector;\",\r\n\r\n\t\t\t\t\t\t\"vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\",\r\n\t\t\t\t\t\t\"float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\",\r\n\t\t\t\t\t\t\"float hemiSpecularWeightGround = specularTex.r * max( pow( hemiDotNormalHalfGround, uShininess ), 0.0 );\",\r\n\r\n\t\t\t\t\t\t\"#ifdef PHYSICALLY_BASED_SHADING\",\r\n\r\n\t\t\t\t\t\t\t\"float dotProductGround = dot( normal, lVectorGround );\",\r\n\r\n\t\t\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\r\n\r\n\t\t\t\t\t\t\t\"float specularNormalization = ( uShininess + 2.0001 ) / 8.0;\",\r\n\r\n\t\t\t\t\t\t\t\"vec3 schlickSky = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );\",\r\n\t\t\t\t\t\t\t\"vec3 schlickGround = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );\",\r\n\t\t\t\t\t\t\t\"hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\",\r\n\r\n\t\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\t\"hemiSpecular += uSpecularColor * hemiColor * ( hemiSpecularWeightSky + hemiSpecularWeightGround ) * hemiDiffuseWeight;\",\r\n\r\n\t\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t// all lights contribution summation\r\n\r\n\t\t\t\t\"vec3 totalDiffuse = vec3( 0.0 );\",\r\n\t\t\t\t\"vec3 totalSpecular = vec3( 0.0 );\",\r\n\r\n\t\t\t\t\"#if MAX_DIR_LIGHTS > 0\",\r\n\r\n\t\t\t\t\t\"totalDiffuse += dirDiffuse;\",\r\n\t\t\t\t\t\"totalSpecular += dirSpecular;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"#if MAX_HEMI_LIGHTS > 0\",\r\n\r\n\t\t\t\t\t\"totalDiffuse += hemiDiffuse;\",\r\n\t\t\t\t\t\"totalSpecular += hemiSpecular;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"#if MAX_POINT_LIGHTS > 0\",\r\n\r\n\t\t\t\t\t\"totalDiffuse += pointDiffuse;\",\r\n\t\t\t\t\t\"totalSpecular += pointSpecular;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"#if MAX_SPOT_LIGHTS > 0\",\r\n\r\n\t\t\t\t\t\"totalDiffuse += spotDiffuse;\",\r\n\t\t\t\t\t\"totalSpecular += spotSpecular;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"#ifdef METAL\",\r\n\r\n\t\t\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * uAmbientColor + totalSpecular );\",\r\n\r\n\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * uAmbientColor ) + totalSpecular;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"if ( enableReflection ) {\",\r\n\r\n\t\t\t\t\t\"vec3 vReflect;\",\r\n\t\t\t\t\t\"vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\",\r\n\r\n\t\t\t\t\t\"if ( useRefract ) {\",\r\n\r\n\t\t\t\t\t\t\"vReflect = refract( cameraToVertex, normal, uRefractionRatio );\",\r\n\r\n\t\t\t\t\t\"} else {\",\r\n\r\n\t\t\t\t\t\t\"vReflect = reflect( cameraToVertex, normal );\",\r\n\r\n\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\t\"vec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\",\r\n\r\n\t\t\t\t\t\"#ifdef GAMMA_INPUT\",\r\n\r\n\t\t\t\t\t\t\"cubeColor.xyz *= cubeColor.xyz;\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\t\"gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * uReflectivity );\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"attribute vec4 tangent;\",\r\n\r\n\t\t\t\"uniform vec2 uOffset;\",\r\n\t\t\t\"uniform vec2 uRepeat;\",\r\n\r\n\t\t\t\"uniform bool enableDisplacement;\",\r\n\r\n\t\t\t\"#ifdef VERTEX_TEXTURES\",\r\n\r\n\t\t\t\t\"uniform sampler2D tDisplacement;\",\r\n\t\t\t\t\"uniform float uDisplacementScale;\",\r\n\t\t\t\t\"uniform float uDisplacementBias;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"varying vec3 vTangent;\",\r\n\t\t\t\"varying vec3 vBinormal;\",\r\n\t\t\t\"varying vec3 vNormal;\",\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"varying vec3 vWorldPosition;\",\r\n\t\t\t\"varying vec3 vViewPosition;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\r\n\r\n\t\t\t\t// normal, tangent and binormal vectors\r\n\r\n\t\t\t\t\"#ifdef USE_SKINNING\",\r\n\r\n\t\t\t\t\t\"vNormal = normalize( normalMatrix * skinnedNormal.xyz );\",\r\n\r\n\t\t\t\t\t\"vec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );\",\r\n\t\t\t\t\t\"vTangent = normalize( normalMatrix * skinnedTangent.xyz );\",\r\n\r\n\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\"vNormal = normalize( normalMatrix * normal );\",\r\n\t\t\t\t\t\"vTangent = normalize( normalMatrix * tangent.xyz );\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"vBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );\",\r\n\r\n\t\t\t\t\"vUv = uv * uRepeat + uOffset;\",\r\n\r\n\t\t\t\t// displacement mapping\r\n\r\n\t\t\t\t\"vec3 displacedPosition;\",\r\n\r\n\t\t\t\t\"#ifdef VERTEX_TEXTURES\",\r\n\r\n\t\t\t\t\t\"if ( enableDisplacement ) {\",\r\n\r\n\t\t\t\t\t\t\"vec3 dv = texture2D( tDisplacement, uv ).xyz;\",\r\n\t\t\t\t\t\t\"float df = uDisplacementScale * dv.x + uDisplacementBias;\",\r\n\t\t\t\t\t\t\"displacedPosition = position + normalize( normal ) * df;\",\r\n\r\n\t\t\t\t\t\"} else {\",\r\n\r\n\t\t\t\t\t\t\"#ifdef USE_SKINNING\",\r\n\r\n\t\t\t\t\t\t\t\"vec4 skinVertex = vec4( position, 1.0 );\",\r\n\r\n\t\t\t\t\t\t\t\"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;\",\r\n\t\t\t\t\t\t\t\"skinned \t  += boneMatY * skinVertex * skinWeight.y;\",\r\n\r\n\t\t\t\t\t\t\t\"displacedPosition  = skinned.xyz;\",\r\n\r\n\t\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\t\"displacedPosition = position;\",\r\n\r\n\t\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\"#ifdef USE_SKINNING\",\r\n\r\n\t\t\t\t\t\t\"vec4 skinVertex = vec4( position, 1.0 );\",\r\n\r\n\t\t\t\t\t\t\"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;\",\r\n\t\t\t\t\t\t\"skinned \t  += boneMatY * skinVertex * skinWeight.y;\",\r\n\r\n\t\t\t\t\t\t\"displacedPosition  = skinned.xyz;\",\r\n\r\n\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\"displacedPosition = position;\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t//\r\n\r\n\t\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );\",\r\n\t\t\t\t\"vec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );\",\r\n\r\n\t\t\t\t\"gl_Position = projectionMatrix * mvPosition;\",\r\n\r\n\t\t\t\t//\r\n\r\n\t\t\t\t\"vWorldPosition = worldPosition.xyz;\",\r\n\t\t\t\t\"vViewPosition = -mvPosition.xyz;\",\r\n\r\n\t\t\t\t// shadows\r\n\r\n\t\t\t\t\"#ifdef USE_SHADOWMAP\",\r\n\r\n\t\t\t\t\t\"for( int i = 0; i < MAX_SHADOWS; i ++ ) {\",\r\n\r\n\t\t\t\t\t\t\"vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\",\r\n\r\n\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t/* -------------------------------------------------------------------------\r\n\t//\tCube map shader\r\n\t ------------------------------------------------------------------------- */\r\n\r\n\t'cube': {\r\n\r\n\t\tuniforms: { \"tCube\": { type: \"t\", value: null },\r\n\t\t\t\t\t\"tFlip\": { type: \"f\", value: -1 } },\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec3 vWorldPosition;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\",\r\n\t\t\t\t\"vWorldPosition = worldPosition.xyz;\",\r\n\r\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform samplerCube tCube;\",\r\n\t\t\t\"uniform float tFlip;\",\r\n\r\n\t\t\t\"varying vec3 vWorldPosition;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t// Depth encoding into RGBA texture\r\n\t// \tbased on SpiderGL shadow map example\r\n\t// \t\thttp://spidergl.org/example.php?id=6\r\n\t// \toriginally from\r\n\t//\t\thttp://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD\r\n\t// \tsee also here:\r\n\t//\t\thttp://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\r\n\r\n\t'depthRGBA': {\r\n\r\n\t\tuniforms: {},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"vec4 pack_depth( const in float depth ) {\",\r\n\r\n\t\t\t\t\"const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\",\r\n\t\t\t\t\"const vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\",\r\n\t\t\t\t\"vec4 res = fract( depth * bit_shift );\",\r\n\t\t\t\t\"res -= res.xxyz * bit_mask;\",\r\n\t\t\t\t\"return res;\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\",\r\n\r\n\t\t\t\t//\"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );\",\r\n\t\t\t\t//\"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );\",\r\n\t\t\t\t//\"gl_FragData[ 0 ] = pack_depth( z );\",\r\n\t\t\t\t//\"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t}\r\n\r\n};\r\n/**\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author szimek / https://github.com/szimek/\r\n */\r\n\r\nTHREE.WebGLRenderer = function ( parameters ) {\r\n\r\n\tconsole.log( 'THREE.WebGLRenderer', THREE.REVISION );\r\n\r\n\tparameters = parameters || {};\r\n\r\n\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),\r\n\r\n\t_precision = parameters.precision !== undefined ? parameters.precision : 'highp',\r\n\r\n\t_alpha = parameters.alpha !== undefined ? parameters.alpha : true,\r\n\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\r\n\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\r\n\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\r\n\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,\r\n\r\n\t_clearColor = parameters.clearColor !== undefined ? new THREE.Color( parameters.clearColor ) : new THREE.Color( 0x000000 ),\r\n\t_clearAlpha = parameters.clearAlpha !== undefined ? parameters.clearAlpha : 0;\r\n\r\n\t// public properties\r\n\r\n\tthis.domElement = _canvas;\r\n\tthis.context = null;\r\n\tthis.devicePixelRatio = parameters.devicePixelRatio !== undefined\r\n\t\t\t\t? parameters.devicePixelRatio\r\n\t\t\t\t: window.devicePixelRatio !== undefined\r\n\t\t\t\t\t? window.devicePixelRatio\r\n\t\t\t\t\t: 1;\r\n\r\n\t// clearing\r\n\r\n\tthis.autoClear = true;\r\n\tthis.autoClearColor = true;\r\n\tthis.autoClearDepth = true;\r\n\tthis.autoClearStencil = true;\r\n\r\n\t// scene graph\r\n\r\n\tthis.sortObjects = true;\r\n\r\n\tthis.autoUpdateObjects = true;\r\n\tthis.autoUpdateScene = true;\r\n\r\n\t// physically based shading\r\n\r\n\tthis.gammaInput = false;\r\n\tthis.gammaOutput = false;\r\n\tthis.physicallyBasedShading = false;\r\n\r\n\t// shadow map\r\n\r\n\tthis.shadowMapEnabled = false;\r\n\tthis.shadowMapAutoUpdate = true;\r\n\tthis.shadowMapType = THREE.PCFShadowMap;\r\n\tthis.shadowMapCullFace = THREE.CullFaceFront;\r\n\tthis.shadowMapDebug = false;\r\n\tthis.shadowMapCascade = false;\r\n\r\n\t// morphs\r\n\r\n\tthis.maxMorphTargets = 8;\r\n\tthis.maxMorphNormals = 4;\r\n\r\n\t// flags\r\n\r\n\tthis.autoScaleCubemaps = true;\r\n\r\n\t// custom render plugins\r\n\r\n\tthis.renderPluginsPre = [];\r\n\tthis.renderPluginsPost = [];\r\n\r\n\t// info\r\n\r\n\tthis.info = {\r\n\r\n\t\tmemory: {\r\n\r\n\t\t\tprograms: 0,\r\n\t\t\tgeometries: 0,\r\n\t\t\ttextures: 0\r\n\r\n\t\t},\r\n\r\n\t\trender: {\r\n\r\n\t\t\tcalls: 0,\r\n\t\t\tvertices: 0,\r\n\t\t\tfaces: 0,\r\n\t\t\tpoints: 0\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// internal properties\r\n\r\n\tvar _this = this,\r\n\r\n\t_programs = [],\r\n\t_programs_counter = 0,\r\n\r\n\t// internal state cache\r\n\r\n\t_currentProgram = null,\r\n\t_currentFramebuffer = null,\r\n\t_currentMaterialId = -1,\r\n\t_currentGeometryGroupHash = null,\r\n\t_currentCamera = null,\r\n\t_geometryGroupCounter = 0,\r\n\r\n\t_usedTextureUnits = 0,\r\n\r\n\t// GL state cache\r\n\r\n\t_oldDoubleSided = -1,\r\n\t_oldFlipSided = -1,\r\n\r\n\t_oldBlending = -1,\r\n\r\n\t_oldBlendEquation = -1,\r\n\t_oldBlendSrc = -1,\r\n\t_oldBlendDst = -1,\r\n\r\n\t_oldDepthTest = -1,\r\n\t_oldDepthWrite = -1,\r\n\r\n\t_oldPolygonOffset = null,\r\n\t_oldPolygonOffsetFactor = null,\r\n\t_oldPolygonOffsetUnits = null,\r\n\r\n\t_oldLineWidth = null,\r\n\r\n\t_viewportX = 0,\r\n\t_viewportY = 0,\r\n\t_viewportWidth = 0,\r\n\t_viewportHeight = 0,\r\n\t_currentWidth = 0,\r\n\t_currentHeight = 0,\r\n\r\n\t_enabledAttributes = {},\r\n\r\n\t// frustum\r\n\r\n\t_frustum = new THREE.Frustum(),\r\n\r\n\t // camera matrices cache\r\n\r\n\t_projScreenMatrix = new THREE.Matrix4(),\r\n\t_projScreenMatrixPS = new THREE.Matrix4(),\r\n\r\n\t_vector3 = new THREE.Vector3(),\r\n\r\n\t// light arrays cache\r\n\r\n\t_direction = new THREE.Vector3(),\r\n\r\n\t_lightsNeedUpdate = true,\r\n\r\n\t_lights = {\r\n\r\n\t\tambient: [ 0, 0, 0 ],\r\n\t\tdirectional: { length: 0, colors: new Array(), positions: new Array() },\r\n\t\tpoint: { length: 0, colors: new Array(), positions: new Array(), distances: new Array() },\r\n\t\tspot: { length: 0, colors: new Array(), positions: new Array(), distances: new Array(), directions: new Array(), anglesCos: new Array(), exponents: new Array() },\r\n\t\themi: { length: 0, skyColors: new Array(), groundColors: new Array(), positions: new Array() }\r\n\r\n\t};\r\n\r\n\t// initialize\r\n\r\n\tvar _gl;\r\n\r\n\tvar _glExtensionTextureFloat;\r\n\tvar _glExtensionStandardDerivatives;\r\n\tvar _glExtensionTextureFilterAnisotropic;\r\n\tvar _glExtensionCompressedTextureS3TC;\r\n\r\n\tinitGL();\r\n\r\n\tsetDefaultGLState();\r\n\r\n\tthis.context = _gl;\r\n\r\n\t// GPU capabilities\r\n\r\n\tvar _maxTextures = _gl.getParameter( _gl.MAX_TEXTURE_IMAGE_UNITS );\r\n\tvar _maxVertexTextures = _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\r\n\tvar _maxTextureSize = _gl.getParameter( _gl.MAX_TEXTURE_SIZE );\r\n\tvar _maxCubemapSize = _gl.getParameter( _gl.MAX_CUBE_MAP_TEXTURE_SIZE );\r\n\r\n\tvar _maxAnisotropy = _glExtensionTextureFilterAnisotropic ? _gl.getParameter( _glExtensionTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT ) : 0;\r\n\r\n\tvar _supportsVertexTextures = ( _maxVertexTextures > 0 );\r\n\tvar _supportsBoneTextures = _supportsVertexTextures && _glExtensionTextureFloat;\r\n\r\n\tvar _compressedTextureFormats = _glExtensionCompressedTextureS3TC ? _gl.getParameter( _gl.COMPRESSED_TEXTURE_FORMATS ) : [];\r\n\r\n\t//\r\n\r\n\tvar _vertexShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_FLOAT );\r\n\tvar _vertexShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_FLOAT );\r\n\tvar _vertexShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.LOW_FLOAT );\r\n\r\n\tvar _fragmentShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_FLOAT );\r\n\tvar _fragmentShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_FLOAT );\r\n\tvar _fragmentShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.LOW_FLOAT );\r\n\r\n\tvar _vertexShaderPrecisionHighpInt = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_INT );\r\n\tvar _vertexShaderPrecisionMediumpInt = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_INT );\r\n\tvar _vertexShaderPrecisionLowpInt = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.LOW_INT );\r\n\r\n\tvar _fragmentShaderPrecisionHighpInt = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_INT );\r\n\tvar _fragmentShaderPrecisionMediumpInt = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_INT );\r\n\tvar _fragmentShaderPrecisionLowpInt = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.LOW_INT );\r\n\r\n\t// clamp precision to maximum available\r\n\r\n\tvar highpAvailable = _vertexShaderPrecisionHighpFloat.precision > 0 && _fragmentShaderPrecisionHighpFloat.precision > 0;\r\n\tvar mediumpAvailable = _vertexShaderPrecisionMediumpFloat.precision > 0 && _fragmentShaderPrecisionMediumpFloat.precision > 0;\r\n\r\n\tif ( _precision === \"highp\" && ! highpAvailable ) {\r\n\r\n\t\tif ( mediumpAvailable ) {\r\n\r\n\t\t\t_precision = \"mediump\";\r\n\t\t\tconsole.warn( \"WebGLRenderer: highp not supported, using mediump\" );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_precision = \"lowp\";\r\n\t\t\tconsole.warn( \"WebGLRenderer: highp and mediump not supported, using lowp\" );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tif ( _precision === \"mediump\" && ! mediumpAvailable ) {\r\n\r\n\t\t_precision = \"lowp\";\r\n\t\tconsole.warn( \"WebGLRenderer: mediump not supported, using lowp\" );\r\n\r\n\t}\r\n\r\n\t// API\r\n\r\n\tthis.getContext = function () {\r\n\r\n\t\treturn _gl;\r\n\r\n\t};\r\n\r\n\tthis.supportsVertexTextures = function () {\r\n\r\n\t\treturn _supportsVertexTextures;\r\n\r\n\t};\r\n\r\n\tthis.supportsFloatTextures = function () {\r\n\r\n\t\treturn _glExtensionTextureFloat;\r\n\r\n\t};\r\n\t\r\n\tthis.supportsStandardDerivatives = function () {\r\n\r\n\t\treturn _glExtensionStandardDerivatives;\r\n\r\n\t};\r\n\t\r\n\tthis.supportsCompressedTextureS3TC = function () {\r\n\r\n\t\treturn _glExtensionCompressedTextureS3TC;\r\n\r\n\t};\r\n\t\r\n\tthis.getMaxAnisotropy  = function () {\r\n\r\n\t\treturn _maxAnisotropy;\r\n\r\n\t};\r\n\r\n\tthis.getPrecision = function () {\r\n\r\n\t\treturn _precision;\r\n\r\n\t};\r\n\r\n\tthis.setSize = function ( width, height ) {\r\n\r\n\t\t_canvas.width = width * this.devicePixelRatio;\r\n\t\t_canvas.height = height * this.devicePixelRatio;\r\n\r\n\t\t_canvas.style.width = width + 'px';\r\n\t\t_canvas.style.height = height + 'px';\r\n\r\n\t\tthis.setViewport( 0, 0, _canvas.width, _canvas.height );\r\n\r\n\t};\r\n\r\n\tthis.setViewport = function ( x, y, width, height ) {\r\n\r\n\t\t_viewportX = x !== undefined ? x : 0;\r\n\t\t_viewportY = y !== undefined ? y : 0;\r\n\r\n\t\t_viewportWidth = width !== undefined ? width : _canvas.width;\r\n\t\t_viewportHeight = height !== undefined ? height : _canvas.height;\r\n\r\n\t\t_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );\r\n\r\n\t};\r\n\r\n\tthis.setScissor = function ( x, y, width, height ) {\r\n\r\n\t\t_gl.scissor( x, y, width, height );\r\n\r\n\t};\r\n\r\n\tthis.enableScissorTest = function ( enable ) {\r\n\r\n\t\tenable ? _gl.enable( _gl.SCISSOR_TEST ) : _gl.disable( _gl.SCISSOR_TEST );\r\n\r\n\t};\r\n\r\n\t// Clearing\r\n\r\n\tthis.setClearColorHex = function ( hex, alpha ) {\r\n\r\n\t\t_clearColor.setHex( hex );\r\n\t\t_clearAlpha = alpha;\r\n\r\n\t\t_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\r\n\t};\r\n\r\n\tthis.setClearColor = function ( color, alpha ) {\r\n\r\n\t\t_clearColor.copy( color );\r\n\t\t_clearAlpha = alpha;\r\n\r\n\t\t_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\r\n\t};\r\n\r\n\tthis.getClearColor = function () {\r\n\r\n\t\treturn _clearColor;\r\n\r\n\t};\r\n\r\n\tthis.getClearAlpha = function () {\r\n\r\n\t\treturn _clearAlpha;\r\n\r\n\t};\r\n\r\n\tthis.clear = function ( color, depth, stencil ) {\r\n\r\n\t\tvar bits = 0;\r\n\r\n\t\tif ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\r\n\t\tif ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\r\n\t\tif ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\r\n\r\n\t\t_gl.clear( bits );\r\n\r\n\t};\r\n\r\n\tthis.clearTarget = function ( renderTarget, color, depth, stencil ) {\r\n\r\n\t\tthis.setRenderTarget( renderTarget );\r\n\t\tthis.clear( color, depth, stencil );\r\n\r\n\t};\r\n\r\n\t// Plugins\r\n\r\n\tthis.addPostPlugin = function ( plugin ) {\r\n\r\n\t\tplugin.init( this );\r\n\t\tthis.renderPluginsPost.push( plugin );\r\n\r\n\t};\r\n\r\n\tthis.addPrePlugin = function ( plugin ) {\r\n\r\n\t\tplugin.init( this );\r\n\t\tthis.renderPluginsPre.push( plugin );\r\n\r\n\t};\r\n\r\n\t// Rendering\r\n\r\n\tthis.updateShadowMap = function ( scene, camera ) {\r\n\r\n\t\t_currentProgram = null;\r\n\t\t_oldBlending = -1;\r\n\t\t_oldDepthTest = -1;\r\n\t\t_oldDepthWrite = -1;\r\n\t\t_currentGeometryGroupHash = -1;\r\n\t\t_currentMaterialId = -1;\r\n\t\t_lightsNeedUpdate = true;\r\n\t\t_oldDoubleSided = -1;\r\n\t\t_oldFlipSided = -1;\r\n\r\n\t\tthis.shadowMapPlugin.update( scene, camera );\r\n\r\n\t};\r\n\r\n\t// Internal functions\r\n\r\n\t// Buffer allocation\r\n\r\n\tfunction createParticleBuffers ( geometry ) {\r\n\r\n\t\tgeometry.__webglVertexBuffer = _gl.createBuffer();\r\n\t\tgeometry.__webglColorBuffer = _gl.createBuffer();\r\n\r\n\t\t_this.info.memory.geometries ++;\r\n\r\n\t};\r\n\r\n\tfunction createLineBuffers ( geometry ) {\r\n\r\n\t\tgeometry.__webglVertexBuffer = _gl.createBuffer();\r\n\t\tgeometry.__webglColorBuffer = _gl.createBuffer();\r\n\t\tgeometry.__webglLineDistanceBuffer = _gl.createBuffer();\r\n\r\n\t\t_this.info.memory.geometries ++;\r\n\r\n\t};\r\n\r\n\tfunction createRibbonBuffers ( geometry ) {\r\n\r\n\t\tgeometry.__webglVertexBuffer = _gl.createBuffer();\r\n\t\tgeometry.__webglColorBuffer = _gl.createBuffer();\r\n\t\tgeometry.__webglNormalBuffer = _gl.createBuffer();\r\n\r\n\t\t_this.info.memory.geometries ++;\r\n\r\n\t};\r\n\r\n\tfunction createMeshBuffers ( geometryGroup ) {\r\n\r\n\t\tgeometryGroup.__webglVertexBuffer = _gl.createBuffer();\r\n\t\tgeometryGroup.__webglNormalBuffer = _gl.createBuffer();\r\n\t\tgeometryGroup.__webglTangentBuffer = _gl.createBuffer();\r\n\t\tgeometryGroup.__webglColorBuffer = _gl.createBuffer();\r\n\t\tgeometryGroup.__webglUVBuffer = _gl.createBuffer();\r\n\t\tgeometryGroup.__webglUV2Buffer = _gl.createBuffer();\r\n\r\n\t\tgeometryGroup.__webglSkinIndicesBuffer = _gl.createBuffer();\r\n\t\tgeometryGroup.__webglSkinWeightsBuffer = _gl.createBuffer();\r\n\r\n\t\tgeometryGroup.__webglFaceBuffer = _gl.createBuffer();\r\n\t\tgeometryGroup.__webglLineBuffer = _gl.createBuffer();\r\n\r\n\t\tvar m, ml;\r\n\r\n\t\tif ( geometryGroup.numMorphTargets ) {\r\n\r\n\t\t\tgeometryGroup.__webglMorphTargetsBuffers = [];\r\n\r\n\t\t\tfor ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {\r\n\r\n\t\t\t\tgeometryGroup.__webglMorphTargetsBuffers.push( _gl.createBuffer() );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometryGroup.numMorphNormals ) {\r\n\r\n\t\t\tgeometryGroup.__webglMorphNormalsBuffers = [];\r\n\r\n\t\t\tfor ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {\r\n\r\n\t\t\t\tgeometryGroup.__webglMorphNormalsBuffers.push( _gl.createBuffer() );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t_this.info.memory.geometries ++;\r\n\r\n\t};\r\n\r\n\t// Events\r\n\r\n\tvar onGeometryDispose = function ( event ) {\r\n\r\n\t\tvar geometry = event.target;\r\n\r\n\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\r\n\r\n\t\tdeallocateGeometry( geometry );\r\n\r\n\t\t_this.info.memory.geometries --;\r\n\r\n\t};\r\n\r\n\tvar onTextureDispose = function ( event ) {\r\n\r\n\t\tvar texture = event.target;\r\n\r\n\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\r\n\r\n\t\tdeallocateTexture( texture );\r\n\r\n\t\t_this.info.memory.textures --;\r\n\r\n\r\n\t};\r\n\r\n\tvar onRenderTargetDispose = function ( event ) {\r\n\r\n\t\tvar renderTarget = event.target;\r\n\r\n\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\r\n\r\n\t\tdeallocateRenderTarget( renderTarget );\r\n\r\n\t\t_this.info.memory.textures --;\r\n\r\n\t};\r\n\r\n\tvar onMaterialDispose = function ( event ) {\r\n\r\n\t\tvar material = event.target;\r\n\r\n\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\r\n\r\n\t\tdeallocateMaterial( material );\r\n\r\n\t};\r\n\r\n\t// Buffer deallocation\r\n\r\n\tvar deallocateGeometry = function ( geometry ) {\r\n\r\n\t\tgeometry.__webglInit = undefined;\r\n\r\n\t\tif ( geometry.__webglVertexBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglVertexBuffer );\r\n\t\tif ( geometry.__webglNormalBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglNormalBuffer );\r\n\t\tif ( geometry.__webglTangentBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglTangentBuffer );\r\n\t\tif ( geometry.__webglColorBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglColorBuffer );\r\n\t\tif ( geometry.__webglUVBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglUVBuffer );\r\n\t\tif ( geometry.__webglUV2Buffer !== undefined ) _gl.deleteBuffer( geometry.__webglUV2Buffer );\r\n\r\n\t\tif ( geometry.__webglSkinIndicesBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglSkinIndicesBuffer );\r\n\t\tif ( geometry.__webglSkinWeightsBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglSkinWeightsBuffer );\r\n\r\n\t\tif ( geometry.__webglFaceBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglFaceBuffer );\r\n\t\tif ( geometry.__webglLineBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglLineBuffer );\r\n\r\n\t\tif ( geometry.__webglLineDistanceBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglLineDistanceBuffer );\r\n\r\n\t\t// geometry groups\r\n\r\n\t\tif ( geometry.geometryGroups !== undefined ) {\r\n\r\n\t\t\tfor ( var g in geometry.geometryGroups ) {\r\n\r\n\t\t\t\tvar geometryGroup = geometry.geometryGroups[ g ];\r\n\r\n\t\t\t\tif ( geometryGroup.numMorphTargets !== undefined ) {\r\n\r\n\t\t\t\t\tfor ( var m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {\r\n\r\n\t\t\t\t\t\t_gl.deleteBuffer( geometryGroup.__webglMorphTargetsBuffers[ m ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( geometryGroup.numMorphNormals !== undefined ) {\r\n\r\n\t\t\t\t\tfor ( var m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {\r\n\r\n\t\t\t\t\t\t_gl.deleteBuffer( geometryGroup.__webglMorphNormalsBuffers[ m ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdeleteCustomAttributesBuffers( geometryGroup );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tdeleteCustomAttributesBuffers( geometry );\r\n\r\n\t};\r\n\r\n\tvar deallocateTexture = function ( texture ) {\r\n\r\n\t\tif ( texture.image && texture.image.__webglTextureCube ) {\r\n\r\n\t\t\t// cube texture\r\n\r\n\t\t\t_gl.deleteTexture( texture.image.__webglTextureCube );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// 2D texture\r\n\r\n\t\t\tif ( ! texture.__webglInit ) return;\r\n\r\n\t\t\ttexture.__webglInit = false;\r\n\t\t\t_gl.deleteTexture( texture.__webglTexture );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar deallocateRenderTarget = function ( renderTarget ) {\r\n\r\n\t\tif ( !renderTarget || ! renderTarget.__webglTexture ) return;\r\n\r\n\t\t_gl.deleteTexture( renderTarget.__webglTexture );\r\n\r\n\t\tif ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {\r\n\r\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\t_gl.deleteFramebuffer( renderTarget.__webglFramebuffer[ i ] );\r\n\t\t\t\t_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_gl.deleteFramebuffer( renderTarget.__webglFramebuffer );\r\n\t\t\t_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar deallocateMaterial = function ( material ) {\r\n\r\n\t\tvar program = material.program;\r\n\r\n\t\tif ( program === undefined ) return;\r\n\r\n\t\tmaterial.program = undefined;\r\n\r\n\t\t// only deallocate GL program if this was the last use of shared program\r\n\t\t// assumed there is only single copy of any program in the _programs list\r\n\t\t// (that's how it's constructed)\r\n\r\n\t\tvar i, il, programInfo;\r\n\t\tvar deleteProgram = false;\r\n\r\n\t\tfor ( i = 0, il = _programs.length; i < il; i ++ ) {\r\n\r\n\t\t\tprogramInfo = _programs[ i ];\r\n\r\n\t\t\tif ( programInfo.program === program ) {\r\n\r\n\t\t\t\tprogramInfo.usedTimes --;\r\n\r\n\t\t\t\tif ( programInfo.usedTimes === 0 ) {\r\n\r\n\t\t\t\t\tdeleteProgram = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( deleteProgram === true ) {\r\n\r\n\t\t\t// avoid using array.splice, this is costlier than creating new array from scratch\r\n\r\n\t\t\tvar newPrograms = [];\r\n\r\n\t\t\tfor ( i = 0, il = _programs.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tprogramInfo = _programs[ i ];\r\n\r\n\t\t\t\tif ( programInfo.program !== program ) {\r\n\r\n\t\t\t\t\tnewPrograms.push( programInfo );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_programs = newPrograms;\r\n\r\n\t\t\t_gl.deleteProgram( program );\r\n\r\n\t\t\t_this.info.memory.programs --;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t//\r\n\r\n\t/*\r\n\tfunction deleteParticleBuffers ( geometry ) {\r\n\r\n\t\t_gl.deleteBuffer( geometry.__webglVertexBuffer );\r\n\t\t_gl.deleteBuffer( geometry.__webglColorBuffer );\r\n\r\n\t\tdeleteCustomAttributesBuffers( geometry );\r\n\r\n\t\t_this.info.memory.geometries --;\r\n\r\n\t};\r\n\r\n\tfunction deleteLineBuffers ( geometry ) {\r\n\r\n\t\t_gl.deleteBuffer( geometry.__webglVertexBuffer );\r\n\t\t_gl.deleteBuffer( geometry.__webglColorBuffer );\r\n\t\t_gl.deleteBuffer( geometry.__webglLineDistanceBuffer );\r\n\r\n\t\tdeleteCustomAttributesBuffers( geometry );\r\n\r\n\t\t_this.info.memory.geometries --;\r\n\r\n\t};\r\n\r\n\tfunction deleteRibbonBuffers ( geometry ) {\r\n\r\n\t\t_gl.deleteBuffer( geometry.__webglVertexBuffer );\r\n\t\t_gl.deleteBuffer( geometry.__webglColorBuffer );\r\n\t\t_gl.deleteBuffer( geometry.__webglNormalBuffer );\r\n\r\n\t\tdeleteCustomAttributesBuffers( geometry );\r\n\r\n\t\t_this.info.memory.geometries --;\r\n\r\n\t};\r\n\r\n\tfunction deleteMeshBuffers ( geometryGroup ) {\r\n\r\n\t\t_gl.deleteBuffer( geometryGroup.__webglVertexBuffer );\r\n\t\t_gl.deleteBuffer( geometryGroup.__webglNormalBuffer );\r\n\t\t_gl.deleteBuffer( geometryGroup.__webglTangentBuffer );\r\n\t\t_gl.deleteBuffer( geometryGroup.__webglColorBuffer );\r\n\t\t_gl.deleteBuffer( geometryGroup.__webglUVBuffer );\r\n\t\t_gl.deleteBuffer( geometryGroup.__webglUV2Buffer );\r\n\r\n\t\t_gl.deleteBuffer( geometryGroup.__webglSkinIndicesBuffer );\r\n\t\t_gl.deleteBuffer( geometryGroup.__webglSkinWeightsBuffer );\r\n\r\n\t\t_gl.deleteBuffer( geometryGroup.__webglFaceBuffer );\r\n\t\t_gl.deleteBuffer( geometryGroup.__webglLineBuffer );\r\n\r\n\t\tvar m, ml;\r\n\r\n\t\tif ( geometryGroup.numMorphTargets ) {\r\n\r\n\t\t\tfor ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {\r\n\r\n\t\t\t\t_gl.deleteBuffer( geometryGroup.__webglMorphTargetsBuffers[ m ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometryGroup.numMorphNormals ) {\r\n\r\n\t\t\tfor ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {\r\n\r\n\t\t\t\t_gl.deleteBuffer( geometryGroup.__webglMorphNormalsBuffers[ m ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tdeleteCustomAttributesBuffers( geometryGroup );\r\n\r\n\t\t_this.info.memory.geometries --;\r\n\r\n\t};\r\n\t*/\r\n\r\n\tfunction deleteCustomAttributesBuffers( geometry ) {\r\n\r\n\t\tif ( geometry.__webglCustomAttributesList ) {\r\n\r\n\t\t\tfor ( var id in geometry.__webglCustomAttributesList ) {\r\n\r\n\t\t\t\t_gl.deleteBuffer( geometry.__webglCustomAttributesList[ id ].buffer );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Buffer initialization\r\n\r\n\tfunction initCustomAttributes ( geometry, object ) {\r\n\r\n\t\tvar nvertices = geometry.vertices.length;\r\n\r\n\t\tvar material = object.material;\r\n\r\n\t\tif ( material.attributes ) {\r\n\r\n\t\t\tif ( geometry.__webglCustomAttributesList === undefined ) {\r\n\r\n\t\t\t\tgeometry.__webglCustomAttributesList = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var a in material.attributes ) {\r\n\r\n\t\t\t\tvar attribute = material.attributes[ a ];\r\n\r\n\t\t\t\tif ( !attribute.__webglInitialized || attribute.createUniqueBuffers ) {\r\n\r\n\t\t\t\t\tattribute.__webglInitialized = true;\r\n\r\n\t\t\t\t\tvar size = 1;\t\t// \"f\" and \"i\"\r\n\r\n\t\t\t\t\tif ( attribute.type === \"v2\" ) size = 2;\r\n\t\t\t\t\telse if ( attribute.type === \"v3\" ) size = 3;\r\n\t\t\t\t\telse if ( attribute.type === \"v4\" ) size = 4;\r\n\t\t\t\t\telse if ( attribute.type === \"c\"  ) size = 3;\r\n\r\n\t\t\t\t\tattribute.size = size;\r\n\r\n\t\t\t\t\tattribute.array = new Float32Array( nvertices * size );\r\n\r\n\t\t\t\t\tattribute.buffer = _gl.createBuffer();\r\n\t\t\t\t\tattribute.buffer.belongsToAttribute = a;\r\n\r\n\t\t\t\t\tattribute.needsUpdate = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.__webglCustomAttributesList.push( attribute );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction initParticleBuffers ( geometry, object ) {\r\n\r\n\t\tvar nvertices = geometry.vertices.length;\r\n\r\n\t\tgeometry.__vertexArray = new Float32Array( nvertices * 3 );\r\n\t\tgeometry.__colorArray = new Float32Array( nvertices * 3 );\r\n\r\n\t\tgeometry.__sortArray = [];\r\n\r\n\t\tgeometry.__webglParticleCount = nvertices;\r\n\r\n\t\tinitCustomAttributes ( geometry, object );\r\n\r\n\t};\r\n\r\n\tfunction initLineBuffers ( geometry, object ) {\r\n\r\n\t\tvar nvertices = geometry.vertices.length;\r\n\r\n\t\tgeometry.__vertexArray = new Float32Array( nvertices * 3 );\r\n\t\tgeometry.__colorArray = new Float32Array( nvertices * 3 );\r\n\t\tgeometry.__lineDistanceArray = new Float32Array( nvertices * 1 );\r\n\r\n\t\tgeometry.__webglLineCount = nvertices;\r\n\r\n\t\tinitCustomAttributes ( geometry, object );\r\n\r\n\t};\r\n\r\n\tfunction initRibbonBuffers ( geometry, object ) {\r\n\r\n\t\tvar nvertices = geometry.vertices.length;\r\n\r\n\t\tgeometry.__vertexArray = new Float32Array( nvertices * 3 );\r\n\t\tgeometry.__colorArray = new Float32Array( nvertices * 3 );\r\n\t\tgeometry.__normalArray = new Float32Array( nvertices * 3 );\r\n\r\n\t\tgeometry.__webglVertexCount = nvertices;\r\n\r\n\t\tinitCustomAttributes ( geometry, object );\r\n\r\n\t};\r\n\r\n\tfunction initMeshBuffers ( geometryGroup, object ) {\r\n\r\n\t\tvar geometry = object.geometry,\r\n\t\t\tfaces3 = geometryGroup.faces3,\r\n\t\t\tfaces4 = geometryGroup.faces4,\r\n\r\n\t\t\tnvertices = faces3.length * 3 + faces4.length * 4,\r\n\t\t\tntris     = faces3.length * 1 + faces4.length * 2,\r\n\t\t\tnlines    = faces3.length * 3 + faces4.length * 4,\r\n\r\n\t\t\tmaterial = getBufferMaterial( object, geometryGroup ),\r\n\r\n\t\t\tuvType = bufferGuessUVType( material ),\r\n\t\t\tnormalType = bufferGuessNormalType( material ),\r\n\t\t\tvertexColorType = bufferGuessVertexColorType( material );\r\n\r\n\t\t//console.log( \"uvType\", uvType, \"normalType\", normalType, \"vertexColorType\", vertexColorType, object, geometryGroup, material );\r\n\r\n\t\tgeometryGroup.__vertexArray = new Float32Array( nvertices * 3 );\r\n\r\n\t\tif ( normalType ) {\r\n\r\n\t\t\tgeometryGroup.__normalArray = new Float32Array( nvertices * 3 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.hasTangents ) {\r\n\r\n\t\t\tgeometryGroup.__tangentArray = new Float32Array( nvertices * 4 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( vertexColorType ) {\r\n\r\n\t\t\tgeometryGroup.__colorArray = new Float32Array( nvertices * 3 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( uvType ) {\r\n\r\n\t\t\tif ( geometry.faceUvs.length > 0 || geometry.faceVertexUvs.length > 0 ) {\r\n\r\n\t\t\t\tgeometryGroup.__uvArray = new Float32Array( nvertices * 2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( geometry.faceUvs.length > 1 || geometry.faceVertexUvs.length > 1 ) {\r\n\r\n\t\t\t\tgeometryGroup.__uv2Array = new Float32Array( nvertices * 2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.geometry.skinWeights.length && object.geometry.skinIndices.length ) {\r\n\r\n\t\t\tgeometryGroup.__skinIndexArray = new Float32Array( nvertices * 4 );\r\n\t\t\tgeometryGroup.__skinWeightArray = new Float32Array( nvertices * 4 );\r\n\r\n\t\t}\r\n\r\n\t\tgeometryGroup.__faceArray = new Uint16Array( ntris * 3 );\r\n\t\tgeometryGroup.__lineArray = new Uint16Array( nlines * 2 );\r\n\r\n\t\tvar m, ml;\r\n\r\n\t\tif ( geometryGroup.numMorphTargets ) {\r\n\r\n\t\t\tgeometryGroup.__morphTargetsArrays = [];\r\n\r\n\t\t\tfor ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {\r\n\r\n\t\t\t\tgeometryGroup.__morphTargetsArrays.push( new Float32Array( nvertices * 3 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometryGroup.numMorphNormals ) {\r\n\r\n\t\t\tgeometryGroup.__morphNormalsArrays = [];\r\n\r\n\t\t\tfor ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {\r\n\r\n\t\t\t\tgeometryGroup.__morphNormalsArrays.push( new Float32Array( nvertices * 3 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tgeometryGroup.__webglFaceCount = ntris * 3;\r\n\t\tgeometryGroup.__webglLineCount = nlines * 2;\r\n\r\n\r\n\t\t// custom attributes\r\n\r\n\t\tif ( material.attributes ) {\r\n\r\n\t\t\tif ( geometryGroup.__webglCustomAttributesList === undefined ) {\r\n\r\n\t\t\t\tgeometryGroup.__webglCustomAttributesList = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var a in material.attributes ) {\r\n\r\n\t\t\t\t// Do a shallow copy of the attribute object so different geometryGroup chunks use different\r\n\t\t\t\t// attribute buffers which are correctly indexed in the setMeshBuffers function\r\n\r\n\t\t\t\tvar originalAttribute = material.attributes[ a ];\r\n\r\n\t\t\t\tvar attribute = {};\r\n\r\n\t\t\t\tfor ( var property in originalAttribute ) {\r\n\r\n\t\t\t\t\tattribute[ property ] = originalAttribute[ property ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( !attribute.__webglInitialized || attribute.createUniqueBuffers ) {\r\n\r\n\t\t\t\t\tattribute.__webglInitialized = true;\r\n\r\n\t\t\t\t\tvar size = 1;\t\t// \"f\" and \"i\"\r\n\r\n\t\t\t\t\tif( attribute.type === \"v2\" ) size = 2;\r\n\t\t\t\t\telse if( attribute.type === \"v3\" ) size = 3;\r\n\t\t\t\t\telse if( attribute.type === \"v4\" ) size = 4;\r\n\t\t\t\t\telse if( attribute.type === \"c\"  ) size = 3;\r\n\r\n\t\t\t\t\tattribute.size = size;\r\n\r\n\t\t\t\t\tattribute.array = new Float32Array( nvertices * size );\r\n\r\n\t\t\t\t\tattribute.buffer = _gl.createBuffer();\r\n\t\t\t\t\tattribute.buffer.belongsToAttribute = a;\r\n\r\n\t\t\t\t\toriginalAttribute.needsUpdate = true;\r\n\t\t\t\t\tattribute.__original = originalAttribute;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometryGroup.__webglCustomAttributesList.push( attribute );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tgeometryGroup.__inittedArrays = true;\r\n\r\n\t};\r\n\r\n\tfunction getBufferMaterial( object, geometryGroup ) {\r\n\r\n\t\treturn object.material instanceof THREE.MeshFaceMaterial\r\n\t\t\t? object.material.materials[ geometryGroup.materialIndex ]\r\n\t\t\t: object.material;\r\n\r\n\t};\r\n\r\n\tfunction materialNeedsSmoothNormals ( material ) {\r\n\r\n\t\treturn material && material.shading !== undefined && material.shading === THREE.SmoothShading;\r\n\r\n\t};\r\n\r\n\tfunction bufferGuessNormalType ( material ) {\r\n\r\n\t\t// only MeshBasicMaterial and MeshDepthMaterial don't need normals\r\n\r\n\t\tif ( ( material instanceof THREE.MeshBasicMaterial && !material.envMap ) || material instanceof THREE.MeshDepthMaterial ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( materialNeedsSmoothNormals( material ) ) {\r\n\r\n\t\t\treturn THREE.SmoothShading;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn THREE.FlatShading;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction bufferGuessVertexColorType ( material ) {\r\n\r\n\t\tif ( material.vertexColors ) {\r\n\r\n\t\t\treturn material.vertexColors;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t};\r\n\r\n\tfunction bufferGuessUVType ( material ) {\r\n\r\n\t\t// material must use some texture to require uvs\r\n\r\n\t\tif ( material.map || material.lightMap || material.bumpMap || material.normalMap || material.specularMap || material instanceof THREE.ShaderMaterial ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t};\r\n\r\n\t//\r\n\r\n\tfunction initDirectBuffers( geometry ) {\r\n\r\n\t\tvar a, attribute, type;\r\n\r\n\t\tfor ( a in geometry.attributes ) {\r\n\r\n\t\t\tif ( a === \"index\" ) {\r\n\r\n\t\t\t\ttype = _gl.ELEMENT_ARRAY_BUFFER;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ttype = _gl.ARRAY_BUFFER;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tattribute = geometry.attributes[ a ];\r\n\r\n\t\t\tattribute.buffer = _gl.createBuffer();\r\n\r\n\t\t\t_gl.bindBuffer( type, attribute.buffer );\r\n\t\t\t_gl.bufferData( type, attribute.array, _gl.STATIC_DRAW );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Buffer setting\r\n\r\n\tfunction setParticleBuffers ( geometry, hint, object ) {\r\n\r\n\t\tvar v, c, vertex, offset, index, color,\r\n\r\n\t\tvertices = geometry.vertices,\r\n\t\tvl = vertices.length,\r\n\r\n\t\tcolors = geometry.colors,\r\n\t\tcl = colors.length,\r\n\r\n\t\tvertexArray = geometry.__vertexArray,\r\n\t\tcolorArray = geometry.__colorArray,\r\n\r\n\t\tsortArray = geometry.__sortArray,\r\n\r\n\t\tdirtyVertices = geometry.verticesNeedUpdate,\r\n\t\tdirtyElements = geometry.elementsNeedUpdate,\r\n\t\tdirtyColors = geometry.colorsNeedUpdate,\r\n\r\n\t\tcustomAttributes = geometry.__webglCustomAttributesList,\r\n\t\ti, il,\r\n\t\ta, ca, cal, value,\r\n\t\tcustomAttribute;\r\n\r\n\t\tif ( object.sortParticles ) {\r\n\r\n\t\t\t_projScreenMatrixPS.copy( _projScreenMatrix );\r\n\t\t\t_projScreenMatrixPS.multiply( object.matrixWorld );\r\n\r\n\t\t\tfor ( v = 0; v < vl; v ++ ) {\r\n\r\n\t\t\t\tvertex = vertices[ v ];\r\n\r\n\t\t\t\t_vector3.copy( vertex );\r\n\t\t\t\t_vector3.applyProjection( _projScreenMatrixPS );\r\n\r\n\t\t\t\tsortArray[ v ] = [ _vector3.z, v ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tsortArray.sort( numericalSort );\r\n\r\n\t\t\tfor ( v = 0; v < vl; v ++ ) {\r\n\r\n\t\t\t\tvertex = vertices[ sortArray[v][1] ];\r\n\r\n\t\t\t\toffset = v * 3;\r\n\r\n\t\t\t\tvertexArray[ offset ]     = vertex.x;\r\n\t\t\t\tvertexArray[ offset + 1 ] = vertex.y;\r\n\t\t\t\tvertexArray[ offset + 2 ] = vertex.z;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( c = 0; c < cl; c ++ ) {\r\n\r\n\t\t\t\toffset = c * 3;\r\n\r\n\t\t\t\tcolor = colors[ sortArray[c][1] ];\r\n\r\n\t\t\t\tcolorArray[ offset ]     = color.r;\r\n\t\t\t\tcolorArray[ offset + 1 ] = color.g;\r\n\t\t\t\tcolorArray[ offset + 2 ] = color.b;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( customAttributes ) {\r\n\r\n\t\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tcustomAttribute = customAttributes[ i ];\r\n\r\n\t\t\t\t\tif ( ! ( customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\" ) ) continue;\r\n\r\n\t\t\t\t\toffset = 0;\r\n\r\n\t\t\t\t\tcal = customAttribute.value.length;\r\n\r\n\t\t\t\t\tif ( customAttribute.size === 1 ) {\r\n\r\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\tindex = sortArray[ ca ][ 1 ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ ca ] = customAttribute.value[ index ];\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.size === 2 ) {\r\n\r\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\tindex = sortArray[ ca ][ 1 ];\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ index ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\r\n\r\n\t\t\t\t\t\t\toffset += 2;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.size === 3 ) {\r\n\r\n\t\t\t\t\t\tif ( customAttribute.type === \"c\" ) {\r\n\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tindex = sortArray[ ca ][ 1 ];\r\n\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ index ];\r\n\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ]     = value.r;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.g;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.b;\r\n\r\n\t\t\t\t\t\t\t\toffset += 3;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tindex = sortArray[ ca ][ 1 ];\r\n\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ index ];\r\n\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.z;\r\n\r\n\t\t\t\t\t\t\t\toffset += 3;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.size === 4 ) {\r\n\r\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\tindex = sortArray[ ca ][ 1 ];\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ index ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset ]      = value.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1  ] = value.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2  ] = value.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 3  ] = value.w;\r\n\r\n\t\t\t\t\t\t\toffset += 4;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( dirtyVertices ) {\r\n\r\n\t\t\t\tfor ( v = 0; v < vl; v ++ ) {\r\n\r\n\t\t\t\t\tvertex = vertices[ v ];\r\n\r\n\t\t\t\t\toffset = v * 3;\r\n\r\n\t\t\t\t\tvertexArray[ offset ]     = vertex.x;\r\n\t\t\t\t\tvertexArray[ offset + 1 ] = vertex.y;\r\n\t\t\t\t\tvertexArray[ offset + 2 ] = vertex.z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( dirtyColors ) {\r\n\r\n\t\t\t\tfor ( c = 0; c < cl; c ++ ) {\r\n\r\n\t\t\t\t\tcolor = colors[ c ];\r\n\r\n\t\t\t\t\toffset = c * 3;\r\n\r\n\t\t\t\t\tcolorArray[ offset ]     = color.r;\r\n\t\t\t\t\tcolorArray[ offset + 1 ] = color.g;\r\n\t\t\t\t\tcolorArray[ offset + 2 ] = color.b;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( customAttributes ) {\r\n\r\n\t\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tcustomAttribute = customAttributes[ i ];\r\n\r\n\t\t\t\t\tif ( customAttribute.needsUpdate &&\r\n\t\t\t\t\t\t ( customAttribute.boundTo === undefined ||\r\n\t\t\t\t\t\t   customAttribute.boundTo === \"vertices\") ) {\r\n\r\n\t\t\t\t\t\tcal = customAttribute.value.length;\r\n\r\n\t\t\t\t\t\toffset = 0;\r\n\r\n\t\t\t\t\t\tif ( customAttribute.size === 1 ) {\r\n\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ ca ] = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else if ( customAttribute.size === 2 ) {\r\n\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\r\n\r\n\t\t\t\t\t\t\t\toffset += 2;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else if ( customAttribute.size === 3 ) {\r\n\r\n\t\t\t\t\t\t\tif ( customAttribute.type === \"c\" ) {\r\n\r\n\t\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.r;\r\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.g;\r\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.b;\r\n\r\n\t\t\t\t\t\t\t\t\toffset += 3;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\r\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\r\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.z;\r\n\r\n\t\t\t\t\t\t\t\t\toffset += 3;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else if ( customAttribute.size === 4 ) {\r\n\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ]      = value.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1  ] = value.y;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2  ] = value.z;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 3  ] = value.w;\r\n\r\n\t\t\t\t\t\t\t\toffset += 4;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyVertices || object.sortParticles ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyColors || object.sortParticles ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( customAttributes ) {\r\n\r\n\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tcustomAttribute = customAttributes[ i ];\r\n\r\n\t\t\t\tif ( customAttribute.needsUpdate || object.sortParticles ) {\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );\r\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\t};\r\n\r\n\tfunction setLineBuffers ( geometry, hint ) {\r\n\r\n\t\tvar v, c, d, vertex, offset, color,\r\n\r\n\t\tvertices = geometry.vertices,\r\n\t\tcolors = geometry.colors,\r\n\t\tlineDistances = geometry.lineDistances,\r\n\r\n\t\tvl = vertices.length,\r\n\t\tcl = colors.length,\r\n\t\tdl = lineDistances.length,\r\n\r\n\t\tvertexArray = geometry.__vertexArray,\r\n\t\tcolorArray = geometry.__colorArray,\r\n\t\tlineDistanceArray = geometry.__lineDistanceArray,\r\n\r\n\t\tdirtyVertices = geometry.verticesNeedUpdate,\r\n\t\tdirtyColors = geometry.colorsNeedUpdate,\r\n\t\tdirtyLineDistances = geometry.lineDistancesNeedUpdate,\r\n\r\n\t\tcustomAttributes = geometry.__webglCustomAttributesList,\r\n\r\n\t\ti, il,\r\n\t\ta, ca, cal, value,\r\n\t\tcustomAttribute;\r\n\r\n\t\tif ( dirtyVertices ) {\r\n\r\n\t\t\tfor ( v = 0; v < vl; v ++ ) {\r\n\r\n\t\t\t\tvertex = vertices[ v ];\r\n\r\n\t\t\t\toffset = v * 3;\r\n\r\n\t\t\t\tvertexArray[ offset ]     = vertex.x;\r\n\t\t\t\tvertexArray[ offset + 1 ] = vertex.y;\r\n\t\t\t\tvertexArray[ offset + 2 ] = vertex.z;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyColors ) {\r\n\r\n\t\t\tfor ( c = 0; c < cl; c ++ ) {\r\n\r\n\t\t\t\tcolor = colors[ c ];\r\n\r\n\t\t\t\toffset = c * 3;\r\n\r\n\t\t\t\tcolorArray[ offset ]     = color.r;\r\n\t\t\t\tcolorArray[ offset + 1 ] = color.g;\r\n\t\t\t\tcolorArray[ offset + 2 ] = color.b;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyLineDistances ) {\r\n\r\n\t\t\tfor ( d = 0; d < dl; d ++ ) {\r\n\r\n\t\t\t\tlineDistanceArray[ d ] = lineDistances[ d ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglLineDistanceBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, lineDistanceArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( customAttributes ) {\r\n\r\n\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tcustomAttribute = customAttributes[ i ];\r\n\r\n\t\t\t\tif ( customAttribute.needsUpdate &&\r\n\t\t\t\t\t ( customAttribute.boundTo === undefined ||\r\n\t\t\t\t\t   customAttribute.boundTo === \"vertices\" ) ) {\r\n\r\n\t\t\t\t\toffset = 0;\r\n\r\n\t\t\t\t\tcal = customAttribute.value.length;\r\n\r\n\t\t\t\t\tif ( customAttribute.size === 1 ) {\r\n\r\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ ca ] = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.size === 2 ) {\r\n\r\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\r\n\r\n\t\t\t\t\t\t\toffset += 2;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.size === 3 ) {\r\n\r\n\t\t\t\t\t\tif ( customAttribute.type === \"c\" ) {\r\n\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.r;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.g;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.b;\r\n\r\n\t\t\t\t\t\t\t\toffset += 3;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.z;\r\n\r\n\t\t\t\t\t\t\t\toffset += 3;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.size === 4 ) {\r\n\r\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t = value.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1  ] = value.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2  ] = value.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 3  ] = value.w;\r\n\r\n\t\t\t\t\t\t\toffset += 4;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );\r\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction setRibbonBuffers ( geometry, hint ) {\r\n\r\n\t\tvar v, c, n, vertex, offset, color, normal,\r\n\r\n\t\ti, il, ca, cal, customAttribute, value,\r\n\r\n\t\tvertices = geometry.vertices,\r\n\t\tcolors = geometry.colors,\r\n\t\tnormals = geometry.normals,\r\n\r\n\t\tvl = vertices.length,\r\n\t\tcl = colors.length,\r\n\t\tnl = normals.length,\r\n\r\n\t\tvertexArray = geometry.__vertexArray,\r\n\t\tcolorArray = geometry.__colorArray,\r\n\t\tnormalArray = geometry.__normalArray,\r\n\r\n\t\tdirtyVertices = geometry.verticesNeedUpdate,\r\n\t\tdirtyColors = geometry.colorsNeedUpdate,\r\n\t\tdirtyNormals = geometry.normalsNeedUpdate,\r\n\r\n\t\tcustomAttributes = geometry.__webglCustomAttributesList;\r\n\r\n\t\tif ( dirtyVertices ) {\r\n\r\n\t\t\tfor ( v = 0; v < vl; v ++ ) {\r\n\r\n\t\t\t\tvertex = vertices[ v ];\r\n\r\n\t\t\t\toffset = v * 3;\r\n\r\n\t\t\t\tvertexArray[ offset ]     = vertex.x;\r\n\t\t\t\tvertexArray[ offset + 1 ] = vertex.y;\r\n\t\t\t\tvertexArray[ offset + 2 ] = vertex.z;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyColors ) {\r\n\r\n\t\t\tfor ( c = 0; c < cl; c ++ ) {\r\n\r\n\t\t\t\tcolor = colors[ c ];\r\n\r\n\t\t\t\toffset = c * 3;\r\n\r\n\t\t\t\tcolorArray[ offset ]     = color.r;\r\n\t\t\t\tcolorArray[ offset + 1 ] = color.g;\r\n\t\t\t\tcolorArray[ offset + 2 ] = color.b;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyNormals ) {\r\n\r\n\t\t\tfor ( n = 0; n < nl; n ++ ) {\r\n\r\n\t\t\t\tnormal = normals[ n ];\r\n\r\n\t\t\t\toffset = n * 3;\r\n\r\n\t\t\t\tnormalArray[ offset ]     = normal.x;\r\n\t\t\t\tnormalArray[ offset + 1 ] = normal.y;\r\n\t\t\t\tnormalArray[ offset + 2 ] = normal.z;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglNormalBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, normalArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( customAttributes ) {\r\n\r\n\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tcustomAttribute = customAttributes[ i ];\r\n\r\n\t\t\t\tif ( customAttribute.needsUpdate &&\r\n\t\t\t\t\t ( customAttribute.boundTo === undefined ||\r\n\t\t\t\t\t   customAttribute.boundTo === \"vertices\" ) ) {\r\n\r\n\t\t\t\t\toffset = 0;\r\n\r\n\t\t\t\t\tcal = customAttribute.value.length;\r\n\r\n\t\t\t\t\tif ( customAttribute.size === 1 ) {\r\n\r\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ ca ] = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.size === 2 ) {\r\n\r\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\r\n\r\n\t\t\t\t\t\t\toffset += 2;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.size === 3 ) {\r\n\r\n\t\t\t\t\t\tif ( customAttribute.type === \"c\" ) {\r\n\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.r;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.g;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.b;\r\n\r\n\t\t\t\t\t\t\t\toffset += 3;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.z;\r\n\r\n\t\t\t\t\t\t\t\toffset += 3;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.size === 4 ) {\r\n\r\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t = value.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1  ] = value.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2  ] = value.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 3  ] = value.w;\r\n\r\n\t\t\t\t\t\t\toffset += 4;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );\r\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction setMeshBuffers( geometryGroup, object, hint, dispose, material ) {\r\n\r\n\t\tif ( ! geometryGroup.__inittedArrays ) {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar normalType = bufferGuessNormalType( material ),\r\n\t\tvertexColorType = bufferGuessVertexColorType( material ),\r\n\t\tuvType = bufferGuessUVType( material ),\r\n\r\n\t\tneedsSmoothNormals = ( normalType === THREE.SmoothShading );\r\n\r\n\t\tvar f, fl, fi, face,\r\n\t\tvertexNormals, faceNormal, normal,\r\n\t\tvertexColors, faceColor,\r\n\t\tvertexTangents,\r\n\t\tuv, uv2, v1, v2, v3, v4, t1, t2, t3, t4, n1, n2, n3, n4,\r\n\t\tc1, c2, c3, c4,\r\n\t\tsw1, sw2, sw3, sw4,\r\n\t\tsi1, si2, si3, si4,\r\n\t\tsa1, sa2, sa3, sa4,\r\n\t\tsb1, sb2, sb3, sb4,\r\n\t\tm, ml, i, il,\r\n\t\tvn, uvi, uv2i,\r\n\t\tvk, vkl, vka,\r\n\t\tnka, chf, faceVertexNormals,\r\n\t\ta,\r\n\r\n\t\tvertexIndex = 0,\r\n\r\n\t\toffset = 0,\r\n\t\toffset_uv = 0,\r\n\t\toffset_uv2 = 0,\r\n\t\toffset_face = 0,\r\n\t\toffset_normal = 0,\r\n\t\toffset_tangent = 0,\r\n\t\toffset_line = 0,\r\n\t\toffset_color = 0,\r\n\t\toffset_skin = 0,\r\n\t\toffset_morphTarget = 0,\r\n\t\toffset_custom = 0,\r\n\t\toffset_customSrc = 0,\r\n\r\n\t\tvalue,\r\n\r\n\t\tvertexArray = geometryGroup.__vertexArray,\r\n\t\tuvArray = geometryGroup.__uvArray,\r\n\t\tuv2Array = geometryGroup.__uv2Array,\r\n\t\tnormalArray = geometryGroup.__normalArray,\r\n\t\ttangentArray = geometryGroup.__tangentArray,\r\n\t\tcolorArray = geometryGroup.__colorArray,\r\n\r\n\t\tskinIndexArray = geometryGroup.__skinIndexArray,\r\n\t\tskinWeightArray = geometryGroup.__skinWeightArray,\r\n\r\n\t\tmorphTargetsArrays = geometryGroup.__morphTargetsArrays,\r\n\t\tmorphNormalsArrays = geometryGroup.__morphNormalsArrays,\r\n\r\n\t\tcustomAttributes = geometryGroup.__webglCustomAttributesList,\r\n\t\tcustomAttribute,\r\n\r\n\t\tfaceArray = geometryGroup.__faceArray,\r\n\t\tlineArray = geometryGroup.__lineArray,\r\n\r\n\t\tgeometry = object.geometry, // this is shared for all chunks\r\n\r\n\t\tdirtyVertices = geometry.verticesNeedUpdate,\r\n\t\tdirtyElements = geometry.elementsNeedUpdate,\r\n\t\tdirtyUvs = geometry.uvsNeedUpdate,\r\n\t\tdirtyNormals = geometry.normalsNeedUpdate,\r\n\t\tdirtyTangents = geometry.tangentsNeedUpdate,\r\n\t\tdirtyColors = geometry.colorsNeedUpdate,\r\n\t\tdirtyMorphTargets = geometry.morphTargetsNeedUpdate,\r\n\r\n\t\tvertices = geometry.vertices,\r\n\t\tchunk_faces3 = geometryGroup.faces3,\r\n\t\tchunk_faces4 = geometryGroup.faces4,\r\n\t\tobj_faces = geometry.faces,\r\n\r\n\t\tobj_uvs  = geometry.faceVertexUvs[ 0 ],\r\n\t\tobj_uvs2 = geometry.faceVertexUvs[ 1 ],\r\n\r\n\t\tobj_colors = geometry.colors,\r\n\r\n\t\tobj_skinIndices = geometry.skinIndices,\r\n\t\tobj_skinWeights = geometry.skinWeights,\r\n\r\n\t\tmorphTargets = geometry.morphTargets,\r\n\t\tmorphNormals = geometry.morphNormals;\r\n\r\n\t\tif ( dirtyVertices ) {\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\tv1 = vertices[ face.a ];\r\n\t\t\t\tv2 = vertices[ face.b ];\r\n\t\t\t\tv3 = vertices[ face.c ];\r\n\r\n\t\t\t\tvertexArray[ offset ]     = v1.x;\r\n\t\t\t\tvertexArray[ offset + 1 ] = v1.y;\r\n\t\t\t\tvertexArray[ offset + 2 ] = v1.z;\r\n\r\n\t\t\t\tvertexArray[ offset + 3 ] = v2.x;\r\n\t\t\t\tvertexArray[ offset + 4 ] = v2.y;\r\n\t\t\t\tvertexArray[ offset + 5 ] = v2.z;\r\n\r\n\t\t\t\tvertexArray[ offset + 6 ] = v3.x;\r\n\t\t\t\tvertexArray[ offset + 7 ] = v3.y;\r\n\t\t\t\tvertexArray[ offset + 8 ] = v3.z;\r\n\r\n\t\t\t\toffset += 9;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = obj_faces[ chunk_faces4[ f ] ];\r\n\r\n\t\t\t\tv1 = vertices[ face.a ];\r\n\t\t\t\tv2 = vertices[ face.b ];\r\n\t\t\t\tv3 = vertices[ face.c ];\r\n\t\t\t\tv4 = vertices[ face.d ];\r\n\r\n\t\t\t\tvertexArray[ offset ]     = v1.x;\r\n\t\t\t\tvertexArray[ offset + 1 ] = v1.y;\r\n\t\t\t\tvertexArray[ offset + 2 ] = v1.z;\r\n\r\n\t\t\t\tvertexArray[ offset + 3 ] = v2.x;\r\n\t\t\t\tvertexArray[ offset + 4 ] = v2.y;\r\n\t\t\t\tvertexArray[ offset + 5 ] = v2.z;\r\n\r\n\t\t\t\tvertexArray[ offset + 6 ] = v3.x;\r\n\t\t\t\tvertexArray[ offset + 7 ] = v3.y;\r\n\t\t\t\tvertexArray[ offset + 8 ] = v3.z;\r\n\r\n\t\t\t\tvertexArray[ offset + 9 ]  = v4.x;\r\n\t\t\t\tvertexArray[ offset + 10 ] = v4.y;\r\n\t\t\t\tvertexArray[ offset + 11 ] = v4.z;\r\n\r\n\t\t\t\toffset += 12;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyMorphTargets ) {\r\n\r\n\t\t\tfor ( vk = 0, vkl = morphTargets.length; vk < vkl; vk ++ ) {\r\n\r\n\t\t\t\toffset_morphTarget = 0;\r\n\r\n\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\tchf = chunk_faces3[ f ];\r\n\t\t\t\t\tface = obj_faces[ chf ];\r\n\r\n\t\t\t\t\t// morph positions\r\n\r\n\t\t\t\t\tv1 = morphTargets[ vk ].vertices[ face.a ];\r\n\t\t\t\t\tv2 = morphTargets[ vk ].vertices[ face.b ];\r\n\t\t\t\t\tv3 = morphTargets[ vk ].vertices[ face.c ];\r\n\r\n\t\t\t\t\tvka = morphTargetsArrays[ vk ];\r\n\r\n\t\t\t\t\tvka[ offset_morphTarget ] \t  = v1.x;\r\n\t\t\t\t\tvka[ offset_morphTarget + 1 ] = v1.y;\r\n\t\t\t\t\tvka[ offset_morphTarget + 2 ] = v1.z;\r\n\r\n\t\t\t\t\tvka[ offset_morphTarget + 3 ] = v2.x;\r\n\t\t\t\t\tvka[ offset_morphTarget + 4 ] = v2.y;\r\n\t\t\t\t\tvka[ offset_morphTarget + 5 ] = v2.z;\r\n\r\n\t\t\t\t\tvka[ offset_morphTarget + 6 ] = v3.x;\r\n\t\t\t\t\tvka[ offset_morphTarget + 7 ] = v3.y;\r\n\t\t\t\t\tvka[ offset_morphTarget + 8 ] = v3.z;\r\n\r\n\t\t\t\t\t// morph normals\r\n\r\n\t\t\t\t\tif ( material.morphNormals ) {\r\n\r\n\t\t\t\t\t\tif ( needsSmoothNormals ) {\r\n\r\n\t\t\t\t\t\t\tfaceVertexNormals = morphNormals[ vk ].vertexNormals[ chf ];\r\n\r\n\t\t\t\t\t\t\tn1 = faceVertexNormals.a;\r\n\t\t\t\t\t\t\tn2 = faceVertexNormals.b;\r\n\t\t\t\t\t\t\tn3 = faceVertexNormals.c;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tn1 = morphNormals[ vk ].faceNormals[ chf ];\r\n\t\t\t\t\t\t\tn2 = n1;\r\n\t\t\t\t\t\t\tn3 = n1;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tnka = morphNormalsArrays[ vk ];\r\n\r\n\t\t\t\t\t\tnka[ offset_morphTarget ] \t  = n1.x;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 1 ] = n1.y;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 2 ] = n1.z;\r\n\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 3 ] = n2.x;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 4 ] = n2.y;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 5 ] = n2.z;\r\n\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 6 ] = n3.x;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 7 ] = n3.y;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 8 ] = n3.z;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t//\r\n\r\n\t\t\t\t\toffset_morphTarget += 9;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\tchf = chunk_faces4[ f ];\r\n\t\t\t\t\tface = obj_faces[ chf ];\r\n\r\n\t\t\t\t\t// morph positions\r\n\r\n\t\t\t\t\tv1 = morphTargets[ vk ].vertices[ face.a ];\r\n\t\t\t\t\tv2 = morphTargets[ vk ].vertices[ face.b ];\r\n\t\t\t\t\tv3 = morphTargets[ vk ].vertices[ face.c ];\r\n\t\t\t\t\tv4 = morphTargets[ vk ].vertices[ face.d ];\r\n\r\n\t\t\t\t\tvka = morphTargetsArrays[ vk ];\r\n\r\n\t\t\t\t\tvka[ offset_morphTarget ] \t  = v1.x;\r\n\t\t\t\t\tvka[ offset_morphTarget + 1 ] = v1.y;\r\n\t\t\t\t\tvka[ offset_morphTarget + 2 ] = v1.z;\r\n\r\n\t\t\t\t\tvka[ offset_morphTarget + 3 ] = v2.x;\r\n\t\t\t\t\tvka[ offset_morphTarget + 4 ] = v2.y;\r\n\t\t\t\t\tvka[ offset_morphTarget + 5 ] = v2.z;\r\n\r\n\t\t\t\t\tvka[ offset_morphTarget + 6 ] = v3.x;\r\n\t\t\t\t\tvka[ offset_morphTarget + 7 ] = v3.y;\r\n\t\t\t\t\tvka[ offset_morphTarget + 8 ] = v3.z;\r\n\r\n\t\t\t\t\tvka[ offset_morphTarget + 9 ]  = v4.x;\r\n\t\t\t\t\tvka[ offset_morphTarget + 10 ] = v4.y;\r\n\t\t\t\t\tvka[ offset_morphTarget + 11 ] = v4.z;\r\n\r\n\t\t\t\t\t// morph normals\r\n\r\n\t\t\t\t\tif ( material.morphNormals ) {\r\n\r\n\t\t\t\t\t\tif ( needsSmoothNormals ) {\r\n\r\n\t\t\t\t\t\t\tfaceVertexNormals = morphNormals[ vk ].vertexNormals[ chf ];\r\n\r\n\t\t\t\t\t\t\tn1 = faceVertexNormals.a;\r\n\t\t\t\t\t\t\tn2 = faceVertexNormals.b;\r\n\t\t\t\t\t\t\tn3 = faceVertexNormals.c;\r\n\t\t\t\t\t\t\tn4 = faceVertexNormals.d;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tn1 = morphNormals[ vk ].faceNormals[ chf ];\r\n\t\t\t\t\t\t\tn2 = n1;\r\n\t\t\t\t\t\t\tn3 = n1;\r\n\t\t\t\t\t\t\tn4 = n1;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tnka = morphNormalsArrays[ vk ];\r\n\r\n\t\t\t\t\t\tnka[ offset_morphTarget ] \t  = n1.x;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 1 ] = n1.y;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 2 ] = n1.z;\r\n\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 3 ] = n2.x;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 4 ] = n2.y;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 5 ] = n2.z;\r\n\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 6 ] = n3.x;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 7 ] = n3.y;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 8 ] = n3.z;\r\n\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 9 ]  = n4.x;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 10 ] = n4.y;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 11 ] = n4.z;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t//\r\n\r\n\t\t\t\t\toffset_morphTarget += 12;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ vk ] );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, morphTargetsArrays[ vk ], hint );\r\n\r\n\t\t\t\tif ( material.morphNormals ) {\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ vk ] );\r\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, morphNormalsArrays[ vk ], hint );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( obj_skinWeights.length ) {\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\r\n\r\n\t\t\t\t// weights\r\n\r\n\t\t\t\tsw1 = obj_skinWeights[ face.a ];\r\n\t\t\t\tsw2 = obj_skinWeights[ face.b ];\r\n\t\t\t\tsw3 = obj_skinWeights[ face.c ];\r\n\r\n\t\t\t\tskinWeightArray[ offset_skin ]     = sw1.x;\r\n\t\t\t\tskinWeightArray[ offset_skin + 1 ] = sw1.y;\r\n\t\t\t\tskinWeightArray[ offset_skin + 2 ] = sw1.z;\r\n\t\t\t\tskinWeightArray[ offset_skin + 3 ] = sw1.w;\r\n\r\n\t\t\t\tskinWeightArray[ offset_skin + 4 ] = sw2.x;\r\n\t\t\t\tskinWeightArray[ offset_skin + 5 ] = sw2.y;\r\n\t\t\t\tskinWeightArray[ offset_skin + 6 ] = sw2.z;\r\n\t\t\t\tskinWeightArray[ offset_skin + 7 ] = sw2.w;\r\n\r\n\t\t\t\tskinWeightArray[ offset_skin + 8 ]  = sw3.x;\r\n\t\t\t\tskinWeightArray[ offset_skin + 9 ]  = sw3.y;\r\n\t\t\t\tskinWeightArray[ offset_skin + 10 ] = sw3.z;\r\n\t\t\t\tskinWeightArray[ offset_skin + 11 ] = sw3.w;\r\n\r\n\t\t\t\t// indices\r\n\r\n\t\t\t\tsi1 = obj_skinIndices[ face.a ];\r\n\t\t\t\tsi2 = obj_skinIndices[ face.b ];\r\n\t\t\t\tsi3 = obj_skinIndices[ face.c ];\r\n\r\n\t\t\t\tskinIndexArray[ offset_skin ]     = si1.x;\r\n\t\t\t\tskinIndexArray[ offset_skin + 1 ] = si1.y;\r\n\t\t\t\tskinIndexArray[ offset_skin + 2 ] = si1.z;\r\n\t\t\t\tskinIndexArray[ offset_skin + 3 ] = si1.w;\r\n\r\n\t\t\t\tskinIndexArray[ offset_skin + 4 ] = si2.x;\r\n\t\t\t\tskinIndexArray[ offset_skin + 5 ] = si2.y;\r\n\t\t\t\tskinIndexArray[ offset_skin + 6 ] = si2.z;\r\n\t\t\t\tskinIndexArray[ offset_skin + 7 ] = si2.w;\r\n\r\n\t\t\t\tskinIndexArray[ offset_skin + 8 ]  = si3.x;\r\n\t\t\t\tskinIndexArray[ offset_skin + 9 ]  = si3.y;\r\n\t\t\t\tskinIndexArray[ offset_skin + 10 ] = si3.z;\r\n\t\t\t\tskinIndexArray[ offset_skin + 11 ] = si3.w;\r\n\r\n\t\t\t\toffset_skin += 12;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = obj_faces[ chunk_faces4[ f ] ];\r\n\r\n\t\t\t\t// weights\r\n\r\n\t\t\t\tsw1 = obj_skinWeights[ face.a ];\r\n\t\t\t\tsw2 = obj_skinWeights[ face.b ];\r\n\t\t\t\tsw3 = obj_skinWeights[ face.c ];\r\n\t\t\t\tsw4 = obj_skinWeights[ face.d ];\r\n\r\n\t\t\t\tskinWeightArray[ offset_skin ]     = sw1.x;\r\n\t\t\t\tskinWeightArray[ offset_skin + 1 ] = sw1.y;\r\n\t\t\t\tskinWeightArray[ offset_skin + 2 ] = sw1.z;\r\n\t\t\t\tskinWeightArray[ offset_skin + 3 ] = sw1.w;\r\n\r\n\t\t\t\tskinWeightArray[ offset_skin + 4 ] = sw2.x;\r\n\t\t\t\tskinWeightArray[ offset_skin + 5 ] = sw2.y;\r\n\t\t\t\tskinWeightArray[ offset_skin + 6 ] = sw2.z;\r\n\t\t\t\tskinWeightArray[ offset_skin + 7 ] = sw2.w;\r\n\r\n\t\t\t\tskinWeightArray[ offset_skin + 8 ]  = sw3.x;\r\n\t\t\t\tskinWeightArray[ offset_skin + 9 ]  = sw3.y;\r\n\t\t\t\tskinWeightArray[ offset_skin + 10 ] = sw3.z;\r\n\t\t\t\tskinWeightArray[ offset_skin + 11 ] = sw3.w;\r\n\r\n\t\t\t\tskinWeightArray[ offset_skin + 12 ] = sw4.x;\r\n\t\t\t\tskinWeightArray[ offset_skin + 13 ] = sw4.y;\r\n\t\t\t\tskinWeightArray[ offset_skin + 14 ] = sw4.z;\r\n\t\t\t\tskinWeightArray[ offset_skin + 15 ] = sw4.w;\r\n\r\n\t\t\t\t// indices\r\n\r\n\t\t\t\tsi1 = obj_skinIndices[ face.a ];\r\n\t\t\t\tsi2 = obj_skinIndices[ face.b ];\r\n\t\t\t\tsi3 = obj_skinIndices[ face.c ];\r\n\t\t\t\tsi4 = obj_skinIndices[ face.d ];\r\n\r\n\t\t\t\tskinIndexArray[ offset_skin ]     = si1.x;\r\n\t\t\t\tskinIndexArray[ offset_skin + 1 ] = si1.y;\r\n\t\t\t\tskinIndexArray[ offset_skin + 2 ] = si1.z;\r\n\t\t\t\tskinIndexArray[ offset_skin + 3 ] = si1.w;\r\n\r\n\t\t\t\tskinIndexArray[ offset_skin + 4 ] = si2.x;\r\n\t\t\t\tskinIndexArray[ offset_skin + 5 ] = si2.y;\r\n\t\t\t\tskinIndexArray[ offset_skin + 6 ] = si2.z;\r\n\t\t\t\tskinIndexArray[ offset_skin + 7 ] = si2.w;\r\n\r\n\t\t\t\tskinIndexArray[ offset_skin + 8 ]  = si3.x;\r\n\t\t\t\tskinIndexArray[ offset_skin + 9 ]  = si3.y;\r\n\t\t\t\tskinIndexArray[ offset_skin + 10 ] = si3.z;\r\n\t\t\t\tskinIndexArray[ offset_skin + 11 ] = si3.w;\r\n\r\n\t\t\t\tskinIndexArray[ offset_skin + 12 ] = si4.x;\r\n\t\t\t\tskinIndexArray[ offset_skin + 13 ] = si4.y;\r\n\t\t\t\tskinIndexArray[ offset_skin + 14 ] = si4.z;\r\n\t\t\t\tskinIndexArray[ offset_skin + 15 ] = si4.w;\r\n\r\n\t\t\t\toffset_skin += 16;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( offset_skin > 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, skinIndexArray, hint );\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, skinWeightArray, hint );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyColors && vertexColorType ) {\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\r\n\r\n\t\t\t\tvertexColors = face.vertexColors;\r\n\t\t\t\tfaceColor = face.color;\r\n\r\n\t\t\t\tif ( vertexColors.length === 3 && vertexColorType === THREE.VertexColors ) {\r\n\r\n\t\t\t\t\tc1 = vertexColors[ 0 ];\r\n\t\t\t\t\tc2 = vertexColors[ 1 ];\r\n\t\t\t\t\tc3 = vertexColors[ 2 ];\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tc1 = faceColor;\r\n\t\t\t\t\tc2 = faceColor;\r\n\t\t\t\t\tc3 = faceColor;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcolorArray[ offset_color ]     = c1.r;\r\n\t\t\t\tcolorArray[ offset_color + 1 ] = c1.g;\r\n\t\t\t\tcolorArray[ offset_color + 2 ] = c1.b;\r\n\r\n\t\t\t\tcolorArray[ offset_color + 3 ] = c2.r;\r\n\t\t\t\tcolorArray[ offset_color + 4 ] = c2.g;\r\n\t\t\t\tcolorArray[ offset_color + 5 ] = c2.b;\r\n\r\n\t\t\t\tcolorArray[ offset_color + 6 ] = c3.r;\r\n\t\t\t\tcolorArray[ offset_color + 7 ] = c3.g;\r\n\t\t\t\tcolorArray[ offset_color + 8 ] = c3.b;\r\n\r\n\t\t\t\toffset_color += 9;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = obj_faces[ chunk_faces4[ f ] ];\r\n\r\n\t\t\t\tvertexColors = face.vertexColors;\r\n\t\t\t\tfaceColor = face.color;\r\n\r\n\t\t\t\tif ( vertexColors.length === 4 && vertexColorType === THREE.VertexColors ) {\r\n\r\n\t\t\t\t\tc1 = vertexColors[ 0 ];\r\n\t\t\t\t\tc2 = vertexColors[ 1 ];\r\n\t\t\t\t\tc3 = vertexColors[ 2 ];\r\n\t\t\t\t\tc4 = vertexColors[ 3 ];\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tc1 = faceColor;\r\n\t\t\t\t\tc2 = faceColor;\r\n\t\t\t\t\tc3 = faceColor;\r\n\t\t\t\t\tc4 = faceColor;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcolorArray[ offset_color ]     = c1.r;\r\n\t\t\t\tcolorArray[ offset_color + 1 ] = c1.g;\r\n\t\t\t\tcolorArray[ offset_color + 2 ] = c1.b;\r\n\r\n\t\t\t\tcolorArray[ offset_color + 3 ] = c2.r;\r\n\t\t\t\tcolorArray[ offset_color + 4 ] = c2.g;\r\n\t\t\t\tcolorArray[ offset_color + 5 ] = c2.b;\r\n\r\n\t\t\t\tcolorArray[ offset_color + 6 ] = c3.r;\r\n\t\t\t\tcolorArray[ offset_color + 7 ] = c3.g;\r\n\t\t\t\tcolorArray[ offset_color + 8 ] = c3.b;\r\n\r\n\t\t\t\tcolorArray[ offset_color + 9 ]  = c4.r;\r\n\t\t\t\tcolorArray[ offset_color + 10 ] = c4.g;\r\n\t\t\t\tcolorArray[ offset_color + 11 ] = c4.b;\r\n\r\n\t\t\t\toffset_color += 12;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( offset_color > 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyTangents && geometry.hasTangents ) {\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\r\n\r\n\t\t\t\tvertexTangents = face.vertexTangents;\r\n\r\n\t\t\t\tt1 = vertexTangents[ 0 ];\r\n\t\t\t\tt2 = vertexTangents[ 1 ];\r\n\t\t\t\tt3 = vertexTangents[ 2 ];\r\n\r\n\t\t\t\ttangentArray[ offset_tangent ]     = t1.x;\r\n\t\t\t\ttangentArray[ offset_tangent + 1 ] = t1.y;\r\n\t\t\t\ttangentArray[ offset_tangent + 2 ] = t1.z;\r\n\t\t\t\ttangentArray[ offset_tangent + 3 ] = t1.w;\r\n\r\n\t\t\t\ttangentArray[ offset_tangent + 4 ] = t2.x;\r\n\t\t\t\ttangentArray[ offset_tangent + 5 ] = t2.y;\r\n\t\t\t\ttangentArray[ offset_tangent + 6 ] = t2.z;\r\n\t\t\t\ttangentArray[ offset_tangent + 7 ] = t2.w;\r\n\r\n\t\t\t\ttangentArray[ offset_tangent + 8 ]  = t3.x;\r\n\t\t\t\ttangentArray[ offset_tangent + 9 ]  = t3.y;\r\n\t\t\t\ttangentArray[ offset_tangent + 10 ] = t3.z;\r\n\t\t\t\ttangentArray[ offset_tangent + 11 ] = t3.w;\r\n\r\n\t\t\t\toffset_tangent += 12;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = obj_faces[ chunk_faces4[ f ] ];\r\n\r\n\t\t\t\tvertexTangents = face.vertexTangents;\r\n\r\n\t\t\t\tt1 = vertexTangents[ 0 ];\r\n\t\t\t\tt2 = vertexTangents[ 1 ];\r\n\t\t\t\tt3 = vertexTangents[ 2 ];\r\n\t\t\t\tt4 = vertexTangents[ 3 ];\r\n\r\n\t\t\t\ttangentArray[ offset_tangent ]     = t1.x;\r\n\t\t\t\ttangentArray[ offset_tangent + 1 ] = t1.y;\r\n\t\t\t\ttangentArray[ offset_tangent + 2 ] = t1.z;\r\n\t\t\t\ttangentArray[ offset_tangent + 3 ] = t1.w;\r\n\r\n\t\t\t\ttangentArray[ offset_tangent + 4 ] = t2.x;\r\n\t\t\t\ttangentArray[ offset_tangent + 5 ] = t2.y;\r\n\t\t\t\ttangentArray[ offset_tangent + 6 ] = t2.z;\r\n\t\t\t\ttangentArray[ offset_tangent + 7 ] = t2.w;\r\n\r\n\t\t\t\ttangentArray[ offset_tangent + 8 ]  = t3.x;\r\n\t\t\t\ttangentArray[ offset_tangent + 9 ]  = t3.y;\r\n\t\t\t\ttangentArray[ offset_tangent + 10 ] = t3.z;\r\n\t\t\t\ttangentArray[ offset_tangent + 11 ] = t3.w;\r\n\r\n\t\t\t\ttangentArray[ offset_tangent + 12 ] = t4.x;\r\n\t\t\t\ttangentArray[ offset_tangent + 13 ] = t4.y;\r\n\t\t\t\ttangentArray[ offset_tangent + 14 ] = t4.z;\r\n\t\t\t\ttangentArray[ offset_tangent + 15 ] = t4.w;\r\n\r\n\t\t\t\toffset_tangent += 16;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, tangentArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyNormals && normalType ) {\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\r\n\r\n\t\t\t\tvertexNormals = face.vertexNormals;\r\n\t\t\t\tfaceNormal = face.normal;\r\n\r\n\t\t\t\tif ( vertexNormals.length === 3 && needsSmoothNormals ) {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\t\tvn = vertexNormals[ i ];\r\n\r\n\t\t\t\t\t\tnormalArray[ offset_normal ]     = vn.x;\r\n\t\t\t\t\t\tnormalArray[ offset_normal + 1 ] = vn.y;\r\n\t\t\t\t\t\tnormalArray[ offset_normal + 2 ] = vn.z;\r\n\r\n\t\t\t\t\t\toffset_normal += 3;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\t\tnormalArray[ offset_normal ]     = faceNormal.x;\r\n\t\t\t\t\t\tnormalArray[ offset_normal + 1 ] = faceNormal.y;\r\n\t\t\t\t\t\tnormalArray[ offset_normal + 2 ] = faceNormal.z;\r\n\r\n\t\t\t\t\t\toffset_normal += 3;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = obj_faces[ chunk_faces4[ f ] ];\r\n\r\n\t\t\t\tvertexNormals = face.vertexNormals;\r\n\t\t\t\tfaceNormal = face.normal;\r\n\r\n\t\t\t\tif ( vertexNormals.length === 4 && needsSmoothNormals ) {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\t\t\t\tvn = vertexNormals[ i ];\r\n\r\n\t\t\t\t\t\tnormalArray[ offset_normal ]     = vn.x;\r\n\t\t\t\t\t\tnormalArray[ offset_normal + 1 ] = vn.y;\r\n\t\t\t\t\t\tnormalArray[ offset_normal + 2 ] = vn.z;\r\n\r\n\t\t\t\t\t\toffset_normal += 3;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\t\t\t\tnormalArray[ offset_normal ]     = faceNormal.x;\r\n\t\t\t\t\t\tnormalArray[ offset_normal + 1 ] = faceNormal.y;\r\n\t\t\t\t\t\tnormalArray[ offset_normal + 2 ] = faceNormal.z;\r\n\r\n\t\t\t\t\t\toffset_normal += 3;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, normalArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyUvs && obj_uvs && uvType ) {\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tfi = chunk_faces3[ f ];\r\n\r\n\t\t\t\tuv = obj_uvs[ fi ];\r\n\r\n\t\t\t\tif ( uv === undefined ) continue;\r\n\r\n\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\tuvi = uv[ i ];\r\n\r\n\t\t\t\t\tuvArray[ offset_uv ]     = uvi.x;\r\n\t\t\t\t\tuvArray[ offset_uv + 1 ] = uvi.y;\r\n\r\n\t\t\t\t\toffset_uv += 2;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tfi = chunk_faces4[ f ];\r\n\r\n\t\t\t\tuv = obj_uvs[ fi ];\r\n\r\n\t\t\t\tif ( uv === undefined ) continue;\r\n\r\n\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\t\t\tuvi = uv[ i ];\r\n\r\n\t\t\t\t\tuvArray[ offset_uv ]     = uvi.x;\r\n\t\t\t\t\tuvArray[ offset_uv + 1 ] = uvi.y;\r\n\r\n\t\t\t\t\toffset_uv += 2;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( offset_uv > 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, uvArray, hint );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyUvs && obj_uvs2 && uvType ) {\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tfi = chunk_faces3[ f ];\r\n\r\n\t\t\t\tuv2 = obj_uvs2[ fi ];\r\n\r\n\t\t\t\tif ( uv2 === undefined ) continue;\r\n\r\n\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\tuv2i = uv2[ i ];\r\n\r\n\t\t\t\t\tuv2Array[ offset_uv2 ]     = uv2i.x;\r\n\t\t\t\t\tuv2Array[ offset_uv2 + 1 ] = uv2i.y;\r\n\r\n\t\t\t\t\toffset_uv2 += 2;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tfi = chunk_faces4[ f ];\r\n\r\n\t\t\t\tuv2 = obj_uvs2[ fi ];\r\n\r\n\t\t\t\tif ( uv2 === undefined ) continue;\r\n\r\n\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\t\t\tuv2i = uv2[ i ];\r\n\r\n\t\t\t\t\tuv2Array[ offset_uv2 ]     = uv2i.x;\r\n\t\t\t\t\tuv2Array[ offset_uv2 + 1 ] = uv2i.y;\r\n\r\n\t\t\t\t\toffset_uv2 += 2;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( offset_uv2 > 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, uv2Array, hint );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyElements ) {\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tfaceArray[ offset_face ] \t = vertexIndex;\r\n\t\t\t\tfaceArray[ offset_face + 1 ] = vertexIndex + 1;\r\n\t\t\t\tfaceArray[ offset_face + 2 ] = vertexIndex + 2;\r\n\r\n\t\t\t\toffset_face += 3;\r\n\r\n\t\t\t\tlineArray[ offset_line ]     = vertexIndex;\r\n\t\t\t\tlineArray[ offset_line + 1 ] = vertexIndex + 1;\r\n\r\n\t\t\t\tlineArray[ offset_line + 2 ] = vertexIndex;\r\n\t\t\t\tlineArray[ offset_line + 3 ] = vertexIndex + 2;\r\n\r\n\t\t\t\tlineArray[ offset_line + 4 ] = vertexIndex + 1;\r\n\t\t\t\tlineArray[ offset_line + 5 ] = vertexIndex + 2;\r\n\r\n\t\t\t\toffset_line += 6;\r\n\r\n\t\t\t\tvertexIndex += 3;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tfaceArray[ offset_face ]     = vertexIndex;\r\n\t\t\t\tfaceArray[ offset_face + 1 ] = vertexIndex + 1;\r\n\t\t\t\tfaceArray[ offset_face + 2 ] = vertexIndex + 3;\r\n\r\n\t\t\t\tfaceArray[ offset_face + 3 ] = vertexIndex + 1;\r\n\t\t\t\tfaceArray[ offset_face + 4 ] = vertexIndex + 2;\r\n\t\t\t\tfaceArray[ offset_face + 5 ] = vertexIndex + 3;\r\n\r\n\t\t\t\toffset_face += 6;\r\n\r\n\t\t\t\tlineArray[ offset_line ]     = vertexIndex;\r\n\t\t\t\tlineArray[ offset_line + 1 ] = vertexIndex + 1;\r\n\r\n\t\t\t\tlineArray[ offset_line + 2 ] = vertexIndex;\r\n\t\t\t\tlineArray[ offset_line + 3 ] = vertexIndex + 3;\r\n\r\n\t\t\t\tlineArray[ offset_line + 4 ] = vertexIndex + 1;\r\n\t\t\t\tlineArray[ offset_line + 5 ] = vertexIndex + 2;\r\n\r\n\t\t\t\tlineArray[ offset_line + 6 ] = vertexIndex + 2;\r\n\t\t\t\tlineArray[ offset_line + 7 ] = vertexIndex + 3;\r\n\r\n\t\t\t\toffset_line += 8;\r\n\r\n\t\t\t\tvertexIndex += 4;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );\r\n\t\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, faceArray, hint );\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );\r\n\t\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, lineArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( customAttributes ) {\r\n\r\n\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tcustomAttribute = customAttributes[ i ];\r\n\r\n\t\t\t\tif ( ! customAttribute.__original.needsUpdate ) continue;\r\n\r\n\t\t\t\toffset_custom = 0;\r\n\t\t\t\toffset_customSrc = 0;\r\n\r\n\t\t\t\tif ( customAttribute.size === 1 ) {\r\n\r\n\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\" ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = customAttribute.value[ face.a ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];\r\n\r\n\t\t\t\t\t\t\toffset_custom += 3;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces4[ f ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = customAttribute.value[ face.a ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = customAttribute.value[ face.d ];\r\n\r\n\t\t\t\t\t\t\toffset_custom += 4;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.boundTo === \"faces\" ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = value;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = value;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = value;\r\n\r\n\t\t\t\t\t\t\toffset_custom += 3;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces4[ f ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = value;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = value;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = value;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = value;\r\n\r\n\t\t\t\t\t\t\toffset_custom += 4;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( customAttribute.size === 2 ) {\r\n\r\n\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\" ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\r\n\r\n\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\r\n\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\r\n\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1.y;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v2.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2.y;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v3.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v3.y;\r\n\r\n\t\t\t\t\t\t\toffset_custom += 6;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces4[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\r\n\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\r\n\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\r\n\t\t\t\t\t\t\tv4 = customAttribute.value[ face.d ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1.y;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v2.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2.y;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v3.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v3.y;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v4.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v4.y;\r\n\r\n\t\t\t\t\t\t\toffset_custom += 8;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.boundTo === \"faces\" ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = value;\r\n\t\t\t\t\t\t\tv2 = value;\r\n\t\t\t\t\t\t\tv3 = value;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1.y;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v2.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2.y;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v3.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v3.y;\r\n\r\n\t\t\t\t\t\t\toffset_custom += 6;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces4[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = value;\r\n\t\t\t\t\t\t\tv2 = value;\r\n\t\t\t\t\t\t\tv3 = value;\r\n\t\t\t\t\t\t\tv4 = value;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1.y;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v2.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2.y;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v3.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v3.y;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v4.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v4.y;\r\n\r\n\t\t\t\t\t\t\toffset_custom += 8;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( customAttribute.size === 3 ) {\r\n\r\n\t\t\t\t\tvar pp;\r\n\r\n\t\t\t\t\tif ( customAttribute.type === \"c\" ) {\r\n\r\n\t\t\t\t\t\tpp = [ \"r\", \"g\", \"b\" ];\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tpp = [ \"x\", \"y\", \"z\" ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\" ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\r\n\r\n\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\r\n\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\r\n\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\toffset_custom += 9;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces4[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\r\n\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\r\n\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\r\n\t\t\t\t\t\t\tv4 = customAttribute.value[ face.d ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v2[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v3[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v3[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v4[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v4[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v4[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\toffset_custom += 12;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.boundTo === \"faces\" ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = value;\r\n\t\t\t\t\t\t\tv2 = value;\r\n\t\t\t\t\t\t\tv3 = value;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\toffset_custom += 9;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces4[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = value;\r\n\t\t\t\t\t\t\tv2 = value;\r\n\t\t\t\t\t\t\tv3 = value;\r\n\t\t\t\t\t\t\tv4 = value;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v2[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v3[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v3[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v4[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v4[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v4[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\toffset_custom += 12;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.boundTo === \"faceVertices\" ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = value[ 0 ];\r\n\t\t\t\t\t\t\tv2 = value[ 1 ];\r\n\t\t\t\t\t\t\tv3 = value[ 2 ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\toffset_custom += 9;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces4[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = value[ 0 ];\r\n\t\t\t\t\t\t\tv2 = value[ 1 ];\r\n\t\t\t\t\t\t\tv3 = value[ 2 ];\r\n\t\t\t\t\t\t\tv4 = value[ 3 ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v2[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v3[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v3[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v4[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v4[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v4[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\toffset_custom += 12;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( customAttribute.size === 4 ) {\r\n\r\n\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\" ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\r\n\r\n\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\r\n\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\r\n\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\r\n\r\n\t\t\t\t\t\t\toffset_custom += 12;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces4[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\r\n\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\r\n\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\r\n\t\t\t\t\t\t\tv4 = customAttribute.value[ face.d ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 12 ] = v4.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 13 ] = v4.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 14 ] = v4.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 15 ] = v4.w;\r\n\r\n\t\t\t\t\t\t\toffset_custom += 16;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.boundTo === \"faces\" ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = value;\r\n\t\t\t\t\t\t\tv2 = value;\r\n\t\t\t\t\t\t\tv3 = value;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\r\n\r\n\t\t\t\t\t\t\toffset_custom += 12;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces4[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = value;\r\n\t\t\t\t\t\t\tv2 = value;\r\n\t\t\t\t\t\t\tv3 = value;\r\n\t\t\t\t\t\t\tv4 = value;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 12 ] = v4.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 13 ] = v4.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 14 ] = v4.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 15 ] = v4.w;\r\n\r\n\t\t\t\t\t\t\toffset_custom += 16;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.boundTo === \"faceVertices\" ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = value[ 0 ];\r\n\t\t\t\t\t\t\tv2 = value[ 1 ];\r\n\t\t\t\t\t\t\tv3 = value[ 2 ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\r\n\r\n\t\t\t\t\t\t\toffset_custom += 12;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces4[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = value[ 0 ];\r\n\t\t\t\t\t\t\tv2 = value[ 1 ];\r\n\t\t\t\t\t\t\tv3 = value[ 2 ];\r\n\t\t\t\t\t\t\tv4 = value[ 3 ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 12 ] = v4.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 13 ] = v4.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 14 ] = v4.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 15 ] = v4.w;\r\n\r\n\t\t\t\t\t\t\toffset_custom += 16;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( dispose ) {\r\n\r\n\t\t\tdelete geometryGroup.__inittedArrays;\r\n\t\t\tdelete geometryGroup.__colorArray;\r\n\t\t\tdelete geometryGroup.__normalArray;\r\n\t\t\tdelete geometryGroup.__tangentArray;\r\n\t\t\tdelete geometryGroup.__uvArray;\r\n\t\t\tdelete geometryGroup.__uv2Array;\r\n\t\t\tdelete geometryGroup.__faceArray;\r\n\t\t\tdelete geometryGroup.__vertexArray;\r\n\t\t\tdelete geometryGroup.__lineArray;\r\n\t\t\tdelete geometryGroup.__skinIndexArray;\r\n\t\t\tdelete geometryGroup.__skinWeightArray;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction setDirectBuffers ( geometry, hint, dispose ) {\r\n\r\n\t\tvar attributes = geometry.attributes;\r\n\r\n\t\tvar index = attributes[ \"index\" ];\r\n\t\tvar position = attributes[ \"position\" ];\r\n\t\tvar normal = attributes[ \"normal\" ];\r\n\t\tvar uv = attributes[ \"uv\" ];\r\n\t\tvar color = attributes[ \"color\" ];\r\n\t\tvar tangent = attributes[ \"tangent\" ];\r\n\r\n\t\tif ( geometry.elementsNeedUpdate && index !== undefined ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );\r\n\t\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, index.array, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.verticesNeedUpdate && position !== undefined ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, position.buffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, position.array, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.normalsNeedUpdate && normal !== undefined ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, normal.buffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, normal.array, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.uvsNeedUpdate && uv !== undefined ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, uv.buffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, uv.array, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.colorsNeedUpdate && color !== undefined ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, color.buffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, color.array, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.tangentsNeedUpdate && tangent !== undefined ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, tangent.buffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, tangent.array, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( dispose ) {\r\n\r\n\t\t\tfor ( var i in geometry.attributes ) {\r\n\r\n\t\t\t\tdelete geometry.attributes[ i ].array;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Buffer rendering\r\n\r\n\tthis.renderBufferImmediate = function ( object, program, material ) {\r\n\r\n\t\tif ( object.hasPositions && ! object.__webglVertexBuffer ) object.__webglVertexBuffer = _gl.createBuffer();\r\n\t\tif ( object.hasNormals && ! object.__webglNormalBuffer ) object.__webglNormalBuffer = _gl.createBuffer();\r\n\t\tif ( object.hasUvs && ! object.__webglUvBuffer ) object.__webglUvBuffer = _gl.createBuffer();\r\n\t\tif ( object.hasColors && ! object.__webglColorBuffer ) object.__webglColorBuffer = _gl.createBuffer();\r\n\r\n\t\tif ( object.hasPositions ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglVertexBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\r\n\t\t\t_gl.enableVertexAttribArray( program.attributes.position );\r\n\t\t\t_gl.vertexAttribPointer( program.attributes.position, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.hasNormals ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglNormalBuffer );\r\n\r\n\t\t\tif ( material.shading === THREE.FlatShading ) {\r\n\r\n\t\t\t\tvar nx, ny, nz,\r\n\t\t\t\t\tnax, nbx, ncx, nay, nby, ncy, naz, nbz, ncz,\r\n\t\t\t\t\tnormalArray,\r\n\t\t\t\t\ti, il = object.count * 3;\r\n\r\n\t\t\t\tfor( i = 0; i < il; i += 9 ) {\r\n\r\n\t\t\t\t\tnormalArray = object.normalArray;\r\n\r\n\t\t\t\t\tnax  = normalArray[ i ];\r\n\t\t\t\t\tnay  = normalArray[ i + 1 ];\r\n\t\t\t\t\tnaz  = normalArray[ i + 2 ];\r\n\r\n\t\t\t\t\tnbx  = normalArray[ i + 3 ];\r\n\t\t\t\t\tnby  = normalArray[ i + 4 ];\r\n\t\t\t\t\tnbz  = normalArray[ i + 5 ];\r\n\r\n\t\t\t\t\tncx  = normalArray[ i + 6 ];\r\n\t\t\t\t\tncy  = normalArray[ i + 7 ];\r\n\t\t\t\t\tncz  = normalArray[ i + 8 ];\r\n\r\n\t\t\t\t\tnx = ( nax + nbx + ncx ) / 3;\r\n\t\t\t\t\tny = ( nay + nby + ncy ) / 3;\r\n\t\t\t\t\tnz = ( naz + nbz + ncz ) / 3;\r\n\r\n\t\t\t\t\tnormalArray[ i ] \t = nx;\r\n\t\t\t\t\tnormalArray[ i + 1 ] = ny;\r\n\t\t\t\t\tnormalArray[ i + 2 ] = nz;\r\n\r\n\t\t\t\t\tnormalArray[ i + 3 ] = nx;\r\n\t\t\t\t\tnormalArray[ i + 4 ] = ny;\r\n\t\t\t\t\tnormalArray[ i + 5 ] = nz;\r\n\r\n\t\t\t\t\tnormalArray[ i + 6 ] = nx;\r\n\t\t\t\t\tnormalArray[ i + 7 ] = ny;\r\n\t\t\t\t\tnormalArray[ i + 8 ] = nz;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\r\n\t\t\t_gl.enableVertexAttribArray( program.attributes.normal );\r\n\t\t\t_gl.vertexAttribPointer( program.attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.hasUvs && material.map ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglUvBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\r\n\t\t\t_gl.enableVertexAttribArray( program.attributes.uv );\r\n\t\t\t_gl.vertexAttribPointer( program.attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.hasColors && material.vertexColors !== THREE.NoColors ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglColorBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\r\n\t\t\t_gl.enableVertexAttribArray( program.attributes.color );\r\n\t\t\t_gl.vertexAttribPointer( program.attributes.color, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\t_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\r\n\r\n\t\tobject.count = 0;\r\n\r\n\t};\r\n\r\n\tthis.renderBufferDirect = function ( camera, lights, fog, material, geometry, object ) {\r\n\r\n\t\tif ( material.visible === false ) return;\r\n\r\n\t\tvar program, attributes, linewidth, primitives, a, attribute;\r\n\r\n\t\tprogram = setProgram( camera, lights, fog, material, object );\r\n\r\n\t\tattributes = program.attributes;\r\n\r\n\t\tvar updateBuffers = false,\r\n\t\t\twireframeBit = material.wireframe ? 1 : 0,\r\n\t\t\tgeometryHash = ( geometry.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;\r\n\r\n\t\tif ( geometryHash !== _currentGeometryGroupHash ) {\r\n\r\n\t\t\t_currentGeometryGroupHash = geometryHash;\r\n\t\t\tupdateBuffers = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( updateBuffers ) {\r\n\r\n\t\t\tdisableAttributes();\r\n\r\n\t\t}\r\n\r\n\t\t// render mesh\r\n\r\n\t\tif ( object instanceof THREE.Mesh ) {\r\n\r\n\t\t\tvar index = geometry.attributes[ \"index\" ];\r\n\r\n\t\t\t// indexed triangles\r\n\r\n\t\t\tif ( index ) {\r\n\r\n\t\t\t\tvar offsets = geometry.offsets;\r\n\r\n\t\t\t\t// if there is more than 1 chunk\r\n\t\t\t\t// must set attribute pointers to use new offsets for each chunk\r\n\t\t\t\t// even if geometry and materials didn't change\r\n\r\n\t\t\t\tif ( offsets.length > 1 ) updateBuffers = true;\r\n\r\n\t\t\t\tfor ( var i = 0, il = offsets.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tvar startIndex = offsets[ i ].index;\r\n\r\n\t\t\t\t\tif ( updateBuffers ) {\r\n\r\n\t\t\t\t\t\t// vertices\r\n\r\n\t\t\t\t\t\tvar position = geometry.attributes[ \"position\" ];\r\n\t\t\t\t\t\tvar positionSize = position.itemSize;\r\n\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, position.buffer );\r\n\t\t\t\t\t\tenableAttribute( attributes.position );\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes.position, positionSize, _gl.FLOAT, false, 0, startIndex * positionSize * 4 ); // 4 bytes per Float32\r\n\r\n\t\t\t\t\t\t// normals\r\n\r\n\t\t\t\t\t\tvar normal = geometry.attributes[ \"normal\" ];\r\n\r\n\t\t\t\t\t\tif ( attributes.normal >= 0 && normal ) {\r\n\r\n\t\t\t\t\t\t\tvar normalSize = normal.itemSize;\r\n\r\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, normal.buffer );\r\n\t\t\t\t\t\t\tenableAttribute( attributes.normal );\r\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( attributes.normal, normalSize, _gl.FLOAT, false, 0, startIndex * normalSize * 4 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// uvs\r\n\r\n\t\t\t\t\t\tvar uv = geometry.attributes[ \"uv\" ];\r\n\r\n\t\t\t\t\t\tif ( attributes.uv >= 0 && uv ) {\r\n\r\n\t\t\t\t\t\t\tvar uvSize = uv.itemSize;\r\n\r\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, uv.buffer );\r\n\t\t\t\t\t\t\tenableAttribute( attributes.uv );\r\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( attributes.uv, uvSize, _gl.FLOAT, false, 0, startIndex * uvSize * 4 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// colors\r\n\r\n\t\t\t\t\t\tvar color = geometry.attributes[ \"color\" ];\r\n\r\n\t\t\t\t\t\tif ( attributes.color >= 0 && color ) {\r\n\r\n\t\t\t\t\t\t\tvar colorSize = color.itemSize;\r\n\r\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, color.buffer );\r\n\t\t\t\t\t\t\tenableAttribute( attributes.color );\r\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( attributes.color, colorSize, _gl.FLOAT, false, 0, startIndex * colorSize * 4 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// tangents\r\n\r\n\t\t\t\t\t\tvar tangent = geometry.attributes[ \"tangent\" ];\r\n\r\n\t\t\t\t\t\tif ( attributes.tangent >= 0 && tangent ) {\r\n\r\n\t\t\t\t\t\t\tvar tangentSize = tangent.itemSize;\r\n\r\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, tangent.buffer );\r\n\t\t\t\t\t\t\tenableAttribute( attributes.tangent );\r\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( attributes.tangent, tangentSize, _gl.FLOAT, false, 0, startIndex * tangentSize * 4 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// indices\r\n\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// render indexed triangles\r\n\r\n\t\t\t\t\t_gl.drawElements( _gl.TRIANGLES, offsets[ i ].count, _gl.UNSIGNED_SHORT, offsets[ i ].start * 2 ); // 2 bytes per Uint16\r\n\r\n\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t_this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared\r\n\t\t\t\t\t_this.info.render.faces += offsets[ i ].count / 3;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t// non-indexed triangles\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( updateBuffers ) {\r\n\r\n\t\t\t\t\t// vertices\r\n\r\n\t\t\t\t\tvar position = geometry.attributes[ \"position\" ];\r\n\t\t\t\t\tvar positionSize = position.itemSize;\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, position.buffer );\r\n\t\t\t\t\tenableAttribute( attributes.position );\r\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.position, positionSize, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t\t// normals\r\n\r\n\t\t\t\t\tvar normal = geometry.attributes[ \"normal\" ];\r\n\r\n\t\t\t\t\tif ( attributes.normal >= 0 && normal ) {\r\n\r\n\t\t\t\t\t\tvar normalSize = normal.itemSize;\r\n\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, normal.buffer );\r\n\t\t\t\t\t\tenableAttribute( attributes.normal );\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes.normal, normalSize, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// uvs\r\n\r\n\t\t\t\t\tvar uv = geometry.attributes[ \"uv\" ];\r\n\r\n\t\t\t\t\tif ( attributes.uv >= 0 && uv ) {\r\n\r\n\t\t\t\t\t\tvar uvSize = uv.itemSize;\r\n\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, uv.buffer );\r\n\t\t\t\t\t\tenableAttribute( attributes.uv );\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes.uv, uvSize, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// colors\r\n\r\n\t\t\t\t\tvar color = geometry.attributes[ \"color\" ];\r\n\r\n\t\t\t\t\tif ( attributes.color >= 0 && color ) {\r\n\r\n\t\t\t\t\t\tvar colorSize = color.itemSize;\r\n\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, color.buffer );\r\n\t\t\t\t\t\tenableAttribute( attributes.color );\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes.color, colorSize, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// tangents\r\n\r\n\t\t\t\t\tvar tangent = geometry.attributes[ \"tangent\" ];\r\n\r\n\t\t\t\t\tif ( attributes.tangent >= 0 && tangent ) {\r\n\r\n\t\t\t\t\t\tvar tangentSize = tangent.itemSize;\r\n\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, tangent.buffer );\r\n\t\t\t\t\t\tenableAttribute( attributes.tangent );\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes.tangent, tangentSize, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// render non-indexed triangles\r\n\r\n\t\t\t\t_gl.drawArrays( _gl.TRIANGLES, 0, position.numItems / 3 );\r\n\r\n\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t_this.info.render.vertices += position.numItems / 3;\r\n\t\t\t\t_this.info.render.faces += position.numItems / 3 / 3;\r\n\r\n\t\t\t}\r\n\r\n\t\t// render particles\r\n\r\n\t\t} else if ( object instanceof THREE.ParticleSystem ) {\r\n\r\n\t\t\tif ( updateBuffers ) {\r\n\r\n\t\t\t\t// vertices\r\n\r\n\t\t\t\tvar position = geometry.attributes[ \"position\" ];\r\n\t\t\t\tvar positionSize = position.itemSize;\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, position.buffer );\r\n\t\t\t\tenableAttribute( attributes.position );\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.position, positionSize, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t// colors\r\n\r\n\t\t\t\tvar color = geometry.attributes[ \"color\" ];\r\n\r\n\t\t\t\tif ( attributes.color >= 0 && color ) {\r\n\r\n\t\t\t\t\tvar colorSize = color.itemSize;\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, color.buffer );\r\n\t\t\t\t\tenableAttribute( attributes.color );\r\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.color, colorSize, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// render particles\r\n\r\n\t\t\t\t_gl.drawArrays( _gl.POINTS, 0, position.numItems / 3 );\r\n\r\n\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t_this.info.render.points += position.numItems / 3;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( object instanceof THREE.Line ) {\r\n\r\n\t\t\tif ( updateBuffers ) {\r\n\r\n\t\t\t\t// vertices\r\n\r\n\t\t\t\tvar position = geometry.attributes[ \"position\" ];\r\n\t\t\t\tvar positionSize = position.itemSize;\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, position.buffer );\r\n\t\t\t\tenableAttribute( attributes.position );\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.position, positionSize, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t// colors\r\n\r\n\t\t\t\tvar color = geometry.attributes[ \"color\" ];\r\n\r\n\t\t\t\tif ( attributes.color >= 0 && color ) {\r\n\r\n\t\t\t\t\tvar colorSize = color.itemSize;\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, color.buffer );\r\n\t\t\t\t\tenableAttribute( attributes.color );\r\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.color, colorSize, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// render lines\r\n\r\n\t\t\t\tsetLineWidth( material.linewidth );\r\n\r\n\t\t\t\t_gl.drawArrays( _gl.LINE_STRIP, 0, position.numItems / 3 );\r\n\r\n\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t_this.info.render.points += position.numItems;\r\n\r\n\t\t\t}\r\n\r\n    }\r\n\r\n\t};\r\n\r\n\tthis.renderBuffer = function ( camera, lights, fog, material, geometryGroup, object ) {\r\n\r\n\t\tif ( material.visible === false ) return;\r\n\r\n\t\tvar program, attributes, linewidth, primitives, a, attribute, i, il;\r\n\r\n\t\tprogram = setProgram( camera, lights, fog, material, object );\r\n\r\n\t\tattributes = program.attributes;\r\n\r\n\t\tvar updateBuffers = false,\r\n\t\t\twireframeBit = material.wireframe ? 1 : 0,\r\n\t\t\tgeometryGroupHash = ( geometryGroup.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;\r\n\r\n\t\tif ( geometryGroupHash !== _currentGeometryGroupHash ) {\r\n\r\n\t\t\t_currentGeometryGroupHash = geometryGroupHash;\r\n\t\t\tupdateBuffers = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( updateBuffers ) {\r\n\r\n\t\t\tdisableAttributes();\r\n\r\n\t\t}\r\n\r\n\t\t// vertices\r\n\r\n\t\tif ( !material.morphTargets && attributes.position >= 0 ) {\r\n\r\n\t\t\tif ( updateBuffers ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );\r\n\t\t\t\tenableAttribute( attributes.position );\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( object.morphTargetBase ) {\r\n\r\n\t\t\t\tsetupMorphTargets( material, geometryGroup, object );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\t\tif ( updateBuffers ) {\r\n\r\n\t\t\t// custom attributes\r\n\r\n\t\t\t// Use the per-geometryGroup custom attribute arrays which are setup in initMeshBuffers\r\n\r\n\t\t\tif ( geometryGroup.__webglCustomAttributesList ) {\r\n\r\n\t\t\t\tfor ( i = 0, il = geometryGroup.__webglCustomAttributesList.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tattribute = geometryGroup.__webglCustomAttributesList[ i ];\r\n\r\n\t\t\t\t\tif ( attributes[ attribute.buffer.belongsToAttribute ] >= 0 ) {\r\n\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, attribute.buffer );\r\n\t\t\t\t\t\tenableAttribute( attributes[ attribute.buffer.belongsToAttribute ] );\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes[ attribute.buffer.belongsToAttribute ], attribute.size, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\t// colors\r\n\r\n\t\t\tif ( attributes.color >= 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );\r\n\t\t\t\tenableAttribute( attributes.color );\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// normals\r\n\r\n\t\t\tif ( attributes.normal >= 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );\r\n\t\t\t\tenableAttribute( attributes.normal );\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// tangents\r\n\r\n\t\t\tif ( attributes.tangent >= 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );\r\n\t\t\t\tenableAttribute( attributes.tangent );\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.tangent, 4, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// uvs\r\n\r\n\t\t\tif ( attributes.uv >= 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );\r\n\t\t\t\tenableAttribute( attributes.uv );\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( attributes.uv2 >= 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );\r\n\t\t\t\tenableAttribute( attributes.uv2 );\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.uv2, 2, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( material.skinning &&\r\n\t\t\t\t attributes.skinIndex >= 0 && attributes.skinWeight >= 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );\r\n\t\t\t\tenableAttribute( attributes.skinIndex );\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.skinIndex, 4, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );\r\n\t\t\t\tenableAttribute( attributes.skinWeight );\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.skinWeight, 4, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// line distances\r\n\r\n\t\t\tif ( attributes.lineDistance >= 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglLineDistanceBuffer );\r\n\t\t\t\tenableAttribute( attributes.lineDistance );\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.lineDistance, 1, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// render mesh\r\n\r\n\t\tif ( object instanceof THREE.Mesh ) {\r\n\r\n\t\t\t// wireframe\r\n\r\n\t\t\tif ( material.wireframe ) {\r\n\r\n\t\t\t\tsetLineWidth( material.wireframeLinewidth );\r\n\r\n\t\t\t\tif ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );\r\n\t\t\t\t_gl.drawElements( _gl.LINES, geometryGroup.__webglLineCount, _gl.UNSIGNED_SHORT, 0 );\r\n\r\n\t\t\t// triangles\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );\r\n\t\t\t\t_gl.drawElements( _gl.TRIANGLES, geometryGroup.__webglFaceCount, _gl.UNSIGNED_SHORT, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_this.info.render.calls ++;\r\n\t\t\t_this.info.render.vertices += geometryGroup.__webglFaceCount;\r\n\t\t\t_this.info.render.faces += geometryGroup.__webglFaceCount / 3;\r\n\r\n\t\t// render lines\r\n\r\n\t\t} else if ( object instanceof THREE.Line ) {\r\n\r\n\t\t\tprimitives = ( object.type === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;\r\n\r\n\t\t\tsetLineWidth( material.linewidth );\r\n\r\n\t\t\t_gl.drawArrays( primitives, 0, geometryGroup.__webglLineCount );\r\n\r\n\t\t\t_this.info.render.calls ++;\r\n\r\n\t\t// render particles\r\n\r\n\t\t} else if ( object instanceof THREE.ParticleSystem ) {\r\n\r\n\t\t\t_gl.drawArrays( _gl.POINTS, 0, geometryGroup.__webglParticleCount );\r\n\r\n\t\t\t_this.info.render.calls ++;\r\n\t\t\t_this.info.render.points += geometryGroup.__webglParticleCount;\r\n\r\n\t\t// render ribbon\r\n\r\n\t\t} else if ( object instanceof THREE.Ribbon ) {\r\n\r\n\t\t\t_gl.drawArrays( _gl.TRIANGLE_STRIP, 0, geometryGroup.__webglVertexCount );\r\n\r\n\t\t\t_this.info.render.calls ++;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction enableAttribute( attribute ) {\r\n\r\n\t\tif ( ! _enabledAttributes[ attribute ] ) {\r\n\r\n\t\t\t_gl.enableVertexAttribArray( attribute );\r\n\t\t\t_enabledAttributes[ attribute ] = true;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction disableAttributes() {\r\n\r\n\t\tfor ( var attribute in _enabledAttributes ) {\r\n\r\n\t\t\tif ( _enabledAttributes[ attribute ] ) {\r\n\r\n\t\t\t\t_gl.disableVertexAttribArray( attribute );\r\n\t\t\t\t_enabledAttributes[ attribute ] = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction setupMorphTargets ( material, geometryGroup, object ) {\r\n\r\n\t\t// set base\r\n\r\n\t\tvar attributes = material.program.attributes;\r\n\r\n\t\tif ( object.morphTargetBase !== -1 && attributes.position >= 0 ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ object.morphTargetBase ] );\r\n\t\t\tenableAttribute( attributes.position );\r\n\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t} else if ( attributes.position >= 0 ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );\r\n\t\t\tenableAttribute( attributes.position );\r\n\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.morphTargetForcedOrder.length ) {\r\n\r\n\t\t\t// set forced order\r\n\r\n\t\t\tvar m = 0;\r\n\t\t\tvar order = object.morphTargetForcedOrder;\r\n\t\t\tvar influences = object.morphTargetInfluences;\r\n\r\n\t\t\twhile ( m < material.numSupportedMorphTargets && m < order.length ) {\r\n\r\n\t\t\t\tif ( attributes[ \"morphTarget\" + m ] >= 0 ) {\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ order[ m ] ] );\r\n\t\t\t\t\tenableAttribute( attributes[ \"morphTarget\" + m ] );\r\n\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphTarget\" + m ], 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( attributes[ \"morphNormal\" + m ] >= 0 && material.morphNormals ) {\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ order[ m ] ] );\r\n\t\t\t\t\tenableAttribute( attributes[ \"morphNormal\" + m ] );\r\n\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphNormal\" + m ], 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tobject.__webglMorphTargetInfluences[ m ] = influences[ order[ m ] ];\r\n\r\n\t\t\t\tm ++;\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// find the most influencing\r\n\r\n\t\t\tvar influence, activeInfluenceIndices = [];\r\n\t\t\tvar influences = object.morphTargetInfluences;\r\n\t\t\tvar i, il = influences.length;\r\n\r\n\t\t\tfor ( i = 0; i < il; i ++ ) {\r\n\r\n\t\t\t\tinfluence = influences[ i ];\r\n\r\n\t\t\t\tif ( influence > 0 ) {\r\n\r\n\t\t\t\t\tactiveInfluenceIndices.push( [ influence, i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( activeInfluenceIndices.length > material.numSupportedMorphTargets ) {\r\n\r\n\t\t\t\tactiveInfluenceIndices.sort( numericalSort );\r\n\t\t\t\tactiveInfluenceIndices.length = material.numSupportedMorphTargets;\r\n\r\n\t\t\t} else if ( activeInfluenceIndices.length > material.numSupportedMorphNormals ) {\r\n\r\n\t\t\t\tactiveInfluenceIndices.sort( numericalSort );\r\n\r\n\t\t\t} else if ( activeInfluenceIndices.length === 0 ) {\r\n\r\n\t\t\t\tactiveInfluenceIndices.push( [ 0, 0 ] );\r\n\r\n\t\t\t};\r\n\r\n\t\t\tvar influenceIndex, m = 0;\r\n\r\n\t\t\twhile ( m < material.numSupportedMorphTargets ) {\r\n\r\n\t\t\t\tif ( activeInfluenceIndices[ m ] ) {\r\n\r\n\t\t\t\t\tinfluenceIndex = activeInfluenceIndices[ m ][ 1 ];\r\n\r\n\t\t\t\t\tif ( attributes[ \"morphTarget\" + m ] >= 0 ) {\r\n\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ influenceIndex ] );\r\n\t\t\t\t\t\tenableAttribute( attributes[ \"morphTarget\" + m ] );\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphTarget\" + m ], 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( attributes[ \"morphNormal\" + m ] >= 0 && material.morphNormals ) {\r\n\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ influenceIndex ] );\r\n\t\t\t\t\t\tenableAttribute( attributes[ \"morphNormal\" + m ] );\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphNormal\" + m ], 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tobject.__webglMorphTargetInfluences[ m ] = influences[ influenceIndex ];\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphTarget\" + m ], 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t\tif ( material.morphNormals ) {\r\n\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphNormal\" + m ], 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\t*/\r\n\r\n\t\t\t\t\tobject.__webglMorphTargetInfluences[ m ] = 0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tm ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// load updated influences uniform\r\n\r\n\t\tif ( material.program.uniforms.morphTargetInfluences !== null ) {\r\n\r\n\t\t\t_gl.uniform1fv( material.program.uniforms.morphTargetInfluences, object.__webglMorphTargetInfluences );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Sorting\r\n\r\n\tfunction painterSortStable ( a, b ) {\r\n\r\n\t\tif ( a.z !== b.z ) {\r\n\r\n\t\t\treturn b.z - a.z;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn b.id - a.id;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction numericalSort ( a, b ) {\r\n\r\n\t\treturn b[ 0 ] - a[ 0 ];\r\n\r\n\t};\r\n\r\n\r\n\t// Rendering\r\n\r\n\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\r\n\r\n\t\tif ( camera instanceof THREE.Camera === false ) {\r\n\r\n\t\t\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar i, il,\r\n\r\n\t\twebglObject, object,\r\n\t\trenderList,\r\n\r\n\t\tlights = scene.__lights,\r\n\t\tfog = scene.fog;\r\n\r\n\t\t// reset caching for this frame\r\n\r\n\t\t_currentMaterialId = -1;\r\n\t\t_lightsNeedUpdate = true;\r\n\r\n\t\t// update scene graph\r\n\r\n\t\tif ( this.autoUpdateScene ) scene.updateMatrixWorld();\r\n\r\n\t\t// update camera matrices and frustum\r\n\r\n\t\tif ( camera.parent === undefined ) camera.updateMatrixWorld();\r\n\r\n\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\r\n\r\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\r\n\t\t_frustum.setFromMatrix( _projScreenMatrix );\r\n\r\n\t\t// update WebGL objects\r\n\r\n\t\tif ( this.autoUpdateObjects ) this.initWebGLObjects( scene );\r\n\r\n\t\t// custom render plugins (pre pass)\r\n\r\n\t\trenderPlugins( this.renderPluginsPre, scene, camera );\r\n\r\n\t\t//\r\n\r\n\t\t_this.info.render.calls = 0;\r\n\t\t_this.info.render.vertices = 0;\r\n\t\t_this.info.render.faces = 0;\r\n\t\t_this.info.render.points = 0;\r\n\r\n\t\tthis.setRenderTarget( renderTarget );\r\n\r\n\t\tif ( this.autoClear || forceClear ) {\r\n\r\n\t\t\tthis.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );\r\n\r\n\t\t}\r\n\r\n\t\t// set matrices for regular objects (frustum culled)\r\n\r\n\t\trenderList = scene.__webglObjects;\r\n\r\n\t\tfor ( i = 0, il = renderList.length; i < il; i ++ ) {\r\n\r\n\t\t\twebglObject = renderList[ i ];\r\n\t\t\tobject = webglObject.object;\r\n\r\n\t\t\twebglObject.render = false;\r\n\r\n\t\t\tif ( object.visible ) {\r\n\r\n\t\t\t\tif ( ! ( object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.intersectsObject( object ) ) {\r\n\r\n\t\t\t\t\tsetupMatrices( object, camera );\r\n\r\n\t\t\t\t\tunrollBufferMaterial( webglObject );\r\n\r\n\t\t\t\t\twebglObject.render = true;\r\n\r\n\t\t\t\t\tif ( this.sortObjects === true ) {\r\n\r\n\t\t\t\t\t\tif ( object.renderDepth !== null ) {\r\n\r\n\t\t\t\t\t\t\twebglObject.z = object.renderDepth;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t_vector3.getPositionFromMatrix( object.matrixWorld );\r\n\t\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\r\n\r\n\t\t\t\t\t\t\twebglObject.z = _vector3.z;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\twebglObject.id = object.id;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.sortObjects ) {\r\n\r\n\t\t\trenderList.sort( painterSortStable );\r\n\r\n\t\t}\r\n\r\n\t\t// set matrices for immediate objects\r\n\r\n\t\trenderList = scene.__webglObjectsImmediate;\r\n\r\n\t\tfor ( i = 0, il = renderList.length; i < il; i ++ ) {\r\n\r\n\t\t\twebglObject = renderList[ i ];\r\n\t\t\tobject = webglObject.object;\r\n\r\n\t\t\tif ( object.visible ) {\r\n\r\n\t\t\t\tsetupMatrices( object, camera );\r\n\r\n\t\t\t\tunrollImmediateBufferMaterial( webglObject );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( scene.overrideMaterial ) {\r\n\r\n\t\t\tvar material = scene.overrideMaterial;\r\n\r\n\t\t\tthis.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\r\n\t\t\tthis.setDepthTest( material.depthTest );\r\n\t\t\tthis.setDepthWrite( material.depthWrite );\r\n\t\t\tsetPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\r\n\r\n\t\t\trenderObjects( scene.__webglObjects, false, \"\", camera, lights, fog, true, material );\r\n\t\t\trenderObjectsImmediate( scene.__webglObjectsImmediate, \"\", camera, lights, fog, false, material );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar material = null;\r\n\r\n\t\t\t// opaque pass (front-to-back order)\r\n\r\n\t\t\tthis.setBlending( THREE.NoBlending );\r\n\r\n\t\t\trenderObjects( scene.__webglObjects, true, \"opaque\", camera, lights, fog, false, material );\r\n\t\t\trenderObjectsImmediate( scene.__webglObjectsImmediate, \"opaque\", camera, lights, fog, false, material );\r\n\r\n\t\t\t// transparent pass (back-to-front order)\r\n\r\n\t\t\trenderObjects( scene.__webglObjects, false, \"transparent\", camera, lights, fog, true, material );\r\n\t\t\trenderObjectsImmediate( scene.__webglObjectsImmediate, \"transparent\", camera, lights, fog, true, material );\r\n\r\n\t\t}\r\n\r\n\t\t// custom render plugins (post pass)\r\n\r\n\t\trenderPlugins( this.renderPluginsPost, scene, camera );\r\n\r\n\r\n\t\t// Generate mipmap if we're using any kind of mipmap filtering\r\n\r\n\t\tif ( renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter ) {\r\n\r\n\t\t\tupdateRenderTargetMipmap( renderTarget );\r\n\r\n\t\t}\r\n\r\n\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\r\n\r\n\t\tthis.setDepthTest( true );\r\n\t\tthis.setDepthWrite( true );\r\n\r\n\t\t// _gl.finish();\r\n\r\n\t};\r\n\r\n\tfunction renderPlugins( plugins, scene, camera ) {\r\n\r\n\t\tif ( ! plugins.length ) return;\r\n\r\n\t\tfor ( var i = 0, il = plugins.length; i < il; i ++ ) {\r\n\r\n\t\t\t// reset state for plugin (to start from clean slate)\r\n\r\n\t\t\t_currentProgram = null;\r\n\t\t\t_currentCamera = null;\r\n\r\n\t\t\t_oldBlending = -1;\r\n\t\t\t_oldDepthTest = -1;\r\n\t\t\t_oldDepthWrite = -1;\r\n\t\t\t_oldDoubleSided = -1;\r\n\t\t\t_oldFlipSided = -1;\r\n\t\t\t_currentGeometryGroupHash = -1;\r\n\t\t\t_currentMaterialId = -1;\r\n\r\n\t\t\t_lightsNeedUpdate = true;\r\n\r\n\t\t\tplugins[ i ].render( scene, camera, _currentWidth, _currentHeight );\r\n\r\n\t\t\t// reset state after plugin (anything could have changed)\r\n\r\n\t\t\t_currentProgram = null;\r\n\t\t\t_currentCamera = null;\r\n\r\n\t\t\t_oldBlending = -1;\r\n\t\t\t_oldDepthTest = -1;\r\n\t\t\t_oldDepthWrite = -1;\r\n\t\t\t_oldDoubleSided = -1;\r\n\t\t\t_oldFlipSided = -1;\r\n\t\t\t_currentGeometryGroupHash = -1;\r\n\t\t\t_currentMaterialId = -1;\r\n\r\n\t\t\t_lightsNeedUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction renderObjects ( renderList, reverse, materialType, camera, lights, fog, useBlending, overrideMaterial ) {\r\n\r\n\t\tvar webglObject, object, buffer, material, start, end, delta;\r\n\r\n\t\tif ( reverse ) {\r\n\r\n\t\t\tstart = renderList.length - 1;\r\n\t\t\tend = -1;\r\n\t\t\tdelta = -1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tstart = 0;\r\n\t\t\tend = renderList.length;\r\n\t\t\tdelta = 1;\r\n\t\t}\r\n\r\n\t\tfor ( var i = start; i !== end; i += delta ) {\r\n\r\n\t\t\twebglObject = renderList[ i ];\r\n\r\n\t\t\tif ( webglObject.render ) {\r\n\r\n\t\t\t\tobject = webglObject.object;\r\n\t\t\t\tbuffer = webglObject.buffer;\r\n\r\n\t\t\t\tif ( overrideMaterial ) {\r\n\r\n\t\t\t\t\tmaterial = overrideMaterial;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tmaterial = webglObject[ materialType ];\r\n\r\n\t\t\t\t\tif ( ! material ) continue;\r\n\r\n\t\t\t\t\tif ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\r\n\r\n\t\t\t\t\t_this.setDepthTest( material.depthTest );\r\n\t\t\t\t\t_this.setDepthWrite( material.depthWrite );\r\n\t\t\t\t\tsetPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_this.setMaterialFaces( material );\r\n\r\n\t\t\t\tif ( buffer instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\t\t\t_this.renderBufferDirect( camera, lights, fog, material, buffer, object );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t_this.renderBuffer( camera, lights, fog, material, buffer, object );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction renderObjectsImmediate ( renderList, materialType, camera, lights, fog, useBlending, overrideMaterial ) {\r\n\r\n\t\tvar webglObject, object, material, program;\r\n\r\n\t\tfor ( var i = 0, il = renderList.length; i < il; i ++ ) {\r\n\r\n\t\t\twebglObject = renderList[ i ];\r\n\t\t\tobject = webglObject.object;\r\n\r\n\t\t\tif ( object.visible ) {\r\n\r\n\t\t\t\tif ( overrideMaterial ) {\r\n\r\n\t\t\t\t\tmaterial = overrideMaterial;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tmaterial = webglObject[ materialType ];\r\n\r\n\t\t\t\t\tif ( ! material ) continue;\r\n\r\n\t\t\t\t\tif ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\r\n\r\n\t\t\t\t\t_this.setDepthTest( material.depthTest );\r\n\t\t\t\t\t_this.setDepthWrite( material.depthWrite );\r\n\t\t\t\t\tsetPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_this.renderImmediateObject( camera, lights, fog, material, object );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.renderImmediateObject = function ( camera, lights, fog, material, object ) {\r\n\r\n\t\tvar program = setProgram( camera, lights, fog, material, object );\r\n\r\n\t\t_currentGeometryGroupHash = -1;\r\n\r\n\t\t_this.setMaterialFaces( material );\r\n\r\n\t\tif ( object.immediateRenderCallback ) {\r\n\r\n\t\t\tobject.immediateRenderCallback( program, _gl, _frustum );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tobject.render( function( object ) { _this.renderBufferImmediate( object, program, material ); } );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction unrollImmediateBufferMaterial ( globject ) {\r\n\r\n\t\tvar object = globject.object,\r\n\t\t\tmaterial = object.material;\r\n\r\n\t\tif ( material.transparent ) {\r\n\r\n\t\t\tglobject.transparent = material;\r\n\t\t\tglobject.opaque = null;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tglobject.opaque = material;\r\n\t\t\tglobject.transparent = null;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction unrollBufferMaterial ( globject ) {\r\n\r\n\t\tvar object = globject.object,\r\n\t\t\tbuffer = globject.buffer,\r\n\t\t\tmaterial, materialIndex, meshMaterial;\r\n\r\n\t\tmeshMaterial = object.material;\r\n\r\n\t\tif ( meshMaterial instanceof THREE.MeshFaceMaterial ) {\r\n\r\n\t\t\tmaterialIndex = buffer.materialIndex;\r\n\r\n\t\t\tmaterial = meshMaterial.materials[ materialIndex ];\r\n\r\n\t\t\tif ( material.transparent ) {\r\n\r\n\t\t\t\tglobject.transparent = material;\r\n\t\t\t\tglobject.opaque = null;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tglobject.opaque = material;\r\n\t\t\t\tglobject.transparent = null;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmaterial = meshMaterial;\r\n\r\n\t\t\tif ( material ) {\r\n\r\n\t\t\t\tif ( material.transparent ) {\r\n\r\n\t\t\t\t\tglobject.transparent = material;\r\n\t\t\t\t\tglobject.opaque = null;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tglobject.opaque = material;\r\n\t\t\t\t\tglobject.transparent = null;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Geometry splitting\r\n\r\n\tfunction sortFacesByMaterial ( geometry, material ) {\r\n\r\n\t\tvar f, fl, face, materialIndex, vertices,\r\n\t\t\tgroupHash, hash_map = {};\r\n\r\n\t\tvar numMorphTargets = geometry.morphTargets.length;\r\n\t\tvar numMorphNormals = geometry.morphNormals.length;\r\n\r\n\t\tvar usesFaceMaterial = material instanceof THREE.MeshFaceMaterial;\r\n\r\n\t\tgeometry.geometryGroups = {};\r\n\r\n\t\tfor ( f = 0, fl = geometry.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = geometry.faces[ f ];\r\n\t\t\tmaterialIndex = usesFaceMaterial ? face.materialIndex : 0;\r\n\r\n\t\t\tif ( hash_map[ materialIndex ] === undefined ) {\r\n\r\n\t\t\t\thash_map[ materialIndex ] = { 'hash': materialIndex, 'counter': 0 };\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgroupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;\r\n\r\n\t\t\tif ( geometry.geometryGroups[ groupHash ] === undefined ) {\r\n\r\n\t\t\t\tgeometry.geometryGroups[ groupHash ] = { 'faces3': [], 'faces4': [], 'materialIndex': materialIndex, 'vertices': 0, 'numMorphTargets': numMorphTargets, 'numMorphNormals': numMorphNormals };\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvertices = face instanceof THREE.Face3 ? 3 : 4;\r\n\r\n\t\t\tif ( geometry.geometryGroups[ groupHash ].vertices + vertices > 65535 ) {\r\n\r\n\t\t\t\thash_map[ materialIndex ].counter += 1;\r\n\t\t\t\tgroupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;\r\n\r\n\t\t\t\tif ( geometry.geometryGroups[ groupHash ] === undefined ) {\r\n\r\n\t\t\t\t\tgeometry.geometryGroups[ groupHash ] = { 'faces3': [], 'faces4': [], 'materialIndex': materialIndex, 'vertices': 0, 'numMorphTargets': numMorphTargets, 'numMorphNormals': numMorphNormals };\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( face instanceof THREE.Face3 ) {\r\n\r\n\t\t\t\tgeometry.geometryGroups[ groupHash ].faces3.push( f );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tgeometry.geometryGroups[ groupHash ].faces4.push( f );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.geometryGroups[ groupHash ].vertices += vertices;\r\n\r\n\t\t}\r\n\r\n\t\tgeometry.geometryGroupsList = [];\r\n\r\n\t\tfor ( var g in geometry.geometryGroups ) {\r\n\r\n\t\t\tgeometry.geometryGroups[ g ].id = _geometryGroupCounter ++;\r\n\r\n\t\t\tgeometry.geometryGroupsList.push( geometry.geometryGroups[ g ] );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Objects refresh\r\n\r\n\tthis.initWebGLObjects = function ( scene ) {\r\n\r\n\t\tif ( !scene.__webglObjects ) {\r\n\r\n\t\t\tscene.__webglObjects = [];\r\n\t\t\tscene.__webglObjectsImmediate = [];\r\n\t\t\tscene.__webglSprites = [];\r\n\t\t\tscene.__webglFlares = [];\r\n\r\n\t\t}\r\n\r\n\t\twhile ( scene.__objectsAdded.length ) {\r\n\r\n\t\t\taddObject( scene.__objectsAdded[ 0 ], scene );\r\n\t\t\tscene.__objectsAdded.splice( 0, 1 );\r\n\r\n\t\t}\r\n\r\n\t\twhile ( scene.__objectsRemoved.length ) {\r\n\r\n\t\t\tremoveObject( scene.__objectsRemoved[ 0 ], scene );\r\n\t\t\tscene.__objectsRemoved.splice( 0, 1 );\r\n\r\n\t\t}\r\n\r\n\t\t// update must be called after objects adding / removal\r\n\r\n\t\tfor ( var o = 0, ol = scene.__webglObjects.length; o < ol; o ++ ) {\r\n\r\n\t\t\tupdateObject( scene.__webglObjects[ o ].object );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Objects adding\r\n\r\n\tfunction addObject ( object, scene ) {\r\n\r\n\t\tvar g, geometry, material, geometryGroup;\r\n\r\n\t\tif ( ! object.__webglInit ) {\r\n\r\n\t\t\tobject.__webglInit = true;\r\n\r\n\t\t\tobject._modelViewMatrix = new THREE.Matrix4();\r\n\t\t\tobject._normalMatrix = new THREE.Matrix3();\r\n\r\n\t\t\tif ( object.geometry !== undefined && object.geometry.__webglInit === undefined ) {\r\n\r\n\t\t\t\tobject.geometry.__webglInit = true;\r\n\t\t\t\tobject.geometry.addEventListener( 'dispose', onGeometryDispose );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( object instanceof THREE.Mesh ) {\r\n\r\n\t\t\t\tgeometry = object.geometry;\r\n\t\t\t\tmaterial = object.material;\r\n\r\n\t\t\t\tif ( geometry instanceof THREE.Geometry ) {\r\n\r\n\t\t\t\t\tif ( geometry.geometryGroups === undefined ) {\r\n\r\n\t\t\t\t\t\tsortFacesByMaterial( geometry, material );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// create separate VBOs per geometry chunk\r\n\r\n\t\t\t\t\tfor ( g in geometry.geometryGroups ) {\r\n\r\n\t\t\t\t\t\tgeometryGroup = geometry.geometryGroups[ g ];\r\n\r\n\t\t\t\t\t\t// initialise VBO on the first access\r\n\r\n\t\t\t\t\t\tif ( ! geometryGroup.__webglVertexBuffer ) {\r\n\r\n\t\t\t\t\t\t\tcreateMeshBuffers( geometryGroup );\r\n\t\t\t\t\t\t\tinitMeshBuffers( geometryGroup, object );\r\n\r\n\t\t\t\t\t\t\tgeometry.verticesNeedUpdate = true;\r\n\t\t\t\t\t\t\tgeometry.morphTargetsNeedUpdate = true;\r\n\t\t\t\t\t\t\tgeometry.elementsNeedUpdate = true;\r\n\t\t\t\t\t\t\tgeometry.uvsNeedUpdate = true;\r\n\t\t\t\t\t\t\tgeometry.normalsNeedUpdate = true;\r\n\t\t\t\t\t\t\tgeometry.tangentsNeedUpdate = true;\r\n\t\t\t\t\t\t\tgeometry.colorsNeedUpdate = true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\t\t\tinitDirectBuffers( geometry );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( object instanceof THREE.Ribbon ) {\r\n\r\n\t\t\t\tgeometry = object.geometry;\r\n\r\n\t\t\t\tif ( ! geometry.__webglVertexBuffer ) {\r\n\r\n\t\t\t\t\tcreateRibbonBuffers( geometry );\r\n\t\t\t\t\tinitRibbonBuffers( geometry, object );\r\n\r\n\t\t\t\t\tgeometry.verticesNeedUpdate = true;\r\n\t\t\t\t\tgeometry.colorsNeedUpdate = true;\r\n\t\t\t\t\tgeometry.normalsNeedUpdate = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( object instanceof THREE.Line ) {\r\n\r\n\t\t\t\tgeometry = object.geometry;\r\n\r\n\t\t\t\tif ( ! geometry.__webglVertexBuffer ) {\r\n\r\n\t\t\t\t\tif ( geometry instanceof THREE.Geometry ) {\r\n\r\n            createLineBuffers( geometry );\r\n            initLineBuffers( geometry, object );\r\n\r\n            geometry.verticesNeedUpdate = true;\r\n            geometry.colorsNeedUpdate = true;\r\n            geometry.lineDistancesNeedUpdate = true;\r\n\r\n          } else if ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\t\t\t\tinitDirectBuffers( geometry );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( object instanceof THREE.ParticleSystem ) {\r\n\r\n\t\t\t\tgeometry = object.geometry;\r\n\r\n\t\t\t\tif ( ! geometry.__webglVertexBuffer ) {\r\n\r\n\t\t\t\t\tif ( geometry instanceof THREE.Geometry ) {\r\n\r\n\t\t\t\t\t\tcreateParticleBuffers( geometry );\r\n\t\t\t\t\t\tinitParticleBuffers( geometry, object );\r\n\r\n\t\t\t\t\t\tgeometry.verticesNeedUpdate = true;\r\n\t\t\t\t\t\tgeometry.colorsNeedUpdate = true;\r\n\r\n\t\t\t\t\t} else if ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\t\t\t\tinitDirectBuffers( geometry );\r\n\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! object.__webglActive ) {\r\n\r\n\t\t\tif ( object instanceof THREE.Mesh ) {\r\n\r\n\t\t\t\tgeometry = object.geometry;\r\n\r\n\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\t\t\taddBuffer( scene.__webglObjects, geometry, object );\r\n\r\n\t\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\r\n\r\n\t\t\t\t\tfor ( g in geometry.geometryGroups ) {\r\n\r\n\t\t\t\t\t\tgeometryGroup = geometry.geometryGroups[ g ];\r\n\r\n\t\t\t\t\t\taddBuffer( scene.__webglObjects, geometryGroup, object );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( object instanceof THREE.Ribbon ||\r\n\t\t\t\t\t\tobject instanceof THREE.Line ||\r\n\t\t\t\t\t\tobject instanceof THREE.ParticleSystem ) {\r\n\r\n\t\t\t\tgeometry = object.geometry;\r\n\t\t\t\taddBuffer( scene.__webglObjects, geometry, object );\r\n\r\n\t\t\t} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {\r\n\r\n\t\t\t\taddBufferImmediate( scene.__webglObjectsImmediate, object );\r\n\r\n\t\t\t} else if ( object instanceof THREE.Sprite ) {\r\n\r\n\t\t\t\tscene.__webglSprites.push( object );\r\n\r\n\t\t\t} else if ( object instanceof THREE.LensFlare ) {\r\n\r\n\t\t\t\tscene.__webglFlares.push( object );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobject.__webglActive = true;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction addBuffer ( objlist, buffer, object ) {\r\n\r\n\t\tobjlist.push(\r\n\t\t\t{\r\n\t\t\t\tbuffer: buffer,\r\n\t\t\t\tobject: object,\r\n\t\t\t\topaque: null,\r\n\t\t\t\ttransparent: null\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t};\r\n\r\n\tfunction addBufferImmediate ( objlist, object ) {\r\n\r\n\t\tobjlist.push(\r\n\t\t\t{\r\n\t\t\t\tobject: object,\r\n\t\t\t\topaque: null,\r\n\t\t\t\ttransparent: null\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t};\r\n\r\n\t// Objects updates\r\n\r\n\tfunction updateObject ( object ) {\r\n\r\n\t\tvar geometry = object.geometry,\r\n\t\t\tgeometryGroup, customAttributesDirty, material;\r\n\r\n\t\tif ( object instanceof THREE.Mesh ) {\r\n\r\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\t\tif ( geometry.verticesNeedUpdate || geometry.elementsNeedUpdate ||\r\n\t\t\t\t\t geometry.uvsNeedUpdate || geometry.normalsNeedUpdate ||\r\n\t\t\t\t\t geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate ) {\r\n\r\n\t\t\t\t\tsetDirectBuffers( geometry, _gl.DYNAMIC_DRAW, !geometry.dynamic );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.verticesNeedUpdate = false;\r\n\t\t\t\tgeometry.elementsNeedUpdate = false;\r\n\t\t\t\tgeometry.uvsNeedUpdate = false;\r\n\t\t\t\tgeometry.normalsNeedUpdate = false;\r\n\t\t\t\tgeometry.colorsNeedUpdate = false;\r\n\t\t\t\tgeometry.tangentsNeedUpdate = false;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// check all geometry groups\r\n\r\n\t\t\t\tfor( var i = 0, il = geometry.geometryGroupsList.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tgeometryGroup = geometry.geometryGroupsList[ i ];\r\n\r\n\t\t\t\t\tmaterial = getBufferMaterial( object, geometryGroup );\r\n\r\n\t\t\t\t\tif ( geometry.buffersNeedUpdate ) {\r\n\r\n\t\t\t\t\t\tinitMeshBuffers( geometryGroup, object );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcustomAttributesDirty = material.attributes && areCustomAttributesDirty( material );\r\n\r\n\t\t\t\t\tif ( geometry.verticesNeedUpdate || geometry.morphTargetsNeedUpdate || geometry.elementsNeedUpdate ||\r\n\t\t\t\t\t\t geometry.uvsNeedUpdate || geometry.normalsNeedUpdate ||\r\n\t\t\t\t\t\t geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate || customAttributesDirty ) {\r\n\r\n\t\t\t\t\t\tsetMeshBuffers( geometryGroup, object, _gl.DYNAMIC_DRAW, !geometry.dynamic, material );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.verticesNeedUpdate = false;\r\n\t\t\t\tgeometry.morphTargetsNeedUpdate = false;\r\n\t\t\t\tgeometry.elementsNeedUpdate = false;\r\n\t\t\t\tgeometry.uvsNeedUpdate = false;\r\n\t\t\t\tgeometry.normalsNeedUpdate = false;\r\n\t\t\t\tgeometry.colorsNeedUpdate = false;\r\n\t\t\t\tgeometry.tangentsNeedUpdate = false;\r\n\r\n\t\t\t\tgeometry.buffersNeedUpdate = false;\r\n\r\n\t\t\t\tmaterial.attributes && clearCustomAttributes( material );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( object instanceof THREE.Ribbon ) {\r\n\r\n\t\t\tmaterial = getBufferMaterial( object, geometry );\r\n\r\n\t\t\tcustomAttributesDirty = material.attributes && areCustomAttributesDirty( material );\r\n\r\n\t\t\tif ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.normalsNeedUpdate || customAttributesDirty ) {\r\n\r\n\t\t\t\tsetRibbonBuffers( geometry, _gl.DYNAMIC_DRAW );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.verticesNeedUpdate = false;\r\n\t\t\tgeometry.colorsNeedUpdate = false;\r\n\t\t\tgeometry.normalsNeedUpdate = false;\r\n\r\n\t\t\tmaterial.attributes && clearCustomAttributes( material );\r\n\r\n\t\t} else if ( object instanceof THREE.Line ) {\r\n\r\n      if ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\t\tif ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate ) {\r\n\r\n\t\t\t\t\tsetDirectBuffers( geometry, _gl.DYNAMIC_DRAW, !geometry.dynamic );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.verticesNeedUpdate = false;\r\n\t\t\t\tgeometry.colorsNeedUpdate = false;\r\n\r\n\t\t\t} else {\r\n\r\n        material = getBufferMaterial( object, geometry );\r\n\r\n        customAttributesDirty = material.attributes && areCustomAttributesDirty( material );\r\n\r\n        if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.lineDistancesNeedUpdate || customAttributesDirty ) {\r\n\r\n          setLineBuffers( geometry, _gl.DYNAMIC_DRAW );\r\n\r\n        }\r\n\r\n        geometry.verticesNeedUpdate = false;\r\n        geometry.colorsNeedUpdate = false;\r\n        geometry.lineDistancesNeedUpdate = false;\r\n\r\n        material.attributes && clearCustomAttributes( material );\r\n\r\n      }\r\n\r\n\t\t} else if ( object instanceof THREE.ParticleSystem ) {\r\n\r\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\t\tif ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate ) {\r\n\r\n\t\t\t\t\tsetDirectBuffers( geometry, _gl.DYNAMIC_DRAW, !geometry.dynamic );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.verticesNeedUpdate = false;\r\n\t\t\t\tgeometry.colorsNeedUpdate = false;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tmaterial = getBufferMaterial( object, geometry );\r\n\r\n\t\t\t\tcustomAttributesDirty = material.attributes && areCustomAttributesDirty( material );\r\n\r\n\t\t\t\tif ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || object.sortParticles || customAttributesDirty ) {\r\n\r\n\t\t\t\t\tsetParticleBuffers( geometry, _gl.DYNAMIC_DRAW, object );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.verticesNeedUpdate = false;\r\n\t\t\t\tgeometry.colorsNeedUpdate = false;\r\n\r\n\t\t\t\tmaterial.attributes && clearCustomAttributes( material );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Objects updates - custom attributes check\r\n\r\n\tfunction areCustomAttributesDirty ( material ) {\r\n\r\n\t\tfor ( var a in material.attributes ) {\r\n\r\n\t\t\tif ( material.attributes[ a ].needsUpdate ) return true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t};\r\n\r\n\tfunction clearCustomAttributes ( material ) {\r\n\r\n\t\tfor ( var a in material.attributes ) {\r\n\r\n\t\t\tmaterial.attributes[ a ].needsUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Objects removal\r\n\r\n\tfunction removeObject ( object, scene ) {\r\n\r\n\t\tif ( object instanceof THREE.Mesh  ||\r\n\t\t\t object instanceof THREE.ParticleSystem ||\r\n\t\t\t object instanceof THREE.Ribbon ||\r\n\t\t\t object instanceof THREE.Line ) {\r\n\r\n\t\t\tremoveInstances( scene.__webglObjects, object );\r\n\r\n\t\t} else if ( object instanceof THREE.Sprite ) {\r\n\r\n\t\t\tremoveInstancesDirect( scene.__webglSprites, object );\r\n\r\n\t\t} else if ( object instanceof THREE.LensFlare ) {\r\n\r\n\t\t\tremoveInstancesDirect( scene.__webglFlares, object );\r\n\r\n\t\t} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {\r\n\r\n\t\t\tremoveInstances( scene.__webglObjectsImmediate, object );\r\n\r\n\t\t}\r\n\r\n\t\tobject.__webglActive = false;\r\n\r\n\t};\r\n\r\n\tfunction removeInstances ( objlist, object ) {\r\n\r\n\t\tfor ( var o = objlist.length - 1; o >= 0; o -- ) {\r\n\r\n\t\t\tif ( objlist[ o ].object === object ) {\r\n\r\n\t\t\t\tobjlist.splice( o, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction removeInstancesDirect ( objlist, object ) {\r\n\r\n\t\tfor ( var o = objlist.length - 1; o >= 0; o -- ) {\r\n\r\n\t\t\tif ( objlist[ o ] === object ) {\r\n\r\n\t\t\t\tobjlist.splice( o, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Materials\r\n\r\n\tthis.initMaterial = function ( material, lights, fog, object ) {\r\n\r\n\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\r\n\r\n\t\tvar u, a, identifiers, i, parameters, maxLightCount, maxBones, maxShadows, shaderID;\r\n\r\n\t\tif ( material instanceof THREE.MeshDepthMaterial ) {\r\n\r\n\t\t\tshaderID = 'depth';\r\n\r\n\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\r\n\r\n\t\t\tshaderID = 'normal';\r\n\r\n\t\t} else if ( material instanceof THREE.MeshBasicMaterial ) {\r\n\r\n\t\t\tshaderID = 'basic';\r\n\r\n\t\t} else if ( material instanceof THREE.MeshLambertMaterial ) {\r\n\r\n\t\t\tshaderID = 'lambert';\r\n\r\n\t\t} else if ( material instanceof THREE.MeshPhongMaterial ) {\r\n\r\n\t\t\tshaderID = 'phong';\r\n\r\n\t\t} else if ( material instanceof THREE.LineBasicMaterial ) {\r\n\r\n\t\t\tshaderID = 'basic';\r\n\r\n\t\t} else if ( material instanceof THREE.LineDashedMaterial ) {\r\n\r\n\t\t\tshaderID = 'dashed';\r\n\r\n\t\t} else if ( material instanceof THREE.ParticleBasicMaterial ) {\r\n\r\n\t\t\tshaderID = 'particle_basic';\r\n\r\n\t\t}\r\n\r\n\t\tif ( shaderID ) {\r\n\r\n\t\t\tsetMaterialShaders( material, THREE.ShaderLib[ shaderID ] );\r\n\r\n\t\t}\r\n\r\n\t\t// heuristics to create shader parameters according to lights in the scene\r\n\t\t// (not to blow over maxLights budget)\r\n\r\n\t\tmaxLightCount = allocateLights( lights );\r\n\r\n\t\tmaxShadows = allocateShadows( lights );\r\n\r\n\t\tmaxBones = allocateBones( object );\r\n\r\n\t\tparameters = {\r\n\r\n\t\t\tmap: !!material.map,\r\n\t\t\tenvMap: !!material.envMap,\r\n\t\t\tlightMap: !!material.lightMap,\r\n\t\t\tbumpMap: !!material.bumpMap,\r\n\t\t\tnormalMap: !!material.normalMap,\r\n\t\t\tspecularMap: !!material.specularMap,\r\n\r\n\t\t\tvertexColors: material.vertexColors,\r\n\r\n\t\t\tfog: fog,\r\n\t\t\tuseFog: material.fog,\r\n\t\t\tfogExp: fog instanceof THREE.FogExp2,\r\n\r\n\t\t\tsizeAttenuation: material.sizeAttenuation,\r\n\r\n\t\t\tskinning: material.skinning,\r\n\t\t\tmaxBones: maxBones,\r\n\t\t\tuseVertexTexture: _supportsBoneTextures && object && object.useVertexTexture,\r\n\t\t\tboneTextureWidth: object && object.boneTextureWidth,\r\n\t\t\tboneTextureHeight: object && object.boneTextureHeight,\r\n\r\n\t\t\tmorphTargets: material.morphTargets,\r\n\t\t\tmorphNormals: material.morphNormals,\r\n\t\t\tmaxMorphTargets: this.maxMorphTargets,\r\n\t\t\tmaxMorphNormals: this.maxMorphNormals,\r\n\r\n\t\t\tmaxDirLights: maxLightCount.directional,\r\n\t\t\tmaxPointLights: maxLightCount.point,\r\n\t\t\tmaxSpotLights: maxLightCount.spot,\r\n\t\t\tmaxHemiLights: maxLightCount.hemi,\r\n\r\n\t\t\tmaxShadows: maxShadows,\r\n\t\t\tshadowMapEnabled: this.shadowMapEnabled && object.receiveShadow,\r\n\t\t\tshadowMapType: this.shadowMapType,\r\n\t\t\tshadowMapDebug: this.shadowMapDebug,\r\n\t\t\tshadowMapCascade: this.shadowMapCascade,\r\n\r\n\t\t\talphaTest: material.alphaTest,\r\n\t\t\tmetal: material.metal,\r\n\t\t\tperPixel: material.perPixel,\r\n\t\t\twrapAround: material.wrapAround,\r\n\t\t\tdoubleSided: material.side === THREE.DoubleSide,\r\n\t\t\tflipSided: material.side === THREE.BackSide\r\n\r\n\t\t};\r\n\r\n\t\tmaterial.program = buildProgram( shaderID, material.fragmentShader, material.vertexShader, material.uniforms, material.attributes, material.defines, parameters );\r\n\r\n\t\tvar attributes = material.program.attributes;\r\n\r\n\t\tif ( material.morphTargets ) {\r\n\r\n\t\t\tmaterial.numSupportedMorphTargets = 0;\r\n\r\n\t\t\tvar id, base = \"morphTarget\";\r\n\r\n\t\t\tfor ( i = 0; i < this.maxMorphTargets; i ++ ) {\r\n\r\n\t\t\t\tid = base + i;\r\n\r\n\t\t\t\tif ( attributes[ id ] >= 0 ) {\r\n\r\n\t\t\t\t\tmaterial.numSupportedMorphTargets ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.morphNormals ) {\r\n\r\n\t\t\tmaterial.numSupportedMorphNormals = 0;\r\n\r\n\t\t\tvar id, base = \"morphNormal\";\r\n\r\n\t\t\tfor ( i = 0; i < this.maxMorphNormals; i ++ ) {\r\n\r\n\t\t\t\tid = base + i;\r\n\r\n\t\t\t\tif ( attributes[ id ] >= 0 ) {\r\n\r\n\t\t\t\t\tmaterial.numSupportedMorphNormals ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tmaterial.uniformsList = [];\r\n\r\n\t\tfor ( u in material.uniforms ) {\r\n\r\n\t\t\tmaterial.uniformsList.push( [ material.uniforms[ u ], u ] );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction setMaterialShaders( material, shaders ) {\r\n\r\n\t\tmaterial.uniforms = THREE.UniformsUtils.clone( shaders.uniforms );\r\n\t\tmaterial.vertexShader = shaders.vertexShader;\r\n\t\tmaterial.fragmentShader = shaders.fragmentShader;\r\n\r\n\t};\r\n\r\n\tfunction setProgram( camera, lights, fog, material, object ) {\r\n\r\n\t\t_usedTextureUnits = 0;\r\n\r\n\t\tif ( material.needsUpdate ) {\r\n\r\n\t\t\tif ( material.program ) deallocateMaterial( material );\r\n\r\n\t\t\t_this.initMaterial( material, lights, fog, object );\r\n\t\t\tmaterial.needsUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.morphTargets ) {\r\n\r\n\t\t\tif ( ! object.__webglMorphTargetInfluences ) {\r\n\r\n\t\t\t\tobject.__webglMorphTargetInfluences = new Float32Array( _this.maxMorphTargets );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar refreshMaterial = false;\r\n\r\n\t\tvar program = material.program,\r\n\t\t\tp_uniforms = program.uniforms,\r\n\t\t\tm_uniforms = material.uniforms;\r\n\r\n\t\tif ( program !== _currentProgram ) {\r\n\r\n\t\t\t_gl.useProgram( program );\r\n\t\t\t_currentProgram = program;\r\n\r\n\t\t\trefreshMaterial = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.id !== _currentMaterialId ) {\r\n\r\n\t\t\t_currentMaterialId = material.id;\r\n\t\t\trefreshMaterial = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( refreshMaterial || camera !== _currentCamera ) {\r\n\r\n\t\t\t_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\r\n\r\n\t\t\tif ( camera !== _currentCamera ) _currentCamera = camera;\r\n\r\n\t\t}\r\n\r\n\t\t// skinning uniforms must be set even if material didn't change\r\n\t\t// auto-setting of texture unit for bone texture must go before other textures\r\n\t\t// not sure why, but otherwise weird things happen\r\n\r\n\t\tif ( material.skinning ) {\r\n\r\n\t\t\tif ( _supportsBoneTextures && object.useVertexTexture ) {\r\n\r\n\t\t\t\tif ( p_uniforms.boneTexture !== null ) {\r\n\r\n\t\t\t\t\tvar textureUnit = getTextureUnit();\r\n\r\n\t\t\t\t\t_gl.uniform1i( p_uniforms.boneTexture, textureUnit );\r\n\t\t\t\t\t_this.setTexture( object.boneTexture, textureUnit );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( p_uniforms.boneGlobalMatrices !== null ) {\r\n\r\n\t\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.boneMatrices );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( refreshMaterial ) {\r\n\r\n\t\t\t// refresh uniforms common to several materials\r\n\r\n\t\t\tif ( fog && material.fog ) {\r\n\r\n\t\t\t\trefreshUniformsFog( m_uniforms, fog );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\r\n\t\t\t\t material.lights ) {\r\n\r\n\t\t\t\tif ( _lightsNeedUpdate ) {\r\n\r\n\t\t\t\t\tsetupLights( program, lights );\r\n\t\t\t\t\t_lightsNeedUpdate = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\trefreshUniformsLights( m_uniforms, _lights );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( material instanceof THREE.MeshBasicMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshPhongMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsCommon( m_uniforms, material );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// refresh single material specific uniforms\r\n\r\n\t\t\tif ( material instanceof THREE.LineBasicMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsLine( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.LineDashedMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsLine( m_uniforms, material );\r\n\t\t\t\trefreshUniformsDash( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.ParticleBasicMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsParticle( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshPhongMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsPhong( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshLambertMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsLambert( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshDepthMaterial ) {\r\n\r\n\t\t\t\tm_uniforms.mNear.value = camera.near;\r\n\t\t\t\tm_uniforms.mFar.value = camera.far;\r\n\t\t\t\tm_uniforms.opacity.value = material.opacity;\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\r\n\r\n\t\t\t\tm_uniforms.opacity.value = material.opacity;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( object.receiveShadow && ! material._shadowPass ) {\r\n\r\n\t\t\t\trefreshUniformsShadow( m_uniforms, lights );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// load common uniforms\r\n\r\n\t\t\tloadUniformsGeneric( program, material.uniformsList );\r\n\r\n\t\t\t// load material specific uniforms\r\n\t\t\t// (shader material also gets them for the sake of genericity)\r\n\r\n\t\t\tif ( material instanceof THREE.ShaderMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t material.envMap ) {\r\n\r\n\t\t\t\tif ( p_uniforms.cameraPosition !== null ) {\r\n\r\n\t\t\t\t\t_vector3.getPositionFromMatrix( camera.matrixWorld );\r\n\t\t\t\t\t_gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\r\n\t\t\t\t material instanceof THREE.ShaderMaterial ||\r\n\t\t\t\t material.skinning ) {\r\n\r\n\t\t\t\tif ( p_uniforms.viewMatrix !== null ) {\r\n\r\n\t\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tloadUniformsMatrices( p_uniforms, object );\r\n\r\n\t\tif ( p_uniforms.modelMatrix !== null ) {\r\n\r\n\t\t\t_gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );\r\n\r\n\t\t}\r\n\r\n\t\treturn program;\r\n\r\n\t};\r\n\r\n\t// Uniforms (refresh uniforms objects)\r\n\r\n\tfunction refreshUniformsCommon ( uniforms, material ) {\r\n\r\n\t\tuniforms.opacity.value = material.opacity;\r\n\r\n\t\tif ( _this.gammaInput ) {\r\n\r\n\t\t\tuniforms.diffuse.value.copyGammaToLinear( material.color );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tuniforms.diffuse.value = material.color;\r\n\r\n\t\t}\r\n\r\n\t\tuniforms.map.value = material.map;\r\n\t\tuniforms.lightMap.value = material.lightMap;\r\n\t\tuniforms.specularMap.value = material.specularMap;\r\n\r\n\t\tif ( material.bumpMap ) {\r\n\r\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\r\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.normalMap ) {\r\n\r\n\t\t\tuniforms.normalMap.value = material.normalMap;\r\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\r\n\r\n\t\t}\r\n\r\n\t\t// uv repeat and offset setting priorities\r\n\t\t//\t1. color map\r\n\t\t//\t2. specular map\r\n\t\t//\t3. normal map\r\n\t\t//\t4. bump map\r\n\r\n\t\tvar uvScaleMap;\r\n\r\n\t\tif ( material.map ) {\r\n\r\n\t\t\tuvScaleMap = material.map;\r\n\r\n\t\t} else if ( material.specularMap ) {\r\n\r\n\t\t\tuvScaleMap = material.specularMap;\r\n\r\n\t\t} else if ( material.normalMap ) {\r\n\r\n\t\t\tuvScaleMap = material.normalMap;\r\n\r\n\t\t} else if ( material.bumpMap ) {\r\n\r\n\t\t\tuvScaleMap = material.bumpMap;\r\n\r\n\t\t}\r\n\r\n\t\tif ( uvScaleMap !== undefined ) {\r\n\r\n\t\t\tvar offset = uvScaleMap.offset;\r\n\t\t\tvar repeat = uvScaleMap.repeat;\r\n\r\n\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\r\n\r\n\t\t}\r\n\r\n\t\tuniforms.envMap.value = material.envMap;\r\n\t\tuniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : -1;\r\n\r\n\t\tif ( _this.gammaInput ) {\r\n\r\n\t\t\t//uniforms.reflectivity.value = material.reflectivity * material.reflectivity;\r\n\t\t\tuniforms.reflectivity.value = material.reflectivity;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tuniforms.reflectivity.value = material.reflectivity;\r\n\r\n\t\t}\r\n\r\n\t\tuniforms.refractionRatio.value = material.refractionRatio;\r\n\t\tuniforms.combine.value = material.combine;\r\n\t\tuniforms.useRefract.value = material.envMap && material.envMap.mapping instanceof THREE.CubeRefractionMapping;\r\n\r\n\t};\r\n\r\n\tfunction refreshUniformsLine ( uniforms, material ) {\r\n\r\n\t\tuniforms.diffuse.value = material.color;\r\n\t\tuniforms.opacity.value = material.opacity;\r\n\r\n\t};\r\n\r\n\tfunction refreshUniformsDash ( uniforms, material ) {\r\n\r\n\t\tuniforms.dashSize.value = material.dashSize;\r\n\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\r\n\t\tuniforms.scale.value = material.scale;\r\n\r\n\t};\r\n\r\n\tfunction refreshUniformsParticle ( uniforms, material ) {\r\n\r\n\t\tuniforms.psColor.value = material.color;\r\n\t\tuniforms.opacity.value = material.opacity;\r\n\t\tuniforms.size.value = material.size;\r\n\t\tuniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.\r\n\r\n\t\tuniforms.map.value = material.map;\r\n\r\n\t};\r\n\r\n\tfunction refreshUniformsFog ( uniforms, fog ) {\r\n\r\n\t\tuniforms.fogColor.value = fog.color;\r\n\r\n\t\tif ( fog instanceof THREE.Fog ) {\r\n\r\n\t\t\tuniforms.fogNear.value = fog.near;\r\n\t\t\tuniforms.fogFar.value = fog.far;\r\n\r\n\t\t} else if ( fog instanceof THREE.FogExp2 ) {\r\n\r\n\t\t\tuniforms.fogDensity.value = fog.density;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction refreshUniformsPhong ( uniforms, material ) {\r\n\r\n\t\tuniforms.shininess.value = material.shininess;\r\n\r\n\t\tif ( _this.gammaInput ) {\r\n\r\n\t\t\tuniforms.ambient.value.copyGammaToLinear( material.ambient );\r\n\t\t\tuniforms.emissive.value.copyGammaToLinear( material.emissive );\r\n\t\t\tuniforms.specular.value.copyGammaToLinear( material.specular );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tuniforms.ambient.value = material.ambient;\r\n\t\t\tuniforms.emissive.value = material.emissive;\r\n\t\t\tuniforms.specular.value = material.specular;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.wrapAround ) {\r\n\r\n\t\t\tuniforms.wrapRGB.value.copy( material.wrapRGB );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction refreshUniformsLambert ( uniforms, material ) {\r\n\r\n\t\tif ( _this.gammaInput ) {\r\n\r\n\t\t\tuniforms.ambient.value.copyGammaToLinear( material.ambient );\r\n\t\t\tuniforms.emissive.value.copyGammaToLinear( material.emissive );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tuniforms.ambient.value = material.ambient;\r\n\t\t\tuniforms.emissive.value = material.emissive;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.wrapAround ) {\r\n\r\n\t\t\tuniforms.wrapRGB.value.copy( material.wrapRGB );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction refreshUniformsLights ( uniforms, lights ) {\r\n\r\n\t\tuniforms.ambientLightColor.value = lights.ambient;\r\n\r\n\t\tuniforms.directionalLightColor.value = lights.directional.colors;\r\n\t\tuniforms.directionalLightDirection.value = lights.directional.positions;\r\n\r\n\t\tuniforms.pointLightColor.value = lights.point.colors;\r\n\t\tuniforms.pointLightPosition.value = lights.point.positions;\r\n\t\tuniforms.pointLightDistance.value = lights.point.distances;\r\n\r\n\t\tuniforms.spotLightColor.value = lights.spot.colors;\r\n\t\tuniforms.spotLightPosition.value = lights.spot.positions;\r\n\t\tuniforms.spotLightDistance.value = lights.spot.distances;\r\n\t\tuniforms.spotLightDirection.value = lights.spot.directions;\r\n\t\tuniforms.spotLightAngleCos.value = lights.spot.anglesCos;\r\n\t\tuniforms.spotLightExponent.value = lights.spot.exponents;\r\n\r\n\t\tuniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;\r\n\t\tuniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;\r\n\t\tuniforms.hemisphereLightDirection.value = lights.hemi.positions;\r\n\r\n\t};\r\n\r\n\tfunction refreshUniformsShadow ( uniforms, lights ) {\r\n\r\n\t\tif ( uniforms.shadowMatrix ) {\r\n\r\n\t\t\tvar j = 0;\r\n\r\n\t\t\tfor ( var i = 0, il = lights.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvar light = lights[ i ];\r\n\r\n\t\t\t\tif ( ! light.castShadow ) continue;\r\n\r\n\t\t\t\tif ( light instanceof THREE.SpotLight || ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) ) {\r\n\r\n\t\t\t\t\tuniforms.shadowMap.value[ j ] = light.shadowMap;\r\n\t\t\t\t\tuniforms.shadowMapSize.value[ j ] = light.shadowMapSize;\r\n\r\n\t\t\t\t\tuniforms.shadowMatrix.value[ j ] = light.shadowMatrix;\r\n\r\n\t\t\t\t\tuniforms.shadowDarkness.value[ j ] = light.shadowDarkness;\r\n\t\t\t\t\tuniforms.shadowBias.value[ j ] = light.shadowBias;\r\n\r\n\t\t\t\t\tj ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Uniforms (load to GPU)\r\n\r\n\tfunction loadUniformsMatrices ( uniforms, object ) {\r\n\r\n\t\t_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object._modelViewMatrix.elements );\r\n\r\n\t\tif ( uniforms.normalMatrix ) {\r\n\r\n\t\t\t_gl.uniformMatrix3fv( uniforms.normalMatrix, false, object._normalMatrix.elements );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction getTextureUnit() {\r\n\r\n\t\tvar textureUnit = _usedTextureUnits;\r\n\r\n\t\tif ( textureUnit >= _maxTextures ) {\r\n\r\n\t\t\tconsole.warn( \"WebGLRenderer: trying to use \" + textureUnit + \" texture units while this GPU supports only \" + _maxTextures );\r\n\r\n\t\t}\r\n\r\n\t\t_usedTextureUnits += 1;\r\n\r\n\t\treturn textureUnit;\r\n\r\n\t};\r\n\r\n\tfunction loadUniformsGeneric ( program, uniforms ) {\r\n\r\n\t\tvar uniform, value, type, location, texture, textureUnit, i, il, j, jl, offset;\r\n\r\n\t\tfor ( j = 0, jl = uniforms.length; j < jl; j ++ ) {\r\n\r\n\t\t\tlocation = program.uniforms[ uniforms[ j ][ 1 ] ];\r\n\t\t\tif ( !location ) continue;\r\n\r\n\t\t\tuniform = uniforms[ j ][ 0 ];\r\n\r\n\t\t\ttype = uniform.type;\r\n\t\t\tvalue = uniform.value;\r\n\r\n\t\t\tif ( type === \"i\" ) { // single integer\r\n\r\n\t\t\t\t_gl.uniform1i( location, value );\r\n\r\n\t\t\t} else if ( type === \"f\" ) { // single float\r\n\r\n\t\t\t\t_gl.uniform1f( location, value );\r\n\r\n\t\t\t} else if ( type === \"v2\" ) { // single THREE.Vector2\r\n\r\n\t\t\t\t_gl.uniform2f( location, value.x, value.y );\r\n\r\n\t\t\t} else if ( type === \"v3\" ) { // single THREE.Vector3\r\n\r\n\t\t\t\t_gl.uniform3f( location, value.x, value.y, value.z );\r\n\r\n\t\t\t} else if ( type === \"v4\" ) { // single THREE.Vector4\r\n\r\n\t\t\t\t_gl.uniform4f( location, value.x, value.y, value.z, value.w );\r\n\r\n\t\t\t} else if ( type === \"c\" ) { // single THREE.Color\r\n\r\n\t\t\t\t_gl.uniform3f( location, value.r, value.g, value.b );\r\n\r\n\t\t\t} else if ( type === \"iv1\" ) { // flat array of integers (JS or typed array)\r\n\r\n\t\t\t\t_gl.uniform1iv( location, value );\r\n\r\n\t\t\t} else if ( type === \"iv\" ) { // flat array of integers with 3 x N size (JS or typed array)\r\n\r\n\t\t\t\t_gl.uniform3iv( location, value );\r\n\r\n\t\t\t} else if ( type === \"fv1\" ) { // flat array of floats (JS or typed array)\r\n\r\n\t\t\t\t_gl.uniform1fv( location, value );\r\n\r\n\t\t\t} else if ( type === \"fv\" ) { // flat array of floats with 3 x N size (JS or typed array)\r\n\r\n\t\t\t\t_gl.uniform3fv( location, value );\r\n\r\n\t\t\t} else if ( type === \"v2v\" ) { // array of THREE.Vector2\r\n\r\n\t\t\t\tif ( uniform._array === undefined ) {\r\n\r\n\t\t\t\t\tuniform._array = new Float32Array( 2 * value.length );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( i = 0, il = value.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\toffset = i * 2;\r\n\r\n\t\t\t\t\tuniform._array[ offset ] \t = value[ i ].x;\r\n\t\t\t\t\tuniform._array[ offset + 1 ] = value[ i ].y;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_gl.uniform2fv( location, uniform._array );\r\n\r\n\t\t\t} else if ( type === \"v3v\" ) { // array of THREE.Vector3\r\n\r\n\t\t\t\tif ( uniform._array === undefined ) {\r\n\r\n\t\t\t\t\tuniform._array = new Float32Array( 3 * value.length );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( i = 0, il = value.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\toffset = i * 3;\r\n\r\n\t\t\t\t\tuniform._array[ offset ] \t = value[ i ].x;\r\n\t\t\t\t\tuniform._array[ offset + 1 ] = value[ i ].y;\r\n\t\t\t\t\tuniform._array[ offset + 2 ] = value[ i ].z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_gl.uniform3fv( location, uniform._array );\r\n\r\n\t\t\t} else if ( type === \"v4v\" ) { // array of THREE.Vector4\r\n\r\n\t\t\t\tif ( uniform._array === undefined ) {\r\n\r\n\t\t\t\t\tuniform._array = new Float32Array( 4 * value.length );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( i = 0, il = value.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\toffset = i * 4;\r\n\r\n\t\t\t\t\tuniform._array[ offset ] \t = value[ i ].x;\r\n\t\t\t\t\tuniform._array[ offset + 1 ] = value[ i ].y;\r\n\t\t\t\t\tuniform._array[ offset + 2 ] = value[ i ].z;\r\n\t\t\t\t\tuniform._array[ offset + 3 ] = value[ i ].w;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_gl.uniform4fv( location, uniform._array );\r\n\r\n\t\t\t} else if ( type === \"m4\") { // single THREE.Matrix4\r\n\r\n\t\t\t\tif ( uniform._array === undefined ) {\r\n\r\n\t\t\t\t\tuniform._array = new Float32Array( 16 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvalue.flattenToArray( uniform._array );\r\n\t\t\t\t_gl.uniformMatrix4fv( location, false, uniform._array );\r\n\r\n\t\t\t} else if ( type === \"m4v\" ) { // array of THREE.Matrix4\r\n\r\n\t\t\t\tif ( uniform._array === undefined ) {\r\n\r\n\t\t\t\t\tuniform._array = new Float32Array( 16 * value.length );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( i = 0, il = value.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tvalue[ i ].flattenToArrayOffset( uniform._array, i * 16 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_gl.uniformMatrix4fv( location, false, uniform._array );\r\n\r\n\t\t\t} else if ( type === \"t\" ) { // single THREE.Texture (2d or cube)\r\n\r\n\t\t\t\ttexture = value;\r\n\t\t\t\ttextureUnit = getTextureUnit();\r\n\r\n\t\t\t\t_gl.uniform1i( location, textureUnit );\r\n\r\n\t\t\t\tif ( !texture ) continue;\r\n\r\n\t\t\t\tif ( texture.image instanceof Array && texture.image.length === 6 ) {\r\n\r\n\t\t\t\t\tsetCubeTexture( texture, textureUnit );\r\n\r\n\t\t\t\t} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {\r\n\r\n\t\t\t\t\tsetCubeTextureDynamic( texture, textureUnit );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t_this.setTexture( texture, textureUnit );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( type === \"tv\" ) { // array of THREE.Texture (2d)\r\n\r\n\t\t\t\tif ( uniform._array === undefined ) {\r\n\r\n\t\t\t\t\tuniform._array = [];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor( i = 0, il = uniform.value.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tuniform._array[ i ] = getTextureUnit();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_gl.uniform1iv( location, uniform._array );\r\n\r\n\t\t\t\tfor( i = 0, il = uniform.value.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\ttexture = uniform.value[ i ];\r\n\t\t\t\t\ttextureUnit = uniform._array[ i ];\r\n\r\n\t\t\t\t\tif ( !texture ) continue;\r\n\r\n\t\t\t\t\t_this.setTexture( texture, textureUnit );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction setupMatrices ( object, camera ) {\r\n\r\n\t\tobject._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\r\n\r\n\t\tobject._normalMatrix.getInverse( object._modelViewMatrix );\r\n\t\tobject._normalMatrix.transpose();\r\n\r\n\t};\r\n\r\n\t//\r\n\r\n\tfunction setColorGamma( array, offset, color, intensitySq ) {\r\n\r\n\t\tarray[ offset ]     = color.r * color.r * intensitySq;\r\n\t\tarray[ offset + 1 ] = color.g * color.g * intensitySq;\r\n\t\tarray[ offset + 2 ] = color.b * color.b * intensitySq;\r\n\r\n\t};\r\n\r\n\tfunction setColorLinear( array, offset, color, intensity ) {\r\n\r\n\t\tarray[ offset ]     = color.r * intensity;\r\n\t\tarray[ offset + 1 ] = color.g * intensity;\r\n\t\tarray[ offset + 2 ] = color.b * intensity;\r\n\r\n\t};\r\n\r\n\tfunction setupLights ( program, lights ) {\r\n\r\n\t\tvar l, ll, light, n,\r\n\t\tr = 0, g = 0, b = 0,\r\n\t\tcolor, skyColor, groundColor,\r\n\t\tintensity,  intensitySq,\r\n\t\tposition,\r\n\t\tdistance,\r\n\r\n\t\tzlights = _lights,\r\n\r\n\t\tdirColors = zlights.directional.colors,\r\n\t\tdirPositions = zlights.directional.positions,\r\n\r\n\t\tpointColors = zlights.point.colors,\r\n\t\tpointPositions = zlights.point.positions,\r\n\t\tpointDistances = zlights.point.distances,\r\n\r\n\t\tspotColors = zlights.spot.colors,\r\n\t\tspotPositions = zlights.spot.positions,\r\n\t\tspotDistances = zlights.spot.distances,\r\n\t\tspotDirections = zlights.spot.directions,\r\n\t\tspotAnglesCos = zlights.spot.anglesCos,\r\n\t\tspotExponents = zlights.spot.exponents,\r\n\r\n\t\themiSkyColors = zlights.hemi.skyColors,\r\n\t\themiGroundColors = zlights.hemi.groundColors,\r\n\t\themiPositions = zlights.hemi.positions,\r\n\r\n\t\tdirLength = 0,\r\n\t\tpointLength = 0,\r\n\t\tspotLength = 0,\r\n\t\themiLength = 0,\r\n\r\n\t\tdirCount = 0,\r\n\t\tpointCount = 0,\r\n\t\tspotCount = 0,\r\n\t\themiCount = 0,\r\n\r\n\t\tdirOffset = 0,\r\n\t\tpointOffset = 0,\r\n\t\tspotOffset = 0,\r\n\t\themiOffset = 0;\r\n\r\n\t\tfor ( l = 0, ll = lights.length; l < ll; l ++ ) {\r\n\r\n\t\t\tlight = lights[ l ];\r\n\r\n\t\t\tif ( light.onlyShadow ) continue;\r\n\r\n\t\t\tcolor = light.color;\r\n\t\t\tintensity = light.intensity;\r\n\t\t\tdistance = light.distance;\r\n\r\n\t\t\tif ( light instanceof THREE.AmbientLight ) {\r\n\r\n\t\t\t\tif ( ! light.visible ) continue;\r\n\r\n\t\t\t\tif ( _this.gammaInput ) {\r\n\r\n\t\t\t\t\tr += color.r * color.r;\r\n\t\t\t\t\tg += color.g * color.g;\r\n\t\t\t\t\tb += color.b * color.b;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tr += color.r;\r\n\t\t\t\t\tg += color.g;\r\n\t\t\t\t\tb += color.b;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\r\n\r\n\t\t\t\tdirCount += 1;\r\n\r\n\t\t\t\tif ( ! light.visible ) continue;\r\n\r\n\t\t\t\t_direction.getPositionFromMatrix( light.matrixWorld );\r\n\t\t\t\t_vector3.getPositionFromMatrix( light.target.matrixWorld );\r\n\t\t\t\t_direction.sub( _vector3 );\r\n\t\t\t\t_direction.normalize();\r\n\r\n\t\t\t\t// skip lights with undefined direction\r\n\t\t\t\t// these create troubles in OpenGL (making pixel black)\r\n\r\n\t\t\t\tif ( _direction.x === 0 && _direction.y === 0 && _direction.z === 0 ) continue;\r\n\r\n\t\t\t\tdirOffset = dirLength * 3;\r\n\r\n\t\t\t\tdirPositions[ dirOffset ]     = _direction.x;\r\n\t\t\t\tdirPositions[ dirOffset + 1 ] = _direction.y;\r\n\t\t\t\tdirPositions[ dirOffset + 2 ] = _direction.z;\r\n\r\n\t\t\t\tif ( _this.gammaInput ) {\r\n\r\n\t\t\t\t\tsetColorGamma( dirColors, dirOffset, color, intensity * intensity );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tsetColorLinear( dirColors, dirOffset, color, intensity );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdirLength += 1;\r\n\r\n\t\t\t} else if ( light instanceof THREE.PointLight ) {\r\n\r\n\t\t\t\tpointCount += 1;\r\n\r\n\t\t\t\tif ( ! light.visible ) continue;\r\n\r\n\t\t\t\tpointOffset = pointLength * 3;\r\n\r\n\t\t\t\tif ( _this.gammaInput ) {\r\n\r\n\t\t\t\t\tsetColorGamma( pointColors, pointOffset, color, intensity * intensity );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tsetColorLinear( pointColors, pointOffset, color, intensity );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_vector3.getPositionFromMatrix( light.matrixWorld );\r\n\r\n\t\t\t\tpointPositions[ pointOffset ]     = _vector3.x;\r\n\t\t\t\tpointPositions[ pointOffset + 1 ] = _vector3.y;\r\n\t\t\t\tpointPositions[ pointOffset + 2 ] = _vector3.z;\r\n\r\n\t\t\t\tpointDistances[ pointLength ] = distance;\r\n\r\n\t\t\t\tpointLength += 1;\r\n\r\n\t\t\t} else if ( light instanceof THREE.SpotLight ) {\r\n\r\n\t\t\t\tspotCount += 1;\r\n\r\n\t\t\t\tif ( ! light.visible ) continue;\r\n\r\n\t\t\t\tspotOffset = spotLength * 3;\r\n\r\n\t\t\t\tif ( _this.gammaInput ) {\r\n\r\n\t\t\t\t\tsetColorGamma( spotColors, spotOffset, color, intensity * intensity );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tsetColorLinear( spotColors, spotOffset, color, intensity );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_vector3.getPositionFromMatrix( light.matrixWorld );\r\n\r\n\t\t\t\tspotPositions[ spotOffset ]     = _vector3.x;\r\n\t\t\t\tspotPositions[ spotOffset + 1 ] = _vector3.y;\r\n\t\t\t\tspotPositions[ spotOffset + 2 ] = _vector3.z;\r\n\r\n\t\t\t\tspotDistances[ spotLength ] = distance;\r\n\r\n\t\t\t\t_direction.copy( _vector3 );\r\n\t\t\t\t_vector3.getPositionFromMatrix( light.target.matrixWorld );\r\n\t\t\t\t_direction.sub( _vector3 );\r\n\t\t\t\t_direction.normalize();\r\n\r\n\t\t\t\tspotDirections[ spotOffset ]     = _direction.x;\r\n\t\t\t\tspotDirections[ spotOffset + 1 ] = _direction.y;\r\n\t\t\t\tspotDirections[ spotOffset + 2 ] = _direction.z;\r\n\r\n\t\t\t\tspotAnglesCos[ spotLength ] = Math.cos( light.angle );\r\n\t\t\t\tspotExponents[ spotLength ] = light.exponent;\r\n\r\n\t\t\t\tspotLength += 1;\r\n\r\n\t\t\t} else if ( light instanceof THREE.HemisphereLight ) {\r\n\r\n\t\t\t\themiCount += 1;\r\n\r\n\t\t\t\tif ( ! light.visible ) continue;\r\n\r\n\t\t\t\t_direction.getPositionFromMatrix( light.matrixWorld );\r\n\t\t\t\t_direction.normalize();\r\n\r\n\t\t\t\t// skip lights with undefined direction\r\n\t\t\t\t// these create troubles in OpenGL (making pixel black)\r\n\r\n\t\t\t\tif ( _direction.x === 0 && _direction.y === 0 && _direction.z === 0 ) continue;\r\n\r\n\t\t\t\themiOffset = hemiLength * 3;\r\n\r\n\t\t\t\themiPositions[ hemiOffset ]     = _direction.x;\r\n\t\t\t\themiPositions[ hemiOffset + 1 ] = _direction.y;\r\n\t\t\t\themiPositions[ hemiOffset + 2 ] = _direction.z;\r\n\r\n\t\t\t\tskyColor = light.color;\r\n\t\t\t\tgroundColor = light.groundColor;\r\n\r\n\t\t\t\tif ( _this.gammaInput ) {\r\n\r\n\t\t\t\t\tintensitySq = intensity * intensity;\r\n\r\n\t\t\t\t\tsetColorGamma( hemiSkyColors, hemiOffset, skyColor, intensitySq );\r\n\t\t\t\t\tsetColorGamma( hemiGroundColors, hemiOffset, groundColor, intensitySq );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tsetColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );\r\n\t\t\t\t\tsetColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\themiLength += 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// null eventual remains from removed lights\r\n\t\t// (this is to avoid if in shader)\r\n\r\n\t\tfor ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l ++ ) dirColors[ l ] = 0.0;\r\n\t\tfor ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l ++ ) pointColors[ l ] = 0.0;\r\n\t\tfor ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l ++ ) spotColors[ l ] = 0.0;\r\n\t\tfor ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;\r\n\t\tfor ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;\r\n\r\n\t\tzlights.directional.length = dirLength;\r\n\t\tzlights.point.length = pointLength;\r\n\t\tzlights.spot.length = spotLength;\r\n\t\tzlights.hemi.length = hemiLength;\r\n\r\n\t\tzlights.ambient[ 0 ] = r;\r\n\t\tzlights.ambient[ 1 ] = g;\r\n\t\tzlights.ambient[ 2 ] = b;\r\n\r\n\t};\r\n\r\n\t// GL state setting\r\n\r\n\tthis.setFaceCulling = function ( cullFace, frontFaceDirection ) {\r\n\r\n\t\tif ( cullFace === THREE.CullFaceNone ) {\r\n\r\n\t\t\t_gl.disable( _gl.CULL_FACE );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {\r\n\r\n\t\t\t\t_gl.frontFace( _gl.CW );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.frontFace( _gl.CCW );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( cullFace === THREE.CullFaceBack ) {\r\n\r\n\t\t\t\t_gl.cullFace( _gl.BACK );\r\n\r\n\t\t\t} else if ( cullFace === THREE.CullFaceFront ) {\r\n\r\n\t\t\t\t_gl.cullFace( _gl.FRONT );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.cullFace( _gl.FRONT_AND_BACK );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.enable( _gl.CULL_FACE );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setMaterialFaces = function ( material ) {\r\n\r\n\t\tvar doubleSided = material.side === THREE.DoubleSide;\r\n\t\tvar flipSided = material.side === THREE.BackSide;\r\n\r\n\t\tif ( _oldDoubleSided !== doubleSided ) {\r\n\r\n\t\t\tif ( doubleSided ) {\r\n\r\n\t\t\t\t_gl.disable( _gl.CULL_FACE );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.enable( _gl.CULL_FACE );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_oldDoubleSided = doubleSided;\r\n\r\n\t\t}\r\n\r\n\t\tif ( _oldFlipSided !== flipSided ) {\r\n\r\n\t\t\tif ( flipSided ) {\r\n\r\n\t\t\t\t_gl.frontFace( _gl.CW );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.frontFace( _gl.CCW );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_oldFlipSided = flipSided;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setDepthTest = function ( depthTest ) {\r\n\r\n\t\tif ( _oldDepthTest !== depthTest ) {\r\n\r\n\t\t\tif ( depthTest ) {\r\n\r\n\t\t\t\t_gl.enable( _gl.DEPTH_TEST );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.disable( _gl.DEPTH_TEST );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_oldDepthTest = depthTest;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setDepthWrite = function ( depthWrite ) {\r\n\r\n\t\tif ( _oldDepthWrite !== depthWrite ) {\r\n\r\n\t\t\t_gl.depthMask( depthWrite );\r\n\t\t\t_oldDepthWrite = depthWrite;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction setLineWidth ( width ) {\r\n\r\n\t\tif ( width !== _oldLineWidth ) {\r\n\r\n\t\t\t_gl.lineWidth( width );\r\n\r\n\t\t\t_oldLineWidth = width;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction setPolygonOffset ( polygonoffset, factor, units ) {\r\n\r\n\t\tif ( _oldPolygonOffset !== polygonoffset ) {\r\n\r\n\t\t\tif ( polygonoffset ) {\r\n\r\n\t\t\t\t_gl.enable( _gl.POLYGON_OFFSET_FILL );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.disable( _gl.POLYGON_OFFSET_FILL );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_oldPolygonOffset = polygonoffset;\r\n\r\n\t\t}\r\n\r\n\t\tif ( polygonoffset && ( _oldPolygonOffsetFactor !== factor || _oldPolygonOffsetUnits !== units ) ) {\r\n\r\n\t\t\t_gl.polygonOffset( factor, units );\r\n\r\n\t\t\t_oldPolygonOffsetFactor = factor;\r\n\t\t\t_oldPolygonOffsetUnits = units;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setBlending = function ( blending, blendEquation, blendSrc, blendDst ) {\r\n\r\n\t\tif ( blending !== _oldBlending ) {\r\n\r\n\t\t\tif ( blending === THREE.NoBlending ) {\r\n\r\n\t\t\t\t_gl.disable( _gl.BLEND );\r\n\r\n\t\t\t} else if ( blending === THREE.AdditiveBlending ) {\r\n\r\n\t\t\t\t_gl.enable( _gl.BLEND );\r\n\t\t\t\t_gl.blendEquation( _gl.FUNC_ADD );\r\n\t\t\t\t_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE );\r\n\r\n\t\t\t} else if ( blending === THREE.SubtractiveBlending ) {\r\n\r\n\t\t\t\t// TODO: Find blendFuncSeparate() combination\r\n\t\t\t\t_gl.enable( _gl.BLEND );\r\n\t\t\t\t_gl.blendEquation( _gl.FUNC_ADD );\r\n\t\t\t\t_gl.blendFunc( _gl.ZERO, _gl.ONE_MINUS_SRC_COLOR );\r\n\r\n\t\t\t} else if ( blending === THREE.MultiplyBlending ) {\r\n\r\n\t\t\t\t// TODO: Find blendFuncSeparate() combination\r\n\t\t\t\t_gl.enable( _gl.BLEND );\r\n\t\t\t\t_gl.blendEquation( _gl.FUNC_ADD );\r\n\t\t\t\t_gl.blendFunc( _gl.ZERO, _gl.SRC_COLOR );\r\n\r\n\t\t\t} else if ( blending === THREE.CustomBlending ) {\r\n\r\n\t\t\t\t_gl.enable( _gl.BLEND );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.enable( _gl.BLEND );\r\n\t\t\t\t_gl.blendEquationSeparate( _gl.FUNC_ADD, _gl.FUNC_ADD );\r\n\t\t\t\t_gl.blendFuncSeparate( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA, _gl.ONE, _gl.ONE_MINUS_SRC_ALPHA );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_oldBlending = blending;\r\n\r\n\t\t}\r\n\r\n\t\tif ( blending === THREE.CustomBlending ) {\r\n\r\n\t\t\tif ( blendEquation !== _oldBlendEquation ) {\r\n\r\n\t\t\t\t_gl.blendEquation( paramThreeToGL( blendEquation ) );\r\n\r\n\t\t\t\t_oldBlendEquation = blendEquation;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( blendSrc !== _oldBlendSrc || blendDst !== _oldBlendDst ) {\r\n\r\n\t\t\t\t_gl.blendFunc( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ) );\r\n\r\n\t\t\t\t_oldBlendSrc = blendSrc;\r\n\t\t\t\t_oldBlendDst = blendDst;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_oldBlendEquation = null;\r\n\t\t\t_oldBlendSrc = null;\r\n\t\t\t_oldBlendDst = null;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Defines\r\n\r\n\tfunction generateDefines ( defines ) {\r\n\r\n\t\tvar value, chunk, chunks = [];\r\n\r\n\t\tfor ( var d in defines ) {\r\n\r\n\t\t\tvalue = defines[ d ];\r\n\t\t\tif ( value === false ) continue;\r\n\r\n\t\t\tchunk = \"#define \" + d + \" \" + value;\r\n\t\t\tchunks.push( chunk );\r\n\r\n\t\t}\r\n\r\n\t\treturn chunks.join( \"\\n\" );\r\n\r\n\t};\r\n\r\n\t// Shaders\r\n\r\n\tfunction buildProgram ( shaderID, fragmentShader, vertexShader, uniforms, attributes, defines, parameters ) {\r\n\r\n\t\tvar p, pl, d, program, code;\r\n\t\tvar chunks = [];\r\n\r\n\t\t// Generate code\r\n\r\n\t\tif ( shaderID ) {\r\n\r\n\t\t\tchunks.push( shaderID );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tchunks.push( fragmentShader );\r\n\t\t\tchunks.push( vertexShader );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( d in defines ) {\r\n\r\n\t\t\tchunks.push( d );\r\n\t\t\tchunks.push( defines[ d ] );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( p in parameters ) {\r\n\r\n\t\t\tchunks.push( p );\r\n\t\t\tchunks.push( parameters[ p ] );\r\n\r\n\t\t}\r\n\r\n\t\tcode = chunks.join();\r\n\r\n\t\t// Check if code has been already compiled\r\n\r\n\t\tfor ( p = 0, pl = _programs.length; p < pl; p ++ ) {\r\n\r\n\t\t\tvar programInfo = _programs[ p ];\r\n\r\n\t\t\tif ( programInfo.code === code ) {\r\n\r\n\t\t\t\t//console.log( \"Code already compiled.\" /*: \\n\\n\" + code*/ );\r\n\r\n\t\t\t\tprogramInfo.usedTimes ++;\r\n\r\n\t\t\t\treturn programInfo.program;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar shadowMapTypeDefine = \"SHADOWMAP_TYPE_BASIC\";\r\n\r\n\t\tif ( parameters.shadowMapType === THREE.PCFShadowMap ) {\r\n\r\n\t\t\tshadowMapTypeDefine = \"SHADOWMAP_TYPE_PCF\";\r\n\r\n\t\t} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {\r\n\r\n\t\t\tshadowMapTypeDefine = \"SHADOWMAP_TYPE_PCF_SOFT\";\r\n\r\n\t\t}\r\n\r\n\t\t//console.log( \"building new program \" );\r\n\r\n\t\t//\r\n\r\n\t\tvar customDefines = generateDefines( defines );\r\n\r\n\t\t//\r\n\r\n\t\tprogram = _gl.createProgram();\r\n\r\n\t\tvar prefix_vertex = [\r\n\r\n\t\t\t\"precision \" + _precision + \" float;\",\r\n\r\n\t\t\tcustomDefines,\r\n\r\n\t\t\t_supportsVertexTextures ? \"#define VERTEX_TEXTURES\" : \"\",\r\n\r\n\t\t\t_this.gammaInput ? \"#define GAMMA_INPUT\" : \"\",\r\n\t\t\t_this.gammaOutput ? \"#define GAMMA_OUTPUT\" : \"\",\r\n\t\t\t_this.physicallyBasedShading ? \"#define PHYSICALLY_BASED_SHADING\" : \"\",\r\n\r\n\t\t\t\"#define MAX_DIR_LIGHTS \" + parameters.maxDirLights,\r\n\t\t\t\"#define MAX_POINT_LIGHTS \" + parameters.maxPointLights,\r\n\t\t\t\"#define MAX_SPOT_LIGHTS \" + parameters.maxSpotLights,\r\n\t\t\t\"#define MAX_HEMI_LIGHTS \" + parameters.maxHemiLights,\r\n\r\n\t\t\t\"#define MAX_SHADOWS \" + parameters.maxShadows,\r\n\r\n\t\t\t\"#define MAX_BONES \" + parameters.maxBones,\r\n\r\n\t\t\tparameters.map ? \"#define USE_MAP\" : \"\",\r\n\t\t\tparameters.envMap ? \"#define USE_ENVMAP\" : \"\",\r\n\t\t\tparameters.lightMap ? \"#define USE_LIGHTMAP\" : \"\",\r\n\t\t\tparameters.bumpMap ? \"#define USE_BUMPMAP\" : \"\",\r\n\t\t\tparameters.normalMap ? \"#define USE_NORMALMAP\" : \"\",\r\n\t\t\tparameters.specularMap ? \"#define USE_SPECULARMAP\" : \"\",\r\n\t\t\tparameters.vertexColors ? \"#define USE_COLOR\" : \"\",\r\n\r\n\t\t\tparameters.skinning ? \"#define USE_SKINNING\" : \"\",\r\n\t\t\tparameters.useVertexTexture ? \"#define BONE_TEXTURE\" : \"\",\r\n\t\t\tparameters.boneTextureWidth ? \"#define N_BONE_PIXEL_X \" + parameters.boneTextureWidth.toFixed( 1 ) : \"\",\r\n\t\t\tparameters.boneTextureHeight ? \"#define N_BONE_PIXEL_Y \" + parameters.boneTextureHeight.toFixed( 1 ) : \"\",\r\n\r\n\t\t\tparameters.morphTargets ? \"#define USE_MORPHTARGETS\" : \"\",\r\n\t\t\tparameters.morphNormals ? \"#define USE_MORPHNORMALS\" : \"\",\r\n\t\t\tparameters.perPixel ? \"#define PHONG_PER_PIXEL\" : \"\",\r\n\t\t\tparameters.wrapAround ? \"#define WRAP_AROUND\" : \"\",\r\n\t\t\tparameters.doubleSided ? \"#define DOUBLE_SIDED\" : \"\",\r\n\t\t\tparameters.flipSided ? \"#define FLIP_SIDED\" : \"\",\r\n\r\n\t\t\tparameters.shadowMapEnabled ? \"#define USE_SHADOWMAP\" : \"\",\r\n\t\t\tparameters.shadowMapEnabled ? \"#define \" + shadowMapTypeDefine : \"\",\r\n\t\t\tparameters.shadowMapDebug ? \"#define SHADOWMAP_DEBUG\" : \"\",\r\n\t\t\tparameters.shadowMapCascade ? \"#define SHADOWMAP_CASCADE\" : \"\",\r\n\r\n\t\t\tparameters.sizeAttenuation ? \"#define USE_SIZEATTENUATION\" : \"\",\r\n\r\n\t\t\t\"uniform mat4 modelMatrix;\",\r\n\t\t\t\"uniform mat4 modelViewMatrix;\",\r\n\t\t\t\"uniform mat4 projectionMatrix;\",\r\n\t\t\t\"uniform mat4 viewMatrix;\",\r\n\t\t\t\"uniform mat3 normalMatrix;\",\r\n\t\t\t\"uniform vec3 cameraPosition;\",\r\n\r\n\t\t\t\"attribute vec3 position;\",\r\n\t\t\t\"attribute vec3 normal;\",\r\n\t\t\t\"attribute vec2 uv;\",\r\n\t\t\t\"attribute vec2 uv2;\",\r\n\r\n\t\t\t\"#ifdef USE_COLOR\",\r\n\r\n\t\t\t\t\"attribute vec3 color;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#ifdef USE_MORPHTARGETS\",\r\n\r\n\t\t\t\t\"attribute vec3 morphTarget0;\",\r\n\t\t\t\t\"attribute vec3 morphTarget1;\",\r\n\t\t\t\t\"attribute vec3 morphTarget2;\",\r\n\t\t\t\t\"attribute vec3 morphTarget3;\",\r\n\r\n\t\t\t\t\"#ifdef USE_MORPHNORMALS\",\r\n\r\n\t\t\t\t\t\"attribute vec3 morphNormal0;\",\r\n\t\t\t\t\t\"attribute vec3 morphNormal1;\",\r\n\t\t\t\t\t\"attribute vec3 morphNormal2;\",\r\n\t\t\t\t\t\"attribute vec3 morphNormal3;\",\r\n\r\n\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\"attribute vec3 morphTarget4;\",\r\n\t\t\t\t\t\"attribute vec3 morphTarget5;\",\r\n\t\t\t\t\t\"attribute vec3 morphTarget6;\",\r\n\t\t\t\t\t\"attribute vec3 morphTarget7;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#ifdef USE_SKINNING\",\r\n\r\n\t\t\t\t\"attribute vec4 skinIndex;\",\r\n\t\t\t\t\"attribute vec4 skinWeight;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"\"\r\n\r\n\t\t].join(\"\\n\");\r\n\r\n\t\tvar prefix_fragment = [\r\n\r\n\t\t\t\"precision \" + _precision + \" float;\",\r\n\r\n\t\t\t( parameters.bumpMap || parameters.normalMap ) ? \"#extension GL_OES_standard_derivatives : enable\" : \"\",\r\n\r\n\t\t\tcustomDefines,\r\n\r\n\t\t\t\"#define MAX_DIR_LIGHTS \" + parameters.maxDirLights,\r\n\t\t\t\"#define MAX_POINT_LIGHTS \" + parameters.maxPointLights,\r\n\t\t\t\"#define MAX_SPOT_LIGHTS \" + parameters.maxSpotLights,\r\n\t\t\t\"#define MAX_HEMI_LIGHTS \" + parameters.maxHemiLights,\r\n\r\n\t\t\t\"#define MAX_SHADOWS \" + parameters.maxShadows,\r\n\r\n\t\t\tparameters.alphaTest ? \"#define ALPHATEST \" + parameters.alphaTest: \"\",\r\n\r\n\t\t\t_this.gammaInput ? \"#define GAMMA_INPUT\" : \"\",\r\n\t\t\t_this.gammaOutput ? \"#define GAMMA_OUTPUT\" : \"\",\r\n\t\t\t_this.physicallyBasedShading ? \"#define PHYSICALLY_BASED_SHADING\" : \"\",\r\n\r\n\t\t\t( parameters.useFog && parameters.fog ) ? \"#define USE_FOG\" : \"\",\r\n\t\t\t( parameters.useFog && parameters.fogExp ) ? \"#define FOG_EXP2\" : \"\",\r\n\r\n\t\t\tparameters.map ? \"#define USE_MAP\" : \"\",\r\n\t\t\tparameters.envMap ? \"#define USE_ENVMAP\" : \"\",\r\n\t\t\tparameters.lightMap ? \"#define USE_LIGHTMAP\" : \"\",\r\n\t\t\tparameters.bumpMap ? \"#define USE_BUMPMAP\" : \"\",\r\n\t\t\tparameters.normalMap ? \"#define USE_NORMALMAP\" : \"\",\r\n\t\t\tparameters.specularMap ? \"#define USE_SPECULARMAP\" : \"\",\r\n\t\t\tparameters.vertexColors ? \"#define USE_COLOR\" : \"\",\r\n\r\n\t\t\tparameters.metal ? \"#define METAL\" : \"\",\r\n\t\t\tparameters.perPixel ? \"#define PHONG_PER_PIXEL\" : \"\",\r\n\t\t\tparameters.wrapAround ? \"#define WRAP_AROUND\" : \"\",\r\n\t\t\tparameters.doubleSided ? \"#define DOUBLE_SIDED\" : \"\",\r\n\t\t\tparameters.flipSided ? \"#define FLIP_SIDED\" : \"\",\r\n\r\n\t\t\tparameters.shadowMapEnabled ? \"#define USE_SHADOWMAP\" : \"\",\r\n\t\t\tparameters.shadowMapEnabled ? \"#define \" + shadowMapTypeDefine : \"\",\r\n\t\t\tparameters.shadowMapDebug ? \"#define SHADOWMAP_DEBUG\" : \"\",\r\n\t\t\tparameters.shadowMapCascade ? \"#define SHADOWMAP_CASCADE\" : \"\",\r\n\r\n\t\t\t\"uniform mat4 viewMatrix;\",\r\n\t\t\t\"uniform vec3 cameraPosition;\",\r\n\t\t\t\"\"\r\n\r\n\t\t].join(\"\\n\");\r\n\r\n\t\tvar glFragmentShader = getShader( \"fragment\", prefix_fragment + fragmentShader );\r\n\t\tvar glVertexShader = getShader( \"vertex\", prefix_vertex + vertexShader );\r\n\r\n\t\t_gl.attachShader( program, glVertexShader );\r\n\t\t_gl.attachShader( program, glFragmentShader );\r\n\r\n\t\t_gl.linkProgram( program );\r\n\r\n\t\tif ( !_gl.getProgramParameter( program, _gl.LINK_STATUS ) ) {\r\n\r\n\t\t\tconsole.error( \"Could not initialise shader\\n\" + \"VALIDATE_STATUS: \" + _gl.getProgramParameter( program, _gl.VALIDATE_STATUS ) + \", gl error [\" + _gl.getError() + \"]\" );\r\n\r\n\t\t}\r\n\r\n\t\t// clean up\r\n\r\n\t\t_gl.deleteShader( glFragmentShader );\r\n\t\t_gl.deleteShader( glVertexShader );\r\n\r\n\t\t//console.log( prefix_fragment + fragmentShader );\r\n\t\t//console.log( prefix_vertex + vertexShader );\r\n\r\n\t\tprogram.uniforms = {};\r\n\t\tprogram.attributes = {};\r\n\r\n\t\tvar identifiers, u, a, i;\r\n\r\n\t\t// cache uniform locations\r\n\r\n\t\tidentifiers = [\r\n\r\n\t\t\t'viewMatrix', 'modelViewMatrix', 'projectionMatrix', 'normalMatrix', 'modelMatrix', 'cameraPosition',\r\n\t\t\t'morphTargetInfluences'\r\n\r\n\t\t];\r\n\r\n\t\tif ( parameters.useVertexTexture ) {\r\n\r\n\t\t\tidentifiers.push( 'boneTexture' );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tidentifiers.push( 'boneGlobalMatrices' );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( u in uniforms ) {\r\n\r\n\t\t\tidentifiers.push( u );\r\n\r\n\t\t}\r\n\r\n\t\tcacheUniformLocations( program, identifiers );\r\n\r\n\t\t// cache attributes locations\r\n\r\n\t\tidentifiers = [\r\n\r\n\t\t\t\"position\", \"normal\", \"uv\", \"uv2\", \"tangent\", \"color\",\r\n\t\t\t\"skinIndex\", \"skinWeight\", \"lineDistance\"\r\n\r\n\t\t];\r\n\r\n\t\tfor ( i = 0; i < parameters.maxMorphTargets; i ++ ) {\r\n\r\n\t\t\tidentifiers.push( \"morphTarget\" + i );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( i = 0; i < parameters.maxMorphNormals; i ++ ) {\r\n\r\n\t\t\tidentifiers.push( \"morphNormal\" + i );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( a in attributes ) {\r\n\r\n\t\t\tidentifiers.push( a );\r\n\r\n\t\t}\r\n\r\n\t\tcacheAttributeLocations( program, identifiers );\r\n\r\n\t\tprogram.id = _programs_counter ++;\r\n\r\n\t\t_programs.push( { program: program, code: code, usedTimes: 1 } );\r\n\r\n\t\t_this.info.memory.programs = _programs.length;\r\n\r\n\t\treturn program;\r\n\r\n\t};\r\n\r\n\t// Shader parameters cache\r\n\r\n\tfunction cacheUniformLocations ( program, identifiers ) {\r\n\r\n\t\tvar i, l, id;\r\n\r\n\t\tfor( i = 0, l = identifiers.length; i < l; i ++ ) {\r\n\r\n\t\t\tid = identifiers[ i ];\r\n\t\t\tprogram.uniforms[ id ] = _gl.getUniformLocation( program, id );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction cacheAttributeLocations ( program, identifiers ) {\r\n\r\n\t\tvar i, l, id;\r\n\r\n\t\tfor( i = 0, l = identifiers.length; i < l; i ++ ) {\r\n\r\n\t\t\tid = identifiers[ i ];\r\n\t\t\tprogram.attributes[ id ] = _gl.getAttribLocation( program, id );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction addLineNumbers ( string ) {\r\n\r\n\t\tvar chunks = string.split( \"\\n\" );\r\n\r\n\t\tfor ( var i = 0, il = chunks.length; i < il; i ++ ) {\r\n\r\n\t\t\t// Chrome reports shader errors on lines\r\n\t\t\t// starting counting from 1\r\n\r\n\t\t\tchunks[ i ] = ( i + 1 ) + \": \" + chunks[ i ];\r\n\r\n\t\t}\r\n\r\n\t\treturn chunks.join( \"\\n\" );\r\n\r\n\t};\r\n\r\n\tfunction getShader ( type, string ) {\r\n\r\n\t\tvar shader;\r\n\r\n\t\tif ( type === \"fragment\" ) {\r\n\r\n\t\t\tshader = _gl.createShader( _gl.FRAGMENT_SHADER );\r\n\r\n\t\t} else if ( type === \"vertex\" ) {\r\n\r\n\t\t\tshader = _gl.createShader( _gl.VERTEX_SHADER );\r\n\r\n\t\t}\r\n\r\n\t\t_gl.shaderSource( shader, string );\r\n\t\t_gl.compileShader( shader );\r\n\r\n\t\tif ( !_gl.getShaderParameter( shader, _gl.COMPILE_STATUS ) ) {\r\n\r\n\t\t\tconsole.error( _gl.getShaderInfoLog( shader ) );\r\n\t\t\tconsole.error( addLineNumbers( string ) );\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\treturn shader;\r\n\r\n\t};\r\n\r\n\t// Textures\r\n\r\n\r\n\tfunction isPowerOfTwo ( value ) {\r\n\r\n\t\treturn ( value & ( value - 1 ) ) === 0;\r\n\r\n\t};\r\n\r\n\tfunction setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {\r\n\r\n\t\tif ( isImagePowerOfTwo ) {\r\n\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );\r\n\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\r\n\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( _glExtensionTextureFilterAnisotropic && texture.type !== THREE.FloatType ) {\r\n\r\n\t\t\tif ( texture.anisotropy > 1 || texture.__oldAnisotropy ) {\r\n\r\n\t\t\t\t_gl.texParameterf( textureType, _glExtensionTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _maxAnisotropy ) );\r\n\t\t\t\ttexture.__oldAnisotropy = texture.anisotropy;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setTexture = function ( texture, slot ) {\r\n\r\n\t\tif ( texture.needsUpdate ) {\r\n\r\n\t\t\tif ( ! texture.__webglInit ) {\r\n\r\n\t\t\t\ttexture.__webglInit = true;\r\n\r\n\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\r\n\r\n\t\t\t\ttexture.__webglTexture = _gl.createTexture();\r\n\r\n\t\t\t\t_this.info.memory.textures ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );\r\n\r\n\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\r\n\t\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\r\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\r\n\r\n\t\t\tvar image = texture.image,\r\n\t\t\tisImagePowerOfTwo = isPowerOfTwo( image.width ) && isPowerOfTwo( image.height ),\r\n\t\t\tglFormat = paramThreeToGL( texture.format ),\r\n\t\t\tglType = paramThreeToGL( texture.type );\r\n\r\n\t\t\tsetTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );\r\n\r\n\t\t\tvar mipmap, mipmaps = texture.mipmaps;\r\n\r\n\t\t\tif ( texture instanceof THREE.DataTexture ) {\r\n\r\n\t\t\t\t// use manually created mipmaps if available\r\n\t\t\t\t// if there are no manual mipmaps\r\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\r\n\r\n\t\t\t\tif ( mipmaps.length > 0 && isImagePowerOfTwo ) {\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\r\n\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttexture.generateMipmaps = false;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( texture instanceof THREE.CompressedTexture ) {\r\n\r\n\t\t\t\t// compressed textures can only use manually created mipmaps\r\n\t\t\t\t// WebGL can't generate mipmaps for DDS textures\r\n\r\n\t\t\t\tfor( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tmipmap = mipmaps[ i ];\r\n\t\t\t\t\t_gl.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else { // regular Texture (image, video, canvas)\r\n\r\n\t\t\t\t// use manually created mipmaps if available\r\n\t\t\t\t// if there are no manual mipmaps\r\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\r\n\r\n\t\t\t\tif ( mipmaps.length > 0 && isImagePowerOfTwo ) {\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\r\n\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttexture.generateMipmaps = false;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\r\n\r\n\t\t\ttexture.needsUpdate = false;\r\n\r\n\t\t\tif ( texture.onUpdate ) texture.onUpdate();\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction clampToMaxSize ( image, maxSize ) {\r\n\r\n\t\tif ( image.width <= maxSize && image.height <= maxSize ) {\r\n\r\n\t\t\treturn image;\r\n\r\n\t\t}\r\n\r\n\t\t// Warning: Scaling through the canvas will only work with images that use\r\n\t\t// premultiplied alpha.\r\n\r\n\t\tvar maxDimension = Math.max( image.width, image.height );\r\n\t\tvar newWidth = Math.floor( image.width * maxSize / maxDimension );\r\n\t\tvar newHeight = Math.floor( image.height * maxSize / maxDimension );\r\n\r\n\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\tcanvas.width = newWidth;\r\n\t\tcanvas.height = newHeight;\r\n\r\n\t\tvar ctx = canvas.getContext( \"2d\" );\r\n\t\tctx.drawImage( image, 0, 0, image.width, image.height, 0, 0, newWidth, newHeight );\r\n\r\n\t\treturn canvas;\r\n\r\n\t}\r\n\r\n\tfunction setCubeTexture ( texture, slot ) {\r\n\r\n\t\tif ( texture.image.length === 6 ) {\r\n\r\n\t\t\tif ( texture.needsUpdate ) {\r\n\r\n\t\t\t\tif ( ! texture.image.__webglTextureCube ) {\r\n\r\n\t\t\t\t\ttexture.image.__webglTextureCube = _gl.createTexture();\r\n\r\n\t\t\t\t\t_this.info.memory.textures ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );\r\n\r\n\t\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\r\n\r\n\t\t\t\tvar isCompressed = texture instanceof THREE.CompressedTexture;\r\n\r\n\t\t\t\tvar cubeImage = [];\r\n\r\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\t\tif ( _this.autoScaleCubemaps && ! isCompressed ) {\r\n\r\n\t\t\t\t\t\tcubeImage[ i ] = clampToMaxSize( texture.image[ i ], _maxCubemapSize );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tcubeImage[ i ] = texture.image[ i ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar image = cubeImage[ 0 ],\r\n\t\t\t\tisImagePowerOfTwo = isPowerOfTwo( image.width ) && isPowerOfTwo( image.height ),\r\n\t\t\t\tglFormat = paramThreeToGL( texture.format ),\r\n\t\t\t\tglType = paramThreeToGL( texture.type );\r\n\r\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );\r\n\r\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\t\tif ( isCompressed ) {\r\n\r\n\t\t\t\t\t\tvar mipmap, mipmaps = cubeImage[ i ].mipmaps;\r\n\r\n\t\t\t\t\t\tfor( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tmipmap = mipmaps[ j ];\r\n\t\t\t\t\t\t\t_gl.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( texture.generateMipmaps && isImagePowerOfTwo ) {\r\n\r\n\t\t\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttexture.needsUpdate = false;\r\n\r\n\t\t\t\tif ( texture.onUpdate ) texture.onUpdate();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction setCubeTextureDynamic ( texture, slot ) {\r\n\r\n\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.__webglTexture );\r\n\r\n\t};\r\n\r\n\t// Render targets\r\n\r\n\tfunction setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {\r\n\r\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, renderTarget.__webglTexture, 0 );\r\n\r\n\t};\r\n\r\n\tfunction setupRenderBuffer ( renderbuffer, renderTarget  ) {\r\n\r\n\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\r\n\r\n\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\r\n\r\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\r\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n\r\n\t\t/* For some reason this is not working. Defaulting to RGBA4.\r\n\t\t} else if( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\r\n\r\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );\r\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n\t\t*/\r\n\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\r\n\r\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\r\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setRenderTarget = function ( renderTarget ) {\r\n\r\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\r\n\r\n\t\tif ( renderTarget && ! renderTarget.__webglFramebuffer ) {\r\n\r\n\t\t\tif ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;\r\n\t\t\tif ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;\r\n\r\n\t\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\r\n\r\n\t\t\trenderTarget.__webglTexture = _gl.createTexture();\r\n\r\n\t\t\t_this.info.memory.textures ++;\r\n\r\n\t\t\t// Setup texture, create render and frame buffers\r\n\r\n\t\t\tvar isTargetPowerOfTwo = isPowerOfTwo( renderTarget.width ) && isPowerOfTwo( renderTarget.height ),\r\n\t\t\t\tglFormat = paramThreeToGL( renderTarget.format ),\r\n\t\t\t\tglType = paramThreeToGL( renderTarget.type );\r\n\r\n\t\t\tif ( isCube ) {\r\n\r\n\t\t\t\trenderTarget.__webglFramebuffer = [];\r\n\t\t\t\trenderTarget.__webglRenderbuffer = [];\r\n\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );\r\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo );\r\n\r\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\t\trenderTarget.__webglFramebuffer[ i ] = _gl.createFramebuffer();\r\n\t\t\t\t\trenderTarget.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();\r\n\r\n\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\r\n\r\n\t\t\t\t\tsetupFrameBuffer( renderTarget.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\r\n\t\t\t\t\tsetupRenderBuffer( renderTarget.__webglRenderbuffer[ i ], renderTarget );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\trenderTarget.__webglFramebuffer = _gl.createFramebuffer();\r\n\r\n\t\t\t\tif ( renderTarget.shareDepthFrom ) {\r\n\r\n\t\t\t\t\trenderTarget.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\trenderTarget.__webglRenderbuffer = _gl.createRenderbuffer();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );\r\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo );\r\n\r\n\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\r\n\r\n\t\t\t\tsetupFrameBuffer( renderTarget.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );\r\n\r\n\t\t\t\tif ( renderTarget.shareDepthFrom ) {\r\n\r\n\t\t\t\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\r\n\r\n\t\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );\r\n\r\n\t\t\t\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\r\n\r\n\t\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tsetupRenderBuffer( renderTarget.__webglRenderbuffer, renderTarget );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Release everything\r\n\r\n\t\t\tif ( isCube ) {\r\n\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, null );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\r\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\r\n\r\n\t\t}\r\n\r\n\t\tvar framebuffer, width, height, vx, vy;\r\n\r\n\t\tif ( renderTarget ) {\r\n\r\n\t\t\tif ( isCube ) {\r\n\r\n\t\t\t\tframebuffer = renderTarget.__webglFramebuffer[ renderTarget.activeCubeFace ];\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tframebuffer = renderTarget.__webglFramebuffer;\r\n\r\n\t\t\t}\r\n\r\n\t\t\twidth = renderTarget.width;\r\n\t\t\theight = renderTarget.height;\r\n\r\n\t\t\tvx = 0;\r\n\t\t\tvy = 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tframebuffer = null;\r\n\r\n\t\t\twidth = _viewportWidth;\r\n\t\t\theight = _viewportHeight;\r\n\r\n\t\t\tvx = _viewportX;\r\n\t\t\tvy = _viewportY;\r\n\r\n\t\t}\r\n\r\n\t\tif ( framebuffer !== _currentFramebuffer ) {\r\n\r\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\t\t\t_gl.viewport( vx, vy, width, height );\r\n\r\n\t\t\t_currentFramebuffer = framebuffer;\r\n\r\n\t\t}\r\n\r\n\t\t_currentWidth = width;\r\n\t\t_currentHeight = height;\r\n\r\n\t};\r\n\r\n\tfunction updateRenderTargetMipmap ( renderTarget ) {\r\n\r\n\t\tif ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {\r\n\r\n\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );\r\n\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\r\n\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );\r\n\t\t\t_gl.generateMipmap( _gl.TEXTURE_2D );\r\n\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, null );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Fallback filters for non-power-of-2 textures\r\n\r\n\tfunction filterFallback ( f ) {\r\n\r\n\t\tif ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {\r\n\r\n\t\t\treturn _gl.NEAREST;\r\n\r\n\t\t}\r\n\r\n\t\treturn _gl.LINEAR;\r\n\r\n\t};\r\n\r\n\t// Map three.js constants to WebGL constants\r\n\r\n\tfunction paramThreeToGL ( p ) {\r\n\r\n\t\tif ( p === THREE.RepeatWrapping ) return _gl.REPEAT;\r\n\t\tif ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;\r\n\t\tif ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;\r\n\r\n\t\tif ( p === THREE.NearestFilter ) return _gl.NEAREST;\r\n\t\tif ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;\r\n\t\tif ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;\r\n\r\n\t\tif ( p === THREE.LinearFilter ) return _gl.LINEAR;\r\n\t\tif ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;\r\n\t\tif ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;\r\n\r\n\t\tif ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;\r\n\t\tif ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;\r\n\t\tif ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;\r\n\t\tif ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;\r\n\r\n\t\tif ( p === THREE.ByteType ) return _gl.BYTE;\r\n\t\tif ( p === THREE.ShortType ) return _gl.SHORT;\r\n\t\tif ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;\r\n\t\tif ( p === THREE.IntType ) return _gl.INT;\r\n\t\tif ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;\r\n\t\tif ( p === THREE.FloatType ) return _gl.FLOAT;\r\n\r\n\t\tif ( p === THREE.AlphaFormat ) return _gl.ALPHA;\r\n\t\tif ( p === THREE.RGBFormat ) return _gl.RGB;\r\n\t\tif ( p === THREE.RGBAFormat ) return _gl.RGBA;\r\n\t\tif ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;\r\n\t\tif ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;\r\n\r\n\t\tif ( p === THREE.AddEquation ) return _gl.FUNC_ADD;\r\n\t\tif ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;\r\n\t\tif ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;\r\n\r\n\t\tif ( p === THREE.ZeroFactor ) return _gl.ZERO;\r\n\t\tif ( p === THREE.OneFactor ) return _gl.ONE;\r\n\t\tif ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;\r\n\t\tif ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;\r\n\t\tif ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;\r\n\t\tif ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;\r\n\t\tif ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;\r\n\t\tif ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;\r\n\r\n\t\tif ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;\r\n\t\tif ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;\r\n\t\tif ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;\r\n\r\n\t\tif ( _glExtensionCompressedTextureS3TC !== undefined ) {\r\n\r\n\t\t\tif ( p === THREE.RGB_S3TC_DXT1_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGB_S3TC_DXT1_EXT;\r\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT1_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT1_EXT;\r\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT3_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT;\r\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT5_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT;\r\n\r\n\t\t}\r\n\r\n\t\treturn 0;\r\n\r\n\t};\r\n\r\n\t// Allocations\r\n\r\n\tfunction allocateBones ( object ) {\r\n\r\n\t\tif ( _supportsBoneTextures && object && object.useVertexTexture ) {\r\n\r\n\t\t\treturn 1024;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// default for when object is not specified\r\n\t\t\t// ( for example when prebuilding shader\r\n\t\t\t//   to be used with multiple objects )\r\n\t\t\t//\r\n\t\t\t// \t- leave some extra space for other uniforms\r\n\t\t\t//  - limit here is ANGLE's 254 max uniform vectors\r\n\t\t\t//    (up to 54 should be safe)\r\n\r\n\t\t\tvar nVertexUniforms = _gl.getParameter( _gl.MAX_VERTEX_UNIFORM_VECTORS );\r\n\t\t\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\r\n\r\n\t\t\tvar maxBones = nVertexMatrices;\r\n\r\n\t\t\tif ( object !== undefined && object instanceof THREE.SkinnedMesh ) {\r\n\r\n\t\t\t\tmaxBones = Math.min( object.bones.length, maxBones );\r\n\r\n\t\t\t\tif ( maxBones < object.bones.length ) {\r\n\r\n\t\t\t\t\tconsole.warn( \"WebGLRenderer: too many bones - \" + object.bones.length + \", this GPU supports just \" + maxBones + \" (try OpenGL instead of ANGLE)\" );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn maxBones;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction allocateLights ( lights ) {\r\n\r\n\t\tvar l, ll, light, dirLights, pointLights, spotLights, hemiLights;\r\n\r\n\t\tdirLights = pointLights = spotLights = hemiLights = 0;\r\n\r\n\t\tfor ( l = 0, ll = lights.length; l < ll; l ++ ) {\r\n\r\n\t\t\tlight = lights[ l ];\r\n\r\n\t\t\tif ( light.onlyShadow ) continue;\r\n\r\n\t\t\tif ( light instanceof THREE.DirectionalLight ) dirLights ++;\r\n\t\t\tif ( light instanceof THREE.PointLight ) pointLights ++;\r\n\t\t\tif ( light instanceof THREE.SpotLight ) spotLights ++;\r\n\t\t\tif ( light instanceof THREE.HemisphereLight ) hemiLights ++;\r\n\r\n\t\t}\r\n\r\n\t\treturn { 'directional' : dirLights, 'point' : pointLights, 'spot': spotLights, 'hemi': hemiLights };\r\n\r\n\t};\r\n\r\n\tfunction allocateShadows ( lights ) {\r\n\r\n\t\tvar l, ll, light, maxShadows = 0;\r\n\r\n\t\tfor ( l = 0, ll = lights.length; l < ll; l++ ) {\r\n\r\n\t\t\tlight = lights[ l ];\r\n\r\n\t\t\tif ( ! light.castShadow ) continue;\r\n\r\n\t\t\tif ( light instanceof THREE.SpotLight ) maxShadows ++;\r\n\t\t\tif ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) maxShadows ++;\r\n\r\n\t\t}\r\n\r\n\t\treturn maxShadows;\r\n\r\n\t};\r\n\r\n\t// Initialization\r\n\r\n\tfunction initGL () {\r\n\r\n\t\ttry {\r\n\r\n\t\t\tif ( ! ( _gl = _canvas.getContext( 'experimental-webgl', { alpha: _alpha, premultipliedAlpha: _premultipliedAlpha, antialias: _antialias, stencil: _stencil, preserveDrawingBuffer: _preserveDrawingBuffer } ) ) ) {\r\n\r\n\t\t\t\tthrow 'Error creating WebGL context.';\r\n\r\n\t\t\t}\r\n\r\n\t\t} catch ( error ) {\r\n\r\n\t\t\tconsole.error( error );\r\n\r\n\t\t}\r\n\r\n\t\t_glExtensionTextureFloat = _gl.getExtension( 'OES_texture_float' );\r\n\t\t_glExtensionStandardDerivatives = _gl.getExtension( 'OES_standard_derivatives' );\r\n\r\n\t\t_glExtensionTextureFilterAnisotropic = _gl.getExtension( 'EXT_texture_filter_anisotropic' ) ||\r\n\t\t\t\t\t\t\t\t\t\t\t   _gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) ||\r\n\t\t\t\t\t\t\t\t\t\t\t   _gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\r\n\r\n\r\n\t\t_glExtensionCompressedTextureS3TC = _gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) ||\r\n\t\t\t\t\t\t\t\t\t\t\t_gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) ||\r\n\t\t\t\t\t\t\t\t\t\t\t_gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\r\n\r\n\t\tif ( ! _glExtensionTextureFloat ) {\r\n\r\n\t\t\tconsole.log( 'THREE.WebGLRenderer: Float textures not supported.' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! _glExtensionStandardDerivatives ) {\r\n\r\n\t\t\tconsole.log( 'THREE.WebGLRenderer: Standard derivatives not supported.' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! _glExtensionTextureFilterAnisotropic ) {\r\n\r\n\t\t\tconsole.log( 'THREE.WebGLRenderer: Anisotropic texture filtering not supported.' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! _glExtensionCompressedTextureS3TC ) {\r\n\r\n\t\t\tconsole.log( 'THREE.WebGLRenderer: S3TC compressed textures not supported.' );\r\n\r\n\t\t}\r\n\t\t\r\n\t\tif ( _gl.getShaderPrecisionFormat === undefined ) {\r\n\t\t\t\r\n\t\t\t_gl.getShaderPrecisionFormat = function() { \r\n\t\t\t\t\r\n\t\t\t\treturn {\r\n\t\t\t\t\t\"rangeMin\"  : 1,\r\n\t\t\t\t\t\"rangeMax\"  : 1,\r\n\t\t\t\t\t\"precision\" : 1\r\n\t\t\t\t};\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction setDefaultGLState () {\r\n\r\n\t\t_gl.clearColor( 0, 0, 0, 1 );\r\n\t\t_gl.clearDepth( 1 );\r\n\t\t_gl.clearStencil( 0 );\r\n\r\n\t\t_gl.enable( _gl.DEPTH_TEST );\r\n\t\t_gl.depthFunc( _gl.LEQUAL );\r\n\r\n\t\t_gl.frontFace( _gl.CCW );\r\n\t\t_gl.cullFace( _gl.BACK );\r\n\t\t_gl.enable( _gl.CULL_FACE );\r\n\r\n\t\t_gl.enable( _gl.BLEND );\r\n\t\t_gl.blendEquation( _gl.FUNC_ADD );\r\n\t\t_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA );\r\n\r\n\t\t_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\r\n\t};\r\n\r\n\t// default plugins (order is important)\r\n\r\n\tthis.shadowMapPlugin = new THREE.ShadowMapPlugin();\r\n\tthis.addPrePlugin( this.shadowMapPlugin );\r\n\r\n\tthis.addPostPlugin( new THREE.SpritePlugin() );\r\n\tthis.addPostPlugin( new THREE.LensFlarePlugin() );\r\n\r\n};\r\n/**\r\n * @author szimek / https://github.com/szimek/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.WebGLRenderTarget = function ( width, height, options ) {\r\n\r\n\tTHREE.EventDispatcher.call( this );\r\n\r\n\tthis.width = width;\r\n\tthis.height = height;\r\n\r\n\toptions = options || {};\r\n\r\n\tthis.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;\r\n\tthis.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;\r\n\r\n\tthis.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;\r\n\tthis.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;\r\n\r\n\tthis.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;\r\n\r\n\tthis.offset = new THREE.Vector2( 0, 0 );\r\n\tthis.repeat = new THREE.Vector2( 1, 1 );\r\n\r\n\tthis.format = options.format !== undefined ? options.format : THREE.RGBAFormat;\r\n\tthis.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;\r\n\r\n\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\r\n\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\r\n\r\n\tthis.generateMipmaps = true;\r\n\r\n\tthis.shareDepthFrom = null;\r\n\r\n};\r\n\r\nTHREE.WebGLRenderTarget.prototype.clone = function() {\r\n\r\n\tvar tmp = new THREE.WebGLRenderTarget( this.width, this.height );\r\n\r\n\ttmp.wrapS = this.wrapS;\r\n\ttmp.wrapT = this.wrapT;\r\n\r\n\ttmp.magFilter = this.magFilter;\r\n\ttmp.minFilter = this.minFilter;\r\n\r\n\ttmp.anisotropy = this.anisotropy;\r\n\r\n\ttmp.offset.copy( this.offset );\r\n\ttmp.repeat.copy( this.repeat );\r\n\r\n\ttmp.format = this.format;\r\n\ttmp.type = this.type;\r\n\r\n\ttmp.depthBuffer = this.depthBuffer;\r\n\ttmp.stencilBuffer = this.stencilBuffer;\r\n\r\n\ttmp.generateMipmaps = this.generateMipmaps;\r\n\r\n\ttmp.shareDepthFrom = this.shareDepthFrom;\r\n\r\n\treturn tmp;\r\n\r\n};\r\n\r\nTHREE.WebGLRenderTarget.prototype.dispose = function () {\r\n\r\n\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n};\r\n/**\r\n * @author alteredq / http://alteredqualia.com\r\n */\r\n\r\nTHREE.WebGLRenderTargetCube = function ( width, height, options ) {\r\n\r\n\tTHREE.WebGLRenderTarget.call( this, width, height, options );\r\n\r\n\tthis.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\r\n\r\n};\r\n\r\nTHREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.RenderableVertex = function () {\r\n\r\n\tthis.positionWorld = new THREE.Vector3();\r\n\tthis.positionScreen = new THREE.Vector4();\r\n\r\n\tthis.visible = true;\r\n\r\n};\r\n\r\nTHREE.RenderableVertex.prototype.copy = function ( vertex ) {\r\n\r\n\tthis.positionWorld.copy( vertex.positionWorld );\r\n\tthis.positionScreen.copy( vertex.positionScreen );\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.RenderableFace3 = function () {\r\n\r\n\tthis.v1 = new THREE.RenderableVertex();\r\n\tthis.v2 = new THREE.RenderableVertex();\r\n\tthis.v3 = new THREE.RenderableVertex();\r\n\r\n\tthis.centroidModel = new THREE.Vector3();\r\n\r\n\tthis.normalModel = new THREE.Vector3();\r\n\tthis.normalModelView = new THREE.Vector3();\r\n\r\n\tthis.vertexNormalsLength = 0;\r\n\tthis.vertexNormalsModel = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];\r\n\tthis.vertexNormalsModelView = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];\r\n\r\n\tthis.color = null;\r\n\tthis.material = null;\r\n\tthis.uvs = [[]];\r\n\r\n\tthis.z = null;\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.RenderableFace4 = function () {\r\n\r\n\tthis.v1 = new THREE.RenderableVertex();\r\n\tthis.v2 = new THREE.RenderableVertex();\r\n\tthis.v3 = new THREE.RenderableVertex();\r\n\tthis.v4 = new THREE.RenderableVertex();\r\n\r\n\tthis.centroidModel = new THREE.Vector3();\r\n\r\n\tthis.normalModel = new THREE.Vector3();\r\n\tthis.normalModelView = new THREE.Vector3();\r\n\r\n\tthis.vertexNormalsLength = 0;\r\n\tthis.vertexNormalsModel = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];\r\n\tthis.vertexNormalsModelView = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];\r\n\r\n\tthis.color = null;\r\n\tthis.material = null;\r\n\tthis.uvs = [[]];\r\n\r\n\tthis.z = null;\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.RenderableObject = function () {\r\n\r\n\tthis.object = null;\r\n\tthis.z = null;\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.RenderableParticle = function () {\r\n\r\n\tthis.object = null;\r\n\r\n\tthis.x = null;\r\n\tthis.y = null;\r\n\tthis.z = null;\r\n\r\n\tthis.rotation = null;\r\n\tthis.scale = new THREE.Vector2();\r\n\r\n\tthis.material = null;\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.RenderableLine = function () {\r\n\r\n\tthis.z = null;\r\n\r\n\tthis.v1 = new THREE.RenderableVertex();\r\n\tthis.v2 = new THREE.RenderableVertex();\r\n\r\n\tthis.material = null;\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.GeometryUtils = {\r\n\r\n\t// Merge two geometries or geometry and geometry from object (using object's transform)\r\n\r\n\tmerge: function ( geometry1, object2 /* mesh | geometry */ ) {\r\n\r\n\t\tvar matrix, normalMatrix,\r\n\t\tvertexOffset = geometry1.vertices.length,\r\n\t\tuvPosition = geometry1.faceVertexUvs[ 0 ].length,\r\n\t\tgeometry2 = object2 instanceof THREE.Mesh ? object2.geometry : object2,\r\n\t\tvertices1 = geometry1.vertices,\r\n\t\tvertices2 = geometry2.vertices,\r\n\t\tfaces1 = geometry1.faces,\r\n\t\tfaces2 = geometry2.faces,\r\n\t\tuvs1 = geometry1.faceVertexUvs[ 0 ],\r\n\t\tuvs2 = geometry2.faceVertexUvs[ 0 ];\r\n\r\n\t\tif ( object2 instanceof THREE.Mesh ) {\r\n\r\n\t\t\tobject2.matrixAutoUpdate && object2.updateMatrix();\r\n\r\n\t\t\tmatrix = object2.matrix;\r\n\r\n\t\t\tnormalMatrix = new THREE.Matrix3();\r\n\t\t\tnormalMatrix.getInverse( matrix );\r\n\t\t\tnormalMatrix.transpose();\r\n\r\n\t\t}\r\n\r\n\t\t// vertices\r\n\r\n\t\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar vertex = vertices2[ i ];\r\n\r\n\t\t\tvar vertexCopy = vertex.clone();\r\n\r\n\t\t\tif ( matrix ) vertexCopy.applyMatrix4( matrix );\r\n\r\n\t\t\tvertices1.push( vertexCopy );\r\n\r\n\t\t}\r\n\r\n\t\t// faces\r\n\r\n\t\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar face = faces2[ i ], faceCopy, normal, color,\r\n\t\t\tfaceVertexNormals = face.vertexNormals,\r\n\t\t\tfaceVertexColors = face.vertexColors;\r\n\r\n\t\t\tif ( face instanceof THREE.Face3 ) {\r\n\r\n\t\t\t\tfaceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\r\n\r\n\t\t\t} else if ( face instanceof THREE.Face4 ) {\r\n\r\n\t\t\t\tfaceCopy = new THREE.Face4( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset, face.d + vertexOffset );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfaceCopy.normal.copy( face.normal );\r\n\r\n\t\t\tif ( normalMatrix ) {\r\n\r\n\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tnormal = faceVertexNormals[ j ].clone();\r\n\r\n\t\t\t\tif ( normalMatrix ) {\r\n\r\n\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfaceCopy.vertexNormals.push( normal );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfaceCopy.color.copy( face.color );\r\n\r\n\t\t\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tcolor = faceVertexColors[ j ];\r\n\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfaceCopy.materialIndex = face.materialIndex;\r\n\r\n\t\t\tfaceCopy.centroid.copy( face.centroid );\r\n\r\n\t\t\tif ( matrix ) {\r\n\r\n\t\t\t\tfaceCopy.centroid.applyMatrix4( matrix );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfaces1.push( faceCopy );\r\n\r\n\t\t}\r\n\r\n\t\t// uvs\r\n\r\n\t\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar uv = uvs2[ i ], uvCopy = [];\r\n\r\n\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tuvCopy.push( new THREE.Vector2( uv[ j ].x, uv[ j ].y ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tuvs1.push( uvCopy );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tremoveMaterials: function ( geometry, materialIndexArray ) {\r\n\r\n\t\tvar materialIndexMap = {};\r\n\r\n\t\tfor ( var i = 0, il = materialIndexArray.length; i < il; i ++ ) {\r\n\r\n\t\t\tmaterialIndexMap[ materialIndexArray[i] ] = true;\r\n\r\n\t\t}\r\n\r\n\t\tvar face, newFaces = [];\r\n\r\n\t\tfor ( var i = 0, il = geometry.faces.length; i < il; i ++ ) {\r\n\r\n\t\t\tface = geometry.faces[ i ];\r\n\t\t\tif ( ! ( face.materialIndex in materialIndexMap ) ) newFaces.push( face );\r\n\r\n\t\t}\r\n\r\n\t\tgeometry.faces = newFaces;\r\n\r\n\t},\r\n\r\n\t// Get random point in triangle (via barycentric coordinates)\r\n\t// \t(uniform distribution)\r\n\t// \thttp://www.cgafaq.info/wiki/Random_Point_In_Triangle\r\n\r\n\trandomPointInTriangle: function ( vectorA, vectorB, vectorC ) {\r\n\r\n\t\tvar a, b, c,\r\n\t\t\tpoint = new THREE.Vector3(),\r\n\t\t\ttmp = THREE.GeometryUtils.__v1;\r\n\r\n\t\ta = THREE.GeometryUtils.random();\r\n\t\tb = THREE.GeometryUtils.random();\r\n\r\n\t\tif ( ( a + b ) > 1 ) {\r\n\r\n\t\t\ta = 1 - a;\r\n\t\t\tb = 1 - b;\r\n\r\n\t\t}\r\n\r\n\t\tc = 1 - a - b;\r\n\r\n\t\tpoint.copy( vectorA );\r\n\t\tpoint.multiplyScalar( a );\r\n\r\n\t\ttmp.copy( vectorB );\r\n\t\ttmp.multiplyScalar( b );\r\n\r\n\t\tpoint.add( tmp );\r\n\r\n\t\ttmp.copy( vectorC );\r\n\t\ttmp.multiplyScalar( c );\r\n\r\n\t\tpoint.add( tmp );\r\n\r\n\t\treturn point;\r\n\r\n\t},\r\n\r\n\t// Get random point in face (triangle / quad)\r\n\t// (uniform distribution)\r\n\r\n\trandomPointInFace: function ( face, geometry, useCachedAreas ) {\r\n\r\n\t\tvar vA, vB, vC, vD;\r\n\r\n\t\tif ( face instanceof THREE.Face3 ) {\r\n\r\n\t\t\tvA = geometry.vertices[ face.a ];\r\n\t\t\tvB = geometry.vertices[ face.b ];\r\n\t\t\tvC = geometry.vertices[ face.c ];\r\n\r\n\t\t\treturn THREE.GeometryUtils.randomPointInTriangle( vA, vB, vC );\r\n\r\n\t\t} else if ( face instanceof THREE.Face4 ) {\r\n\r\n\t\t\tvA = geometry.vertices[ face.a ];\r\n\t\t\tvB = geometry.vertices[ face.b ];\r\n\t\t\tvC = geometry.vertices[ face.c ];\r\n\t\t\tvD = geometry.vertices[ face.d ];\r\n\r\n\t\t\tvar area1, area2;\r\n\r\n\t\t\tif ( useCachedAreas ) {\r\n\r\n\t\t\t\tif ( face._area1 && face._area2 ) {\r\n\r\n\t\t\t\t\tarea1 = face._area1;\r\n\t\t\t\t\tarea2 = face._area2;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tarea1 = THREE.GeometryUtils.triangleArea( vA, vB, vD );\r\n\t\t\t\t\tarea2 = THREE.GeometryUtils.triangleArea( vB, vC, vD );\r\n\r\n\t\t\t\t\tface._area1 = area1;\r\n\t\t\t\t\tface._area2 = area2;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tarea1 = THREE.GeometryUtils.triangleArea( vA, vB, vD ),\r\n\t\t\t\tarea2 = THREE.GeometryUtils.triangleArea( vB, vC, vD );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar r = THREE.GeometryUtils.random() * ( area1 + area2 );\r\n\r\n\t\t\tif ( r < area1 ) {\r\n\r\n\t\t\t\treturn THREE.GeometryUtils.randomPointInTriangle( vA, vB, vD );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn THREE.GeometryUtils.randomPointInTriangle( vB, vC, vD );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t// Get uniformly distributed random points in mesh\r\n\t// \t- create array with cumulative sums of face areas\r\n\t//  - pick random number from 0 to total area\r\n\t//  - find corresponding place in area array by binary search\r\n\t//\t- get random point in face\r\n\r\n\trandomPointsInGeometry: function ( geometry, n ) {\r\n\r\n\t\tvar face, i,\r\n\t\t\tfaces = geometry.faces,\r\n\t\t\tvertices = geometry.vertices,\r\n\t\t\til = faces.length,\r\n\t\t\ttotalArea = 0,\r\n\t\t\tcumulativeAreas = [],\r\n\t\t\tvA, vB, vC, vD;\r\n\r\n\t\t// precompute face areas\r\n\r\n\t\tfor ( i = 0; i < il; i ++ ) {\r\n\r\n\t\t\tface = faces[ i ];\r\n\r\n\t\t\tif ( face instanceof THREE.Face3 ) {\r\n\r\n\t\t\t\tvA = vertices[ face.a ];\r\n\t\t\t\tvB = vertices[ face.b ];\r\n\t\t\t\tvC = vertices[ face.c ];\r\n\r\n\t\t\t\tface._area = THREE.GeometryUtils.triangleArea( vA, vB, vC );\r\n\r\n\t\t\t} else if ( face instanceof THREE.Face4 ) {\r\n\r\n\t\t\t\tvA = vertices[ face.a ];\r\n\t\t\t\tvB = vertices[ face.b ];\r\n\t\t\t\tvC = vertices[ face.c ];\r\n\t\t\t\tvD = vertices[ face.d ];\r\n\r\n\t\t\t\tface._area1 = THREE.GeometryUtils.triangleArea( vA, vB, vD );\r\n\t\t\t\tface._area2 = THREE.GeometryUtils.triangleArea( vB, vC, vD );\r\n\r\n\t\t\t\tface._area = face._area1 + face._area2;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttotalArea += face._area;\r\n\r\n\t\t\tcumulativeAreas[ i ] = totalArea;\r\n\r\n\t\t}\r\n\r\n\t\t// binary search cumulative areas array\r\n\r\n\t\tfunction binarySearchIndices( value ) {\r\n\r\n\t\t\tfunction binarySearch( start, end ) {\r\n\r\n\t\t\t\t// return closest larger index\r\n\t\t\t\t// if exact number is not found\r\n\r\n\t\t\t\tif ( end < start )\r\n\t\t\t\t\treturn start;\r\n\r\n\t\t\t\tvar mid = start + Math.floor( ( end - start ) / 2 );\r\n\r\n\t\t\t\tif ( cumulativeAreas[ mid ] > value ) {\r\n\r\n\t\t\t\t\treturn binarySearch( start, mid - 1 );\r\n\r\n\t\t\t\t} else if ( cumulativeAreas[ mid ] < value ) {\r\n\r\n\t\t\t\t\treturn binarySearch( mid + 1, end );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\treturn mid;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar result = binarySearch( 0, cumulativeAreas.length - 1 )\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t\t// pick random face weighted by face area\r\n\r\n\t\tvar r, index,\r\n\t\t\tresult = [];\r\n\r\n\t\tvar stats = {};\r\n\r\n\t\tfor ( i = 0; i < n; i ++ ) {\r\n\r\n\t\t\tr = THREE.GeometryUtils.random() * totalArea;\r\n\r\n\t\t\tindex = binarySearchIndices( r );\r\n\r\n\t\t\tresult[ i ] = THREE.GeometryUtils.randomPointInFace( faces[ index ], geometry, true );\r\n\r\n\t\t\tif ( ! stats[ index ] ) {\r\n\r\n\t\t\t\tstats[ index ] = 1;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tstats[ index ] += 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t},\r\n\r\n\t// Get triangle area (half of parallelogram)\r\n\t//\thttp://mathworld.wolfram.com/TriangleArea.html\r\n\r\n\ttriangleArea: function ( vectorA, vectorB, vectorC ) {\r\n\r\n\t\tvar tmp1 = THREE.GeometryUtils.__v1,\r\n\t\t\ttmp2 = THREE.GeometryUtils.__v2;\r\n\r\n\t\ttmp1.subVectors( vectorB, vectorA );\r\n\t\ttmp2.subVectors( vectorC, vectorA );\r\n\t\ttmp1.cross( tmp2 );\r\n\r\n\t\treturn 0.5 * tmp1.length();\r\n\r\n\t},\r\n\r\n\t// Center geometry so that 0,0,0 is in center of bounding box\r\n\r\n\tcenter: function ( geometry ) {\r\n\r\n\t\tgeometry.computeBoundingBox();\r\n\r\n\t\tvar bb = geometry.boundingBox;\r\n\r\n\t\tvar offset = new THREE.Vector3();\r\n\r\n\t\toffset.addVectors( bb.min, bb.max );\r\n\t\toffset.multiplyScalar( -0.5 );\r\n\r\n\t\tgeometry.applyMatrix( new THREE.Matrix4().makeTranslation( offset.x, offset.y, offset.z ) );\r\n\t\tgeometry.computeBoundingBox();\r\n\r\n\t\treturn offset;\r\n\r\n\t},\r\n\r\n\t// Normalize UVs to be from <0,1>\r\n\t// (for now just the first set of UVs)\r\n\r\n\tnormalizeUVs: function ( geometry ) {\r\n\r\n\t\tvar uvSet = geometry.faceVertexUvs[ 0 ];\r\n\r\n\t\tfor ( var i = 0, il = uvSet.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar uvs = uvSet[ i ];\r\n\r\n\t\t\tfor ( var j = 0, jl = uvs.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t// texture repeat\r\n\r\n\t\t\t\tif( uvs[ j ].x !== 1.0 ) uvs[ j ].x = uvs[ j ].x - Math.floor( uvs[ j ].x );\r\n\t\t\t\tif( uvs[ j ].y !== 1.0 ) uvs[ j ].y = uvs[ j ].y - Math.floor( uvs[ j ].y );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ttriangulateQuads: function ( geometry ) {\r\n\r\n\t\tvar i, il, j, jl;\r\n\r\n\t\tvar faces = [];\r\n\t\tvar faceUvs = [];\r\n\t\tvar faceVertexUvs = [];\r\n\r\n\t\tfor ( i = 0, il = geometry.faceUvs.length; i < il; i ++ ) {\r\n\r\n\t\t\tfaceUvs[ i ] = [];\r\n\r\n\t\t}\r\n\r\n\t\tfor ( i = 0, il = geometry.faceVertexUvs.length; i < il; i ++ ) {\r\n\r\n\t\t\tfaceVertexUvs[ i ] = [];\r\n\r\n\t\t}\r\n\r\n\t\tfor ( i = 0, il = geometry.faces.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar face = geometry.faces[ i ];\r\n\r\n\t\t\tif ( face instanceof THREE.Face4 ) {\r\n\r\n\t\t\t\tvar a = face.a;\r\n\t\t\t\tvar b = face.b;\r\n\t\t\t\tvar c = face.c;\r\n\t\t\t\tvar d = face.d;\r\n\r\n\t\t\t\tvar triA = new THREE.Face3();\r\n\t\t\t\tvar triB = new THREE.Face3();\r\n\r\n\t\t\t\ttriA.color.copy( face.color );\r\n\t\t\t\ttriB.color.copy( face.color );\r\n\r\n\t\t\t\ttriA.materialIndex = face.materialIndex;\r\n\t\t\t\ttriB.materialIndex = face.materialIndex;\r\n\r\n\t\t\t\ttriA.a = a;\r\n\t\t\t\ttriA.b = b;\r\n\t\t\t\ttriA.c = d;\r\n\r\n\t\t\t\ttriB.a = b;\r\n\t\t\t\ttriB.b = c;\r\n\t\t\t\ttriB.c = d;\r\n\r\n\t\t\t\tif ( face.vertexColors.length === 4 ) {\r\n\r\n\t\t\t\t\ttriA.vertexColors[ 0 ] = face.vertexColors[ 0 ].clone();\r\n\t\t\t\t\ttriA.vertexColors[ 1 ] = face.vertexColors[ 1 ].clone();\r\n\t\t\t\t\ttriA.vertexColors[ 2 ] = face.vertexColors[ 3 ].clone();\r\n\r\n\t\t\t\t\ttriB.vertexColors[ 0 ] = face.vertexColors[ 1 ].clone();\r\n\t\t\t\t\ttriB.vertexColors[ 1 ] = face.vertexColors[ 2 ].clone();\r\n\t\t\t\t\ttriB.vertexColors[ 2 ] = face.vertexColors[ 3 ].clone();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfaces.push( triA, triB );\r\n\r\n\t\t\t\tfor ( j = 0, jl = geometry.faceVertexUvs.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tif ( geometry.faceVertexUvs[ j ].length ) {\r\n\r\n\t\t\t\t\t\tvar uvs = geometry.faceVertexUvs[ j ][ i ];\r\n\r\n\t\t\t\t\t\tvar uvA = uvs[ 0 ];\r\n\t\t\t\t\t\tvar uvB = uvs[ 1 ];\r\n\t\t\t\t\t\tvar uvC = uvs[ 2 ];\r\n\t\t\t\t\t\tvar uvD = uvs[ 3 ];\r\n\r\n\t\t\t\t\t\tvar uvsTriA = [ uvA.clone(), uvB.clone(), uvD.clone() ];\r\n\t\t\t\t\t\tvar uvsTriB = [ uvB.clone(), uvC.clone(), uvD.clone() ];\r\n\r\n\t\t\t\t\t\tfaceVertexUvs[ j ].push( uvsTriA, uvsTriB );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( j = 0, jl = geometry.faceUvs.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tif ( geometry.faceUvs[ j ].length ) {\r\n\r\n\t\t\t\t\t\tvar faceUv = geometry.faceUvs[ j ][ i ];\r\n\r\n\t\t\t\t\t\tfaceUvs[ j ].push( faceUv, faceUv );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfaces.push( face );\r\n\r\n\t\t\t\tfor ( j = 0, jl = geometry.faceUvs.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tfaceUvs[ j ].push( geometry.faceUvs[ j ][ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( j = 0, jl = geometry.faceVertexUvs.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tfaceVertexUvs[ j ].push( geometry.faceVertexUvs[ j ][ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tgeometry.faces = faces;\r\n\t\tgeometry.faceUvs = faceUvs;\r\n\t\tgeometry.faceVertexUvs = faceVertexUvs;\r\n\r\n\t\tgeometry.computeCentroids();\r\n\t\tgeometry.computeFaceNormals();\r\n\t\tgeometry.computeVertexNormals();\r\n\r\n\t\tif ( geometry.hasTangents ) geometry.computeTangents();\r\n\r\n\t},\r\n\r\n\tsetMaterialIndex: function ( geometry, index, startFace, endFace ){\r\n\r\n\t\tvar faces = geometry.faces;\r\n\t\tvar start = startFace || 0;\r\n\t\tvar end = endFace || faces.length - 1;\r\n\r\n\t\tfor ( var i = start; i <= end; i ++ ) {\r\n\r\n\t\t\tfaces[i].materialIndex = index;\r\n\r\n\t\t}\r\n\r\n    }\r\n\r\n};\r\n\r\nTHREE.GeometryUtils.random = THREE.Math.random16;\r\n\r\nTHREE.GeometryUtils.__v1 = new THREE.Vector3();\r\nTHREE.GeometryUtils.__v2 = new THREE.Vector3();\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.ImageUtils = {\r\n\r\n\tcrossOrigin: 'anonymous',\r\n\r\n\tloadTexture: function ( url, mapping, onLoad, onError ) {\r\n\r\n\t\tvar image = new Image();\r\n\t\tvar texture = new THREE.Texture( image, mapping );\r\n\r\n\t\tvar loader = new THREE.ImageLoader();\r\n\r\n\t\tloader.addEventListener( 'load', function ( event ) {\r\n\r\n\t\t\ttexture.image = event.content;\r\n\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\tif ( onLoad ) onLoad( texture );\r\n\r\n\t\t} );\r\n\r\n\t\tloader.addEventListener( 'error', function ( event ) {\r\n\r\n\t\t\tif ( onError ) onError( event.message );\r\n\r\n\t\t} );\r\n\r\n\t\tloader.crossOrigin = this.crossOrigin;\r\n\t\tloader.load( url, image );\r\n\r\n\t\ttexture.sourceFile = url;\r\n\r\n\t\treturn texture;\r\n\r\n\t},\r\n\r\n\tloadCompressedTexture: function ( url, mapping, onLoad, onError ) {\r\n\r\n\t\tvar texture = new THREE.CompressedTexture();\r\n\t\ttexture.mapping = mapping;\r\n\r\n\t\tvar request = new XMLHttpRequest();\r\n\r\n\t\trequest.onload = function () {\r\n\r\n\t\t\tvar buffer = request.response;\r\n\t\t\tvar dds = THREE.ImageUtils.parseDDS( buffer, true );\r\n\r\n\t\t\ttexture.format = dds.format;\r\n\r\n\t\t\ttexture.mipmaps = dds.mipmaps;\r\n\t\t\ttexture.image.width = dds.width;\r\n\t\t\ttexture.image.height = dds.height;\r\n\r\n\t\t\t// gl.generateMipmap fails for compressed textures\r\n\t\t\t// mipmaps must be embedded in the DDS file\r\n\t\t\t// or texture filters must not use mipmapping\r\n\r\n\t\t\ttexture.generateMipmaps = false;\r\n\r\n\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\tif ( onLoad ) onLoad( texture );\r\n\r\n\t\t}\r\n\r\n\t\trequest.onerror = onError;\r\n\r\n\t\trequest.open( 'GET', url, true );\r\n\t\trequest.responseType = \"arraybuffer\";\r\n\t\trequest.send( null );\r\n\r\n\t\treturn texture;\r\n\r\n\t},\r\n\r\n\tloadTextureCube: function ( array, mapping, onLoad, onError ) {\r\n\r\n\t\tvar images = [];\r\n\t\timages.loadCount = 0;\r\n\r\n\t\tvar texture = new THREE.Texture();\r\n\t\ttexture.image = images;\r\n\t\tif ( mapping !== undefined ) texture.mapping = mapping;\r\n\r\n\t\t// no flipping needed for cube textures\r\n\r\n\t\ttexture.flipY = false;\r\n\r\n\t\tfor ( var i = 0, il = array.length; i < il; ++ i ) {\r\n\r\n\t\t\tvar cubeImage = new Image();\r\n\t\t\timages[ i ] = cubeImage;\r\n\r\n\t\t\tcubeImage.onload = function () {\r\n\r\n\t\t\t\timages.loadCount += 1;\r\n\r\n\t\t\t\tif ( images.loadCount === 6 ) {\r\n\r\n\t\t\t\t\ttexture.needsUpdate = true;\r\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t};\r\n\r\n\t\t\tcubeImage.onerror = onError;\r\n\r\n\t\t\tcubeImage.crossOrigin = this.crossOrigin;\r\n\t\t\tcubeImage.src = array[ i ];\r\n\r\n\t\t}\r\n\r\n\t\treturn texture;\r\n\r\n\t},\r\n\r\n\tloadCompressedTextureCube: function ( array, mapping, onLoad, onError ) {\r\n\r\n\t\tvar images = [];\r\n\t\timages.loadCount = 0;\r\n\r\n\t\tvar texture = new THREE.CompressedTexture();\r\n\t\ttexture.image = images;\r\n\t\tif ( mapping !== undefined ) texture.mapping = mapping;\r\n\r\n\t\t// no flipping for cube textures\r\n\t\t// (also flipping doesn't work for compressed textures )\r\n\r\n\t\ttexture.flipY = false;\r\n\r\n\t\t// can't generate mipmaps for compressed textures\r\n\t\t// mips must be embedded in DDS files\r\n\r\n\t\ttexture.generateMipmaps = false;\r\n\r\n\t\tvar generateCubeFaceCallback = function ( rq, img ) {\r\n\r\n\t\t\treturn function () {\r\n\r\n\t\t\t\tvar buffer = rq.response;\r\n\t\t\t\tvar dds = THREE.ImageUtils.parseDDS( buffer, true );\r\n\r\n\t\t\t\timg.format = dds.format;\r\n\r\n\t\t\t\timg.mipmaps = dds.mipmaps;\r\n\t\t\t\timg.width = dds.width;\r\n\t\t\t\timg.height = dds.height;\r\n\r\n\t\t\t\timages.loadCount += 1;\r\n\r\n\t\t\t\tif ( images.loadCount === 6 ) {\r\n\r\n\t\t\t\t\ttexture.format = dds.format;\r\n\t\t\t\t\ttexture.needsUpdate = true;\r\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// compressed cubemap textures as 6 separate DDS files\r\n\r\n\t\tif ( array instanceof Array ) {\r\n\r\n\t\t\tfor ( var i = 0, il = array.length; i < il; ++ i ) {\r\n\r\n\t\t\t\tvar cubeImage = {};\r\n\t\t\t\timages[ i ] = cubeImage;\r\n\r\n\t\t\t\tvar request = new XMLHttpRequest();\r\n\r\n\t\t\t\trequest.onload = generateCubeFaceCallback( request, cubeImage );\r\n\t\t\t\trequest.onerror = onError;\r\n\r\n\t\t\t\tvar url = array[ i ];\r\n\r\n\t\t\t\trequest.open( 'GET', url, true );\r\n\t\t\t\trequest.responseType = \"arraybuffer\";\r\n\t\t\t\trequest.send( null );\r\n\r\n\t\t\t}\r\n\r\n\t\t// compressed cubemap texture stored in a single DDS file\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar url = array;\r\n\t\t\tvar request = new XMLHttpRequest();\r\n\r\n\t\t\trequest.onload = function( ) {\r\n\r\n\t\t\t\tvar buffer = request.response;\r\n\t\t\t\tvar dds = THREE.ImageUtils.parseDDS( buffer, true );\r\n\r\n\t\t\t\tif ( dds.isCubemap ) {\r\n\r\n\t\t\t\t\tvar faces = dds.mipmaps.length / dds.mipmapCount;\r\n\r\n\t\t\t\t\tfor ( var f = 0; f < faces; f ++ ) {\r\n\r\n\t\t\t\t\t\timages[ f ] = { mipmaps : [] };\r\n\r\n\t\t\t\t\t\tfor ( var i = 0; i < dds.mipmapCount; i ++ ) {\r\n\r\n\t\t\t\t\t\t\timages[ f ].mipmaps.push( dds.mipmaps[ f * dds.mipmapCount + i ] );\r\n\t\t\t\t\t\t\timages[ f ].format = dds.format;\r\n\t\t\t\t\t\t\timages[ f ].width = dds.width;\r\n\t\t\t\t\t\t\timages[ f ].height = dds.height;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttexture.format = dds.format;\r\n\t\t\t\t\ttexture.needsUpdate = true;\r\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\trequest.onerror = onError;\r\n\r\n\t\t\trequest.open( 'GET', url, true );\r\n\t\t\trequest.responseType = \"arraybuffer\";\r\n\t\t\trequest.send( null );\r\n\r\n\t\t}\r\n\r\n\t\treturn texture;\r\n\r\n\t},\r\n\r\n\tparseDDS: function ( buffer, loadMipmaps ) {\r\n\r\n\t\tvar dds = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 };\r\n\r\n\t\t// Adapted from @toji's DDS utils\r\n\t\t//\thttps://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js\r\n\r\n\t\t// All values and structures referenced from:\r\n\t\t// http://msdn.microsoft.com/en-us/library/bb943991.aspx/\r\n\r\n\t\tvar DDS_MAGIC = 0x20534444;\r\n\r\n\t\tvar DDSD_CAPS = 0x1,\r\n\t\t\tDDSD_HEIGHT = 0x2,\r\n\t\t\tDDSD_WIDTH = 0x4,\r\n\t\t\tDDSD_PITCH = 0x8,\r\n\t\t\tDDSD_PIXELFORMAT = 0x1000,\r\n\t\t\tDDSD_MIPMAPCOUNT = 0x20000,\r\n\t\t\tDDSD_LINEARSIZE = 0x80000,\r\n\t\t\tDDSD_DEPTH = 0x800000;\r\n\r\n\t\tvar DDSCAPS_COMPLEX = 0x8,\r\n\t\t\tDDSCAPS_MIPMAP = 0x400000,\r\n\t\t\tDDSCAPS_TEXTURE = 0x1000;\r\n\r\n\t\tvar DDSCAPS2_CUBEMAP = 0x200,\r\n\t\t\tDDSCAPS2_CUBEMAP_POSITIVEX = 0x400,\r\n\t\t\tDDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,\r\n\t\t\tDDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,\r\n\t\t\tDDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,\r\n\t\t\tDDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,\r\n\t\t\tDDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,\r\n\t\t\tDDSCAPS2_VOLUME = 0x200000;\r\n\r\n\t\tvar DDPF_ALPHAPIXELS = 0x1,\r\n\t\t\tDDPF_ALPHA = 0x2,\r\n\t\t\tDDPF_FOURCC = 0x4,\r\n\t\t\tDDPF_RGB = 0x40,\r\n\t\t\tDDPF_YUV = 0x200,\r\n\t\t\tDDPF_LUMINANCE = 0x20000;\r\n\r\n\t\tfunction fourCCToInt32( value ) {\r\n\r\n\t\t\treturn value.charCodeAt(0) +\r\n\t\t\t\t(value.charCodeAt(1) << 8) +\r\n\t\t\t\t(value.charCodeAt(2) << 16) +\r\n\t\t\t\t(value.charCodeAt(3) << 24);\r\n\r\n\t\t}\r\n\r\n\t\tfunction int32ToFourCC( value ) {\r\n\r\n\t\t\treturn String.fromCharCode(\r\n\t\t\t\tvalue & 0xff,\r\n\t\t\t\t(value >> 8) & 0xff,\r\n\t\t\t\t(value >> 16) & 0xff,\r\n\t\t\t\t(value >> 24) & 0xff\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tvar FOURCC_DXT1 = fourCCToInt32(\"DXT1\");\r\n\t\tvar FOURCC_DXT3 = fourCCToInt32(\"DXT3\");\r\n\t\tvar FOURCC_DXT5 = fourCCToInt32(\"DXT5\");\r\n\r\n\t\tvar headerLengthInt = 31; // The header length in 32 bit ints\r\n\r\n\t\t// Offsets into the header array\r\n\r\n\t\tvar off_magic = 0;\r\n\r\n\t\tvar off_size = 1;\r\n\t\tvar off_flags = 2;\r\n\t\tvar off_height = 3;\r\n\t\tvar off_width = 4;\r\n\r\n\t\tvar off_mipmapCount = 7;\r\n\r\n\t\tvar off_pfFlags = 20;\r\n\t\tvar off_pfFourCC = 21;\r\n\r\n\t\tvar off_caps = 27;\r\n\t\tvar off_caps2 = 28;\r\n\t\tvar off_caps3 = 29;\r\n\t\tvar off_caps4 = 30;\r\n\r\n\t\t// Parse header\r\n\r\n\t\tvar header = new Int32Array( buffer, 0, headerLengthInt );\r\n\r\n\t\tif ( header[ off_magic ] !== DDS_MAGIC ) {\r\n\r\n\t\t\tconsole.error( \"ImageUtils.parseDDS(): Invalid magic number in DDS header\" );\r\n\t\t\treturn dds;\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! header[ off_pfFlags ] & DDPF_FOURCC ) {\r\n\r\n\t\t\tconsole.error( \"ImageUtils.parseDDS(): Unsupported format, must contain a FourCC code\" );\r\n\t\t\treturn dds;\r\n\r\n\t\t}\r\n\r\n\t\tvar blockBytes;\r\n\r\n\t\tvar fourCC = header[ off_pfFourCC ];\r\n\r\n\t\tswitch ( fourCC ) {\r\n\r\n\t\t\tcase FOURCC_DXT1:\r\n\r\n\t\t\t\tblockBytes = 8;\r\n\t\t\t\tdds.format = THREE.RGB_S3TC_DXT1_Format;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase FOURCC_DXT3:\r\n\r\n\t\t\t\tblockBytes = 16;\r\n\t\t\t\tdds.format = THREE.RGBA_S3TC_DXT3_Format;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase FOURCC_DXT5:\r\n\r\n\t\t\t\tblockBytes = 16;\r\n\t\t\t\tdds.format = THREE.RGBA_S3TC_DXT5_Format;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\r\n\t\t\t\tconsole.error( \"ImageUtils.parseDDS(): Unsupported FourCC code: \", int32ToFourCC( fourCC ) );\r\n\t\t\t\treturn dds;\r\n\r\n\t\t}\r\n\r\n\t\tdds.mipmapCount = 1;\r\n\r\n\t\tif ( header[ off_flags ] & DDSD_MIPMAPCOUNT && loadMipmaps !== false ) {\r\n\r\n\t\t\tdds.mipmapCount = Math.max( 1, header[ off_mipmapCount ] );\r\n\r\n\t\t}\r\n\r\n\t\t//TODO: Verify that all faces of the cubemap are present with DDSCAPS2_CUBEMAP_POSITIVEX, etc.\r\n\r\n\t\tdds.isCubemap = header[ off_caps2 ] & DDSCAPS2_CUBEMAP ? true : false;\r\n\r\n\t\tdds.width = header[ off_width ];\r\n\t\tdds.height = header[ off_height ];\r\n\r\n\t\tvar dataOffset = header[ off_size ] + 4;\r\n\r\n\t\t// Extract mipmaps buffers\r\n\r\n\t\tvar width = dds.width;\r\n\t\tvar height = dds.height;\r\n\r\n\t\tvar faces = dds.isCubemap ? 6 : 1;\r\n\r\n\t\tfor ( var face = 0; face < faces; face ++ ) {\r\n\r\n\t\t\tfor ( var i = 0; i < dds.mipmapCount; i ++ ) {\r\n\r\n\t\t\t\tvar dataLength = Math.max( 4, width ) / 4 * Math.max( 4, height ) / 4 * blockBytes;\r\n\t\t\t\tvar byteArray = new Uint8Array( buffer, dataOffset, dataLength );\r\n\r\n\t\t\t\tvar mipmap = { \"data\": byteArray, \"width\": width, \"height\": height };\r\n\t\t\t\tdds.mipmaps.push( mipmap );\r\n\r\n\t\t\t\tdataOffset += dataLength;\r\n\r\n\t\t\t\twidth = Math.max( width * 0.5, 1 );\r\n\t\t\t\theight = Math.max( height * 0.5, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\twidth = dds.width;\r\n\t\t\theight = dds.height;\r\n\r\n\t\t}\r\n\r\n\t\treturn dds;\r\n\r\n\t},\r\n\r\n\tgetNormalMap: function ( image, depth ) {\r\n\r\n\t\t// Adapted from http://www.paulbrunt.co.uk/lab/heightnormal/\r\n\r\n\t\tvar cross = function ( a, b ) {\r\n\r\n\t\t\treturn [ a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ], a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ], a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ] ];\r\n\r\n\t\t}\r\n\r\n\t\tvar subtract = function ( a, b ) {\r\n\r\n\t\t\treturn [ a[ 0 ] - b[ 0 ], a[ 1 ] - b[ 1 ], a[ 2 ] - b[ 2 ] ];\r\n\r\n\t\t}\r\n\r\n\t\tvar normalize = function ( a ) {\r\n\r\n\t\t\tvar l = Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );\r\n\t\t\treturn [ a[ 0 ] / l, a[ 1 ] / l, a[ 2 ] / l ];\r\n\r\n\t\t}\r\n\r\n\t\tdepth = depth | 1;\r\n\r\n\t\tvar width = image.width;\r\n\t\tvar height = image.height;\r\n\r\n\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\tcanvas.width = width;\r\n\t\tcanvas.height = height;\r\n\r\n\t\tvar context = canvas.getContext( '2d' );\r\n\t\tcontext.drawImage( image, 0, 0 );\r\n\r\n\t\tvar data = context.getImageData( 0, 0, width, height ).data;\r\n\t\tvar imageData = context.createImageData( width, height );\r\n\t\tvar output = imageData.data;\r\n\r\n\t\tfor ( var x = 0; x < width; x ++ ) {\r\n\r\n\t\t\tfor ( var y = 0; y < height; y ++ ) {\r\n\r\n\t\t\t\tvar ly = y - 1 < 0 ? 0 : y - 1;\r\n\t\t\t\tvar uy = y + 1 > height - 1 ? height - 1 : y + 1;\r\n\t\t\t\tvar lx = x - 1 < 0 ? 0 : x - 1;\r\n\t\t\t\tvar ux = x + 1 > width - 1 ? width - 1 : x + 1;\r\n\r\n\t\t\t\tvar points = [];\r\n\t\t\t\tvar origin = [ 0, 0, data[ ( y * width + x ) * 4 ] / 255 * depth ];\r\n\t\t\t\tpoints.push( [ - 1, 0, data[ ( y * width + lx ) * 4 ] / 255 * depth ] );\r\n\t\t\t\tpoints.push( [ - 1, - 1, data[ ( ly * width + lx ) * 4 ] / 255 * depth ] );\r\n\t\t\t\tpoints.push( [ 0, - 1, data[ ( ly * width + x ) * 4 ] / 255 * depth ] );\r\n\t\t\t\tpoints.push( [  1, - 1, data[ ( ly * width + ux ) * 4 ] / 255 * depth ] );\r\n\t\t\t\tpoints.push( [ 1, 0, data[ ( y * width + ux ) * 4 ] / 255 * depth ] );\r\n\t\t\t\tpoints.push( [ 1, 1, data[ ( uy * width + ux ) * 4 ] / 255 * depth ] );\r\n\t\t\t\tpoints.push( [ 0, 1, data[ ( uy * width + x ) * 4 ] / 255 * depth ] );\r\n\t\t\t\tpoints.push( [ - 1, 1, data[ ( uy * width + lx ) * 4 ] / 255 * depth ] );\r\n\r\n\t\t\t\tvar normals = [];\r\n\t\t\t\tvar num_points = points.length;\r\n\r\n\t\t\t\tfor ( var i = 0; i < num_points; i ++ ) {\r\n\r\n\t\t\t\t\tvar v1 = points[ i ];\r\n\t\t\t\t\tvar v2 = points[ ( i + 1 ) % num_points ];\r\n\t\t\t\t\tv1 = subtract( v1, origin );\r\n\t\t\t\t\tv2 = subtract( v2, origin );\r\n\t\t\t\t\tnormals.push( normalize( cross( v1, v2 ) ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar normal = [ 0, 0, 0 ];\r\n\r\n\t\t\t\tfor ( var i = 0; i < normals.length; i ++ ) {\r\n\r\n\t\t\t\t\tnormal[ 0 ] += normals[ i ][ 0 ];\r\n\t\t\t\t\tnormal[ 1 ] += normals[ i ][ 1 ];\r\n\t\t\t\t\tnormal[ 2 ] += normals[ i ][ 2 ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnormal[ 0 ] /= normals.length;\r\n\t\t\t\tnormal[ 1 ] /= normals.length;\r\n\t\t\t\tnormal[ 2 ] /= normals.length;\r\n\r\n\t\t\t\tvar idx = ( y * width + x ) * 4;\r\n\r\n\t\t\t\toutput[ idx ] = ( ( normal[ 0 ] + 1.0 ) / 2.0 * 255 ) | 0;\r\n\t\t\t\toutput[ idx + 1 ] = ( ( normal[ 1 ] + 1.0 ) / 2.0 * 255 ) | 0;\r\n\t\t\t\toutput[ idx + 2 ] = ( normal[ 2 ] * 255 ) | 0;\r\n\t\t\t\toutput[ idx + 3 ] = 255;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tcontext.putImageData( imageData, 0, 0 );\r\n\r\n\t\treturn canvas;\r\n\r\n\t},\r\n\r\n\tgenerateDataTexture: function ( width, height, color ) {\r\n\r\n\t\tvar size = width * height;\r\n\t\tvar data = new Uint8Array( 3 * size );\r\n\r\n\t\tvar r = Math.floor( color.r * 255 );\r\n\t\tvar g = Math.floor( color.g * 255 );\r\n\t\tvar b = Math.floor( color.b * 255 );\r\n\r\n\t\tfor ( var i = 0; i < size; i ++ ) {\r\n\r\n\t\t\tdata[ i * 3 ] \t  = r;\r\n\t\t\tdata[ i * 3 + 1 ] = g;\r\n\t\t\tdata[ i * 3 + 2 ] = b;\r\n\r\n\t\t}\r\n\r\n\t\tvar texture = new THREE.DataTexture( data, width, height, THREE.RGBFormat );\r\n\t\ttexture.needsUpdate = true;\r\n\r\n\t\treturn texture;\r\n\r\n\t}\r\n\r\n};\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.SceneUtils = {\r\n\r\n\tcreateMultiMaterialObject: function ( geometry, materials ) {\r\n\r\n\t\tvar group = new THREE.Object3D();\r\n\r\n\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\r\n\r\n\t\t\tgroup.add( new THREE.Mesh( geometry, materials[ i ] ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn group;\r\n\r\n\t},\r\n\r\n\tdetach : function ( child, parent, scene ) {\r\n\r\n\t\tchild.applyMatrix( parent.matrixWorld );\r\n\t\tparent.remove( child );\r\n\t\tscene.add( child );\r\n\r\n\t},\r\n\r\n\tattach: function ( child, scene, parent ) {\r\n\r\n\t\tvar matrixWorldInverse = new THREE.Matrix4();\r\n\t\tmatrixWorldInverse.getInverse( parent.matrixWorld );\r\n\t\tchild.applyMatrix( matrixWorldInverse );\r\n\r\n\t\tscene.remove( child );\r\n\t\tparent.add( child );\r\n\r\n\t}\r\n\r\n};\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * For Text operations in three.js (See TextGeometry)\r\n *\r\n * It uses techniques used in:\r\n *\r\n * \ttypeface.js and canvastext\r\n * \t\tFor converting fonts and rendering with javascript\r\n *\t\thttp://typeface.neocracy.org\r\n *\r\n *\tTriangulation ported from AS3\r\n *\t\tSimple Polygon Triangulation\r\n *\t\thttp://actionsnippet.com/?p=1462\r\n *\r\n * \tA Method to triangulate shapes with holes\r\n *\t\thttp://www.sakri.net/blog/2009/06/12/an-approach-to-triangulating-polygons-with-holes/\r\n *\r\n */\r\n\r\nTHREE.FontUtils = {\r\n\r\n\tfaces : {},\r\n\r\n\t// Just for now. face[weight][style]\r\n\r\n\tface : \"helvetiker\",\r\n\tweight: \"normal\",\r\n\tstyle : \"normal\",\r\n\tsize : 150,\r\n\tdivisions : 10,\r\n\r\n\tgetFace : function() {\r\n\r\n\t\treturn this.faces[ this.face ][ this.weight ][ this.style ];\r\n\r\n\t},\r\n\r\n\tloadFace : function( data ) {\r\n\r\n\t\tvar family = data.familyName.toLowerCase();\r\n\r\n\t\tvar ThreeFont = this;\r\n\r\n\t\tThreeFont.faces[ family ] = ThreeFont.faces[ family ] || {};\r\n\r\n\t\tThreeFont.faces[ family ][ data.cssFontWeight ] = ThreeFont.faces[ family ][ data.cssFontWeight ] || {};\r\n\t\tThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;\r\n\r\n\t\tvar face = ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;\r\n\r\n\t\treturn data;\r\n\r\n\t},\r\n\r\n\tdrawText : function( text ) {\r\n\r\n\t\tvar characterPts = [], allPts = [];\r\n\r\n\t\t// RenderText\r\n\r\n\t\tvar i, p,\r\n\t\t\tface = this.getFace(),\r\n\t\t\tscale = this.size / face.resolution,\r\n\t\t\toffset = 0,\r\n\t\t\tchars = String( text ).split( '' ),\r\n\t\t\tlength = chars.length;\r\n\r\n\t\tvar fontPaths = [];\r\n\r\n\t\tfor ( i = 0; i < length; i ++ ) {\r\n\r\n\t\t\tvar path = new THREE.Path();\r\n\r\n\t\t\tvar ret = this.extractGlyphPoints( chars[ i ], face, scale, offset, path );\r\n\t\t\toffset += ret.offset;\r\n\r\n\t\t\tfontPaths.push( ret.path );\r\n\r\n\t\t}\r\n\r\n\t\t// get the width\r\n\r\n\t\tvar width = offset / 2;\r\n\t\t//\r\n\t\t// for ( p = 0; p < allPts.length; p++ ) {\r\n\t\t//\r\n\t\t// \tallPts[ p ].x -= width;\r\n\t\t//\r\n\t\t// }\r\n\r\n\t\t//var extract = this.extractPoints( allPts, characterPts );\r\n\t\t//extract.contour = allPts;\r\n\r\n\t\t//extract.paths = fontPaths;\r\n\t\t//extract.offset = width;\r\n\r\n\t\treturn { paths : fontPaths, offset : width };\r\n\r\n\t},\r\n\r\n\r\n\r\n\r\n\textractGlyphPoints : function( c, face, scale, offset, path ) {\r\n\r\n\t\tvar pts = [];\r\n\r\n\t\tvar i, i2, divisions,\r\n\t\t\toutline, action, length,\r\n\t\t\tscaleX, scaleY,\r\n\t\t\tx, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2,\r\n\t\t\tlaste,\r\n\t\t\tglyph = face.glyphs[ c ] || face.glyphs[ '?' ];\r\n\r\n\t\tif ( !glyph ) return;\r\n\r\n\t\tif ( glyph.o ) {\r\n\r\n\t\t\toutline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\r\n\t\t\tlength = outline.length;\r\n\r\n\t\t\tscaleX = scale;\r\n\t\t\tscaleY = scale;\r\n\r\n\t\t\tfor ( i = 0; i < length; ) {\r\n\r\n\t\t\t\taction = outline[ i ++ ];\r\n\r\n\t\t\t\t//console.log( action );\r\n\r\n\t\t\t\tswitch( action ) {\r\n\r\n\t\t\t\tcase 'm':\r\n\r\n\t\t\t\t\t// Move To\r\n\r\n\t\t\t\t\tx = outline[ i++ ] * scaleX + offset;\r\n\t\t\t\t\ty = outline[ i++ ] * scaleY;\r\n\r\n\t\t\t\t\tpath.moveTo( x, y );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'l':\r\n\r\n\t\t\t\t\t// Line To\r\n\r\n\t\t\t\t\tx = outline[ i++ ] * scaleX + offset;\r\n\t\t\t\t\ty = outline[ i++ ] * scaleY;\r\n\t\t\t\t\tpath.lineTo(x,y);\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'q':\r\n\r\n\t\t\t\t\t// QuadraticCurveTo\r\n\r\n\t\t\t\t\tcpx  = outline[ i++ ] * scaleX + offset;\r\n\t\t\t\t\tcpy  = outline[ i++ ] * scaleY;\r\n\t\t\t\t\tcpx1 = outline[ i++ ] * scaleX + offset;\r\n\t\t\t\t\tcpy1 = outline[ i++ ] * scaleY;\r\n\r\n\t\t\t\t\tpath.quadraticCurveTo(cpx1, cpy1, cpx, cpy);\r\n\r\n\t\t\t\t\tlaste = pts[ pts.length - 1 ];\r\n\r\n\t\t\t\t\tif ( laste ) {\r\n\r\n\t\t\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\t\t\tcpy0 = laste.y;\r\n\r\n\t\t\t\t\t\tfor ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {\r\n\r\n\t\t\t\t\t\t\tvar t = i2 / divisions;\r\n\t\t\t\t\t\t\tvar tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );\r\n\t\t\t\t\t\t\tvar ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );\r\n\t\t\t\t\t  }\r\n\r\n\t\t\t\t  }\r\n\r\n\t\t\t\t  break;\r\n\r\n\t\t\t\tcase 'b':\r\n\r\n\t\t\t\t\t// Cubic Bezier Curve\r\n\r\n\t\t\t\t\tcpx  = outline[ i++ ] *  scaleX + offset;\r\n\t\t\t\t\tcpy  = outline[ i++ ] *  scaleY;\r\n\t\t\t\t\tcpx1 = outline[ i++ ] *  scaleX + offset;\r\n\t\t\t\t\tcpy1 = outline[ i++ ] * -scaleY;\r\n\t\t\t\t\tcpx2 = outline[ i++ ] *  scaleX + offset;\r\n\t\t\t\t\tcpy2 = outline[ i++ ] * -scaleY;\r\n\r\n\t\t\t\t\tpath.bezierCurveTo( cpx, cpy, cpx1, cpy1, cpx2, cpy2 );\r\n\r\n\t\t\t\t\tlaste = pts[ pts.length - 1 ];\r\n\r\n\t\t\t\t\tif ( laste ) {\r\n\r\n\t\t\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\t\t\tcpy0 = laste.y;\r\n\r\n\t\t\t\t\t\tfor ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {\r\n\r\n\t\t\t\t\t\t\tvar t = i2 / divisions;\r\n\t\t\t\t\t\t\tvar tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );\r\n\t\t\t\t\t\t\tvar ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\r\n\t\treturn { offset: glyph.ha*scale, path:path};\r\n\t}\r\n\r\n};\r\n\r\n\r\nTHREE.FontUtils.generateShapes = function( text, parameters ) {\r\n\r\n\t// Parameters \r\n\r\n\tparameters = parameters || {};\r\n\r\n\tvar size = parameters.size !== undefined ? parameters.size : 100;\r\n\tvar curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments: 4;\r\n\r\n\tvar font = parameters.font !== undefined ? parameters.font : \"helvetiker\";\r\n\tvar weight = parameters.weight !== undefined ? parameters.weight : \"normal\";\r\n\tvar style = parameters.style !== undefined ? parameters.style : \"normal\";\r\n\r\n\tTHREE.FontUtils.size = size;\r\n\tTHREE.FontUtils.divisions = curveSegments;\r\n\r\n\tTHREE.FontUtils.face = font;\r\n\tTHREE.FontUtils.weight = weight;\r\n\tTHREE.FontUtils.style = style;\r\n\r\n\t// Get a Font data json object\r\n\r\n\tvar data = THREE.FontUtils.drawText( text );\r\n\r\n\tvar paths = data.paths;\r\n\tvar shapes = [];\r\n\r\n\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\r\n\r\n\t\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\r\n\r\n\t}\r\n\r\n\treturn shapes;\r\n\r\n};\r\n\r\n\r\n/**\r\n * This code is a quick port of code written in C++ which was submitted to\r\n * flipcode.com by John W. Ratcliff  // July 22, 2000\r\n * See original code and more information here:\r\n * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml\r\n *\r\n * ported to actionscript by Zevan Rosser\r\n * www.actionsnippet.com\r\n *\r\n * ported to javascript by Joshua Koo\r\n * http://www.lab4games.net/zz85/blog\r\n *\r\n */\r\n\r\n\r\n( function( namespace ) {\r\n\r\n\tvar EPSILON = 0.0000000001;\r\n\r\n\t// takes in an contour array and returns\r\n\r\n\tvar process = function( contour, indices ) {\r\n\r\n\t\tvar n = contour.length;\r\n\r\n\t\tif ( n < 3 ) return null;\r\n\r\n\t\tvar result = [],\r\n\t\t\tverts = [],\r\n\t\t\tvertIndices = [];\r\n\r\n\t\t/* we want a counter-clockwise polygon in verts */\r\n\r\n\t\tvar u, v, w;\r\n\r\n\t\tif ( area( contour ) > 0.0 ) {\r\n\r\n\t\t\tfor ( v = 0; v < n; v++ ) verts[ v ] = v;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tfor ( v = 0; v < n; v++ ) verts[ v ] = ( n - 1 ) - v;\r\n\r\n\t\t}\r\n\r\n\t\tvar nv = n;\r\n\r\n\t\t/*  remove nv - 2 vertices, creating 1 triangle every time */\r\n\r\n\t\tvar count = 2 * nv;   /* error detection */\r\n\r\n\t\tfor( v = nv - 1; nv > 2; ) {\r\n\r\n\t\t\t/* if we loop, it is probably a non-simple polygon */\r\n\r\n\t\t\tif ( ( count-- ) <= 0 ) {\r\n\r\n\t\t\t\t//** Triangulate: ERROR - probable bad polygon!\r\n\r\n\t\t\t\t//throw ( \"Warning, unable to triangulate polygon!\" );\r\n\t\t\t\t//return null;\r\n\t\t\t\t// Sometimes warning is fine, especially polygons are triangulated in reverse.\r\n\t\t\t\tconsole.log( \"Warning, unable to triangulate polygon!\" );\r\n\r\n\t\t\t\tif ( indices ) return vertIndices;\r\n\t\t\t\treturn result;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t/* three consecutive vertices in current polygon, <u,v,w> */\r\n\r\n\t\t\tu = v; \t \tif ( nv <= u ) u = 0;     /* previous */\r\n\t\t\tv = u + 1;  if ( nv <= v ) v = 0;     /* new v    */\r\n\t\t\tw = v + 1;  if ( nv <= w ) w = 0;     /* next     */\r\n\r\n\t\t\tif ( snip( contour, u, v, w, nv, verts ) ) {\r\n\r\n\t\t\t\tvar a, b, c, s, t;\r\n\r\n\t\t\t\t/* true names of the vertices */\r\n\r\n\t\t\t\ta = verts[ u ];\r\n\t\t\t\tb = verts[ v ];\r\n\t\t\t\tc = verts[ w ];\r\n\r\n\t\t\t\t/* output Triangle */\r\n\r\n\t\t\t\tresult.push( [ contour[ a ],\r\n\t\t\t\t\tcontour[ b ],\r\n\t\t\t\t\tcontour[ c ] ] );\r\n\r\n\r\n\t\t\t\tvertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );\r\n\r\n\t\t\t\t/* remove v from the remaining polygon */\r\n\r\n\t\t\t\tfor( s = v, t = v + 1; t < nv; s++, t++ ) {\r\n\r\n\t\t\t\t\tverts[ s ] = verts[ t ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnv--;\r\n\r\n\t\t\t\t/* reset error detection counter */\r\n\r\n\t\t\t\tcount = 2 * nv;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( indices ) return vertIndices;\r\n\t\treturn result;\r\n\r\n\t};\r\n\r\n\t// calculate area of the contour polygon\r\n\r\n\tvar area = function ( contour ) {\r\n\r\n\t\tvar n = contour.length;\r\n\t\tvar a = 0.0;\r\n\r\n\t\tfor( var p = n - 1, q = 0; q < n; p = q++ ) {\r\n\r\n\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\r\n\r\n\t\t}\r\n\r\n\t\treturn a * 0.5;\r\n\r\n\t};\r\n\r\n\tvar snip = function ( contour, u, v, w, n, verts ) {\r\n\r\n\t\tvar p;\r\n\t\tvar ax, ay, bx, by;\r\n\t\tvar cx, cy, px, py;\r\n\r\n\t\tax = contour[ verts[ u ] ].x;\r\n\t\tay = contour[ verts[ u ] ].y;\r\n\r\n\t\tbx = contour[ verts[ v ] ].x;\r\n\t\tby = contour[ verts[ v ] ].y;\r\n\r\n\t\tcx = contour[ verts[ w ] ].x;\r\n\t\tcy = contour[ verts[ w ] ].y;\r\n\r\n\t\tif ( EPSILON > (((bx-ax)*(cy-ay)) - ((by-ay)*(cx-ax))) ) return false;\r\n\r\n\t\tvar aX, aY, bX, bY, cX, cY;\r\n\t\tvar apx, apy, bpx, bpy, cpx, cpy;\r\n\t\tvar cCROSSap, bCROSScp, aCROSSbp;\r\n\r\n\t\taX = cx - bx;  aY = cy - by;\r\n\t\tbX = ax - cx;  bY = ay - cy;\r\n\t\tcX = bx - ax;  cY = by - ay;\r\n\r\n\t\tfor ( p = 0; p < n; p++ ) {\r\n\r\n\t\t\tif( (p === u) || (p === v) || (p === w) ) continue;\r\n\r\n\t\t\tpx = contour[ verts[ p ] ].x\r\n\t\t\tpy = contour[ verts[ p ] ].y\r\n\r\n\t\t\tapx = px - ax;  apy = py - ay;\r\n\t\t\tbpx = px - bx;  bpy = py - by;\r\n\t\t\tcpx = px - cx;  cpy = py - cy;\r\n\r\n\t\t\t// see if p is inside triangle abc\r\n\r\n\t\t\taCROSSbp = aX*bpy - aY*bpx;\r\n\t\t\tcCROSSap = cX*apy - cY*apx;\r\n\t\t\tbCROSScp = bX*cpy - bY*cpx;\r\n\r\n\t\t\tif ( (aCROSSbp >= 0.0) && (bCROSScp >= 0.0) && (cCROSSap >= 0.0) ) return false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t};\r\n\r\n\r\n\tnamespace.Triangulate = process;\r\n\tnamespace.Triangulate.area = area;\r\n\r\n\treturn namespace;\r\n\r\n})(THREE.FontUtils);\r\n\r\n// To use the typeface.js face files, hook up the API\r\nself._typeface_js = { faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace };/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Extensible curve object\r\n *\r\n * Some common of Curve methods\r\n * .getPoint(t), getTangent(t)\r\n * .getPointAt(u), getTagentAt(u)\r\n * .getPoints(), .getSpacedPoints()\r\n * .getLength()\r\n * .updateArcLengths()\r\n *\r\n * This file contains following classes:\r\n *\r\n * -- 2d classes --\r\n * THREE.Curve\r\n * THREE.LineCurve\r\n * THREE.QuadraticBezierCurve\r\n * THREE.CubicBezierCurve\r\n * THREE.SplineCurve\r\n * THREE.ArcCurve\r\n * THREE.EllipseCurve\r\n *\r\n * -- 3d classes --\r\n * THREE.LineCurve3\r\n * THREE.QuadraticBezierCurve3\r\n * THREE.CubicBezierCurve3\r\n * THREE.SplineCurve3\r\n * THREE.ClosedSplineCurve3\r\n *\r\n * A series of curves can be represented as a THREE.CurvePath\r\n *\r\n **/\r\n\r\n/**************************************************************\r\n *\tAbstract Curve base class\r\n **************************************************************/\r\n\r\nTHREE.Curve = function () {\r\n\r\n};\r\n\r\n// Virtual base class method to overwrite and implement in subclasses\r\n//\t- t [0 .. 1]\r\n\r\nTHREE.Curve.prototype.getPoint = function ( t ) {\r\n\r\n\tconsole.log( \"Warning, getPoint() not implemented!\" );\r\n\treturn null;\r\n\r\n};\r\n\r\n// Get point at relative position in curve according to arc length\r\n// - u [0 .. 1]\r\n\r\nTHREE.Curve.prototype.getPointAt = function ( u ) {\r\n\r\n\tvar t = this.getUtoTmapping( u );\r\n\treturn this.getPoint( t );\r\n\r\n};\r\n\r\n// Get sequence of points using getPoint( t )\r\n\r\nTHREE.Curve.prototype.getPoints = function ( divisions ) {\r\n\r\n\tif ( !divisions ) divisions = 5;\r\n\r\n\tvar d, pts = [];\r\n\r\n\tfor ( d = 0; d <= divisions; d ++ ) {\r\n\r\n\t\tpts.push( this.getPoint( d / divisions ) );\r\n\r\n\t}\r\n\r\n\treturn pts;\r\n\r\n};\r\n\r\n// Get sequence of points using getPointAt( u )\r\n\r\nTHREE.Curve.prototype.getSpacedPoints = function ( divisions ) {\r\n\r\n\tif ( !divisions ) divisions = 5;\r\n\r\n\tvar d, pts = [];\r\n\r\n\tfor ( d = 0; d <= divisions; d ++ ) {\r\n\r\n\t\tpts.push( this.getPointAt( d / divisions ) );\r\n\r\n\t}\r\n\r\n\treturn pts;\r\n\r\n};\r\n\r\n// Get total curve arc length\r\n\r\nTHREE.Curve.prototype.getLength = function () {\r\n\r\n\tvar lengths = this.getLengths();\r\n\treturn lengths[ lengths.length - 1 ];\r\n\r\n};\r\n\r\n// Get list of cumulative segment lengths\r\n\r\nTHREE.Curve.prototype.getLengths = function ( divisions ) {\r\n\r\n\tif ( !divisions ) divisions = (this.__arcLengthDivisions) ? (this.__arcLengthDivisions): 200;\r\n\r\n\tif ( this.cacheArcLengths\r\n\t\t&& ( this.cacheArcLengths.length == divisions + 1 )\r\n\t\t&& !this.needsUpdate) {\r\n\r\n\t\t//console.log( \"cached\", this.cacheArcLengths );\r\n\t\treturn this.cacheArcLengths;\r\n\r\n\t}\r\n\r\n\tthis.needsUpdate = false;\r\n\r\n\tvar cache = [];\r\n\tvar current, last = this.getPoint( 0 );\r\n\tvar p, sum = 0;\r\n\r\n\tcache.push( 0 );\r\n\r\n\tfor ( p = 1; p <= divisions; p ++ ) {\r\n\r\n\t\tcurrent = this.getPoint ( p / divisions );\r\n\t\tsum += current.distanceTo( last );\r\n\t\tcache.push( sum );\r\n\t\tlast = current;\r\n\r\n\t}\r\n\r\n\tthis.cacheArcLengths = cache;\r\n\r\n\treturn cache; // { sums: cache, sum:sum }; Sum is in the last element.\r\n\r\n};\r\n\r\n\r\nTHREE.Curve.prototype.updateArcLengths = function() {\r\n\tthis.needsUpdate = true;\r\n\tthis.getLengths();\r\n};\r\n\r\n// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance\r\n\r\nTHREE.Curve.prototype.getUtoTmapping = function ( u, distance ) {\r\n\r\n\tvar arcLengths = this.getLengths();\r\n\r\n\tvar i = 0, il = arcLengths.length;\r\n\r\n\tvar targetArcLength; // The targeted u distance value to get\r\n\r\n\tif ( distance ) {\r\n\r\n\t\ttargetArcLength = distance;\r\n\r\n\t} else {\r\n\r\n\t\ttargetArcLength = u * arcLengths[ il - 1 ];\r\n\r\n\t}\r\n\r\n\t//var time = Date.now();\r\n\r\n\t// binary search for the index with largest value smaller than target u distance\r\n\r\n\tvar low = 0, high = il - 1, comparison;\r\n\r\n\twhile ( low <= high ) {\r\n\r\n\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\r\n\r\n\t\tcomparison = arcLengths[ i ] - targetArcLength;\r\n\r\n\t\tif ( comparison < 0 ) {\r\n\r\n\t\t\tlow = i + 1;\r\n\t\t\tcontinue;\r\n\r\n\t\t} else if ( comparison > 0 ) {\r\n\r\n\t\t\thigh = i - 1;\r\n\t\t\tcontinue;\r\n\r\n\t\t} else {\r\n\r\n\t\t\thigh = i;\r\n\t\t\tbreak;\r\n\r\n\t\t\t// DONE\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\ti = high;\r\n\r\n\t//console.log('b' , i, low, high, Date.now()- time);\r\n\r\n\tif ( arcLengths[ i ] == targetArcLength ) {\r\n\r\n\t\tvar t = i / ( il - 1 );\r\n\t\treturn t;\r\n\r\n\t}\r\n\r\n\t// we could get finer grain at lengths, or use simple interpolatation between two points\r\n\r\n\tvar lengthBefore = arcLengths[ i ];\r\n    var lengthAfter = arcLengths[ i + 1 ];\r\n\r\n    var segmentLength = lengthAfter - lengthBefore;\r\n\r\n    // determine where we are between the 'before' and 'after' points\r\n\r\n    var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\r\n\r\n    // add that fractional amount to t\r\n\r\n    var t = ( i + segmentFraction ) / ( il -1 );\r\n\r\n\treturn t;\r\n\r\n};\r\n\r\n// Returns a unit vector tangent at t\r\n// In case any sub curve does not implement its tangent derivation,\r\n// 2 points a small delta apart will be used to find its gradient\r\n// which seems to give a reasonable approximation\r\n\r\nTHREE.Curve.prototype.getTangent = function( t ) {\r\n\r\n\tvar delta = 0.0001;\r\n\tvar t1 = t - delta;\r\n\tvar t2 = t + delta;\r\n\r\n\t// Capping in case of danger\r\n\r\n\tif ( t1 < 0 ) t1 = 0;\r\n\tif ( t2 > 1 ) t2 = 1;\r\n\r\n\tvar pt1 = this.getPoint( t1 );\r\n\tvar pt2 = this.getPoint( t2 );\r\n\r\n\tvar vec = pt2.clone().sub(pt1);\r\n\treturn vec.normalize();\r\n\r\n};\r\n\r\n\r\nTHREE.Curve.prototype.getTangentAt = function ( u ) {\r\n\r\n\tvar t = this.getUtoTmapping( u );\r\n\treturn this.getTangent( t );\r\n\r\n};\r\n\r\n/**************************************************************\r\n *\tLine\r\n **************************************************************/\r\n\r\nTHREE.LineCurve = function ( v1, v2 ) {\r\n\r\n\tthis.v1 = v1;\r\n\tthis.v2 = v2;\r\n\r\n};\r\n\r\nTHREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );\r\n\r\nTHREE.LineCurve.prototype.getPoint = function ( t ) {\r\n\r\n\tvar point = this.v2.clone().sub(this.v1);\r\n\tpoint.multiplyScalar( t ).add( this.v1 );\r\n\r\n\treturn point;\r\n\r\n};\r\n\r\n// Line curve is linear, so we can overwrite default getPointAt\r\n\r\nTHREE.LineCurve.prototype.getPointAt = function ( u ) {\r\n\r\n\treturn this.getPoint( u );\r\n\r\n};\r\n\r\nTHREE.LineCurve.prototype.getTangent = function( t ) {\r\n\r\n\tvar tangent = this.v2.clone().sub(this.v1);\r\n\r\n\treturn tangent.normalize();\r\n\r\n};\r\n\r\n/**************************************************************\r\n *\tQuadratic Bezier curve\r\n **************************************************************/\r\n\r\n\r\nTHREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {\r\n\r\n\tthis.v0 = v0;\r\n\tthis.v1 = v1;\r\n\tthis.v2 = v2;\r\n\r\n};\r\n\r\nTHREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );\r\n\r\n\r\nTHREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {\r\n\r\n\tvar tx, ty;\r\n\r\n\ttx = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );\r\n\tty = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );\r\n\r\n\treturn new THREE.Vector2( tx, ty );\r\n\r\n};\r\n\r\n\r\nTHREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {\r\n\r\n\tvar tx, ty;\r\n\r\n\ttx = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x );\r\n\tty = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y );\r\n\r\n\t// returns unit vector\r\n\r\n\tvar tangent = new THREE.Vector2( tx, ty );\r\n\ttangent.normalize();\r\n\r\n\treturn tangent;\r\n\r\n};\r\n\r\n\r\n/**************************************************************\r\n *\tCubic Bezier curve\r\n **************************************************************/\r\n\r\nTHREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {\r\n\r\n\tthis.v0 = v0;\r\n\tthis.v1 = v1;\r\n\tthis.v2 = v2;\r\n\tthis.v3 = v3;\r\n\r\n};\r\n\r\nTHREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );\r\n\r\nTHREE.CubicBezierCurve.prototype.getPoint = function ( t ) {\r\n\r\n\tvar tx, ty;\r\n\r\n\ttx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );\r\n\tty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );\r\n\r\n\treturn new THREE.Vector2( tx, ty );\r\n\r\n};\r\n\r\nTHREE.CubicBezierCurve.prototype.getTangent = function( t ) {\r\n\r\n\tvar tx, ty;\r\n\r\n\ttx = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );\r\n\tty = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );\r\n\r\n\tvar tangent = new THREE.Vector2( tx, ty );\r\n\ttangent.normalize();\r\n\r\n\treturn tangent;\r\n\r\n};\r\n\r\n\r\n/**************************************************************\r\n *\tSpline curve\r\n **************************************************************/\r\n\r\nTHREE.SplineCurve = function ( points /* array of Vector2 */ ) {\r\n\r\n\tthis.points = (points == undefined) ? [] : points;\r\n\r\n};\r\n\r\nTHREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );\r\n\r\nTHREE.SplineCurve.prototype.getPoint = function ( t ) {\r\n\r\n\tvar v = new THREE.Vector2();\r\n\tvar c = [];\r\n\tvar points = this.points, point, intPoint, weight;\r\n\tpoint = ( points.length - 1 ) * t;\r\n\r\n\tintPoint = Math.floor( point );\r\n\tweight = point - intPoint;\r\n\r\n\tc[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;\r\n\tc[ 1 ] = intPoint;\r\n\tc[ 2 ] = intPoint  > points.length - 2 ? points.length -1 : intPoint + 1;\r\n\tc[ 3 ] = intPoint  > points.length - 3 ? points.length -1 : intPoint + 2;\r\n\r\n\tv.x = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].x, points[ c[ 1 ] ].x, points[ c[ 2 ] ].x, points[ c[ 3 ] ].x, weight );\r\n\tv.y = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].y, points[ c[ 1 ] ].y, points[ c[ 2 ] ].y, points[ c[ 3 ] ].y, weight );\r\n\r\n\treturn v;\r\n\r\n};\r\n\r\n/**************************************************************\r\n *\tEllipse curve\r\n **************************************************************/\r\n\r\nTHREE.EllipseCurve = function ( aX, aY, xRadius, yRadius,\r\n\t\t\t\t\t\t\taStartAngle, aEndAngle,\r\n\t\t\t\t\t\t\taClockwise ) {\r\n\r\n\tthis.aX = aX;\r\n\tthis.aY = aY;\r\n\r\n\tthis.xRadius = xRadius;\r\n\tthis.yRadius = yRadius;\r\n\r\n\tthis.aStartAngle = aStartAngle;\r\n\tthis.aEndAngle = aEndAngle;\r\n\r\n\tthis.aClockwise = aClockwise;\r\n\r\n};\r\n\r\nTHREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );\r\n\r\nTHREE.EllipseCurve.prototype.getPoint = function ( t ) {\r\n\r\n\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\r\n\r\n\tif ( !this.aClockwise ) {\r\n\r\n\t\tt = 1 - t;\r\n\r\n\t}\r\n\r\n\tvar angle = this.aStartAngle + t * deltaAngle;\r\n\r\n\tvar tx = this.aX + this.xRadius * Math.cos( angle );\r\n\tvar ty = this.aY + this.yRadius * Math.sin( angle );\r\n\r\n\treturn new THREE.Vector2( tx, ty );\r\n\r\n};\r\n\r\n/**************************************************************\r\n *\tArc curve\r\n **************************************************************/\r\n\r\nTHREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n\tTHREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\r\n};\r\n\r\nTHREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );\r\n\r\n\r\n/**************************************************************\r\n *\tUtils\r\n **************************************************************/\r\n\r\nTHREE.Curve.Utils = {\r\n\r\n\ttangentQuadraticBezier: function ( t, p0, p1, p2 ) {\r\n\r\n\t\treturn 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );\r\n\r\n\t},\r\n\r\n\t// Puay Bing, thanks for helping with this derivative!\r\n\r\n\ttangentCubicBezier: function (t, p0, p1, p2, p3 ) {\r\n\r\n\t\treturn -3 * p0 * (1 - t) * (1 - t)  +\r\n\t\t\t3 * p1 * (1 - t) * (1-t) - 6 *t *p1 * (1-t) +\r\n\t\t\t6 * t *  p2 * (1-t) - 3 * t * t * p2 +\r\n\t\t\t3 * t * t * p3;\r\n\t},\r\n\r\n\r\n\ttangentSpline: function ( t, p0, p1, p2, p3 ) {\r\n\r\n\t\t// To check if my formulas are correct\r\n\r\n\t\tvar h00 = 6 * t * t - 6 * t; \t// derived from 2t^3 − 3t^2 + 1\r\n\t\tvar h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t\r\n\t\tvar h01 = -6 * t * t + 6 * t; \t// − 2t3 + 3t2\r\n\t\tvar h11 = 3 * t * t - 2 * t;\t// t3 − t2\r\n\r\n\t\treturn h00 + h10 + h01 + h11;\r\n\r\n\t},\r\n\r\n\t// Catmull-Rom\r\n\r\n\tinterpolate: function( p0, p1, p2, p3, t ) {\r\n\r\n\t\tvar v0 = ( p2 - p0 ) * 0.5;\r\n\t\tvar v1 = ( p3 - p1 ) * 0.5;\r\n\t\tvar t2 = t * t;\r\n\t\tvar t3 = t * t2;\r\n\t\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\r\n\t}\r\n\r\n};\r\n\r\n\r\n// TODO: Transformation for Curves?\r\n\r\n/**************************************************************\r\n *\t3D Curves\r\n **************************************************************/\r\n\r\n// A Factory method for creating new curve subclasses\r\n\r\nTHREE.Curve.create = function ( constructor, getPointFunc ) {\r\n\r\n\tconstructor.prototype = Object.create( THREE.Curve.prototype );\r\n\tconstructor.prototype.getPoint = getPointFunc;\r\n\r\n\treturn constructor;\r\n\r\n};\r\n\r\n\r\n/**************************************************************\r\n *\tLine3D\r\n **************************************************************/\r\n\r\nTHREE.LineCurve3 = THREE.Curve.create(\r\n\r\n\tfunction ( v1, v2 ) {\r\n\r\n\t\tthis.v1 = v1;\r\n\t\tthis.v2 = v2;\r\n\r\n\t},\r\n\r\n\tfunction ( t ) {\r\n\r\n\t\tvar r = new THREE.Vector3();\r\n\r\n\r\n\t\tr.subVectors( this.v2, this.v1 ); // diff\r\n\t\tr.multiplyScalar( t );\r\n\t\tr.add( this.v1 );\r\n\r\n\t\treturn r;\r\n\r\n\t}\r\n\r\n);\r\n\r\n\r\n/**************************************************************\r\n *\tQuadratic Bezier 3D curve\r\n **************************************************************/\r\n\r\nTHREE.QuadraticBezierCurve3 = THREE.Curve.create(\r\n\r\n\tfunction ( v0, v1, v2 ) {\r\n\r\n\t\tthis.v0 = v0;\r\n\t\tthis.v1 = v1;\r\n\t\tthis.v2 = v2;\r\n\r\n\t},\r\n\r\n\tfunction ( t ) {\r\n\r\n\t\tvar tx, ty, tz;\r\n\r\n\t\ttx = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );\r\n\t\tty = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );\r\n\t\ttz = THREE.Shape.Utils.b2( t, this.v0.z, this.v1.z, this.v2.z );\r\n\r\n\t\treturn new THREE.Vector3( tx, ty, tz );\r\n\r\n\t}\r\n\r\n);\r\n\r\n\r\n\r\n/**************************************************************\r\n *\tCubic Bezier 3D curve\r\n **************************************************************/\r\n\r\nTHREE.CubicBezierCurve3 = THREE.Curve.create(\r\n\r\n\tfunction ( v0, v1, v2, v3 ) {\r\n\r\n\t\tthis.v0 = v0;\r\n\t\tthis.v1 = v1;\r\n\t\tthis.v2 = v2;\r\n\t\tthis.v3 = v3;\r\n\r\n\t},\r\n\r\n\tfunction ( t ) {\r\n\r\n\t\tvar tx, ty, tz;\r\n\r\n\t\ttx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );\r\n\t\tty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );\r\n\t\ttz = THREE.Shape.Utils.b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z );\r\n\r\n\t\treturn new THREE.Vector3( tx, ty, tz );\r\n\r\n\t}\r\n\r\n);\r\n\r\n\r\n\r\n/**************************************************************\r\n *\tSpline 3D curve\r\n **************************************************************/\r\n\r\n\r\nTHREE.SplineCurve3 = THREE.Curve.create(\r\n\r\n\tfunction ( points /* array of Vector3 */) {\r\n\r\n\t\tthis.points = (points == undefined) ? [] : points;\r\n\r\n\t},\r\n\r\n\tfunction ( t ) {\r\n\r\n\t\tvar v = new THREE.Vector3();\r\n\t\tvar c = [];\r\n\t\tvar points = this.points, point, intPoint, weight;\r\n\t\tpoint = ( points.length - 1 ) * t;\r\n\r\n\t\tintPoint = Math.floor( point );\r\n\t\tweight = point - intPoint;\r\n\r\n\t\tc[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;\r\n\t\tc[ 1 ] = intPoint;\r\n\t\tc[ 2 ] = intPoint  > points.length - 2 ? points.length - 1 : intPoint + 1;\r\n\t\tc[ 3 ] = intPoint  > points.length - 3 ? points.length - 1 : intPoint + 2;\r\n\r\n\t\tvar pt0 = points[ c[0] ],\r\n\t\t\tpt1 = points[ c[1] ],\r\n\t\t\tpt2 = points[ c[2] ],\r\n\t\t\tpt3 = points[ c[3] ];\r\n\r\n\t\tv.x = THREE.Curve.Utils.interpolate(pt0.x, pt1.x, pt2.x, pt3.x, weight);\r\n\t\tv.y = THREE.Curve.Utils.interpolate(pt0.y, pt1.y, pt2.y, pt3.y, weight);\r\n\t\tv.z = THREE.Curve.Utils.interpolate(pt0.z, pt1.z, pt2.z, pt3.z, weight);\r\n\r\n\t\treturn v;\r\n\r\n\t}\r\n\r\n);\r\n\r\n\r\n// THREE.SplineCurve3.prototype.getTangent = function(t) {\r\n// \t\tvar v = new THREE.Vector3();\r\n// \t\tvar c = [];\r\n// \t\tvar points = this.points, point, intPoint, weight;\r\n// \t\tpoint = ( points.length - 1 ) * t;\r\n\r\n// \t\tintPoint = Math.floor( point );\r\n// \t\tweight = point - intPoint;\r\n\r\n// \t\tc[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;\r\n// \t\tc[ 1 ] = intPoint;\r\n// \t\tc[ 2 ] = intPoint  > points.length - 2 ? points.length - 1 : intPoint + 1;\r\n// \t\tc[ 3 ] = intPoint  > points.length - 3 ? points.length - 1 : intPoint + 2;\r\n\r\n// \t\tvar pt0 = points[ c[0] ],\r\n// \t\t\tpt1 = points[ c[1] ],\r\n// \t\t\tpt2 = points[ c[2] ],\r\n// \t\t\tpt3 = points[ c[3] ];\r\n\r\n// \t// t = weight;\r\n// \tv.x = THREE.Curve.Utils.tangentSpline( t, pt0.x, pt1.x, pt2.x, pt3.x );\r\n// \tv.y = THREE.Curve.Utils.tangentSpline( t, pt0.y, pt1.y, pt2.y, pt3.y );\r\n// \tv.z = THREE.Curve.Utils.tangentSpline( t, pt0.z, pt1.z, pt2.z, pt3.z );\r\n\r\n// \treturn v;\r\n\r\n// }\r\n\r\n/**************************************************************\r\n *\tClosed Spline 3D curve\r\n **************************************************************/\r\n\r\n\r\nTHREE.ClosedSplineCurve3 = THREE.Curve.create(\r\n\r\n\tfunction ( points /* array of Vector3 */) {\r\n\r\n\t\tthis.points = (points == undefined) ? [] : points;\r\n\r\n\t},\r\n\r\n    function ( t ) {\r\n\r\n        var v = new THREE.Vector3();\r\n        var c = [];\r\n        var points = this.points, point, intPoint, weight;\r\n        point = ( points.length - 0 ) * t;\r\n            // This needs to be from 0-length +1\r\n\r\n        intPoint = Math.floor( point );\r\n        weight = point - intPoint;\r\n\r\n        intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\r\n        c[ 0 ] = ( intPoint - 1 ) % points.length;\r\n        c[ 1 ] = ( intPoint ) % points.length;\r\n        c[ 2 ] = ( intPoint + 1 ) % points.length;\r\n        c[ 3 ] = ( intPoint + 2 ) % points.length;\r\n\r\n        v.x = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].x, points[ c[ 1 ] ].x, points[ c[ 2 ] ].x, points[ c[ 3 ] ].x, weight );\r\n        v.y = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].y, points[ c[ 1 ] ].y, points[ c[ 2 ] ].y, points[ c[ 3 ] ].y, weight );\r\n        v.z = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].z, points[ c[ 1 ] ].z, points[ c[ 2 ] ].z, points[ c[ 3 ] ].z, weight );\r\n\r\n        return v;\r\n\r\n    }\r\n\r\n);\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n *\r\n **/\r\n\r\n/**************************************************************\r\n *\tCurved Path - a curve path is simply a array of connected\r\n *  curves, but retains the api of a curve\r\n **************************************************************/\r\n\r\nTHREE.CurvePath = function () {\r\n\r\n\tthis.curves = [];\r\n\tthis.bends = [];\r\n\t\r\n\tthis.autoClose = false; // Automatically closes the path\r\n};\r\n\r\nTHREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );\r\n\r\nTHREE.CurvePath.prototype.add = function ( curve ) {\r\n\r\n\tthis.curves.push( curve );\r\n\r\n};\r\n\r\nTHREE.CurvePath.prototype.checkConnection = function() {\r\n\t// TODO\r\n\t// If the ending of curve is not connected to the starting\r\n\t// or the next curve, then, this is not a real path\r\n};\r\n\r\nTHREE.CurvePath.prototype.closePath = function() {\r\n\t// TODO Test\r\n\t// and verify for vector3 (needs to implement equals)\r\n\t// Add a line curve if start and end of lines are not connected\r\n\tvar startPoint = this.curves[0].getPoint(0);\r\n\tvar endPoint = this.curves[this.curves.length-1].getPoint(1);\r\n\t\r\n\tif (!startPoint.equals(endPoint)) {\r\n\t\tthis.curves.push( new THREE.LineCurve(endPoint, startPoint) );\r\n\t}\r\n\t\r\n};\r\n\r\n// To get accurate point with reference to\r\n// entire path distance at time t,\r\n// following has to be done:\r\n\r\n// 1. Length of each sub path have to be known\r\n// 2. Locate and identify type of curve\r\n// 3. Get t for the curve\r\n// 4. Return curve.getPointAt(t')\r\n\r\nTHREE.CurvePath.prototype.getPoint = function( t ) {\r\n\r\n\tvar d = t * this.getLength();\r\n\tvar curveLengths = this.getCurveLengths();\r\n\tvar i = 0, diff, curve;\r\n\r\n\t// To think about boundaries points.\r\n\r\n\twhile ( i < curveLengths.length ) {\r\n\r\n\t\tif ( curveLengths[ i ] >= d ) {\r\n\r\n\t\t\tdiff = curveLengths[ i ] - d;\r\n\t\t\tcurve = this.curves[ i ];\r\n\r\n\t\t\tvar u = 1 - diff / curve.getLength();\r\n\r\n\t\t\treturn curve.getPointAt( u );\r\n\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\ti ++;\r\n\r\n\t}\r\n\r\n\treturn null;\r\n\r\n\t// loop where sum != 0, sum > d , sum+1 <d\r\n\r\n};\r\n\r\n/*\r\nTHREE.CurvePath.prototype.getTangent = function( t ) {\r\n};*/\r\n\r\n\r\n// We cannot use the default THREE.Curve getPoint() with getLength() because in\r\n// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\r\n// getPoint() depends on getLength\r\n\r\nTHREE.CurvePath.prototype.getLength = function() {\r\n\r\n\tvar lens = this.getCurveLengths();\r\n\treturn lens[ lens.length - 1 ];\r\n\r\n};\r\n\r\n// Compute lengths and cache them\r\n// We cannot overwrite getLengths() because UtoT mapping uses it.\r\n\r\nTHREE.CurvePath.prototype.getCurveLengths = function() {\r\n\r\n\t// We use cache values if curves and cache array are same length\r\n\r\n\tif ( this.cacheLengths && this.cacheLengths.length == this.curves.length ) {\r\n\r\n\t\treturn this.cacheLengths;\r\n\r\n\t};\r\n\r\n\t// Get length of subsurve\r\n\t// Push sums into cached array\r\n\r\n\tvar lengths = [], sums = 0;\r\n\tvar i, il = this.curves.length;\r\n\r\n\tfor ( i = 0; i < il; i ++ ) {\r\n\r\n\t\tsums += this.curves[ i ].getLength();\r\n\t\tlengths.push( sums );\r\n\r\n\t}\r\n\r\n\tthis.cacheLengths = lengths;\r\n\r\n\treturn lengths;\r\n\r\n};\r\n\r\n\r\n\r\n// Returns min and max coordinates, as well as centroid\r\n\r\nTHREE.CurvePath.prototype.getBoundingBox = function () {\r\n\r\n\tvar points = this.getPoints();\r\n\r\n\tvar maxX, maxY, maxZ;\r\n\tvar minX, minY, minZ;\r\n\r\n\tmaxX = maxY = Number.NEGATIVE_INFINITY;\r\n\tminX = minY = Number.POSITIVE_INFINITY;\r\n\r\n\tvar p, i, il, sum;\r\n\r\n\tvar v3 = points[0] instanceof THREE.Vector3;\r\n\r\n\tsum = v3 ? new THREE.Vector3() : new THREE.Vector2();\r\n\r\n\tfor ( i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n\t\tp = points[ i ];\r\n\r\n\t\tif ( p.x > maxX ) maxX = p.x;\r\n\t\telse if ( p.x < minX ) minX = p.x;\r\n\r\n\t\tif ( p.y > maxY ) maxY = p.y;\r\n\t\telse if ( p.y < minY ) minY = p.y;\r\n\r\n\t\tif ( v3 ) {\r\n\r\n\t\t\tif ( p.z > maxZ ) maxZ = p.z;\r\n\t\t\telse if ( p.z < minZ ) minZ = p.z;\r\n\r\n\t\t}\r\n\r\n\t\tsum.add( p );\r\n\r\n\t}\r\n\r\n\tvar ret = {\r\n\r\n\t\tminX: minX,\r\n\t\tminY: minY,\r\n\t\tmaxX: maxX,\r\n\t\tmaxY: maxY,\r\n\t\tcentroid: sum.divideScalar( il )\r\n\r\n\t};\r\n\r\n\tif ( v3 ) {\r\n\r\n\t\tret.maxZ = maxZ;\r\n\t\tret.minZ = minZ;\r\n\r\n\t}\r\n\r\n\treturn ret;\r\n\r\n};\r\n\r\n/**************************************************************\r\n *\tCreate Geometries Helpers\r\n **************************************************************/\r\n\r\n/// Generate geometry from path points (for Line or ParticleSystem objects)\r\n\r\nTHREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {\r\n\r\n\tvar pts = this.getPoints( divisions, true );\r\n\treturn this.createGeometry( pts );\r\n\r\n};\r\n\r\n// Generate geometry from equidistance sampling along the path\r\n\r\nTHREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {\r\n\r\n\tvar pts = this.getSpacedPoints( divisions, true );\r\n\treturn this.createGeometry( pts );\r\n\r\n};\r\n\r\nTHREE.CurvePath.prototype.createGeometry = function( points ) {\r\n\r\n\tvar geometry = new THREE.Geometry();\r\n\r\n\tfor ( var i = 0; i < points.length; i ++ ) {\r\n\r\n\t\tgeometry.vertices.push( new THREE.Vector3( points[ i ].x, points[ i ].y, points[ i ].z || 0) );\r\n\r\n\t}\r\n\r\n\treturn geometry;\r\n\r\n};\r\n\r\n\r\n/**************************************************************\r\n *\tBend / Wrap Helper Methods\r\n **************************************************************/\r\n\r\n// Wrap path / Bend modifiers?\r\n\r\nTHREE.CurvePath.prototype.addWrapPath = function ( bendpath ) {\r\n\r\n\tthis.bends.push( bendpath );\r\n\r\n};\r\n\r\nTHREE.CurvePath.prototype.getTransformedPoints = function( segments, bends ) {\r\n\r\n\tvar oldPts = this.getPoints( segments ); // getPoints getSpacedPoints\r\n\tvar i, il;\r\n\r\n\tif ( !bends ) {\r\n\r\n\t\tbends = this.bends;\r\n\r\n\t}\r\n\r\n\tfor ( i = 0, il = bends.length; i < il; i ++ ) {\r\n\r\n\t\toldPts = this.getWrapPoints( oldPts, bends[ i ] );\r\n\r\n\t}\r\n\r\n\treturn oldPts;\r\n\r\n};\r\n\r\nTHREE.CurvePath.prototype.getTransformedSpacedPoints = function( segments, bends ) {\r\n\r\n\tvar oldPts = this.getSpacedPoints( segments );\r\n\r\n\tvar i, il;\r\n\r\n\tif ( !bends ) {\r\n\r\n\t\tbends = this.bends;\r\n\r\n\t}\r\n\r\n\tfor ( i = 0, il = bends.length; i < il; i ++ ) {\r\n\r\n\t\toldPts = this.getWrapPoints( oldPts, bends[ i ] );\r\n\r\n\t}\r\n\r\n\treturn oldPts;\r\n\r\n};\r\n\r\n// This returns getPoints() bend/wrapped around the contour of a path.\r\n// Read http://www.planetclegg.com/projects/WarpingTextToSplines.html\r\n\r\nTHREE.CurvePath.prototype.getWrapPoints = function ( oldPts, path ) {\r\n\r\n\tvar bounds = this.getBoundingBox();\r\n\r\n\tvar i, il, p, oldX, oldY, xNorm;\r\n\r\n\tfor ( i = 0, il = oldPts.length; i < il; i ++ ) {\r\n\r\n\t\tp = oldPts[ i ];\r\n\r\n\t\toldX = p.x;\r\n\t\toldY = p.y;\r\n\r\n\t\txNorm = oldX / bounds.maxX;\r\n\r\n\t\t// If using actual distance, for length > path, requires line extrusions\r\n\t\t//xNorm = path.getUtoTmapping(xNorm, oldX); // 3 styles. 1) wrap stretched. 2) wrap stretch by arc length 3) warp by actual distance\r\n\r\n\t\txNorm = path.getUtoTmapping( xNorm, oldX );\r\n\r\n\t\t// check for out of bounds?\r\n\r\n\t\tvar pathPt = path.getPoint( xNorm );\r\n\t\tvar normal = path.getNormalVector( xNorm ).multiplyScalar( oldY );\r\n\r\n\t\tp.x = pathPt.x + normal.x;\r\n\t\tp.y = pathPt.y + normal.y;\r\n\r\n\t}\r\n\r\n\treturn oldPts;\r\n\r\n};\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Gyroscope = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n};\r\n\r\nTHREE.Gyroscope.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.Gyroscope.prototype.updateMatrixWorld = function ( force ) {\r\n\r\n\tthis.matrixAutoUpdate && this.updateMatrix();\r\n\r\n\t// update matrixWorld\r\n\r\n\tif ( this.matrixWorldNeedsUpdate || force ) {\r\n\r\n\t\tif ( this.parent ) {\r\n\r\n\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\r\n\r\n\t\t\tthis.matrixWorld.decompose( this.translationWorld, this.rotationWorld, this.scaleWorld );\r\n\t\t\tthis.matrix.decompose( this.translationObject, this.rotationObject, this.scaleObject );\r\n\r\n\t\t\tthis.matrixWorld.compose( this.translationWorld, this.rotationObject, this.scaleWorld );\r\n\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.matrixWorld.copy( this.matrix );\r\n\r\n\t\t}\r\n\r\n\r\n\t\tthis.matrixWorldNeedsUpdate = false;\r\n\r\n\t\tforce = true;\r\n\r\n\t}\r\n\r\n\t// update children\r\n\r\n\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n\t\tthis.children[ i ].updateMatrixWorld( force );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Gyroscope.prototype.translationWorld = new THREE.Vector3();\r\nTHREE.Gyroscope.prototype.translationObject = new THREE.Vector3();\r\nTHREE.Gyroscope.prototype.rotationWorld = new THREE.Quaternion();\r\nTHREE.Gyroscope.prototype.rotationObject = new THREE.Quaternion();\r\nTHREE.Gyroscope.prototype.scaleWorld = new THREE.Vector3();\r\nTHREE.Gyroscope.prototype.scaleObject = new THREE.Vector3();\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Creates free form 2d path using series of points, lines or curves.\r\n *\r\n **/\r\n\r\nTHREE.Path = function ( points ) {\r\n\r\n\tTHREE.CurvePath.call(this);\r\n\r\n\tthis.actions = [];\r\n\r\n\tif ( points ) {\r\n\r\n\t\tthis.fromPoints( points );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Path.prototype = Object.create( THREE.CurvePath.prototype );\r\n\r\nTHREE.PathActions = {\r\n\r\n\tMOVE_TO: 'moveTo',\r\n\tLINE_TO: 'lineTo',\r\n\tQUADRATIC_CURVE_TO: 'quadraticCurveTo', // Bezier quadratic curve\r\n\tBEZIER_CURVE_TO: 'bezierCurveTo', \t\t// Bezier cubic curve\r\n\tCSPLINE_THRU: 'splineThru',\t\t\t\t// Catmull-rom spline\r\n\tARC: 'arc',\t\t\t\t\t\t\t\t// Circle\r\n\tELLIPSE: 'ellipse'\r\n};\r\n\r\n// TODO Clean up PATH API\r\n\r\n// Create path using straight lines to connect all points\r\n// - vectors: array of Vector2\r\n\r\nTHREE.Path.prototype.fromPoints = function ( vectors ) {\r\n\r\n\tthis.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );\r\n\r\n\tfor ( var v = 1, vlen = vectors.length; v < vlen; v ++ ) {\r\n\r\n\t\tthis.lineTo( vectors[ v ].x, vectors[ v ].y );\r\n\r\n\t};\r\n\r\n};\r\n\r\n// startPath() endPath()?\r\n\r\nTHREE.Path.prototype.moveTo = function ( x, y ) {\r\n\r\n\tvar args = Array.prototype.slice.call( arguments );\r\n\tthis.actions.push( { action: THREE.PathActions.MOVE_TO, args: args } );\r\n\r\n};\r\n\r\nTHREE.Path.prototype.lineTo = function ( x, y ) {\r\n\r\n\tvar args = Array.prototype.slice.call( arguments );\r\n\r\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n\tvar curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );\r\n\tthis.curves.push( curve );\r\n\r\n\tthis.actions.push( { action: THREE.PathActions.LINE_TO, args: args } );\r\n\r\n};\r\n\r\nTHREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {\r\n\r\n\tvar args = Array.prototype.slice.call( arguments );\r\n\r\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n\tvar curve = new THREE.QuadraticBezierCurve( new THREE.Vector2( x0, y0 ),\r\n\t\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aCPx, aCPy ),\r\n\t\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aX, aY ) );\r\n\tthis.curves.push( curve );\r\n\r\n\tthis.actions.push( { action: THREE.PathActions.QUADRATIC_CURVE_TO, args: args } );\r\n\r\n};\r\n\r\nTHREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y,\r\n                                               aCP2x, aCP2y,\r\n                                               aX, aY ) {\r\n\r\n\tvar args = Array.prototype.slice.call( arguments );\r\n\r\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n\tvar curve = new THREE.CubicBezierCurve( new THREE.Vector2( x0, y0 ),\r\n\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aCP1x, aCP1y ),\r\n\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aCP2x, aCP2y ),\r\n\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aX, aY ) );\r\n\tthis.curves.push( curve );\r\n\r\n\tthis.actions.push( { action: THREE.PathActions.BEZIER_CURVE_TO, args: args } );\r\n\r\n};\r\n\r\nTHREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {\r\n\r\n\tvar args = Array.prototype.slice.call( arguments );\r\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n//---\r\n\tvar npts = [ new THREE.Vector2( x0, y0 ) ];\r\n\tArray.prototype.push.apply( npts, pts );\r\n\r\n\tvar curve = new THREE.SplineCurve( npts );\r\n\tthis.curves.push( curve );\r\n\r\n\tthis.actions.push( { action: THREE.PathActions.CSPLINE_THRU, args: args } );\r\n\r\n};\r\n\r\n// FUTURE: Change the API or follow canvas API?\r\n\r\nTHREE.Path.prototype.arc = function ( aX, aY, aRadius,\r\n\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n\tvar lastargs = this.actions[ this.actions.length - 1].args;\r\n\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n\tthis.absarc(aX + x0, aY + y0, aRadius,\r\n\t\taStartAngle, aEndAngle, aClockwise );\r\n\t\r\n };\r\n\r\n THREE.Path.prototype.absarc = function ( aX, aY, aRadius,\r\n\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\r\n\tthis.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);\r\n };\r\n \r\nTHREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius,\r\n\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n\tvar lastargs = this.actions[ this.actions.length - 1].args;\r\n\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n\tthis.absellipse(aX + x0, aY + y0, xRadius, yRadius,\r\n\t\taStartAngle, aEndAngle, aClockwise );\r\n\r\n };\r\n \r\n\r\nTHREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius,\r\n\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n\tvar args = Array.prototype.slice.call( arguments );\r\n\tvar curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius,\r\n\t\t\t\t\t\t\t\t\taStartAngle, aEndAngle, aClockwise );\r\n\tthis.curves.push( curve );\r\n\r\n\tvar lastPoint = curve.getPoint(aClockwise ? 1 : 0);\r\n\targs.push(lastPoint.x);\r\n\targs.push(lastPoint.y);\r\n\r\n\tthis.actions.push( { action: THREE.PathActions.ELLIPSE, args: args } );\r\n\r\n };\r\n\r\nTHREE.Path.prototype.getSpacedPoints = function ( divisions, closedPath ) {\r\n\r\n\tif ( ! divisions ) divisions = 40;\r\n\r\n\tvar points = [];\r\n\r\n\tfor ( var i = 0; i < divisions; i ++ ) {\r\n\r\n\t\tpoints.push( this.getPoint( i / divisions ) );\r\n\r\n\t\t//if( !this.getPoint( i / divisions ) ) throw \"DIE\";\r\n\r\n\t}\r\n\r\n\t// if ( closedPath ) {\r\n\t//\r\n\t// \tpoints.push( points[ 0 ] );\r\n\t//\r\n\t// }\r\n\r\n\treturn points;\r\n\r\n};\r\n\r\n/* Return an array of vectors based on contour of the path */\r\n\r\nTHREE.Path.prototype.getPoints = function( divisions, closedPath ) {\r\n\r\n\tif (this.useSpacedPoints) {\r\n\t\tconsole.log('tata');\r\n\t\treturn this.getSpacedPoints( divisions, closedPath );\r\n\t}\r\n\r\n\tdivisions = divisions || 12;\r\n\r\n\tvar points = [];\r\n\r\n\tvar i, il, item, action, args;\r\n\tvar cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,\r\n\t\tlaste, j,\r\n\t\tt, tx, ty;\r\n\r\n\tfor ( i = 0, il = this.actions.length; i < il; i ++ ) {\r\n\r\n\t\titem = this.actions[ i ];\r\n\r\n\t\taction = item.action;\r\n\t\targs = item.args;\r\n\r\n\t\tswitch( action ) {\r\n\r\n\t\tcase THREE.PathActions.MOVE_TO:\r\n\r\n\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase THREE.PathActions.LINE_TO:\r\n\r\n\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase THREE.PathActions.QUADRATIC_CURVE_TO:\r\n\r\n\t\t\tcpx  = args[ 2 ];\r\n\t\t\tcpy  = args[ 3 ];\r\n\r\n\t\t\tcpx1 = args[ 0 ];\r\n\t\t\tcpy1 = args[ 1 ];\r\n\r\n\t\t\tif ( points.length > 0 ) {\r\n\r\n\t\t\t\tlaste = points[ points.length - 1 ];\r\n\r\n\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\tcpy0 = laste.y;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tlaste = this.actions[ i - 1 ].args;\r\n\r\n\t\t\t\tcpx0 = laste[ laste.length - 2 ];\r\n\t\t\t\tcpy0 = laste[ laste.length - 1 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( j = 1; j <= divisions; j ++ ) {\r\n\r\n\t\t\t\tt = j / divisions;\r\n\r\n\t\t\t\ttx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );\r\n\t\t\t\tty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );\r\n\r\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\r\n\t\t  \t}\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase THREE.PathActions.BEZIER_CURVE_TO:\r\n\r\n\t\t\tcpx  = args[ 4 ];\r\n\t\t\tcpy  = args[ 5 ];\r\n\r\n\t\t\tcpx1 = args[ 0 ];\r\n\t\t\tcpy1 = args[ 1 ];\r\n\r\n\t\t\tcpx2 = args[ 2 ];\r\n\t\t\tcpy2 = args[ 3 ];\r\n\r\n\t\t\tif ( points.length > 0 ) {\r\n\r\n\t\t\t\tlaste = points[ points.length - 1 ];\r\n\r\n\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\tcpy0 = laste.y;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tlaste = this.actions[ i - 1 ].args;\r\n\r\n\t\t\t\tcpx0 = laste[ laste.length - 2 ];\r\n\t\t\t\tcpy0 = laste[ laste.length - 1 ];\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tfor ( j = 1; j <= divisions; j ++ ) {\r\n\r\n\t\t\t\tt = j / divisions;\r\n\r\n\t\t\t\ttx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );\r\n\t\t\t\tty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );\r\n\r\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase THREE.PathActions.CSPLINE_THRU:\r\n\r\n\t\t\tlaste = this.actions[ i - 1 ].args;\r\n\r\n\t\t\tvar last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );\r\n\t\t\tvar spts = [ last ];\r\n\r\n\t\t\tvar n = divisions * args[ 0 ].length;\r\n\r\n\t\t\tspts = spts.concat( args[ 0 ] );\r\n\r\n\t\t\tvar spline = new THREE.SplineCurve( spts );\r\n\r\n\t\t\tfor ( j = 1; j <= n; j ++ ) {\r\n\r\n\t\t\t\tpoints.push( spline.getPointAt( j / n ) ) ;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase THREE.PathActions.ARC:\r\n\r\n\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\r\n\t\t\t\taRadius = args[ 2 ],\r\n\t\t\t\taStartAngle = args[ 3 ], aEndAngle = args[ 4 ],\r\n\t\t\t\taClockwise = !!args[ 5 ];\r\n\r\n\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\r\n\t\t\tvar angle;\r\n\t\t\tvar tdivisions = divisions * 2;\r\n\r\n\t\t\tfor ( j = 1; j <= tdivisions; j ++ ) {\r\n\r\n\t\t\t\tt = j / tdivisions;\r\n\r\n\t\t\t\tif ( ! aClockwise ) {\r\n\r\n\t\t\t\t\tt = 1 - t;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tangle = aStartAngle + t * deltaAngle;\r\n\r\n\t\t\t\ttx = aX + aRadius * Math.cos( angle );\r\n\t\t\t\tty = aY + aRadius * Math.sin( angle );\r\n\r\n\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\r\n\r\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t//console.log(points);\r\n\r\n\t\t  break;\r\n\t\t  \r\n\t\tcase THREE.PathActions.ELLIPSE:\r\n\r\n\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\r\n\t\t\t\txRadius = args[ 2 ],\r\n\t\t\t\tyRadius = args[ 3 ],\r\n\t\t\t\taStartAngle = args[ 4 ], aEndAngle = args[ 5 ],\r\n\t\t\t\taClockwise = !!args[ 6 ];\r\n\r\n\r\n\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\r\n\t\t\tvar angle;\r\n\t\t\tvar tdivisions = divisions * 2;\r\n\r\n\t\t\tfor ( j = 1; j <= tdivisions; j ++ ) {\r\n\r\n\t\t\t\tt = j / tdivisions;\r\n\r\n\t\t\t\tif ( ! aClockwise ) {\r\n\r\n\t\t\t\t\tt = 1 - t;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tangle = aStartAngle + t * deltaAngle;\r\n\r\n\t\t\t\ttx = aX + xRadius * Math.cos( angle );\r\n\t\t\t\tty = aY + yRadius * Math.sin( angle );\r\n\r\n\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\r\n\r\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t//console.log(points);\r\n\r\n\t\t  break;\r\n\r\n\t\t} // end switch\r\n\r\n\t}\r\n\r\n\r\n\r\n\t// Normalize to remove the closing point by default.\r\n\tvar lastPoint = points[ points.length - 1];\r\n\tvar EPSILON = 0.0000000001;\r\n\tif ( Math.abs(lastPoint.x - points[ 0 ].x) < EPSILON &&\r\n             Math.abs(lastPoint.y - points[ 0 ].y) < EPSILON)\r\n\t\tpoints.splice( points.length - 1, 1);\r\n\tif ( closedPath ) {\r\n\r\n\t\tpoints.push( points[ 0 ] );\r\n\r\n\t}\r\n\r\n\treturn points;\r\n\r\n};\r\n\r\n// Breaks path into shapes\r\n\r\nTHREE.Path.prototype.toShapes = function() {\r\n\r\n\tvar i, il, item, action, args;\r\n\r\n\tvar subPaths = [], lastPath = new THREE.Path();\r\n\r\n\tfor ( i = 0, il = this.actions.length; i < il; i ++ ) {\r\n\r\n\t\titem = this.actions[ i ];\r\n\r\n\t\targs = item.args;\r\n\t\taction = item.action;\r\n\r\n\t\tif ( action == THREE.PathActions.MOVE_TO ) {\r\n\r\n\t\t\tif ( lastPath.actions.length != 0 ) {\r\n\r\n\t\t\t\tsubPaths.push( lastPath );\r\n\t\t\t\tlastPath = new THREE.Path();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tlastPath[ action ].apply( lastPath, args );\r\n\r\n\t}\r\n\r\n\tif ( lastPath.actions.length != 0 ) {\r\n\r\n\t\tsubPaths.push( lastPath );\r\n\r\n\t}\r\n\r\n\t// console.log(subPaths);\r\n\r\n\tif ( subPaths.length == 0 ) return [];\r\n\r\n\tvar tmpPath, tmpShape, shapes = [];\r\n\r\n\tvar holesFirst = !THREE.Shape.Utils.isClockWise( subPaths[ 0 ].getPoints() );\r\n\t// console.log(\"Holes first\", holesFirst);\r\n\r\n\tif ( subPaths.length == 1) {\r\n\t\ttmpPath = subPaths[0];\r\n\t\ttmpShape = new THREE.Shape();\r\n\t\ttmpShape.actions = tmpPath.actions;\r\n\t\ttmpShape.curves = tmpPath.curves;\r\n\t\tshapes.push( tmpShape );\r\n\t\treturn shapes;\r\n\t};\r\n\r\n\tif ( holesFirst ) {\r\n\r\n\t\ttmpShape = new THREE.Shape();\r\n\r\n\t\tfor ( i = 0, il = subPaths.length; i < il; i ++ ) {\r\n\r\n\t\t\ttmpPath = subPaths[ i ];\r\n\r\n\t\t\tif ( THREE.Shape.Utils.isClockWise( tmpPath.getPoints() ) ) {\r\n\r\n\t\t\t\ttmpShape.actions = tmpPath.actions;\r\n\t\t\t\ttmpShape.curves = tmpPath.curves;\r\n\r\n\t\t\t\tshapes.push( tmpShape );\r\n\t\t\t\ttmpShape = new THREE.Shape();\r\n\r\n\t\t\t\t//console.log('cw', i);\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ttmpShape.holes.push( tmpPath );\r\n\r\n\t\t\t\t//console.log('ccw', i);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\t// Shapes first\r\n\r\n\t\tfor ( i = 0, il = subPaths.length; i < il; i ++ ) {\r\n\r\n\t\t\ttmpPath = subPaths[ i ];\r\n\r\n\t\t\tif ( THREE.Shape.Utils.isClockWise( tmpPath.getPoints() ) ) {\r\n\r\n\r\n\t\t\t\tif ( tmpShape ) shapes.push( tmpShape );\r\n\r\n\t\t\t\ttmpShape = new THREE.Shape();\r\n\t\t\t\ttmpShape.actions = tmpPath.actions;\r\n\t\t\t\ttmpShape.curves = tmpPath.curves;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ttmpShape.holes.push( tmpPath );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tshapes.push( tmpShape );\r\n\r\n\t}\r\n\r\n\t//console.log(\"shape\", shapes);\r\n\r\n\treturn shapes;\r\n\r\n};\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Defines a 2d shape plane using paths.\r\n **/\r\n\r\n// STEP 1 Create a path.\r\n// STEP 2 Turn path into shape.\r\n// STEP 3 ExtrudeGeometry takes in Shape/Shapes\r\n// STEP 3a - Extract points from each shape, turn to vertices\r\n// STEP 3b - Triangulate each shape, add faces.\r\n\r\nTHREE.Shape = function () {\r\n\r\n\tTHREE.Path.apply( this, arguments );\r\n\tthis.holes = [];\r\n\r\n};\r\n\r\nTHREE.Shape.prototype = Object.create( THREE.Path.prototype );\r\n\r\n// Convenience method to return ExtrudeGeometry\r\n\r\nTHREE.Shape.prototype.extrude = function ( options ) {\r\n\r\n\tvar extruded = new THREE.ExtrudeGeometry( this, options );\r\n\treturn extruded;\r\n\r\n};\r\n\r\n// Convenience method to return ShapeGeometry\r\n\r\nTHREE.Shape.prototype.makeGeometry = function ( options ) {\r\n\r\n\tvar geometry = new THREE.ShapeGeometry( this, options );\r\n\treturn geometry;\r\n\r\n};\r\n\r\n// Get points of holes\r\n\r\nTHREE.Shape.prototype.getPointsHoles = function ( divisions ) {\r\n\r\n\tvar i, il = this.holes.length, holesPts = [];\r\n\r\n\tfor ( i = 0; i < il; i ++ ) {\r\n\r\n\t\tholesPts[ i ] = this.holes[ i ].getTransformedPoints( divisions, this.bends );\r\n\r\n\t}\r\n\r\n\treturn holesPts;\r\n\r\n};\r\n\r\n// Get points of holes (spaced by regular distance)\r\n\r\nTHREE.Shape.prototype.getSpacedPointsHoles = function ( divisions ) {\r\n\r\n\tvar i, il = this.holes.length, holesPts = [];\r\n\r\n\tfor ( i = 0; i < il; i ++ ) {\r\n\r\n\t\tholesPts[ i ] = this.holes[ i ].getTransformedSpacedPoints( divisions, this.bends );\r\n\r\n\t}\r\n\r\n\treturn holesPts;\r\n\r\n};\r\n\r\n\r\n// Get points of shape and holes (keypoints based on segments parameter)\r\n\r\nTHREE.Shape.prototype.extractAllPoints = function ( divisions ) {\r\n\r\n\treturn {\r\n\r\n\t\tshape: this.getTransformedPoints( divisions ),\r\n\t\tholes: this.getPointsHoles( divisions )\r\n\r\n\t};\r\n\r\n};\r\n\r\nTHREE.Shape.prototype.extractPoints = function ( divisions ) {\r\n\r\n\tif (this.useSpacedPoints) {\r\n\t\treturn this.extractAllSpacedPoints(divisions);\r\n\t}\r\n\r\n\treturn this.extractAllPoints(divisions);\r\n\r\n};\r\n\r\n//\r\n// THREE.Shape.prototype.extractAllPointsWithBend = function ( divisions, bend ) {\r\n//\r\n// \treturn {\r\n//\r\n// \t\tshape: this.transform( bend, divisions ),\r\n// \t\tholes: this.getPointsHoles( divisions, bend )\r\n//\r\n// \t};\r\n//\r\n// };\r\n\r\n// Get points of shape and holes (spaced by regular distance)\r\n\r\nTHREE.Shape.prototype.extractAllSpacedPoints = function ( divisions ) {\r\n\r\n\treturn {\r\n\r\n\t\tshape: this.getTransformedSpacedPoints( divisions ),\r\n\t\tholes: this.getSpacedPointsHoles( divisions )\r\n\r\n\t};\r\n\r\n};\r\n\r\n/**************************************************************\r\n *\tUtils\r\n **************************************************************/\r\n\r\nTHREE.Shape.Utils = {\r\n\r\n\t/*\r\n\t\tcontour - array of vector2 for contour\r\n\t\tholes   - array of array of vector2\r\n\t*/\r\n\r\n\tremoveHoles: function ( contour, holes ) {\r\n\r\n\t\tvar shape = contour.concat(); // work on this shape\r\n\t\tvar allpoints = shape.concat();\r\n\r\n\t\t/* For each isolated shape, find the closest points and break to the hole to allow triangulation */\r\n\r\n\r\n\t\tvar prevShapeVert, nextShapeVert,\r\n\t\t\tprevHoleVert, nextHoleVert,\r\n\t\t\tholeIndex, shapeIndex,\r\n\t\t\tshapeId, shapeGroup,\r\n\t\t\th, h2,\r\n\t\t\thole, shortest, d,\r\n\t\t\tp, pts1, pts2,\r\n\t\t\ttmpShape1, tmpShape2,\r\n\t\t\ttmpHole1, tmpHole2,\r\n\t\t\tverts = [];\r\n\r\n\t\tfor ( h = 0; h < holes.length; h ++ ) {\r\n\r\n\t\t\thole = holes[ h ];\r\n\r\n\t\t\t/*\r\n\t\t\tshapeholes[ h ].concat(); // preserves original\r\n\t\t\tholes.push( hole );\r\n\t\t\t*/\r\n\r\n\t\t\tArray.prototype.push.apply( allpoints, hole );\r\n\r\n\t\t\tshortest = Number.POSITIVE_INFINITY;\r\n\r\n\r\n\t\t\t// Find the shortest pair of pts between shape and hole\r\n\r\n\t\t\t// Note: Actually, I'm not sure now if we could optimize this to be faster than O(m*n)\r\n\t\t\t// Using distanceToSquared() intead of distanceTo() should speed a little\r\n\t\t\t// since running square roots operations are reduced.\r\n\r\n\t\t\tfor ( h2 = 0; h2 < hole.length; h2 ++ ) {\r\n\r\n\t\t\t\tpts1 = hole[ h2 ];\r\n\t\t\t\tvar dist = [];\r\n\r\n\t\t\t\tfor ( p = 0; p < shape.length; p++ ) {\r\n\r\n\t\t\t\t\tpts2 = shape[ p ];\r\n\t\t\t\t\td = pts1.distanceToSquared( pts2 );\r\n\t\t\t\t\tdist.push( d );\r\n\r\n\t\t\t\t\tif ( d < shortest ) {\r\n\r\n\t\t\t\t\t\tshortest = d;\r\n\t\t\t\t\t\tholeIndex = h2;\r\n\t\t\t\t\t\tshapeIndex = p;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t//console.log(\"shortest\", shortest, dist);\r\n\r\n\t\t\tprevShapeVert = ( shapeIndex - 1 ) >= 0 ? shapeIndex - 1 : shape.length - 1;\r\n\t\t\tprevHoleVert = ( holeIndex - 1 ) >= 0 ? holeIndex - 1 : hole.length - 1;\r\n\r\n\t\t\tvar areaapts = [\r\n\r\n\t\t\t\thole[ holeIndex ],\r\n\t\t\t\tshape[ shapeIndex ],\r\n\t\t\t\tshape[ prevShapeVert ]\r\n\r\n\t\t\t];\r\n\r\n\t\t\tvar areaa = THREE.FontUtils.Triangulate.area( areaapts );\r\n\r\n\t\t\tvar areabpts = [\r\n\r\n\t\t\t\thole[ holeIndex ],\r\n\t\t\t\thole[ prevHoleVert ],\r\n\t\t\t\tshape[ shapeIndex ]\r\n\r\n\t\t\t];\r\n\r\n\t\t\tvar areab = THREE.FontUtils.Triangulate.area( areabpts );\r\n\r\n\t\t\tvar shapeOffset = 1;\r\n\t\t\tvar holeOffset = -1;\r\n\r\n\t\t\tvar oldShapeIndex = shapeIndex, oldHoleIndex = holeIndex;\r\n\t\t\tshapeIndex += shapeOffset;\r\n\t\t\tholeIndex += holeOffset;\r\n\r\n\t\t\tif ( shapeIndex < 0 ) { shapeIndex += shape.length;  }\r\n\t\t\tshapeIndex %= shape.length;\r\n\r\n\t\t\tif ( holeIndex < 0 ) { holeIndex += hole.length;  }\r\n\t\t\tholeIndex %= hole.length;\r\n\r\n\t\t\tprevShapeVert = ( shapeIndex - 1 ) >= 0 ? shapeIndex - 1 : shape.length - 1;\r\n\t\t\tprevHoleVert = ( holeIndex - 1 ) >= 0 ? holeIndex - 1 : hole.length - 1;\r\n\r\n\t\t\tareaapts = [\r\n\r\n\t\t\t\thole[ holeIndex ],\r\n\t\t\t\tshape[ shapeIndex ],\r\n\t\t\t\tshape[ prevShapeVert ]\r\n\r\n\t\t\t];\r\n\r\n\t\t\tvar areaa2 = THREE.FontUtils.Triangulate.area( areaapts );\r\n\r\n\t\t\tareabpts = [\r\n\r\n\t\t\t\thole[ holeIndex ],\r\n\t\t\t\thole[ prevHoleVert ],\r\n\t\t\t\tshape[ shapeIndex ]\r\n\r\n\t\t\t];\r\n\r\n\t\t\tvar areab2 = THREE.FontUtils.Triangulate.area( areabpts );\r\n\t\t\t//console.log(areaa,areab ,areaa2,areab2, ( areaa + areab ),  ( areaa2 + areab2 ));\r\n\r\n\t\t\tif ( ( areaa + areab ) > ( areaa2 + areab2 ) ) {\r\n\r\n\t\t\t\t// In case areas are not correct.\r\n\t\t\t\t//console.log(\"USE THIS\");\r\n\r\n\t\t\t\tshapeIndex = oldShapeIndex;\r\n\t\t\t\tholeIndex = oldHoleIndex ;\r\n\r\n\t\t\t\tif ( shapeIndex < 0 ) { shapeIndex += shape.length;  }\r\n\t\t\t\tshapeIndex %= shape.length;\r\n\r\n\t\t\t\tif ( holeIndex < 0 ) { holeIndex += hole.length;  }\r\n\t\t\t\tholeIndex %= hole.length;\r\n\r\n\t\t\t\tprevShapeVert = ( shapeIndex - 1 ) >= 0 ? shapeIndex - 1 : shape.length - 1;\r\n\t\t\t\tprevHoleVert = ( holeIndex - 1 ) >= 0 ? holeIndex - 1 : hole.length - 1;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t//console.log(\"USE THAT \")\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttmpShape1 = shape.slice( 0, shapeIndex );\r\n\t\t\ttmpShape2 = shape.slice( shapeIndex );\r\n\t\t\ttmpHole1 = hole.slice( holeIndex );\r\n\t\t\ttmpHole2 = hole.slice( 0, holeIndex );\r\n\r\n\t\t\t// Should check orders here again?\r\n\r\n\t\t\tvar trianglea = [\r\n\r\n\t\t\t\thole[ holeIndex ],\r\n\t\t\t\tshape[ shapeIndex ],\r\n\t\t\t\tshape[ prevShapeVert ]\r\n\r\n\t\t\t];\r\n\r\n\t\t\tvar triangleb = [\r\n\r\n\t\t\t\thole[ holeIndex ] ,\r\n\t\t\t\thole[ prevHoleVert ],\r\n\t\t\t\tshape[ shapeIndex ]\r\n\r\n\t\t\t];\r\n\r\n\t\t\tverts.push( trianglea );\r\n\t\t\tverts.push( triangleb );\r\n\r\n\t\t\tshape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );\r\n\r\n\t\t}\r\n\r\n\t\treturn {\r\n\r\n\t\t\tshape:shape, \t\t/* shape with no holes */\r\n\t\t\tisolatedPts: verts, /* isolated faces */\r\n\t\t\tallpoints: allpoints\r\n\r\n\t\t}\r\n\r\n\r\n\t},\r\n\r\n\ttriangulateShape: function ( contour, holes ) {\r\n\r\n\t\tvar shapeWithoutHoles = THREE.Shape.Utils.removeHoles( contour, holes );\r\n\r\n\t\tvar shape = shapeWithoutHoles.shape,\r\n\t\t\tallpoints = shapeWithoutHoles.allpoints,\r\n\t\t\tisolatedPts = shapeWithoutHoles.isolatedPts;\r\n\r\n\t\tvar triangles = THREE.FontUtils.Triangulate( shape, false ); // True returns indices for points of spooled shape\r\n\r\n\t\t// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.\r\n\r\n\t\t//console.log( \"triangles\",triangles, triangles.length );\r\n\t\t//console.log( \"allpoints\",allpoints, allpoints.length );\r\n\r\n\t\tvar i, il, f, face,\r\n\t\t\tkey, index,\r\n\t\t\tallPointsMap = {},\r\n\t\t\tisolatedPointsMap = {};\r\n\r\n\t\t// prepare all points map\r\n\r\n\t\tfor ( i = 0, il = allpoints.length; i < il; i ++ ) {\r\n\r\n\t\t\tkey = allpoints[ i ].x + \":\" + allpoints[ i ].y;\r\n\r\n\t\t\tif ( allPointsMap[ key ] !== undefined ) {\r\n\r\n\t\t\t\tconsole.log( \"Duplicate point\", key );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tallPointsMap[ key ] = i;\r\n\r\n\t\t}\r\n\r\n\t\t// check all face vertices against all points map\r\n\r\n\t\tfor ( i = 0, il = triangles.length; i < il; i ++ ) {\r\n\r\n\t\t\tface = triangles[ i ];\r\n\r\n\t\t\tfor ( f = 0; f < 3; f ++ ) {\r\n\r\n\t\t\t\tkey = face[ f ].x + \":\" + face[ f ].y;\r\n\r\n\t\t\t\tindex = allPointsMap[ key ];\r\n\r\n\t\t\t\tif ( index !== undefined ) {\r\n\r\n\t\t\t\t\tface[ f ] = index;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// check isolated points vertices against all points map\r\n\r\n\t\tfor ( i = 0, il = isolatedPts.length; i < il; i ++ ) {\r\n\r\n\t\t\tface = isolatedPts[ i ];\r\n\r\n\t\t\tfor ( f = 0; f < 3; f ++ ) {\r\n\r\n\t\t\t\tkey = face[ f ].x + \":\" + face[ f ].y;\r\n\r\n\t\t\t\tindex = allPointsMap[ key ];\r\n\r\n\t\t\t\tif ( index !== undefined ) {\r\n\r\n\t\t\t\t\tface[ f ] = index;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn triangles.concat( isolatedPts );\r\n\r\n\t}, // end triangulate shapes\r\n\r\n\t/*\r\n\ttriangulate2 : function( pts, holes ) {\r\n\r\n\t\t// For use with Poly2Tri.js\r\n\r\n\t\tvar allpts = pts.concat();\r\n\t\tvar shape = [];\r\n\t\tfor (var p in pts) {\r\n\t\t\tshape.push(new js.poly2tri.Point(pts[p].x, pts[p].y));\r\n\t\t}\r\n\r\n\t\tvar swctx = new js.poly2tri.SweepContext(shape);\r\n\r\n\t\tfor (var h in holes) {\r\n\t\t\tvar aHole = holes[h];\r\n\t\t\tvar newHole = []\r\n\t\t\tfor (i in aHole) {\r\n\t\t\t\tnewHole.push(new js.poly2tri.Point(aHole[i].x, aHole[i].y));\r\n\t\t\t\tallpts.push(aHole[i]);\r\n\t\t\t}\r\n\t\t\tswctx.AddHole(newHole);\r\n\t\t}\r\n\r\n\t\tvar find;\r\n\t\tvar findIndexForPt = function (pt) {\r\n\t\t\tfind = new THREE.Vector2(pt.x, pt.y);\r\n\t\t\tvar p;\r\n\t\t\tfor (p=0, pl = allpts.length; p<pl; p++) {\r\n\t\t\t\tif (allpts[p].equals(find)) return p;\r\n\t\t\t}\r\n\t\t\treturn -1;\r\n\t\t};\r\n\r\n\t\t// triangulate\r\n\t\tjs.poly2tri.sweep.Triangulate(swctx);\r\n\r\n\t\tvar triangles =  swctx.GetTriangles();\r\n\t\tvar tr ;\r\n\t\tvar facesPts = [];\r\n\t\tfor (var t in triangles) {\r\n\t\t\ttr =  triangles[t];\r\n\t\t\tfacesPts.push([\r\n\t\t\t\tfindIndexForPt(tr.GetPoint(0)),\r\n\t\t\t\tfindIndexForPt(tr.GetPoint(1)),\r\n\t\t\t\tfindIndexForPt(tr.GetPoint(2))\r\n\t\t\t\t\t]);\r\n\t\t}\r\n\r\n\r\n\t//\tconsole.log(facesPts);\r\n\t//\tconsole.log(\"triangles\", triangles.length, triangles);\r\n\r\n\t\t// Returns array of faces with 3 element each\r\n\treturn facesPts;\r\n\t},\r\n*/\r\n\r\n\tisClockWise: function ( pts ) {\r\n\r\n\t\treturn THREE.FontUtils.Triangulate.area( pts ) < 0;\r\n\r\n\t},\r\n\r\n\t// Bezier Curves formulas obtained from\r\n\t// http://en.wikipedia.org/wiki/B%C3%A9zier_curve\r\n\r\n\t// Quad Bezier Functions\r\n\r\n\tb2p0: function ( t, p ) {\r\n\r\n\t\tvar k = 1 - t;\r\n\t\treturn k * k * p;\r\n\r\n\t},\r\n\r\n\tb2p1: function ( t, p ) {\r\n\r\n\t\treturn 2 * ( 1 - t ) * t * p;\r\n\r\n\t},\r\n\r\n\tb2p2: function ( t, p ) {\r\n\r\n\t\treturn t * t * p;\r\n\r\n\t},\r\n\r\n\tb2: function ( t, p0, p1, p2 ) {\r\n\r\n\t\treturn this.b2p0( t, p0 ) + this.b2p1( t, p1 ) + this.b2p2( t, p2 );\r\n\r\n\t},\r\n\r\n\t// Cubic Bezier Functions\r\n\r\n\tb3p0: function ( t, p ) {\r\n\r\n\t\tvar k = 1 - t;\r\n\t\treturn k * k * k * p;\r\n\r\n\t},\r\n\r\n\tb3p1: function ( t, p ) {\r\n\r\n\t\tvar k = 1 - t;\r\n\t\treturn 3 * k * k * t * p;\r\n\r\n\t},\r\n\r\n\tb3p2: function ( t, p ) {\r\n\r\n\t\tvar k = 1 - t;\r\n\t\treturn 3 * k * t * t * p;\r\n\r\n\t},\r\n\r\n\tb3p3: function ( t, p ) {\r\n\r\n\t\treturn t * t * t * p;\r\n\r\n\t},\r\n\r\n\tb3: function ( t, p0, p1, p2, p3 ) {\r\n\r\n\t\treturn this.b3p0( t, p0 ) + this.b3p1( t, p1 ) + this.b3p2( t, p2 ) +  this.b3p3( t, p3 );\r\n\r\n\t}\r\n\r\n};\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n */\r\n\r\nTHREE.AnimationHandler = (function() {\r\n\r\n\tvar playing = [];\r\n\tvar library = {};\r\n\tvar that    = {};\r\n\r\n\r\n\t//--- update ---\r\n\r\n\tthat.update = function( deltaTimeMS ) {\r\n\r\n\t\tfor( var i = 0; i < playing.length; i ++ )\r\n\t\t\tplaying[ i ].update( deltaTimeMS );\r\n\r\n\t};\r\n\r\n\r\n\t//--- add ---\r\n\r\n\tthat.addToUpdate = function( animation ) {\r\n\r\n\t\tif ( playing.indexOf( animation ) === -1 )\r\n\t\t\tplaying.push( animation );\r\n\r\n\t};\r\n\r\n\r\n\t//--- remove ---\r\n\r\n\tthat.removeFromUpdate = function( animation ) {\r\n\r\n\t\tvar index = playing.indexOf( animation );\r\n\r\n\t\tif( index !== -1 )\r\n\t\t\tplaying.splice( index, 1 );\r\n\r\n\t};\r\n\r\n\r\n\t//--- add ---\r\n\r\n\tthat.add = function( data ) {\r\n\r\n\t\tif ( library[ data.name ] !== undefined )\r\n\t\t\tconsole.log( \"THREE.AnimationHandler.add: Warning! \" + data.name + \" already exists in library. Overwriting.\" );\r\n\r\n\t\tlibrary[ data.name ] = data;\r\n\t\tinitData( data );\r\n\r\n\t};\r\n\r\n\r\n\t//--- get ---\r\n\r\n\tthat.get = function( name ) {\r\n\r\n\t\tif ( typeof name === \"string\" ) {\r\n\r\n\t\t\tif ( library[ name ] ) {\r\n\r\n\t\t\t\treturn library[ name ];\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.log( \"THREE.AnimationHandler.get: Couldn't find animation \" + name );\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// todo: add simple tween library\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t//--- parse ---\r\n\r\n\tthat.parse = function( root ) {\r\n\r\n\t\t// setup hierarchy\r\n\r\n\t\tvar hierarchy = [];\r\n\r\n\t\tif ( root instanceof THREE.SkinnedMesh ) {\r\n\r\n\t\t\tfor( var b = 0; b < root.bones.length; b++ ) {\r\n\r\n\t\t\t\thierarchy.push( root.bones[ b ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tparseRecurseHierarchy( root, hierarchy );\r\n\r\n\t\t}\r\n\r\n\t\treturn hierarchy;\r\n\r\n\t};\r\n\r\n\tvar parseRecurseHierarchy = function( root, hierarchy ) {\r\n\r\n\t\thierarchy.push( root );\r\n\r\n\t\tfor( var c = 0; c < root.children.length; c++ )\r\n\t\t\tparseRecurseHierarchy( root.children[ c ], hierarchy );\r\n\r\n\t}\r\n\r\n\r\n\t//--- init data ---\r\n\r\n\tvar initData = function( data ) {\r\n\r\n\t\tif( data.initialized === true )\r\n\t\t\treturn;\r\n\r\n\r\n\t\t// loop through all keys\r\n\r\n\t\tfor( var h = 0; h < data.hierarchy.length; h ++ ) {\r\n\r\n\t\t\tfor( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\r\n\t\t\t\t// remove minus times\r\n\r\n\t\t\t\tif( data.hierarchy[ h ].keys[ k ].time < 0 )\r\n\t\t\t\t\tdata.hierarchy[ h ].keys[ k ].time = 0;\r\n\r\n\r\n\t\t\t\t// create quaternions\r\n\r\n\t\t\t\tif( data.hierarchy[ h ].keys[ k ].rot !== undefined &&\r\n\t\t\t\t !( data.hierarchy[ h ].keys[ k ].rot instanceof THREE.Quaternion ) ) {\r\n\r\n\t\t\t\t\tvar quat = data.hierarchy[ h ].keys[ k ].rot;\r\n\t\t\t\t\tdata.hierarchy[ h ].keys[ k ].rot = new THREE.Quaternion( quat[0], quat[1], quat[2], quat[3] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\t// prepare morph target keys\r\n\r\n\t\t\tif( data.hierarchy[ h ].keys.length && data.hierarchy[ h ].keys[ 0 ].morphTargets !== undefined ) {\r\n\r\n\t\t\t\t// get all used\r\n\r\n\t\t\t\tvar usedMorphTargets = {};\r\n\r\n\t\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\r\n\t\t\t\t\tfor ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {\r\n\r\n\t\t\t\t\t\tvar morphTargetName = data.hierarchy[ h ].keys[ k ].morphTargets[ m ];\r\n\t\t\t\t\t\tusedMorphTargets[ morphTargetName ] = -1;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdata.hierarchy[ h ].usedMorphTargets = usedMorphTargets;\r\n\r\n\r\n\t\t\t\t// set all used on all frames\r\n\r\n\t\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\r\n\t\t\t\t\tvar influences = {};\r\n\r\n\t\t\t\t\tfor ( var morphTargetName in usedMorphTargets ) {\r\n\r\n\t\t\t\t\t\tfor ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {\r\n\r\n\t\t\t\t\t\t\tif ( data.hierarchy[ h ].keys[ k ].morphTargets[ m ] === morphTargetName ) {\r\n\r\n\t\t\t\t\t\t\t\tinfluences[ morphTargetName ] = data.hierarchy[ h ].keys[ k ].morphTargetsInfluences[ m ];\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( m === data.hierarchy[ h ].keys[ k ].morphTargets.length ) {\r\n\r\n\t\t\t\t\t\t\tinfluences[ morphTargetName ] = 0;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tdata.hierarchy[ h ].keys[ k ].morphTargetsInfluences = influences;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\t// remove all keys that are on the same time\r\n\r\n\t\t\tfor ( var k = 1; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\r\n\t\t\t\tif ( data.hierarchy[ h ].keys[ k ].time === data.hierarchy[ h ].keys[ k - 1 ].time ) {\r\n\r\n\t\t\t\t\tdata.hierarchy[ h ].keys.splice( k, 1 );\r\n\t\t\t\t\tk --;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\t// set index\r\n\r\n\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\r\n\t\t\t\tdata.hierarchy[ h ].keys[ k ].index = k;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\t\t// JIT\r\n\r\n\t\tvar lengthInFrames = parseInt( data.length * data.fps, 10 );\r\n\r\n\t\tdata.JIT = {};\r\n\t\tdata.JIT.hierarchy = [];\r\n\r\n\t\tfor( var h = 0; h < data.hierarchy.length; h ++ )\r\n\t\t\tdata.JIT.hierarchy.push( new Array( lengthInFrames ) );\r\n\r\n\r\n\t\t// done\r\n\r\n\t\tdata.initialized = true;\r\n\r\n\t};\r\n\r\n\r\n\t// interpolation types\r\n\r\n\tthat.LINEAR = 0;\r\n\tthat.CATMULLROM = 1;\r\n\tthat.CATMULLROM_FORWARD = 2;\r\n\r\n\treturn that;\r\n\r\n}());\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Animation = function ( root, name, interpolationType ) {\r\n\r\n\tthis.root = root;\r\n\tthis.data = THREE.AnimationHandler.get( name );\r\n\tthis.hierarchy = THREE.AnimationHandler.parse( root );\r\n\r\n\tthis.currentTime = 0;\r\n\tthis.timeScale = 1;\r\n\r\n\tthis.isPlaying = false;\r\n\tthis.isPaused = true;\r\n\tthis.loop = true;\r\n\r\n\tthis.interpolationType = interpolationType !== undefined ? interpolationType : THREE.AnimationHandler.LINEAR;\r\n\r\n\tthis.points = [];\r\n\tthis.target = new THREE.Vector3();\r\n\r\n};\r\n\r\nTHREE.Animation.prototype.play = function ( loop, startTimeMS ) {\r\n\r\n\tif ( this.isPlaying === false ) {\r\n\r\n\t\tthis.isPlaying = true;\r\n\t\tthis.loop = loop !== undefined ? loop : true;\r\n\t\tthis.currentTime = startTimeMS !== undefined ? startTimeMS : 0;\r\n\r\n\t\t// reset key cache\r\n\r\n\t\tvar h, hl = this.hierarchy.length,\r\n\t\t\tobject;\r\n\r\n\t\tfor ( h = 0; h < hl; h ++ ) {\r\n\r\n\t\t\tobject = this.hierarchy[ h ];\r\n\r\n\t\t\tif ( this.interpolationType !== THREE.AnimationHandler.CATMULLROM_FORWARD ) {\r\n\r\n\t\t\t\tobject.useQuaternion = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobject.matrixAutoUpdate = true;\r\n\r\n\t\t\tif ( object.animationCache === undefined ) {\r\n\r\n\t\t\t\tobject.animationCache = {};\r\n\t\t\t\tobject.animationCache.prevKey = { pos: 0, rot: 0, scl: 0 };\r\n\t\t\t\tobject.animationCache.nextKey = { pos: 0, rot: 0, scl: 0 };\r\n\t\t\t\tobject.animationCache.originalMatrix = object instanceof THREE.Bone ? object.skinMatrix : object.matrix;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar prevKey = object.animationCache.prevKey;\r\n\t\t\tvar nextKey = object.animationCache.nextKey;\r\n\r\n\t\t\tprevKey.pos = this.data.hierarchy[ h ].keys[ 0 ];\r\n\t\t\tprevKey.rot = this.data.hierarchy[ h ].keys[ 0 ];\r\n\t\t\tprevKey.scl = this.data.hierarchy[ h ].keys[ 0 ];\r\n\r\n\t\t\tnextKey.pos = this.getNextKeyWith( \"pos\", h, 1 );\r\n\t\t\tnextKey.rot = this.getNextKeyWith( \"rot\", h, 1 );\r\n\t\t\tnextKey.scl = this.getNextKeyWith( \"scl\", h, 1 );\r\n\r\n\t\t}\r\n\r\n\t\tthis.update( 0 );\r\n\r\n\t}\r\n\r\n\tthis.isPaused = false;\r\n\r\n\tTHREE.AnimationHandler.addToUpdate( this );\r\n\r\n};\r\n\r\n\r\nTHREE.Animation.prototype.pause = function() {\r\n\r\n\tif ( this.isPaused === true ) {\r\n\r\n\t\tTHREE.AnimationHandler.addToUpdate( this );\r\n\r\n\t} else {\r\n\r\n\t\tTHREE.AnimationHandler.removeFromUpdate( this );\r\n\r\n\t}\r\n\r\n\tthis.isPaused = !this.isPaused;\r\n\r\n};\r\n\r\n\r\nTHREE.Animation.prototype.stop = function() {\r\n\r\n\tthis.isPlaying = false;\r\n\tthis.isPaused  = false;\r\n\tTHREE.AnimationHandler.removeFromUpdate( this );\r\n\r\n};\r\n\r\n\r\nTHREE.Animation.prototype.update = function ( deltaTimeMS ) {\r\n\r\n\t// early out\r\n\r\n\tif ( this.isPlaying === false ) return;\r\n\r\n\r\n\t// vars\r\n\r\n\tvar types = [ \"pos\", \"rot\", \"scl\" ];\r\n\tvar type;\r\n\tvar scale;\r\n\tvar vector;\r\n\tvar prevXYZ, nextXYZ;\r\n\tvar prevKey, nextKey;\r\n\tvar object;\r\n\tvar animationCache;\r\n\tvar frame;\r\n\tvar JIThierarchy = this.data.JIT.hierarchy;\r\n\tvar currentTime, unloopedCurrentTime;\r\n\tvar currentPoint, forwardPoint, angle;\r\n\r\n\r\n\tthis.currentTime += deltaTimeMS * this.timeScale;\r\n\r\n\tunloopedCurrentTime = this.currentTime;\r\n\tcurrentTime = this.currentTime = this.currentTime % this.data.length;\r\n\tframe = parseInt( Math.min( currentTime * this.data.fps, this.data.length * this.data.fps ), 10 );\r\n\r\n\r\n\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\r\n\r\n\t\tobject = this.hierarchy[ h ];\r\n\t\tanimationCache = object.animationCache;\r\n\r\n\t\t// loop through pos/rot/scl\r\n\r\n\t\tfor ( var t = 0; t < 3; t ++ ) {\r\n\r\n\t\t\t// get keys\r\n\r\n\t\t\ttype    = types[ t ];\r\n\t\t\tprevKey = animationCache.prevKey[ type ];\r\n\t\t\tnextKey = animationCache.nextKey[ type ];\r\n\r\n\t\t\t// switch keys?\r\n\r\n\t\t\tif ( nextKey.time <= unloopedCurrentTime ) {\r\n\r\n\t\t\t\t// did we loop?\r\n\r\n\t\t\t\tif ( currentTime < unloopedCurrentTime ) {\r\n\r\n\t\t\t\t\tif ( this.loop ) {\r\n\r\n\t\t\t\t\t\tprevKey = this.data.hierarchy[ h ].keys[ 0 ];\r\n\t\t\t\t\t\tnextKey = this.getNextKeyWith( type, h, 1 );\r\n\r\n\t\t\t\t\t\twhile( nextKey.time < currentTime ) {\r\n\r\n\t\t\t\t\t\t\tprevKey = nextKey;\r\n\t\t\t\t\t\t\tnextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tthis.stop();\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tdo {\r\n\r\n\t\t\t\t\t\tprevKey = nextKey;\r\n\t\t\t\t\t\tnextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );\r\n\r\n\t\t\t\t\t} while( nextKey.time < currentTime )\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tanimationCache.prevKey[ type ] = prevKey;\r\n\t\t\t\tanimationCache.nextKey[ type ] = nextKey;\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tobject.matrixAutoUpdate = true;\r\n\t\t\tobject.matrixWorldNeedsUpdate = true;\r\n\r\n\t\t\tscale = ( currentTime - prevKey.time ) / ( nextKey.time - prevKey.time );\r\n\t\t\tprevXYZ = prevKey[ type ];\r\n\t\t\tnextXYZ = nextKey[ type ];\r\n\r\n\r\n\t\t\t// check scale error\r\n\r\n\t\t\tif ( scale < 0 || scale > 1 ) {\r\n\r\n\t\t\t\tconsole.log( \"THREE.Animation.update: Warning! Scale out of bounds:\" + scale + \" on bone \" + h );\r\n\t\t\t\tscale = scale < 0 ? 0 : 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// interpolate\r\n\r\n\t\t\tif ( type === \"pos\" ) {\r\n\r\n\t\t\t\tvector = object.position;\r\n\r\n\t\t\t\tif ( this.interpolationType === THREE.AnimationHandler.LINEAR ) {\r\n\r\n\t\t\t\t\tvector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;\r\n\t\t\t\t\tvector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;\r\n\t\t\t\t\tvector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;\r\n\r\n\t\t\t\t} else if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\r\n\t\t\t\t\t\t    this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\r\n\r\n\t\t\t\t\tthis.points[ 0 ] = this.getPrevKeyWith( \"pos\", h, prevKey.index - 1 )[ \"pos\" ];\r\n\t\t\t\t\tthis.points[ 1 ] = prevXYZ;\r\n\t\t\t\t\tthis.points[ 2 ] = nextXYZ;\r\n\t\t\t\t\tthis.points[ 3 ] = this.getNextKeyWith( \"pos\", h, nextKey.index + 1 )[ \"pos\" ];\r\n\r\n\t\t\t\t\tscale = scale * 0.33 + 0.33;\r\n\r\n\t\t\t\t\tcurrentPoint = this.interpolateCatmullRom( this.points, scale );\r\n\r\n\t\t\t\t\tvector.x = currentPoint[ 0 ];\r\n\t\t\t\t\tvector.y = currentPoint[ 1 ];\r\n\t\t\t\t\tvector.z = currentPoint[ 2 ];\r\n\r\n\t\t\t\t\tif ( this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\r\n\r\n\t\t\t\t\t\tforwardPoint = this.interpolateCatmullRom( this.points, scale * 1.01 );\r\n\r\n\t\t\t\t\t\tthis.target.set( forwardPoint[ 0 ], forwardPoint[ 1 ], forwardPoint[ 2 ] );\r\n\t\t\t\t\t\tthis.target.sub( vector );\r\n\t\t\t\t\t\tthis.target.y = 0;\r\n\t\t\t\t\t\tthis.target.normalize();\r\n\r\n\t\t\t\t\t\tangle = Math.atan2( this.target.x, this.target.z );\r\n\t\t\t\t\t\tobject.rotation.set( 0, angle, 0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( type === \"rot\" ) {\r\n\r\n\t\t\t\tTHREE.Quaternion.slerp( prevXYZ, nextXYZ, object.quaternion, scale );\r\n\r\n\t\t\t} else if ( type === \"scl\" ) {\r\n\r\n\t\t\t\tvector = object.scale;\r\n\r\n\t\t\t\tvector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;\r\n\t\t\t\tvector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;\r\n\t\t\t\tvector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\n// Catmull-Rom spline\r\n\r\nTHREE.Animation.prototype.interpolateCatmullRom = function ( points, scale ) {\r\n\r\n\tvar c = [], v3 = [],\r\n\tpoint, intPoint, weight, w2, w3,\r\n\tpa, pb, pc, pd;\r\n\r\n\tpoint = ( points.length - 1 ) * scale;\r\n\tintPoint = Math.floor( point );\r\n\tweight = point - intPoint;\r\n\r\n\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\r\n\tc[ 1 ] = intPoint;\r\n\tc[ 2 ] = intPoint > points.length - 2 ? intPoint : intPoint + 1;\r\n\tc[ 3 ] = intPoint > points.length - 3 ? intPoint : intPoint + 2;\r\n\r\n\tpa = points[ c[ 0 ] ];\r\n\tpb = points[ c[ 1 ] ];\r\n\tpc = points[ c[ 2 ] ];\r\n\tpd = points[ c[ 3 ] ];\r\n\r\n\tw2 = weight * weight;\r\n\tw3 = weight * w2;\r\n\r\n\tv3[ 0 ] = this.interpolate( pa[ 0 ], pb[ 0 ], pc[ 0 ], pd[ 0 ], weight, w2, w3 );\r\n\tv3[ 1 ] = this.interpolate( pa[ 1 ], pb[ 1 ], pc[ 1 ], pd[ 1 ], weight, w2, w3 );\r\n\tv3[ 2 ] = this.interpolate( pa[ 2 ], pb[ 2 ], pc[ 2 ], pd[ 2 ], weight, w2, w3 );\r\n\r\n\treturn v3;\r\n\r\n};\r\n\r\nTHREE.Animation.prototype.interpolate = function ( p0, p1, p2, p3, t, t2, t3 ) {\r\n\r\n\tvar v0 = ( p2 - p0 ) * 0.5,\r\n\t\tv1 = ( p3 - p1 ) * 0.5;\r\n\r\n\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\r\n};\r\n\r\n\r\n\r\n// Get next key with\r\n\r\nTHREE.Animation.prototype.getNextKeyWith = function ( type, h, key ) {\r\n\r\n\tvar keys = this.data.hierarchy[ h ].keys;\r\n\r\n\tif ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\r\n\t\t this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\r\n\r\n\t\tkey = key < keys.length - 1 ? key : keys.length - 1;\r\n\r\n\t} else {\r\n\r\n\t\tkey = key % keys.length;\r\n\r\n\t}\r\n\r\n\tfor ( ; key < keys.length; key++ ) {\r\n\r\n\t\tif ( keys[ key ][ type ] !== undefined ) {\r\n\r\n\t\t\treturn keys[ key ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn this.data.hierarchy[ h ].keys[ 0 ];\r\n\r\n};\r\n\r\n// Get previous key with\r\n\r\nTHREE.Animation.prototype.getPrevKeyWith = function ( type, h, key ) {\r\n\r\n\tvar keys = this.data.hierarchy[ h ].keys;\r\n\r\n\tif ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\r\n\t\t this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\r\n\r\n\t\tkey = key > 0 ? key : 0;\r\n\r\n\t} else {\r\n\r\n\t\tkey = key >= 0 ? key : key + keys.length;\r\n\r\n\t}\r\n\r\n\r\n\tfor ( ; key >= 0; key -- ) {\r\n\r\n\t\tif ( keys[ key ][ type ] !== undefined ) {\r\n\r\n\t\t\treturn keys[ key ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn this.data.hierarchy[ h ].keys[ keys.length - 1 ];\r\n\r\n};\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author khang duong\r\n * @author erik kitson\r\n */\r\n\r\nTHREE.KeyFrameAnimation = function( root, data, JITCompile ) {\r\n\r\n\tthis.root = root;\r\n\tthis.data = THREE.AnimationHandler.get( data );\r\n\tthis.hierarchy = THREE.AnimationHandler.parse( root );\r\n\tthis.currentTime = 0;\r\n\tthis.timeScale = 0.001;\r\n\tthis.isPlaying = false;\r\n\tthis.isPaused = true;\r\n\tthis.loop = true;\r\n\tthis.JITCompile = JITCompile !== undefined ? JITCompile : true;\r\n\r\n\t// initialize to first keyframes\r\n\r\n\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {\r\n\r\n\t\tvar keys = this.data.hierarchy[h].keys,\r\n\t\t\tsids = this.data.hierarchy[h].sids,\r\n\t\t\tobj = this.hierarchy[h];\r\n\r\n\t\tif ( keys.length && sids ) {\r\n\r\n\t\t\tfor ( var s = 0; s < sids.length; s++ ) {\r\n\r\n\t\t\t\tvar sid = sids[ s ],\r\n\t\t\t\t\tnext = this.getNextKeyWith( sid, h, 0 );\r\n\r\n\t\t\t\tif ( next ) {\r\n\r\n\t\t\t\t\tnext.apply( sid );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobj.matrixAutoUpdate = false;\r\n\t\t\tthis.data.hierarchy[h].node.updateMatrix();\r\n\t\t\tobj.matrixWorldNeedsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\n// Play\r\n\r\nTHREE.KeyFrameAnimation.prototype.play = function( loop, startTimeMS ) {\r\n\r\n\tif( !this.isPlaying ) {\r\n\r\n\t\tthis.isPlaying = true;\r\n\t\tthis.loop = loop !== undefined ? loop : true;\r\n\t\tthis.currentTime = startTimeMS !== undefined ? startTimeMS : 0;\r\n\t\tthis.startTimeMs = startTimeMS;\r\n\t\tthis.startTime = 10000000;\r\n\t\tthis.endTime = -this.startTime;\r\n\r\n\r\n\t\t// reset key cache\r\n\r\n\t\tvar h, hl = this.hierarchy.length,\r\n\t\t\tobject,\r\n\t\t\tnode;\r\n\r\n\t\tfor ( h = 0; h < hl; h++ ) {\r\n\r\n\t\t\tobject = this.hierarchy[ h ];\r\n\t\t\tnode = this.data.hierarchy[ h ];\r\n\t\t\tobject.useQuaternion = true;\r\n\r\n\t\t\tif ( node.animationCache === undefined ) {\r\n\r\n\t\t\t\tnode.animationCache = {};\r\n\t\t\t\tnode.animationCache.prevKey = null;\r\n\t\t\t\tnode.animationCache.nextKey = null;\r\n\t\t\t\tnode.animationCache.originalMatrix = object instanceof THREE.Bone ? object.skinMatrix : object.matrix;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar keys = this.data.hierarchy[h].keys;\r\n\r\n\t\t\tif (keys.length) {\r\n\r\n\t\t\t\tnode.animationCache.prevKey = keys[ 0 ];\r\n\t\t\t\tnode.animationCache.nextKey = keys[ 1 ];\r\n\r\n\t\t\t\tthis.startTime = Math.min( keys[0].time, this.startTime );\r\n\t\t\t\tthis.endTime = Math.max( keys[keys.length - 1].time, this.endTime );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.update( 0 );\r\n\r\n\t}\r\n\r\n\tthis.isPaused = false;\r\n\r\n\tTHREE.AnimationHandler.addToUpdate( this );\r\n\r\n};\r\n\r\n\r\n\r\n// Pause\r\n\r\nTHREE.KeyFrameAnimation.prototype.pause = function() {\r\n\r\n\tif( this.isPaused ) {\r\n\r\n\t\tTHREE.AnimationHandler.addToUpdate( this );\r\n\r\n\t} else {\r\n\r\n\t\tTHREE.AnimationHandler.removeFromUpdate( this );\r\n\r\n\t}\r\n\r\n\tthis.isPaused = !this.isPaused;\r\n\r\n};\r\n\r\n\r\n// Stop\r\n\r\nTHREE.KeyFrameAnimation.prototype.stop = function() {\r\n\r\n\tthis.isPlaying = false;\r\n\tthis.isPaused  = false;\r\n\tTHREE.AnimationHandler.removeFromUpdate( this );\r\n\r\n\r\n\t// reset JIT matrix and remove cache\r\n\r\n\tfor ( var h = 0; h < this.data.hierarchy.length; h++ ) {\r\n        \r\n        var obj = this.hierarchy[ h ];\r\n\t\tvar node = this.data.hierarchy[ h ];\r\n\r\n\t\tif ( node.animationCache !== undefined ) {\r\n\r\n\t\t\tvar original = node.animationCache.originalMatrix;\r\n\r\n\t\t\tif( obj instanceof THREE.Bone ) {\r\n\r\n\t\t\t\toriginal.copy( obj.skinMatrix );\r\n\t\t\t\tobj.skinMatrix = original;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\toriginal.copy( obj.matrix );\r\n\t\t\t\tobj.matrix = original;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdelete node.animationCache;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\n\r\n// Update\r\n\r\nTHREE.KeyFrameAnimation.prototype.update = function( deltaTimeMS ) {\r\n\r\n\t// early out\r\n\r\n\tif( !this.isPlaying ) return;\r\n\r\n\r\n\t// vars\r\n\r\n\tvar prevKey, nextKey;\r\n\tvar object;\r\n\tvar node;\r\n\tvar frame;\r\n\tvar JIThierarchy = this.data.JIT.hierarchy;\r\n\tvar currentTime, unloopedCurrentTime;\r\n\tvar looped;\r\n\r\n\r\n\t// update\r\n\r\n\tthis.currentTime += deltaTimeMS * this.timeScale;\r\n\r\n\tunloopedCurrentTime = this.currentTime;\r\n\tcurrentTime         = this.currentTime = this.currentTime % this.data.length;\r\n\r\n\t// if looped around, the current time should be based on the startTime\r\n\tif ( currentTime < this.startTimeMs ) {\r\n\r\n\t\tcurrentTime = this.currentTime = this.startTimeMs + currentTime;\r\n\r\n\t}\r\n\r\n\tframe               = parseInt( Math.min( currentTime * this.data.fps, this.data.length * this.data.fps ), 10 );\r\n\tlooped \t\t\t\t= currentTime < unloopedCurrentTime;\r\n\r\n\tif ( looped && !this.loop ) {\r\n\r\n\t\t// Set the animation to the last keyframes and stop\r\n\t\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {\r\n\r\n\t\t\tvar keys = this.data.hierarchy[h].keys,\r\n\t\t\t\tsids = this.data.hierarchy[h].sids,\r\n\t\t\t\tend = keys.length-1,\r\n\t\t\t\tobj = this.hierarchy[h];\r\n\r\n\t\t\tif ( keys.length ) {\r\n\r\n\t\t\t\tfor ( var s = 0; s < sids.length; s++ ) {\r\n\r\n\t\t\t\t\tvar sid = sids[ s ],\r\n\t\t\t\t\t\tprev = this.getPrevKeyWith( sid, h, end );\r\n\r\n\t\t\t\t\tif ( prev ) {\r\n\t\t\t\t\t\tprev.apply( sid );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.data.hierarchy[h].node.updateMatrix();\r\n\t\t\t\tobj.matrixWorldNeedsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.stop();\r\n\t\treturn;\r\n\r\n\t}\r\n\r\n\t// check pre-infinity\r\n\tif ( currentTime < this.startTime ) {\r\n\r\n\t\treturn;\r\n\r\n\t}\r\n\r\n\t// update\r\n\r\n\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {\r\n\r\n\t\tobject = this.hierarchy[ h ];\r\n\t\tnode = this.data.hierarchy[ h ];\r\n\r\n\t\tvar keys = node.keys,\r\n\t\t\tanimationCache = node.animationCache;\r\n\r\n\t\t// use JIT?\r\n\r\n\t\tif ( this.JITCompile && JIThierarchy[ h ][ frame ] !== undefined ) {\r\n\r\n\t\t\tif( object instanceof THREE.Bone ) {\r\n\r\n\t\t\t\tobject.skinMatrix = JIThierarchy[ h ][ frame ];\r\n\t\t\t\tobject.matrixWorldNeedsUpdate = false;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tobject.matrix = JIThierarchy[ h ][ frame ];\r\n\t\t\t\tobject.matrixWorldNeedsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t// use interpolation\r\n\r\n\t\t} else if ( keys.length ) {\r\n\r\n\t\t\t// make sure so original matrix and not JIT matrix is set\r\n\r\n\t\t\tif ( this.JITCompile && animationCache ) {\r\n\r\n\t\t\t\tif( object instanceof THREE.Bone ) {\r\n\r\n\t\t\t\t\tobject.skinMatrix = animationCache.originalMatrix;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tobject.matrix = animationCache.originalMatrix;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tprevKey = animationCache.prevKey;\r\n\t\t\tnextKey = animationCache.nextKey;\r\n\r\n\t\t\tif ( prevKey && nextKey ) {\r\n\r\n\t\t\t\t// switch keys?\r\n\r\n\t\t\t\tif ( nextKey.time <= unloopedCurrentTime ) {\r\n\r\n\t\t\t\t\t// did we loop?\r\n\r\n\t\t\t\t\tif ( looped && this.loop ) {\r\n\r\n\t\t\t\t\t\tprevKey = keys[ 0 ];\r\n\t\t\t\t\t\tnextKey = keys[ 1 ];\r\n\r\n\t\t\t\t\t\twhile ( nextKey.time < currentTime ) {\r\n\r\n\t\t\t\t\t\t\tprevKey = nextKey;\r\n\t\t\t\t\t\t\tnextKey = keys[ prevKey.index + 1 ];\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( !looped ) {\r\n\r\n\t\t\t\t\t\tvar lastIndex = keys.length - 1;\r\n\r\n\t\t\t\t\t\twhile ( nextKey.time < currentTime && nextKey.index !== lastIndex ) {\r\n\r\n\t\t\t\t\t\t\tprevKey = nextKey;\r\n\t\t\t\t\t\t\tnextKey = keys[ prevKey.index + 1 ];\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tanimationCache.prevKey = prevKey;\r\n\t\t\t\t\tanimationCache.nextKey = nextKey;\r\n\r\n\t\t\t\t}\r\n                if(nextKey.time >= currentTime)\r\n                    prevKey.interpolate( nextKey, currentTime );\r\n                else\r\n                    prevKey.interpolate( nextKey, nextKey.time);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.data.hierarchy[h].node.updateMatrix();\r\n\t\t\tobject.matrixWorldNeedsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// update JIT?\r\n\r\n\tif ( this.JITCompile ) {\r\n\r\n\t\tif ( JIThierarchy[ 0 ][ frame ] === undefined ) {\r\n\r\n\t\t\tthis.hierarchy[ 0 ].updateMatrixWorld( true );\r\n\r\n\t\t\tfor ( var h = 0; h < this.hierarchy.length; h++ ) {\r\n\r\n\t\t\t\tif( this.hierarchy[ h ] instanceof THREE.Bone ) {\r\n\r\n\t\t\t\t\tJIThierarchy[ h ][ frame ] = this.hierarchy[ h ].skinMatrix.clone();\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tJIThierarchy[ h ][ frame ] = this.hierarchy[ h ].matrix.clone();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\n// Get next key with\r\n\r\nTHREE.KeyFrameAnimation.prototype.getNextKeyWith = function( sid, h, key ) {\r\n\r\n\tvar keys = this.data.hierarchy[ h ].keys;\r\n\tkey = key % keys.length;\r\n\r\n\tfor ( ; key < keys.length; key++ ) {\r\n\r\n\t\tif ( keys[ key ].hasTarget( sid ) ) {\r\n\r\n\t\t\treturn keys[ key ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn keys[ 0 ];\r\n\r\n};\r\n\r\n// Get previous key with\r\n\r\nTHREE.KeyFrameAnimation.prototype.getPrevKeyWith = function( sid, h, key ) {\r\n\r\n\tvar keys = this.data.hierarchy[ h ].keys;\r\n\tkey = key >= 0 ? key : key + keys.length;\r\n\r\n\tfor ( ; key >= 0; key-- ) {\r\n\r\n\t\tif ( keys[ key ].hasTarget( sid ) ) {\r\n\r\n\t\t\treturn keys[ key ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn keys[ keys.length - 1 ];\r\n\r\n};\r\n/**\r\n * Camera for rendering cube maps\r\n *\t- renders scene into axis-aligned cube\r\n *\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.CubeCamera = function ( near, far, cubeResolution ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tvar fov = 90, aspect = 1;\r\n\r\n\tvar cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraPX.up.set( 0, -1, 0 );\r\n\tcameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );\r\n\tthis.add( cameraPX );\r\n\r\n\tvar cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraNX.up.set( 0, -1, 0 );\r\n\tcameraNX.lookAt( new THREE.Vector3( -1, 0, 0 ) );\r\n\tthis.add( cameraNX );\r\n\r\n\tvar cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraPY.up.set( 0, 0, 1 );\r\n\tcameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );\r\n\tthis.add( cameraPY );\r\n\r\n\tvar cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraNY.up.set( 0, 0, -1 );\r\n\tcameraNY.lookAt( new THREE.Vector3( 0, -1, 0 ) );\r\n\tthis.add( cameraNY );\r\n\r\n\tvar cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraPZ.up.set( 0, -1, 0 );\r\n\tcameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );\r\n\tthis.add( cameraPZ );\r\n\r\n\tvar cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraNZ.up.set( 0, -1, 0 );\r\n\tcameraNZ.lookAt( new THREE.Vector3( 0, 0, -1 ) );\r\n\tthis.add( cameraNZ );\r\n\r\n\tthis.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter } );\r\n\r\n\tthis.updateCubeMap = function ( renderer, scene ) {\r\n\r\n\t\tvar renderTarget = this.renderTarget;\r\n\t\tvar generateMipmaps = renderTarget.generateMipmaps;\r\n\r\n\t\trenderTarget.generateMipmaps = false;\r\n\r\n\t\trenderTarget.activeCubeFace = 0;\r\n\t\trenderer.render( scene, cameraPX, renderTarget );\r\n\r\n\t\trenderTarget.activeCubeFace = 1;\r\n\t\trenderer.render( scene, cameraNX, renderTarget );\r\n\r\n\t\trenderTarget.activeCubeFace = 2;\r\n\t\trenderer.render( scene, cameraPY, renderTarget );\r\n\r\n\t\trenderTarget.activeCubeFace = 3;\r\n\t\trenderer.render( scene, cameraNY, renderTarget );\r\n\r\n\t\trenderTarget.activeCubeFace = 4;\r\n\t\trenderer.render( scene, cameraPZ, renderTarget );\r\n\r\n\t\trenderTarget.generateMipmaps = generateMipmaps;\r\n\r\n\t\trenderTarget.activeCubeFace = 5;\r\n\t\trenderer.render( scene, cameraNZ, renderTarget );\r\n\r\n\t};\r\n\r\n};\r\n\r\nTHREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );\r\n/*\r\n *\t@author zz85 / http://twitter.com/blurspline / http://www.lab4games.net/zz85/blog\r\n *\r\n *\tA general perpose camera, for setting FOV, Lens Focal Length,\r\n *\t\tand switching between perspective and orthographic views easily.\r\n *\t\tUse this only if you do not wish to manage\r\n *\t\tboth a Orthographic and Perspective Camera\r\n *\r\n */\r\n\r\n\r\nTHREE.CombinedCamera = function ( width, height, fov, near, far, orthoNear, orthoFar ) {\r\n\r\n\tTHREE.Camera.call( this );\r\n\r\n\tthis.fov = fov;\r\n\r\n\tthis.left = -width / 2;\r\n\tthis.right = width / 2\r\n\tthis.top = height / 2;\r\n\tthis.bottom = -height / 2;\r\n\r\n\t// We could also handle the projectionMatrix internally, but just wanted to test nested camera objects\r\n\r\n\tthis.cameraO = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, \torthoNear, orthoFar );\r\n\tthis.cameraP = new THREE.PerspectiveCamera( fov, width / height, near, far );\r\n\r\n\tthis.zoom = 1;\r\n\r\n\tthis.toPerspective();\r\n\r\n\tvar aspect = width/height;\r\n\r\n};\r\n\r\nTHREE.CombinedCamera.prototype = Object.create( THREE.Camera.prototype );\r\n\r\nTHREE.CombinedCamera.prototype.toPerspective = function () {\r\n\r\n\t// Switches to the Perspective Camera\r\n\r\n\tthis.near = this.cameraP.near;\r\n\tthis.far = this.cameraP.far;\r\n\r\n\tthis.cameraP.fov =  this.fov / this.zoom ;\r\n\r\n\tthis.cameraP.updateProjectionMatrix();\r\n\r\n\tthis.projectionMatrix = this.cameraP.projectionMatrix;\r\n\r\n\tthis.inPerspectiveMode = true;\r\n\tthis.inOrthographicMode = false;\r\n\r\n};\r\n\r\nTHREE.CombinedCamera.prototype.toOrthographic = function () {\r\n\r\n\t// Switches to the Orthographic camera estimating viewport from Perspective\r\n\r\n\tvar fov = this.fov;\r\n\tvar aspect = this.cameraP.aspect;\r\n\tvar near = this.cameraP.near;\r\n\tvar far = this.cameraP.far;\r\n\r\n\t// The size that we set is the mid plane of the viewing frustum\r\n\r\n\tvar hyperfocus = ( near + far ) / 2;\r\n\r\n\tvar halfHeight = Math.tan( fov / 2 ) * hyperfocus;\r\n\tvar planeHeight = 2 * halfHeight;\r\n\tvar planeWidth = planeHeight * aspect;\r\n\tvar halfWidth = planeWidth / 2;\r\n\r\n\thalfHeight /= this.zoom;\r\n\thalfWidth /= this.zoom;\r\n\r\n\tthis.cameraO.left = -halfWidth;\r\n\tthis.cameraO.right = halfWidth;\r\n\tthis.cameraO.top = halfHeight;\r\n\tthis.cameraO.bottom = -halfHeight;\r\n\r\n\t// this.cameraO.left = -farHalfWidth;\r\n\t// this.cameraO.right = farHalfWidth;\r\n\t// this.cameraO.top = farHalfHeight;\r\n\t// this.cameraO.bottom = -farHalfHeight;\r\n\r\n\t// this.cameraO.left = this.left / this.zoom;\r\n\t// this.cameraO.right = this.right / this.zoom;\r\n\t// this.cameraO.top = this.top / this.zoom;\r\n\t// this.cameraO.bottom = this.bottom / this.zoom;\r\n\r\n\tthis.cameraO.updateProjectionMatrix();\r\n\r\n\tthis.near = this.cameraO.near;\r\n\tthis.far = this.cameraO.far;\r\n\tthis.projectionMatrix = this.cameraO.projectionMatrix;\r\n\r\n\tthis.inPerspectiveMode = false;\r\n\tthis.inOrthographicMode = true;\r\n\r\n};\r\n\r\n\r\nTHREE.CombinedCamera.prototype.setSize = function( width, height ) {\r\n\r\n\tthis.cameraP.aspect = width / height;\r\n\tthis.left = -width / 2;\r\n\tthis.right = width / 2\r\n\tthis.top = height / 2;\r\n\tthis.bottom = -height / 2;\r\n\r\n};\r\n\r\n\r\nTHREE.CombinedCamera.prototype.setFov = function( fov ) {\r\n\r\n\tthis.fov = fov;\r\n\r\n\tif ( this.inPerspectiveMode ) {\r\n\r\n\t\tthis.toPerspective();\r\n\r\n\t} else {\r\n\r\n\t\tthis.toOrthographic();\r\n\r\n\t}\r\n\r\n};\r\n\r\n// For mantaining similar API with PerspectiveCamera\r\n\r\nTHREE.CombinedCamera.prototype.updateProjectionMatrix = function() {\r\n\r\n\tif ( this.inPerspectiveMode ) {\r\n\r\n\t\tthis.toPerspective();\r\n\r\n\t} else {\r\n\r\n\t\tthis.toPerspective();\r\n\t\tthis.toOrthographic();\r\n\r\n\t}\r\n\r\n};\r\n\r\n/*\r\n* Uses Focal Length (in mm) to estimate and set FOV\r\n* 35mm (fullframe) camera is used if frame size is not specified;\r\n* Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html\r\n*/\r\nTHREE.CombinedCamera.prototype.setLens = function ( focalLength, frameHeight ) {\r\n\r\n\tif ( frameHeight === undefined ) frameHeight = 24;\r\n\r\n\tvar fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );\r\n\r\n\tthis.setFov( fov );\r\n\r\n\treturn fov;\r\n};\r\n\r\n\r\nTHREE.CombinedCamera.prototype.setZoom = function( zoom ) {\r\n\r\n\tthis.zoom = zoom;\r\n\r\n\tif ( this.inPerspectiveMode ) {\r\n\r\n\t\tthis.toPerspective();\r\n\r\n\t} else {\r\n\r\n\t\tthis.toOrthographic();\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.CombinedCamera.prototype.toFrontView = function() {\r\n\r\n\tthis.rotation.x = 0;\r\n\tthis.rotation.y = 0;\r\n\tthis.rotation.z = 0;\r\n\r\n\t// should we be modifing the matrix instead?\r\n\r\n\tthis.rotationAutoUpdate = false;\r\n\r\n};\r\n\r\nTHREE.CombinedCamera.prototype.toBackView = function() {\r\n\r\n\tthis.rotation.x = 0;\r\n\tthis.rotation.y = Math.PI;\r\n\tthis.rotation.z = 0;\r\n\tthis.rotationAutoUpdate = false;\r\n\r\n};\r\n\r\nTHREE.CombinedCamera.prototype.toLeftView = function() {\r\n\r\n\tthis.rotation.x = 0;\r\n\tthis.rotation.y = - Math.PI / 2;\r\n\tthis.rotation.z = 0;\r\n\tthis.rotationAutoUpdate = false;\r\n\r\n};\r\n\r\nTHREE.CombinedCamera.prototype.toRightView = function() {\r\n\r\n\tthis.rotation.x = 0;\r\n\tthis.rotation.y = Math.PI / 2;\r\n\tthis.rotation.z = 0;\r\n\tthis.rotationAutoUpdate = false;\r\n\r\n};\r\n\r\nTHREE.CombinedCamera.prototype.toTopView = function() {\r\n\r\n\tthis.rotation.x = - Math.PI / 2;\r\n\tthis.rotation.y = 0;\r\n\tthis.rotation.z = 0;\r\n\tthis.rotationAutoUpdate = false;\r\n\r\n};\r\n\r\nTHREE.CombinedCamera.prototype.toBottomView = function() {\r\n\r\n\tthis.rotation.x = Math.PI / 2;\r\n\tthis.rotation.y = 0;\r\n\tthis.rotation.z = 0;\r\n\tthis.rotationAutoUpdate = false;\r\n\r\n};\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n *\t- 3d asterisk shape (for line pieces THREE.Line)\r\n */\r\n\r\nTHREE.AsteriskGeometry = function ( innerRadius, outerRadius ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tvar sd = innerRadius;\r\n\tvar ed = outerRadius;\r\n\r\n\tvar sd2 = 0.707 * sd;\r\n\tvar ed2 = 0.707 * ed;\r\n\r\n\tvar rays = [ [ sd, 0, 0 ], [ ed, 0, 0 ], [ -sd, 0, 0 ], [ -ed, 0, 0 ],\r\n\t\t\t\t [ 0, sd, 0 ], [ 0, ed, 0 ], [ 0, -sd, 0 ], [ 0, -ed, 0 ],\r\n\t\t\t\t [ 0, 0, sd ], [ 0, 0, ed ], [ 0, 0, -sd ], [ 0, 0, -ed ],\r\n\t\t\t\t [ sd2, sd2, 0 ], [ ed2, ed2, 0 ], [ -sd2, -sd2, 0 ], [ -ed2, -ed2, 0 ],\r\n\t\t\t\t [ sd2, -sd2, 0 ], [ ed2, -ed2, 0 ], [ -sd2, sd2, 0 ], [ -ed2, ed2, 0 ],\r\n\t\t\t\t [ sd2, 0, sd2 ], [ ed2, 0, ed2 ], [ -sd2, 0, -sd2 ], [ -ed2, 0, -ed2 ],\r\n\t\t\t\t [ sd2, 0, -sd2 ], [ ed2, 0, -ed2 ], [ -sd2, 0, sd2 ], [ -ed2, 0, ed2 ],\r\n\t\t\t\t [ 0, sd2, sd2 ], [ 0, ed2, ed2 ], [ 0, -sd2, -sd2 ], [ 0, -ed2, -ed2 ],\r\n\t\t\t\t [ 0, sd2, -sd2 ], [ 0, ed2, -ed2 ], [ 0, -sd2, sd2 ], [ 0, -ed2, ed2 ]\r\n\t];\r\n\r\n\tfor ( var i = 0, il = rays.length; i < il; i ++ ) {\r\n\r\n\t\tvar x = rays[ i ][ 0 ];\r\n\t\tvar y = rays[ i ][ 1 ];\r\n\t\tvar z = rays[ i ][ 2 ];\r\n\r\n\t\tthis.vertices.push( new THREE.Vector3( x, y, z ) );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.AsteriskGeometry.prototype = Object.create( THREE.Geometry.prototype );/**\r\n * @author hughes\r\n */\r\n\r\nTHREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {\r\n\r\n    THREE.Geometry.call( this );\r\n\r\n    radius = radius || 50;\r\n\r\n    thetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\r\n    segments = segments !== undefined ? Math.max( 3, segments ) : 8;\r\n\r\n    var i, uvs = [],\r\n    center = new THREE.Vector3(), centerUV = new THREE.Vector2( 0.5, 0.5 );\r\n\r\n    this.vertices.push(center);\r\n    uvs.push( centerUV );\r\n\r\n    for ( i = 0; i <= segments; i ++ ) {\r\n\r\n        var vertex = new THREE.Vector3();\r\n\r\n        vertex.x = radius * Math.cos( thetaStart + i / segments * thetaLength );\r\n        vertex.y = radius * Math.sin( thetaStart + i / segments * thetaLength );\r\n\r\n        this.vertices.push( vertex );\r\n        uvs.push( new THREE.Vector2( ( vertex.x / radius + 1 ) / 2, - ( vertex.y / radius + 1 ) / 2 + 1 ) );\r\n\r\n    }\r\n\r\n    var n = new THREE.Vector3( 0, 0, -1 );\r\n\r\n    for ( i = 1; i <= segments; i ++ ) {\r\n\r\n        var v1 = i;\r\n        var v2 = i + 1 ;\r\n        var v3 = 0;\r\n\r\n        this.faces.push( new THREE.Face3( v1, v2, v3, [ n, n, n ] ) );\r\n        this.faceVertexUvs[ 0 ].push( [ uvs[ i ], uvs[ i + 1 ], centerUV ] );\r\n\r\n    }\r\n\r\n    this.computeCentroids();\r\n    this.computeFaceNormals();\r\n\r\n    this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\r\n};\r\n\r\nTHREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as\r\n */\r\n\r\nTHREE.CubeGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tvar scope = this;\r\n\r\n\tthis.width = width;\r\n\tthis.height = height;\r\n\tthis.depth = depth;\r\n\r\n\tthis.widthSegments = widthSegments || 1;\r\n\tthis.heightSegments = heightSegments || 1;\r\n\tthis.depthSegments = depthSegments || 1;\r\n\r\n\tvar width_half = this.width / 2;\r\n\tvar height_half = this.height / 2;\r\n\tvar depth_half = this.depth / 2;\r\n\r\n\tbuildPlane( 'z', 'y', - 1, - 1, this.depth, this.height, width_half, 0 ); // px\r\n\tbuildPlane( 'z', 'y',   1, - 1, this.depth, this.height, - width_half, 1 ); // nx\r\n\tbuildPlane( 'x', 'z',   1,   1, this.width, this.depth, height_half, 2 ); // py\r\n\tbuildPlane( 'x', 'z',   1, - 1, this.width, this.depth, - height_half, 3 ); // ny\r\n\tbuildPlane( 'x', 'y',   1, - 1, this.width, this.height, depth_half, 4 ); // pz\r\n\tbuildPlane( 'x', 'y', - 1, - 1, this.width, this.height, - depth_half, 5 ); // nz\r\n\r\n\tfunction buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {\r\n\r\n\t\tvar w, ix, iy,\r\n\t\tgridX = scope.widthSegments,\r\n\t\tgridY = scope.heightSegments,\r\n\t\twidth_half = width / 2,\r\n\t\theight_half = height / 2,\r\n\t\toffset = scope.vertices.length;\r\n\r\n\t\tif ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {\r\n\r\n\t\t\tw = 'z';\r\n\r\n\t\t} else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {\r\n\r\n\t\t\tw = 'y';\r\n\t\t\tgridY = scope.depthSegments;\r\n\r\n\t\t} else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {\r\n\r\n\t\t\tw = 'x';\r\n\t\t\tgridX = scope.depthSegments;\r\n\r\n\t\t}\r\n\r\n\t\tvar gridX1 = gridX + 1,\r\n\t\tgridY1 = gridY + 1,\r\n\t\tsegment_width = width / gridX,\r\n\t\tsegment_height = height / gridY,\r\n\t\tnormal = new THREE.Vector3();\r\n\r\n\t\tnormal[ w ] = depth > 0 ? 1 : - 1;\r\n\r\n\t\tfor ( iy = 0; iy < gridY1; iy ++ ) {\r\n\r\n\t\t\tfor ( ix = 0; ix < gridX1; ix ++ ) {\r\n\r\n\t\t\t\tvar vector = new THREE.Vector3();\r\n\t\t\t\tvector[ u ] = ( ix * segment_width - width_half ) * udir;\r\n\t\t\t\tvector[ v ] = ( iy * segment_height - height_half ) * vdir;\r\n\t\t\t\tvector[ w ] = depth;\r\n\r\n\t\t\t\tscope.vertices.push( vector );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( iy = 0; iy < gridY; iy++ ) {\r\n\r\n\t\t\tfor ( ix = 0; ix < gridX; ix++ ) {\r\n\r\n\t\t\t\tvar a = ix + gridX1 * iy;\r\n\t\t\t\tvar b = ix + gridX1 * ( iy + 1 );\r\n\t\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\r\n\t\t\t\tvar d = ( ix + 1 ) + gridX1 * iy;\r\n\r\n\t\t\t\tvar face = new THREE.Face4( a + offset, b + offset, c + offset, d + offset );\r\n\t\t\t\tface.normal.copy( normal );\r\n\t\t\t\tface.vertexNormals.push( normal.clone(), normal.clone(), normal.clone(), normal.clone() );\r\n\t\t\t\tface.materialIndex = materialIndex;\r\n\r\n\t\t\t\tscope.faces.push( face );\r\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( [\r\n\t\t\t\t\t\t\tnew THREE.Vector2( ix / gridX, 1 - iy / gridY ),\r\n\t\t\t\t\t\t\tnew THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY ),\r\n\t\t\t\t\t\t\tnew THREE.Vector2( ( ix + 1 ) / gridX, 1- ( iy + 1 ) / gridY ),\r\n\t\t\t\t\t\t\tnew THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY )\r\n\t\t\t\t\t\t] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.computeCentroids();\r\n\tthis.mergeVertices();\r\n\r\n};\r\n\r\nTHREE.CubeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tradiusTop = radiusTop !== undefined ? radiusTop : 20;\r\n\tradiusBottom = radiusBottom !== undefined ? radiusBottom : 20;\r\n\theight = height !== undefined ? height : 100;\r\n\r\n\tvar heightHalf = height / 2;\r\n\tvar segmentsX = radiusSegments || 8;\r\n\tvar segmentsY = heightSegments || 1;\r\n\r\n\tvar x, y, vertices = [], uvs = [];\r\n\r\n\tfor ( y = 0; y <= segmentsY; y ++ ) {\r\n\r\n\t\tvar verticesRow = [];\r\n\t\tvar uvsRow = [];\r\n\r\n\t\tvar v = y / segmentsY;\r\n\t\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\r\n\r\n\t\tfor ( x = 0; x <= segmentsX; x ++ ) {\r\n\r\n\t\t\tvar u = x / segmentsX;\r\n\r\n\t\t\tvar vertex = new THREE.Vector3();\r\n\t\t\tvertex.x = radius * Math.sin( u * Math.PI * 2 );\r\n\t\t\tvertex.y = - v * height + heightHalf;\r\n\t\t\tvertex.z = radius * Math.cos( u * Math.PI * 2 );\r\n\r\n\t\t\tthis.vertices.push( vertex );\r\n\r\n\t\t\tverticesRow.push( this.vertices.length - 1 );\r\n\t\t\tuvsRow.push( new THREE.Vector2( u, 1 - v ) );\r\n\r\n\t\t}\r\n\r\n\t\tvertices.push( verticesRow );\r\n\t\tuvs.push( uvsRow );\r\n\r\n\t}\r\n\r\n\tvar tanTheta = ( radiusBottom - radiusTop ) / height;\r\n\tvar na, nb;\r\n\r\n\tfor ( x = 0; x < segmentsX; x ++ ) {\r\n\r\n\t\tif ( radiusTop !== 0 ) {\r\n\r\n\t\t\tna = this.vertices[ vertices[ 0 ][ x ] ].clone();\r\n\t\t\tnb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();\r\n\r\n\t\t} else {\r\n\r\n\t\t\tna = this.vertices[ vertices[ 1 ][ x ] ].clone();\r\n\t\t\tnb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();\r\n\r\n\t\t}\r\n\r\n\t\tna.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();\r\n\t\tnb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();\r\n\r\n\t\tfor ( y = 0; y < segmentsY; y ++ ) {\r\n\r\n\t\t\tvar v1 = vertices[ y ][ x ];\r\n\t\t\tvar v2 = vertices[ y + 1 ][ x ];\r\n\t\t\tvar v3 = vertices[ y + 1 ][ x + 1 ];\r\n\t\t\tvar v4 = vertices[ y ][ x + 1 ];\r\n\r\n\t\t\tvar n1 = na.clone();\r\n\t\t\tvar n2 = na.clone();\r\n\t\t\tvar n3 = nb.clone();\r\n\t\t\tvar n4 = nb.clone();\r\n\r\n\t\t\tvar uv1 = uvs[ y ][ x ].clone();\r\n\t\t\tvar uv2 = uvs[ y + 1 ][ x ].clone();\r\n\t\t\tvar uv3 = uvs[ y + 1 ][ x + 1 ].clone();\r\n\t\t\tvar uv4 = uvs[ y ][ x + 1 ].clone();\r\n\r\n\t\t\tthis.faces.push( new THREE.Face4( v1, v2, v3, v4, [ n1, n2, n3, n4 ] ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3, uv4 ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// top cap\r\n\r\n\tif ( !openEnded && radiusTop > 0 ) {\r\n\r\n\t\tthis.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );\r\n\r\n\t\tfor ( x = 0; x < segmentsX; x ++ ) {\r\n\r\n\t\t\tvar v1 = vertices[ 0 ][ x ];\r\n\t\t\tvar v2 = vertices[ 0 ][ x + 1 ];\r\n\t\t\tvar v3 = this.vertices.length - 1;\r\n\r\n\t\t\tvar n1 = new THREE.Vector3( 0, 1, 0 );\r\n\t\t\tvar n2 = new THREE.Vector3( 0, 1, 0 );\r\n\t\t\tvar n3 = new THREE.Vector3( 0, 1, 0 );\r\n\r\n\t\t\tvar uv1 = uvs[ 0 ][ x ].clone();\r\n\t\t\tvar uv2 = uvs[ 0 ][ x + 1 ].clone();\r\n\t\t\tvar uv3 = new THREE.Vector2( uv2.u, 0 );\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// bottom cap\r\n\r\n\tif ( !openEnded && radiusBottom > 0 ) {\r\n\r\n\t\tthis.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );\r\n\r\n\t\tfor ( x = 0; x < segmentsX; x ++ ) {\r\n\r\n\t\t\tvar v1 = vertices[ y ][ x + 1 ];\r\n\t\t\tvar v2 = vertices[ y ][ x ];\r\n\t\t\tvar v3 = this.vertices.length - 1;\r\n\r\n\t\t\tvar n1 = new THREE.Vector3( 0, - 1, 0 );\r\n\t\t\tvar n2 = new THREE.Vector3( 0, - 1, 0 );\r\n\t\t\tvar n3 = new THREE.Vector3( 0, - 1, 0 );\r\n\r\n\t\t\tvar uv1 = uvs[ y ][ x + 1 ].clone();\r\n\t\t\tvar uv2 = uvs[ y ][ x ].clone();\r\n\t\t\tvar uv3 = new THREE.Vector2( uv2.u, 1 );\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.computeCentroids();\r\n\tthis.computeFaceNormals();\r\n\r\n}\r\n\r\nTHREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n *\r\n * Creates extruded geometry from a path shape.\r\n *\r\n * parameters = {\r\n *\r\n *  size: <float>, // size of the text\r\n *  height: <float>, // thickness to extrude text\r\n *  curveSegments: <int>, // number of points on the curves\r\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segements of extrude spline too\r\n *  amount: <int>, // Amount\r\n *\r\n *  bevelEnabled: <bool>, // turn on bevel\r\n *  bevelThickness: <float>, // how deep into text bevel goes\r\n *  bevelSize: <float>, // how far from text outline is bevel\r\n *  bevelSegments: <int>, // number of bevel layers\r\n *\r\n *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)\r\n *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals\r\n *\r\n *  material: <int> // material index for front and back faces\r\n *  extrudeMaterial: <int> // material index for extrusion and beveled faces\r\n *  uvGenerator: <Object> // object that provides UV generator functions\r\n *\r\n * }\r\n **/\r\n\r\nTHREE.ExtrudeGeometry = function ( shapes, options ) {\r\n\r\n\tif ( typeof( shapes ) === \"undefined\" ) {\r\n\t\tshapes = [];\r\n\t\treturn;\r\n\t}\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tshapes = shapes instanceof Array ? shapes : [ shapes ];\r\n\r\n\tthis.shapebb = shapes[ shapes.length - 1 ].getBoundingBox();\r\n\r\n\tthis.addShapeList( shapes, options );\r\n\r\n\tthis.computeCentroids();\r\n\tthis.computeFaceNormals();\r\n\r\n\t// can't really use automatic vertex normals\r\n\t// as then front and back sides get smoothed too\r\n\t// should do separate smoothing just for sides\r\n\r\n\t//this.computeVertexNormals();\r\n\r\n\t//console.log( \"took\", ( Date.now() - startTime ) );\r\n\r\n};\r\n\r\nTHREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\r\nTHREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {\r\n\tvar sl = shapes.length;\r\n\r\n\tfor ( var s = 0; s < sl; s ++ ) {\r\n\t\tvar shape = shapes[ s ];\r\n\t\tthis.addShape( shape, options );\r\n\t}\r\n};\r\n\r\nTHREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {\r\n\r\n\tvar amount = options.amount !== undefined ? options.amount : 100;\r\n\r\n\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\r\n\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\r\n\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\r\n\r\n\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\r\n\r\n\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\r\n\r\n\tvar steps = options.steps !== undefined ? options.steps : 1;\r\n\r\n\tvar extrudePath = options.extrudePath;\r\n\tvar extrudePts, extrudeByPath = false;\r\n\r\n\tvar material = options.material;\r\n\tvar extrudeMaterial = options.extrudeMaterial;\r\n\r\n\t// Use default WorldUVGenerator if no UV generators are specified.\r\n\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;\r\n\r\n\tvar shapebb = this.shapebb;\r\n\t//shapebb = shape.getBoundingBox();\r\n\r\n\r\n\r\n\tvar splineTube, binormal, normal, position2;\r\n\tif ( extrudePath ) {\r\n\r\n\t\textrudePts = extrudePath.getSpacedPoints( steps );\r\n\r\n\t\textrudeByPath = true;\r\n\t\tbevelEnabled = false; // bevels not supported for path extrusion\r\n\r\n\t\t// SETUP TNB variables\r\n\r\n\t\t// Reuse TNB from TubeGeomtry for now.\r\n\t\t// TODO1 - have a .isClosed in spline?\r\n\r\n\t\tsplineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath, steps, false);\r\n\r\n\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\r\n\r\n\t\tbinormal = new THREE.Vector3();\r\n\t\tnormal = new THREE.Vector3();\r\n\t\tposition2 = new THREE.Vector3();\r\n\r\n\t}\r\n\r\n\t// Safeguards if bevels are not enabled\r\n\r\n\tif ( ! bevelEnabled ) {\r\n\r\n\t\tbevelSegments = 0;\r\n\t\tbevelThickness = 0;\r\n\t\tbevelSize = 0;\r\n\r\n\t}\r\n\r\n\t// Variables initalization\r\n\r\n\tvar ahole, h, hl; // looping of holes\r\n\tvar scope = this;\r\n\tvar bevelPoints = [];\r\n\r\n\tvar shapesOffset = this.vertices.length;\r\n\r\n\tvar shapePoints = shape.extractPoints( curveSegments );\r\n\r\n\tvar vertices = shapePoints.shape;\r\n\tvar holes = shapePoints.holes;\r\n\r\n\tvar reverse = !THREE.Shape.Utils.isClockWise( vertices ) ;\r\n\r\n\tif ( reverse ) {\r\n\r\n\t\tvertices = vertices.reverse();\r\n\r\n\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\r\n\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\tahole = holes[ h ];\r\n\r\n\t\t\tif ( THREE.Shape.Utils.isClockWise( ahole ) ) {\r\n\r\n\t\t\t\tholes[ h ] = ahole.reverse();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!\r\n\r\n\t}\r\n\r\n\r\n\tvar faces = THREE.Shape.Utils.triangulateShape ( vertices, holes );\r\n\r\n\t/* Vertices */\r\n\r\n\tvar contour = vertices; // vertices has all points but contour has only points of circumference\r\n\r\n\tfor ( h = 0, hl = holes.length;  h < hl; h ++ ) {\r\n\r\n\t\tahole = holes[ h ];\r\n\r\n\t\tvertices = vertices.concat( ahole );\r\n\r\n\t}\r\n\r\n\r\n\tfunction scalePt2 ( pt, vec, size ) {\r\n\r\n\t\tif ( !vec ) console.log( \"die\" );\r\n\r\n\t\treturn vec.clone().multiplyScalar( size ).add( pt );\r\n\r\n\t}\r\n\r\n\tvar b, bs, t, z,\r\n\t\tvert, vlen = vertices.length,\r\n\t\tface, flen = faces.length,\r\n\t\tcont, clen = contour.length;\r\n\r\n\r\n\t// Find directions for point movement\r\n\r\n\tvar RAD_TO_DEGREES = 180 / Math.PI;\r\n\r\n\r\n\tfunction getBevelVec( pt_i, pt_j, pt_k ) {\r\n\r\n\t\t// Algorithm 2\r\n\r\n\t\treturn getBevelVec2( pt_i, pt_j, pt_k );\r\n\r\n\t}\r\n\r\n\tfunction getBevelVec1( pt_i, pt_j, pt_k ) {\r\n\r\n\t\tvar anglea = Math.atan2( pt_j.y - pt_i.y, pt_j.x - pt_i.x );\r\n\t\tvar angleb = Math.atan2( pt_k.y - pt_i.y, pt_k.x - pt_i.x );\r\n\r\n\t\tif ( anglea > angleb ) {\r\n\r\n\t\t\tangleb += Math.PI * 2;\r\n\r\n\t\t}\r\n\r\n\t\tvar anglec = ( anglea + angleb ) / 2;\r\n\r\n\r\n\t\t//console.log('angle1', anglea * RAD_TO_DEGREES,'angle2', angleb * RAD_TO_DEGREES, 'anglec', anglec *RAD_TO_DEGREES);\r\n\r\n\t\tvar x = - Math.cos( anglec );\r\n\t\tvar y = - Math.sin( anglec );\r\n\r\n\t\tvar vec = new THREE.Vector2( x, y ); //.normalize();\r\n\r\n\t\treturn vec;\r\n\r\n\t}\r\n\r\n\tfunction getBevelVec2( pt_i, pt_j, pt_k ) {\r\n\r\n\t\tvar a = THREE.ExtrudeGeometry.__v1,\r\n\t\t\tb = THREE.ExtrudeGeometry.__v2,\r\n\t\t\tv_hat = THREE.ExtrudeGeometry.__v3,\r\n\t\t\tw_hat = THREE.ExtrudeGeometry.__v4,\r\n\t\t\tp = THREE.ExtrudeGeometry.__v5,\r\n\t\t\tq = THREE.ExtrudeGeometry.__v6,\r\n\t\t\tv, w,\r\n\t\t\tv_dot_w_hat, q_sub_p_dot_w_hat,\r\n\t\t\ts, intersection;\r\n\r\n\t\t// good reading for line-line intersection\r\n\t\t// http://sputsoft.com/blog/2010/03/line-line-intersection.html\r\n\r\n\t\t// define a as vector j->i\r\n\t\t// define b as vectot k->i\r\n\r\n\t\ta.set( pt_i.x - pt_j.x, pt_i.y - pt_j.y );\r\n\t\tb.set( pt_i.x - pt_k.x, pt_i.y - pt_k.y );\r\n\r\n\t\t// get unit vectors\r\n\r\n\t\tv = a.normalize();\r\n\t\tw = b.normalize();\r\n\r\n\t\t// normals from pt i\r\n\r\n\t\tv_hat.set( -v.y, v.x );\r\n\t\tw_hat.set( w.y, -w.x );\r\n\r\n\t\t// pts from i\r\n\r\n\t\tp.copy( pt_i ).add( v_hat );\r\n\t\tq.copy( pt_i ).add( w_hat );\r\n\r\n\t\tif ( p.equals( q ) ) {\r\n\r\n\t\t\t//console.log(\"Warning: lines are straight\");\r\n\t\t\treturn w_hat.clone();\r\n\r\n\t\t}\r\n\r\n\t\t// Points from j, k. helps prevents points cross overover most of the time\r\n\r\n\t\tp.copy( pt_j ).add( v_hat );\r\n\t\tq.copy( pt_k ).add( w_hat );\r\n\r\n\t\tv_dot_w_hat = v.dot( w_hat );\r\n\t\tq_sub_p_dot_w_hat = q.sub( p ).dot( w_hat );\r\n\r\n\t\t// We should not reach these conditions\r\n\r\n\t\tif ( v_dot_w_hat === 0 ) {\r\n\r\n\t\t\tconsole.log( \"Either infinite or no solutions!\" );\r\n\r\n\t\t\tif ( q_sub_p_dot_w_hat === 0 ) {\r\n\r\n\t\t\t\tconsole.log( \"Its finite solutions.\" );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.log( \"Too bad, no solutions.\" );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\ts = q_sub_p_dot_w_hat / v_dot_w_hat;\r\n\r\n\t\tif ( s < 0 ) {\r\n\r\n\t\t\t// in case of emergecy, revert to algorithm 1.\r\n\r\n\t\t\treturn getBevelVec1( pt_i, pt_j, pt_k );\r\n\r\n\t\t}\r\n\r\n\t\tintersection = v.multiplyScalar( s ).add( p );\r\n\r\n\t\treturn intersection.sub( pt_i ).clone(); // Don't normalize!, otherwise sharp corners become ugly\r\n\r\n\t}\r\n\r\n\tvar contourMovements = [];\r\n\r\n\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\r\n\r\n\t\tif ( j === il ) j = 0;\r\n\t\tif ( k === il ) k = 0;\r\n\r\n\t\t//  (j)---(i)---(k)\r\n\t\t// console.log('i,j,k', i, j , k)\r\n\r\n\t\tvar pt_i = contour[ i ];\r\n\t\tvar pt_j = contour[ j ];\r\n\t\tvar pt_k = contour[ k ];\r\n\r\n\t\tcontourMovements[ i ]= getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\r\n\r\n\t}\r\n\r\n\tvar holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();\r\n\r\n\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\tahole = holes[ h ];\r\n\r\n\t\toneHoleMovements = [];\r\n\r\n\t\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\r\n\r\n\t\t\tif ( j === il ) j = 0;\r\n\t\t\tif ( k === il ) k = 0;\r\n\r\n\t\t\t//  (j)---(i)---(k)\r\n\t\t\toneHoleMovements[ i ]= getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\r\n\r\n\t\t}\r\n\r\n\t\tholesMovements.push( oneHoleMovements );\r\n\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\r\n\r\n\t}\r\n\r\n\r\n\t// Loop bevelSegments, 1 for the front, 1 for the back\r\n\r\n\tfor ( b = 0; b < bevelSegments; b ++ ) {\r\n\t//for ( b = bevelSegments; b > 0; b -- ) {\r\n\r\n\t\tt = b / bevelSegments;\r\n\t\tz = bevelThickness * ( 1 - t );\r\n\r\n\t\t//z = bevelThickness * t;\r\n\t\tbs = bevelSize * ( Math.sin ( t * Math.PI/2 ) ) ; // curved\r\n\t\t//bs = bevelSize * t ; // linear\r\n\r\n\t\t// contract shape\r\n\r\n\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\r\n\r\n\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\r\n\t\t\t//vert = scalePt( contour[ i ], contourCentroid, bs, false );\r\n\t\t\tv( vert.x, vert.y,  - z );\r\n\r\n\t\t}\r\n\r\n\t\t// expand holes\r\n\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h++ ) {\r\n\r\n\t\t\tahole = holes[ h ];\r\n\t\t\toneHoleMovements = holesMovements[ h ];\r\n\r\n\t\t\tfor ( i = 0, il = ahole.length; i < il; i++ ) {\r\n\r\n\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\r\n\t\t\t\t//vert = scalePt( ahole[ i ], holesCentroids[ h ], bs, true );\r\n\r\n\t\t\t\tv( vert.x, vert.y,  -z );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tbs = bevelSize;\r\n\r\n\t// Back facing vertices\r\n\r\n\tfor ( i = 0; i < vlen; i ++ ) {\r\n\r\n\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\r\n\r\n\t\tif ( !extrudeByPath ) {\r\n\r\n\t\t\tv( vert.x, vert.y, 0 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\r\n\r\n\t\t\tnormal.copy( splineTube.normals[0] ).multiplyScalar(vert.x);\r\n\t\t\tbinormal.copy( splineTube.binormals[0] ).multiplyScalar(vert.y);\r\n\r\n\t\t\tposition2.copy( extrudePts[0] ).add(normal).add(binormal);\r\n\r\n\t\t\tv( position2.x, position2.y, position2.z );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Add stepped vertices...\r\n\t// Including front facing vertices\r\n\r\n\tvar s;\r\n\r\n\tfor ( s = 1; s <= steps; s ++ ) {\r\n\r\n\t\tfor ( i = 0; i < vlen; i ++ ) {\r\n\r\n\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\r\n\r\n\t\t\tif ( !extrudeByPath ) {\r\n\r\n\t\t\t\tv( vert.x, vert.y, amount / steps * s );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\r\n\r\n\t\t\t\tnormal.copy( splineTube.normals[s] ).multiplyScalar( vert.x );\r\n\t\t\t\tbinormal.copy( splineTube.binormals[s] ).multiplyScalar( vert.y );\r\n\r\n\t\t\t\tposition2.copy( extrudePts[s] ).add( normal ).add( binormal );\r\n\r\n\t\t\t\tv( position2.x, position2.y, position2.z );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\t// Add bevel segments planes\r\n\r\n\t//for ( b = 1; b <= bevelSegments; b ++ ) {\r\n\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\r\n\r\n\t\tt = b / bevelSegments;\r\n\t\tz = bevelThickness * ( 1 - t );\r\n\t\t//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );\r\n\t\tbs = bevelSize * Math.sin ( t * Math.PI/2 ) ;\r\n\r\n\t\t// contract shape\r\n\r\n\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\r\n\r\n\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\r\n\t\t\tv( vert.x, vert.y,  amount + z );\r\n\r\n\t\t}\r\n\r\n\t\t// expand holes\r\n\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\tahole = holes[ h ];\r\n\t\t\toneHoleMovements = holesMovements[ h ];\r\n\r\n\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\r\n\r\n\t\t\t\tif ( !extrudeByPath ) {\r\n\r\n\t\t\t\t\tv( vert.x, vert.y,  amount + z );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/* Faces */\r\n\r\n\t// Top and bottom faces\r\n\r\n\tbuildLidFaces();\r\n\r\n\t// Sides faces\r\n\r\n\tbuildSideFaces();\r\n\r\n\r\n\t/////  Internal functions\r\n\r\n\tfunction buildLidFaces() {\r\n\r\n\t\tif ( bevelEnabled ) {\r\n\r\n\t\t\tvar layer = 0 ; // steps + 1\r\n\t\t\tvar offset = vlen * layer;\r\n\r\n\t\t\t// Bottom faces\r\n\r\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\tface = faces[ i ];\r\n\t\t\t\tf3( face[ 2 ]+ offset, face[ 1 ]+ offset, face[ 0 ] + offset, true );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlayer = steps + bevelSegments * 2;\r\n\t\t\toffset = vlen * layer;\r\n\r\n\t\t\t// Top faces\r\n\r\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\tface = faces[ i ];\r\n\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset, false );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// Bottom faces\r\n\r\n\t\t\tfor ( i = 0; i < flen; i++ ) {\r\n\r\n\t\t\t\tface = faces[ i ];\r\n\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ], true );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Top faces\r\n\r\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\tface = faces[ i ];\r\n\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps, false );\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Create faces for the z-sides of the shape\r\n\r\n\tfunction buildSideFaces() {\r\n\r\n\t\tvar layeroffset = 0;\r\n\t\tsidewalls( contour, layeroffset );\r\n\t\tlayeroffset += contour.length;\r\n\r\n\t\tfor ( h = 0, hl = holes.length;  h < hl; h ++ ) {\r\n\r\n\t\t\tahole = holes[ h ];\r\n\t\t\tsidewalls( ahole, layeroffset );\r\n\r\n\t\t\t//, true\r\n\t\t\tlayeroffset += ahole.length;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction sidewalls( contour, layeroffset ) {\r\n\r\n\t\tvar j, k;\r\n\t\ti = contour.length;\r\n\r\n\t\twhile ( --i >= 0 ) {\r\n\r\n\t\t\tj = i;\r\n\t\t\tk = i - 1;\r\n\t\t\tif ( k < 0 ) k = contour.length - 1;\r\n\r\n\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\r\n\r\n\t\t\tvar s = 0, sl = steps  + bevelSegments * 2;\r\n\r\n\t\t\tfor ( s = 0; s < sl; s ++ ) {\r\n\r\n\t\t\t\tvar slen1 = vlen * s;\r\n\t\t\t\tvar slen2 = vlen * ( s + 1 );\r\n\r\n\t\t\t\tvar a = layeroffset + j + slen1,\r\n\t\t\t\t\tb = layeroffset + k + slen1,\r\n\t\t\t\t\tc = layeroffset + k + slen2,\r\n\t\t\t\t\td = layeroffset + j + slen2;\r\n\r\n\t\t\t\tf4( a, b, c, d, contour, s, sl, j, k );\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\tfunction v( x, y, z ) {\r\n\r\n\t\tscope.vertices.push( new THREE.Vector3( x, y, z ) );\r\n\r\n\t}\r\n\r\n\tfunction f3( a, b, c, isBottom ) {\r\n\r\n\t\ta += shapesOffset;\r\n\t\tb += shapesOffset;\r\n\t\tc += shapesOffset;\r\n\r\n\t\t// normal, color, material\r\n\t\tscope.faces.push( new THREE.Face3( a, b, c, null, null, material ) );\r\n\r\n\t\tvar uvs = isBottom ? uvgen.generateBottomUV( scope, shape, options, a, b, c ) : uvgen.generateTopUV( scope, shape, options, a, b, c );\r\n\r\n \t\tscope.faceVertexUvs[ 0 ].push( uvs );\r\n\r\n\t}\r\n\r\n\tfunction f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {\r\n\r\n\t\ta += shapesOffset;\r\n\t\tb += shapesOffset;\r\n\t\tc += shapesOffset;\r\n\t\td += shapesOffset;\r\n\r\n \t\tscope.faces.push( new THREE.Face4( a, b, c, d, null, null, extrudeMaterial ) );\r\n\r\n \t\tvar uvs = uvgen.generateSideWallUV( scope, shape, wallContour, options, a, b, c, d,\r\n \t\t                                    stepIndex, stepsLength, contourIndex1, contourIndex2 );\r\n \t\tscope.faceVertexUvs[ 0 ].push( uvs );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.ExtrudeGeometry.WorldUVGenerator = {\r\n\r\n\tgenerateTopUV: function( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC ) {\r\n\t\tvar ax = geometry.vertices[ indexA ].x,\r\n\t\t\tay = geometry.vertices[ indexA ].y,\r\n\r\n\t\t\tbx = geometry.vertices[ indexB ].x,\r\n\t\t\tby = geometry.vertices[ indexB ].y,\r\n\r\n\t\t\tcx = geometry.vertices[ indexC ].x,\r\n\t\t\tcy = geometry.vertices[ indexC ].y;\r\n\r\n\t\treturn [\r\n\t\t\tnew THREE.Vector2( ax, ay ),\r\n\t\t\tnew THREE.Vector2( bx, by ),\r\n\t\t\tnew THREE.Vector2( cx, cy )\r\n\t\t];\r\n\r\n\t},\r\n\r\n\tgenerateBottomUV: function( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC ) {\r\n\r\n\t\treturn this.generateTopUV( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC );\r\n\r\n\t},\r\n\r\n\tgenerateSideWallUV: function( geometry, extrudedShape, wallContour, extrudeOptions,\r\n\t                              indexA, indexB, indexC, indexD, stepIndex, stepsLength,\r\n\t                              contourIndex1, contourIndex2 ) {\r\n\r\n\t\tvar ax = geometry.vertices[ indexA ].x,\r\n\t\t\tay = geometry.vertices[ indexA ].y,\r\n\t\t\taz = geometry.vertices[ indexA ].z,\r\n\r\n\t\t\tbx = geometry.vertices[ indexB ].x,\r\n\t\t\tby = geometry.vertices[ indexB ].y,\r\n\t\t\tbz = geometry.vertices[ indexB ].z,\r\n\r\n\t\t\tcx = geometry.vertices[ indexC ].x,\r\n\t\t\tcy = geometry.vertices[ indexC ].y,\r\n\t\t\tcz = geometry.vertices[ indexC ].z,\r\n\r\n\t\t\tdx = geometry.vertices[ indexD ].x,\r\n\t\t\tdy = geometry.vertices[ indexD ].y,\r\n\t\t\tdz = geometry.vertices[ indexD ].z;\r\n\r\n\t\tif ( Math.abs( ay - by ) < 0.01 ) {\r\n\t\t\treturn [\r\n\t\t\t\tnew THREE.Vector2( ax, 1 - az ),\r\n\t\t\t\tnew THREE.Vector2( bx, 1 - bz ),\r\n\t\t\t\tnew THREE.Vector2( cx, 1 - cz ),\r\n\t\t\t\tnew THREE.Vector2( dx, 1 - dz )\r\n\t\t\t];\r\n\t\t} else {\r\n\t\t\treturn [\r\n\t\t\t\tnew THREE.Vector2( ay, 1 - az ),\r\n\t\t\t\tnew THREE.Vector2( by, 1 - bz ),\r\n\t\t\t\tnew THREE.Vector2( cy, 1 - cz ),\r\n\t\t\t\tnew THREE.Vector2( dy, 1 - dz )\r\n\t\t\t];\r\n\t\t}\r\n\t}\r\n};\r\n\r\nTHREE.ExtrudeGeometry.__v1 = new THREE.Vector2();\r\nTHREE.ExtrudeGeometry.__v2 = new THREE.Vector2();\r\nTHREE.ExtrudeGeometry.__v3 = new THREE.Vector2();\r\nTHREE.ExtrudeGeometry.__v4 = new THREE.Vector2();\r\nTHREE.ExtrudeGeometry.__v5 = new THREE.Vector2();\r\nTHREE.ExtrudeGeometry.__v6 = new THREE.Vector2();\r\n/**\r\n * @author jonobr1 / http://jonobr1.com\r\n *\r\n * Creates a one-sided polygonal geometry from a path shape. Similar to\r\n * ExtrudeGeometry.\r\n *\r\n * parameters = {\r\n *\r\n *\tcurveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.\r\n *\r\n *\tmaterial: <int> // material index for front and back faces\r\n *\tuvGenerator: <Object> // object that provides UV generator functions\r\n *\r\n * }\r\n **/\r\n\r\nTHREE.ShapeGeometry = function ( shapes, options ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tif ( shapes instanceof Array === false ) shapes = [ shapes ];\r\n\r\n\tthis.shapebb = shapes[ shapes.length - 1 ].getBoundingBox();\r\n\r\n\tthis.addShapeList( shapes, options );\r\n\r\n\tthis.computeCentroids();\r\n\tthis.computeFaceNormals();\r\n\r\n};\r\n\r\nTHREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\r\n/**\r\n * Add an array of shapes to THREE.ShapeGeometry.\r\n */\r\nTHREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {\r\n\r\n\tfor ( var i = 0, l = shapes.length; i < l; i++ ) {\r\n\r\n\t\tthis.addShape( shapes[ i ], options );\r\n\r\n\t}\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n/**\r\n * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.\r\n */\r\nTHREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {\r\n\r\n\tif ( options === undefined ) options = {};\r\n\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\r\n\r\n\tvar material = options.material;\r\n\tvar uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;\r\n\r\n\tvar shapebb = this.shapebb;\r\n\r\n\t//\r\n\r\n\tvar i, l, hole, s;\r\n\r\n\tvar shapesOffset = this.vertices.length;\r\n\tvar shapePoints = shape.extractPoints( curveSegments );\r\n\r\n\tvar vertices = shapePoints.shape;\r\n\tvar holes = shapePoints.holes;\r\n\r\n\tvar reverse = !THREE.Shape.Utils.isClockWise( vertices );\r\n\r\n\tif ( reverse ) {\r\n\r\n\t\tvertices = vertices.reverse();\r\n\r\n\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe...\r\n\r\n\t\tfor ( i = 0, l = holes.length; i < l; i++ ) {\r\n\r\n\t\t\thole = holes[ i ];\r\n\r\n\t\t\tif ( THREE.Shape.Utils.isClockWise( hole ) ) {\r\n\r\n\t\t\t\tholes[ i ] = hole.reverse();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treverse = false;\r\n\r\n\t}\r\n\r\n\tvar faces = THREE.Shape.Utils.triangulateShape( vertices, holes );\r\n\r\n\t// Vertices\r\n\r\n\tvar contour = vertices;\r\n\r\n\tfor ( i = 0, l = holes.length; i < l; i++ ) {\r\n\r\n\t\thole = holes[ i ];\r\n\t\tvertices = vertices.concat( hole );\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tvar vert, vlen = vertices.length;\r\n\tvar face, flen = faces.length;\r\n\tvar cont, clen = contour.length;\r\n\r\n\tfor ( i = 0; i < vlen; i++ ) {\r\n\r\n\t\tvert = vertices[ i ];\r\n\r\n\t\tthis.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );\r\n\r\n\t}\r\n\r\n\tfor ( i = 0; i < flen; i++ ) {\r\n\r\n\t\tface = faces[ i ];\r\n\r\n\t\tvar a = face[ 0 ] + shapesOffset;\r\n\t\tvar b = face[ 1 ] + shapesOffset;\r\n\t\tvar c = face[ 2 ] + shapesOffset;\r\n\r\n\t\tthis.faces.push( new THREE.Face3( a, b, c, null, null, material ) );\r\n\t\tthis.faceVertexUvs[ 0 ].push( uvgen.generateBottomUV( this, shape, options, a, b, c ) );\r\n\r\n\t}\r\n\r\n};\r\n/**\r\n * @author astrodud / http://astrodud.isgreat.org/\r\n * @author zz85 / https://github.com/zz85\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\n// points - to create a closed torus, one must use a set of points \r\n//    like so: [ a, b, c, d, a ], see first is the same as last.\r\n// segments - the number of circumference segments to create\r\n// phiStart - the starting radian\r\n// phiLength - the radian (0 to 2*PI) range of the lathed section\r\n//    2*pi is a closed lathe, less than 2PI is a portion.\r\nTHREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tsegments = segments || 12;\r\n\tphiStart = phiStart || 0;\r\n\tphiLength = phiLength || 2 * Math.PI;\r\n\r\n\tvar inversePointLength = 1.0 / ( points.length - 1 );\r\n\tvar inverseSegments = 1.0 / segments;\r\n\r\n\tfor ( var i = 0, il = segments; i <= il; i ++ ) {\r\n\r\n\t\tvar phi = phiStart + i * inverseSegments * phiLength;\r\n\r\n\t\tvar c = Math.cos( phi ),\r\n\t\t\ts = Math.sin( phi );\r\n\r\n\t\tfor ( var j = 0, jl = points.length; j < jl; j ++ ) {\r\n\r\n\t\t\tvar pt = points[ j ];\r\n\r\n\t\t\tvar vertex = new THREE.Vector3();\r\n\r\n\t\t\tvertex.x = c * pt.x - s * pt.y;\r\n\t\t\tvertex.y = s * pt.x + c * pt.y;\r\n\t\t\tvertex.z = pt.z;\r\n\r\n\t\t\tthis.vertices.push( vertex );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tvar np = points.length;\r\n\r\n\tfor ( var i = 0, il = segments; i < il; i ++ ) {\r\n\r\n\t\tfor ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {\r\n\r\n\t\t\tvar base = j + np * i;\r\n\t\t\tvar a = base;\r\n\t\t\tvar b = base + np;\r\n\t\t\tvar c = base + 1 + np;\r\n\t\t\tvar d = base + 1;\r\n\r\n\t\t\tthis.faces.push( new THREE.Face4( a, b, c, d ) );\r\n\r\n\t\t\tvar u0 = i * inverseSegments;\r\n\t\t\tvar v0 = j * inversePointLength;\r\n\t\t\tvar u1 = u0 + inverseSegments;\r\n\t\t\tvar v1 = v0 + inversePointLength;\r\n\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [\r\n\r\n\t\t\t\tnew THREE.Vector2( u0, v0 ), \r\n\t\t\t\tnew THREE.Vector2( u1, v0 ),\r\n\t\t\t\tnew THREE.Vector2( u1, v1 ),\r\n\t\t\t\tnew THREE.Vector2( u0, v1 )\r\n\r\n\t\t\t] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.mergeVertices();\r\n\tthis.computeCentroids();\r\n\tthis.computeFaceNormals();\r\n\tthis.computeVertexNormals();\r\n\r\n};\r\n\r\nTHREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\r\n */\r\n\r\nTHREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.width = width;\r\n\tthis.height = height;\r\n\r\n\tthis.widthSegments = widthSegments || 1;\r\n\tthis.heightSegments = heightSegments || 1;\r\n\r\n\tvar ix, iz;\r\n\tvar width_half = width / 2;\r\n\tvar height_half = height / 2;\r\n\r\n\tvar gridX = this.widthSegments;\r\n\tvar gridZ = this.heightSegments;\r\n\r\n\tvar gridX1 = gridX + 1;\r\n\tvar gridZ1 = gridZ + 1;\r\n\r\n\tvar segment_width = this.width / gridX;\r\n\tvar segment_height = this.height / gridZ;\r\n\r\n\tvar normal = new THREE.Vector3( 0, 0, 1 );\r\n\r\n\tfor ( iz = 0; iz < gridZ1; iz ++ ) {\r\n\r\n\t\tfor ( ix = 0; ix < gridX1; ix ++ ) {\r\n\r\n\t\t\tvar x = ix * segment_width - width_half;\r\n\t\t\tvar y = iz * segment_height - height_half;\r\n\r\n\t\t\tthis.vertices.push( new THREE.Vector3( x, - y, 0 ) );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfor ( iz = 0; iz < gridZ; iz ++ ) {\r\n\r\n\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\r\n\r\n\t\t\tvar a = ix + gridX1 * iz;\r\n\t\t\tvar b = ix + gridX1 * ( iz + 1 );\r\n\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iz + 1 );\r\n\t\t\tvar d = ( ix + 1 ) + gridX1 * iz;\r\n\r\n\t\t\tvar face = new THREE.Face4( a, b, c, d );\r\n\t\t\tface.normal.copy( normal );\r\n\t\t\tface.vertexNormals.push( normal.clone(), normal.clone(), normal.clone(), normal.clone() );\r\n\r\n\t\t\tthis.faces.push( face );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [\r\n\t\t\t\tnew THREE.Vector2( ix / gridX, 1 - iz / gridZ ),\r\n\t\t\t\tnew THREE.Vector2( ix / gridX, 1 - ( iz + 1 ) / gridZ ),\r\n\t\t\t\tnew THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iz + 1 ) / gridZ ),\r\n\t\t\t\tnew THREE.Vector2( ( ix + 1 ) / gridX, 1 - iz / gridZ )\r\n\t\t\t] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.computeCentroids();\r\n\r\n};\r\n\r\nTHREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.radius = radius || 50;\r\n\r\n\tthis.widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\r\n\tthis.heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\r\n\r\n\tphiStart = phiStart !== undefined ? phiStart : 0;\r\n\tphiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\r\n\r\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\r\n\r\n\tvar x, y, vertices = [], uvs = [];\r\n\r\n\tfor ( y = 0; y <= this.heightSegments; y ++ ) {\r\n\r\n\t\tvar verticesRow = [];\r\n\t\tvar uvsRow = [];\r\n\r\n\t\tfor ( x = 0; x <= this.widthSegments; x ++ ) {\r\n\r\n\t\t\tvar u = x / this.widthSegments;\r\n\t\t\tvar v = y / this.heightSegments;\r\n\r\n\t\t\tvar vertex = new THREE.Vector3();\r\n\t\t\tvertex.x = - this.radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\r\n\t\t\tvertex.y = this.radius * Math.cos( thetaStart + v * thetaLength );\r\n\t\t\tvertex.z = this.radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\r\n\r\n\t\t\tthis.vertices.push( vertex );\r\n\r\n\t\t\tverticesRow.push( this.vertices.length - 1 );\r\n\t\t\tuvsRow.push( new THREE.Vector2( u, 1 - v ) );\r\n\r\n\t\t}\r\n\r\n\t\tvertices.push( verticesRow );\r\n\t\tuvs.push( uvsRow );\r\n\r\n\t}\r\n\r\n\tfor ( y = 0; y < this.heightSegments; y ++ ) {\r\n\r\n\t\tfor ( x = 0; x < this.widthSegments; x ++ ) {\r\n\r\n\t\t\tvar v1 = vertices[ y ][ x + 1 ];\r\n\t\t\tvar v2 = vertices[ y ][ x ];\r\n\t\t\tvar v3 = vertices[ y + 1 ][ x ];\r\n\t\t\tvar v4 = vertices[ y + 1 ][ x + 1 ];\r\n\r\n\t\t\tvar n1 = this.vertices[ v1 ].clone().normalize();\r\n\t\t\tvar n2 = this.vertices[ v2 ].clone().normalize();\r\n\t\t\tvar n3 = this.vertices[ v3 ].clone().normalize();\r\n\t\t\tvar n4 = this.vertices[ v4 ].clone().normalize();\r\n\r\n\t\t\tvar uv1 = uvs[ y ][ x + 1 ].clone();\r\n\t\t\tvar uv2 = uvs[ y ][ x ].clone();\r\n\t\t\tvar uv3 = uvs[ y + 1 ][ x ].clone();\r\n\t\t\tvar uv4 = uvs[ y + 1 ][ x + 1 ].clone();\r\n\r\n\t\t\tif ( Math.abs( this.vertices[ v1 ].y ) === this.radius ) {\r\n\r\n\t\t\t\tthis.faces.push( new THREE.Face3( v1, v3, v4, [ n1, n3, n4 ] ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv3, uv4 ] );\r\n\r\n\t\t\t} else if ( Math.abs( this.vertices[ v3 ].y ) === this.radius ) {\r\n\r\n\t\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.faces.push( new THREE.Face4( v1, v2, v3, v4, [ n1, n2, n3, n4 ] ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3, uv4 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.computeCentroids();\r\n\tthis.computeFaceNormals();\r\n\r\n    this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\r\n};\r\n\r\nTHREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * For creating 3D text geometry in three.js\r\n *\r\n * Text = 3D Text\r\n *\r\n * parameters = {\r\n *  size: \t\t\t<float>, \t// size of the text\r\n *  height: \t\t<float>, \t// thickness to extrude text\r\n *  curveSegments: \t<int>,\t\t// number of points on the curves\r\n *\r\n *  font: \t\t\t<string>,\t\t// font name\r\n *  weight: \t\t<string>,\t\t// font weight (normal, bold)\r\n *  style: \t\t\t<string>,\t\t// font style  (normal, italics)\r\n *\r\n *  bevelEnabled:\t<bool>,\t\t\t// turn on bevel\r\n *  bevelThickness: <float>, \t\t// how deep into text bevel goes\r\n *  bevelSize:\t\t<float>, \t\t// how far from text outline is bevel\r\n *  }\r\n *\r\n */\r\n\r\n/*\tUsage Examples\r\n\r\n\t// TextGeometry wrapper\r\n\r\n\tvar text3d = new TextGeometry( text, options );\r\n\r\n\t// Complete manner\r\n\r\n\tvar textShapes = THREE.FontUtils.generateShapes( text, options );\r\n\tvar text3d = new ExtrudeGeometry( textShapes, options );\r\n\r\n*/\r\n\r\n\r\nTHREE.TextGeometry = function ( text, parameters ) {\r\n\r\n\tvar textShapes = THREE.FontUtils.generateShapes( text, parameters );\r\n\r\n\t// translate parameters to ExtrudeGeometry API\r\n\r\n\tparameters.amount = parameters.height !== undefined ? parameters.height : 50;\r\n\r\n\t// defaults\r\n\r\n\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\r\n\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\r\n\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\r\n\r\n\tTHREE.ExtrudeGeometry.call( this, textShapes, parameters );\r\n\r\n};\r\n\r\nTHREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );\r\n/**\r\n * @author oosmoxiecode\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888\r\n */\r\n\r\nTHREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tvar scope = this;\r\n\r\n\tthis.radius = radius || 100;\r\n\tthis.tube = tube || 40;\r\n\tthis.radialSegments = radialSegments || 8;\r\n\tthis.tubularSegments = tubularSegments || 6;\r\n\tthis.arc = arc || Math.PI * 2;\r\n\r\n\tvar center = new THREE.Vector3(), uvs = [], normals = [];\r\n\r\n\tfor ( var j = 0; j <= this.radialSegments; j ++ ) {\r\n\r\n\t\tfor ( var i = 0; i <= this.tubularSegments; i ++ ) {\r\n\r\n\t\t\tvar u = i / this.tubularSegments * this.arc;\r\n\t\t\tvar v = j / this.radialSegments * Math.PI * 2;\r\n\r\n\t\t\tcenter.x = this.radius * Math.cos( u );\r\n\t\t\tcenter.y = this.radius * Math.sin( u );\r\n\r\n\t\t\tvar vertex = new THREE.Vector3();\r\n\t\t\tvertex.x = ( this.radius + this.tube * Math.cos( v ) ) * Math.cos( u );\r\n\t\t\tvertex.y = ( this.radius + this.tube * Math.cos( v ) ) * Math.sin( u );\r\n\t\t\tvertex.z = this.tube * Math.sin( v );\r\n\r\n\t\t\tthis.vertices.push( vertex );\r\n\r\n\t\t\tuvs.push( new THREE.Vector2( i / this.tubularSegments, j / this.radialSegments ) );\r\n\t\t\tnormals.push( vertex.clone().sub( center ).normalize() );\r\n\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tfor ( var j = 1; j <= this.radialSegments; j ++ ) {\r\n\r\n\t\tfor ( var i = 1; i <= this.tubularSegments; i ++ ) {\r\n\r\n\t\t\tvar a = ( this.tubularSegments + 1 ) * j + i - 1;\r\n\t\t\tvar b = ( this.tubularSegments + 1 ) * ( j - 1 ) + i - 1;\r\n\t\t\tvar c = ( this.tubularSegments + 1 ) * ( j - 1 ) + i;\r\n\t\t\tvar d = ( this.tubularSegments + 1 ) * j + i;\r\n\r\n\t\t\tvar face = new THREE.Face4( a, b, c, d, [ normals[ a ], normals[ b ], normals[ c ], normals[ d ] ] );\r\n\t\t\tface.normal.add( normals[ a ] );\r\n\t\t\tface.normal.add( normals[ b ] );\r\n\t\t\tface.normal.add( normals[ c ] );\r\n\t\t\tface.normal.add( normals[ d ] );\r\n\t\t\tface.normal.normalize();\r\n\r\n\t\t\tthis.faces.push( face );\r\n\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.computeCentroids();\r\n\r\n};\r\n\r\nTHREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n/**\r\n * @author oosmoxiecode\r\n * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\r\n */\r\n\r\nTHREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tvar scope = this;\r\n\r\n\tthis.radius = radius || 100;\r\n\tthis.tube = tube || 40;\r\n\tthis.radialSegments = radialSegments || 64;\r\n\tthis.tubularSegments = tubularSegments || 8;\r\n\tthis.p = p || 2;\r\n\tthis.q = q || 3;\r\n\tthis.heightScale = heightScale || 1;\r\n\tthis.grid = new Array( this.radialSegments );\r\n\r\n\tvar tang = new THREE.Vector3();\r\n\tvar n = new THREE.Vector3();\r\n\tvar bitan = new THREE.Vector3();\r\n\r\n\tfor ( var i = 0; i < this.radialSegments; ++ i ) {\r\n\r\n\t\tthis.grid[ i ] = new Array( this.tubularSegments );\r\n\r\n\t\tfor ( var j = 0; j < this.tubularSegments; ++ j ) {\r\n\r\n\t\t\tvar u = i / this.radialSegments * 2 * this.p * Math.PI;\r\n\t\t\tvar v = j / this.tubularSegments * 2 * Math.PI;\r\n\t\t\tvar p1 = getPos( u, v, this.q, this.p, this.radius, this.heightScale );\r\n\t\t\tvar p2 = getPos( u + 0.01, v, this.q, this.p, this.radius, this.heightScale );\r\n\t\t\tvar cx, cy;\r\n\r\n\t\t\ttang.subVectors( p2, p1 );\r\n\t\t\tn.addVectors( p2, p1 );\r\n\r\n\t\t\tbitan.crossVectors( tang, n );\r\n\t\t\tn.crossVectors( bitan, tang );\r\n\t\t\tbitan.normalize();\r\n\t\t\tn.normalize();\r\n\r\n\t\t\tcx = - this.tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\r\n\t\t\tcy = this.tube * Math.sin( v );\r\n\r\n\t\t\tp1.x += cx * n.x + cy * bitan.x;\r\n\t\t\tp1.y += cx * n.y + cy * bitan.y;\r\n\t\t\tp1.z += cx * n.z + cy * bitan.z;\r\n\r\n\t\t\tthis.grid[ i ][ j ] = vert( p1.x, p1.y, p1.z );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfor ( var i = 0; i < this.radialSegments; ++ i ) {\r\n\r\n\t\tfor ( var j = 0; j < this.tubularSegments; ++ j ) {\r\n\r\n\t\t\tvar ip = ( i + 1 ) % this.radialSegments;\r\n\t\t\tvar jp = ( j + 1 ) % this.tubularSegments;\r\n\r\n\t\t\tvar a = this.grid[ i ][ j ];\r\n\t\t\tvar b = this.grid[ ip ][ j ];\r\n\t\t\tvar c = this.grid[ ip ][ jp ];\r\n\t\t\tvar d = this.grid[ i ][ jp ];\r\n\r\n\t\t\tvar uva = new THREE.Vector2( i / this.radialSegments, j / this.tubularSegments );\r\n\t\t\tvar uvb = new THREE.Vector2( ( i + 1 ) / this.radialSegments, j / this.tubularSegments );\r\n\t\t\tvar uvc = new THREE.Vector2( ( i + 1 ) / this.radialSegments, ( j + 1 ) / this.tubularSegments );\r\n\t\t\tvar uvd = new THREE.Vector2( i / this.radialSegments, ( j + 1 ) / this.tubularSegments );\r\n\r\n\t\t\tthis.faces.push( new THREE.Face4( a, b, c, d ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uva,uvb,uvc, uvd ] );\r\n\r\n\t\t}\r\n\t}\r\n\r\n\tthis.computeCentroids();\r\n\tthis.computeFaceNormals();\r\n\tthis.computeVertexNormals();\r\n\r\n\tfunction vert( x, y, z ) {\r\n\r\n\t\treturn scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;\r\n\r\n\t}\r\n\r\n\tfunction getPos( u, v, in_q, in_p, radius, heightScale ) {\r\n\r\n\t\tvar cu = Math.cos( u );\r\n\t\tvar cv = Math.cos( v );\r\n\t\tvar su = Math.sin( u );\r\n\t\tvar quOverP = in_q / in_p * u;\r\n\t\tvar cs = Math.cos( quOverP );\r\n\r\n\t\tvar tx = radius * ( 2 + cs ) * 0.5 * cu;\r\n\t\tvar ty = radius * ( 2 + cs ) * su * 0.5;\r\n\t\tvar tz = heightScale * radius * Math.sin( quOverP ) * 0.5;\r\n\r\n\t\treturn new THREE.Vector3( tx, ty, tz );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n/**\r\n * @author WestLangley / https://github.com/WestLangley\r\n * @author zz85 / https://github.com/zz85\r\n * @author miningold / https://github.com/miningold\r\n *\r\n * Modified from the TorusKnotGeometry by @oosmoxiecode\r\n *\r\n * Creates a tube which extrudes along a 3d spline\r\n *\r\n * Uses parallel transport frames as described in\r\n * http://www.cs.indiana.edu/pub/techreports/TR425.pdf\r\n */\r\n\r\nTHREE.TubeGeometry = function( path, segments, radius, radiusSegments, closed, debug ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.path = path;\r\n\tthis.segments = segments || 64;\r\n\tthis.radius = radius || 1;\r\n\tthis.radiusSegments = radiusSegments || 8;\r\n\tthis.closed = closed || false;\r\n\r\n\tif ( debug ) this.debug = new THREE.Object3D();\r\n\r\n\tthis.grid = [];\r\n\r\n\tvar scope = this,\r\n\r\n\t\ttangent,\r\n\t\tnormal,\r\n\t\tbinormal,\r\n\r\n\t\tnumpoints = this.segments + 1,\r\n\r\n\t\tx, y, z,\r\n\t\ttx, ty, tz,\r\n\t\tu, v,\r\n\r\n\t\tcx, cy,\r\n\t\tpos, pos2 = new THREE.Vector3(),\r\n\t\ti, j,\r\n\t\tip, jp,\r\n\t\ta, b, c, d,\r\n\t\tuva, uvb, uvc, uvd;\r\n\r\n\tvar frames = new THREE.TubeGeometry.FrenetFrames( this.path, this.segments, this.closed ),\r\n\t\ttangents = frames.tangents,\r\n\t\tnormals = frames.normals,\r\n\t\tbinormals = frames.binormals;\r\n\r\n\t// proxy internals\r\n\tthis.tangents = tangents;\r\n\tthis.normals = normals;\r\n\tthis.binormals = binormals;\r\n\r\n\tfunction vert( x, y, z ) {\r\n\r\n\t\treturn scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;\r\n\r\n\t}\r\n\r\n\r\n\t// consruct the grid\r\n\r\n\tfor ( i = 0; i < numpoints; i++ ) {\r\n\r\n\t\tthis.grid[ i ] = [];\r\n\r\n\t\tu = i / ( numpoints - 1 );\r\n\r\n\t\tpos = path.getPointAt( u );\r\n\r\n\t\ttangent = tangents[ i ];\r\n\t\tnormal = normals[ i ];\r\n\t\tbinormal = binormals[ i ];\r\n\r\n\t\tif ( this.debug ) {\r\n\r\n\t\t\tthis.debug.add( new THREE.ArrowHelper(tangent, pos, radius, 0x0000ff ) );\r\n\t\t\tthis.debug.add( new THREE.ArrowHelper(normal, pos, radius, 0xff0000 ) );\r\n\t\t\tthis.debug.add( new THREE.ArrowHelper(binormal, pos, radius, 0x00ff00 ) );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( j = 0; j < this.radiusSegments; j++ ) {\r\n\r\n\t\t\tv = j / this.radiusSegments * 2 * Math.PI;\r\n\r\n\t\t\tcx = -this.radius * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\r\n\t\t\tcy = this.radius * Math.sin( v );\r\n\r\n\t\t\tpos2.copy( pos );\r\n\t\t\tpos2.x += cx * normal.x + cy * binormal.x;\r\n\t\t\tpos2.y += cx * normal.y + cy * binormal.y;\r\n\t\t\tpos2.z += cx * normal.z + cy * binormal.z;\r\n\r\n\t\t\tthis.grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );\r\n\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t// construct the mesh\r\n\r\n\tfor ( i = 0; i < this.segments; i++ ) {\r\n\r\n\t\tfor ( j = 0; j < this.radiusSegments; j++ ) {\r\n\r\n\t\t\tip = ( this.closed ) ? (i + 1) % this.segments : i + 1;\r\n\t\t\tjp = (j + 1) % this.radiusSegments;\r\n\r\n\t\t\ta = this.grid[ i ][ j ];\t\t// *** NOT NECESSARILY PLANAR ! ***\r\n\t\t\tb = this.grid[ ip ][ j ];\r\n\t\t\tc = this.grid[ ip ][ jp ];\r\n\t\t\td = this.grid[ i ][ jp ];\r\n\r\n\t\t\tuva = new THREE.Vector2( i / this.segments, j / this.radiusSegments );\r\n\t\t\tuvb = new THREE.Vector2( ( i + 1 ) / this.segments, j / this.radiusSegments );\r\n\t\t\tuvc = new THREE.Vector2( ( i + 1 ) / this.segments, ( j + 1 ) / this.radiusSegments );\r\n\t\t\tuvd = new THREE.Vector2( i / this.segments, ( j + 1 ) / this.radiusSegments );\r\n\r\n\t\t\tthis.faces.push( new THREE.Face4( a, b, c, d ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uva, uvb, uvc, uvd ] );\r\n\r\n\t\t}\r\n\t}\r\n\r\n\tthis.computeCentroids();\r\n\tthis.computeFaceNormals();\r\n\tthis.computeVertexNormals();\r\n\r\n};\r\n\r\nTHREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\r\n\r\n// For computing of Frenet frames, exposing the tangents, normals and binormals the spline\r\nTHREE.TubeGeometry.FrenetFrames = function(path, segments, closed) {\r\n\r\n\tvar\ttangent = new THREE.Vector3(),\r\n\t\tnormal = new THREE.Vector3(),\r\n\t\tbinormal = new THREE.Vector3(),\r\n\r\n\t\ttangents = [],\r\n\t\tnormals = [],\r\n\t\tbinormals = [],\r\n\r\n\t\tvec = new THREE.Vector3(),\r\n\t\tmat = new THREE.Matrix4(),\r\n\r\n\t\tnumpoints = segments + 1,\r\n\t\ttheta,\r\n\t\tepsilon = 0.0001,\r\n\t\tsmallest,\r\n\r\n\t\ttx, ty, tz,\r\n\t\ti, u, v;\r\n\r\n\r\n\t// expose internals\r\n\tthis.tangents = tangents;\r\n\tthis.normals = normals;\r\n\tthis.binormals = binormals;\r\n\r\n\t// compute the tangent vectors for each segment on the path\r\n\r\n\tfor ( i = 0; i < numpoints; i++ ) {\r\n\r\n\t\tu = i / ( numpoints - 1 );\r\n\r\n\t\ttangents[ i ] = path.getTangentAt( u );\r\n\t\ttangents[ i ].normalize();\r\n\r\n\t}\r\n\r\n\tinitialNormal3();\r\n\r\n\tfunction initialNormal1(lastBinormal) {\r\n\t\t// fixed start binormal. Has dangers of 0 vectors\r\n\t\tnormals[ 0 ] = new THREE.Vector3();\r\n\t\tbinormals[ 0 ] = new THREE.Vector3();\r\n\t\tif (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );\r\n\t\tnormals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();\r\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\r\n\t}\r\n\r\n\tfunction initialNormal2() {\r\n\r\n\t\t// This uses the Frenet-Serret formula for deriving binormal\r\n\t\tvar t2 = path.getTangentAt( epsilon );\r\n\r\n\t\tnormals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();\r\n\t\tbinormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );\r\n\r\n\t\tnormals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent\r\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\r\n\r\n\t}\r\n\r\n\tfunction initialNormal3() {\r\n\t\t// select an initial normal vector perpenicular to the first tangent vector,\r\n\t\t// and in the direction of the smallest tangent xyz component\r\n\r\n\t\tnormals[ 0 ] = new THREE.Vector3();\r\n\t\tbinormals[ 0 ] = new THREE.Vector3();\r\n\t\tsmallest = Number.MAX_VALUE;\r\n\t\ttx = Math.abs( tangents[ 0 ].x );\r\n\t\tty = Math.abs( tangents[ 0 ].y );\r\n\t\ttz = Math.abs( tangents[ 0 ].z );\r\n\r\n\t\tif ( tx <= smallest ) {\r\n\t\t\tsmallest = tx;\r\n\t\t\tnormal.set( 1, 0, 0 );\r\n\t\t}\r\n\r\n\t\tif ( ty <= smallest ) {\r\n\t\t\tsmallest = ty;\r\n\t\t\tnormal.set( 0, 1, 0 );\r\n\t\t}\r\n\r\n\t\tif ( tz <= smallest ) {\r\n\t\t\tnormal.set( 0, 0, 1 );\r\n\t\t}\r\n\r\n\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\r\n\r\n\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\r\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\r\n\t}\r\n\r\n\r\n\t// compute the slowly-varying normal and binormal vectors for each segment on the path\r\n\r\n\tfor ( i = 1; i < numpoints; i++ ) {\r\n\r\n\t\tnormals[ i ] = normals[ i-1 ].clone();\r\n\r\n\t\tbinormals[ i ] = binormals[ i-1 ].clone();\r\n\r\n\t\tvec.crossVectors( tangents[ i-1 ], tangents[ i ] );\r\n\r\n\t\tif ( vec.length() > epsilon ) {\r\n\r\n\t\t\tvec.normalize();\r\n\r\n\t\t\ttheta = Math.acos( tangents[ i-1 ].dot( tangents[ i ] ) );\r\n\r\n\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\r\n\r\n\t\t}\r\n\r\n\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\r\n\r\n\t}\r\n\r\n\r\n\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\r\n\r\n\tif ( closed ) {\r\n\r\n\t\ttheta = Math.acos( normals[ 0 ].dot( normals[ numpoints-1 ] ) );\r\n\t\ttheta /= ( numpoints - 1 );\r\n\r\n\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints-1 ] ) ) > 0 ) {\r\n\r\n\t\t\ttheta = -theta;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( i = 1; i < numpoints; i++ ) {\r\n\r\n\t\t\t// twist a little...\r\n\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\r\n\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n};\r\n/**\r\n * @author clockworkgeek / https://github.com/clockworkgeek\r\n * @author timothypratley / https://github.com/timothypratley\r\n */\r\n\r\nTHREE.PolyhedronGeometry = function ( vertices, faces, radius, detail ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tradius = radius || 1;\r\n\tdetail = detail || 0;\r\n\r\n\tvar that = this;\r\n\r\n\tfor ( var i = 0, l = vertices.length; i < l; i ++ ) {\r\n\r\n\t\tprepare( new THREE.Vector3( vertices[ i ][ 0 ], vertices[ i ][ 1 ], vertices[ i ][ 2 ] ) );\r\n\r\n\t}\r\n\r\n\tvar midpoints = [], p = this.vertices;\r\n\r\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\tmake( p[ faces[ i ][ 0 ] ], p[ faces[ i ][ 1 ] ], p[ faces[ i ][ 2 ] ], detail );\r\n\r\n\t}\r\n\r\n\tthis.mergeVertices();\r\n\r\n\t// Apply radius\r\n\r\n\tfor ( var i = 0, l = this.vertices.length; i < l; i ++ ) {\r\n\r\n\t\tthis.vertices[ i ].multiplyScalar( radius );\r\n\r\n\t}\r\n\r\n\r\n\t// Project vector onto sphere's surface\r\n\r\n\tfunction prepare( vector ) {\r\n\r\n\t\tvar vertex = vector.normalize().clone();\r\n\t\tvertex.index = that.vertices.push( vertex ) - 1;\r\n\r\n\t\t// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.\r\n\r\n\t\tvar u = azimuth( vector ) / 2 / Math.PI + 0.5;\r\n\t\tvar v = inclination( vector ) / Math.PI + 0.5;\r\n\t\tvertex.uv = new THREE.Vector2( u, 1 - v );\r\n\r\n\t\treturn vertex;\r\n\r\n\t}\r\n\r\n\r\n\t// Approximate a curved face with recursively sub-divided triangles.\r\n\r\n\tfunction make( v1, v2, v3, detail ) {\r\n\r\n\t\tif ( detail < 1 ) {\r\n\r\n\t\t\tvar face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );\r\n\t\t\tface.centroid.add( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );\r\n\t\t\tface.normal = face.centroid.clone().normalize();\r\n\t\t\tthat.faces.push( face );\r\n\r\n\t\t\tvar azi = azimuth( face.centroid );\r\n\t\t\tthat.faceVertexUvs[ 0 ].push( [\r\n\t\t\t\tcorrectUV( v1.uv, v1, azi ),\r\n\t\t\t\tcorrectUV( v2.uv, v2, azi ),\r\n\t\t\t\tcorrectUV( v3.uv, v3, azi )\r\n\t\t\t] );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tdetail -= 1;\r\n\r\n\t\t\t// split triangle into 4 smaller triangles\r\n\r\n\t\t\tmake( v1, midpoint( v1, v2 ), midpoint( v1, v3 ), detail ); // top quadrant\r\n\t\t\tmake( midpoint( v1, v2 ), v2, midpoint( v2, v3 ), detail ); // left quadrant\r\n\t\t\tmake( midpoint( v1, v3 ), midpoint( v2, v3 ), v3, detail ); // right quadrant\r\n\t\t\tmake( midpoint( v1, v2 ), midpoint( v2, v3 ), midpoint( v1, v3 ), detail ); // center quadrant\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction midpoint( v1, v2 ) {\r\n\r\n\t\tif ( !midpoints[ v1.index ] ) midpoints[ v1.index ] = [];\r\n\t\tif ( !midpoints[ v2.index ] ) midpoints[ v2.index ] = [];\r\n\r\n\t\tvar mid = midpoints[ v1.index ][ v2.index ];\r\n\r\n\t\tif ( mid === undefined ) {\r\n\r\n\t\t\t// generate mean point and project to surface with prepare()\r\n\r\n\t\t\tmidpoints[ v1.index ][ v2.index ] = midpoints[ v2.index ][ v1.index ] = mid = prepare(\r\n\t\t\t\tnew THREE.Vector3().addVectors( v1, v2 ).divideScalar( 2 )\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\treturn mid;\r\n\r\n\t}\r\n\r\n\r\n\t// Angle around the Y axis, counter-clockwise when looking from above.\r\n\r\n\tfunction azimuth( vector ) {\r\n\r\n\t\treturn Math.atan2( vector.z, -vector.x );\r\n\r\n\t}\r\n\r\n\r\n\t// Angle above the XZ plane.\r\n\r\n\tfunction inclination( vector ) {\r\n\r\n\t\treturn Math.atan2( -vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\r\n\r\n\t}\r\n\r\n\r\n\t// Texture fixing helper. Spheres have some odd behaviours.\r\n\r\n\tfunction correctUV( uv, vector, azimuth ) {\r\n\r\n\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );\r\n\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );\r\n\t\treturn uv;\r\n\r\n\t}\r\n\r\n\tthis.computeCentroids();\r\n\r\n    this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\r\n};\r\n\r\nTHREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n/**\r\n * @author timothypratley / https://github.com/timothypratley\r\n */\r\n\r\nTHREE.IcosahedronGeometry = function ( radius, detail ) {\r\n\r\n\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\r\n\r\n\tvar vertices = [\r\n\t\t[ -1,  t,  0 ], [  1, t, 0 ], [ -1, -t,  0 ], [  1, -t,  0 ],\r\n\t\t[  0, -1,  t ], [  0, 1, t ], [  0, -1, -t ], [  0,  1, -t ],\r\n\t\t[  t,  0, -1 ], [  t, 0, 1 ], [ -t,  0, -1 ], [ -t,  0,  1 ]\r\n\t];\r\n\r\n\tvar faces = [\r\n\t\t[ 0, 11,  5 ], [ 0,  5,  1 ], [  0,  1,  7 ], [  0,  7, 10 ], [  0, 10, 11 ],\r\n\t\t[ 1,  5,  9 ], [ 5, 11,  4 ], [ 11, 10,  2 ], [ 10,  7,  6 ], [  7,  1,  8 ],\r\n\t\t[ 3,  9,  4 ], [ 3,  4,  2 ], [  3,  2,  6 ], [  3,  6,  8 ], [  3,  8,  9 ],\r\n\t\t[ 4,  9,  5 ], [ 2,  4, 11 ], [  6,  2, 10 ], [  8,  6,  7 ], [  9,  8,  1 ]\r\n\t];\r\n\r\n\tTHREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );\r\n\r\n};\r\n\r\nTHREE.IcosahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n/**\r\n * @author timothypratley / https://github.com/timothypratley\r\n */\r\n\r\nTHREE.OctahedronGeometry = function ( radius, detail ) {\r\n\r\n\tvar vertices = [\r\n\t\t[ 1, 0, 0 ], [ -1, 0, 0 ], [ 0, 1, 0 ], [ 0, -1, 0 ], [ 0, 0, 1 ], [ 0, 0, -1 ]\r\n\t];\r\n\r\n\tvar faces = [\r\n\t\t[ 0, 2, 4 ], [ 0, 4, 3 ], [ 0, 3, 5 ], [ 0, 5, 2 ], [ 1, 2, 5 ], [ 1, 5, 3 ], [ 1, 3, 4 ], [ 1, 4, 2 ]\r\n\t];\r\n\r\n\tTHREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );\r\n};\r\n\r\nTHREE.OctahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n/**\r\n * @author timothypratley / https://github.com/timothypratley\r\n */\r\n\r\nTHREE.TetrahedronGeometry = function ( radius, detail ) {\r\n\r\n\tvar vertices = [\r\n\t\t[ 1,  1,  1 ], [ -1, -1, 1 ], [ -1, 1, -1 ], [ 1, -1, -1 ]\r\n\t];\r\n\r\n\tvar faces = [\r\n\t\t[ 2, 1, 0 ], [ 0, 3, 2 ], [ 1, 3, 0 ], [ 2, 3, 1 ]\r\n\t];\r\n\r\n\tTHREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );\r\n\r\n};\r\n\r\nTHREE.TetrahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n/**\r\n * @author zz85 / https://github.com/zz85\r\n * Parametric Surfaces Geometry\r\n * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\r\n *\r\n * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements, useTris );\r\n *\r\n */\r\n\r\nTHREE.ParametricGeometry = function ( func, slices, stacks, useTris ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tvar verts = this.vertices;\r\n\tvar faces = this.faces;\r\n\tvar uvs = this.faceVertexUvs[ 0 ];\r\n\r\n\tuseTris = (useTris === undefined) ? false : useTris;\r\n\r\n\tvar i, il, j, p;\r\n\tvar u, v;\r\n\r\n\tvar stackCount = stacks + 1;\r\n\tvar sliceCount = slices + 1;\r\n\r\n\tfor ( i = 0; i <= stacks; i ++ ) {\r\n\r\n\t\tv = i / stacks;\r\n\r\n\t\tfor ( j = 0; j <= slices; j ++ ) {\r\n\r\n\t\t\tu = j / slices;\r\n\r\n\t\t\tp = func( u, v );\r\n\t\t\tverts.push( p );\r\n\r\n\t\t}\r\n\t}\r\n\r\n\tvar a, b, c, d;\r\n\tvar uva, uvb, uvc, uvd;\r\n\r\n\tfor ( i = 0; i < stacks; i ++ ) {\r\n\r\n\t\tfor ( j = 0; j < slices; j ++ ) {\r\n\r\n\t\t\ta = i * sliceCount + j;\r\n\t\t\tb = i * sliceCount + j + 1;\r\n\t\t\tc = (i + 1) * sliceCount + j;\r\n\t\t\td = (i + 1) * sliceCount + j + 1;\r\n\r\n\t\t\tuva = new THREE.Vector2( j / slices, i / stacks );\r\n\t\t\tuvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );\r\n\t\t\tuvc = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );\r\n\t\t\tuvd = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );\r\n\r\n\t\t\tif ( useTris ) {\r\n\r\n\t\t\t\tfaces.push( new THREE.Face3( a, b, c ) );\r\n\t\t\t\tfaces.push( new THREE.Face3( b, d, c ) );\r\n\r\n\t\t\t\tuvs.push( [ uva, uvb, uvc ] );\r\n\t\t\t\tuvs.push( [ uvb, uvd, uvc ] );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfaces.push( new THREE.Face4( a, b, d, c ) );\r\n\t\t\t\tuvs.push( [ uva, uvb, uvd, uvc ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// console.log(this);\r\n\r\n\t// magic bullet\r\n\t// var diff = this.mergeVertices();\r\n\t// console.log('removed ', diff, ' vertices by merging');\r\n\r\n\tthis.computeCentroids();\r\n\tthis.computeFaceNormals();\r\n\tthis.computeVertexNormals();\r\n\r\n};\r\n\r\nTHREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n/**\r\n * @author qiao / https://github.com/qiao\r\n * @fileoverview This is a convex hull generator using the incremental method. \r\n * The complexity is O(n^2) where n is the number of vertices.\r\n * O(nlogn) algorithms do exist, but they are much more complicated.\r\n *\r\n * Benchmark: \r\n *\r\n *  Platform: CPU: P7350 @2.00GHz Engine: V8\r\n *\r\n *  Num Vertices\tTime(ms)\r\n *\r\n *     10           1\r\n *     20           3\r\n *     30           19\r\n *     40           48\r\n *     50           107\r\n */\r\n\r\nTHREE.ConvexGeometry = function( vertices ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tvar faces = [ [ 0, 1, 2 ], [ 0, 2, 1 ] ]; \r\n\r\n\tfor ( var i = 3; i < vertices.length; i++ ) {\r\n\r\n\t\taddPoint( i );\r\n\r\n\t}\r\n\r\n\r\n\tfunction addPoint( vertexId ) {\r\n\r\n\t\tvar vertex = vertices[ vertexId ].clone();\r\n\r\n\t\tvar mag = vertex.length();\r\n\t\tvertex.x += mag * randomOffset();\r\n\t\tvertex.y += mag * randomOffset();\r\n\t\tvertex.z += mag * randomOffset();\r\n\r\n\t\tvar hole = [];\r\n\r\n\t\tfor ( var f = 0; f < faces.length; ) {\r\n\r\n\t\t\tvar face = faces[ f ];\r\n\r\n\t\t\t// for each face, if the vertex can see it,\r\n\t\t\t// then we try to add the face's edges into the hole.\r\n\t\t\tif ( visible( face, vertex ) ) {\r\n\r\n\t\t\t\tfor ( var e = 0; e < 3; e++ ) {\r\n\r\n\t\t\t\t\tvar edge = [ face[ e ], face[ ( e + 1 ) % 3 ] ];\r\n\t\t\t\t\tvar boundary = true;\r\n\r\n\t\t\t\t\t// remove duplicated edges.\r\n\t\t\t\t\tfor ( var h = 0; h < hole.length; h++ ) {\r\n\r\n\t\t\t\t\t\tif ( equalEdge( hole[ h ], edge ) ) {\r\n\r\n\t\t\t\t\t\t\thole[ h ] = hole[ hole.length - 1 ];\r\n\t\t\t\t\t\t\thole.pop();\r\n\t\t\t\t\t\t\tboundary = false;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( boundary ) {\r\n\r\n\t\t\t\t\t\thole.push( edge );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// remove faces[ f ]\r\n\t\t\t\tfaces[ f ] = faces[ faces.length - 1 ];\r\n\t\t\t\tfaces.pop();\r\n\r\n\t\t\t} else { // not visible\r\n\r\n\t\t\t\tf++;\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// construct the new faces formed by the edges of the hole and the vertex\r\n\t\tfor ( var h = 0; h < hole.length; h++ ) {\r\n\r\n\t\t\tfaces.push( [ \r\n\t\t\t\thole[ h ][ 0 ],\r\n\t\t\t\thole[ h ][ 1 ],\r\n\t\t\t\tvertexId\r\n\t\t\t] );\r\n\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Whether the face is visible from the vertex\r\n\t */\r\n\tfunction visible( face, vertex ) {\r\n\r\n\t\tvar va = vertices[ face[ 0 ] ];\r\n\t\tvar vb = vertices[ face[ 1 ] ];\r\n\t\tvar vc = vertices[ face[ 2 ] ];\r\n\r\n\t\tvar n = normal( va, vb, vc );\r\n\r\n\t\t// distance from face to origin\r\n\t\tvar dist = n.dot( va );\r\n\r\n\t\treturn n.dot( vertex ) >= dist; \r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Face normal\r\n\t */\r\n\tfunction normal( va, vb, vc ) {\r\n\r\n\t\tvar cb = new THREE.Vector3();\r\n\t\tvar ab = new THREE.Vector3();\r\n\r\n\t\tcb.subVectors( vc, vb );\r\n\t\tab.subVectors( va, vb );\r\n\t\tcb.cross( ab );\r\n\r\n\t\tcb.normalize();\r\n\r\n\t\treturn cb;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Detect whether two edges are equal.\r\n\t * Note that when constructing the convex hull, two same edges can only\r\n\t * be of the negative direction.\r\n\t */\r\n\tfunction equalEdge( ea, eb ) {\r\n\r\n\t\treturn ea[ 0 ] === eb[ 1 ] && ea[ 1 ] === eb[ 0 ]; \r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Create a random offset between -1e-6 and 1e-6.\r\n\t */\r\n\tfunction randomOffset() {\r\n\r\n\t\treturn ( Math.random() - 0.5 ) * 2 * 1e-6;\r\n\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * XXX: Not sure if this is the correct approach. Need someone to review.\r\n\t */\r\n\tfunction vertexUv( vertex ) {\r\n\r\n\t\tvar mag = vertex.length();\r\n\t\treturn new THREE.Vector2( vertex.x / mag, vertex.y / mag );\r\n\r\n\t}\r\n\r\n\t// Push vertices into `this.vertices`, skipping those inside the hull\r\n\tvar id = 0;\r\n\tvar newId = new Array( vertices.length ); // map from old vertex id to new id\r\n\r\n\tfor ( var i = 0; i < faces.length; i++ ) {\r\n\r\n\t\t var face = faces[ i ];\r\n\r\n\t\t for ( var j = 0; j < 3; j++ ) {\r\n\r\n\t\t\t\tif ( newId[ face[ j ] ] === undefined ) {\r\n\r\n\t\t\t\t\t\tnewId[ face[ j ] ] = id++;\r\n\t\t\t\t\t\tthis.vertices.push( vertices[ face[ j ] ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tface[ j ] = newId[ face[ j ] ];\r\n\r\n\t\t }\r\n\r\n\t}\r\n\r\n\t// Convert faces into instances of THREE.Face3\r\n\tfor ( var i = 0; i < faces.length; i++ ) {\r\n\r\n\t\tthis.faces.push( new THREE.Face3( \r\n\t\t\t\tfaces[ i ][ 0 ],\r\n\t\t\t\tfaces[ i ][ 1 ],\r\n\t\t\t\tfaces[ i ][ 2 ]\r\n\t\t) );\r\n\r\n\t}\r\n\r\n\t// Compute UVs\r\n\tfor ( var i = 0; i < this.faces.length; i++ ) {\r\n\r\n\t\tvar face = this.faces[ i ];\r\n\r\n\t\tthis.faceVertexUvs[ 0 ].push( [\r\n\t\t\tvertexUv( this.vertices[ face.a ] ),\r\n\t\t\tvertexUv( this.vertices[ face.b ] ),\r\n\t\t\tvertexUv( this.vertices[ face.c ])\r\n\t\t] );\r\n\r\n\t}\r\n\r\n\r\n\tthis.computeCentroids();\r\n\tthis.computeFaceNormals();\r\n\tthis.computeVertexNormals();\r\n\r\n};\r\n\r\nTHREE.ConvexGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n/**\r\n * @author sroucheray / http://sroucheray.org/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.AxisHelper = function ( size ) {\r\n\r\n\tvar geometry = new THREE.Geometry();\r\n\r\n\tgeometry.vertices.push(\r\n\t\tnew THREE.Vector3(), new THREE.Vector3( size || 1, 0, 0 ),\r\n\t\tnew THREE.Vector3(), new THREE.Vector3( 0, size || 1, 0 ),\r\n\t\tnew THREE.Vector3(), new THREE.Vector3( 0, 0, size || 1 )\r\n\t);\r\n\r\n\tgeometry.colors.push(\r\n\t\tnew THREE.Color( 0xff0000 ), new THREE.Color( 0xffaa00 ),\r\n\t\tnew THREE.Color( 0x00ff00 ), new THREE.Color( 0xaaff00 ),\r\n\t\tnew THREE.Color( 0x0000ff ), new THREE.Color( 0x00aaff )\r\n\t);\r\n\r\n\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\r\n\r\n\tTHREE.Line.call( this, geometry, material, THREE.LinePieces );\r\n\r\n};\r\n\r\nTHREE.AxisHelper.prototype = Object.create( THREE.Line.prototype );\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author zz85 / https://github.com/zz85\r\n * @author bhouston / https://exocortex.com\r\n *\r\n * Creates an arrow for visualizing directions\r\n *\r\n * Parameters:\r\n *  dir - Vector3\r\n *  origin - Vector3\r\n *  length - Number\r\n *  hex - color in hex value\r\n */\r\n\r\nTHREE.ArrowHelper = function ( dir, origin, length, hex ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tif ( length === undefined ) length = 20;\r\n\tif ( hex === undefined ) hex = 0xffff00;\r\n\r\n\tvar lineGeometry = new THREE.Geometry();\r\n\tlineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ) );\r\n\tlineGeometry.vertices.push( new THREE.Vector3( 0, 1, 0 ) );\r\n\r\n\tthis.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: hex } ) );\r\n\tthis.add( this.line );\r\n\r\n\tvar coneGeometry = new THREE.CylinderGeometry( 0, 0.05, 0.25, 5, 1 );\r\n\r\n\tthis.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: hex } ) );\r\n\tthis.cone.position.set( 0, 1, 0 );\r\n\tthis.add( this.cone );\r\n\r\n\tif ( origin instanceof THREE.Vector3 ) this.position = origin;\r\n\r\n\tthis.setDirection( dir );\r\n\tthis.setLength( length );\r\n\r\n};\r\n\r\nTHREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.ArrowHelper.prototype.setDirection = function ( dir ) {\r\n\r\n    var d = THREE.ArrowHelper.__v1.copy( dir ).normalize();\r\n\r\n    if ( d.y > 0.999 ) {\r\n\r\n        this.rotation.set( 0, 0, 0 );\r\n \r\n    } else if ( d.y < - 0.999 ) {\r\n\r\n        this.rotation.set( Math.PI, 0, 0 );\r\n\r\n    } else {\r\n\r\n\t    var axis = THREE.ArrowHelper.__v2.set( d.z, 0, - d.x ).normalize();\r\n\t    var radians = Math.acos( d.y );\r\n\t    var quaternion = THREE.ArrowHelper.__q1.setFromAxisAngle( axis, radians );\r\n\r\n\t    this.rotation.setEulerFromQuaternion( quaternion, this.eulerOrder );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.ArrowHelper.prototype.setLength = function ( length ) {\r\n\r\n\tthis.scale.set( length, length, length );\r\n\r\n};\r\n\r\nTHREE.ArrowHelper.prototype.setColor = function ( hex ) {\r\n\r\n\tthis.line.material.color.setHex( hex );\r\n\tthis.cone.material.color.setHex( hex );\r\n\r\n};\r\n\r\nTHREE.ArrowHelper.__v1 = new THREE.Vector3();\r\nTHREE.ArrowHelper.__v2 = new THREE.Vector3();\r\nTHREE.ArrowHelper.__q1 = new THREE.Quaternion();\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n *\t- shows frustum, line of sight and up of the camera\r\n *\t- suitable for fast updates\r\n * \t- based on frustum visualization in lightgl.js shadowmap example\r\n *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\r\n */\r\n\r\nTHREE.CameraHelper = function ( camera ) {\r\n\r\n\tTHREE.Line.call( this );\r\n\r\n\tvar scope = this;\r\n\r\n\tthis.geometry = new THREE.Geometry();\r\n\tthis.material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );\r\n\tthis.type = THREE.LinePieces;\r\n\r\n\tthis.matrixWorld = camera.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tthis.pointMap = {};\r\n\r\n\t// colors\r\n\r\n\tvar hexFrustum = 0xffaa00;\r\n\tvar hexCone = 0xff0000;\r\n\tvar hexUp = 0x00aaff;\r\n\tvar hexTarget = 0xffffff;\r\n\tvar hexCross = 0x333333;\r\n\r\n\t// near\r\n\r\n\taddLine( \"n1\", \"n2\", hexFrustum );\r\n\taddLine( \"n2\", \"n4\", hexFrustum );\r\n\taddLine( \"n4\", \"n3\", hexFrustum );\r\n\taddLine( \"n3\", \"n1\", hexFrustum );\r\n\r\n\t// far\r\n\r\n\taddLine( \"f1\", \"f2\", hexFrustum );\r\n\taddLine( \"f2\", \"f4\", hexFrustum );\r\n\taddLine( \"f4\", \"f3\", hexFrustum );\r\n\taddLine( \"f3\", \"f1\", hexFrustum );\r\n\r\n\t// sides\r\n\r\n\taddLine( \"n1\", \"f1\", hexFrustum );\r\n\taddLine( \"n2\", \"f2\", hexFrustum );\r\n\taddLine( \"n3\", \"f3\", hexFrustum );\r\n\taddLine( \"n4\", \"f4\", hexFrustum );\r\n\r\n\t// cone\r\n\r\n\taddLine( \"p\", \"n1\", hexCone );\r\n\taddLine( \"p\", \"n2\", hexCone );\r\n\taddLine( \"p\", \"n3\", hexCone );\r\n\taddLine( \"p\", \"n4\", hexCone );\r\n\r\n\t// up\r\n\r\n\taddLine( \"u1\", \"u2\", hexUp );\r\n\taddLine( \"u2\", \"u3\", hexUp );\r\n\taddLine( \"u3\", \"u1\", hexUp );\r\n\r\n\t// target\r\n\r\n\taddLine( \"c\", \"t\", hexTarget );\r\n\taddLine( \"p\", \"c\", hexCross );\r\n\r\n\t// cross\r\n\r\n\taddLine( \"cn1\", \"cn2\", hexCross );\r\n\taddLine( \"cn3\", \"cn4\", hexCross );\r\n\r\n\taddLine( \"cf1\", \"cf2\", hexCross );\r\n\taddLine( \"cf3\", \"cf4\", hexCross );\r\n\r\n\tthis.camera = camera;\r\n\r\n\tfunction addLine( a, b, hex ) {\r\n\r\n\t\taddPoint( a, hex );\r\n\t\taddPoint( b, hex );\r\n\r\n\t}\r\n\r\n\tfunction addPoint( id, hex ) {\r\n\r\n\t\tscope.geometry.vertices.push( new THREE.Vector3() );\r\n\t\tscope.geometry.colors.push( new THREE.Color( hex ) );\r\n\r\n\t\tif ( scope.pointMap[ id ] === undefined ) scope.pointMap[ id ] = [];\r\n\r\n\t\tscope.pointMap[ id ].push( scope.geometry.vertices.length - 1 );\r\n\r\n\t}\r\n\r\n\tthis.update( camera );\r\n\r\n};\r\n\r\nTHREE.CameraHelper.prototype = Object.create( THREE.Line.prototype );\r\n\r\nTHREE.CameraHelper.prototype.update = function () {\r\n\r\n\tvar scope = this;\r\n\r\n\tvar w = 1, h = 1;\r\n\r\n\t// we need just camera projection matrix\r\n\t// world matrix must be identity\r\n\r\n\tTHREE.CameraHelper.__c.projectionMatrix.copy( this.camera.projectionMatrix );\r\n\r\n\t// center / target\r\n\r\n\tsetPoint( \"c\", 0, 0, -1 );\r\n\tsetPoint( \"t\", 0, 0,  1 );\r\n\r\n\t// near\r\n\r\n\tsetPoint( \"n1\", -w, -h, -1 );\r\n\tsetPoint( \"n2\",  w, -h, -1 );\r\n\tsetPoint( \"n3\", -w,  h, -1 );\r\n\tsetPoint( \"n4\",  w,  h, -1 );\r\n\r\n\t// far\r\n\r\n\tsetPoint( \"f1\", -w, -h, 1 );\r\n\tsetPoint( \"f2\",  w, -h, 1 );\r\n\tsetPoint( \"f3\", -w,  h, 1 );\r\n\tsetPoint( \"f4\",  w,  h, 1 );\r\n\r\n\t// up\r\n\r\n\tsetPoint( \"u1\",  w * 0.7, h * 1.1, -1 );\r\n\tsetPoint( \"u2\", -w * 0.7, h * 1.1, -1 );\r\n\tsetPoint( \"u3\",        0, h * 2,   -1 );\r\n\r\n\t// cross\r\n\r\n\tsetPoint( \"cf1\", -w,  0, 1 );\r\n\tsetPoint( \"cf2\",  w,  0, 1 );\r\n\tsetPoint( \"cf3\",  0, -h, 1 );\r\n\tsetPoint( \"cf4\",  0,  h, 1 );\r\n\r\n\tsetPoint( \"cn1\", -w,  0, -1 );\r\n\tsetPoint( \"cn2\",  w,  0, -1 );\r\n\tsetPoint( \"cn3\",  0, -h, -1 );\r\n\tsetPoint( \"cn4\",  0,  h, -1 );\r\n\r\n\tfunction setPoint( point, x, y, z ) {\r\n\r\n\t\tTHREE.CameraHelper.__v.set( x, y, z );\r\n\t\tTHREE.CameraHelper.__projector.unprojectVector( THREE.CameraHelper.__v, THREE.CameraHelper.__c );\r\n\r\n\t\tvar points = scope.pointMap[ point ];\r\n\r\n\t\tif ( points !== undefined ) {\r\n\r\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tscope.geometry.vertices[ points[ i ] ].copy( THREE.CameraHelper.__v );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.geometry.verticesNeedUpdate = true;\r\n\r\n};\r\n\r\nTHREE.CameraHelper.__projector = new THREE.Projector();\r\nTHREE.CameraHelper.__v = new THREE.Vector3();\r\nTHREE.CameraHelper.__c = new THREE.Camera();\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n *\t- shows directional light color, intensity, position, orientation and target\r\n */\r\n\r\nTHREE.DirectionalLightHelper = function ( light, sphereSize ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.light = light;\r\n\r\n\t// position\r\n\r\n\tthis.position = light.position;\r\n\r\n\t// direction\r\n\r\n\tthis.direction = new THREE.Vector3();\r\n\tthis.direction.subVectors( light.target.position, light.position );\r\n\r\n\t// color\r\n\r\n\tvar intensity = THREE.Math.clamp( light.intensity, 0, 1 );\r\n\r\n\tthis.color = light.color.clone();\r\n\tthis.color.multiplyScalar( intensity );\r\n\r\n\tvar hexColor = this.color.getHex();\r\n\r\n\t// light helper\r\n\r\n\tvar bulbGeometry = new THREE.SphereGeometry( sphereSize, 16, 8 );\r\n\tvar raysGeometry = new THREE.AsteriskGeometry( sphereSize * 1.25, sphereSize * 2.25 );\r\n\r\n\tvar bulbMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false } );\r\n\tvar raysMaterial = new THREE.LineBasicMaterial( { color: hexColor, fog: false } );\r\n\r\n\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\r\n\r\n\tthis.lightRays = new THREE.Line( raysGeometry, raysMaterial, THREE.LinePieces );\r\n\r\n\tthis.add( this.lightSphere );\r\n\tthis.add( this.lightRays );\r\n\r\n\tthis.lightSphere.properties.isGizmo = true;\r\n\tthis.lightSphere.properties.gizmoSubject = light;\r\n\tthis.lightSphere.properties.gizmoRoot = this;\r\n\r\n\t// light target helper\r\n\r\n\tthis.targetSphere = null;\r\n\r\n\tif ( light.target.properties.targetInverse !== undefined ) {\r\n\r\n\t\tvar targetGeo = new THREE.SphereGeometry( sphereSize, 8, 4 );\r\n\t\tvar targetMaterial = new THREE.MeshBasicMaterial( { color: hexColor, wireframe: true, fog: false } );\r\n\r\n\t\tthis.targetSphere = new THREE.Mesh( targetGeo, targetMaterial );\r\n\t\tthis.targetSphere.position = light.target.position;\r\n\r\n\t\tthis.targetSphere.properties.isGizmo = true;\r\n\t\tthis.targetSphere.properties.gizmoSubject = light.target;\r\n\t\tthis.targetSphere.properties.gizmoRoot = this.targetSphere;\r\n\r\n\t\tvar lineMaterial = new THREE.LineDashedMaterial( { color: hexColor, dashSize: 4, gapSize: 4, opacity: 0.75, transparent: true, fog: false } );\r\n\t\tvar lineGeometry = new THREE.Geometry();\r\n\t\tlineGeometry.vertices.push( this.position.clone() );\r\n\t\tlineGeometry.vertices.push( this.targetSphere.position.clone() );\r\n\t\tlineGeometry.computeLineDistances();\r\n\r\n\t\tthis.targetLine = new THREE.Line( lineGeometry, lineMaterial );\r\n\t\tthis.targetLine.properties.isGizmo = true;\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tthis.properties.isGizmo = true;\r\n\r\n}\r\n\r\nTHREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.DirectionalLightHelper.prototype.update = function () {\r\n\r\n\t// update arrow orientation\r\n\t// pointing from light to target\r\n\r\n\tthis.direction.subVectors( this.light.target.position, this.light.position );\r\n\r\n\t// update arrow, spheres, rays and line colors to light color * light intensity\r\n\r\n\tvar intensity = THREE.Math.clamp( this.light.intensity, 0, 1 );\r\n\r\n\tthis.color.copy( this.light.color );\r\n\tthis.color.multiplyScalar( intensity );\r\n\r\n\tthis.lightSphere.material.color.copy( this.color );\r\n\tthis.lightRays.material.color.copy( this.color );\r\n\r\n\t// Only update targetSphere and targetLine if available\r\n\tif ( this.targetSphere !== null ) {\r\n\r\n\t\tthis.targetSphere.material.color.copy( this.color );\r\n\t\tthis.targetLine.material.color.copy( this.color );\r\n\r\n\t\t// update target line vertices\r\n\r\n\t\tthis.targetLine.geometry.vertices[ 0 ].copy( this.light.position );\r\n\t\tthis.targetLine.geometry.vertices[ 1 ].copy( this.light.target.position );\r\n\r\n\t\tthis.targetLine.geometry.computeLineDistances();\r\n\t\tthis.targetLine.geometry.verticesNeedUpdate = true;\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n *\t- shows hemisphere light intensity, sky and ground colors and directions\r\n */\r\n\r\nTHREE.HemisphereLightHelper = function ( light, sphereSize, arrowLength, domeSize ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.light = light;\r\n\r\n\t// position\r\n\r\n\tthis.position = light.position;\r\n\r\n\t//\r\n\r\n\tvar intensity = THREE.Math.clamp( light.intensity, 0, 1 );\r\n\r\n\t// sky color\r\n\r\n\tthis.color = light.color.clone();\r\n\tthis.color.multiplyScalar( intensity );\r\n\r\n\tvar hexColor = this.color.getHex();\r\n\r\n\t// ground color\r\n\r\n\tthis.groundColor = light.groundColor.clone();\r\n\tthis.groundColor.multiplyScalar( intensity );\r\n\r\n\tvar hexColorGround = this.groundColor.getHex();\r\n\r\n\t// double colored light bulb\r\n\r\n\tvar bulbGeometry = new THREE.SphereGeometry( sphereSize, 16, 8, 0, Math.PI * 2, 0, Math.PI * 0.5 );\r\n\tvar bulbGroundGeometry = new THREE.SphereGeometry( sphereSize, 16, 8, 0, Math.PI * 2, Math.PI * 0.5, Math.PI );\r\n\r\n\tvar bulbSkyMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false } );\r\n\tvar bulbGroundMaterial = new THREE.MeshBasicMaterial( { color: hexColorGround, fog: false } );\r\n\r\n\tfor ( var i = 0, il = bulbGeometry.faces.length; i < il; i ++ ) {\r\n\r\n\t\tbulbGeometry.faces[ i ].materialIndex = 0;\r\n\r\n\t}\r\n\r\n\tfor ( var i = 0, il = bulbGroundGeometry.faces.length; i < il; i ++ ) {\r\n\r\n\t\tbulbGroundGeometry.faces[ i ].materialIndex = 1;\r\n\r\n\t}\r\n\r\n\tTHREE.GeometryUtils.merge( bulbGeometry, bulbGroundGeometry );\r\n\r\n\tthis.lightSphere = new THREE.Mesh( bulbGeometry, new THREE.MeshFaceMaterial( [ bulbSkyMaterial, bulbGroundMaterial ] ) );\r\n\r\n\t// arrows for sky and ground light directions\r\n\r\n\tthis.lightArrow = new THREE.ArrowHelper( new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, ( sphereSize + arrowLength ) * 1.1, 0 ), arrowLength, hexColor );\r\n\tthis.lightArrow.rotation.x = Math.PI;\r\n\r\n\tthis.lightArrowGround = new THREE.ArrowHelper( new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, ( sphereSize + arrowLength ) * -1.1, 0 ), arrowLength, hexColorGround );\r\n\r\n\tvar joint = new THREE.Object3D();\r\n\tjoint.rotation.x = -Math.PI * 0.5;\r\n\r\n\tjoint.add( this.lightSphere );\r\n\tjoint.add( this.lightArrow );\r\n\tjoint.add( this.lightArrowGround );\r\n\r\n\tthis.add( joint );\r\n\r\n\t//\r\n\r\n\tthis.lightSphere.properties.isGizmo = true;\r\n\tthis.lightSphere.properties.gizmoSubject = light;\r\n\tthis.lightSphere.properties.gizmoRoot = this;\r\n\r\n\t//\r\n\r\n\tthis.properties.isGizmo = true;\r\n\r\n\t//\r\n\r\n\tthis.target = new THREE.Vector3();\r\n\tthis.lookAt( this.target );\r\n\r\n}\r\n\r\nTHREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.HemisphereLightHelper.prototype.update = function () {\r\n\r\n\t// update sphere sky and ground colors to light color * light intensity\r\n\r\n\tvar intensity = THREE.Math.clamp( this.light.intensity, 0, 1 );\r\n\r\n\tthis.color.copy( this.light.color );\r\n\tthis.color.multiplyScalar( intensity );\r\n\r\n\tthis.groundColor.copy( this.light.groundColor );\r\n\tthis.groundColor.multiplyScalar( intensity );\r\n\r\n\tthis.lightSphere.material.materials[ 0 ].color.copy( this.color );\r\n\tthis.lightSphere.material.materials[ 1 ].color.copy( this.groundColor );\r\n\r\n\tthis.lightArrow.setColor( this.color.getHex() );\r\n\tthis.lightArrowGround.setColor( this.groundColor.getHex() );\r\n\r\n\tthis.lookAt( this.target );\r\n\r\n}\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n *\t- shows point light color, intensity, position and distance\r\n */\r\n\r\nTHREE.PointLightHelper = function ( light, sphereSize ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.light = light;\r\n\r\n\t// position\r\n\r\n\tthis.position = light.position;\r\n\r\n\t// color\r\n\r\n\tvar intensity = THREE.Math.clamp( light.intensity, 0, 1 );\r\n\r\n\tthis.color = light.color.clone();\r\n\tthis.color.multiplyScalar( intensity );\r\n\r\n\tvar hexColor = this.color.getHex();\r\n\r\n\t// light helper\r\n\r\n\tvar bulbGeometry = new THREE.SphereGeometry( sphereSize, 16, 8 );\r\n\tvar raysGeometry = new THREE.AsteriskGeometry( sphereSize * 1.25, sphereSize * 2.25 );\r\n\tvar distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\r\n\r\n\tvar bulbMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false } );\r\n\tvar raysMaterial = new THREE.LineBasicMaterial( { color: hexColor, fog: false } );\r\n\tvar distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\r\n\r\n\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\r\n\tthis.lightRays = new THREE.Line( raysGeometry, raysMaterial, THREE.LinePieces );\r\n\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\r\n\r\n\tvar d = light.distance;\r\n\r\n\tif ( d === 0.0 ) {\r\n\r\n\t\tthis.lightDistance.visible = false;\r\n\r\n\t} else {\r\n\r\n\t\tthis.lightDistance.scale.set( d, d, d );\r\n\r\n\t}\r\n\r\n\tthis.add( this.lightSphere );\r\n\tthis.add( this.lightRays );\r\n\tthis.add( this.lightDistance );\r\n\r\n\t//\r\n\r\n\tthis.lightSphere.properties.isGizmo = true;\r\n\tthis.lightSphere.properties.gizmoSubject = light;\r\n\tthis.lightSphere.properties.gizmoRoot = this;\r\n\r\n\t//\r\n\r\n\tthis.properties.isGizmo = true;\r\n\r\n}\r\n\r\nTHREE.PointLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.PointLightHelper.prototype.update = function () {\r\n\r\n\t// update sphere and rays colors to light color * light intensity\r\n\r\n\tvar intensity = THREE.Math.clamp( this.light.intensity, 0, 1 );\r\n\r\n\tthis.color.copy( this.light.color );\r\n\tthis.color.multiplyScalar( intensity );\r\n\r\n\tthis.lightSphere.material.color.copy( this.color );\r\n\tthis.lightRays.material.color.copy( this.color );\r\n\tthis.lightDistance.material.color.copy( this.color );\r\n\r\n\t//\r\n\r\n\tvar d = this.light.distance;\r\n\r\n\tif ( d === 0.0 ) {\r\n\r\n\t\tthis.lightDistance.visible = false;\r\n\r\n\t} else {\r\n\r\n\t\tthis.lightDistance.visible = true;\r\n\t\tthis.lightDistance.scale.set( d, d, d );\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n *\t- shows spot light color, intensity, position, orientation, light cone and target\r\n */\r\n\r\nTHREE.SpotLightHelper = function ( light, sphereSize ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.light = light;\r\n\r\n\t// position\r\n\r\n\tthis.position = light.position;\r\n\r\n\t// direction\r\n\r\n\tthis.direction = new THREE.Vector3();\r\n\tthis.direction.subVectors( light.target.position, light.position );\r\n\r\n\t// color\r\n\r\n\tvar intensity = THREE.Math.clamp( light.intensity, 0, 1 );\r\n\r\n\tthis.color = light.color.clone();\r\n\tthis.color.multiplyScalar( intensity );\r\n\r\n\tvar hexColor = this.color.getHex();\r\n\r\n\t// light helper\r\n\r\n\tvar bulbGeometry = new THREE.SphereGeometry( sphereSize, 16, 8 );\r\n\tvar raysGeometry = new THREE.AsteriskGeometry( sphereSize * 1.25, sphereSize * 2.25 );\r\n\tvar coneGeometry = new THREE.CylinderGeometry( 0.0001, 1, 1, 8, 1, true );\r\n\r\n\tvar coneMatrix = new THREE.Matrix4();\r\n\tconeMatrix.rotateX( -Math.PI/2 );\r\n\tconeMatrix.translate( new THREE.Vector3( 0, -0.5, 0 ) );\r\n\tconeGeometry.applyMatrix( coneMatrix );\r\n\r\n\tvar bulbMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false } );\r\n\tvar raysMaterial = new THREE.LineBasicMaterial( { color: hexColor, fog: false } );\r\n\tvar coneMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.3, transparent: true } );\r\n\r\n\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\r\n\tthis.lightCone = new THREE.Mesh( coneGeometry, coneMaterial );\r\n\r\n\tvar coneLength = light.distance ? light.distance : 10000;\r\n\tvar coneWidth = coneLength * Math.tan( light.angle * 0.5 ) * 2;\r\n\tthis.lightCone.scale.set( coneWidth, coneWidth, coneLength );\r\n\r\n\tthis.lightRays = new THREE.Line( raysGeometry, raysMaterial, THREE.LinePieces );\r\n\r\n\tthis.gyroscope = new THREE.Gyroscope();\r\n\r\n\tthis.gyroscope.add( this.lightSphere );\r\n\tthis.gyroscope.add( this.lightRays );\r\n\r\n\tthis.add( this.gyroscope );\r\n\tthis.add( this.lightCone );\r\n\r\n\tthis.lookAt( light.target.position );\r\n\r\n\tthis.lightSphere.properties.isGizmo = true;\r\n\tthis.lightSphere.properties.gizmoSubject = light;\r\n\tthis.lightSphere.properties.gizmoRoot = this;\r\n\r\n\t// light target helper\r\n\r\n\tthis.targetSphere = null;\r\n\r\n\tif ( light.target.properties.targetInverse !== undefined ) {\r\n\r\n\t\tvar targetGeo = new THREE.SphereGeometry( sphereSize, 8, 4 );\r\n\t\tvar targetMaterial = new THREE.MeshBasicMaterial( { color: hexColor, wireframe: true, fog: false } );\r\n\r\n\t\tthis.targetSphere = new THREE.Mesh( targetGeo, targetMaterial );\r\n\t\tthis.targetSphere.position = light.target.position;\r\n\r\n\t\tthis.targetSphere.properties.isGizmo = true;\r\n\t\tthis.targetSphere.properties.gizmoSubject = light.target;\r\n\t\tthis.targetSphere.properties.gizmoRoot = this.targetSphere;\r\n\r\n\t\tvar lineMaterial = new THREE.LineDashedMaterial( { color: hexColor, dashSize: 4, gapSize: 4, opacity: 0.75, transparent: true, fog: false } );\r\n\t\tvar lineGeometry = new THREE.Geometry();\r\n\t\tlineGeometry.vertices.push( this.position.clone() );\r\n\t\tlineGeometry.vertices.push( this.targetSphere.position.clone() );\r\n\t\tlineGeometry.computeLineDistances();\r\n\r\n\t\tthis.targetLine = new THREE.Line( lineGeometry, lineMaterial );\r\n\t\tthis.targetLine.properties.isGizmo = true;\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tthis.properties.isGizmo = true;\r\n\r\n}\r\n\r\nTHREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.SpotLightHelper.prototype.update = function () {\r\n\r\n\t// update arrow orientation\r\n\t// pointing from light to target\r\n\r\n\tthis.direction.subVectors( this.light.target.position, this.light.position );\r\n\r\n\t// update light cone orientation and size\r\n\r\n\tthis.lookAt( this.light.target.position );\r\n\r\n\tvar coneLength = this.light.distance ? this.light.distance : 10000;\r\n\tvar coneWidth = coneLength * Math.tan( this.light.angle * 0.5 ) * 2;\r\n\tthis.lightCone.scale.set( coneWidth, coneWidth, coneLength );\r\n\r\n\t// update arrow, spheres, rays and line colors to light color * light intensity\r\n\r\n\tvar intensity = THREE.Math.clamp( this.light.intensity, 0, 1 );\r\n\r\n\tthis.color.copy( this.light.color );\r\n\tthis.color.multiplyScalar( intensity );\r\n\r\n\tthis.lightSphere.material.color.copy( this.color );\r\n\tthis.lightRays.material.color.copy( this.color );\r\n\tthis.lightCone.material.color.copy( this.color );\r\n\r\n\t// Only update targetSphere and targetLine if available\r\n\tif ( this.targetSphere !== null ) {\r\n\r\n\t\tthis.targetSphere.material.color.copy( this.color );\r\n\t\tthis.targetLine.material.color.copy( this.color );\r\n\r\n\t\t// update target line vertices\r\n\r\n\t\tthis.targetLine.geometry.vertices[ 0 ].copy( this.light.position );\r\n\t\tthis.targetLine.geometry.vertices[ 1 ].copy( this.light.target.position );\r\n\r\n\t\tthis.targetLine.geometry.computeLineDistances();\r\n\t\tthis.targetLine.geometry.verticesNeedUpdate = true;\r\n\r\n\t}\r\n\r\n};\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.ImmediateRenderObject = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.render = function ( renderCallback ) { };\r\n\r\n};\r\n\r\nTHREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.LensFlare = function ( texture, size, distance, blending, color ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.lensFlares = [];\r\n\r\n\tthis.positionScreen = new THREE.Vector3();\r\n\tthis.customUpdateCallback = undefined;\r\n\r\n\tif( texture !== undefined ) {\r\n\r\n\t\tthis.add( texture, size, distance, blending, color );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\n\r\n/*\r\n * Add: adds another flare\r\n */\r\n\r\nTHREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {\r\n\r\n\tif( size === undefined ) size = -1;\r\n\tif( distance === undefined ) distance = 0;\r\n\tif( opacity === undefined ) opacity = 1;\r\n\tif( color === undefined ) color = new THREE.Color( 0xffffff );\r\n\tif( blending === undefined ) blending = THREE.NormalBlending;\r\n\r\n\tdistance = Math.min( distance, Math.max( 0, distance ) );\r\n\r\n\tthis.lensFlares.push( { texture: texture, \t\t\t// THREE.Texture\r\n\t\t                    size: size, \t\t\t\t// size in pixels (-1 = use texture.width)\r\n\t\t                    distance: distance, \t\t// distance (0-1) from light source (0=at light source)\r\n\t\t                    x: 0, y: 0, z: 0,\t\t\t// screen position (-1 => 1) z = 0 is ontop z = 1 is back\r\n\t\t                    scale: 1, \t\t\t\t\t// scale\r\n\t\t                    rotation: 1, \t\t\t\t// rotation\r\n\t\t                    opacity: opacity,\t\t\t// opacity\r\n\t\t\t\t\t\t\tcolor: color,\t\t\t\t// color\r\n\t\t                    blending: blending } );\t\t// blending\r\n\r\n};\r\n\r\n\r\n/*\r\n * Update lens flares update positions on all flares based on the screen position\r\n * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\r\n */\r\n\r\nTHREE.LensFlare.prototype.updateLensFlares = function () {\r\n\r\n\tvar f, fl = this.lensFlares.length;\r\n\tvar flare;\r\n\tvar vecX = -this.positionScreen.x * 2;\r\n\tvar vecY = -this.positionScreen.y * 2;\r\n\r\n\tfor( f = 0; f < fl; f ++ ) {\r\n\r\n\t\tflare = this.lensFlares[ f ];\r\n\r\n\t\tflare.x = this.positionScreen.x + vecX * flare.distance;\r\n\t\tflare.y = this.positionScreen.y + vecY * flare.distance;\r\n\r\n\t\tflare.wantedRotation = flare.x * Math.PI * 0.25;\r\n\t\tflare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;\r\n\r\n\t}\r\n\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.MorphBlendMesh = function( geometry, material ) {\r\n\r\n\tTHREE.Mesh.call( this, geometry, material );\r\n\r\n\tthis.animationsMap = {};\r\n\tthis.animationsList = [];\r\n\r\n\t// prepare default animation\r\n\t// (all frames played together in 1 second)\r\n\r\n\tvar numFrames = this.geometry.morphTargets.length;\r\n\r\n\tvar name = \"__default\";\r\n\r\n\tvar startFrame = 0;\r\n\tvar endFrame = numFrames - 1;\r\n\r\n\tvar fps = numFrames / 1;\r\n\r\n\tthis.createAnimation( name, startFrame, endFrame, fps );\r\n\tthis.setAnimationWeight( name, 1 );\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );\r\n\r\nTHREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {\r\n\r\n\tvar animation = {\r\n\r\n\t\tstartFrame: start,\r\n\t\tendFrame: end,\r\n\r\n\t\tlength: end - start + 1,\r\n\r\n\t\tfps: fps,\r\n\t\tduration: ( end - start ) / fps,\r\n\r\n\t\tlastFrame: 0,\r\n\t\tcurrentFrame: 0,\r\n\r\n\t\tactive: false,\r\n\r\n\t\ttime: 0,\r\n\t\tdirection: 1,\r\n\t\tweight: 1,\r\n\r\n\t\tdirectionBackwards: false,\r\n\t\tmirroredLoop: false\r\n\r\n\t};\r\n\r\n\tthis.animationsMap[ name ] = animation;\r\n\tthis.animationsList.push( animation );\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {\r\n\r\n\tvar pattern = /([a-z]+)(\\d+)/;\r\n\r\n\tvar firstAnimation, frameRanges = {};\r\n\r\n\tvar geometry = this.geometry;\r\n\r\n\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\r\n\r\n\t\tvar morph = geometry.morphTargets[ i ];\r\n\t\tvar chunks = morph.name.match( pattern );\r\n\r\n\t\tif ( chunks && chunks.length > 1 ) {\r\n\r\n\t\t\tvar name = chunks[ 1 ];\r\n\t\t\tvar num = chunks[ 2 ];\r\n\r\n\t\t\tif ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: -Infinity };\r\n\r\n\t\t\tvar range = frameRanges[ name ];\r\n\r\n\t\t\tif ( i < range.start ) range.start = i;\r\n\t\t\tif ( i > range.end ) range.end = i;\r\n\r\n\t\t\tif ( ! firstAnimation ) firstAnimation = name;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfor ( var name in frameRanges ) {\r\n\r\n\t\tvar range = frameRanges[ name ];\r\n\t\tthis.createAnimation( name, range.start, range.end, fps );\r\n\r\n\t}\r\n\r\n\tthis.firstAnimation = firstAnimation;\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.direction = 1;\r\n\t\tanimation.directionBackwards = false;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.direction = -1;\r\n\t\tanimation.directionBackwards = true;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.fps = fps;\r\n\t\tanimation.duration = ( animation.end - animation.start ) / animation.fps;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.duration = duration;\r\n\t\tanimation.fps = ( animation.end - animation.start ) / animation.duration;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.weight = weight;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.time = time;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {\r\n\r\n\tvar time = 0;\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\ttime = animation.time;\r\n\r\n\t}\r\n\r\n\treturn time;\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {\r\n\r\n\tvar duration = -1;\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tduration = animation.duration;\r\n\r\n\t}\r\n\r\n\treturn duration;\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.time = 0;\r\n\t\tanimation.active = true;\r\n\r\n\t} else {\r\n\r\n\t\tconsole.warn( \"animation[\" + name + \"] undefined\" );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.active = false;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.update = function ( delta ) {\r\n\r\n\tfor ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {\r\n\r\n\t\tvar animation = this.animationsList[ i ];\r\n\r\n\t\tif ( ! animation.active ) continue;\r\n\r\n\t\tvar frameTime = animation.duration / animation.length;\r\n\r\n\t\tanimation.time += animation.direction * delta;\r\n\r\n\t\tif ( animation.mirroredLoop ) {\r\n\r\n\t\t\tif ( animation.time > animation.duration || animation.time < 0 ) {\r\n\r\n\t\t\t\tanimation.direction *= -1;\r\n\r\n\t\t\t\tif ( animation.time > animation.duration ) {\r\n\r\n\t\t\t\t\tanimation.time = animation.duration;\r\n\t\t\t\t\tanimation.directionBackwards = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( animation.time < 0 ) {\r\n\r\n\t\t\t\t\tanimation.time = 0;\r\n\t\t\t\t\tanimation.directionBackwards = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tanimation.time = animation.time % animation.duration;\r\n\r\n\t\t\tif ( animation.time < 0 ) animation.time += animation.duration;\r\n\r\n\t\t}\r\n\r\n\t\tvar keyframe = animation.startFrame + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );\r\n\t\tvar weight = animation.weight;\r\n\r\n\t\tif ( keyframe !== animation.currentFrame ) {\r\n\r\n\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = 0;\r\n\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;\r\n\r\n\t\t\tthis.morphTargetInfluences[ keyframe ] = 0;\r\n\r\n\t\t\tanimation.lastFrame = animation.currentFrame;\r\n\t\t\tanimation.currentFrame = keyframe;\r\n\r\n\t\t}\r\n\r\n\t\tvar mix = ( animation.time % frameTime ) / frameTime;\r\n\r\n\t\tif ( animation.directionBackwards ) mix = 1 - mix;\r\n\r\n\t\tthis.morphTargetInfluences[ animation.currentFrame ] = mix * weight;\r\n\t\tthis.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;\r\n\r\n\t}\r\n\r\n};\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.LensFlarePlugin = function () {\r\n\r\n\tvar _gl, _renderer, _precision, _lensFlare = {};\r\n\r\n\tthis.init = function ( renderer ) {\r\n\r\n\t\t_gl = renderer.context;\r\n\t\t_renderer = renderer;\r\n\r\n\t\t_precision = renderer.getPrecision();\r\n\r\n\t\t_lensFlare.vertices = new Float32Array( 8 + 8 );\r\n\t\t_lensFlare.faces = new Uint16Array( 6 );\r\n\r\n\t\tvar i = 0;\r\n\t\t_lensFlare.vertices[ i++ ] = -1; _lensFlare.vertices[ i++ ] = -1;\t// vertex\r\n\t\t_lensFlare.vertices[ i++ ] = 0;  _lensFlare.vertices[ i++ ] = 0;\t// uv... etc.\r\n\r\n\t\t_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = -1;\r\n\t\t_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 0;\r\n\r\n\t\t_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 1;\r\n\t\t_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 1;\r\n\r\n\t\t_lensFlare.vertices[ i++ ] = -1; _lensFlare.vertices[ i++ ] = 1;\r\n\t\t_lensFlare.vertices[ i++ ] = 0;  _lensFlare.vertices[ i++ ] = 1;\r\n\r\n\t\ti = 0;\r\n\t\t_lensFlare.faces[ i++ ] = 0; _lensFlare.faces[ i++ ] = 1; _lensFlare.faces[ i++ ] = 2;\r\n\t\t_lensFlare.faces[ i++ ] = 0; _lensFlare.faces[ i++ ] = 2; _lensFlare.faces[ i++ ] = 3;\r\n\r\n\t\t// buffers\r\n\r\n\t\t_lensFlare.vertexBuffer     = _gl.createBuffer();\r\n\t\t_lensFlare.elementBuffer    = _gl.createBuffer();\r\n\r\n\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, _lensFlare.vertexBuffer );\r\n\t\t_gl.bufferData( _gl.ARRAY_BUFFER, _lensFlare.vertices, _gl.STATIC_DRAW );\r\n\r\n\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.elementBuffer );\r\n\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.faces, _gl.STATIC_DRAW );\r\n\r\n\t\t// textures\r\n\r\n\t\t_lensFlare.tempTexture      = _gl.createTexture();\r\n\t\t_lensFlare.occlusionTexture = _gl.createTexture();\r\n\r\n\t\t_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );\r\n\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, _gl.RGB, 16, 16, 0, _gl.RGB, _gl.UNSIGNED_BYTE, null );\r\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\r\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\r\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, _gl.NEAREST );\r\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, _gl.NEAREST );\r\n\r\n\t\t_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.occlusionTexture );\r\n\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, _gl.RGBA, 16, 16, 0, _gl.RGBA, _gl.UNSIGNED_BYTE, null );\r\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\r\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\r\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, _gl.NEAREST );\r\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, _gl.NEAREST );\r\n\r\n\t\tif ( _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) <= 0 ) {\r\n\r\n\t\t\t_lensFlare.hasVertexTexture = false;\r\n\t\t\t_lensFlare.program = createProgram( THREE.ShaderFlares[ \"lensFlare\" ], _precision );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_lensFlare.hasVertexTexture = true;\r\n\t\t\t_lensFlare.program = createProgram( THREE.ShaderFlares[ \"lensFlareVertexTexture\" ], _precision );\r\n\r\n\t\t}\r\n\r\n\t\t_lensFlare.attributes = {};\r\n\t\t_lensFlare.uniforms = {};\r\n\r\n\t\t_lensFlare.attributes.vertex       = _gl.getAttribLocation ( _lensFlare.program, \"position\" );\r\n\t\t_lensFlare.attributes.uv           = _gl.getAttribLocation ( _lensFlare.program, \"uv\" );\r\n\r\n\t\t_lensFlare.uniforms.renderType     = _gl.getUniformLocation( _lensFlare.program, \"renderType\" );\r\n\t\t_lensFlare.uniforms.map            = _gl.getUniformLocation( _lensFlare.program, \"map\" );\r\n\t\t_lensFlare.uniforms.occlusionMap   = _gl.getUniformLocation( _lensFlare.program, \"occlusionMap\" );\r\n\t\t_lensFlare.uniforms.opacity        = _gl.getUniformLocation( _lensFlare.program, \"opacity\" );\r\n\t\t_lensFlare.uniforms.color          = _gl.getUniformLocation( _lensFlare.program, \"color\" );\r\n\t\t_lensFlare.uniforms.scale          = _gl.getUniformLocation( _lensFlare.program, \"scale\" );\r\n\t\t_lensFlare.uniforms.rotation       = _gl.getUniformLocation( _lensFlare.program, \"rotation\" );\r\n\t\t_lensFlare.uniforms.screenPosition = _gl.getUniformLocation( _lensFlare.program, \"screenPosition\" );\r\n\r\n\t};\r\n\r\n\r\n\t/*\r\n\t * Render lens flares\r\n\t * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\r\n\t *         reads these back and calculates occlusion.\r\n\t *         Then _lensFlare.update_lensFlares() is called to re-position and\r\n\t *         update transparency of flares. Then they are rendered.\r\n\t *\r\n\t */\r\n\r\n\tthis.render = function ( scene, camera, viewportWidth, viewportHeight ) {\r\n\r\n\t\tvar flares = scene.__webglFlares,\r\n\t\t\tnFlares = flares.length;\r\n\r\n\t\tif ( ! nFlares ) return;\r\n\r\n\t\tvar tempPosition = new THREE.Vector3();\r\n\r\n\t\tvar invAspect = viewportHeight / viewportWidth,\r\n\t\t\thalfViewportWidth = viewportWidth * 0.5,\r\n\t\t\thalfViewportHeight = viewportHeight * 0.5;\r\n\r\n\t\tvar size = 16 / viewportHeight,\r\n\t\t\tscale = new THREE.Vector2( size * invAspect, size );\r\n\r\n\t\tvar screenPosition = new THREE.Vector3( 1, 1, 0 ),\r\n\t\t\tscreenPositionPixels = new THREE.Vector2( 1, 1 );\r\n\r\n\t\tvar uniforms = _lensFlare.uniforms,\r\n\t\t\tattributes = _lensFlare.attributes;\r\n\r\n\t\t// set _lensFlare program and reset blending\r\n\r\n\t\t_gl.useProgram( _lensFlare.program );\r\n\r\n\t\t_gl.enableVertexAttribArray( _lensFlare.attributes.vertex );\r\n\t\t_gl.enableVertexAttribArray( _lensFlare.attributes.uv );\r\n\r\n\t\t// loop through all lens flares to update their occlusion and positions\r\n\t\t// setup gl and common used attribs/unforms\r\n\r\n\t\t_gl.uniform1i( uniforms.occlusionMap, 0 );\r\n\t\t_gl.uniform1i( uniforms.map, 1 );\r\n\r\n\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, _lensFlare.vertexBuffer );\r\n\t\t_gl.vertexAttribPointer( attributes.vertex, 2, _gl.FLOAT, false, 2 * 8, 0 );\r\n\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 2 * 8, 8 );\r\n\r\n\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.elementBuffer );\r\n\r\n\t\t_gl.disable( _gl.CULL_FACE );\r\n\t\t_gl.depthMask( false );\r\n\r\n\t\tvar i, j, jl, flare, sprite;\r\n\r\n\t\tfor ( i = 0; i < nFlares; i ++ ) {\r\n\r\n\t\t\tsize = 16 / viewportHeight;\r\n\t\t\tscale.set( size * invAspect, size );\r\n\r\n\t\t\t// calc object screen position\r\n\r\n\t\t\tflare = flares[ i ];\r\n\r\n\t\t\ttempPosition.set( flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14] );\r\n\r\n\t\t\ttempPosition.applyMatrix4( camera.matrixWorldInverse );\r\n\t\t\ttempPosition.applyProjection( camera.projectionMatrix );\r\n\r\n\t\t\t// setup arrays for gl programs\r\n\r\n\t\t\tscreenPosition.copy( tempPosition )\r\n\r\n\t\t\tscreenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;\r\n\t\t\tscreenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;\r\n\r\n\t\t\t// screen cull\r\n\r\n\t\t\tif ( _lensFlare.hasVertexTexture || (\r\n\t\t\t\tscreenPositionPixels.x > 0 &&\r\n\t\t\t\tscreenPositionPixels.x < viewportWidth &&\r\n\t\t\t\tscreenPositionPixels.y > 0 &&\r\n\t\t\t\tscreenPositionPixels.y < viewportHeight ) ) {\r\n\r\n\t\t\t\t// save current RGB to temp texture\r\n\r\n\t\t\t\t_gl.activeTexture( _gl.TEXTURE1 );\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );\r\n\t\t\t\t_gl.copyTexImage2D( _gl.TEXTURE_2D, 0, _gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );\r\n\r\n\r\n\t\t\t\t// render pink quad\r\n\r\n\t\t\t\t_gl.uniform1i( uniforms.renderType, 0 );\r\n\t\t\t\t_gl.uniform2f( uniforms.scale, scale.x, scale.y );\r\n\t\t\t\t_gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\r\n\r\n\t\t\t\t_gl.disable( _gl.BLEND );\r\n\t\t\t\t_gl.enable( _gl.DEPTH_TEST );\r\n\r\n\t\t\t\t_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );\r\n\r\n\r\n\t\t\t\t// copy result to occlusionMap\r\n\r\n\t\t\t\t_gl.activeTexture( _gl.TEXTURE0 );\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.occlusionTexture );\r\n\t\t\t\t_gl.copyTexImage2D( _gl.TEXTURE_2D, 0, _gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );\r\n\r\n\r\n\t\t\t\t// restore graphics\r\n\r\n\t\t\t\t_gl.uniform1i( uniforms.renderType, 1 );\r\n\t\t\t\t_gl.disable( _gl.DEPTH_TEST );\r\n\r\n\t\t\t\t_gl.activeTexture( _gl.TEXTURE1 );\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );\r\n\t\t\t\t_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );\r\n\r\n\r\n\t\t\t\t// update object positions\r\n\r\n\t\t\t\tflare.positionScreen.copy( screenPosition )\r\n\r\n\t\t\t\tif ( flare.customUpdateCallback ) {\r\n\r\n\t\t\t\t\tflare.customUpdateCallback( flare );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tflare.updateLensFlares();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// render flares\r\n\r\n\t\t\t\t_gl.uniform1i( uniforms.renderType, 2 );\r\n\t\t\t\t_gl.enable( _gl.BLEND );\r\n\r\n\t\t\t\tfor ( j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tsprite = flare.lensFlares[ j ];\r\n\r\n\t\t\t\t\tif ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {\r\n\r\n\t\t\t\t\t\tscreenPosition.x = sprite.x;\r\n\t\t\t\t\t\tscreenPosition.y = sprite.y;\r\n\t\t\t\t\t\tscreenPosition.z = sprite.z;\r\n\r\n\t\t\t\t\t\tsize = sprite.size * sprite.scale / viewportHeight;\r\n\r\n\t\t\t\t\t\tscale.x = size * invAspect;\r\n\t\t\t\t\t\tscale.y = size;\r\n\r\n\t\t\t\t\t\t_gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\r\n\t\t\t\t\t\t_gl.uniform2f( uniforms.scale, scale.x, scale.y );\r\n\t\t\t\t\t\t_gl.uniform1f( uniforms.rotation, sprite.rotation );\r\n\r\n\t\t\t\t\t\t_gl.uniform1f( uniforms.opacity, sprite.opacity );\r\n\t\t\t\t\t\t_gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );\r\n\r\n\t\t\t\t\t\t_renderer.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );\r\n\t\t\t\t\t\t_renderer.setTexture( sprite.texture, 1 );\r\n\r\n\t\t\t\t\t\t_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// restore gl\r\n\r\n\t\t_gl.enable( _gl.CULL_FACE );\r\n\t\t_gl.enable( _gl.DEPTH_TEST );\r\n\t\t_gl.depthMask( true );\r\n\r\n\t};\r\n\r\n\tfunction createProgram ( shader, precision ) {\r\n\r\n\t\tvar program = _gl.createProgram();\r\n\r\n\t\tvar fragmentShader = _gl.createShader( _gl.FRAGMENT_SHADER );\r\n\t\tvar vertexShader = _gl.createShader( _gl.VERTEX_SHADER );\r\n\r\n\t\tvar prefix = \"precision \" + precision + \" float;\\n\";\r\n\r\n\t\t_gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\r\n\t\t_gl.shaderSource( vertexShader, prefix + shader.vertexShader );\r\n\r\n\t\t_gl.compileShader( fragmentShader );\r\n\t\t_gl.compileShader( vertexShader );\r\n\r\n\t\t_gl.attachShader( program, fragmentShader );\r\n\t\t_gl.attachShader( program, vertexShader );\r\n\r\n\t\t_gl.linkProgram( program );\r\n\r\n\t\treturn program;\r\n\r\n\t};\r\n\r\n};\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.ShadowMapPlugin = function () {\r\n\r\n\tvar _gl,\r\n\t_renderer,\r\n\t_depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin,\r\n\r\n\t_frustum = new THREE.Frustum(),\r\n\t_projScreenMatrix = new THREE.Matrix4(),\r\n\r\n\t_min = new THREE.Vector3(),\r\n\t_max = new THREE.Vector3(),\r\n\r\n\t_matrixPosition = new THREE.Vector3();\r\n\r\n\tthis.init = function ( renderer ) {\r\n\r\n\t\t_gl = renderer.context;\r\n\t\t_renderer = renderer;\r\n\r\n\t\tvar depthShader = THREE.ShaderLib[ \"depthRGBA\" ];\r\n\t\tvar depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );\r\n\r\n\t\t_depthMaterial = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms } );\r\n\t\t_depthMaterialMorph = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true } );\r\n\t\t_depthMaterialSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, skinning: true } );\r\n\t\t_depthMaterialMorphSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true, skinning: true } );\r\n\r\n\t\t_depthMaterial._shadowPass = true;\r\n\t\t_depthMaterialMorph._shadowPass = true;\r\n\t\t_depthMaterialSkin._shadowPass = true;\r\n\t\t_depthMaterialMorphSkin._shadowPass = true;\r\n\r\n\t};\r\n\r\n\tthis.render = function ( scene, camera ) {\r\n\r\n\t\tif ( ! ( _renderer.shadowMapEnabled && _renderer.shadowMapAutoUpdate ) ) return;\r\n\r\n\t\tthis.update( scene, camera );\r\n\r\n\t};\r\n\r\n\tthis.update = function ( scene, camera ) {\r\n\r\n\t\tvar i, il, j, jl, n,\r\n\r\n\t\tshadowMap, shadowMatrix, shadowCamera,\r\n\t\tprogram, buffer, material,\r\n\t\twebglObject, object, light,\r\n\t\trenderList,\r\n\r\n\t\tlights = [],\r\n\t\tk = 0,\r\n\r\n\t\tfog = null;\r\n\r\n\t\t// set GL state for depth map\r\n\r\n\t\t_gl.clearColor( 1, 1, 1, 1 );\r\n\t\t_gl.disable( _gl.BLEND );\r\n\r\n\t\t_gl.enable( _gl.CULL_FACE );\r\n\t\t_gl.frontFace( _gl.CCW );\r\n\r\n\t\tif ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {\r\n\r\n\t\t\t_gl.cullFace( _gl.FRONT );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_gl.cullFace( _gl.BACK );\r\n\r\n\t\t}\r\n\r\n\t\t_renderer.setDepthTest( true );\r\n\r\n\t\t// preprocess lights\r\n\t\t// \t- skip lights that are not casting shadows\r\n\t\t//\t- create virtual lights for cascaded shadow maps\r\n\r\n\t\tfor ( i = 0, il = scene.__lights.length; i < il; i ++ ) {\r\n\r\n\t\t\tlight = scene.__lights[ i ];\r\n\r\n\t\t\tif ( ! light.castShadow ) continue;\r\n\r\n\t\t\tif ( ( light instanceof THREE.DirectionalLight ) && light.shadowCascade ) {\r\n\r\n\t\t\t\tfor ( n = 0; n < light.shadowCascadeCount; n ++ ) {\r\n\r\n\t\t\t\t\tvar virtualLight;\r\n\r\n\t\t\t\t\tif ( ! light.shadowCascadeArray[ n ] ) {\r\n\r\n\t\t\t\t\t\tvirtualLight = createVirtualLight( light, n );\r\n\t\t\t\t\t\tvirtualLight.originalCamera = camera;\r\n\r\n\t\t\t\t\t\tvar gyro = new THREE.Gyroscope();\r\n\t\t\t\t\t\tgyro.position = light.shadowCascadeOffset;\r\n\r\n\t\t\t\t\t\tgyro.add( virtualLight );\r\n\t\t\t\t\t\tgyro.add( virtualLight.target );\r\n\r\n\t\t\t\t\t\tcamera.add( gyro );\r\n\r\n\t\t\t\t\t\tlight.shadowCascadeArray[ n ] = virtualLight;\r\n\r\n\t\t\t\t\t\tconsole.log( \"Created virtualLight\", virtualLight );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tvirtualLight = light.shadowCascadeArray[ n ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tupdateVirtualLight( light, n );\r\n\r\n\t\t\t\t\tlights[ k ] = virtualLight;\r\n\t\t\t\t\tk ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tlights[ k ] = light;\r\n\t\t\t\tk ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// render depth map\r\n\r\n\t\tfor ( i = 0, il = lights.length; i < il; i ++ ) {\r\n\r\n\t\t\tlight = lights[ i ];\r\n\r\n\t\t\tif ( ! light.shadowMap ) {\r\n\r\n\t\t\t\tvar shadowFilter = THREE.LinearFilter;\r\n\r\n\t\t\t\tif ( _renderer.shadowMapType === THREE.PCFSoftShadowMap ) {\r\n\r\n\t\t\t\t\tshadowFilter = THREE.NearestFilter;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar pars = { minFilter: shadowFilter, magFilter: shadowFilter, format: THREE.RGBAFormat };\r\n\r\n\t\t\t\tlight.shadowMap = new THREE.WebGLRenderTarget( light.shadowMapWidth, light.shadowMapHeight, pars );\r\n\t\t\t\tlight.shadowMapSize = new THREE.Vector2( light.shadowMapWidth, light.shadowMapHeight );\r\n\r\n\t\t\t\tlight.shadowMatrix = new THREE.Matrix4();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! light.shadowCamera ) {\r\n\r\n\t\t\t\tif ( light instanceof THREE.SpotLight ) {\r\n\r\n\t\t\t\t\tlight.shadowCamera = new THREE.PerspectiveCamera( light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar );\r\n\r\n\t\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\r\n\r\n\t\t\t\t\tlight.shadowCamera = new THREE.OrthographicCamera( light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.error( \"Unsupported light type for shadow\" );\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tscene.add( light.shadowCamera );\r\n\r\n\t\t\t\tif ( _renderer.autoUpdateScene ) scene.updateMatrixWorld();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( light.shadowCameraVisible && ! light.cameraHelper ) {\r\n\r\n\t\t\t\tlight.cameraHelper = new THREE.CameraHelper( light.shadowCamera );\r\n\t\t\t\tlight.shadowCamera.add( light.cameraHelper );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( light.isVirtual && virtualLight.originalCamera == camera ) {\r\n\r\n\t\t\t\tupdateShadowCamera( camera, light );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tshadowMap = light.shadowMap;\r\n\t\t\tshadowMatrix = light.shadowMatrix;\r\n\t\t\tshadowCamera = light.shadowCamera;\r\n\r\n\t\t\tshadowCamera.position.getPositionFromMatrix( light.matrixWorld );\r\n\t\t\t_matrixPosition.getPositionFromMatrix( light.target.matrixWorld );\r\n\t\t\tshadowCamera.lookAt( _matrixPosition );\r\n\t\t\tshadowCamera.updateMatrixWorld();\r\n\r\n\t\t\tshadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );\r\n\r\n\t\t\tif ( light.cameraHelper ) light.cameraHelper.visible = light.shadowCameraVisible;\r\n\t\t\tif ( light.shadowCameraVisible ) light.cameraHelper.update();\r\n\r\n\t\t\t// compute shadow matrix\r\n\r\n\t\t\tshadowMatrix.set( 0.5, 0.0, 0.0, 0.5,\r\n\t\t\t\t\t\t\t  0.0, 0.5, 0.0, 0.5,\r\n\t\t\t\t\t\t\t  0.0, 0.0, 0.5, 0.5,\r\n\t\t\t\t\t\t\t  0.0, 0.0, 0.0, 1.0 );\r\n\r\n\t\t\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\r\n\t\t\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\r\n\r\n\t\t\t// update camera matrices and frustum\r\n\r\n\t\t\t_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\r\n\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\r\n\r\n\t\t\t// render shadow map\r\n\r\n\t\t\t_renderer.setRenderTarget( shadowMap );\r\n\t\t\t_renderer.clear();\r\n\r\n\t\t\t// set object matrices & frustum culling\r\n\r\n\t\t\trenderList = scene.__webglObjects;\r\n\r\n\t\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\twebglObject = renderList[ j ];\r\n\t\t\t\tobject = webglObject.object;\r\n\r\n\t\t\t\twebglObject.render = false;\r\n\r\n\t\t\t\tif ( object.visible && object.castShadow ) {\r\n\r\n\t\t\t\t\tif ( ! ( object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.intersectsObject( object ) ) {\r\n\r\n\t\t\t\t\t\tobject._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\r\n\r\n\t\t\t\t\t\twebglObject.render = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// render regular objects\r\n\r\n\t\t\tvar objectMaterial, useMorphing, useSkinning;\r\n\r\n\t\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\twebglObject = renderList[ j ];\r\n\r\n\t\t\t\tif ( webglObject.render ) {\r\n\r\n\t\t\t\t\tobject = webglObject.object;\r\n\t\t\t\t\tbuffer = webglObject.buffer;\r\n\r\n\t\t\t\t\t// culling is overriden globally for all objects\r\n\t\t\t\t\t// while rendering depth map\r\n\r\n\t\t\t\t\t// need to deal with MeshFaceMaterial somehow\r\n\t\t\t\t\t// in that case just use the first of material.materials for now\r\n\t\t\t\t\t// (proper solution would require to break objects by materials\r\n\t\t\t\t\t//  similarly to regular rendering and then set corresponding\r\n\t\t\t\t\t//  depth materials per each chunk instead of just once per object)\r\n\r\n\t\t\t\t\tobjectMaterial = getObjectMaterial( object );\r\n\r\n\t\t\t\t\tuseMorphing = object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;\r\n\t\t\t\t\tuseSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;\r\n\r\n\t\t\t\t\tif ( object.customDepthMaterial ) {\r\n\r\n\t\t\t\t\t\tmaterial = object.customDepthMaterial;\r\n\r\n\t\t\t\t\t} else if ( useSkinning ) {\r\n\r\n\t\t\t\t\t\tmaterial = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;\r\n\r\n\t\t\t\t\t} else if ( useMorphing ) {\r\n\r\n\t\t\t\t\t\tmaterial = _depthMaterialMorph;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tmaterial = _depthMaterial;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( buffer instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, scene.__lights, fog, material, buffer, object );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t_renderer.renderBuffer( shadowCamera, scene.__lights, fog, material, buffer, object );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// set matrices and render immediate objects\r\n\r\n\t\t\trenderList = scene.__webglObjectsImmediate;\r\n\r\n\t\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\twebglObject = renderList[ j ];\r\n\t\t\t\tobject = webglObject.object;\r\n\r\n\t\t\t\tif ( object.visible && object.castShadow ) {\r\n\r\n\t\t\t\t\tobject._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\r\n\r\n\t\t\t\t\t_renderer.renderImmediateObject( shadowCamera, scene.__lights, fog, _depthMaterial, object );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// restore GL state\r\n\r\n\t\tvar clearColor = _renderer.getClearColor(),\r\n\t\tclearAlpha = _renderer.getClearAlpha();\r\n\r\n\t\t_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );\r\n\t\t_gl.enable( _gl.BLEND );\r\n\r\n\t\tif ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {\r\n\r\n\t\t\t_gl.cullFace( _gl.BACK );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction createVirtualLight( light, cascade ) {\r\n\r\n\t\tvar virtualLight = new THREE.DirectionalLight();\r\n\r\n\t\tvirtualLight.isVirtual = true;\r\n\r\n\t\tvirtualLight.onlyShadow = true;\r\n\t\tvirtualLight.castShadow = true;\r\n\r\n\t\tvirtualLight.shadowCameraNear = light.shadowCameraNear;\r\n\t\tvirtualLight.shadowCameraFar = light.shadowCameraFar;\r\n\r\n\t\tvirtualLight.shadowCameraLeft = light.shadowCameraLeft;\r\n\t\tvirtualLight.shadowCameraRight = light.shadowCameraRight;\r\n\t\tvirtualLight.shadowCameraBottom = light.shadowCameraBottom;\r\n\t\tvirtualLight.shadowCameraTop = light.shadowCameraTop;\r\n\r\n\t\tvirtualLight.shadowCameraVisible = light.shadowCameraVisible;\r\n\r\n\t\tvirtualLight.shadowDarkness = light.shadowDarkness;\r\n\r\n\t\tvirtualLight.shadowBias = light.shadowCascadeBias[ cascade ];\r\n\t\tvirtualLight.shadowMapWidth = light.shadowCascadeWidth[ cascade ];\r\n\t\tvirtualLight.shadowMapHeight = light.shadowCascadeHeight[ cascade ];\r\n\r\n\t\tvirtualLight.pointsWorld = [];\r\n\t\tvirtualLight.pointsFrustum = [];\r\n\r\n\t\tvar pointsWorld = virtualLight.pointsWorld,\r\n\t\t\tpointsFrustum = virtualLight.pointsFrustum;\r\n\r\n\t\tfor ( var i = 0; i < 8; i ++ ) {\r\n\r\n\t\t\tpointsWorld[ i ] = new THREE.Vector3();\r\n\t\t\tpointsFrustum[ i ] = new THREE.Vector3();\r\n\r\n\t\t}\r\n\r\n\t\tvar nearZ = light.shadowCascadeNearZ[ cascade ];\r\n\t\tvar farZ = light.shadowCascadeFarZ[ cascade ];\r\n\r\n\t\tpointsFrustum[ 0 ].set( -1, -1, nearZ );\r\n\t\tpointsFrustum[ 1 ].set(  1, -1, nearZ );\r\n\t\tpointsFrustum[ 2 ].set( -1,  1, nearZ );\r\n\t\tpointsFrustum[ 3 ].set(  1,  1, nearZ );\r\n\r\n\t\tpointsFrustum[ 4 ].set( -1, -1, farZ );\r\n\t\tpointsFrustum[ 5 ].set(  1, -1, farZ );\r\n\t\tpointsFrustum[ 6 ].set( -1,  1, farZ );\r\n\t\tpointsFrustum[ 7 ].set(  1,  1, farZ );\r\n\r\n\t\treturn virtualLight;\r\n\r\n\t}\r\n\r\n\t// Synchronize virtual light with the original light\r\n\r\n\tfunction updateVirtualLight( light, cascade ) {\r\n\r\n\t\tvar virtualLight = light.shadowCascadeArray[ cascade ];\r\n\r\n\t\tvirtualLight.position.copy( light.position );\r\n\t\tvirtualLight.target.position.copy( light.target.position );\r\n\t\tvirtualLight.lookAt( virtualLight.target );\r\n\r\n\t\tvirtualLight.shadowCameraVisible = light.shadowCameraVisible;\r\n\t\tvirtualLight.shadowDarkness = light.shadowDarkness;\r\n\r\n\t\tvirtualLight.shadowBias = light.shadowCascadeBias[ cascade ];\r\n\r\n\t\tvar nearZ = light.shadowCascadeNearZ[ cascade ];\r\n\t\tvar farZ = light.shadowCascadeFarZ[ cascade ];\r\n\r\n\t\tvar pointsFrustum = virtualLight.pointsFrustum;\r\n\r\n\t\tpointsFrustum[ 0 ].z = nearZ;\r\n\t\tpointsFrustum[ 1 ].z = nearZ;\r\n\t\tpointsFrustum[ 2 ].z = nearZ;\r\n\t\tpointsFrustum[ 3 ].z = nearZ;\r\n\r\n\t\tpointsFrustum[ 4 ].z = farZ;\r\n\t\tpointsFrustum[ 5 ].z = farZ;\r\n\t\tpointsFrustum[ 6 ].z = farZ;\r\n\t\tpointsFrustum[ 7 ].z = farZ;\r\n\r\n\t}\r\n\r\n\t// Fit shadow camera's ortho frustum to camera frustum\r\n\r\n\tfunction updateShadowCamera( camera, light ) {\r\n\r\n\t\tvar shadowCamera = light.shadowCamera,\r\n\t\t\tpointsFrustum = light.pointsFrustum,\r\n\t\t\tpointsWorld = light.pointsWorld;\r\n\r\n\t\t_min.set( Infinity, Infinity, Infinity );\r\n\t\t_max.set( -Infinity, -Infinity, -Infinity );\r\n\r\n\t\tfor ( var i = 0; i < 8; i ++ ) {\r\n\r\n\t\t\tvar p = pointsWorld[ i ];\r\n\r\n\t\t\tp.copy( pointsFrustum[ i ] );\r\n\t\t\tTHREE.ShadowMapPlugin.__projector.unprojectVector( p, camera );\r\n\r\n\t\t\tp.applyMatrix4( shadowCamera.matrixWorldInverse );\r\n\r\n\t\t\tif ( p.x < _min.x ) _min.x = p.x;\r\n\t\t\tif ( p.x > _max.x ) _max.x = p.x;\r\n\r\n\t\t\tif ( p.y < _min.y ) _min.y = p.y;\r\n\t\t\tif ( p.y > _max.y ) _max.y = p.y;\r\n\r\n\t\t\tif ( p.z < _min.z ) _min.z = p.z;\r\n\t\t\tif ( p.z > _max.z ) _max.z = p.z;\r\n\r\n\t\t}\r\n\r\n\t\tshadowCamera.left = _min.x;\r\n\t\tshadowCamera.right = _max.x;\r\n\t\tshadowCamera.top = _max.y;\r\n\t\tshadowCamera.bottom = _min.y;\r\n\r\n\t\t// can't really fit near/far\r\n\t\t//shadowCamera.near = _min.z;\r\n\t\t//shadowCamera.far = _max.z;\r\n\r\n\t\tshadowCamera.updateProjectionMatrix();\r\n\r\n\t}\r\n\r\n\t// For the moment just ignore objects that have multiple materials with different animation methods\r\n\t// Only the first material will be taken into account for deciding which depth material to use for shadow maps\r\n\r\n\tfunction getObjectMaterial( object ) {\r\n\r\n\t\treturn object.material instanceof THREE.MeshFaceMaterial\r\n\t\t\t? object.material.materials[ 0 ]\r\n\t\t\t: object.material;\r\n\r\n\t};\r\n\r\n};\r\n\r\nTHREE.ShadowMapPlugin.__projector = new THREE.Projector();\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.SpritePlugin = function () {\r\n\r\n\tvar _gl, _renderer, _precision, _sprite = {};\r\n\r\n\tthis.init = function ( renderer ) {\r\n\r\n\t\t_gl = renderer.context;\r\n\t\t_renderer = renderer;\r\n\r\n\t\t_precision = renderer.getPrecision();\r\n\r\n\t\t_sprite.vertices = new Float32Array( 8 + 8 );\r\n\t\t_sprite.faces    = new Uint16Array( 6 );\r\n\r\n\t\tvar i = 0;\r\n\r\n\t\t_sprite.vertices[ i++ ] = -1; _sprite.vertices[ i++ ] = -1;\t// vertex 0\r\n\t\t_sprite.vertices[ i++ ] = 0;  _sprite.vertices[ i++ ] = 0;\t// uv 0\r\n\r\n\t\t_sprite.vertices[ i++ ] = 1;  _sprite.vertices[ i++ ] = -1;\t// vertex 1\r\n\t\t_sprite.vertices[ i++ ] = 1;  _sprite.vertices[ i++ ] = 0;\t// uv 1\r\n\r\n\t\t_sprite.vertices[ i++ ] = 1;  _sprite.vertices[ i++ ] = 1;\t// vertex 2\r\n\t\t_sprite.vertices[ i++ ] = 1;  _sprite.vertices[ i++ ] = 1;\t// uv 2\r\n\r\n\t\t_sprite.vertices[ i++ ] = -1; _sprite.vertices[ i++ ] = 1;\t// vertex 3\r\n\t\t_sprite.vertices[ i++ ] = 0;  _sprite.vertices[ i++ ] = 1;\t// uv 3\r\n\r\n\t\ti = 0;\r\n\r\n\t\t_sprite.faces[ i++ ] = 0; _sprite.faces[ i++ ] = 1; _sprite.faces[ i++ ] = 2;\r\n\t\t_sprite.faces[ i++ ] = 0; _sprite.faces[ i++ ] = 2; _sprite.faces[ i++ ] = 3;\r\n\r\n\t\t_sprite.vertexBuffer  = _gl.createBuffer();\r\n\t\t_sprite.elementBuffer = _gl.createBuffer();\r\n\r\n\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, _sprite.vertexBuffer );\r\n\t\t_gl.bufferData( _gl.ARRAY_BUFFER, _sprite.vertices, _gl.STATIC_DRAW );\r\n\r\n\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _sprite.elementBuffer );\r\n\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, _sprite.faces, _gl.STATIC_DRAW );\r\n\r\n\t\t_sprite.program = createProgram( THREE.ShaderSprite[ \"sprite\" ], _precision );\r\n\r\n\t\t_sprite.attributes = {};\r\n\t\t_sprite.uniforms = {};\r\n\r\n\t\t_sprite.attributes.position           = _gl.getAttribLocation ( _sprite.program, \"position\" );\r\n\t\t_sprite.attributes.uv                 = _gl.getAttribLocation ( _sprite.program, \"uv\" );\r\n\r\n\t\t_sprite.uniforms.uvOffset             = _gl.getUniformLocation( _sprite.program, \"uvOffset\" );\r\n\t\t_sprite.uniforms.uvScale              = _gl.getUniformLocation( _sprite.program, \"uvScale\" );\r\n\r\n\t\t_sprite.uniforms.rotation             = _gl.getUniformLocation( _sprite.program, \"rotation\" );\r\n\t\t_sprite.uniforms.scale                = _gl.getUniformLocation( _sprite.program, \"scale\" );\r\n\t\t_sprite.uniforms.alignment            = _gl.getUniformLocation( _sprite.program, \"alignment\" );\r\n\r\n\t\t_sprite.uniforms.color                = _gl.getUniformLocation( _sprite.program, \"color\" );\r\n\t\t_sprite.uniforms.map                  = _gl.getUniformLocation( _sprite.program, \"map\" );\r\n\t\t_sprite.uniforms.opacity              = _gl.getUniformLocation( _sprite.program, \"opacity\" );\r\n\r\n\t\t_sprite.uniforms.useScreenCoordinates = _gl.getUniformLocation( _sprite.program, \"useScreenCoordinates\" );\r\n\t\t_sprite.uniforms.sizeAttenuation   \t  = _gl.getUniformLocation( _sprite.program, \"sizeAttenuation\" );\r\n\t\t_sprite.uniforms.screenPosition    \t  = _gl.getUniformLocation( _sprite.program, \"screenPosition\" );\r\n\t\t_sprite.uniforms.modelViewMatrix      = _gl.getUniformLocation( _sprite.program, \"modelViewMatrix\" );\r\n\t\t_sprite.uniforms.projectionMatrix     = _gl.getUniformLocation( _sprite.program, \"projectionMatrix\" );\r\n\r\n\t\t_sprite.uniforms.fogType \t\t  \t  = _gl.getUniformLocation( _sprite.program, \"fogType\" );\r\n\t\t_sprite.uniforms.fogDensity \t\t  = _gl.getUniformLocation( _sprite.program, \"fogDensity\" );\r\n\t\t_sprite.uniforms.fogNear \t\t  \t  = _gl.getUniformLocation( _sprite.program, \"fogNear\" );\r\n\t\t_sprite.uniforms.fogFar \t\t  \t  = _gl.getUniformLocation( _sprite.program, \"fogFar\" );\r\n\t\t_sprite.uniforms.fogColor \t\t  \t  = _gl.getUniformLocation( _sprite.program, \"fogColor\" );\r\n\r\n\t\t_sprite.uniforms.alphaTest \t\t  \t  = _gl.getUniformLocation( _sprite.program, \"alphaTest\" );\r\n\r\n\t};\r\n\r\n\tthis.render = function ( scene, camera, viewportWidth, viewportHeight ) {\r\n\r\n\t\tvar sprites = scene.__webglSprites,\r\n\t\t\tnSprites = sprites.length;\r\n\r\n\t\tif ( ! nSprites ) return;\r\n\r\n\t\tvar attributes = _sprite.attributes,\r\n\t\t\tuniforms = _sprite.uniforms;\r\n\r\n\t\tvar invAspect = viewportHeight / viewportWidth;\r\n\r\n\t\tvar halfViewportWidth = viewportWidth * 0.5,\r\n\t\t\thalfViewportHeight = viewportHeight * 0.5;\r\n\r\n\t\t// setup gl\r\n\r\n\t\t_gl.useProgram( _sprite.program );\r\n\r\n\t\t_gl.enableVertexAttribArray( attributes.position );\r\n\t\t_gl.enableVertexAttribArray( attributes.uv );\r\n\r\n\t\t_gl.disable( _gl.CULL_FACE );\r\n\t\t_gl.enable( _gl.BLEND );\r\n\r\n\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, _sprite.vertexBuffer );\r\n\t\t_gl.vertexAttribPointer( attributes.position, 2, _gl.FLOAT, false, 2 * 8, 0 );\r\n\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 2 * 8, 8 );\r\n\r\n\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _sprite.elementBuffer );\r\n\r\n\t\t_gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\r\n\r\n\t\t_gl.activeTexture( _gl.TEXTURE0 );\r\n\t\t_gl.uniform1i( uniforms.map, 0 );\r\n\r\n\t\tvar oldFogType = 0;\r\n\t\tvar sceneFogType = 0;\r\n\t\tvar fog = scene.fog;\r\n\r\n\t\tif ( fog ) {\r\n\r\n\t\t\t_gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );\r\n\r\n\t\t\tif ( fog instanceof THREE.Fog ) {\r\n\r\n\t\t\t\t_gl.uniform1f( uniforms.fogNear, fog.near );\r\n\t\t\t\t_gl.uniform1f( uniforms.fogFar, fog.far );\r\n\r\n\t\t\t\t_gl.uniform1i( uniforms.fogType, 1 );\r\n\t\t\t\toldFogType = 1;\r\n\t\t\t\tsceneFogType = 1;\r\n\r\n\t\t\t} else if ( fog instanceof THREE.FogExp2 ) {\r\n\r\n\t\t\t\t_gl.uniform1f( uniforms.fogDensity, fog.density );\r\n\r\n\t\t\t\t_gl.uniform1i( uniforms.fogType, 2 );\r\n\t\t\t\toldFogType = 2;\r\n\t\t\t\tsceneFogType = 2;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_gl.uniform1i( uniforms.fogType, 0 );\r\n\t\t\toldFogType = 0;\r\n\t\t\tsceneFogType = 0;\r\n\r\n\t\t}\r\n\r\n\r\n\t\t// update positions and sort\r\n\r\n\t\tvar i, sprite, material, screenPosition, size, fogType, scale = [];\r\n\r\n\t\tfor( i = 0; i < nSprites; i ++ ) {\r\n\r\n\t\t\tsprite = sprites[ i ];\r\n\t\t\tmaterial = sprite.material;\r\n\r\n\t\t\tif ( ! sprite.visible || material.opacity === 0 ) continue;\r\n\r\n\t\t\tif ( ! material.useScreenCoordinates ) {\r\n\r\n\t\t\t\tsprite._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );\r\n\t\t\t\tsprite.z = - sprite._modelViewMatrix.elements[ 14 ];\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tsprite.z = - sprite.position.z;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tsprites.sort( painterSortStable );\r\n\r\n\t\t// render all sprites\r\n\r\n\t\tfor( i = 0; i < nSprites; i ++ ) {\r\n\r\n\t\t\tsprite = sprites[ i ];\r\n\t\t\tmaterial = sprite.material;\r\n\r\n\t\t\tif ( ! sprite.visible || material.opacity === 0 ) continue;\r\n\r\n\t\t\tif ( material.map && material.map.image && material.map.image.width ) {\r\n\r\n\t\t\t\t_gl.uniform1f( uniforms.alphaTest, material.alphaTest );\r\n\r\n\t\t\t\tif ( material.useScreenCoordinates === true ) {\r\n\r\n\t\t\t\t\t_gl.uniform1i( uniforms.useScreenCoordinates, 1 );\r\n\t\t\t\t\t_gl.uniform3f(\r\n\t\t\t\t\t\tuniforms.screenPosition,\r\n\t\t\t\t\t\t( ( sprite.position.x * _renderer.devicePixelRatio ) - halfViewportWidth  ) / halfViewportWidth,\r\n\t\t\t\t\t\t( halfViewportHeight - ( sprite.position.y * _renderer.devicePixelRatio ) ) / halfViewportHeight,\r\n\t\t\t\t\t\tMath.max( 0, Math.min( 1, sprite.position.z ) )\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\tscale[ 0 ] = _renderer.devicePixelRatio;\r\n\t\t\t\t\tscale[ 1 ] = _renderer.devicePixelRatio;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t_gl.uniform1i( uniforms.useScreenCoordinates, 0 );\r\n\t\t\t\t\t_gl.uniform1i( uniforms.sizeAttenuation, material.sizeAttenuation ? 1 : 0 );\r\n\t\t\t\t\t_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite._modelViewMatrix.elements );\r\n\r\n\t\t\t\t\tscale[ 0 ] = 1;\r\n\t\t\t\t\tscale[ 1 ] = 1;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( scene.fog && material.fog ) {\r\n\r\n\t\t\t\t\tfogType = sceneFogType;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tfogType = 0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( oldFogType !== fogType ) {\r\n\r\n\t\t\t\t\t_gl.uniform1i( uniforms.fogType, fogType );\r\n\t\t\t\t\toldFogType = fogType;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tsize = 1 / ( material.scaleByViewport ? viewportHeight : 1 );\r\n\r\n\t\t\t\tscale[ 0 ] *= size * invAspect * sprite.scale.x\r\n\t\t\t\tscale[ 1 ] *= size * sprite.scale.y;\r\n\r\n\t\t\t\t_gl.uniform2f( uniforms.uvScale, material.uvScale.x, material.uvScale.y );\r\n\t\t\t\t_gl.uniform2f( uniforms.uvOffset, material.uvOffset.x, material.uvOffset.y );\r\n\t\t\t\t_gl.uniform2f( uniforms.alignment, material.alignment.x, material.alignment.y );\r\n\r\n\t\t\t\t_gl.uniform1f( uniforms.opacity, material.opacity );\r\n\t\t\t\t_gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );\r\n\r\n\t\t\t\t_gl.uniform1f( uniforms.rotation, sprite.rotation );\r\n\t\t\t\t_gl.uniform2fv( uniforms.scale, scale );\r\n\r\n\t\t\t\t_renderer.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\r\n\t\t\t\t_renderer.setDepthTest( material.depthTest );\r\n\t\t\t\t_renderer.setDepthWrite( material.depthWrite );\r\n\t\t\t\t_renderer.setTexture( material.map, 0 );\r\n\r\n\t\t\t\t_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// restore gl\r\n\r\n\t\t_gl.enable( _gl.CULL_FACE );\r\n\r\n\t};\r\n\r\n\tfunction createProgram ( shader, precision ) {\r\n\r\n\t\tvar program = _gl.createProgram();\r\n\r\n\t\tvar fragmentShader = _gl.createShader( _gl.FRAGMENT_SHADER );\r\n\t\tvar vertexShader = _gl.createShader( _gl.VERTEX_SHADER );\r\n\r\n\t\tvar prefix = \"precision \" + precision + \" float;\\n\";\r\n\r\n\t\t_gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\r\n\t\t_gl.shaderSource( vertexShader, prefix + shader.vertexShader );\r\n\r\n\t\t_gl.compileShader( fragmentShader );\r\n\t\t_gl.compileShader( vertexShader );\r\n\r\n\t\t_gl.attachShader( program, fragmentShader );\r\n\t\t_gl.attachShader( program, vertexShader );\r\n\r\n\t\t_gl.linkProgram( program );\r\n\r\n\t\treturn program;\r\n\r\n\t};\r\n\r\n\tfunction painterSortStable ( a, b ) {\r\n\r\n\t\tif ( a.z !== b.z ) {\r\n\r\n\t\t\treturn b.z - a.z;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn b.id - a.id;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n};\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.DepthPassPlugin = function () {\r\n\r\n\tthis.enabled = false;\r\n\tthis.renderTarget = null;\r\n\r\n\tvar _gl,\r\n\t_renderer,\r\n\t_depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin,\r\n\r\n\t_frustum = new THREE.Frustum(),\r\n\t_projScreenMatrix = new THREE.Matrix4();\r\n\r\n\tthis.init = function ( renderer ) {\r\n\r\n\t\t_gl = renderer.context;\r\n\t\t_renderer = renderer;\r\n\r\n\t\tvar depthShader = THREE.ShaderLib[ \"depthRGBA\" ];\r\n\t\tvar depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );\r\n\r\n\t\t_depthMaterial = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms } );\r\n\t\t_depthMaterialMorph = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true } );\r\n\t\t_depthMaterialSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, skinning: true } );\r\n\t\t_depthMaterialMorphSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true, skinning: true } );\r\n\r\n\t\t_depthMaterial._shadowPass = true;\r\n\t\t_depthMaterialMorph._shadowPass = true;\r\n\t\t_depthMaterialSkin._shadowPass = true;\r\n\t\t_depthMaterialMorphSkin._shadowPass = true;\r\n\r\n\t};\r\n\r\n\tthis.render = function ( scene, camera ) {\r\n\r\n\t\tif ( ! this.enabled ) return;\r\n\r\n\t\tthis.update( scene, camera );\r\n\r\n\t};\r\n\r\n\tthis.update = function ( scene, camera ) {\r\n\r\n\t\tvar i, il, j, jl, n,\r\n\r\n\t\tprogram, buffer, material,\r\n\t\twebglObject, object, light,\r\n\t\trenderList,\r\n\r\n\t\tfog = null;\r\n\r\n\t\t// set GL state for depth map\r\n\r\n\t\t_gl.clearColor( 1, 1, 1, 1 );\r\n\t\t_gl.disable( _gl.BLEND );\r\n\r\n\t\t_renderer.setDepthTest( true );\r\n\r\n\t\t// update scene\r\n\r\n\t\tif ( _renderer.autoUpdateScene ) scene.updateMatrixWorld();\r\n\r\n\t\t// update camera matrices and frustum\r\n\r\n\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\r\n\r\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\r\n\t\t_frustum.setFromMatrix( _projScreenMatrix );\r\n\r\n\t\t// render depth map\r\n\r\n\t\t_renderer.setRenderTarget( this.renderTarget );\r\n\t\t_renderer.clear();\r\n\r\n\t\t// set object matrices & frustum culling\r\n\r\n\t\trenderList = scene.__webglObjects;\r\n\r\n\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\r\n\r\n\t\t\twebglObject = renderList[ j ];\r\n\t\t\tobject = webglObject.object;\r\n\r\n\t\t\twebglObject.render = false;\r\n\r\n\t\t\tif ( object.visible ) {\r\n\r\n\t\t\t\tif ( ! ( object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.intersectsObject( object ) ) {\r\n\r\n\t\t\t\t\tobject._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\r\n\r\n\t\t\t\t\twebglObject.render = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// render regular objects\r\n\r\n\t\tvar objectMaterial, useMorphing, useSkinning;\r\n\r\n\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\r\n\r\n\t\t\twebglObject = renderList[ j ];\r\n\r\n\t\t\tif ( webglObject.render ) {\r\n\r\n\t\t\t\tobject = webglObject.object;\r\n\t\t\t\tbuffer = webglObject.buffer;\r\n\r\n\t\t\t\t// todo: create proper depth material for particles\r\n\r\n\t\t\t\tif ( object instanceof THREE.ParticleSystem && !object.customDepthMaterial ) continue;\r\n\r\n\t\t\t\tobjectMaterial = getObjectMaterial( object );\r\n\r\n\t\t\t\tif ( objectMaterial ) _renderer.setMaterialFaces( object.material );\r\n\r\n\t\t\t\tuseMorphing = object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;\r\n\t\t\t\tuseSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;\r\n\r\n\t\t\t\tif ( object.customDepthMaterial ) {\r\n\r\n\t\t\t\t\tmaterial = object.customDepthMaterial;\r\n\r\n\t\t\t\t} else if ( useSkinning ) {\r\n\r\n\t\t\t\t\tmaterial = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;\r\n\r\n\t\t\t\t} else if ( useMorphing ) {\r\n\r\n\t\t\t\t\tmaterial = _depthMaterialMorph;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tmaterial = _depthMaterial;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( buffer instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\t\t\t_renderer.renderBufferDirect( camera, scene.__lights, fog, material, buffer, object );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t_renderer.renderBuffer( camera, scene.__lights, fog, material, buffer, object );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// set matrices and render immediate objects\r\n\r\n\t\trenderList = scene.__webglObjectsImmediate;\r\n\r\n\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\r\n\r\n\t\t\twebglObject = renderList[ j ];\r\n\t\t\tobject = webglObject.object;\r\n\r\n\t\t\tif ( object.visible ) {\r\n\r\n\t\t\t\tobject._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\r\n\r\n\t\t\t\t_renderer.renderImmediateObject( camera, scene.__lights, fog, _depthMaterial, object );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// restore GL state\r\n\r\n\t\tvar clearColor = _renderer.getClearColor(),\r\n\t\tclearAlpha = _renderer.getClearAlpha();\r\n\r\n\t\t_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );\r\n\t\t_gl.enable( _gl.BLEND );\r\n\r\n\t};\r\n\r\n\t// For the moment just ignore objects that have multiple materials with different animation methods\r\n\t// Only the first material will be taken into account for deciding which depth material to use\r\n\r\n\tfunction getObjectMaterial( object ) {\r\n\r\n\t\treturn object.material instanceof THREE.MeshFaceMaterial\r\n\t\t\t? object.material.materials[ 0 ]\r\n\t\t\t: object.material;\r\n\r\n\t};\r\n\r\n};\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n *\r\n */\r\n\r\nTHREE.ShaderFlares = {\r\n\r\n\t'lensFlareVertexTexture': {\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"uniform lowp int renderType;\",\r\n\r\n\t\t\t\"uniform vec3 screenPosition;\",\r\n\t\t\t\"uniform vec2 scale;\",\r\n\t\t\t\"uniform float rotation;\",\r\n\r\n\t\t\t\"uniform sampler2D occlusionMap;\",\r\n\r\n\t\t\t\"attribute vec2 position;\",\r\n\t\t\t\"attribute vec2 uv;\",\r\n\r\n\t\t\t\"varying vec2 vUV;\",\r\n\t\t\t\"varying float vVisibility;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vUV = uv;\",\r\n\r\n\t\t\t\t\"vec2 pos = position;\",\r\n\r\n\t\t\t\t\"if( renderType == 2 ) {\",\r\n\r\n\t\t\t\t\t\"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) ) +\",\r\n\t\t\t\t\t\t\t\t\t  \"texture2D( occlusionMap, vec2( 0.5, 0.1 ) ) +\",\r\n\t\t\t\t\t\t\t\t\t  \"texture2D( occlusionMap, vec2( 0.9, 0.1 ) ) +\",\r\n\t\t\t\t\t\t\t\t\t  \"texture2D( occlusionMap, vec2( 0.9, 0.5 ) ) +\",\r\n\t\t\t\t\t\t\t\t\t  \"texture2D( occlusionMap, vec2( 0.9, 0.9 ) ) +\",\r\n\t\t\t\t\t\t\t\t\t  \"texture2D( occlusionMap, vec2( 0.5, 0.9 ) ) +\",\r\n\t\t\t\t\t\t\t\t\t  \"texture2D( occlusionMap, vec2( 0.1, 0.9 ) ) +\",\r\n\t\t\t\t\t\t\t\t\t  \"texture2D( occlusionMap, vec2( 0.1, 0.5 ) ) +\",\r\n\t\t\t\t\t\t\t\t\t  \"texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\",\r\n\r\n\t\t\t\t\t\"vVisibility = (       visibility.r / 9.0 ) *\",\r\n\t\t\t\t\t\t\t\t  \"( 1.0 - visibility.g / 9.0 ) *\",\r\n\t\t\t\t\t\t\t\t  \"(       visibility.b / 9.0 ) *\",\r\n\t\t\t\t\t\t\t\t  \"( 1.0 - visibility.a / 9.0 );\",\r\n\r\n\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\r\n\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" ),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform lowp int renderType;\",\r\n\r\n\t\t\t\"uniform sampler2D map;\",\r\n\t\t\t\"uniform float opacity;\",\r\n\t\t\t\"uniform vec3 color;\",\r\n\r\n\t\t\t\"varying vec2 vUV;\",\r\n\t\t\t\"varying float vVisibility;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t// pink square\r\n\r\n\t\t\t\t\"if( renderType == 0 ) {\",\r\n\r\n\t\t\t\t\t\"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\",\r\n\r\n\t\t\t\t// restore\r\n\r\n\t\t\t\t\"} else if( renderType == 1 ) {\",\r\n\r\n\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\r\n\r\n\t\t\t\t// flare\r\n\r\n\t\t\t\t\"} else {\",\r\n\r\n\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\r\n\t\t\t\t\t\"texture.a *= opacity * vVisibility;\",\r\n\t\t\t\t\t\"gl_FragColor = texture;\",\r\n\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\"}\"\r\n\t\t].join( \"\\n\" )\r\n\r\n\t},\r\n\r\n\r\n\t'lensFlare': {\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"uniform lowp int renderType;\",\r\n\r\n\t\t\t\"uniform vec3 screenPosition;\",\r\n\t\t\t\"uniform vec2 scale;\",\r\n\t\t\t\"uniform float rotation;\",\r\n\r\n\t\t\t\"attribute vec2 position;\",\r\n\t\t\t\"attribute vec2 uv;\",\r\n\r\n\t\t\t\"varying vec2 vUV;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vUV = uv;\",\r\n\r\n\t\t\t\t\"vec2 pos = position;\",\r\n\r\n\t\t\t\t\"if( renderType == 2 ) {\",\r\n\r\n\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\r\n\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" ),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"precision mediump float;\",\r\n\r\n\t\t\t\"uniform lowp int renderType;\",\r\n\r\n\t\t\t\"uniform sampler2D map;\",\r\n\t\t\t\"uniform sampler2D occlusionMap;\",\r\n\t\t\t\"uniform float opacity;\",\r\n\t\t\t\"uniform vec3 color;\",\r\n\r\n\t\t\t\"varying vec2 vUV;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t// pink square\r\n\r\n\t\t\t\t\"if( renderType == 0 ) {\",\r\n\r\n\t\t\t\t\t\"gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\",\r\n\r\n\t\t\t\t// restore\r\n\r\n\t\t\t\t\"} else if( renderType == 1 ) {\",\r\n\r\n\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\r\n\r\n\t\t\t\t// flare\r\n\r\n\t\t\t\t\"} else {\",\r\n\r\n\t\t\t\t\t\"float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a +\",\r\n\t\t\t\t\t\t\t\t\t   \"texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a +\",\r\n\t\t\t\t\t\t\t\t\t   \"texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a +\",\r\n\t\t\t\t\t\t\t\t\t   \"texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\",\r\n\r\n\t\t\t\t\t\"visibility = ( 1.0 - visibility / 4.0 );\",\r\n\r\n\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\r\n\t\t\t\t\t\"texture.a *= opacity * visibility;\",\r\n\t\t\t\t\t\"gl_FragColor = texture;\",\r\n\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" )\r\n\r\n\t}\r\n\r\n};\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n */\r\n\r\nTHREE.ShaderSprite = {\r\n\r\n\t'sprite': {\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"uniform int useScreenCoordinates;\",\r\n\t\t\t\"uniform int sizeAttenuation;\",\r\n\t\t\t\"uniform vec3 screenPosition;\",\r\n\t\t\t\"uniform mat4 modelViewMatrix;\",\r\n\t\t\t\"uniform mat4 projectionMatrix;\",\r\n\t\t\t\"uniform float rotation;\",\r\n\t\t\t\"uniform vec2 scale;\",\r\n\t\t\t\"uniform vec2 alignment;\",\r\n\t\t\t\"uniform vec2 uvOffset;\",\r\n\t\t\t\"uniform vec2 uvScale;\",\r\n\r\n\t\t\t\"attribute vec2 position;\",\r\n\t\t\t\"attribute vec2 uv;\",\r\n\r\n\t\t\t\"varying vec2 vUV;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vUV = uvOffset + uv * uvScale;\",\r\n\r\n\t\t\t\t\"vec2 alignedPosition = position + alignment;\",\r\n\r\n\t\t\t\t\"vec2 rotatedPosition;\",\r\n\t\t\t\t\"rotatedPosition.x = ( cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y ) * scale.x;\",\r\n\t\t\t\t\"rotatedPosition.y = ( sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y ) * scale.y;\",\r\n\r\n\t\t\t\t\"vec4 finalPosition;\",\r\n\r\n\t\t\t\t\"if( useScreenCoordinates != 0 ) {\",\r\n\r\n\t\t\t\t\t\"finalPosition = vec4( screenPosition.xy + rotatedPosition, screenPosition.z, 1.0 );\",\r\n\r\n\t\t\t\t\"} else {\",\r\n\r\n\t\t\t\t\t\"finalPosition = projectionMatrix * modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\",\r\n\t\t\t\t\t\"finalPosition.xy += rotatedPosition * ( sizeAttenuation == 1 ? 1.0 : finalPosition.z );\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"gl_Position = finalPosition;\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" ),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform vec3 color;\",\r\n\t\t\t\"uniform sampler2D map;\",\r\n\t\t\t\"uniform float opacity;\",\r\n\r\n\t\t\t\"uniform int fogType;\",\r\n\t\t\t\"uniform vec3 fogColor;\",\r\n\t\t\t\"uniform float fogDensity;\",\r\n\t\t\t\"uniform float fogNear;\",\r\n\t\t\t\"uniform float fogFar;\",\r\n\t\t\t\"uniform float alphaTest;\",\r\n\r\n\t\t\t\"varying vec2 vUV;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\r\n\r\n\t\t\t\t\"if ( texture.a < alphaTest ) discard;\",\r\n\r\n\t\t\t\t\"gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\",\r\n\r\n\t\t\t\t\"if ( fogType > 0 ) {\",\r\n\r\n\t\t\t\t\t\"float depth = gl_FragCoord.z / gl_FragCoord.w;\",\r\n\t\t\t\t\t\"float fogFactor = 0.0;\",\r\n\r\n\t\t\t\t\t\"if ( fogType == 1 ) {\",\r\n\r\n\t\t\t\t\t\t\"fogFactor = smoothstep( fogNear, fogFar, depth );\",\r\n\r\n\t\t\t\t\t\"} else {\",\r\n\r\n\t\t\t\t\t\t\"const float LOG2 = 1.442695;\",\r\n\t\t\t\t\t\t\"float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\",\r\n\t\t\t\t\t\t\"fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\",\r\n\r\n\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\t\"gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" )\r\n\r\n\t}\r\n\r\n};\r\n\r\n// Export the THREE object for **Node.js**, with\r\n// backwards-compatibility for the old `require()` API. If we're in\r\n// the browser, add `_` as a global object via a string identifier,\r\n// for Closure Compiler \"advanced\" mode.\r\nif (typeof exports !== 'undefined') {\r\n  if (typeof module !== 'undefined' && module.exports) {\r\n    exports = module.exports = THREE;\r\n  }\r\n  exports.THREE = THREE;\r\n} else {\r\n  this['THREE'] = THREE;\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/dmillet/Projects/fpt/fpt/~/three/three.js\n ** module id = 28\n ** module chunks = 0 1 2\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/process/browser.js\n ** module id = 29\n ** module chunks = 0 1 2\n **/","\nimport THREE from 'three';\nimport voxelMesh from 'voxel-mesh';\nimport Texture from 'voxel-texture';\nimport voxel from 'voxel';\n\nexport default class TerrainView {\n\n\tstatic create(terrain) {\n\t\treturn new TerrainView(terrain);\n\t}\n\n\tconstructor(terrain) {\n\t\tthis.terrain = terrain;\n\t\tthis.three = new THREE.Object3D();\n\t\tthis.materials = new Texture({\n\t\t\tgame: {\n\t\t\t\tTHREE: THREE\n\t\t\t},\n\t\t\ttexturePath: '/client/textures/',\n\t\t\tmaterialType:  THREE.MeshLambertMaterial,\n\t\t\tmaterialParams: {},\n\t\t\tmaterialFlatColor: false\n\t\t});\n\n\t\tthis.materialNames = [['grass', 'dirt', 'grass_dirt'], 'brick', 'dirt', 'obsidian', 'plank', 'shama', 'whitewool'];\n\t\tthis.materials.load(this.materialNames);\n\n\t\tthis.showAllChunks();\n\t}\n\n\tshowChunkAtPosition(pos) {\n\t\tlet voxels = this.terrain.get('voxels'),\n\t\t\tchunkID = voxels.chunkAtPosition(pos).join('|'),\n\t\t\tchunk = voxels.chunks[chunkID];\n\t\tthis.showChunk(chunk);\n\t}\n\n\tshowAllChunks() {\n\t\tlet chunks = this.terrain.get('voxels').chunks;\n\t\tfor (var chunkIndex in chunks) {\n\t\t\tthis.showChunk(chunks[chunkIndex]);\n\t\t}\n\t}\n\n\tshowChunk(chunk) {\n\t\tvar chunkIndex = chunk.position.join('|');\n\n\t\tlet voxels = this.terrain.get('voxels'),\n\t\t\tbounds = voxels.getBounds.apply(this.voxels, chunk.position),\n\t\t\tscale = new THREE.Vector3(1, 1, 1),\n\t\t\tmesher = voxel.meshers.culled,\n\t\t\tmesh = voxelMesh(chunk, mesher, scale, THREE);\n\t\tvoxels.chunks[chunkIndex] = chunk;\n\t\tif (voxels.meshes[chunkIndex]) {\n\t\t\tif (voxels.meshes[chunkIndex].surfaceMesh) {\n\t\t\t\tthis.three.remove(voxels.meshes[chunkIndex].surfaceMesh);\n\t\t\t}\n\t\t\tif (voxels.meshes[chunkIndex].wireMesh) {\n\t\t\t\tthis.three.remove(voxels.meshes[chunkIndex].wireMesh);\n\t\t\t}\n\t\t}\n\t\tvoxels.meshes[chunkIndex] = mesh;\n\n\t\tif (this.meshType === 'wireMesh') {\n\t\t\tmesh.createWireMesh(0x111111);\n\t\t} else {\n\t\t\tmesh.createSurfaceMesh(this.materials.material);\n\t\t\tmesh.surfaceMesh.castShadow = mesh.surfaceMesh.receiveShadow = true;\n\t\t}\n\n\t\tthis.materials.paint(mesh);\n\n\t\tmesh.setPosition(bounds[0][0]*32, bounds[0][1]*32, bounds[0][2]*32);\n\n\t\tmesh.addToScene(this.three);\n\n\t\treturn mesh;\n\t}\n};\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./view/TerrainView.js\n **/","var THREE = require('three')\n\nmodule.exports = function(data, mesher, scaleFactor, three) {\n  return new Mesh(data, mesher, scaleFactor, three)\n}\n\nmodule.exports.Mesh = Mesh\n\nfunction Mesh(data, mesher, scaleFactor, three) {\n  this.THREE = three || THREE\n  this.data = data\n  var geometry = this.geometry = new this.THREE.Geometry()\n  this.scale = scaleFactor || new this.THREE.Vector3(10, 10, 10)\n  \n  var result = mesher( data.voxels, data.dims )\n  this.meshed = result\n\n  geometry.vertices.length = 0\n  geometry.faces.length = 0\n\n  for (var i = 0; i < result.vertices.length; ++i) {\n    var q = result.vertices[i]\n    geometry.vertices.push(new this.THREE.Vector3(q[0], q[1], q[2]))\n  } \n  \n  for (var i = 0; i < result.faces.length; ++i) {\n    geometry.faceVertexUvs[0].push(this.faceVertexUv(i))\n    \n    var q = result.faces[i]\n    if (q.length === 5) {\n      var f = new this.THREE.Face4(q[0], q[1], q[2], q[3])\n      f.color = new this.THREE.Color(q[4])\n      geometry.faces.push(f)\n    } else if (q.length == 4) {\n      var f = new this.THREE.Face3(q[0], q[1], q[2])\n      f.color = new this.THREE.Color(q[3])\n      geometry.faces.push(f)\n    }\n  }\n  \n  geometry.computeFaceNormals()\n\n  geometry.verticesNeedUpdate = true\n  geometry.elementsNeedUpdate = true\n  geometry.normalsNeedUpdate = true\n\n  geometry.computeBoundingBox()\n  geometry.computeBoundingSphere()\n\n}\n\nMesh.prototype.createWireMesh = function(hexColor) {    \n  var wireMaterial = new this.THREE.MeshBasicMaterial({\n    color : hexColor || 0xffffff,\n    wireframe : true\n  })\n  wireMesh = new this.THREE.Mesh(this.geometry, wireMaterial)\n  wireMesh.scale = this.scale\n  wireMesh.doubleSided = true\n  this.wireMesh = wireMesh\n  return wireMesh\n}\n\nMesh.prototype.createSurfaceMesh = function(material) {\n  material = material || new this.THREE.MeshNormalMaterial()\n  var surfaceMesh  = new this.THREE.Mesh( this.geometry, material )\n  surfaceMesh.scale = this.scale\n  surfaceMesh.doubleSided = false\n  this.surfaceMesh = surfaceMesh\n  return surfaceMesh\n}\n\nMesh.prototype.addToScene = function(scene) {\n  if (this.wireMesh) scene.add( this.wireMesh )\n  if (this.surfaceMesh) scene.add( this.surfaceMesh )\n}\n\nMesh.prototype.setPosition = function(x, y, z) {\n  if (this.wireMesh) this.wireMesh.position = new this.THREE.Vector3(x, y, z)\n  if (this.surfaceMesh) this.surfaceMesh.position = new this.THREE.Vector3(x, y, z)\n}\n\nMesh.prototype.faceVertexUv = function(i) {\n  var vs = [\n    this.meshed.vertices[i*4+0],\n    this.meshed.vertices[i*4+1],\n    this.meshed.vertices[i*4+2],\n    this.meshed.vertices[i*4+3]\n  ]\n  var spans = {\n    x0: vs[0][0] - vs[1][0],\n    x1: vs[1][0] - vs[2][0],\n    y0: vs[0][1] - vs[1][1],\n    y1: vs[1][1] - vs[2][1],\n    z0: vs[0][2] - vs[1][2],\n    z1: vs[1][2] - vs[2][2]\n  }\n  var size = {\n    x: Math.max(Math.abs(spans.x0), Math.abs(spans.x1)),\n    y: Math.max(Math.abs(spans.y0), Math.abs(spans.y1)),\n    z: Math.max(Math.abs(spans.z0), Math.abs(spans.z1))\n  }\n  if (size.x === 0) {\n    if (spans.y0 > spans.y1) {\n      var width = size.y\n      var height = size.z\n    }\n    else {\n      var width = size.z\n      var height = size.y\n    }\n  }\n  if (size.y === 0) {\n    if (spans.x0 > spans.x1) {\n      var width = size.x\n      var height = size.z\n    }\n    else {\n      var width = size.z\n      var height = size.x\n    }\n  }\n  if (size.z === 0) {\n    if (spans.x0 > spans.x1) {\n      var width = size.x\n      var height = size.y\n    }\n    else {\n      var width = size.y\n      var height = size.x\n    }\n  }\n  if ((size.z === 0 && spans.x0 < spans.x1) || (size.x === 0 && spans.y0 > spans.y1)) {\n    return [\n      new this.THREE.Vector2(height, 0),\n      new this.THREE.Vector2(0, 0),\n      new this.THREE.Vector2(0, width),\n      new this.THREE.Vector2(height, width)\n    ]\n  } else {\n    return [\n      new this.THREE.Vector2(0, 0),\n      new this.THREE.Vector2(0, height),\n      new this.THREE.Vector2(width, height),\n      new this.THREE.Vector2(width, 0)\n    ]\n  }\n}\n;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/dmillet/Projects/fpt/fpt/~/voxel-mesh/index.js\n ** module id = 31\n ** module chunks = 0 1 2\n **/","var tic = require('tic')();\nvar createAtlas = require('atlaspack');\nvar isTransparent = require('opaque').transparent;\n\nfunction Texture(opts) {\n  if (!(this instanceof Texture)) return new Texture(opts || {});\n  var self = this;\n  this.game = opts.game; delete opts.game;\n  this.THREE = this.game.THREE;\n  this.materials = [];\n  this.transparents = [];\n  this.texturePath = opts.texturePath || '/textures/';\n  this.loading = 0;\n  this.ao = require('voxel-fakeao')(this.game);\n\n  var useFlatColors = opts.materialFlatColor === true;\n  delete opts.materialFlatColor;\n\n  this.options = defaults(opts || {}, {\n    crossOrigin: 'Anonymous',\n    materialParams: defaults(opts.materialParams || {}, {\n      ambient: 0xbbbbbb,\n      transparent: false,\n      side: this.THREE.DoubleSide,\n    }),\n    materialTransparentParams: defaults(opts.materialTransparentParams || {}, {\n      ambient: 0xbbbbbb,\n      transparent: true,\n      side: this.THREE.DoubleSide,\n      //depthWrite: false,\n      //depthTest: false\n    }),\n    materialType: this.THREE.MeshLambertMaterial,\n    applyTextureParams: function(map) {\n      map.magFilter = self.THREE.NearestFilter;\n      map.minFilter = self.THREE.LinearMipMapLinearFilter;\n    }\n  });\n\n  // create a canvas for the texture atlas\n  this.canvas = (typeof document !== 'undefined') ? document.createElement('canvas') : {};\n  this.canvas.width = opts.atlasWidth || 512;\n  this.canvas.height = opts.atlasHeight || 512;\n  var ctx = this.canvas.getContext('2d');\n  ctx.fillStyle = 'black';\n  ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n\n  // create core atlas and texture\n  this.atlas = createAtlas(this.canvas);\n  this.atlas.tilepad = true;\n  this._atlasuv = false;\n  this._atlaskey = false;\n  this.texture = new this.THREE.Texture(this.canvas);\n  this.options.applyTextureParams(this.texture);\n\n  if (useFlatColors) {\n    // If were using simple colors\n    this.material = new this.THREE.MeshBasicMaterial({\n      vertexColors: this.THREE.VertexColors\n    });\n  } else {\n    var opaque = new this.options.materialType(this.options.materialParams);\n    opaque.map = this.texture;\n    var transparent = new this.options.materialType(this.options.materialTransparentParams);\n    transparent.map = this.texture;\n    this.material = new this.THREE.MeshFaceMaterial([\n      opaque,\n      transparent\n    ]);\n  }\n\n  // a place for meshes to wait while textures are loading\n  this._meshQueue = [];\n}\nmodule.exports = Texture;\n\nTexture.prototype.load = function(names, done) {\n  var self = this;\n  if (!Array.isArray(names)) names = [names];\n  done = done || function() {};\n  this.loading++;\n\n  var materialSlice = names.map(self._expandName);\n  self.materials = self.materials.concat(materialSlice);\n\n  // load onto the texture atlas\n  var load = Object.create(null);\n  materialSlice.forEach(function(mats) {\n    mats.forEach(function(mat) {\n      if (mat.slice(0, 1) === '#') return;\n      // todo: check if texture already exists\n      load[mat] = true;\n    });\n  });\n  if (Object.keys(load).length > 0) {\n    each(Object.keys(load), self.pack.bind(self), function() {\n      self._afterLoading();\n      done(materialSlice);\n    });\n  } else {\n    self._afterLoading();\n  }\n};\n\nTexture.prototype.pack = function(name, done) {\n  var self = this;\n  function pack(img) {\n    var node = self.atlas.pack(img);\n    if (node === false) {\n      self.atlas = self.atlas.expand(img);\n      self.atlas.tilepad = true;\n    }\n    done();\n  }\n  if (typeof name === 'string') {\n    var img = new Image();\n    img.id = name;\n    img.crossOrigin = self.options.crossOrigin;\n    img.src = self.texturePath + ext(name);\n    img.onload = function() {\n      if (isTransparent(img)) {\n        self.transparents.push(name);\n      }\n      pack(img);\n    };\n    img.onerror = function() {\n      console.error('Couldn\\'t load URL [' + img.src + ']');\n      done();\n    };\n  } else {\n    pack(name);\n  }\n  return self;\n};\n\nTexture.prototype.find = function(name) {\n  var self = this;\n  var type = 0;\n  self.materials.forEach(function(mats, i) {\n    mats.forEach(function(mat) {\n      if (mat === name) {\n        type = i + 1;\n        return false;\n      }\n    });\n    if (type !== 0) return false;\n  });\n  return type;\n};\n\nTexture.prototype._expandName = function(name) {\n  if (name === null) return Array(6);\n  if (name.top) return [name.back, name.front, name.top, name.bottom, name.left, name.right];\n  if (!Array.isArray(name)) name = [name];\n  // load the 0 texture to all\n  if (name.length === 1) name = [name[0],name[0],name[0],name[0],name[0],name[0]];\n  // 0 is top/bottom, 1 is sides\n  if (name.length === 2) name = [name[1],name[1],name[0],name[0],name[1],name[1]];\n  // 0 is top, 1 is bottom, 2 is sides\n  if (name.length === 3) name = [name[2],name[2],name[0],name[1],name[2],name[2]];\n  // 0 is top, 1 is bottom, 2 is front/back, 3 is left/right\n  if (name.length === 4) name = [name[2],name[2],name[0],name[1],name[3],name[3]];\n  return name;\n};\n\nTexture.prototype._afterLoading = function() {\n  var self = this;\n  function alldone() {\n    self.loading--;\n    self._atlasuv = self.atlas.uv(self.canvas.width, self.canvas.height);\n    self._atlaskey = Object.create(null);\n    self.atlas.index().forEach(function(key) {\n      self._atlaskey[key.name] = key;\n    });\n    self.texture.needsUpdate = true;\n    self.material.needsUpdate = true;\n    //window.open(self.canvas.toDataURL());\n    if (self._meshQueue.length > 0) {\n      self._meshQueue.forEach(function(queue, i) {\n        self.paint.apply(queue.self, queue.args);\n        delete self._meshQueue[i];\n      });\n    }\n  }\n  self._powerof2(function() {\n    setTimeout(alldone, 100);\n  });\n};\n\n// Ensure the texture stays at a power of 2 for mipmaps\n// this is cheating :D\nTexture.prototype._powerof2 = function(done) {\n  var w = this.canvas.width;\n  var h = this.canvas.height;\n  function pow2(x) {\n    x--;\n    x |= x >> 1;\n    x |= x >> 2;\n    x |= x >> 4;\n    x |= x >> 8;\n    x |= x >> 16;\n    x++;\n    return x;\n  }\n  if (h > w) w = h;\n  var old = this.canvas.getContext('2d').getImageData(0, 0, this.canvas.width, this.canvas.height);\n  this.canvas.width = this.canvas.height = pow2(w);\n  this.canvas.getContext('2d').putImageData(old, 0, 0);\n  done();\n};\n\nTexture.prototype.paint = function(mesh, materials) {\n  var self = this;\n\n  // if were loading put into queue\n  if (self.loading > 0) {\n    self._meshQueue.push({self: self, args: arguments});\n    return false;\n  }\n\n  var isVoxelMesh = (materials) ? false : true;\n  if (!isVoxelMesh) materials = self._expandName(materials);\n\n  mesh.geometry.faces.forEach(function(face, i) {\n    if (mesh.geometry.faceVertexUvs[0].length < 1) return;\n\n    if (isVoxelMesh) {\n      var index = Math.floor(face.color.b*255 + face.color.g*255*255 + face.color.r*255*255*255);\n      materials = self.materials[index - 1];\n      if (!materials) materials = self.materials[0];\n    }\n\n    // BACK, FRONT, TOP, BOTTOM, LEFT, RIGHT\n    var name = materials[0] || '';\n    if      (face.normal.z === 1)  name = materials[1] || '';\n    else if (face.normal.y === 1)  name = materials[2] || '';\n    else if (face.normal.y === -1) name = materials[3] || '';\n    else if (face.normal.x === -1) name = materials[4] || '';\n    else if (face.normal.x === 1)  name = materials[5] || '';\n\n    // if just a simple color\n    if (name.slice(0, 1) === '#') {\n      self.ao(face, name);\n      return;\n    }\n\n    var atlasuv = self._atlasuv[name];\n    if (!atlasuv) return;\n\n    // If a transparent texture use transparent material\n    face.materialIndex = (self.transparents.indexOf(name) !== -1) ? 1 : 0;\n\n    // 0 -- 1\n    // |    |\n    // 3 -- 2\n    // faces on these meshes are flipped vertically, so we map in reverse\n    // TODO: tops need rotate\n    if (isVoxelMesh) {\n      if (face.normal.z === -1 || face.normal.x === 1) {\n        atlasuv = uvrot(atlasuv, 90);\n      }\n      atlasuv = uvinvert(atlasuv);\n    } else {\n      atlasuv = uvrot(atlasuv, -90);\n    }\n    for (var j = 0; j < mesh.geometry.faceVertexUvs[0][i].length; j++) {\n      mesh.geometry.faceVertexUvs[0][i][j].set(atlasuv[j][0], 1 - atlasuv[j][1]);\n    }\n  });\n\n  mesh.geometry.uvsNeedUpdate = true;\n};\n\nTexture.prototype.sprite = function(name, w, h, cb) {\n  var self = this;\n  if (typeof w === 'function') { cb = w; w = null; }\n  if (typeof h === 'function') { cb = h; h = null; }\n  w = w || 16; h = h || w;\n  self.loading++;\n  var img = new Image();\n  img.src = self.texturePath + ext(name);\n  img.onerror = cb;\n  img.onload = function() {\n    var canvases = [];\n    for (var x = 0; x < img.width; x += w) {\n      for (var y = 0; y < img.height; y += h) {\n        var canvas = document.createElement('canvas');\n        canvas.width = w; canvas.height = h;\n        canvas.name = name + '_' + x + '_' + y;\n        canvas.getContext('2d').drawImage(img, x, y, w, h, 0, 0, w, h);\n        canvases.push(canvas);\n      }\n    }\n    var textures = [];\n    each(canvases, function(canvas, next) {\n      var tex = new Image();\n      tex.name = canvas.name;\n      tex.src = canvas.toDataURL();\n      tex.onload = function() {\n        self.pack(tex, next);\n      };\n      tex.onerror = next;\n      textures.push([\n        tex.name, tex.name, tex.name,\n        tex.name, tex.name, tex.name\n      ]);\n    }, function() {\n      self._afterLoading();\n      delete canvases;\n      self.materials = self.materials.concat(textures);\n      cb(textures);\n    });\n  };\n  return self;\n};\n\nTexture.prototype.animate = function(mesh, names, delay) {\n  var self = this;\n  delay = delay || 1000;\n  if (!Array.isArray(names) || names.length < 2) return false;\n  var i = 0;\n  var mat = new this.options.materialType(this.options.materialParams);\n  mat.map = this.texture;\n  mat.transparent = true;\n  mat.needsUpdate = true;\n  tic.interval(function() {\n    self.paint(mesh, names[i % names.length]);\n    i++;\n  }, delay);\n  return mat;\n};\n\nTexture.prototype.tick = function(dt) {\n  tic.tick(dt);\n};\n\nfunction uvrot(coords, deg) {\n  if (deg === 0) return coords;\n  var c = [];\n  var i = (4 - Math.ceil(deg / 90)) % 4;\n  for (var j = 0; j < 4; j++) {\n    c.push(coords[i]);\n    if (i === 3) i = 0; else i++;\n  }\n  return c;\n}\n\nfunction uvinvert(coords) {\n  var c = coords.slice(0);\n  return [c[3], c[2], c[1], c[0]];\n}\n\nfunction ext(name) {\n  return (String(name).indexOf('.') !== -1) ? name : name + '.png';\n}\n\nfunction defaults(obj) {\n  [].slice.call(arguments, 1).forEach(function(from) {\n    if (from) for (var k in from) if (obj[k] == null) obj[k] = from[k];\n  });\n  return obj;\n}\n\nfunction each(arr, it, done) {\n  var count = 0;\n  arr.forEach(function(a) {\n    it(a, function() {\n      count++;\n      if (count >= arr.length) done();\n    });\n  });\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/dmillet/Projects/fpt/fpt/~/voxel-texture/index.js\n ** module id = 32\n ** module chunks = 0 1 2\n **/","/*\n * tic\n * https://github.com/shama/tic\n *\n * Copyright (c) 2013 Kyle Robinson Young\n * Licensed under the MIT license.\n */\n\nfunction Tic() { this._things = []; }\nmodule.exports = function() { return new Tic(); };\n\nTic.prototype._stack = function(thing) {\n  var self = this;\n  self._things.push(thing);\n  var i = self._things.length - 1;\n  return function() { delete self._things[i]; }\n};\n\nTic.prototype.interval = Tic.prototype.setInterval = function(fn, at) {\n  return this._stack({\n    fn: fn, at: at, args: Array.prototype.slice.call(arguments, 2),\n    elapsed: 0, once: false\n  });\n};\n\nTic.prototype.timeout = Tic.prototype.setTimeout = function(fn, at) {\n  return this._stack({\n    fn: fn, at: at, args: Array.prototype.slice.call(arguments, 2),\n    elapsed: 0, once: true\n  });\n};\n\nTic.prototype.tick = function(dt) {\n  var self = this;\n  self._things.forEach(function(thing, i) {\n    thing.elapsed += dt;\n    if (thing.elapsed > thing.at) {\n      thing.elapsed -= thing.at;\n      thing.fn.apply(thing.fn, thing.args || []);\n      if (thing.once) {\n        delete self._things[i];\n      }\n    }\n  });\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/dmillet/Projects/fpt/fpt/~/voxel-texture/~/tic/index.js\n ** module id = 33\n ** module chunks = 0 1 2\n **/","!function(e){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define([],e);else{var f;\"undefined\"!=typeof window?f=window:\"undefined\"!=typeof global?f=global:\"undefined\"!=typeof self&&(f=self),f.atlaspack=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/*\n * atlaspack\n * https://github.com/shama/atlaspack\n *\n * Copyright (c) 2014 Kyle Robinson Young\n * Licensed under the MIT license.\n *\n * Based on Nick Welch's binpack: https://github.com/mackstann/binpack\n */\n\nfunction Rect(x, y, w, h) {\n  this.x = x; this.y = y;\n  this.w = w; this.h = h;\n}\n\nRect.prototype.fitsIn = function(outer) {\n  return outer.w >= this.w && outer.h >= this.h;\n};\n\nRect.prototype.sameSizeAs = function(other) {\n  return this.w === other.w && this.h === other.h;\n};\n\nfunction Atlas(x, y, w, h) {\n  if (arguments.length === 1) {\n    this.canvas = x;\n    x = y = 0;\n    w = this.canvas.width;\n    h = this.canvas.height;\n  }\n  if (arguments.length === 2) {\n    w = x; h = y; x = y = 0;\n  }\n  this.left = this.right = null;\n  this.rect = new Rect(x, y, w, h);\n  this.filled = false;\n  this.tilepad = false;\n  this._cache = [];\n  this._uvcache = Object.create(null);\n}\nmodule.exports = function() {\n  if (arguments.length === 1) { return new Atlas(arguments[0]); }\n  if (arguments.length === 2) { return new Atlas(arguments[0], arguments[1]); }\n  return new Atlas(arguments[0], arguments[1], arguments[2], arguments[3]);\n};\nmodule.exports.Atlas = Atlas;\nmodule.exports.Rect = Rect;\n\n// pack image/rect to the atlas\nAtlas.prototype.pack = function(rect) {\n  this._cache = [];\n  this._uvcache = Object.create(null);\n  rect = this._toRect(rect);\n\n  if (this.img && this.tilepad) {\n    rect = this._tilepad(rect);\n  }\n\n  if (this.left !== null) {\n    return this._ontoCanvas(this.left.pack(rect) || this.right.pack(rect));\n  }\n  // if atlas filled or wont fit\n  if (this.filled || !rect.fitsIn(this.rect)) {\n    return false;\n  }\n  // if this atlas has been filled\n  if (rect.sameSizeAs(this.rect)) {\n    this.filled = true;\n    return this._ontoCanvas(this);\n  }\n  if ((this.rect.w - rect.w) > (this.rect.h - rect.h)) {\n    this.left = new Atlas(this.rect.x, this.rect.y, rect.w, this.rect.h);\n    this.right = new Atlas(this.rect.x + rect.w, this.rect.y, this.rect.w - rect.w, this.rect.h);\n  } else {\n    this.left = new Atlas(this.rect.x, this.rect.y, this.rect.w, rect.h);\n    this.right = new Atlas(this.rect.x, this.rect.y + rect.h, this.rect.w, this.rect.h - rect.h);\n  }\n  return this._ontoCanvas(this.left.pack(rect));\n};\n\nAtlas.prototype.expand = function(rect) {\n  var self = this;\n  rect = this._toRect(rect);\n\n  if (this.img && this.tilepad) {\n    rect = this._tilepad(rect);\n  }\n\n  var atlas;\n  if (this.rect.w < this.rect.h) {\n    atlas = new Atlas(0, 0, this.rect.w + rect.w, this.rect.h);\n    atlas.right = new Atlas(this.rect.w, 0, rect.w, this.rect.h);\n    atlas.left = this;\n  } else {\n    atlas = new Atlas(0, 0, this.rect.w, this.rect.h + rect.h);\n    atlas.right = new Atlas(0, this.rect.h, this.rect.w, rect.h);\n    atlas.left = this;\n  }\n\n  ['canvas', 'context', 'img'].forEach(function(p) {\n    if (self[p]) {\n      atlas[p] = self[p];\n      self[p] = null;\n    }\n  });\n\n  // resize canvas\n  if (atlas.canvas) {\n    if (!atlas.context) {\n      atlas.context = atlas.canvas.getContext('2d');\n    }\n    var old = atlas.context.getImageData(0, 0, atlas.canvas.width, atlas.canvas.height);\n    atlas.canvas.width = atlas.rect.w;\n    atlas.canvas.height = atlas.rect.h;\n    atlas.context.putImageData(old, 0, 0);\n  }\n\n  return (atlas.pack(rect) === false) ? atlas.expand(rect) : atlas;\n};\n\nAtlas.prototype.index = function() {\n  var self = this;\n  if (self._cache.length > 0) {\n    return self._cache;\n  }\n  (function loop(atlas) {\n    if (atlas.left !== null) {\n      loop(atlas.left);\n      loop(atlas.right);\n    } else if (atlas.rect.name) {\n      self._cache.push(atlas.rect);\n    }\n  }(self));\n  return self._cache;\n};\n\nAtlas.prototype.uv = function(w, h) {\n  var self = this;\n  w = w || self.rect.w;\n  h = h || self.rect.h;\n  var isPad = this.tilepad;\n  (function loop(atlas) {\n    if (atlas.left !== null) {\n      loop(atlas.left);\n      loop(atlas.right);\n    } else if (typeof atlas.rect.name !== 'undefined') {\n      var p = (isPad) ? atlas.rect.w / 4 : 0;\n      self._uvcache[atlas.rect.name] = [\n        [atlas.rect.x + p, atlas.rect.y + p],\n        [(atlas.rect.x + p) + (atlas.rect.w - (p * 2)), atlas.rect.y + p],\n        [(atlas.rect.x + p) + (atlas.rect.w - (p * 2)), (atlas.rect.y + p) + (atlas.rect.h - (p * 2))],\n        [(atlas.rect.x + p), (atlas.rect.y + p) + (atlas.rect.h - (p * 2))],\n      ].map(function(uv) {\n        if (uv[0] !== 0) {\n          uv[0] = uv[0] / w;\n        }\n        if (uv[1] !== 0) {\n          uv[1] = uv[1] / h;\n        }\n        return uv;\n      });\n    }\n  }(self));\n  return self._uvcache;\n};\n\nAtlas.prototype.json = function(input) {\n  var self = this;\n  if (input) {\n    if (typeof input === 'string') input = JSON.parse(input);\n    return (function loop(obj) {\n      if (!obj || !obj.rect) return;\n      var atlas = new Atlas(obj.rect.x, obj.rect.y, obj.rect.w, obj.rect.h);\n      if (obj.left) atlas.left = loop(obj.left);\n      if (obj.right) atlas.right = loop(obj.right);\n      return atlas;\n    }(input));\n  } else {\n    return JSON.stringify(function loop(atlas) {\n      var obj = {\n        left: null, right: null,\n        rect: atlas.rect, filled: atlas.filled\n      };\n      if (atlas.left !== null) {\n        obj.left = loop(atlas.left);\n        obj.right = loop(atlas.right);\n      }\n      return obj;\n    }(self), null, 2);\n  }\n};\n\n// Pads the image by tiling itself around itself\nAtlas.prototype._tilepad = function(rect) {\n  var img = this.img;\n  if (!img) return rect;\n\n  var p = img.width / 2;\n\n  var canvas = document.createElement('canvas');\n  canvas.name = img.name || img.src;\n  canvas.id = img.id || '';\n  canvas.width = img.width + img.width;\n  canvas.height = img.height + img.height;\n  var ctx = canvas.getContext('2d');\n\n  var pattern = ctx.createPattern(img, 'repeat');\n  ctx.fillStyle = pattern;\n  ctx.translate(p, p);\n  ctx.fillRect(-p, -p, canvas.width + p, canvas.height + p);\n  ctx.translate(-p, -p);\n\n  this.img = canvas;\n\n  return new Rect(rect.x, rect.y, this.img.width, this.img.height);\n};\n\n// if has an image and canvas, draw to the canvas as we go\nAtlas.prototype._ontoCanvas = function(node) {\n  if (node && this.img && this.canvas) {\n    if (!this.context) {\n      this.context = this.canvas.getContext('2d');\n    }\n    this.context.clearRect(node.rect.x, node.rect.y, node.rect.w, node.rect.h);\n    this.context.drawImage(this.img, node.rect.x, node.rect.y, node.rect.w, node.rect.h);\n    node.rect.name = this.img.id || this.img.name || this.img.src || null;\n  }\n  return node;\n};\n\n// make sure we're always working with rects\nAtlas.prototype._toRect = function(rect) {\n  // if rect is an image\n  if (rect.nodeName && rect.nodeName === 'IMG') {\n    this.img = rect;\n    rect = new Rect(rect.x, rect.y, rect.width, rect.height);\n  }\n  // if rect is an object\n  if (!(rect instanceof Rect)) {\n    rect = new Rect(rect.x || 0, rect.y || 0, rect.w || rect.width, rect.h || rect.height);\n  }\n  return rect;\n};\n\nAtlas.prototype._debug = function() {\n  if (!this.canvas) { return; }\n  var context = this.canvas.getContext('2d');\n  this.index().forEach(function(rect) {\n    context.lineWidth = 1;\n    context.strokeStyle = 'red';\n    context.strokeRect(rect.x, rect.y, rect.w, rect.h);\n  });\n};\n\n},{}]},{},[1])\n(1)\n});;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/dmillet/Projects/fpt/fpt/~/voxel-texture/~/atlaspack/index.js\n ** module id = 34\n ** module chunks = 0 1 2\n **/","function opaque(image) {\n  var canvas, ctx\n\n  if (image.nodeName.toLowerCase() === 'img') {\n    canvas = document.createElement('canvas')\n    canvas.width = image.width\n    canvas.height = image.height\n    ctx = canvas.getContext('2d')\n    ctx.drawImage(image, 0, 0)\n  } else {\n    canvas = image\n    ctx = canvas.getContext('2d')\n  }\n\n  var imageData = ctx.getImageData(0, 0, canvas.height, canvas.width)\n    , data = imageData.data\n\n  for (var i = 3, l = data.length; i < l; i += 4)\n    if (data[i] !== 255)\n      return false\n\n  return true\n};\n\nmodule.exports = opaque\nmodule.exports.opaque = opaque\nmodule.exports.transparent = function(image) {\n  return !opaque(image)\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/dmillet/Projects/fpt/fpt/~/voxel-texture/~/opaque/index.js\n ** module id = 35\n ** module chunks = 0 1 2\n **/","module.exports = function(game) {\n  var THREE = game.THREE;\n  var colorCache = Object.create(null);\n\n  var ao = function(face, light, dark) {\n    if (arguments.length === 1) {\n      light = face.color;\n      dark = getDark(light);\n    } else if (arguments.length === 2) {\n      light = convertColor(light);\n      dark = getDark(light);\n    } else {\n      light = convertColor(light);\n      dark = convertColor(dark);\n    }\n    face.color = light;\n\n    // TODO: AO should be figured better than this\n    if (face.normal.y === 1)       face.vertexColors = [light, light, light, light];\n    else if (face.normal.y === -1) face.vertexColors = [dark,  dark,  dark,  dark];\n    else if (face.normal.x === 1)  face.vertexColors = [dark,  light, light, dark];\n    else if (face.normal.x === -1) face.vertexColors = [dark,  dark,  light, light];\n    else if (face.normal.z === 1)  face.vertexColors = [dark,  dark,  light, light];\n    else                           face.vertexColors = [dark,  light, light, dark];\n  };\n\n  ao.onGeometry = function(geom, light, dark) {\n    for (var i = 0; i < geom.faces.length; ++i) {\n      ao(geom.faces[i], light, dark);\n    }\n  };\n\n  ao.onChunk = function(chunk, light, dark) {\n    var pos = ('position' in chunk) ? chunk.position : chunk;\n    var mesh = game.voxels.meshes[pos.join('|')];\n    if (mesh) {\n      ao.onGeometry(mesh.geometry, light, dark);\n    }\n  };\n\n  var getDark = function(light) {\n    var hex = light.getHexString();\n    if (colorCache[hex]) return colorCache[hex];\n    var hsl = light.getHSL();\n    var dark = light.clone();\n    dark.setHSL(hsl.h, hsl.s, hsl.l - 0.1);\n    return colorCache[hex] = dark;\n  };\n\n  var convertColor = function(color) {\n    if (color instanceof THREE.Color) return color;\n    if (colorCache[color]) return colorCache[color];\n    return colorCache[color] = new THREE.Color(color);\n  };\n\n  return ao;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /Users/dmillet/Projects/fpt/fpt/~/voxel-texture/~/voxel-fakeao/index.js\n ** module id = 36\n ** module chunks = 0 1 2\n **/","\nimport THREE from 'three';\n\nclass MeshComponent {\n\n\tstatic create() {\n\t\treturn new MeshComponent();\n\t}\n\n\tconstructor() {\n\t\tlet geometry = new THREE.CubeGeometry(1, 1, 1);\n\t\tlet material = new THREE.MeshLambertMaterial({color: 0x0000ff, wireframe: false});\n\t\tthis.three = new THREE.Mesh(geometry, material);\n\t\tthis.three.castShadow = this.three.receiveShadow = true;\n\t\tthis.three.useQuaternion = true;\n\t}\n\n}\n\nexport default MeshComponent;\n\n\n\n/** WEBPACK FOOTER **\n ** ./view/MeshComponent.js\n **/","\nimport Level from './Level';\nimport voxel from 'voxel';\n\nlet TestLevel1 = Level.createClass({\n\tgenerateVoxel: voxel.generator['Hill']\n});\n\nTestLevel1.create = function() {\n\treturn new TestLevel1();\n};\n\nexport default TestLevel1;\n\n\n\n/** WEBPACK FOOTER **\n ** ../levels/TestLevel1.js\n **/","\nimport EventObject from '../shared/EventObject';\n\nclass ClientConnection {\n\n\tstatic create() {\n\t\treturn new ClientConnection();\n\t}\n\n\tconstructor() {\n\t\tthis._eo = EventObject.create();\n\t\tthis._queue = [];\n\t\tthis.connected = false;\n\t\tthis._ws = new WebSocket('ws://localhost:3001/');\n\n\t\tthis._ws.onopen = function() {\n\t\t\tthis.connected = true;\n\t\t\tthis._sendNext();\n\t\t}.bind(this);\n\n\t\tthis._ws.onmessage = function(raw) {\n\t\t\tlet msg = JSON.parse(raw.data);\n\t\t\tthis._handleMessage(msg);\n\t\t}.bind(this);\n\t}\n\n\tsend(type, data) {\n\t\tthis._queue.push({\n\t\t\ttype: type,\n\t\t\tdata: data\n\t\t});\n\t\tthis._sendNext();\n\t}\n\n\tonMessage(type, callback) {\n\t\treturn this._eo.on('message:' + type, callback);\n\t}\n\n\t_sendNext() {\n\t\tif (!this.connected) {\n\t\t\treturn;\n\t\t}\n\t\tlet msg = this._queue.shift();\n\t\tif (!msg) {\n\t\t\treturn;\n\t\t}\n\t\tthis._ws.send(JSON.stringify(msg));\n\t\tthis._sendNext();\n\t}\n\n\t_handleMessage(msg) {\n\t\tthis._eo.triggerEvent('message:' + msg.type, msg.data);\n\t}\n\n}\n\nexport default ClientConnection;\n\n\n\n/** WEBPACK FOOTER **\n ** ./ClientConnection.js\n **/","\nclass EventObject {\n\n\tstatic create() {\n\t\treturn new EventObject();\n\t}\n\n\tconstructor() {\n\t\tthis._handlers = [];\n\t}\n\n\ton(type, callback) {\n\t\tlet handler = Handler.create(this, callback);\n\t\tthis._getHandlers(type).push(handler);\n\t\treturn handler;\n\t}\n\n\ttriggerEvent(type, ...args) {\n\t\tlet handlers = this._getHandlers(type);\n\t\thandlers.forEach(function(handler) {\n\t\t\thandler.trigger(args);\n\t\t});\n\t}\n\n\t_getHandlers(type) {\n\t\tif (!this._handlers[type]) {\n\t\t\tthis._handlers[type] = [];\n\t\t}\n\t\treturn this._handlers[type];\n\t}\n\n}\n\nclass Handler {\n\n\tstatic create(target, callback) {\n\t\treturn new Handler(target, callback);\n\t}\n\n\tconstructor(target, callback) {\n\t\tthis.target = target;\n\t\tthis.callback = callback;\n\t}\n\n\ttrigger(args) {\n\t\tthis.callback.apply(this.target, args);\n\t}\n\n}\n\n\nexport default EventObject;\n\n\n/** WEBPACK FOOTER **\n ** ../shared/EventObject.js\n **/","\nimport ServerSession from '../server/ServerSession';\n\nexport default class ClientSession {\n\t\n\tstatic create(clientConnection) {\n\t\treturn new ClientSession(clientConnection);\n\t}\n\n\tconstructor(clientConnection) {\n\t\tthis.connection = clientConnection;\n\n\t\tthis.authenticated = false;\n\t\tthis.sessionId = null;\n\t\tthis.sessionToken = null;\n\n\t\tthis.connection.onMessage(\n\t\t\tServerSession.SET_SESSION,\n\t\t\tfunction(sessionInfo) {\n\t\t\t\tthis.sessionId = sessionInfo.id;\n\t\t\t\tthis.sessionToken = sessionInfo.token;\n\t\t\t\tthis.authenticated = true;\n\t\t\t\tlocalStorage.setItem(ClientSession.STORAGE_KEY, JSON.stringify({\n\t\t\t\t\tid: this.sessionId,\n\t\t\t\t\ttoken: this.sessionToken\n\t\t\t\t}));\n\t\t\t\tconsole.log('session established:', this.sessionId);\n\t\t\t}.bind(this)\n\t\t);\n\n\t\tthis.connection.onMessage(\n\t\t\tServerSession.SESSION_REFUSED,\n\t\t\tfunction() {\n\t\t\t\tthis.register();\n\t\t\t}.bind(this)\n\t\t);\n\n\t\tlet connectionInfo = localStorage.getItem(ClientSession.STORAGE_KEY);\n\t\tif (connectionInfo) {\n\t\t\tconnectionInfo = JSON.parse(connectionInfo);\n\t\t\tthis.sessionId = connectionInfo.id;\n\t\t\tthis.sessionToken = connectionInfo.token;\n\t\t}\n\n\t\tif (this.sessionId || this.sessionId === 0) {\n\t\t\tthis.authenticate();\n\t\t} else {\n\t\t\tthis.register();\n\t\t}\n\t}\n\n\tauthenticate() {\n\t\tthis.connection.send(\n\t\t\tServerSession.SET_SESSION,\n\t\t\t{\n\t\t\t\tid: this.sessionId,\n\t\t\t\ttoken: this.sessionToken\n\t\t\t}\n\t\t);\n\t}\n\n\tregister() {\n\t\tthis.connection.send(ServerSession.GET_SESSION);\n\t}\n\n}\n\nClientSession.STORAGE_KEY = 'fpt-session';\n\n\n\n/** WEBPACK FOOTER **\n ** ./ClientSession.js\n **/","\nclass ServerSession {\n\t\n\tstatic create() {\n\t\treturn new ServerSession();\n\t}\n\n\tconstructor() {\n\t\tthis.id = null;\n\t\tthis.token = null;\n\t\tthis.connection = null;\n\t}\n\n}\n\nServerSession.GET_SESSION = 'get-session';\nServerSession.SET_SESSION = 'set-session';\nServerSession.SESSION_REFUSED = 'session-refused';\n\nexport default ServerSession;\n\n\n\n/** WEBPACK FOOTER **\n ** ../server/ServerSession.js\n **/","\nimport THREE from 'three';\n\n/**\n * @author qiao / https://github.com/qiao\n * @author mrdoob / http://mrdoob.com\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / https://github.com/WestLangley\n */\n\nTHREE.OrbitControls = function ( object, domElement ) {\n\n\tTHREE.EventDispatcher.call( this );\n\n\tthis.object = object;\n\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\n\n\t// API\n\n\tthis.center = new THREE.Vector3();\n\n\tthis.userZoom = true;\n\tthis.userZoomSpeed = 1.0;\n\n\tthis.userRotate = true;\n\tthis.userRotateSpeed = 1.0;\n\n\tthis.autoRotate = false;\n\tthis.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\n\tthis.minPolarAngle = 0; // radians\n\tthis.maxPolarAngle = Math.PI; // radians\n\n\tthis.minDistance = 0;\n\tthis.maxDistance = Infinity;\n\n\t// internals\n\n\tvar scope = this;\n\n\tvar EPS = 0.000001;\n\tvar PIXELS_PER_ROUND = 1800;\n\n\tvar rotateStart = new THREE.Vector2();\n\tvar rotateEnd = new THREE.Vector2();\n\tvar rotateDelta = new THREE.Vector2();\n\n\tvar zoomStart = new THREE.Vector2();\n\tvar zoomEnd = new THREE.Vector2();\n\tvar zoomDelta = new THREE.Vector2();\n\n\tvar phiDelta = 0;\n\tvar thetaDelta = 0;\n\tvar scale = 1;\n\n\tvar lastPosition = new THREE.Vector3();\n\n\tvar STATE = { NONE : -1, ROTATE : 0, ZOOM : 1 };\n\tvar state = STATE.NONE;\n\n\t// events\n\n\tvar changeEvent = { type: 'change' };\n\n\n\tthis.rotateLeft = function ( angle ) {\n\n\t\tif ( angle === undefined ) {\n\n\t\t\tangle = getAutoRotationAngle();\n\n\t\t}\n\n\t\tthetaDelta -= angle;\n\n\t};\n\n\tthis.rotateRight = function ( angle ) {\n\n\t\tif ( angle === undefined ) {\n\n\t\t\tangle = getAutoRotationAngle();\n\n\t\t}\n\n\t\tthetaDelta += angle;\n\n\t};\n\n\tthis.rotateUp = function ( angle ) {\n\n\t\tif ( angle === undefined ) {\n\n\t\t\tangle = getAutoRotationAngle();\n\n\t\t}\n\n\t\tphiDelta -= angle;\n\n\t};\n\n\tthis.rotateDown = function ( angle ) {\n\n\t\tif ( angle === undefined ) {\n\n\t\t\tangle = getAutoRotationAngle();\n\n\t\t}\n\n\t\tphiDelta += angle;\n\n\t};\n\n\tthis.zoomIn = function ( zoomScale ) {\n\n\t\tif ( zoomScale === undefined ) {\n\n\t\t\tzoomScale = getZoomScale();\n\n\t\t}\n\n\t\tscale /= zoomScale;\n\n\t};\n\n\tthis.zoomOut = function ( zoomScale ) {\n\n\t\tif ( zoomScale === undefined ) {\n\n\t\t\tzoomScale = getZoomScale();\n\n\t\t}\n\n\t\tscale *= zoomScale;\n\n\t};\n\n\tthis.update = function () {\n\n\t\tvar position = this.object.position;\n\t\tvar offset = position.clone().sub( this.center )\n\n\t\t// angle from z-axis around y-axis\n\n\t\tvar theta = Math.atan2( offset.x, offset.z );\n\n\t\t// angle from y-axis\n\n\t\tvar phi = Math.atan2( Math.sqrt( offset.x * offset.x + offset.z * offset.z ), offset.y );\n\n\t\tif ( this.autoRotate ) {\n\n\t\t\tthis.rotateLeft( getAutoRotationAngle() );\n\n\t\t}\n\n\t\ttheta += thetaDelta;\n\t\tphi += phiDelta;\n\n\t\t// restrict phi to be between desired limits\n\t\tphi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, phi ) );\n\n\t\t// restrict phi to be betwee EPS and PI-EPS\n\t\tphi = Math.max( EPS, Math.min( Math.PI - EPS, phi ) );\n\n\t\tvar radius = offset.length() * scale;\n\n\t\t// restrict radius to be between desired limits\n\t\tradius = Math.max( this.minDistance, Math.min( this.maxDistance, radius ) );\n\n\t\toffset.x = radius * Math.sin( phi ) * Math.sin( theta );\n\t\toffset.y = radius * Math.cos( phi );\n\t\toffset.z = radius * Math.sin( phi ) * Math.cos( theta );\n\n\t\tposition.copy( this.center ).add( offset );\n\n\t\tthis.object.lookAt( this.center );\n\n\t\tthetaDelta = 0;\n\t\tphiDelta = 0;\n\t\tscale = 1;\n\n\t\tif ( lastPosition.distanceTo( this.object.position ) > 0 ) {\n\n\t\t\tthis.dispatchEvent( changeEvent );\n\n\t\t\tlastPosition.copy( this.object.position );\n\n\t\t}\n\n\t};\n\n\n\tfunction getAutoRotationAngle() {\n\n\t\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\n\t}\n\n\tfunction getZoomScale() {\n\n\t\treturn Math.pow( 0.95, scope.userZoomSpeed );\n\n\t}\n\n\tfunction onMouseDown( event ) {\n\n\t\tif ( !scope.userRotate ) return;\n\n\t\tevent.preventDefault();\n\n\t\tif ( event.button === 0 || event.button === 2 ) {\n\n\t\t\tstate = STATE.ROTATE;\n\n\t\t\trotateStart.set( event.clientX, event.clientY );\n\n\t\t} else if ( event.button === 1 ) {\n\n\t\t\tstate = STATE.ZOOM;\n\n\t\t\tzoomStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tdocument.addEventListener( 'mousemove', onMouseMove, false );\n\t\tdocument.addEventListener( 'mouseup', onMouseUp, false );\n\n\t}\n\n\tfunction onMouseMove( event ) {\n\n\t\tevent.preventDefault();\n\n\t\tif ( state === STATE.ROTATE ) {\n\n\t\t\trotateEnd.set( event.clientX, event.clientY );\n\t\t\trotateDelta.subVectors( rotateEnd, rotateStart );\n\n\t\t\tscope.rotateLeft( 2 * Math.PI * rotateDelta.x / PIXELS_PER_ROUND * scope.userRotateSpeed );\n\t\t\tscope.rotateUp( 2 * Math.PI * rotateDelta.y / PIXELS_PER_ROUND * scope.userRotateSpeed );\n\n\t\t\trotateStart.copy( rotateEnd );\n\n\t\t} else if ( state === STATE.ZOOM ) {\n\n\t\t\tzoomEnd.set( event.clientX, event.clientY );\n\t\t\tzoomDelta.subVectors( zoomEnd, zoomStart );\n\n\t\t\tif ( zoomDelta.y > 0 ) {\n\n\t\t\t\tscope.zoomIn();\n\n\t\t\t} else {\n\n\t\t\t\tscope.zoomOut();\n\n\t\t\t}\n\n\t\t\tzoomStart.copy( zoomEnd );\n\n\t\t}\n\n\t}\n\n\tfunction onMouseUp( event ) {\n\n\t\tif ( ! scope.userRotate ) return;\n\n\t\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\n\t\tdocument.removeEventListener( 'mouseup', onMouseUp, false );\n\n\t\tstate = STATE.NONE;\n\n\t}\n\n\tfunction onMouseWheel( event ) {\n\n\t\tif ( ! scope.userZoom ) return;\n\n\t\tvar delta = 0;\n\n\t\tif ( event.wheelDelta ) { // WebKit / Opera / Explorer 9\n\n\t\t\tdelta = event.wheelDelta;\n\n\t\t} else if ( event.detail ) { // Firefox\n\n\t\t\tdelta = - event.detail;\n\n\t\t}\n\n\t\tif ( delta > 0 ) {\n\n\t\t\tscope.zoomOut();\n\n\t\t} else {\n\n\t\t\tscope.zoomIn();\n\n\t\t}\n\n\t}\n\n\tthis.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );\n\tthis.domElement.addEventListener( 'mousedown', onMouseDown, false );\n\tthis.domElement.addEventListener( 'mousewheel', onMouseWheel, false );\n\tthis.domElement.addEventListener( 'DOMMouseScroll', onMouseWheel, false ); // firefox\n\n};\n\nexport default THREE.OrbitControls;\n\n\n\n/** WEBPACK FOOTER **\n ** ./THREE.OrbitControls.js\n **/","\nimport Entity from '../ecs/Entity';\nimport PhysicsComponent from '../physics/PhysicsComponent';\nimport ViewComponent from '../view/ViewComponent';\n\nlet TestBall = Entity.createClass({\n\tconstructor: function(options) {\n\t\tlet physics = PhysicsComponent.create({\n\t\t\tposition: options.position,\n\t\t\trotation: options.rotation\n\t\t});\n\t\tthis.set('physics', physics);\n\t\tlet viewComponent = ViewComponent.create({\n\t\t\tphysics: physics\n\t\t});\n\t\tthis.set('view', viewComponent);\n\t}\n});\n\nTestBall.create = function(options) {\n\treturn new TestBall(options);\n};\n\nmodule.exports = TestBall;\n\n\n\n/** WEBPACK FOOTER **\n ** ../game/testBall/TestBall.js\n **/","\nclass ViewComponent {\n\n\tstatic create() {\n\t\treturn new ViewComponent();\n\t}\n\n\tconstructor() {\n\n\t}\n\n}\n\nexport default ViewComponent;\n\n\n\n/** WEBPACK FOOTER **\n ** ../game/view/ViewComponent.js\n **/","\nimport System from '../../game/ecs/System';\nimport THREE from 'three';\nimport PhysicsDebugComponent from './PhysicsDebugComponent';\nimport ConstraintDebugView from './debug/ConstraintDebugView';\n\nlet PhysicsDebugView = System.createClass({\n\t\n\tconstructor: function(fptGameView) {\n\n\t\tthis.view = fptGameView;\n\n\t\tthis.three = new THREE.Object3D();\n\n\t\tthis.threeConstraints = new THREE.Object3D();\n\t\tthis.three.add(this.threeConstraints);\n\n\t\tthis.threeShapes = new THREE.Object3D();\n\t\tthis.three.add(this.threeShapes);\n\n\t\tthis.view.scene.add(this.three);\n\n\t\tthis.entities = fptGameView.game.entities;\n\n\t\tthis._constraints = [];\n\n\t},\n\n\ttick: function(ms) {\n\t\tthis.entities.forEach(function(entity) {\n\t\t\tthis.tickEntity(entity);\n\t\t}.bind(this));\n\n\t\tthis.tickConstraints();\n\t},\n\n\ttickEntity: function(entity) {\n\t\tlet pieces = entity.get('pieces');\n\n\t\tif (pieces) {\n\t\t\tpieces.forEach(function(piece) {\n\t\t\t\tthis.tickEntity(piece);\n\t\t\t}.bind(this));\n\t\t}\n\n\t\tlet view = entity.get('physicsDebugView'),\n\t\t\tphysics = entity.get('physics');\n\n\t\tif (view && !physics) {\n\t\t\tthis.threeShapes.remove(view.three);\n\t\t}\n\n\t\tif (!view && physics) {\n\t\t\tview = new PhysicsDebugComponent(entity);\n\t\t\tentity.set('physicsDebugView', view);\n\t\t}\n\n\t\tif (view && physics && !view.three.parent) {\n\t\t\tthis.threeShapes.add(view.three);\n\t\t}\n\n\t\tif (view) {\n\t\t\tview.tick();\n\t\t}\n\t},\n\n\ttickConstraints: function() {\n\t\tvar newConstraints = [];\n\t\tthis.view.game.physics.world.constraints.forEach(function(cannonConstraint) {\n\t\t\tif (\n\t\t\t\t!this._constraints.find(function(constraintDebugView) {\n\t\t\t\t\treturn constraintDebugView.cannon === cannonConstraint;\n\t\t\t\t}.bind(this))\n\t\t\t) {\n\t\t\t\tconsole.debug('adding one');\n\t\t\t\tlet view = new ConstraintDebugView(cannonConstraint);\n\t\t\t\tthis._constraints.push(view);\n\t\t\t\tthis.threeConstraints.add(view.three);\n\t\t\t}\n\t\t}.bind(this));\n\t}\n\n});\n\nPhysicsDebugView.create = function(fptGameView) {\n\treturn new PhysicsDebugView(fptGameView);\n};\n\nexport default PhysicsDebugView;\n\n\n\n/** WEBPACK FOOTER **\n ** ./view/PhysicsDebugView.js\n **/","\nimport THREE from 'three';\nimport compare from '../../shared/compare';\nimport clone from '../../shared/clone';\n\nclass PhysicsDebugComponent {\n\n\tconstructor(entity) {\n\t\tthis.entity = entity;\n\n\t\tlet three = new THREE.Object3D();\n\t\tlet physics = entity.get('physics');\n\n\t\tthis.threeAxis = new ThreeAxis();\n\t\tthree.add(this.threeAxis);\n\n\t\tthis.three = three;\n\t}\n\n\ttick() {\n\t\tthis.tickShapes();\n\t\tthis.tickPosition();\n\t}\n\n\ttickPosition() {\n\t\tlet physics = this.entity.get('physics');\n\n\t\tif (physics) {\n\t\t\tlet position = physics.position;\n\t\t\tthis.three.position.set(position.x, position.y, position.z);\n\n\t\t\tlet rotation = physics.rotation;\n\t\t\tthis.three.useQuaternion = true;\n\t\t\tthis.three.quaternion.set(rotation.x, rotation.y, rotation.z, rotation.w);\n\t\t}\n\t}\n\n\ttickShapes() {\n\t\tlet physics = this.entity.get('physics');\n\n\t\tif (physics) {\n\n\t\t\tif (this.oldShapes && compare.arrays(this.oldShapes, physics.cannon.shapes) === true) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (this.threeShapes) {\n\t\t\t\tthis.three.remove(this.threeShapes);\n\t\t\t}\n\n\t\t\tthis.threeShapes = new THREE.Object3D();\n\t\t\tthis.three.add(this.threeShapes);\n\n\t\t\tlet material = new THREE.MeshLambertMaterial({\n\t\t\t\tcolor: 0xff0000,\n\t\t\t\twireframe: true\n\t\t\t});\n\n\t\t\tthis.oldShapes = clone.array(physics.cannon.shapes);\n\n\t\t\tphysics.cannon.shapes.forEach(function(cannonShape, i) {\n\t\t\t\tlet mesh = new THREE.Mesh(\n\t\t\t\t\tnew THREE.CubeGeometry(\n\t\t\t\t\t\tcannonShape.halfExtents.x * 2,\n\t\t\t\t\t\tcannonShape.halfExtents.y * 2,\n\t\t\t\t\t\tcannonShape.halfExtents.z * 2\n\t\t\t\t\t),\n\t\t\t\t\tmaterial\n\t\t\t\t);\n\t\t\t\tlet position = physics.cannon.shapeOffsets[i];\n\t\t\t\tmesh.position.set(position.x, position.y, position.z);\n\t\t\t\tlet rotation = physics.cannon.shapeOrientations[i];\n\t\t\t\tmesh.useQuaternion = true;\n\t\t\t\tmesh.quaternion.set(rotation.x, rotation.y, rotation.z, rotation.w);\n\t\t\t\tthis.threeShapes.add(mesh);\n\t\t\t}.bind(this));\n\n\t\t}\n\t}\n\t\t\n};\n\n\n\n\n\n\n\nfunction ThreeAxis() {\n\treturn ThreeAxis.prototype.clone();\n}\n\nThreeAxis.prototype = (function() {\n\n\tlet three = new THREE.Object3D();\n\n\tlet LENGTH = 2;\n\tlet HALF_LENGTH = LENGTH/2;\n\tlet THICKNESS = .001;\n\n\tlet xAxis = new THREE.Mesh(\n\t\tnew THREE.CubeGeometry(LENGTH, THICKNESS, THICKNESS),\n\t\tnew THREE.MeshBasicMaterial({\n\t\t\tcolor: 0xff0000,\n\t\t\twireframe: true\n\t\t})\n\t);\n\txAxis.position.setX(HALF_LENGTH);\n\txAxis.castShadow = xAxis.receiveShadow = false;\n\tthree.add(xAxis);\n\n\tlet yAxis = new THREE.Mesh(\n\t\tnew THREE.CubeGeometry(THICKNESS, LENGTH, THICKNESS),\n\t\tnew THREE.MeshBasicMaterial({\n\t\t\tcolor: 0x00ff00,\n\t\t\twireframe: true\n\t\t})\n\t);\n\tyAxis.position.setY(HALF_LENGTH);\n\tyAxis.castShadow = yAxis.receiveShadow = false;\n\tthree.add(yAxis);\n\n\tlet zAxis = new THREE.Mesh(\n\t\tnew THREE.CubeGeometry(THICKNESS, THICKNESS, LENGTH),\n\t\tnew THREE.MeshBasicMaterial({\n\t\t\tcolor: 0x0000ff,\n\t\t\twireframe: true\n\t\t})\n\t);\n\tzAxis.position.setZ(HALF_LENGTH);\n\tzAxis.castShadow = zAxis.receiveShadow = false;\n\tthree.add(zAxis);\n\n\treturn three;\n\n})();\n\nexport default PhysicsDebugComponent;\n\n\n\n/** WEBPACK FOOTER **\n ** ./view/PhysicsDebugComponent.js\n **/","\nimport Vector from './Vector';\n\nlet Position = Vector.createClass({x: 0, y: 0, z: 0});\n\nPosition.shim = function(targetObject, hiddenVector) {\n\tVector.shim(targetObject, 'position', new Position(), hiddenVector);\n}\n\nexport default Position;\n\n\n\n/** WEBPACK FOOTER **\n ** ../game/physics/Position.js\n **/","\nexport default class Vector {\n\n\tstatic createClass(vals) {\n\t\tfunction Klass() {\n\t\t\tthis.points = Object.keys(vals);\n\t\t\tthis.set(vals);\n\t\t};\n\t\tKlass.prototype.__proto__ = Vector.prototype;\n\t\treturn Klass;\n\t}\n\t\n\tconstructor(vals) {\n\t\tthis.points = Object.keys(vals);\n\t\tthis.set(vals);\n\t}\n\n\tset(vals) {\n\t\tfor (let prop in vals) {\n\t\t\tthis[prop] = vals[prop];\n\t\t}\n\t}\n\n\tget() {\n\t\tvar result = {};\n\t\tthis.points.forEach(function(dim) {\n\t\t\tresult[dim] = this[dim];\n\t\t}.bind(this));\n\t\treturn result;\n\t}\n\n}\n\nVector.shim = function(targetObject, publicProperty, publicVector, hiddenVector) {\n\n\tpublicVector.points.forEach(function(prop) {\n\n\t\tdelete publicVector[prop];\n\n\t\tObject.defineProperty(publicVector, prop, {\n\t\t\tget: function() {\n\t\t\t\treturn hiddenVector[prop];\n\t\t\t},\n\t\t\tset: function(val) {\n\t\t\t\thiddenVector[prop] = val;\n\t\t\t}\n\t\t});\n\n\t});\n\n\tObject.defineProperty(targetObject, publicProperty, {\n\t\tget: function() {\n\t\t\treturn publicVector;\n\t\t},\n\t\tset: function(val) {\n\t\t\tpublicVector.set(val);\n\t\t}\n\t});\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ../game/physics/Vector.js\n **/","\nimport Vector from './Vector';\n\nlet Rotation = Vector.createClass({w: 1, x: 0, y: 0, z: 0});\n\nRotation.prototype.normalize = function() {\n\tvar length = Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);\n\tif (length === 0) {\n\t\tthis.w = this.x = this.y = this.z = 0;\n\t} else {\n\t\tlength = 1/length;\n\t\tthis.w *= length;\n\t\tthis.x *= length;\n\t\tthis.y *= length;\n\t\tthis.z *= length;\n\t}\n};\n\nRotation.prototype.rotate = function(vector4) {\n\tvar a = this;\n\tvar b = vector4;\n\tthis.set({\n        w: a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z,  // 1\n        x: a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y,  // i\n        y: a.w * b.y - a.x * b.z + a.y * b.w + a.z * b.x,  // j\n        z: a.w * b.z + a.x * b.y - a.y * b.x + a.z * b.w   // k\n\t});\n\tthis.normalize();\n};\n\nRotation.prototype.setFromEuler = function(euler) {\n\n\tvar bank = euler.x;\n\tvar heading = euler.y;\n\tvar attitude = euler.z;\n\n\tvar c1 = Math.cos(heading / 2);\n\tvar c2 = Math.cos(attitude / 2)\n\tvar c3 = Math.cos(bank / 2)\n\tvar s1 = Math.sin(heading / 2)\n\tvar s2 = Math.sin(attitude / 2)\n\tvar s3 = Math.sin(bank / 2)\n\n\tthis.set({\n\t\tw: c1 * c2 * c3 - s1 * s2 * s3,\n\t\tx: s1 * s2 * c3 + c1 * c2 * s3,\n\t\ty: s1 * c2 * c3 + c1 * s2 * s3,\n\t\tz: c1 * s2 * c3 - s1 * c2 * s3\n\t});\n};\n\nRotation.shim = function(targetObject, hiddenVector) {\n\tVector.shim(targetObject, 'rotation', new Rotation(), hiddenVector);\n};\n\nRotation.createFromAxisAngle = function(vector3, radians) {\n\tvar factor = Math.sin(radians/2);\n\tvar rotation = new Rotation();\n\trotation.set({\n\t\tx: vector3.x * factor,\n\t\ty: vector3.y * factor,\n\t\tz: vector3.z * factor,\n\t\tw: Math.cos(radians/2)\n\t});\n\trotation.normalize();\n\treturn rotation;\n};\n\nexport default Rotation;\n\n\n\n/** WEBPACK FOOTER **\n ** ../game/physics/Rotation.js\n **/","\nimport Vector from './Vector';\n\nlet Velocity = Vector.createClass({x: 0, y: 0, z: 0});\n\nVelocity.shim = function(targetObject, hiddenVector) {\n\tVector.shim(targetObject, 'velocity', new Velocity(), hiddenVector);\n}\n\nexport default Velocity;\n\n\n\n/** WEBPACK FOOTER **\n ** ../game/physics/Velocity.js\n **/","\nlet compare = {\n\tarrays: function(a, b) {\n\t\tif (a === b) {\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif (a.length !== b.length) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (a.find(\n\t\t\tfunction(val,i) { return b[i] !== val; }\n\t\t)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n};\n\nexport default compare;\n\n\n\n/** WEBPACK FOOTER **\n ** ../shared/compare.js\n **/","\nlet clone = {\n\tarray: function(arr) {\n\t\treturn [].concat(arr);\n\t}\n};\n\nexport default clone;\n\n\n\n/** WEBPACK FOOTER **\n ** ../shared/clone.js\n **/","\nimport THREE from 'three';\n\nexport default class ConstraintDebugView {\n\t\n\tconstructor(cannonConstraint) {\n\t\tthis.cannon = cannonConstraint;\n\t\tthis.three = new THREE.Object3D();\n\t}\n\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./view/debug/ConstraintDebugView.js\n **/"],"sourceRoot":""}