/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _FPTClient = __webpack_require__(2);\n\nvar _FPTClient2 = _interopRequireDefault(_FPTClient);\n\nvar _three = __webpack_require__(32);\n\nvar _three2 = _interopRequireDefault(_three);\n\nvar _cannon = __webpack_require__(9);\n\nvar _cannon2 = _interopRequireDefault(_cannon);\n\nvar _THREE = __webpack_require__(47);\n\nvar _THREE2 = _interopRequireDefault(_THREE);\n\nvar _TestBall = __webpack_require__(48);\n\nvar _TestBall2 = _interopRequireDefault(_TestBall);\n\nvar _PhysicsDebugView = __webpack_require__(50);\n\nvar _PhysicsDebugView2 = _interopRequireDefault(_PhysicsDebugView);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar client = _FPTClient2.default.create();\n\ndocument.body.appendChild(client.view.element);\n\n// debugging stuff\n\nconsole.debug('dummybuild', 1);\n\nwindow.THREE = _three2.default;\nwindow.CANNON = _cannon2.default;\nwindow.client = client;\n\nvar orbitControls = new _THREE2.default(client.view.camera);\nsetInterval(orbitControls.update.bind(orbitControls), 40);\n\nvar lamp = new _three2.default.HemisphereLight(0xffffff, .5);\nlamp.position.set(0, 10, 0);\nclient.view.scene.add(lamp);\n\nvar ball = _TestBall2.default.create({\n\tposition: { x: .7, y: 200, z: 0 }\n});\nball.debug = true;\nclient.game.entities.add(ball);\nwindow.ball = ball;\n\nvar physicsDebugView = _PhysicsDebugView2.default.create(client.view);\nclient.view.systems.add(physicsDebugView);//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdGFydC5qcz8zYTk1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQSxJQUFJLFNBQVMsb0JBQVUsTUFBVixFQUFiOztBQUVBLFNBQVMsSUFBVCxDQUFjLFdBQWQsQ0FBMEIsT0FBTyxJQUFQLENBQVksT0FBdEM7Ozs7QUFNQSxRQUFRLEtBQVIsQ0FBYyxZQUFkLEVBQTRCLENBQTVCOztBQUVBLE9BQU8sS0FBUDtBQUNBLE9BQU8sTUFBUDtBQUNBLE9BQU8sTUFBUCxHQUFnQixNQUFoQjs7QUFFQSxJQUFJLGdCQUFnQixvQkFBa0IsT0FBTyxJQUFQLENBQVksTUFBOUIsQ0FBcEI7QUFDQSxZQUFZLGNBQWMsTUFBZCxDQUFxQixJQUFyQixDQUEwQixhQUExQixDQUFaLEVBQXNELEVBQXREOztBQUdBLElBQUksT0FBTyxJQUFJLGdCQUFNLGVBQVYsQ0FBMEIsUUFBMUIsRUFBb0MsRUFBcEMsQ0FBWDtBQUNBLEtBQUssUUFBTCxDQUFjLEdBQWQsQ0FBa0IsQ0FBbEIsRUFBcUIsRUFBckIsRUFBeUIsQ0FBekI7QUFDQSxPQUFPLElBQVAsQ0FBWSxLQUFaLENBQWtCLEdBQWxCLENBQXNCLElBQXRCOztBQUVBLElBQUksT0FBTyxtQkFBUyxNQUFULENBQ1Y7QUFDQyxXQUFVLEVBQUMsR0FBRyxFQUFKLEVBQVEsR0FBRyxHQUFYLEVBQWdCLEdBQUcsQ0FBbkI7QUFEWCxDQURVLENBQVg7QUFLQSxLQUFLLEtBQUwsR0FBYSxJQUFiO0FBQ0EsT0FBTyxJQUFQLENBQVksUUFBWixDQUFxQixHQUFyQixDQUF5QixJQUF6QjtBQUNBLE9BQU8sSUFBUCxHQUFjLElBQWQ7O0FBRUEsSUFBSSxtQkFBbUIsMkJBQWlCLE1BQWpCLENBQXdCLE9BQU8sSUFBL0IsQ0FBdkI7QUFDQSxPQUFPLElBQVAsQ0FBWSxPQUFaLENBQW9CLEdBQXBCLENBQXdCLGdCQUF4QiIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgRlBUQ2xpZW50IGZyb20gJy4vRlBUQ2xpZW50JztcbmltcG9ydCBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgQ0FOTk9OIGZyb20gJ2Nhbm5vbic7XG5pbXBvcnQgT3JiaXRDb250cm9scyBmcm9tICcuL1RIUkVFLk9yYml0Q29udHJvbHMnO1xuaW1wb3J0IFRlc3RCYWxsIGZyb20gJy4uL2dhbWUvdGVzdEJhbGwvVGVzdEJhbGwnO1xuaW1wb3J0IFBoeXNpY3NEZWJ1Z1ZpZXcgZnJvbSAnLi92aWV3L1BoeXNpY3NEZWJ1Z1ZpZXcnO1xuXG52YXIgY2xpZW50ID0gRlBUQ2xpZW50LmNyZWF0ZSgpO1xuXG5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNsaWVudC52aWV3LmVsZW1lbnQpO1xuXG5cblxuLy8gZGVidWdnaW5nIHN0dWZmXG5cbmNvbnNvbGUuZGVidWcoJ2R1bW15YnVpbGQnLCAxKTtcblxud2luZG93LlRIUkVFID0gVEhSRUU7XG53aW5kb3cuQ0FOTk9OID0gQ0FOTk9OO1xud2luZG93LmNsaWVudCA9IGNsaWVudDtcblxubGV0IG9yYml0Q29udHJvbHMgPSBuZXcgT3JiaXRDb250cm9scyhjbGllbnQudmlldy5jYW1lcmEpO1xuc2V0SW50ZXJ2YWwob3JiaXRDb250cm9scy51cGRhdGUuYmluZChvcmJpdENvbnRyb2xzKSwgNDApO1xuXG5cbmxldCBsYW1wID0gbmV3IFRIUkVFLkhlbWlzcGhlcmVMaWdodCgweGZmZmZmZiwgLjUpO1xubGFtcC5wb3NpdGlvbi5zZXQoMCwgMTAsIDApO1xuY2xpZW50LnZpZXcuc2NlbmUuYWRkKGxhbXApO1xuXG5sZXQgYmFsbCA9IFRlc3RCYWxsLmNyZWF0ZShcblx0e1xuXHRcdHBvc2l0aW9uOiB7eDogLjcsIHk6IDIwMCwgejogMH1cblx0fVxuKTtcbmJhbGwuZGVidWcgPSB0cnVlO1xuY2xpZW50LmdhbWUuZW50aXRpZXMuYWRkKGJhbGwpO1xud2luZG93LmJhbGwgPSBiYWxsO1xuXG5sZXQgcGh5c2ljc0RlYnVnVmlldyA9IFBoeXNpY3NEZWJ1Z1ZpZXcuY3JlYXRlKGNsaWVudC52aWV3KTtcbmNsaWVudC52aWV3LnN5c3RlbXMuYWRkKHBoeXNpY3NEZWJ1Z1ZpZXcpO1xuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3N0YXJ0LmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _FPTGame = __webpack_require__(3);\n\nvar _FPTGame2 = _interopRequireDefault(_FPTGame);\n\nvar _FPTGameView = __webpack_require__(31);\n\nvar _FPTGameView2 = _interopRequireDefault(_FPTGameView);\n\nvar _TestLevel = __webpack_require__(42);\n\nvar _TestLevel2 = _interopRequireDefault(_TestLevel);\n\nvar _ClientConnection = __webpack_require__(43);\n\nvar _ClientConnection2 = _interopRequireDefault(_ClientConnection);\n\nvar _ClientSession = __webpack_require__(45);\n\nvar _ClientSession2 = _interopRequireDefault(_ClientSession);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar FPTClient = function () {\n\tfunction FPTClient() {\n\t\t_classCallCheck(this, FPTClient);\n\n\t\tthis.game = _FPTGame2.default.create();\n\t\tthis.game.setLevel(_TestLevel2.default.create());\n\t\tthis.view = _FPTGameView2.default.create(this.game);\n\n\t\tthis.connection = _ClientConnection2.default.create();\n\t\tthis.session = _ClientSession2.default.create(this.connection);\n\t}\n\n\t_createClass(FPTClient, null, [{\n\t\tkey: 'create',\n\t\tvalue: function create() {\n\t\t\treturn new FPTClient();\n\t\t}\n\t}]);\n\n\treturn FPTClient;\n}();\n\nexports.default = FPTClient;\n;//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9GUFRDbGllbnQuanM/NDc0OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7O0lBRXFCLFM7QUFFcEIsVUFGb0IsU0FFcEIsR0FBYztBQUFBLHdCQUZNLFNBRU47O0FBQ2IsT0FBSyxJQUFMLEdBQVksa0JBQVEsTUFBUixFQUFaO0FBQ0EsT0FBSyxJQUFMLENBQVUsUUFBVixDQUFtQixvQkFBVyxNQUFYLEVBQW5CO0FBQ0EsT0FBSyxJQUFMLEdBQVksc0JBQVksTUFBWixDQUFtQixLQUFLLElBQXhCLENBQVo7O0FBRUEsT0FBSyxVQUFMLEdBQWtCLDJCQUFpQixNQUFqQixFQUFsQjtBQUNBLE9BQUssT0FBTCxHQUFlLHdCQUFjLE1BQWQsQ0FBcUIsS0FBSyxVQUExQixDQUFmO0FBQ0E7O2NBVG1CLFM7OzJCQVdKO0FBQ2YsVUFBTyxJQUFJLFNBQUosRUFBUDtBQUNBOzs7UUFibUIsUzs7O2tCQUFBLFM7QUFlcEIiLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IEZQVEdhbWUgZnJvbSAnLi4vZ2FtZS9GUFRHYW1lJztcbmltcG9ydCBGUFRHYW1lVmlldyBmcm9tICcuL3ZpZXcvRlBUR2FtZVZpZXcnO1xuaW1wb3J0IFRlc3RMZXZlbDEgZnJvbSAnLi4vbGV2ZWxzL1Rlc3RMZXZlbDEnO1xuaW1wb3J0IENsaWVudENvbm5lY3Rpb24gZnJvbSAnLi9DbGllbnRDb25uZWN0aW9uJztcbmltcG9ydCBDbGllbnRTZXNzaW9uIGZyb20gJy4vQ2xpZW50U2Vzc2lvbic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZQVENsaWVudCB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0dGhpcy5nYW1lID0gRlBUR2FtZS5jcmVhdGUoKTtcblx0XHR0aGlzLmdhbWUuc2V0TGV2ZWwoVGVzdExldmVsMS5jcmVhdGUoKSk7XG5cdFx0dGhpcy52aWV3ID0gRlBUR2FtZVZpZXcuY3JlYXRlKHRoaXMuZ2FtZSk7XG5cblx0XHR0aGlzLmNvbm5lY3Rpb24gPSBDbGllbnRDb25uZWN0aW9uLmNyZWF0ZSgpO1xuXHRcdHRoaXMuc2Vzc2lvbiA9IENsaWVudFNlc3Npb24uY3JlYXRlKHRoaXMuY29ubmVjdGlvbik7XG5cdH1cblxuXHRzdGF0aWMgY3JlYXRlKCkge1xuXHRcdHJldHVybiBuZXcgRlBUQ2xpZW50KCk7XG5cdH1cblxufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vRlBUQ2xpZW50LmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _System = __webpack_require__(4);\n\nvar _System2 = _interopRequireDefault(_System);\n\nvar _EntityCollection = __webpack_require__(6);\n\nvar _EntityCollection2 = _interopRequireDefault(_EntityCollection);\n\nvar _Ticker = __webpack_require__(7);\n\nvar _Ticker2 = _interopRequireDefault(_Ticker);\n\nvar _Physics = __webpack_require__(8);\n\nvar _Physics2 = _interopRequireDefault(_Physics);\n\nvar _Level = __webpack_require__(10);\n\nvar _Level2 = _interopRequireDefault(_Level);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar FPTGame = _System2.default.createClass({\n\n\tconstructor: function constructor() {\n\t\tthis.entities = _EntityCollection2.default.create();\n\n\t\tthis.physics = _Physics2.default.create(this);\n\n\t\tthis.systems.add(this.physics);\n\n\t\tthis._ticker = _Ticker2.default.create(1000 / 60, this.tick.bind(this));\n\t},\n\n\tsetLevel: function setLevel(level) {\n\t\tthis.level = level;\n\t\tthis.systems.add(level);\n\t\tthis.entities.add(level.entity);\n\t\tthis.level.onLoaded(this.start.bind(this));\n\t},\n\n\tstart: function start() {\n\t\tthis.physics.playing = true;\n\t}\n\n});\n\nFPTGame.create = function () {\n\treturn new FPTGame();\n};\n\nexports.default = FPTGame;//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vZ2FtZS9GUFRHYW1lLmpzPzNmZDgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUEsSUFBSSxVQUFVLGlCQUFPLFdBQVAsQ0FBbUI7O0FBRWhDLGNBQWEsdUJBQVc7QUFDdkIsT0FBSyxRQUFMLEdBQWdCLDJCQUFpQixNQUFqQixFQUFoQjs7QUFFQSxPQUFLLE9BQUwsR0FBZSxrQkFBUSxNQUFSLENBQWUsSUFBZixDQUFmOztBQUVBLE9BQUssT0FBTCxDQUFhLEdBQWIsQ0FBaUIsS0FBSyxPQUF0Qjs7QUFFQSxPQUFLLE9BQUwsR0FBZSxpQkFBTyxNQUFQLENBQWMsT0FBSyxFQUFuQixFQUF1QixLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsSUFBZixDQUF2QixDQUFmO0FBQ0EsRUFWK0I7O0FBWWhDLFdBQVUsa0JBQVMsS0FBVCxFQUFnQjtBQUN6QixPQUFLLEtBQUwsR0FBYSxLQUFiO0FBQ0EsT0FBSyxPQUFMLENBQWEsR0FBYixDQUFpQixLQUFqQjtBQUNBLE9BQUssUUFBTCxDQUFjLEdBQWQsQ0FBa0IsTUFBTSxNQUF4QjtBQUNBLE9BQUssS0FBTCxDQUFXLFFBQVgsQ0FBb0IsS0FBSyxLQUFMLENBQVcsSUFBWCxDQUFnQixJQUFoQixDQUFwQjtBQUNBLEVBakIrQjs7QUFtQmhDLFFBQU8saUJBQVc7QUFDakIsT0FBSyxPQUFMLENBQWEsT0FBYixHQUF1QixJQUF2QjtBQUNBOztBQXJCK0IsQ0FBbkIsQ0FBZDs7QUF5QkEsUUFBUSxNQUFSLEdBQWlCLFlBQVc7QUFDM0IsUUFBTyxJQUFJLE9BQUosRUFBUDtBQUNBLENBRkQ7O2tCQUllLE8iLCJmaWxlIjoiMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IFN5c3RlbSBmcm9tICcuL2Vjcy9TeXN0ZW0nO1xuaW1wb3J0IEVudGl0eUNvbGxlY3Rpb24gZnJvbSAnLi9lY3MvRW50aXR5Q29sbGVjdGlvbic7XG5pbXBvcnQgVGlja2VyIGZyb20gJy4vVGlja2VyJztcbmltcG9ydCBQaHlzaWNzIGZyb20gJy4vcGh5c2ljcy9QaHlzaWNzJztcbmltcG9ydCBMZXZlbCBmcm9tICcuLi9sZXZlbHMvTGV2ZWwnO1xuXG52YXIgRlBUR2FtZSA9IFN5c3RlbS5jcmVhdGVDbGFzcyh7XG5cblx0Y29uc3RydWN0b3I6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZW50aXRpZXMgPSBFbnRpdHlDb2xsZWN0aW9uLmNyZWF0ZSgpO1xuXG5cdFx0dGhpcy5waHlzaWNzID0gUGh5c2ljcy5jcmVhdGUodGhpcyk7XG5cblx0XHR0aGlzLnN5c3RlbXMuYWRkKHRoaXMucGh5c2ljcyk7XG5cblx0XHR0aGlzLl90aWNrZXIgPSBUaWNrZXIuY3JlYXRlKDEwMDAvNjAsIHRoaXMudGljay5iaW5kKHRoaXMpKTtcblx0fSxcblxuXHRzZXRMZXZlbDogZnVuY3Rpb24obGV2ZWwpIHtcblx0XHR0aGlzLmxldmVsID0gbGV2ZWw7XG5cdFx0dGhpcy5zeXN0ZW1zLmFkZChsZXZlbCk7XG5cdFx0dGhpcy5lbnRpdGllcy5hZGQobGV2ZWwuZW50aXR5KTtcblx0XHR0aGlzLmxldmVsLm9uTG9hZGVkKHRoaXMuc3RhcnQuYmluZCh0aGlzKSk7XG5cdH0sXG5cblx0c3RhcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucGh5c2ljcy5wbGF5aW5nID0gdHJ1ZTtcblx0fVxuXG59KTtcblxuRlBUR2FtZS5jcmVhdGUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIG5ldyBGUFRHYW1lKCk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBGUFRHYW1lO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vZ2FtZS9GUFRHYW1lLmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _SystemCollection = __webpack_require__(5);\n\nvar _SystemCollection2 = _interopRequireDefault(_SystemCollection);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar System = function () {\n\t_createClass(System, null, [{\n\t\tkey: 'createClass',\n\t\tvalue: function createClass(props) {\n\t\t\tfunction Klass() {\n\t\t\t\tSystem.call(this);\n\t\t\t\tprops.constructor.apply(this, arguments);\n\t\t\t};\n\t\t\tKlass.prototype = props;\n\t\t\tprops.__proto__ = System.prototype;\n\t\t\treturn Klass;\n\t\t}\n\t}, {\n\t\tkey: 'create',\n\t\tvalue: function create() {\n\t\t\treturn new System();\n\t\t}\n\t}]);\n\n\tfunction System() {\n\t\t_classCallCheck(this, System);\n\n\t\tthis.systems = _SystemCollection2.default.create();\n\t}\n\n\t_createClass(System, [{\n\t\tkey: 'tick',\n\t\tvalue: function tick(ms) {\n\t\t\tif (this.entities) {\n\t\t\t\tthis.entities.forEach(function (entity) {\n\t\t\t\t\tthis.tickEntity(entity, ms);\n\t\t\t\t}.bind(this));\n\t\t\t}\n\t\t\tthis.tickSubsystems(ms);\n\t\t}\n\t}, {\n\t\tkey: 'tickEntity',\n\t\tvalue: function tickEntity(entity, ms) {}\n\t}, {\n\t\tkey: 'tickSubsystems',\n\t\tvalue: function tickSubsystems(ms) {\n\t\t\tthis.systems.forEach(function (system) {\n\t\t\t\treturn system.tick(ms);\n\t\t\t});\n\t\t}\n\t}]);\n\n\treturn System;\n}();\n\nexports.default = System;//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vZ2FtZS9lY3MvU3lzdGVtLmpzP2FjZjEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFDQTs7Ozs7Ozs7SUFFTSxNO2NBQUEsTTs7OEJBRWMsSyxFQUFPO0FBQ3pCLFlBQVMsS0FBVCxHQUFpQjtBQUNoQixXQUFPLElBQVAsQ0FBWSxJQUFaO0FBQ0EsVUFBTSxXQUFOLENBQWtCLEtBQWxCLENBQXdCLElBQXhCLEVBQTZCLFNBQTdCO0FBQ0E7QUFDRCxTQUFNLFNBQU4sR0FBa0IsS0FBbEI7QUFDQSxTQUFNLFNBQU4sR0FBa0IsT0FBTyxTQUF6QjtBQUNBLFVBQU8sS0FBUDtBQUNBOzs7MkJBRWU7QUFDZixVQUFPLElBQUksTUFBSixFQUFQO0FBQ0E7OztBQUVELFVBaEJLLE1BZ0JMLEdBQWM7QUFBQSx3QkFoQlQsTUFnQlM7O0FBQ2IsT0FBSyxPQUFMLEdBQWUsMkJBQWlCLE1BQWpCLEVBQWY7QUFDQTs7Y0FsQkksTTs7dUJBb0JBLEUsRUFBSTtBQUNSLE9BQUksS0FBSyxRQUFULEVBQW1CO0FBQ2xCLFNBQUssUUFBTCxDQUFjLE9BQWQsQ0FBc0IsVUFBUyxNQUFULEVBQWlCO0FBQ3RDLFVBQUssVUFBTCxDQUFnQixNQUFoQixFQUF3QixFQUF4QjtBQUNBLEtBRnFCLENBRXBCLElBRm9CLENBRWYsSUFGZSxDQUF0QjtBQUdBO0FBQ0QsUUFBSyxjQUFMLENBQW9CLEVBQXBCO0FBQ0E7Ozs2QkFFVSxNLEVBQVEsRSxFQUFJLENBQUU7OztpQ0FFVixFLEVBQUk7QUFDbEIsUUFBSyxPQUFMLENBQWEsT0FBYixDQUFxQjtBQUFBLFdBQVUsT0FBTyxJQUFQLENBQVksRUFBWixDQUFWO0FBQUEsSUFBckI7QUFDQTs7O1FBakNJLE07OztrQkFxQ1MsTSIsImZpbGUiOiI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgU3lzdGVtQ29sbGVjdGlvbiBmcm9tICcuL1N5c3RlbUNvbGxlY3Rpb24nO1xuXG5jbGFzcyBTeXN0ZW0ge1xuXHRcblx0c3RhdGljIGNyZWF0ZUNsYXNzKHByb3BzKSB7XG5cdFx0ZnVuY3Rpb24gS2xhc3MoKSB7XG5cdFx0XHRTeXN0ZW0uY2FsbCh0aGlzKTtcblx0XHRcdHByb3BzLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtcblx0XHR9O1xuXHRcdEtsYXNzLnByb3RvdHlwZSA9IHByb3BzO1xuXHRcdHByb3BzLl9fcHJvdG9fXyA9IFN5c3RlbS5wcm90b3R5cGU7XG5cdFx0cmV0dXJuIEtsYXNzO1xuXHR9XG5cblx0c3RhdGljIGNyZWF0ZSgpIHtcblx0XHRyZXR1cm4gbmV3IFN5c3RlbSgpO1xuXHR9XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0dGhpcy5zeXN0ZW1zID0gU3lzdGVtQ29sbGVjdGlvbi5jcmVhdGUoKTtcblx0fVxuXG5cdHRpY2sobXMpIHtcblx0XHRpZiAodGhpcy5lbnRpdGllcykge1xuXHRcdFx0dGhpcy5lbnRpdGllcy5mb3JFYWNoKGZ1bmN0aW9uKGVudGl0eSkge1xuXHRcdFx0XHR0aGlzLnRpY2tFbnRpdHkoZW50aXR5LCBtcyk7XG5cdFx0XHR9LmJpbmQodGhpcykpO1xuXHRcdH1cblx0XHR0aGlzLnRpY2tTdWJzeXN0ZW1zKG1zKTtcblx0fVxuXG5cdHRpY2tFbnRpdHkoZW50aXR5LCBtcykge31cblxuXHR0aWNrU3Vic3lzdGVtcyhtcykge1xuXHRcdHRoaXMuc3lzdGVtcy5mb3JFYWNoKHN5c3RlbSA9PiBzeXN0ZW0udGljayhtcykpO1xuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgU3lzdGVtO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vZ2FtZS9lY3MvU3lzdGVtLmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 5 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar SystemCollection = function () {\n\t_createClass(SystemCollection, null, [{\n\t\tkey: \"create\",\n\t\tvalue: function create() {\n\t\t\treturn new SystemCollection();\n\t\t}\n\t}]);\n\n\tfunction SystemCollection() {\n\t\t_classCallCheck(this, SystemCollection);\n\n\t\tthis._systems = [];\n\t}\n\n\t_createClass(SystemCollection, [{\n\t\tkey: \"add\",\n\t\tvalue: function add(system) {\n\t\t\tthis._systems.push(system);\n\t\t}\n\t}, {\n\t\tkey: \"forEach\",\n\t\tvalue: function forEach(callback) {\n\t\t\tthis._systems.forEach(callback);\n\t\t}\n\t}]);\n\n\treturn SystemCollection;\n}();\n\nexports.default = SystemCollection;//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vZ2FtZS9lY3MvU3lzdGVtQ29sbGVjdGlvbi5qcz9lNWU3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7SUFDcUIsZ0I7Y0FBQSxnQjs7MkJBRUo7QUFDZixVQUFPLElBQUksZ0JBQUosRUFBUDtBQUNBOzs7QUFFRCxVQU5vQixnQkFNcEIsR0FBYztBQUFBLHdCQU5NLGdCQU1OOztBQUNiLE9BQUssUUFBTCxHQUFnQixFQUFoQjtBQUNBOztjQVJtQixnQjs7c0JBVWhCLE0sRUFBUTtBQUNYLFFBQUssUUFBTCxDQUFjLElBQWQsQ0FBbUIsTUFBbkI7QUFDQTs7OzBCQUVPLFEsRUFBVTtBQUNqQixRQUFLLFFBQUwsQ0FBYyxPQUFkLENBQXNCLFFBQXRCO0FBQ0E7OztRQWhCbUIsZ0I7OztrQkFBQSxnQiIsImZpbGUiOiI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTeXN0ZW1Db2xsZWN0aW9uIHtcblx0XG5cdHN0YXRpYyBjcmVhdGUoKSB7XG5cdFx0cmV0dXJuIG5ldyBTeXN0ZW1Db2xsZWN0aW9uKCk7XG5cdH1cblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLl9zeXN0ZW1zID0gW107XG5cdH1cblxuXHRhZGQoc3lzdGVtKSB7XG5cdFx0dGhpcy5fc3lzdGVtcy5wdXNoKHN5c3RlbSk7XG5cdH1cblxuXHRmb3JFYWNoKGNhbGxiYWNrKSB7XG5cdFx0dGhpcy5fc3lzdGVtcy5mb3JFYWNoKGNhbGxiYWNrKTtcblx0fVxuXG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9nYW1lL2Vjcy9TeXN0ZW1Db2xsZWN0aW9uLmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 6 */
/***/ function(module, exports) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar EntityCollection = function () {\n\t_createClass(EntityCollection, null, [{\n\t\tkey: 'create',\n\t\tvalue: function create() {\n\t\t\treturn new EntityCollection();\n\t\t}\n\t}]);\n\n\tfunction EntityCollection() {\n\t\t_classCallCheck(this, EntityCollection);\n\n\t\tthis._hash = {};\n\t\tthis._entities = [];\n\t}\n\n\t_createClass(EntityCollection, [{\n\t\tkey: 'add',\n\t\tvalue: function add(name, entity) {\n\t\t\tif (typeof name === 'string') {\n\t\t\t\tthis._hash[name] = entity;\n\t\t\t} else {\n\t\t\t\tentity = name;\n\t\t\t}\n\t\t\tthis._entities.push(entity);\n\t\t}\n\t}, {\n\t\tkey: 'get',\n\t\tvalue: function get(name) {\n\t\t\treturn this._hash[name];\n\t\t}\n\t}, {\n\t\tkey: 'forEach',\n\t\tvalue: function forEach(callback) {\n\t\t\tthis._entities.forEach(callback);\n\t\t}\n\t}]);\n\n\treturn EntityCollection;\n}();\n\nexports.default = EntityCollection;//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vZ2FtZS9lY3MvRW50aXR5Q29sbGVjdGlvbi5qcz83OGRmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7SUFDcUIsZ0I7Y0FBQSxnQjs7MkJBRUo7QUFDZixVQUFPLElBQUksZ0JBQUosRUFBUDtBQUNBOzs7QUFFRCxVQU5vQixnQkFNcEIsR0FBYztBQUFBLHdCQU5NLGdCQU1OOztBQUNiLE9BQUssS0FBTCxHQUFhLEVBQWI7QUFDQSxPQUFLLFNBQUwsR0FBaUIsRUFBakI7QUFDQTs7Y0FUbUIsZ0I7O3NCQVdoQixJLEVBQU0sTSxFQUFRO0FBQ2pCLE9BQUksT0FBTyxJQUFQLEtBQWdCLFFBQXBCLEVBQThCO0FBQzdCLFNBQUssS0FBTCxDQUFXLElBQVgsSUFBbUIsTUFBbkI7QUFDQSxJQUZELE1BRU87QUFDTixhQUFTLElBQVQ7QUFDQTtBQUNELFFBQUssU0FBTCxDQUFlLElBQWYsQ0FBb0IsTUFBcEI7QUFDQTs7O3NCQUVHLEksRUFBTTtBQUNULFVBQU8sS0FBSyxLQUFMLENBQVcsSUFBWCxDQUFQO0FBQ0E7OzswQkFFTyxRLEVBQVU7QUFDakIsUUFBSyxTQUFMLENBQWUsT0FBZixDQUF1QixRQUF2QjtBQUNBOzs7UUExQm1CLGdCOzs7a0JBQUEsZ0IiLCJmaWxlIjoiNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW50aXR5Q29sbGVjdGlvbiB7XG5cdFxuXHRzdGF0aWMgY3JlYXRlKCkge1xuXHRcdHJldHVybiBuZXcgRW50aXR5Q29sbGVjdGlvbigpO1xuXHR9XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0dGhpcy5faGFzaCA9IHt9O1xuXHRcdHRoaXMuX2VudGl0aWVzID0gW107XG5cdH1cblxuXHRhZGQobmFtZSwgZW50aXR5KSB7XG5cdFx0aWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xuXHRcdFx0dGhpcy5faGFzaFtuYW1lXSA9IGVudGl0eTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZW50aXR5ID0gbmFtZTtcblx0XHR9XG5cdFx0dGhpcy5fZW50aXRpZXMucHVzaChlbnRpdHkpO1xuXHR9XG5cblx0Z2V0KG5hbWUpIHtcblx0XHRyZXR1cm4gdGhpcy5faGFzaFtuYW1lXTtcblx0fVxuXG5cdGZvckVhY2goY2FsbGJhY2spIHtcblx0XHR0aGlzLl9lbnRpdGllcy5mb3JFYWNoKGNhbGxiYWNrKTtcblx0fVxuXG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9nYW1lL2Vjcy9FbnRpdHlDb2xsZWN0aW9uLmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 7 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Ticker = function () {\n\t_createClass(Ticker, null, [{\n\t\tkey: \"create\",\n\t\tvalue: function create(ms, callback) {\n\t\t\treturn new Ticker(ms, callback);\n\t\t}\n\t}]);\n\n\tfunction Ticker(ms, callback) {\n\t\t_classCallCheck(this, Ticker);\n\n\t\tthis._time = +new Date();\n\t\tthis._callback = callback;\n\t\tsetInterval(this._nextTick.bind(this), ms);\n\t}\n\n\t_createClass(Ticker, [{\n\t\tkey: \"_nextTick\",\n\t\tvalue: function _nextTick() {\n\t\t\tvar now = +new Date();\n\t\t\tvar ms = now - this._time;\n\t\t\tthis._time = now;\n\t\t\tthis._callback(ms);\n\t\t}\n\t}]);\n\n\treturn Ticker;\n}();\n\nexports.default = Ticker;\n;//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vZ2FtZS9UaWNrZXIuanM/YzMyMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0lBQ3FCLE07Y0FBQSxNOzt5QkFFTixFLEVBQUksUSxFQUFVO0FBQzNCLFVBQU8sSUFBSSxNQUFKLENBQVcsRUFBWCxFQUFlLFFBQWYsQ0FBUDtBQUNBOzs7QUFFRCxVQU5vQixNQU1wQixDQUFZLEVBQVosRUFBZ0IsUUFBaEIsRUFBMEI7QUFBQSx3QkFOTixNQU1NOztBQUN6QixPQUFLLEtBQUwsR0FBYSxDQUFFLElBQUksSUFBSixFQUFmO0FBQ0EsT0FBSyxTQUFMLEdBQWlCLFFBQWpCO0FBQ0EsY0FBWSxLQUFLLFNBQUwsQ0FBZSxJQUFmLENBQW9CLElBQXBCLENBQVosRUFBdUMsRUFBdkM7QUFDQTs7Y0FWbUIsTTs7OEJBWVI7QUFDWCxPQUFJLE1BQU0sQ0FBRSxJQUFJLElBQUosRUFBWjtBQUNBLE9BQUksS0FBSyxNQUFNLEtBQUssS0FBcEI7QUFDQSxRQUFLLEtBQUwsR0FBYSxHQUFiO0FBQ0EsUUFBSyxTQUFMLENBQWUsRUFBZjtBQUNBOzs7UUFqQm1CLE07OztrQkFBQSxNO0FBbUJwQiIsImZpbGUiOiI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaWNrZXIge1xuXG5cdHN0YXRpYyBjcmVhdGUobXMsIGNhbGxiYWNrKSB7XG5cdFx0cmV0dXJuIG5ldyBUaWNrZXIobXMsIGNhbGxiYWNrKTtcblx0fVxuXG5cdGNvbnN0cnVjdG9yKG1zLCBjYWxsYmFjaykge1xuXHRcdHRoaXMuX3RpbWUgPSArKG5ldyBEYXRlKCkpO1xuXHRcdHRoaXMuX2NhbGxiYWNrID0gY2FsbGJhY2s7XG5cdFx0c2V0SW50ZXJ2YWwodGhpcy5fbmV4dFRpY2suYmluZCh0aGlzKSwgbXMpO1xuXHR9XG5cblx0X25leHRUaWNrKCkge1xuXHRcdGxldCBub3cgPSArKG5ldyBEYXRlKCkpO1xuXHRcdGxldCBtcyA9IG5vdyAtIHRoaXMuX3RpbWU7XG5cdFx0dGhpcy5fdGltZSA9IG5vdztcblx0XHR0aGlzLl9jYWxsYmFjayhtcyk7XG5cdH1cblxufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL2dhbWUvVGlja2VyLmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _System = __webpack_require__(4);\n\nvar _System2 = _interopRequireDefault(_System);\n\nvar _cannon = __webpack_require__(9);\n\nvar _cannon2 = _interopRequireDefault(_cannon);\n\nvar _FPTGame = __webpack_require__(3);\n\nvar _FPTGame2 = _interopRequireDefault(_FPTGame);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Physics = _System2.default.createClass({\n\n\tconstructor: function constructor(fptGame) {\n\n\t\tthis.playing = false;\n\n\t\tthis.entities = fptGame.entities;\n\n\t\tvar world = new _cannon2.default.World();\n\t\tworld.gravity = new _cannon2.default.Vec3(0, -9.8, 0);\n\t\tworld.broadphase = new _cannon2.default.NaiveBroadphase();\n\t\tvar solver = new _cannon2.default.GSSolver();\n\t\tsolver.iterations = 7;\n\t\tworld.defaultContactMaterial.contactEquationRegularizationTime = 0.55;\n\t\tsolver.tolerance = 0.01;\n\t\tworld.solver = solver;\n\n\t\tworld.quatNormalizeFast = true;\n\t\tworld.quatNormalizeSkip = 0;\n\n\t\tworld.defaultContactMaterial.friction = 0.7;\n\t\tworld.defaultContactMaterial.restitution = 0.0;\n\t\tworld.defaultContactMaterial.contactEquationStiffness = 1e9;\n\t\tworld.defaultContactMaterial.contactEquationRegularizationTime = 4;\n\t\tworld.broadphase.useBoundingBoxes = true;\n\t\tworld.allowSleep = false;\n\n\t\tthis.world = world;\n\t},\n\n\ttick: function tick(ms, entityCollection) {\n\t\tthis.entities.forEach(this._prepareEntity.bind(this));\n\t\tif (this.playing) {\n\t\t\tthis.world.step(ms / 1000);\n\t\t}\n\t\tthis.tickSubsystems(ms);\n\t},\n\n\t_prepareEntity: function _prepareEntity(entity) {\n\t\tvar pieces = entity.get('pieces');\n\t\tif (pieces) {\n\t\t\tpieces.forEach(function (piece) {\n\t\t\t\tthis._prepareEntity(piece);\n\t\t\t}.bind(this));\n\t\t}\n\t\tvar physics = entity.get('physics');\n\t\tif (physics) {\n\t\t\tif (!physics.ready) {\n\t\t\t\tthis.world.add(physics.cannon);\n\t\t\t\tphysics.constraints.forEach(function (constraint) {\n\t\t\t\t\tconsole.info('adding constraint');\n\t\t\t\t\tthis.world.addConstraint(constraint);\n\t\t\t\t}.bind(this));\n\t\t\t}\n\t\t\tphysics.ready = true;\n\t\t}\n\t}\n\n});\n\nPhysics.create = function (fptGame) {\n\treturn new Physics(fptGame);\n};\n\nexports.default = Physics;//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vZ2FtZS9waHlzaWNzL1BoeXNpY3MuanM/OTFjNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUdBLElBQUksVUFBVSxpQkFBTyxXQUFQLENBQW1COztBQUVoQyxjQUFhLHFCQUFTLE9BQVQsRUFBa0I7O0FBRTlCLE9BQUssT0FBTCxHQUFlLEtBQWY7O0FBRUEsT0FBSyxRQUFMLEdBQWdCLFFBQVEsUUFBeEI7O0FBRUEsTUFBSSxRQUFRLElBQUksaUJBQU8sS0FBWCxFQUFaO0FBQ0EsUUFBTSxPQUFOLEdBQWdCLElBQUksaUJBQU8sSUFBWCxDQUFnQixDQUFoQixFQUFtQixDQUFDLEdBQXBCLEVBQXlCLENBQXpCLENBQWhCO0FBQ0EsUUFBTSxVQUFOLEdBQW1CLElBQUksaUJBQU8sZUFBWCxFQUFuQjtBQUNBLE1BQUksU0FBUyxJQUFJLGlCQUFPLFFBQVgsRUFBYjtBQUNBLFNBQU8sVUFBUCxHQUFvQixDQUFwQjtBQUNBLFFBQU0sc0JBQU4sQ0FBNkIsaUNBQTdCLEdBQWlFLElBQWpFO0FBQ0EsU0FBTyxTQUFQLEdBQW1CLElBQW5CO0FBQ0EsUUFBTSxNQUFOLEdBQWUsTUFBZjs7QUFFQSxRQUFNLGlCQUFOLEdBQTBCLElBQTFCO0FBQ0EsUUFBTSxpQkFBTixHQUEwQixDQUExQjs7QUFFQSxRQUFNLHNCQUFOLENBQTZCLFFBQTdCLEdBQXdDLEdBQXhDO0FBQ0EsUUFBTSxzQkFBTixDQUE2QixXQUE3QixHQUEyQyxHQUEzQztBQUNBLFFBQU0sc0JBQU4sQ0FBNkIsd0JBQTdCLEdBQXdELEdBQXhEO0FBQ0EsUUFBTSxzQkFBTixDQUE2QixpQ0FBN0IsR0FBaUUsQ0FBakU7QUFDQSxRQUFNLFVBQU4sQ0FBaUIsZ0JBQWpCLEdBQW9DLElBQXBDO0FBQ0EsUUFBTSxVQUFOLEdBQW1CLEtBQW5COztBQUVBLE9BQUssS0FBTCxHQUFhLEtBQWI7QUFDQSxFQTVCK0I7O0FBOEJoQyxPQUFNLGNBQVMsRUFBVCxFQUFhLGdCQUFiLEVBQStCO0FBQ3BDLE9BQUssUUFBTCxDQUFjLE9BQWQsQ0FBc0IsS0FBSyxjQUFMLENBQW9CLElBQXBCLENBQXlCLElBQXpCLENBQXRCO0FBQ0EsTUFBSSxLQUFLLE9BQVQsRUFBa0I7QUFDakIsUUFBSyxLQUFMLENBQVcsSUFBWCxDQUFnQixLQUFHLElBQW5CO0FBQ0E7QUFDRCxPQUFLLGNBQUwsQ0FBb0IsRUFBcEI7QUFDQSxFQXBDK0I7O0FBc0NoQyxpQkFBZ0Isd0JBQVMsTUFBVCxFQUFpQjtBQUNoQyxNQUFJLFNBQVMsT0FBTyxHQUFQLENBQVcsUUFBWCxDQUFiO0FBQ0EsTUFBSSxNQUFKLEVBQVk7QUFDWCxVQUFPLE9BQVAsQ0FBZSxVQUFTLEtBQVQsRUFBZ0I7QUFDOUIsU0FBSyxjQUFMLENBQW9CLEtBQXBCO0FBQ0EsSUFGYyxDQUViLElBRmEsQ0FFUixJQUZRLENBQWY7QUFHQTtBQUNELE1BQUksVUFBVSxPQUFPLEdBQVAsQ0FBVyxTQUFYLENBQWQ7QUFDQSxNQUFJLE9BQUosRUFBYTtBQUNaLE9BQUksQ0FBQyxRQUFRLEtBQWIsRUFBb0I7QUFDbkIsU0FBSyxLQUFMLENBQVcsR0FBWCxDQUFlLFFBQVEsTUFBdkI7QUFDQSxZQUFRLFdBQVIsQ0FBb0IsT0FBcEIsQ0FBNEIsVUFBUyxVQUFULEVBQXFCO0FBQ2hELGFBQVEsSUFBUixDQUFhLG1CQUFiO0FBQ0EsVUFBSyxLQUFMLENBQVcsYUFBWCxDQUF5QixVQUF6QjtBQUNBLEtBSDJCLENBRzFCLElBSDBCLENBR3JCLElBSHFCLENBQTVCO0FBSUE7QUFDRCxXQUFRLEtBQVIsR0FBZ0IsSUFBaEI7QUFDQTtBQUNEOztBQXhEK0IsQ0FBbkIsQ0FBZDs7QUE0REEsUUFBUSxNQUFSLEdBQWlCLFVBQVMsT0FBVCxFQUFrQjtBQUNsQyxRQUFPLElBQUksT0FBSixDQUFZLE9BQVosQ0FBUDtBQUNBLENBRkQ7O2tCQUllLE8iLCJmaWxlIjoiOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IFN5c3RlbSBmcm9tICcuLi9lY3MvU3lzdGVtJztcbmltcG9ydCBDQU5OT04gZnJvbSAnY2Fubm9uJztcbmltcG9ydCBGUFRHYW1lIGZyb20gJy4uL0ZQVEdhbWUnO1xuXG5cbnZhciBQaHlzaWNzID0gU3lzdGVtLmNyZWF0ZUNsYXNzKHtcblxuXHRjb25zdHJ1Y3RvcjogZnVuY3Rpb24oZnB0R2FtZSkge1xuXG5cdFx0dGhpcy5wbGF5aW5nID0gZmFsc2U7XG5cblx0XHR0aGlzLmVudGl0aWVzID0gZnB0R2FtZS5lbnRpdGllcztcblxuXHRcdHZhciB3b3JsZCA9IG5ldyBDQU5OT04uV29ybGQoKTtcblx0XHR3b3JsZC5ncmF2aXR5ID0gbmV3IENBTk5PTi5WZWMzKDAsIC05LjgsIDApO1xuXHRcdHdvcmxkLmJyb2FkcGhhc2UgPSBuZXcgQ0FOTk9OLk5haXZlQnJvYWRwaGFzZSgpO1xuXHRcdHZhciBzb2x2ZXIgPSBuZXcgQ0FOTk9OLkdTU29sdmVyKCk7XG5cdFx0c29sdmVyLml0ZXJhdGlvbnMgPSA3O1xuXHRcdHdvcmxkLmRlZmF1bHRDb250YWN0TWF0ZXJpYWwuY29udGFjdEVxdWF0aW9uUmVndWxhcml6YXRpb25UaW1lID0gMC41NTtcblx0XHRzb2x2ZXIudG9sZXJhbmNlID0gMC4wMTtcblx0XHR3b3JsZC5zb2x2ZXIgPSBzb2x2ZXI7XG5cblx0XHR3b3JsZC5xdWF0Tm9ybWFsaXplRmFzdCA9IHRydWU7XG5cdFx0d29ybGQucXVhdE5vcm1hbGl6ZVNraXAgPSAwO1xuXG5cdFx0d29ybGQuZGVmYXVsdENvbnRhY3RNYXRlcmlhbC5mcmljdGlvbiA9IDAuNztcblx0XHR3b3JsZC5kZWZhdWx0Q29udGFjdE1hdGVyaWFsLnJlc3RpdHV0aW9uID0gMC4wO1xuXHRcdHdvcmxkLmRlZmF1bHRDb250YWN0TWF0ZXJpYWwuY29udGFjdEVxdWF0aW9uU3RpZmZuZXNzID0gMWU5O1xuXHRcdHdvcmxkLmRlZmF1bHRDb250YWN0TWF0ZXJpYWwuY29udGFjdEVxdWF0aW9uUmVndWxhcml6YXRpb25UaW1lID0gNDtcblx0XHR3b3JsZC5icm9hZHBoYXNlLnVzZUJvdW5kaW5nQm94ZXMgPSB0cnVlO1xuXHRcdHdvcmxkLmFsbG93U2xlZXAgPSBmYWxzZTtcblxuXHRcdHRoaXMud29ybGQgPSB3b3JsZDtcblx0fSxcblxuXHR0aWNrOiBmdW5jdGlvbihtcywgZW50aXR5Q29sbGVjdGlvbikge1xuXHRcdHRoaXMuZW50aXRpZXMuZm9yRWFjaCh0aGlzLl9wcmVwYXJlRW50aXR5LmJpbmQodGhpcykpO1xuXHRcdGlmICh0aGlzLnBsYXlpbmcpIHtcblx0XHRcdHRoaXMud29ybGQuc3RlcChtcy8xMDAwKTtcblx0XHR9XG5cdFx0dGhpcy50aWNrU3Vic3lzdGVtcyhtcyk7XG5cdH0sXG5cblx0X3ByZXBhcmVFbnRpdHk6IGZ1bmN0aW9uKGVudGl0eSkge1xuXHRcdGxldCBwaWVjZXMgPSBlbnRpdHkuZ2V0KCdwaWVjZXMnKTtcblx0XHRpZiAocGllY2VzKSB7XG5cdFx0XHRwaWVjZXMuZm9yRWFjaChmdW5jdGlvbihwaWVjZSkge1xuXHRcdFx0XHR0aGlzLl9wcmVwYXJlRW50aXR5KHBpZWNlKTtcblx0XHRcdH0uYmluZCh0aGlzKSk7XG5cdFx0fVxuXHRcdGxldCBwaHlzaWNzID0gZW50aXR5LmdldCgncGh5c2ljcycpO1xuXHRcdGlmIChwaHlzaWNzKSB7XG5cdFx0XHRpZiAoIXBoeXNpY3MucmVhZHkpIHtcblx0XHRcdFx0dGhpcy53b3JsZC5hZGQocGh5c2ljcy5jYW5ub24pO1xuXHRcdFx0XHRwaHlzaWNzLmNvbnN0cmFpbnRzLmZvckVhY2goZnVuY3Rpb24oY29uc3RyYWludCkge1xuXHRcdFx0XHRcdGNvbnNvbGUuaW5mbygnYWRkaW5nIGNvbnN0cmFpbnQnKTtcblx0XHRcdFx0XHR0aGlzLndvcmxkLmFkZENvbnN0cmFpbnQoY29uc3RyYWludCk7XG5cdFx0XHRcdH0uYmluZCh0aGlzKSk7XG5cdFx0XHR9XG5cdFx0XHRwaHlzaWNzLnJlYWR5ID0gdHJ1ZTtcblx0XHR9XG5cdH1cblxufSk7XG5cblBoeXNpY3MuY3JlYXRlID0gZnVuY3Rpb24oZnB0R2FtZSkge1xuXHRyZXR1cm4gbmV3IFBoeXNpY3MoZnB0R2FtZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBoeXNpY3M7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9nYW1lL3BoeXNpY3MvUGh5c2ljcy5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	eval("var require;var require;/*\n * Copyright (c) 2015 cannon.js Authors\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use, copy,\n * modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n!function(e){if(true)module.exports=e();else if(\"function\"==typeof define&&false)define([],e);else{var f;\"undefined\"!=typeof window?f=window:\"undefined\"!=typeof global?f=global:\"undefined\"!=typeof self&&(f=self),f.CANNON=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\nmodule.exports={\n  \"name\": \"cannon\",\n  \"version\": \"0.6.2\",\n  \"description\": \"A lightweight 3D physics engine written in JavaScript.\",\n  \"homepage\": \"https://github.com/schteppe/cannon.js\",\n  \"author\": \"Stefan Hedman <schteppe@gmail.com> (http://steffe.se)\",\n  \"keywords\": [\n    \"cannon.js\",\n    \"cannon\",\n    \"physics\",\n    \"engine\",\n    \"3d\"\n  ],\n  \"main\": \"./build/cannon.js\",\n  \"engines\": {\n    \"node\": \"*\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/schteppe/cannon.js.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/schteppe/cannon.js/issues\"\n  },\n  \"licenses\": [\n    {\n      \"type\": \"MIT\"\n    }\n  ],\n  \"devDependencies\": {\n    \"jshint\": \"latest\",\n    \"uglify-js\": \"latest\",\n    \"nodeunit\": \"^0.9.0\",\n    \"grunt\": \"~0.4.0\",\n    \"grunt-contrib-jshint\": \"~0.1.1\",\n    \"grunt-contrib-nodeunit\": \"^0.4.1\",\n    \"grunt-contrib-concat\": \"~0.1.3\",\n    \"grunt-contrib-uglify\": \"^0.5.1\",\n    \"grunt-browserify\": \"^2.1.4\",\n    \"grunt-contrib-yuidoc\": \"^0.5.2\",\n    \"browserify\": \"*\"\n  },\n  \"dependencies\": {}\n}\n\n},{}],2:[function(_dereq_,module,exports){\n// Export classes\nmodule.exports = {\n    version :                       _dereq_('../package.json').version,\n\n    AABB :                          _dereq_('./collision/AABB'),\n    ArrayCollisionMatrix :          _dereq_('./collision/ArrayCollisionMatrix'),\n    Body :                          _dereq_('./objects/Body'),\n    Box :                           _dereq_('./shapes/Box'),\n    Broadphase :                    _dereq_('./collision/Broadphase'),\n    Constraint :                    _dereq_('./constraints/Constraint'),\n    ContactEquation :               _dereq_('./equations/ContactEquation'),\n    Narrowphase :                   _dereq_('./world/Narrowphase'),\n    ConeTwistConstraint :           _dereq_('./constraints/ConeTwistConstraint'),\n    ContactMaterial :               _dereq_('./material/ContactMaterial'),\n    ConvexPolyhedron :              _dereq_('./shapes/ConvexPolyhedron'),\n    Cylinder :                      _dereq_('./shapes/Cylinder'),\n    DistanceConstraint :            _dereq_('./constraints/DistanceConstraint'),\n    Equation :                      _dereq_('./equations/Equation'),\n    EventTarget :                   _dereq_('./utils/EventTarget'),\n    FrictionEquation :              _dereq_('./equations/FrictionEquation'),\n    GSSolver :                      _dereq_('./solver/GSSolver'),\n    GridBroadphase :                _dereq_('./collision/GridBroadphase'),\n    Heightfield :                   _dereq_('./shapes/Heightfield'),\n    HingeConstraint :               _dereq_('./constraints/HingeConstraint'),\n    LockConstraint :                _dereq_('./constraints/LockConstraint'),\n    Mat3 :                          _dereq_('./math/Mat3'),\n    Material :                      _dereq_('./material/Material'),\n    NaiveBroadphase :               _dereq_('./collision/NaiveBroadphase'),\n    ObjectCollisionMatrix :         _dereq_('./collision/ObjectCollisionMatrix'),\n    Pool :                          _dereq_('./utils/Pool'),\n    Particle :                      _dereq_('./shapes/Particle'),\n    Plane :                         _dereq_('./shapes/Plane'),\n    PointToPointConstraint :        _dereq_('./constraints/PointToPointConstraint'),\n    Quaternion :                    _dereq_('./math/Quaternion'),\n    Ray :                           _dereq_('./collision/Ray'),\n    RaycastVehicle :                _dereq_('./objects/RaycastVehicle'),\n    RaycastResult :                 _dereq_('./collision/RaycastResult'),\n    RigidVehicle :                  _dereq_('./objects/RigidVehicle'),\n    RotationalEquation :            _dereq_('./equations/RotationalEquation'),\n    RotationalMotorEquation :       _dereq_('./equations/RotationalMotorEquation'),\n    SAPBroadphase :                 _dereq_('./collision/SAPBroadphase'),\n    SPHSystem :                     _dereq_('./objects/SPHSystem'),\n    Shape :                         _dereq_('./shapes/Shape'),\n    Solver :                        _dereq_('./solver/Solver'),\n    Sphere :                        _dereq_('./shapes/Sphere'),\n    SplitSolver :                   _dereq_('./solver/SplitSolver'),\n    Spring :                        _dereq_('./objects/Spring'),\n    Trimesh :                       _dereq_('./shapes/Trimesh'),\n    Vec3 :                          _dereq_('./math/Vec3'),\n    Vec3Pool :                      _dereq_('./utils/Vec3Pool'),\n    World :                         _dereq_('./world/World'),\n};\n\n},{\"../package.json\":1,\"./collision/AABB\":3,\"./collision/ArrayCollisionMatrix\":4,\"./collision/Broadphase\":5,\"./collision/GridBroadphase\":6,\"./collision/NaiveBroadphase\":7,\"./collision/ObjectCollisionMatrix\":8,\"./collision/Ray\":9,\"./collision/RaycastResult\":10,\"./collision/SAPBroadphase\":11,\"./constraints/ConeTwistConstraint\":12,\"./constraints/Constraint\":13,\"./constraints/DistanceConstraint\":14,\"./constraints/HingeConstraint\":15,\"./constraints/LockConstraint\":16,\"./constraints/PointToPointConstraint\":17,\"./equations/ContactEquation\":19,\"./equations/Equation\":20,\"./equations/FrictionEquation\":21,\"./equations/RotationalEquation\":22,\"./equations/RotationalMotorEquation\":23,\"./material/ContactMaterial\":24,\"./material/Material\":25,\"./math/Mat3\":27,\"./math/Quaternion\":28,\"./math/Vec3\":30,\"./objects/Body\":31,\"./objects/RaycastVehicle\":32,\"./objects/RigidVehicle\":33,\"./objects/SPHSystem\":34,\"./objects/Spring\":35,\"./shapes/Box\":37,\"./shapes/ConvexPolyhedron\":38,\"./shapes/Cylinder\":39,\"./shapes/Heightfield\":40,\"./shapes/Particle\":41,\"./shapes/Plane\":42,\"./shapes/Shape\":43,\"./shapes/Sphere\":44,\"./shapes/Trimesh\":45,\"./solver/GSSolver\":46,\"./solver/Solver\":47,\"./solver/SplitSolver\":48,\"./utils/EventTarget\":49,\"./utils/Pool\":51,\"./utils/Vec3Pool\":54,\"./world/Narrowphase\":55,\"./world/World\":56}],3:[function(_dereq_,module,exports){\nvar Vec3 = _dereq_('../math/Vec3');\nvar Utils = _dereq_('../utils/Utils');\n\nmodule.exports = AABB;\n\n/**\n * Axis aligned bounding box class.\n * @class AABB\n * @constructor\n * @param {Object} [options]\n * @param {Vec3}   [options.upperBound]\n * @param {Vec3}   [options.lowerBound]\n */\nfunction AABB(options){\n    options = options || {};\n\n    /**\n     * The lower bound of the bounding box.\n     * @property lowerBound\n     * @type {Vec3}\n     */\n    this.lowerBound = new Vec3();\n    if(options.lowerBound){\n        this.lowerBound.copy(options.lowerBound);\n    }\n\n    /**\n     * The upper bound of the bounding box.\n     * @property upperBound\n     * @type {Vec3}\n     */\n    this.upperBound = new Vec3();\n    if(options.upperBound){\n        this.upperBound.copy(options.upperBound);\n    }\n}\n\nvar tmp = new Vec3();\n\n/**\n * Set the AABB bounds from a set of points.\n * @method setFromPoints\n * @param {Array} points An array of Vec3's.\n * @param {Vec3} position\n * @param {Quaternion} quaternion\n * @param {number} skinSize\n * @return {AABB} The self object\n */\nAABB.prototype.setFromPoints = function(points, position, quaternion, skinSize){\n    var l = this.lowerBound,\n        u = this.upperBound,\n        q = quaternion;\n\n    // Set to the first point\n    l.copy(points[0]);\n    if(q){\n        q.vmult(l, l);\n    }\n    u.copy(l);\n\n    for(var i = 1; i<points.length; i++){\n        var p = points[i];\n\n        if(q){\n            q.vmult(p, tmp);\n            p = tmp;\n        }\n\n        if(p.x > u.x){ u.x = p.x; }\n        if(p.x < l.x){ l.x = p.x; }\n        if(p.y > u.y){ u.y = p.y; }\n        if(p.y < l.y){ l.y = p.y; }\n        if(p.z > u.z){ u.z = p.z; }\n        if(p.z < l.z){ l.z = p.z; }\n    }\n\n    // Add offset\n    if (position) {\n        position.vadd(l, l);\n        position.vadd(u, u);\n    }\n\n    if(skinSize){\n        l.x -= skinSize;\n        l.y -= skinSize;\n        l.z -= skinSize;\n        u.x += skinSize;\n        u.y += skinSize;\n        u.z += skinSize;\n    }\n\n    return this;\n};\n\n/**\n * Copy bounds from an AABB to this AABB\n * @method copy\n * @param  {AABB} aabb Source to copy from\n * @return {AABB} The this object, for chainability\n */\nAABB.prototype.copy = function(aabb){\n    this.lowerBound.copy(aabb.lowerBound);\n    this.upperBound.copy(aabb.upperBound);\n    return this;\n};\n\n/**\n * Clone an AABB\n * @method clone\n */\nAABB.prototype.clone = function(){\n    return new AABB().copy(this);\n};\n\n/**\n * Extend this AABB so that it covers the given AABB too.\n * @method extend\n * @param  {AABB} aabb\n */\nAABB.prototype.extend = function(aabb){\n    // Extend lower bound\n    var l = aabb.lowerBound.x;\n    if(this.lowerBound.x > l){\n        this.lowerBound.x = l;\n    }\n\n    // Upper\n    var u = aabb.upperBound.x;\n    if(this.upperBound.x < u){\n        this.upperBound.x = u;\n    }\n\n    // Extend lower bound\n    var l = aabb.lowerBound.y;\n    if(this.lowerBound.y > l){\n        this.lowerBound.y = l;\n    }\n\n    // Upper\n    var u = aabb.upperBound.y;\n    if(this.upperBound.y < u){\n        this.upperBound.y = u;\n    }\n\n    // Extend lower bound\n    var l = aabb.lowerBound.z;\n    if(this.lowerBound.z > l){\n        this.lowerBound.z = l;\n    }\n\n    // Upper\n    var u = aabb.upperBound.z;\n    if(this.upperBound.z < u){\n        this.upperBound.z = u;\n    }\n};\n\n/**\n * Returns true if the given AABB overlaps this AABB.\n * @method overlaps\n * @param  {AABB} aabb\n * @return {Boolean}\n */\nAABB.prototype.overlaps = function(aabb){\n    var l1 = this.lowerBound,\n        u1 = this.upperBound,\n        l2 = aabb.lowerBound,\n        u2 = aabb.upperBound;\n\n    //      l2        u2\n    //      |---------|\n    // |--------|\n    // l1       u1\n\n    return ((l2.x <= u1.x && u1.x <= u2.x) || (l1.x <= u2.x && u2.x <= u1.x)) &&\n           ((l2.y <= u1.y && u1.y <= u2.y) || (l1.y <= u2.y && u2.y <= u1.y)) &&\n           ((l2.z <= u1.z && u1.z <= u2.z) || (l1.z <= u2.z && u2.z <= u1.z));\n};\n\n/**\n * Returns true if the given AABB is fully contained in this AABB.\n * @method contains\n * @param {AABB} aabb\n * @return {Boolean}\n */\nAABB.prototype.contains = function(aabb){\n    var l1 = this.lowerBound,\n        u1 = this.upperBound,\n        l2 = aabb.lowerBound,\n        u2 = aabb.upperBound;\n\n    //      l2        u2\n    //      |---------|\n    // |---------------|\n    // l1              u1\n\n    return (\n        (l1.x <= l2.x && u1.x >= u2.x) &&\n        (l1.y <= l2.y && u1.y >= u2.y) &&\n        (l1.z <= l2.z && u1.z >= u2.z)\n    );\n};\n\n/**\n * @method getCorners\n * @param {Vec3} a\n * @param {Vec3} b\n * @param {Vec3} c\n * @param {Vec3} d\n * @param {Vec3} e\n * @param {Vec3} f\n * @param {Vec3} g\n * @param {Vec3} h\n */\nAABB.prototype.getCorners = function(a, b, c, d, e, f, g, h){\n    var l = this.lowerBound,\n        u = this.upperBound;\n\n    a.copy(l);\n    b.set( u.x, l.y, l.z );\n    c.set( u.x, u.y, l.z );\n    d.set( l.x, u.y, u.z );\n    e.set( u.x, l.y, l.z );\n    f.set( l.x, u.y, l.z );\n    g.set( l.x, l.y, u.z );\n    h.copy(u);\n};\n\nvar transformIntoFrame_corners = [\n    new Vec3(),\n    new Vec3(),\n    new Vec3(),\n    new Vec3(),\n    new Vec3(),\n    new Vec3(),\n    new Vec3(),\n    new Vec3()\n];\n\n/**\n * Get the representation of an AABB in another frame.\n * @method toLocalFrame\n * @param  {Transform} frame\n * @param  {AABB} target\n * @return {AABB} The \"target\" AABB object.\n */\nAABB.prototype.toLocalFrame = function(frame, target){\n\n    var corners = transformIntoFrame_corners;\n    var a = corners[0];\n    var b = corners[1];\n    var c = corners[2];\n    var d = corners[3];\n    var e = corners[4];\n    var f = corners[5];\n    var g = corners[6];\n    var h = corners[7];\n\n    // Get corners in current frame\n    this.getCorners(a, b, c, d, e, f, g, h);\n\n    // Transform them to new local frame\n    for(var i=0; i !== 8; i++){\n        var corner = corners[i];\n        frame.pointToLocal(corner, corner);\n    }\n\n    return target.setFromPoints(corners);\n};\n\n/**\n * Get the representation of an AABB in the global frame.\n * @method toWorldFrame\n * @param  {Transform} frame\n * @param  {AABB} target\n * @return {AABB} The \"target\" AABB object.\n */\nAABB.prototype.toWorldFrame = function(frame, target){\n\n    var corners = transformIntoFrame_corners;\n    var a = corners[0];\n    var b = corners[1];\n    var c = corners[2];\n    var d = corners[3];\n    var e = corners[4];\n    var f = corners[5];\n    var g = corners[6];\n    var h = corners[7];\n\n    // Get corners in current frame\n    this.getCorners(a, b, c, d, e, f, g, h);\n\n    // Transform them to new local frame\n    for(var i=0; i !== 8; i++){\n        var corner = corners[i];\n        frame.pointToWorld(corner, corner);\n    }\n\n    return target.setFromPoints(corners);\n};\n\n},{\"../math/Vec3\":30,\"../utils/Utils\":53}],4:[function(_dereq_,module,exports){\nmodule.exports = ArrayCollisionMatrix;\n\n/**\n * Collision \"matrix\". It's actually a triangular-shaped array of whether two bodies are touching this step, for reference next step\n * @class ArrayCollisionMatrix\n * @constructor\n */\nfunction ArrayCollisionMatrix() {\n\n    /**\n     * The matrix storage\n     * @property matrix\n     * @type {Array}\n     */\n\tthis.matrix = [];\n}\n\n/**\n * Get an element\n * @method get\n * @param  {Number} i\n * @param  {Number} j\n * @return {Number}\n */\nArrayCollisionMatrix.prototype.get = function(i, j) {\n\ti = i.index;\n\tj = j.index;\n    if (j > i) {\n        var temp = j;\n        j = i;\n        i = temp;\n    }\n\treturn this.matrix[(i*(i + 1)>>1) + j-1];\n};\n\n/**\n * Set an element\n * @method set\n * @param {Number} i\n * @param {Number} j\n * @param {Number} value\n */\nArrayCollisionMatrix.prototype.set = function(i, j, value) {\n\ti = i.index;\n\tj = j.index;\n    if (j > i) {\n        var temp = j;\n        j = i;\n        i = temp;\n    }\n\tthis.matrix[(i*(i + 1)>>1) + j-1] = value ? 1 : 0;\n};\n\n/**\n * Sets all elements to zero\n * @method reset\n */\nArrayCollisionMatrix.prototype.reset = function() {\n\tfor (var i=0, l=this.matrix.length; i!==l; i++) {\n\t\tthis.matrix[i]=0;\n\t}\n};\n\n/**\n * Sets the max number of objects\n * @method setNumObjects\n * @param {Number} n\n */\nArrayCollisionMatrix.prototype.setNumObjects = function(n) {\n\tthis.matrix.length = n*(n-1)>>1;\n};\n\n},{}],5:[function(_dereq_,module,exports){\nvar Body = _dereq_('../objects/Body');\nvar Vec3 = _dereq_('../math/Vec3');\nvar Quaternion = _dereq_('../math/Quaternion');\nvar Shape = _dereq_('../shapes/Shape');\nvar Plane = _dereq_('../shapes/Plane');\n\nmodule.exports = Broadphase;\n\n/**\n * Base class for broadphase implementations\n * @class Broadphase\n * @constructor\n * @author schteppe\n */\nfunction Broadphase(){\n    /**\n    * The world to search for collisions in.\n    * @property world\n    * @type {World}\n    */\n    this.world = null;\n\n    /**\n     * If set to true, the broadphase uses bounding boxes for intersection test, else it uses bounding spheres.\n     * @property useBoundingBoxes\n     * @type {Boolean}\n     */\n    this.useBoundingBoxes = false;\n\n    /**\n     * Set to true if the objects in the world moved.\n     * @property {Boolean} dirty\n     */\n    this.dirty = true;\n}\n\n/**\n * Get the collision pairs from the world\n * @method collisionPairs\n * @param {World} world The world to search in\n * @param {Array} p1 Empty array to be filled with body objects\n * @param {Array} p2 Empty array to be filled with body objects\n */\nBroadphase.prototype.collisionPairs = function(world,p1,p2){\n    throw new Error(\"collisionPairs not implemented for this BroadPhase class!\");\n};\n\n/**\n * Check if a body pair needs to be intersection tested at all.\n * @method needBroadphaseCollision\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @return {bool}\n */\nvar Broadphase_needBroadphaseCollision_STATIC_OR_KINEMATIC = Body.STATIC | Body.KINEMATIC;\nBroadphase.prototype.needBroadphaseCollision = function(bodyA,bodyB){\n\n    // Check collision filter masks\n    if( (bodyA.collisionFilterGroup & bodyB.collisionFilterMask)===0 || (bodyB.collisionFilterGroup & bodyA.collisionFilterMask)===0){\n        return false;\n    }\n\n    // Check types\n    if(((bodyA.type & Broadphase_needBroadphaseCollision_STATIC_OR_KINEMATIC)!==0 || bodyA.sleepState === Body.SLEEPING) &&\n       ((bodyB.type & Broadphase_needBroadphaseCollision_STATIC_OR_KINEMATIC)!==0 || bodyB.sleepState === Body.SLEEPING)) {\n        // Both bodies are static, kinematic or sleeping. Skip.\n        return false;\n    }\n\n    return true;\n};\n\n/**\n * Check if the bounding volumes of two bodies intersect.\n * @method intersectionTest\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {array} pairs1\n * @param {array} pairs2\n  */\nBroadphase.prototype.intersectionTest = function(bodyA, bodyB, pairs1, pairs2){\n    if(this.useBoundingBoxes){\n        this.doBoundingBoxBroadphase(bodyA,bodyB,pairs1,pairs2);\n    } else {\n        this.doBoundingSphereBroadphase(bodyA,bodyB,pairs1,pairs2);\n    }\n};\n\n/**\n * Check if the bounding spheres of two bodies are intersecting.\n * @method doBoundingSphereBroadphase\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Array} pairs1 bodyA is appended to this array if intersection\n * @param {Array} pairs2 bodyB is appended to this array if intersection\n */\nvar Broadphase_collisionPairs_r = new Vec3(), // Temp objects\n    Broadphase_collisionPairs_normal =  new Vec3(),\n    Broadphase_collisionPairs_quat =  new Quaternion(),\n    Broadphase_collisionPairs_relpos  =  new Vec3();\nBroadphase.prototype.doBoundingSphereBroadphase = function(bodyA,bodyB,pairs1,pairs2){\n    var r = Broadphase_collisionPairs_r;\n    bodyB.position.vsub(bodyA.position,r);\n    var boundingRadiusSum2 = Math.pow(bodyA.boundingRadius + bodyB.boundingRadius, 2);\n    var norm2 = r.norm2();\n    if(norm2 < boundingRadiusSum2){\n        pairs1.push(bodyA);\n        pairs2.push(bodyB);\n    }\n};\n\n/**\n * Check if the bounding boxes of two bodies are intersecting.\n * @method doBoundingBoxBroadphase\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Array} pairs1\n * @param {Array} pairs2\n */\nBroadphase.prototype.doBoundingBoxBroadphase = function(bodyA,bodyB,pairs1,pairs2){\n    if(bodyA.aabbNeedsUpdate){\n        bodyA.computeAABB();\n    }\n    if(bodyB.aabbNeedsUpdate){\n        bodyB.computeAABB();\n    }\n\n    // Check AABB / AABB\n    if(bodyA.aabb.overlaps(bodyB.aabb)){\n        pairs1.push(bodyA);\n        pairs2.push(bodyB);\n    }\n};\n\n/**\n * Removes duplicate pairs from the pair arrays.\n * @method makePairsUnique\n * @param {Array} pairs1\n * @param {Array} pairs2\n */\nvar Broadphase_makePairsUnique_temp = { keys:[] },\n    Broadphase_makePairsUnique_p1 = [],\n    Broadphase_makePairsUnique_p2 = [];\nBroadphase.prototype.makePairsUnique = function(pairs1,pairs2){\n    var t = Broadphase_makePairsUnique_temp,\n        p1 = Broadphase_makePairsUnique_p1,\n        p2 = Broadphase_makePairsUnique_p2,\n        N = pairs1.length;\n\n    for(var i=0; i!==N; i++){\n        p1[i] = pairs1[i];\n        p2[i] = pairs2[i];\n    }\n\n    pairs1.length = 0;\n    pairs2.length = 0;\n\n    for(var i=0; i!==N; i++){\n        var id1 = p1[i].id,\n            id2 = p2[i].id;\n        var key = id1 < id2 ? id1+\",\"+id2 :  id2+\",\"+id1;\n        t[key] = i;\n        t.keys.push(key);\n    }\n\n    for(var i=0; i!==t.keys.length; i++){\n        var key = t.keys.pop(),\n            pairIndex = t[key];\n        pairs1.push(p1[pairIndex]);\n        pairs2.push(p2[pairIndex]);\n        delete t[key];\n    }\n};\n\n/**\n * To be implemented by subcasses\n * @method setWorld\n * @param {World} world\n */\nBroadphase.prototype.setWorld = function(world){\n};\n\n/**\n * Check if the bounding spheres of two bodies overlap.\n * @method boundingSphereCheck\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @return {boolean}\n */\nvar bsc_dist = new Vec3();\nBroadphase.boundingSphereCheck = function(bodyA,bodyB){\n    var dist = bsc_dist;\n    bodyA.position.vsub(bodyB.position,dist);\n    return Math.pow(bodyA.shape.boundingSphereRadius + bodyB.shape.boundingSphereRadius,2) > dist.norm2();\n};\n\n/**\n * Returns all the bodies within the AABB.\n * @method aabbQuery\n * @param  {World} world\n * @param  {AABB} aabb\n * @param  {array} result An array to store resulting bodies in.\n * @return {array}\n */\nBroadphase.prototype.aabbQuery = function(world, aabb, result){\n    console.warn('.aabbQuery is not implemented in this Broadphase subclass.');\n    return [];\n};\n},{\"../math/Quaternion\":28,\"../math/Vec3\":30,\"../objects/Body\":31,\"../shapes/Plane\":42,\"../shapes/Shape\":43}],6:[function(_dereq_,module,exports){\nmodule.exports = GridBroadphase;\n\nvar Broadphase = _dereq_('./Broadphase');\nvar Vec3 = _dereq_('../math/Vec3');\nvar Shape = _dereq_('../shapes/Shape');\n\n/**\n * Axis aligned uniform grid broadphase.\n * @class GridBroadphase\n * @constructor\n * @extends Broadphase\n * @todo Needs support for more than just planes and spheres.\n * @param {Vec3} aabbMin\n * @param {Vec3} aabbMax\n * @param {Number} nx Number of boxes along x\n * @param {Number} ny Number of boxes along y\n * @param {Number} nz Number of boxes along z\n */\nfunction GridBroadphase(aabbMin,aabbMax,nx,ny,nz){\n    Broadphase.apply(this);\n    this.nx = nx || 10;\n    this.ny = ny || 10;\n    this.nz = nz || 10;\n    this.aabbMin = aabbMin || new Vec3(100,100,100);\n    this.aabbMax = aabbMax || new Vec3(-100,-100,-100);\n\tvar nbins = this.nx * this.ny * this.nz;\n\tif (nbins <= 0) {\n\t\tthrow \"GridBroadphase: Each dimension's n must be >0\";\n\t}\n    this.bins = [];\n\tthis.binLengths = []; //Rather than continually resizing arrays (thrashing the memory), just record length and allow them to grow\n\tthis.bins.length = nbins;\n\tthis.binLengths.length = nbins;\n\tfor (var i=0;i<nbins;i++) {\n\t\tthis.bins[i]=[];\n\t\tthis.binLengths[i]=0;\n\t}\n}\nGridBroadphase.prototype = new Broadphase();\nGridBroadphase.prototype.constructor = GridBroadphase;\n\n/**\n * Get all the collision pairs in the physics world\n * @method collisionPairs\n * @param {World} world\n * @param {Array} pairs1\n * @param {Array} pairs2\n */\nvar GridBroadphase_collisionPairs_d = new Vec3();\nvar GridBroadphase_collisionPairs_binPos = new Vec3();\nGridBroadphase.prototype.collisionPairs = function(world,pairs1,pairs2){\n    var N = world.numObjects(),\n        bodies = world.bodies;\n\n    var max = this.aabbMax,\n        min = this.aabbMin,\n        nx = this.nx,\n        ny = this.ny,\n        nz = this.nz;\n\n\tvar xstep = ny*nz;\n\tvar ystep = nz;\n\tvar zstep = 1;\n\n    var xmax = max.x,\n        ymax = max.y,\n        zmax = max.z,\n        xmin = min.x,\n        ymin = min.y,\n        zmin = min.z;\n\n    var xmult = nx / (xmax-xmin),\n        ymult = ny / (ymax-ymin),\n        zmult = nz / (zmax-zmin);\n\n    var binsizeX = (xmax - xmin) / nx,\n        binsizeY = (ymax - ymin) / ny,\n        binsizeZ = (zmax - zmin) / nz;\n\n\tvar binRadius = Math.sqrt(binsizeX*binsizeX + binsizeY*binsizeY + binsizeZ*binsizeZ) * 0.5;\n\n    var types = Shape.types;\n    var SPHERE =            types.SPHERE,\n        PLANE =             types.PLANE,\n        BOX =               types.BOX,\n        COMPOUND =          types.COMPOUND,\n        CONVEXPOLYHEDRON =  types.CONVEXPOLYHEDRON;\n\n    var bins=this.bins,\n\t\tbinLengths=this.binLengths,\n        Nbins=this.bins.length;\n\n    // Reset bins\n    for(var i=0; i!==Nbins; i++){\n        binLengths[i] = 0;\n    }\n\n    var ceil = Math.ceil;\n\tvar min = Math.min;\n\tvar max = Math.max;\n\n\tfunction addBoxToBins(x0,y0,z0,x1,y1,z1,bi) {\n\t\tvar xoff0 = ((x0 - xmin) * xmult)|0,\n\t\t\tyoff0 = ((y0 - ymin) * ymult)|0,\n\t\t\tzoff0 = ((z0 - zmin) * zmult)|0,\n\t\t\txoff1 = ceil((x1 - xmin) * xmult),\n\t\t\tyoff1 = ceil((y1 - ymin) * ymult),\n\t\t\tzoff1 = ceil((z1 - zmin) * zmult);\n\n\t\tif (xoff0 < 0) { xoff0 = 0; } else if (xoff0 >= nx) { xoff0 = nx - 1; }\n\t\tif (yoff0 < 0) { yoff0 = 0; } else if (yoff0 >= ny) { yoff0 = ny - 1; }\n\t\tif (zoff0 < 0) { zoff0 = 0; } else if (zoff0 >= nz) { zoff0 = nz - 1; }\n\t\tif (xoff1 < 0) { xoff1 = 0; } else if (xoff1 >= nx) { xoff1 = nx - 1; }\n\t\tif (yoff1 < 0) { yoff1 = 0; } else if (yoff1 >= ny) { yoff1 = ny - 1; }\n\t\tif (zoff1 < 0) { zoff1 = 0; } else if (zoff1 >= nz) { zoff1 = nz - 1; }\n\n\t\txoff0 *= xstep;\n\t\tyoff0 *= ystep;\n\t\tzoff0 *= zstep;\n\t\txoff1 *= xstep;\n\t\tyoff1 *= ystep;\n\t\tzoff1 *= zstep;\n\n\t\tfor (var xoff = xoff0; xoff <= xoff1; xoff += xstep) {\n\t\t\tfor (var yoff = yoff0; yoff <= yoff1; yoff += ystep) {\n\t\t\t\tfor (var zoff = zoff0; zoff <= zoff1; zoff += zstep) {\n\t\t\t\t\tvar idx = xoff+yoff+zoff;\n\t\t\t\t\tbins[idx][binLengths[idx]++] = bi;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n    // Put all bodies into the bins\n    for(var i=0; i!==N; i++){\n        var bi = bodies[i];\n        var si = bi.shape;\n\n        switch(si.type){\n        case SPHERE:\n            // Put in bin\n            // check if overlap with other bins\n            var x = bi.position.x,\n                y = bi.position.y,\n                z = bi.position.z;\n            var r = si.radius;\n\n\t\t\taddBoxToBins(x-r, y-r, z-r, x+r, y+r, z+r, bi);\n            break;\n\n        case PLANE:\n            if(si.worldNormalNeedsUpdate){\n                si.computeWorldNormal(bi.quaternion);\n            }\n            var planeNormal = si.worldNormal;\n\n\t\t\t//Relative position from origin of plane object to the first bin\n\t\t\t//Incremented as we iterate through the bins\n\t\t\tvar xreset = xmin + binsizeX*0.5 - bi.position.x,\n\t\t\t\tyreset = ymin + binsizeY*0.5 - bi.position.y,\n\t\t\t\tzreset = zmin + binsizeZ*0.5 - bi.position.z;\n\n            var d = GridBroadphase_collisionPairs_d;\n\t\t\td.set(xreset, yreset, zreset);\n\n\t\t\tfor (var xi = 0, xoff = 0; xi !== nx; xi++, xoff += xstep, d.y = yreset, d.x += binsizeX) {\n\t\t\t\tfor (var yi = 0, yoff = 0; yi !== ny; yi++, yoff += ystep, d.z = zreset, d.y += binsizeY) {\n\t\t\t\t\tfor (var zi = 0, zoff = 0; zi !== nz; zi++, zoff += zstep, d.z += binsizeZ) {\n\t\t\t\t\t\tif (d.dot(planeNormal) < binRadius) {\n\t\t\t\t\t\t\tvar idx = xoff + yoff + zoff;\n\t\t\t\t\t\t\tbins[idx][binLengths[idx]++] = bi;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n            break;\n\n        default:\n\t\t\tif (bi.aabbNeedsUpdate) {\n\t\t\t\tbi.computeAABB();\n\t\t\t}\n\n\t\t\taddBoxToBins(\n\t\t\t\tbi.aabb.lowerBound.x,\n\t\t\t\tbi.aabb.lowerBound.y,\n\t\t\t\tbi.aabb.lowerBound.z,\n\t\t\t\tbi.aabb.upperBound.x,\n\t\t\t\tbi.aabb.upperBound.y,\n\t\t\t\tbi.aabb.upperBound.z,\n\t\t\t\tbi);\n            break;\n        }\n    }\n\n    // Check each bin\n    for(var i=0; i!==Nbins; i++){\n\t\tvar binLength = binLengths[i];\n\t\t//Skip bins with no potential collisions\n\t\tif (binLength > 1) {\n\t\t\tvar bin = bins[i];\n\n\t\t\t// Do N^2 broadphase inside\n\t\t\tfor(var xi=0; xi!==binLength; xi++){\n\t\t\t\tvar bi = bin[xi];\n\t\t\t\tfor(var yi=0; yi!==xi; yi++){\n\t\t\t\t\tvar bj = bin[yi];\n\t\t\t\t\tif(this.needBroadphaseCollision(bi,bj)){\n\t\t\t\t\t\tthis.intersectionTest(bi,bj,pairs1,pairs2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    }\n\n//\tfor (var zi = 0, zoff=0; zi < nz; zi++, zoff+= zstep) {\n//\t\tconsole.log(\"layer \"+zi);\n//\t\tfor (var yi = 0, yoff=0; yi < ny; yi++, yoff += ystep) {\n//\t\t\tvar row = '';\n//\t\t\tfor (var xi = 0, xoff=0; xi < nx; xi++, xoff += xstep) {\n//\t\t\t\tvar idx = xoff + yoff + zoff;\n//\t\t\t\trow += ' ' + binLengths[idx];\n//\t\t\t}\n//\t\t\tconsole.log(row);\n//\t\t}\n//\t}\n\n    this.makePairsUnique(pairs1,pairs2);\n};\n\n},{\"../math/Vec3\":30,\"../shapes/Shape\":43,\"./Broadphase\":5}],7:[function(_dereq_,module,exports){\nmodule.exports = NaiveBroadphase;\n\nvar Broadphase = _dereq_('./Broadphase');\nvar AABB = _dereq_('./AABB');\n\n/**\n * Naive broadphase implementation, used in lack of better ones.\n * @class NaiveBroadphase\n * @constructor\n * @description The naive broadphase looks at all possible pairs without restriction, therefore it has complexity N^2 (which is bad)\n * @extends Broadphase\n */\nfunction NaiveBroadphase(){\n    Broadphase.apply(this);\n}\nNaiveBroadphase.prototype = new Broadphase();\nNaiveBroadphase.prototype.constructor = NaiveBroadphase;\n\n/**\n * Get all the collision pairs in the physics world\n * @method collisionPairs\n * @param {World} world\n * @param {Array} pairs1\n * @param {Array} pairs2\n */\nNaiveBroadphase.prototype.collisionPairs = function(world,pairs1,pairs2){\n    var bodies = world.bodies,\n        n = bodies.length,\n        i,j,bi,bj;\n\n    // Naive N^2 ftw!\n    for(i=0; i!==n; i++){\n        for(j=0; j!==i; j++){\n\n            bi = bodies[i];\n            bj = bodies[j];\n\n            if(!this.needBroadphaseCollision(bi,bj)){\n                continue;\n            }\n\n            this.intersectionTest(bi,bj,pairs1,pairs2);\n        }\n    }\n};\n\nvar tmpAABB = new AABB();\n\n/**\n * Returns all the bodies within an AABB.\n * @method aabbQuery\n * @param  {World} world\n * @param  {AABB} aabb\n * @param {array} result An array to store resulting bodies in.\n * @return {array}\n */\nNaiveBroadphase.prototype.aabbQuery = function(world, aabb, result){\n    result = result || [];\n\n    for(var i = 0; i < world.bodies.length; i++){\n        var b = world.bodies[i];\n\n        if(b.aabbNeedsUpdate){\n            b.computeAABB();\n        }\n\n        // Ugly hack until Body gets aabb\n        if(b.aabb.overlaps(aabb)){\n            result.push(b);\n        }\n    }\n\n    return result;\n};\n},{\"./AABB\":3,\"./Broadphase\":5}],8:[function(_dereq_,module,exports){\nmodule.exports = ObjectCollisionMatrix;\n\n/**\n * Records what objects are colliding with each other\n * @class ObjectCollisionMatrix\n * @constructor\n */\nfunction ObjectCollisionMatrix() {\n\n    /**\n     * The matrix storage\n     * @property matrix\n     * @type {Object}\n     */\n\tthis.matrix = {};\n}\n\n/**\n * @method get\n * @param  {Number} i\n * @param  {Number} j\n * @return {Number}\n */\nObjectCollisionMatrix.prototype.get = function(i, j) {\n\ti = i.id;\n\tj = j.id;\n    if (j > i) {\n        var temp = j;\n        j = i;\n        i = temp;\n    }\n\treturn i+'-'+j in this.matrix;\n};\n\n/**\n * @method set\n * @param  {Number} i\n * @param  {Number} j\n * @param {Number} value\n */\nObjectCollisionMatrix.prototype.set = function(i, j, value) {\n\ti = i.id;\n\tj = j.id;\n    if (j > i) {\n        var temp = j;\n        j = i;\n        i = temp;\n\t}\n\tif (value) {\n\t\tthis.matrix[i+'-'+j] = true;\n\t}\n\telse {\n\t\tdelete this.matrix[i+'-'+j];\n\t}\n};\n\n/**\n * Empty the matrix\n * @method reset\n */\nObjectCollisionMatrix.prototype.reset = function() {\n\tthis.matrix = {};\n};\n\n/**\n * Set max number of objects\n * @method setNumObjects\n * @param {Number} n\n */\nObjectCollisionMatrix.prototype.setNumObjects = function(n) {\n};\n\n},{}],9:[function(_dereq_,module,exports){\nmodule.exports = Ray;\n\nvar Vec3 = _dereq_('../math/Vec3');\nvar Quaternion = _dereq_('../math/Quaternion');\nvar Transform = _dereq_('../math/Transform');\nvar ConvexPolyhedron = _dereq_('../shapes/ConvexPolyhedron');\nvar Box = _dereq_('../shapes/Box');\nvar RaycastResult = _dereq_('../collision/RaycastResult');\nvar Shape = _dereq_('../shapes/Shape');\nvar AABB = _dereq_('../collision/AABB');\n\n/**\n * A line in 3D space that intersects bodies and return points.\n * @class Ray\n * @constructor\n * @param {Vec3} from\n * @param {Vec3} to\n */\nfunction Ray(from, to){\n    /**\n     * @property {Vec3} from\n     */\n    this.from = from ? from.clone() : new Vec3();\n\n    /**\n     * @property {Vec3} to\n     */\n    this.to = to ? to.clone() : new Vec3();\n\n    /**\n     * @private\n     * @property {Vec3} _direction\n     */\n    this._direction = new Vec3();\n\n    /**\n     * The precision of the ray. Used when checking parallelity etc.\n     * @property {Number} precision\n     */\n    this.precision = 0.0001;\n\n    /**\n     * Set to true if you want the Ray to take .collisionResponse flags into account on bodies and shapes.\n     * @property {Boolean} checkCollisionResponse\n     */\n    this.checkCollisionResponse = true;\n\n    /**\n     * If set to true, the ray skips any hits with normal.dot(rayDirection) < 0.\n     * @property {Boolean} skipBackfaces\n     */\n    this.skipBackfaces = false;\n\n    /**\n     * @property {number} collisionFilterMask\n     * @default -1\n     */\n    this.collisionFilterMask = -1;\n\n    /**\n     * @property {number} collisionFilterGroup\n     * @default -1\n     */\n    this.collisionFilterGroup = -1;\n\n    /**\n     * The intersection mode. Should be Ray.ANY, Ray.ALL or Ray.CLOSEST.\n     * @property {number} mode\n     */\n    this.mode = Ray.ANY;\n\n    /**\n     * Current result object.\n     * @property {RaycastResult} result\n     */\n    this.result = new RaycastResult();\n\n    /**\n     * Will be set to true during intersectWorld() if the ray hit anything.\n     * @property {Boolean} hasHit\n     */\n    this.hasHit = false;\n\n    /**\n     * Current, user-provided result callback. Will be used if mode is Ray.ALL.\n     * @property {Function} callback\n     */\n    this.callback = function(result){};\n}\nRay.prototype.constructor = Ray;\n\nRay.CLOSEST = 1;\nRay.ANY = 2;\nRay.ALL = 4;\n\nvar tmpAABB = new AABB();\nvar tmpArray = [];\n\n/**\n * Do itersection against all bodies in the given World.\n * @method intersectWorld\n * @param  {World} world\n * @param  {object} options\n * @return {Boolean} True if the ray hit anything, otherwise false.\n */\nRay.prototype.intersectWorld = function (world, options) {\n    this.mode = options.mode || Ray.ANY;\n    this.result = options.result || new RaycastResult();\n    this.skipBackfaces = !!options.skipBackfaces;\n    this.collisionFilterMask = typeof(options.collisionFilterMask) !== 'undefined' ? options.collisionFilterMask : -1;\n    this.collisionFilterGroup = typeof(options.collisionFilterGroup) !== 'undefined' ? options.collisionFilterGroup : -1;\n    if(options.from){\n        this.from.copy(options.from);\n    }\n    if(options.to){\n        this.to.copy(options.to);\n    }\n    this.callback = options.callback || function(){};\n    this.hasHit = false;\n\n    this.result.reset();\n    this._updateDirection();\n\n    this.getAABB(tmpAABB);\n    tmpArray.length = 0;\n    world.broadphase.aabbQuery(world, tmpAABB, tmpArray);\n    this.intersectBodies(tmpArray);\n\n    return this.hasHit;\n};\n\nvar v1 = new Vec3(),\n    v2 = new Vec3();\n\n/*\n * As per \"Barycentric Technique\" as named here http://www.blackpawn.com/texts/pointinpoly/default.html But without the division\n */\nRay.pointInTriangle = pointInTriangle;\nfunction pointInTriangle(p, a, b, c) {\n    c.vsub(a,v0);\n    b.vsub(a,v1);\n    p.vsub(a,v2);\n\n    var dot00 = v0.dot( v0 );\n    var dot01 = v0.dot( v1 );\n    var dot02 = v0.dot( v2 );\n    var dot11 = v1.dot( v1 );\n    var dot12 = v1.dot( v2 );\n\n    var u,v;\n\n    return  ( (u = dot11 * dot02 - dot01 * dot12) >= 0 ) &&\n            ( (v = dot00 * dot12 - dot01 * dot02) >= 0 ) &&\n            ( u + v < ( dot00 * dot11 - dot01 * dot01 ) );\n}\n\n/**\n * Shoot a ray at a body, get back information about the hit.\n * @method intersectBody\n * @private\n * @param {Body} body\n * @param {RaycastResult} [result] Deprecated - set the result property of the Ray instead.\n */\nvar intersectBody_xi = new Vec3();\nvar intersectBody_qi = new Quaternion();\nRay.prototype.intersectBody = function (body, result) {\n    if(result){\n        this.result = result;\n        this._updateDirection();\n    }\n    var checkCollisionResponse = this.checkCollisionResponse;\n\n    if(checkCollisionResponse && !body.collisionResponse){\n        return;\n    }\n\n    if((this.collisionFilterGroup & body.collisionFilterMask)===0 || (body.collisionFilterGroup & this.collisionFilterMask)===0){\n        return;\n    }\n\n    var xi = intersectBody_xi;\n    var qi = intersectBody_qi;\n\n    for (var i = 0, N = body.shapes.length; i < N; i++) {\n        var shape = body.shapes[i];\n\n        if(checkCollisionResponse && !shape.collisionResponse){\n            continue; // Skip\n        }\n\n        body.quaternion.mult(body.shapeOrientations[i], qi);\n        body.quaternion.vmult(body.shapeOffsets[i], xi);\n        xi.vadd(body.position, xi);\n\n        this.intersectShape(\n            shape,\n            qi,\n            xi,\n            body\n        );\n\n        if(this.result._shouldStop){\n            break;\n        }\n    }\n};\n\n/**\n * @method intersectBodies\n * @param {Array} bodies An array of Body objects.\n * @param {RaycastResult} [result] Deprecated\n */\nRay.prototype.intersectBodies = function (bodies, result) {\n    if(result){\n        this.result = result;\n        this._updateDirection();\n    }\n\n    for ( var i = 0, l = bodies.length; !this.result._shouldStop && i < l; i ++ ) {\n        this.intersectBody(bodies[i]);\n    }\n};\n\n/**\n * Updates the _direction vector.\n * @private\n * @method _updateDirection\n */\nRay.prototype._updateDirection = function(){\n    this.to.vsub(this.from, this._direction);\n    this._direction.normalize();\n};\n\n/**\n * @method intersectShape\n * @private\n * @param {Shape} shape\n * @param {Quaternion} quat\n * @param {Vec3} position\n * @param {Body} body\n */\nRay.prototype.intersectShape = function(shape, quat, position, body){\n    var from = this.from;\n\n\n    // Checking boundingSphere\n    var distance = distanceFromIntersection(from, this._direction, position);\n    if ( distance > shape.boundingSphereRadius ) {\n        return;\n    }\n\n    var intersectMethod = this[shape.type];\n    if(intersectMethod){\n        intersectMethod.call(this, shape, quat, position, body);\n    }\n};\n\nvar vector = new Vec3();\nvar normal = new Vec3();\nvar intersectPoint = new Vec3();\n\nvar a = new Vec3();\nvar b = new Vec3();\nvar c = new Vec3();\nvar d = new Vec3();\n\nvar tmpRaycastResult = new RaycastResult();\n\n/**\n * @method intersectBox\n * @private\n * @param  {Shape} shape\n * @param  {Quaternion} quat\n * @param  {Vec3} position\n * @param  {Body} body\n */\nRay.prototype.intersectBox = function(shape, quat, position, body){\n    return this.intersectConvex(shape.convexPolyhedronRepresentation, quat, position, body);\n};\nRay.prototype[Shape.types.BOX] = Ray.prototype.intersectBox;\n\n/**\n * @method intersectPlane\n * @private\n * @param  {Shape} shape\n * @param  {Quaternion} quat\n * @param  {Vec3} position\n * @param  {Body} body\n */\nRay.prototype.intersectPlane = function(shape, quat, position, body){\n    var from = this.from;\n    var to = this.to;\n    var direction = this._direction;\n\n    // Get plane normal\n    var worldNormal = new Vec3(0, 0, 1);\n    quat.vmult(worldNormal, worldNormal);\n\n    var len = new Vec3();\n    from.vsub(position, len);\n    var planeToFrom = len.dot(worldNormal);\n    to.vsub(position, len);\n    var planeToTo = len.dot(worldNormal);\n\n    if(planeToFrom * planeToTo > 0){\n        // \"from\" and \"to\" are on the same side of the plane... bail out\n        return;\n    }\n\n    if(from.distanceTo(to) < planeToFrom){\n        return;\n    }\n\n    var n_dot_dir = worldNormal.dot(direction);\n\n    if (Math.abs(n_dot_dir) < this.precision) {\n        // No intersection\n        return;\n    }\n\n    var planePointToFrom = new Vec3();\n    var dir_scaled_with_t = new Vec3();\n    var hitPointWorld = new Vec3();\n\n    from.vsub(position, planePointToFrom);\n    var t = -worldNormal.dot(planePointToFrom) / n_dot_dir;\n    direction.scale(t, dir_scaled_with_t);\n    from.vadd(dir_scaled_with_t, hitPointWorld);\n\n    this.reportIntersection(worldNormal, hitPointWorld, shape, body, -1);\n};\nRay.prototype[Shape.types.PLANE] = Ray.prototype.intersectPlane;\n\n/**\n * Get the world AABB of the ray.\n * @method getAABB\n * @param  {AABB} aabb\n */\nRay.prototype.getAABB = function(result){\n    var to = this.to;\n    var from = this.from;\n    result.lowerBound.x = Math.min(to.x, from.x);\n    result.lowerBound.y = Math.min(to.y, from.y);\n    result.lowerBound.z = Math.min(to.z, from.z);\n    result.upperBound.x = Math.max(to.x, from.x);\n    result.upperBound.y = Math.max(to.y, from.y);\n    result.upperBound.z = Math.max(to.z, from.z);\n};\n\nvar intersectConvexOptions = {\n    faceList: [0]\n};\n\n/**\n * @method intersectHeightfield\n * @private\n * @param  {Shape} shape\n * @param  {Quaternion} quat\n * @param  {Vec3} position\n * @param  {Body} body\n */\nRay.prototype.intersectHeightfield = function(shape, quat, position, body){\n    var data = shape.data,\n        w = shape.elementSize,\n        worldPillarOffset = new Vec3();\n\n    // Convert the ray to local heightfield coordinates\n    var localRay = new Ray(this.from, this.to);\n    Transform.pointToLocalFrame(position, quat, localRay.from, localRay.from);\n    Transform.pointToLocalFrame(position, quat, localRay.to, localRay.to);\n\n    // Get the index of the data points to test against\n    var index = [];\n    var iMinX = null;\n    var iMinY = null;\n    var iMaxX = null;\n    var iMaxY = null;\n\n    var inside = shape.getIndexOfPosition(localRay.from.x, localRay.from.y, index, false);\n    if(inside){\n        iMinX = index[0];\n        iMinY = index[1];\n        iMaxX = index[0];\n        iMaxY = index[1];\n    }\n    inside = shape.getIndexOfPosition(localRay.to.x, localRay.to.y, index, false);\n    if(inside){\n        if (iMinX === null || index[0] < iMinX) { iMinX = index[0]; }\n        if (iMaxX === null || index[0] > iMaxX) { iMaxX = index[0]; }\n        if (iMinY === null || index[1] < iMinY) { iMinY = index[1]; }\n        if (iMaxY === null || index[1] > iMaxY) { iMaxY = index[1]; }\n    }\n\n    if(iMinX === null){\n        return;\n    }\n\n    var minMax = [];\n    shape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);\n    var min = minMax[0];\n    var max = minMax[1];\n\n    // // Bail out if the ray can't touch the bounding box\n    // // TODO\n    // var aabb = new AABB();\n    // this.getAABB(aabb);\n    // if(aabb.intersects()){\n    //     return;\n    // }\n\n    for(var i = iMinX; i <= iMaxX; i++){\n        for(var j = iMinY; j <= iMaxY; j++){\n\n            if(this.result._shouldStop){\n                return;\n            }\n\n            // Lower triangle\n            shape.getConvexTrianglePillar(i, j, false);\n            Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset);\n            this.intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, intersectConvexOptions);\n\n            if(this.result._shouldStop){\n                return;\n            }\n\n            // Upper triangle\n            shape.getConvexTrianglePillar(i, j, true);\n            Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset);\n            this.intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, intersectConvexOptions);\n        }\n    }\n};\nRay.prototype[Shape.types.HEIGHTFIELD] = Ray.prototype.intersectHeightfield;\n\nvar Ray_intersectSphere_intersectionPoint = new Vec3();\nvar Ray_intersectSphere_normal = new Vec3();\n\n/**\n * @method intersectSphere\n * @private\n * @param  {Shape} shape\n * @param  {Quaternion} quat\n * @param  {Vec3} position\n * @param  {Body} body\n */\nRay.prototype.intersectSphere = function(shape, quat, position, body){\n    var from = this.from,\n        to = this.to,\n        r = shape.radius;\n\n    var a = Math.pow(to.x - from.x, 2) + Math.pow(to.y - from.y, 2) + Math.pow(to.z - from.z, 2);\n    var b = 2 * ((to.x - from.x) * (from.x - position.x) + (to.y - from.y) * (from.y - position.y) + (to.z - from.z) * (from.z - position.z));\n    var c = Math.pow(from.x - position.x, 2) + Math.pow(from.y - position.y, 2) + Math.pow(from.z - position.z, 2) - Math.pow(r, 2);\n\n    var delta = Math.pow(b, 2) - 4 * a * c;\n\n    var intersectionPoint = Ray_intersectSphere_intersectionPoint;\n    var normal = Ray_intersectSphere_normal;\n\n    if(delta < 0){\n        // No intersection\n        return;\n\n    } else if(delta === 0){\n        // single intersection point\n        from.lerp(to, delta, intersectionPoint);\n\n        intersectionPoint.vsub(position, normal);\n        normal.normalize();\n\n        this.reportIntersection(normal, intersectionPoint, shape, body, -1);\n\n    } else {\n        var d1 = (- b - Math.sqrt(delta)) / (2 * a);\n        var d2 = (- b + Math.sqrt(delta)) / (2 * a);\n\n        if(d1 >= 0 && d1 <= 1){\n            from.lerp(to, d1, intersectionPoint);\n            intersectionPoint.vsub(position, normal);\n            normal.normalize();\n            this.reportIntersection(normal, intersectionPoint, shape, body, -1);\n        }\n\n        if(this.result._shouldStop){\n            return;\n        }\n\n        if(d2 >= 0 && d2 <= 1){\n            from.lerp(to, d2, intersectionPoint);\n            intersectionPoint.vsub(position, normal);\n            normal.normalize();\n            this.reportIntersection(normal, intersectionPoint, shape, body, -1);\n        }\n    }\n};\nRay.prototype[Shape.types.SPHERE] = Ray.prototype.intersectSphere;\n\n\nvar intersectConvex_normal = new Vec3();\nvar intersectConvex_minDistNormal = new Vec3();\nvar intersectConvex_minDistIntersect = new Vec3();\nvar intersectConvex_vector = new Vec3();\n\n/**\n * @method intersectConvex\n * @private\n * @param  {Shape} shape\n * @param  {Quaternion} quat\n * @param  {Vec3} position\n * @param  {Body} body\n * @param {object} [options]\n * @param {array} [options.faceList]\n */\nRay.prototype.intersectConvex = function intersectConvex(\n    shape,\n    quat,\n    position,\n    body,\n    options\n){\n    var minDistNormal = intersectConvex_minDistNormal;\n    var normal = intersectConvex_normal;\n    var vector = intersectConvex_vector;\n    var minDistIntersect = intersectConvex_minDistIntersect;\n    var faceList = (options && options.faceList) || null;\n\n    // Checking faces\n    var faces = shape.faces,\n        vertices = shape.vertices,\n        normals = shape.faceNormals;\n    var direction = this._direction;\n\n    var from = this.from;\n    var to = this.to;\n    var fromToDistance = from.distanceTo(to);\n\n    var minDist = -1;\n    var Nfaces = faceList ? faceList.length : faces.length;\n    var result = this.result;\n\n    for (var j = 0; !result._shouldStop && j < Nfaces; j++) {\n        var fi = faceList ? faceList[j] : j;\n\n        var face = faces[fi];\n        var faceNormal = normals[fi];\n        var q = quat;\n        var x = position;\n\n        // determine if ray intersects the plane of the face\n        // note: this works regardless of the direction of the face normal\n\n        // Get plane point in world coordinates...\n        vector.copy(vertices[face[0]]);\n        q.vmult(vector,vector);\n        vector.vadd(x,vector);\n\n        // ...but make it relative to the ray from. We'll fix this later.\n        vector.vsub(from,vector);\n\n        // Get plane normal\n        q.vmult(faceNormal,normal);\n\n        // If this dot product is negative, we have something interesting\n        var dot = direction.dot(normal);\n\n        // Bail out if ray and plane are parallel\n        if ( Math.abs( dot ) < this.precision ){\n            continue;\n        }\n\n        // calc distance to plane\n        var scalar = normal.dot(vector) / dot;\n\n        // if negative distance, then plane is behind ray\n        if (scalar < 0){\n            continue;\n        }\n\n        // if (dot < 0) {\n\n        // Intersection point is from + direction * scalar\n        direction.mult(scalar,intersectPoint);\n        intersectPoint.vadd(from,intersectPoint);\n\n        // a is the point we compare points b and c with.\n        a.copy(vertices[face[0]]);\n        q.vmult(a,a);\n        x.vadd(a,a);\n\n        for(var i = 1; !result._shouldStop && i < face.length - 1; i++){\n            // Transform 3 vertices to world coords\n            b.copy(vertices[face[i]]);\n            c.copy(vertices[face[i+1]]);\n            q.vmult(b,b);\n            q.vmult(c,c);\n            x.vadd(b,b);\n            x.vadd(c,c);\n\n            var distance = intersectPoint.distanceTo(from);\n\n            if(!(pointInTriangle(intersectPoint, a, b, c) || pointInTriangle(intersectPoint, b, a, c)) || distance > fromToDistance){\n                continue;\n            }\n\n            this.reportIntersection(normal, intersectPoint, shape, body, fi);\n        }\n        // }\n    }\n};\nRay.prototype[Shape.types.CONVEXPOLYHEDRON] = Ray.prototype.intersectConvex;\n\nvar intersectTrimesh_normal = new Vec3();\nvar intersectTrimesh_localDirection = new Vec3();\nvar intersectTrimesh_localFrom = new Vec3();\nvar intersectTrimesh_localTo = new Vec3();\nvar intersectTrimesh_worldNormal = new Vec3();\nvar intersectTrimesh_worldIntersectPoint = new Vec3();\nvar intersectTrimesh_localAABB = new AABB();\nvar intersectTrimesh_triangles = [];\nvar intersectTrimesh_treeTransform = new Transform();\n\n/**\n * @method intersectTrimesh\n * @private\n * @param  {Shape} shape\n * @param  {Quaternion} quat\n * @param  {Vec3} position\n * @param  {Body} body\n * @param {object} [options]\n * @todo Optimize by transforming the world to local space first.\n * @todo Use Octree lookup\n */\nRay.prototype.intersectTrimesh = function intersectTrimesh(\n    mesh,\n    quat,\n    position,\n    body,\n    options\n){\n    var normal = intersectTrimesh_normal;\n    var triangles = intersectTrimesh_triangles;\n    var treeTransform = intersectTrimesh_treeTransform;\n    var minDistNormal = intersectConvex_minDistNormal;\n    var vector = intersectConvex_vector;\n    var minDistIntersect = intersectConvex_minDistIntersect;\n    var localAABB = intersectTrimesh_localAABB;\n    var localDirection = intersectTrimesh_localDirection;\n    var localFrom = intersectTrimesh_localFrom;\n    var localTo = intersectTrimesh_localTo;\n    var worldIntersectPoint = intersectTrimesh_worldIntersectPoint;\n    var worldNormal = intersectTrimesh_worldNormal;\n    var faceList = (options && options.faceList) || null;\n\n    // Checking faces\n    var indices = mesh.indices,\n        vertices = mesh.vertices,\n        normals = mesh.faceNormals;\n\n    var from = this.from;\n    var to = this.to;\n    var direction = this._direction;\n\n    var minDist = -1;\n    treeTransform.position.copy(position);\n    treeTransform.quaternion.copy(quat);\n\n    // Transform ray to local space!\n    Transform.vectorToLocalFrame(position, quat, direction, localDirection);\n    //body.vectorToLocalFrame(direction, localDirection);\n    Transform.pointToLocalFrame(position, quat, from, localFrom);\n    //body.pointToLocalFrame(from, localFrom);\n    Transform.pointToLocalFrame(position, quat, to, localTo);\n    //body.pointToLocalFrame(to, localTo);\n    var fromToDistanceSquared = localFrom.distanceSquared(localTo);\n\n    mesh.tree.rayQuery(this, treeTransform, triangles);\n\n    for (var i = 0, N = triangles.length; !this.result._shouldStop && i !== N; i++) {\n        var trianglesIndex = triangles[i];\n\n        mesh.getNormal(trianglesIndex, normal);\n\n        // determine if ray intersects the plane of the face\n        // note: this works regardless of the direction of the face normal\n\n        // Get plane point in world coordinates...\n        mesh.getVertex(indices[trianglesIndex * 3], a);\n\n        // ...but make it relative to the ray from. We'll fix this later.\n        a.vsub(localFrom,vector);\n\n        // Get plane normal\n        // quat.vmult(normal, normal);\n\n        // If this dot product is negative, we have something interesting\n        var dot = localDirection.dot(normal);\n\n        // Bail out if ray and plane are parallel\n        // if (Math.abs( dot ) < this.precision){\n        //     continue;\n        // }\n\n        // calc distance to plane\n        var scalar = normal.dot(vector) / dot;\n\n        // if negative distance, then plane is behind ray\n        if (scalar < 0){\n            continue;\n        }\n\n        // Intersection point is from + direction * scalar\n        localDirection.scale(scalar,intersectPoint);\n        intersectPoint.vadd(localFrom,intersectPoint);\n\n        // Get triangle vertices\n        mesh.getVertex(indices[trianglesIndex * 3 + 1], b);\n        mesh.getVertex(indices[trianglesIndex * 3 + 2], c);\n\n        var squaredDistance = intersectPoint.distanceSquared(localFrom);\n\n        if(!(pointInTriangle(intersectPoint, b, a, c) || pointInTriangle(intersectPoint, a, b, c)) || squaredDistance > fromToDistanceSquared){\n            continue;\n        }\n\n        // transform intersectpoint and normal to world\n        Transform.vectorToWorldFrame(quat, normal, worldNormal);\n        //body.vectorToWorldFrame(normal, worldNormal);\n        Transform.pointToWorldFrame(position, quat, intersectPoint, worldIntersectPoint);\n        //body.pointToWorldFrame(intersectPoint, worldIntersectPoint);\n        this.reportIntersection(worldNormal, worldIntersectPoint, mesh, body, trianglesIndex);\n    }\n    triangles.length = 0;\n};\nRay.prototype[Shape.types.TRIMESH] = Ray.prototype.intersectTrimesh;\n\n\n/**\n * @method reportIntersection\n * @private\n * @param  {Vec3} normal\n * @param  {Vec3} hitPointWorld\n * @param  {Shape} shape\n * @param  {Body} body\n * @return {boolean} True if the intersections should continue\n */\nRay.prototype.reportIntersection = function(normal, hitPointWorld, shape, body, hitFaceIndex){\n    var from = this.from;\n    var to = this.to;\n    var distance = from.distanceTo(hitPointWorld);\n    var result = this.result;\n\n    // Skip back faces?\n    if(this.skipBackfaces && normal.dot(this._direction) > 0){\n        return;\n    }\n\n    result.hitFaceIndex = typeof(hitFaceIndex) !== 'undefined' ? hitFaceIndex : -1;\n\n    switch(this.mode){\n    case Ray.ALL:\n        this.hasHit = true;\n        result.set(\n            from,\n            to,\n            normal,\n            hitPointWorld,\n            shape,\n            body,\n            distance\n        );\n        result.hasHit = true;\n        this.callback(result);\n        break;\n\n    case Ray.CLOSEST:\n\n        // Store if closer than current closest\n        if(distance < result.distance || !result.hasHit){\n            this.hasHit = true;\n            result.hasHit = true;\n            result.set(\n                from,\n                to,\n                normal,\n                hitPointWorld,\n                shape,\n                body,\n                distance\n            );\n        }\n        break;\n\n    case Ray.ANY:\n\n        // Report and stop.\n        this.hasHit = true;\n        result.hasHit = true;\n        result.set(\n            from,\n            to,\n            normal,\n            hitPointWorld,\n            shape,\n            body,\n            distance\n        );\n        result._shouldStop = true;\n        break;\n    }\n};\n\nvar v0 = new Vec3(),\n    intersect = new Vec3();\nfunction distanceFromIntersection(from, direction, position) {\n\n    // v0 is vector from from to position\n    position.vsub(from,v0);\n    var dot = v0.dot(direction);\n\n    // intersect = direction*dot + from\n    direction.mult(dot,intersect);\n    intersect.vadd(from,intersect);\n\n    var distance = position.distanceTo(intersect);\n\n    return distance;\n}\n\n\n},{\"../collision/AABB\":3,\"../collision/RaycastResult\":10,\"../math/Quaternion\":28,\"../math/Transform\":29,\"../math/Vec3\":30,\"../shapes/Box\":37,\"../shapes/ConvexPolyhedron\":38,\"../shapes/Shape\":43}],10:[function(_dereq_,module,exports){\nvar Vec3 = _dereq_('../math/Vec3');\n\nmodule.exports = RaycastResult;\n\n/**\n * Storage for Ray casting data.\n * @class RaycastResult\n * @constructor\n */\nfunction RaycastResult(){\n\n\t/**\n\t * @property {Vec3} rayFromWorld\n\t */\n\tthis.rayFromWorld = new Vec3();\n\n\t/**\n\t * @property {Vec3} rayToWorld\n\t */\n\tthis.rayToWorld = new Vec3();\n\n\t/**\n\t * @property {Vec3} hitNormalWorld\n\t */\n\tthis.hitNormalWorld = new Vec3();\n\n\t/**\n\t * @property {Vec3} hitPointWorld\n\t */\n\tthis.hitPointWorld = new Vec3();\n\n\t/**\n\t * @property {boolean} hasHit\n\t */\n\tthis.hasHit = false;\n\n\t/**\n\t * The hit shape, or null.\n\t * @property {Shape} shape\n\t */\n\tthis.shape = null;\n\n\t/**\n\t * The hit body, or null.\n\t * @property {Body} body\n\t */\n\tthis.body = null;\n\n\t/**\n\t * The index of the hit triangle, if the hit shape was a trimesh.\n\t * @property {number} hitFaceIndex\n\t * @default -1\n\t */\n\tthis.hitFaceIndex = -1;\n\n\t/**\n\t * Distance to the hit. Will be set to -1 if there was no hit.\n\t * @property {number} distance\n\t * @default -1\n\t */\n\tthis.distance = -1;\n\n\t/**\n\t * If the ray should stop traversing the bodies.\n\t * @private\n\t * @property {Boolean} _shouldStop\n\t * @default false\n\t */\n\tthis._shouldStop = false;\n}\n\n/**\n * Reset all result data.\n * @method reset\n */\nRaycastResult.prototype.reset = function () {\n\tthis.rayFromWorld.setZero();\n\tthis.rayToWorld.setZero();\n\tthis.hitNormalWorld.setZero();\n\tthis.hitPointWorld.setZero();\n\tthis.hasHit = false;\n\tthis.shape = null;\n\tthis.body = null;\n\tthis.hitFaceIndex = -1;\n\tthis.distance = -1;\n\tthis._shouldStop = false;\n};\n\n/**\n * @method abort\n */\nRaycastResult.prototype.abort = function(){\n\tthis._shouldStop = true;\n};\n\n/**\n * @method set\n * @param {Vec3} rayFromWorld\n * @param {Vec3} rayToWorld\n * @param {Vec3} hitNormalWorld\n * @param {Vec3} hitPointWorld\n * @param {Shape} shape\n * @param {Body} body\n * @param {number} distance\n */\nRaycastResult.prototype.set = function(\n\trayFromWorld,\n\trayToWorld,\n\thitNormalWorld,\n\thitPointWorld,\n\tshape,\n\tbody,\n\tdistance\n){\n\tthis.rayFromWorld.copy(rayFromWorld);\n\tthis.rayToWorld.copy(rayToWorld);\n\tthis.hitNormalWorld.copy(hitNormalWorld);\n\tthis.hitPointWorld.copy(hitPointWorld);\n\tthis.shape = shape;\n\tthis.body = body;\n\tthis.distance = distance;\n};\n},{\"../math/Vec3\":30}],11:[function(_dereq_,module,exports){\nvar Shape = _dereq_('../shapes/Shape');\nvar Broadphase = _dereq_('../collision/Broadphase');\n\nmodule.exports = SAPBroadphase;\n\n/**\n * Sweep and prune broadphase along one axis.\n *\n * @class SAPBroadphase\n * @constructor\n * @param {World} [world]\n * @extends Broadphase\n */\nfunction SAPBroadphase(world){\n    Broadphase.apply(this);\n\n    /**\n     * List of bodies currently in the broadphase.\n     * @property axisList\n     * @type {Array}\n     */\n    this.axisList = [];\n\n    /**\n     * The world to search in.\n     * @property world\n     * @type {World}\n     */\n    this.world = null;\n\n    /**\n     * Axis to sort the bodies along. Set to 0 for x axis, and 1 for y axis. For best performance, choose an axis that the bodies are spread out more on.\n     * @property axisIndex\n     * @type {Number}\n     */\n    this.axisIndex = 0;\n\n    var axisList = this.axisList;\n\n    this._addBodyHandler = function(e){\n        axisList.push(e.body);\n    };\n\n    this._removeBodyHandler = function(e){\n        var idx = axisList.indexOf(e.body);\n        if(idx !== -1){\n            axisList.splice(idx,1);\n        }\n    };\n\n    if(world){\n        this.setWorld(world);\n    }\n}\nSAPBroadphase.prototype = new Broadphase();\n\n/**\n * Change the world\n * @method setWorld\n * @param  {World} world\n */\nSAPBroadphase.prototype.setWorld = function(world){\n    // Clear the old axis array\n    this.axisList.length = 0;\n\n    // Add all bodies from the new world\n    for(var i=0; i<world.bodies.length; i++){\n        this.axisList.push(world.bodies[i]);\n    }\n\n    // Remove old handlers, if any\n    world.removeEventListener(\"addBody\", this._addBodyHandler);\n    world.removeEventListener(\"removeBody\", this._removeBodyHandler);\n\n    // Add handlers to update the list of bodies.\n    world.addEventListener(\"addBody\", this._addBodyHandler);\n    world.addEventListener(\"removeBody\", this._removeBodyHandler);\n\n    this.world = world;\n    this.dirty = true;\n};\n\n/**\n * @static\n * @method insertionSortX\n * @param  {Array} a\n * @return {Array}\n */\nSAPBroadphase.insertionSortX = function(a) {\n    for(var i=1,l=a.length;i<l;i++) {\n        var v = a[i];\n        for(var j=i - 1;j>=0;j--) {\n            if(a[j].aabb.lowerBound.x <= v.aabb.lowerBound.x){\n                break;\n            }\n            a[j+1] = a[j];\n        }\n        a[j+1] = v;\n    }\n    return a;\n};\n\n/**\n * @static\n * @method insertionSortY\n * @param  {Array} a\n * @return {Array}\n */\nSAPBroadphase.insertionSortY = function(a) {\n    for(var i=1,l=a.length;i<l;i++) {\n        var v = a[i];\n        for(var j=i - 1;j>=0;j--) {\n            if(a[j].aabb.lowerBound.y <= v.aabb.lowerBound.y){\n                break;\n            }\n            a[j+1] = a[j];\n        }\n        a[j+1] = v;\n    }\n    return a;\n};\n\n/**\n * @static\n * @method insertionSortZ\n * @param  {Array} a\n * @return {Array}\n */\nSAPBroadphase.insertionSortZ = function(a) {\n    for(var i=1,l=a.length;i<l;i++) {\n        var v = a[i];\n        for(var j=i - 1;j>=0;j--) {\n            if(a[j].aabb.lowerBound.z <= v.aabb.lowerBound.z){\n                break;\n            }\n            a[j+1] = a[j];\n        }\n        a[j+1] = v;\n    }\n    return a;\n};\n\n/**\n * Collect all collision pairs\n * @method collisionPairs\n * @param  {World} world\n * @param  {Array} p1\n * @param  {Array} p2\n */\nSAPBroadphase.prototype.collisionPairs = function(world,p1,p2){\n    var bodies = this.axisList,\n        N = bodies.length,\n        axisIndex = this.axisIndex,\n        i, j;\n\n    if(this.dirty){\n        this.sortList();\n        this.dirty = false;\n    }\n\n    // Look through the list\n    for(i=0; i !== N; i++){\n        var bi = bodies[i];\n\n        for(j=i+1; j < N; j++){\n            var bj = bodies[j];\n\n            if(!this.needBroadphaseCollision(bi,bj)){\n                continue;\n            }\n\n            if(!SAPBroadphase.checkBounds(bi,bj,axisIndex)){\n                break;\n            }\n\n            this.intersectionTest(bi,bj,p1,p2);\n        }\n    }\n};\n\nSAPBroadphase.prototype.sortList = function(){\n    var axisList = this.axisList;\n    var axisIndex = this.axisIndex;\n    var N = axisList.length;\n\n    // Update AABBs\n    for(var i = 0; i!==N; i++){\n        var bi = axisList[i];\n        if(bi.aabbNeedsUpdate){\n            bi.computeAABB();\n        }\n    }\n\n    // Sort the list\n    if(axisIndex === 0){\n        SAPBroadphase.insertionSortX(axisList);\n    } else if(axisIndex === 1){\n        SAPBroadphase.insertionSortY(axisList);\n    } else if(axisIndex === 2){\n        SAPBroadphase.insertionSortZ(axisList);\n    }\n};\n\n/**\n * Check if the bounds of two bodies overlap, along the given SAP axis.\n * @static\n * @method checkBounds\n * @param  {Body} bi\n * @param  {Body} bj\n * @param  {Number} axisIndex\n * @return {Boolean}\n */\nSAPBroadphase.checkBounds = function(bi, bj, axisIndex){\n    var biPos;\n    var bjPos;\n\n    if(axisIndex === 0){\n        biPos = bi.position.x;\n        bjPos = bj.position.x;\n    } else if(axisIndex === 1){\n        biPos = bi.position.y;\n        bjPos = bj.position.y;\n    } else if(axisIndex === 2){\n        biPos = bi.position.z;\n        bjPos = bj.position.z;\n    }\n\n    var ri = bi.boundingRadius,\n        rj = bj.boundingRadius,\n        boundA1 = biPos - ri,\n        boundA2 = biPos + ri,\n        boundB1 = bjPos - rj,\n        boundB2 = bjPos + rj;\n\n    return boundB1 < boundA2;\n};\n\n/**\n * Computes the variance of the body positions and estimates the best\n * axis to use. Will automatically set property .axisIndex.\n * @method autoDetectAxis\n */\nSAPBroadphase.prototype.autoDetectAxis = function(){\n    var sumX=0,\n        sumX2=0,\n        sumY=0,\n        sumY2=0,\n        sumZ=0,\n        sumZ2=0,\n        bodies = this.axisList,\n        N = bodies.length,\n        invN=1/N;\n\n    for(var i=0; i!==N; i++){\n        var b = bodies[i];\n\n        var centerX = b.position.x;\n        sumX += centerX;\n        sumX2 += centerX*centerX;\n\n        var centerY = b.position.y;\n        sumY += centerY;\n        sumY2 += centerY*centerY;\n\n        var centerZ = b.position.z;\n        sumZ += centerZ;\n        sumZ2 += centerZ*centerZ;\n    }\n\n    var varianceX = sumX2 - sumX*sumX*invN,\n        varianceY = sumY2 - sumY*sumY*invN,\n        varianceZ = sumZ2 - sumZ*sumZ*invN;\n\n    if(varianceX > varianceY){\n        if(varianceX > varianceZ){\n            this.axisIndex = 0;\n        } else{\n            this.axisIndex = 2;\n        }\n    } else if(varianceY > varianceZ){\n        this.axisIndex = 1;\n    } else{\n        this.axisIndex = 2;\n    }\n};\n\n/**\n * Returns all the bodies within an AABB.\n * @method aabbQuery\n * @param  {World} world\n * @param  {AABB} aabb\n * @param {array} result An array to store resulting bodies in.\n * @return {array}\n */\nSAPBroadphase.prototype.aabbQuery = function(world, aabb, result){\n    result = result || [];\n\n    if(this.dirty){\n        this.sortList();\n        this.dirty = false;\n    }\n\n    var axisIndex = this.axisIndex, axis = 'x';\n    if(axisIndex === 1){ axis = 'y'; }\n    if(axisIndex === 2){ axis = 'z'; }\n\n    var axisList = this.axisList;\n    var lower = aabb.lowerBound[axis];\n    var upper = aabb.upperBound[axis];\n    for(var i = 0; i < axisList.length; i++){\n        var b = axisList[i];\n\n        if(b.aabbNeedsUpdate){\n            b.computeAABB();\n        }\n\n        if(b.aabb.overlaps(aabb)){\n            result.push(b);\n        }\n    }\n\n    return result;\n};\n},{\"../collision/Broadphase\":5,\"../shapes/Shape\":43}],12:[function(_dereq_,module,exports){\nmodule.exports = ConeTwistConstraint;\n\nvar Constraint = _dereq_('./Constraint');\nvar PointToPointConstraint = _dereq_('./PointToPointConstraint');\nvar ConeEquation = _dereq_('../equations/ConeEquation');\nvar RotationalEquation = _dereq_('../equations/RotationalEquation');\nvar ContactEquation = _dereq_('../equations/ContactEquation');\nvar Vec3 = _dereq_('../math/Vec3');\n\n/**\n * @class ConeTwistConstraint\n * @constructor\n * @author schteppe\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {object} [options]\n * @param {Vec3} [options.pivotA]\n * @param {Vec3} [options.pivotB]\n * @param {Vec3} [options.axisA]\n * @param {Vec3} [options.axisB]\n * @param {Number} [options.maxForce=1e6]\n * @extends PointToPointConstraint\n */\nfunction ConeTwistConstraint(bodyA, bodyB, options){\n    options = options || {};\n    var maxForce = typeof(options.maxForce) !== 'undefined' ? options.maxForce : 1e6;\n\n    // Set pivot point in between\n    var pivotA = options.pivotA ? options.pivotA.clone() : new Vec3();\n    var pivotB = options.pivotB ? options.pivotB.clone() : new Vec3();\n    this.axisA = options.axisA ? options.axisA.clone() : new Vec3();\n    this.axisB = options.axisB ? options.axisB.clone() : new Vec3();\n\n    PointToPointConstraint.call(this, bodyA, pivotA, bodyB, pivotB, maxForce);\n\n    this.collideConnected = !!options.collideConnected;\n\n    this.angle = typeof(options.angle) !== 'undefined' ? options.angle : 0;\n\n    /**\n     * @property {ConeEquation} coneEquation\n     */\n    var c = this.coneEquation = new ConeEquation(bodyA,bodyB,options);\n\n    /**\n     * @property {RotationalEquation} twistEquation\n     */\n    var t = this.twistEquation = new RotationalEquation(bodyA,bodyB,options);\n    this.twistAngle = typeof(options.twistAngle) !== 'undefined' ? options.twistAngle : 0;\n\n    // Make the cone equation push the bodies toward the cone axis, not outward\n    c.maxForce = 0;\n    c.minForce = -maxForce;\n\n    // Make the twist equation add torque toward the initial position\n    t.maxForce = 0;\n    t.minForce = -maxForce;\n\n    this.equations.push(c, t);\n}\nConeTwistConstraint.prototype = new PointToPointConstraint();\nConeTwistConstraint.constructor = ConeTwistConstraint;\n\nvar ConeTwistConstraint_update_tmpVec1 = new Vec3();\nvar ConeTwistConstraint_update_tmpVec2 = new Vec3();\n\nConeTwistConstraint.prototype.update = function(){\n    var bodyA = this.bodyA,\n        bodyB = this.bodyB,\n        cone = this.coneEquation,\n        twist = this.twistEquation;\n\n    PointToPointConstraint.prototype.update.call(this);\n\n    // Update the axes to the cone constraint\n    bodyA.vectorToWorldFrame(this.axisA, cone.axisA);\n    bodyB.vectorToWorldFrame(this.axisB, cone.axisB);\n\n    // Update the world axes in the twist constraint\n    this.axisA.tangents(twist.axisA, twist.axisA);\n    bodyA.vectorToWorldFrame(twist.axisA, twist.axisA);\n\n    this.axisB.tangents(twist.axisB, twist.axisB);\n    bodyB.vectorToWorldFrame(twist.axisB, twist.axisB);\n\n    cone.angle = this.angle;\n    twist.maxAngle = this.twistAngle;\n};\n\n\n},{\"../equations/ConeEquation\":18,\"../equations/ContactEquation\":19,\"../equations/RotationalEquation\":22,\"../math/Vec3\":30,\"./Constraint\":13,\"./PointToPointConstraint\":17}],13:[function(_dereq_,module,exports){\nmodule.exports = Constraint;\n\nvar Utils = _dereq_('../utils/Utils');\n\n/**\n * Constraint base class\n * @class Constraint\n * @author schteppe\n * @constructor\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {object} [options]\n * @param {boolean} [options.collideConnected=true]\n * @param {boolean} [options.wakeUpBodies=true]\n */\nfunction Constraint(bodyA, bodyB, options){\n    options = Utils.defaults(options,{\n        collideConnected : true,\n        wakeUpBodies : true,\n    });\n\n    /**\n     * Equations to be solved in this constraint\n     * @property equations\n     * @type {Array}\n     */\n    this.equations = [];\n\n    /**\n     * @property {Body} bodyA\n     */\n    this.bodyA = bodyA;\n\n    /**\n     * @property {Body} bodyB\n     */\n    this.bodyB = bodyB;\n\n    /**\n     * @property {Number} id\n     */\n    this.id = Constraint.idCounter++;\n\n    /**\n     * Set to true if you want the bodies to collide when they are connected.\n     * @property collideConnected\n     * @type {boolean}\n     */\n    this.collideConnected = options.collideConnected;\n\n    if(options.wakeUpBodies){\n        if(bodyA){\n            bodyA.wakeUp();\n        }\n        if(bodyB){\n            bodyB.wakeUp();\n        }\n    }\n}\n\n/**\n * Update all the equations with data.\n * @method update\n */\nConstraint.prototype.update = function(){\n    throw new Error(\"method update() not implmemented in this Constraint subclass!\");\n};\n\n/**\n * Enables all equations in the constraint.\n * @method enable\n */\nConstraint.prototype.enable = function(){\n    var eqs = this.equations;\n    for(var i=0; i<eqs.length; i++){\n        eqs[i].enabled = true;\n    }\n};\n\n/**\n * Disables all equations in the constraint.\n * @method disable\n */\nConstraint.prototype.disable = function(){\n    var eqs = this.equations;\n    for(var i=0; i<eqs.length; i++){\n        eqs[i].enabled = false;\n    }\n};\n\nConstraint.idCounter = 0;\n\n},{\"../utils/Utils\":53}],14:[function(_dereq_,module,exports){\nmodule.exports = DistanceConstraint;\n\nvar Constraint = _dereq_('./Constraint');\nvar ContactEquation = _dereq_('../equations/ContactEquation');\n\n/**\n * Constrains two bodies to be at a constant distance from each others center of mass.\n * @class DistanceConstraint\n * @constructor\n * @author schteppe\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Number} [distance] The distance to keep. If undefined, it will be set to the current distance between bodyA and bodyB\n * @param {Number} [maxForce=1e6]\n * @extends Constraint\n */\nfunction DistanceConstraint(bodyA,bodyB,distance,maxForce){\n    Constraint.call(this,bodyA,bodyB);\n\n    if(typeof(distance)===\"undefined\") {\n        distance = bodyA.position.distanceTo(bodyB.position);\n    }\n\n    if(typeof(maxForce)===\"undefined\") {\n        maxForce = 1e6;\n    }\n\n    /**\n     * @property {number} distance\n     */\n    this.distance = distance;\n\n    /**\n     * @property {ContactEquation} distanceEquation\n     */\n    var eq = this.distanceEquation = new ContactEquation(bodyA, bodyB);\n    this.equations.push(eq);\n\n    // Make it bidirectional\n    eq.minForce = -maxForce;\n    eq.maxForce =  maxForce;\n}\nDistanceConstraint.prototype = new Constraint();\n\nDistanceConstraint.prototype.update = function(){\n    var bodyA = this.bodyA;\n    var bodyB = this.bodyB;\n    var eq = this.distanceEquation;\n    var halfDist = this.distance * 0.5;\n    var normal = eq.ni;\n\n    bodyB.position.vsub(bodyA.position, normal);\n    normal.normalize();\n    normal.mult(halfDist, eq.ri);\n    normal.mult(-halfDist, eq.rj);\n};\n},{\"../equations/ContactEquation\":19,\"./Constraint\":13}],15:[function(_dereq_,module,exports){\nmodule.exports = HingeConstraint;\n\nvar Constraint = _dereq_('./Constraint');\nvar PointToPointConstraint = _dereq_('./PointToPointConstraint');\nvar RotationalEquation = _dereq_('../equations/RotationalEquation');\nvar RotationalMotorEquation = _dereq_('../equations/RotationalMotorEquation');\nvar ContactEquation = _dereq_('../equations/ContactEquation');\nvar Vec3 = _dereq_('../math/Vec3');\n\n/**\n * Hinge constraint. Think of it as a door hinge. It tries to keep the door in the correct place and with the correct orientation.\n * @class HingeConstraint\n * @constructor\n * @author schteppe\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {object} [options]\n * @param {Vec3} [options.pivotA] A point defined locally in bodyA. This defines the offset of axisA.\n * @param {Vec3} [options.axisA] An axis that bodyA can rotate around, defined locally in bodyA.\n * @param {Vec3} [options.pivotB]\n * @param {Vec3} [options.axisB]\n * @param {Number} [options.maxForce=1e6]\n * @extends PointToPointConstraint\n */\nfunction HingeConstraint(bodyA, bodyB, options){\n    options = options || {};\n    var maxForce = typeof(options.maxForce) !== 'undefined' ? options.maxForce : 1e6;\n    var pivotA = options.pivotA ? options.pivotA.clone() : new Vec3();\n    var pivotB = options.pivotB ? options.pivotB.clone() : new Vec3();\n\n    PointToPointConstraint.call(this, bodyA, pivotA, bodyB, pivotB, maxForce);\n\n    /**\n     * Rotation axis, defined locally in bodyA.\n     * @property {Vec3} axisA\n     */\n    var axisA = this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1,0,0);\n    axisA.normalize();\n\n    /**\n     * Rotation axis, defined locally in bodyB.\n     * @property {Vec3} axisB\n     */\n    var axisB = this.axisB = options.axisB ? options.axisB.clone() : new Vec3(1,0,0);\n    axisB.normalize();\n\n    /**\n     * @property {RotationalEquation} rotationalEquation1\n     */\n    var r1 = this.rotationalEquation1 = new RotationalEquation(bodyA,bodyB,options);\n\n    /**\n     * @property {RotationalEquation} rotationalEquation2\n     */\n    var r2 = this.rotationalEquation2 = new RotationalEquation(bodyA,bodyB,options);\n\n    /**\n     * @property {RotationalMotorEquation} motorEquation\n     */\n    var motor = this.motorEquation = new RotationalMotorEquation(bodyA,bodyB,maxForce);\n    motor.enabled = false; // Not enabled by default\n\n    // Equations to be fed to the solver\n    this.equations.push(\n        r1, // rotational1\n        r2, // rotational2\n        motor\n    );\n}\nHingeConstraint.prototype = new PointToPointConstraint();\nHingeConstraint.constructor = HingeConstraint;\n\n/**\n * @method enableMotor\n */\nHingeConstraint.prototype.enableMotor = function(){\n    this.motorEquation.enabled = true;\n};\n\n/**\n * @method disableMotor\n */\nHingeConstraint.prototype.disableMotor = function(){\n    this.motorEquation.enabled = false;\n};\n\n/**\n * @method setMotorSpeed\n * @param {number} speed\n */\nHingeConstraint.prototype.setMotorSpeed = function(speed){\n    this.motorEquation.targetVelocity = speed;\n};\n\n/**\n * @method setMotorMaxForce\n * @param {number} maxForce\n */\nHingeConstraint.prototype.setMotorMaxForce = function(maxForce){\n    this.motorEquation.maxForce = maxForce;\n    this.motorEquation.minForce = -maxForce;\n};\n\nvar HingeConstraint_update_tmpVec1 = new Vec3();\nvar HingeConstraint_update_tmpVec2 = new Vec3();\n\nHingeConstraint.prototype.update = function(){\n    var bodyA = this.bodyA,\n        bodyB = this.bodyB,\n        motor = this.motorEquation,\n        r1 = this.rotationalEquation1,\n        r2 = this.rotationalEquation2,\n        worldAxisA = HingeConstraint_update_tmpVec1,\n        worldAxisB = HingeConstraint_update_tmpVec2;\n\n    var axisA = this.axisA;\n    var axisB = this.axisB;\n\n    PointToPointConstraint.prototype.update.call(this);\n\n    // Get world axes\n    bodyA.quaternion.vmult(axisA, worldAxisA);\n    bodyB.quaternion.vmult(axisB, worldAxisB);\n\n    worldAxisA.tangents(r1.axisA, r2.axisA);\n    r1.axisB.copy(worldAxisB);\n    r2.axisB.copy(worldAxisB);\n\n    if(this.motorEquation.enabled){\n        bodyA.quaternion.vmult(this.axisA, motor.axisA);\n        bodyB.quaternion.vmult(this.axisB, motor.axisB);\n    }\n};\n\n\n},{\"../equations/ContactEquation\":19,\"../equations/RotationalEquation\":22,\"../equations/RotationalMotorEquation\":23,\"../math/Vec3\":30,\"./Constraint\":13,\"./PointToPointConstraint\":17}],16:[function(_dereq_,module,exports){\nmodule.exports = LockConstraint;\n\nvar Constraint = _dereq_('./Constraint');\nvar PointToPointConstraint = _dereq_('./PointToPointConstraint');\nvar RotationalEquation = _dereq_('../equations/RotationalEquation');\nvar RotationalMotorEquation = _dereq_('../equations/RotationalMotorEquation');\nvar ContactEquation = _dereq_('../equations/ContactEquation');\nvar Vec3 = _dereq_('../math/Vec3');\n\n/**\n * Lock constraint. Will remove all degrees of freedom between the bodies.\n * @class LockConstraint\n * @constructor\n * @author schteppe\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {object} [options]\n * @param {Number} [options.maxForce=1e6]\n * @extends PointToPointConstraint\n */\nfunction LockConstraint(bodyA, bodyB, options){\n    options = options || {};\n    var maxForce = typeof(options.maxForce) !== 'undefined' ? options.maxForce : 1e6;\n\n    // Set pivot point in between\n    var pivotA = new Vec3();\n    var pivotB = new Vec3();\n    var halfWay = new Vec3();\n    bodyA.position.vadd(bodyB.position, halfWay);\n    halfWay.scale(0.5, halfWay);\n    bodyB.pointToLocalFrame(halfWay, pivotB);\n    bodyA.pointToLocalFrame(halfWay, pivotA);\n    PointToPointConstraint.call(this, bodyA, pivotA, bodyB, pivotB, maxForce);\n\n    /**\n     * @property {RotationalEquation} rotationalEquation1\n     */\n    var r1 = this.rotationalEquation1 = new RotationalEquation(bodyA,bodyB,options);\n\n    /**\n     * @property {RotationalEquation} rotationalEquation2\n     */\n    var r2 = this.rotationalEquation2 = new RotationalEquation(bodyA,bodyB,options);\n\n    /**\n     * @property {RotationalEquation} rotationalEquation3\n     */\n    var r3 = this.rotationalEquation3 = new RotationalEquation(bodyA,bodyB,options);\n\n    this.equations.push(r1, r2, r3);\n}\nLockConstraint.prototype = new PointToPointConstraint();\nLockConstraint.constructor = LockConstraint;\n\nvar LockConstraint_update_tmpVec1 = new Vec3();\nvar LockConstraint_update_tmpVec2 = new Vec3();\n\nLockConstraint.prototype.update = function(){\n    var bodyA = this.bodyA,\n        bodyB = this.bodyB,\n        motor = this.motorEquation,\n        r1 = this.rotationalEquation1,\n        r2 = this.rotationalEquation2,\n        r3 = this.rotationalEquation3,\n        worldAxisA = LockConstraint_update_tmpVec1,\n        worldAxisB = LockConstraint_update_tmpVec2;\n\n    PointToPointConstraint.prototype.update.call(this);\n\n    bodyA.vectorToWorldFrame(Vec3.UNIT_X, r1.axisA);\n    bodyB.vectorToWorldFrame(Vec3.UNIT_Y, r1.axisB);\n\n    bodyA.vectorToWorldFrame(Vec3.UNIT_Y, r2.axisA);\n    bodyB.vectorToWorldFrame(Vec3.UNIT_Z, r2.axisB);\n\n    bodyA.vectorToWorldFrame(Vec3.UNIT_Z, r3.axisA);\n    bodyB.vectorToWorldFrame(Vec3.UNIT_X, r3.axisB);\n};\n\n\n},{\"../equations/ContactEquation\":19,\"../equations/RotationalEquation\":22,\"../equations/RotationalMotorEquation\":23,\"../math/Vec3\":30,\"./Constraint\":13,\"./PointToPointConstraint\":17}],17:[function(_dereq_,module,exports){\nmodule.exports = PointToPointConstraint;\n\nvar Constraint = _dereq_('./Constraint');\nvar ContactEquation = _dereq_('../equations/ContactEquation');\nvar Vec3 = _dereq_('../math/Vec3');\n\n/**\n * Connects two bodies at given offset points.\n * @class PointToPointConstraint\n * @extends Constraint\n * @constructor\n * @param {Body} bodyA\n * @param {Vec3} pivotA The point relative to the center of mass of bodyA which bodyA is constrained to.\n * @param {Body} bodyB Body that will be constrained in a similar way to the same point as bodyA. We will therefore get a link between bodyA and bodyB. If not specified, bodyA will be constrained to a static point.\n * @param {Vec3} pivotB See pivotA.\n * @param {Number} maxForce The maximum force that should be applied to constrain the bodies.\n *\n * @example\n *     var bodyA = new Body({ mass: 1 });\n *     var bodyB = new Body({ mass: 1 });\n *     bodyA.position.set(-1, 0, 0);\n *     bodyB.position.set(1, 0, 0);\n *     bodyA.addShape(shapeA);\n *     bodyB.addShape(shapeB);\n *     world.addBody(bodyA);\n *     world.addBody(bodyB);\n *     var localPivotA = new Vec3(1, 0, 0);\n *     var localPivotB = new Vec3(-1, 0, 0);\n *     var constraint = new PointToPointConstraint(bodyA, localPivotA, bodyB, localPivotB);\n *     world.addConstraint(constraint);\n */\nfunction PointToPointConstraint(bodyA,pivotA,bodyB,pivotB,maxForce){\n    Constraint.call(this,bodyA,bodyB);\n\n    maxForce = typeof(maxForce) !== 'undefined' ? maxForce : 1e6;\n\n    /**\n     * Pivot, defined locally in bodyA.\n     * @property {Vec3} pivotA\n     */\n    this.pivotA = pivotA ? pivotA.clone() : new Vec3();\n\n    /**\n     * Pivot, defined locally in bodyB.\n     * @property {Vec3} pivotB\n     */\n    this.pivotB = pivotB ? pivotB.clone() : new Vec3();\n\n    /**\n     * @property {ContactEquation} equationX\n     */\n    var x = this.equationX = new ContactEquation(bodyA,bodyB);\n\n    /**\n     * @property {ContactEquation} equationY\n     */\n    var y = this.equationY = new ContactEquation(bodyA,bodyB);\n\n    /**\n     * @property {ContactEquation} equationZ\n     */\n    var z = this.equationZ = new ContactEquation(bodyA,bodyB);\n\n    // Equations to be fed to the solver\n    this.equations.push(x, y, z);\n\n    // Make the equations bidirectional\n    x.minForce = y.minForce = z.minForce = -maxForce;\n    x.maxForce = y.maxForce = z.maxForce =  maxForce;\n\n    x.ni.set(1, 0, 0);\n    y.ni.set(0, 1, 0);\n    z.ni.set(0, 0, 1);\n}\nPointToPointConstraint.prototype = new Constraint();\n\nPointToPointConstraint.prototype.update = function(){\n    var bodyA = this.bodyA;\n    var bodyB = this.bodyB;\n    var x = this.equationX;\n    var y = this.equationY;\n    var z = this.equationZ;\n\n    // Rotate the pivots to world space\n    bodyA.quaternion.vmult(this.pivotA,x.ri);\n    bodyB.quaternion.vmult(this.pivotB,x.rj);\n\n    y.ri.copy(x.ri);\n    y.rj.copy(x.rj);\n    z.ri.copy(x.ri);\n    z.rj.copy(x.rj);\n};\n},{\"../equations/ContactEquation\":19,\"../math/Vec3\":30,\"./Constraint\":13}],18:[function(_dereq_,module,exports){\nmodule.exports = ConeEquation;\n\nvar Vec3 = _dereq_('../math/Vec3');\nvar Mat3 = _dereq_('../math/Mat3');\nvar Equation = _dereq_('./Equation');\n\n/**\n * Cone equation. Works to keep the given body world vectors aligned, or tilted within a given angle from each other.\n * @class ConeEquation\n * @constructor\n * @author schteppe\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Vec3} [options.axisA] Local axis in A\n * @param {Vec3} [options.axisB] Local axis in B\n * @param {Vec3} [options.angle] The \"cone angle\" to keep\n * @param {number} [options.maxForce=1e6]\n * @extends Equation\n */\nfunction ConeEquation(bodyA, bodyB, options){\n    options = options || {};\n    var maxForce = typeof(options.maxForce) !== 'undefined' ? options.maxForce : 1e6;\n\n    Equation.call(this,bodyA,bodyB,-maxForce, maxForce);\n\n    this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1, 0, 0);\n    this.axisB = options.axisB ? options.axisB.clone() : new Vec3(0, 1, 0);\n\n    /**\n     * The cone angle to keep\n     * @property {number} angle\n     */\n    this.angle = typeof(options.angle) !== 'undefined' ? options.angle : 0;\n}\n\nConeEquation.prototype = new Equation();\nConeEquation.prototype.constructor = ConeEquation;\n\nvar tmpVec1 = new Vec3();\nvar tmpVec2 = new Vec3();\n\nConeEquation.prototype.computeB = function(h){\n    var a = this.a,\n        b = this.b,\n\n        ni = this.axisA,\n        nj = this.axisB,\n\n        nixnj = tmpVec1,\n        njxni = tmpVec2,\n\n        GA = this.jacobianElementA,\n        GB = this.jacobianElementB;\n\n    // Caluclate cross products\n    ni.cross(nj, nixnj);\n    nj.cross(ni, njxni);\n\n    // The angle between two vector is:\n    // cos(theta) = a * b / (length(a) * length(b) = { len(a) = len(b) = 1 } = a * b\n\n    // g = a * b\n    // gdot = (b x a) * wi + (a x b) * wj\n    // G = [0 bxa 0 axb]\n    // W = [vi wi vj wj]\n    GA.rotational.copy(njxni);\n    GB.rotational.copy(nixnj);\n\n    var g = Math.cos(this.angle) - ni.dot(nj),\n        GW = this.computeGW(),\n        GiMf = this.computeGiMf();\n\n    var B = - g * a - GW * b - h * GiMf;\n\n    return B;\n};\n\n\n},{\"../math/Mat3\":27,\"../math/Vec3\":30,\"./Equation\":20}],19:[function(_dereq_,module,exports){\nmodule.exports = ContactEquation;\n\nvar Equation = _dereq_('./Equation');\nvar Vec3 = _dereq_('../math/Vec3');\nvar Mat3 = _dereq_('../math/Mat3');\n\n/**\n * Contact/non-penetration constraint equation\n * @class ContactEquation\n * @constructor\n * @author schteppe\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @extends Equation\n */\nfunction ContactEquation(bodyA, bodyB, maxForce){\n    maxForce = typeof(maxForce) !== 'undefined' ? maxForce : 1e6;\n    Equation.call(this, bodyA, bodyB, 0, maxForce);\n\n    /**\n     * @property restitution\n     * @type {Number}\n     */\n    this.restitution = 0.0; // \"bounciness\": u1 = -e*u0\n\n    /**\n     * World-oriented vector that goes from the center of bi to the contact point.\n     * @property {Vec3} ri\n     */\n    this.ri = new Vec3();\n\n    /**\n     * World-oriented vector that starts in body j position and goes to the contact point.\n     * @property {Vec3} rj\n     */\n    this.rj = new Vec3();\n\n    /**\n     * Contact normal, pointing out of body i.\n     * @property {Vec3} ni\n     */\n    this.ni = new Vec3();\n}\n\nContactEquation.prototype = new Equation();\nContactEquation.prototype.constructor = ContactEquation;\n\nvar ContactEquation_computeB_temp1 = new Vec3(); // Temp vectors\nvar ContactEquation_computeB_temp2 = new Vec3();\nvar ContactEquation_computeB_temp3 = new Vec3();\nContactEquation.prototype.computeB = function(h){\n    var a = this.a,\n        b = this.b,\n        bi = this.bi,\n        bj = this.bj,\n        ri = this.ri,\n        rj = this.rj,\n        rixn = ContactEquation_computeB_temp1,\n        rjxn = ContactEquation_computeB_temp2,\n\n        vi = bi.velocity,\n        wi = bi.angularVelocity,\n        fi = bi.force,\n        taui = bi.torque,\n\n        vj = bj.velocity,\n        wj = bj.angularVelocity,\n        fj = bj.force,\n        tauj = bj.torque,\n\n        penetrationVec = ContactEquation_computeB_temp3,\n\n        GA = this.jacobianElementA,\n        GB = this.jacobianElementB,\n\n        n = this.ni;\n\n    // Caluclate cross products\n    ri.cross(n,rixn);\n    rj.cross(n,rjxn);\n\n    // g = xj+rj -(xi+ri)\n    // G = [ -ni  -rixn  ni  rjxn ]\n    n.negate(GA.spatial);\n    rixn.negate(GA.rotational);\n    GB.spatial.copy(n);\n    GB.rotational.copy(rjxn);\n\n    // Calculate the penetration vector\n    penetrationVec.copy(bj.position);\n    penetrationVec.vadd(rj,penetrationVec);\n    penetrationVec.vsub(bi.position,penetrationVec);\n    penetrationVec.vsub(ri,penetrationVec);\n\n    var g = n.dot(penetrationVec);\n\n    // Compute iteration\n    var ePlusOne = this.restitution + 1;\n    var GW = ePlusOne * vj.dot(n) - ePlusOne * vi.dot(n) + wj.dot(rjxn) - wi.dot(rixn);\n    var GiMf = this.computeGiMf();\n\n    var B = - g * a - GW * b - h*GiMf;\n\n    return B;\n};\n\nvar ContactEquation_getImpactVelocityAlongNormal_vi = new Vec3();\nvar ContactEquation_getImpactVelocityAlongNormal_vj = new Vec3();\nvar ContactEquation_getImpactVelocityAlongNormal_xi = new Vec3();\nvar ContactEquation_getImpactVelocityAlongNormal_xj = new Vec3();\nvar ContactEquation_getImpactVelocityAlongNormal_relVel = new Vec3();\n\n/**\n * Get the current relative velocity in the contact point.\n * @method getImpactVelocityAlongNormal\n * @return {number}\n */\nContactEquation.prototype.getImpactVelocityAlongNormal = function(){\n    var vi = ContactEquation_getImpactVelocityAlongNormal_vi;\n    var vj = ContactEquation_getImpactVelocityAlongNormal_vj;\n    var xi = ContactEquation_getImpactVelocityAlongNormal_xi;\n    var xj = ContactEquation_getImpactVelocityAlongNormal_xj;\n    var relVel = ContactEquation_getImpactVelocityAlongNormal_relVel;\n\n    this.bi.position.vadd(this.ri, xi);\n    this.bj.position.vadd(this.rj, xj);\n\n    this.bi.getVelocityAtWorldPoint(xi, vi);\n    this.bj.getVelocityAtWorldPoint(xj, vj);\n\n    vi.vsub(vj, relVel);\n\n    return this.ni.dot(relVel);\n};\n\n\n},{\"../math/Mat3\":27,\"../math/Vec3\":30,\"./Equation\":20}],20:[function(_dereq_,module,exports){\nmodule.exports = Equation;\n\nvar JacobianElement = _dereq_('../math/JacobianElement'),\n    Vec3 = _dereq_('../math/Vec3');\n\n/**\n * Equation base class\n * @class Equation\n * @constructor\n * @author schteppe\n * @param {Body} bi\n * @param {Body} bj\n * @param {Number} minForce Minimum (read: negative max) force to be applied by the constraint.\n * @param {Number} maxForce Maximum (read: positive max) force to be applied by the constraint.\n */\nfunction Equation(bi,bj,minForce,maxForce){\n    this.id = Equation.id++;\n\n    /**\n     * @property {number} minForce\n     */\n    this.minForce = typeof(minForce)===\"undefined\" ? -1e6 : minForce;\n\n    /**\n     * @property {number} maxForce\n     */\n    this.maxForce = typeof(maxForce)===\"undefined\" ? 1e6 : maxForce;\n\n    /**\n     * @property bi\n     * @type {Body}\n     */\n    this.bi = bi;\n\n    /**\n     * @property bj\n     * @type {Body}\n     */\n    this.bj = bj;\n\n    /**\n     * SPOOK parameter\n     * @property {number} a\n     */\n    this.a = 0.0;\n\n    /**\n     * SPOOK parameter\n     * @property {number} b\n     */\n    this.b = 0.0;\n\n    /**\n     * SPOOK parameter\n     * @property {number} eps\n     */\n    this.eps = 0.0;\n\n    /**\n     * @property {JacobianElement} jacobianElementA\n     */\n    this.jacobianElementA = new JacobianElement();\n\n    /**\n     * @property {JacobianElement} jacobianElementB\n     */\n    this.jacobianElementB = new JacobianElement();\n\n    /**\n     * @property {boolean} enabled\n     * @default true\n     */\n    this.enabled = true;\n\n    // Set typical spook params\n    this.setSpookParams(1e7,4,1/60);\n}\nEquation.prototype.constructor = Equation;\n\nEquation.id = 0;\n\n/**\n * Recalculates a,b,eps.\n * @method setSpookParams\n */\nEquation.prototype.setSpookParams = function(stiffness,relaxation,timeStep){\n    var d = relaxation,\n        k = stiffness,\n        h = timeStep;\n    this.a = 4.0 / (h * (1 + 4 * d));\n    this.b = (4.0 * d) / (1 + 4 * d);\n    this.eps = 4.0 / (h * h * k * (1 + 4 * d));\n};\n\n/**\n * Computes the RHS of the SPOOK equation\n * @method computeB\n * @return {Number}\n */\nEquation.prototype.computeB = function(a,b,h){\n    var GW = this.computeGW(),\n        Gq = this.computeGq(),\n        GiMf = this.computeGiMf();\n    return - Gq * a - GW * b - GiMf*h;\n};\n\n/**\n * Computes G*q, where q are the generalized body coordinates\n * @method computeGq\n * @return {Number}\n */\nEquation.prototype.computeGq = function(){\n    var GA = this.jacobianElementA,\n        GB = this.jacobianElementB,\n        bi = this.bi,\n        bj = this.bj,\n        xi = bi.position,\n        xj = bj.position;\n    return GA.spatial.dot(xi) + GB.spatial.dot(xj);\n};\n\nvar zero = new Vec3();\n\n/**\n * Computes G*W, where W are the body velocities\n * @method computeGW\n * @return {Number}\n */\nEquation.prototype.computeGW = function(){\n    var GA = this.jacobianElementA,\n        GB = this.jacobianElementB,\n        bi = this.bi,\n        bj = this.bj,\n        vi = bi.velocity,\n        vj = bj.velocity,\n        wi = bi.angularVelocity || zero,\n        wj = bj.angularVelocity || zero;\n    return GA.multiplyVectors(vi,wi) + GB.multiplyVectors(vj,wj);\n};\n\n\n/**\n * Computes G*Wlambda, where W are the body velocities\n * @method computeGWlambda\n * @return {Number}\n */\nEquation.prototype.computeGWlambda = function(){\n    var GA = this.jacobianElementA,\n        GB = this.jacobianElementB,\n        bi = this.bi,\n        bj = this.bj,\n        vi = bi.vlambda,\n        vj = bj.vlambda,\n        wi = bi.wlambda || zero,\n        wj = bj.wlambda || zero;\n    return GA.multiplyVectors(vi,wi) + GB.multiplyVectors(vj,wj);\n};\n\n/**\n * Computes G*inv(M)*f, where M is the mass matrix with diagonal blocks for each body, and f are the forces on the bodies.\n * @method computeGiMf\n * @return {Number}\n */\nvar iMfi = new Vec3(),\n    iMfj = new Vec3(),\n    invIi_vmult_taui = new Vec3(),\n    invIj_vmult_tauj = new Vec3();\nEquation.prototype.computeGiMf = function(){\n    var GA = this.jacobianElementA,\n        GB = this.jacobianElementB,\n        bi = this.bi,\n        bj = this.bj,\n        fi = bi.force,\n        ti = bi.torque,\n        fj = bj.force,\n        tj = bj.torque,\n        invMassi = bi.invMassSolve,\n        invMassj = bj.invMassSolve;\n\n    if(bi.invInertiaWorldSolve){ bi.invInertiaWorldSolve.vmult(ti,invIi_vmult_taui); }\n    else { invIi_vmult_taui.set(0,0,0); }\n    if(bj.invInertiaWorldSolve){ bj.invInertiaWorldSolve.vmult(tj,invIj_vmult_tauj); }\n    else { invIj_vmult_tauj.set(0,0,0); }\n\n    fi.mult(invMassi,iMfi);\n    fj.mult(invMassj,iMfj);\n\n    return GA.multiplyVectors(iMfi,invIi_vmult_taui) + GB.multiplyVectors(iMfj,invIj_vmult_tauj);\n};\n\n/**\n * Computes G*inv(M)*G'\n * @method computeGiMGt\n * @return {Number}\n */\nvar tmp = new Vec3();\nEquation.prototype.computeGiMGt = function(){\n    var GA = this.jacobianElementA,\n        GB = this.jacobianElementB,\n        bi = this.bi,\n        bj = this.bj,\n        invMassi = bi.invMassSolve,\n        invMassj = bj.invMassSolve,\n        invIi = bi.invInertiaWorldSolve,\n        invIj = bj.invInertiaWorldSolve,\n        result = invMassi + invMassj;\n\n    if(invIi){\n        invIi.vmult(GA.rotational,tmp);\n        result += tmp.dot(GA.rotational);\n    }\n\n    if(invIj){\n        invIj.vmult(GB.rotational,tmp);\n        result += tmp.dot(GB.rotational);\n    }\n\n    return  result;\n};\n\nvar addToWlambda_temp = new Vec3(),\n    addToWlambda_Gi = new Vec3(),\n    addToWlambda_Gj = new Vec3(),\n    addToWlambda_ri = new Vec3(),\n    addToWlambda_rj = new Vec3(),\n    addToWlambda_Mdiag = new Vec3();\n\n/**\n * Add constraint velocity to the bodies.\n * @method addToWlambda\n * @param {Number} deltalambda\n */\nEquation.prototype.addToWlambda = function(deltalambda){\n    var GA = this.jacobianElementA,\n        GB = this.jacobianElementB,\n        bi = this.bi,\n        bj = this.bj,\n        temp = addToWlambda_temp;\n\n    // Add to linear velocity\n    // v_lambda += inv(M) * delta_lamba * G\n    GA.spatial.mult(bi.invMassSolve * deltalambda,temp);\n    bi.vlambda.vadd(temp, bi.vlambda);\n\n    GB.spatial.mult(bj.invMassSolve * deltalambda,temp);\n    bj.vlambda.vadd(temp, bj.vlambda);\n\n    // Add to angular velocity\n    if(bi.invInertiaWorldSolve){\n        bi.invInertiaWorldSolve.vmult(GA.rotational,temp);\n        temp.mult(deltalambda,temp);\n        bi.wlambda.vadd(temp,bi.wlambda);\n    }\n\n    if(bj.invInertiaWorldSolve){\n        bj.invInertiaWorldSolve.vmult(GB.rotational,temp);\n        temp.mult(deltalambda,temp);\n        bj.wlambda.vadd(temp,bj.wlambda);\n    }\n};\n\n/**\n * Compute the denominator part of the SPOOK equation: C = G*inv(M)*G' + eps\n * @method computeInvC\n * @param  {Number} eps\n * @return {Number}\n */\nEquation.prototype.computeC = function(){\n    return this.computeGiMGt() + this.eps;\n};\n\n},{\"../math/JacobianElement\":26,\"../math/Vec3\":30}],21:[function(_dereq_,module,exports){\nmodule.exports = FrictionEquation;\n\nvar Equation = _dereq_('./Equation');\nvar Vec3 = _dereq_('../math/Vec3');\nvar Mat3 = _dereq_('../math/Mat3');\n\n/**\n * Constrains the slipping in a contact along a tangent\n * @class FrictionEquation\n * @constructor\n * @author schteppe\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Number} slipForce should be +-F_friction = +-mu * F_normal = +-mu * m * g\n * @extends Equation\n */\nfunction FrictionEquation(bodyA, bodyB, slipForce){\n    Equation.call(this,bodyA, bodyB, -slipForce, slipForce);\n    this.ri = new Vec3();\n    this.rj = new Vec3();\n    this.t = new Vec3(); // tangent\n}\n\nFrictionEquation.prototype = new Equation();\nFrictionEquation.prototype.constructor = FrictionEquation;\n\nvar FrictionEquation_computeB_temp1 = new Vec3();\nvar FrictionEquation_computeB_temp2 = new Vec3();\nFrictionEquation.prototype.computeB = function(h){\n    var a = this.a,\n        b = this.b,\n        bi = this.bi,\n        bj = this.bj,\n        ri = this.ri,\n        rj = this.rj,\n        rixt = FrictionEquation_computeB_temp1,\n        rjxt = FrictionEquation_computeB_temp2,\n        t = this.t;\n\n    // Caluclate cross products\n    ri.cross(t,rixt);\n    rj.cross(t,rjxt);\n\n    // G = [-t -rixt t rjxt]\n    // And remember, this is a pure velocity constraint, g is always zero!\n    var GA = this.jacobianElementA,\n        GB = this.jacobianElementB;\n    t.negate(GA.spatial);\n    rixt.negate(GA.rotational);\n    GB.spatial.copy(t);\n    GB.rotational.copy(rjxt);\n\n    var GW = this.computeGW();\n    var GiMf = this.computeGiMf();\n\n    var B = - GW * b - h * GiMf;\n\n    return B;\n};\n\n},{\"../math/Mat3\":27,\"../math/Vec3\":30,\"./Equation\":20}],22:[function(_dereq_,module,exports){\nmodule.exports = RotationalEquation;\n\nvar Vec3 = _dereq_('../math/Vec3');\nvar Mat3 = _dereq_('../math/Mat3');\nvar Equation = _dereq_('./Equation');\n\n/**\n * Rotational constraint. Works to keep the local vectors orthogonal to each other in world space.\n * @class RotationalEquation\n * @constructor\n * @author schteppe\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Vec3} [options.axisA]\n * @param {Vec3} [options.axisB]\n * @param {number} [options.maxForce]\n * @extends Equation\n */\nfunction RotationalEquation(bodyA, bodyB, options){\n    options = options || {};\n    var maxForce = typeof(options.maxForce) !== 'undefined' ? options.maxForce : 1e6;\n\n    Equation.call(this,bodyA,bodyB,-maxForce, maxForce);\n\n    this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1, 0, 0);\n    this.axisB = options.axisB ? options.axisB.clone() : new Vec3(0, 1, 0);\n\n    this.maxAngle = Math.PI / 2;\n}\n\nRotationalEquation.prototype = new Equation();\nRotationalEquation.prototype.constructor = RotationalEquation;\n\nvar tmpVec1 = new Vec3();\nvar tmpVec2 = new Vec3();\n\nRotationalEquation.prototype.computeB = function(h){\n    var a = this.a,\n        b = this.b,\n\n        ni = this.axisA,\n        nj = this.axisB,\n\n        nixnj = tmpVec1,\n        njxni = tmpVec2,\n\n        GA = this.jacobianElementA,\n        GB = this.jacobianElementB;\n\n    // Caluclate cross products\n    ni.cross(nj, nixnj);\n    nj.cross(ni, njxni);\n\n    // g = ni * nj\n    // gdot = (nj x ni) * wi + (ni x nj) * wj\n    // G = [0 njxni 0 nixnj]\n    // W = [vi wi vj wj]\n    GA.rotational.copy(njxni);\n    GB.rotational.copy(nixnj);\n\n    var g = Math.cos(this.maxAngle) - ni.dot(nj),\n        GW = this.computeGW(),\n        GiMf = this.computeGiMf();\n\n    var B = - g * a - GW * b - h * GiMf;\n\n    return B;\n};\n\n\n},{\"../math/Mat3\":27,\"../math/Vec3\":30,\"./Equation\":20}],23:[function(_dereq_,module,exports){\nmodule.exports = RotationalMotorEquation;\n\nvar Vec3 = _dereq_('../math/Vec3');\nvar Mat3 = _dereq_('../math/Mat3');\nvar Equation = _dereq_('./Equation');\n\n/**\n * Rotational motor constraint. Tries to keep the relative angular velocity of the bodies to a given value.\n * @class RotationalMotorEquation\n * @constructor\n * @author schteppe\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Number} maxForce\n * @extends Equation\n */\nfunction RotationalMotorEquation(bodyA, bodyB, maxForce){\n    maxForce = typeof(maxForce)!=='undefined' ? maxForce : 1e6;\n    Equation.call(this,bodyA,bodyB,-maxForce,maxForce);\n\n    /**\n     * World oriented rotational axis\n     * @property {Vec3} axisA\n     */\n    this.axisA = new Vec3();\n\n    /**\n     * World oriented rotational axis\n     * @property {Vec3} axisB\n     */\n    this.axisB = new Vec3(); // World oriented rotational axis\n\n    /**\n     * Motor velocity\n     * @property {Number} targetVelocity\n     */\n    this.targetVelocity = 0;\n}\n\nRotationalMotorEquation.prototype = new Equation();\nRotationalMotorEquation.prototype.constructor = RotationalMotorEquation;\n\nRotationalMotorEquation.prototype.computeB = function(h){\n    var a = this.a,\n        b = this.b,\n        bi = this.bi,\n        bj = this.bj,\n\n        axisA = this.axisA,\n        axisB = this.axisB,\n\n        GA = this.jacobianElementA,\n        GB = this.jacobianElementB;\n\n    // g = 0\n    // gdot = axisA * wi - axisB * wj\n    // gdot = G * W = G * [vi wi vj wj]\n    // =>\n    // G = [0 axisA 0 -axisB]\n\n    GA.rotational.copy(axisA);\n    axisB.negate(GB.rotational);\n\n    var GW = this.computeGW() - this.targetVelocity,\n        GiMf = this.computeGiMf();\n\n    var B = - GW * b - h * GiMf;\n\n    return B;\n};\n\n},{\"../math/Mat3\":27,\"../math/Vec3\":30,\"./Equation\":20}],24:[function(_dereq_,module,exports){\nvar Utils = _dereq_('../utils/Utils');\n\nmodule.exports = ContactMaterial;\n\n/**\n * Defines what happens when two materials meet.\n * @class ContactMaterial\n * @constructor\n * @param {Material} m1\n * @param {Material} m2\n * @param {object} [options]\n * @param {Number} [options.friction=0.3]\n * @param {Number} [options.restitution=0.3]\n * @param {number} [options.contactEquationStiffness=1e7]\n * @param {number} [options.contactEquationRelaxation=3]\n * @param {number} [options.frictionEquationStiffness=1e7]\n * @param {Number} [options.frictionEquationRelaxation=3]\n */\nfunction ContactMaterial(m1, m2, options){\n    options = Utils.defaults(options, {\n        friction: 0.3,\n        restitution: 0.3,\n        contactEquationStiffness: 1e7,\n        contactEquationRelaxation: 3,\n        frictionEquationStiffness: 1e7,\n        frictionEquationRelaxation: 3\n    });\n\n    /**\n     * Identifier of this material\n     * @property {Number} id\n     */\n    this.id = ContactMaterial.idCounter++;\n\n    /**\n     * Participating materials\n     * @property {Array} materials\n     * @todo  Should be .materialA and .materialB instead\n     */\n    this.materials = [m1, m2];\n\n    /**\n     * Friction coefficient\n     * @property {Number} friction\n     */\n    this.friction = options.friction;\n\n    /**\n     * Restitution coefficient\n     * @property {Number} restitution\n     */\n    this.restitution = options.restitution;\n\n    /**\n     * Stiffness of the produced contact equations\n     * @property {Number} contactEquationStiffness\n     */\n    this.contactEquationStiffness = options.contactEquationStiffness;\n\n    /**\n     * Relaxation time of the produced contact equations\n     * @property {Number} contactEquationRelaxation\n     */\n    this.contactEquationRelaxation = options.contactEquationRelaxation;\n\n    /**\n     * Stiffness of the produced friction equations\n     * @property {Number} frictionEquationStiffness\n     */\n    this.frictionEquationStiffness = options.frictionEquationStiffness;\n\n    /**\n     * Relaxation time of the produced friction equations\n     * @property {Number} frictionEquationRelaxation\n     */\n    this.frictionEquationRelaxation = options.frictionEquationRelaxation;\n}\n\nContactMaterial.idCounter = 0;\n\n},{\"../utils/Utils\":53}],25:[function(_dereq_,module,exports){\nmodule.exports = Material;\n\n/**\n * Defines a physics material.\n * @class Material\n * @constructor\n * @param {object} [options]\n * @author schteppe\n */\nfunction Material(options){\n    var name = '';\n    options = options || {};\n\n    // Backwards compatibility fix\n    if(typeof(options) === 'string'){\n        name = options;\n        options = {};\n    } else if(typeof(options) === 'object') {\n        name = '';\n    }\n\n    /**\n     * @property name\n     * @type {String}\n     */\n    this.name = name;\n\n    /**\n     * material id.\n     * @property id\n     * @type {number}\n     */\n    this.id = Material.idCounter++;\n\n    /**\n     * Friction for this material. If non-negative, it will be used instead of the friction given by ContactMaterials. If there's no matching ContactMaterial, the value from .defaultContactMaterial in the World will be used.\n     * @property {number} friction\n     */\n    this.friction = typeof(options.friction) !== 'undefined' ? options.friction : -1;\n\n    /**\n     * Restitution for this material. If non-negative, it will be used instead of the restitution given by ContactMaterials. If there's no matching ContactMaterial, the value from .defaultContactMaterial in the World will be used.\n     * @property {number} restitution\n     */\n    this.restitution = typeof(options.restitution) !== 'undefined' ? options.restitution : -1;\n}\n\nMaterial.idCounter = 0;\n\n},{}],26:[function(_dereq_,module,exports){\nmodule.exports = JacobianElement;\n\nvar Vec3 = _dereq_('./Vec3');\n\n/**\n * An element containing 6 entries, 3 spatial and 3 rotational degrees of freedom.\n * @class JacobianElement\n * @constructor\n */\nfunction JacobianElement(){\n\n    /**\n     * @property {Vec3} spatial\n     */\n    this.spatial = new Vec3();\n\n    /**\n     * @property {Vec3} rotational\n     */\n    this.rotational = new Vec3();\n}\n\n/**\n * Multiply with other JacobianElement\n * @method multiplyElement\n * @param  {JacobianElement} element\n * @return {Number}\n */\nJacobianElement.prototype.multiplyElement = function(element){\n    return element.spatial.dot(this.spatial) + element.rotational.dot(this.rotational);\n};\n\n/**\n * Multiply with two vectors\n * @method multiplyVectors\n * @param  {Vec3} spatial\n * @param  {Vec3} rotational\n * @return {Number}\n */\nJacobianElement.prototype.multiplyVectors = function(spatial,rotational){\n    return spatial.dot(this.spatial) + rotational.dot(this.rotational);\n};\n\n},{\"./Vec3\":30}],27:[function(_dereq_,module,exports){\nmodule.exports = Mat3;\n\nvar Vec3 = _dereq_('./Vec3');\n\n/**\n * A 3x3 matrix.\n * @class Mat3\n * @constructor\n * @param array elements Array of nine elements. Optional.\n * @author schteppe / http://github.com/schteppe\n */\nfunction Mat3(elements){\n    /**\n     * A vector of length 9, containing all matrix elements\n     * @property {Array} elements\n     */\n    if(elements){\n        this.elements = elements;\n    } else {\n        this.elements = [0,0,0,0,0,0,0,0,0];\n    }\n}\n\n/**\n * Sets the matrix to identity\n * @method identity\n * @todo Should perhaps be renamed to setIdentity() to be more clear.\n * @todo Create another function that immediately creates an identity matrix eg. eye()\n */\nMat3.prototype.identity = function(){\n    var e = this.elements;\n    e[0] = 1;\n    e[1] = 0;\n    e[2] = 0;\n\n    e[3] = 0;\n    e[4] = 1;\n    e[5] = 0;\n\n    e[6] = 0;\n    e[7] = 0;\n    e[8] = 1;\n};\n\n/**\n * Set all elements to zero\n * @method setZero\n */\nMat3.prototype.setZero = function(){\n    var e = this.elements;\n    e[0] = 0;\n    e[1] = 0;\n    e[2] = 0;\n    e[3] = 0;\n    e[4] = 0;\n    e[5] = 0;\n    e[6] = 0;\n    e[7] = 0;\n    e[8] = 0;\n};\n\n/**\n * Sets the matrix diagonal elements from a Vec3\n * @method setTrace\n * @param {Vec3} vec3\n */\nMat3.prototype.setTrace = function(vec3){\n    var e = this.elements;\n    e[0] = vec3.x;\n    e[4] = vec3.y;\n    e[8] = vec3.z;\n};\n\n/**\n * Gets the matrix diagonal elements\n * @method getTrace\n * @return {Vec3}\n */\nMat3.prototype.getTrace = function(target){\n    var target = target || new Vec3();\n    var e = this.elements;\n    target.x = e[0];\n    target.y = e[4];\n    target.z = e[8];\n};\n\n/**\n * Matrix-Vector multiplication\n * @method vmult\n * @param {Vec3} v The vector to multiply with\n * @param {Vec3} target Optional, target to save the result in.\n */\nMat3.prototype.vmult = function(v,target){\n    target = target || new Vec3();\n\n    var e = this.elements,\n        x = v.x,\n        y = v.y,\n        z = v.z;\n    target.x = e[0]*x + e[1]*y + e[2]*z;\n    target.y = e[3]*x + e[4]*y + e[5]*z;\n    target.z = e[6]*x + e[7]*y + e[8]*z;\n\n    return target;\n};\n\n/**\n * Matrix-scalar multiplication\n * @method smult\n * @param {Number} s\n */\nMat3.prototype.smult = function(s){\n    for(var i=0; i<this.elements.length; i++){\n        this.elements[i] *= s;\n    }\n};\n\n/**\n * Matrix multiplication\n * @method mmult\n * @param {Mat3} m Matrix to multiply with from left side.\n * @return {Mat3} The result.\n */\nMat3.prototype.mmult = function(m,target){\n    var r = target || new Mat3();\n    for(var i=0; i<3; i++){\n        for(var j=0; j<3; j++){\n            var sum = 0.0;\n            for(var k=0; k<3; k++){\n                sum += m.elements[i+k*3] * this.elements[k+j*3];\n            }\n            r.elements[i+j*3] = sum;\n        }\n    }\n    return r;\n};\n\n/**\n * Scale each column of the matrix\n * @method scale\n * @param {Vec3} v\n * @return {Mat3} The result.\n */\nMat3.prototype.scale = function(v,target){\n    target = target || new Mat3();\n    var e = this.elements,\n        t = target.elements;\n    for(var i=0; i!==3; i++){\n        t[3*i + 0] = v.x * e[3*i + 0];\n        t[3*i + 1] = v.y * e[3*i + 1];\n        t[3*i + 2] = v.z * e[3*i + 2];\n    }\n    return target;\n};\n\n/**\n * Solve Ax=b\n * @method solve\n * @param {Vec3} b The right hand side\n * @param {Vec3} target Optional. Target vector to save in.\n * @return {Vec3} The solution x\n * @todo should reuse arrays\n */\nMat3.prototype.solve = function(b,target){\n    target = target || new Vec3();\n\n    // Construct equations\n    var nr = 3; // num rows\n    var nc = 4; // num cols\n    var eqns = [];\n    for(var i=0; i<nr*nc; i++){\n        eqns.push(0);\n    }\n    var i,j;\n    for(i=0; i<3; i++){\n        for(j=0; j<3; j++){\n            eqns[i+nc*j] = this.elements[i+3*j];\n        }\n    }\n    eqns[3+4*0] = b.x;\n    eqns[3+4*1] = b.y;\n    eqns[3+4*2] = b.z;\n\n    // Compute right upper triangular version of the matrix - Gauss elimination\n    var n = 3, k = n, np;\n    var kp = 4; // num rows\n    var p, els;\n    do {\n        i = k - n;\n        if (eqns[i+nc*i] === 0) {\n            // the pivot is null, swap lines\n            for (j = i + 1; j < k; j++) {\n                if (eqns[i+nc*j] !== 0) {\n                    np = kp;\n                    do {  // do ligne( i ) = ligne( i ) + ligne( k )\n                        p = kp - np;\n                        eqns[p+nc*i] += eqns[p+nc*j];\n                    } while (--np);\n                    break;\n                }\n            }\n        }\n        if (eqns[i+nc*i] !== 0) {\n            for (j = i + 1; j < k; j++) {\n                var multiplier = eqns[i+nc*j] / eqns[i+nc*i];\n                np = kp;\n                do {  // do ligne( k ) = ligne( k ) - multiplier * ligne( i )\n                    p = kp - np;\n                    eqns[p+nc*j] = p <= i ? 0 : eqns[p+nc*j] - eqns[p+nc*i] * multiplier ;\n                } while (--np);\n            }\n        }\n    } while (--n);\n\n    // Get the solution\n    target.z = eqns[2*nc+3] / eqns[2*nc+2];\n    target.y = (eqns[1*nc+3] - eqns[1*nc+2]*target.z) / eqns[1*nc+1];\n    target.x = (eqns[0*nc+3] - eqns[0*nc+2]*target.z - eqns[0*nc+1]*target.y) / eqns[0*nc+0];\n\n    if(isNaN(target.x) || isNaN(target.y) || isNaN(target.z) || target.x===Infinity || target.y===Infinity || target.z===Infinity){\n        throw \"Could not solve equation! Got x=[\"+target.toString()+\"], b=[\"+b.toString()+\"], A=[\"+this.toString()+\"]\";\n    }\n\n    return target;\n};\n\n/**\n * Get an element in the matrix by index. Index starts at 0, not 1!!!\n * @method e\n * @param {Number} row\n * @param {Number} column\n * @param {Number} value Optional. If provided, the matrix element will be set to this value.\n * @return {Number}\n */\nMat3.prototype.e = function( row , column ,value){\n    if(value===undefined){\n        return this.elements[column+3*row];\n    } else {\n        // Set value\n        this.elements[column+3*row] = value;\n    }\n};\n\n/**\n * Copy another matrix into this matrix object.\n * @method copy\n * @param {Mat3} source\n * @return {Mat3} this\n */\nMat3.prototype.copy = function(source){\n    for(var i=0; i < source.elements.length; i++){\n        this.elements[i] = source.elements[i];\n    }\n    return this;\n};\n\n/**\n * Returns a string representation of the matrix.\n * @method toString\n * @return string\n */\nMat3.prototype.toString = function(){\n    var r = \"\";\n    var sep = \",\";\n    for(var i=0; i<9; i++){\n        r += this.elements[i] + sep;\n    }\n    return r;\n};\n\n/**\n * reverse the matrix\n * @method reverse\n * @param {Mat3} target Optional. Target matrix to save in.\n * @return {Mat3} The solution x\n */\nMat3.prototype.reverse = function(target){\n\n    target = target || new Mat3();\n\n    // Construct equations\n    var nr = 3; // num rows\n    var nc = 6; // num cols\n    var eqns = [];\n    for(var i=0; i<nr*nc; i++){\n        eqns.push(0);\n    }\n    var i,j;\n    for(i=0; i<3; i++){\n        for(j=0; j<3; j++){\n            eqns[i+nc*j] = this.elements[i+3*j];\n        }\n    }\n    eqns[3+6*0] = 1;\n    eqns[3+6*1] = 0;\n    eqns[3+6*2] = 0;\n    eqns[4+6*0] = 0;\n    eqns[4+6*1] = 1;\n    eqns[4+6*2] = 0;\n    eqns[5+6*0] = 0;\n    eqns[5+6*1] = 0;\n    eqns[5+6*2] = 1;\n\n    // Compute right upper triangular version of the matrix - Gauss elimination\n    var n = 3, k = n, np;\n    var kp = nc; // num rows\n    var p;\n    do {\n        i = k - n;\n        if (eqns[i+nc*i] === 0) {\n            // the pivot is null, swap lines\n            for (j = i + 1; j < k; j++) {\n                if (eqns[i+nc*j] !== 0) {\n                    np = kp;\n                    do { // do line( i ) = line( i ) + line( k )\n                        p = kp - np;\n                        eqns[p+nc*i] += eqns[p+nc*j];\n                    } while (--np);\n                    break;\n                }\n            }\n        }\n        if (eqns[i+nc*i] !== 0) {\n            for (j = i + 1; j < k; j++) {\n                var multiplier = eqns[i+nc*j] / eqns[i+nc*i];\n                np = kp;\n                do { // do line( k ) = line( k ) - multiplier * line( i )\n                    p = kp - np;\n                    eqns[p+nc*j] = p <= i ? 0 : eqns[p+nc*j] - eqns[p+nc*i] * multiplier ;\n                } while (--np);\n            }\n        }\n    } while (--n);\n\n    // eliminate the upper left triangle of the matrix\n    i = 2;\n    do {\n        j = i-1;\n        do {\n            var multiplier = eqns[i+nc*j] / eqns[i+nc*i];\n            np = nc;\n            do {\n                p = nc - np;\n                eqns[p+nc*j] =  eqns[p+nc*j] - eqns[p+nc*i] * multiplier ;\n            } while (--np);\n        } while (j--);\n    } while (--i);\n\n    // operations on the diagonal\n    i = 2;\n    do {\n        var multiplier = 1 / eqns[i+nc*i];\n        np = nc;\n        do {\n            p = nc - np;\n            eqns[p+nc*i] = eqns[p+nc*i] * multiplier ;\n        } while (--np);\n    } while (i--);\n\n    i = 2;\n    do {\n        j = 2;\n        do {\n            p = eqns[nr+j+nc*i];\n            if( isNaN( p ) || p ===Infinity ){\n                throw \"Could not reverse! A=[\"+this.toString()+\"]\";\n            }\n            target.e( i , j , p );\n        } while (j--);\n    } while (i--);\n\n    return target;\n};\n\n/**\n * Set the matrix from a quaterion\n * @method setRotationFromQuaternion\n * @param {Quaternion} q\n */\nMat3.prototype.setRotationFromQuaternion = function( q ) {\n    var x = q.x, y = q.y, z = q.z, w = q.w,\n        x2 = x + x, y2 = y + y, z2 = z + z,\n        xx = x * x2, xy = x * y2, xz = x * z2,\n        yy = y * y2, yz = y * z2, zz = z * z2,\n        wx = w * x2, wy = w * y2, wz = w * z2,\n        e = this.elements;\n\n    e[3*0 + 0] = 1 - ( yy + zz );\n    e[3*0 + 1] = xy - wz;\n    e[3*0 + 2] = xz + wy;\n\n    e[3*1 + 0] = xy + wz;\n    e[3*1 + 1] = 1 - ( xx + zz );\n    e[3*1 + 2] = yz - wx;\n\n    e[3*2 + 0] = xz - wy;\n    e[3*2 + 1] = yz + wx;\n    e[3*2 + 2] = 1 - ( xx + yy );\n\n    return this;\n};\n\n/**\n * Transpose the matrix\n * @method transpose\n * @param  {Mat3} target Where to store the result.\n * @return {Mat3} The target Mat3, or a new Mat3 if target was omitted.\n */\nMat3.prototype.transpose = function( target ) {\n    target = target || new Mat3();\n\n    var Mt = target.elements,\n        M = this.elements;\n\n    for(var i=0; i!==3; i++){\n        for(var j=0; j!==3; j++){\n            Mt[3*i + j] = M[3*j + i];\n        }\n    }\n\n    return target;\n};\n\n},{\"./Vec3\":30}],28:[function(_dereq_,module,exports){\nmodule.exports = Quaternion;\n\nvar Vec3 = _dereq_('./Vec3');\n\n/**\n * A Quaternion describes a rotation in 3D space. The Quaternion is mathematically defined as Q = x*i + y*j + z*k + w, where (i,j,k) are imaginary basis vectors. (x,y,z) can be seen as a vector related to the axis of rotation, while the real multiplier, w, is related to the amount of rotation.\n * @class Quaternion\n * @constructor\n * @param {Number} x Multiplier of the imaginary basis vector i.\n * @param {Number} y Multiplier of the imaginary basis vector j.\n * @param {Number} z Multiplier of the imaginary basis vector k.\n * @param {Number} w Multiplier of the real part.\n * @see http://en.wikipedia.org/wiki/Quaternion\n */\nfunction Quaternion(x,y,z,w){\n    /**\n     * @property {Number} x\n     */\n    this.x = x!==undefined ? x : 0;\n\n    /**\n     * @property {Number} y\n     */\n    this.y = y!==undefined ? y : 0;\n\n    /**\n     * @property {Number} z\n     */\n    this.z = z!==undefined ? z : 0;\n\n    /**\n     * The multiplier of the real quaternion basis vector.\n     * @property {Number} w\n     */\n    this.w = w!==undefined ? w : 1;\n}\n\n/**\n * Set the value of the quaternion.\n * @method set\n * @param {Number} x\n * @param {Number} y\n * @param {Number} z\n * @param {Number} w\n */\nQuaternion.prototype.set = function(x,y,z,w){\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n};\n\n/**\n * Convert to a readable format\n * @method toString\n * @return string\n */\nQuaternion.prototype.toString = function(){\n    return this.x+\",\"+this.y+\",\"+this.z+\",\"+this.w;\n};\n\n/**\n * Convert to an Array\n * @method toArray\n * @return Array\n */\nQuaternion.prototype.toArray = function(){\n    return [this.x, this.y, this.z, this.w];\n};\n\n/**\n * Set the quaternion components given an axis and an angle.\n * @method setFromAxisAngle\n * @param {Vec3} axis\n * @param {Number} angle in radians\n */\nQuaternion.prototype.setFromAxisAngle = function(axis,angle){\n    var s = Math.sin(angle*0.5);\n    this.x = axis.x * s;\n    this.y = axis.y * s;\n    this.z = axis.z * s;\n    this.w = Math.cos(angle*0.5);\n};\n\n/**\n * Converts the quaternion to axis/angle representation.\n * @method toAxisAngle\n * @param {Vec3} targetAxis Optional. A vector object to reuse for storing the axis.\n * @return Array An array, first elemnt is the axis and the second is the angle in radians.\n */\nQuaternion.prototype.toAxisAngle = function(targetAxis){\n    targetAxis = targetAxis || new Vec3();\n    this.normalize(); // if w>1 acos and sqrt will produce errors, this cant happen if quaternion is normalised\n    var angle = 2 * Math.acos(this.w);\n    var s = Math.sqrt(1-this.w*this.w); // assuming quaternion normalised then w is less than 1, so term always positive.\n    if (s < 0.001) { // test to avoid divide by zero, s is always positive due to sqrt\n        // if s close to zero then direction of axis not important\n        targetAxis.x = this.x; // if it is important that axis is normalised then replace with x=1; y=z=0;\n        targetAxis.y = this.y;\n        targetAxis.z = this.z;\n    } else {\n        targetAxis.x = this.x / s; // normalise axis\n        targetAxis.y = this.y / s;\n        targetAxis.z = this.z / s;\n    }\n    return [targetAxis,angle];\n};\n\nvar sfv_t1 = new Vec3(),\n    sfv_t2 = new Vec3();\n\n/**\n * Set the quaternion value given two vectors. The resulting rotation will be the needed rotation to rotate u to v.\n * @method setFromVectors\n * @param {Vec3} u\n * @param {Vec3} v\n */\nQuaternion.prototype.setFromVectors = function(u,v){\n    if(u.isAntiparallelTo(v)){\n        var t1 = sfv_t1;\n        var t2 = sfv_t2;\n\n        u.tangents(t1,t2);\n        this.setFromAxisAngle(t1,Math.PI);\n    } else {\n        var a = u.cross(v);\n        this.x = a.x;\n        this.y = a.y;\n        this.z = a.z;\n        this.w = Math.sqrt(Math.pow(u.norm(),2) * Math.pow(v.norm(),2)) + u.dot(v);\n        this.normalize();\n    }\n};\n\n/**\n * Quaternion multiplication\n * @method mult\n * @param {Quaternion} q\n * @param {Quaternion} target Optional.\n * @return {Quaternion}\n */\nvar Quaternion_mult_va = new Vec3();\nvar Quaternion_mult_vb = new Vec3();\nvar Quaternion_mult_vaxvb = new Vec3();\nQuaternion.prototype.mult = function(q,target){\n    target = target || new Quaternion();\n    var w = this.w,\n        va = Quaternion_mult_va,\n        vb = Quaternion_mult_vb,\n        vaxvb = Quaternion_mult_vaxvb;\n\n    va.set(this.x,this.y,this.z);\n    vb.set(q.x,q.y,q.z);\n    target.w = w*q.w - va.dot(vb);\n    va.cross(vb,vaxvb);\n\n    target.x = w * vb.x + q.w*va.x + vaxvb.x;\n    target.y = w * vb.y + q.w*va.y + vaxvb.y;\n    target.z = w * vb.z + q.w*va.z + vaxvb.z;\n\n    return target;\n};\n\n/**\n * Get the inverse quaternion rotation.\n * @method inverse\n * @param {Quaternion} target\n * @return {Quaternion}\n */\nQuaternion.prototype.inverse = function(target){\n    var x = this.x, y = this.y, z = this.z, w = this.w;\n    target = target || new Quaternion();\n\n    this.conjugate(target);\n    var inorm2 = 1/(x*x + y*y + z*z + w*w);\n    target.x *= inorm2;\n    target.y *= inorm2;\n    target.z *= inorm2;\n    target.w *= inorm2;\n\n    return target;\n};\n\n/**\n * Get the quaternion conjugate\n * @method conjugate\n * @param {Quaternion} target\n * @return {Quaternion}\n */\nQuaternion.prototype.conjugate = function(target){\n    target = target || new Quaternion();\n\n    target.x = -this.x;\n    target.y = -this.y;\n    target.z = -this.z;\n    target.w = this.w;\n\n    return target;\n};\n\n/**\n * Normalize the quaternion. Note that this changes the values of the quaternion.\n * @method normalize\n */\nQuaternion.prototype.normalize = function(){\n    var l = Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);\n    if ( l === 0 ) {\n        this.x = 0;\n        this.y = 0;\n        this.z = 0;\n        this.w = 0;\n    } else {\n        l = 1 / l;\n        this.x *= l;\n        this.y *= l;\n        this.z *= l;\n        this.w *= l;\n    }\n};\n\n/**\n * Approximation of quaternion normalization. Works best when quat is already almost-normalized.\n * @method normalizeFast\n * @see http://jsperf.com/fast-quaternion-normalization\n * @author unphased, https://github.com/unphased\n */\nQuaternion.prototype.normalizeFast = function () {\n    var f = (3.0-(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w))/2.0;\n    if ( f === 0 ) {\n        this.x = 0;\n        this.y = 0;\n        this.z = 0;\n        this.w = 0;\n    } else {\n        this.x *= f;\n        this.y *= f;\n        this.z *= f;\n        this.w *= f;\n    }\n};\n\n/**\n * Multiply the quaternion by a vector\n * @method vmult\n * @param {Vec3} v\n * @param {Vec3} target Optional\n * @return {Vec3}\n */\nQuaternion.prototype.vmult = function(v,target){\n    target = target || new Vec3();\n\n    var x = v.x,\n        y = v.y,\n        z = v.z;\n\n    var qx = this.x,\n        qy = this.y,\n        qz = this.z,\n        qw = this.w;\n\n    // q*v\n    var ix =  qw * x + qy * z - qz * y,\n    iy =  qw * y + qz * x - qx * z,\n    iz =  qw * z + qx * y - qy * x,\n    iw = -qx * x - qy * y - qz * z;\n\n    target.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n    target.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n    target.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n\n    return target;\n};\n\n/**\n * Copies value of source to this quaternion.\n * @method copy\n * @param {Quaternion} source\n * @return {Quaternion} this\n */\nQuaternion.prototype.copy = function(source){\n    this.x = source.x;\n    this.y = source.y;\n    this.z = source.z;\n    this.w = source.w;\n    return this;\n};\n\n/**\n * Convert the quaternion to euler angle representation. Order: YZX, as this page describes: http://www.euclideanspace.com/maths/standards/index.htm\n * @method toEuler\n * @param {Vec3} target\n * @param string order Three-character string e.g. \"YZX\", which also is default.\n */\nQuaternion.prototype.toEuler = function(target,order){\n    order = order || \"YZX\";\n\n    var heading, attitude, bank;\n    var x = this.x, y = this.y, z = this.z, w = this.w;\n\n    switch(order){\n    case \"YZX\":\n        var test = x*y + z*w;\n        if (test > 0.499) { // singularity at north pole\n            heading = 2 * Math.atan2(x,w);\n            attitude = Math.PI/2;\n            bank = 0;\n        }\n        if (test < -0.499) { // singularity at south pole\n            heading = -2 * Math.atan2(x,w);\n            attitude = - Math.PI/2;\n            bank = 0;\n        }\n        if(isNaN(heading)){\n            var sqx = x*x;\n            var sqy = y*y;\n            var sqz = z*z;\n            heading = Math.atan2(2*y*w - 2*x*z , 1 - 2*sqy - 2*sqz); // Heading\n            attitude = Math.asin(2*test); // attitude\n            bank = Math.atan2(2*x*w - 2*y*z , 1 - 2*sqx - 2*sqz); // bank\n        }\n        break;\n    default:\n        throw new Error(\"Euler order \"+order+\" not supported yet.\");\n    }\n\n    target.y = heading;\n    target.z = attitude;\n    target.x = bank;\n};\n\n/**\n * See http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m\n * @method setFromEuler\n * @param {Number} x\n * @param {Number} y\n * @param {Number} z\n * @param {String} order The order to apply angles: 'XYZ' or 'YXZ' or any other combination\n */\nQuaternion.prototype.setFromEuler = function ( x, y, z, order ) {\n    order = order || \"XYZ\";\n\n    var c1 = Math.cos( x / 2 );\n    var c2 = Math.cos( y / 2 );\n    var c3 = Math.cos( z / 2 );\n    var s1 = Math.sin( x / 2 );\n    var s2 = Math.sin( y / 2 );\n    var s3 = Math.sin( z / 2 );\n\n    if ( order === 'XYZ' ) {\n\n        this.x = s1 * c2 * c3 + c1 * s2 * s3;\n        this.y = c1 * s2 * c3 - s1 * c2 * s3;\n        this.z = c1 * c2 * s3 + s1 * s2 * c3;\n        this.w = c1 * c2 * c3 - s1 * s2 * s3;\n\n    } else if ( order === 'YXZ' ) {\n\n        this.x = s1 * c2 * c3 + c1 * s2 * s3;\n        this.y = c1 * s2 * c3 - s1 * c2 * s3;\n        this.z = c1 * c2 * s3 - s1 * s2 * c3;\n        this.w = c1 * c2 * c3 + s1 * s2 * s3;\n\n    } else if ( order === 'ZXY' ) {\n\n        this.x = s1 * c2 * c3 - c1 * s2 * s3;\n        this.y = c1 * s2 * c3 + s1 * c2 * s3;\n        this.z = c1 * c2 * s3 + s1 * s2 * c3;\n        this.w = c1 * c2 * c3 - s1 * s2 * s3;\n\n    } else if ( order === 'ZYX' ) {\n\n        this.x = s1 * c2 * c3 - c1 * s2 * s3;\n        this.y = c1 * s2 * c3 + s1 * c2 * s3;\n        this.z = c1 * c2 * s3 - s1 * s2 * c3;\n        this.w = c1 * c2 * c3 + s1 * s2 * s3;\n\n    } else if ( order === 'YZX' ) {\n\n        this.x = s1 * c2 * c3 + c1 * s2 * s3;\n        this.y = c1 * s2 * c3 + s1 * c2 * s3;\n        this.z = c1 * c2 * s3 - s1 * s2 * c3;\n        this.w = c1 * c2 * c3 - s1 * s2 * s3;\n\n    } else if ( order === 'XZY' ) {\n\n        this.x = s1 * c2 * c3 - c1 * s2 * s3;\n        this.y = c1 * s2 * c3 - s1 * c2 * s3;\n        this.z = c1 * c2 * s3 + s1 * s2 * c3;\n        this.w = c1 * c2 * c3 + s1 * s2 * s3;\n\n    }\n\n    return this;\n\n};\n\nQuaternion.prototype.clone = function(){\n    return new Quaternion(this.x, this.y, this.z, this.w);\n};\n},{\"./Vec3\":30}],29:[function(_dereq_,module,exports){\nvar Vec3 = _dereq_('./Vec3');\nvar Quaternion = _dereq_('./Quaternion');\n\nmodule.exports = Transform;\n\n/**\n * @class Transform\n * @constructor\n */\nfunction Transform(options) {\n    options = options || {};\n\n\t/**\n\t * @property {Vec3} position\n\t */\n\tthis.position = new Vec3();\n    if(options.position){\n        this.position.copy(options.position);\n    }\n\n\t/**\n\t * @property {Quaternion} quaternion\n\t */\n\tthis.quaternion = new Quaternion();\n    if(options.quaternion){\n        this.quaternion.copy(options.quaternion);\n    }\n}\n\nvar tmpQuat = new Quaternion();\n\n/**\n * @static\n * @method pointToLocaFrame\n * @param {Vec3} position\n * @param {Quaternion} quaternion\n * @param {Vec3} worldPoint\n * @param {Vec3} result\n */\nTransform.pointToLocalFrame = function(position, quaternion, worldPoint, result){\n    var result = result || new Vec3();\n    worldPoint.vsub(position, result);\n    quaternion.conjugate(tmpQuat);\n    tmpQuat.vmult(result, result);\n    return result;\n};\n\n/**\n * Get a global point in local transform coordinates.\n * @method pointToLocal\n * @param  {Vec3} point\n * @param  {Vec3} result\n * @return {Vec3} The \"result\" vector object\n */\nTransform.prototype.pointToLocal = function(worldPoint, result){\n    return Transform.pointToLocalFrame(this.position, this.quaternion, worldPoint, result);\n};\n\n/**\n * @static\n * @method pointToWorldFrame\n * @param {Vec3} position\n * @param {Vec3} quaternion\n * @param {Vec3} localPoint\n * @param {Vec3} result\n */\nTransform.pointToWorldFrame = function(position, quaternion, localPoint, result){\n    var result = result || new Vec3();\n    quaternion.vmult(localPoint, result);\n    result.vadd(position, result);\n    return result;\n};\n\n/**\n * Get a local point in global transform coordinates.\n * @method pointToWorld\n * @param  {Vec3} point\n * @param  {Vec3} result\n * @return {Vec3} The \"result\" vector object\n */\nTransform.prototype.pointToWorld = function(localPoint, result){\n    return Transform.pointToWorldFrame(this.position, this.quaternion, localPoint, result);\n};\n\n\nTransform.prototype.vectorToWorldFrame = function(localVector, result){\n    var result = result || new Vec3();\n    this.quaternion.vmult(localVector, result);\n    return result;\n};\n\nTransform.vectorToWorldFrame = function(quaternion, localVector, result){\n    quaternion.vmult(localVector, result);\n    return result;\n};\n\nTransform.vectorToLocalFrame = function(position, quaternion, worldVector, result){\n    var result = result || new Vec3();\n    quaternion.w *= -1;\n    quaternion.vmult(worldVector, result);\n    quaternion.w *= -1;\n    return result;\n};\n\n},{\"./Quaternion\":28,\"./Vec3\":30}],30:[function(_dereq_,module,exports){\nmodule.exports = Vec3;\n\nvar Mat3 = _dereq_('./Mat3');\n\n/**\n * 3-dimensional vector\n * @class Vec3\n * @constructor\n * @param {Number} x\n * @param {Number} y\n * @param {Number} z\n * @author schteppe\n * @example\n *     var v = new Vec3(1, 2, 3);\n *     console.log('x=' + v.x); // x=1\n */\nfunction Vec3(x,y,z){\n    /**\n     * @property x\n     * @type {Number}\n     */\n    this.x = x||0.0;\n\n    /**\n     * @property y\n     * @type {Number}\n     */\n    this.y = y||0.0;\n\n    /**\n     * @property z\n     * @type {Number}\n     */\n    this.z = z||0.0;\n}\n\n/**\n * @static\n * @property {Vec3} ZERO\n */\nVec3.ZERO = new Vec3(0, 0, 0);\n\n/**\n * @static\n * @property {Vec3} UNIT_X\n */\nVec3.UNIT_X = new Vec3(1, 0, 0);\n\n/**\n * @static\n * @property {Vec3} UNIT_Y\n */\nVec3.UNIT_Y = new Vec3(0, 1, 0);\n\n/**\n * @static\n * @property {Vec3} UNIT_Z\n */\nVec3.UNIT_Z = new Vec3(0, 0, 1);\n\n/**\n * Vector cross product\n * @method cross\n * @param {Vec3} v\n * @param {Vec3} target Optional. Target to save in.\n * @return {Vec3}\n */\nVec3.prototype.cross = function(v,target){\n    var vx=v.x, vy=v.y, vz=v.z, x=this.x, y=this.y, z=this.z;\n    target = target || new Vec3();\n\n    target.x = (y * vz) - (z * vy);\n    target.y = (z * vx) - (x * vz);\n    target.z = (x * vy) - (y * vx);\n\n    return target;\n};\n\n/**\n * Set the vectors' 3 elements\n * @method set\n * @param {Number} x\n * @param {Number} y\n * @param {Number} z\n * @return Vec3\n */\nVec3.prototype.set = function(x,y,z){\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    return this;\n};\n\n/**\n * Set all components of the vector to zero.\n * @method setZero\n */\nVec3.prototype.setZero = function(){\n    this.x = this.y = this.z = 0;\n};\n\n/**\n * Vector addition\n * @method vadd\n * @param {Vec3} v\n * @param {Vec3} target Optional.\n * @return {Vec3}\n */\nVec3.prototype.vadd = function(v,target){\n    if(target){\n        target.x = v.x + this.x;\n        target.y = v.y + this.y;\n        target.z = v.z + this.z;\n    } else {\n        return new Vec3(this.x + v.x,\n                               this.y + v.y,\n                               this.z + v.z);\n    }\n};\n\n/**\n * Vector subtraction\n * @method vsub\n * @param {Vec3} v\n * @param {Vec3} target Optional. Target to save in.\n * @return {Vec3}\n */\nVec3.prototype.vsub = function(v,target){\n    if(target){\n        target.x = this.x - v.x;\n        target.y = this.y - v.y;\n        target.z = this.z - v.z;\n    } else {\n        return new Vec3(this.x-v.x,\n                               this.y-v.y,\n                               this.z-v.z);\n    }\n};\n\n/**\n * Get the cross product matrix a_cross from a vector, such that a x b = a_cross * b = c\n * @method crossmat\n * @see http://www8.cs.umu.se/kurser/TDBD24/VT06/lectures/Lecture6.pdf\n * @return {Mat3}\n */\nVec3.prototype.crossmat = function(){\n    return new Mat3([     0,  -this.z,   this.y,\n                            this.z,        0,  -this.x,\n                           -this.y,   this.x,        0]);\n};\n\n/**\n * Normalize the vector. Note that this changes the values in the vector.\n * @method normalize\n * @return {Number} Returns the norm of the vector\n */\nVec3.prototype.normalize = function(){\n    var x=this.x, y=this.y, z=this.z;\n    var n = Math.sqrt(x*x + y*y + z*z);\n    if(n>0.0){\n        var invN = 1/n;\n        this.x *= invN;\n        this.y *= invN;\n        this.z *= invN;\n    } else {\n        // Make something up\n        this.x = 0;\n        this.y = 0;\n        this.z = 0;\n    }\n    return n;\n};\n\n/**\n * Get the version of this vector that is of length 1.\n * @method unit\n * @param {Vec3} target Optional target to save in\n * @return {Vec3} Returns the unit vector\n */\nVec3.prototype.unit = function(target){\n    target = target || new Vec3();\n    var x=this.x, y=this.y, z=this.z;\n    var ninv = Math.sqrt(x*x + y*y + z*z);\n    if(ninv>0.0){\n        ninv = 1.0/ninv;\n        target.x = x * ninv;\n        target.y = y * ninv;\n        target.z = z * ninv;\n    } else {\n        target.x = 1;\n        target.y = 0;\n        target.z = 0;\n    }\n    return target;\n};\n\n/**\n * Get the length of the vector\n * @method norm\n * @return {Number}\n * @deprecated Use .length() instead\n */\nVec3.prototype.norm = function(){\n    var x=this.x, y=this.y, z=this.z;\n    return Math.sqrt(x*x + y*y + z*z);\n};\n\n/**\n * Get the length of the vector\n * @method length\n * @return {Number}\n */\nVec3.prototype.length = Vec3.prototype.norm;\n\n/**\n * Get the squared length of the vector\n * @method norm2\n * @return {Number}\n * @deprecated Use .lengthSquared() instead.\n */\nVec3.prototype.norm2 = function(){\n    return this.dot(this);\n};\n\n/**\n * Get the squared length of the vector.\n * @method lengthSquared\n * @return {Number}\n */\nVec3.prototype.lengthSquared = Vec3.prototype.norm2;\n\n/**\n * Get distance from this point to another point\n * @method distanceTo\n * @param  {Vec3} p\n * @return {Number}\n */\nVec3.prototype.distanceTo = function(p){\n    var x=this.x, y=this.y, z=this.z;\n    var px=p.x, py=p.y, pz=p.z;\n    return Math.sqrt((px-x)*(px-x)+\n                     (py-y)*(py-y)+\n                     (pz-z)*(pz-z));\n};\n\n/**\n * Get squared distance from this point to another point\n * @method distanceSquared\n * @param  {Vec3} p\n * @return {Number}\n */\nVec3.prototype.distanceSquared = function(p){\n    var x=this.x, y=this.y, z=this.z;\n    var px=p.x, py=p.y, pz=p.z;\n    return (px-x)*(px-x) + (py-y)*(py-y) + (pz-z)*(pz-z);\n};\n\n/**\n * Multiply all the components of the vector with a scalar.\n * @deprecated Use .scale instead\n * @method mult\n * @param {Number} scalar\n * @param {Vec3} target The vector to save the result in.\n * @return {Vec3}\n * @deprecated Use .scale() instead\n */\nVec3.prototype.mult = function(scalar,target){\n    target = target || new Vec3();\n    var x = this.x,\n        y = this.y,\n        z = this.z;\n    target.x = scalar * x;\n    target.y = scalar * y;\n    target.z = scalar * z;\n    return target;\n};\n\n/**\n * Multiply the vector with a scalar.\n * @method scale\n * @param {Number} scalar\n * @param {Vec3} target\n * @return {Vec3}\n */\nVec3.prototype.scale = Vec3.prototype.mult;\n\n/**\n * Calculate dot product\n * @method dot\n * @param {Vec3} v\n * @return {Number}\n */\nVec3.prototype.dot = function(v){\n    return this.x * v.x + this.y * v.y + this.z * v.z;\n};\n\n/**\n * @method isZero\n * @return bool\n */\nVec3.prototype.isZero = function(){\n    return this.x===0 && this.y===0 && this.z===0;\n};\n\n/**\n * Make the vector point in the opposite direction.\n * @method negate\n * @param {Vec3} target Optional target to save in\n * @return {Vec3}\n */\nVec3.prototype.negate = function(target){\n    target = target || new Vec3();\n    target.x = -this.x;\n    target.y = -this.y;\n    target.z = -this.z;\n    return target;\n};\n\n/**\n * Compute two artificial tangents to the vector\n * @method tangents\n * @param {Vec3} t1 Vector object to save the first tangent in\n * @param {Vec3} t2 Vector object to save the second tangent in\n */\nvar Vec3_tangents_n = new Vec3();\nvar Vec3_tangents_randVec = new Vec3();\nVec3.prototype.tangents = function(t1,t2){\n    var norm = this.norm();\n    if(norm>0.0){\n        var n = Vec3_tangents_n;\n        var inorm = 1/norm;\n        n.set(this.x*inorm,this.y*inorm,this.z*inorm);\n        var randVec = Vec3_tangents_randVec;\n        if(Math.abs(n.x) < 0.9){\n            randVec.set(1,0,0);\n            n.cross(randVec,t1);\n        } else {\n            randVec.set(0,1,0);\n            n.cross(randVec,t1);\n        }\n        n.cross(t1,t2);\n    } else {\n        // The normal length is zero, make something up\n        t1.set(1, 0, 0);\n        t2.set(0, 1, 0);\n    }\n};\n\n/**\n * Converts to a more readable format\n * @method toString\n * @return string\n */\nVec3.prototype.toString = function(){\n    return this.x+\",\"+this.y+\",\"+this.z;\n};\n\n/**\n * Converts to an array\n * @method toArray\n * @return Array\n */\nVec3.prototype.toArray = function(){\n    return [this.x, this.y, this.z];\n};\n\n/**\n * Copies value of source to this vector.\n * @method copy\n * @param {Vec3} source\n * @return {Vec3} this\n */\nVec3.prototype.copy = function(source){\n    this.x = source.x;\n    this.y = source.y;\n    this.z = source.z;\n    return this;\n};\n\n\n/**\n * Do a linear interpolation between two vectors\n * @method lerp\n * @param {Vec3} v\n * @param {Number} t A number between 0 and 1. 0 will make this function return u, and 1 will make it return v. Numbers in between will generate a vector in between them.\n * @param {Vec3} target\n */\nVec3.prototype.lerp = function(v,t,target){\n    var x=this.x, y=this.y, z=this.z;\n    target.x = x + (v.x-x)*t;\n    target.y = y + (v.y-y)*t;\n    target.z = z + (v.z-z)*t;\n};\n\n/**\n * Check if a vector equals is almost equal to another one.\n * @method almostEquals\n * @param {Vec3} v\n * @param {Number} precision\n * @return bool\n */\nVec3.prototype.almostEquals = function(v,precision){\n    if(precision===undefined){\n        precision = 1e-6;\n    }\n    if( Math.abs(this.x-v.x)>precision ||\n        Math.abs(this.y-v.y)>precision ||\n        Math.abs(this.z-v.z)>precision){\n        return false;\n    }\n    return true;\n};\n\n/**\n * Check if a vector is almost zero\n * @method almostZero\n * @param {Number} precision\n */\nVec3.prototype.almostZero = function(precision){\n    if(precision===undefined){\n        precision = 1e-6;\n    }\n    if( Math.abs(this.x)>precision ||\n        Math.abs(this.y)>precision ||\n        Math.abs(this.z)>precision){\n        return false;\n    }\n    return true;\n};\n\nvar antip_neg = new Vec3();\n\n/**\n * Check if the vector is anti-parallel to another vector.\n * @method isAntiparallelTo\n * @param  {Vec3}  v\n * @param  {Number}  precision Set to zero for exact comparisons\n * @return {Boolean}\n */\nVec3.prototype.isAntiparallelTo = function(v,precision){\n    this.negate(antip_neg);\n    return antip_neg.almostEquals(v,precision);\n};\n\n/**\n * Clone the vector\n * @method clone\n * @return {Vec3}\n */\nVec3.prototype.clone = function(){\n    return new Vec3(this.x, this.y, this.z);\n};\n},{\"./Mat3\":27}],31:[function(_dereq_,module,exports){\nmodule.exports = Body;\n\nvar EventTarget = _dereq_('../utils/EventTarget');\nvar Shape = _dereq_('../shapes/Shape');\nvar Vec3 = _dereq_('../math/Vec3');\nvar Mat3 = _dereq_('../math/Mat3');\nvar Quaternion = _dereq_('../math/Quaternion');\nvar Material = _dereq_('../material/Material');\nvar AABB = _dereq_('../collision/AABB');\nvar Box = _dereq_('../shapes/Box');\n\n/**\n * Base class for all body types.\n * @class Body\n * @constructor\n * @extends EventTarget\n * @param {object} [options]\n * @param {Vec3} [options.position]\n * @param {Vec3} [options.velocity]\n * @param {Vec3} [options.angularVelocity]\n * @param {Quaternion} [options.quaternion]\n * @param {number} [options.mass]\n * @param {Material} [options.material]\n * @param {number} [options.type]\n * @param {number} [options.linearDamping=0.01]\n * @param {number} [options.angularDamping=0.01]\n * @param {boolean} [options.allowSleep=true]\n * @param {number} [options.sleepSpeedLimit=0.1]\n * @param {number} [options.sleepTimeLimit=1]\n * @param {number} [options.collisionFilterGroup=1]\n * @param {number} [options.collisionFilterMask=1]\n * @param {boolean} [options.fixedRotation=false]\n * @param {Body} [options.shape]\n * @example\n *     var body = new Body({\n *         mass: 1\n *     });\n *     var shape = new Sphere(1);\n *     body.addShape(shape);\n *     world.add(body);\n */\nfunction Body(options){\n    options = options || {};\n\n    EventTarget.apply(this);\n\n    this.id = Body.idCounter++;\n\n    /**\n     * Reference to the world the body is living in\n     * @property world\n     * @type {World}\n     */\n    this.world = null;\n\n    /**\n     * Callback function that is used BEFORE stepping the system. Use it to apply forces, for example. Inside the function, \"this\" will refer to this Body object.\n     * @property preStep\n     * @type {Function}\n     * @deprecated Use World events instead\n     */\n    this.preStep = null;\n\n    /**\n     * Callback function that is used AFTER stepping the system. Inside the function, \"this\" will refer to this Body object.\n     * @property postStep\n     * @type {Function}\n     * @deprecated Use World events instead\n     */\n    this.postStep = null;\n\n    this.vlambda = new Vec3();\n\n    /**\n     * @property {Number} collisionFilterGroup\n     */\n    this.collisionFilterGroup = typeof(options.collisionFilterGroup) === 'number' ? options.collisionFilterGroup : 1;\n\n    /**\n     * @property {Number} collisionFilterMask\n     */\n    this.collisionFilterMask = typeof(options.collisionFilterMask) === 'number' ? options.collisionFilterMask : 1;\n\n    /**\n     * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled.\n     * @property {Number} collisionResponse\n     */\n\tthis.collisionResponse = true;\n\n    /**\n     * @property position\n     * @type {Vec3}\n     */\n    this.position = new Vec3();\n\n    if(options.position){\n        this.position.copy(options.position);\n    }\n\n    /**\n     * @property {Vec3} previousPosition\n     */\n    this.previousPosition = new Vec3();\n\n    /**\n     * Initial position of the body\n     * @property initPosition\n     * @type {Vec3}\n     */\n    this.initPosition = new Vec3();\n\n    /**\n     * @property velocity\n     * @type {Vec3}\n     */\n    this.velocity = new Vec3();\n\n    if(options.velocity){\n        this.velocity.copy(options.velocity);\n    }\n\n    /**\n     * @property initVelocity\n     * @type {Vec3}\n     */\n    this.initVelocity = new Vec3();\n\n    /**\n     * Linear force on the body\n     * @property force\n     * @type {Vec3}\n     */\n    this.force = new Vec3();\n\n    var mass = typeof(options.mass) === 'number' ? options.mass : 0;\n\n    /**\n     * @property mass\n     * @type {Number}\n     * @default 0\n     */\n    this.mass = mass;\n\n    /**\n     * @property invMass\n     * @type {Number}\n     */\n    this.invMass = mass > 0 ? 1.0 / mass : 0;\n\n    /**\n     * @property material\n     * @type {Material}\n     */\n    this.material = options.material || null;\n\n    /**\n     * @property linearDamping\n     * @type {Number}\n     */\n    this.linearDamping = typeof(options.linearDamping) === 'number' ? options.linearDamping : 0.01;\n\n    /**\n     * One of: Body.DYNAMIC, Body.STATIC and Body.KINEMATIC.\n     * @property type\n     * @type {Number}\n     */\n    this.type = (mass <= 0.0 ? Body.STATIC : Body.DYNAMIC);\n    if(typeof(options.type) === typeof(Body.STATIC)){\n        this.type = options.type;\n    }\n\n    /**\n     * If true, the body will automatically fall to sleep.\n     * @property allowSleep\n     * @type {Boolean}\n     * @default true\n     */\n    this.allowSleep = typeof(options.allowSleep) !== 'undefined' ? options.allowSleep : true;\n\n    /**\n     * Current sleep state.\n     * @property sleepState\n     * @type {Number}\n     */\n    this.sleepState = 0;\n\n    /**\n     * If the speed (the norm of the velocity) is smaller than this value, the body is considered sleepy.\n     * @property sleepSpeedLimit\n     * @type {Number}\n     * @default 0.1\n     */\n    this.sleepSpeedLimit = typeof(options.sleepSpeedLimit) !== 'undefined' ? options.sleepSpeedLimit : 0.1;\n\n    /**\n     * If the body has been sleepy for this sleepTimeLimit seconds, it is considered sleeping.\n     * @property sleepTimeLimit\n     * @type {Number}\n     * @default 1\n     */\n    this.sleepTimeLimit = typeof(options.sleepTimeLimit) !== 'undefined' ? options.sleepTimeLimit : 1;\n\n    this.timeLastSleepy = 0;\n\n    this._wakeUpAfterNarrowphase = false;\n\n\n    /**\n     * Rotational force on the body, around center of mass\n     * @property {Vec3} torque\n     */\n    this.torque = new Vec3();\n\n    /**\n     * Orientation of the body\n     * @property quaternion\n     * @type {Quaternion}\n     */\n    this.quaternion = new Quaternion();\n\n    if(options.quaternion){\n        this.quaternion.copy(options.quaternion);\n    }\n\n    /**\n     * @property initQuaternion\n     * @type {Quaternion}\n     */\n    this.initQuaternion = new Quaternion();\n\n    /**\n     * @property angularVelocity\n     * @type {Vec3}\n     */\n    this.angularVelocity = new Vec3();\n\n    if(options.angularVelocity){\n        this.angularVelocity.copy(options.angularVelocity);\n    }\n\n    /**\n     * @property initAngularVelocity\n     * @type {Vec3}\n     */\n    this.initAngularVelocity = new Vec3();\n\n    this.interpolatedPosition = new Vec3();\n    this.interpolatedQuaternion = new Quaternion();\n\n    /**\n     * @property shapes\n     * @type {array}\n     */\n    this.shapes = [];\n\n    /**\n     * @property shapeOffsets\n     * @type {array}\n     */\n    this.shapeOffsets = [];\n\n    /**\n     * @property shapeOrientations\n     * @type {array}\n     */\n    this.shapeOrientations = [];\n\n    /**\n     * @property inertia\n     * @type {Vec3}\n     */\n    this.inertia = new Vec3();\n\n    /**\n     * @property {Vec3} invInertia\n     */\n    this.invInertia = new Vec3();\n\n    /**\n     * @property {Mat3} invInertiaWorld\n     */\n    this.invInertiaWorld = new Mat3();\n\n    this.invMassSolve = 0;\n\n    /**\n     * @property {Vec3} invInertiaSolve\n     */\n    this.invInertiaSolve = new Vec3();\n\n    /**\n     * @property {Mat3} invInertiaWorldSolve\n     */\n    this.invInertiaWorldSolve = new Mat3();\n\n    /**\n     * Set to true if you don't want the body to rotate. Make sure to run .updateMassProperties() after changing this.\n     * @property {Boolean} fixedRotation\n     * @default false\n     */\n    this.fixedRotation = typeof(options.fixedRotation) !== \"undefined\" ? options.fixedRotation : false;\n\n    /**\n     * @property {Number} angularDamping\n     */\n    this.angularDamping = typeof(options.angularDamping) !== 'undefined' ? options.angularDamping : 0.01;\n\n    /**\n     * @property aabb\n     * @type {AABB}\n     */\n    this.aabb = new AABB();\n\n    /**\n     * Indicates if the AABB needs to be updated before use.\n     * @property aabbNeedsUpdate\n     * @type {Boolean}\n     */\n    this.aabbNeedsUpdate = true;\n\n    this.wlambda = new Vec3();\n\n    if(options.shape){\n        this.addShape(options.shape);\n    }\n\n    this.updateMassProperties();\n}\nBody.prototype = new EventTarget();\nBody.prototype.constructor = Body;\n\n/**\n * A dynamic body is fully simulated. Can be moved manually by the user, but normally they move according to forces. A dynamic body can collide with all body types. A dynamic body always has finite, non-zero mass.\n * @static\n * @property DYNAMIC\n * @type {Number}\n */\nBody.DYNAMIC = 1;\n\n/**\n * A static body does not move during simulation and behaves as if it has infinite mass. Static bodies can be moved manually by setting the position of the body. The velocity of a static body is always zero. Static bodies do not collide with other static or kinematic bodies.\n * @static\n * @property STATIC\n * @type {Number}\n */\nBody.STATIC = 2;\n\n/**\n * A kinematic body moves under simulation according to its velocity. They do not respond to forces. They can be moved manually, but normally a kinematic body is moved by setting its velocity. A kinematic body behaves as if it has infinite mass. Kinematic bodies do not collide with other static or kinematic bodies.\n * @static\n * @property KINEMATIC\n * @type {Number}\n */\nBody.KINEMATIC = 4;\n\n\n\n/**\n * @static\n * @property AWAKE\n * @type {number}\n */\nBody.AWAKE = 0;\n\n/**\n * @static\n * @property SLEEPY\n * @type {number}\n */\nBody.SLEEPY = 1;\n\n/**\n * @static\n * @property SLEEPING\n * @type {number}\n */\nBody.SLEEPING = 2;\n\nBody.idCounter = 0;\n\n/**\n * Wake the body up.\n * @method wakeUp\n */\nBody.prototype.wakeUp = function(){\n    var s = this.sleepState;\n    this.sleepState = 0;\n    if(s === Body.SLEEPING){\n        this.dispatchEvent({type:\"wakeup\"});\n    }\n};\n\n/**\n * Force body sleep\n * @method sleep\n */\nBody.prototype.sleep = function(){\n    this.sleepState = Body.SLEEPING;\n    this.velocity.set(0,0,0);\n    this.angularVelocity.set(0,0,0);\n};\n\nBody.sleepyEvent = {\n    type: \"sleepy\"\n};\n\nBody.sleepEvent = {\n    type: \"sleep\"\n};\n\n/**\n * Called every timestep to update internal sleep timer and change sleep state if needed.\n * @method sleepTick\n * @param {Number} time The world time in seconds\n */\nBody.prototype.sleepTick = function(time){\n    if(this.allowSleep){\n        var sleepState = this.sleepState;\n        var speedSquared = this.velocity.norm2() + this.angularVelocity.norm2();\n        var speedLimitSquared = Math.pow(this.sleepSpeedLimit,2);\n        if(sleepState===Body.AWAKE && speedSquared < speedLimitSquared){\n            this.sleepState = Body.SLEEPY; // Sleepy\n            this.timeLastSleepy = time;\n            this.dispatchEvent(Body.sleepyEvent);\n        } else if(sleepState===Body.SLEEPY && speedSquared > speedLimitSquared){\n            this.wakeUp(); // Wake up\n        } else if(sleepState===Body.SLEEPY && (time - this.timeLastSleepy ) > this.sleepTimeLimit){\n            this.sleep(); // Sleeping\n            this.dispatchEvent(Body.sleepEvent);\n        }\n    }\n};\n\n/**\n * If the body is sleeping, it should be immovable / have infinite mass during solve. We solve it by having a separate \"solve mass\".\n * @method updateSolveMassProperties\n */\nBody.prototype.updateSolveMassProperties = function(){\n    if(this.sleepState === Body.SLEEPING || this.type === Body.KINEMATIC){\n        this.invMassSolve = 0;\n        this.invInertiaSolve.setZero();\n        this.invInertiaWorldSolve.setZero();\n    } else {\n        this.invMassSolve = this.invMass;\n        this.invInertiaSolve.copy(this.invInertia);\n        this.invInertiaWorldSolve.copy(this.invInertiaWorld);\n    }\n};\n\n/**\n * Convert a world point to local body frame.\n * @method pointToLocalFrame\n * @param  {Vec3} worldPoint\n * @param  {Vec3} result\n * @return {Vec3}\n */\nBody.prototype.pointToLocalFrame = function(worldPoint,result){\n    var result = result || new Vec3();\n    worldPoint.vsub(this.position,result);\n    this.quaternion.conjugate().vmult(result,result);\n    return result;\n};\n\n/**\n * Convert a world vector to local body frame.\n * @method vectorToLocalFrame\n * @param  {Vec3} worldPoint\n * @param  {Vec3} result\n * @return {Vec3}\n */\nBody.prototype.vectorToLocalFrame = function(worldVector, result){\n    var result = result || new Vec3();\n    this.quaternion.conjugate().vmult(worldVector,result);\n    return result;\n};\n\n/**\n * Convert a local body point to world frame.\n * @method pointToWorldFrame\n * @param  {Vec3} localPoint\n * @param  {Vec3} result\n * @return {Vec3}\n */\nBody.prototype.pointToWorldFrame = function(localPoint,result){\n    var result = result || new Vec3();\n    this.quaternion.vmult(localPoint,result);\n    result.vadd(this.position,result);\n    return result;\n};\n\n/**\n * Convert a local body point to world frame.\n * @method vectorToWorldFrame\n * @param  {Vec3} localVector\n * @param  {Vec3} result\n * @return {Vec3}\n */\nBody.prototype.vectorToWorldFrame = function(localVector, result){\n    var result = result || new Vec3();\n    this.quaternion.vmult(localVector, result);\n    return result;\n};\n\nvar tmpVec = new Vec3();\nvar tmpQuat = new Quaternion();\n\n/**\n * Add a shape to the body with a local offset and orientation.\n * @method addShape\n * @param {Shape} shape\n * @param {Vec3} offset\n * @param {Quaternion} quaternion\n * @return {Body} The body object, for chainability.\n */\nBody.prototype.addShape = function(shape, _offset, _orientation){\n    var offset = new Vec3();\n    var orientation = new Quaternion();\n\n    if(_offset){\n        offset.copy(_offset);\n    }\n    if(_orientation){\n        orientation.copy(_orientation);\n    }\n\n    this.shapes.push(shape);\n    this.shapeOffsets.push(offset);\n    this.shapeOrientations.push(orientation);\n    this.updateMassProperties();\n    this.updateBoundingRadius();\n\n    this.aabbNeedsUpdate = true;\n\n    return this;\n};\n\n/**\n * Update the bounding radius of the body. Should be done if any of the shapes are changed.\n * @method updateBoundingRadius\n */\nBody.prototype.updateBoundingRadius = function(){\n    var shapes = this.shapes,\n        shapeOffsets = this.shapeOffsets,\n        N = shapes.length,\n        radius = 0;\n\n    for(var i=0; i!==N; i++){\n        var shape = shapes[i];\n        shape.updateBoundingSphereRadius();\n        var offset = shapeOffsets[i].norm(),\n            r = shape.boundingSphereRadius;\n        if(offset + r > radius){\n            radius = offset + r;\n        }\n    }\n\n    this.boundingRadius = radius;\n};\n\nvar computeAABB_shapeAABB = new AABB();\n\n/**\n * Updates the .aabb\n * @method computeAABB\n * @todo rename to updateAABB()\n */\nBody.prototype.computeAABB = function(){\n    var shapes = this.shapes,\n        shapeOffsets = this.shapeOffsets,\n        shapeOrientations = this.shapeOrientations,\n        N = shapes.length,\n        offset = tmpVec,\n        orientation = tmpQuat,\n        bodyQuat = this.quaternion,\n        aabb = this.aabb,\n        shapeAABB = computeAABB_shapeAABB;\n\n    for(var i=0; i!==N; i++){\n        var shape = shapes[i];\n\n        // Get shape world quaternion\n        shapeOrientations[i].mult(bodyQuat, orientation);\n\n        // Get shape world position\n        orientation.vmult(shapeOffsets[i], offset);\n        offset.vadd(this.position, offset);\n\n        // vec2.rotate(offset, shapeOffsets[i], bodyAngle);\n        // vec2.add(offset, offset, this.position);\n\n        // Get shape AABB\n        shape.calculateWorldAABB(offset, orientation, shapeAABB.lowerBound, shapeAABB.upperBound);\n\n        if(i === 0){\n            aabb.copy(shapeAABB);\n        } else {\n            aabb.extend(shapeAABB);\n        }\n    }\n\n    this.aabbNeedsUpdate = false;\n};\n\nvar uiw_m1 = new Mat3(),\n    uiw_m2 = new Mat3(),\n    uiw_m3 = new Mat3();\n\n/**\n * Update .inertiaWorld and .invInertiaWorld\n * @method updateInertiaWorld\n */\nBody.prototype.updateInertiaWorld = function(force){\n    var I = this.invInertia;\n    if (I.x === I.y && I.y === I.z && !force) {\n        // If inertia M = s*I, where I is identity and s a scalar, then\n        //    R*M*R' = R*(s*I)*R' = s*R*I*R' = s*R*R' = s*I = M\n        // where R is the rotation matrix.\n        // In other words, we don't have to transform the inertia if all\n        // inertia diagonal entries are equal.\n    } else {\n        var m1 = uiw_m1,\n            m2 = uiw_m2,\n            m3 = uiw_m3;\n        m1.setRotationFromQuaternion(this.quaternion);\n        m1.transpose(m2);\n        m1.scale(I,m1);\n        m1.mmult(m2,this.invInertiaWorld);\n        //m3.getTrace(this.invInertiaWorld);\n    }\n\n    /*\n    this.quaternion.vmult(this.inertia,this.inertiaWorld);\n    this.quaternion.vmult(this.invInertia,this.invInertiaWorld);\n    */\n};\n\n/**\n * Apply force to a world point. This could for example be a point on the Body surface. Applying force this way will add to Body.force and Body.torque.\n * @method applyForce\n * @param  {Vec3} force The amount of force to add.\n * @param  {Vec3} worldPoint A world point to apply the force on.\n */\nvar Body_applyForce_r = new Vec3();\nvar Body_applyForce_rotForce = new Vec3();\nBody.prototype.applyForce = function(force,worldPoint){\n    if(this.type !== Body.DYNAMIC){\n        return;\n    }\n\n    // Compute point position relative to the body center\n    var r = Body_applyForce_r;\n    worldPoint.vsub(this.position,r);\n\n    // Compute produced rotational force\n    var rotForce = Body_applyForce_rotForce;\n    r.cross(force,rotForce);\n\n    // Add linear force\n    this.force.vadd(force,this.force);\n\n    // Add rotational force\n    this.torque.vadd(rotForce,this.torque);\n};\n\n/**\n * Apply force to a local point in the body.\n * @method applyLocalForce\n * @param  {Vec3} force The force vector to apply, defined locally in the body frame.\n * @param  {Vec3} localPoint A local point in the body to apply the force on.\n */\nvar Body_applyLocalForce_worldForce = new Vec3();\nvar Body_applyLocalForce_worldPoint = new Vec3();\nBody.prototype.applyLocalForce = function(localForce, localPoint){\n    if(this.type !== Body.DYNAMIC){\n        return;\n    }\n\n    var worldForce = Body_applyLocalForce_worldForce;\n    var worldPoint = Body_applyLocalForce_worldPoint;\n\n    // Transform the force vector to world space\n    this.vectorToWorldFrame(localForce, worldForce);\n    this.pointToWorldFrame(localPoint, worldPoint);\n\n    this.applyForce(worldForce, worldPoint);\n};\n\n/**\n * Apply impulse to a world point. This could for example be a point on the Body surface. An impulse is a force added to a body during a short period of time (impulse = force * time). Impulses will be added to Body.velocity and Body.angularVelocity.\n * @method applyImpulse\n * @param  {Vec3} impulse The amount of impulse to add.\n * @param  {Vec3} worldPoint A world point to apply the force on.\n */\nvar Body_applyImpulse_r = new Vec3();\nvar Body_applyImpulse_velo = new Vec3();\nvar Body_applyImpulse_rotVelo = new Vec3();\nBody.prototype.applyImpulse = function(impulse, worldPoint){\n    if(this.type !== Body.DYNAMIC){\n        return;\n    }\n\n    // Compute point position relative to the body center\n    var r = Body_applyImpulse_r;\n    worldPoint.vsub(this.position,r);\n\n    // Compute produced central impulse velocity\n    var velo = Body_applyImpulse_velo;\n    velo.copy(impulse);\n    velo.mult(this.invMass,velo);\n\n    // Add linear impulse\n    this.velocity.vadd(velo, this.velocity);\n\n    // Compute produced rotational impulse velocity\n    var rotVelo = Body_applyImpulse_rotVelo;\n    r.cross(impulse,rotVelo);\n\n    /*\n    rotVelo.x *= this.invInertia.x;\n    rotVelo.y *= this.invInertia.y;\n    rotVelo.z *= this.invInertia.z;\n    */\n    this.invInertiaWorld.vmult(rotVelo,rotVelo);\n\n    // Add rotational Impulse\n    this.angularVelocity.vadd(rotVelo, this.angularVelocity);\n};\n\n/**\n * Apply locally-defined impulse to a local point in the body.\n * @method applyLocalImpulse\n * @param  {Vec3} force The force vector to apply, defined locally in the body frame.\n * @param  {Vec3} localPoint A local point in the body to apply the force on.\n */\nvar Body_applyLocalImpulse_worldImpulse = new Vec3();\nvar Body_applyLocalImpulse_worldPoint = new Vec3();\nBody.prototype.applyLocalImpulse = function(localImpulse, localPoint){\n    if(this.type !== Body.DYNAMIC){\n        return;\n    }\n\n    var worldImpulse = Body_applyLocalImpulse_worldImpulse;\n    var worldPoint = Body_applyLocalImpulse_worldPoint;\n\n    // Transform the force vector to world space\n    this.vectorToWorldFrame(localImpulse, worldImpulse);\n    this.pointToWorldFrame(localPoint, worldPoint);\n\n    this.applyImpulse(worldImpulse, worldPoint);\n};\n\nvar Body_updateMassProperties_halfExtents = new Vec3();\n\n/**\n * Should be called whenever you change the body shape or mass.\n * @method updateMassProperties\n */\nBody.prototype.updateMassProperties = function(){\n    var halfExtents = Body_updateMassProperties_halfExtents;\n\n    this.invMass = this.mass > 0 ? 1.0 / this.mass : 0;\n    var I = this.inertia;\n    var fixed = this.fixedRotation;\n\n    // Approximate with AABB box\n    this.computeAABB();\n    halfExtents.set(\n        (this.aabb.upperBound.x-this.aabb.lowerBound.x) / 2,\n        (this.aabb.upperBound.y-this.aabb.lowerBound.y) / 2,\n        (this.aabb.upperBound.z-this.aabb.lowerBound.z) / 2\n    );\n    Box.calculateInertia(halfExtents, this.mass, I);\n\n    this.invInertia.set(\n        I.x > 0 && !fixed ? 1.0 / I.x : 0,\n        I.y > 0 && !fixed ? 1.0 / I.y : 0,\n        I.z > 0 && !fixed ? 1.0 / I.z : 0\n    );\n    this.updateInertiaWorld(true);\n};\n\n/**\n * Get world velocity of a point in the body.\n * @method getVelocityAtWorldPoint\n * @param  {Vec3} worldPoint\n * @param  {Vec3} result\n * @return {Vec3} The result vector.\n */\nBody.prototype.getVelocityAtWorldPoint = function(worldPoint, result){\n    var r = new Vec3();\n    worldPoint.vsub(this.position, r);\n    this.angularVelocity.cross(r, result);\n    this.velocity.vadd(result, result);\n    return result;\n};\n\n},{\"../collision/AABB\":3,\"../material/Material\":25,\"../math/Mat3\":27,\"../math/Quaternion\":28,\"../math/Vec3\":30,\"../shapes/Box\":37,\"../shapes/Shape\":43,\"../utils/EventTarget\":49}],32:[function(_dereq_,module,exports){\nvar Body = _dereq_('./Body');\nvar Vec3 = _dereq_('../math/Vec3');\nvar Quaternion = _dereq_('../math/Quaternion');\nvar RaycastResult = _dereq_('../collision/RaycastResult');\nvar Ray = _dereq_('../collision/Ray');\nvar WheelInfo = _dereq_('../objects/WheelInfo');\n\nmodule.exports = RaycastVehicle;\n\n/**\n * Vehicle helper class that casts rays from the wheel positions towards the ground and applies forces.\n * @class RaycastVehicle\n * @constructor\n * @param {object} [options]\n * @param {Body} [options.chassisBody] The car chassis body.\n * @param {integer} [options.indexRightAxis] Axis to use for right. x=0, y=1, z=2\n * @param {integer} [options.indexLeftAxis]\n * @param {integer} [options.indexUpAxis]\n */\nfunction RaycastVehicle(options){\n\n    /**\n     * @property {Body} chassisBody\n     */\n    this.chassisBody = options.chassisBody;\n\n    /**\n     * An array of WheelInfo objects.\n     * @property {array} wheelInfos\n     */\n    this.wheelInfos = [];\n\n    /**\n     * Will be set to true if the car is sliding.\n     * @property {boolean} sliding\n     */\n    this.sliding = false;\n\n    /**\n     * @property {World} world\n     */\n    this.world = null;\n\n    /**\n     * Index of the right axis, 0=x, 1=y, 2=z\n     * @property {integer} indexRightAxis\n     * @default 1\n     */\n    this.indexRightAxis = typeof(options.indexRightAxis) !== 'undefined' ? options.indexRightAxis : 1;\n\n    /**\n     * Index of the forward axis, 0=x, 1=y, 2=z\n     * @property {integer} indexForwardAxis\n     * @default 0\n     */\n    this.indexForwardAxis = typeof(options.indexForwardAxis) !== 'undefined' ? options.indexForwardAxis : 0;\n\n    /**\n     * Index of the up axis, 0=x, 1=y, 2=z\n     * @property {integer} indexUpAxis\n     * @default 2\n     */\n    this.indexUpAxis = typeof(options.indexUpAxis) !== 'undefined' ? options.indexUpAxis : 2;\n}\n\nvar tmpVec1 = new Vec3();\nvar tmpVec2 = new Vec3();\nvar tmpVec3 = new Vec3();\nvar tmpVec4 = new Vec3();\nvar tmpVec5 = new Vec3();\nvar tmpVec6 = new Vec3();\nvar tmpRay = new Ray();\n\n/**\n * Add a wheel. For information about the options, see WheelInfo.\n * @method addWheel\n * @param {object} [options]\n */\nRaycastVehicle.prototype.addWheel = function(options){\n    options = options || {};\n\n    var info = new WheelInfo(options);\n    var index = this.wheelInfos.length;\n    this.wheelInfos.push(info);\n\n    return index;\n};\n\n/**\n * Set the steering value of a wheel.\n * @method setSteeringValue\n * @param {number} value\n * @param {integer} wheelIndex\n */\nRaycastVehicle.prototype.setSteeringValue = function(value, wheelIndex){\n    var wheel = this.wheelInfos[wheelIndex];\n    wheel.steering = value;\n};\n\nvar torque = new Vec3();\n\n/**\n * Set the wheel force to apply on one of the wheels each time step\n * @method applyEngineForce\n * @param  {number} value\n * @param  {integer} wheelIndex\n */\nRaycastVehicle.prototype.applyEngineForce = function(value, wheelIndex){\n    this.wheelInfos[wheelIndex].engineForce = value;\n};\n\n/**\n * Set the braking force of a wheel\n * @method setBrake\n * @param {number} brake\n * @param {integer} wheelIndex\n */\nRaycastVehicle.prototype.setBrake = function(brake, wheelIndex){\n    this.wheelInfos[wheelIndex].brake = brake;\n};\n\n/**\n * Add the vehicle including its constraints to the world.\n * @method addToWorld\n * @param {World} world\n */\nRaycastVehicle.prototype.addToWorld = function(world){\n    var constraints = this.constraints;\n    world.add(this.chassisBody);\n    var that = this;\n    this.preStepCallback = function(){\n        that.updateVehicle(world.dt);\n    };\n    world.addEventListener('preStep', this.preStepCallback);\n    this.world = world;\n};\n\n/**\n * Get one of the wheel axles, world-oriented.\n * @private\n * @method getVehicleAxisWorld\n * @param  {integer} axisIndex\n * @param  {Vec3} result\n */\nRaycastVehicle.prototype.getVehicleAxisWorld = function(axisIndex, result){\n    result.set(\n        axisIndex === 0 ? 1 : 0,\n        axisIndex === 1 ? 1 : 0,\n        axisIndex === 2 ? 1 : 0\n    );\n    this.chassisBody.vectorToWorldFrame(result, result);\n};\n\nRaycastVehicle.prototype.updateVehicle = function(timeStep){\n    var wheelInfos = this.wheelInfos;\n    var numWheels = wheelInfos.length;\n    var chassisBody = this.chassisBody;\n\n    for (var i = 0; i < numWheels; i++) {\n        this.updateWheelTransform(i);\n    }\n\n    this.currentVehicleSpeedKmHour = 3.6 * chassisBody.velocity.norm();\n\n    var forwardWorld = new Vec3();\n    this.getVehicleAxisWorld(this.indexForwardAxis, forwardWorld);\n\n    if (forwardWorld.dot(chassisBody.velocity) < 0){\n        this.currentVehicleSpeedKmHour *= -1;\n    }\n\n    // simulate suspension\n    for (var i = 0; i < numWheels; i++) {\n        this.castRay(wheelInfos[i]);\n    }\n\n    this.updateSuspension(timeStep);\n\n    var impulse = new Vec3();\n    var relpos = new Vec3();\n    for (var i = 0; i < numWheels; i++) {\n        //apply suspension force\n        var wheel = wheelInfos[i];\n        var suspensionForce = wheel.suspensionForce;\n        if (suspensionForce > wheel.maxSuspensionForce) {\n            suspensionForce = wheel.maxSuspensionForce;\n        }\n        wheel.raycastResult.hitNormalWorld.scale(suspensionForce * timeStep, impulse);\n\n        wheel.raycastResult.hitPointWorld.vsub(chassisBody.position, relpos);\n        chassisBody.applyImpulse(impulse, wheel.raycastResult.hitPointWorld/*relpos*/);\n    }\n\n    this.updateFriction(timeStep);\n\n    var hitNormalWorldScaledWithProj = new Vec3();\n    var fwd  = new Vec3();\n    var vel = new Vec3();\n    for (i = 0; i < numWheels; i++) {\n        var wheel = wheelInfos[i];\n        //var relpos = new Vec3();\n        //wheel.chassisConnectionPointWorld.vsub(chassisBody.position, relpos);\n        chassisBody.getVelocityAtWorldPoint(wheel.chassisConnectionPointWorld, vel);\n\n        // Hack to get the rotation in the correct direction\n        var m = 1;\n        switch(this.indexUpAxis){\n        case 1:\n            m = -1;\n            break;\n        }\n\n        if (wheel.isInContact) {\n\n            this.getVehicleAxisWorld(this.indexForwardAxis, fwd);\n            var proj = fwd.dot(wheel.raycastResult.hitNormalWorld);\n            wheel.raycastResult.hitNormalWorld.scale(proj, hitNormalWorldScaledWithProj);\n\n            fwd.vsub(hitNormalWorldScaledWithProj, fwd);\n\n            var proj2 = fwd.dot(vel);\n            wheel.deltaRotation = m * proj2 * timeStep / wheel.radius;\n        }\n\n        if((wheel.sliding || !wheel.isInContact) && wheel.engineForce !== 0 && wheel.useCustomSlidingRotationalSpeed){\n            // Apply custom rotation when accelerating and sliding\n            wheel.deltaRotation = (wheel.engineForce > 0 ? 1 : -1) * wheel.customSlidingRotationalSpeed * timeStep;\n        }\n\n        // Lock wheels\n        if(Math.abs(wheel.brake) > Math.abs(wheel.engineForce)){\n            wheel.deltaRotation = 0;\n        }\n\n        wheel.rotation += wheel.deltaRotation; // Use the old value\n        wheel.deltaRotation *= 0.99; // damping of rotation when not in contact\n    }\n};\n\nRaycastVehicle.prototype.updateSuspension = function(deltaTime) {\n    var chassisBody = this.chassisBody;\n    var chassisMass = chassisBody.mass;\n    var wheelInfos = this.wheelInfos;\n    var numWheels = wheelInfos.length;\n\n    for (var w_it = 0; w_it < numWheels; w_it++){\n        var wheel = wheelInfos[w_it];\n\n        if (wheel.isInContact){\n            var force;\n\n            // Spring\n            var susp_length = wheel.suspensionRestLength;\n            var current_length = wheel.suspensionLength;\n            var length_diff = (susp_length - current_length);\n\n            force = wheel.suspensionStiffness * length_diff * wheel.clippedInvContactDotSuspension;\n\n            // Damper\n            var projected_rel_vel = wheel.suspensionRelativeVelocity;\n            var susp_damping;\n            if (projected_rel_vel < 0) {\n                susp_damping = wheel.dampingCompression;\n            } else {\n                susp_damping = wheel.dampingRelaxation;\n            }\n            force -= susp_damping * projected_rel_vel;\n\n            wheel.suspensionForce = force * chassisMass;\n            if (wheel.suspensionForce < 0) {\n                wheel.suspensionForce = 0;\n            }\n        } else {\n            wheel.suspensionForce = 0;\n        }\n    }\n};\n\n/**\n * Remove the vehicle including its constraints from the world.\n * @method removeFromWorld\n * @param {World} world\n */\nRaycastVehicle.prototype.removeFromWorld = function(world){\n    var constraints = this.constraints;\n    world.remove(this.chassisBody);\n    world.removeEventListener('preStep', this.preStepCallback);\n    this.world = null;\n};\n\nvar castRay_rayvector = new Vec3();\nvar castRay_target = new Vec3();\nRaycastVehicle.prototype.castRay = function(wheel) {\n    var rayvector = castRay_rayvector;\n    var target = castRay_target;\n\n    this.updateWheelTransformWorld(wheel);\n    var chassisBody = this.chassisBody;\n\n    var depth = -1;\n\n    var raylen = wheel.suspensionRestLength + wheel.radius;\n\n    wheel.directionWorld.scale(raylen, rayvector);\n    var source = wheel.chassisConnectionPointWorld;\n    source.vadd(rayvector, target);\n    var raycastResult = wheel.raycastResult;\n\n    var param = 0;\n\n    raycastResult.reset();\n    // Turn off ray collision with the chassis temporarily\n    var oldState = chassisBody.collisionResponse;\n    chassisBody.collisionResponse = false;\n\n    // Cast ray against world\n    this.world.rayTest(source, target, raycastResult);\n    chassisBody.collisionResponse = oldState;\n\n    var object = raycastResult.body;\n\n    wheel.raycastResult.groundObject = 0;\n\n    if (object) {\n        depth = raycastResult.distance;\n        wheel.raycastResult.hitNormalWorld  = raycastResult.hitNormalWorld;\n        wheel.isInContact = true;\n\n        var hitDistance = raycastResult.distance;\n        wheel.suspensionLength = hitDistance - wheel.radius;\n\n        // clamp on max suspension travel\n        var minSuspensionLength = wheel.suspensionRestLength - wheel.maxSuspensionTravel;\n        var maxSuspensionLength = wheel.suspensionRestLength + wheel.maxSuspensionTravel;\n        if (wheel.suspensionLength < minSuspensionLength) {\n            wheel.suspensionLength = minSuspensionLength;\n        }\n        if (wheel.suspensionLength > maxSuspensionLength) {\n            wheel.suspensionLength = maxSuspensionLength;\n            wheel.raycastResult.reset();\n        }\n\n        var denominator = wheel.raycastResult.hitNormalWorld.dot(wheel.directionWorld);\n\n        var chassis_velocity_at_contactPoint = new Vec3();\n        chassisBody.getVelocityAtWorldPoint(wheel.raycastResult.hitPointWorld, chassis_velocity_at_contactPoint);\n\n        var projVel = wheel.raycastResult.hitNormalWorld.dot( chassis_velocity_at_contactPoint );\n\n        if (denominator >= -0.1) {\n            wheel.suspensionRelativeVelocity = 0;\n            wheel.clippedInvContactDotSuspension = 1 / 0.1;\n        } else {\n            var inv = -1 / denominator;\n            wheel.suspensionRelativeVelocity = projVel * inv;\n            wheel.clippedInvContactDotSuspension = inv;\n        }\n\n    } else {\n\n        //put wheel info as in rest position\n        wheel.suspensionLength = wheel.suspensionRestLength + 0 * wheel.maxSuspensionTravel;\n        wheel.suspensionRelativeVelocity = 0.0;\n        wheel.directionWorld.scale(-1, wheel.raycastResult.hitNormalWorld);\n        wheel.clippedInvContactDotSuspension = 1.0;\n    }\n\n    return depth;\n};\n\nRaycastVehicle.prototype.updateWheelTransformWorld = function(wheel){\n    wheel.isInContact = false;\n    var chassisBody = this.chassisBody;\n    chassisBody.pointToWorldFrame(wheel.chassisConnectionPointLocal, wheel.chassisConnectionPointWorld);\n    chassisBody.vectorToWorldFrame(wheel.directionLocal, wheel.directionWorld);\n    chassisBody.vectorToWorldFrame(wheel.axleLocal, wheel.axleWorld);\n};\n\n\n/**\n * Update one of the wheel transform.\n * Note when rendering wheels: during each step, wheel transforms are updated BEFORE the chassis; ie. their position becomes invalid after the step. Thus when you render wheels, you must update wheel transforms before rendering them. See raycastVehicle demo for an example.\n * @method updateWheelTransform\n * @param {integer} wheelIndex The wheel index to update.\n */\nRaycastVehicle.prototype.updateWheelTransform = function(wheelIndex){\n    var up = tmpVec4;\n    var right = tmpVec5;\n    var fwd = tmpVec6;\n\n    var wheel = this.wheelInfos[wheelIndex];\n    this.updateWheelTransformWorld(wheel);\n\n    wheel.directionLocal.scale(-1, up);\n    right.copy(wheel.axleLocal);\n    up.cross(right, fwd);\n    fwd.normalize();\n    right.normalize();\n\n    // Rotate around steering over the wheelAxle\n    var steering = wheel.steering;\n    var steeringOrn = new Quaternion();\n    steeringOrn.setFromAxisAngle(up, steering);\n\n    var rotatingOrn = new Quaternion();\n    rotatingOrn.setFromAxisAngle(right, wheel.rotation);\n\n    // World rotation of the wheel\n    var q = wheel.worldTransform.quaternion;\n    this.chassisBody.quaternion.mult(steeringOrn, q);\n    q.mult(rotatingOrn, q);\n\n    q.normalize();\n\n    // world position of the wheel\n    var p = wheel.worldTransform.position;\n    p.copy(wheel.directionWorld);\n    p.scale(wheel.suspensionLength, p);\n    p.vadd(wheel.chassisConnectionPointWorld, p);\n};\n\nvar directions = [\n    new Vec3(1, 0, 0),\n    new Vec3(0, 1, 0),\n    new Vec3(0, 0, 1)\n];\n\n/**\n * Get the world transform of one of the wheels\n * @method getWheelTransformWorld\n * @param  {integer} wheelIndex\n * @return {Transform}\n */\nRaycastVehicle.prototype.getWheelTransformWorld = function(wheelIndex) {\n    return this.wheelInfos[wheelIndex].worldTransform;\n};\n\n\nvar updateFriction_surfNormalWS_scaled_proj = new Vec3();\nvar updateFriction_axle = [];\nvar updateFriction_forwardWS = [];\nvar sideFrictionStiffness2 = 1;\nRaycastVehicle.prototype.updateFriction = function(timeStep) {\n    var surfNormalWS_scaled_proj = updateFriction_surfNormalWS_scaled_proj;\n\n    //calculate the impulse, so that the wheels don't move sidewards\n    var wheelInfos = this.wheelInfos;\n    var numWheels = wheelInfos.length;\n    var chassisBody = this.chassisBody;\n    var forwardWS = updateFriction_forwardWS;\n    var axle = updateFriction_axle;\n\n    var numWheelsOnGround = 0;\n\n    for (var i = 0; i < numWheels; i++) {\n        var wheel = wheelInfos[i];\n\n        var groundObject = wheel.raycastResult.body;\n        if (groundObject){\n            numWheelsOnGround++;\n        }\n\n        wheel.sideImpulse = 0;\n        wheel.forwardImpulse = 0;\n        if(!forwardWS[i]){\n            forwardWS[i] = new Vec3();\n        }\n        if(!axle[i]){\n            axle[i] = new Vec3();\n        }\n    }\n\n    for (var i = 0; i < numWheels; i++){\n        var wheel = wheelInfos[i];\n\n        var groundObject = wheel.raycastResult.body;\n\n        if (groundObject) {\n            var axlei = axle[i];\n            var wheelTrans = this.getWheelTransformWorld(i);\n\n            // Get world axle\n            wheelTrans.vectorToWorldFrame(directions[this.indexRightAxis], axlei);\n\n            var surfNormalWS = wheel.raycastResult.hitNormalWorld;\n            var proj = axlei.dot(surfNormalWS);\n            surfNormalWS.scale(proj, surfNormalWS_scaled_proj);\n            axlei.vsub(surfNormalWS_scaled_proj, axlei);\n            axlei.normalize();\n\n            surfNormalWS.cross(axlei, forwardWS[i]);\n            forwardWS[i].normalize();\n\n            wheel.sideImpulse = resolveSingleBilateral(\n                chassisBody,\n                wheel.raycastResult.hitPointWorld,\n                groundObject,\n                wheel.raycastResult.hitPointWorld,\n                axlei\n            );\n\n            wheel.sideImpulse *= sideFrictionStiffness2;\n        }\n    }\n\n    var sideFactor = 1;\n    var fwdFactor = 0.5;\n\n    this.sliding = false;\n    for (var i = 0; i < numWheels; i++) {\n        var wheel = wheelInfos[i];\n        var groundObject = wheel.raycastResult.body;\n\n        var rollingFriction = 0;\n\n        wheel.slipInfo = 1;\n        if (groundObject) {\n            var defaultRollingFrictionImpulse = 0;\n            var maxImpulse = wheel.brake ? wheel.brake : defaultRollingFrictionImpulse;\n\n            // btWheelContactPoint contactPt(chassisBody,groundObject,wheelInfraycastInfo.hitPointWorld,forwardWS[wheel],maxImpulse);\n            // rollingFriction = calcRollingFriction(contactPt);\n            rollingFriction = calcRollingFriction(chassisBody, groundObject, wheel.raycastResult.hitPointWorld, forwardWS[i], maxImpulse);\n\n            rollingFriction += wheel.engineForce * timeStep;\n\n            // rollingFriction = 0;\n            var factor = maxImpulse / rollingFriction;\n            wheel.slipInfo *= factor;\n        }\n\n        //switch between active rolling (throttle), braking and non-active rolling friction (nthrottle/break)\n\n        wheel.forwardImpulse = 0;\n        wheel.skidInfo = 1;\n\n        if (groundObject) {\n            wheel.skidInfo = 1;\n\n            var maximp = wheel.suspensionForce * timeStep * wheel.frictionSlip;\n            var maximpSide = maximp;\n\n            var maximpSquared = maximp * maximpSide;\n\n            wheel.forwardImpulse = rollingFriction;//wheelInfo.engineForce* timeStep;\n\n            var x = wheel.forwardImpulse * fwdFactor;\n            var y = wheel.sideImpulse * sideFactor;\n\n            var impulseSquared = x * x + y * y;\n\n            wheel.sliding = false;\n            if (impulseSquared > maximpSquared) {\n                this.sliding = true;\n                wheel.sliding = true;\n\n                var factor = maximp / Math.sqrt(impulseSquared);\n\n                wheel.skidInfo *= factor;\n            }\n        }\n    }\n\n    if (this.sliding) {\n        for (var i = 0; i < numWheels; i++) {\n            var wheel = wheelInfos[i];\n            if (wheel.sideImpulse !== 0) {\n                if (wheel.skidInfo < 1){\n                    wheel.forwardImpulse *= wheel.skidInfo;\n                    wheel.sideImpulse *= wheel.skidInfo;\n                }\n            }\n        }\n    }\n\n    // apply the impulses\n    for (var i = 0; i < numWheels; i++) {\n        var wheel = wheelInfos[i];\n\n        var rel_pos = new Vec3();\n        //wheel.raycastResult.hitPointWorld.vsub(chassisBody.position, rel_pos);\n        // cannons applyimpulse is using world coord for the position\n        rel_pos.copy(wheel.raycastResult.hitPointWorld);\n\n        if (wheel.forwardImpulse !== 0) {\n            var impulse = new Vec3();\n            forwardWS[i].scale(wheel.forwardImpulse, impulse);\n            chassisBody.applyImpulse(impulse, rel_pos);\n        }\n\n        if (wheel.sideImpulse !== 0){\n            var groundObject = wheel.raycastResult.body;\n\n            var rel_pos2 = new Vec3();\n            //wheel.raycastResult.hitPointWorld.vsub(groundObject.position, rel_pos2);\n            rel_pos2.copy(wheel.raycastResult.hitPointWorld);\n            var sideImp = new Vec3();\n            axle[i].scale(wheel.sideImpulse, sideImp);\n\n            // Scale the relative position in the up direction with rollInfluence.\n            // If rollInfluence is 1, the impulse will be applied on the hitPoint (easy to roll over), if it is zero it will be applied in the same plane as the center of mass (not easy to roll over).\n            chassisBody.pointToLocalFrame(rel_pos, rel_pos);\n            rel_pos['xyz'[this.indexUpAxis]] *= wheel.rollInfluence;\n            chassisBody.pointToWorldFrame(rel_pos, rel_pos);\n            chassisBody.applyImpulse(sideImp, rel_pos);\n\n            //apply friction impulse on the ground\n            sideImp.scale(-1, sideImp);\n            groundObject.applyImpulse(sideImp, rel_pos2);\n        }\n    }\n};\n\nvar calcRollingFriction_vel1 = new Vec3();\nvar calcRollingFriction_vel2 = new Vec3();\nvar calcRollingFriction_vel = new Vec3();\n\nfunction calcRollingFriction(body0, body1, frictionPosWorld, frictionDirectionWorld, maxImpulse) {\n    var j1 = 0;\n    var contactPosWorld = frictionPosWorld;\n\n    // var rel_pos1 = new Vec3();\n    // var rel_pos2 = new Vec3();\n    var vel1 = calcRollingFriction_vel1;\n    var vel2 = calcRollingFriction_vel2;\n    var vel = calcRollingFriction_vel;\n    // contactPosWorld.vsub(body0.position, rel_pos1);\n    // contactPosWorld.vsub(body1.position, rel_pos2);\n\n    body0.getVelocityAtWorldPoint(contactPosWorld, vel1);\n    body1.getVelocityAtWorldPoint(contactPosWorld, vel2);\n    vel1.vsub(vel2, vel);\n\n    var vrel = frictionDirectionWorld.dot(vel);\n\n    var denom0 = computeImpulseDenominator(body0, frictionPosWorld, frictionDirectionWorld);\n    var denom1 = computeImpulseDenominator(body1, frictionPosWorld, frictionDirectionWorld);\n    var relaxation = 1;\n    var jacDiagABInv = relaxation / (denom0 + denom1);\n\n    // calculate j that moves us to zero relative velocity\n    j1 = -vrel * jacDiagABInv;\n\n    if (maxImpulse < j1) {\n        j1 = maxImpulse;\n    }\n    if (j1 < -maxImpulse) {\n        j1 = -maxImpulse;\n    }\n\n    return j1;\n}\n\nvar computeImpulseDenominator_r0 = new Vec3();\nvar computeImpulseDenominator_c0 = new Vec3();\nvar computeImpulseDenominator_vec = new Vec3();\nvar computeImpulseDenominator_m = new Vec3();\nfunction computeImpulseDenominator(body, pos, normal) {\n    var r0 = computeImpulseDenominator_r0;\n    var c0 = computeImpulseDenominator_c0;\n    var vec = computeImpulseDenominator_vec;\n    var m = computeImpulseDenominator_m;\n\n    pos.vsub(body.position, r0);\n    r0.cross(normal, c0);\n    body.invInertiaWorld.vmult(c0, m);\n    m.cross(r0, vec);\n\n    return body.invMass + normal.dot(vec);\n}\n\n\nvar resolveSingleBilateral_vel1 = new Vec3();\nvar resolveSingleBilateral_vel2 = new Vec3();\nvar resolveSingleBilateral_vel = new Vec3();\n\n//bilateral constraint between two dynamic objects\nfunction resolveSingleBilateral(body1, pos1, body2, pos2, normal, impulse){\n    var normalLenSqr = normal.norm2();\n    if (normalLenSqr > 1.1){\n        return 0; // no impulse\n    }\n    // var rel_pos1 = new Vec3();\n    // var rel_pos2 = new Vec3();\n    // pos1.vsub(body1.position, rel_pos1);\n    // pos2.vsub(body2.position, rel_pos2);\n\n    var vel1 = resolveSingleBilateral_vel1;\n    var vel2 = resolveSingleBilateral_vel2;\n    var vel = resolveSingleBilateral_vel;\n    body1.getVelocityAtWorldPoint(pos1, vel1);\n    body2.getVelocityAtWorldPoint(pos2, vel2);\n\n    vel1.vsub(vel2, vel);\n\n    var rel_vel = normal.dot(vel);\n\n    var contactDamping = 0.2;\n    var massTerm = 1 / (body1.invMass + body2.invMass);\n    var impulse = - contactDamping * rel_vel * massTerm;\n\n    return impulse;\n}\n},{\"../collision/Ray\":9,\"../collision/RaycastResult\":10,\"../math/Quaternion\":28,\"../math/Vec3\":30,\"../objects/WheelInfo\":36,\"./Body\":31}],33:[function(_dereq_,module,exports){\nvar Body = _dereq_('./Body');\nvar Sphere = _dereq_('../shapes/Sphere');\nvar Box = _dereq_('../shapes/Box');\nvar Vec3 = _dereq_('../math/Vec3');\nvar HingeConstraint = _dereq_('../constraints/HingeConstraint');\n\nmodule.exports = RigidVehicle;\n\n/**\n * Simple vehicle helper class with spherical rigid body wheels.\n * @class RigidVehicle\n * @constructor\n * @param {Body} [options.chassisBody]\n */\nfunction RigidVehicle(options){\n    this.wheelBodies = [];\n\n    /**\n     * @property coordinateSystem\n     * @type {Vec3}\n     */\n    this.coordinateSystem = typeof(options.coordinateSystem)==='undefined' ? new Vec3(1, 2, 3) : options.coordinateSystem.clone();\n\n    /**\n     * @property {Body} chassisBody\n     */\n    this.chassisBody = options.chassisBody;\n\n    if(!this.chassisBody){\n        // No chassis body given. Create it!\n        var chassisShape = new Box(new Vec3(5, 2, 0.5));\n        this.chassisBody = new Body(1, chassisShape);\n    }\n\n    /**\n     * @property constraints\n     * @type {Array}\n     */\n    this.constraints = [];\n\n    this.wheelAxes = [];\n    this.wheelForces = [];\n}\n\n/**\n * Add a wheel\n * @method addWheel\n * @param {object} options\n * @param {boolean} [options.isFrontWheel]\n * @param {Vec3} [options.position] Position of the wheel, locally in the chassis body.\n * @param {Vec3} [options.direction] Slide direction of the wheel along the suspension.\n * @param {Vec3} [options.axis] Axis of rotation of the wheel, locally defined in the chassis.\n * @param {Body} [options.body] The wheel body.\n */\nRigidVehicle.prototype.addWheel = function(options){\n    options = options || {};\n    var wheelBody = options.body;\n    if(!wheelBody){\n        wheelBody =  new Body(1, new Sphere(1.2));\n    }\n    this.wheelBodies.push(wheelBody);\n    this.wheelForces.push(0);\n\n    // Position constrain wheels\n    var zero = new Vec3();\n    var position = typeof(options.position) !== 'undefined' ? options.position.clone() : new Vec3();\n\n    // Set position locally to the chassis\n    var worldPosition = new Vec3();\n    this.chassisBody.pointToWorldFrame(position, worldPosition);\n    wheelBody.position.set(worldPosition.x, worldPosition.y, worldPosition.z);\n\n    // Constrain wheel\n    var axis = typeof(options.axis) !== 'undefined' ? options.axis.clone() : new Vec3(0, 1, 0);\n    this.wheelAxes.push(axis);\n\n    var hingeConstraint = new HingeConstraint(this.chassisBody, wheelBody, {\n        pivotA: position,\n        axisA: axis,\n        pivotB: Vec3.ZERO,\n        axisB: axis,\n        collideConnected: false\n    });\n    this.constraints.push(hingeConstraint);\n\n    return this.wheelBodies.length - 1;\n};\n\n/**\n * Set the steering value of a wheel.\n * @method setSteeringValue\n * @param {number} value\n * @param {integer} wheelIndex\n * @todo check coordinateSystem\n */\nRigidVehicle.prototype.setSteeringValue = function(value, wheelIndex){\n    // Set angle of the hinge axis\n    var axis = this.wheelAxes[wheelIndex];\n\n    var c = Math.cos(value),\n        s = Math.sin(value),\n        x = axis.x,\n        y = axis.y;\n    this.constraints[wheelIndex].axisA.set(\n        c*x -s*y,\n        s*x +c*y,\n        0\n    );\n};\n\n/**\n * Set the target rotational speed of the hinge constraint.\n * @method setMotorSpeed\n * @param {number} value\n * @param {integer} wheelIndex\n */\nRigidVehicle.prototype.setMotorSpeed = function(value, wheelIndex){\n    var hingeConstraint = this.constraints[wheelIndex];\n    hingeConstraint.enableMotor();\n    hingeConstraint.motorTargetVelocity = value;\n};\n\n/**\n * Set the target rotational speed of the hinge constraint.\n * @method disableMotor\n * @param {number} value\n * @param {integer} wheelIndex\n */\nRigidVehicle.prototype.disableMotor = function(wheelIndex){\n    var hingeConstraint = this.constraints[wheelIndex];\n    hingeConstraint.disableMotor();\n};\n\nvar torque = new Vec3();\n\n/**\n * Set the wheel force to apply on one of the wheels each time step\n * @method setWheelForce\n * @param  {number} value\n * @param  {integer} wheelIndex\n */\nRigidVehicle.prototype.setWheelForce = function(value, wheelIndex){\n    this.wheelForces[wheelIndex] = value;\n};\n\n/**\n * Apply a torque on one of the wheels.\n * @method applyWheelForce\n * @param  {number} value\n * @param  {integer} wheelIndex\n */\nRigidVehicle.prototype.applyWheelForce = function(value, wheelIndex){\n    var axis = this.wheelAxes[wheelIndex];\n    var wheelBody = this.wheelBodies[wheelIndex];\n    var bodyTorque = wheelBody.torque;\n\n    axis.scale(value, torque);\n    wheelBody.vectorToWorldFrame(torque, torque);\n    bodyTorque.vadd(torque, bodyTorque);\n};\n\n/**\n * Add the vehicle including its constraints to the world.\n * @method addToWorld\n * @param {World} world\n */\nRigidVehicle.prototype.addToWorld = function(world){\n    var constraints = this.constraints;\n    var bodies = this.wheelBodies.concat([this.chassisBody]);\n\n    for (var i = 0; i < bodies.length; i++) {\n        world.add(bodies[i]);\n    }\n\n    for (var i = 0; i < constraints.length; i++) {\n        world.addConstraint(constraints[i]);\n    }\n\n    world.addEventListener('preStep', this._update.bind(this));\n};\n\nRigidVehicle.prototype._update = function(){\n    var wheelForces = this.wheelForces;\n    for (var i = 0; i < wheelForces.length; i++) {\n        this.applyWheelForce(wheelForces[i], i);\n    }\n};\n\n/**\n * Remove the vehicle including its constraints from the world.\n * @method removeFromWorld\n * @param {World} world\n */\nRigidVehicle.prototype.removeFromWorld = function(world){\n    var constraints = this.constraints;\n    var bodies = this.wheelBodies.concat([this.chassisBody]);\n\n    for (var i = 0; i < bodies.length; i++) {\n        world.remove(bodies[i]);\n    }\n\n    for (var i = 0; i < constraints.length; i++) {\n        world.removeConstraint(constraints[i]);\n    }\n};\n\nvar worldAxis = new Vec3();\n\n/**\n * Get current rotational velocity of a wheel\n * @method getWheelSpeed\n * @param {integer} wheelIndex\n */\nRigidVehicle.prototype.getWheelSpeed = function(wheelIndex){\n    var axis = this.wheelAxes[wheelIndex];\n    var wheelBody = this.wheelBodies[wheelIndex];\n    var w = wheelBody.angularVelocity;\n    this.chassisBody.vectorToWorldFrame(axis, worldAxis);\n    return w.dot(worldAxis);\n};\n\n},{\"../constraints/HingeConstraint\":15,\"../math/Vec3\":30,\"../shapes/Box\":37,\"../shapes/Sphere\":44,\"./Body\":31}],34:[function(_dereq_,module,exports){\nmodule.exports = SPHSystem;\n\nvar Shape = _dereq_('../shapes/Shape');\nvar Vec3 = _dereq_('../math/Vec3');\nvar Quaternion = _dereq_('../math/Quaternion');\nvar Particle = _dereq_('../shapes/Particle');\nvar Body = _dereq_('../objects/Body');\nvar Material = _dereq_('../material/Material');\n\n/**\n * Smoothed-particle hydrodynamics system\n * @class SPHSystem\n * @constructor\n */\nfunction SPHSystem(){\n    this.particles = [];\n\t\n    /**\n     * Density of the system (kg/m3).\n     * @property {number} density\n     */\n    this.density = 1;\n\t\n    /**\n     * Distance below which two particles are considered to be neighbors.\n     * It should be adjusted so there are about 15-20 neighbor particles within this radius.\n     * @property {number} smoothingRadius\n     */\n    this.smoothingRadius = 1;\n    this.speedOfSound = 1;\n\t\n    /**\n     * Viscosity of the system.\n     * @property {number} viscosity\n     */\n    this.viscosity = 0.01;\n    this.eps = 0.000001;\n\n    // Stuff Computed per particle\n    this.pressures = [];\n    this.densities = [];\n    this.neighbors = [];\n}\n\n/**\n * Add a particle to the system.\n * @method add\n * @param {Body} particle\n */\nSPHSystem.prototype.add = function(particle){\n    this.particles.push(particle);\n    if(this.neighbors.length < this.particles.length){\n        this.neighbors.push([]);\n    }\n};\n\n/**\n * Remove a particle from the system.\n * @method remove\n * @param {Body} particle\n */\nSPHSystem.prototype.remove = function(particle){\n    var idx = this.particles.indexOf(particle);\n    if(idx !== -1){\n        this.particles.splice(idx,1);\n        if(this.neighbors.length > this.particles.length){\n            this.neighbors.pop();\n        }\n    }\n};\n\n/**\n * Get neighbors within smoothing volume, save in the array neighbors\n * @method getNeighbors\n * @param {Body} particle\n * @param {Array} neighbors\n */\nvar SPHSystem_getNeighbors_dist = new Vec3();\nSPHSystem.prototype.getNeighbors = function(particle,neighbors){\n    var N = this.particles.length,\n        id = particle.id,\n        R2 = this.smoothingRadius * this.smoothingRadius,\n        dist = SPHSystem_getNeighbors_dist;\n    for(var i=0; i!==N; i++){\n        var p = this.particles[i];\n        p.position.vsub(particle.position,dist);\n        if(id!==p.id && dist.norm2() < R2){\n            neighbors.push(p);\n        }\n    }\n};\n\n// Temp vectors for calculation\nvar SPHSystem_update_dist = new Vec3(),\n    SPHSystem_update_a_pressure = new Vec3(),\n    SPHSystem_update_a_visc = new Vec3(),\n    SPHSystem_update_gradW = new Vec3(),\n    SPHSystem_update_r_vec = new Vec3(),\n    SPHSystem_update_u = new Vec3(); // Relative velocity\nSPHSystem.prototype.update = function(){\n    var N = this.particles.length,\n        dist = SPHSystem_update_dist,\n        cs = this.speedOfSound,\n        eps = this.eps;\n\n    for(var i=0; i!==N; i++){\n        var p = this.particles[i]; // Current particle\n        var neighbors = this.neighbors[i];\n\n        // Get neighbors\n        neighbors.length = 0;\n        this.getNeighbors(p,neighbors);\n        neighbors.push(this.particles[i]); // Add current too\n        var numNeighbors = neighbors.length;\n\n        // Accumulate density for the particle\n        var sum = 0.0;\n        for(var j=0; j!==numNeighbors; j++){\n\n            //printf(\"Current particle has position %f %f %f\\n\",objects[id].pos.x(),objects[id].pos.y(),objects[id].pos.z());\n            p.position.vsub(neighbors[j].position, dist);\n            var len = dist.norm();\n\n            var weight = this.w(len);\n            sum += neighbors[j].mass * weight;\n        }\n\n        // Save\n        this.densities[i] = sum;\n        this.pressures[i] = cs * cs * (this.densities[i] - this.density);\n    }\n\n    // Add forces\n\n    // Sum to these accelerations\n    var a_pressure= SPHSystem_update_a_pressure;\n    var a_visc =    SPHSystem_update_a_visc;\n    var gradW =     SPHSystem_update_gradW;\n    var r_vec =     SPHSystem_update_r_vec;\n    var u =         SPHSystem_update_u;\n\n    for(var i=0; i!==N; i++){\n\n        var particle = this.particles[i];\n\n        a_pressure.set(0,0,0);\n        a_visc.set(0,0,0);\n\n        // Init vars\n        var Pij;\n        var nabla;\n        var Vij;\n\n        // Sum up for all other neighbors\n        var neighbors = this.neighbors[i];\n        var numNeighbors = neighbors.length;\n\n        //printf(\"Neighbors: \");\n        for(var j=0; j!==numNeighbors; j++){\n\n            var neighbor = neighbors[j];\n            //printf(\"%d \",nj);\n\n            // Get r once for all..\n            particle.position.vsub(neighbor.position,r_vec);\n            var r = r_vec.norm();\n\n            // Pressure contribution\n            Pij = -neighbor.mass * (this.pressures[i] / (this.densities[i]*this.densities[i] + eps) + this.pressures[j] / (this.densities[j]*this.densities[j] + eps));\n            this.gradw(r_vec, gradW);\n            // Add to pressure acceleration\n            gradW.mult(Pij , gradW);\n            a_pressure.vadd(gradW, a_pressure);\n\n            // Viscosity contribution\n            neighbor.velocity.vsub(particle.velocity, u);\n            u.mult( 1.0 / (0.0001+this.densities[i] * this.densities[j]) * this.viscosity * neighbor.mass , u );\n            nabla = this.nablaw(r);\n            u.mult(nabla,u);\n            // Add to viscosity acceleration\n            a_visc.vadd( u, a_visc );\n        }\n\n        // Calculate force\n        a_visc.mult(particle.mass, a_visc);\n        a_pressure.mult(particle.mass, a_pressure);\n\n        // Add force to particles\n        particle.force.vadd(a_visc, particle.force);\n        particle.force.vadd(a_pressure, particle.force);\n    }\n};\n\n// Calculate the weight using the W(r) weightfunction\nSPHSystem.prototype.w = function(r){\n    // 315\n    var h = this.smoothingRadius;\n    return 315.0/(64.0*Math.PI*Math.pow(h,9)) * Math.pow(h*h-r*r,3);\n};\n\n// calculate gradient of the weight function\nSPHSystem.prototype.gradw = function(rVec,resultVec){\n    var r = rVec.norm(),\n        h = this.smoothingRadius;\n    rVec.mult(945.0/(32.0*Math.PI*Math.pow(h,9)) * Math.pow((h*h-r*r),2) , resultVec);\n};\n\n// Calculate nabla(W)\nSPHSystem.prototype.nablaw = function(r){\n    var h = this.smoothingRadius;\n    var nabla = 945.0/(32.0*Math.PI*Math.pow(h,9)) * (h*h-r*r)*(7*r*r - 3*h*h);\n    return nabla;\n};\n\n},{\"../material/Material\":25,\"../math/Quaternion\":28,\"../math/Vec3\":30,\"../objects/Body\":31,\"../shapes/Particle\":41,\"../shapes/Shape\":43}],35:[function(_dereq_,module,exports){\nvar Vec3 = _dereq_('../math/Vec3');\n\nmodule.exports = Spring;\n\n/**\n * A spring, connecting two bodies.\n *\n * @class Spring\n * @constructor\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Object} [options]\n * @param {number} [options.restLength]   A number > 0. Default: 1\n * @param {number} [options.stiffness]    A number >= 0. Default: 100\n * @param {number} [options.damping]      A number >= 0. Default: 1\n * @param {Vec3}  [options.worldAnchorA] Where to hook the spring to body A, in world coordinates.\n * @param {Vec3}  [options.worldAnchorB]\n * @param {Vec3}  [options.localAnchorA] Where to hook the spring to body A, in local body coordinates.\n * @param {Vec3}  [options.localAnchorB]\n */\nfunction Spring(bodyA,bodyB,options){\n    options = options || {};\n\n    /**\n     * Rest length of the spring.\n     * @property restLength\n     * @type {number}\n     */\n    this.restLength = typeof(options.restLength) === \"number\" ? options.restLength : 1;\n\n    /**\n     * Stiffness of the spring.\n     * @property stiffness\n     * @type {number}\n     */\n    this.stiffness = options.stiffness || 100;\n\n    /**\n     * Damping of the spring.\n     * @property damping\n     * @type {number}\n     */\n    this.damping = options.damping || 1;\n\n    /**\n     * First connected body.\n     * @property bodyA\n     * @type {Body}\n     */\n    this.bodyA = bodyA;\n\n    /**\n     * Second connected body.\n     * @property bodyB\n     * @type {Body}\n     */\n    this.bodyB = bodyB;\n\n    /**\n     * Anchor for bodyA in local bodyA coordinates.\n     * @property localAnchorA\n     * @type {Vec3}\n     */\n    this.localAnchorA = new Vec3();\n\n    /**\n     * Anchor for bodyB in local bodyB coordinates.\n     * @property localAnchorB\n     * @type {Vec3}\n     */\n    this.localAnchorB = new Vec3();\n\n    if(options.localAnchorA){\n        this.localAnchorA.copy(options.localAnchorA);\n    }\n    if(options.localAnchorB){\n        this.localAnchorB.copy(options.localAnchorB);\n    }\n    if(options.worldAnchorA){\n        this.setWorldAnchorA(options.worldAnchorA);\n    }\n    if(options.worldAnchorB){\n        this.setWorldAnchorB(options.worldAnchorB);\n    }\n}\n\n/**\n * Set the anchor point on body A, using world coordinates.\n * @method setWorldAnchorA\n * @param {Vec3} worldAnchorA\n */\nSpring.prototype.setWorldAnchorA = function(worldAnchorA){\n    this.bodyA.pointToLocalFrame(worldAnchorA,this.localAnchorA);\n};\n\n/**\n * Set the anchor point on body B, using world coordinates.\n * @method setWorldAnchorB\n * @param {Vec3} worldAnchorB\n */\nSpring.prototype.setWorldAnchorB = function(worldAnchorB){\n    this.bodyB.pointToLocalFrame(worldAnchorB,this.localAnchorB);\n};\n\n/**\n * Get the anchor point on body A, in world coordinates.\n * @method getWorldAnchorA\n * @param {Vec3} result The vector to store the result in.\n */\nSpring.prototype.getWorldAnchorA = function(result){\n    this.bodyA.pointToWorldFrame(this.localAnchorA,result);\n};\n\n/**\n * Get the anchor point on body B, in world coordinates.\n * @method getWorldAnchorB\n * @param {Vec3} result The vector to store the result in.\n */\nSpring.prototype.getWorldAnchorB = function(result){\n    this.bodyB.pointToWorldFrame(this.localAnchorB,result);\n};\n\nvar applyForce_r =              new Vec3(),\n    applyForce_r_unit =         new Vec3(),\n    applyForce_u =              new Vec3(),\n    applyForce_f =              new Vec3(),\n    applyForce_worldAnchorA =   new Vec3(),\n    applyForce_worldAnchorB =   new Vec3(),\n    applyForce_ri =             new Vec3(),\n    applyForce_rj =             new Vec3(),\n    applyForce_ri_x_f =         new Vec3(),\n    applyForce_rj_x_f =         new Vec3(),\n    applyForce_tmp =            new Vec3();\n\n/**\n * Apply the spring force to the connected bodies.\n * @method applyForce\n */\nSpring.prototype.applyForce = function(){\n    var k = this.stiffness,\n        d = this.damping,\n        l = this.restLength,\n        bodyA = this.bodyA,\n        bodyB = this.bodyB,\n        r = applyForce_r,\n        r_unit = applyForce_r_unit,\n        u = applyForce_u,\n        f = applyForce_f,\n        tmp = applyForce_tmp;\n\n    var worldAnchorA = applyForce_worldAnchorA,\n        worldAnchorB = applyForce_worldAnchorB,\n        ri = applyForce_ri,\n        rj = applyForce_rj,\n        ri_x_f = applyForce_ri_x_f,\n        rj_x_f = applyForce_rj_x_f;\n\n    // Get world anchors\n    this.getWorldAnchorA(worldAnchorA);\n    this.getWorldAnchorB(worldAnchorB);\n\n    // Get offset points\n    worldAnchorA.vsub(bodyA.position,ri);\n    worldAnchorB.vsub(bodyB.position,rj);\n\n    // Compute distance vector between world anchor points\n    worldAnchorB.vsub(worldAnchorA,r);\n    var rlen = r.norm();\n    r_unit.copy(r);\n    r_unit.normalize();\n\n    // Compute relative velocity of the anchor points, u\n    bodyB.velocity.vsub(bodyA.velocity,u);\n    // Add rotational velocity\n\n    bodyB.angularVelocity.cross(rj,tmp);\n    u.vadd(tmp,u);\n    bodyA.angularVelocity.cross(ri,tmp);\n    u.vsub(tmp,u);\n\n    // F = - k * ( x - L ) - D * ( u )\n    r_unit.mult(-k*(rlen-l) - d*u.dot(r_unit), f);\n\n    // Add forces to bodies\n    bodyA.force.vsub(f,bodyA.force);\n    bodyB.force.vadd(f,bodyB.force);\n\n    // Angular force\n    ri.cross(f,ri_x_f);\n    rj.cross(f,rj_x_f);\n    bodyA.torque.vsub(ri_x_f,bodyA.torque);\n    bodyB.torque.vadd(rj_x_f,bodyB.torque);\n};\n\n},{\"../math/Vec3\":30}],36:[function(_dereq_,module,exports){\nvar Vec3 = _dereq_('../math/Vec3');\nvar Transform = _dereq_('../math/Transform');\nvar RaycastResult = _dereq_('../collision/RaycastResult');\nvar Utils = _dereq_('../utils/Utils');\n\nmodule.exports = WheelInfo;\n\n/**\n * @class WheelInfo\n * @constructor\n * @param {Object} [options]\n *\n * @param {Vec3} [options.chassisConnectionPointLocal]\n * @param {Vec3} [options.chassisConnectionPointWorld]\n * @param {Vec3} [options.directionLocal]\n * @param {Vec3} [options.directionWorld]\n * @param {Vec3} [options.axleLocal]\n * @param {Vec3} [options.axleWorld]\n * @param {number} [options.suspensionRestLength=1]\n * @param {number} [options.suspensionMaxLength=2]\n * @param {number} [options.radius=1]\n * @param {number} [options.suspensionStiffness=100]\n * @param {number} [options.dampingCompression=10]\n * @param {number} [options.dampingRelaxation=10]\n * @param {number} [options.frictionSlip=10000]\n * @param {number} [options.steering=0]\n * @param {number} [options.rotation=0]\n * @param {number} [options.deltaRotation=0]\n * @param {number} [options.rollInfluence=0.01]\n * @param {number} [options.maxSuspensionForce]\n * @param {boolean} [options.isFrontWheel=true]\n * @param {number} [options.clippedInvContactDotSuspension=1]\n * @param {number} [options.suspensionRelativeVelocity=0]\n * @param {number} [options.suspensionForce=0]\n * @param {number} [options.skidInfo=0]\n * @param {number} [options.suspensionLength=0]\n * @param {number} [options.maxSuspensionTravel=1]\n * @param {boolean} [options.useCustomSlidingRotationalSpeed=false]\n * @param {number} [options.customSlidingRotationalSpeed=-0.1]\n */\nfunction WheelInfo(options){\n    options = Utils.defaults(options, {\n        chassisConnectionPointLocal: new Vec3(),\n        chassisConnectionPointWorld: new Vec3(),\n        directionLocal: new Vec3(),\n        directionWorld: new Vec3(),\n        axleLocal: new Vec3(),\n        axleWorld: new Vec3(),\n        suspensionRestLength: 1,\n        suspensionMaxLength: 2,\n        radius: 1,\n        suspensionStiffness: 100,\n        dampingCompression: 10,\n        dampingRelaxation: 10,\n        frictionSlip: 10000,\n        steering: 0,\n        rotation: 0,\n        deltaRotation: 0,\n        rollInfluence: 0.01,\n        maxSuspensionForce: Number.MAX_VALUE,\n        isFrontWheel: true,\n        clippedInvContactDotSuspension: 1,\n        suspensionRelativeVelocity: 0,\n        suspensionForce: 0,\n        skidInfo: 0,\n        suspensionLength: 0,\n        maxSuspensionTravel: 1,\n        useCustomSlidingRotationalSpeed: false,\n        customSlidingRotationalSpeed: -0.1\n    });\n\n    /**\n     * Max travel distance of the suspension, in meters.\n     * @property {number} maxSuspensionTravel\n     */\n    this.maxSuspensionTravel = options.maxSuspensionTravel;\n\n    /**\n     * Speed to apply to the wheel rotation when the wheel is sliding.\n     * @property {number} customSlidingRotationalSpeed\n     */\n    this.customSlidingRotationalSpeed = options.customSlidingRotationalSpeed;\n\n    /**\n     * If the customSlidingRotationalSpeed should be used.\n     * @property {Boolean} useCustomSlidingRotationalSpeed\n     */\n    this.useCustomSlidingRotationalSpeed = options.useCustomSlidingRotationalSpeed;\n\n    /**\n     * @property {Boolean} sliding\n     */\n    this.sliding = false;\n\n    /**\n     * Connection point, defined locally in the chassis body frame.\n     * @property {Vec3} chassisConnectionPointLocal\n     */\n    this.chassisConnectionPointLocal = options.chassisConnectionPointLocal.clone();\n\n    /**\n     * @property {Vec3} chassisConnectionPointWorld\n     */\n    this.chassisConnectionPointWorld = options.chassisConnectionPointWorld.clone();\n\n    /**\n     * @property {Vec3} directionLocal\n     */\n    this.directionLocal = options.directionLocal.clone();\n\n    /**\n     * @property {Vec3} directionWorld\n     */\n    this.directionWorld = options.directionWorld.clone();\n\n    /**\n     * @property {Vec3} axleLocal\n     */\n    this.axleLocal = options.axleLocal.clone();\n\n    /**\n     * @property {Vec3} axleWorld\n     */\n    this.axleWorld = options.axleWorld.clone();\n\n    /**\n     * @property {number} suspensionRestLength\n     */\n    this.suspensionRestLength = options.suspensionRestLength;\n\n    /**\n     * @property {number} suspensionMaxLength\n     */\n    this.suspensionMaxLength = options.suspensionMaxLength;\n\n    /**\n     * @property {number} radius\n     */\n    this.radius = options.radius;\n\n    /**\n     * @property {number} suspensionStiffness\n     */\n    this.suspensionStiffness = options.suspensionStiffness;\n\n    /**\n     * @property {number} dampingCompression\n     */\n    this.dampingCompression = options.dampingCompression;\n\n    /**\n     * @property {number} dampingRelaxation\n     */\n    this.dampingRelaxation = options.dampingRelaxation;\n\n    /**\n     * @property {number} frictionSlip\n     */\n    this.frictionSlip = options.frictionSlip;\n\n    /**\n     * @property {number} steering\n     */\n    this.steering = 0;\n\n    /**\n     * Rotation value, in radians.\n     * @property {number} rotation\n     */\n    this.rotation = 0;\n\n    /**\n     * @property {number} deltaRotation\n     */\n    this.deltaRotation = 0;\n\n    /**\n     * @property {number} rollInfluence\n     */\n    this.rollInfluence = options.rollInfluence;\n\n    /**\n     * @property {number} maxSuspensionForce\n     */\n    this.maxSuspensionForce = options.maxSuspensionForce;\n\n    /**\n     * @property {number} engineForce\n     */\n    this.engineForce = 0;\n\n    /**\n     * @property {number} brake\n     */\n    this.brake = 0;\n\n    /**\n     * @property {number} isFrontWheel\n     */\n    this.isFrontWheel = options.isFrontWheel;\n\n    /**\n     * @property {number} clippedInvContactDotSuspension\n     */\n    this.clippedInvContactDotSuspension = 1;\n\n    /**\n     * @property {number} suspensionRelativeVelocity\n     */\n    this.suspensionRelativeVelocity = 0;\n\n    /**\n     * @property {number} suspensionForce\n     */\n    this.suspensionForce = 0;\n\n    /**\n     * @property {number} skidInfo\n     */\n    this.skidInfo = 0;\n\n    /**\n     * @property {number} suspensionLength\n     */\n    this.suspensionLength = 0;\n\n    /**\n     * @property {number} sideImpulse\n     */\n    this.sideImpulse = 0;\n\n    /**\n     * @property {number} forwardImpulse\n     */\n    this.forwardImpulse = 0;\n\n    /**\n     * The result from raycasting\n     * @property {RaycastResult} raycastResult\n     */\n    this.raycastResult = new RaycastResult();\n\n    /**\n     * Wheel world transform\n     * @property {Transform} worldTransform\n     */\n    this.worldTransform = new Transform();\n\n    /**\n     * @property {boolean} isInContact\n     */\n    this.isInContact = false;\n}\n\nvar chassis_velocity_at_contactPoint = new Vec3();\nvar relpos = new Vec3();\nvar chassis_velocity_at_contactPoint = new Vec3();\nWheelInfo.prototype.updateWheel = function(chassis){\n    var raycastResult = this.raycastResult;\n\n    if (this.isInContact){\n        var project= raycastResult.hitNormalWorld.dot(raycastResult.directionWorld);\n        raycastResult.hitPointWorld.vsub(chassis.position, relpos);\n        chassis.getVelocityAtWorldPoint(relpos, chassis_velocity_at_contactPoint);\n        var projVel = raycastResult.hitNormalWorld.dot( chassis_velocity_at_contactPoint );\n        if (project >= -0.1) {\n            this.suspensionRelativeVelocity = 0.0;\n            this.clippedInvContactDotSuspension = 1.0 / 0.1;\n        } else {\n            var inv = -1 / project;\n            this.suspensionRelativeVelocity = projVel * inv;\n            this.clippedInvContactDotSuspension = inv;\n        }\n\n    } else {\n        // Not in contact : position wheel in a nice (rest length) position\n        raycastResult.suspensionLength = this.suspensionRestLength;\n        this.suspensionRelativeVelocity = 0.0;\n        raycastResult.directionWorld.scale(-1, raycastResult.hitNormalWorld);\n        this.clippedInvContactDotSuspension = 1.0;\n    }\n};\n},{\"../collision/RaycastResult\":10,\"../math/Transform\":29,\"../math/Vec3\":30,\"../utils/Utils\":53}],37:[function(_dereq_,module,exports){\nmodule.exports = Box;\n\nvar Shape = _dereq_('./Shape');\nvar Vec3 = _dereq_('../math/Vec3');\nvar ConvexPolyhedron = _dereq_('./ConvexPolyhedron');\n\n/**\n * A 3d box shape.\n * @class Box\n * @constructor\n * @param {Vec3} halfExtents\n * @author schteppe\n * @extends Shape\n */\nfunction Box(halfExtents){\n    Shape.call(this);\n\n    this.type = Shape.types.BOX;\n\n    /**\n     * @property halfExtents\n     * @type {Vec3}\n     */\n    this.halfExtents = halfExtents;\n\n    /**\n     * Used by the contact generator to make contacts with other convex polyhedra for example\n     * @property convexPolyhedronRepresentation\n     * @type {ConvexPolyhedron}\n     */\n    this.convexPolyhedronRepresentation = null;\n\n    this.updateConvexPolyhedronRepresentation();\n    this.updateBoundingSphereRadius();\n}\nBox.prototype = new Shape();\nBox.prototype.constructor = Box;\n\n/**\n * Updates the local convex polyhedron representation used for some collisions.\n * @method updateConvexPolyhedronRepresentation\n */\nBox.prototype.updateConvexPolyhedronRepresentation = function(){\n    var sx = this.halfExtents.x;\n    var sy = this.halfExtents.y;\n    var sz = this.halfExtents.z;\n    var V = Vec3;\n\n    var vertices = [\n        new V(-sx,-sy,-sz),\n        new V( sx,-sy,-sz),\n        new V( sx, sy,-sz),\n        new V(-sx, sy,-sz),\n        new V(-sx,-sy, sz),\n        new V( sx,-sy, sz),\n        new V( sx, sy, sz),\n        new V(-sx, sy, sz)\n    ];\n\n    var indices = [\n        [3,2,1,0], // -z\n        [4,5,6,7], // +z\n        [5,4,0,1], // -y\n        [2,3,7,6], // +y\n        [0,4,7,3], // -x\n        [1,2,6,5], // +x\n    ];\n\n    var axes = [\n        new V(0, 0, 1),\n        new V(0, 1, 0),\n        new V(1, 0, 0)\n    ];\n\n    var h = new ConvexPolyhedron(vertices, indices);\n    this.convexPolyhedronRepresentation = h;\n    h.material = this.material;\n};\n\n/**\n * @method calculateLocalInertia\n * @param  {Number} mass\n * @param  {Vec3} target\n * @return {Vec3}\n */\nBox.prototype.calculateLocalInertia = function(mass,target){\n    target = target || new Vec3();\n    Box.calculateInertia(this.halfExtents, mass, target);\n    return target;\n};\n\nBox.calculateInertia = function(halfExtents,mass,target){\n    var e = halfExtents;\n    target.x = 1.0 / 12.0 * mass * (   2*e.y*2*e.y + 2*e.z*2*e.z );\n    target.y = 1.0 / 12.0 * mass * (   2*e.x*2*e.x + 2*e.z*2*e.z );\n    target.z = 1.0 / 12.0 * mass * (   2*e.y*2*e.y + 2*e.x*2*e.x );\n};\n\n/**\n * Get the box 6 side normals\n * @method getSideNormals\n * @param {array}      sixTargetVectors An array of 6 vectors, to store the resulting side normals in.\n * @param {Quaternion} quat             Orientation to apply to the normal vectors. If not provided, the vectors will be in respect to the local frame.\n * @return {array}\n */\nBox.prototype.getSideNormals = function(sixTargetVectors,quat){\n    var sides = sixTargetVectors;\n    var ex = this.halfExtents;\n    sides[0].set(  ex.x,     0,     0);\n    sides[1].set(     0,  ex.y,     0);\n    sides[2].set(     0,     0,  ex.z);\n    sides[3].set( -ex.x,     0,     0);\n    sides[4].set(     0, -ex.y,     0);\n    sides[5].set(     0,     0, -ex.z);\n\n    if(quat!==undefined){\n        for(var i=0; i!==sides.length; i++){\n            quat.vmult(sides[i],sides[i]);\n        }\n    }\n\n    return sides;\n};\n\nBox.prototype.volume = function(){\n    return 8.0 * this.halfExtents.x * this.halfExtents.y * this.halfExtents.z;\n};\n\nBox.prototype.updateBoundingSphereRadius = function(){\n    this.boundingSphereRadius = this.halfExtents.norm();\n};\n\nvar worldCornerTempPos = new Vec3();\nvar worldCornerTempNeg = new Vec3();\nBox.prototype.forEachWorldCorner = function(pos,quat,callback){\n\n    var e = this.halfExtents;\n    var corners = [[  e.x,  e.y,  e.z],\n                   [ -e.x,  e.y,  e.z],\n                   [ -e.x, -e.y,  e.z],\n                   [ -e.x, -e.y, -e.z],\n                   [  e.x, -e.y, -e.z],\n                   [  e.x,  e.y, -e.z],\n                   [ -e.x,  e.y, -e.z],\n                   [  e.x, -e.y,  e.z]];\n    for(var i=0; i<corners.length; i++){\n        worldCornerTempPos.set(corners[i][0],corners[i][1],corners[i][2]);\n        quat.vmult(worldCornerTempPos,worldCornerTempPos);\n        pos.vadd(worldCornerTempPos,worldCornerTempPos);\n        callback(worldCornerTempPos.x,\n                 worldCornerTempPos.y,\n                 worldCornerTempPos.z);\n    }\n};\n\nvar worldCornersTemp = [\n    new Vec3(),\n    new Vec3(),\n    new Vec3(),\n    new Vec3(),\n    new Vec3(),\n    new Vec3(),\n    new Vec3(),\n    new Vec3()\n];\nBox.prototype.calculateWorldAABB = function(pos,quat,min,max){\n\n    var e = this.halfExtents;\n    worldCornersTemp[0].set(e.x, e.y, e.z);\n    worldCornersTemp[1].set(-e.x,  e.y, e.z);\n    worldCornersTemp[2].set(-e.x, -e.y, e.z);\n    worldCornersTemp[3].set(-e.x, -e.y, -e.z);\n    worldCornersTemp[4].set(e.x, -e.y, -e.z);\n    worldCornersTemp[5].set(e.x,  e.y, -e.z);\n    worldCornersTemp[6].set(-e.x,  e.y, -e.z);\n    worldCornersTemp[7].set(e.x, -e.y,  e.z);\n\n    var wc = worldCornersTemp[0];\n    quat.vmult(wc, wc);\n    pos.vadd(wc, wc);\n    max.copy(wc);\n    min.copy(wc);\n    for(var i=1; i<8; i++){\n        var wc = worldCornersTemp[i];\n        quat.vmult(wc, wc);\n        pos.vadd(wc, wc);\n        var x = wc.x;\n        var y = wc.y;\n        var z = wc.z;\n        if(x > max.x){\n            max.x = x;\n        }\n        if(y > max.y){\n            max.y = y;\n        }\n        if(z > max.z){\n            max.z = z;\n        }\n\n        if(x < min.x){\n            min.x = x;\n        }\n        if(y < min.y){\n            min.y = y;\n        }\n        if(z < min.z){\n            min.z = z;\n        }\n    }\n\n    // Get each axis max\n    // min.set(Infinity,Infinity,Infinity);\n    // max.set(-Infinity,-Infinity,-Infinity);\n    // this.forEachWorldCorner(pos,quat,function(x,y,z){\n    //     if(x > max.x){\n    //         max.x = x;\n    //     }\n    //     if(y > max.y){\n    //         max.y = y;\n    //     }\n    //     if(z > max.z){\n    //         max.z = z;\n    //     }\n\n    //     if(x < min.x){\n    //         min.x = x;\n    //     }\n    //     if(y < min.y){\n    //         min.y = y;\n    //     }\n    //     if(z < min.z){\n    //         min.z = z;\n    //     }\n    // });\n};\n\n},{\"../math/Vec3\":30,\"./ConvexPolyhedron\":38,\"./Shape\":43}],38:[function(_dereq_,module,exports){\nmodule.exports = ConvexPolyhedron;\n\nvar Shape = _dereq_('./Shape');\nvar Vec3 = _dereq_('../math/Vec3');\nvar Quaternion = _dereq_('../math/Quaternion');\nvar Transform = _dereq_('../math/Transform');\n\n/**\n * A set of polygons describing a convex shape.\n * @class ConvexPolyhedron\n * @constructor\n * @extends Shape\n * @description The shape MUST be convex for the code to work properly. No polygons may be coplanar (contained\n * in the same 3D plane), instead these should be merged into one polygon.\n *\n * @param {array} points An array of Vec3's\n * @param {array} faces Array of integer arrays, describing which vertices that is included in each face.\n *\n * @author qiao / https://github.com/qiao (original author, see https://github.com/qiao/three.js/commit/85026f0c769e4000148a67d45a9e9b9c5108836f)\n * @author schteppe / https://github.com/schteppe\n * @see http://www.altdevblogaday.com/2011/05/13/contact-generation-between-3d-convex-meshes/\n * @see http://bullet.googlecode.com/svn/trunk/src/BulletCollision/NarrowPhaseCollision/btPolyhedralContactClipping.cpp\n *\n * @todo Move the clipping functions to ContactGenerator?\n * @todo Automatically merge coplanar polygons in constructor.\n */\nfunction ConvexPolyhedron(points, faces, uniqueAxes) {\n    var that = this;\n    Shape.call(this);\n    this.type = Shape.types.CONVEXPOLYHEDRON;\n\n    /**\n     * Array of Vec3\n     * @property vertices\n     * @type {Array}\n     */\n    this.vertices = points||[];\n\n    this.worldVertices = []; // World transformed version of .vertices\n    this.worldVerticesNeedsUpdate = true;\n\n    /**\n     * Array of integer arrays, indicating which vertices each face consists of\n     * @property faces\n     * @type {Array}\n     */\n    this.faces = faces||[];\n\n    /**\n     * Array of Vec3\n     * @property faceNormals\n     * @type {Array}\n     */\n    this.faceNormals = [];\n    this.computeNormals();\n\n    this.worldFaceNormalsNeedsUpdate = true;\n    this.worldFaceNormals = []; // World transformed version of .faceNormals\n\n    /**\n     * Array of Vec3\n     * @property uniqueEdges\n     * @type {Array}\n     */\n    this.uniqueEdges = [];\n\n    /**\n     * If given, these locally defined, normalized axes are the only ones being checked when doing separating axis check.\n     * @property {Array} uniqueAxes\n     */\n    this.uniqueAxes = uniqueAxes ? uniqueAxes.slice() : null;\n\n    this.computeEdges();\n    this.updateBoundingSphereRadius();\n}\nConvexPolyhedron.prototype = new Shape();\nConvexPolyhedron.prototype.constructor = ConvexPolyhedron;\n\nvar computeEdges_tmpEdge = new Vec3();\n/**\n * Computes uniqueEdges\n * @method computeEdges\n */\nConvexPolyhedron.prototype.computeEdges = function(){\n    var faces = this.faces;\n    var vertices = this.vertices;\n    var nv = vertices.length;\n    var edges = this.uniqueEdges;\n\n    edges.length = 0;\n\n    var edge = computeEdges_tmpEdge;\n\n    for(var i=0; i !== faces.length; i++){\n        var face = faces[i];\n        var numVertices = face.length;\n        for(var j = 0; j !== numVertices; j++){\n            var k = ( j+1 ) % numVertices;\n            vertices[face[j]].vsub(vertices[face[k]], edge);\n            edge.normalize();\n            var found = false;\n            for(var p=0; p !== edges.length; p++){\n                if (edges[p].almostEquals(edge) || edges[p].almostEquals(edge)){\n                    found = true;\n                    break;\n                }\n            }\n\n            if (!found){\n                edges.push(edge.clone());\n            }\n        }\n    }\n};\n\n/**\n * Compute the normals of the faces. Will reuse existing Vec3 objects in the .faceNormals array if they exist.\n * @method computeNormals\n */\nConvexPolyhedron.prototype.computeNormals = function(){\n    this.faceNormals.length = this.faces.length;\n\n    // Generate normals\n    for(var i=0; i<this.faces.length; i++){\n\n        // Check so all vertices exists for this face\n        for(var j=0; j<this.faces[i].length; j++){\n            if(!this.vertices[this.faces[i][j]]){\n                throw new Error(\"Vertex \"+this.faces[i][j]+\" not found!\");\n            }\n        }\n\n        var n = this.faceNormals[i] || new Vec3();\n        this.getFaceNormal(i,n);\n        n.negate(n);\n        this.faceNormals[i] = n;\n        var vertex = this.vertices[this.faces[i][0]];\n        if(n.dot(vertex) < 0){\n            console.error(\".faceNormals[\" + i + \"] = Vec3(\"+n.toString()+\") looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.\");\n            for(var j=0; j<this.faces[i].length; j++){\n                console.warn(\".vertices[\"+this.faces[i][j]+\"] = Vec3(\"+this.vertices[this.faces[i][j]].toString()+\")\");\n            }\n        }\n    }\n};\n\n/**\n * Get face normal given 3 vertices\n * @static\n * @method getFaceNormal\n * @param {Vec3} va\n * @param {Vec3} vb\n * @param {Vec3} vc\n * @param {Vec3} target\n */\nvar cb = new Vec3();\nvar ab = new Vec3();\nConvexPolyhedron.computeNormal = function ( va, vb, vc, target ) {\n    vb.vsub(va,ab);\n    vc.vsub(vb,cb);\n    cb.cross(ab,target);\n    if ( !target.isZero() ) {\n        target.normalize();\n    }\n};\n\n/**\n * Compute the normal of a face from its vertices\n * @method getFaceNormal\n * @param  {Number} i\n * @param  {Vec3} target\n */\nConvexPolyhedron.prototype.getFaceNormal = function(i,target){\n    var f = this.faces[i];\n    var va = this.vertices[f[0]];\n    var vb = this.vertices[f[1]];\n    var vc = this.vertices[f[2]];\n    return ConvexPolyhedron.computeNormal(va,vb,vc,target);\n};\n\n/**\n * @method clipAgainstHull\n * @param {Vec3} posA\n * @param {Quaternion} quatA\n * @param {ConvexPolyhedron} hullB\n * @param {Vec3} posB\n * @param {Quaternion} quatB\n * @param {Vec3} separatingNormal\n * @param {Number} minDist Clamp distance\n * @param {Number} maxDist\n * @param {array} result The an array of contact point objects, see clipFaceAgainstHull\n * @see http://bullet.googlecode.com/svn/trunk/src/BulletCollision/NarrowPhaseCollision/btPolyhedralContactClipping.cpp\n */\nvar cah_WorldNormal = new Vec3();\nConvexPolyhedron.prototype.clipAgainstHull = function(posA,quatA,hullB,posB,quatB,separatingNormal,minDist,maxDist,result){\n    var WorldNormal = cah_WorldNormal;\n    var hullA = this;\n    var curMaxDist = maxDist;\n    var closestFaceB = -1;\n    var dmax = -Number.MAX_VALUE;\n    for(var face=0; face < hullB.faces.length; face++){\n        WorldNormal.copy(hullB.faceNormals[face]);\n        quatB.vmult(WorldNormal,WorldNormal);\n        //posB.vadd(WorldNormal,WorldNormal);\n        var d = WorldNormal.dot(separatingNormal);\n        if (d > dmax){\n            dmax = d;\n            closestFaceB = face;\n        }\n    }\n    var worldVertsB1 = [];\n    var polyB = hullB.faces[closestFaceB];\n    var numVertices = polyB.length;\n    for(var e0=0; e0<numVertices; e0++){\n        var b = hullB.vertices[polyB[e0]];\n        var worldb = new Vec3();\n        worldb.copy(b);\n        quatB.vmult(worldb,worldb);\n        posB.vadd(worldb,worldb);\n        worldVertsB1.push(worldb);\n    }\n\n    if (closestFaceB>=0){\n        this.clipFaceAgainstHull(separatingNormal,\n                                 posA,\n                                 quatA,\n                                 worldVertsB1,\n                                 minDist,\n                                 maxDist,\n                                 result);\n    }\n};\n\n/**\n * Find the separating axis between this hull and another\n * @method findSeparatingAxis\n * @param {ConvexPolyhedron} hullB\n * @param {Vec3} posA\n * @param {Quaternion} quatA\n * @param {Vec3} posB\n * @param {Quaternion} quatB\n * @param {Vec3} target The target vector to save the axis in\n * @return {bool} Returns false if a separation is found, else true\n */\nvar fsa_faceANormalWS3 = new Vec3(),\n    fsa_Worldnormal1 = new Vec3(),\n    fsa_deltaC = new Vec3(),\n    fsa_worldEdge0 = new Vec3(),\n    fsa_worldEdge1 = new Vec3(),\n    fsa_Cross = new Vec3();\nConvexPolyhedron.prototype.findSeparatingAxis = function(hullB,posA,quatA,posB,quatB,target, faceListA, faceListB){\n    var faceANormalWS3 = fsa_faceANormalWS3,\n        Worldnormal1 = fsa_Worldnormal1,\n        deltaC = fsa_deltaC,\n        worldEdge0 = fsa_worldEdge0,\n        worldEdge1 = fsa_worldEdge1,\n        Cross = fsa_Cross;\n\n    var dmin = Number.MAX_VALUE;\n    var hullA = this;\n    var curPlaneTests=0;\n\n    if(!hullA.uniqueAxes){\n\n        var numFacesA = faceListA ? faceListA.length : hullA.faces.length;\n\n        // Test face normals from hullA\n        for(var i=0; i<numFacesA; i++){\n            var fi = faceListA ? faceListA[i] : i;\n\n            // Get world face normal\n            faceANormalWS3.copy(hullA.faceNormals[fi]);\n            quatA.vmult(faceANormalWS3,faceANormalWS3);\n\n            var d = hullA.testSepAxis(faceANormalWS3, hullB, posA, quatA, posB, quatB);\n            if(d===false){\n                return false;\n            }\n\n            if(d<dmin){\n                dmin = d;\n                target.copy(faceANormalWS3);\n            }\n        }\n\n    } else {\n\n        // Test unique axes\n        for(var i = 0; i !== hullA.uniqueAxes.length; i++){\n\n            // Get world axis\n            quatA.vmult(hullA.uniqueAxes[i],faceANormalWS3);\n\n            var d = hullA.testSepAxis(faceANormalWS3, hullB, posA, quatA, posB, quatB);\n            if(d===false){\n                return false;\n            }\n\n            if(d<dmin){\n                dmin = d;\n                target.copy(faceANormalWS3);\n            }\n        }\n    }\n\n    if(!hullB.uniqueAxes){\n\n        // Test face normals from hullB\n        var numFacesB = faceListB ? faceListB.length : hullB.faces.length;\n        for(var i=0;i<numFacesB;i++){\n\n            var fi = faceListB ? faceListB[i] : i;\n\n            Worldnormal1.copy(hullB.faceNormals[fi]);\n            quatB.vmult(Worldnormal1,Worldnormal1);\n            curPlaneTests++;\n            var d = hullA.testSepAxis(Worldnormal1, hullB,posA,quatA,posB,quatB);\n            if(d===false){\n                return false;\n            }\n\n            if(d<dmin){\n                dmin = d;\n                target.copy(Worldnormal1);\n            }\n        }\n    } else {\n\n        // Test unique axes in B\n        for(var i = 0; i !== hullB.uniqueAxes.length; i++){\n            quatB.vmult(hullB.uniqueAxes[i],Worldnormal1);\n\n            curPlaneTests++;\n            var d = hullA.testSepAxis(Worldnormal1, hullB,posA,quatA,posB,quatB);\n            if(d===false){\n                return false;\n            }\n\n            if(d<dmin){\n                dmin = d;\n                target.copy(Worldnormal1);\n            }\n        }\n    }\n\n    // Test edges\n    for(var e0=0; e0 !== hullA.uniqueEdges.length; e0++){\n\n        // Get world edge\n        quatA.vmult(hullA.uniqueEdges[e0],worldEdge0);\n\n        for(var e1=0; e1 !== hullB.uniqueEdges.length; e1++){\n\n            // Get world edge 2\n            quatB.vmult(hullB.uniqueEdges[e1], worldEdge1);\n            worldEdge0.cross(worldEdge1,Cross);\n\n            if(!Cross.almostZero()){\n                Cross.normalize();\n                var dist = hullA.testSepAxis(Cross, hullB, posA, quatA, posB, quatB);\n                if(dist === false){\n                    return false;\n                }\n                if(dist < dmin){\n                    dmin = dist;\n                    target.copy(Cross);\n                }\n            }\n        }\n    }\n\n    posB.vsub(posA,deltaC);\n    if((deltaC.dot(target))>0.0){\n        target.negate(target);\n    }\n\n    return true;\n};\n\nvar maxminA=[], maxminB=[];\n\n/**\n * Test separating axis against two hulls. Both hulls are projected onto the axis and the overlap size is returned if there is one.\n * @method testSepAxis\n * @param {Vec3} axis\n * @param {ConvexPolyhedron} hullB\n * @param {Vec3} posA\n * @param {Quaternion} quatA\n * @param {Vec3} posB\n * @param {Quaternion} quatB\n * @return {number} The overlap depth, or FALSE if no penetration.\n */\nConvexPolyhedron.prototype.testSepAxis = function(axis, hullB, posA, quatA, posB, quatB){\n    var hullA=this;\n    ConvexPolyhedron.project(hullA, axis, posA, quatA, maxminA);\n    ConvexPolyhedron.project(hullB, axis, posB, quatB, maxminB);\n    var maxA = maxminA[0];\n    var minA = maxminA[1];\n    var maxB = maxminB[0];\n    var minB = maxminB[1];\n    if(maxA<minB || maxB<minA){\n        return false; // Separated\n    }\n    var d0 = maxA - minB;\n    var d1 = maxB - minA;\n    var depth = d0<d1 ? d0:d1;\n    return depth;\n};\n\nvar cli_aabbmin = new Vec3(),\n    cli_aabbmax = new Vec3();\n\n/**\n * @method calculateLocalInertia\n * @param  {Number} mass\n * @param  {Vec3} target\n */\nConvexPolyhedron.prototype.calculateLocalInertia = function(mass,target){\n    // Approximate with box inertia\n    // Exact inertia calculation is overkill, but see http://geometrictools.com/Documentation/PolyhedralMassProperties.pdf for the correct way to do it\n    this.computeLocalAABB(cli_aabbmin,cli_aabbmax);\n    var x = cli_aabbmax.x - cli_aabbmin.x,\n        y = cli_aabbmax.y - cli_aabbmin.y,\n        z = cli_aabbmax.z - cli_aabbmin.z;\n    target.x = 1.0 / 12.0 * mass * ( 2*y*2*y + 2*z*2*z );\n    target.y = 1.0 / 12.0 * mass * ( 2*x*2*x + 2*z*2*z );\n    target.z = 1.0 / 12.0 * mass * ( 2*y*2*y + 2*x*2*x );\n};\n\n/**\n * @method getPlaneConstantOfFace\n * @param  {Number} face_i Index of the face\n * @return {Number}\n */\nConvexPolyhedron.prototype.getPlaneConstantOfFace = function(face_i){\n    var f = this.faces[face_i];\n    var n = this.faceNormals[face_i];\n    var v = this.vertices[f[0]];\n    var c = -n.dot(v);\n    return c;\n};\n\n/**\n * Clip a face against a hull.\n * @method clipFaceAgainstHull\n * @param {Vec3} separatingNormal\n * @param {Vec3} posA\n * @param {Quaternion} quatA\n * @param {Array} worldVertsB1 An array of Vec3 with vertices in the world frame.\n * @param {Number} minDist Distance clamping\n * @param {Number} maxDist\n * @param Array result Array to store resulting contact points in. Will be objects with properties: point, depth, normal. These are represented in world coordinates.\n */\nvar cfah_faceANormalWS = new Vec3(),\n    cfah_edge0 = new Vec3(),\n    cfah_WorldEdge0 = new Vec3(),\n    cfah_worldPlaneAnormal1 = new Vec3(),\n    cfah_planeNormalWS1 = new Vec3(),\n    cfah_worldA1 = new Vec3(),\n    cfah_localPlaneNormal = new Vec3(),\n    cfah_planeNormalWS = new Vec3();\nConvexPolyhedron.prototype.clipFaceAgainstHull = function(separatingNormal, posA, quatA, worldVertsB1, minDist, maxDist,result){\n    var faceANormalWS = cfah_faceANormalWS,\n        edge0 = cfah_edge0,\n        WorldEdge0 = cfah_WorldEdge0,\n        worldPlaneAnormal1 = cfah_worldPlaneAnormal1,\n        planeNormalWS1 = cfah_planeNormalWS1,\n        worldA1 = cfah_worldA1,\n        localPlaneNormal = cfah_localPlaneNormal,\n        planeNormalWS = cfah_planeNormalWS;\n\n    var hullA = this;\n    var worldVertsB2 = [];\n    var pVtxIn = worldVertsB1;\n    var pVtxOut = worldVertsB2;\n    // Find the face with normal closest to the separating axis\n    var closestFaceA = -1;\n    var dmin = Number.MAX_VALUE;\n    for(var face=0; face<hullA.faces.length; face++){\n        faceANormalWS.copy(hullA.faceNormals[face]);\n        quatA.vmult(faceANormalWS,faceANormalWS);\n        //posA.vadd(faceANormalWS,faceANormalWS);\n        var d = faceANormalWS.dot(separatingNormal);\n        if (d < dmin){\n            dmin = d;\n            closestFaceA = face;\n        }\n    }\n    if (closestFaceA < 0){\n        // console.log(\"--- did not find any closest face... ---\");\n        return;\n    }\n    //console.log(\"closest A: \",closestFaceA);\n    // Get the face and construct connected faces\n    var polyA = hullA.faces[closestFaceA];\n    polyA.connectedFaces = [];\n    for(var i=0; i<hullA.faces.length; i++){\n        for(var j=0; j<hullA.faces[i].length; j++){\n            if(polyA.indexOf(hullA.faces[i][j])!==-1 /* Sharing a vertex*/ && i!==closestFaceA /* Not the one we are looking for connections from */ && polyA.connectedFaces.indexOf(i)===-1 /* Not already added */ ){\n                polyA.connectedFaces.push(i);\n            }\n        }\n    }\n    // Clip the polygon to the back of the planes of all faces of hull A, that are adjacent to the witness face\n    var numContacts = pVtxIn.length;\n    var numVerticesA = polyA.length;\n    var res = [];\n    for(var e0=0; e0<numVerticesA; e0++){\n        var a = hullA.vertices[polyA[e0]];\n        var b = hullA.vertices[polyA[(e0+1)%numVerticesA]];\n        a.vsub(b,edge0);\n        WorldEdge0.copy(edge0);\n        quatA.vmult(WorldEdge0,WorldEdge0);\n        posA.vadd(WorldEdge0,WorldEdge0);\n        worldPlaneAnormal1.copy(this.faceNormals[closestFaceA]);//transA.getBasis()* btVector3(polyA.m_plane[0],polyA.m_plane[1],polyA.m_plane[2]);\n        quatA.vmult(worldPlaneAnormal1,worldPlaneAnormal1);\n        posA.vadd(worldPlaneAnormal1,worldPlaneAnormal1);\n        WorldEdge0.cross(worldPlaneAnormal1,planeNormalWS1);\n        planeNormalWS1.negate(planeNormalWS1);\n        worldA1.copy(a);\n        quatA.vmult(worldA1,worldA1);\n        posA.vadd(worldA1,worldA1);\n        var planeEqWS1 = -worldA1.dot(planeNormalWS1);\n        var planeEqWS;\n        if(true){\n            var otherFace = polyA.connectedFaces[e0];\n            localPlaneNormal.copy(this.faceNormals[otherFace]);\n            var localPlaneEq = this.getPlaneConstantOfFace(otherFace);\n\n            planeNormalWS.copy(localPlaneNormal);\n            quatA.vmult(planeNormalWS,planeNormalWS);\n            //posA.vadd(planeNormalWS,planeNormalWS);\n            var planeEqWS = localPlaneEq - planeNormalWS.dot(posA);\n        } else  {\n            planeNormalWS.copy(planeNormalWS1);\n            planeEqWS = planeEqWS1;\n        }\n\n        // Clip face against our constructed plane\n        this.clipFaceAgainstPlane(pVtxIn, pVtxOut, planeNormalWS, planeEqWS);\n\n        // Throw away all clipped points, but save the reamining until next clip\n        while(pVtxIn.length){\n            pVtxIn.shift();\n        }\n        while(pVtxOut.length){\n            pVtxIn.push(pVtxOut.shift());\n        }\n    }\n\n    //console.log(\"Resulting points after clip:\",pVtxIn);\n\n    // only keep contact points that are behind the witness face\n    localPlaneNormal.copy(this.faceNormals[closestFaceA]);\n\n    var localPlaneEq = this.getPlaneConstantOfFace(closestFaceA);\n    planeNormalWS.copy(localPlaneNormal);\n    quatA.vmult(planeNormalWS,planeNormalWS);\n\n    var planeEqWS = localPlaneEq - planeNormalWS.dot(posA);\n    for (var i=0; i<pVtxIn.length; i++){\n        var depth = planeNormalWS.dot(pVtxIn[i]) + planeEqWS; //???\n        /*console.log(\"depth calc from normal=\",planeNormalWS.toString(),\" and constant \"+planeEqWS+\" and vertex \",pVtxIn[i].toString(),\" gives \"+depth);*/\n        if (depth <=minDist){\n            console.log(\"clamped: depth=\"+depth+\" to minDist=\"+(minDist+\"\"));\n            depth = minDist;\n        }\n\n        if (depth <=maxDist){\n            var point = pVtxIn[i];\n            if(depth<=0){\n                /*console.log(\"Got contact point \",point.toString(),\n                  \", depth=\",depth,\n                  \"contact normal=\",separatingNormal.toString(),\n                  \"plane\",planeNormalWS.toString(),\n                  \"planeConstant\",planeEqWS);*/\n                var p = {\n                    point:point,\n                    normal:planeNormalWS,\n                    depth: depth,\n                };\n                result.push(p);\n            }\n        }\n    }\n};\n\n/**\n * Clip a face in a hull against the back of a plane.\n * @method clipFaceAgainstPlane\n * @param {Array} inVertices\n * @param {Array} outVertices\n * @param {Vec3} planeNormal\n * @param {Number} planeConstant The constant in the mathematical plane equation\n */\nConvexPolyhedron.prototype.clipFaceAgainstPlane = function(inVertices,outVertices, planeNormal, planeConstant){\n    var n_dot_first, n_dot_last;\n    var numVerts = inVertices.length;\n\n    if(numVerts < 2){\n        return outVertices;\n    }\n\n    var firstVertex = inVertices[inVertices.length-1],\n        lastVertex =   inVertices[0];\n\n    n_dot_first = planeNormal.dot(firstVertex) + planeConstant;\n\n    for(var vi = 0; vi < numVerts; vi++){\n        lastVertex = inVertices[vi];\n        n_dot_last = planeNormal.dot(lastVertex) + planeConstant;\n        if(n_dot_first < 0){\n            if(n_dot_last < 0){\n                // Start < 0, end < 0, so output lastVertex\n                var newv = new Vec3();\n                newv.copy(lastVertex);\n                outVertices.push(newv);\n            } else {\n                // Start < 0, end >= 0, so output intersection\n                var newv = new Vec3();\n                firstVertex.lerp(lastVertex,\n                                 n_dot_first / (n_dot_first - n_dot_last),\n                                 newv);\n                outVertices.push(newv);\n            }\n        } else {\n            if(n_dot_last<0){\n                // Start >= 0, end < 0 so output intersection and end\n                var newv = new Vec3();\n                firstVertex.lerp(lastVertex,\n                                 n_dot_first / (n_dot_first - n_dot_last),\n                                 newv);\n                outVertices.push(newv);\n                outVertices.push(lastVertex);\n            }\n        }\n        firstVertex = lastVertex;\n        n_dot_first = n_dot_last;\n    }\n    return outVertices;\n};\n\n// Updates .worldVertices and sets .worldVerticesNeedsUpdate to false.\nConvexPolyhedron.prototype.computeWorldVertices = function(position,quat){\n    var N = this.vertices.length;\n    while(this.worldVertices.length < N){\n        this.worldVertices.push( new Vec3() );\n    }\n\n    var verts = this.vertices,\n        worldVerts = this.worldVertices;\n    for(var i=0; i!==N; i++){\n        quat.vmult( verts[i] , worldVerts[i] );\n        position.vadd( worldVerts[i] , worldVerts[i] );\n    }\n\n    this.worldVerticesNeedsUpdate = false;\n};\n\nvar computeLocalAABB_worldVert = new Vec3();\nConvexPolyhedron.prototype.computeLocalAABB = function(aabbmin,aabbmax){\n    var n = this.vertices.length,\n        vertices = this.vertices,\n        worldVert = computeLocalAABB_worldVert;\n\n    aabbmin.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    aabbmax.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n\n    for(var i=0; i<n; i++){\n        var v = vertices[i];\n        if     (v.x < aabbmin.x){\n            aabbmin.x = v.x;\n        } else if(v.x > aabbmax.x){\n            aabbmax.x = v.x;\n        }\n        if     (v.y < aabbmin.y){\n            aabbmin.y = v.y;\n        } else if(v.y > aabbmax.y){\n            aabbmax.y = v.y;\n        }\n        if     (v.z < aabbmin.z){\n            aabbmin.z = v.z;\n        } else if(v.z > aabbmax.z){\n            aabbmax.z = v.z;\n        }\n    }\n};\n\n/**\n * Updates .worldVertices and sets .worldVerticesNeedsUpdate to false.\n * @method computeWorldFaceNormals\n * @param  {Quaternion} quat\n */\nConvexPolyhedron.prototype.computeWorldFaceNormals = function(quat){\n    var N = this.faceNormals.length;\n    while(this.worldFaceNormals.length < N){\n        this.worldFaceNormals.push( new Vec3() );\n    }\n\n    var normals = this.faceNormals,\n        worldNormals = this.worldFaceNormals;\n    for(var i=0; i!==N; i++){\n        quat.vmult( normals[i] , worldNormals[i] );\n    }\n\n    this.worldFaceNormalsNeedsUpdate = false;\n};\n\n/**\n * @method updateBoundingSphereRadius\n */\nConvexPolyhedron.prototype.updateBoundingSphereRadius = function(){\n    // Assume points are distributed with local (0,0,0) as center\n    var max2 = 0;\n    var verts = this.vertices;\n    for(var i=0, N=verts.length; i!==N; i++) {\n        var norm2 = verts[i].norm2();\n        if(norm2 > max2){\n            max2 = norm2;\n        }\n    }\n    this.boundingSphereRadius = Math.sqrt(max2);\n};\n\nvar tempWorldVertex = new Vec3();\n\n/**\n * @method calculateWorldAABB\n * @param {Vec3}        pos\n * @param {Quaternion}  quat\n * @param {Vec3}        min\n * @param {Vec3}        max\n */\nConvexPolyhedron.prototype.calculateWorldAABB = function(pos,quat,min,max){\n    var n = this.vertices.length, verts = this.vertices;\n    var minx,miny,minz,maxx,maxy,maxz;\n    for(var i=0; i<n; i++){\n        tempWorldVertex.copy(verts[i]);\n        quat.vmult(tempWorldVertex,tempWorldVertex);\n        pos.vadd(tempWorldVertex,tempWorldVertex);\n        var v = tempWorldVertex;\n        if     (v.x < minx || minx===undefined){\n            minx = v.x;\n        } else if(v.x > maxx || maxx===undefined){\n            maxx = v.x;\n        }\n\n        if     (v.y < miny || miny===undefined){\n            miny = v.y;\n        } else if(v.y > maxy || maxy===undefined){\n            maxy = v.y;\n        }\n\n        if     (v.z < minz || minz===undefined){\n            minz = v.z;\n        } else if(v.z > maxz || maxz===undefined){\n            maxz = v.z;\n        }\n    }\n    min.set(minx,miny,minz);\n    max.set(maxx,maxy,maxz);\n};\n\n/**\n * Get approximate convex volume\n * @method volume\n * @return {Number}\n */\nConvexPolyhedron.prototype.volume = function(){\n    return 4.0 * Math.PI * this.boundingSphereRadius / 3.0;\n};\n\n/**\n * Get an average of all the vertices positions\n * @method getAveragePointLocal\n * @param  {Vec3} target\n * @return {Vec3}\n */\nConvexPolyhedron.prototype.getAveragePointLocal = function(target){\n    target = target || new Vec3();\n    var n = this.vertices.length,\n        verts = this.vertices;\n    for(var i=0; i<n; i++){\n        target.vadd(verts[i],target);\n    }\n    target.mult(1/n,target);\n    return target;\n};\n\n/**\n * Transform all local points. Will change the .vertices\n * @method transformAllPoints\n * @param  {Vec3} offset\n * @param  {Quaternion} quat\n */\nConvexPolyhedron.prototype.transformAllPoints = function(offset,quat){\n    var n = this.vertices.length,\n        verts = this.vertices;\n\n    // Apply rotation\n    if(quat){\n        // Rotate vertices\n        for(var i=0; i<n; i++){\n            var v = verts[i];\n            quat.vmult(v,v);\n        }\n        // Rotate face normals\n        for(var i=0; i<this.faceNormals.length; i++){\n            var v = this.faceNormals[i];\n            quat.vmult(v,v);\n        }\n        /*\n        // Rotate edges\n        for(var i=0; i<this.uniqueEdges.length; i++){\n            var v = this.uniqueEdges[i];\n            quat.vmult(v,v);\n        }*/\n    }\n\n    // Apply offset\n    if(offset){\n        for(var i=0; i<n; i++){\n            var v = verts[i];\n            v.vadd(offset,v);\n        }\n    }\n};\n\n/**\n * Checks whether p is inside the polyhedra. Must be in local coords. The point lies outside of the convex hull of the other points if and only if the direction of all the vectors from it to those other points are on less than one half of a sphere around it.\n * @method pointIsInside\n * @param  {Vec3} p      A point given in local coordinates\n * @return {Boolean}\n */\nvar ConvexPolyhedron_pointIsInside = new Vec3();\nvar ConvexPolyhedron_vToP = new Vec3();\nvar ConvexPolyhedron_vToPointInside = new Vec3();\nConvexPolyhedron.prototype.pointIsInside = function(p){\n    var n = this.vertices.length,\n        verts = this.vertices,\n        faces = this.faces,\n        normals = this.faceNormals;\n    var positiveResult = null;\n    var N = this.faces.length;\n    var pointInside = ConvexPolyhedron_pointIsInside;\n    this.getAveragePointLocal(pointInside);\n    for(var i=0; i<N; i++){\n        var numVertices = this.faces[i].length;\n        var n = normals[i];\n        var v = verts[faces[i][0]]; // We only need one point in the face\n\n        // This dot product determines which side of the edge the point is\n        var vToP = ConvexPolyhedron_vToP;\n        p.vsub(v,vToP);\n        var r1 = n.dot(vToP);\n\n        var vToPointInside = ConvexPolyhedron_vToPointInside;\n        pointInside.vsub(v,vToPointInside);\n        var r2 = n.dot(vToPointInside);\n\n        if((r1<0 && r2>0) || (r1>0 && r2<0)){\n            return false; // Encountered some other sign. Exit.\n        } else {\n        }\n    }\n\n    // If we got here, all dot products were of the same sign.\n    return positiveResult ? 1 : -1;\n};\n\n/**\n * Get max and min dot product of a convex hull at position (pos,quat) projected onto an axis. Results are saved in the array maxmin.\n * @static\n * @method project\n * @param {ConvexPolyhedron} hull\n * @param {Vec3} axis\n * @param {Vec3} pos\n * @param {Quaternion} quat\n * @param {array} result result[0] and result[1] will be set to maximum and minimum, respectively.\n */\nvar project_worldVertex = new Vec3();\nvar project_localAxis = new Vec3();\nvar project_localOrigin = new Vec3();\nConvexPolyhedron.project = function(hull, axis, pos, quat, result){\n    var n = hull.vertices.length,\n        worldVertex = project_worldVertex,\n        localAxis = project_localAxis,\n        max = 0,\n        min = 0,\n        localOrigin = project_localOrigin,\n        vs = hull.vertices;\n\n    localOrigin.setZero();\n\n    // Transform the axis to local\n    Transform.vectorToLocalFrame(pos, quat, axis, localAxis);\n    Transform.pointToLocalFrame(pos, quat, localOrigin, localOrigin);\n    var add = localOrigin.dot(localAxis);\n\n    min = max = vs[0].dot(localAxis);\n\n    for(var i = 1; i < n; i++){\n        var val = vs[i].dot(localAxis);\n\n        if(val > max){\n            max = val;\n        }\n\n        if(val < min){\n            min = val;\n        }\n    }\n\n    min -= add;\n    max -= add;\n\n    if(min > max){\n        // Inconsistent - swap\n        var temp = min;\n        min = max;\n        max = temp;\n    }\n    // Output\n    result[0] = max;\n    result[1] = min;\n};\n\n},{\"../math/Quaternion\":28,\"../math/Transform\":29,\"../math/Vec3\":30,\"./Shape\":43}],39:[function(_dereq_,module,exports){\nmodule.exports = Cylinder;\n\nvar Shape = _dereq_('./Shape');\nvar Vec3 = _dereq_('../math/Vec3');\nvar Quaternion = _dereq_('../math/Quaternion');\nvar ConvexPolyhedron = _dereq_('./ConvexPolyhedron');\n\n/**\n * @class Cylinder\n * @constructor\n * @extends ConvexPolyhedron\n * @author schteppe / https://github.com/schteppe\n * @param {Number} radiusTop\n * @param {Number} radiusBottom\n * @param {Number} height\n * @param {Number} numSegments The number of segments to build the cylinder out of\n */\nfunction Cylinder( radiusTop, radiusBottom, height , numSegments ) {\n    var N = numSegments,\n        verts = [],\n        axes = [],\n        faces = [],\n        bottomface = [],\n        topface = [],\n        cos = Math.cos,\n        sin = Math.sin;\n\n    // First bottom point\n    verts.push(new Vec3(radiusBottom*cos(0),\n                               radiusBottom*sin(0),\n                               -height*0.5));\n    bottomface.push(0);\n\n    // First top point\n    verts.push(new Vec3(radiusTop*cos(0),\n                               radiusTop*sin(0),\n                               height*0.5));\n    topface.push(1);\n\n    for(var i=0; i<N; i++){\n        var theta = 2*Math.PI/N * (i+1);\n        var thetaN = 2*Math.PI/N * (i+0.5);\n        if(i<N-1){\n            // Bottom\n            verts.push(new Vec3(radiusBottom*cos(theta),\n                                       radiusBottom*sin(theta),\n                                       -height*0.5));\n            bottomface.push(2*i+2);\n            // Top\n            verts.push(new Vec3(radiusTop*cos(theta),\n                                       radiusTop*sin(theta),\n                                       height*0.5));\n            topface.push(2*i+3);\n\n            // Face\n            faces.push([2*i+2, 2*i+3, 2*i+1,2*i]);\n        } else {\n            faces.push([0,1, 2*i+1, 2*i]); // Connect\n        }\n\n        // Axis: we can cut off half of them if we have even number of segments\n        if(N % 2 === 1 || i < N / 2){\n            axes.push(new Vec3(cos(thetaN), sin(thetaN), 0));\n        }\n    }\n    faces.push(topface);\n    axes.push(new Vec3(0,0,1));\n\n    // Reorder bottom face\n    var temp = [];\n    for(var i=0; i<bottomface.length; i++){\n        temp.push(bottomface[bottomface.length - i - 1]);\n    }\n    faces.push(temp);\n\n    this.type = Shape.types.CONVEXPOLYHEDRON;\n    ConvexPolyhedron.call( this, verts, faces, axes );\n}\n\nCylinder.prototype = new ConvexPolyhedron();\n\n},{\"../math/Quaternion\":28,\"../math/Vec3\":30,\"./ConvexPolyhedron\":38,\"./Shape\":43}],40:[function(_dereq_,module,exports){\nvar Shape = _dereq_('./Shape');\nvar ConvexPolyhedron = _dereq_('./ConvexPolyhedron');\nvar Vec3 = _dereq_('../math/Vec3');\nvar Utils = _dereq_('../utils/Utils');\n\nmodule.exports = Heightfield;\n\n/**\n * Heightfield shape class. Height data is given as an array. These data points are spread out evenly with a given distance.\n * @class Heightfield\n * @extends Shape\n * @constructor\n * @param {Array} data An array of Y values that will be used to construct the terrain.\n * @param {object} options\n * @param {Number} [options.minValue] Minimum value of the data points in the data array. Will be computed automatically if not given.\n * @param {Number} [options.maxValue] Maximum value.\n * @param {Number} [options.elementSize=0.1] World spacing between the data points in X direction.\n * @todo Should be possible to use along all axes, not just y\n *\n * @example\n *     // Generate some height data (y-values).\n *     var data = [];\n *     for(var i = 0; i < 1000; i++){\n *         var y = 0.5 * Math.cos(0.2 * i);\n *         data.push(y);\n *     }\n *\n *     // Create the heightfield shape\n *     var heightfieldShape = new Heightfield(data, {\n *         elementSize: 1 // Distance between the data points in X and Y directions\n *     });\n *     var heightfieldBody = new Body();\n *     heightfieldBody.addShape(heightfieldShape);\n *     world.addBody(heightfieldBody);\n */\nfunction Heightfield(data, options){\n    options = Utils.defaults(options, {\n        maxValue : null,\n        minValue : null,\n        elementSize : 1\n    });\n\n    /**\n     * An array of numbers, or height values, that are spread out along the x axis.\n     * @property {array} data\n     */\n    this.data = data;\n\n    /**\n     * Max value of the data\n     * @property {number} maxValue\n     */\n    this.maxValue = options.maxValue;\n\n    /**\n     * Max value of the data\n     * @property {number} minValue\n     */\n    this.minValue = options.minValue;\n\n    /**\n     * The width of each element\n     * @property {number} elementSize\n     * @todo elementSizeX and Y\n     */\n    this.elementSize = options.elementSize;\n\n    if(options.minValue === null){\n        this.updateMinValue();\n    }\n    if(options.maxValue === null){\n        this.updateMaxValue();\n    }\n\n    this.cacheEnabled = true;\n\n    Shape.call(this);\n\n    this.pillarConvex = new ConvexPolyhedron();\n    this.pillarOffset = new Vec3();\n\n    this.type = Shape.types.HEIGHTFIELD;\n    this.updateBoundingSphereRadius();\n\n    // \"i_j_isUpper\" => { convex: ..., offset: ... }\n    // for example:\n    // _cachedPillars[\"0_2_1\"]\n    this._cachedPillars = {};\n}\nHeightfield.prototype = new Shape();\n\n/**\n * Call whenever you change the data array.\n * @method update\n */\nHeightfield.prototype.update = function(){\n    this._cachedPillars = {};\n};\n\n/**\n * Update the .minValue property\n * @method updateMinValue\n */\nHeightfield.prototype.updateMinValue = function(){\n    var data = this.data;\n    var minValue = data[0][0];\n    for(var i=0; i !== data.length; i++){\n        for(var j=0; j !== data[i].length; j++){\n            var v = data[i][j];\n            if(v < minValue){\n                minValue = v;\n            }\n        }\n    }\n    this.minValue = minValue;\n};\n\n/**\n * Update the .maxValue property\n * @method updateMaxValue\n */\nHeightfield.prototype.updateMaxValue = function(){\n    var data = this.data;\n    var maxValue = data[0][0];\n    for(var i=0; i !== data.length; i++){\n        for(var j=0; j !== data[i].length; j++){\n            var v = data[i][j];\n            if(v > maxValue){\n                maxValue = v;\n            }\n        }\n    }\n    this.maxValue = maxValue;\n};\n\n/**\n * Set the height value at an index. Don't forget to update maxValue and minValue after you're done.\n * @method setHeightValueAtIndex\n * @param {integer} xi\n * @param {integer} yi\n * @param {number} value\n */\nHeightfield.prototype.setHeightValueAtIndex = function(xi, yi, value){\n    var data = this.data;\n    data[xi][yi] = value;\n\n    // Invalidate cache\n    this.clearCachedConvexTrianglePillar(xi, yi, false);\n    if(xi > 0){\n        this.clearCachedConvexTrianglePillar(xi - 1, yi, true);\n        this.clearCachedConvexTrianglePillar(xi - 1, yi, false);\n    }\n    if(yi > 0){\n        this.clearCachedConvexTrianglePillar(xi, yi - 1, true);\n        this.clearCachedConvexTrianglePillar(xi, yi - 1, false);\n    }\n    if(yi > 0 && xi > 0){\n        this.clearCachedConvexTrianglePillar(xi - 1, yi - 1, true);\n    }\n};\n\n/**\n * Get max/min in a rectangle in the matrix data\n * @method getRectMinMax\n * @param  {integer} iMinX\n * @param  {integer} iMinY\n * @param  {integer} iMaxX\n * @param  {integer} iMaxY\n * @param  {array} [result] An array to store the results in.\n * @return {array} The result array, if it was passed in. Minimum will be at position 0 and max at 1.\n */\nHeightfield.prototype.getRectMinMax = function (iMinX, iMinY, iMaxX, iMaxY, result) {\n    result = result || [];\n\n    // Get max and min of the data\n    var data = this.data,\n        max = this.minValue; // Set first value\n    for(var i = iMinX; i <= iMaxX; i++){\n        for(var j = iMinY; j <= iMaxY; j++){\n            var height = data[i][j];\n            if(height > max){\n                max = height;\n            }\n        }\n    }\n\n    result[0] = this.minValue;\n    result[1] = max;\n};\n\n/**\n * Get the index of a local position on the heightfield. The indexes indicate the rectangles, so if your terrain is made of N x N height data points, you will have rectangle indexes ranging from 0 to N-1.\n * @method getIndexOfPosition\n * @param  {number} x\n * @param  {number} y\n * @param  {array} result Two-element array\n * @param  {boolean} clamp If the position should be clamped to the heightfield edge.\n * @return {boolean}\n */\nHeightfield.prototype.getIndexOfPosition = function (x, y, result, clamp) {\n\n    // Get the index of the data points to test against\n    var w = this.elementSize;\n    var data = this.data;\n    var xi = Math.floor(x / w);\n    var yi = Math.floor(y / w);\n\n    result[0] = xi;\n    result[1] = yi;\n\n    if(clamp){\n        // Clamp index to edges\n        if(xi < 0){ xi = 0; }\n        if(yi < 0){ yi = 0; }\n        if(xi >= data.length - 1){ xi = data.length - 1; }\n        if(yi >= data[0].length - 1){ yi = data[0].length - 1; }\n    }\n\n    // Bail out if we are out of the terrain\n    if(xi < 0 || yi < 0 || xi >= data.length-1 || yi >= data[0].length-1){\n        return false;\n    }\n\n    return true;\n};\n\nHeightfield.prototype.getHeightAt = function(x, y, edgeClamp){\n    var idx = [];\n    this.getIndexOfPosition(x, y, idx, edgeClamp);\n\n    // TODO: get upper or lower triangle, then use barycentric interpolation to get the height in the triangle.\n    var minmax = [];\n    this.getRectMinMax(idx[0], idx[1] + 1, idx[0], idx[1] + 1, minmax);\n\n    return (minmax[0] + minmax[1]) / 2; // average\n};\n\nHeightfield.prototype.getCacheConvexTrianglePillarKey = function(xi, yi, getUpperTriangle){\n    return xi + '_' + yi + '_' + (getUpperTriangle ? 1 : 0);\n};\n\nHeightfield.prototype.getCachedConvexTrianglePillar = function(xi, yi, getUpperTriangle){\n    return this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)];\n};\n\nHeightfield.prototype.setCachedConvexTrianglePillar = function(xi, yi, getUpperTriangle, convex, offset){\n    this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)] = {\n        convex: convex,\n        offset: offset\n    };\n};\n\nHeightfield.prototype.clearCachedConvexTrianglePillar = function(xi, yi, getUpperTriangle){\n    delete this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)];\n};\n\n/**\n * Get a triangle in the terrain in the form of a triangular convex shape.\n * @method getConvexTrianglePillar\n * @param  {integer} i\n * @param  {integer} j\n * @param  {boolean} getUpperTriangle\n */\nHeightfield.prototype.getConvexTrianglePillar = function(xi, yi, getUpperTriangle){\n    var result = this.pillarConvex;\n    var offsetResult = this.pillarOffset;\n\n    if(this.cacheEnabled){\n        var data = this.getCachedConvexTrianglePillar(xi, yi, getUpperTriangle);\n        if(data){\n            this.pillarConvex = data.convex;\n            this.pillarOffset = data.offset;\n            return;\n        }\n\n        result = new ConvexPolyhedron();\n        offsetResult = new Vec3();\n\n        this.pillarConvex = result;\n        this.pillarOffset = offsetResult;\n    }\n\n    var data = this.data;\n    var elementSize = this.elementSize;\n    var faces = result.faces;\n\n    // Reuse verts if possible\n    result.vertices.length = 6;\n    for (var i = 0; i < 6; i++) {\n        if(!result.vertices[i]){\n            result.vertices[i] = new Vec3();\n        }\n    }\n\n    // Reuse faces if possible\n    faces.length = 5;\n    for (var i = 0; i < 5; i++) {\n        if(!faces[i]){\n            faces[i] = [];\n        }\n    }\n\n    var verts = result.vertices;\n\n    var h = (Math.min(\n        data[xi][yi],\n        data[xi+1][yi],\n        data[xi][yi+1],\n        data[xi+1][yi+1]\n    ) - this.minValue ) / 2 + this.minValue;\n\n    if (!getUpperTriangle) {\n\n        // Center of the triangle pillar - all polygons are given relative to this one\n        offsetResult.set(\n            (xi + 0.25) * elementSize, // sort of center of a triangle\n            (yi + 0.25) * elementSize,\n            h // vertical center\n        );\n\n        // Top triangle verts\n        verts[0].set(\n            -0.25 * elementSize,\n            -0.25 * elementSize,\n            data[xi][yi] - h\n        );\n        verts[1].set(\n            0.75 * elementSize,\n            -0.25 * elementSize,\n            data[xi + 1][yi] - h\n        );\n        verts[2].set(\n            -0.25 * elementSize,\n            0.75 * elementSize,\n            data[xi][yi + 1] - h\n        );\n\n        // bottom triangle verts\n        verts[3].set(\n            -0.25 * elementSize,\n            -0.25 * elementSize,\n            -h-1\n        );\n        verts[4].set(\n            0.75 * elementSize,\n            -0.25 * elementSize,\n            -h-1\n        );\n        verts[5].set(\n            -0.25 * elementSize,\n            0.75  * elementSize,\n            -h-1\n        );\n\n        // top triangle\n        faces[0][0] = 0;\n        faces[0][1] = 1;\n        faces[0][2] = 2;\n\n        // bottom triangle\n        faces[1][0] = 5;\n        faces[1][1] = 4;\n        faces[1][2] = 3;\n\n        // -x facing quad\n        faces[2][0] = 0;\n        faces[2][1] = 2;\n        faces[2][2] = 5;\n        faces[2][3] = 3;\n\n        // -y facing quad\n        faces[3][0] = 1;\n        faces[3][1] = 0;\n        faces[3][2] = 3;\n        faces[3][3] = 4;\n\n        // +xy facing quad\n        faces[4][0] = 4;\n        faces[4][1] = 5;\n        faces[4][2] = 2;\n        faces[4][3] = 1;\n\n\n    } else {\n\n        // Center of the triangle pillar - all polygons are given relative to this one\n        offsetResult.set(\n            (xi + 0.75) * elementSize, // sort of center of a triangle\n            (yi + 0.75) * elementSize,\n            h // vertical center\n        );\n\n        // Top triangle verts\n        verts[0].set(\n            0.25 * elementSize,\n            0.25 * elementSize,\n            data[xi + 1][yi + 1] - h\n        );\n        verts[1].set(\n            -0.75 * elementSize,\n            0.25 * elementSize,\n            data[xi][yi + 1] - h\n        );\n        verts[2].set(\n            0.25 * elementSize,\n            -0.75 * elementSize,\n            data[xi + 1][yi] - h\n        );\n\n        // bottom triangle verts\n        verts[3].set(\n            0.25 * elementSize,\n            0.25 * elementSize,\n            - h-1\n        );\n        verts[4].set(\n            -0.75 * elementSize,\n            0.25 * elementSize,\n            - h-1\n        );\n        verts[5].set(\n            0.25 * elementSize,\n            -0.75 * elementSize,\n            - h-1\n        );\n\n        // Top triangle\n        faces[0][0] = 0;\n        faces[0][1] = 1;\n        faces[0][2] = 2;\n\n        // bottom triangle\n        faces[1][0] = 5;\n        faces[1][1] = 4;\n        faces[1][2] = 3;\n\n        // +x facing quad\n        faces[2][0] = 2;\n        faces[2][1] = 5;\n        faces[2][2] = 3;\n        faces[2][3] = 0;\n\n        // +y facing quad\n        faces[3][0] = 3;\n        faces[3][1] = 4;\n        faces[3][2] = 1;\n        faces[3][3] = 0;\n\n        // -xy facing quad\n        faces[4][0] = 1;\n        faces[4][1] = 4;\n        faces[4][2] = 5;\n        faces[4][3] = 2;\n    }\n\n    result.computeNormals();\n    result.computeEdges();\n    result.updateBoundingSphereRadius();\n\n    this.setCachedConvexTrianglePillar(xi, yi, getUpperTriangle, result, offsetResult);\n};\n\nHeightfield.prototype.calculateLocalInertia = function(mass, target){\n    target = target || new Vec3();\n    target.set(0, 0, 0);\n    return target;\n};\n\nHeightfield.prototype.volume = function(){\n    return Number.MAX_VALUE; // The terrain is infinite\n};\n\nHeightfield.prototype.calculateWorldAABB = function(pos, quat, min, max){\n    // TODO: do it properly\n    min.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n    max.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n};\n\nHeightfield.prototype.updateBoundingSphereRadius = function(){\n    // Use the bounding box of the min/max values\n    var data = this.data,\n        s = this.elementSize;\n    this.boundingSphereRadius = new Vec3(data.length * s, data[0].length * s, Math.max(Math.abs(this.maxValue), Math.abs(this.minValue))).norm();\n};\n\n},{\"../math/Vec3\":30,\"../utils/Utils\":53,\"./ConvexPolyhedron\":38,\"./Shape\":43}],41:[function(_dereq_,module,exports){\nmodule.exports = Particle;\n\nvar Shape = _dereq_('./Shape');\nvar Vec3 = _dereq_('../math/Vec3');\n\n/**\n * Particle shape.\n * @class Particle\n * @constructor\n * @author schteppe\n * @extends Shape\n */\nfunction Particle(){\n    Shape.call(this);\n\n    this.type = Shape.types.PARTICLE;\n}\nParticle.prototype = new Shape();\nParticle.prototype.constructor = Particle;\n\n/**\n * @method calculateLocalInertia\n * @param  {Number} mass\n * @param  {Vec3} target\n * @return {Vec3}\n */\nParticle.prototype.calculateLocalInertia = function(mass,target){\n    target = target || new Vec3();\n    target.set(0, 0, 0);\n    return target;\n};\n\nParticle.prototype.volume = function(){\n    return 0;\n};\n\nParticle.prototype.updateBoundingSphereRadius = function(){\n    this.boundingSphereRadius = 0;\n};\n\nParticle.prototype.calculateWorldAABB = function(pos,quat,min,max){\n    // Get each axis max\n    min.copy(pos);\n    max.copy(pos);\n};\n\n},{\"../math/Vec3\":30,\"./Shape\":43}],42:[function(_dereq_,module,exports){\nmodule.exports = Plane;\n\nvar Shape = _dereq_('./Shape');\nvar Vec3 = _dereq_('../math/Vec3');\n\n/**\n * A plane, facing in the Z direction. The plane has its surface at z=0 and everything below z=0 is assumed to be solid plane. To make the plane face in some other direction than z, you must put it inside a RigidBody and rotate that body. See the demos.\n * @class Plane\n * @constructor\n * @extends Shape\n * @author schteppe\n */\nfunction Plane(){\n    Shape.call(this);\n    this.type = Shape.types.PLANE;\n\n    // World oriented normal\n    this.worldNormal = new Vec3();\n    this.worldNormalNeedsUpdate = true;\n\n    this.boundingSphereRadius = Number.MAX_VALUE;\n}\nPlane.prototype = new Shape();\nPlane.prototype.constructor = Plane;\n\nPlane.prototype.computeWorldNormal = function(quat){\n    var n = this.worldNormal;\n    n.set(0,0,1);\n    quat.vmult(n,n);\n    this.worldNormalNeedsUpdate = false;\n};\n\nPlane.prototype.calculateLocalInertia = function(mass,target){\n    target = target || new Vec3();\n    return target;\n};\n\nPlane.prototype.volume = function(){\n    return Number.MAX_VALUE; // The plane is infinite...\n};\n\nvar tempNormal = new Vec3();\nPlane.prototype.calculateWorldAABB = function(pos, quat, min, max){\n    // The plane AABB is infinite, except if the normal is pointing along any axis\n    tempNormal.set(0,0,1); // Default plane normal is z\n    quat.vmult(tempNormal,tempNormal);\n    var maxVal = Number.MAX_VALUE;\n    min.set(-maxVal, -maxVal, -maxVal);\n    max.set(maxVal, maxVal, maxVal);\n\n    if(tempNormal.x === 1){ max.x = pos.x; }\n    if(tempNormal.y === 1){ max.y = pos.y; }\n    if(tempNormal.z === 1){ max.z = pos.z; }\n\n    if(tempNormal.x === -1){ min.x = pos.x; }\n    if(tempNormal.y === -1){ min.y = pos.y; }\n    if(tempNormal.z === -1){ min.z = pos.z; }\n};\n\nPlane.prototype.updateBoundingSphereRadius = function(){\n    this.boundingSphereRadius = Number.MAX_VALUE;\n};\n},{\"../math/Vec3\":30,\"./Shape\":43}],43:[function(_dereq_,module,exports){\nmodule.exports = Shape;\n\nvar Shape = _dereq_('./Shape');\nvar Vec3 = _dereq_('../math/Vec3');\nvar Quaternion = _dereq_('../math/Quaternion');\nvar Material = _dereq_('../material/Material');\n\n/**\n * Base class for shapes\n * @class Shape\n * @constructor\n * @author schteppe\n * @todo Should have a mechanism for caching bounding sphere radius instead of calculating it each time\n */\nfunction Shape(){\n\n    /**\n     * Identifyer of the Shape.\n     * @property {number} id\n     */\n    this.id = Shape.idCounter++;\n\n    /**\n     * The type of this shape. Must be set to an int > 0 by subclasses.\n     * @property type\n     * @type {Number}\n     * @see Shape.types\n     */\n    this.type = 0;\n\n    /**\n     * The local bounding sphere radius of this shape.\n     * @property {Number} boundingSphereRadius\n     */\n    this.boundingSphereRadius = 0;\n\n    /**\n     * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled.\n     * @property {boolean} collisionResponse\n     */\n    this.collisionResponse = true;\n\n    /**\n     * @property {Material} material\n     */\n    this.material = null;\n}\nShape.prototype.constructor = Shape;\n\n/**\n * Computes the bounding sphere radius. The result is stored in the property .boundingSphereRadius\n * @method updateBoundingSphereRadius\n * @return {Number}\n */\nShape.prototype.updateBoundingSphereRadius = function(){\n    throw \"computeBoundingSphereRadius() not implemented for shape type \"+this.type;\n};\n\n/**\n * Get the volume of this shape\n * @method volume\n * @return {Number}\n */\nShape.prototype.volume = function(){\n    throw \"volume() not implemented for shape type \"+this.type;\n};\n\n/**\n * Calculates the inertia in the local frame for this shape.\n * @method calculateLocalInertia\n * @return {Vec3}\n * @see http://en.wikipedia.org/wiki/List_of_moments_of_inertia\n */\nShape.prototype.calculateLocalInertia = function(mass,target){\n    throw \"calculateLocalInertia() not implemented for shape type \"+this.type;\n};\n\nShape.idCounter = 0;\n\n/**\n * The available shape types.\n * @static\n * @property types\n * @type {Object}\n */\nShape.types = {\n    SPHERE:1,\n    PLANE:2,\n    BOX:4,\n    COMPOUND:8,\n    CONVEXPOLYHEDRON:16,\n    HEIGHTFIELD:32,\n    PARTICLE:64,\n    CYLINDER:128,\n    TRIMESH:256\n};\n\n\n},{\"../material/Material\":25,\"../math/Quaternion\":28,\"../math/Vec3\":30,\"./Shape\":43}],44:[function(_dereq_,module,exports){\nmodule.exports = Sphere;\n\nvar Shape = _dereq_('./Shape');\nvar Vec3 = _dereq_('../math/Vec3');\n\n/**\n * Spherical shape\n * @class Sphere\n * @constructor\n * @extends Shape\n * @param {Number} radius The radius of the sphere, a non-negative number.\n * @author schteppe / http://github.com/schteppe\n */\nfunction Sphere(radius){\n    Shape.call(this);\n\n    /**\n     * @property {Number} radius\n     */\n    this.radius = radius!==undefined ? Number(radius) : 1.0;\n    this.type = Shape.types.SPHERE;\n\n    if(this.radius < 0){\n        throw new Error('The sphere radius cannot be negative.');\n    }\n\n    this.updateBoundingSphereRadius();\n}\nSphere.prototype = new Shape();\nSphere.prototype.constructor = Sphere;\n\nSphere.prototype.calculateLocalInertia = function(mass,target){\n    target = target || new Vec3();\n    var I = 2.0*mass*this.radius*this.radius/5.0;\n    target.x = I;\n    target.y = I;\n    target.z = I;\n    return target;\n};\n\nSphere.prototype.volume = function(){\n    return 4.0 * Math.PI * this.radius / 3.0;\n};\n\nSphere.prototype.updateBoundingSphereRadius = function(){\n    this.boundingSphereRadius = this.radius;\n};\n\nSphere.prototype.calculateWorldAABB = function(pos,quat,min,max){\n    var r = this.radius;\n    var axes = ['x','y','z'];\n    for(var i=0; i<axes.length; i++){\n        var ax = axes[i];\n        min[ax] = pos[ax] - r;\n        max[ax] = pos[ax] + r;\n    }\n};\n\n},{\"../math/Vec3\":30,\"./Shape\":43}],45:[function(_dereq_,module,exports){\nmodule.exports = Trimesh;\n\nvar Shape = _dereq_('./Shape');\nvar Vec3 = _dereq_('../math/Vec3');\nvar Quaternion = _dereq_('../math/Quaternion');\nvar Transform = _dereq_('../math/Transform');\nvar AABB = _dereq_('../collision/AABB');\nvar Octree = _dereq_('../utils/Octree');\n\n/**\n * @class Trimesh\n * @constructor\n * @param {array} vertices\n * @param {array} indices\n * @extends Shape\n * @example\n *     // How to make a mesh with a single triangle\n *     var vertices = [\n *         0, 0, 0, // vertex 0\n *         1, 0, 0, // vertex 1\n *         0, 1, 0  // vertex 2\n *     ];\n *     var indices = [\n *         0, 1, 2  // triangle 0\n *     ];\n *     var trimeshShape = new Trimesh(vertices, indices);\n */\nfunction Trimesh(vertices, indices) {\n    Shape.call(this);\n    this.type = Shape.types.TRIMESH;\n\n    /**\n     * @property vertices\n     * @type {Array}\n     */\n    this.vertices = new Float32Array(vertices);\n\n    /**\n     * Array of integers, indicating which vertices each triangle consists of. The length of this array is thus 3 times the number of triangles.\n     * @property indices\n     * @type {Array}\n     */\n    this.indices = new Int16Array(indices);\n\n    /**\n     * The normals data.\n     * @property normals\n     * @type {Array}\n     */\n    this.normals = new Float32Array(indices.length);\n\n    /**\n     * The local AABB of the mesh.\n     * @property aabb\n     * @type {Array}\n     */\n    this.aabb = new AABB();\n\n    /**\n     * References to vertex pairs, making up all unique edges in the trimesh.\n     * @property {array} edges\n     */\n    this.edges = null;\n\n    /**\n     * Local scaling of the mesh. Use .setScale() to set it.\n     * @property {Vec3} scale\n     */\n    this.scale = new Vec3(1, 1, 1);\n\n    /**\n     * The indexed triangles. Use .updateTree() to update it.\n     * @property {Octree} tree\n     */\n    this.tree = new Octree();\n\n    this.updateEdges();\n    this.updateNormals();\n    this.updateAABB();\n    this.updateBoundingSphereRadius();\n    this.updateTree();\n}\nTrimesh.prototype = new Shape();\nTrimesh.prototype.constructor = Trimesh;\n\nvar computeNormals_n = new Vec3();\n\n/**\n * @method updateTree\n */\nTrimesh.prototype.updateTree = function(){\n    var tree = this.tree;\n\n    tree.reset();\n    tree.aabb.copy(this.aabb);\n    var scale = this.scale; // The local mesh AABB is scaled, but the octree AABB should be unscaled\n    tree.aabb.lowerBound.x *= 1 / scale.x;\n    tree.aabb.lowerBound.y *= 1 / scale.y;\n    tree.aabb.lowerBound.z *= 1 / scale.z;\n    tree.aabb.upperBound.x *= 1 / scale.x;\n    tree.aabb.upperBound.y *= 1 / scale.y;\n    tree.aabb.upperBound.z *= 1 / scale.z;\n\n    // Insert all triangles\n    var triangleAABB = new AABB();\n    var a = new Vec3();\n    var b = new Vec3();\n    var c = new Vec3();\n    var points = [a, b, c];\n    for (var i = 0; i < this.indices.length / 3; i++) {\n        //this.getTriangleVertices(i, a, b, c);\n\n        // Get unscaled triangle verts\n        var i3 = i * 3;\n        this._getUnscaledVertex(this.indices[i3], a);\n        this._getUnscaledVertex(this.indices[i3 + 1], b);\n        this._getUnscaledVertex(this.indices[i3 + 2], c);\n\n        triangleAABB.setFromPoints(points);\n        tree.insert(triangleAABB, i);\n    }\n    tree.removeEmptyNodes();\n};\n\nvar unscaledAABB = new AABB();\n\n/**\n * Get triangles in a local AABB from the trimesh.\n * @method getTrianglesInAABB\n * @param  {AABB} aabb\n * @param  {array} result An array of integers, referencing the queried triangles.\n */\nTrimesh.prototype.getTrianglesInAABB = function(aabb, result){\n    unscaledAABB.copy(aabb);\n\n    // Scale it to local\n    var scale = this.scale;\n    var isx = scale.x;\n    var isy = scale.y;\n    var isz = scale.z;\n    var l = unscaledAABB.lowerBound;\n    var u = unscaledAABB.upperBound;\n    l.x /= isx;\n    l.y /= isy;\n    l.z /= isz;\n    u.x /= isx;\n    u.y /= isy;\n    u.z /= isz;\n\n    return this.tree.aabbQuery(unscaledAABB, result);\n};\n\n/**\n * @method setScale\n * @param {Vec3} scale\n */\nTrimesh.prototype.setScale = function(scale){\n    var wasUniform = this.scale.x === this.scale.y === this.scale.z;\n    var isUniform = scale.x === scale.y === scale.z;\n\n    if(!(wasUniform && isUniform)){\n        // Non-uniform scaling. Need to update normals.\n        this.updateNormals();\n    }\n    this.scale.copy(scale);\n    this.updateAABB();\n    this.updateBoundingSphereRadius();\n};\n\n/**\n * Compute the normals of the faces. Will save in the .normals array.\n * @method updateNormals\n */\nTrimesh.prototype.updateNormals = function(){\n    var n = computeNormals_n;\n\n    // Generate normals\n    var normals = this.normals;\n    for(var i=0; i < this.indices.length / 3; i++){\n        var i3 = i * 3;\n\n        var a = this.indices[i3],\n            b = this.indices[i3 + 1],\n            c = this.indices[i3 + 2];\n\n        this.getVertex(a, va);\n        this.getVertex(b, vb);\n        this.getVertex(c, vc);\n\n        Trimesh.computeNormal(vb, va, vc, n);\n\n        normals[i3] = n.x;\n        normals[i3 + 1] = n.y;\n        normals[i3 + 2] = n.z;\n    }\n};\n\n/**\n * Update the .edges property\n * @method updateEdges\n */\nTrimesh.prototype.updateEdges = function(){\n    var edges = {};\n    var add = function(indexA, indexB){\n        var key = a < b ? a + '_' + b : b + '_' + a;\n        edges[key] = true;\n    };\n    for(var i=0; i < this.indices.length / 3; i++){\n        var i3 = i * 3;\n        var a = this.indices[i3],\n            b = this.indices[i3 + 1],\n            c = this.indices[i3 + 2];\n        add(a,b);\n        add(b,c);\n        add(c,a);\n    }\n    var keys = Object.keys(edges);\n    this.edges = new Int16Array(keys.length * 2);\n    for (var i = 0; i < keys.length; i++) {\n        var indices = keys[i].split('_');\n        this.edges[2 * i] = parseInt(indices[0], 10);\n        this.edges[2 * i + 1] = parseInt(indices[1], 10);\n    }\n};\n\n/**\n * Get an edge vertex\n * @method getEdgeVertex\n * @param  {number} edgeIndex\n * @param  {number} firstOrSecond 0 or 1, depending on which one of the vertices you need.\n * @param  {Vec3} vertexStore Where to store the result\n */\nTrimesh.prototype.getEdgeVertex = function(edgeIndex, firstOrSecond, vertexStore){\n    var vertexIndex = this.edges[edgeIndex * 2 + (firstOrSecond ? 1 : 0)];\n    this.getVertex(vertexIndex, vertexStore);\n};\n\nvar getEdgeVector_va = new Vec3();\nvar getEdgeVector_vb = new Vec3();\n\n/**\n * Get a vector along an edge.\n * @method getEdgeVector\n * @param  {number} edgeIndex\n * @param  {Vec3} vectorStore\n */\nTrimesh.prototype.getEdgeVector = function(edgeIndex, vectorStore){\n    var va = getEdgeVector_va;\n    var vb = getEdgeVector_vb;\n    this.getEdgeVertex(edgeIndex, 0, va);\n    this.getEdgeVertex(edgeIndex, 1, vb);\n    vb.vsub(va, vectorStore);\n};\n\n/**\n * Get face normal given 3 vertices\n * @static\n * @method computeNormal\n * @param {Vec3} va\n * @param {Vec3} vb\n * @param {Vec3} vc\n * @param {Vec3} target\n */\nvar cb = new Vec3();\nvar ab = new Vec3();\nTrimesh.computeNormal = function ( va, vb, vc, target ) {\n    vb.vsub(va,ab);\n    vc.vsub(vb,cb);\n    cb.cross(ab,target);\n    if ( !target.isZero() ) {\n        target.normalize();\n    }\n};\n\nvar va = new Vec3();\nvar vb = new Vec3();\nvar vc = new Vec3();\n\n/**\n * Get vertex i.\n * @method getVertex\n * @param  {number} i\n * @param  {Vec3} out\n * @return {Vec3} The \"out\" vector object\n */\nTrimesh.prototype.getVertex = function(i, out){\n    var scale = this.scale;\n    this._getUnscaledVertex(i, out);\n    out.x *= scale.x;\n    out.y *= scale.y;\n    out.z *= scale.z;\n    return out;\n};\n\n/**\n * Get raw vertex i\n * @private\n * @method _getUnscaledVertex\n * @param  {number} i\n * @param  {Vec3} out\n * @return {Vec3} The \"out\" vector object\n */\nTrimesh.prototype._getUnscaledVertex = function(i, out){\n    var i3 = i * 3;\n    var vertices = this.vertices;\n    return out.set(\n        vertices[i3],\n        vertices[i3 + 1],\n        vertices[i3 + 2]\n    );\n};\n\n/**\n * Get a vertex from the trimesh,transformed by the given position and quaternion.\n * @method getWorldVertex\n * @param  {number} i\n * @param  {Vec3} pos\n * @param  {Quaternion} quat\n * @param  {Vec3} out\n * @return {Vec3} The \"out\" vector object\n */\nTrimesh.prototype.getWorldVertex = function(i, pos, quat, out){\n    this.getVertex(i, out);\n    Transform.pointToWorldFrame(pos, quat, out, out);\n    return out;\n};\n\n/**\n * Get the three vertices for triangle i.\n * @method getTriangleVertices\n * @param  {number} i\n * @param  {Vec3} a\n * @param  {Vec3} b\n * @param  {Vec3} c\n */\nTrimesh.prototype.getTriangleVertices = function(i, a, b, c){\n    var i3 = i * 3;\n    this.getVertex(this.indices[i3], a);\n    this.getVertex(this.indices[i3 + 1], b);\n    this.getVertex(this.indices[i3 + 2], c);\n};\n\n/**\n * Compute the normal of triangle i.\n * @method getNormal\n * @param  {Number} i\n * @param  {Vec3} target\n * @return {Vec3} The \"target\" vector object\n */\nTrimesh.prototype.getNormal = function(i, target){\n    var i3 = i * 3;\n    return target.set(\n        this.normals[i3],\n        this.normals[i3 + 1],\n        this.normals[i3 + 2]\n    );\n};\n\nvar cli_aabb = new AABB();\n\n/**\n * @method calculateLocalInertia\n * @param  {Number} mass\n * @param  {Vec3} target\n * @return {Vec3} The \"target\" vector object\n */\nTrimesh.prototype.calculateLocalInertia = function(mass,target){\n    // Approximate with box inertia\n    // Exact inertia calculation is overkill, but see http://geometrictools.com/Documentation/PolyhedralMassProperties.pdf for the correct way to do it\n    this.computeLocalAABB(cli_aabb);\n    var x = cli_aabb.upperBound.x - cli_aabb.lowerBound.x,\n        y = cli_aabb.upperBound.y - cli_aabb.lowerBound.y,\n        z = cli_aabb.upperBound.z - cli_aabb.lowerBound.z;\n    return target.set(\n        1.0 / 12.0 * mass * ( 2*y*2*y + 2*z*2*z ),\n        1.0 / 12.0 * mass * ( 2*x*2*x + 2*z*2*z ),\n        1.0 / 12.0 * mass * ( 2*y*2*y + 2*x*2*x )\n    );\n};\n\nvar computeLocalAABB_worldVert = new Vec3();\n\n/**\n * Compute the local AABB for the trimesh\n * @method computeLocalAABB\n * @param  {AABB} aabb\n */\nTrimesh.prototype.computeLocalAABB = function(aabb){\n    var l = aabb.lowerBound,\n        u = aabb.upperBound,\n        n = this.vertices.length,\n        vertices = this.vertices,\n        v = computeLocalAABB_worldVert;\n\n    this.getVertex(0, v);\n    l.copy(v);\n    u.copy(v);\n\n    for(var i=0; i !== n; i++){\n        this.getVertex(i, v);\n\n        if(v.x < l.x){\n            l.x = v.x;\n        } else if(v.x > u.x){\n            u.x = v.x;\n        }\n\n        if(v.y < l.y){\n            l.y = v.y;\n        } else if(v.y > u.y){\n            u.y = v.y;\n        }\n\n        if(v.z < l.z){\n            l.z = v.z;\n        } else if(v.z > u.z){\n            u.z = v.z;\n        }\n    }\n};\n\n\n/**\n * Update the .aabb property\n * @method updateAABB\n */\nTrimesh.prototype.updateAABB = function(){\n    this.computeLocalAABB(this.aabb);\n};\n\n/**\n * Will update the .boundingSphereRadius property\n * @method updateBoundingSphereRadius\n */\nTrimesh.prototype.updateBoundingSphereRadius = function(){\n    // Assume points are distributed with local (0,0,0) as center\n    var max2 = 0;\n    var vertices = this.vertices;\n    var v = new Vec3();\n    for(var i=0, N=vertices.length / 3; i !== N; i++) {\n        this.getVertex(i, v);\n        var norm2 = v.norm2();\n        if(norm2 > max2){\n            max2 = norm2;\n        }\n    }\n    this.boundingSphereRadius = Math.sqrt(max2);\n};\n\nvar tempWorldVertex = new Vec3();\nvar calculateWorldAABB_frame = new Transform();\nvar calculateWorldAABB_aabb = new AABB();\n\n/**\n * @method calculateWorldAABB\n * @param {Vec3}        pos\n * @param {Quaternion}  quat\n * @param {Vec3}        min\n * @param {Vec3}        max\n */\nTrimesh.prototype.calculateWorldAABB = function(pos,quat,min,max){\n    /*\n    var n = this.vertices.length / 3,\n        verts = this.vertices;\n    var minx,miny,minz,maxx,maxy,maxz;\n\n    var v = tempWorldVertex;\n    for(var i=0; i<n; i++){\n        this.getVertex(i, v);\n        quat.vmult(v, v);\n        pos.vadd(v, v);\n        if (v.x < minx || minx===undefined){\n            minx = v.x;\n        } else if(v.x > maxx || maxx===undefined){\n            maxx = v.x;\n        }\n\n        if (v.y < miny || miny===undefined){\n            miny = v.y;\n        } else if(v.y > maxy || maxy===undefined){\n            maxy = v.y;\n        }\n\n        if (v.z < minz || minz===undefined){\n            minz = v.z;\n        } else if(v.z > maxz || maxz===undefined){\n            maxz = v.z;\n        }\n    }\n    min.set(minx,miny,minz);\n    max.set(maxx,maxy,maxz);\n    */\n\n    // Faster approximation using local AABB\n    var frame = calculateWorldAABB_frame;\n    var result = calculateWorldAABB_aabb;\n    frame.position = pos;\n    frame.quaternion = quat;\n    this.aabb.toWorldFrame(frame, result);\n    min.copy(result.lowerBound);\n    max.copy(result.upperBound);\n};\n\n/**\n * Get approximate volume\n * @method volume\n * @return {Number}\n */\nTrimesh.prototype.volume = function(){\n    return 4.0 * Math.PI * this.boundingSphereRadius / 3.0;\n};\n\n/**\n * Create a Trimesh instance, shaped as a torus.\n * @static\n * @method createTorus\n * @param  {number} [radius=1]\n * @param  {number} [tube=0.5]\n * @param  {number} [radialSegments=8]\n * @param  {number} [tubularSegments=6]\n * @param  {number} [arc=6.283185307179586]\n * @return {Trimesh} A torus\n */\nTrimesh.createTorus = function (radius, tube, radialSegments, tubularSegments, arc) {\n    radius = radius || 1;\n    tube = tube || 0.5;\n    radialSegments = radialSegments || 8;\n    tubularSegments = tubularSegments || 6;\n    arc = arc || Math.PI * 2;\n\n    var vertices = [];\n    var indices = [];\n\n    for ( var j = 0; j <= radialSegments; j ++ ) {\n        for ( var i = 0; i <= tubularSegments; i ++ ) {\n            var u = i / tubularSegments * arc;\n            var v = j / radialSegments * Math.PI * 2;\n\n            var x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\n            var y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\n            var z = tube * Math.sin( v );\n\n            vertices.push( x, y, z );\n        }\n    }\n\n    for ( var j = 1; j <= radialSegments; j ++ ) {\n        for ( var i = 1; i <= tubularSegments; i ++ ) {\n            var a = ( tubularSegments + 1 ) * j + i - 1;\n            var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\n            var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\n            var d = ( tubularSegments + 1 ) * j + i;\n\n            indices.push(a, b, d);\n            indices.push(b, c, d);\n        }\n    }\n\n    return new Trimesh(vertices, indices);\n};\n\n},{\"../collision/AABB\":3,\"../math/Quaternion\":28,\"../math/Transform\":29,\"../math/Vec3\":30,\"../utils/Octree\":50,\"./Shape\":43}],46:[function(_dereq_,module,exports){\nmodule.exports = GSSolver;\n\nvar Vec3 = _dereq_('../math/Vec3');\nvar Quaternion = _dereq_('../math/Quaternion');\nvar Solver = _dereq_('./Solver');\n\n/**\n * Constraint equation Gauss-Seidel solver.\n * @class GSSolver\n * @constructor\n * @todo The spook parameters should be specified for each constraint, not globally.\n * @author schteppe / https://github.com/schteppe\n * @see https://www8.cs.umu.se/kurser/5DV058/VT09/lectures/spooknotes.pdf\n * @extends Solver\n */\nfunction GSSolver(){\n    Solver.call(this);\n\n    /**\n     * The number of solver iterations determines quality of the constraints in the world. The more iterations, the more correct simulation. More iterations need more computations though. If you have a large gravity force in your world, you will need more iterations.\n     * @property iterations\n     * @type {Number}\n     * @todo write more about solver and iterations in the wiki\n     */\n    this.iterations = 10;\n\n    /**\n     * When tolerance is reached, the system is assumed to be converged.\n     * @property tolerance\n     * @type {Number}\n     */\n    this.tolerance = 1e-7;\n}\nGSSolver.prototype = new Solver();\n\nvar GSSolver_solve_lambda = []; // Just temporary number holders that we want to reuse each solve.\nvar GSSolver_solve_invCs = [];\nvar GSSolver_solve_Bs = [];\nGSSolver.prototype.solve = function(dt,world){\n    var iter = 0,\n        maxIter = this.iterations,\n        tolSquared = this.tolerance*this.tolerance,\n        equations = this.equations,\n        Neq = equations.length,\n        bodies = world.bodies,\n        Nbodies = bodies.length,\n        h = dt,\n        q, B, invC, deltalambda, deltalambdaTot, GWlambda, lambdaj;\n\n    // Update solve mass\n    if(Neq !== 0){\n        for(var i=0; i!==Nbodies; i++){\n            bodies[i].updateSolveMassProperties();\n        }\n    }\n\n    // Things that does not change during iteration can be computed once\n    var invCs = GSSolver_solve_invCs,\n        Bs = GSSolver_solve_Bs,\n        lambda = GSSolver_solve_lambda;\n    invCs.length = Neq;\n    Bs.length = Neq;\n    lambda.length = Neq;\n    for(var i=0; i!==Neq; i++){\n        var c = equations[i];\n        lambda[i] = 0.0;\n        Bs[i] = c.computeB(h);\n        invCs[i] = 1.0 / c.computeC();\n    }\n\n    if(Neq !== 0){\n\n        // Reset vlambda\n        for(var i=0; i!==Nbodies; i++){\n            var b=bodies[i],\n                vlambda=b.vlambda,\n                wlambda=b.wlambda;\n            vlambda.set(0,0,0);\n            if(wlambda){\n                wlambda.set(0,0,0);\n            }\n        }\n\n        // Iterate over equations\n        for(iter=0; iter!==maxIter; iter++){\n\n            // Accumulate the total error for each iteration.\n            deltalambdaTot = 0.0;\n\n            for(var j=0; j!==Neq; j++){\n\n                var c = equations[j];\n\n                // Compute iteration\n                B = Bs[j];\n                invC = invCs[j];\n                lambdaj = lambda[j];\n                GWlambda = c.computeGWlambda();\n                deltalambda = invC * ( B - GWlambda - c.eps * lambdaj );\n\n                // Clamp if we are not within the min/max interval\n                if(lambdaj + deltalambda < c.minForce){\n                    deltalambda = c.minForce - lambdaj;\n                } else if(lambdaj + deltalambda > c.maxForce){\n                    deltalambda = c.maxForce - lambdaj;\n                }\n                lambda[j] += deltalambda;\n\n                deltalambdaTot += deltalambda > 0.0 ? deltalambda : -deltalambda; // abs(deltalambda)\n\n                c.addToWlambda(deltalambda);\n            }\n\n            // If the total error is small enough - stop iterate\n            if(deltalambdaTot*deltalambdaTot < tolSquared){\n                break;\n            }\n        }\n\n        // Add result to velocity\n        for(var i=0; i!==Nbodies; i++){\n            var b=bodies[i],\n                v=b.velocity,\n                w=b.angularVelocity;\n            v.vadd(b.vlambda, v);\n            if(w){\n                w.vadd(b.wlambda, w);\n            }\n        }\n    }\n\n    return iter;\n};\n\n},{\"../math/Quaternion\":28,\"../math/Vec3\":30,\"./Solver\":47}],47:[function(_dereq_,module,exports){\nmodule.exports = Solver;\n\n/**\n * Constraint equation solver base class.\n * @class Solver\n * @constructor\n * @author schteppe / https://github.com/schteppe\n */\nfunction Solver(){\n    /**\n     * All equations to be solved\n     * @property {Array} equations\n     */\n    this.equations = [];\n}\n\n/**\n * Should be implemented in subclasses!\n * @method solve\n * @param  {Number} dt\n * @param  {World} world\n */\nSolver.prototype.solve = function(dt,world){\n    // Should return the number of iterations done!\n    return 0;\n};\n\n/**\n * Add an equation\n * @method addEquation\n * @param {Equation} eq\n */\nSolver.prototype.addEquation = function(eq){\n    if (eq.enabled) {\n        this.equations.push(eq);\n    }\n};\n\n/**\n * Remove an equation\n * @method removeEquation\n * @param {Equation} eq\n */\nSolver.prototype.removeEquation = function(eq){\n    var eqs = this.equations;\n    var i = eqs.indexOf(eq);\n    if(i !== -1){\n        eqs.splice(i,1);\n    }\n};\n\n/**\n * Add all equations\n * @method removeAllEquations\n */\nSolver.prototype.removeAllEquations = function(){\n    this.equations.length = 0;\n};\n\n\n},{}],48:[function(_dereq_,module,exports){\nmodule.exports = SplitSolver;\n\nvar Vec3 = _dereq_('../math/Vec3');\nvar Quaternion = _dereq_('../math/Quaternion');\nvar Solver = _dereq_('./Solver');\nvar Body = _dereq_('../objects/Body');\n\n/**\n * Splits the equations into islands and solves them independently. Can improve performance.\n * @class SplitSolver\n * @constructor\n * @extends Solver\n * @param {Solver} subsolver\n */\nfunction SplitSolver(subsolver){\n    Solver.call(this);\n    this.iterations = 10;\n    this.tolerance = 1e-7;\n    this.subsolver = subsolver;\n    this.nodes = [];\n    this.nodePool = [];\n\n    // Create needed nodes, reuse if possible\n    while(this.nodePool.length < 128){\n        this.nodePool.push(this.createNode());\n    }\n}\nSplitSolver.prototype = new Solver();\n\n// Returns the number of subsystems\nvar SplitSolver_solve_nodes = []; // All allocated node objects\nvar SplitSolver_solve_nodePool = []; // All allocated node objects\nvar SplitSolver_solve_eqs = [];   // Temp array\nvar SplitSolver_solve_bds = [];   // Temp array\nvar SplitSolver_solve_dummyWorld = {bodies:[]}; // Temp object\n\nvar STATIC = Body.STATIC;\nfunction getUnvisitedNode(nodes){\n    var Nnodes = nodes.length;\n    for(var i=0; i!==Nnodes; i++){\n        var node = nodes[i];\n        if(!node.visited && !(node.body.type & STATIC)){\n            return node;\n        }\n    }\n    return false;\n}\n\nvar queue = [];\nfunction bfs(root,visitFunc,bds,eqs){\n    queue.push(root);\n    root.visited = true;\n    visitFunc(root,bds,eqs);\n    while(queue.length) {\n        var node = queue.pop();\n        // Loop over unvisited child nodes\n        var child;\n        while((child = getUnvisitedNode(node.children))) {\n            child.visited = true;\n            visitFunc(child,bds,eqs);\n            queue.push(child);\n        }\n    }\n}\n\nfunction visitFunc(node,bds,eqs){\n    bds.push(node.body);\n    var Neqs = node.eqs.length;\n    for(var i=0; i!==Neqs; i++){\n        var eq = node.eqs[i];\n        if(eqs.indexOf(eq) === -1){\n            eqs.push(eq);\n        }\n    }\n}\n\nSplitSolver.prototype.createNode = function(){\n    return { body:null, children:[], eqs:[], visited:false };\n};\n\n/**\n * Solve the subsystems\n * @method solve\n * @param  {Number} dt\n * @param  {World} world\n */\nSplitSolver.prototype.solve = function(dt,world){\n    var nodes=SplitSolver_solve_nodes,\n        nodePool=this.nodePool,\n        bodies=world.bodies,\n        equations=this.equations,\n        Neq=equations.length,\n        Nbodies=bodies.length,\n        subsolver=this.subsolver;\n\n    // Create needed nodes, reuse if possible\n    while(nodePool.length < Nbodies){\n        nodePool.push(this.createNode());\n    }\n    nodes.length = Nbodies;\n    for (var i = 0; i < Nbodies; i++) {\n        nodes[i] = nodePool[i];\n    }\n\n    // Reset node values\n    for(var i=0; i!==Nbodies; i++){\n        var node = nodes[i];\n        node.body = bodies[i];\n        node.children.length = 0;\n        node.eqs.length = 0;\n        node.visited = false;\n    }\n    for(var k=0; k!==Neq; k++){\n        var eq=equations[k],\n            i=bodies.indexOf(eq.bi),\n            j=bodies.indexOf(eq.bj),\n            ni=nodes[i],\n            nj=nodes[j];\n        ni.children.push(nj);\n        ni.eqs.push(eq);\n        nj.children.push(ni);\n        nj.eqs.push(eq);\n    }\n\n    var child, n=0, eqs=SplitSolver_solve_eqs;\n\n    subsolver.tolerance = this.tolerance;\n    subsolver.iterations = this.iterations;\n\n    var dummyWorld = SplitSolver_solve_dummyWorld;\n    while((child = getUnvisitedNode(nodes))){\n        eqs.length = 0;\n        dummyWorld.bodies.length = 0;\n        bfs(child, visitFunc, dummyWorld.bodies, eqs);\n\n        var Neqs = eqs.length;\n\n        eqs = eqs.sort(sortById);\n\n        for(var i=0; i!==Neqs; i++){\n            subsolver.addEquation(eqs[i]);\n        }\n\n        var iter = subsolver.solve(dt,dummyWorld);\n        subsolver.removeAllEquations();\n        n++;\n    }\n\n    return n;\n};\n\nfunction sortById(a, b){\n    return b.id - a.id;\n}\n},{\"../math/Quaternion\":28,\"../math/Vec3\":30,\"../objects/Body\":31,\"./Solver\":47}],49:[function(_dereq_,module,exports){\n/**\n * Base class for objects that dispatches events.\n * @class EventTarget\n * @constructor\n */\nvar EventTarget = function () {\n\n};\n\nmodule.exports = EventTarget;\n\nEventTarget.prototype = {\n    constructor: EventTarget,\n\n    /**\n     * Add an event listener\n     * @method addEventListener\n     * @param  {String} type\n     * @param  {Function} listener\n     * @return {EventTarget} The self object, for chainability.\n     */\n    addEventListener: function ( type, listener ) {\n        if ( this._listeners === undefined ){ this._listeners = {}; }\n        var listeners = this._listeners;\n        if ( listeners[ type ] === undefined ) {\n            listeners[ type ] = [];\n        }\n        if ( listeners[ type ].indexOf( listener ) === - 1 ) {\n            listeners[ type ].push( listener );\n        }\n        return this;\n    },\n\n    /**\n     * Check if an event listener is added\n     * @method hasEventListener\n     * @param  {String} type\n     * @param  {Function} listener\n     * @return {Boolean}\n     */\n    hasEventListener: function ( type, listener ) {\n        if ( this._listeners === undefined ){ return false; }\n        var listeners = this._listeners;\n        if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {\n            return true;\n        }\n        return false;\n    },\n\n    /**\n     * Remove an event listener\n     * @method removeEventListener\n     * @param  {String} type\n     * @param  {Function} listener\n     * @return {EventTarget} The self object, for chainability.\n     */\n    removeEventListener: function ( type, listener ) {\n        if ( this._listeners === undefined ){ return this; }\n        var listeners = this._listeners;\n        if ( listeners[type] === undefined ){ return this; }\n        var index = listeners[ type ].indexOf( listener );\n        if ( index !== - 1 ) {\n            listeners[ type ].splice( index, 1 );\n        }\n        return this;\n    },\n\n    /**\n     * Emit an event.\n     * @method dispatchEvent\n     * @param  {Object} event\n     * @param  {String} event.type\n     * @return {EventTarget} The self object, for chainability.\n     */\n    dispatchEvent: function ( event ) {\n        if ( this._listeners === undefined ){ return this; }\n        var listeners = this._listeners;\n        var listenerArray = listeners[ event.type ];\n        if ( listenerArray !== undefined ) {\n            event.target = this;\n            for ( var i = 0, l = listenerArray.length; i < l; i ++ ) {\n                listenerArray[ i ].call( this, event );\n            }\n        }\n        return this;\n    }\n};\n\n},{}],50:[function(_dereq_,module,exports){\nvar AABB = _dereq_('../collision/AABB');\nvar Vec3 = _dereq_('../math/Vec3');\n\nmodule.exports = Octree;\n\n/**\n * @class OctreeNode\n * @param {object} [options]\n * @param {Octree} [options.root]\n * @param {AABB} [options.aabb]\n */\nfunction OctreeNode(options){\n    options = options || {};\n\n    /**\n     * The root node\n     * @property {OctreeNode} root\n     */\n    this.root = options.root || null;\n\n    /**\n     * Boundary of this node\n     * @property {AABB} aabb\n     */\n    this.aabb = options.aabb ? options.aabb.clone() : new AABB();\n\n    /**\n     * Contained data at the current node level.\n     * @property {Array} data\n     */\n    this.data = [];\n\n    /**\n     * Children to this node\n     * @property {Array} children\n     */\n    this.children = [];\n}\n\n/**\n * @class Octree\n * @param {AABB} aabb The total AABB of the tree\n * @param {object} [options]\n * @param {number} [options.maxDepth=8]\n * @extends OctreeNode\n */\nfunction Octree(aabb, options){\n    options = options || {};\n    options.root = null;\n    options.aabb = aabb;\n    OctreeNode.call(this, options);\n\n    /**\n     * Maximum subdivision depth\n     * @property {number} maxDepth\n     */\n    this.maxDepth = typeof(options.maxDepth) !== 'undefined' ? options.maxDepth : 8;\n}\nOctree.prototype = new OctreeNode();\n\nOctreeNode.prototype.reset = function(aabb, options){\n    this.children.length = this.data.length = 0;\n};\n\n/**\n * Insert data into this node\n * @method insert\n * @param  {AABB} aabb\n * @param  {object} elementData\n * @return {boolean} True if successful, otherwise false\n */\nOctreeNode.prototype.insert = function(aabb, elementData, level){\n    var nodeData = this.data;\n    level = level || 0;\n\n    // Ignore objects that do not belong in this node\n    if (!this.aabb.contains(aabb)){\n        return false; // object cannot be added\n    }\n\n    var children = this.children;\n\n    if(level < (this.maxDepth || this.root.maxDepth)){\n        // Subdivide if there are no children yet\n        var subdivided = false;\n        if (!children.length){\n            this.subdivide();\n            subdivided = true;\n        }\n\n        // add to whichever node will accept it\n        for (var i = 0; i !== 8; i++) {\n            if (children[i].insert(aabb, elementData, level + 1)){\n                return true;\n            }\n        }\n\n        if(subdivided){\n            // No children accepted! Might as well just remove em since they contain none\n            children.length = 0;\n        }\n    }\n\n    // Too deep, or children didnt want it. add it in current node\n    nodeData.push(elementData);\n\n    return true;\n};\n\nvar halfDiagonal = new Vec3();\n\n/**\n * Create 8 equally sized children nodes and put them in the .children array.\n * @method subdivide\n */\nOctreeNode.prototype.subdivide = function() {\n    var aabb = this.aabb;\n    var l = aabb.lowerBound;\n    var u = aabb.upperBound;\n\n    var children = this.children;\n\n    children.push(\n        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(0,0,0) }) }),\n        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(1,0,0) }) }),\n        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(1,1,0) }) }),\n        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(1,1,1) }) }),\n        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(0,1,1) }) }),\n        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(0,0,1) }) }),\n        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(1,0,1) }) }),\n        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(0,1,0) }) })\n    );\n\n    u.vsub(l, halfDiagonal);\n    halfDiagonal.scale(0.5, halfDiagonal);\n\n    var root = this.root || this;\n\n    for (var i = 0; i !== 8; i++) {\n        var child = children[i];\n\n        // Set current node as root\n        child.root = root;\n\n        // Compute bounds\n        var lowerBound = child.aabb.lowerBound;\n        lowerBound.x *= halfDiagonal.x;\n        lowerBound.y *= halfDiagonal.y;\n        lowerBound.z *= halfDiagonal.z;\n\n        lowerBound.vadd(l, lowerBound);\n\n        // Upper bound is always lower bound + halfDiagonal\n        lowerBound.vadd(halfDiagonal, child.aabb.upperBound);\n    }\n};\n\n/**\n * Get all data, potentially within an AABB\n * @method aabbQuery\n * @param  {AABB} aabb\n * @param  {array} result\n * @return {array} The \"result\" object\n */\nOctreeNode.prototype.aabbQuery = function(aabb, result) {\n\n    var nodeData = this.data;\n\n    // abort if the range does not intersect this node\n    // if (!this.aabb.overlaps(aabb)){\n    //     return result;\n    // }\n\n    // Add objects at this level\n    // Array.prototype.push.apply(result, nodeData);\n\n    // Add child data\n    // @todo unwrap recursion into a queue / loop, that's faster in JS\n    var children = this.children;\n\n\n    // for (var i = 0, N = this.children.length; i !== N; i++) {\n    //     children[i].aabbQuery(aabb, result);\n    // }\n\n    var queue = [this];\n    while (queue.length) {\n        var node = queue.pop();\n        if (node.aabb.overlaps(aabb)){\n            Array.prototype.push.apply(result, node.data);\n        }\n        Array.prototype.push.apply(queue, node.children);\n    }\n\n    return result;\n};\n\nvar tmpAABB = new AABB();\n\n/**\n * Get all data, potentially intersected by a ray.\n * @method rayQuery\n * @param  {Ray} ray\n * @param  {Transform} treeTransform\n * @param  {array} result\n * @return {array} The \"result\" object\n */\nOctreeNode.prototype.rayQuery = function(ray, treeTransform, result) {\n\n    // Use aabb query for now.\n    // @todo implement real ray query which needs less lookups\n    ray.getAABB(tmpAABB);\n    tmpAABB.toLocalFrame(treeTransform, tmpAABB);\n    this.aabbQuery(tmpAABB, result);\n\n    return result;\n};\n\n/**\n * @method removeEmptyNodes\n */\nOctreeNode.prototype.removeEmptyNodes = function() {\n    var queue = [this];\n    while (queue.length) {\n        var node = queue.pop();\n        for (var i = node.children.length - 1; i >= 0; i--) {\n            if(!node.children[i].data.length){\n                node.children.splice(i, 1);\n            }\n        }\n        Array.prototype.push.apply(queue, node.children);\n    }\n};\n\n},{\"../collision/AABB\":3,\"../math/Vec3\":30}],51:[function(_dereq_,module,exports){\nmodule.exports = Pool;\n\n/**\n * For pooling objects that can be reused.\n * @class Pool\n * @constructor\n */\nfunction Pool(){\n    /**\n     * The pooled objects\n     * @property {Array} objects\n     */\n    this.objects = [];\n\n    /**\n     * Constructor of the objects\n     * @property {mixed} type\n     */\n    this.type = Object;\n}\n\n/**\n * Release an object after use\n * @method release\n * @param {Object} obj\n */\nPool.prototype.release = function(){\n    var Nargs = arguments.length;\n    for(var i=0; i!==Nargs; i++){\n        this.objects.push(arguments[i]);\n    }\n};\n\n/**\n * Get an object\n * @method get\n * @return {mixed}\n */\nPool.prototype.get = function(){\n    if(this.objects.length===0){\n        return this.constructObject();\n    } else {\n        return this.objects.pop();\n    }\n};\n\n/**\n * Construct an object. Should be implmented in each subclass.\n * @method constructObject\n * @return {mixed}\n */\nPool.prototype.constructObject = function(){\n    throw new Error(\"constructObject() not implemented in this Pool subclass yet!\");\n};\n\n},{}],52:[function(_dereq_,module,exports){\nmodule.exports = TupleDictionary;\n\n/**\n * @class TupleDictionary\n * @constructor\n */\nfunction TupleDictionary() {\n\n    /**\n     * The data storage\n     * @property data\n     * @type {Object}\n     */\n    this.data = { keys:[] };\n}\n\n/**\n * @method get\n * @param  {Number} i\n * @param  {Number} j\n * @return {Number}\n */\nTupleDictionary.prototype.get = function(i, j) {\n    if (i > j) {\n        // swap\n        var temp = j;\n        j = i;\n        i = temp;\n    }\n    return this.data[i+'-'+j];\n};\n\n/**\n * @method set\n * @param  {Number} i\n * @param  {Number} j\n * @param {Number} value\n */\nTupleDictionary.prototype.set = function(i, j, value) {\n    if (i > j) {\n        var temp = j;\n        j = i;\n        i = temp;\n    }\n    var key = i+'-'+j;\n\n    // Check if key already exists\n    if(!this.get(i,j)){\n        this.data.keys.push(key);\n    }\n\n    this.data[key] = value;\n};\n\n/**\n * @method reset\n */\nTupleDictionary.prototype.reset = function() {\n    var data = this.data,\n        keys = data.keys;\n    while(keys.length > 0){\n        var key = keys.pop();\n        delete data[key];\n    }\n};\n\n},{}],53:[function(_dereq_,module,exports){\nfunction Utils(){}\n\nmodule.exports = Utils;\n\n/**\n * Extend an options object with default values.\n * @static\n * @method defaults\n * @param  {object} options The options object. May be falsy: in this case, a new object is created and returned.\n * @param  {object} defaults An object containing default values.\n * @return {object} The modified options object.\n */\nUtils.defaults = function(options, defaults){\n    options = options || {};\n\n    for(var key in defaults){\n        if(!(key in options)){\n            options[key] = defaults[key];\n        }\n    }\n\n    return options;\n};\n\n},{}],54:[function(_dereq_,module,exports){\nmodule.exports = Vec3Pool;\n\nvar Vec3 = _dereq_('../math/Vec3');\nvar Pool = _dereq_('./Pool');\n\n/**\n * @class Vec3Pool\n * @constructor\n * @extends Pool\n */\nfunction Vec3Pool(){\n    Pool.call(this);\n    this.type = Vec3;\n}\nVec3Pool.prototype = new Pool();\n\n/**\n * Construct a vector\n * @method constructObject\n * @return {Vec3}\n */\nVec3Pool.prototype.constructObject = function(){\n    return new Vec3();\n};\n\n},{\"../math/Vec3\":30,\"./Pool\":51}],55:[function(_dereq_,module,exports){\nmodule.exports = Narrowphase;\n\nvar AABB = _dereq_('../collision/AABB');\nvar Shape = _dereq_('../shapes/Shape');\nvar Ray = _dereq_('../collision/Ray');\nvar Vec3 = _dereq_('../math/Vec3');\nvar Transform = _dereq_('../math/Transform');\nvar ConvexPolyhedron = _dereq_('../shapes/ConvexPolyhedron');\nvar Quaternion = _dereq_('../math/Quaternion');\nvar Solver = _dereq_('../solver/Solver');\nvar Vec3Pool = _dereq_('../utils/Vec3Pool');\nvar ContactEquation = _dereq_('../equations/ContactEquation');\nvar FrictionEquation = _dereq_('../equations/FrictionEquation');\n\n/**\n * Helper class for the World. Generates ContactEquations.\n * @class Narrowphase\n * @constructor\n * @todo Sphere-ConvexPolyhedron contacts\n * @todo Contact reduction\n * @todo  should move methods to prototype\n */\nfunction Narrowphase(world){\n\n    /**\n     * Internal storage of pooled contact points.\n     * @property {Array} contactPointPool\n     */\n    this.contactPointPool = [];\n\n    this.frictionEquationPool = [];\n\n    this.result = [];\n    this.frictionResult = [];\n\n    /**\n     * Pooled vectors.\n     * @property {Vec3Pool} v3pool\n     */\n    this.v3pool = new Vec3Pool();\n\n    this.world = world;\n    this.currentContactMaterial = null;\n\n    /**\n     * @property {Boolean} enableFrictionReduction\n     */\n    this.enableFrictionReduction = false;\n}\n\n/**\n * Make a contact object, by using the internal pool or creating a new one.\n * @method createContactEquation\n * @return {ContactEquation}\n */\nNarrowphase.prototype.createContactEquation = function(bi, bj, si, sj, rsi, rsj){\n    var c;\n    if(this.contactPointPool.length){\n        c = this.contactPointPool.pop();\n        c.bi = bi;\n        c.bj = bj;\n    } else {\n        c = new ContactEquation(bi, bj);\n    }\n\n    c.enabled = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;\n\n    var cm = this.currentContactMaterial;\n\n    c.restitution = cm.restitution;\n\n    c.setSpookParams(\n        cm.contactEquationStiffness,\n        cm.contactEquationRelaxation,\n        this.world.dt\n    );\n\n    var matA = si.material || bi.material;\n    var matB = sj.material || bj.material;\n    if(matA && matB && matA.restitution >= 0 && matB.restitution >= 0){\n        c.restitution = matA.restitution * matB.restitution;\n    }\n\n    c.si = rsi || si;\n    c.sj = rsj || sj;\n\n    return c;\n};\n\nNarrowphase.prototype.createFrictionEquationsFromContact = function(contactEquation, outArray){\n    var bodyA = contactEquation.bi;\n    var bodyB = contactEquation.bj;\n    var shapeA = contactEquation.si;\n    var shapeB = contactEquation.sj;\n\n    var world = this.world;\n    var cm = this.currentContactMaterial;\n\n    // If friction or restitution were specified in the material, use them\n    var friction = cm.friction;\n    var matA = shapeA.material || bodyA.material;\n    var matB = shapeB.material || bodyB.material;\n    if(matA && matB && matA.friction >= 0 && matB.friction >= 0){\n        friction = matA.friction * matB.friction;\n    }\n\n    if(friction > 0){\n\n        // Create 2 tangent equations\n        var mug = friction * world.gravity.length();\n        var reducedMass = (bodyA.invMass + bodyB.invMass);\n        if(reducedMass > 0){\n            reducedMass = 1/reducedMass;\n        }\n        var pool = this.frictionEquationPool;\n        var c1 = pool.length ? pool.pop() : new FrictionEquation(bodyA,bodyB,mug*reducedMass);\n        var c2 = pool.length ? pool.pop() : new FrictionEquation(bodyA,bodyB,mug*reducedMass);\n\n        c1.bi = c2.bi = bodyA;\n        c1.bj = c2.bj = bodyB;\n        c1.minForce = c2.minForce = -mug*reducedMass;\n        c1.maxForce = c2.maxForce = mug*reducedMass;\n\n        // Copy over the relative vectors\n        c1.ri.copy(contactEquation.ri);\n        c1.rj.copy(contactEquation.rj);\n        c2.ri.copy(contactEquation.ri);\n        c2.rj.copy(contactEquation.rj);\n\n        // Construct tangents\n        contactEquation.ni.tangents(c1.t, c2.t);\n\n        // Set spook params\n        c1.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, world.dt);\n        c2.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, world.dt);\n\n        c1.enabled = c2.enabled = contactEquation.enabled;\n\n        outArray.push(c1, c2);\n\n        return true;\n    }\n\n    return false;\n};\n\nvar averageNormal = new Vec3();\nvar averageContactPointA = new Vec3();\nvar averageContactPointB = new Vec3();\n\n// Take the average N latest contact point on the plane.\nNarrowphase.prototype.createFrictionFromAverage = function(numContacts){\n    // The last contactEquation\n    var c = this.result[this.result.length - 1];\n\n    // Create the result: two \"average\" friction equations\n    if (!this.createFrictionEquationsFromContact(c, this.frictionResult) || numContacts === 1) {\n        return;\n    }\n\n    var f1 = this.frictionResult[this.frictionResult.length - 2];\n    var f2 = this.frictionResult[this.frictionResult.length - 1];\n\n    averageNormal.setZero();\n    averageContactPointA.setZero();\n    averageContactPointB.setZero();\n\n    var bodyA = c.bi;\n    var bodyB = c.bj;\n    for(var i=0; i!==numContacts; i++){\n        c = this.result[this.result.length - 1 - i];\n        if(c.bodyA !== bodyA){\n            averageNormal.vadd(c.ni, averageNormal); // vec2.add(eq.t, eq.t, c.normalA);\n            averageContactPointA.vadd(c.ri, averageContactPointA); // vec2.add(eq.contactPointA, eq.contactPointA, c.contactPointA);\n            averageContactPointB.vadd(c.rj, averageContactPointB);\n        } else {\n            averageNormal.vsub(c.ni, averageNormal); // vec2.sub(eq.t, eq.t, c.normalA);\n            averageContactPointA.vadd(c.rj, averageContactPointA); // vec2.add(eq.contactPointA, eq.contactPointA, c.contactPointA);\n            averageContactPointB.vadd(c.ri, averageContactPointB);\n        }\n    }\n\n    var invNumContacts = 1 / numContacts;\n    averageContactPointA.scale(invNumContacts, f1.ri); // vec2.scale(eq.contactPointA, eq.contactPointA, invNumContacts);\n    averageContactPointB.scale(invNumContacts, f1.rj); // vec2.scale(eq.contactPointB, eq.contactPointB, invNumContacts);\n    f2.ri.copy(f1.ri); // Should be the same\n    f2.rj.copy(f1.rj);\n    averageNormal.normalize();\n    averageNormal.tangents(f1.t, f2.t);\n    // return eq;\n};\n\n\nvar tmpVec1 = new Vec3();\nvar tmpVec2 = new Vec3();\nvar tmpQuat1 = new Quaternion();\nvar tmpQuat2 = new Quaternion();\n\n/**\n * Generate all contacts between a list of body pairs\n * @method getContacts\n * @param {array} p1 Array of body indices\n * @param {array} p2 Array of body indices\n * @param {World} world\n * @param {array} result Array to store generated contacts\n * @param {array} oldcontacts Optional. Array of reusable contact objects\n */\nNarrowphase.prototype.getContacts = function(p1, p2, world, result, oldcontacts, frictionResult, frictionPool){\n    // Save old contact objects\n    this.contactPointPool = oldcontacts;\n    this.frictionEquationPool = frictionPool;\n    this.result = result;\n    this.frictionResult = frictionResult;\n\n    var qi = tmpQuat1;\n    var qj = tmpQuat2;\n    var xi = tmpVec1;\n    var xj = tmpVec2;\n\n    for(var k=0, N=p1.length; k!==N; k++){\n\n        // Get current collision bodies\n        var bi = p1[k],\n            bj = p2[k];\n\n        // Get contact material\n        var bodyContactMaterial = null;\n        if(bi.material && bj.material){\n            bodyContactMaterial = world.getContactMaterial(bi.material,bj.material) || null;\n        }\n\n        for (var i = 0; i < bi.shapes.length; i++) {\n            bi.quaternion.mult(bi.shapeOrientations[i], qi);\n            bi.quaternion.vmult(bi.shapeOffsets[i], xi);\n            xi.vadd(bi.position, xi);\n            var si = bi.shapes[i];\n\n            for (var j = 0; j < bj.shapes.length; j++) {\n\n                // Compute world transform of shapes\n                bj.quaternion.mult(bj.shapeOrientations[j], qj);\n                bj.quaternion.vmult(bj.shapeOffsets[j], xj);\n                xj.vadd(bj.position, xj);\n                var sj = bj.shapes[j];\n\n                if(xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius){\n                    continue;\n                }\n\n                // Get collision material\n                var shapeContactMaterial = null;\n                if(si.material && sj.material){\n                    shapeContactMaterial = world.getContactMaterial(si.material,sj.material) || null;\n                }\n\n                this.currentContactMaterial = shapeContactMaterial || bodyContactMaterial || world.defaultContactMaterial;\n\n                // Get contacts\n                var resolver = this[si.type | sj.type];\n                if(resolver){\n                    if (si.type < sj.type) {\n                        resolver.call(this, si, sj, xi, xj, qi, qj, bi, bj, si, sj);\n                    } else {\n                        resolver.call(this, sj, si, xj, xi, qj, qi, bj, bi, si, sj);\n                    }\n                }\n            }\n        }\n    }\n};\n\nvar numWarnings = 0;\nvar maxWarnings = 10;\n\nfunction warn(msg){\n    if(numWarnings > maxWarnings){\n        return;\n    }\n\n    numWarnings++;\n\n    console.warn(msg);\n}\n\nNarrowphase.prototype[Shape.types.BOX | Shape.types.BOX] =\nNarrowphase.prototype.boxBox = function(si,sj,xi,xj,qi,qj,bi,bj){\n    si.convexPolyhedronRepresentation.material = si.material;\n    sj.convexPolyhedronRepresentation.material = sj.material;\n    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;\n    sj.convexPolyhedronRepresentation.collisionResponse = sj.collisionResponse;\n    this.convexConvex(si.convexPolyhedronRepresentation,sj.convexPolyhedronRepresentation,xi,xj,qi,qj,bi,bj,si,sj);\n};\n\nNarrowphase.prototype[Shape.types.BOX | Shape.types.CONVEXPOLYHEDRON] =\nNarrowphase.prototype.boxConvex = function(si,sj,xi,xj,qi,qj,bi,bj){\n    si.convexPolyhedronRepresentation.material = si.material;\n    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;\n    this.convexConvex(si.convexPolyhedronRepresentation,sj,xi,xj,qi,qj,bi,bj,si,sj);\n};\n\nNarrowphase.prototype[Shape.types.BOX | Shape.types.PARTICLE] =\nNarrowphase.prototype.boxParticle = function(si,sj,xi,xj,qi,qj,bi,bj){\n    si.convexPolyhedronRepresentation.material = si.material;\n    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;\n    this.convexParticle(si.convexPolyhedronRepresentation,sj,xi,xj,qi,qj,bi,bj,si,sj);\n};\n\n/**\n * @method sphereSphere\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\nNarrowphase.prototype[Shape.types.SPHERE] =\nNarrowphase.prototype.sphereSphere = function(si,sj,xi,xj,qi,qj,bi,bj){\n    // We will have only one contact in this case\n    var r = this.createContactEquation(bi,bj,si,sj);\n\n    // Contact normal\n    xj.vsub(xi, r.ni);\n    r.ni.normalize();\n\n    // Contact point locations\n    r.ri.copy(r.ni);\n    r.rj.copy(r.ni);\n    r.ri.mult(si.radius, r.ri);\n    r.rj.mult(-sj.radius, r.rj);\n\n    r.ri.vadd(xi, r.ri);\n    r.ri.vsub(bi.position, r.ri);\n\n    r.rj.vadd(xj, r.rj);\n    r.rj.vsub(bj.position, r.rj);\n\n    this.result.push(r);\n\n    this.createFrictionEquationsFromContact(r, this.frictionResult);\n};\n\n/**\n * @method planeTrimesh\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\nvar planeTrimesh_normal = new Vec3();\nvar planeTrimesh_relpos = new Vec3();\nvar planeTrimesh_projected = new Vec3();\nNarrowphase.prototype[Shape.types.PLANE | Shape.types.TRIMESH] =\nNarrowphase.prototype.planeTrimesh = function(\n    planeShape,\n    trimeshShape,\n    planePos,\n    trimeshPos,\n    planeQuat,\n    trimeshQuat,\n    planeBody,\n    trimeshBody\n){\n    // Make contacts!\n    var v = new Vec3();\n\n    var normal = planeTrimesh_normal;\n    normal.set(0,0,1);\n    planeQuat.vmult(normal,normal); // Turn normal according to plane\n\n    for(var i=0; i<trimeshShape.vertices.length / 3; i++){\n\n        // Get world vertex from trimesh\n        trimeshShape.getVertex(i, v);\n\n        // Safe up\n        var v2 = new Vec3();\n        v2.copy(v);\n        Transform.pointToWorldFrame(trimeshPos, trimeshQuat, v2, v);\n\n        // Check plane side\n        var relpos = planeTrimesh_relpos;\n        v.vsub(planePos, relpos);\n        var dot = normal.dot(relpos);\n\n        if(dot <= 0.0){\n            var r = this.createContactEquation(planeBody,trimeshBody,planeShape,trimeshShape);\n\n            r.ni.copy(normal); // Contact normal is the plane normal\n\n            // Get vertex position projected on plane\n            var projected = planeTrimesh_projected;\n            normal.scale(relpos.dot(normal), projected);\n            v.vsub(projected,projected);\n\n            // ri is the projected world position minus plane position\n            r.ri.copy(projected);\n            r.ri.vsub(planeBody.position, r.ri);\n\n            r.rj.copy(v);\n            r.rj.vsub(trimeshBody.position, r.rj);\n\n            // Store result\n            this.result.push(r);\n            this.createFrictionEquationsFromContact(r, this.frictionResult);\n        }\n    }\n};\n\n/**\n * @method sphereTrimesh\n * @param  {Shape}      sphereShape\n * @param  {Shape}      trimeshShape\n * @param  {Vec3}       spherePos\n * @param  {Vec3}       trimeshPos\n * @param  {Quaternion} sphereQuat\n * @param  {Quaternion} trimeshQuat\n * @param  {Body}       sphereBody\n * @param  {Body}       trimeshBody\n */\nvar sphereTrimesh_normal = new Vec3();\nvar sphereTrimesh_relpos = new Vec3();\nvar sphereTrimesh_projected = new Vec3();\nvar sphereTrimesh_v = new Vec3();\nvar sphereTrimesh_v2 = new Vec3();\nvar sphereTrimesh_edgeVertexA = new Vec3();\nvar sphereTrimesh_edgeVertexB = new Vec3();\nvar sphereTrimesh_edgeVector = new Vec3();\nvar sphereTrimesh_edgeVectorUnit = new Vec3();\nvar sphereTrimesh_localSpherePos = new Vec3();\nvar sphereTrimesh_tmp = new Vec3();\nvar sphereTrimesh_va = new Vec3();\nvar sphereTrimesh_vb = new Vec3();\nvar sphereTrimesh_vc = new Vec3();\nvar sphereTrimesh_localSphereAABB = new AABB();\nvar sphereTrimesh_triangles = [];\nNarrowphase.prototype[Shape.types.SPHERE | Shape.types.TRIMESH] =\nNarrowphase.prototype.sphereTrimesh = function (\n    sphereShape,\n    trimeshShape,\n    spherePos,\n    trimeshPos,\n    sphereQuat,\n    trimeshQuat,\n    sphereBody,\n    trimeshBody\n) {\n\n    var edgeVertexA = sphereTrimesh_edgeVertexA;\n    var edgeVertexB = sphereTrimesh_edgeVertexB;\n    var edgeVector = sphereTrimesh_edgeVector;\n    var edgeVectorUnit = sphereTrimesh_edgeVectorUnit;\n    var localSpherePos = sphereTrimesh_localSpherePos;\n    var tmp = sphereTrimesh_tmp;\n    var localSphereAABB = sphereTrimesh_localSphereAABB;\n    var v2 = sphereTrimesh_v2;\n    var relpos = sphereTrimesh_relpos;\n    var triangles = sphereTrimesh_triangles;\n\n    // Convert sphere position to local in the trimesh\n    Transform.pointToLocalFrame(trimeshPos, trimeshQuat, spherePos, localSpherePos);\n\n    // Get the aabb of the sphere locally in the trimesh\n    var sphereRadius = sphereShape.radius;\n    localSphereAABB.lowerBound.set(\n        localSpherePos.x - sphereRadius,\n        localSpherePos.y - sphereRadius,\n        localSpherePos.z - sphereRadius\n    );\n    localSphereAABB.upperBound.set(\n        localSpherePos.x + sphereRadius,\n        localSpherePos.y + sphereRadius,\n        localSpherePos.z + sphereRadius\n    );\n\n    trimeshShape.getTrianglesInAABB(localSphereAABB, triangles);\n    //for (var i = 0; i < trimeshShape.indices.length / 3; i++) triangles.push(i); // All\n\n    // Vertices\n    var v = sphereTrimesh_v;\n    var radiusSquared = sphereShape.radius * sphereShape.radius;\n    for(var i=0; i<triangles.length; i++){\n        for (var j = 0; j < 3; j++) {\n\n            trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + j], v);\n\n            // Check vertex overlap in sphere\n            v.vsub(localSpherePos, relpos);\n\n            if(relpos.norm2() <= radiusSquared){\n\n                // Safe up\n                v2.copy(v);\n                Transform.pointToWorldFrame(trimeshPos, trimeshQuat, v2, v);\n\n                v.vsub(spherePos, relpos);\n\n                var r = this.createContactEquation(sphereBody,trimeshBody,sphereShape,trimeshShape);\n                r.ni.copy(relpos);\n                r.ni.normalize();\n\n                // ri is the vector from sphere center to the sphere surface\n                r.ri.copy(r.ni);\n                r.ri.scale(sphereShape.radius, r.ri);\n                r.ri.vadd(spherePos, r.ri);\n                r.ri.vsub(sphereBody.position, r.ri);\n\n                r.rj.copy(v);\n                r.rj.vsub(trimeshBody.position, r.rj);\n\n                // Store result\n                this.result.push(r);\n                this.createFrictionEquationsFromContact(r, this.frictionResult);\n            }\n        }\n    }\n\n    // Check all edges\n    for(var i=0; i<triangles.length; i++){\n        for (var j = 0; j < 3; j++) {\n\n            trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + j], edgeVertexA);\n            trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + ((j+1)%3)], edgeVertexB);\n            edgeVertexB.vsub(edgeVertexA, edgeVector);\n\n            // Project sphere position to the edge\n            localSpherePos.vsub(edgeVertexB, tmp);\n            var positionAlongEdgeB = tmp.dot(edgeVector);\n\n            localSpherePos.vsub(edgeVertexA, tmp);\n            var positionAlongEdgeA = tmp.dot(edgeVector);\n\n            if(positionAlongEdgeA > 0 && positionAlongEdgeB < 0){\n\n                // Now check the orthogonal distance from edge to sphere center\n                localSpherePos.vsub(edgeVertexA, tmp);\n\n                edgeVectorUnit.copy(edgeVector);\n                edgeVectorUnit.normalize();\n                positionAlongEdgeA = tmp.dot(edgeVectorUnit);\n\n                edgeVectorUnit.scale(positionAlongEdgeA, tmp);\n                tmp.vadd(edgeVertexA, tmp);\n\n                // tmp is now the sphere center position projected to the edge, defined locally in the trimesh frame\n                var dist = tmp.distanceTo(localSpherePos);\n                if(dist < sphereShape.radius){\n                    var r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape);\n\n                    tmp.vsub(localSpherePos, r.ni);\n                    r.ni.normalize();\n                    r.ni.scale(sphereShape.radius, r.ri);\n\n                    Transform.pointToWorldFrame(trimeshPos, trimeshQuat, tmp, tmp);\n                    tmp.vsub(trimeshBody.position, r.rj);\n\n                    Transform.vectorToWorldFrame(trimeshQuat, r.ni, r.ni);\n                    Transform.vectorToWorldFrame(trimeshQuat, r.ri, r.ri);\n\n                    this.result.push(r);\n                    this.createFrictionEquationsFromContact(r, this.frictionResult);\n                }\n            }\n        }\n    }\n\n    // Triangle faces\n    var va = sphereTrimesh_va;\n    var vb = sphereTrimesh_vb;\n    var vc = sphereTrimesh_vc;\n    var normal = sphereTrimesh_normal;\n    for(var i=0, N = triangles.length; i !== N; i++){\n        trimeshShape.getTriangleVertices(triangles[i], va, vb, vc);\n        trimeshShape.getNormal(triangles[i], normal);\n        localSpherePos.vsub(va, tmp);\n        var dist = tmp.dot(normal);\n        normal.scale(dist, tmp);\n        localSpherePos.vsub(tmp, tmp);\n\n        // tmp is now the sphere position projected to the triangle plane\n        dist = tmp.distanceTo(localSpherePos);\n        if(Ray.pointInTriangle(tmp, va, vb, vc) && dist < sphereShape.radius){\n            var r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape);\n\n            tmp.vsub(localSpherePos, r.ni);\n            r.ni.normalize();\n            r.ni.scale(sphereShape.radius, r.ri);\n\n            Transform.pointToWorldFrame(trimeshPos, trimeshQuat, tmp, tmp);\n            tmp.vsub(trimeshBody.position, r.rj);\n\n            Transform.vectorToWorldFrame(trimeshQuat, r.ni, r.ni);\n            Transform.vectorToWorldFrame(trimeshQuat, r.ri, r.ri);\n\n            this.result.push(r);\n            this.createFrictionEquationsFromContact(r, this.frictionResult);\n        }\n    }\n\n    triangles.length = 0;\n};\n\nvar point_on_plane_to_sphere = new Vec3();\nvar plane_to_sphere_ortho = new Vec3();\n\n/**\n * @method spherePlane\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\nNarrowphase.prototype[Shape.types.SPHERE | Shape.types.PLANE] =\nNarrowphase.prototype.spherePlane = function(si,sj,xi,xj,qi,qj,bi,bj){\n    // We will have one contact in this case\n    var r = this.createContactEquation(bi,bj,si,sj);\n\n    // Contact normal\n    r.ni.set(0,0,1);\n    qj.vmult(r.ni, r.ni);\n    r.ni.negate(r.ni); // body i is the sphere, flip normal\n    r.ni.normalize(); // Needed?\n\n    // Vector from sphere center to contact point\n    r.ni.mult(si.radius, r.ri);\n\n    // Project down sphere on plane\n    xi.vsub(xj, point_on_plane_to_sphere);\n    r.ni.mult(r.ni.dot(point_on_plane_to_sphere), plane_to_sphere_ortho);\n    point_on_plane_to_sphere.vsub(plane_to_sphere_ortho,r.rj); // The sphere position projected to plane\n\n    if(-point_on_plane_to_sphere.dot(r.ni) <= si.radius){\n\n        // Make it relative to the body\n        var ri = r.ri;\n        var rj = r.rj;\n        ri.vadd(xi, ri);\n        ri.vsub(bi.position, ri);\n        rj.vadd(xj, rj);\n        rj.vsub(bj.position, rj);\n\n        this.result.push(r);\n        this.createFrictionEquationsFromContact(r, this.frictionResult);\n    }\n};\n\n// See http://bulletphysics.com/Bullet/BulletFull/SphereTriangleDetector_8cpp_source.html\nvar pointInPolygon_edge = new Vec3();\nvar pointInPolygon_edge_x_normal = new Vec3();\nvar pointInPolygon_vtp = new Vec3();\nfunction pointInPolygon(verts, normal, p){\n    var positiveResult = null;\n    var N = verts.length;\n    for(var i=0; i!==N; i++){\n        var v = verts[i];\n\n        // Get edge to the next vertex\n        var edge = pointInPolygon_edge;\n        verts[(i+1) % (N)].vsub(v,edge);\n\n        // Get cross product between polygon normal and the edge\n        var edge_x_normal = pointInPolygon_edge_x_normal;\n        //var edge_x_normal = new Vec3();\n        edge.cross(normal,edge_x_normal);\n\n        // Get vector between point and current vertex\n        var vertex_to_p = pointInPolygon_vtp;\n        p.vsub(v,vertex_to_p);\n\n        // This dot product determines which side of the edge the point is\n        var r = edge_x_normal.dot(vertex_to_p);\n\n        // If all such dot products have same sign, we are inside the polygon.\n        if(positiveResult===null || (r>0 && positiveResult===true) || (r<=0 && positiveResult===false)){\n            if(positiveResult===null){\n                positiveResult = r>0;\n            }\n            continue;\n        } else {\n            return false; // Encountered some other sign. Exit.\n        }\n    }\n\n    // If we got here, all dot products were of the same sign.\n    return true;\n}\n\nvar box_to_sphere = new Vec3();\nvar sphereBox_ns = new Vec3();\nvar sphereBox_ns1 = new Vec3();\nvar sphereBox_ns2 = new Vec3();\nvar sphereBox_sides = [new Vec3(),new Vec3(),new Vec3(),new Vec3(),new Vec3(),new Vec3()];\nvar sphereBox_sphere_to_corner = new Vec3();\nvar sphereBox_side_ns = new Vec3();\nvar sphereBox_side_ns1 = new Vec3();\nvar sphereBox_side_ns2 = new Vec3();\n\n/**\n * @method sphereBox\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\nNarrowphase.prototype[Shape.types.SPHERE | Shape.types.BOX] =\nNarrowphase.prototype.sphereBox = function(si,sj,xi,xj,qi,qj,bi,bj){\n    var v3pool = this.v3pool;\n\n    // we refer to the box as body j\n    var sides = sphereBox_sides;\n    xi.vsub(xj,box_to_sphere);\n    sj.getSideNormals(sides,qj);\n    var R =     si.radius;\n    var penetrating_sides = [];\n\n    // Check side (plane) intersections\n    var found = false;\n\n    // Store the resulting side penetration info\n    var side_ns = sphereBox_side_ns;\n    var side_ns1 = sphereBox_side_ns1;\n    var side_ns2 = sphereBox_side_ns2;\n    var side_h = null;\n    var side_penetrations = 0;\n    var side_dot1 = 0;\n    var side_dot2 = 0;\n    var side_distance = null;\n    for(var idx=0,nsides=sides.length; idx!==nsides && found===false; idx++){\n        // Get the plane side normal (ns)\n        var ns = sphereBox_ns;\n        ns.copy(sides[idx]);\n\n        var h = ns.norm();\n        ns.normalize();\n\n        // The normal/distance dot product tells which side of the plane we are\n        var dot = box_to_sphere.dot(ns);\n\n        if(dot<h+R && dot>0){\n            // Intersects plane. Now check the other two dimensions\n            var ns1 = sphereBox_ns1;\n            var ns2 = sphereBox_ns2;\n            ns1.copy(sides[(idx+1)%3]);\n            ns2.copy(sides[(idx+2)%3]);\n            var h1 = ns1.norm();\n            var h2 = ns2.norm();\n            ns1.normalize();\n            ns2.normalize();\n            var dot1 = box_to_sphere.dot(ns1);\n            var dot2 = box_to_sphere.dot(ns2);\n            if(dot1<h1 && dot1>-h1 && dot2<h2 && dot2>-h2){\n                var dist = Math.abs(dot-h-R);\n                if(side_distance===null || dist < side_distance){\n                    side_distance = dist;\n                    side_dot1 = dot1;\n                    side_dot2 = dot2;\n                    side_h = h;\n                    side_ns.copy(ns);\n                    side_ns1.copy(ns1);\n                    side_ns2.copy(ns2);\n                    side_penetrations++;\n                }\n            }\n        }\n    }\n    if(side_penetrations){\n        found = true;\n        var r = this.createContactEquation(bi,bj,si,sj);\n        side_ns.mult(-R,r.ri); // Sphere r\n        r.ni.copy(side_ns);\n        r.ni.negate(r.ni); // Normal should be out of sphere\n        side_ns.mult(side_h,side_ns);\n        side_ns1.mult(side_dot1,side_ns1);\n        side_ns.vadd(side_ns1,side_ns);\n        side_ns2.mult(side_dot2,side_ns2);\n        side_ns.vadd(side_ns2,r.rj);\n\n        // Make relative to bodies\n        r.ri.vadd(xi, r.ri);\n        r.ri.vsub(bi.position, r.ri);\n        r.rj.vadd(xj, r.rj);\n        r.rj.vsub(bj.position, r.rj);\n\n        this.result.push(r);\n        this.createFrictionEquationsFromContact(r, this.frictionResult);\n    }\n\n    // Check corners\n    var rj = v3pool.get();\n    var sphere_to_corner = sphereBox_sphere_to_corner;\n    for(var j=0; j!==2 && !found; j++){\n        for(var k=0; k!==2 && !found; k++){\n            for(var l=0; l!==2 && !found; l++){\n                rj.set(0,0,0);\n                if(j){\n                    rj.vadd(sides[0],rj);\n                } else {\n                    rj.vsub(sides[0],rj);\n                }\n                if(k){\n                    rj.vadd(sides[1],rj);\n                } else {\n                    rj.vsub(sides[1],rj);\n                }\n                if(l){\n                    rj.vadd(sides[2],rj);\n                } else {\n                    rj.vsub(sides[2],rj);\n                }\n\n                // World position of corner\n                xj.vadd(rj,sphere_to_corner);\n                sphere_to_corner.vsub(xi,sphere_to_corner);\n\n                if(sphere_to_corner.norm2() < R*R){\n                    found = true;\n                    var r = this.createContactEquation(bi,bj,si,sj);\n                    r.ri.copy(sphere_to_corner);\n                    r.ri.normalize();\n                    r.ni.copy(r.ri);\n                    r.ri.mult(R,r.ri);\n                    r.rj.copy(rj);\n\n                    // Make relative to bodies\n                    r.ri.vadd(xi, r.ri);\n                    r.ri.vsub(bi.position, r.ri);\n                    r.rj.vadd(xj, r.rj);\n                    r.rj.vsub(bj.position, r.rj);\n\n                    this.result.push(r);\n                    this.createFrictionEquationsFromContact(r, this.frictionResult);\n                }\n            }\n        }\n    }\n    v3pool.release(rj);\n    rj = null;\n\n    // Check edges\n    var edgeTangent = v3pool.get();\n    var edgeCenter = v3pool.get();\n    var r = v3pool.get(); // r = edge center to sphere center\n    var orthogonal = v3pool.get();\n    var dist = v3pool.get();\n    var Nsides = sides.length;\n    for(var j=0; j!==Nsides && !found; j++){\n        for(var k=0; k!==Nsides && !found; k++){\n            if(j%3 !== k%3){\n                // Get edge tangent\n                sides[k].cross(sides[j],edgeTangent);\n                edgeTangent.normalize();\n                sides[j].vadd(sides[k], edgeCenter);\n                r.copy(xi);\n                r.vsub(edgeCenter,r);\n                r.vsub(xj,r);\n                var orthonorm = r.dot(edgeTangent); // distance from edge center to sphere center in the tangent direction\n                edgeTangent.mult(orthonorm,orthogonal); // Vector from edge center to sphere center in the tangent direction\n\n                // Find the third side orthogonal to this one\n                var l = 0;\n                while(l===j%3 || l===k%3){\n                    l++;\n                }\n\n                // vec from edge center to sphere projected to the plane orthogonal to the edge tangent\n                dist.copy(xi);\n                dist.vsub(orthogonal,dist);\n                dist.vsub(edgeCenter,dist);\n                dist.vsub(xj,dist);\n\n                // Distances in tangent direction and distance in the plane orthogonal to it\n                var tdist = Math.abs(orthonorm);\n                var ndist = dist.norm();\n\n                if(tdist < sides[l].norm() && ndist<R){\n                    found = true;\n                    var res = this.createContactEquation(bi,bj,si,sj);\n                    edgeCenter.vadd(orthogonal,res.rj); // box rj\n                    res.rj.copy(res.rj);\n                    dist.negate(res.ni);\n                    res.ni.normalize();\n\n                    res.ri.copy(res.rj);\n                    res.ri.vadd(xj,res.ri);\n                    res.ri.vsub(xi,res.ri);\n                    res.ri.normalize();\n                    res.ri.mult(R,res.ri);\n\n                    // Make relative to bodies\n                    res.ri.vadd(xi, res.ri);\n                    res.ri.vsub(bi.position, res.ri);\n                    res.rj.vadd(xj, res.rj);\n                    res.rj.vsub(bj.position, res.rj);\n\n                    this.result.push(res);\n                    this.createFrictionEquationsFromContact(res, this.frictionResult);\n                }\n            }\n        }\n    }\n    v3pool.release(edgeTangent,edgeCenter,r,orthogonal,dist);\n};\n\nvar convex_to_sphere = new Vec3();\nvar sphereConvex_edge = new Vec3();\nvar sphereConvex_edgeUnit = new Vec3();\nvar sphereConvex_sphereToCorner = new Vec3();\nvar sphereConvex_worldCorner = new Vec3();\nvar sphereConvex_worldNormal = new Vec3();\nvar sphereConvex_worldPoint = new Vec3();\nvar sphereConvex_worldSpherePointClosestToPlane = new Vec3();\nvar sphereConvex_penetrationVec = new Vec3();\nvar sphereConvex_sphereToWorldPoint = new Vec3();\n\n/**\n * @method sphereConvex\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\nNarrowphase.prototype[Shape.types.SPHERE | Shape.types.CONVEXPOLYHEDRON] =\nNarrowphase.prototype.sphereConvex = function(si,sj,xi,xj,qi,qj,bi,bj){\n    var v3pool = this.v3pool;\n    xi.vsub(xj,convex_to_sphere);\n    var normals = sj.faceNormals;\n    var faces = sj.faces;\n    var verts = sj.vertices;\n    var R =     si.radius;\n    var penetrating_sides = [];\n\n    // if(convex_to_sphere.norm2() > si.boundingSphereRadius + sj.boundingSphereRadius){\n    //     return;\n    // }\n\n    // Check corners\n    for(var i=0; i!==verts.length; i++){\n        var v = verts[i];\n\n        // World position of corner\n        var worldCorner = sphereConvex_worldCorner;\n        qj.vmult(v,worldCorner);\n        xj.vadd(worldCorner,worldCorner);\n        var sphere_to_corner = sphereConvex_sphereToCorner;\n        worldCorner.vsub(xi, sphere_to_corner);\n        if(sphere_to_corner.norm2() < R * R){\n            found = true;\n            var r = this.createContactEquation(bi,bj,si,sj);\n            r.ri.copy(sphere_to_corner);\n            r.ri.normalize();\n            r.ni.copy(r.ri);\n            r.ri.mult(R,r.ri);\n            worldCorner.vsub(xj,r.rj);\n\n            // Should be relative to the body.\n            r.ri.vadd(xi, r.ri);\n            r.ri.vsub(bi.position, r.ri);\n\n            // Should be relative to the body.\n            r.rj.vadd(xj, r.rj);\n            r.rj.vsub(bj.position, r.rj);\n\n            this.result.push(r);\n            this.createFrictionEquationsFromContact(r, this.frictionResult);\n            return;\n        }\n    }\n\n    // Check side (plane) intersections\n    var found = false;\n    for(var i=0, nfaces=faces.length; i!==nfaces && found===false; i++){\n        var normal = normals[i];\n        var face = faces[i];\n\n        // Get world-transformed normal of the face\n        var worldNormal = sphereConvex_worldNormal;\n        qj.vmult(normal,worldNormal);\n\n        // Get a world vertex from the face\n        var worldPoint = sphereConvex_worldPoint;\n        qj.vmult(verts[face[0]],worldPoint);\n        worldPoint.vadd(xj,worldPoint);\n\n        // Get a point on the sphere, closest to the face normal\n        var worldSpherePointClosestToPlane = sphereConvex_worldSpherePointClosestToPlane;\n        worldNormal.mult(-R, worldSpherePointClosestToPlane);\n        xi.vadd(worldSpherePointClosestToPlane, worldSpherePointClosestToPlane);\n\n        // Vector from a face point to the closest point on the sphere\n        var penetrationVec = sphereConvex_penetrationVec;\n        worldSpherePointClosestToPlane.vsub(worldPoint,penetrationVec);\n\n        // The penetration. Negative value means overlap.\n        var penetration = penetrationVec.dot(worldNormal);\n\n        var worldPointToSphere = sphereConvex_sphereToWorldPoint;\n        xi.vsub(worldPoint, worldPointToSphere);\n\n        if(penetration < 0 && worldPointToSphere.dot(worldNormal)>0){\n            // Intersects plane. Now check if the sphere is inside the face polygon\n            var faceVerts = []; // Face vertices, in world coords\n            for(var j=0, Nverts=face.length; j!==Nverts; j++){\n                var worldVertex = v3pool.get();\n                qj.vmult(verts[face[j]], worldVertex);\n                xj.vadd(worldVertex,worldVertex);\n                faceVerts.push(worldVertex);\n            }\n\n            if(pointInPolygon(faceVerts,worldNormal,xi)){ // Is the sphere center in the face polygon?\n                found = true;\n                var r = this.createContactEquation(bi,bj,si,sj);\n\n                worldNormal.mult(-R, r.ri); // Contact offset, from sphere center to contact\n                worldNormal.negate(r.ni); // Normal pointing out of sphere\n\n                var penetrationVec2 = v3pool.get();\n                worldNormal.mult(-penetration, penetrationVec2);\n                var penetrationSpherePoint = v3pool.get();\n                worldNormal.mult(-R, penetrationSpherePoint);\n\n                //xi.vsub(xj).vadd(penetrationSpherePoint).vadd(penetrationVec2 , r.rj);\n                xi.vsub(xj,r.rj);\n                r.rj.vadd(penetrationSpherePoint,r.rj);\n                r.rj.vadd(penetrationVec2 , r.rj);\n\n                // Should be relative to the body.\n                r.rj.vadd(xj, r.rj);\n                r.rj.vsub(bj.position, r.rj);\n\n                // Should be relative to the body.\n                r.ri.vadd(xi, r.ri);\n                r.ri.vsub(bi.position, r.ri);\n\n                v3pool.release(penetrationVec2);\n                v3pool.release(penetrationSpherePoint);\n\n                this.result.push(r);\n                this.createFrictionEquationsFromContact(r, this.frictionResult);\n\n                // Release world vertices\n                for(var j=0, Nfaceverts=faceVerts.length; j!==Nfaceverts; j++){\n                    v3pool.release(faceVerts[j]);\n                }\n\n                return; // We only expect *one* face contact\n            } else {\n                // Edge?\n                for(var j=0; j!==face.length; j++){\n\n                    // Get two world transformed vertices\n                    var v1 = v3pool.get();\n                    var v2 = v3pool.get();\n                    qj.vmult(verts[face[(j+1)%face.length]], v1);\n                    qj.vmult(verts[face[(j+2)%face.length]], v2);\n                    xj.vadd(v1, v1);\n                    xj.vadd(v2, v2);\n\n                    // Construct edge vector\n                    var edge = sphereConvex_edge;\n                    v2.vsub(v1,edge);\n\n                    // Construct the same vector, but normalized\n                    var edgeUnit = sphereConvex_edgeUnit;\n                    edge.unit(edgeUnit);\n\n                    // p is xi projected onto the edge\n                    var p = v3pool.get();\n                    var v1_to_xi = v3pool.get();\n                    xi.vsub(v1, v1_to_xi);\n                    var dot = v1_to_xi.dot(edgeUnit);\n                    edgeUnit.mult(dot, p);\n                    p.vadd(v1, p);\n\n                    // Compute a vector from p to the center of the sphere\n                    var xi_to_p = v3pool.get();\n                    p.vsub(xi, xi_to_p);\n\n                    // Collision if the edge-sphere distance is less than the radius\n                    // AND if p is in between v1 and v2\n                    if(dot > 0 && dot*dot<edge.norm2() && xi_to_p.norm2() < R*R){ // Collision if the edge-sphere distance is less than the radius\n                        // Edge contact!\n                        var r = this.createContactEquation(bi,bj,si,sj);\n                        p.vsub(xj,r.rj);\n\n                        p.vsub(xi,r.ni);\n                        r.ni.normalize();\n\n                        r.ni.mult(R,r.ri);\n\n                        // Should be relative to the body.\n                        r.rj.vadd(xj, r.rj);\n                        r.rj.vsub(bj.position, r.rj);\n\n                        // Should be relative to the body.\n                        r.ri.vadd(xi, r.ri);\n                        r.ri.vsub(bi.position, r.ri);\n\n                        this.result.push(r);\n                        this.createFrictionEquationsFromContact(r, this.frictionResult);\n\n                        // Release world vertices\n                        for(var j=0, Nfaceverts=faceVerts.length; j!==Nfaceverts; j++){\n                            v3pool.release(faceVerts[j]);\n                        }\n\n                        v3pool.release(v1);\n                        v3pool.release(v2);\n                        v3pool.release(p);\n                        v3pool.release(xi_to_p);\n                        v3pool.release(v1_to_xi);\n\n                        return;\n                    }\n\n                    v3pool.release(v1);\n                    v3pool.release(v2);\n                    v3pool.release(p);\n                    v3pool.release(xi_to_p);\n                    v3pool.release(v1_to_xi);\n                }\n            }\n\n            // Release world vertices\n            for(var j=0, Nfaceverts=faceVerts.length; j!==Nfaceverts; j++){\n                v3pool.release(faceVerts[j]);\n            }\n        }\n    }\n};\n\nvar planeBox_normal = new Vec3();\nvar plane_to_corner = new Vec3();\n\n/**\n * @method planeBox\n * @param  {Array}      result\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\nNarrowphase.prototype[Shape.types.PLANE | Shape.types.BOX] =\nNarrowphase.prototype.planeBox = function(si,sj,xi,xj,qi,qj,bi,bj){\n    sj.convexPolyhedronRepresentation.material = sj.material;\n    sj.convexPolyhedronRepresentation.collisionResponse = sj.collisionResponse;\n    this.planeConvex(si,sj.convexPolyhedronRepresentation,xi,xj,qi,qj,bi,bj);\n};\n\nvar planeConvex_v = new Vec3();\nvar planeConvex_normal = new Vec3();\nvar planeConvex_relpos = new Vec3();\nvar planeConvex_projected = new Vec3();\n\n/**\n * @method planeConvex\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\nNarrowphase.prototype[Shape.types.PLANE | Shape.types.CONVEXPOLYHEDRON] =\nNarrowphase.prototype.planeConvex = function(\n    planeShape,\n    convexShape,\n    planePosition,\n    convexPosition,\n    planeQuat,\n    convexQuat,\n    planeBody,\n    convexBody\n){\n    // Simply return the points behind the plane.\n    var worldVertex = planeConvex_v,\n        worldNormal = planeConvex_normal;\n    worldNormal.set(0,0,1);\n    planeQuat.vmult(worldNormal,worldNormal); // Turn normal according to plane orientation\n\n    var numContacts = 0;\n    var relpos = planeConvex_relpos;\n    for(var i = 0; i !== convexShape.vertices.length; i++){\n\n        // Get world convex vertex\n        worldVertex.copy(convexShape.vertices[i]);\n        convexQuat.vmult(worldVertex, worldVertex);\n        convexPosition.vadd(worldVertex, worldVertex);\n        worldVertex.vsub(planePosition, relpos);\n\n        var dot = worldNormal.dot(relpos);\n        if(dot <= 0.0){\n\n            var r = this.createContactEquation(planeBody, convexBody, planeShape, convexShape);\n\n            // Get vertex position projected on plane\n            var projected = planeConvex_projected;\n            worldNormal.mult(worldNormal.dot(relpos),projected);\n            worldVertex.vsub(projected, projected);\n            projected.vsub(planePosition, r.ri); // From plane to vertex projected on plane\n\n            r.ni.copy(worldNormal); // Contact normal is the plane normal out from plane\n\n            // rj is now just the vector from the convex center to the vertex\n            worldVertex.vsub(convexPosition, r.rj);\n\n            // Make it relative to the body\n            r.ri.vadd(planePosition, r.ri);\n            r.ri.vsub(planeBody.position, r.ri);\n            r.rj.vadd(convexPosition, r.rj);\n            r.rj.vsub(convexBody.position, r.rj);\n\n            this.result.push(r);\n            numContacts++;\n            if(!this.enableFrictionReduction){\n                this.createFrictionEquationsFromContact(r, this.frictionResult);\n            }\n        }\n    }\n\n    if(this.enableFrictionReduction && numContacts){\n        this.createFrictionFromAverage(numContacts);\n    }\n};\n\nvar convexConvex_sepAxis = new Vec3();\nvar convexConvex_q = new Vec3();\n\n/**\n * @method convexConvex\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\nNarrowphase.prototype[Shape.types.CONVEXPOLYHEDRON] =\nNarrowphase.prototype.convexConvex = function(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,faceListA,faceListB){\n    var sepAxis = convexConvex_sepAxis;\n\n    if(xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius){\n        return;\n    }\n\n    if(si.findSeparatingAxis(sj,xi,qi,xj,qj,sepAxis,faceListA,faceListB)){\n        var res = [];\n        var q = convexConvex_q;\n        si.clipAgainstHull(xi,qi,sj,xj,qj,sepAxis,-100,100,res);\n        var numContacts = 0;\n        for(var j = 0; j !== res.length; j++){\n            var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj),\n                ri = r.ri,\n                rj = r.rj;\n            sepAxis.negate(r.ni);\n            res[j].normal.negate(q);\n            q.mult(res[j].depth, q);\n            res[j].point.vadd(q, ri);\n            rj.copy(res[j].point);\n\n            // Contact points are in world coordinates. Transform back to relative\n            ri.vsub(xi,ri);\n            rj.vsub(xj,rj);\n\n            // Make relative to bodies\n            ri.vadd(xi, ri);\n            ri.vsub(bi.position, ri);\n            rj.vadd(xj, rj);\n            rj.vsub(bj.position, rj);\n\n            this.result.push(r);\n            numContacts++;\n            if(!this.enableFrictionReduction){\n                this.createFrictionEquationsFromContact(r, this.frictionResult);\n            }\n        }\n        if(this.enableFrictionReduction && numContacts){\n            this.createFrictionFromAverage(numContacts);\n        }\n    }\n};\n\n\n/**\n * @method convexTrimesh\n * @param  {Array}      result\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\n// Narrowphase.prototype[Shape.types.CONVEXPOLYHEDRON | Shape.types.TRIMESH] =\n// Narrowphase.prototype.convexTrimesh = function(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,faceListA,faceListB){\n//     var sepAxis = convexConvex_sepAxis;\n\n//     if(xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius){\n//         return;\n//     }\n\n//     // Construct a temp hull for each triangle\n//     var hullB = new ConvexPolyhedron();\n\n//     hullB.faces = [[0,1,2]];\n//     var va = new Vec3();\n//     var vb = new Vec3();\n//     var vc = new Vec3();\n//     hullB.vertices = [\n//         va,\n//         vb,\n//         vc\n//     ];\n\n//     for (var i = 0; i < sj.indices.length / 3; i++) {\n\n//         var triangleNormal = new Vec3();\n//         sj.getNormal(i, triangleNormal);\n//         hullB.faceNormals = [triangleNormal];\n\n//         sj.getTriangleVertices(i, va, vb, vc);\n\n//         var d = si.testSepAxis(triangleNormal, hullB, xi, qi, xj, qj);\n//         if(!d){\n//             triangleNormal.scale(-1, triangleNormal);\n//             d = si.testSepAxis(triangleNormal, hullB, xi, qi, xj, qj);\n\n//             if(!d){\n//                 continue;\n//             }\n//         }\n\n//         var res = [];\n//         var q = convexConvex_q;\n//         si.clipAgainstHull(xi,qi,hullB,xj,qj,triangleNormal,-100,100,res);\n//         for(var j = 0; j !== res.length; j++){\n//             var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj),\n//                 ri = r.ri,\n//                 rj = r.rj;\n//             r.ni.copy(triangleNormal);\n//             r.ni.negate(r.ni);\n//             res[j].normal.negate(q);\n//             q.mult(res[j].depth, q);\n//             res[j].point.vadd(q, ri);\n//             rj.copy(res[j].point);\n\n//             // Contact points are in world coordinates. Transform back to relative\n//             ri.vsub(xi,ri);\n//             rj.vsub(xj,rj);\n\n//             // Make relative to bodies\n//             ri.vadd(xi, ri);\n//             ri.vsub(bi.position, ri);\n//             rj.vadd(xj, rj);\n//             rj.vsub(bj.position, rj);\n\n//             result.push(r);\n//         }\n//     }\n// };\n\nvar particlePlane_normal = new Vec3();\nvar particlePlane_relpos = new Vec3();\nvar particlePlane_projected = new Vec3();\n\n/**\n * @method particlePlane\n * @param  {Array}      result\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\nNarrowphase.prototype[Shape.types.PLANE | Shape.types.PARTICLE] =\nNarrowphase.prototype.planeParticle = function(sj,si,xj,xi,qj,qi,bj,bi){\n    var normal = particlePlane_normal;\n    normal.set(0,0,1);\n    bj.quaternion.vmult(normal,normal); // Turn normal according to plane orientation\n    var relpos = particlePlane_relpos;\n    xi.vsub(bj.position,relpos);\n    var dot = normal.dot(relpos);\n    if(dot <= 0.0){\n        var r = this.createContactEquation(bi,bj,si,sj);\n        r.ni.copy(normal); // Contact normal is the plane normal\n        r.ni.negate(r.ni);\n        r.ri.set(0,0,0); // Center of particle\n\n        // Get particle position projected on plane\n        var projected = particlePlane_projected;\n        normal.mult(normal.dot(xi),projected);\n        xi.vsub(projected,projected);\n        //projected.vadd(bj.position,projected);\n\n        // rj is now the projected world position minus plane position\n        r.rj.copy(projected);\n        this.result.push(r);\n        this.createFrictionEquationsFromContact(r, this.frictionResult);\n    }\n};\n\nvar particleSphere_normal = new Vec3();\n\n/**\n * @method particleSphere\n * @param  {Array}      result\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\nNarrowphase.prototype[Shape.types.PARTICLE | Shape.types.SPHERE] =\nNarrowphase.prototype.sphereParticle = function(sj,si,xj,xi,qj,qi,bj,bi){\n    // The normal is the unit vector from sphere center to particle center\n    var normal = particleSphere_normal;\n    normal.set(0,0,1);\n    xi.vsub(xj,normal);\n    var lengthSquared = normal.norm2();\n\n    if(lengthSquared <= sj.radius * sj.radius){\n        var r = this.createContactEquation(bi,bj,si,sj);\n        normal.normalize();\n        r.rj.copy(normal);\n        r.rj.mult(sj.radius,r.rj);\n        r.ni.copy(normal); // Contact normal\n        r.ni.negate(r.ni);\n        r.ri.set(0,0,0); // Center of particle\n        this.result.push(r);\n        this.createFrictionEquationsFromContact(r, this.frictionResult);\n    }\n};\n\n// WIP\nvar cqj = new Quaternion();\nvar convexParticle_local = new Vec3();\nvar convexParticle_normal = new Vec3();\nvar convexParticle_penetratedFaceNormal = new Vec3();\nvar convexParticle_vertexToParticle = new Vec3();\nvar convexParticle_worldPenetrationVec = new Vec3();\n\n/**\n * @method convexParticle\n * @param  {Array}      result\n * @param  {Shape}      si\n * @param  {Shape}      sj\n * @param  {Vec3}       xi\n * @param  {Vec3}       xj\n * @param  {Quaternion} qi\n * @param  {Quaternion} qj\n * @param  {Body}       bi\n * @param  {Body}       bj\n */\nNarrowphase.prototype[Shape.types.PARTICLE | Shape.types.CONVEXPOLYHEDRON] =\nNarrowphase.prototype.convexParticle = function(sj,si,xj,xi,qj,qi,bj,bi){\n    var penetratedFaceIndex = -1;\n    var penetratedFaceNormal = convexParticle_penetratedFaceNormal;\n    var worldPenetrationVec = convexParticle_worldPenetrationVec;\n    var minPenetration = null;\n    var numDetectedFaces = 0;\n\n    // Convert particle position xi to local coords in the convex\n    var local = convexParticle_local;\n    local.copy(xi);\n    local.vsub(xj,local); // Convert position to relative the convex origin\n    qj.conjugate(cqj);\n    cqj.vmult(local,local);\n\n    if(sj.pointIsInside(local)){\n\n        if(sj.worldVerticesNeedsUpdate){\n            sj.computeWorldVertices(xj,qj);\n        }\n        if(sj.worldFaceNormalsNeedsUpdate){\n            sj.computeWorldFaceNormals(qj);\n        }\n\n        // For each world polygon in the polyhedra\n        for(var i=0,nfaces=sj.faces.length; i!==nfaces; i++){\n\n            // Construct world face vertices\n            var verts = [ sj.worldVertices[ sj.faces[i][0] ] ];\n            var normal = sj.worldFaceNormals[i];\n\n            // Check how much the particle penetrates the polygon plane.\n            xi.vsub(verts[0],convexParticle_vertexToParticle);\n            var penetration = -normal.dot(convexParticle_vertexToParticle);\n            if(minPenetration===null || Math.abs(penetration)<Math.abs(minPenetration)){\n                minPenetration = penetration;\n                penetratedFaceIndex = i;\n                penetratedFaceNormal.copy(normal);\n                numDetectedFaces++;\n            }\n        }\n\n        if(penetratedFaceIndex!==-1){\n            // Setup contact\n            var r = this.createContactEquation(bi,bj,si,sj);\n            penetratedFaceNormal.mult(minPenetration, worldPenetrationVec);\n\n            // rj is the particle position projected to the face\n            worldPenetrationVec.vadd(xi,worldPenetrationVec);\n            worldPenetrationVec.vsub(xj,worldPenetrationVec);\n            r.rj.copy(worldPenetrationVec);\n            //var projectedToFace = xi.vsub(xj).vadd(worldPenetrationVec);\n            //projectedToFace.copy(r.rj);\n\n            //qj.vmult(r.rj,r.rj);\n            penetratedFaceNormal.negate( r.ni ); // Contact normal\n            r.ri.set(0,0,0); // Center of particle\n\n            var ri = r.ri,\n                rj = r.rj;\n\n            // Make relative to bodies\n            ri.vadd(xi, ri);\n            ri.vsub(bi.position, ri);\n            rj.vadd(xj, rj);\n            rj.vsub(bj.position, rj);\n\n            this.result.push(r);\n            this.createFrictionEquationsFromContact(r, this.frictionResult);\n        } else {\n            console.warn(\"Point found inside convex, but did not find penetrating face!\");\n        }\n    }\n};\n\nNarrowphase.prototype[Shape.types.BOX | Shape.types.HEIGHTFIELD] =\nNarrowphase.prototype.boxHeightfield = function (si,sj,xi,xj,qi,qj,bi,bj){\n    si.convexPolyhedronRepresentation.material = si.material;\n    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;\n    this.convexHeightfield(si.convexPolyhedronRepresentation,sj,xi,xj,qi,qj,bi,bj);\n};\n\nvar convexHeightfield_tmp1 = new Vec3();\nvar convexHeightfield_tmp2 = new Vec3();\nvar convexHeightfield_faceList = [0];\n\n/**\n * @method convexHeightfield\n */\nNarrowphase.prototype[Shape.types.CONVEXPOLYHEDRON | Shape.types.HEIGHTFIELD] =\nNarrowphase.prototype.convexHeightfield = function (\n    convexShape,\n    hfShape,\n    convexPos,\n    hfPos,\n    convexQuat,\n    hfQuat,\n    convexBody,\n    hfBody\n){\n    var data = hfShape.data,\n        w = hfShape.elementSize,\n        radius = convexShape.boundingSphereRadius,\n        worldPillarOffset = convexHeightfield_tmp2,\n        faceList = convexHeightfield_faceList;\n\n    // Get sphere position to heightfield local!\n    var localConvexPos = convexHeightfield_tmp1;\n    Transform.pointToLocalFrame(hfPos, hfQuat, convexPos, localConvexPos);\n\n    // Get the index of the data points to test against\n    var iMinX = Math.floor((localConvexPos.x - radius) / w) - 1,\n        iMaxX = Math.ceil((localConvexPos.x + radius) / w) + 1,\n        iMinY = Math.floor((localConvexPos.y - radius) / w) - 1,\n        iMaxY = Math.ceil((localConvexPos.y + radius) / w) + 1;\n\n    // Bail out if we are out of the terrain\n    if(iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMinY > data[0].length){\n        return;\n    }\n\n    // Clamp index to edges\n    if(iMinX < 0){ iMinX = 0; }\n    if(iMaxX < 0){ iMaxX = 0; }\n    if(iMinY < 0){ iMinY = 0; }\n    if(iMaxY < 0){ iMaxY = 0; }\n    if(iMinX >= data.length){ iMinX = data.length - 1; }\n    if(iMaxX >= data.length){ iMaxX = data.length - 1; }\n    if(iMaxY >= data[0].length){ iMaxY = data[0].length - 1; }\n    if(iMinY >= data[0].length){ iMinY = data[0].length - 1; }\n\n    var minMax = [];\n    hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);\n    var min = minMax[0];\n    var max = minMax[1];\n\n    // Bail out if we're cant touch the bounding height box\n    if(localConvexPos.z - radius > max || localConvexPos.z + radius < min){\n        return;\n    }\n\n    for(var i = iMinX; i < iMaxX; i++){\n        for(var j = iMinY; j < iMaxY; j++){\n\n            // Lower triangle\n            hfShape.getConvexTrianglePillar(i, j, false);\n            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);\n            if (convexPos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + convexShape.boundingSphereRadius) {\n                this.convexConvex(convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset, convexQuat, hfQuat, convexBody, hfBody, null, null, faceList, null);\n            }\n\n            // Upper triangle\n            hfShape.getConvexTrianglePillar(i, j, true);\n            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);\n            if (convexPos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + convexShape.boundingSphereRadius) {\n                this.convexConvex(convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset, convexQuat, hfQuat, convexBody, hfBody, null, null, faceList, null);\n            }\n        }\n    }\n};\n\nvar sphereHeightfield_tmp1 = new Vec3();\nvar sphereHeightfield_tmp2 = new Vec3();\n\n/**\n * @method sphereHeightfield\n */\nNarrowphase.prototype[Shape.types.SPHERE | Shape.types.HEIGHTFIELD] =\nNarrowphase.prototype.sphereHeightfield = function (\n    sphereShape,\n    hfShape,\n    spherePos,\n    hfPos,\n    sphereQuat,\n    hfQuat,\n    sphereBody,\n    hfBody\n){\n    var data = hfShape.data,\n        radius = sphereShape.radius,\n        w = hfShape.elementSize,\n        worldPillarOffset = sphereHeightfield_tmp2;\n\n    // Get sphere position to heightfield local!\n    var localSpherePos = sphereHeightfield_tmp1;\n    Transform.pointToLocalFrame(hfPos, hfQuat, spherePos, localSpherePos);\n\n    // Get the index of the data points to test against\n    var iMinX = Math.floor((localSpherePos.x - radius) / w) - 1,\n        iMaxX = Math.ceil((localSpherePos.x + radius) / w) + 1,\n        iMinY = Math.floor((localSpherePos.y - radius) / w) - 1,\n        iMaxY = Math.ceil((localSpherePos.y + radius) / w) + 1;\n\n    // Bail out if we are out of the terrain\n    if(iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMaxY > data[0].length){\n        return;\n    }\n\n    // Clamp index to edges\n    if(iMinX < 0){ iMinX = 0; }\n    if(iMaxX < 0){ iMaxX = 0; }\n    if(iMinY < 0){ iMinY = 0; }\n    if(iMaxY < 0){ iMaxY = 0; }\n    if(iMinX >= data.length){ iMinX = data.length - 1; }\n    if(iMaxX >= data.length){ iMaxX = data.length - 1; }\n    if(iMaxY >= data[0].length){ iMaxY = data[0].length - 1; }\n    if(iMinY >= data[0].length){ iMinY = data[0].length - 1; }\n\n    var minMax = [];\n    hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);\n    var min = minMax[0];\n    var max = minMax[1];\n\n    // Bail out if we're cant touch the bounding height box\n    if(localSpherePos.z - radius > max || localSpherePos.z + radius < min){\n        return;\n    }\n\n    var result = this.result;\n    for(var i = iMinX; i < iMaxX; i++){\n        for(var j = iMinY; j < iMaxY; j++){\n\n            var numContactsBefore = result.length;\n\n            // Lower triangle\n            hfShape.getConvexTrianglePillar(i, j, false);\n            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);\n            if (spherePos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + sphereShape.boundingSphereRadius) {\n                this.sphereConvex(sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset, sphereQuat, hfQuat, sphereBody, hfBody);\n            }\n\n            // Upper triangle\n            hfShape.getConvexTrianglePillar(i, j, true);\n            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);\n            if (spherePos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + sphereShape.boundingSphereRadius) {\n                this.sphereConvex(sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset, sphereQuat, hfQuat, sphereBody, hfBody);\n            }\n\n            var numContacts = result.length - numContactsBefore;\n\n            if(numContacts > 2){\n                return;\n            }\n            /*\n            // Skip all but 1\n            for (var k = 0; k < numContacts - 1; k++) {\n                result.pop();\n            }\n            */\n        }\n    }\n};\n\n},{\"../collision/AABB\":3,\"../collision/Ray\":9,\"../equations/ContactEquation\":19,\"../equations/FrictionEquation\":21,\"../math/Quaternion\":28,\"../math/Transform\":29,\"../math/Vec3\":30,\"../shapes/ConvexPolyhedron\":38,\"../shapes/Shape\":43,\"../solver/Solver\":47,\"../utils/Vec3Pool\":54}],56:[function(_dereq_,module,exports){\n/* global performance */\n\nmodule.exports = World;\n\nvar Shape = _dereq_('../shapes/Shape');\nvar Vec3 = _dereq_('../math/Vec3');\nvar Quaternion = _dereq_('../math/Quaternion');\nvar GSSolver = _dereq_('../solver/GSSolver');\nvar Vec3Pool = _dereq_('../utils/Vec3Pool');\nvar ContactEquation = _dereq_('../equations/ContactEquation');\nvar FrictionEquation = _dereq_('../equations/FrictionEquation');\nvar Narrowphase = _dereq_('./Narrowphase');\nvar EventTarget = _dereq_('../utils/EventTarget');\nvar ArrayCollisionMatrix = _dereq_('../collision/ArrayCollisionMatrix');\nvar Material = _dereq_('../material/Material');\nvar ContactMaterial = _dereq_('../material/ContactMaterial');\nvar Body = _dereq_('../objects/Body');\nvar TupleDictionary = _dereq_('../utils/TupleDictionary');\nvar RaycastResult = _dereq_('../collision/RaycastResult');\nvar AABB = _dereq_('../collision/AABB');\nvar Ray = _dereq_('../collision/Ray');\nvar NaiveBroadphase = _dereq_('../collision/NaiveBroadphase');\n\n/**\n * The physics world\n * @class World\n * @constructor\n * @extends EventTarget\n */\nfunction World(){\n    EventTarget.apply(this);\n\n    /**\n     * Currently / last used timestep. Is set to -1 if not available. This value is updated before each internal step, which means that it is \"fresh\" inside event callbacks.\n     * @property {Number} dt\n     */\n    this.dt = -1;\n\n    /**\n     * Makes bodies go to sleep when they've been inactive\n     * @property allowSleep\n     * @type {Boolean}\n     */\n    this.allowSleep = false;\n\n    /**\n     * All the current contacts (instances of ContactEquation) in the world.\n     * @property contacts\n     * @type {Array}\n     */\n    this.contacts = [];\n    this.frictionEquations = [];\n\n    /**\n     * How often to normalize quaternions. Set to 0 for every step, 1 for every second etc.. A larger value increases performance. If bodies tend to explode, set to a smaller value (zero to be sure nothing can go wrong).\n     * @property quatNormalizeSkip\n     * @type {Number}\n     */\n    this.quatNormalizeSkip = 0;\n\n    /**\n     * Set to true to use fast quaternion normalization. It is often enough accurate to use. If bodies tend to explode, set to false.\n     * @property quatNormalizeFast\n     * @type {Boolean}\n     * @see Quaternion.normalizeFast\n     * @see Quaternion.normalize\n     */\n    this.quatNormalizeFast = false;\n\n    /**\n     * The wall-clock time since simulation start\n     * @property time\n     * @type {Number}\n     */\n    this.time = 0.0;\n\n    /**\n     * Number of timesteps taken since start\n     * @property stepnumber\n     * @type {Number}\n     */\n    this.stepnumber = 0;\n\n    /// Default and last timestep sizes\n    this.default_dt = 1/60;\n\n    this.nextId = 0;\n    /**\n     * @property gravity\n     * @type {Vec3}\n     */\n    this.gravity = new Vec3();\n\n    /**\n     * @property broadphase\n     * @type {Broadphase}\n     */\n    this.broadphase = new NaiveBroadphase();\n\n    /**\n     * @property bodies\n     * @type {Array}\n     */\n    this.bodies = [];\n\n    /**\n     * @property solver\n     * @type {Solver}\n     */\n    this.solver = new GSSolver();\n\n    /**\n     * @property constraints\n     * @type {Array}\n     */\n    this.constraints = [];\n\n    /**\n     * @property narrowphase\n     * @type {Narrowphase}\n     */\n    this.narrowphase = new Narrowphase(this);\n\n    /**\n     * @property {ArrayCollisionMatrix} collisionMatrix\n\t * @type {ArrayCollisionMatrix}\n\t */\n\tthis.collisionMatrix = new ArrayCollisionMatrix();\n\n    /**\n     * CollisionMatrix from the previous step.\n     * @property {ArrayCollisionMatrix} collisionMatrixPrevious\n\t * @type {ArrayCollisionMatrix}\n\t */\n\tthis.collisionMatrixPrevious = new ArrayCollisionMatrix();\n\n    /**\n     * All added materials\n     * @property materials\n     * @type {Array}\n     */\n    this.materials = [];\n\n    /**\n     * @property contactmaterials\n     * @type {Array}\n     */\n    this.contactmaterials = [];\n\n    /**\n     * Used to look up a ContactMaterial given two instances of Material.\n     * @property {TupleDictionary} contactMaterialTable\n     */\n    this.contactMaterialTable = new TupleDictionary();\n\n    this.defaultMaterial = new Material(\"default\");\n\n    /**\n     * This contact material is used if no suitable contactmaterial is found for a contact.\n     * @property defaultContactMaterial\n     * @type {ContactMaterial}\n     */\n    this.defaultContactMaterial = new ContactMaterial(this.defaultMaterial, this.defaultMaterial, { friction: 0.3, restitution: 0.0 });\n\n    /**\n     * @property doProfiling\n     * @type {Boolean}\n     */\n    this.doProfiling = false;\n\n    /**\n     * @property profile\n     * @type {Object}\n     */\n    this.profile = {\n        solve:0,\n        makeContactConstraints:0,\n        broadphase:0,\n        integrate:0,\n        narrowphase:0,\n    };\n\n    /**\n     * @property subsystems\n     * @type {Array}\n     */\n    this.subsystems = [];\n\n    this.addBodyEvent = {\n        type:\"addBody\",\n        body : null,\n    };\n\n    this.removeBodyEvent = {\n        type:\"removeBody\",\n        body : null,\n    };\n}\nWorld.prototype = new EventTarget();\n\n// Temp stuff\nvar tmpAABB1 = new AABB();\nvar tmpArray1 = [];\nvar tmpRay = new Ray();\n\n/**\n * Get the contact material between materials m1 and m2\n * @method getContactMaterial\n * @param {Material} m1\n * @param {Material} m2\n * @return {ContactMaterial} The contact material if it was found.\n */\nWorld.prototype.getContactMaterial = function(m1,m2){\n    return this.contactMaterialTable.get(m1.id,m2.id); //this.contactmaterials[this.mats2cmat[i+j*this.materials.length]];\n};\n\n/**\n * Get number of objects in the world.\n * @method numObjects\n * @return {Number}\n * @deprecated\n */\nWorld.prototype.numObjects = function(){\n    return this.bodies.length;\n};\n\n/**\n * Store old collision state info\n * @method collisionMatrixTick\n */\nWorld.prototype.collisionMatrixTick = function(){\n\tvar temp = this.collisionMatrixPrevious;\n\tthis.collisionMatrixPrevious = this.collisionMatrix;\n\tthis.collisionMatrix = temp;\n\tthis.collisionMatrix.reset();\n};\n\n/**\n * Add a rigid body to the simulation.\n * @method add\n * @param {Body} body\n * @todo If the simulation has not yet started, why recrete and copy arrays for each body? Accumulate in dynamic arrays in this case.\n * @todo Adding an array of bodies should be possible. This would save some loops too\n * @deprecated Use .addBody instead\n */\nWorld.prototype.add = World.prototype.addBody = function(body){\n    if(this.bodies.indexOf(body) !== -1){\n        return;\n    }\n    body.index = this.bodies.length;\n    this.bodies.push(body);\n    body.world = this;\n    body.initPosition.copy(body.position);\n    body.initVelocity.copy(body.velocity);\n    body.timeLastSleepy = this.time;\n    if(body instanceof Body){\n        body.initAngularVelocity.copy(body.angularVelocity);\n        body.initQuaternion.copy(body.quaternion);\n    }\n\tthis.collisionMatrix.setNumObjects(this.bodies.length);\n    this.addBodyEvent.body = body;\n    this.dispatchEvent(this.addBodyEvent);\n};\n\n/**\n * Add a constraint to the simulation.\n * @method addConstraint\n * @param {Constraint} c\n */\nWorld.prototype.addConstraint = function(c){\n    this.constraints.push(c);\n};\n\n/**\n * Removes a constraint\n * @method removeConstraint\n * @param {Constraint} c\n */\nWorld.prototype.removeConstraint = function(c){\n    var idx = this.constraints.indexOf(c);\n    if(idx!==-1){\n        this.constraints.splice(idx,1);\n    }\n};\n\n/**\n * Raycast test\n * @method rayTest\n * @param {Vec3} from\n * @param {Vec3} to\n * @param {Function|RaycastResult} result\n * @deprecated Use .raycastAll, .raycastClosest or .raycastAny instead.\n */\nWorld.prototype.rayTest = function(from, to, result){\n    if(result instanceof RaycastResult){\n        // Do raycastclosest\n        this.raycastClosest(from, to, {\n            skipBackfaces: true\n        }, result);\n    } else {\n        // Do raycastAll\n        this.raycastAll(from, to, {\n            skipBackfaces: true\n        }, result);\n    }\n};\n\n/**\n * Ray cast against all bodies. The provided callback will be executed for each hit with a RaycastResult as single argument.\n * @method raycastAll\n * @param  {Vec3} from\n * @param  {Vec3} to\n * @param  {Object} options\n * @param  {number} [options.collisionFilterMask=-1]\n * @param  {number} [options.collisionFilterGroup=-1]\n * @param  {boolean} [options.skipBackfaces=false]\n * @param  {boolean} [options.checkCollisionResponse=true]\n * @param  {Function} callback\n * @return {boolean} True if any body was hit.\n */\nWorld.prototype.raycastAll = function(from, to, options, callback){\n    options.mode = Ray.ALL;\n    options.from = from;\n    options.to = to;\n    options.callback = callback;\n    return tmpRay.intersectWorld(this, options);\n};\n\n/**\n * Ray cast, and stop at the first result. Note that the order is random - but the method is fast.\n * @method raycastAny\n * @param  {Vec3} from\n * @param  {Vec3} to\n * @param  {Object} options\n * @param  {number} [options.collisionFilterMask=-1]\n * @param  {number} [options.collisionFilterGroup=-1]\n * @param  {boolean} [options.skipBackfaces=false]\n * @param  {boolean} [options.checkCollisionResponse=true]\n * @param  {RaycastResult} result\n * @return {boolean} True if any body was hit.\n */\nWorld.prototype.raycastAny = function(from, to, options, result){\n    options.mode = Ray.ANY;\n    options.from = from;\n    options.to = to;\n    options.result = result;\n    return tmpRay.intersectWorld(this, options);\n};\n\n/**\n * Ray cast, and return information of the closest hit.\n * @method raycastClosest\n * @param  {Vec3} from\n * @param  {Vec3} to\n * @param  {Object} options\n * @param  {number} [options.collisionFilterMask=-1]\n * @param  {number} [options.collisionFilterGroup=-1]\n * @param  {boolean} [options.skipBackfaces=false]\n * @param  {boolean} [options.checkCollisionResponse=true]\n * @param  {RaycastResult} result\n * @return {boolean} True if any body was hit.\n */\nWorld.prototype.raycastClosest = function(from, to, options, result){\n    options.mode = Ray.CLOSEST;\n    options.from = from;\n    options.to = to;\n    options.result = result;\n    return tmpRay.intersectWorld(this, options);\n};\n\n/**\n * Remove a rigid body from the simulation.\n * @method remove\n * @param {Body} body\n * @deprecated Use .removeBody instead\n */\nWorld.prototype.remove = function(body){\n    body.world = null;\n    var n = this.bodies.length-1,\n        bodies = this.bodies,\n        idx = bodies.indexOf(body);\n    if(idx !== -1){\n        bodies.splice(idx, 1); // Todo: should use a garbage free method\n\n        // Recompute index\n        for(var i=0; i!==bodies.length; i++){\n            bodies[i].index = i;\n        }\n\n        this.collisionMatrix.setNumObjects(n);\n        this.removeBodyEvent.body = body;\n        this.dispatchEvent(this.removeBodyEvent);\n    }\n};\n\n/**\n * Remove a rigid body from the simulation.\n * @method removeBody\n * @param {Body} body\n */\nWorld.prototype.removeBody = World.prototype.remove;\n\n/**\n * Adds a material to the World.\n * @method addMaterial\n * @param {Material} m\n * @todo Necessary?\n */\nWorld.prototype.addMaterial = function(m){\n    this.materials.push(m);\n};\n\n/**\n * Adds a contact material to the World\n * @method addContactMaterial\n * @param {ContactMaterial} cmat\n */\nWorld.prototype.addContactMaterial = function(cmat) {\n\n    // Add contact material\n    this.contactmaterials.push(cmat);\n\n    // Add current contact material to the material table\n    this.contactMaterialTable.set(cmat.materials[0].id,cmat.materials[1].id,cmat);\n};\n\n// performance.now()\nif(typeof performance === 'undefined'){\n    performance = {};\n}\nif(!performance.now){\n    var nowOffset = Date.now();\n    if (performance.timing && performance.timing.navigationStart){\n        nowOffset = performance.timing.navigationStart;\n    }\n    performance.now = function(){\n        return Date.now() - nowOffset;\n    };\n}\n\nvar step_tmp1 = new Vec3();\n\n/**\n * Step the physics world forward in time.\n *\n * There are two modes. The simple mode is fixed timestepping without interpolation. In this case you only use the first argument. The second case uses interpolation. In that you also provide the time since the function was last used, as well as the maximum fixed timesteps to take.\n *\n * @method step\n * @param {Number} dt                       The fixed time step size to use.\n * @param {Number} [timeSinceLastCalled]    The time elapsed since the function was last called.\n * @param {Number} [maxSubSteps=10]         Maximum number of fixed steps to take per function call.\n *\n * @example\n *     // fixed timestepping without interpolation\n *     world.step(1/60);\n *\n * @see http://bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World\n */\nWorld.prototype.step = function(dt, timeSinceLastCalled, maxSubSteps){\n    maxSubSteps = maxSubSteps || 10;\n    timeSinceLastCalled = timeSinceLastCalled || 0;\n\n    if(timeSinceLastCalled === 0){ // Fixed, simple stepping\n\n        this.internalStep(dt);\n\n        // Increment time\n        this.time += dt;\n\n    } else {\n\n        // Compute the number of fixed steps we should have taken since the last step\n        var internalSteps = Math.floor((this.time + timeSinceLastCalled) / dt) - Math.floor(this.time / dt);\n        internalSteps = Math.min(internalSteps,maxSubSteps);\n\n        // Do some fixed steps to catch up\n        var t0 = performance.now();\n        for(var i=0; i!==internalSteps; i++){\n            this.internalStep(dt);\n            if(performance.now() - t0 > dt * 1000){\n                // We are slower than real-time. Better bail out.\n                break;\n            }\n        }\n\n        // Increment internal clock\n        this.time += timeSinceLastCalled;\n\n        // Compute \"Left over\" time step\n        var h = this.time % dt;\n        var h_div_dt = h / dt;\n        var interpvelo = step_tmp1;\n        var bodies = this.bodies;\n\n        for(var j=0; j !== bodies.length; j++){\n            var b = bodies[j];\n            if(b.type !== Body.STATIC && b.sleepState !== Body.SLEEPING){\n\n                // Interpolate\n                b.position.vsub(b.previousPosition, interpvelo);\n                interpvelo.scale(h_div_dt, interpvelo);\n                b.position.vadd(interpvelo, b.interpolatedPosition);\n\n                // TODO: interpolate quaternion\n                // b.interpolatedAngle = b.angle + (b.angle - b.previousAngle) * h_div_dt;\n\n            } else {\n\n                // For static bodies, just copy. Who else will do it?\n                b.interpolatedPosition.copy(b.position);\n                b.interpolatedQuaternion.copy(b.quaternion);\n            }\n        }\n    }\n};\n\n/**\n * Step the simulation\n * @method step\n * @param {Number} dt\n */\nvar World_step_postStepEvent = {type:\"postStep\"}, // Reusable event objects to save memory\n    World_step_preStepEvent = {type:\"preStep\"},\n    World_step_collideEvent = {type:\"collide\", body:null, contact:null },\n    World_step_oldContacts = [], // Pools for unused objects\n    World_step_frictionEquationPool = [],\n    World_step_p1 = [], // Reusable arrays for collision pairs\n    World_step_p2 = [],\n    World_step_gvec = new Vec3(), // Temporary vectors and quats\n    World_step_vi = new Vec3(),\n    World_step_vj = new Vec3(),\n    World_step_wi = new Vec3(),\n    World_step_wj = new Vec3(),\n    World_step_t1 = new Vec3(),\n    World_step_t2 = new Vec3(),\n    World_step_rixn = new Vec3(),\n    World_step_rjxn = new Vec3(),\n    World_step_step_q = new Quaternion(),\n    World_step_step_w = new Quaternion(),\n    World_step_step_wq = new Quaternion(),\n    invI_tau_dt = new Vec3();\nWorld.prototype.internalStep = function(dt){\n    this.dt = dt;\n\n    var world = this,\n        that = this,\n        contacts = this.contacts,\n        p1 = World_step_p1,\n        p2 = World_step_p2,\n        N = this.numObjects(),\n        bodies = this.bodies,\n        solver = this.solver,\n        gravity = this.gravity,\n        doProfiling = this.doProfiling,\n        profile = this.profile,\n        DYNAMIC = Body.DYNAMIC,\n        profilingStart,\n        constraints = this.constraints,\n        frictionEquationPool = World_step_frictionEquationPool,\n        gnorm = gravity.norm(),\n        gx = gravity.x,\n        gy = gravity.y,\n        gz = gravity.z,\n        i=0;\n\n    if(doProfiling){\n        profilingStart = performance.now();\n    }\n\n    // Add gravity to all objects\n    for(i=0; i!==N; i++){\n        var bi = bodies[i];\n        if(bi.type & DYNAMIC){ // Only for dynamic bodies\n            var f = bi.force, m = bi.mass;\n            f.x += m*gx;\n            f.y += m*gy;\n            f.z += m*gz;\n        }\n    }\n\n    // Update subsystems\n    for(var i=0, Nsubsystems=this.subsystems.length; i!==Nsubsystems; i++){\n        this.subsystems[i].update();\n    }\n\n    // Collision detection\n    if(doProfiling){ profilingStart = performance.now(); }\n    p1.length = 0; // Clean up pair arrays from last step\n    p2.length = 0;\n    this.broadphase.collisionPairs(this,p1,p2);\n    if(doProfiling){ profile.broadphase = performance.now() - profilingStart; }\n\n    // Remove constrained pairs with collideConnected == false\n    var Nconstraints = constraints.length;\n    for(i=0; i!==Nconstraints; i++){\n        var c = constraints[i];\n        if(!c.collideConnected){\n            for(var j = p1.length-1; j>=0; j-=1){\n                if( (c.bodyA === p1[j] && c.bodyB === p2[j]) ||\n                    (c.bodyB === p1[j] && c.bodyA === p2[j])){\n                    p1.splice(j, 1);\n                    p2.splice(j, 1);\n                }\n            }\n        }\n    }\n\n    this.collisionMatrixTick();\n\n    // Generate contacts\n    if(doProfiling){ profilingStart = performance.now(); }\n    var oldcontacts = World_step_oldContacts;\n    var NoldContacts = contacts.length;\n\n    for(i=0; i!==NoldContacts; i++){\n        oldcontacts.push(contacts[i]);\n    }\n    contacts.length = 0;\n\n    // Transfer FrictionEquation from current list to the pool for reuse\n    var NoldFrictionEquations = this.frictionEquations.length;\n    for(i=0; i!==NoldFrictionEquations; i++){\n        frictionEquationPool.push(this.frictionEquations[i]);\n    }\n    this.frictionEquations.length = 0;\n\n    this.narrowphase.getContacts(\n        p1,\n        p2,\n        this,\n        contacts,\n        oldcontacts, // To be reused\n        this.frictionEquations,\n        frictionEquationPool\n    );\n\n    if(doProfiling){\n        profile.narrowphase = performance.now() - profilingStart;\n    }\n\n    // Loop over all collisions\n    if(doProfiling){\n        profilingStart = performance.now();\n    }\n\n    // Add all friction eqs\n    for (var i = 0; i < this.frictionEquations.length; i++) {\n        solver.addEquation(this.frictionEquations[i]);\n    }\n\n    var ncontacts = contacts.length;\n    for(var k=0; k!==ncontacts; k++){\n\n        // Current contact\n        var c = contacts[k];\n\n        // Get current collision indeces\n        var bi = c.bi,\n            bj = c.bj,\n            si = c.si,\n            sj = c.sj;\n\n        // Get collision properties\n        var cm;\n        if(bi.material && bj.material){\n            cm = this.getContactMaterial(bi.material,bj.material) || this.defaultContactMaterial;\n        } else {\n            cm = this.defaultContactMaterial;\n        }\n\n        // c.enabled = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;\n\n        var mu = cm.friction;\n        // c.restitution = cm.restitution;\n\n        // If friction or restitution were specified in the material, use them\n        if(bi.material && bj.material){\n            if(bi.material.friction >= 0 && bj.material.friction >= 0){\n                mu = bi.material.friction * bj.material.friction;\n            }\n\n            if(bi.material.restitution >= 0 && bj.material.restitution >= 0){\n                c.restitution = bi.material.restitution * bj.material.restitution;\n            }\n        }\n\n\t\t// c.setSpookParams(\n  //           cm.contactEquationStiffness,\n  //           cm.contactEquationRelaxation,\n  //           dt\n  //       );\n\n\t\tsolver.addEquation(c);\n\n\t\t// // Add friction constraint equation\n\t\t// if(mu > 0){\n\n\t\t// \t// Create 2 tangent equations\n\t\t// \tvar mug = mu * gnorm;\n\t\t// \tvar reducedMass = (bi.invMass + bj.invMass);\n\t\t// \tif(reducedMass > 0){\n\t\t// \t\treducedMass = 1/reducedMass;\n\t\t// \t}\n\t\t// \tvar pool = frictionEquationPool;\n\t\t// \tvar c1 = pool.length ? pool.pop() : new FrictionEquation(bi,bj,mug*reducedMass);\n\t\t// \tvar c2 = pool.length ? pool.pop() : new FrictionEquation(bi,bj,mug*reducedMass);\n\t\t// \tthis.frictionEquations.push(c1, c2);\n\n\t\t// \tc1.bi = c2.bi = bi;\n\t\t// \tc1.bj = c2.bj = bj;\n\t\t// \tc1.minForce = c2.minForce = -mug*reducedMass;\n\t\t// \tc1.maxForce = c2.maxForce = mug*reducedMass;\n\n\t\t// \t// Copy over the relative vectors\n\t\t// \tc1.ri.copy(c.ri);\n\t\t// \tc1.rj.copy(c.rj);\n\t\t// \tc2.ri.copy(c.ri);\n\t\t// \tc2.rj.copy(c.rj);\n\n\t\t// \t// Construct tangents\n\t\t// \tc.ni.tangents(c1.t, c2.t);\n\n  //           // Set spook params\n  //           c1.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, dt);\n  //           c2.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, dt);\n\n  //           c1.enabled = c2.enabled = c.enabled;\n\n\t\t// \t// Add equations to solver\n\t\t// \tsolver.addEquation(c1);\n\t\t// \tsolver.addEquation(c2);\n\t\t// }\n\n        if( bi.allowSleep &&\n            bi.type === Body.DYNAMIC &&\n            bi.sleepState  === Body.SLEEPING &&\n            bj.sleepState  === Body.AWAKE &&\n            bj.type !== Body.STATIC\n        ){\n            var speedSquaredB = bj.velocity.norm2() + bj.angularVelocity.norm2();\n            var speedLimitSquaredB = Math.pow(bj.sleepSpeedLimit,2);\n            if(speedSquaredB >= speedLimitSquaredB*2){\n                bi._wakeUpAfterNarrowphase = true;\n            }\n        }\n\n        if( bj.allowSleep &&\n            bj.type === Body.DYNAMIC &&\n            bj.sleepState  === Body.SLEEPING &&\n            bi.sleepState  === Body.AWAKE &&\n            bi.type !== Body.STATIC\n        ){\n            var speedSquaredA = bi.velocity.norm2() + bi.angularVelocity.norm2();\n            var speedLimitSquaredA = Math.pow(bi.sleepSpeedLimit,2);\n            if(speedSquaredA >= speedLimitSquaredA*2){\n                bj._wakeUpAfterNarrowphase = true;\n            }\n        }\n\n        // Now we know that i and j are in contact. Set collision matrix state\n\t\tthis.collisionMatrix.set(bi, bj, true);\n\n        if (!this.collisionMatrixPrevious.get(bi, bj)) {\n            // First contact!\n            // We reuse the collideEvent object, otherwise we will end up creating new objects for each new contact, even if there's no event listener attached.\n            World_step_collideEvent.body = bj;\n            World_step_collideEvent.contact = c;\n            bi.dispatchEvent(World_step_collideEvent);\n\n            World_step_collideEvent.body = bi;\n            bj.dispatchEvent(World_step_collideEvent);\n        }\n    }\n    if(doProfiling){\n        profile.makeContactConstraints = performance.now() - profilingStart;\n        profilingStart = performance.now();\n    }\n\n    // Wake up bodies\n    for(i=0; i!==N; i++){\n        var bi = bodies[i];\n        if(bi._wakeUpAfterNarrowphase){\n            bi.wakeUp();\n            bi._wakeUpAfterNarrowphase = false;\n        }\n    }\n\n    // Add user-added constraints\n    var Nconstraints = constraints.length;\n    for(i=0; i!==Nconstraints; i++){\n        var c = constraints[i];\n        c.update();\n        for(var j=0, Neq=c.equations.length; j!==Neq; j++){\n            var eq = c.equations[j];\n            solver.addEquation(eq);\n        }\n    }\n\n    // Solve the constrained system\n    solver.solve(dt,this);\n\n    if(doProfiling){\n        profile.solve = performance.now() - profilingStart;\n    }\n\n    // Remove all contacts from solver\n    solver.removeAllEquations();\n\n    // Apply damping, see http://code.google.com/p/bullet/issues/detail?id=74 for details\n    var pow = Math.pow;\n    for(i=0; i!==N; i++){\n        var bi = bodies[i];\n        if(bi.type & DYNAMIC){ // Only for dynamic bodies\n            var ld = pow(1.0 - bi.linearDamping,dt);\n            var v = bi.velocity;\n            v.mult(ld,v);\n            var av = bi.angularVelocity;\n            if(av){\n                var ad = pow(1.0 - bi.angularDamping,dt);\n                av.mult(ad,av);\n            }\n        }\n    }\n\n    this.dispatchEvent(World_step_preStepEvent);\n\n    // Invoke pre-step callbacks\n    for(i=0; i!==N; i++){\n        var bi = bodies[i];\n        if(bi.preStep){\n            bi.preStep.call(bi);\n        }\n    }\n\n    // Leap frog\n    // vnew = v + h*f/m\n    // xnew = x + h*vnew\n    if(doProfiling){\n        profilingStart = performance.now();\n    }\n    var q = World_step_step_q;\n    var w = World_step_step_w;\n    var wq = World_step_step_wq;\n    var stepnumber = this.stepnumber;\n    var DYNAMIC_OR_KINEMATIC = Body.DYNAMIC | Body.KINEMATIC;\n    var quatNormalize = stepnumber % (this.quatNormalizeSkip+1) === 0;\n    var quatNormalizeFast = this.quatNormalizeFast;\n    var half_dt = dt * 0.5;\n    var PLANE = Shape.types.PLANE,\n        CONVEX = Shape.types.CONVEXPOLYHEDRON;\n\n    for(i=0; i!==N; i++){\n        var b = bodies[i],\n            force = b.force,\n            tau = b.torque;\n        if((b.type & DYNAMIC_OR_KINEMATIC) && b.sleepState !== Body.SLEEPING){ // Only for dynamic\n            var velo = b.velocity,\n                angularVelo = b.angularVelocity,\n                pos = b.position,\n                quat = b.quaternion,\n                invMass = b.invMass,\n                invInertia = b.invInertiaWorld;\n\n            velo.x += force.x * invMass * dt;\n            velo.y += force.y * invMass * dt;\n            velo.z += force.z * invMass * dt;\n\n            if(b.angularVelocity){\n                invInertia.vmult(tau,invI_tau_dt);\n                invI_tau_dt.mult(dt,invI_tau_dt);\n                invI_tau_dt.vadd(angularVelo,angularVelo);\n            }\n\n            // Use new velocity  - leap frog\n            pos.x += velo.x * dt;\n            pos.y += velo.y * dt;\n            pos.z += velo.z * dt;\n\n            if(b.angularVelocity){\n                w.set(angularVelo.x, angularVelo.y, angularVelo.z, 0);\n                w.mult(quat,wq);\n                quat.x += half_dt * wq.x;\n                quat.y += half_dt * wq.y;\n                quat.z += half_dt * wq.z;\n                quat.w += half_dt * wq.w;\n                if(quatNormalize){\n                    if(quatNormalizeFast){\n                        quat.normalizeFast();\n                    } else {\n                        quat.normalize();\n                    }\n                }\n            }\n\n            if(b.aabb){\n                b.aabbNeedsUpdate = true;\n            }\n\n            // Update world inertia\n            if(b.updateInertiaWorld){\n                b.updateInertiaWorld();\n            }\n        }\n    }\n    this.clearForces();\n\n    this.broadphase.dirty = true;\n\n    if(doProfiling){\n        profile.integrate = performance.now() - profilingStart;\n    }\n\n    // Update world time\n    this.time += dt;\n    this.stepnumber += 1;\n\n    this.dispatchEvent(World_step_postStepEvent);\n\n    // Invoke post-step callbacks\n    for(i=0; i!==N; i++){\n        var bi = bodies[i];\n        var postStep = bi.postStep;\n        if(postStep){\n            postStep.call(bi);\n        }\n    }\n\n    // Sleeping update\n    if(this.allowSleep){\n        for(i=0; i!==N; i++){\n            bodies[i].sleepTick(this.time);\n        }\n    }\n};\n\n/**\n * Sets all body forces in the world to zero.\n * @method clearForces\n */\nWorld.prototype.clearForces = function(){\n    var bodies = this.bodies;\n    var N = bodies.length;\n    for(var i=0; i !== N; i++){\n        var b = bodies[i],\n            force = b.force,\n            tau = b.torque;\n\n        b.force.set(0,0,0);\n        b.torque.set(0,0,0);\n    }\n};\n\n},{\"../collision/AABB\":3,\"../collision/ArrayCollisionMatrix\":4,\"../collision/NaiveBroadphase\":7,\"../collision/Ray\":9,\"../collision/RaycastResult\":10,\"../equations/ContactEquation\":19,\"../equations/FrictionEquation\":21,\"../material/ContactMaterial\":24,\"../material/Material\":25,\"../math/Quaternion\":28,\"../math/Vec3\":30,\"../objects/Body\":31,\"../shapes/Shape\":43,\"../solver/GSSolver\":46,\"../utils/EventTarget\":49,\"../utils/TupleDictionary\":52,\"../utils/Vec3Pool\":54,\"./Narrowphase\":55}]},{},[2])\n(2)\n});//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2RtaWxsZXQvUHJvamVjdHMvZnB0L2ZwdC1vbGQvfi9jYW5ub24vYnVpbGQvY2Fubm9uLmpzPzgzMTYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IllBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSwyQkFBMkUsc0RBQXNELEtBQUssTUFBTSx5SEFBeUgsWUFBWSwwQkFBMEIsMEJBQTBCLGdCQUFnQixVQUFVLFVBQVUsMENBQTBDLDhCQUF3QixvQkFBb0IsOENBQThDLFlBQVksWUFBWSxtQ0FBbUMsaUJBQWlCLGdCQUFnQixzQkFBc0Isb0JBQW9CLDBDQUEwQyxZQUFZLFdBQVcsWUFBWSxTQUFTLEdBQUc7QUFDenRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSxDQUFDLEdBQUc7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLGtCQUFrQixLQUFLO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixLQUFLO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsS0FBSztBQUN2QjtBQUNBOztBQUVBOztBQUVBO0FBQ0Esa0JBQWtCLEtBQUs7QUFDdkI7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixLQUFLO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EsU0FBUztBQUNULDBCQUEwQjtBQUMxQixTQUFTO0FBQ1QseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQixZQUFZLEtBQUs7QUFDakIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQixZQUFZLEtBQUs7QUFDakIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQUs7QUFDakIsWUFBWSxLQUFLO0FBQ2pCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQUs7QUFDakIsWUFBWSxLQUFLO0FBQ2pCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsV0FBVztBQUN0QixZQUFZLEtBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsT0FBTztBQUN2Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQixZQUFZLEtBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQUs7QUFDakIsWUFBWSxLQUFLO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFLO0FBQ2pC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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsZUFBZTtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGVBQWU7QUFDbEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsbURBQW1EOztBQUVuRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLGVBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxFQUFFLGtCQUFrQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxFQUFFLDJFQUEyRTtBQUM5RTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksS0FBSztBQUNqQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEVBQUUsK0JBQStCO0FBQ2xDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLGVBQWU7QUFDMUMsMkJBQTJCLGVBQWU7QUFDMUMsMkJBQTJCLGVBQWU7O0FBRTFDLDRCQUE0QixlQUFlO0FBQzNDLDRCQUE0QixlQUFlO0FBQzNDLDRCQUE0QixlQUFlO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRSwrQkFBK0I7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLENBQUMsRUFBRSxpRkFBaUY7QUFDcEY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEVBQUUsK0JBQStCO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLE1BQU07QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLEtBQUs7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDZCQUE2QjtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsNkJBQTZCO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2QkFBNkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLEtBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLEtBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxLQUFLO0FBQ2pCLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxLQUFLO0FBQ2pCLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxLQUFLO0FBQ2pCLFlBQVksV0FBVztBQUN2QixZQUFZLEtBQUs7QUFDakIsWUFBWSxLQUFLO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxLQUFLO0FBQ2pCLFlBQVksS0FBSztBQUNqQixZQUFZLEtBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksS0FBSztBQUNqQixZQUFZLEtBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxLQUFLO0FBQ2pCLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsV0FBVztBQUN0QixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLHFCQUFxQjtBQUN6Qyx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IscUJBQXFCO0FBQ3pDLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDLEVBQUUseUhBQXlIO0FBQzVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGdCQUFnQjs7QUFFbkM7QUFDQTs7QUFFQSx3QkFBd0IsU0FBUzs7QUFFakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUEsaUZBQWlGOztBQUVqRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDLEVBQUUsd0RBQXdEO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixNQUFNO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsQ0FBQyxHQUFHO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQztBQUNqQyxvQ0FBb0M7QUFDcEMsK0JBQStCO0FBQy9CLCtCQUErQjtBQUMvQixvQ0FBb0MsV0FBVzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsYUFBYTtBQUNoQztBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUUsNkVBQTZFO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQSw2Q0FBNkMsc0JBQXNCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsNkNBQTZDLGNBQWM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLFNBQVM7QUFDekIsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBLDZDQUE2QyxhQUFhO0FBQzFEO0FBQ0EsNkNBQTZDLGFBQWE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBLDZDQUE2QyxhQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELE9BQU87QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsR0FBRztBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLFdBQVc7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLEtBQUs7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLE1BQU07QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLE1BQU07QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQixZQUFZLE9BQU87QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esd0JBQXdCLGlCQUFpQiw4QkFBOEIsR0FBRztBQUMxRSx3QkFBd0IsaUJBQWlCLDhCQUE4QixHQUFHO0FBQzFFLHdCQUF3QixpQkFBaUIsOEJBQThCLEdBQUc7QUFDMUUsd0JBQXdCLGlCQUFpQiw4QkFBOEIsR0FBRztBQUMxRSx3QkFBd0IsaUJBQWlCLDhCQUE4QixHQUFHO0FBQzFFLHdCQUF3QixpQkFBaUIsOEJBQThCLEdBQUc7QUFDMUUsd0JBQXdCLGlCQUFpQiw4QkFBOEIsR0FBRztBQUMxRSx3QkFBd0IsaUJBQWlCLDhCQUE4QixHQUFHO0FBQzFFOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLFNBQVM7QUFDNUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQixZQUFZLE1BQU07QUFDbEIsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBLGdEQUFnRCxTQUFTO0FBQ3pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksSUFBSTtBQUNoQixZQUFZLFVBQVU7QUFDdEIsWUFBWSxNQUFNO0FBQ2xCLFlBQVksTUFBTTtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsRUFBRSx3Q0FBd0M7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixNQUFNO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixNQUFNO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsR0FBRztBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxHQUFHO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUMsR0FBRztBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsRUFBRSw4QkFBOEI7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixNQUFNO0FBQ3hCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRCxrRUFBa0U7QUFDbEU7QUFDQSxTQUFTO0FBQ1Qsb0RBQW9EO0FBQ3BELGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3RELHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsTUFBTTtBQUNqQixXQUFXLE1BQU07QUFDakIsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QixPQUFPOztBQUVwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixzQkFBc0I7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEIsWUFBWSxNQUFNO0FBQ2xCLFlBQVksS0FBSztBQUNqQixZQUFZLEtBQUs7QUFDakIsWUFBWSxXQUFXO0FBQ3ZCLFlBQVksV0FBVztBQUN2QixZQUFZLEtBQUs7QUFDakIsWUFBWSxLQUFLO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQixZQUFZLE1BQU07QUFDbEIsWUFBWSxLQUFLO0FBQ2pCLFlBQVksS0FBSztBQUNqQixZQUFZLFdBQVc7QUFDdkIsWUFBWSxXQUFXO0FBQ3ZCLFlBQVksS0FBSztBQUNqQixZQUFZLEtBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DOztBQUVuQyxnQkFBZ0Isb0NBQW9DOztBQUVwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQixZQUFZLE1BQU07QUFDbEIsWUFBWSxLQUFLO0FBQ2pCLFlBQVksS0FBSztBQUNqQixZQUFZLFdBQVc7QUFDdkIsWUFBWSxXQUFXO0FBQ3ZCLFlBQVksS0FBSztBQUNqQixZQUFZLEtBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIscUNBQXFDLHdCQUF3Qjs7QUFFbEY7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQyx1QkFBdUIsT0FBTzs7QUFFOUI7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDLHVCQUF1QixPQUFPOztBQUU5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEIsWUFBWSxNQUFNO0FBQ2xCLFlBQVksS0FBSztBQUNqQixZQUFZLEtBQUs7QUFDakIsWUFBWSxXQUFXO0FBQ3ZCLFlBQVksV0FBVztBQUN2QixZQUFZLEtBQUs7QUFDakIsWUFBWSxLQUFLO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLHFCQUFxQjs7QUFFckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7O0FBRTlEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEIsWUFBWSxNQUFNO0FBQ2xCLFlBQVksS0FBSztBQUNqQixZQUFZLEtBQUs7QUFDakIsWUFBWSxXQUFXO0FBQ3ZCLFlBQVksV0FBVztBQUN2QixZQUFZLEtBQUs7QUFDakIsWUFBWSxLQUFLO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywrQkFBK0I7QUFDckU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDLG9CQUFvQixpQkFBaUI7QUFDckMsd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQkFBc0I7QUFDdEMsb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25ELHVEQUF1RDs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEIsWUFBWSxNQUFNO0FBQ2xCLFlBQVksS0FBSztBQUNqQixZQUFZLEtBQUs7QUFDakIsWUFBWSxXQUFXO0FBQ3ZCLFlBQVksV0FBVztBQUN2QixZQUFZLEtBQUs7QUFDakIsWUFBWSxLQUFLO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQyw2QkFBNkI7QUFDbEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLDRDQUE0QyxZQUFZO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseURBQXlEO0FBQ3pEO0FBQ0E7O0FBRUEsMkNBQTJDO0FBQzNDLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx5REFBeUQsZ0JBQWdCO0FBQ3pFO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCLGFBQWE7QUFDYjtBQUNBLDRCQUE0QixpQkFBaUI7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpRkFBaUY7QUFDakY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUVBQWlFLGdCQUFnQjtBQUNqRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFEQUFxRCxnQkFBZ0I7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEIsWUFBWSxNQUFNO0FBQ2xCLFlBQVksTUFBTTtBQUNsQixZQUFZLEtBQUs7QUFDakIsWUFBWSxLQUFLO0FBQ2pCLFlBQVksV0FBVztBQUN2QixZQUFZLFdBQVc7QUFDdkIsWUFBWSxLQUFLO0FBQ2pCLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLFlBQVksTUFBTTtBQUNsQixZQUFZLEtBQUs7QUFDakIsWUFBWSxLQUFLO0FBQ2pCLFlBQVksV0FBVztBQUN2QixZQUFZLFdBQVc7QUFDdkIsWUFBWSxLQUFLO0FBQ2pCLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qzs7QUFFN0M7QUFDQTtBQUNBLGtCQUFrQixtQ0FBbUM7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDs7QUFFaEQsbUNBQW1DOztBQUVuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLFlBQVksTUFBTTtBQUNsQixZQUFZLEtBQUs7QUFDakIsWUFBWSxLQUFLO0FBQ2pCLFlBQVksV0FBVztBQUN2QixZQUFZLFdBQVc7QUFDdkIsWUFBWSxLQUFLO0FBQ2pCLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLFlBQVksTUFBTTtBQUNsQixZQUFZLE1BQU07QUFDbEIsWUFBWSxLQUFLO0FBQ2pCLFlBQVksS0FBSztBQUNqQixZQUFZLFdBQVc7QUFDdkIsWUFBWSxXQUFXO0FBQ3ZCLFlBQVksS0FBSztBQUNqQixZQUFZLEtBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQiwyQkFBMkI7O0FBRWpEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0JBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQixZQUFZLE1BQU07QUFDbEIsWUFBWSxNQUFNO0FBQ2xCLFlBQVksS0FBSztBQUNqQixZQUFZLEtBQUs7QUFDakIsWUFBWSxXQUFXO0FBQ3ZCLFlBQVksV0FBVztBQUN2QixZQUFZLEtBQUs7QUFDakIsWUFBWSxLQUFLO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQixZQUFZLE1BQU07QUFDbEIsWUFBWSxNQUFNO0FBQ2xCLFlBQVksS0FBSztBQUNqQixZQUFZLEtBQUs7QUFDakIsWUFBWSxXQUFXO0FBQ3ZCLFlBQVksV0FBVztBQUN2QixZQUFZLEtBQUs7QUFDakIsWUFBWSxLQUFLO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLFlBQVksTUFBTTtBQUNsQixZQUFZLE1BQU07QUFDbEIsWUFBWSxLQUFLO0FBQ2pCLFlBQVksS0FBSztBQUNqQixZQUFZLFdBQVc7QUFDdkIsWUFBWSxXQUFXO0FBQ3ZCLFlBQVksS0FBSztBQUNqQixZQUFZLEtBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMsWUFBWTs7QUFFdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRDtBQUNoRCw0QkFBNEI7O0FBRTVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsV0FBVztBQUM3QixrQkFBa0IsV0FBVztBQUM3QixrQkFBa0IsV0FBVztBQUM3QixrQkFBa0IsV0FBVztBQUM3Qiw2QkFBNkIseUJBQXlCO0FBQ3RELDZCQUE2Qix5QkFBeUI7QUFDdEQsZ0NBQWdDLDRCQUE0QjtBQUM1RCxnQ0FBZ0MsNEJBQTRCOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsV0FBVztBQUNqQywwQkFBMEIsV0FBVzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixXQUFXO0FBQzdCLGtCQUFrQixXQUFXO0FBQzdCLGtCQUFrQixXQUFXO0FBQzdCLGtCQUFrQixXQUFXO0FBQzdCLDZCQUE2Qix5QkFBeUI7QUFDdEQsNkJBQTZCLHlCQUF5QjtBQUN0RCxnQ0FBZ0MsNEJBQTRCO0FBQzVELGdDQUFnQyw0QkFBNEI7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLFdBQVc7QUFDakMsMEJBQTBCLFdBQVc7O0FBRXJDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixxQkFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsRUFBRSxtUkFBbVI7QUFDdFI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QyxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QyxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxtR0FBbUcsa0NBQWtDOztBQUVySTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyx1QkFBdUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQixZQUFZLEtBQUs7QUFDakIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFNBQVM7QUFDckIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCLFlBQVksS0FBSztBQUNqQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksY0FBYztBQUMxQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQUs7QUFDakIsWUFBWSxLQUFLO0FBQ2pCLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxjQUFjO0FBQzFCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDOztBQUVsQzs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hELCtCQUErQixlQUFlO0FBQzlDLCtCQUErQix5Q0FBeUM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0RBQW9ELGlCQUFpQjtBQUNyRTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLG9DQUFvQztBQUN4RCxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLG9CQUFvQix5REFBeUQ7O0FBRTdFO0FBQ0E7QUFDQSxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0Esb0NBQW9DLE1BQU07QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQixvQ0FBb0M7QUFDeEQ7QUFDQTs7QUFFQSxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLG1DQUFtQztBQUN0RDtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGVBQWU7O0FBRS9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0EsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEVBQUUsZ2VBQWdlLEVBQUUsR0FBRztBQUN4ZTtBQUNBLENBQUMiLCJmaWxlIjoiOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgY2Fubm9uLmpzIEF1dGhvcnNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAqIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuICogcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksXG4gKiBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcbiAqIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gKiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRVxuICogTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTlxuICogT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4gKiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4hZnVuY3Rpb24oZSl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGUpbW9kdWxlLmV4cG9ydHM9ZSgpO2Vsc2UgaWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZmYWxzZSlkZWZpbmUoW10sZSk7ZWxzZXt2YXIgZjtcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P2Y9d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Zj1nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGYmJihmPXNlbGYpLGYuQ0FOTk9OPWUoKX19KGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpfXZhciBmPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChmLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGYsZi5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkoezE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJjYW5ub25cIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMC42LjJcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkEgbGlnaHR3ZWlnaHQgM0QgcGh5c2ljcyBlbmdpbmUgd3JpdHRlbiBpbiBKYXZhU2NyaXB0LlwiLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3NjaHRlcHBlL2Nhbm5vbi5qc1wiLFxuICBcImF1dGhvclwiOiBcIlN0ZWZhbiBIZWRtYW4gPHNjaHRlcHBlQGdtYWlsLmNvbT4gKGh0dHA6Ly9zdGVmZmUuc2UpXCIsXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiY2Fubm9uLmpzXCIsXG4gICAgXCJjYW5ub25cIixcbiAgICBcInBoeXNpY3NcIixcbiAgICBcImVuZ2luZVwiLFxuICAgIFwiM2RcIlxuICBdLFxuICBcIm1haW5cIjogXCIuL2J1aWxkL2Nhbm5vbi5qc1wiLFxuICBcImVuZ2luZXNcIjoge1xuICAgIFwibm9kZVwiOiBcIipcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3NjaHRlcHBlL2Nhbm5vbi5qcy5naXRcIlxuICB9LFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3NjaHRlcHBlL2Nhbm5vbi5qcy9pc3N1ZXNcIlxuICB9LFxuICBcImxpY2Vuc2VzXCI6IFtcbiAgICB7XG4gICAgICBcInR5cGVcIjogXCJNSVRcIlxuICAgIH1cbiAgXSxcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwianNoaW50XCI6IFwibGF0ZXN0XCIsXG4gICAgXCJ1Z2xpZnktanNcIjogXCJsYXRlc3RcIixcbiAgICBcIm5vZGV1bml0XCI6IFwiXjAuOS4wXCIsXG4gICAgXCJncnVudFwiOiBcIn4wLjQuMFwiLFxuICAgIFwiZ3J1bnQtY29udHJpYi1qc2hpbnRcIjogXCJ+MC4xLjFcIixcbiAgICBcImdydW50LWNvbnRyaWItbm9kZXVuaXRcIjogXCJeMC40LjFcIixcbiAgICBcImdydW50LWNvbnRyaWItY29uY2F0XCI6IFwifjAuMS4zXCIsXG4gICAgXCJncnVudC1jb250cmliLXVnbGlmeVwiOiBcIl4wLjUuMVwiLFxuICAgIFwiZ3J1bnQtYnJvd3NlcmlmeVwiOiBcIl4yLjEuNFwiLFxuICAgIFwiZ3J1bnQtY29udHJpYi15dWlkb2NcIjogXCJeMC41LjJcIixcbiAgICBcImJyb3dzZXJpZnlcIjogXCIqXCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge31cbn1cblxufSx7fV0sMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBFeHBvcnQgY2xhc3Nlc1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgdmVyc2lvbiA6ICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uLFxuXG4gICAgQUFCQiA6ICAgICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL2NvbGxpc2lvbi9BQUJCJyksXG4gICAgQXJyYXlDb2xsaXNpb25NYXRyaXggOiAgICAgICAgICBfZGVyZXFfKCcuL2NvbGxpc2lvbi9BcnJheUNvbGxpc2lvbk1hdHJpeCcpLFxuICAgIEJvZHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9vYmplY3RzL0JvZHknKSxcbiAgICBCb3ggOiAgICAgICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vc2hhcGVzL0JveCcpLFxuICAgIEJyb2FkcGhhc2UgOiAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9jb2xsaXNpb24vQnJvYWRwaGFzZScpLFxuICAgIENvbnN0cmFpbnQgOiAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9jb25zdHJhaW50cy9Db25zdHJhaW50JyksXG4gICAgQ29udGFjdEVxdWF0aW9uIDogICAgICAgICAgICAgICBfZGVyZXFfKCcuL2VxdWF0aW9ucy9Db250YWN0RXF1YXRpb24nKSxcbiAgICBOYXJyb3dwaGFzZSA6ICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vd29ybGQvTmFycm93cGhhc2UnKSxcbiAgICBDb25lVHdpc3RDb25zdHJhaW50IDogICAgICAgICAgIF9kZXJlcV8oJy4vY29uc3RyYWludHMvQ29uZVR3aXN0Q29uc3RyYWludCcpLFxuICAgIENvbnRhY3RNYXRlcmlhbCA6ICAgICAgICAgICAgICAgX2RlcmVxXygnLi9tYXRlcmlhbC9Db250YWN0TWF0ZXJpYWwnKSxcbiAgICBDb252ZXhQb2x5aGVkcm9uIDogICAgICAgICAgICAgIF9kZXJlcV8oJy4vc2hhcGVzL0NvbnZleFBvbHloZWRyb24nKSxcbiAgICBDeWxpbmRlciA6ICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vc2hhcGVzL0N5bGluZGVyJyksXG4gICAgRGlzdGFuY2VDb25zdHJhaW50IDogICAgICAgICAgICBfZGVyZXFfKCcuL2NvbnN0cmFpbnRzL0Rpc3RhbmNlQ29uc3RyYWludCcpLFxuICAgIEVxdWF0aW9uIDogICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9lcXVhdGlvbnMvRXF1YXRpb24nKSxcbiAgICBFdmVudFRhcmdldCA6ICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vdXRpbHMvRXZlbnRUYXJnZXQnKSxcbiAgICBGcmljdGlvbkVxdWF0aW9uIDogICAgICAgICAgICAgIF9kZXJlcV8oJy4vZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb24nKSxcbiAgICBHU1NvbHZlciA6ICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vc29sdmVyL0dTU29sdmVyJyksXG4gICAgR3JpZEJyb2FkcGhhc2UgOiAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL2NvbGxpc2lvbi9HcmlkQnJvYWRwaGFzZScpLFxuICAgIEhlaWdodGZpZWxkIDogICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9zaGFwZXMvSGVpZ2h0ZmllbGQnKSxcbiAgICBIaW5nZUNvbnN0cmFpbnQgOiAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vY29uc3RyYWludHMvSGluZ2VDb25zdHJhaW50JyksXG4gICAgTG9ja0NvbnN0cmFpbnQgOiAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL2NvbnN0cmFpbnRzL0xvY2tDb25zdHJhaW50JyksXG4gICAgTWF0MyA6ICAgICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL21hdGgvTWF0MycpLFxuICAgIE1hdGVyaWFsIDogICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9tYXRlcmlhbC9NYXRlcmlhbCcpLFxuICAgIE5haXZlQnJvYWRwaGFzZSA6ICAgICAgICAgICAgICAgX2RlcmVxXygnLi9jb2xsaXNpb24vTmFpdmVCcm9hZHBoYXNlJyksXG4gICAgT2JqZWN0Q29sbGlzaW9uTWF0cml4IDogICAgICAgICBfZGVyZXFfKCcuL2NvbGxpc2lvbi9PYmplY3RDb2xsaXNpb25NYXRyaXgnKSxcbiAgICBQb29sIDogICAgICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vdXRpbHMvUG9vbCcpLFxuICAgIFBhcnRpY2xlIDogICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9zaGFwZXMvUGFydGljbGUnKSxcbiAgICBQbGFuZSA6ICAgICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vc2hhcGVzL1BsYW5lJyksXG4gICAgUG9pbnRUb1BvaW50Q29uc3RyYWludCA6ICAgICAgICBfZGVyZXFfKCcuL2NvbnN0cmFpbnRzL1BvaW50VG9Qb2ludENvbnN0cmFpbnQnKSxcbiAgICBRdWF0ZXJuaW9uIDogICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vbWF0aC9RdWF0ZXJuaW9uJyksXG4gICAgUmF5IDogICAgICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL2NvbGxpc2lvbi9SYXknKSxcbiAgICBSYXljYXN0VmVoaWNsZSA6ICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vb2JqZWN0cy9SYXljYXN0VmVoaWNsZScpLFxuICAgIFJheWNhc3RSZXN1bHQgOiAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdCcpLFxuICAgIFJpZ2lkVmVoaWNsZSA6ICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9vYmplY3RzL1JpZ2lkVmVoaWNsZScpLFxuICAgIFJvdGF0aW9uYWxFcXVhdGlvbiA6ICAgICAgICAgICAgX2RlcmVxXygnLi9lcXVhdGlvbnMvUm90YXRpb25hbEVxdWF0aW9uJyksXG4gICAgUm90YXRpb25hbE1vdG9yRXF1YXRpb24gOiAgICAgICBfZGVyZXFfKCcuL2VxdWF0aW9ucy9Sb3RhdGlvbmFsTW90b3JFcXVhdGlvbicpLFxuICAgIFNBUEJyb2FkcGhhc2UgOiAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9jb2xsaXNpb24vU0FQQnJvYWRwaGFzZScpLFxuICAgIFNQSFN5c3RlbSA6ICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9vYmplY3RzL1NQSFN5c3RlbScpLFxuICAgIFNoYXBlIDogICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9zaGFwZXMvU2hhcGUnKSxcbiAgICBTb2x2ZXIgOiAgICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vc29sdmVyL1NvbHZlcicpLFxuICAgIFNwaGVyZSA6ICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9zaGFwZXMvU3BoZXJlJyksXG4gICAgU3BsaXRTb2x2ZXIgOiAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3NvbHZlci9TcGxpdFNvbHZlcicpLFxuICAgIFNwcmluZyA6ICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9vYmplY3RzL1NwcmluZycpLFxuICAgIFRyaW1lc2ggOiAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9zaGFwZXMvVHJpbWVzaCcpLFxuICAgIFZlYzMgOiAgICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9tYXRoL1ZlYzMnKSxcbiAgICBWZWMzUG9vbCA6ICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vdXRpbHMvVmVjM1Bvb2wnKSxcbiAgICBXb3JsZCA6ICAgICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vd29ybGQvV29ybGQnKSxcbn07XG5cbn0se1wiLi4vcGFja2FnZS5qc29uXCI6MSxcIi4vY29sbGlzaW9uL0FBQkJcIjozLFwiLi9jb2xsaXNpb24vQXJyYXlDb2xsaXNpb25NYXRyaXhcIjo0LFwiLi9jb2xsaXNpb24vQnJvYWRwaGFzZVwiOjUsXCIuL2NvbGxpc2lvbi9HcmlkQnJvYWRwaGFzZVwiOjYsXCIuL2NvbGxpc2lvbi9OYWl2ZUJyb2FkcGhhc2VcIjo3LFwiLi9jb2xsaXNpb24vT2JqZWN0Q29sbGlzaW9uTWF0cml4XCI6OCxcIi4vY29sbGlzaW9uL1JheVwiOjksXCIuL2NvbGxpc2lvbi9SYXljYXN0UmVzdWx0XCI6MTAsXCIuL2NvbGxpc2lvbi9TQVBCcm9hZHBoYXNlXCI6MTEsXCIuL2NvbnN0cmFpbnRzL0NvbmVUd2lzdENvbnN0cmFpbnRcIjoxMixcIi4vY29uc3RyYWludHMvQ29uc3RyYWludFwiOjEzLFwiLi9jb25zdHJhaW50cy9EaXN0YW5jZUNvbnN0cmFpbnRcIjoxNCxcIi4vY29uc3RyYWludHMvSGluZ2VDb25zdHJhaW50XCI6MTUsXCIuL2NvbnN0cmFpbnRzL0xvY2tDb25zdHJhaW50XCI6MTYsXCIuL2NvbnN0cmFpbnRzL1BvaW50VG9Qb2ludENvbnN0cmFpbnRcIjoxNyxcIi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvblwiOjE5LFwiLi9lcXVhdGlvbnMvRXF1YXRpb25cIjoyMCxcIi4vZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb25cIjoyMSxcIi4vZXF1YXRpb25zL1JvdGF0aW9uYWxFcXVhdGlvblwiOjIyLFwiLi9lcXVhdGlvbnMvUm90YXRpb25hbE1vdG9yRXF1YXRpb25cIjoyMyxcIi4vbWF0ZXJpYWwvQ29udGFjdE1hdGVyaWFsXCI6MjQsXCIuL21hdGVyaWFsL01hdGVyaWFsXCI6MjUsXCIuL21hdGgvTWF0M1wiOjI3LFwiLi9tYXRoL1F1YXRlcm5pb25cIjoyOCxcIi4vbWF0aC9WZWMzXCI6MzAsXCIuL29iamVjdHMvQm9keVwiOjMxLFwiLi9vYmplY3RzL1JheWNhc3RWZWhpY2xlXCI6MzIsXCIuL29iamVjdHMvUmlnaWRWZWhpY2xlXCI6MzMsXCIuL29iamVjdHMvU1BIU3lzdGVtXCI6MzQsXCIuL29iamVjdHMvU3ByaW5nXCI6MzUsXCIuL3NoYXBlcy9Cb3hcIjozNyxcIi4vc2hhcGVzL0NvbnZleFBvbHloZWRyb25cIjozOCxcIi4vc2hhcGVzL0N5bGluZGVyXCI6MzksXCIuL3NoYXBlcy9IZWlnaHRmaWVsZFwiOjQwLFwiLi9zaGFwZXMvUGFydGljbGVcIjo0MSxcIi4vc2hhcGVzL1BsYW5lXCI6NDIsXCIuL3NoYXBlcy9TaGFwZVwiOjQzLFwiLi9zaGFwZXMvU3BoZXJlXCI6NDQsXCIuL3NoYXBlcy9UcmltZXNoXCI6NDUsXCIuL3NvbHZlci9HU1NvbHZlclwiOjQ2LFwiLi9zb2x2ZXIvU29sdmVyXCI6NDcsXCIuL3NvbHZlci9TcGxpdFNvbHZlclwiOjQ4LFwiLi91dGlscy9FdmVudFRhcmdldFwiOjQ5LFwiLi91dGlscy9Qb29sXCI6NTEsXCIuL3V0aWxzL1ZlYzNQb29sXCI6NTQsXCIuL3dvcmxkL05hcnJvd3BoYXNlXCI6NTUsXCIuL3dvcmxkL1dvcmxkXCI6NTZ9XSwzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XG52YXIgVXRpbHMgPSBfZGVyZXFfKCcuLi91dGlscy9VdGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFBQkI7XG5cbi8qKlxuICogQXhpcyBhbGlnbmVkIGJvdW5kaW5nIGJveCBjbGFzcy5cbiAqIEBjbGFzcyBBQUJCXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7VmVjM30gICBbb3B0aW9ucy51cHBlckJvdW5kXVxuICogQHBhcmFtIHtWZWMzfSAgIFtvcHRpb25zLmxvd2VyQm91bmRdXG4gKi9cbmZ1bmN0aW9uIEFBQkIob3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbG93ZXIgYm91bmQgb2YgdGhlIGJvdW5kaW5nIGJveC5cbiAgICAgKiBAcHJvcGVydHkgbG93ZXJCb3VuZFxuICAgICAqIEB0eXBlIHtWZWMzfVxuICAgICAqL1xuICAgIHRoaXMubG93ZXJCb3VuZCA9IG5ldyBWZWMzKCk7XG4gICAgaWYob3B0aW9ucy5sb3dlckJvdW5kKXtcbiAgICAgICAgdGhpcy5sb3dlckJvdW5kLmNvcHkob3B0aW9ucy5sb3dlckJvdW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdXBwZXIgYm91bmQgb2YgdGhlIGJvdW5kaW5nIGJveC5cbiAgICAgKiBAcHJvcGVydHkgdXBwZXJCb3VuZFxuICAgICAqIEB0eXBlIHtWZWMzfVxuICAgICAqL1xuICAgIHRoaXMudXBwZXJCb3VuZCA9IG5ldyBWZWMzKCk7XG4gICAgaWYob3B0aW9ucy51cHBlckJvdW5kKXtcbiAgICAgICAgdGhpcy51cHBlckJvdW5kLmNvcHkob3B0aW9ucy51cHBlckJvdW5kKTtcbiAgICB9XG59XG5cbnZhciB0bXAgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIFNldCB0aGUgQUFCQiBib3VuZHMgZnJvbSBhIHNldCBvZiBwb2ludHMuXG4gKiBAbWV0aG9kIHNldEZyb21Qb2ludHNcbiAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyBBbiBhcnJheSBvZiBWZWMzJ3MuXG4gKiBAcGFyYW0ge1ZlYzN9IHBvc2l0aW9uXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBza2luU2l6ZVxuICogQHJldHVybiB7QUFCQn0gVGhlIHNlbGYgb2JqZWN0XG4gKi9cbkFBQkIucHJvdG90eXBlLnNldEZyb21Qb2ludHMgPSBmdW5jdGlvbihwb2ludHMsIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBza2luU2l6ZSl7XG4gICAgdmFyIGwgPSB0aGlzLmxvd2VyQm91bmQsXG4gICAgICAgIHUgPSB0aGlzLnVwcGVyQm91bmQsXG4gICAgICAgIHEgPSBxdWF0ZXJuaW9uO1xuXG4gICAgLy8gU2V0IHRvIHRoZSBmaXJzdCBwb2ludFxuICAgIGwuY29weShwb2ludHNbMF0pO1xuICAgIGlmKHEpe1xuICAgICAgICBxLnZtdWx0KGwsIGwpO1xuICAgIH1cbiAgICB1LmNvcHkobCk7XG5cbiAgICBmb3IodmFyIGkgPSAxOyBpPHBvaW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBwID0gcG9pbnRzW2ldO1xuXG4gICAgICAgIGlmKHEpe1xuICAgICAgICAgICAgcS52bXVsdChwLCB0bXApO1xuICAgICAgICAgICAgcCA9IHRtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHAueCA+IHUueCl7IHUueCA9IHAueDsgfVxuICAgICAgICBpZihwLnggPCBsLngpeyBsLnggPSBwLng7IH1cbiAgICAgICAgaWYocC55ID4gdS55KXsgdS55ID0gcC55OyB9XG4gICAgICAgIGlmKHAueSA8IGwueSl7IGwueSA9IHAueTsgfVxuICAgICAgICBpZihwLnogPiB1LnopeyB1LnogPSBwLno7IH1cbiAgICAgICAgaWYocC56IDwgbC56KXsgbC56ID0gcC56OyB9XG4gICAgfVxuXG4gICAgLy8gQWRkIG9mZnNldFxuICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgICBwb3NpdGlvbi52YWRkKGwsIGwpO1xuICAgICAgICBwb3NpdGlvbi52YWRkKHUsIHUpO1xuICAgIH1cblxuICAgIGlmKHNraW5TaXplKXtcbiAgICAgICAgbC54IC09IHNraW5TaXplO1xuICAgICAgICBsLnkgLT0gc2tpblNpemU7XG4gICAgICAgIGwueiAtPSBza2luU2l6ZTtcbiAgICAgICAgdS54ICs9IHNraW5TaXplO1xuICAgICAgICB1LnkgKz0gc2tpblNpemU7XG4gICAgICAgIHUueiArPSBza2luU2l6ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29weSBib3VuZHMgZnJvbSBhbiBBQUJCIHRvIHRoaXMgQUFCQlxuICogQG1ldGhvZCBjb3B5XG4gKiBAcGFyYW0gIHtBQUJCfSBhYWJiIFNvdXJjZSB0byBjb3B5IGZyb21cbiAqIEByZXR1cm4ge0FBQkJ9IFRoZSB0aGlzIG9iamVjdCwgZm9yIGNoYWluYWJpbGl0eVxuICovXG5BQUJCLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oYWFiYil7XG4gICAgdGhpcy5sb3dlckJvdW5kLmNvcHkoYWFiYi5sb3dlckJvdW5kKTtcbiAgICB0aGlzLnVwcGVyQm91bmQuY29weShhYWJiLnVwcGVyQm91bmQpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDbG9uZSBhbiBBQUJCXG4gKiBAbWV0aG9kIGNsb25lXG4gKi9cbkFBQkIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gbmV3IEFBQkIoKS5jb3B5KHRoaXMpO1xufTtcblxuLyoqXG4gKiBFeHRlbmQgdGhpcyBBQUJCIHNvIHRoYXQgaXQgY292ZXJzIHRoZSBnaXZlbiBBQUJCIHRvby5cbiAqIEBtZXRob2QgZXh0ZW5kXG4gKiBAcGFyYW0gIHtBQUJCfSBhYWJiXG4gKi9cbkFBQkIucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uKGFhYmIpe1xuICAgIC8vIEV4dGVuZCBsb3dlciBib3VuZFxuICAgIHZhciBsID0gYWFiYi5sb3dlckJvdW5kLng7XG4gICAgaWYodGhpcy5sb3dlckJvdW5kLnggPiBsKXtcbiAgICAgICAgdGhpcy5sb3dlckJvdW5kLnggPSBsO1xuICAgIH1cblxuICAgIC8vIFVwcGVyXG4gICAgdmFyIHUgPSBhYWJiLnVwcGVyQm91bmQueDtcbiAgICBpZih0aGlzLnVwcGVyQm91bmQueCA8IHUpe1xuICAgICAgICB0aGlzLnVwcGVyQm91bmQueCA9IHU7XG4gICAgfVxuXG4gICAgLy8gRXh0ZW5kIGxvd2VyIGJvdW5kXG4gICAgdmFyIGwgPSBhYWJiLmxvd2VyQm91bmQueTtcbiAgICBpZih0aGlzLmxvd2VyQm91bmQueSA+IGwpe1xuICAgICAgICB0aGlzLmxvd2VyQm91bmQueSA9IGw7XG4gICAgfVxuXG4gICAgLy8gVXBwZXJcbiAgICB2YXIgdSA9IGFhYmIudXBwZXJCb3VuZC55O1xuICAgIGlmKHRoaXMudXBwZXJCb3VuZC55IDwgdSl7XG4gICAgICAgIHRoaXMudXBwZXJCb3VuZC55ID0gdTtcbiAgICB9XG5cbiAgICAvLyBFeHRlbmQgbG93ZXIgYm91bmRcbiAgICB2YXIgbCA9IGFhYmIubG93ZXJCb3VuZC56O1xuICAgIGlmKHRoaXMubG93ZXJCb3VuZC56ID4gbCl7XG4gICAgICAgIHRoaXMubG93ZXJCb3VuZC56ID0gbDtcbiAgICB9XG5cbiAgICAvLyBVcHBlclxuICAgIHZhciB1ID0gYWFiYi51cHBlckJvdW5kLno7XG4gICAgaWYodGhpcy51cHBlckJvdW5kLnogPCB1KXtcbiAgICAgICAgdGhpcy51cHBlckJvdW5kLnogPSB1O1xuICAgIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBBQUJCIG92ZXJsYXBzIHRoaXMgQUFCQi5cbiAqIEBtZXRob2Qgb3ZlcmxhcHNcbiAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbkFBQkIucHJvdG90eXBlLm92ZXJsYXBzID0gZnVuY3Rpb24oYWFiYil7XG4gICAgdmFyIGwxID0gdGhpcy5sb3dlckJvdW5kLFxuICAgICAgICB1MSA9IHRoaXMudXBwZXJCb3VuZCxcbiAgICAgICAgbDIgPSBhYWJiLmxvd2VyQm91bmQsXG4gICAgICAgIHUyID0gYWFiYi51cHBlckJvdW5kO1xuXG4gICAgLy8gICAgICBsMiAgICAgICAgdTJcbiAgICAvLyAgICAgIHwtLS0tLS0tLS18XG4gICAgLy8gfC0tLS0tLS0tfFxuICAgIC8vIGwxICAgICAgIHUxXG5cbiAgICByZXR1cm4gKChsMi54IDw9IHUxLnggJiYgdTEueCA8PSB1Mi54KSB8fCAobDEueCA8PSB1Mi54ICYmIHUyLnggPD0gdTEueCkpICYmXG4gICAgICAgICAgICgobDIueSA8PSB1MS55ICYmIHUxLnkgPD0gdTIueSkgfHwgKGwxLnkgPD0gdTIueSAmJiB1Mi55IDw9IHUxLnkpKSAmJlxuICAgICAgICAgICAoKGwyLnogPD0gdTEueiAmJiB1MS56IDw9IHUyLnopIHx8IChsMS56IDw9IHUyLnogJiYgdTIueiA8PSB1MS56KSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gQUFCQiBpcyBmdWxseSBjb250YWluZWQgaW4gdGhpcyBBQUJCLlxuICogQG1ldGhvZCBjb250YWluc1xuICogQHBhcmFtIHtBQUJCfSBhYWJiXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5BQUJCLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uKGFhYmIpe1xuICAgIHZhciBsMSA9IHRoaXMubG93ZXJCb3VuZCxcbiAgICAgICAgdTEgPSB0aGlzLnVwcGVyQm91bmQsXG4gICAgICAgIGwyID0gYWFiYi5sb3dlckJvdW5kLFxuICAgICAgICB1MiA9IGFhYmIudXBwZXJCb3VuZDtcblxuICAgIC8vICAgICAgbDIgICAgICAgIHUyXG4gICAgLy8gICAgICB8LS0tLS0tLS0tfFxuICAgIC8vIHwtLS0tLS0tLS0tLS0tLS18XG4gICAgLy8gbDEgICAgICAgICAgICAgIHUxXG5cbiAgICByZXR1cm4gKFxuICAgICAgICAobDEueCA8PSBsMi54ICYmIHUxLnggPj0gdTIueCkgJiZcbiAgICAgICAgKGwxLnkgPD0gbDIueSAmJiB1MS55ID49IHUyLnkpICYmXG4gICAgICAgIChsMS56IDw9IGwyLnogJiYgdTEueiA+PSB1Mi56KVxuICAgICk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZ2V0Q29ybmVyc1xuICogQHBhcmFtIHtWZWMzfSBhXG4gKiBAcGFyYW0ge1ZlYzN9IGJcbiAqIEBwYXJhbSB7VmVjM30gY1xuICogQHBhcmFtIHtWZWMzfSBkXG4gKiBAcGFyYW0ge1ZlYzN9IGVcbiAqIEBwYXJhbSB7VmVjM30gZlxuICogQHBhcmFtIHtWZWMzfSBnXG4gKiBAcGFyYW0ge1ZlYzN9IGhcbiAqL1xuQUFCQi5wcm90b3R5cGUuZ2V0Q29ybmVycyA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgpe1xuICAgIHZhciBsID0gdGhpcy5sb3dlckJvdW5kLFxuICAgICAgICB1ID0gdGhpcy51cHBlckJvdW5kO1xuXG4gICAgYS5jb3B5KGwpO1xuICAgIGIuc2V0KCB1LngsIGwueSwgbC56ICk7XG4gICAgYy5zZXQoIHUueCwgdS55LCBsLnogKTtcbiAgICBkLnNldCggbC54LCB1LnksIHUueiApO1xuICAgIGUuc2V0KCB1LngsIGwueSwgbC56ICk7XG4gICAgZi5zZXQoIGwueCwgdS55LCBsLnogKTtcbiAgICBnLnNldCggbC54LCBsLnksIHUueiApO1xuICAgIGguY29weSh1KTtcbn07XG5cbnZhciB0cmFuc2Zvcm1JbnRvRnJhbWVfY29ybmVycyA9IFtcbiAgICBuZXcgVmVjMygpLFxuICAgIG5ldyBWZWMzKCksXG4gICAgbmV3IFZlYzMoKSxcbiAgICBuZXcgVmVjMygpLFxuICAgIG5ldyBWZWMzKCksXG4gICAgbmV3IFZlYzMoKSxcbiAgICBuZXcgVmVjMygpLFxuICAgIG5ldyBWZWMzKClcbl07XG5cbi8qKlxuICogR2V0IHRoZSByZXByZXNlbnRhdGlvbiBvZiBhbiBBQUJCIGluIGFub3RoZXIgZnJhbWUuXG4gKiBAbWV0aG9kIHRvTG9jYWxGcmFtZVxuICogQHBhcmFtICB7VHJhbnNmb3JtfSBmcmFtZVxuICogQHBhcmFtICB7QUFCQn0gdGFyZ2V0XG4gKiBAcmV0dXJuIHtBQUJCfSBUaGUgXCJ0YXJnZXRcIiBBQUJCIG9iamVjdC5cbiAqL1xuQUFCQi5wcm90b3R5cGUudG9Mb2NhbEZyYW1lID0gZnVuY3Rpb24oZnJhbWUsIHRhcmdldCl7XG5cbiAgICB2YXIgY29ybmVycyA9IHRyYW5zZm9ybUludG9GcmFtZV9jb3JuZXJzO1xuICAgIHZhciBhID0gY29ybmVyc1swXTtcbiAgICB2YXIgYiA9IGNvcm5lcnNbMV07XG4gICAgdmFyIGMgPSBjb3JuZXJzWzJdO1xuICAgIHZhciBkID0gY29ybmVyc1szXTtcbiAgICB2YXIgZSA9IGNvcm5lcnNbNF07XG4gICAgdmFyIGYgPSBjb3JuZXJzWzVdO1xuICAgIHZhciBnID0gY29ybmVyc1s2XTtcbiAgICB2YXIgaCA9IGNvcm5lcnNbN107XG5cbiAgICAvLyBHZXQgY29ybmVycyBpbiBjdXJyZW50IGZyYW1lXG4gICAgdGhpcy5nZXRDb3JuZXJzKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgpO1xuXG4gICAgLy8gVHJhbnNmb3JtIHRoZW0gdG8gbmV3IGxvY2FsIGZyYW1lXG4gICAgZm9yKHZhciBpPTA7IGkgIT09IDg7IGkrKyl7XG4gICAgICAgIHZhciBjb3JuZXIgPSBjb3JuZXJzW2ldO1xuICAgICAgICBmcmFtZS5wb2ludFRvTG9jYWwoY29ybmVyLCBjb3JuZXIpO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQuc2V0RnJvbVBvaW50cyhjb3JuZXJzKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSByZXByZXNlbnRhdGlvbiBvZiBhbiBBQUJCIGluIHRoZSBnbG9iYWwgZnJhbWUuXG4gKiBAbWV0aG9kIHRvV29ybGRGcmFtZVxuICogQHBhcmFtICB7VHJhbnNmb3JtfSBmcmFtZVxuICogQHBhcmFtICB7QUFCQn0gdGFyZ2V0XG4gKiBAcmV0dXJuIHtBQUJCfSBUaGUgXCJ0YXJnZXRcIiBBQUJCIG9iamVjdC5cbiAqL1xuQUFCQi5wcm90b3R5cGUudG9Xb3JsZEZyYW1lID0gZnVuY3Rpb24oZnJhbWUsIHRhcmdldCl7XG5cbiAgICB2YXIgY29ybmVycyA9IHRyYW5zZm9ybUludG9GcmFtZV9jb3JuZXJzO1xuICAgIHZhciBhID0gY29ybmVyc1swXTtcbiAgICB2YXIgYiA9IGNvcm5lcnNbMV07XG4gICAgdmFyIGMgPSBjb3JuZXJzWzJdO1xuICAgIHZhciBkID0gY29ybmVyc1szXTtcbiAgICB2YXIgZSA9IGNvcm5lcnNbNF07XG4gICAgdmFyIGYgPSBjb3JuZXJzWzVdO1xuICAgIHZhciBnID0gY29ybmVyc1s2XTtcbiAgICB2YXIgaCA9IGNvcm5lcnNbN107XG5cbiAgICAvLyBHZXQgY29ybmVycyBpbiBjdXJyZW50IGZyYW1lXG4gICAgdGhpcy5nZXRDb3JuZXJzKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgpO1xuXG4gICAgLy8gVHJhbnNmb3JtIHRoZW0gdG8gbmV3IGxvY2FsIGZyYW1lXG4gICAgZm9yKHZhciBpPTA7IGkgIT09IDg7IGkrKyl7XG4gICAgICAgIHZhciBjb3JuZXIgPSBjb3JuZXJzW2ldO1xuICAgICAgICBmcmFtZS5wb2ludFRvV29ybGQoY29ybmVyLCBjb3JuZXIpO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQuc2V0RnJvbVBvaW50cyhjb3JuZXJzKTtcbn07XG5cbn0se1wiLi4vbWF0aC9WZWMzXCI6MzAsXCIuLi91dGlscy9VdGlsc1wiOjUzfV0sNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5Q29sbGlzaW9uTWF0cml4O1xuXG4vKipcbiAqIENvbGxpc2lvbiBcIm1hdHJpeFwiLiBJdCdzIGFjdHVhbGx5IGEgdHJpYW5ndWxhci1zaGFwZWQgYXJyYXkgb2Ygd2hldGhlciB0d28gYm9kaWVzIGFyZSB0b3VjaGluZyB0aGlzIHN0ZXAsIGZvciByZWZlcmVuY2UgbmV4dCBzdGVwXG4gKiBAY2xhc3MgQXJyYXlDb2xsaXNpb25NYXRyaXhcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBBcnJheUNvbGxpc2lvbk1hdHJpeCgpIHtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtYXRyaXggc3RvcmFnZVxuICAgICAqIEBwcm9wZXJ0eSBtYXRyaXhcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG5cdHRoaXMubWF0cml4ID0gW107XG59XG5cbi8qKlxuICogR2V0IGFuIGVsZW1lbnRcbiAqIEBtZXRob2QgZ2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGlcbiAqIEBwYXJhbSAge051bWJlcn0galxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5BcnJheUNvbGxpc2lvbk1hdHJpeC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oaSwgaikge1xuXHRpID0gaS5pbmRleDtcblx0aiA9IGouaW5kZXg7XG4gICAgaWYgKGogPiBpKSB7XG4gICAgICAgIHZhciB0ZW1wID0gajtcbiAgICAgICAgaiA9IGk7XG4gICAgICAgIGkgPSB0ZW1wO1xuICAgIH1cblx0cmV0dXJuIHRoaXMubWF0cml4WyhpKihpICsgMSk+PjEpICsgai0xXTtcbn07XG5cbi8qKlxuICogU2V0IGFuIGVsZW1lbnRcbiAqIEBtZXRob2Qgc2V0XG4gKiBAcGFyYW0ge051bWJlcn0gaVxuICogQHBhcmFtIHtOdW1iZXJ9IGpcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICovXG5BcnJheUNvbGxpc2lvbk1hdHJpeC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oaSwgaiwgdmFsdWUpIHtcblx0aSA9IGkuaW5kZXg7XG5cdGogPSBqLmluZGV4O1xuICAgIGlmIChqID4gaSkge1xuICAgICAgICB2YXIgdGVtcCA9IGo7XG4gICAgICAgIGogPSBpO1xuICAgICAgICBpID0gdGVtcDtcbiAgICB9XG5cdHRoaXMubWF0cml4WyhpKihpICsgMSk+PjEpICsgai0xXSA9IHZhbHVlID8gMSA6IDA7XG59O1xuXG4vKipcbiAqIFNldHMgYWxsIGVsZW1lbnRzIHRvIHplcm9cbiAqIEBtZXRob2QgcmVzZXRcbiAqL1xuQXJyYXlDb2xsaXNpb25NYXRyaXgucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG5cdGZvciAodmFyIGk9MCwgbD10aGlzLm1hdHJpeC5sZW5ndGg7IGkhPT1sOyBpKyspIHtcblx0XHR0aGlzLm1hdHJpeFtpXT0wO1xuXHR9XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIG1heCBudW1iZXIgb2Ygb2JqZWN0c1xuICogQG1ldGhvZCBzZXROdW1PYmplY3RzXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICovXG5BcnJheUNvbGxpc2lvbk1hdHJpeC5wcm90b3R5cGUuc2V0TnVtT2JqZWN0cyA9IGZ1bmN0aW9uKG4pIHtcblx0dGhpcy5tYXRyaXgubGVuZ3RoID0gbioobi0xKT4+MTtcbn07XG5cbn0se31dLDU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIEJvZHkgPSBfZGVyZXFfKCcuLi9vYmplY3RzL0JvZHknKTtcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XG52YXIgUXVhdGVybmlvbiA9IF9kZXJlcV8oJy4uL21hdGgvUXVhdGVybmlvbicpO1xudmFyIFNoYXBlID0gX2RlcmVxXygnLi4vc2hhcGVzL1NoYXBlJyk7XG52YXIgUGxhbmUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvUGxhbmUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBCcm9hZHBoYXNlO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGJyb2FkcGhhc2UgaW1wbGVtZW50YXRpb25zXG4gKiBAY2xhc3MgQnJvYWRwaGFzZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKi9cbmZ1bmN0aW9uIEJyb2FkcGhhc2UoKXtcbiAgICAvKipcbiAgICAqIFRoZSB3b3JsZCB0byBzZWFyY2ggZm9yIGNvbGxpc2lvbnMgaW4uXG4gICAgKiBAcHJvcGVydHkgd29ybGRcbiAgICAqIEB0eXBlIHtXb3JsZH1cbiAgICAqL1xuICAgIHRoaXMud29ybGQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogSWYgc2V0IHRvIHRydWUsIHRoZSBicm9hZHBoYXNlIHVzZXMgYm91bmRpbmcgYm94ZXMgZm9yIGludGVyc2VjdGlvbiB0ZXN0LCBlbHNlIGl0IHVzZXMgYm91bmRpbmcgc3BoZXJlcy5cbiAgICAgKiBAcHJvcGVydHkgdXNlQm91bmRpbmdCb3hlc1xuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMudXNlQm91bmRpbmdCb3hlcyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgaWYgdGhlIG9iamVjdHMgaW4gdGhlIHdvcmxkIG1vdmVkLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZGlydHlcbiAgICAgKi9cbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGNvbGxpc2lvbiBwYWlycyBmcm9tIHRoZSB3b3JsZFxuICogQG1ldGhvZCBjb2xsaXNpb25QYWlyc1xuICogQHBhcmFtIHtXb3JsZH0gd29ybGQgVGhlIHdvcmxkIHRvIHNlYXJjaCBpblxuICogQHBhcmFtIHtBcnJheX0gcDEgRW1wdHkgYXJyYXkgdG8gYmUgZmlsbGVkIHdpdGggYm9keSBvYmplY3RzXG4gKiBAcGFyYW0ge0FycmF5fSBwMiBFbXB0eSBhcnJheSB0byBiZSBmaWxsZWQgd2l0aCBib2R5IG9iamVjdHNcbiAqL1xuQnJvYWRwaGFzZS5wcm90b3R5cGUuY29sbGlzaW9uUGFpcnMgPSBmdW5jdGlvbih3b3JsZCxwMSxwMil7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY29sbGlzaW9uUGFpcnMgbm90IGltcGxlbWVudGVkIGZvciB0aGlzIEJyb2FkUGhhc2UgY2xhc3MhXCIpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIGJvZHkgcGFpciBuZWVkcyB0byBiZSBpbnRlcnNlY3Rpb24gdGVzdGVkIGF0IGFsbC5cbiAqIEBtZXRob2QgbmVlZEJyb2FkcGhhc2VDb2xsaXNpb25cbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEByZXR1cm4ge2Jvb2x9XG4gKi9cbnZhciBCcm9hZHBoYXNlX25lZWRCcm9hZHBoYXNlQ29sbGlzaW9uX1NUQVRJQ19PUl9LSU5FTUFUSUMgPSBCb2R5LlNUQVRJQyB8IEJvZHkuS0lORU1BVElDO1xuQnJvYWRwaGFzZS5wcm90b3R5cGUubmVlZEJyb2FkcGhhc2VDb2xsaXNpb24gPSBmdW5jdGlvbihib2R5QSxib2R5Qil7XG5cbiAgICAvLyBDaGVjayBjb2xsaXNpb24gZmlsdGVyIG1hc2tzXG4gICAgaWYoIChib2R5QS5jb2xsaXNpb25GaWx0ZXJHcm91cCAmIGJvZHlCLmNvbGxpc2lvbkZpbHRlck1hc2spPT09MCB8fCAoYm9keUIuY29sbGlzaW9uRmlsdGVyR3JvdXAgJiBib2R5QS5jb2xsaXNpb25GaWx0ZXJNYXNrKT09PTApe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgdHlwZXNcbiAgICBpZigoKGJvZHlBLnR5cGUgJiBCcm9hZHBoYXNlX25lZWRCcm9hZHBoYXNlQ29sbGlzaW9uX1NUQVRJQ19PUl9LSU5FTUFUSUMpIT09MCB8fCBib2R5QS5zbGVlcFN0YXRlID09PSBCb2R5LlNMRUVQSU5HKSAmJlxuICAgICAgICgoYm9keUIudHlwZSAmIEJyb2FkcGhhc2VfbmVlZEJyb2FkcGhhc2VDb2xsaXNpb25fU1RBVElDX09SX0tJTkVNQVRJQykhPT0wIHx8IGJvZHlCLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcpKSB7XG4gICAgICAgIC8vIEJvdGggYm9kaWVzIGFyZSBzdGF0aWMsIGtpbmVtYXRpYyBvciBzbGVlcGluZy4gU2tpcC5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgYm91bmRpbmcgdm9sdW1lcyBvZiB0d28gYm9kaWVzIGludGVyc2VjdC5cbiAqIEBtZXRob2QgaW50ZXJzZWN0aW9uVGVzdFxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHthcnJheX0gcGFpcnMxXG4gKiBAcGFyYW0ge2FycmF5fSBwYWlyczJcbiAgKi9cbkJyb2FkcGhhc2UucHJvdG90eXBlLmludGVyc2VjdGlvblRlc3QgPSBmdW5jdGlvbihib2R5QSwgYm9keUIsIHBhaXJzMSwgcGFpcnMyKXtcbiAgICBpZih0aGlzLnVzZUJvdW5kaW5nQm94ZXMpe1xuICAgICAgICB0aGlzLmRvQm91bmRpbmdCb3hCcm9hZHBoYXNlKGJvZHlBLGJvZHlCLHBhaXJzMSxwYWlyczIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZG9Cb3VuZGluZ1NwaGVyZUJyb2FkcGhhc2UoYm9keUEsYm9keUIscGFpcnMxLHBhaXJzMik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgYm91bmRpbmcgc3BoZXJlcyBvZiB0d28gYm9kaWVzIGFyZSBpbnRlcnNlY3RpbmcuXG4gKiBAbWV0aG9kIGRvQm91bmRpbmdTcGhlcmVCcm9hZHBoYXNlXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge0FycmF5fSBwYWlyczEgYm9keUEgaXMgYXBwZW5kZWQgdG8gdGhpcyBhcnJheSBpZiBpbnRlcnNlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzMiBib2R5QiBpcyBhcHBlbmRlZCB0byB0aGlzIGFycmF5IGlmIGludGVyc2VjdGlvblxuICovXG52YXIgQnJvYWRwaGFzZV9jb2xsaXNpb25QYWlyc19yID0gbmV3IFZlYzMoKSwgLy8gVGVtcCBvYmplY3RzXG4gICAgQnJvYWRwaGFzZV9jb2xsaXNpb25QYWlyc19ub3JtYWwgPSAgbmV3IFZlYzMoKSxcbiAgICBCcm9hZHBoYXNlX2NvbGxpc2lvblBhaXJzX3F1YXQgPSAgbmV3IFF1YXRlcm5pb24oKSxcbiAgICBCcm9hZHBoYXNlX2NvbGxpc2lvblBhaXJzX3JlbHBvcyAgPSAgbmV3IFZlYzMoKTtcbkJyb2FkcGhhc2UucHJvdG90eXBlLmRvQm91bmRpbmdTcGhlcmVCcm9hZHBoYXNlID0gZnVuY3Rpb24oYm9keUEsYm9keUIscGFpcnMxLHBhaXJzMil7XG4gICAgdmFyIHIgPSBCcm9hZHBoYXNlX2NvbGxpc2lvblBhaXJzX3I7XG4gICAgYm9keUIucG9zaXRpb24udnN1Yihib2R5QS5wb3NpdGlvbixyKTtcbiAgICB2YXIgYm91bmRpbmdSYWRpdXNTdW0yID0gTWF0aC5wb3coYm9keUEuYm91bmRpbmdSYWRpdXMgKyBib2R5Qi5ib3VuZGluZ1JhZGl1cywgMik7XG4gICAgdmFyIG5vcm0yID0gci5ub3JtMigpO1xuICAgIGlmKG5vcm0yIDwgYm91bmRpbmdSYWRpdXNTdW0yKXtcbiAgICAgICAgcGFpcnMxLnB1c2goYm9keUEpO1xuICAgICAgICBwYWlyczIucHVzaChib2R5Qik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgYm91bmRpbmcgYm94ZXMgb2YgdHdvIGJvZGllcyBhcmUgaW50ZXJzZWN0aW5nLlxuICogQG1ldGhvZCBkb0JvdW5kaW5nQm94QnJvYWRwaGFzZVxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtBcnJheX0gcGFpcnMxXG4gKiBAcGFyYW0ge0FycmF5fSBwYWlyczJcbiAqL1xuQnJvYWRwaGFzZS5wcm90b3R5cGUuZG9Cb3VuZGluZ0JveEJyb2FkcGhhc2UgPSBmdW5jdGlvbihib2R5QSxib2R5QixwYWlyczEscGFpcnMyKXtcbiAgICBpZihib2R5QS5hYWJiTmVlZHNVcGRhdGUpe1xuICAgICAgICBib2R5QS5jb21wdXRlQUFCQigpO1xuICAgIH1cbiAgICBpZihib2R5Qi5hYWJiTmVlZHNVcGRhdGUpe1xuICAgICAgICBib2R5Qi5jb21wdXRlQUFCQigpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIEFBQkIgLyBBQUJCXG4gICAgaWYoYm9keUEuYWFiYi5vdmVybGFwcyhib2R5Qi5hYWJiKSl7XG4gICAgICAgIHBhaXJzMS5wdXNoKGJvZHlBKTtcbiAgICAgICAgcGFpcnMyLnB1c2goYm9keUIpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlcyBkdXBsaWNhdGUgcGFpcnMgZnJvbSB0aGUgcGFpciBhcnJheXMuXG4gKiBAbWV0aG9kIG1ha2VQYWlyc1VuaXF1ZVxuICogQHBhcmFtIHtBcnJheX0gcGFpcnMxXG4gKiBAcGFyYW0ge0FycmF5fSBwYWlyczJcbiAqL1xudmFyIEJyb2FkcGhhc2VfbWFrZVBhaXJzVW5pcXVlX3RlbXAgPSB7IGtleXM6W10gfSxcbiAgICBCcm9hZHBoYXNlX21ha2VQYWlyc1VuaXF1ZV9wMSA9IFtdLFxuICAgIEJyb2FkcGhhc2VfbWFrZVBhaXJzVW5pcXVlX3AyID0gW107XG5Ccm9hZHBoYXNlLnByb3RvdHlwZS5tYWtlUGFpcnNVbmlxdWUgPSBmdW5jdGlvbihwYWlyczEscGFpcnMyKXtcbiAgICB2YXIgdCA9IEJyb2FkcGhhc2VfbWFrZVBhaXJzVW5pcXVlX3RlbXAsXG4gICAgICAgIHAxID0gQnJvYWRwaGFzZV9tYWtlUGFpcnNVbmlxdWVfcDEsXG4gICAgICAgIHAyID0gQnJvYWRwaGFzZV9tYWtlUGFpcnNVbmlxdWVfcDIsXG4gICAgICAgIE4gPSBwYWlyczEubGVuZ3RoO1xuXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OOyBpKyspe1xuICAgICAgICBwMVtpXSA9IHBhaXJzMVtpXTtcbiAgICAgICAgcDJbaV0gPSBwYWlyczJbaV07XG4gICAgfVxuXG4gICAgcGFpcnMxLmxlbmd0aCA9IDA7XG4gICAgcGFpcnMyLmxlbmd0aCA9IDA7XG5cbiAgICBmb3IodmFyIGk9MDsgaSE9PU47IGkrKyl7XG4gICAgICAgIHZhciBpZDEgPSBwMVtpXS5pZCxcbiAgICAgICAgICAgIGlkMiA9IHAyW2ldLmlkO1xuICAgICAgICB2YXIga2V5ID0gaWQxIDwgaWQyID8gaWQxK1wiLFwiK2lkMiA6ICBpZDIrXCIsXCIraWQxO1xuICAgICAgICB0W2tleV0gPSBpO1xuICAgICAgICB0LmtleXMucHVzaChrZXkpO1xuICAgIH1cblxuICAgIGZvcih2YXIgaT0wOyBpIT09dC5rZXlzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGtleSA9IHQua2V5cy5wb3AoKSxcbiAgICAgICAgICAgIHBhaXJJbmRleCA9IHRba2V5XTtcbiAgICAgICAgcGFpcnMxLnB1c2gocDFbcGFpckluZGV4XSk7XG4gICAgICAgIHBhaXJzMi5wdXNoKHAyW3BhaXJJbmRleF0pO1xuICAgICAgICBkZWxldGUgdFtrZXldO1xuICAgIH1cbn07XG5cbi8qKlxuICogVG8gYmUgaW1wbGVtZW50ZWQgYnkgc3ViY2Fzc2VzXG4gKiBAbWV0aG9kIHNldFdvcmxkXG4gKiBAcGFyYW0ge1dvcmxkfSB3b3JsZFxuICovXG5Ccm9hZHBoYXNlLnByb3RvdHlwZS5zZXRXb3JsZCA9IGZ1bmN0aW9uKHdvcmxkKXtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGJvdW5kaW5nIHNwaGVyZXMgb2YgdHdvIGJvZGllcyBvdmVybGFwLlxuICogQG1ldGhvZCBib3VuZGluZ1NwaGVyZUNoZWNrXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG52YXIgYnNjX2Rpc3QgPSBuZXcgVmVjMygpO1xuQnJvYWRwaGFzZS5ib3VuZGluZ1NwaGVyZUNoZWNrID0gZnVuY3Rpb24oYm9keUEsYm9keUIpe1xuICAgIHZhciBkaXN0ID0gYnNjX2Rpc3Q7XG4gICAgYm9keUEucG9zaXRpb24udnN1Yihib2R5Qi5wb3NpdGlvbixkaXN0KTtcbiAgICByZXR1cm4gTWF0aC5wb3coYm9keUEuc2hhcGUuYm91bmRpbmdTcGhlcmVSYWRpdXMgKyBib2R5Qi5zaGFwZS5ib3VuZGluZ1NwaGVyZVJhZGl1cywyKSA+IGRpc3Qubm9ybTIoKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbGwgdGhlIGJvZGllcyB3aXRoaW4gdGhlIEFBQkIuXG4gKiBAbWV0aG9kIGFhYmJRdWVyeVxuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXG4gKiBAcGFyYW0gIHtBQUJCfSBhYWJiXG4gKiBAcGFyYW0gIHthcnJheX0gcmVzdWx0IEFuIGFycmF5IHRvIHN0b3JlIHJlc3VsdGluZyBib2RpZXMgaW4uXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuQnJvYWRwaGFzZS5wcm90b3R5cGUuYWFiYlF1ZXJ5ID0gZnVuY3Rpb24od29ybGQsIGFhYmIsIHJlc3VsdCl7XG4gICAgY29uc29sZS53YXJuKCcuYWFiYlF1ZXJ5IGlzIG5vdCBpbXBsZW1lbnRlZCBpbiB0aGlzIEJyb2FkcGhhc2Ugc3ViY2xhc3MuJyk7XG4gICAgcmV0dXJuIFtdO1xufTtcbn0se1wiLi4vbWF0aC9RdWF0ZXJuaW9uXCI6MjgsXCIuLi9tYXRoL1ZlYzNcIjozMCxcIi4uL29iamVjdHMvQm9keVwiOjMxLFwiLi4vc2hhcGVzL1BsYW5lXCI6NDIsXCIuLi9zaGFwZXMvU2hhcGVcIjo0M31dLDY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBHcmlkQnJvYWRwaGFzZTtcblxudmFyIEJyb2FkcGhhc2UgPSBfZGVyZXFfKCcuL0Jyb2FkcGhhc2UnKTtcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvU2hhcGUnKTtcblxuLyoqXG4gKiBBeGlzIGFsaWduZWQgdW5pZm9ybSBncmlkIGJyb2FkcGhhc2UuXG4gKiBAY2xhc3MgR3JpZEJyb2FkcGhhc2VcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQnJvYWRwaGFzZVxuICogQHRvZG8gTmVlZHMgc3VwcG9ydCBmb3IgbW9yZSB0aGFuIGp1c3QgcGxhbmVzIGFuZCBzcGhlcmVzLlxuICogQHBhcmFtIHtWZWMzfSBhYWJiTWluXG4gKiBAcGFyYW0ge1ZlYzN9IGFhYmJNYXhcbiAqIEBwYXJhbSB7TnVtYmVyfSBueCBOdW1iZXIgb2YgYm94ZXMgYWxvbmcgeFxuICogQHBhcmFtIHtOdW1iZXJ9IG55IE51bWJlciBvZiBib3hlcyBhbG9uZyB5XG4gKiBAcGFyYW0ge051bWJlcn0gbnogTnVtYmVyIG9mIGJveGVzIGFsb25nIHpcbiAqL1xuZnVuY3Rpb24gR3JpZEJyb2FkcGhhc2UoYWFiYk1pbixhYWJiTWF4LG54LG55LG56KXtcbiAgICBCcm9hZHBoYXNlLmFwcGx5KHRoaXMpO1xuICAgIHRoaXMubnggPSBueCB8fCAxMDtcbiAgICB0aGlzLm55ID0gbnkgfHwgMTA7XG4gICAgdGhpcy5ueiA9IG56IHx8IDEwO1xuICAgIHRoaXMuYWFiYk1pbiA9IGFhYmJNaW4gfHwgbmV3IFZlYzMoMTAwLDEwMCwxMDApO1xuICAgIHRoaXMuYWFiYk1heCA9IGFhYmJNYXggfHwgbmV3IFZlYzMoLTEwMCwtMTAwLC0xMDApO1xuXHR2YXIgbmJpbnMgPSB0aGlzLm54ICogdGhpcy5ueSAqIHRoaXMubno7XG5cdGlmIChuYmlucyA8PSAwKSB7XG5cdFx0dGhyb3cgXCJHcmlkQnJvYWRwaGFzZTogRWFjaCBkaW1lbnNpb24ncyBuIG11c3QgYmUgPjBcIjtcblx0fVxuICAgIHRoaXMuYmlucyA9IFtdO1xuXHR0aGlzLmJpbkxlbmd0aHMgPSBbXTsgLy9SYXRoZXIgdGhhbiBjb250aW51YWxseSByZXNpemluZyBhcnJheXMgKHRocmFzaGluZyB0aGUgbWVtb3J5KSwganVzdCByZWNvcmQgbGVuZ3RoIGFuZCBhbGxvdyB0aGVtIHRvIGdyb3dcblx0dGhpcy5iaW5zLmxlbmd0aCA9IG5iaW5zO1xuXHR0aGlzLmJpbkxlbmd0aHMubGVuZ3RoID0gbmJpbnM7XG5cdGZvciAodmFyIGk9MDtpPG5iaW5zO2krKykge1xuXHRcdHRoaXMuYmluc1tpXT1bXTtcblx0XHR0aGlzLmJpbkxlbmd0aHNbaV09MDtcblx0fVxufVxuR3JpZEJyb2FkcGhhc2UucHJvdG90eXBlID0gbmV3IEJyb2FkcGhhc2UoKTtcbkdyaWRCcm9hZHBoYXNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdyaWRCcm9hZHBoYXNlO1xuXG4vKipcbiAqIEdldCBhbGwgdGhlIGNvbGxpc2lvbiBwYWlycyBpbiB0aGUgcGh5c2ljcyB3b3JsZFxuICogQG1ldGhvZCBjb2xsaXNpb25QYWlyc1xuICogQHBhcmFtIHtXb3JsZH0gd29ybGRcbiAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzMVxuICogQHBhcmFtIHtBcnJheX0gcGFpcnMyXG4gKi9cbnZhciBHcmlkQnJvYWRwaGFzZV9jb2xsaXNpb25QYWlyc19kID0gbmV3IFZlYzMoKTtcbnZhciBHcmlkQnJvYWRwaGFzZV9jb2xsaXNpb25QYWlyc19iaW5Qb3MgPSBuZXcgVmVjMygpO1xuR3JpZEJyb2FkcGhhc2UucHJvdG90eXBlLmNvbGxpc2lvblBhaXJzID0gZnVuY3Rpb24od29ybGQscGFpcnMxLHBhaXJzMil7XG4gICAgdmFyIE4gPSB3b3JsZC5udW1PYmplY3RzKCksXG4gICAgICAgIGJvZGllcyA9IHdvcmxkLmJvZGllcztcblxuICAgIHZhciBtYXggPSB0aGlzLmFhYmJNYXgsXG4gICAgICAgIG1pbiA9IHRoaXMuYWFiYk1pbixcbiAgICAgICAgbnggPSB0aGlzLm54LFxuICAgICAgICBueSA9IHRoaXMubnksXG4gICAgICAgIG56ID0gdGhpcy5uejtcblxuXHR2YXIgeHN0ZXAgPSBueSpuejtcblx0dmFyIHlzdGVwID0gbno7XG5cdHZhciB6c3RlcCA9IDE7XG5cbiAgICB2YXIgeG1heCA9IG1heC54LFxuICAgICAgICB5bWF4ID0gbWF4LnksXG4gICAgICAgIHptYXggPSBtYXgueixcbiAgICAgICAgeG1pbiA9IG1pbi54LFxuICAgICAgICB5bWluID0gbWluLnksXG4gICAgICAgIHptaW4gPSBtaW4uejtcblxuICAgIHZhciB4bXVsdCA9IG54IC8gKHhtYXgteG1pbiksXG4gICAgICAgIHltdWx0ID0gbnkgLyAoeW1heC15bWluKSxcbiAgICAgICAgem11bHQgPSBueiAvICh6bWF4LXptaW4pO1xuXG4gICAgdmFyIGJpbnNpemVYID0gKHhtYXggLSB4bWluKSAvIG54LFxuICAgICAgICBiaW5zaXplWSA9ICh5bWF4IC0geW1pbikgLyBueSxcbiAgICAgICAgYmluc2l6ZVogPSAoem1heCAtIHptaW4pIC8gbno7XG5cblx0dmFyIGJpblJhZGl1cyA9IE1hdGguc3FydChiaW5zaXplWCpiaW5zaXplWCArIGJpbnNpemVZKmJpbnNpemVZICsgYmluc2l6ZVoqYmluc2l6ZVopICogMC41O1xuXG4gICAgdmFyIHR5cGVzID0gU2hhcGUudHlwZXM7XG4gICAgdmFyIFNQSEVSRSA9ICAgICAgICAgICAgdHlwZXMuU1BIRVJFLFxuICAgICAgICBQTEFORSA9ICAgICAgICAgICAgIHR5cGVzLlBMQU5FLFxuICAgICAgICBCT1ggPSAgICAgICAgICAgICAgIHR5cGVzLkJPWCxcbiAgICAgICAgQ09NUE9VTkQgPSAgICAgICAgICB0eXBlcy5DT01QT1VORCxcbiAgICAgICAgQ09OVkVYUE9MWUhFRFJPTiA9ICB0eXBlcy5DT05WRVhQT0xZSEVEUk9OO1xuXG4gICAgdmFyIGJpbnM9dGhpcy5iaW5zLFxuXHRcdGJpbkxlbmd0aHM9dGhpcy5iaW5MZW5ndGhzLFxuICAgICAgICBOYmlucz10aGlzLmJpbnMubGVuZ3RoO1xuXG4gICAgLy8gUmVzZXQgYmluc1xuICAgIGZvcih2YXIgaT0wOyBpIT09TmJpbnM7IGkrKyl7XG4gICAgICAgIGJpbkxlbmd0aHNbaV0gPSAwO1xuICAgIH1cblxuICAgIHZhciBjZWlsID0gTWF0aC5jZWlsO1xuXHR2YXIgbWluID0gTWF0aC5taW47XG5cdHZhciBtYXggPSBNYXRoLm1heDtcblxuXHRmdW5jdGlvbiBhZGRCb3hUb0JpbnMoeDAseTAsejAseDEseTEsejEsYmkpIHtcblx0XHR2YXIgeG9mZjAgPSAoKHgwIC0geG1pbikgKiB4bXVsdCl8MCxcblx0XHRcdHlvZmYwID0gKCh5MCAtIHltaW4pICogeW11bHQpfDAsXG5cdFx0XHR6b2ZmMCA9ICgoejAgLSB6bWluKSAqIHptdWx0KXwwLFxuXHRcdFx0eG9mZjEgPSBjZWlsKCh4MSAtIHhtaW4pICogeG11bHQpLFxuXHRcdFx0eW9mZjEgPSBjZWlsKCh5MSAtIHltaW4pICogeW11bHQpLFxuXHRcdFx0em9mZjEgPSBjZWlsKCh6MSAtIHptaW4pICogem11bHQpO1xuXG5cdFx0aWYgKHhvZmYwIDwgMCkgeyB4b2ZmMCA9IDA7IH0gZWxzZSBpZiAoeG9mZjAgPj0gbngpIHsgeG9mZjAgPSBueCAtIDE7IH1cblx0XHRpZiAoeW9mZjAgPCAwKSB7IHlvZmYwID0gMDsgfSBlbHNlIGlmICh5b2ZmMCA+PSBueSkgeyB5b2ZmMCA9IG55IC0gMTsgfVxuXHRcdGlmICh6b2ZmMCA8IDApIHsgem9mZjAgPSAwOyB9IGVsc2UgaWYgKHpvZmYwID49IG56KSB7IHpvZmYwID0gbnogLSAxOyB9XG5cdFx0aWYgKHhvZmYxIDwgMCkgeyB4b2ZmMSA9IDA7IH0gZWxzZSBpZiAoeG9mZjEgPj0gbngpIHsgeG9mZjEgPSBueCAtIDE7IH1cblx0XHRpZiAoeW9mZjEgPCAwKSB7IHlvZmYxID0gMDsgfSBlbHNlIGlmICh5b2ZmMSA+PSBueSkgeyB5b2ZmMSA9IG55IC0gMTsgfVxuXHRcdGlmICh6b2ZmMSA8IDApIHsgem9mZjEgPSAwOyB9IGVsc2UgaWYgKHpvZmYxID49IG56KSB7IHpvZmYxID0gbnogLSAxOyB9XG5cblx0XHR4b2ZmMCAqPSB4c3RlcDtcblx0XHR5b2ZmMCAqPSB5c3RlcDtcblx0XHR6b2ZmMCAqPSB6c3RlcDtcblx0XHR4b2ZmMSAqPSB4c3RlcDtcblx0XHR5b2ZmMSAqPSB5c3RlcDtcblx0XHR6b2ZmMSAqPSB6c3RlcDtcblxuXHRcdGZvciAodmFyIHhvZmYgPSB4b2ZmMDsgeG9mZiA8PSB4b2ZmMTsgeG9mZiArPSB4c3RlcCkge1xuXHRcdFx0Zm9yICh2YXIgeW9mZiA9IHlvZmYwOyB5b2ZmIDw9IHlvZmYxOyB5b2ZmICs9IHlzdGVwKSB7XG5cdFx0XHRcdGZvciAodmFyIHpvZmYgPSB6b2ZmMDsgem9mZiA8PSB6b2ZmMTsgem9mZiArPSB6c3RlcCkge1xuXHRcdFx0XHRcdHZhciBpZHggPSB4b2ZmK3lvZmYrem9mZjtcblx0XHRcdFx0XHRiaW5zW2lkeF1bYmluTGVuZ3Roc1tpZHhdKytdID0gYmk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuICAgIC8vIFB1dCBhbGwgYm9kaWVzIGludG8gdGhlIGJpbnNcbiAgICBmb3IodmFyIGk9MDsgaSE9PU47IGkrKyl7XG4gICAgICAgIHZhciBiaSA9IGJvZGllc1tpXTtcbiAgICAgICAgdmFyIHNpID0gYmkuc2hhcGU7XG5cbiAgICAgICAgc3dpdGNoKHNpLnR5cGUpe1xuICAgICAgICBjYXNlIFNQSEVSRTpcbiAgICAgICAgICAgIC8vIFB1dCBpbiBiaW5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIG92ZXJsYXAgd2l0aCBvdGhlciBiaW5zXG4gICAgICAgICAgICB2YXIgeCA9IGJpLnBvc2l0aW9uLngsXG4gICAgICAgICAgICAgICAgeSA9IGJpLnBvc2l0aW9uLnksXG4gICAgICAgICAgICAgICAgeiA9IGJpLnBvc2l0aW9uLno7XG4gICAgICAgICAgICB2YXIgciA9IHNpLnJhZGl1cztcblxuXHRcdFx0YWRkQm94VG9CaW5zKHgtciwgeS1yLCB6LXIsIHgrciwgeStyLCB6K3IsIGJpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUExBTkU6XG4gICAgICAgICAgICBpZihzaS53b3JsZE5vcm1hbE5lZWRzVXBkYXRlKXtcbiAgICAgICAgICAgICAgICBzaS5jb21wdXRlV29ybGROb3JtYWwoYmkucXVhdGVybmlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGxhbmVOb3JtYWwgPSBzaS53b3JsZE5vcm1hbDtcblxuXHRcdFx0Ly9SZWxhdGl2ZSBwb3NpdGlvbiBmcm9tIG9yaWdpbiBvZiBwbGFuZSBvYmplY3QgdG8gdGhlIGZpcnN0IGJpblxuXHRcdFx0Ly9JbmNyZW1lbnRlZCBhcyB3ZSBpdGVyYXRlIHRocm91Z2ggdGhlIGJpbnNcblx0XHRcdHZhciB4cmVzZXQgPSB4bWluICsgYmluc2l6ZVgqMC41IC0gYmkucG9zaXRpb24ueCxcblx0XHRcdFx0eXJlc2V0ID0geW1pbiArIGJpbnNpemVZKjAuNSAtIGJpLnBvc2l0aW9uLnksXG5cdFx0XHRcdHpyZXNldCA9IHptaW4gKyBiaW5zaXplWiowLjUgLSBiaS5wb3NpdGlvbi56O1xuXG4gICAgICAgICAgICB2YXIgZCA9IEdyaWRCcm9hZHBoYXNlX2NvbGxpc2lvblBhaXJzX2Q7XG5cdFx0XHRkLnNldCh4cmVzZXQsIHlyZXNldCwgenJlc2V0KTtcblxuXHRcdFx0Zm9yICh2YXIgeGkgPSAwLCB4b2ZmID0gMDsgeGkgIT09IG54OyB4aSsrLCB4b2ZmICs9IHhzdGVwLCBkLnkgPSB5cmVzZXQsIGQueCArPSBiaW5zaXplWCkge1xuXHRcdFx0XHRmb3IgKHZhciB5aSA9IDAsIHlvZmYgPSAwOyB5aSAhPT0gbnk7IHlpKyssIHlvZmYgKz0geXN0ZXAsIGQueiA9IHpyZXNldCwgZC55ICs9IGJpbnNpemVZKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgemkgPSAwLCB6b2ZmID0gMDsgemkgIT09IG56OyB6aSsrLCB6b2ZmICs9IHpzdGVwLCBkLnogKz0gYmluc2l6ZVopIHtcblx0XHRcdFx0XHRcdGlmIChkLmRvdChwbGFuZU5vcm1hbCkgPCBiaW5SYWRpdXMpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGlkeCA9IHhvZmYgKyB5b2ZmICsgem9mZjtcblx0XHRcdFx0XHRcdFx0Ymluc1tpZHhdW2Jpbkxlbmd0aHNbaWR4XSsrXSA9IGJpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcblx0XHRcdGlmIChiaS5hYWJiTmVlZHNVcGRhdGUpIHtcblx0XHRcdFx0YmkuY29tcHV0ZUFBQkIoKTtcblx0XHRcdH1cblxuXHRcdFx0YWRkQm94VG9CaW5zKFxuXHRcdFx0XHRiaS5hYWJiLmxvd2VyQm91bmQueCxcblx0XHRcdFx0YmkuYWFiYi5sb3dlckJvdW5kLnksXG5cdFx0XHRcdGJpLmFhYmIubG93ZXJCb3VuZC56LFxuXHRcdFx0XHRiaS5hYWJiLnVwcGVyQm91bmQueCxcblx0XHRcdFx0YmkuYWFiYi51cHBlckJvdW5kLnksXG5cdFx0XHRcdGJpLmFhYmIudXBwZXJCb3VuZC56LFxuXHRcdFx0XHRiaSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGVhY2ggYmluXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OYmluczsgaSsrKXtcblx0XHR2YXIgYmluTGVuZ3RoID0gYmluTGVuZ3Roc1tpXTtcblx0XHQvL1NraXAgYmlucyB3aXRoIG5vIHBvdGVudGlhbCBjb2xsaXNpb25zXG5cdFx0aWYgKGJpbkxlbmd0aCA+IDEpIHtcblx0XHRcdHZhciBiaW4gPSBiaW5zW2ldO1xuXG5cdFx0XHQvLyBEbyBOXjIgYnJvYWRwaGFzZSBpbnNpZGVcblx0XHRcdGZvcih2YXIgeGk9MDsgeGkhPT1iaW5MZW5ndGg7IHhpKyspe1xuXHRcdFx0XHR2YXIgYmkgPSBiaW5beGldO1xuXHRcdFx0XHRmb3IodmFyIHlpPTA7IHlpIT09eGk7IHlpKyspe1xuXHRcdFx0XHRcdHZhciBiaiA9IGJpblt5aV07XG5cdFx0XHRcdFx0aWYodGhpcy5uZWVkQnJvYWRwaGFzZUNvbGxpc2lvbihiaSxiaikpe1xuXHRcdFx0XHRcdFx0dGhpcy5pbnRlcnNlY3Rpb25UZXN0KGJpLGJqLHBhaXJzMSxwYWlyczIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cbiAgICB9XG5cbi8vXHRmb3IgKHZhciB6aSA9IDAsIHpvZmY9MDsgemkgPCBuejsgemkrKywgem9mZis9IHpzdGVwKSB7XG4vL1x0XHRjb25zb2xlLmxvZyhcImxheWVyIFwiK3ppKTtcbi8vXHRcdGZvciAodmFyIHlpID0gMCwgeW9mZj0wOyB5aSA8IG55OyB5aSsrLCB5b2ZmICs9IHlzdGVwKSB7XG4vL1x0XHRcdHZhciByb3cgPSAnJztcbi8vXHRcdFx0Zm9yICh2YXIgeGkgPSAwLCB4b2ZmPTA7IHhpIDwgbng7IHhpKyssIHhvZmYgKz0geHN0ZXApIHtcbi8vXHRcdFx0XHR2YXIgaWR4ID0geG9mZiArIHlvZmYgKyB6b2ZmO1xuLy9cdFx0XHRcdHJvdyArPSAnICcgKyBiaW5MZW5ndGhzW2lkeF07XG4vL1x0XHRcdH1cbi8vXHRcdFx0Y29uc29sZS5sb2cocm93KTtcbi8vXHRcdH1cbi8vXHR9XG5cbiAgICB0aGlzLm1ha2VQYWlyc1VuaXF1ZShwYWlyczEscGFpcnMyKTtcbn07XG5cbn0se1wiLi4vbWF0aC9WZWMzXCI6MzAsXCIuLi9zaGFwZXMvU2hhcGVcIjo0MyxcIi4vQnJvYWRwaGFzZVwiOjV9XSw3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gTmFpdmVCcm9hZHBoYXNlO1xuXG52YXIgQnJvYWRwaGFzZSA9IF9kZXJlcV8oJy4vQnJvYWRwaGFzZScpO1xudmFyIEFBQkIgPSBfZGVyZXFfKCcuL0FBQkInKTtcblxuLyoqXG4gKiBOYWl2ZSBicm9hZHBoYXNlIGltcGxlbWVudGF0aW9uLCB1c2VkIGluIGxhY2sgb2YgYmV0dGVyIG9uZXMuXG4gKiBAY2xhc3MgTmFpdmVCcm9hZHBoYXNlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBkZXNjcmlwdGlvbiBUaGUgbmFpdmUgYnJvYWRwaGFzZSBsb29rcyBhdCBhbGwgcG9zc2libGUgcGFpcnMgd2l0aG91dCByZXN0cmljdGlvbiwgdGhlcmVmb3JlIGl0IGhhcyBjb21wbGV4aXR5IE5eMiAod2hpY2ggaXMgYmFkKVxuICogQGV4dGVuZHMgQnJvYWRwaGFzZVxuICovXG5mdW5jdGlvbiBOYWl2ZUJyb2FkcGhhc2UoKXtcbiAgICBCcm9hZHBoYXNlLmFwcGx5KHRoaXMpO1xufVxuTmFpdmVCcm9hZHBoYXNlLnByb3RvdHlwZSA9IG5ldyBCcm9hZHBoYXNlKCk7XG5OYWl2ZUJyb2FkcGhhc2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTmFpdmVCcm9hZHBoYXNlO1xuXG4vKipcbiAqIEdldCBhbGwgdGhlIGNvbGxpc2lvbiBwYWlycyBpbiB0aGUgcGh5c2ljcyB3b3JsZFxuICogQG1ldGhvZCBjb2xsaXNpb25QYWlyc1xuICogQHBhcmFtIHtXb3JsZH0gd29ybGRcbiAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzMVxuICogQHBhcmFtIHtBcnJheX0gcGFpcnMyXG4gKi9cbk5haXZlQnJvYWRwaGFzZS5wcm90b3R5cGUuY29sbGlzaW9uUGFpcnMgPSBmdW5jdGlvbih3b3JsZCxwYWlyczEscGFpcnMyKXtcbiAgICB2YXIgYm9kaWVzID0gd29ybGQuYm9kaWVzLFxuICAgICAgICBuID0gYm9kaWVzLmxlbmd0aCxcbiAgICAgICAgaSxqLGJpLGJqO1xuXG4gICAgLy8gTmFpdmUgTl4yIGZ0dyFcbiAgICBmb3IoaT0wOyBpIT09bjsgaSsrKXtcbiAgICAgICAgZm9yKGo9MDsgaiE9PWk7IGorKyl7XG5cbiAgICAgICAgICAgIGJpID0gYm9kaWVzW2ldO1xuICAgICAgICAgICAgYmogPSBib2RpZXNbal07XG5cbiAgICAgICAgICAgIGlmKCF0aGlzLm5lZWRCcm9hZHBoYXNlQ29sbGlzaW9uKGJpLGJqKSl7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uVGVzdChiaSxiaixwYWlyczEscGFpcnMyKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciB0bXBBQUJCID0gbmV3IEFBQkIoKTtcblxuLyoqXG4gKiBSZXR1cm5zIGFsbCB0aGUgYm9kaWVzIHdpdGhpbiBhbiBBQUJCLlxuICogQG1ldGhvZCBhYWJiUXVlcnlcbiAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxuICogQHBhcmFtICB7QUFCQn0gYWFiYlxuICogQHBhcmFtIHthcnJheX0gcmVzdWx0IEFuIGFycmF5IHRvIHN0b3JlIHJlc3VsdGluZyBib2RpZXMgaW4uXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuTmFpdmVCcm9hZHBoYXNlLnByb3RvdHlwZS5hYWJiUXVlcnkgPSBmdW5jdGlvbih3b3JsZCwgYWFiYiwgcmVzdWx0KXtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgW107XG5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgd29ybGQuYm9kaWVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGIgPSB3b3JsZC5ib2RpZXNbaV07XG5cbiAgICAgICAgaWYoYi5hYWJiTmVlZHNVcGRhdGUpe1xuICAgICAgICAgICAgYi5jb21wdXRlQUFCQigpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVWdseSBoYWNrIHVudGlsIEJvZHkgZ2V0cyBhYWJiXG4gICAgICAgIGlmKGIuYWFiYi5vdmVybGFwcyhhYWJiKSl7XG4gICAgICAgICAgICByZXN1bHQucHVzaChiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xufSx7XCIuL0FBQkJcIjozLFwiLi9Ccm9hZHBoYXNlXCI6NX1dLDg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3RDb2xsaXNpb25NYXRyaXg7XG5cbi8qKlxuICogUmVjb3JkcyB3aGF0IG9iamVjdHMgYXJlIGNvbGxpZGluZyB3aXRoIGVhY2ggb3RoZXJcbiAqIEBjbGFzcyBPYmplY3RDb2xsaXNpb25NYXRyaXhcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBPYmplY3RDb2xsaXNpb25NYXRyaXgoKSB7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWF0cml4IHN0b3JhZ2VcbiAgICAgKiBAcHJvcGVydHkgbWF0cml4XG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cblx0dGhpcy5tYXRyaXggPSB7fTtcbn1cblxuLyoqXG4gKiBAbWV0aG9kIGdldFxuICogQHBhcmFtICB7TnVtYmVyfSBpXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuT2JqZWN0Q29sbGlzaW9uTWF0cml4LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihpLCBqKSB7XG5cdGkgPSBpLmlkO1xuXHRqID0gai5pZDtcbiAgICBpZiAoaiA+IGkpIHtcbiAgICAgICAgdmFyIHRlbXAgPSBqO1xuICAgICAgICBqID0gaTtcbiAgICAgICAgaSA9IHRlbXA7XG4gICAgfVxuXHRyZXR1cm4gaSsnLScraiBpbiB0aGlzLm1hdHJpeDtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gaVxuICogQHBhcmFtICB7TnVtYmVyfSBqXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAqL1xuT2JqZWN0Q29sbGlzaW9uTWF0cml4LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihpLCBqLCB2YWx1ZSkge1xuXHRpID0gaS5pZDtcblx0aiA9IGouaWQ7XG4gICAgaWYgKGogPiBpKSB7XG4gICAgICAgIHZhciB0ZW1wID0gajtcbiAgICAgICAgaiA9IGk7XG4gICAgICAgIGkgPSB0ZW1wO1xuXHR9XG5cdGlmICh2YWx1ZSkge1xuXHRcdHRoaXMubWF0cml4W2krJy0nK2pdID0gdHJ1ZTtcblx0fVxuXHRlbHNlIHtcblx0XHRkZWxldGUgdGhpcy5tYXRyaXhbaSsnLScral07XG5cdH1cbn07XG5cbi8qKlxuICogRW1wdHkgdGhlIG1hdHJpeFxuICogQG1ldGhvZCByZXNldFxuICovXG5PYmplY3RDb2xsaXNpb25NYXRyaXgucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMubWF0cml4ID0ge307XG59O1xuXG4vKipcbiAqIFNldCBtYXggbnVtYmVyIG9mIG9iamVjdHNcbiAqIEBtZXRob2Qgc2V0TnVtT2JqZWN0c1xuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqL1xuT2JqZWN0Q29sbGlzaW9uTWF0cml4LnByb3RvdHlwZS5zZXROdW1PYmplY3RzID0gZnVuY3Rpb24obikge1xufTtcblxufSx7fV0sOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IFJheTtcblxudmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcbnZhciBRdWF0ZXJuaW9uID0gX2RlcmVxXygnLi4vbWF0aC9RdWF0ZXJuaW9uJyk7XG52YXIgVHJhbnNmb3JtID0gX2RlcmVxXygnLi4vbWF0aC9UcmFuc2Zvcm0nKTtcbnZhciBDb252ZXhQb2x5aGVkcm9uID0gX2RlcmVxXygnLi4vc2hhcGVzL0NvbnZleFBvbHloZWRyb24nKTtcbnZhciBCb3ggPSBfZGVyZXFfKCcuLi9zaGFwZXMvQm94Jyk7XG52YXIgUmF5Y2FzdFJlc3VsdCA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9SYXljYXN0UmVzdWx0Jyk7XG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvU2hhcGUnKTtcbnZhciBBQUJCID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL0FBQkInKTtcblxuLyoqXG4gKiBBIGxpbmUgaW4gM0Qgc3BhY2UgdGhhdCBpbnRlcnNlY3RzIGJvZGllcyBhbmQgcmV0dXJuIHBvaW50cy5cbiAqIEBjbGFzcyBSYXlcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtWZWMzfSBmcm9tXG4gKiBAcGFyYW0ge1ZlYzN9IHRvXG4gKi9cbmZ1bmN0aW9uIFJheShmcm9tLCB0byl7XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtWZWMzfSBmcm9tXG4gICAgICovXG4gICAgdGhpcy5mcm9tID0gZnJvbSA/IGZyb20uY2xvbmUoKSA6IG5ldyBWZWMzKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IHRvXG4gICAgICovXG4gICAgdGhpcy50byA9IHRvID8gdG8uY2xvbmUoKSA6IG5ldyBWZWMzKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gX2RpcmVjdGlvblxuICAgICAqL1xuICAgIHRoaXMuX2RpcmVjdGlvbiA9IG5ldyBWZWMzKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcHJlY2lzaW9uIG9mIHRoZSByYXkuIFVzZWQgd2hlbiBjaGVja2luZyBwYXJhbGxlbGl0eSBldGMuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHByZWNpc2lvblxuICAgICAqL1xuICAgIHRoaXMucHJlY2lzaW9uID0gMC4wMDAxO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdGhlIFJheSB0byB0YWtlIC5jb2xsaXNpb25SZXNwb25zZSBmbGFncyBpbnRvIGFjY291bnQgb24gYm9kaWVzIGFuZCBzaGFwZXMuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBjaGVja0NvbGxpc2lvblJlc3BvbnNlXG4gICAgICovXG4gICAgdGhpcy5jaGVja0NvbGxpc2lvblJlc3BvbnNlID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIElmIHNldCB0byB0cnVlLCB0aGUgcmF5IHNraXBzIGFueSBoaXRzIHdpdGggbm9ybWFsLmRvdChyYXlEaXJlY3Rpb24pIDwgMC5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHNraXBCYWNrZmFjZXNcbiAgICAgKi9cbiAgICB0aGlzLnNraXBCYWNrZmFjZXMgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2xsaXNpb25GaWx0ZXJNYXNrXG4gICAgICogQGRlZmF1bHQgLTFcbiAgICAgKi9cbiAgICB0aGlzLmNvbGxpc2lvbkZpbHRlck1hc2sgPSAtMTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2xsaXNpb25GaWx0ZXJHcm91cFxuICAgICAqIEBkZWZhdWx0IC0xXG4gICAgICovXG4gICAgdGhpcy5jb2xsaXNpb25GaWx0ZXJHcm91cCA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGludGVyc2VjdGlvbiBtb2RlLiBTaG91bGQgYmUgUmF5LkFOWSwgUmF5LkFMTCBvciBSYXkuQ0xPU0VTVC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbW9kZVxuICAgICAqL1xuICAgIHRoaXMubW9kZSA9IFJheS5BTlk7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHJlc3VsdCBvYmplY3QuXG4gICAgICogQHByb3BlcnR5IHtSYXljYXN0UmVzdWx0fSByZXN1bHRcbiAgICAgKi9cbiAgICB0aGlzLnJlc3VsdCA9IG5ldyBSYXljYXN0UmVzdWx0KCk7XG5cbiAgICAvKipcbiAgICAgKiBXaWxsIGJlIHNldCB0byB0cnVlIGR1cmluZyBpbnRlcnNlY3RXb3JsZCgpIGlmIHRoZSByYXkgaGl0IGFueXRoaW5nLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaGFzSGl0XG4gICAgICovXG4gICAgdGhpcy5oYXNIaXQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQsIHVzZXItcHJvdmlkZWQgcmVzdWx0IGNhbGxiYWNrLiBXaWxsIGJlIHVzZWQgaWYgbW9kZSBpcyBSYXkuQUxMLlxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICovXG4gICAgdGhpcy5jYWxsYmFjayA9IGZ1bmN0aW9uKHJlc3VsdCl7fTtcbn1cblJheS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSYXk7XG5cblJheS5DTE9TRVNUID0gMTtcblJheS5BTlkgPSAyO1xuUmF5LkFMTCA9IDQ7XG5cbnZhciB0bXBBQUJCID0gbmV3IEFBQkIoKTtcbnZhciB0bXBBcnJheSA9IFtdO1xuXG4vKipcbiAqIERvIGl0ZXJzZWN0aW9uIGFnYWluc3QgYWxsIGJvZGllcyBpbiB0aGUgZ2l2ZW4gV29ybGQuXG4gKiBAbWV0aG9kIGludGVyc2VjdFdvcmxkXG4gKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcbiAqIEBwYXJhbSAge29iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgcmF5IGhpdCBhbnl0aGluZywgb3RoZXJ3aXNlIGZhbHNlLlxuICovXG5SYXkucHJvdG90eXBlLmludGVyc2VjdFdvcmxkID0gZnVuY3Rpb24gKHdvcmxkLCBvcHRpb25zKSB7XG4gICAgdGhpcy5tb2RlID0gb3B0aW9ucy5tb2RlIHx8IFJheS5BTlk7XG4gICAgdGhpcy5yZXN1bHQgPSBvcHRpb25zLnJlc3VsdCB8fCBuZXcgUmF5Y2FzdFJlc3VsdCgpO1xuICAgIHRoaXMuc2tpcEJhY2tmYWNlcyA9ICEhb3B0aW9ucy5za2lwQmFja2ZhY2VzO1xuICAgIHRoaXMuY29sbGlzaW9uRmlsdGVyTWFzayA9IHR5cGVvZihvcHRpb25zLmNvbGxpc2lvbkZpbHRlck1hc2spICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuY29sbGlzaW9uRmlsdGVyTWFzayA6IC0xO1xuICAgIHRoaXMuY29sbGlzaW9uRmlsdGVyR3JvdXAgPSB0eXBlb2Yob3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJHcm91cCkgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJHcm91cCA6IC0xO1xuICAgIGlmKG9wdGlvbnMuZnJvbSl7XG4gICAgICAgIHRoaXMuZnJvbS5jb3B5KG9wdGlvbnMuZnJvbSk7XG4gICAgfVxuICAgIGlmKG9wdGlvbnMudG8pe1xuICAgICAgICB0aGlzLnRvLmNvcHkob3B0aW9ucy50byk7XG4gICAgfVxuICAgIHRoaXMuY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrIHx8IGZ1bmN0aW9uKCl7fTtcbiAgICB0aGlzLmhhc0hpdCA9IGZhbHNlO1xuXG4gICAgdGhpcy5yZXN1bHQucmVzZXQoKTtcbiAgICB0aGlzLl91cGRhdGVEaXJlY3Rpb24oKTtcblxuICAgIHRoaXMuZ2V0QUFCQih0bXBBQUJCKTtcbiAgICB0bXBBcnJheS5sZW5ndGggPSAwO1xuICAgIHdvcmxkLmJyb2FkcGhhc2UuYWFiYlF1ZXJ5KHdvcmxkLCB0bXBBQUJCLCB0bXBBcnJheSk7XG4gICAgdGhpcy5pbnRlcnNlY3RCb2RpZXModG1wQXJyYXkpO1xuXG4gICAgcmV0dXJuIHRoaXMuaGFzSGl0O1xufTtcblxudmFyIHYxID0gbmV3IFZlYzMoKSxcbiAgICB2MiA9IG5ldyBWZWMzKCk7XG5cbi8qXG4gKiBBcyBwZXIgXCJCYXJ5Y2VudHJpYyBUZWNobmlxdWVcIiBhcyBuYW1lZCBoZXJlIGh0dHA6Ly93d3cuYmxhY2twYXduLmNvbS90ZXh0cy9wb2ludGlucG9seS9kZWZhdWx0Lmh0bWwgQnV0IHdpdGhvdXQgdGhlIGRpdmlzaW9uXG4gKi9cblJheS5wb2ludEluVHJpYW5nbGUgPSBwb2ludEluVHJpYW5nbGU7XG5mdW5jdGlvbiBwb2ludEluVHJpYW5nbGUocCwgYSwgYiwgYykge1xuICAgIGMudnN1YihhLHYwKTtcbiAgICBiLnZzdWIoYSx2MSk7XG4gICAgcC52c3ViKGEsdjIpO1xuXG4gICAgdmFyIGRvdDAwID0gdjAuZG90KCB2MCApO1xuICAgIHZhciBkb3QwMSA9IHYwLmRvdCggdjEgKTtcbiAgICB2YXIgZG90MDIgPSB2MC5kb3QoIHYyICk7XG4gICAgdmFyIGRvdDExID0gdjEuZG90KCB2MSApO1xuICAgIHZhciBkb3QxMiA9IHYxLmRvdCggdjIgKTtcblxuICAgIHZhciB1LHY7XG5cbiAgICByZXR1cm4gICggKHUgPSBkb3QxMSAqIGRvdDAyIC0gZG90MDEgKiBkb3QxMikgPj0gMCApICYmXG4gICAgICAgICAgICAoICh2ID0gZG90MDAgKiBkb3QxMiAtIGRvdDAxICogZG90MDIpID49IDAgKSAmJlxuICAgICAgICAgICAgKCB1ICsgdiA8ICggZG90MDAgKiBkb3QxMSAtIGRvdDAxICogZG90MDEgKSApO1xufVxuXG4vKipcbiAqIFNob290IGEgcmF5IGF0IGEgYm9keSwgZ2V0IGJhY2sgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGhpdC5cbiAqIEBtZXRob2QgaW50ZXJzZWN0Qm9keVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICogQHBhcmFtIHtSYXljYXN0UmVzdWx0fSBbcmVzdWx0XSBEZXByZWNhdGVkIC0gc2V0IHRoZSByZXN1bHQgcHJvcGVydHkgb2YgdGhlIFJheSBpbnN0ZWFkLlxuICovXG52YXIgaW50ZXJzZWN0Qm9keV94aSA9IG5ldyBWZWMzKCk7XG52YXIgaW50ZXJzZWN0Qm9keV9xaSA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5SYXkucHJvdG90eXBlLmludGVyc2VjdEJvZHkgPSBmdW5jdGlvbiAoYm9keSwgcmVzdWx0KSB7XG4gICAgaWYocmVzdWx0KXtcbiAgICAgICAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgIHRoaXMuX3VwZGF0ZURpcmVjdGlvbigpO1xuICAgIH1cbiAgICB2YXIgY2hlY2tDb2xsaXNpb25SZXNwb25zZSA9IHRoaXMuY2hlY2tDb2xsaXNpb25SZXNwb25zZTtcblxuICAgIGlmKGNoZWNrQ29sbGlzaW9uUmVzcG9uc2UgJiYgIWJvZHkuY29sbGlzaW9uUmVzcG9uc2Upe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYoKHRoaXMuY29sbGlzaW9uRmlsdGVyR3JvdXAgJiBib2R5LmNvbGxpc2lvbkZpbHRlck1hc2spPT09MCB8fCAoYm9keS5jb2xsaXNpb25GaWx0ZXJHcm91cCAmIHRoaXMuY29sbGlzaW9uRmlsdGVyTWFzayk9PT0wKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB4aSA9IGludGVyc2VjdEJvZHlfeGk7XG4gICAgdmFyIHFpID0gaW50ZXJzZWN0Qm9keV9xaTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBOID0gYm9keS5zaGFwZXMubGVuZ3RoOyBpIDwgTjsgaSsrKSB7XG4gICAgICAgIHZhciBzaGFwZSA9IGJvZHkuc2hhcGVzW2ldO1xuXG4gICAgICAgIGlmKGNoZWNrQ29sbGlzaW9uUmVzcG9uc2UgJiYgIXNoYXBlLmNvbGxpc2lvblJlc3BvbnNlKXtcbiAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBTa2lwXG4gICAgICAgIH1cblxuICAgICAgICBib2R5LnF1YXRlcm5pb24ubXVsdChib2R5LnNoYXBlT3JpZW50YXRpb25zW2ldLCBxaSk7XG4gICAgICAgIGJvZHkucXVhdGVybmlvbi52bXVsdChib2R5LnNoYXBlT2Zmc2V0c1tpXSwgeGkpO1xuICAgICAgICB4aS52YWRkKGJvZHkucG9zaXRpb24sIHhpKTtcblxuICAgICAgICB0aGlzLmludGVyc2VjdFNoYXBlKFxuICAgICAgICAgICAgc2hhcGUsXG4gICAgICAgICAgICBxaSxcbiAgICAgICAgICAgIHhpLFxuICAgICAgICAgICAgYm9keVxuICAgICAgICApO1xuXG4gICAgICAgIGlmKHRoaXMucmVzdWx0Ll9zaG91bGRTdG9wKXtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBAbWV0aG9kIGludGVyc2VjdEJvZGllc1xuICogQHBhcmFtIHtBcnJheX0gYm9kaWVzIEFuIGFycmF5IG9mIEJvZHkgb2JqZWN0cy5cbiAqIEBwYXJhbSB7UmF5Y2FzdFJlc3VsdH0gW3Jlc3VsdF0gRGVwcmVjYXRlZFxuICovXG5SYXkucHJvdG90eXBlLmludGVyc2VjdEJvZGllcyA9IGZ1bmN0aW9uIChib2RpZXMsIHJlc3VsdCkge1xuICAgIGlmKHJlc3VsdCl7XG4gICAgICAgIHRoaXMucmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICB0aGlzLl91cGRhdGVEaXJlY3Rpb24oKTtcbiAgICB9XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBib2RpZXMubGVuZ3RoOyAhdGhpcy5yZXN1bHQuX3Nob3VsZFN0b3AgJiYgaSA8IGw7IGkgKysgKSB7XG4gICAgICAgIHRoaXMuaW50ZXJzZWN0Qm9keShib2RpZXNbaV0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgX2RpcmVjdGlvbiB2ZWN0b3IuXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCBfdXBkYXRlRGlyZWN0aW9uXG4gKi9cblJheS5wcm90b3R5cGUuX3VwZGF0ZURpcmVjdGlvbiA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy50by52c3ViKHRoaXMuZnJvbSwgdGhpcy5fZGlyZWN0aW9uKTtcbiAgICB0aGlzLl9kaXJlY3Rpb24ubm9ybWFsaXplKCk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgaW50ZXJzZWN0U2hhcGVcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1NoYXBlfSBzaGFwZVxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxdWF0XG4gKiBAcGFyYW0ge1ZlYzN9IHBvc2l0aW9uXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlcbiAqL1xuUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RTaGFwZSA9IGZ1bmN0aW9uKHNoYXBlLCBxdWF0LCBwb3NpdGlvbiwgYm9keSl7XG4gICAgdmFyIGZyb20gPSB0aGlzLmZyb207XG5cblxuICAgIC8vIENoZWNraW5nIGJvdW5kaW5nU3BoZXJlXG4gICAgdmFyIGRpc3RhbmNlID0gZGlzdGFuY2VGcm9tSW50ZXJzZWN0aW9uKGZyb20sIHRoaXMuX2RpcmVjdGlvbiwgcG9zaXRpb24pO1xuICAgIGlmICggZGlzdGFuY2UgPiBzaGFwZS5ib3VuZGluZ1NwaGVyZVJhZGl1cyApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpbnRlcnNlY3RNZXRob2QgPSB0aGlzW3NoYXBlLnR5cGVdO1xuICAgIGlmKGludGVyc2VjdE1ldGhvZCl7XG4gICAgICAgIGludGVyc2VjdE1ldGhvZC5jYWxsKHRoaXMsIHNoYXBlLCBxdWF0LCBwb3NpdGlvbiwgYm9keSk7XG4gICAgfVxufTtcblxudmFyIHZlY3RvciA9IG5ldyBWZWMzKCk7XG52YXIgbm9ybWFsID0gbmV3IFZlYzMoKTtcbnZhciBpbnRlcnNlY3RQb2ludCA9IG5ldyBWZWMzKCk7XG5cbnZhciBhID0gbmV3IFZlYzMoKTtcbnZhciBiID0gbmV3IFZlYzMoKTtcbnZhciBjID0gbmV3IFZlYzMoKTtcbnZhciBkID0gbmV3IFZlYzMoKTtcblxudmFyIHRtcFJheWNhc3RSZXN1bHQgPSBuZXcgUmF5Y2FzdFJlc3VsdCgpO1xuXG4vKipcbiAqIEBtZXRob2QgaW50ZXJzZWN0Qm94XG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7U2hhcGV9IHNoYXBlXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxdWF0XG4gKiBAcGFyYW0gIHtWZWMzfSBwb3NpdGlvblxuICogQHBhcmFtICB7Qm9keX0gYm9keVxuICovXG5SYXkucHJvdG90eXBlLmludGVyc2VjdEJveCA9IGZ1bmN0aW9uKHNoYXBlLCBxdWF0LCBwb3NpdGlvbiwgYm9keSl7XG4gICAgcmV0dXJuIHRoaXMuaW50ZXJzZWN0Q29udmV4KHNoYXBlLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbiwgcXVhdCwgcG9zaXRpb24sIGJvZHkpO1xufTtcblJheS5wcm90b3R5cGVbU2hhcGUudHlwZXMuQk9YXSA9IFJheS5wcm90b3R5cGUuaW50ZXJzZWN0Qm94O1xuXG4vKipcbiAqIEBtZXRob2QgaW50ZXJzZWN0UGxhbmVcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHtTaGFwZX0gc2hhcGVcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHF1YXRcbiAqIEBwYXJhbSAge1ZlYzN9IHBvc2l0aW9uXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5XG4gKi9cblJheS5wcm90b3R5cGUuaW50ZXJzZWN0UGxhbmUgPSBmdW5jdGlvbihzaGFwZSwgcXVhdCwgcG9zaXRpb24sIGJvZHkpe1xuICAgIHZhciBmcm9tID0gdGhpcy5mcm9tO1xuICAgIHZhciB0byA9IHRoaXMudG87XG4gICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMuX2RpcmVjdGlvbjtcblxuICAgIC8vIEdldCBwbGFuZSBub3JtYWxcbiAgICB2YXIgd29ybGROb3JtYWwgPSBuZXcgVmVjMygwLCAwLCAxKTtcbiAgICBxdWF0LnZtdWx0KHdvcmxkTm9ybWFsLCB3b3JsZE5vcm1hbCk7XG5cbiAgICB2YXIgbGVuID0gbmV3IFZlYzMoKTtcbiAgICBmcm9tLnZzdWIocG9zaXRpb24sIGxlbik7XG4gICAgdmFyIHBsYW5lVG9Gcm9tID0gbGVuLmRvdCh3b3JsZE5vcm1hbCk7XG4gICAgdG8udnN1Yihwb3NpdGlvbiwgbGVuKTtcbiAgICB2YXIgcGxhbmVUb1RvID0gbGVuLmRvdCh3b3JsZE5vcm1hbCk7XG5cbiAgICBpZihwbGFuZVRvRnJvbSAqIHBsYW5lVG9UbyA+IDApe1xuICAgICAgICAvLyBcImZyb21cIiBhbmQgXCJ0b1wiIGFyZSBvbiB0aGUgc2FtZSBzaWRlIG9mIHRoZSBwbGFuZS4uLiBiYWlsIG91dFxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYoZnJvbS5kaXN0YW5jZVRvKHRvKSA8IHBsYW5lVG9Gcm9tKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuX2RvdF9kaXIgPSB3b3JsZE5vcm1hbC5kb3QoZGlyZWN0aW9uKTtcblxuICAgIGlmIChNYXRoLmFicyhuX2RvdF9kaXIpIDwgdGhpcy5wcmVjaXNpb24pIHtcbiAgICAgICAgLy8gTm8gaW50ZXJzZWN0aW9uXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGxhbmVQb2ludFRvRnJvbSA9IG5ldyBWZWMzKCk7XG4gICAgdmFyIGRpcl9zY2FsZWRfd2l0aF90ID0gbmV3IFZlYzMoKTtcbiAgICB2YXIgaGl0UG9pbnRXb3JsZCA9IG5ldyBWZWMzKCk7XG5cbiAgICBmcm9tLnZzdWIocG9zaXRpb24sIHBsYW5lUG9pbnRUb0Zyb20pO1xuICAgIHZhciB0ID0gLXdvcmxkTm9ybWFsLmRvdChwbGFuZVBvaW50VG9Gcm9tKSAvIG5fZG90X2RpcjtcbiAgICBkaXJlY3Rpb24uc2NhbGUodCwgZGlyX3NjYWxlZF93aXRoX3QpO1xuICAgIGZyb20udmFkZChkaXJfc2NhbGVkX3dpdGhfdCwgaGl0UG9pbnRXb3JsZCk7XG5cbiAgICB0aGlzLnJlcG9ydEludGVyc2VjdGlvbih3b3JsZE5vcm1hbCwgaGl0UG9pbnRXb3JsZCwgc2hhcGUsIGJvZHksIC0xKTtcbn07XG5SYXkucHJvdG90eXBlW1NoYXBlLnR5cGVzLlBMQU5FXSA9IFJheS5wcm90b3R5cGUuaW50ZXJzZWN0UGxhbmU7XG5cbi8qKlxuICogR2V0IHRoZSB3b3JsZCBBQUJCIG9mIHRoZSByYXkuXG4gKiBAbWV0aG9kIGdldEFBQkJcbiAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcbiAqL1xuUmF5LnByb3RvdHlwZS5nZXRBQUJCID0gZnVuY3Rpb24ocmVzdWx0KXtcbiAgICB2YXIgdG8gPSB0aGlzLnRvO1xuICAgIHZhciBmcm9tID0gdGhpcy5mcm9tO1xuICAgIHJlc3VsdC5sb3dlckJvdW5kLnggPSBNYXRoLm1pbih0by54LCBmcm9tLngpO1xuICAgIHJlc3VsdC5sb3dlckJvdW5kLnkgPSBNYXRoLm1pbih0by55LCBmcm9tLnkpO1xuICAgIHJlc3VsdC5sb3dlckJvdW5kLnogPSBNYXRoLm1pbih0by56LCBmcm9tLnopO1xuICAgIHJlc3VsdC51cHBlckJvdW5kLnggPSBNYXRoLm1heCh0by54LCBmcm9tLngpO1xuICAgIHJlc3VsdC51cHBlckJvdW5kLnkgPSBNYXRoLm1heCh0by55LCBmcm9tLnkpO1xuICAgIHJlc3VsdC51cHBlckJvdW5kLnogPSBNYXRoLm1heCh0by56LCBmcm9tLnopO1xufTtcblxudmFyIGludGVyc2VjdENvbnZleE9wdGlvbnMgPSB7XG4gICAgZmFjZUxpc3Q6IFswXVxufTtcblxuLyoqXG4gKiBAbWV0aG9kIGludGVyc2VjdEhlaWdodGZpZWxkXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7U2hhcGV9IHNoYXBlXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxdWF0XG4gKiBAcGFyYW0gIHtWZWMzfSBwb3NpdGlvblxuICogQHBhcmFtICB7Qm9keX0gYm9keVxuICovXG5SYXkucHJvdG90eXBlLmludGVyc2VjdEhlaWdodGZpZWxkID0gZnVuY3Rpb24oc2hhcGUsIHF1YXQsIHBvc2l0aW9uLCBib2R5KXtcbiAgICB2YXIgZGF0YSA9IHNoYXBlLmRhdGEsXG4gICAgICAgIHcgPSBzaGFwZS5lbGVtZW50U2l6ZSxcbiAgICAgICAgd29ybGRQaWxsYXJPZmZzZXQgPSBuZXcgVmVjMygpO1xuXG4gICAgLy8gQ29udmVydCB0aGUgcmF5IHRvIGxvY2FsIGhlaWdodGZpZWxkIGNvb3JkaW5hdGVzXG4gICAgdmFyIGxvY2FsUmF5ID0gbmV3IFJheSh0aGlzLmZyb20sIHRoaXMudG8pO1xuICAgIFRyYW5zZm9ybS5wb2ludFRvTG9jYWxGcmFtZShwb3NpdGlvbiwgcXVhdCwgbG9jYWxSYXkuZnJvbSwgbG9jYWxSYXkuZnJvbSk7XG4gICAgVHJhbnNmb3JtLnBvaW50VG9Mb2NhbEZyYW1lKHBvc2l0aW9uLCBxdWF0LCBsb2NhbFJheS50bywgbG9jYWxSYXkudG8pO1xuXG4gICAgLy8gR2V0IHRoZSBpbmRleCBvZiB0aGUgZGF0YSBwb2ludHMgdG8gdGVzdCBhZ2FpbnN0XG4gICAgdmFyIGluZGV4ID0gW107XG4gICAgdmFyIGlNaW5YID0gbnVsbDtcbiAgICB2YXIgaU1pblkgPSBudWxsO1xuICAgIHZhciBpTWF4WCA9IG51bGw7XG4gICAgdmFyIGlNYXhZID0gbnVsbDtcblxuICAgIHZhciBpbnNpZGUgPSBzaGFwZS5nZXRJbmRleE9mUG9zaXRpb24obG9jYWxSYXkuZnJvbS54LCBsb2NhbFJheS5mcm9tLnksIGluZGV4LCBmYWxzZSk7XG4gICAgaWYoaW5zaWRlKXtcbiAgICAgICAgaU1pblggPSBpbmRleFswXTtcbiAgICAgICAgaU1pblkgPSBpbmRleFsxXTtcbiAgICAgICAgaU1heFggPSBpbmRleFswXTtcbiAgICAgICAgaU1heFkgPSBpbmRleFsxXTtcbiAgICB9XG4gICAgaW5zaWRlID0gc2hhcGUuZ2V0SW5kZXhPZlBvc2l0aW9uKGxvY2FsUmF5LnRvLngsIGxvY2FsUmF5LnRvLnksIGluZGV4LCBmYWxzZSk7XG4gICAgaWYoaW5zaWRlKXtcbiAgICAgICAgaWYgKGlNaW5YID09PSBudWxsIHx8IGluZGV4WzBdIDwgaU1pblgpIHsgaU1pblggPSBpbmRleFswXTsgfVxuICAgICAgICBpZiAoaU1heFggPT09IG51bGwgfHwgaW5kZXhbMF0gPiBpTWF4WCkgeyBpTWF4WCA9IGluZGV4WzBdOyB9XG4gICAgICAgIGlmIChpTWluWSA9PT0gbnVsbCB8fCBpbmRleFsxXSA8IGlNaW5ZKSB7IGlNaW5ZID0gaW5kZXhbMV07IH1cbiAgICAgICAgaWYgKGlNYXhZID09PSBudWxsIHx8IGluZGV4WzFdID4gaU1heFkpIHsgaU1heFkgPSBpbmRleFsxXTsgfVxuICAgIH1cblxuICAgIGlmKGlNaW5YID09PSBudWxsKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBtaW5NYXggPSBbXTtcbiAgICBzaGFwZS5nZXRSZWN0TWluTWF4KGlNaW5YLCBpTWluWSwgaU1heFgsIGlNYXhZLCBtaW5NYXgpO1xuICAgIHZhciBtaW4gPSBtaW5NYXhbMF07XG4gICAgdmFyIG1heCA9IG1pbk1heFsxXTtcblxuICAgIC8vIC8vIEJhaWwgb3V0IGlmIHRoZSByYXkgY2FuJ3QgdG91Y2ggdGhlIGJvdW5kaW5nIGJveFxuICAgIC8vIC8vIFRPRE9cbiAgICAvLyB2YXIgYWFiYiA9IG5ldyBBQUJCKCk7XG4gICAgLy8gdGhpcy5nZXRBQUJCKGFhYmIpO1xuICAgIC8vIGlmKGFhYmIuaW50ZXJzZWN0cygpKXtcbiAgICAvLyAgICAgcmV0dXJuO1xuICAgIC8vIH1cblxuICAgIGZvcih2YXIgaSA9IGlNaW5YOyBpIDw9IGlNYXhYOyBpKyspe1xuICAgICAgICBmb3IodmFyIGogPSBpTWluWTsgaiA8PSBpTWF4WTsgaisrKXtcblxuICAgICAgICAgICAgaWYodGhpcy5yZXN1bHQuX3Nob3VsZFN0b3Ape1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTG93ZXIgdHJpYW5nbGVcbiAgICAgICAgICAgIHNoYXBlLmdldENvbnZleFRyaWFuZ2xlUGlsbGFyKGksIGosIGZhbHNlKTtcbiAgICAgICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZShwb3NpdGlvbiwgcXVhdCwgc2hhcGUucGlsbGFyT2Zmc2V0LCB3b3JsZFBpbGxhck9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLmludGVyc2VjdENvbnZleChzaGFwZS5waWxsYXJDb252ZXgsIHF1YXQsIHdvcmxkUGlsbGFyT2Zmc2V0LCBib2R5LCBpbnRlcnNlY3RDb252ZXhPcHRpb25zKTtcblxuICAgICAgICAgICAgaWYodGhpcy5yZXN1bHQuX3Nob3VsZFN0b3Ape1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXBwZXIgdHJpYW5nbGVcbiAgICAgICAgICAgIHNoYXBlLmdldENvbnZleFRyaWFuZ2xlUGlsbGFyKGksIGosIHRydWUpO1xuICAgICAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKHBvc2l0aW9uLCBxdWF0LCBzaGFwZS5waWxsYXJPZmZzZXQsIHdvcmxkUGlsbGFyT2Zmc2V0KTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0Q29udmV4KHNoYXBlLnBpbGxhckNvbnZleCwgcXVhdCwgd29ybGRQaWxsYXJPZmZzZXQsIGJvZHksIGludGVyc2VjdENvbnZleE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxufTtcblJheS5wcm90b3R5cGVbU2hhcGUudHlwZXMuSEVJR0hURklFTERdID0gUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RIZWlnaHRmaWVsZDtcblxudmFyIFJheV9pbnRlcnNlY3RTcGhlcmVfaW50ZXJzZWN0aW9uUG9pbnQgPSBuZXcgVmVjMygpO1xudmFyIFJheV9pbnRlcnNlY3RTcGhlcmVfbm9ybWFsID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBAbWV0aG9kIGludGVyc2VjdFNwaGVyZVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAge1NoYXBlfSBzaGFwZVxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcXVhdFxuICogQHBhcmFtICB7VmVjM30gcG9zaXRpb25cbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlcbiAqL1xuUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RTcGhlcmUgPSBmdW5jdGlvbihzaGFwZSwgcXVhdCwgcG9zaXRpb24sIGJvZHkpe1xuICAgIHZhciBmcm9tID0gdGhpcy5mcm9tLFxuICAgICAgICB0byA9IHRoaXMudG8sXG4gICAgICAgIHIgPSBzaGFwZS5yYWRpdXM7XG5cbiAgICB2YXIgYSA9IE1hdGgucG93KHRvLnggLSBmcm9tLngsIDIpICsgTWF0aC5wb3codG8ueSAtIGZyb20ueSwgMikgKyBNYXRoLnBvdyh0by56IC0gZnJvbS56LCAyKTtcbiAgICB2YXIgYiA9IDIgKiAoKHRvLnggLSBmcm9tLngpICogKGZyb20ueCAtIHBvc2l0aW9uLngpICsgKHRvLnkgLSBmcm9tLnkpICogKGZyb20ueSAtIHBvc2l0aW9uLnkpICsgKHRvLnogLSBmcm9tLnopICogKGZyb20ueiAtIHBvc2l0aW9uLnopKTtcbiAgICB2YXIgYyA9IE1hdGgucG93KGZyb20ueCAtIHBvc2l0aW9uLngsIDIpICsgTWF0aC5wb3coZnJvbS55IC0gcG9zaXRpb24ueSwgMikgKyBNYXRoLnBvdyhmcm9tLnogLSBwb3NpdGlvbi56LCAyKSAtIE1hdGgucG93KHIsIDIpO1xuXG4gICAgdmFyIGRlbHRhID0gTWF0aC5wb3coYiwgMikgLSA0ICogYSAqIGM7XG5cbiAgICB2YXIgaW50ZXJzZWN0aW9uUG9pbnQgPSBSYXlfaW50ZXJzZWN0U3BoZXJlX2ludGVyc2VjdGlvblBvaW50O1xuICAgIHZhciBub3JtYWwgPSBSYXlfaW50ZXJzZWN0U3BoZXJlX25vcm1hbDtcblxuICAgIGlmKGRlbHRhIDwgMCl7XG4gICAgICAgIC8vIE5vIGludGVyc2VjdGlvblxuICAgICAgICByZXR1cm47XG5cbiAgICB9IGVsc2UgaWYoZGVsdGEgPT09IDApe1xuICAgICAgICAvLyBzaW5nbGUgaW50ZXJzZWN0aW9uIHBvaW50XG4gICAgICAgIGZyb20ubGVycCh0bywgZGVsdGEsIGludGVyc2VjdGlvblBvaW50KTtcblxuICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludC52c3ViKHBvc2l0aW9uLCBub3JtYWwpO1xuICAgICAgICBub3JtYWwubm9ybWFsaXplKCk7XG5cbiAgICAgICAgdGhpcy5yZXBvcnRJbnRlcnNlY3Rpb24obm9ybWFsLCBpbnRlcnNlY3Rpb25Qb2ludCwgc2hhcGUsIGJvZHksIC0xKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkMSA9ICgtIGIgLSBNYXRoLnNxcnQoZGVsdGEpKSAvICgyICogYSk7XG4gICAgICAgIHZhciBkMiA9ICgtIGIgKyBNYXRoLnNxcnQoZGVsdGEpKSAvICgyICogYSk7XG5cbiAgICAgICAgaWYoZDEgPj0gMCAmJiBkMSA8PSAxKXtcbiAgICAgICAgICAgIGZyb20ubGVycCh0bywgZDEsIGludGVyc2VjdGlvblBvaW50KTtcbiAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50LnZzdWIocG9zaXRpb24sIG5vcm1hbCk7XG4gICAgICAgICAgICBub3JtYWwubm9ybWFsaXplKCk7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydEludGVyc2VjdGlvbihub3JtYWwsIGludGVyc2VjdGlvblBvaW50LCBzaGFwZSwgYm9keSwgLTEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5yZXN1bHQuX3Nob3VsZFN0b3Ape1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoZDIgPj0gMCAmJiBkMiA8PSAxKXtcbiAgICAgICAgICAgIGZyb20ubGVycCh0bywgZDIsIGludGVyc2VjdGlvblBvaW50KTtcbiAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50LnZzdWIocG9zaXRpb24sIG5vcm1hbCk7XG4gICAgICAgICAgICBub3JtYWwubm9ybWFsaXplKCk7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydEludGVyc2VjdGlvbihub3JtYWwsIGludGVyc2VjdGlvblBvaW50LCBzaGFwZSwgYm9keSwgLTEpO1xuICAgICAgICB9XG4gICAgfVxufTtcblJheS5wcm90b3R5cGVbU2hhcGUudHlwZXMuU1BIRVJFXSA9IFJheS5wcm90b3R5cGUuaW50ZXJzZWN0U3BoZXJlO1xuXG5cbnZhciBpbnRlcnNlY3RDb252ZXhfbm9ybWFsID0gbmV3IFZlYzMoKTtcbnZhciBpbnRlcnNlY3RDb252ZXhfbWluRGlzdE5vcm1hbCA9IG5ldyBWZWMzKCk7XG52YXIgaW50ZXJzZWN0Q29udmV4X21pbkRpc3RJbnRlcnNlY3QgPSBuZXcgVmVjMygpO1xudmFyIGludGVyc2VjdENvbnZleF92ZWN0b3IgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIEBtZXRob2QgaW50ZXJzZWN0Q29udmV4XG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7U2hhcGV9IHNoYXBlXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxdWF0XG4gKiBAcGFyYW0gIHtWZWMzfSBwb3NpdGlvblxuICogQHBhcmFtICB7Qm9keX0gYm9keVxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHthcnJheX0gW29wdGlvbnMuZmFjZUxpc3RdXG4gKi9cblJheS5wcm90b3R5cGUuaW50ZXJzZWN0Q29udmV4ID0gZnVuY3Rpb24gaW50ZXJzZWN0Q29udmV4KFxuICAgIHNoYXBlLFxuICAgIHF1YXQsXG4gICAgcG9zaXRpb24sXG4gICAgYm9keSxcbiAgICBvcHRpb25zXG4pe1xuICAgIHZhciBtaW5EaXN0Tm9ybWFsID0gaW50ZXJzZWN0Q29udmV4X21pbkRpc3ROb3JtYWw7XG4gICAgdmFyIG5vcm1hbCA9IGludGVyc2VjdENvbnZleF9ub3JtYWw7XG4gICAgdmFyIHZlY3RvciA9IGludGVyc2VjdENvbnZleF92ZWN0b3I7XG4gICAgdmFyIG1pbkRpc3RJbnRlcnNlY3QgPSBpbnRlcnNlY3RDb252ZXhfbWluRGlzdEludGVyc2VjdDtcbiAgICB2YXIgZmFjZUxpc3QgPSAob3B0aW9ucyAmJiBvcHRpb25zLmZhY2VMaXN0KSB8fCBudWxsO1xuXG4gICAgLy8gQ2hlY2tpbmcgZmFjZXNcbiAgICB2YXIgZmFjZXMgPSBzaGFwZS5mYWNlcyxcbiAgICAgICAgdmVydGljZXMgPSBzaGFwZS52ZXJ0aWNlcyxcbiAgICAgICAgbm9ybWFscyA9IHNoYXBlLmZhY2VOb3JtYWxzO1xuICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLl9kaXJlY3Rpb247XG5cbiAgICB2YXIgZnJvbSA9IHRoaXMuZnJvbTtcbiAgICB2YXIgdG8gPSB0aGlzLnRvO1xuICAgIHZhciBmcm9tVG9EaXN0YW5jZSA9IGZyb20uZGlzdGFuY2VUbyh0byk7XG5cbiAgICB2YXIgbWluRGlzdCA9IC0xO1xuICAgIHZhciBOZmFjZXMgPSBmYWNlTGlzdCA/IGZhY2VMaXN0Lmxlbmd0aCA6IGZhY2VzLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5yZXN1bHQ7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgIXJlc3VsdC5fc2hvdWxkU3RvcCAmJiBqIDwgTmZhY2VzOyBqKyspIHtcbiAgICAgICAgdmFyIGZpID0gZmFjZUxpc3QgPyBmYWNlTGlzdFtqXSA6IGo7XG5cbiAgICAgICAgdmFyIGZhY2UgPSBmYWNlc1tmaV07XG4gICAgICAgIHZhciBmYWNlTm9ybWFsID0gbm9ybWFsc1tmaV07XG4gICAgICAgIHZhciBxID0gcXVhdDtcbiAgICAgICAgdmFyIHggPSBwb3NpdGlvbjtcblxuICAgICAgICAvLyBkZXRlcm1pbmUgaWYgcmF5IGludGVyc2VjdHMgdGhlIHBsYW5lIG9mIHRoZSBmYWNlXG4gICAgICAgIC8vIG5vdGU6IHRoaXMgd29ya3MgcmVnYXJkbGVzcyBvZiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBmYWNlIG5vcm1hbFxuXG4gICAgICAgIC8vIEdldCBwbGFuZSBwb2ludCBpbiB3b3JsZCBjb29yZGluYXRlcy4uLlxuICAgICAgICB2ZWN0b3IuY29weSh2ZXJ0aWNlc1tmYWNlWzBdXSk7XG4gICAgICAgIHEudm11bHQodmVjdG9yLHZlY3Rvcik7XG4gICAgICAgIHZlY3Rvci52YWRkKHgsdmVjdG9yKTtcblxuICAgICAgICAvLyAuLi5idXQgbWFrZSBpdCByZWxhdGl2ZSB0byB0aGUgcmF5IGZyb20uIFdlJ2xsIGZpeCB0aGlzIGxhdGVyLlxuICAgICAgICB2ZWN0b3IudnN1Yihmcm9tLHZlY3Rvcik7XG5cbiAgICAgICAgLy8gR2V0IHBsYW5lIG5vcm1hbFxuICAgICAgICBxLnZtdWx0KGZhY2VOb3JtYWwsbm9ybWFsKTtcblxuICAgICAgICAvLyBJZiB0aGlzIGRvdCBwcm9kdWN0IGlzIG5lZ2F0aXZlLCB3ZSBoYXZlIHNvbWV0aGluZyBpbnRlcmVzdGluZ1xuICAgICAgICB2YXIgZG90ID0gZGlyZWN0aW9uLmRvdChub3JtYWwpO1xuXG4gICAgICAgIC8vIEJhaWwgb3V0IGlmIHJheSBhbmQgcGxhbmUgYXJlIHBhcmFsbGVsXG4gICAgICAgIGlmICggTWF0aC5hYnMoIGRvdCApIDwgdGhpcy5wcmVjaXNpb24gKXtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2FsYyBkaXN0YW5jZSB0byBwbGFuZVxuICAgICAgICB2YXIgc2NhbGFyID0gbm9ybWFsLmRvdCh2ZWN0b3IpIC8gZG90O1xuXG4gICAgICAgIC8vIGlmIG5lZ2F0aXZlIGRpc3RhbmNlLCB0aGVuIHBsYW5lIGlzIGJlaGluZCByYXlcbiAgICAgICAgaWYgKHNjYWxhciA8IDApe1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiAoZG90IDwgMCkge1xuXG4gICAgICAgIC8vIEludGVyc2VjdGlvbiBwb2ludCBpcyBmcm9tICsgZGlyZWN0aW9uICogc2NhbGFyXG4gICAgICAgIGRpcmVjdGlvbi5tdWx0KHNjYWxhcixpbnRlcnNlY3RQb2ludCk7XG4gICAgICAgIGludGVyc2VjdFBvaW50LnZhZGQoZnJvbSxpbnRlcnNlY3RQb2ludCk7XG5cbiAgICAgICAgLy8gYSBpcyB0aGUgcG9pbnQgd2UgY29tcGFyZSBwb2ludHMgYiBhbmQgYyB3aXRoLlxuICAgICAgICBhLmNvcHkodmVydGljZXNbZmFjZVswXV0pO1xuICAgICAgICBxLnZtdWx0KGEsYSk7XG4gICAgICAgIHgudmFkZChhLGEpO1xuXG4gICAgICAgIGZvcih2YXIgaSA9IDE7ICFyZXN1bHQuX3Nob3VsZFN0b3AgJiYgaSA8IGZhY2UubGVuZ3RoIC0gMTsgaSsrKXtcbiAgICAgICAgICAgIC8vIFRyYW5zZm9ybSAzIHZlcnRpY2VzIHRvIHdvcmxkIGNvb3Jkc1xuICAgICAgICAgICAgYi5jb3B5KHZlcnRpY2VzW2ZhY2VbaV1dKTtcbiAgICAgICAgICAgIGMuY29weSh2ZXJ0aWNlc1tmYWNlW2krMV1dKTtcbiAgICAgICAgICAgIHEudm11bHQoYixiKTtcbiAgICAgICAgICAgIHEudm11bHQoYyxjKTtcbiAgICAgICAgICAgIHgudmFkZChiLGIpO1xuICAgICAgICAgICAgeC52YWRkKGMsYyk7XG5cbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IGludGVyc2VjdFBvaW50LmRpc3RhbmNlVG8oZnJvbSk7XG5cbiAgICAgICAgICAgIGlmKCEocG9pbnRJblRyaWFuZ2xlKGludGVyc2VjdFBvaW50LCBhLCBiLCBjKSB8fCBwb2ludEluVHJpYW5nbGUoaW50ZXJzZWN0UG9pbnQsIGIsIGEsIGMpKSB8fCBkaXN0YW5jZSA+IGZyb21Ub0Rpc3RhbmNlKXtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5yZXBvcnRJbnRlcnNlY3Rpb24obm9ybWFsLCBpbnRlcnNlY3RQb2ludCwgc2hhcGUsIGJvZHksIGZpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB9XG4gICAgfVxufTtcblJheS5wcm90b3R5cGVbU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTl0gPSBSYXkucHJvdG90eXBlLmludGVyc2VjdENvbnZleDtcblxudmFyIGludGVyc2VjdFRyaW1lc2hfbm9ybWFsID0gbmV3IFZlYzMoKTtcbnZhciBpbnRlcnNlY3RUcmltZXNoX2xvY2FsRGlyZWN0aW9uID0gbmV3IFZlYzMoKTtcbnZhciBpbnRlcnNlY3RUcmltZXNoX2xvY2FsRnJvbSA9IG5ldyBWZWMzKCk7XG52YXIgaW50ZXJzZWN0VHJpbWVzaF9sb2NhbFRvID0gbmV3IFZlYzMoKTtcbnZhciBpbnRlcnNlY3RUcmltZXNoX3dvcmxkTm9ybWFsID0gbmV3IFZlYzMoKTtcbnZhciBpbnRlcnNlY3RUcmltZXNoX3dvcmxkSW50ZXJzZWN0UG9pbnQgPSBuZXcgVmVjMygpO1xudmFyIGludGVyc2VjdFRyaW1lc2hfbG9jYWxBQUJCID0gbmV3IEFBQkIoKTtcbnZhciBpbnRlcnNlY3RUcmltZXNoX3RyaWFuZ2xlcyA9IFtdO1xudmFyIGludGVyc2VjdFRyaW1lc2hfdHJlZVRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm0oKTtcblxuLyoqXG4gKiBAbWV0aG9kIGludGVyc2VjdFRyaW1lc2hcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHtTaGFwZX0gc2hhcGVcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHF1YXRcbiAqIEBwYXJhbSAge1ZlYzN9IHBvc2l0aW9uXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5XG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAdG9kbyBPcHRpbWl6ZSBieSB0cmFuc2Zvcm1pbmcgdGhlIHdvcmxkIHRvIGxvY2FsIHNwYWNlIGZpcnN0LlxuICogQHRvZG8gVXNlIE9jdHJlZSBsb29rdXBcbiAqL1xuUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RUcmltZXNoID0gZnVuY3Rpb24gaW50ZXJzZWN0VHJpbWVzaChcbiAgICBtZXNoLFxuICAgIHF1YXQsXG4gICAgcG9zaXRpb24sXG4gICAgYm9keSxcbiAgICBvcHRpb25zXG4pe1xuICAgIHZhciBub3JtYWwgPSBpbnRlcnNlY3RUcmltZXNoX25vcm1hbDtcbiAgICB2YXIgdHJpYW5nbGVzID0gaW50ZXJzZWN0VHJpbWVzaF90cmlhbmdsZXM7XG4gICAgdmFyIHRyZWVUcmFuc2Zvcm0gPSBpbnRlcnNlY3RUcmltZXNoX3RyZWVUcmFuc2Zvcm07XG4gICAgdmFyIG1pbkRpc3ROb3JtYWwgPSBpbnRlcnNlY3RDb252ZXhfbWluRGlzdE5vcm1hbDtcbiAgICB2YXIgdmVjdG9yID0gaW50ZXJzZWN0Q29udmV4X3ZlY3RvcjtcbiAgICB2YXIgbWluRGlzdEludGVyc2VjdCA9IGludGVyc2VjdENvbnZleF9taW5EaXN0SW50ZXJzZWN0O1xuICAgIHZhciBsb2NhbEFBQkIgPSBpbnRlcnNlY3RUcmltZXNoX2xvY2FsQUFCQjtcbiAgICB2YXIgbG9jYWxEaXJlY3Rpb24gPSBpbnRlcnNlY3RUcmltZXNoX2xvY2FsRGlyZWN0aW9uO1xuICAgIHZhciBsb2NhbEZyb20gPSBpbnRlcnNlY3RUcmltZXNoX2xvY2FsRnJvbTtcbiAgICB2YXIgbG9jYWxUbyA9IGludGVyc2VjdFRyaW1lc2hfbG9jYWxUbztcbiAgICB2YXIgd29ybGRJbnRlcnNlY3RQb2ludCA9IGludGVyc2VjdFRyaW1lc2hfd29ybGRJbnRlcnNlY3RQb2ludDtcbiAgICB2YXIgd29ybGROb3JtYWwgPSBpbnRlcnNlY3RUcmltZXNoX3dvcmxkTm9ybWFsO1xuICAgIHZhciBmYWNlTGlzdCA9IChvcHRpb25zICYmIG9wdGlvbnMuZmFjZUxpc3QpIHx8IG51bGw7XG5cbiAgICAvLyBDaGVja2luZyBmYWNlc1xuICAgIHZhciBpbmRpY2VzID0gbWVzaC5pbmRpY2VzLFxuICAgICAgICB2ZXJ0aWNlcyA9IG1lc2gudmVydGljZXMsXG4gICAgICAgIG5vcm1hbHMgPSBtZXNoLmZhY2VOb3JtYWxzO1xuXG4gICAgdmFyIGZyb20gPSB0aGlzLmZyb207XG4gICAgdmFyIHRvID0gdGhpcy50bztcbiAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5fZGlyZWN0aW9uO1xuXG4gICAgdmFyIG1pbkRpc3QgPSAtMTtcbiAgICB0cmVlVHJhbnNmb3JtLnBvc2l0aW9uLmNvcHkocG9zaXRpb24pO1xuICAgIHRyZWVUcmFuc2Zvcm0ucXVhdGVybmlvbi5jb3B5KHF1YXQpO1xuXG4gICAgLy8gVHJhbnNmb3JtIHJheSB0byBsb2NhbCBzcGFjZSFcbiAgICBUcmFuc2Zvcm0udmVjdG9yVG9Mb2NhbEZyYW1lKHBvc2l0aW9uLCBxdWF0LCBkaXJlY3Rpb24sIGxvY2FsRGlyZWN0aW9uKTtcbiAgICAvL2JvZHkudmVjdG9yVG9Mb2NhbEZyYW1lKGRpcmVjdGlvbiwgbG9jYWxEaXJlY3Rpb24pO1xuICAgIFRyYW5zZm9ybS5wb2ludFRvTG9jYWxGcmFtZShwb3NpdGlvbiwgcXVhdCwgZnJvbSwgbG9jYWxGcm9tKTtcbiAgICAvL2JvZHkucG9pbnRUb0xvY2FsRnJhbWUoZnJvbSwgbG9jYWxGcm9tKTtcbiAgICBUcmFuc2Zvcm0ucG9pbnRUb0xvY2FsRnJhbWUocG9zaXRpb24sIHF1YXQsIHRvLCBsb2NhbFRvKTtcbiAgICAvL2JvZHkucG9pbnRUb0xvY2FsRnJhbWUodG8sIGxvY2FsVG8pO1xuICAgIHZhciBmcm9tVG9EaXN0YW5jZVNxdWFyZWQgPSBsb2NhbEZyb20uZGlzdGFuY2VTcXVhcmVkKGxvY2FsVG8pO1xuXG4gICAgbWVzaC50cmVlLnJheVF1ZXJ5KHRoaXMsIHRyZWVUcmFuc2Zvcm0sIHRyaWFuZ2xlcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgTiA9IHRyaWFuZ2xlcy5sZW5ndGg7ICF0aGlzLnJlc3VsdC5fc2hvdWxkU3RvcCAmJiBpICE9PSBOOyBpKyspIHtcbiAgICAgICAgdmFyIHRyaWFuZ2xlc0luZGV4ID0gdHJpYW5nbGVzW2ldO1xuXG4gICAgICAgIG1lc2guZ2V0Tm9ybWFsKHRyaWFuZ2xlc0luZGV4LCBub3JtYWwpO1xuXG4gICAgICAgIC8vIGRldGVybWluZSBpZiByYXkgaW50ZXJzZWN0cyB0aGUgcGxhbmUgb2YgdGhlIGZhY2VcbiAgICAgICAgLy8gbm90ZTogdGhpcyB3b3JrcyByZWdhcmRsZXNzIG9mIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGZhY2Ugbm9ybWFsXG5cbiAgICAgICAgLy8gR2V0IHBsYW5lIHBvaW50IGluIHdvcmxkIGNvb3JkaW5hdGVzLi4uXG4gICAgICAgIG1lc2guZ2V0VmVydGV4KGluZGljZXNbdHJpYW5nbGVzSW5kZXggKiAzXSwgYSk7XG5cbiAgICAgICAgLy8gLi4uYnV0IG1ha2UgaXQgcmVsYXRpdmUgdG8gdGhlIHJheSBmcm9tLiBXZSdsbCBmaXggdGhpcyBsYXRlci5cbiAgICAgICAgYS52c3ViKGxvY2FsRnJvbSx2ZWN0b3IpO1xuXG4gICAgICAgIC8vIEdldCBwbGFuZSBub3JtYWxcbiAgICAgICAgLy8gcXVhdC52bXVsdChub3JtYWwsIG5vcm1hbCk7XG5cbiAgICAgICAgLy8gSWYgdGhpcyBkb3QgcHJvZHVjdCBpcyBuZWdhdGl2ZSwgd2UgaGF2ZSBzb21ldGhpbmcgaW50ZXJlc3RpbmdcbiAgICAgICAgdmFyIGRvdCA9IGxvY2FsRGlyZWN0aW9uLmRvdChub3JtYWwpO1xuXG4gICAgICAgIC8vIEJhaWwgb3V0IGlmIHJheSBhbmQgcGxhbmUgYXJlIHBhcmFsbGVsXG4gICAgICAgIC8vIGlmIChNYXRoLmFicyggZG90ICkgPCB0aGlzLnByZWNpc2lvbil7XG4gICAgICAgIC8vICAgICBjb250aW51ZTtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIGNhbGMgZGlzdGFuY2UgdG8gcGxhbmVcbiAgICAgICAgdmFyIHNjYWxhciA9IG5vcm1hbC5kb3QodmVjdG9yKSAvIGRvdDtcblxuICAgICAgICAvLyBpZiBuZWdhdGl2ZSBkaXN0YW5jZSwgdGhlbiBwbGFuZSBpcyBiZWhpbmQgcmF5XG4gICAgICAgIGlmIChzY2FsYXIgPCAwKXtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW50ZXJzZWN0aW9uIHBvaW50IGlzIGZyb20gKyBkaXJlY3Rpb24gKiBzY2FsYXJcbiAgICAgICAgbG9jYWxEaXJlY3Rpb24uc2NhbGUoc2NhbGFyLGludGVyc2VjdFBvaW50KTtcbiAgICAgICAgaW50ZXJzZWN0UG9pbnQudmFkZChsb2NhbEZyb20saW50ZXJzZWN0UG9pbnQpO1xuXG4gICAgICAgIC8vIEdldCB0cmlhbmdsZSB2ZXJ0aWNlc1xuICAgICAgICBtZXNoLmdldFZlcnRleChpbmRpY2VzW3RyaWFuZ2xlc0luZGV4ICogMyArIDFdLCBiKTtcbiAgICAgICAgbWVzaC5nZXRWZXJ0ZXgoaW5kaWNlc1t0cmlhbmdsZXNJbmRleCAqIDMgKyAyXSwgYyk7XG5cbiAgICAgICAgdmFyIHNxdWFyZWREaXN0YW5jZSA9IGludGVyc2VjdFBvaW50LmRpc3RhbmNlU3F1YXJlZChsb2NhbEZyb20pO1xuXG4gICAgICAgIGlmKCEocG9pbnRJblRyaWFuZ2xlKGludGVyc2VjdFBvaW50LCBiLCBhLCBjKSB8fCBwb2ludEluVHJpYW5nbGUoaW50ZXJzZWN0UG9pbnQsIGEsIGIsIGMpKSB8fCBzcXVhcmVkRGlzdGFuY2UgPiBmcm9tVG9EaXN0YW5jZVNxdWFyZWQpe1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cmFuc2Zvcm0gaW50ZXJzZWN0cG9pbnQgYW5kIG5vcm1hbCB0byB3b3JsZFxuICAgICAgICBUcmFuc2Zvcm0udmVjdG9yVG9Xb3JsZEZyYW1lKHF1YXQsIG5vcm1hbCwgd29ybGROb3JtYWwpO1xuICAgICAgICAvL2JvZHkudmVjdG9yVG9Xb3JsZEZyYW1lKG5vcm1hbCwgd29ybGROb3JtYWwpO1xuICAgICAgICBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUocG9zaXRpb24sIHF1YXQsIGludGVyc2VjdFBvaW50LCB3b3JsZEludGVyc2VjdFBvaW50KTtcbiAgICAgICAgLy9ib2R5LnBvaW50VG9Xb3JsZEZyYW1lKGludGVyc2VjdFBvaW50LCB3b3JsZEludGVyc2VjdFBvaW50KTtcbiAgICAgICAgdGhpcy5yZXBvcnRJbnRlcnNlY3Rpb24od29ybGROb3JtYWwsIHdvcmxkSW50ZXJzZWN0UG9pbnQsIG1lc2gsIGJvZHksIHRyaWFuZ2xlc0luZGV4KTtcbiAgICB9XG4gICAgdHJpYW5nbGVzLmxlbmd0aCA9IDA7XG59O1xuUmF5LnByb3RvdHlwZVtTaGFwZS50eXBlcy5UUklNRVNIXSA9IFJheS5wcm90b3R5cGUuaW50ZXJzZWN0VHJpbWVzaDtcblxuXG4vKipcbiAqIEBtZXRob2QgcmVwb3J0SW50ZXJzZWN0aW9uXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7VmVjM30gbm9ybWFsXG4gKiBAcGFyYW0gIHtWZWMzfSBoaXRQb2ludFdvcmxkXG4gKiBAcGFyYW0gIHtTaGFwZX0gc2hhcGVcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGludGVyc2VjdGlvbnMgc2hvdWxkIGNvbnRpbnVlXG4gKi9cblJheS5wcm90b3R5cGUucmVwb3J0SW50ZXJzZWN0aW9uID0gZnVuY3Rpb24obm9ybWFsLCBoaXRQb2ludFdvcmxkLCBzaGFwZSwgYm9keSwgaGl0RmFjZUluZGV4KXtcbiAgICB2YXIgZnJvbSA9IHRoaXMuZnJvbTtcbiAgICB2YXIgdG8gPSB0aGlzLnRvO1xuICAgIHZhciBkaXN0YW5jZSA9IGZyb20uZGlzdGFuY2VUbyhoaXRQb2ludFdvcmxkKTtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5yZXN1bHQ7XG5cbiAgICAvLyBTa2lwIGJhY2sgZmFjZXM/XG4gICAgaWYodGhpcy5za2lwQmFja2ZhY2VzICYmIG5vcm1hbC5kb3QodGhpcy5fZGlyZWN0aW9uKSA+IDApe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmVzdWx0LmhpdEZhY2VJbmRleCA9IHR5cGVvZihoaXRGYWNlSW5kZXgpICE9PSAndW5kZWZpbmVkJyA/IGhpdEZhY2VJbmRleCA6IC0xO1xuXG4gICAgc3dpdGNoKHRoaXMubW9kZSl7XG4gICAgY2FzZSBSYXkuQUxMOlxuICAgICAgICB0aGlzLmhhc0hpdCA9IHRydWU7XG4gICAgICAgIHJlc3VsdC5zZXQoXG4gICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICBub3JtYWwsXG4gICAgICAgICAgICBoaXRQb2ludFdvcmxkLFxuICAgICAgICAgICAgc2hhcGUsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgZGlzdGFuY2VcbiAgICAgICAgKTtcbiAgICAgICAgcmVzdWx0Lmhhc0hpdCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFJheS5DTE9TRVNUOlxuXG4gICAgICAgIC8vIFN0b3JlIGlmIGNsb3NlciB0aGFuIGN1cnJlbnQgY2xvc2VzdFxuICAgICAgICBpZihkaXN0YW5jZSA8IHJlc3VsdC5kaXN0YW5jZSB8fCAhcmVzdWx0Lmhhc0hpdCl7XG4gICAgICAgICAgICB0aGlzLmhhc0hpdCA9IHRydWU7XG4gICAgICAgICAgICByZXN1bHQuaGFzSGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc3VsdC5zZXQoXG4gICAgICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgICAgICBub3JtYWwsXG4gICAgICAgICAgICAgICAgaGl0UG9pbnRXb3JsZCxcbiAgICAgICAgICAgICAgICBzaGFwZSxcbiAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgICAgIGRpc3RhbmNlXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBSYXkuQU5ZOlxuXG4gICAgICAgIC8vIFJlcG9ydCBhbmQgc3RvcC5cbiAgICAgICAgdGhpcy5oYXNIaXQgPSB0cnVlO1xuICAgICAgICByZXN1bHQuaGFzSGl0ID0gdHJ1ZTtcbiAgICAgICAgcmVzdWx0LnNldChcbiAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICB0byxcbiAgICAgICAgICAgIG5vcm1hbCxcbiAgICAgICAgICAgIGhpdFBvaW50V29ybGQsXG4gICAgICAgICAgICBzaGFwZSxcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICBkaXN0YW5jZVxuICAgICAgICApO1xuICAgICAgICByZXN1bHQuX3Nob3VsZFN0b3AgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG59O1xuXG52YXIgdjAgPSBuZXcgVmVjMygpLFxuICAgIGludGVyc2VjdCA9IG5ldyBWZWMzKCk7XG5mdW5jdGlvbiBkaXN0YW5jZUZyb21JbnRlcnNlY3Rpb24oZnJvbSwgZGlyZWN0aW9uLCBwb3NpdGlvbikge1xuXG4gICAgLy8gdjAgaXMgdmVjdG9yIGZyb20gZnJvbSB0byBwb3NpdGlvblxuICAgIHBvc2l0aW9uLnZzdWIoZnJvbSx2MCk7XG4gICAgdmFyIGRvdCA9IHYwLmRvdChkaXJlY3Rpb24pO1xuXG4gICAgLy8gaW50ZXJzZWN0ID0gZGlyZWN0aW9uKmRvdCArIGZyb21cbiAgICBkaXJlY3Rpb24ubXVsdChkb3QsaW50ZXJzZWN0KTtcbiAgICBpbnRlcnNlY3QudmFkZChmcm9tLGludGVyc2VjdCk7XG5cbiAgICB2YXIgZGlzdGFuY2UgPSBwb3NpdGlvbi5kaXN0YW5jZVRvKGludGVyc2VjdCk7XG5cbiAgICByZXR1cm4gZGlzdGFuY2U7XG59XG5cblxufSx7XCIuLi9jb2xsaXNpb24vQUFCQlwiOjMsXCIuLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdFwiOjEwLFwiLi4vbWF0aC9RdWF0ZXJuaW9uXCI6MjgsXCIuLi9tYXRoL1RyYW5zZm9ybVwiOjI5LFwiLi4vbWF0aC9WZWMzXCI6MzAsXCIuLi9zaGFwZXMvQm94XCI6MzcsXCIuLi9zaGFwZXMvQ29udmV4UG9seWhlZHJvblwiOjM4LFwiLi4vc2hhcGVzL1NoYXBlXCI6NDN9XSwxMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJheWNhc3RSZXN1bHQ7XG5cbi8qKlxuICogU3RvcmFnZSBmb3IgUmF5IGNhc3RpbmcgZGF0YS5cbiAqIEBjbGFzcyBSYXljYXN0UmVzdWx0XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gUmF5Y2FzdFJlc3VsdCgpe1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkge1ZlYzN9IHJheUZyb21Xb3JsZFxuXHQgKi9cblx0dGhpcy5yYXlGcm9tV29ybGQgPSBuZXcgVmVjMygpO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkge1ZlYzN9IHJheVRvV29ybGRcblx0ICovXG5cdHRoaXMucmF5VG9Xb3JsZCA9IG5ldyBWZWMzKCk7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB7VmVjM30gaGl0Tm9ybWFsV29ybGRcblx0ICovXG5cdHRoaXMuaGl0Tm9ybWFsV29ybGQgPSBuZXcgVmVjMygpO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkge1ZlYzN9IGhpdFBvaW50V29ybGRcblx0ICovXG5cdHRoaXMuaGl0UG9pbnRXb3JsZCA9IG5ldyBWZWMzKCk7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaGFzSGl0XG5cdCAqL1xuXHR0aGlzLmhhc0hpdCA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBUaGUgaGl0IHNoYXBlLCBvciBudWxsLlxuXHQgKiBAcHJvcGVydHkge1NoYXBlfSBzaGFwZVxuXHQgKi9cblx0dGhpcy5zaGFwZSA9IG51bGw7XG5cblx0LyoqXG5cdCAqIFRoZSBoaXQgYm9keSwgb3IgbnVsbC5cblx0ICogQHByb3BlcnR5IHtCb2R5fSBib2R5XG5cdCAqL1xuXHR0aGlzLmJvZHkgPSBudWxsO1xuXG5cdC8qKlxuXHQgKiBUaGUgaW5kZXggb2YgdGhlIGhpdCB0cmlhbmdsZSwgaWYgdGhlIGhpdCBzaGFwZSB3YXMgYSB0cmltZXNoLlxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gaGl0RmFjZUluZGV4XG5cdCAqIEBkZWZhdWx0IC0xXG5cdCAqL1xuXHR0aGlzLmhpdEZhY2VJbmRleCA9IC0xO1xuXG5cdC8qKlxuXHQgKiBEaXN0YW5jZSB0byB0aGUgaGl0LiBXaWxsIGJlIHNldCB0byAtMSBpZiB0aGVyZSB3YXMgbm8gaGl0LlxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gZGlzdGFuY2Vcblx0ICogQGRlZmF1bHQgLTFcblx0ICovXG5cdHRoaXMuZGlzdGFuY2UgPSAtMTtcblxuXHQvKipcblx0ICogSWYgdGhlIHJheSBzaG91bGQgc3RvcCB0cmF2ZXJzaW5nIHRoZSBib2RpZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gX3Nob3VsZFN0b3Bcblx0ICogQGRlZmF1bHQgZmFsc2Vcblx0ICovXG5cdHRoaXMuX3Nob3VsZFN0b3AgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXNldCBhbGwgcmVzdWx0IGRhdGEuXG4gKiBAbWV0aG9kIHJlc2V0XG4gKi9cblJheWNhc3RSZXN1bHQucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuXHR0aGlzLnJheUZyb21Xb3JsZC5zZXRaZXJvKCk7XG5cdHRoaXMucmF5VG9Xb3JsZC5zZXRaZXJvKCk7XG5cdHRoaXMuaGl0Tm9ybWFsV29ybGQuc2V0WmVybygpO1xuXHR0aGlzLmhpdFBvaW50V29ybGQuc2V0WmVybygpO1xuXHR0aGlzLmhhc0hpdCA9IGZhbHNlO1xuXHR0aGlzLnNoYXBlID0gbnVsbDtcblx0dGhpcy5ib2R5ID0gbnVsbDtcblx0dGhpcy5oaXRGYWNlSW5kZXggPSAtMTtcblx0dGhpcy5kaXN0YW5jZSA9IC0xO1xuXHR0aGlzLl9zaG91bGRTdG9wID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgYWJvcnRcbiAqL1xuUmF5Y2FzdFJlc3VsdC5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpe1xuXHR0aGlzLl9zaG91bGRTdG9wID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBzZXRcbiAqIEBwYXJhbSB7VmVjM30gcmF5RnJvbVdvcmxkXG4gKiBAcGFyYW0ge1ZlYzN9IHJheVRvV29ybGRcbiAqIEBwYXJhbSB7VmVjM30gaGl0Tm9ybWFsV29ybGRcbiAqIEBwYXJhbSB7VmVjM30gaGl0UG9pbnRXb3JsZFxuICogQHBhcmFtIHtTaGFwZX0gc2hhcGVcbiAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlXG4gKi9cblJheWNhc3RSZXN1bHQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKFxuXHRyYXlGcm9tV29ybGQsXG5cdHJheVRvV29ybGQsXG5cdGhpdE5vcm1hbFdvcmxkLFxuXHRoaXRQb2ludFdvcmxkLFxuXHRzaGFwZSxcblx0Ym9keSxcblx0ZGlzdGFuY2Vcbil7XG5cdHRoaXMucmF5RnJvbVdvcmxkLmNvcHkocmF5RnJvbVdvcmxkKTtcblx0dGhpcy5yYXlUb1dvcmxkLmNvcHkocmF5VG9Xb3JsZCk7XG5cdHRoaXMuaGl0Tm9ybWFsV29ybGQuY29weShoaXROb3JtYWxXb3JsZCk7XG5cdHRoaXMuaGl0UG9pbnRXb3JsZC5jb3B5KGhpdFBvaW50V29ybGQpO1xuXHR0aGlzLnNoYXBlID0gc2hhcGU7XG5cdHRoaXMuYm9keSA9IGJvZHk7XG5cdHRoaXMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcbn07XG59LHtcIi4uL21hdGgvVmVjM1wiOjMwfV0sMTE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIFNoYXBlID0gX2RlcmVxXygnLi4vc2hhcGVzL1NoYXBlJyk7XG52YXIgQnJvYWRwaGFzZSA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9Ccm9hZHBoYXNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU0FQQnJvYWRwaGFzZTtcblxuLyoqXG4gKiBTd2VlcCBhbmQgcHJ1bmUgYnJvYWRwaGFzZSBhbG9uZyBvbmUgYXhpcy5cbiAqXG4gKiBAY2xhc3MgU0FQQnJvYWRwaGFzZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1dvcmxkfSBbd29ybGRdXG4gKiBAZXh0ZW5kcyBCcm9hZHBoYXNlXG4gKi9cbmZ1bmN0aW9uIFNBUEJyb2FkcGhhc2Uod29ybGQpe1xuICAgIEJyb2FkcGhhc2UuYXBwbHkodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIGJvZGllcyBjdXJyZW50bHkgaW4gdGhlIGJyb2FkcGhhc2UuXG4gICAgICogQHByb3BlcnR5IGF4aXNMaXN0XG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuYXhpc0xpc3QgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB3b3JsZCB0byBzZWFyY2ggaW4uXG4gICAgICogQHByb3BlcnR5IHdvcmxkXG4gICAgICogQHR5cGUge1dvcmxkfVxuICAgICAqL1xuICAgIHRoaXMud29ybGQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQXhpcyB0byBzb3J0IHRoZSBib2RpZXMgYWxvbmcuIFNldCB0byAwIGZvciB4IGF4aXMsIGFuZCAxIGZvciB5IGF4aXMuIEZvciBiZXN0IHBlcmZvcm1hbmNlLCBjaG9vc2UgYW4gYXhpcyB0aGF0IHRoZSBib2RpZXMgYXJlIHNwcmVhZCBvdXQgbW9yZSBvbi5cbiAgICAgKiBAcHJvcGVydHkgYXhpc0luZGV4XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmF4aXNJbmRleCA9IDA7XG5cbiAgICB2YXIgYXhpc0xpc3QgPSB0aGlzLmF4aXNMaXN0O1xuXG4gICAgdGhpcy5fYWRkQm9keUhhbmRsZXIgPSBmdW5jdGlvbihlKXtcbiAgICAgICAgYXhpc0xpc3QucHVzaChlLmJvZHkpO1xuICAgIH07XG5cbiAgICB0aGlzLl9yZW1vdmVCb2R5SGFuZGxlciA9IGZ1bmN0aW9uKGUpe1xuICAgICAgICB2YXIgaWR4ID0gYXhpc0xpc3QuaW5kZXhPZihlLmJvZHkpO1xuICAgICAgICBpZihpZHggIT09IC0xKXtcbiAgICAgICAgICAgIGF4aXNMaXN0LnNwbGljZShpZHgsMSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYod29ybGQpe1xuICAgICAgICB0aGlzLnNldFdvcmxkKHdvcmxkKTtcbiAgICB9XG59XG5TQVBCcm9hZHBoYXNlLnByb3RvdHlwZSA9IG5ldyBCcm9hZHBoYXNlKCk7XG5cbi8qKlxuICogQ2hhbmdlIHRoZSB3b3JsZFxuICogQG1ldGhvZCBzZXRXb3JsZFxuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXG4gKi9cblNBUEJyb2FkcGhhc2UucHJvdG90eXBlLnNldFdvcmxkID0gZnVuY3Rpb24od29ybGQpe1xuICAgIC8vIENsZWFyIHRoZSBvbGQgYXhpcyBhcnJheVxuICAgIHRoaXMuYXhpc0xpc3QubGVuZ3RoID0gMDtcblxuICAgIC8vIEFkZCBhbGwgYm9kaWVzIGZyb20gdGhlIG5ldyB3b3JsZFxuICAgIGZvcih2YXIgaT0wOyBpPHdvcmxkLmJvZGllcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHRoaXMuYXhpc0xpc3QucHVzaCh3b3JsZC5ib2RpZXNbaV0pO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBvbGQgaGFuZGxlcnMsIGlmIGFueVxuICAgIHdvcmxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhZGRCb2R5XCIsIHRoaXMuX2FkZEJvZHlIYW5kbGVyKTtcbiAgICB3b3JsZC5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVtb3ZlQm9keVwiLCB0aGlzLl9yZW1vdmVCb2R5SGFuZGxlcik7XG5cbiAgICAvLyBBZGQgaGFuZGxlcnMgdG8gdXBkYXRlIHRoZSBsaXN0IG9mIGJvZGllcy5cbiAgICB3b3JsZC5hZGRFdmVudExpc3RlbmVyKFwiYWRkQm9keVwiLCB0aGlzLl9hZGRCb2R5SGFuZGxlcik7XG4gICAgd29ybGQuYWRkRXZlbnRMaXN0ZW5lcihcInJlbW92ZUJvZHlcIiwgdGhpcy5fcmVtb3ZlQm9keUhhbmRsZXIpO1xuXG4gICAgdGhpcy53b3JsZCA9IHdvcmxkO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGluc2VydGlvblNvcnRYXG4gKiBAcGFyYW0gIHtBcnJheX0gYVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblNBUEJyb2FkcGhhc2UuaW5zZXJ0aW9uU29ydFggPSBmdW5jdGlvbihhKSB7XG4gICAgZm9yKHZhciBpPTEsbD1hLmxlbmd0aDtpPGw7aSsrKSB7XG4gICAgICAgIHZhciB2ID0gYVtpXTtcbiAgICAgICAgZm9yKHZhciBqPWkgLSAxO2o+PTA7ai0tKSB7XG4gICAgICAgICAgICBpZihhW2pdLmFhYmIubG93ZXJCb3VuZC54IDw9IHYuYWFiYi5sb3dlckJvdW5kLngpe1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYVtqKzFdID0gYVtqXTtcbiAgICAgICAgfVxuICAgICAgICBhW2orMV0gPSB2O1xuICAgIH1cbiAgICByZXR1cm4gYTtcbn07XG5cbi8qKlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBpbnNlcnRpb25Tb3J0WVxuICogQHBhcmFtICB7QXJyYXl9IGFcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5TQVBCcm9hZHBoYXNlLmluc2VydGlvblNvcnRZID0gZnVuY3Rpb24oYSkge1xuICAgIGZvcih2YXIgaT0xLGw9YS5sZW5ndGg7aTxsO2krKykge1xuICAgICAgICB2YXIgdiA9IGFbaV07XG4gICAgICAgIGZvcih2YXIgaj1pIC0gMTtqPj0wO2otLSkge1xuICAgICAgICAgICAgaWYoYVtqXS5hYWJiLmxvd2VyQm91bmQueSA8PSB2LmFhYmIubG93ZXJCb3VuZC55KXtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFbaisxXSA9IGFbal07XG4gICAgICAgIH1cbiAgICAgICAgYVtqKzFdID0gdjtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG59O1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgaW5zZXJ0aW9uU29ydFpcbiAqIEBwYXJhbSAge0FycmF5fSBhXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuU0FQQnJvYWRwaGFzZS5pbnNlcnRpb25Tb3J0WiA9IGZ1bmN0aW9uKGEpIHtcbiAgICBmb3IodmFyIGk9MSxsPWEubGVuZ3RoO2k8bDtpKyspIHtcbiAgICAgICAgdmFyIHYgPSBhW2ldO1xuICAgICAgICBmb3IodmFyIGo9aSAtIDE7aj49MDtqLS0pIHtcbiAgICAgICAgICAgIGlmKGFbal0uYWFiYi5sb3dlckJvdW5kLnogPD0gdi5hYWJiLmxvd2VyQm91bmQueil7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhW2orMV0gPSBhW2pdO1xuICAgICAgICB9XG4gICAgICAgIGFbaisxXSA9IHY7XG4gICAgfVxuICAgIHJldHVybiBhO1xufTtcblxuLyoqXG4gKiBDb2xsZWN0IGFsbCBjb2xsaXNpb24gcGFpcnNcbiAqIEBtZXRob2QgY29sbGlzaW9uUGFpcnNcbiAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxuICogQHBhcmFtICB7QXJyYXl9IHAxXG4gKiBAcGFyYW0gIHtBcnJheX0gcDJcbiAqL1xuU0FQQnJvYWRwaGFzZS5wcm90b3R5cGUuY29sbGlzaW9uUGFpcnMgPSBmdW5jdGlvbih3b3JsZCxwMSxwMil7XG4gICAgdmFyIGJvZGllcyA9IHRoaXMuYXhpc0xpc3QsXG4gICAgICAgIE4gPSBib2RpZXMubGVuZ3RoLFxuICAgICAgICBheGlzSW5kZXggPSB0aGlzLmF4aXNJbmRleCxcbiAgICAgICAgaSwgajtcblxuICAgIGlmKHRoaXMuZGlydHkpe1xuICAgICAgICB0aGlzLnNvcnRMaXN0KCk7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBMb29rIHRocm91Z2ggdGhlIGxpc3RcbiAgICBmb3IoaT0wOyBpICE9PSBOOyBpKyspe1xuICAgICAgICB2YXIgYmkgPSBib2RpZXNbaV07XG5cbiAgICAgICAgZm9yKGo9aSsxOyBqIDwgTjsgaisrKXtcbiAgICAgICAgICAgIHZhciBiaiA9IGJvZGllc1tqXTtcblxuICAgICAgICAgICAgaWYoIXRoaXMubmVlZEJyb2FkcGhhc2VDb2xsaXNpb24oYmksYmopKXtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIVNBUEJyb2FkcGhhc2UuY2hlY2tCb3VuZHMoYmksYmosYXhpc0luZGV4KSl7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uVGVzdChiaSxiaixwMSxwMik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5TQVBCcm9hZHBoYXNlLnByb3RvdHlwZS5zb3J0TGlzdCA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGF4aXNMaXN0ID0gdGhpcy5heGlzTGlzdDtcbiAgICB2YXIgYXhpc0luZGV4ID0gdGhpcy5heGlzSW5kZXg7XG4gICAgdmFyIE4gPSBheGlzTGlzdC5sZW5ndGg7XG5cbiAgICAvLyBVcGRhdGUgQUFCQnNcbiAgICBmb3IodmFyIGkgPSAwOyBpIT09TjsgaSsrKXtcbiAgICAgICAgdmFyIGJpID0gYXhpc0xpc3RbaV07XG4gICAgICAgIGlmKGJpLmFhYmJOZWVkc1VwZGF0ZSl7XG4gICAgICAgICAgICBiaS5jb21wdXRlQUFCQigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU29ydCB0aGUgbGlzdFxuICAgIGlmKGF4aXNJbmRleCA9PT0gMCl7XG4gICAgICAgIFNBUEJyb2FkcGhhc2UuaW5zZXJ0aW9uU29ydFgoYXhpc0xpc3QpO1xuICAgIH0gZWxzZSBpZihheGlzSW5kZXggPT09IDEpe1xuICAgICAgICBTQVBCcm9hZHBoYXNlLmluc2VydGlvblNvcnRZKGF4aXNMaXN0KTtcbiAgICB9IGVsc2UgaWYoYXhpc0luZGV4ID09PSAyKXtcbiAgICAgICAgU0FQQnJvYWRwaGFzZS5pbnNlcnRpb25Tb3J0WihheGlzTGlzdCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgYm91bmRzIG9mIHR3byBib2RpZXMgb3ZlcmxhcCwgYWxvbmcgdGhlIGdpdmVuIFNBUCBheGlzLlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBjaGVja0JvdW5kc1xuICogQHBhcmFtICB7Qm9keX0gYmlcbiAqIEBwYXJhbSAge0JvZHl9IGJqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGF4aXNJbmRleFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuU0FQQnJvYWRwaGFzZS5jaGVja0JvdW5kcyA9IGZ1bmN0aW9uKGJpLCBiaiwgYXhpc0luZGV4KXtcbiAgICB2YXIgYmlQb3M7XG4gICAgdmFyIGJqUG9zO1xuXG4gICAgaWYoYXhpc0luZGV4ID09PSAwKXtcbiAgICAgICAgYmlQb3MgPSBiaS5wb3NpdGlvbi54O1xuICAgICAgICBialBvcyA9IGJqLnBvc2l0aW9uLng7XG4gICAgfSBlbHNlIGlmKGF4aXNJbmRleCA9PT0gMSl7XG4gICAgICAgIGJpUG9zID0gYmkucG9zaXRpb24ueTtcbiAgICAgICAgYmpQb3MgPSBiai5wb3NpdGlvbi55O1xuICAgIH0gZWxzZSBpZihheGlzSW5kZXggPT09IDIpe1xuICAgICAgICBiaVBvcyA9IGJpLnBvc2l0aW9uLno7XG4gICAgICAgIGJqUG9zID0gYmoucG9zaXRpb24uejtcbiAgICB9XG5cbiAgICB2YXIgcmkgPSBiaS5ib3VuZGluZ1JhZGl1cyxcbiAgICAgICAgcmogPSBiai5ib3VuZGluZ1JhZGl1cyxcbiAgICAgICAgYm91bmRBMSA9IGJpUG9zIC0gcmksXG4gICAgICAgIGJvdW5kQTIgPSBiaVBvcyArIHJpLFxuICAgICAgICBib3VuZEIxID0gYmpQb3MgLSByaixcbiAgICAgICAgYm91bmRCMiA9IGJqUG9zICsgcmo7XG5cbiAgICByZXR1cm4gYm91bmRCMSA8IGJvdW5kQTI7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSB2YXJpYW5jZSBvZiB0aGUgYm9keSBwb3NpdGlvbnMgYW5kIGVzdGltYXRlcyB0aGUgYmVzdFxuICogYXhpcyB0byB1c2UuIFdpbGwgYXV0b21hdGljYWxseSBzZXQgcHJvcGVydHkgLmF4aXNJbmRleC5cbiAqIEBtZXRob2QgYXV0b0RldGVjdEF4aXNcbiAqL1xuU0FQQnJvYWRwaGFzZS5wcm90b3R5cGUuYXV0b0RldGVjdEF4aXMgPSBmdW5jdGlvbigpe1xuICAgIHZhciBzdW1YPTAsXG4gICAgICAgIHN1bVgyPTAsXG4gICAgICAgIHN1bVk9MCxcbiAgICAgICAgc3VtWTI9MCxcbiAgICAgICAgc3VtWj0wLFxuICAgICAgICBzdW1aMj0wLFxuICAgICAgICBib2RpZXMgPSB0aGlzLmF4aXNMaXN0LFxuICAgICAgICBOID0gYm9kaWVzLmxlbmd0aCxcbiAgICAgICAgaW52Tj0xL047XG5cbiAgICBmb3IodmFyIGk9MDsgaSE9PU47IGkrKyl7XG4gICAgICAgIHZhciBiID0gYm9kaWVzW2ldO1xuXG4gICAgICAgIHZhciBjZW50ZXJYID0gYi5wb3NpdGlvbi54O1xuICAgICAgICBzdW1YICs9IGNlbnRlclg7XG4gICAgICAgIHN1bVgyICs9IGNlbnRlclgqY2VudGVyWDtcblxuICAgICAgICB2YXIgY2VudGVyWSA9IGIucG9zaXRpb24ueTtcbiAgICAgICAgc3VtWSArPSBjZW50ZXJZO1xuICAgICAgICBzdW1ZMiArPSBjZW50ZXJZKmNlbnRlclk7XG5cbiAgICAgICAgdmFyIGNlbnRlclogPSBiLnBvc2l0aW9uLno7XG4gICAgICAgIHN1bVogKz0gY2VudGVyWjtcbiAgICAgICAgc3VtWjIgKz0gY2VudGVyWipjZW50ZXJaO1xuICAgIH1cblxuICAgIHZhciB2YXJpYW5jZVggPSBzdW1YMiAtIHN1bVgqc3VtWCppbnZOLFxuICAgICAgICB2YXJpYW5jZVkgPSBzdW1ZMiAtIHN1bVkqc3VtWSppbnZOLFxuICAgICAgICB2YXJpYW5jZVogPSBzdW1aMiAtIHN1bVoqc3VtWippbnZOO1xuXG4gICAgaWYodmFyaWFuY2VYID4gdmFyaWFuY2VZKXtcbiAgICAgICAgaWYodmFyaWFuY2VYID4gdmFyaWFuY2VaKXtcbiAgICAgICAgICAgIHRoaXMuYXhpc0luZGV4ID0gMDtcbiAgICAgICAgfSBlbHNle1xuICAgICAgICAgICAgdGhpcy5heGlzSW5kZXggPSAyO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmKHZhcmlhbmNlWSA+IHZhcmlhbmNlWil7XG4gICAgICAgIHRoaXMuYXhpc0luZGV4ID0gMTtcbiAgICB9IGVsc2V7XG4gICAgICAgIHRoaXMuYXhpc0luZGV4ID0gMjtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgYWxsIHRoZSBib2RpZXMgd2l0aGluIGFuIEFBQkIuXG4gKiBAbWV0aG9kIGFhYmJRdWVyeVxuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXG4gKiBAcGFyYW0gIHtBQUJCfSBhYWJiXG4gKiBAcGFyYW0ge2FycmF5fSByZXN1bHQgQW4gYXJyYXkgdG8gc3RvcmUgcmVzdWx0aW5nIGJvZGllcyBpbi5cbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5TQVBCcm9hZHBoYXNlLnByb3RvdHlwZS5hYWJiUXVlcnkgPSBmdW5jdGlvbih3b3JsZCwgYWFiYiwgcmVzdWx0KXtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgW107XG5cbiAgICBpZih0aGlzLmRpcnR5KXtcbiAgICAgICAgdGhpcy5zb3J0TGlzdCgpO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGF4aXNJbmRleCA9IHRoaXMuYXhpc0luZGV4LCBheGlzID0gJ3gnO1xuICAgIGlmKGF4aXNJbmRleCA9PT0gMSl7IGF4aXMgPSAneSc7IH1cbiAgICBpZihheGlzSW5kZXggPT09IDIpeyBheGlzID0gJ3onOyB9XG5cbiAgICB2YXIgYXhpc0xpc3QgPSB0aGlzLmF4aXNMaXN0O1xuICAgIHZhciBsb3dlciA9IGFhYmIubG93ZXJCb3VuZFtheGlzXTtcbiAgICB2YXIgdXBwZXIgPSBhYWJiLnVwcGVyQm91bmRbYXhpc107XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGF4aXNMaXN0Lmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGIgPSBheGlzTGlzdFtpXTtcblxuICAgICAgICBpZihiLmFhYmJOZWVkc1VwZGF0ZSl7XG4gICAgICAgICAgICBiLmNvbXB1dGVBQUJCKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihiLmFhYmIub3ZlcmxhcHMoYWFiYikpe1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbn0se1wiLi4vY29sbGlzaW9uL0Jyb2FkcGhhc2VcIjo1LFwiLi4vc2hhcGVzL1NoYXBlXCI6NDN9XSwxMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IENvbmVUd2lzdENvbnN0cmFpbnQ7XG5cbnZhciBDb25zdHJhaW50ID0gX2RlcmVxXygnLi9Db25zdHJhaW50Jyk7XG52YXIgUG9pbnRUb1BvaW50Q29uc3RyYWludCA9IF9kZXJlcV8oJy4vUG9pbnRUb1BvaW50Q29uc3RyYWludCcpO1xudmFyIENvbmVFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9Db25lRXF1YXRpb24nKTtcbnZhciBSb3RhdGlvbmFsRXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvUm90YXRpb25hbEVxdWF0aW9uJyk7XG52YXIgQ29udGFjdEVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvbicpO1xudmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcblxuLyoqXG4gKiBAY2xhc3MgQ29uZVR3aXN0Q29uc3RyYWludFxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLnBpdm90QV1cbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMucGl2b3RCXVxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5heGlzQV1cbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuYXhpc0JdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4Rm9yY2U9MWU2XVxuICogQGV4dGVuZHMgUG9pbnRUb1BvaW50Q29uc3RyYWludFxuICovXG5mdW5jdGlvbiBDb25lVHdpc3RDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIG1heEZvcmNlID0gdHlwZW9mKG9wdGlvbnMubWF4Rm9yY2UpICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMubWF4Rm9yY2UgOiAxZTY7XG5cbiAgICAvLyBTZXQgcGl2b3QgcG9pbnQgaW4gYmV0d2VlblxuICAgIHZhciBwaXZvdEEgPSBvcHRpb25zLnBpdm90QSA/IG9wdGlvbnMucGl2b3RBLmNsb25lKCkgOiBuZXcgVmVjMygpO1xuICAgIHZhciBwaXZvdEIgPSBvcHRpb25zLnBpdm90QiA/IG9wdGlvbnMucGl2b3RCLmNsb25lKCkgOiBuZXcgVmVjMygpO1xuICAgIHRoaXMuYXhpc0EgPSBvcHRpb25zLmF4aXNBID8gb3B0aW9ucy5heGlzQS5jbG9uZSgpIDogbmV3IFZlYzMoKTtcbiAgICB0aGlzLmF4aXNCID0gb3B0aW9ucy5heGlzQiA/IG9wdGlvbnMuYXhpc0IuY2xvbmUoKSA6IG5ldyBWZWMzKCk7XG5cbiAgICBQb2ludFRvUG9pbnRDb25zdHJhaW50LmNhbGwodGhpcywgYm9keUEsIHBpdm90QSwgYm9keUIsIHBpdm90QiwgbWF4Rm9yY2UpO1xuXG4gICAgdGhpcy5jb2xsaWRlQ29ubmVjdGVkID0gISFvcHRpb25zLmNvbGxpZGVDb25uZWN0ZWQ7XG5cbiAgICB0aGlzLmFuZ2xlID0gdHlwZW9mKG9wdGlvbnMuYW5nbGUpICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuYW5nbGUgOiAwO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtDb25lRXF1YXRpb259IGNvbmVFcXVhdGlvblxuICAgICAqL1xuICAgIHZhciBjID0gdGhpcy5jb25lRXF1YXRpb24gPSBuZXcgQ29uZUVxdWF0aW9uKGJvZHlBLGJvZHlCLG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtSb3RhdGlvbmFsRXF1YXRpb259IHR3aXN0RXF1YXRpb25cbiAgICAgKi9cbiAgICB2YXIgdCA9IHRoaXMudHdpc3RFcXVhdGlvbiA9IG5ldyBSb3RhdGlvbmFsRXF1YXRpb24oYm9keUEsYm9keUIsb3B0aW9ucyk7XG4gICAgdGhpcy50d2lzdEFuZ2xlID0gdHlwZW9mKG9wdGlvbnMudHdpc3RBbmdsZSkgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy50d2lzdEFuZ2xlIDogMDtcblxuICAgIC8vIE1ha2UgdGhlIGNvbmUgZXF1YXRpb24gcHVzaCB0aGUgYm9kaWVzIHRvd2FyZCB0aGUgY29uZSBheGlzLCBub3Qgb3V0d2FyZFxuICAgIGMubWF4Rm9yY2UgPSAwO1xuICAgIGMubWluRm9yY2UgPSAtbWF4Rm9yY2U7XG5cbiAgICAvLyBNYWtlIHRoZSB0d2lzdCBlcXVhdGlvbiBhZGQgdG9ycXVlIHRvd2FyZCB0aGUgaW5pdGlhbCBwb3NpdGlvblxuICAgIHQubWF4Rm9yY2UgPSAwO1xuICAgIHQubWluRm9yY2UgPSAtbWF4Rm9yY2U7XG5cbiAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKGMsIHQpO1xufVxuQ29uZVR3aXN0Q29uc3RyYWludC5wcm90b3R5cGUgPSBuZXcgUG9pbnRUb1BvaW50Q29uc3RyYWludCgpO1xuQ29uZVR3aXN0Q29uc3RyYWludC5jb25zdHJ1Y3RvciA9IENvbmVUd2lzdENvbnN0cmFpbnQ7XG5cbnZhciBDb25lVHdpc3RDb25zdHJhaW50X3VwZGF0ZV90bXBWZWMxID0gbmV3IFZlYzMoKTtcbnZhciBDb25lVHdpc3RDb25zdHJhaW50X3VwZGF0ZV90bXBWZWMyID0gbmV3IFZlYzMoKTtcblxuQ29uZVR3aXN0Q29uc3RyYWludC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgYm9keUEgPSB0aGlzLmJvZHlBLFxuICAgICAgICBib2R5QiA9IHRoaXMuYm9keUIsXG4gICAgICAgIGNvbmUgPSB0aGlzLmNvbmVFcXVhdGlvbixcbiAgICAgICAgdHdpc3QgPSB0aGlzLnR3aXN0RXF1YXRpb247XG5cbiAgICBQb2ludFRvUG9pbnRDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgYXhlcyB0byB0aGUgY29uZSBjb25zdHJhaW50XG4gICAgYm9keUEudmVjdG9yVG9Xb3JsZEZyYW1lKHRoaXMuYXhpc0EsIGNvbmUuYXhpc0EpO1xuICAgIGJvZHlCLnZlY3RvclRvV29ybGRGcmFtZSh0aGlzLmF4aXNCLCBjb25lLmF4aXNCKTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgd29ybGQgYXhlcyBpbiB0aGUgdHdpc3QgY29uc3RyYWludFxuICAgIHRoaXMuYXhpc0EudGFuZ2VudHModHdpc3QuYXhpc0EsIHR3aXN0LmF4aXNBKTtcbiAgICBib2R5QS52ZWN0b3JUb1dvcmxkRnJhbWUodHdpc3QuYXhpc0EsIHR3aXN0LmF4aXNBKTtcblxuICAgIHRoaXMuYXhpc0IudGFuZ2VudHModHdpc3QuYXhpc0IsIHR3aXN0LmF4aXNCKTtcbiAgICBib2R5Qi52ZWN0b3JUb1dvcmxkRnJhbWUodHdpc3QuYXhpc0IsIHR3aXN0LmF4aXNCKTtcblxuICAgIGNvbmUuYW5nbGUgPSB0aGlzLmFuZ2xlO1xuICAgIHR3aXN0Lm1heEFuZ2xlID0gdGhpcy50d2lzdEFuZ2xlO1xufTtcblxuXG59LHtcIi4uL2VxdWF0aW9ucy9Db25lRXF1YXRpb25cIjoxOCxcIi4uL2VxdWF0aW9ucy9Db250YWN0RXF1YXRpb25cIjoxOSxcIi4uL2VxdWF0aW9ucy9Sb3RhdGlvbmFsRXF1YXRpb25cIjoyMixcIi4uL21hdGgvVmVjM1wiOjMwLFwiLi9Db25zdHJhaW50XCI6MTMsXCIuL1BvaW50VG9Qb2ludENvbnN0cmFpbnRcIjoxN31dLDEzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gQ29uc3RyYWludDtcblxudmFyIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKTtcblxuLyoqXG4gKiBDb25zdHJhaW50IGJhc2UgY2xhc3NcbiAqIEBjbGFzcyBDb25zdHJhaW50XG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY29sbGlkZUNvbm5lY3RlZD10cnVlXVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy53YWtlVXBCb2RpZXM9dHJ1ZV1cbiAqL1xuZnVuY3Rpb24gQ29uc3RyYWludChib2R5QSwgYm9keUIsIG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBVdGlscy5kZWZhdWx0cyhvcHRpb25zLHtcbiAgICAgICAgY29sbGlkZUNvbm5lY3RlZCA6IHRydWUsXG4gICAgICAgIHdha2VVcEJvZGllcyA6IHRydWUsXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBFcXVhdGlvbnMgdG8gYmUgc29sdmVkIGluIHRoaXMgY29uc3RyYWludFxuICAgICAqIEBwcm9wZXJ0eSBlcXVhdGlvbnNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5lcXVhdGlvbnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9keX0gYm9keUFcbiAgICAgKi9cbiAgICB0aGlzLmJvZHlBID0gYm9keUE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0JvZHl9IGJvZHlCXG4gICAgICovXG4gICAgdGhpcy5ib2R5QiA9IGJvZHlCO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGlkXG4gICAgICovXG4gICAgdGhpcy5pZCA9IENvbnN0cmFpbnQuaWRDb3VudGVyKys7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0aGUgYm9kaWVzIHRvIGNvbGxpZGUgd2hlbiB0aGV5IGFyZSBjb25uZWN0ZWQuXG4gICAgICogQHByb3BlcnR5IGNvbGxpZGVDb25uZWN0ZWRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbGxpZGVDb25uZWN0ZWQgPSBvcHRpb25zLmNvbGxpZGVDb25uZWN0ZWQ7XG5cbiAgICBpZihvcHRpb25zLndha2VVcEJvZGllcyl7XG4gICAgICAgIGlmKGJvZHlBKXtcbiAgICAgICAgICAgIGJvZHlBLndha2VVcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmKGJvZHlCKXtcbiAgICAgICAgICAgIGJvZHlCLndha2VVcCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIFVwZGF0ZSBhbGwgdGhlIGVxdWF0aW9ucyB3aXRoIGRhdGEuXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICovXG5Db25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpe1xuICAgIHRocm93IG5ldyBFcnJvcihcIm1ldGhvZCB1cGRhdGUoKSBub3QgaW1wbG1lbWVudGVkIGluIHRoaXMgQ29uc3RyYWludCBzdWJjbGFzcyFcIik7XG59O1xuXG4vKipcbiAqIEVuYWJsZXMgYWxsIGVxdWF0aW9ucyBpbiB0aGUgY29uc3RyYWludC5cbiAqIEBtZXRob2QgZW5hYmxlXG4gKi9cbkNvbnN0cmFpbnQucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVxcyA9IHRoaXMuZXF1YXRpb25zO1xuICAgIGZvcih2YXIgaT0wOyBpPGVxcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGVxc1tpXS5lbmFibGVkID0gdHJ1ZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIERpc2FibGVzIGFsbCBlcXVhdGlvbnMgaW4gdGhlIGNvbnN0cmFpbnQuXG4gKiBAbWV0aG9kIGRpc2FibGVcbiAqL1xuQ29uc3RyYWludC5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVxcyA9IHRoaXMuZXF1YXRpb25zO1xuICAgIGZvcih2YXIgaT0wOyBpPGVxcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGVxc1tpXS5lbmFibGVkID0gZmFsc2U7XG4gICAgfVxufTtcblxuQ29uc3RyYWludC5pZENvdW50ZXIgPSAwO1xuXG59LHtcIi4uL3V0aWxzL1V0aWxzXCI6NTN9XSwxNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IERpc3RhbmNlQ29uc3RyYWludDtcblxudmFyIENvbnN0cmFpbnQgPSBfZGVyZXFfKCcuL0NvbnN0cmFpbnQnKTtcbnZhciBDb250YWN0RXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uJyk7XG5cbi8qKlxuICogQ29uc3RyYWlucyB0d28gYm9kaWVzIHRvIGJlIGF0IGEgY29uc3RhbnQgZGlzdGFuY2UgZnJvbSBlYWNoIG90aGVycyBjZW50ZXIgb2YgbWFzcy5cbiAqIEBjbGFzcyBEaXN0YW5jZUNvbnN0cmFpbnRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGF1dGhvciBzY2h0ZXBwZVxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtOdW1iZXJ9IFtkaXN0YW5jZV0gVGhlIGRpc3RhbmNlIHRvIGtlZXAuIElmIHVuZGVmaW5lZCwgaXQgd2lsbCBiZSBzZXQgdG8gdGhlIGN1cnJlbnQgZGlzdGFuY2UgYmV0d2VlbiBib2R5QSBhbmQgYm9keUJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4Rm9yY2U9MWU2XVxuICogQGV4dGVuZHMgQ29uc3RyYWludFxuICovXG5mdW5jdGlvbiBEaXN0YW5jZUNvbnN0cmFpbnQoYm9keUEsYm9keUIsZGlzdGFuY2UsbWF4Rm9yY2Upe1xuICAgIENvbnN0cmFpbnQuY2FsbCh0aGlzLGJvZHlBLGJvZHlCKTtcblxuICAgIGlmKHR5cGVvZihkaXN0YW5jZSk9PT1cInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGRpc3RhbmNlID0gYm9keUEucG9zaXRpb24uZGlzdGFuY2VUbyhib2R5Qi5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgaWYodHlwZW9mKG1heEZvcmNlKT09PVwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgbWF4Rm9yY2UgPSAxZTY7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRpc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtDb250YWN0RXF1YXRpb259IGRpc3RhbmNlRXF1YXRpb25cbiAgICAgKi9cbiAgICB2YXIgZXEgPSB0aGlzLmRpc3RhbmNlRXF1YXRpb24gPSBuZXcgQ29udGFjdEVxdWF0aW9uKGJvZHlBLCBib2R5Qik7XG4gICAgdGhpcy5lcXVhdGlvbnMucHVzaChlcSk7XG5cbiAgICAvLyBNYWtlIGl0IGJpZGlyZWN0aW9uYWxcbiAgICBlcS5taW5Gb3JjZSA9IC1tYXhGb3JjZTtcbiAgICBlcS5tYXhGb3JjZSA9ICBtYXhGb3JjZTtcbn1cbkRpc3RhbmNlQ29uc3RyYWludC5wcm90b3R5cGUgPSBuZXcgQ29uc3RyYWludCgpO1xuXG5EaXN0YW5jZUNvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGJvZHlBID0gdGhpcy5ib2R5QTtcbiAgICB2YXIgYm9keUIgPSB0aGlzLmJvZHlCO1xuICAgIHZhciBlcSA9IHRoaXMuZGlzdGFuY2VFcXVhdGlvbjtcbiAgICB2YXIgaGFsZkRpc3QgPSB0aGlzLmRpc3RhbmNlICogMC41O1xuICAgIHZhciBub3JtYWwgPSBlcS5uaTtcblxuICAgIGJvZHlCLnBvc2l0aW9uLnZzdWIoYm9keUEucG9zaXRpb24sIG5vcm1hbCk7XG4gICAgbm9ybWFsLm5vcm1hbGl6ZSgpO1xuICAgIG5vcm1hbC5tdWx0KGhhbGZEaXN0LCBlcS5yaSk7XG4gICAgbm9ybWFsLm11bHQoLWhhbGZEaXN0LCBlcS5yaik7XG59O1xufSx7XCIuLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uXCI6MTksXCIuL0NvbnN0cmFpbnRcIjoxM31dLDE1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gSGluZ2VDb25zdHJhaW50O1xuXG52YXIgQ29uc3RyYWludCA9IF9kZXJlcV8oJy4vQ29uc3RyYWludCcpO1xudmFyIFBvaW50VG9Qb2ludENvbnN0cmFpbnQgPSBfZGVyZXFfKCcuL1BvaW50VG9Qb2ludENvbnN0cmFpbnQnKTtcbnZhciBSb3RhdGlvbmFsRXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvUm90YXRpb25hbEVxdWF0aW9uJyk7XG52YXIgUm90YXRpb25hbE1vdG9yRXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvUm90YXRpb25hbE1vdG9yRXF1YXRpb24nKTtcbnZhciBDb250YWN0RXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uJyk7XG52YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xuXG4vKipcbiAqIEhpbmdlIGNvbnN0cmFpbnQuIFRoaW5rIG9mIGl0IGFzIGEgZG9vciBoaW5nZS4gSXQgdHJpZXMgdG8ga2VlcCB0aGUgZG9vciBpbiB0aGUgY29ycmVjdCBwbGFjZSBhbmQgd2l0aCB0aGUgY29ycmVjdCBvcmllbnRhdGlvbi5cbiAqIEBjbGFzcyBIaW5nZUNvbnN0cmFpbnRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGF1dGhvciBzY2h0ZXBwZVxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5waXZvdEFdIEEgcG9pbnQgZGVmaW5lZCBsb2NhbGx5IGluIGJvZHlBLiBUaGlzIGRlZmluZXMgdGhlIG9mZnNldCBvZiBheGlzQS5cbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuYXhpc0FdIEFuIGF4aXMgdGhhdCBib2R5QSBjYW4gcm90YXRlIGFyb3VuZCwgZGVmaW5lZCBsb2NhbGx5IGluIGJvZHlBLlxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5waXZvdEJdXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmF4aXNCXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heEZvcmNlPTFlNl1cbiAqIEBleHRlbmRzIFBvaW50VG9Qb2ludENvbnN0cmFpbnRcbiAqL1xuZnVuY3Rpb24gSGluZ2VDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIG1heEZvcmNlID0gdHlwZW9mKG9wdGlvbnMubWF4Rm9yY2UpICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMubWF4Rm9yY2UgOiAxZTY7XG4gICAgdmFyIHBpdm90QSA9IG9wdGlvbnMucGl2b3RBID8gb3B0aW9ucy5waXZvdEEuY2xvbmUoKSA6IG5ldyBWZWMzKCk7XG4gICAgdmFyIHBpdm90QiA9IG9wdGlvbnMucGl2b3RCID8gb3B0aW9ucy5waXZvdEIuY2xvbmUoKSA6IG5ldyBWZWMzKCk7XG5cbiAgICBQb2ludFRvUG9pbnRDb25zdHJhaW50LmNhbGwodGhpcywgYm9keUEsIHBpdm90QSwgYm9keUIsIHBpdm90QiwgbWF4Rm9yY2UpO1xuXG4gICAgLyoqXG4gICAgICogUm90YXRpb24gYXhpcywgZGVmaW5lZCBsb2NhbGx5IGluIGJvZHlBLlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gYXhpc0FcbiAgICAgKi9cbiAgICB2YXIgYXhpc0EgPSB0aGlzLmF4aXNBID0gb3B0aW9ucy5heGlzQSA/IG9wdGlvbnMuYXhpc0EuY2xvbmUoKSA6IG5ldyBWZWMzKDEsMCwwKTtcbiAgICBheGlzQS5ub3JtYWxpemUoKTtcblxuICAgIC8qKlxuICAgICAqIFJvdGF0aW9uIGF4aXMsIGRlZmluZWQgbG9jYWxseSBpbiBib2R5Qi5cbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IGF4aXNCXG4gICAgICovXG4gICAgdmFyIGF4aXNCID0gdGhpcy5heGlzQiA9IG9wdGlvbnMuYXhpc0IgPyBvcHRpb25zLmF4aXNCLmNsb25lKCkgOiBuZXcgVmVjMygxLDAsMCk7XG4gICAgYXhpc0Iubm9ybWFsaXplKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge1JvdGF0aW9uYWxFcXVhdGlvbn0gcm90YXRpb25hbEVxdWF0aW9uMVxuICAgICAqL1xuICAgIHZhciByMSA9IHRoaXMucm90YXRpb25hbEVxdWF0aW9uMSA9IG5ldyBSb3RhdGlvbmFsRXF1YXRpb24oYm9keUEsYm9keUIsb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge1JvdGF0aW9uYWxFcXVhdGlvbn0gcm90YXRpb25hbEVxdWF0aW9uMlxuICAgICAqL1xuICAgIHZhciByMiA9IHRoaXMucm90YXRpb25hbEVxdWF0aW9uMiA9IG5ldyBSb3RhdGlvbmFsRXF1YXRpb24oYm9keUEsYm9keUIsb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge1JvdGF0aW9uYWxNb3RvckVxdWF0aW9ufSBtb3RvckVxdWF0aW9uXG4gICAgICovXG4gICAgdmFyIG1vdG9yID0gdGhpcy5tb3RvckVxdWF0aW9uID0gbmV3IFJvdGF0aW9uYWxNb3RvckVxdWF0aW9uKGJvZHlBLGJvZHlCLG1heEZvcmNlKTtcbiAgICBtb3Rvci5lbmFibGVkID0gZmFsc2U7IC8vIE5vdCBlbmFibGVkIGJ5IGRlZmF1bHRcblxuICAgIC8vIEVxdWF0aW9ucyB0byBiZSBmZWQgdG8gdGhlIHNvbHZlclxuICAgIHRoaXMuZXF1YXRpb25zLnB1c2goXG4gICAgICAgIHIxLCAvLyByb3RhdGlvbmFsMVxuICAgICAgICByMiwgLy8gcm90YXRpb25hbDJcbiAgICAgICAgbW90b3JcbiAgICApO1xufVxuSGluZ2VDb25zdHJhaW50LnByb3RvdHlwZSA9IG5ldyBQb2ludFRvUG9pbnRDb25zdHJhaW50KCk7XG5IaW5nZUNvbnN0cmFpbnQuY29uc3RydWN0b3IgPSBIaW5nZUNvbnN0cmFpbnQ7XG5cbi8qKlxuICogQG1ldGhvZCBlbmFibGVNb3RvclxuICovXG5IaW5nZUNvbnN0cmFpbnQucHJvdG90eXBlLmVuYWJsZU1vdG9yID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLm1vdG9yRXF1YXRpb24uZW5hYmxlZCA9IHRydWU7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZGlzYWJsZU1vdG9yXG4gKi9cbkhpbmdlQ29uc3RyYWludC5wcm90b3R5cGUuZGlzYWJsZU1vdG9yID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLm1vdG9yRXF1YXRpb24uZW5hYmxlZCA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHNldE1vdG9yU3BlZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBzcGVlZFxuICovXG5IaW5nZUNvbnN0cmFpbnQucHJvdG90eXBlLnNldE1vdG9yU3BlZWQgPSBmdW5jdGlvbihzcGVlZCl7XG4gICAgdGhpcy5tb3RvckVxdWF0aW9uLnRhcmdldFZlbG9jaXR5ID0gc3BlZWQ7XG59O1xuXG4vKipcbiAqIEBtZXRob2Qgc2V0TW90b3JNYXhGb3JjZVxuICogQHBhcmFtIHtudW1iZXJ9IG1heEZvcmNlXG4gKi9cbkhpbmdlQ29uc3RyYWludC5wcm90b3R5cGUuc2V0TW90b3JNYXhGb3JjZSA9IGZ1bmN0aW9uKG1heEZvcmNlKXtcbiAgICB0aGlzLm1vdG9yRXF1YXRpb24ubWF4Rm9yY2UgPSBtYXhGb3JjZTtcbiAgICB0aGlzLm1vdG9yRXF1YXRpb24ubWluRm9yY2UgPSAtbWF4Rm9yY2U7XG59O1xuXG52YXIgSGluZ2VDb25zdHJhaW50X3VwZGF0ZV90bXBWZWMxID0gbmV3IFZlYzMoKTtcbnZhciBIaW5nZUNvbnN0cmFpbnRfdXBkYXRlX3RtcFZlYzIgPSBuZXcgVmVjMygpO1xuXG5IaW5nZUNvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGJvZHlBID0gdGhpcy5ib2R5QSxcbiAgICAgICAgYm9keUIgPSB0aGlzLmJvZHlCLFxuICAgICAgICBtb3RvciA9IHRoaXMubW90b3JFcXVhdGlvbixcbiAgICAgICAgcjEgPSB0aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjEsXG4gICAgICAgIHIyID0gdGhpcy5yb3RhdGlvbmFsRXF1YXRpb24yLFxuICAgICAgICB3b3JsZEF4aXNBID0gSGluZ2VDb25zdHJhaW50X3VwZGF0ZV90bXBWZWMxLFxuICAgICAgICB3b3JsZEF4aXNCID0gSGluZ2VDb25zdHJhaW50X3VwZGF0ZV90bXBWZWMyO1xuXG4gICAgdmFyIGF4aXNBID0gdGhpcy5heGlzQTtcbiAgICB2YXIgYXhpc0IgPSB0aGlzLmF4aXNCO1xuXG4gICAgUG9pbnRUb1BvaW50Q29uc3RyYWludC5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcyk7XG5cbiAgICAvLyBHZXQgd29ybGQgYXhlc1xuICAgIGJvZHlBLnF1YXRlcm5pb24udm11bHQoYXhpc0EsIHdvcmxkQXhpc0EpO1xuICAgIGJvZHlCLnF1YXRlcm5pb24udm11bHQoYXhpc0IsIHdvcmxkQXhpc0IpO1xuXG4gICAgd29ybGRBeGlzQS50YW5nZW50cyhyMS5heGlzQSwgcjIuYXhpc0EpO1xuICAgIHIxLmF4aXNCLmNvcHkod29ybGRBeGlzQik7XG4gICAgcjIuYXhpc0IuY29weSh3b3JsZEF4aXNCKTtcblxuICAgIGlmKHRoaXMubW90b3JFcXVhdGlvbi5lbmFibGVkKXtcbiAgICAgICAgYm9keUEucXVhdGVybmlvbi52bXVsdCh0aGlzLmF4aXNBLCBtb3Rvci5heGlzQSk7XG4gICAgICAgIGJvZHlCLnF1YXRlcm5pb24udm11bHQodGhpcy5heGlzQiwgbW90b3IuYXhpc0IpO1xuICAgIH1cbn07XG5cblxufSx7XCIuLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uXCI6MTksXCIuLi9lcXVhdGlvbnMvUm90YXRpb25hbEVxdWF0aW9uXCI6MjIsXCIuLi9lcXVhdGlvbnMvUm90YXRpb25hbE1vdG9yRXF1YXRpb25cIjoyMyxcIi4uL21hdGgvVmVjM1wiOjMwLFwiLi9Db25zdHJhaW50XCI6MTMsXCIuL1BvaW50VG9Qb2ludENvbnN0cmFpbnRcIjoxN31dLDE2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gTG9ja0NvbnN0cmFpbnQ7XG5cbnZhciBDb25zdHJhaW50ID0gX2RlcmVxXygnLi9Db25zdHJhaW50Jyk7XG52YXIgUG9pbnRUb1BvaW50Q29uc3RyYWludCA9IF9kZXJlcV8oJy4vUG9pbnRUb1BvaW50Q29uc3RyYWludCcpO1xudmFyIFJvdGF0aW9uYWxFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9Sb3RhdGlvbmFsRXF1YXRpb24nKTtcbnZhciBSb3RhdGlvbmFsTW90b3JFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9Sb3RhdGlvbmFsTW90b3JFcXVhdGlvbicpO1xudmFyIENvbnRhY3RFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9Db250YWN0RXF1YXRpb24nKTtcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XG5cbi8qKlxuICogTG9jayBjb25zdHJhaW50LiBXaWxsIHJlbW92ZSBhbGwgZGVncmVlcyBvZiBmcmVlZG9tIGJldHdlZW4gdGhlIGJvZGllcy5cbiAqIEBjbGFzcyBMb2NrQ29uc3RyYWludFxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4Rm9yY2U9MWU2XVxuICogQGV4dGVuZHMgUG9pbnRUb1BvaW50Q29uc3RyYWludFxuICovXG5mdW5jdGlvbiBMb2NrQ29uc3RyYWludChib2R5QSwgYm9keUIsIG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBtYXhGb3JjZSA9IHR5cGVvZihvcHRpb25zLm1heEZvcmNlKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLm1heEZvcmNlIDogMWU2O1xuXG4gICAgLy8gU2V0IHBpdm90IHBvaW50IGluIGJldHdlZW5cbiAgICB2YXIgcGl2b3RBID0gbmV3IFZlYzMoKTtcbiAgICB2YXIgcGl2b3RCID0gbmV3IFZlYzMoKTtcbiAgICB2YXIgaGFsZldheSA9IG5ldyBWZWMzKCk7XG4gICAgYm9keUEucG9zaXRpb24udmFkZChib2R5Qi5wb3NpdGlvbiwgaGFsZldheSk7XG4gICAgaGFsZldheS5zY2FsZSgwLjUsIGhhbGZXYXkpO1xuICAgIGJvZHlCLnBvaW50VG9Mb2NhbEZyYW1lKGhhbGZXYXksIHBpdm90Qik7XG4gICAgYm9keUEucG9pbnRUb0xvY2FsRnJhbWUoaGFsZldheSwgcGl2b3RBKTtcbiAgICBQb2ludFRvUG9pbnRDb25zdHJhaW50LmNhbGwodGhpcywgYm9keUEsIHBpdm90QSwgYm9keUIsIHBpdm90QiwgbWF4Rm9yY2UpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtSb3RhdGlvbmFsRXF1YXRpb259IHJvdGF0aW9uYWxFcXVhdGlvbjFcbiAgICAgKi9cbiAgICB2YXIgcjEgPSB0aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjEgPSBuZXcgUm90YXRpb25hbEVxdWF0aW9uKGJvZHlBLGJvZHlCLG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtSb3RhdGlvbmFsRXF1YXRpb259IHJvdGF0aW9uYWxFcXVhdGlvbjJcbiAgICAgKi9cbiAgICB2YXIgcjIgPSB0aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjIgPSBuZXcgUm90YXRpb25hbEVxdWF0aW9uKGJvZHlBLGJvZHlCLG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtSb3RhdGlvbmFsRXF1YXRpb259IHJvdGF0aW9uYWxFcXVhdGlvbjNcbiAgICAgKi9cbiAgICB2YXIgcjMgPSB0aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjMgPSBuZXcgUm90YXRpb25hbEVxdWF0aW9uKGJvZHlBLGJvZHlCLG9wdGlvbnMpO1xuXG4gICAgdGhpcy5lcXVhdGlvbnMucHVzaChyMSwgcjIsIHIzKTtcbn1cbkxvY2tDb25zdHJhaW50LnByb3RvdHlwZSA9IG5ldyBQb2ludFRvUG9pbnRDb25zdHJhaW50KCk7XG5Mb2NrQ29uc3RyYWludC5jb25zdHJ1Y3RvciA9IExvY2tDb25zdHJhaW50O1xuXG52YXIgTG9ja0NvbnN0cmFpbnRfdXBkYXRlX3RtcFZlYzEgPSBuZXcgVmVjMygpO1xudmFyIExvY2tDb25zdHJhaW50X3VwZGF0ZV90bXBWZWMyID0gbmV3IFZlYzMoKTtcblxuTG9ja0NvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGJvZHlBID0gdGhpcy5ib2R5QSxcbiAgICAgICAgYm9keUIgPSB0aGlzLmJvZHlCLFxuICAgICAgICBtb3RvciA9IHRoaXMubW90b3JFcXVhdGlvbixcbiAgICAgICAgcjEgPSB0aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjEsXG4gICAgICAgIHIyID0gdGhpcy5yb3RhdGlvbmFsRXF1YXRpb24yLFxuICAgICAgICByMyA9IHRoaXMucm90YXRpb25hbEVxdWF0aW9uMyxcbiAgICAgICAgd29ybGRBeGlzQSA9IExvY2tDb25zdHJhaW50X3VwZGF0ZV90bXBWZWMxLFxuICAgICAgICB3b3JsZEF4aXNCID0gTG9ja0NvbnN0cmFpbnRfdXBkYXRlX3RtcFZlYzI7XG5cbiAgICBQb2ludFRvUG9pbnRDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcblxuICAgIGJvZHlBLnZlY3RvclRvV29ybGRGcmFtZShWZWMzLlVOSVRfWCwgcjEuYXhpc0EpO1xuICAgIGJvZHlCLnZlY3RvclRvV29ybGRGcmFtZShWZWMzLlVOSVRfWSwgcjEuYXhpc0IpO1xuXG4gICAgYm9keUEudmVjdG9yVG9Xb3JsZEZyYW1lKFZlYzMuVU5JVF9ZLCByMi5heGlzQSk7XG4gICAgYm9keUIudmVjdG9yVG9Xb3JsZEZyYW1lKFZlYzMuVU5JVF9aLCByMi5heGlzQik7XG5cbiAgICBib2R5QS52ZWN0b3JUb1dvcmxkRnJhbWUoVmVjMy5VTklUX1osIHIzLmF4aXNBKTtcbiAgICBib2R5Qi52ZWN0b3JUb1dvcmxkRnJhbWUoVmVjMy5VTklUX1gsIHIzLmF4aXNCKTtcbn07XG5cblxufSx7XCIuLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uXCI6MTksXCIuLi9lcXVhdGlvbnMvUm90YXRpb25hbEVxdWF0aW9uXCI6MjIsXCIuLi9lcXVhdGlvbnMvUm90YXRpb25hbE1vdG9yRXF1YXRpb25cIjoyMyxcIi4uL21hdGgvVmVjM1wiOjMwLFwiLi9Db25zdHJhaW50XCI6MTMsXCIuL1BvaW50VG9Qb2ludENvbnN0cmFpbnRcIjoxN31dLDE3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gUG9pbnRUb1BvaW50Q29uc3RyYWludDtcblxudmFyIENvbnN0cmFpbnQgPSBfZGVyZXFfKCcuL0NvbnN0cmFpbnQnKTtcbnZhciBDb250YWN0RXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uJyk7XG52YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xuXG4vKipcbiAqIENvbm5lY3RzIHR3byBib2RpZXMgYXQgZ2l2ZW4gb2Zmc2V0IHBvaW50cy5cbiAqIEBjbGFzcyBQb2ludFRvUG9pbnRDb25zdHJhaW50XG4gKiBAZXh0ZW5kcyBDb25zdHJhaW50XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7VmVjM30gcGl2b3RBIFRoZSBwb2ludCByZWxhdGl2ZSB0byB0aGUgY2VudGVyIG9mIG1hc3Mgb2YgYm9keUEgd2hpY2ggYm9keUEgaXMgY29uc3RyYWluZWQgdG8uXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCIEJvZHkgdGhhdCB3aWxsIGJlIGNvbnN0cmFpbmVkIGluIGEgc2ltaWxhciB3YXkgdG8gdGhlIHNhbWUgcG9pbnQgYXMgYm9keUEuIFdlIHdpbGwgdGhlcmVmb3JlIGdldCBhIGxpbmsgYmV0d2VlbiBib2R5QSBhbmQgYm9keUIuIElmIG5vdCBzcGVjaWZpZWQsIGJvZHlBIHdpbGwgYmUgY29uc3RyYWluZWQgdG8gYSBzdGF0aWMgcG9pbnQuXG4gKiBAcGFyYW0ge1ZlYzN9IHBpdm90QiBTZWUgcGl2b3RBLlxuICogQHBhcmFtIHtOdW1iZXJ9IG1heEZvcmNlIFRoZSBtYXhpbXVtIGZvcmNlIHRoYXQgc2hvdWxkIGJlIGFwcGxpZWQgdG8gY29uc3RyYWluIHRoZSBib2RpZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgICB2YXIgYm9keUEgPSBuZXcgQm9keSh7IG1hc3M6IDEgfSk7XG4gKiAgICAgdmFyIGJvZHlCID0gbmV3IEJvZHkoeyBtYXNzOiAxIH0pO1xuICogICAgIGJvZHlBLnBvc2l0aW9uLnNldCgtMSwgMCwgMCk7XG4gKiAgICAgYm9keUIucG9zaXRpb24uc2V0KDEsIDAsIDApO1xuICogICAgIGJvZHlBLmFkZFNoYXBlKHNoYXBlQSk7XG4gKiAgICAgYm9keUIuYWRkU2hhcGUoc2hhcGVCKTtcbiAqICAgICB3b3JsZC5hZGRCb2R5KGJvZHlBKTtcbiAqICAgICB3b3JsZC5hZGRCb2R5KGJvZHlCKTtcbiAqICAgICB2YXIgbG9jYWxQaXZvdEEgPSBuZXcgVmVjMygxLCAwLCAwKTtcbiAqICAgICB2YXIgbG9jYWxQaXZvdEIgPSBuZXcgVmVjMygtMSwgMCwgMCk7XG4gKiAgICAgdmFyIGNvbnN0cmFpbnQgPSBuZXcgUG9pbnRUb1BvaW50Q29uc3RyYWludChib2R5QSwgbG9jYWxQaXZvdEEsIGJvZHlCLCBsb2NhbFBpdm90Qik7XG4gKiAgICAgd29ybGQuYWRkQ29uc3RyYWludChjb25zdHJhaW50KTtcbiAqL1xuZnVuY3Rpb24gUG9pbnRUb1BvaW50Q29uc3RyYWludChib2R5QSxwaXZvdEEsYm9keUIscGl2b3RCLG1heEZvcmNlKXtcbiAgICBDb25zdHJhaW50LmNhbGwodGhpcyxib2R5QSxib2R5Qik7XG5cbiAgICBtYXhGb3JjZSA9IHR5cGVvZihtYXhGb3JjZSkgIT09ICd1bmRlZmluZWQnID8gbWF4Rm9yY2UgOiAxZTY7XG5cbiAgICAvKipcbiAgICAgKiBQaXZvdCwgZGVmaW5lZCBsb2NhbGx5IGluIGJvZHlBLlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gcGl2b3RBXG4gICAgICovXG4gICAgdGhpcy5waXZvdEEgPSBwaXZvdEEgPyBwaXZvdEEuY2xvbmUoKSA6IG5ldyBWZWMzKCk7XG5cbiAgICAvKipcbiAgICAgKiBQaXZvdCwgZGVmaW5lZCBsb2NhbGx5IGluIGJvZHlCLlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gcGl2b3RCXG4gICAgICovXG4gICAgdGhpcy5waXZvdEIgPSBwaXZvdEIgPyBwaXZvdEIuY2xvbmUoKSA6IG5ldyBWZWMzKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0NvbnRhY3RFcXVhdGlvbn0gZXF1YXRpb25YXG4gICAgICovXG4gICAgdmFyIHggPSB0aGlzLmVxdWF0aW9uWCA9IG5ldyBDb250YWN0RXF1YXRpb24oYm9keUEsYm9keUIpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtDb250YWN0RXF1YXRpb259IGVxdWF0aW9uWVxuICAgICAqL1xuICAgIHZhciB5ID0gdGhpcy5lcXVhdGlvblkgPSBuZXcgQ29udGFjdEVxdWF0aW9uKGJvZHlBLGJvZHlCKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7Q29udGFjdEVxdWF0aW9ufSBlcXVhdGlvblpcbiAgICAgKi9cbiAgICB2YXIgeiA9IHRoaXMuZXF1YXRpb25aID0gbmV3IENvbnRhY3RFcXVhdGlvbihib2R5QSxib2R5Qik7XG5cbiAgICAvLyBFcXVhdGlvbnMgdG8gYmUgZmVkIHRvIHRoZSBzb2x2ZXJcbiAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKHgsIHksIHopO1xuXG4gICAgLy8gTWFrZSB0aGUgZXF1YXRpb25zIGJpZGlyZWN0aW9uYWxcbiAgICB4Lm1pbkZvcmNlID0geS5taW5Gb3JjZSA9IHoubWluRm9yY2UgPSAtbWF4Rm9yY2U7XG4gICAgeC5tYXhGb3JjZSA9IHkubWF4Rm9yY2UgPSB6Lm1heEZvcmNlID0gIG1heEZvcmNlO1xuXG4gICAgeC5uaS5zZXQoMSwgMCwgMCk7XG4gICAgeS5uaS5zZXQoMCwgMSwgMCk7XG4gICAgei5uaS5zZXQoMCwgMCwgMSk7XG59XG5Qb2ludFRvUG9pbnRDb25zdHJhaW50LnByb3RvdHlwZSA9IG5ldyBDb25zdHJhaW50KCk7XG5cblBvaW50VG9Qb2ludENvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGJvZHlBID0gdGhpcy5ib2R5QTtcbiAgICB2YXIgYm9keUIgPSB0aGlzLmJvZHlCO1xuICAgIHZhciB4ID0gdGhpcy5lcXVhdGlvblg7XG4gICAgdmFyIHkgPSB0aGlzLmVxdWF0aW9uWTtcbiAgICB2YXIgeiA9IHRoaXMuZXF1YXRpb25aO1xuXG4gICAgLy8gUm90YXRlIHRoZSBwaXZvdHMgdG8gd29ybGQgc3BhY2VcbiAgICBib2R5QS5xdWF0ZXJuaW9uLnZtdWx0KHRoaXMucGl2b3RBLHgucmkpO1xuICAgIGJvZHlCLnF1YXRlcm5pb24udm11bHQodGhpcy5waXZvdEIseC5yaik7XG5cbiAgICB5LnJpLmNvcHkoeC5yaSk7XG4gICAgeS5yai5jb3B5KHgucmopO1xuICAgIHoucmkuY29weSh4LnJpKTtcbiAgICB6LnJqLmNvcHkoeC5yaik7XG59O1xufSx7XCIuLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uXCI6MTksXCIuLi9tYXRoL1ZlYzNcIjozMCxcIi4vQ29uc3RyYWludFwiOjEzfV0sMTg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBDb25lRXF1YXRpb247XG5cbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XG52YXIgTWF0MyA9IF9kZXJlcV8oJy4uL21hdGgvTWF0MycpO1xudmFyIEVxdWF0aW9uID0gX2RlcmVxXygnLi9FcXVhdGlvbicpO1xuXG4vKipcbiAqIENvbmUgZXF1YXRpb24uIFdvcmtzIHRvIGtlZXAgdGhlIGdpdmVuIGJvZHkgd29ybGQgdmVjdG9ycyBhbGlnbmVkLCBvciB0aWx0ZWQgd2l0aGluIGEgZ2l2ZW4gYW5nbGUgZnJvbSBlYWNoIG90aGVyLlxuICogQGNsYXNzIENvbmVFcXVhdGlvblxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmF4aXNBXSBMb2NhbCBheGlzIGluIEFcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuYXhpc0JdIExvY2FsIGF4aXMgaW4gQlxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5hbmdsZV0gVGhlIFwiY29uZSBhbmdsZVwiIHRvIGtlZXBcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhGb3JjZT0xZTZdXG4gKiBAZXh0ZW5kcyBFcXVhdGlvblxuICovXG5mdW5jdGlvbiBDb25lRXF1YXRpb24oYm9keUEsIGJvZHlCLCBvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgbWF4Rm9yY2UgPSB0eXBlb2Yob3B0aW9ucy5tYXhGb3JjZSkgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5tYXhGb3JjZSA6IDFlNjtcblxuICAgIEVxdWF0aW9uLmNhbGwodGhpcyxib2R5QSxib2R5QiwtbWF4Rm9yY2UsIG1heEZvcmNlKTtcblxuICAgIHRoaXMuYXhpc0EgPSBvcHRpb25zLmF4aXNBID8gb3B0aW9ucy5heGlzQS5jbG9uZSgpIDogbmV3IFZlYzMoMSwgMCwgMCk7XG4gICAgdGhpcy5heGlzQiA9IG9wdGlvbnMuYXhpc0IgPyBvcHRpb25zLmF4aXNCLmNsb25lKCkgOiBuZXcgVmVjMygwLCAxLCAwKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb25lIGFuZ2xlIHRvIGtlZXBcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYW5nbGVcbiAgICAgKi9cbiAgICB0aGlzLmFuZ2xlID0gdHlwZW9mKG9wdGlvbnMuYW5nbGUpICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuYW5nbGUgOiAwO1xufVxuXG5Db25lRXF1YXRpb24ucHJvdG90eXBlID0gbmV3IEVxdWF0aW9uKCk7XG5Db25lRXF1YXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29uZUVxdWF0aW9uO1xuXG52YXIgdG1wVmVjMSA9IG5ldyBWZWMzKCk7XG52YXIgdG1wVmVjMiA9IG5ldyBWZWMzKCk7XG5cbkNvbmVFcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUIgPSBmdW5jdGlvbihoKXtcbiAgICB2YXIgYSA9IHRoaXMuYSxcbiAgICAgICAgYiA9IHRoaXMuYixcblxuICAgICAgICBuaSA9IHRoaXMuYXhpc0EsXG4gICAgICAgIG5qID0gdGhpcy5heGlzQixcblxuICAgICAgICBuaXhuaiA9IHRtcFZlYzEsXG4gICAgICAgIG5qeG5pID0gdG1wVmVjMixcblxuICAgICAgICBHQSA9IHRoaXMuamFjb2JpYW5FbGVtZW50QSxcbiAgICAgICAgR0IgPSB0aGlzLmphY29iaWFuRWxlbWVudEI7XG5cbiAgICAvLyBDYWx1Y2xhdGUgY3Jvc3MgcHJvZHVjdHNcbiAgICBuaS5jcm9zcyhuaiwgbml4bmopO1xuICAgIG5qLmNyb3NzKG5pLCBuanhuaSk7XG5cbiAgICAvLyBUaGUgYW5nbGUgYmV0d2VlbiB0d28gdmVjdG9yIGlzOlxuICAgIC8vIGNvcyh0aGV0YSkgPSBhICogYiAvIChsZW5ndGgoYSkgKiBsZW5ndGgoYikgPSB7IGxlbihhKSA9IGxlbihiKSA9IDEgfSA9IGEgKiBiXG5cbiAgICAvLyBnID0gYSAqIGJcbiAgICAvLyBnZG90ID0gKGIgeCBhKSAqIHdpICsgKGEgeCBiKSAqIHdqXG4gICAgLy8gRyA9IFswIGJ4YSAwIGF4Yl1cbiAgICAvLyBXID0gW3ZpIHdpIHZqIHdqXVxuICAgIEdBLnJvdGF0aW9uYWwuY29weShuanhuaSk7XG4gICAgR0Iucm90YXRpb25hbC5jb3B5KG5peG5qKTtcblxuICAgIHZhciBnID0gTWF0aC5jb3ModGhpcy5hbmdsZSkgLSBuaS5kb3QobmopLFxuICAgICAgICBHVyA9IHRoaXMuY29tcHV0ZUdXKCksXG4gICAgICAgIEdpTWYgPSB0aGlzLmNvbXB1dGVHaU1mKCk7XG5cbiAgICB2YXIgQiA9IC0gZyAqIGEgLSBHVyAqIGIgLSBoICogR2lNZjtcblxuICAgIHJldHVybiBCO1xufTtcblxuXG59LHtcIi4uL21hdGgvTWF0M1wiOjI3LFwiLi4vbWF0aC9WZWMzXCI6MzAsXCIuL0VxdWF0aW9uXCI6MjB9XSwxOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhY3RFcXVhdGlvbjtcblxudmFyIEVxdWF0aW9uID0gX2RlcmVxXygnLi9FcXVhdGlvbicpO1xudmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcbnZhciBNYXQzID0gX2RlcmVxXygnLi4vbWF0aC9NYXQzJyk7XG5cbi8qKlxuICogQ29udGFjdC9ub24tcGVuZXRyYXRpb24gY29uc3RyYWludCBlcXVhdGlvblxuICogQGNsYXNzIENvbnRhY3RFcXVhdGlvblxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAZXh0ZW5kcyBFcXVhdGlvblxuICovXG5mdW5jdGlvbiBDb250YWN0RXF1YXRpb24oYm9keUEsIGJvZHlCLCBtYXhGb3JjZSl7XG4gICAgbWF4Rm9yY2UgPSB0eXBlb2YobWF4Rm9yY2UpICE9PSAndW5kZWZpbmVkJyA/IG1heEZvcmNlIDogMWU2O1xuICAgIEVxdWF0aW9uLmNhbGwodGhpcywgYm9keUEsIGJvZHlCLCAwLCBtYXhGb3JjZSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgcmVzdGl0dXRpb25cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVzdGl0dXRpb24gPSAwLjA7IC8vIFwiYm91bmNpbmVzc1wiOiB1MSA9IC1lKnUwXG5cbiAgICAvKipcbiAgICAgKiBXb3JsZC1vcmllbnRlZCB2ZWN0b3IgdGhhdCBnb2VzIGZyb20gdGhlIGNlbnRlciBvZiBiaSB0byB0aGUgY29udGFjdCBwb2ludC5cbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IHJpXG4gICAgICovXG4gICAgdGhpcy5yaSA9IG5ldyBWZWMzKCk7XG5cbiAgICAvKipcbiAgICAgKiBXb3JsZC1vcmllbnRlZCB2ZWN0b3IgdGhhdCBzdGFydHMgaW4gYm9keSBqIHBvc2l0aW9uIGFuZCBnb2VzIHRvIHRoZSBjb250YWN0IHBvaW50LlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gcmpcbiAgICAgKi9cbiAgICB0aGlzLnJqID0gbmV3IFZlYzMoKTtcblxuICAgIC8qKlxuICAgICAqIENvbnRhY3Qgbm9ybWFsLCBwb2ludGluZyBvdXQgb2YgYm9keSBpLlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gbmlcbiAgICAgKi9cbiAgICB0aGlzLm5pID0gbmV3IFZlYzMoKTtcbn1cblxuQ29udGFjdEVxdWF0aW9uLnByb3RvdHlwZSA9IG5ldyBFcXVhdGlvbigpO1xuQ29udGFjdEVxdWF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnRhY3RFcXVhdGlvbjtcblxudmFyIENvbnRhY3RFcXVhdGlvbl9jb21wdXRlQl90ZW1wMSA9IG5ldyBWZWMzKCk7IC8vIFRlbXAgdmVjdG9yc1xudmFyIENvbnRhY3RFcXVhdGlvbl9jb21wdXRlQl90ZW1wMiA9IG5ldyBWZWMzKCk7XG52YXIgQ29udGFjdEVxdWF0aW9uX2NvbXB1dGVCX3RlbXAzID0gbmV3IFZlYzMoKTtcbkNvbnRhY3RFcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUIgPSBmdW5jdGlvbihoKXtcbiAgICB2YXIgYSA9IHRoaXMuYSxcbiAgICAgICAgYiA9IHRoaXMuYixcbiAgICAgICAgYmkgPSB0aGlzLmJpLFxuICAgICAgICBiaiA9IHRoaXMuYmosXG4gICAgICAgIHJpID0gdGhpcy5yaSxcbiAgICAgICAgcmogPSB0aGlzLnJqLFxuICAgICAgICByaXhuID0gQ29udGFjdEVxdWF0aW9uX2NvbXB1dGVCX3RlbXAxLFxuICAgICAgICByanhuID0gQ29udGFjdEVxdWF0aW9uX2NvbXB1dGVCX3RlbXAyLFxuXG4gICAgICAgIHZpID0gYmkudmVsb2NpdHksXG4gICAgICAgIHdpID0gYmkuYW5ndWxhclZlbG9jaXR5LFxuICAgICAgICBmaSA9IGJpLmZvcmNlLFxuICAgICAgICB0YXVpID0gYmkudG9ycXVlLFxuXG4gICAgICAgIHZqID0gYmoudmVsb2NpdHksXG4gICAgICAgIHdqID0gYmouYW5ndWxhclZlbG9jaXR5LFxuICAgICAgICBmaiA9IGJqLmZvcmNlLFxuICAgICAgICB0YXVqID0gYmoudG9ycXVlLFxuXG4gICAgICAgIHBlbmV0cmF0aW9uVmVjID0gQ29udGFjdEVxdWF0aW9uX2NvbXB1dGVCX3RlbXAzLFxuXG4gICAgICAgIEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBLFxuICAgICAgICBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QixcblxuICAgICAgICBuID0gdGhpcy5uaTtcblxuICAgIC8vIENhbHVjbGF0ZSBjcm9zcyBwcm9kdWN0c1xuICAgIHJpLmNyb3NzKG4scml4bik7XG4gICAgcmouY3Jvc3MobixyanhuKTtcblxuICAgIC8vIGcgPSB4aityaiAtKHhpK3JpKVxuICAgIC8vIEcgPSBbIC1uaSAgLXJpeG4gIG5pICByanhuIF1cbiAgICBuLm5lZ2F0ZShHQS5zcGF0aWFsKTtcbiAgICByaXhuLm5lZ2F0ZShHQS5yb3RhdGlvbmFsKTtcbiAgICBHQi5zcGF0aWFsLmNvcHkobik7XG4gICAgR0Iucm90YXRpb25hbC5jb3B5KHJqeG4pO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBwZW5ldHJhdGlvbiB2ZWN0b3JcbiAgICBwZW5ldHJhdGlvblZlYy5jb3B5KGJqLnBvc2l0aW9uKTtcbiAgICBwZW5ldHJhdGlvblZlYy52YWRkKHJqLHBlbmV0cmF0aW9uVmVjKTtcbiAgICBwZW5ldHJhdGlvblZlYy52c3ViKGJpLnBvc2l0aW9uLHBlbmV0cmF0aW9uVmVjKTtcbiAgICBwZW5ldHJhdGlvblZlYy52c3ViKHJpLHBlbmV0cmF0aW9uVmVjKTtcblxuICAgIHZhciBnID0gbi5kb3QocGVuZXRyYXRpb25WZWMpO1xuXG4gICAgLy8gQ29tcHV0ZSBpdGVyYXRpb25cbiAgICB2YXIgZVBsdXNPbmUgPSB0aGlzLnJlc3RpdHV0aW9uICsgMTtcbiAgICB2YXIgR1cgPSBlUGx1c09uZSAqIHZqLmRvdChuKSAtIGVQbHVzT25lICogdmkuZG90KG4pICsgd2ouZG90KHJqeG4pIC0gd2kuZG90KHJpeG4pO1xuICAgIHZhciBHaU1mID0gdGhpcy5jb21wdXRlR2lNZigpO1xuXG4gICAgdmFyIEIgPSAtIGcgKiBhIC0gR1cgKiBiIC0gaCpHaU1mO1xuXG4gICAgcmV0dXJuIEI7XG59O1xuXG52YXIgQ29udGFjdEVxdWF0aW9uX2dldEltcGFjdFZlbG9jaXR5QWxvbmdOb3JtYWxfdmkgPSBuZXcgVmVjMygpO1xudmFyIENvbnRhY3RFcXVhdGlvbl9nZXRJbXBhY3RWZWxvY2l0eUFsb25nTm9ybWFsX3ZqID0gbmV3IFZlYzMoKTtcbnZhciBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF94aSA9IG5ldyBWZWMzKCk7XG52YXIgQ29udGFjdEVxdWF0aW9uX2dldEltcGFjdFZlbG9jaXR5QWxvbmdOb3JtYWxfeGogPSBuZXcgVmVjMygpO1xudmFyIENvbnRhY3RFcXVhdGlvbl9nZXRJbXBhY3RWZWxvY2l0eUFsb25nTm9ybWFsX3JlbFZlbCA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IHJlbGF0aXZlIHZlbG9jaXR5IGluIHRoZSBjb250YWN0IHBvaW50LlxuICogQG1ldGhvZCBnZXRJbXBhY3RWZWxvY2l0eUFsb25nTm9ybWFsXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbkNvbnRhY3RFcXVhdGlvbi5wcm90b3R5cGUuZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbCA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHZpID0gQ29udGFjdEVxdWF0aW9uX2dldEltcGFjdFZlbG9jaXR5QWxvbmdOb3JtYWxfdmk7XG4gICAgdmFyIHZqID0gQ29udGFjdEVxdWF0aW9uX2dldEltcGFjdFZlbG9jaXR5QWxvbmdOb3JtYWxfdmo7XG4gICAgdmFyIHhpID0gQ29udGFjdEVxdWF0aW9uX2dldEltcGFjdFZlbG9jaXR5QWxvbmdOb3JtYWxfeGk7XG4gICAgdmFyIHhqID0gQ29udGFjdEVxdWF0aW9uX2dldEltcGFjdFZlbG9jaXR5QWxvbmdOb3JtYWxfeGo7XG4gICAgdmFyIHJlbFZlbCA9IENvbnRhY3RFcXVhdGlvbl9nZXRJbXBhY3RWZWxvY2l0eUFsb25nTm9ybWFsX3JlbFZlbDtcblxuICAgIHRoaXMuYmkucG9zaXRpb24udmFkZCh0aGlzLnJpLCB4aSk7XG4gICAgdGhpcy5iai5wb3NpdGlvbi52YWRkKHRoaXMucmosIHhqKTtcblxuICAgIHRoaXMuYmkuZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQoeGksIHZpKTtcbiAgICB0aGlzLmJqLmdldFZlbG9jaXR5QXRXb3JsZFBvaW50KHhqLCB2aik7XG5cbiAgICB2aS52c3ViKHZqLCByZWxWZWwpO1xuXG4gICAgcmV0dXJuIHRoaXMubmkuZG90KHJlbFZlbCk7XG59O1xuXG5cbn0se1wiLi4vbWF0aC9NYXQzXCI6MjcsXCIuLi9tYXRoL1ZlYzNcIjozMCxcIi4vRXF1YXRpb25cIjoyMH1dLDIwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gRXF1YXRpb247XG5cbnZhciBKYWNvYmlhbkVsZW1lbnQgPSBfZGVyZXFfKCcuLi9tYXRoL0phY29iaWFuRWxlbWVudCcpLFxuICAgIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcblxuLyoqXG4gKiBFcXVhdGlvbiBiYXNlIGNsYXNzXG4gKiBAY2xhc3MgRXF1YXRpb25cbiAqIEBjb25zdHJ1Y3RvclxuICogQGF1dGhvciBzY2h0ZXBwZVxuICogQHBhcmFtIHtCb2R5fSBiaVxuICogQHBhcmFtIHtCb2R5fSBialxuICogQHBhcmFtIHtOdW1iZXJ9IG1pbkZvcmNlIE1pbmltdW0gKHJlYWQ6IG5lZ2F0aXZlIG1heCkgZm9yY2UgdG8gYmUgYXBwbGllZCBieSB0aGUgY29uc3RyYWludC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhGb3JjZSBNYXhpbXVtIChyZWFkOiBwb3NpdGl2ZSBtYXgpIGZvcmNlIHRvIGJlIGFwcGxpZWQgYnkgdGhlIGNvbnN0cmFpbnQuXG4gKi9cbmZ1bmN0aW9uIEVxdWF0aW9uKGJpLGJqLG1pbkZvcmNlLG1heEZvcmNlKXtcbiAgICB0aGlzLmlkID0gRXF1YXRpb24uaWQrKztcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW5Gb3JjZVxuICAgICAqL1xuICAgIHRoaXMubWluRm9yY2UgPSB0eXBlb2YobWluRm9yY2UpPT09XCJ1bmRlZmluZWRcIiA/IC0xZTYgOiBtaW5Gb3JjZTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhGb3JjZVxuICAgICAqL1xuICAgIHRoaXMubWF4Rm9yY2UgPSB0eXBlb2YobWF4Rm9yY2UpPT09XCJ1bmRlZmluZWRcIiA/IDFlNiA6IG1heEZvcmNlO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGJpXG4gICAgICogQHR5cGUge0JvZHl9XG4gICAgICovXG4gICAgdGhpcy5iaSA9IGJpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGJqXG4gICAgICogQHR5cGUge0JvZHl9XG4gICAgICovXG4gICAgdGhpcy5iaiA9IGJqO1xuXG4gICAgLyoqXG4gICAgICogU1BPT0sgcGFyYW1ldGVyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGFcbiAgICAgKi9cbiAgICB0aGlzLmEgPSAwLjA7XG5cbiAgICAvKipcbiAgICAgKiBTUE9PSyBwYXJhbWV0ZXJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYlxuICAgICAqL1xuICAgIHRoaXMuYiA9IDAuMDtcblxuICAgIC8qKlxuICAgICAqIFNQT09LIHBhcmFtZXRlclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBlcHNcbiAgICAgKi9cbiAgICB0aGlzLmVwcyA9IDAuMDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7SmFjb2JpYW5FbGVtZW50fSBqYWNvYmlhbkVsZW1lbnRBXG4gICAgICovXG4gICAgdGhpcy5qYWNvYmlhbkVsZW1lbnRBID0gbmV3IEphY29iaWFuRWxlbWVudCgpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtKYWNvYmlhbkVsZW1lbnR9IGphY29iaWFuRWxlbWVudEJcbiAgICAgKi9cbiAgICB0aGlzLmphY29iaWFuRWxlbWVudEIgPSBuZXcgSmFjb2JpYW5FbGVtZW50KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGVuYWJsZWRcbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcblxuICAgIC8vIFNldCB0eXBpY2FsIHNwb29rIHBhcmFtc1xuICAgIHRoaXMuc2V0U3Bvb2tQYXJhbXMoMWU3LDQsMS82MCk7XG59XG5FcXVhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFcXVhdGlvbjtcblxuRXF1YXRpb24uaWQgPSAwO1xuXG4vKipcbiAqIFJlY2FsY3VsYXRlcyBhLGIsZXBzLlxuICogQG1ldGhvZCBzZXRTcG9va1BhcmFtc1xuICovXG5FcXVhdGlvbi5wcm90b3R5cGUuc2V0U3Bvb2tQYXJhbXMgPSBmdW5jdGlvbihzdGlmZm5lc3MscmVsYXhhdGlvbix0aW1lU3RlcCl7XG4gICAgdmFyIGQgPSByZWxheGF0aW9uLFxuICAgICAgICBrID0gc3RpZmZuZXNzLFxuICAgICAgICBoID0gdGltZVN0ZXA7XG4gICAgdGhpcy5hID0gNC4wIC8gKGggKiAoMSArIDQgKiBkKSk7XG4gICAgdGhpcy5iID0gKDQuMCAqIGQpIC8gKDEgKyA0ICogZCk7XG4gICAgdGhpcy5lcHMgPSA0LjAgLyAoaCAqIGggKiBrICogKDEgKyA0ICogZCkpO1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgUkhTIG9mIHRoZSBTUE9PSyBlcXVhdGlvblxuICogQG1ldGhvZCBjb21wdXRlQlxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5FcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUIgPSBmdW5jdGlvbihhLGIsaCl7XG4gICAgdmFyIEdXID0gdGhpcy5jb21wdXRlR1coKSxcbiAgICAgICAgR3EgPSB0aGlzLmNvbXB1dGVHcSgpLFxuICAgICAgICBHaU1mID0gdGhpcy5jb21wdXRlR2lNZigpO1xuICAgIHJldHVybiAtIEdxICogYSAtIEdXICogYiAtIEdpTWYqaDtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgRypxLCB3aGVyZSBxIGFyZSB0aGUgZ2VuZXJhbGl6ZWQgYm9keSBjb29yZGluYXRlc1xuICogQG1ldGhvZCBjb21wdXRlR3FcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVHcSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBLFxuICAgICAgICBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QixcbiAgICAgICAgYmkgPSB0aGlzLmJpLFxuICAgICAgICBiaiA9IHRoaXMuYmosXG4gICAgICAgIHhpID0gYmkucG9zaXRpb24sXG4gICAgICAgIHhqID0gYmoucG9zaXRpb247XG4gICAgcmV0dXJuIEdBLnNwYXRpYWwuZG90KHhpKSArIEdCLnNwYXRpYWwuZG90KHhqKTtcbn07XG5cbnZhciB6ZXJvID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBDb21wdXRlcyBHKlcsIHdoZXJlIFcgYXJlIHRoZSBib2R5IHZlbG9jaXRpZXNcbiAqIEBtZXRob2QgY29tcHV0ZUdXXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlR1cgPSBmdW5jdGlvbigpe1xuICAgIHZhciBHQSA9IHRoaXMuamFjb2JpYW5FbGVtZW50QSxcbiAgICAgICAgR0IgPSB0aGlzLmphY29iaWFuRWxlbWVudEIsXG4gICAgICAgIGJpID0gdGhpcy5iaSxcbiAgICAgICAgYmogPSB0aGlzLmJqLFxuICAgICAgICB2aSA9IGJpLnZlbG9jaXR5LFxuICAgICAgICB2aiA9IGJqLnZlbG9jaXR5LFxuICAgICAgICB3aSA9IGJpLmFuZ3VsYXJWZWxvY2l0eSB8fCB6ZXJvLFxuICAgICAgICB3aiA9IGJqLmFuZ3VsYXJWZWxvY2l0eSB8fCB6ZXJvO1xuICAgIHJldHVybiBHQS5tdWx0aXBseVZlY3RvcnModmksd2kpICsgR0IubXVsdGlwbHlWZWN0b3JzKHZqLHdqKTtcbn07XG5cblxuLyoqXG4gKiBDb21wdXRlcyBHKldsYW1iZGEsIHdoZXJlIFcgYXJlIHRoZSBib2R5IHZlbG9jaXRpZXNcbiAqIEBtZXRob2QgY29tcHV0ZUdXbGFtYmRhXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlR1dsYW1iZGEgPSBmdW5jdGlvbigpe1xuICAgIHZhciBHQSA9IHRoaXMuamFjb2JpYW5FbGVtZW50QSxcbiAgICAgICAgR0IgPSB0aGlzLmphY29iaWFuRWxlbWVudEIsXG4gICAgICAgIGJpID0gdGhpcy5iaSxcbiAgICAgICAgYmogPSB0aGlzLmJqLFxuICAgICAgICB2aSA9IGJpLnZsYW1iZGEsXG4gICAgICAgIHZqID0gYmoudmxhbWJkYSxcbiAgICAgICAgd2kgPSBiaS53bGFtYmRhIHx8IHplcm8sXG4gICAgICAgIHdqID0gYmoud2xhbWJkYSB8fCB6ZXJvO1xuICAgIHJldHVybiBHQS5tdWx0aXBseVZlY3RvcnModmksd2kpICsgR0IubXVsdGlwbHlWZWN0b3JzKHZqLHdqKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgRyppbnYoTSkqZiwgd2hlcmUgTSBpcyB0aGUgbWFzcyBtYXRyaXggd2l0aCBkaWFnb25hbCBibG9ja3MgZm9yIGVhY2ggYm9keSwgYW5kIGYgYXJlIHRoZSBmb3JjZXMgb24gdGhlIGJvZGllcy5cbiAqIEBtZXRob2QgY29tcHV0ZUdpTWZcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xudmFyIGlNZmkgPSBuZXcgVmVjMygpLFxuICAgIGlNZmogPSBuZXcgVmVjMygpLFxuICAgIGludklpX3ZtdWx0X3RhdWkgPSBuZXcgVmVjMygpLFxuICAgIGludklqX3ZtdWx0X3RhdWogPSBuZXcgVmVjMygpO1xuRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVHaU1mID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgR0EgPSB0aGlzLmphY29iaWFuRWxlbWVudEEsXG4gICAgICAgIEdCID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRCLFxuICAgICAgICBiaSA9IHRoaXMuYmksXG4gICAgICAgIGJqID0gdGhpcy5iaixcbiAgICAgICAgZmkgPSBiaS5mb3JjZSxcbiAgICAgICAgdGkgPSBiaS50b3JxdWUsXG4gICAgICAgIGZqID0gYmouZm9yY2UsXG4gICAgICAgIHRqID0gYmoudG9ycXVlLFxuICAgICAgICBpbnZNYXNzaSA9IGJpLmludk1hc3NTb2x2ZSxcbiAgICAgICAgaW52TWFzc2ogPSBiai5pbnZNYXNzU29sdmU7XG5cbiAgICBpZihiaS5pbnZJbmVydGlhV29ybGRTb2x2ZSl7IGJpLmludkluZXJ0aWFXb3JsZFNvbHZlLnZtdWx0KHRpLGludklpX3ZtdWx0X3RhdWkpOyB9XG4gICAgZWxzZSB7IGludklpX3ZtdWx0X3RhdWkuc2V0KDAsMCwwKTsgfVxuICAgIGlmKGJqLmludkluZXJ0aWFXb3JsZFNvbHZlKXsgYmouaW52SW5lcnRpYVdvcmxkU29sdmUudm11bHQodGosaW52SWpfdm11bHRfdGF1aik7IH1cbiAgICBlbHNlIHsgaW52SWpfdm11bHRfdGF1ai5zZXQoMCwwLDApOyB9XG5cbiAgICBmaS5tdWx0KGludk1hc3NpLGlNZmkpO1xuICAgIGZqLm11bHQoaW52TWFzc2osaU1maik7XG5cbiAgICByZXR1cm4gR0EubXVsdGlwbHlWZWN0b3JzKGlNZmksaW52SWlfdm11bHRfdGF1aSkgKyBHQi5tdWx0aXBseVZlY3RvcnMoaU1maixpbnZJal92bXVsdF90YXVqKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgRyppbnYoTSkqRydcbiAqIEBtZXRob2QgY29tcHV0ZUdpTUd0XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbnZhciB0bXAgPSBuZXcgVmVjMygpO1xuRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVHaU1HdCA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBLFxuICAgICAgICBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QixcbiAgICAgICAgYmkgPSB0aGlzLmJpLFxuICAgICAgICBiaiA9IHRoaXMuYmosXG4gICAgICAgIGludk1hc3NpID0gYmkuaW52TWFzc1NvbHZlLFxuICAgICAgICBpbnZNYXNzaiA9IGJqLmludk1hc3NTb2x2ZSxcbiAgICAgICAgaW52SWkgPSBiaS5pbnZJbmVydGlhV29ybGRTb2x2ZSxcbiAgICAgICAgaW52SWogPSBiai5pbnZJbmVydGlhV29ybGRTb2x2ZSxcbiAgICAgICAgcmVzdWx0ID0gaW52TWFzc2kgKyBpbnZNYXNzajtcblxuICAgIGlmKGludklpKXtcbiAgICAgICAgaW52SWkudm11bHQoR0Eucm90YXRpb25hbCx0bXApO1xuICAgICAgICByZXN1bHQgKz0gdG1wLmRvdChHQS5yb3RhdGlvbmFsKTtcbiAgICB9XG5cbiAgICBpZihpbnZJail7XG4gICAgICAgIGludklqLnZtdWx0KEdCLnJvdGF0aW9uYWwsdG1wKTtcbiAgICAgICAgcmVzdWx0ICs9IHRtcC5kb3QoR0Iucm90YXRpb25hbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuICByZXN1bHQ7XG59O1xuXG52YXIgYWRkVG9XbGFtYmRhX3RlbXAgPSBuZXcgVmVjMygpLFxuICAgIGFkZFRvV2xhbWJkYV9HaSA9IG5ldyBWZWMzKCksXG4gICAgYWRkVG9XbGFtYmRhX0dqID0gbmV3IFZlYzMoKSxcbiAgICBhZGRUb1dsYW1iZGFfcmkgPSBuZXcgVmVjMygpLFxuICAgIGFkZFRvV2xhbWJkYV9yaiA9IG5ldyBWZWMzKCksXG4gICAgYWRkVG9XbGFtYmRhX01kaWFnID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBBZGQgY29uc3RyYWludCB2ZWxvY2l0eSB0byB0aGUgYm9kaWVzLlxuICogQG1ldGhvZCBhZGRUb1dsYW1iZGFcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YWxhbWJkYVxuICovXG5FcXVhdGlvbi5wcm90b3R5cGUuYWRkVG9XbGFtYmRhID0gZnVuY3Rpb24oZGVsdGFsYW1iZGEpe1xuICAgIHZhciBHQSA9IHRoaXMuamFjb2JpYW5FbGVtZW50QSxcbiAgICAgICAgR0IgPSB0aGlzLmphY29iaWFuRWxlbWVudEIsXG4gICAgICAgIGJpID0gdGhpcy5iaSxcbiAgICAgICAgYmogPSB0aGlzLmJqLFxuICAgICAgICB0ZW1wID0gYWRkVG9XbGFtYmRhX3RlbXA7XG5cbiAgICAvLyBBZGQgdG8gbGluZWFyIHZlbG9jaXR5XG4gICAgLy8gdl9sYW1iZGEgKz0gaW52KE0pICogZGVsdGFfbGFtYmEgKiBHXG4gICAgR0Euc3BhdGlhbC5tdWx0KGJpLmludk1hc3NTb2x2ZSAqIGRlbHRhbGFtYmRhLHRlbXApO1xuICAgIGJpLnZsYW1iZGEudmFkZCh0ZW1wLCBiaS52bGFtYmRhKTtcblxuICAgIEdCLnNwYXRpYWwubXVsdChiai5pbnZNYXNzU29sdmUgKiBkZWx0YWxhbWJkYSx0ZW1wKTtcbiAgICBiai52bGFtYmRhLnZhZGQodGVtcCwgYmoudmxhbWJkYSk7XG5cbiAgICAvLyBBZGQgdG8gYW5ndWxhciB2ZWxvY2l0eVxuICAgIGlmKGJpLmludkluZXJ0aWFXb3JsZFNvbHZlKXtcbiAgICAgICAgYmkuaW52SW5lcnRpYVdvcmxkU29sdmUudm11bHQoR0Eucm90YXRpb25hbCx0ZW1wKTtcbiAgICAgICAgdGVtcC5tdWx0KGRlbHRhbGFtYmRhLHRlbXApO1xuICAgICAgICBiaS53bGFtYmRhLnZhZGQodGVtcCxiaS53bGFtYmRhKTtcbiAgICB9XG5cbiAgICBpZihiai5pbnZJbmVydGlhV29ybGRTb2x2ZSl7XG4gICAgICAgIGJqLmludkluZXJ0aWFXb3JsZFNvbHZlLnZtdWx0KEdCLnJvdGF0aW9uYWwsdGVtcCk7XG4gICAgICAgIHRlbXAubXVsdChkZWx0YWxhbWJkYSx0ZW1wKTtcbiAgICAgICAgYmoud2xhbWJkYS52YWRkKHRlbXAsYmoud2xhbWJkYSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBkZW5vbWluYXRvciBwYXJ0IG9mIHRoZSBTUE9PSyBlcXVhdGlvbjogQyA9IEcqaW52KE0pKkcnICsgZXBzXG4gKiBAbWV0aG9kIGNvbXB1dGVJbnZDXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGVwc1xuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5FcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUMgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmNvbXB1dGVHaU1HdCgpICsgdGhpcy5lcHM7XG59O1xuXG59LHtcIi4uL21hdGgvSmFjb2JpYW5FbGVtZW50XCI6MjYsXCIuLi9tYXRoL1ZlYzNcIjozMH1dLDIxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gRnJpY3Rpb25FcXVhdGlvbjtcblxudmFyIEVxdWF0aW9uID0gX2RlcmVxXygnLi9FcXVhdGlvbicpO1xudmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcbnZhciBNYXQzID0gX2RlcmVxXygnLi4vbWF0aC9NYXQzJyk7XG5cbi8qKlxuICogQ29uc3RyYWlucyB0aGUgc2xpcHBpbmcgaW4gYSBjb250YWN0IGFsb25nIGEgdGFuZ2VudFxuICogQGNsYXNzIEZyaWN0aW9uRXF1YXRpb25cbiAqIEBjb25zdHJ1Y3RvclxuICogQGF1dGhvciBzY2h0ZXBwZVxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtOdW1iZXJ9IHNsaXBGb3JjZSBzaG91bGQgYmUgKy1GX2ZyaWN0aW9uID0gKy1tdSAqIEZfbm9ybWFsID0gKy1tdSAqIG0gKiBnXG4gKiBAZXh0ZW5kcyBFcXVhdGlvblxuICovXG5mdW5jdGlvbiBGcmljdGlvbkVxdWF0aW9uKGJvZHlBLCBib2R5Qiwgc2xpcEZvcmNlKXtcbiAgICBFcXVhdGlvbi5jYWxsKHRoaXMsYm9keUEsIGJvZHlCLCAtc2xpcEZvcmNlLCBzbGlwRm9yY2UpO1xuICAgIHRoaXMucmkgPSBuZXcgVmVjMygpO1xuICAgIHRoaXMucmogPSBuZXcgVmVjMygpO1xuICAgIHRoaXMudCA9IG5ldyBWZWMzKCk7IC8vIHRhbmdlbnRcbn1cblxuRnJpY3Rpb25FcXVhdGlvbi5wcm90b3R5cGUgPSBuZXcgRXF1YXRpb24oKTtcbkZyaWN0aW9uRXF1YXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRnJpY3Rpb25FcXVhdGlvbjtcblxudmFyIEZyaWN0aW9uRXF1YXRpb25fY29tcHV0ZUJfdGVtcDEgPSBuZXcgVmVjMygpO1xudmFyIEZyaWN0aW9uRXF1YXRpb25fY29tcHV0ZUJfdGVtcDIgPSBuZXcgVmVjMygpO1xuRnJpY3Rpb25FcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUIgPSBmdW5jdGlvbihoKXtcbiAgICB2YXIgYSA9IHRoaXMuYSxcbiAgICAgICAgYiA9IHRoaXMuYixcbiAgICAgICAgYmkgPSB0aGlzLmJpLFxuICAgICAgICBiaiA9IHRoaXMuYmosXG4gICAgICAgIHJpID0gdGhpcy5yaSxcbiAgICAgICAgcmogPSB0aGlzLnJqLFxuICAgICAgICByaXh0ID0gRnJpY3Rpb25FcXVhdGlvbl9jb21wdXRlQl90ZW1wMSxcbiAgICAgICAgcmp4dCA9IEZyaWN0aW9uRXF1YXRpb25fY29tcHV0ZUJfdGVtcDIsXG4gICAgICAgIHQgPSB0aGlzLnQ7XG5cbiAgICAvLyBDYWx1Y2xhdGUgY3Jvc3MgcHJvZHVjdHNcbiAgICByaS5jcm9zcyh0LHJpeHQpO1xuICAgIHJqLmNyb3NzKHQscmp4dCk7XG5cbiAgICAvLyBHID0gWy10IC1yaXh0IHQgcmp4dF1cbiAgICAvLyBBbmQgcmVtZW1iZXIsIHRoaXMgaXMgYSBwdXJlIHZlbG9jaXR5IGNvbnN0cmFpbnQsIGcgaXMgYWx3YXlzIHplcm8hXG4gICAgdmFyIEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBLFxuICAgICAgICBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QjtcbiAgICB0Lm5lZ2F0ZShHQS5zcGF0aWFsKTtcbiAgICByaXh0Lm5lZ2F0ZShHQS5yb3RhdGlvbmFsKTtcbiAgICBHQi5zcGF0aWFsLmNvcHkodCk7XG4gICAgR0Iucm90YXRpb25hbC5jb3B5KHJqeHQpO1xuXG4gICAgdmFyIEdXID0gdGhpcy5jb21wdXRlR1coKTtcbiAgICB2YXIgR2lNZiA9IHRoaXMuY29tcHV0ZUdpTWYoKTtcblxuICAgIHZhciBCID0gLSBHVyAqIGIgLSBoICogR2lNZjtcblxuICAgIHJldHVybiBCO1xufTtcblxufSx7XCIuLi9tYXRoL01hdDNcIjoyNyxcIi4uL21hdGgvVmVjM1wiOjMwLFwiLi9FcXVhdGlvblwiOjIwfV0sMjI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGlvbmFsRXF1YXRpb247XG5cbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XG52YXIgTWF0MyA9IF9kZXJlcV8oJy4uL21hdGgvTWF0MycpO1xudmFyIEVxdWF0aW9uID0gX2RlcmVxXygnLi9FcXVhdGlvbicpO1xuXG4vKipcbiAqIFJvdGF0aW9uYWwgY29uc3RyYWludC4gV29ya3MgdG8ga2VlcCB0aGUgbG9jYWwgdmVjdG9ycyBvcnRob2dvbmFsIHRvIGVhY2ggb3RoZXIgaW4gd29ybGQgc3BhY2UuXG4gKiBAY2xhc3MgUm90YXRpb25hbEVxdWF0aW9uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhdXRob3Igc2NodGVwcGVcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuYXhpc0FdXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmF4aXNCXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heEZvcmNlXVxuICogQGV4dGVuZHMgRXF1YXRpb25cbiAqL1xuZnVuY3Rpb24gUm90YXRpb25hbEVxdWF0aW9uKGJvZHlBLCBib2R5Qiwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIG1heEZvcmNlID0gdHlwZW9mKG9wdGlvbnMubWF4Rm9yY2UpICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMubWF4Rm9yY2UgOiAxZTY7XG5cbiAgICBFcXVhdGlvbi5jYWxsKHRoaXMsYm9keUEsYm9keUIsLW1heEZvcmNlLCBtYXhGb3JjZSk7XG5cbiAgICB0aGlzLmF4aXNBID0gb3B0aW9ucy5heGlzQSA/IG9wdGlvbnMuYXhpc0EuY2xvbmUoKSA6IG5ldyBWZWMzKDEsIDAsIDApO1xuICAgIHRoaXMuYXhpc0IgPSBvcHRpb25zLmF4aXNCID8gb3B0aW9ucy5heGlzQi5jbG9uZSgpIDogbmV3IFZlYzMoMCwgMSwgMCk7XG5cbiAgICB0aGlzLm1heEFuZ2xlID0gTWF0aC5QSSAvIDI7XG59XG5cblJvdGF0aW9uYWxFcXVhdGlvbi5wcm90b3R5cGUgPSBuZXcgRXF1YXRpb24oKTtcblJvdGF0aW9uYWxFcXVhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSb3RhdGlvbmFsRXF1YXRpb247XG5cbnZhciB0bXBWZWMxID0gbmV3IFZlYzMoKTtcbnZhciB0bXBWZWMyID0gbmV3IFZlYzMoKTtcblxuUm90YXRpb25hbEVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlQiA9IGZ1bmN0aW9uKGgpe1xuICAgIHZhciBhID0gdGhpcy5hLFxuICAgICAgICBiID0gdGhpcy5iLFxuXG4gICAgICAgIG5pID0gdGhpcy5heGlzQSxcbiAgICAgICAgbmogPSB0aGlzLmF4aXNCLFxuXG4gICAgICAgIG5peG5qID0gdG1wVmVjMSxcbiAgICAgICAgbmp4bmkgPSB0bXBWZWMyLFxuXG4gICAgICAgIEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBLFxuICAgICAgICBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QjtcblxuICAgIC8vIENhbHVjbGF0ZSBjcm9zcyBwcm9kdWN0c1xuICAgIG5pLmNyb3NzKG5qLCBuaXhuaik7XG4gICAgbmouY3Jvc3MobmksIG5qeG5pKTtcblxuICAgIC8vIGcgPSBuaSAqIG5qXG4gICAgLy8gZ2RvdCA9IChuaiB4IG5pKSAqIHdpICsgKG5pIHggbmopICogd2pcbiAgICAvLyBHID0gWzAgbmp4bmkgMCBuaXhual1cbiAgICAvLyBXID0gW3ZpIHdpIHZqIHdqXVxuICAgIEdBLnJvdGF0aW9uYWwuY29weShuanhuaSk7XG4gICAgR0Iucm90YXRpb25hbC5jb3B5KG5peG5qKTtcblxuICAgIHZhciBnID0gTWF0aC5jb3ModGhpcy5tYXhBbmdsZSkgLSBuaS5kb3QobmopLFxuICAgICAgICBHVyA9IHRoaXMuY29tcHV0ZUdXKCksXG4gICAgICAgIEdpTWYgPSB0aGlzLmNvbXB1dGVHaU1mKCk7XG5cbiAgICB2YXIgQiA9IC0gZyAqIGEgLSBHVyAqIGIgLSBoICogR2lNZjtcblxuICAgIHJldHVybiBCO1xufTtcblxuXG59LHtcIi4uL21hdGgvTWF0M1wiOjI3LFwiLi4vbWF0aC9WZWMzXCI6MzAsXCIuL0VxdWF0aW9uXCI6MjB9XSwyMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0aW9uYWxNb3RvckVxdWF0aW9uO1xuXG52YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xudmFyIE1hdDMgPSBfZGVyZXFfKCcuLi9tYXRoL01hdDMnKTtcbnZhciBFcXVhdGlvbiA9IF9kZXJlcV8oJy4vRXF1YXRpb24nKTtcblxuLyoqXG4gKiBSb3RhdGlvbmFsIG1vdG9yIGNvbnN0cmFpbnQuIFRyaWVzIHRvIGtlZXAgdGhlIHJlbGF0aXZlIGFuZ3VsYXIgdmVsb2NpdHkgb2YgdGhlIGJvZGllcyB0byBhIGdpdmVuIHZhbHVlLlxuICogQGNsYXNzIFJvdGF0aW9uYWxNb3RvckVxdWF0aW9uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhdXRob3Igc2NodGVwcGVcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhGb3JjZVxuICogQGV4dGVuZHMgRXF1YXRpb25cbiAqL1xuZnVuY3Rpb24gUm90YXRpb25hbE1vdG9yRXF1YXRpb24oYm9keUEsIGJvZHlCLCBtYXhGb3JjZSl7XG4gICAgbWF4Rm9yY2UgPSB0eXBlb2YobWF4Rm9yY2UpIT09J3VuZGVmaW5lZCcgPyBtYXhGb3JjZSA6IDFlNjtcbiAgICBFcXVhdGlvbi5jYWxsKHRoaXMsYm9keUEsYm9keUIsLW1heEZvcmNlLG1heEZvcmNlKTtcblxuICAgIC8qKlxuICAgICAqIFdvcmxkIG9yaWVudGVkIHJvdGF0aW9uYWwgYXhpc1xuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gYXhpc0FcbiAgICAgKi9cbiAgICB0aGlzLmF4aXNBID0gbmV3IFZlYzMoKTtcblxuICAgIC8qKlxuICAgICAqIFdvcmxkIG9yaWVudGVkIHJvdGF0aW9uYWwgYXhpc1xuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gYXhpc0JcbiAgICAgKi9cbiAgICB0aGlzLmF4aXNCID0gbmV3IFZlYzMoKTsgLy8gV29ybGQgb3JpZW50ZWQgcm90YXRpb25hbCBheGlzXG5cbiAgICAvKipcbiAgICAgKiBNb3RvciB2ZWxvY2l0eVxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB0YXJnZXRWZWxvY2l0eVxuICAgICAqL1xuICAgIHRoaXMudGFyZ2V0VmVsb2NpdHkgPSAwO1xufVxuXG5Sb3RhdGlvbmFsTW90b3JFcXVhdGlvbi5wcm90b3R5cGUgPSBuZXcgRXF1YXRpb24oKTtcblJvdGF0aW9uYWxNb3RvckVxdWF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJvdGF0aW9uYWxNb3RvckVxdWF0aW9uO1xuXG5Sb3RhdGlvbmFsTW90b3JFcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUIgPSBmdW5jdGlvbihoKXtcbiAgICB2YXIgYSA9IHRoaXMuYSxcbiAgICAgICAgYiA9IHRoaXMuYixcbiAgICAgICAgYmkgPSB0aGlzLmJpLFxuICAgICAgICBiaiA9IHRoaXMuYmosXG5cbiAgICAgICAgYXhpc0EgPSB0aGlzLmF4aXNBLFxuICAgICAgICBheGlzQiA9IHRoaXMuYXhpc0IsXG5cbiAgICAgICAgR0EgPSB0aGlzLmphY29iaWFuRWxlbWVudEEsXG4gICAgICAgIEdCID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRCO1xuXG4gICAgLy8gZyA9IDBcbiAgICAvLyBnZG90ID0gYXhpc0EgKiB3aSAtIGF4aXNCICogd2pcbiAgICAvLyBnZG90ID0gRyAqIFcgPSBHICogW3ZpIHdpIHZqIHdqXVxuICAgIC8vID0+XG4gICAgLy8gRyA9IFswIGF4aXNBIDAgLWF4aXNCXVxuXG4gICAgR0Eucm90YXRpb25hbC5jb3B5KGF4aXNBKTtcbiAgICBheGlzQi5uZWdhdGUoR0Iucm90YXRpb25hbCk7XG5cbiAgICB2YXIgR1cgPSB0aGlzLmNvbXB1dGVHVygpIC0gdGhpcy50YXJnZXRWZWxvY2l0eSxcbiAgICAgICAgR2lNZiA9IHRoaXMuY29tcHV0ZUdpTWYoKTtcblxuICAgIHZhciBCID0gLSBHVyAqIGIgLSBoICogR2lNZjtcblxuICAgIHJldHVybiBCO1xufTtcblxufSx7XCIuLi9tYXRoL01hdDNcIjoyNyxcIi4uL21hdGgvVmVjM1wiOjMwLFwiLi9FcXVhdGlvblwiOjIwfV0sMjQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb250YWN0TWF0ZXJpYWw7XG5cbi8qKlxuICogRGVmaW5lcyB3aGF0IGhhcHBlbnMgd2hlbiB0d28gbWF0ZXJpYWxzIG1lZXQuXG4gKiBAY2xhc3MgQ29udGFjdE1hdGVyaWFsXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7TWF0ZXJpYWx9IG0xXG4gKiBAcGFyYW0ge01hdGVyaWFsfSBtMlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmZyaWN0aW9uPTAuM11cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXN0aXR1dGlvbj0wLjNdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY29udGFjdEVxdWF0aW9uU3RpZmZuZXNzPTFlN11cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jb250YWN0RXF1YXRpb25SZWxheGF0aW9uPTNdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzcz0xZTddXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb249M11cbiAqL1xuZnVuY3Rpb24gQ29udGFjdE1hdGVyaWFsKG0xLCBtMiwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgICAgZnJpY3Rpb246IDAuMyxcbiAgICAgICAgcmVzdGl0dXRpb246IDAuMyxcbiAgICAgICAgY29udGFjdEVxdWF0aW9uU3RpZmZuZXNzOiAxZTcsXG4gICAgICAgIGNvbnRhY3RFcXVhdGlvblJlbGF4YXRpb246IDMsXG4gICAgICAgIGZyaWN0aW9uRXF1YXRpb25TdGlmZm5lc3M6IDFlNyxcbiAgICAgICAgZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb246IDNcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIElkZW50aWZpZXIgb2YgdGhpcyBtYXRlcmlhbFxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBpZFxuICAgICAqL1xuICAgIHRoaXMuaWQgPSBDb250YWN0TWF0ZXJpYWwuaWRDb3VudGVyKys7XG5cbiAgICAvKipcbiAgICAgKiBQYXJ0aWNpcGF0aW5nIG1hdGVyaWFsc1xuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IG1hdGVyaWFsc1xuICAgICAqIEB0b2RvICBTaG91bGQgYmUgLm1hdGVyaWFsQSBhbmQgLm1hdGVyaWFsQiBpbnN0ZWFkXG4gICAgICovXG4gICAgdGhpcy5tYXRlcmlhbHMgPSBbbTEsIG0yXTtcblxuICAgIC8qKlxuICAgICAqIEZyaWN0aW9uIGNvZWZmaWNpZW50XG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGZyaWN0aW9uXG4gICAgICovXG4gICAgdGhpcy5mcmljdGlvbiA9IG9wdGlvbnMuZnJpY3Rpb247XG5cbiAgICAvKipcbiAgICAgKiBSZXN0aXR1dGlvbiBjb2VmZmljaWVudFxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSByZXN0aXR1dGlvblxuICAgICAqL1xuICAgIHRoaXMucmVzdGl0dXRpb24gPSBvcHRpb25zLnJlc3RpdHV0aW9uO1xuXG4gICAgLyoqXG4gICAgICogU3RpZmZuZXNzIG9mIHRoZSBwcm9kdWNlZCBjb250YWN0IGVxdWF0aW9uc1xuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjb250YWN0RXF1YXRpb25TdGlmZm5lc3NcbiAgICAgKi9cbiAgICB0aGlzLmNvbnRhY3RFcXVhdGlvblN0aWZmbmVzcyA9IG9wdGlvbnMuY29udGFjdEVxdWF0aW9uU3RpZmZuZXNzO1xuXG4gICAgLyoqXG4gICAgICogUmVsYXhhdGlvbiB0aW1lIG9mIHRoZSBwcm9kdWNlZCBjb250YWN0IGVxdWF0aW9uc1xuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjb250YWN0RXF1YXRpb25SZWxheGF0aW9uXG4gICAgICovXG4gICAgdGhpcy5jb250YWN0RXF1YXRpb25SZWxheGF0aW9uID0gb3B0aW9ucy5jb250YWN0RXF1YXRpb25SZWxheGF0aW9uO1xuXG4gICAgLyoqXG4gICAgICogU3RpZmZuZXNzIG9mIHRoZSBwcm9kdWNlZCBmcmljdGlvbiBlcXVhdGlvbnNcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzc1xuICAgICAqL1xuICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzcyA9IG9wdGlvbnMuZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzcztcblxuICAgIC8qKlxuICAgICAqIFJlbGF4YXRpb24gdGltZSBvZiB0aGUgcHJvZHVjZWQgZnJpY3Rpb24gZXF1YXRpb25zXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGZyaWN0aW9uRXF1YXRpb25SZWxheGF0aW9uXG4gICAgICovXG4gICAgdGhpcy5mcmljdGlvbkVxdWF0aW9uUmVsYXhhdGlvbiA9IG9wdGlvbnMuZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb247XG59XG5cbkNvbnRhY3RNYXRlcmlhbC5pZENvdW50ZXIgPSAwO1xuXG59LHtcIi4uL3V0aWxzL1V0aWxzXCI6NTN9XSwyNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IE1hdGVyaWFsO1xuXG4vKipcbiAqIERlZmluZXMgYSBwaHlzaWNzIG1hdGVyaWFsLlxuICogQGNsYXNzIE1hdGVyaWFsXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEBhdXRob3Igc2NodGVwcGVcbiAqL1xuZnVuY3Rpb24gTWF0ZXJpYWwob3B0aW9ucyl7XG4gICAgdmFyIG5hbWUgPSAnJztcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZpeFxuICAgIGlmKHR5cGVvZihvcHRpb25zKSA9PT0gJ3N0cmluZycpe1xuICAgICAgICBuYW1lID0gb3B0aW9ucztcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH0gZWxzZSBpZih0eXBlb2Yob3B0aW9ucykgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG5hbWUgPSAnJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgbmFtZVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcblxuICAgIC8qKlxuICAgICAqIG1hdGVyaWFsIGlkLlxuICAgICAqIEBwcm9wZXJ0eSBpZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pZCA9IE1hdGVyaWFsLmlkQ291bnRlcisrO1xuXG4gICAgLyoqXG4gICAgICogRnJpY3Rpb24gZm9yIHRoaXMgbWF0ZXJpYWwuIElmIG5vbi1uZWdhdGl2ZSwgaXQgd2lsbCBiZSB1c2VkIGluc3RlYWQgb2YgdGhlIGZyaWN0aW9uIGdpdmVuIGJ5IENvbnRhY3RNYXRlcmlhbHMuIElmIHRoZXJlJ3Mgbm8gbWF0Y2hpbmcgQ29udGFjdE1hdGVyaWFsLCB0aGUgdmFsdWUgZnJvbSAuZGVmYXVsdENvbnRhY3RNYXRlcmlhbCBpbiB0aGUgV29ybGQgd2lsbCBiZSB1c2VkLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmcmljdGlvblxuICAgICAqL1xuICAgIHRoaXMuZnJpY3Rpb24gPSB0eXBlb2Yob3B0aW9ucy5mcmljdGlvbikgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5mcmljdGlvbiA6IC0xO1xuXG4gICAgLyoqXG4gICAgICogUmVzdGl0dXRpb24gZm9yIHRoaXMgbWF0ZXJpYWwuIElmIG5vbi1uZWdhdGl2ZSwgaXQgd2lsbCBiZSB1c2VkIGluc3RlYWQgb2YgdGhlIHJlc3RpdHV0aW9uIGdpdmVuIGJ5IENvbnRhY3RNYXRlcmlhbHMuIElmIHRoZXJlJ3Mgbm8gbWF0Y2hpbmcgQ29udGFjdE1hdGVyaWFsLCB0aGUgdmFsdWUgZnJvbSAuZGVmYXVsdENvbnRhY3RNYXRlcmlhbCBpbiB0aGUgV29ybGQgd2lsbCBiZSB1c2VkLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByZXN0aXR1dGlvblxuICAgICAqL1xuICAgIHRoaXMucmVzdGl0dXRpb24gPSB0eXBlb2Yob3B0aW9ucy5yZXN0aXR1dGlvbikgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5yZXN0aXR1dGlvbiA6IC0xO1xufVxuXG5NYXRlcmlhbC5pZENvdW50ZXIgPSAwO1xuXG59LHt9XSwyNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IEphY29iaWFuRWxlbWVudDtcblxudmFyIFZlYzMgPSBfZGVyZXFfKCcuL1ZlYzMnKTtcblxuLyoqXG4gKiBBbiBlbGVtZW50IGNvbnRhaW5pbmcgNiBlbnRyaWVzLCAzIHNwYXRpYWwgYW5kIDMgcm90YXRpb25hbCBkZWdyZWVzIG9mIGZyZWVkb20uXG4gKiBAY2xhc3MgSmFjb2JpYW5FbGVtZW50XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSmFjb2JpYW5FbGVtZW50KCl7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IHNwYXRpYWxcbiAgICAgKi9cbiAgICB0aGlzLnNwYXRpYWwgPSBuZXcgVmVjMygpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtWZWMzfSByb3RhdGlvbmFsXG4gICAgICovXG4gICAgdGhpcy5yb3RhdGlvbmFsID0gbmV3IFZlYzMoKTtcbn1cblxuLyoqXG4gKiBNdWx0aXBseSB3aXRoIG90aGVyIEphY29iaWFuRWxlbWVudFxuICogQG1ldGhvZCBtdWx0aXBseUVsZW1lbnRcbiAqIEBwYXJhbSAge0phY29iaWFuRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5KYWNvYmlhbkVsZW1lbnQucHJvdG90eXBlLm11bHRpcGx5RWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQpe1xuICAgIHJldHVybiBlbGVtZW50LnNwYXRpYWwuZG90KHRoaXMuc3BhdGlhbCkgKyBlbGVtZW50LnJvdGF0aW9uYWwuZG90KHRoaXMucm90YXRpb25hbCk7XG59O1xuXG4vKipcbiAqIE11bHRpcGx5IHdpdGggdHdvIHZlY3RvcnNcbiAqIEBtZXRob2QgbXVsdGlwbHlWZWN0b3JzXG4gKiBAcGFyYW0gIHtWZWMzfSBzcGF0aWFsXG4gKiBAcGFyYW0gIHtWZWMzfSByb3RhdGlvbmFsXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkphY29iaWFuRWxlbWVudC5wcm90b3R5cGUubXVsdGlwbHlWZWN0b3JzID0gZnVuY3Rpb24oc3BhdGlhbCxyb3RhdGlvbmFsKXtcbiAgICByZXR1cm4gc3BhdGlhbC5kb3QodGhpcy5zcGF0aWFsKSArIHJvdGF0aW9uYWwuZG90KHRoaXMucm90YXRpb25hbCk7XG59O1xuXG59LHtcIi4vVmVjM1wiOjMwfV0sMjc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBNYXQzO1xuXG52YXIgVmVjMyA9IF9kZXJlcV8oJy4vVmVjMycpO1xuXG4vKipcbiAqIEEgM3gzIG1hdHJpeC5cbiAqIEBjbGFzcyBNYXQzXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSBhcnJheSBlbGVtZW50cyBBcnJheSBvZiBuaW5lIGVsZW1lbnRzLiBPcHRpb25hbC5cbiAqIEBhdXRob3Igc2NodGVwcGUgLyBodHRwOi8vZ2l0aHViLmNvbS9zY2h0ZXBwZVxuICovXG5mdW5jdGlvbiBNYXQzKGVsZW1lbnRzKXtcbiAgICAvKipcbiAgICAgKiBBIHZlY3RvciBvZiBsZW5ndGggOSwgY29udGFpbmluZyBhbGwgbWF0cml4IGVsZW1lbnRzXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gZWxlbWVudHNcbiAgICAgKi9cbiAgICBpZihlbGVtZW50cyl7XG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVsZW1lbnRzID0gWzAsMCwwLDAsMCwwLDAsMCwwXTtcbiAgICB9XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbWF0cml4IHRvIGlkZW50aXR5XG4gKiBAbWV0aG9kIGlkZW50aXR5XG4gKiBAdG9kbyBTaG91bGQgcGVyaGFwcyBiZSByZW5hbWVkIHRvIHNldElkZW50aXR5KCkgdG8gYmUgbW9yZSBjbGVhci5cbiAqIEB0b2RvIENyZWF0ZSBhbm90aGVyIGZ1bmN0aW9uIHRoYXQgaW1tZWRpYXRlbHkgY3JlYXRlcyBhbiBpZGVudGl0eSBtYXRyaXggZWcuIGV5ZSgpXG4gKi9cbk1hdDMucHJvdG90eXBlLmlkZW50aXR5ID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgZVswXSA9IDE7XG4gICAgZVsxXSA9IDA7XG4gICAgZVsyXSA9IDA7XG5cbiAgICBlWzNdID0gMDtcbiAgICBlWzRdID0gMTtcbiAgICBlWzVdID0gMDtcblxuICAgIGVbNl0gPSAwO1xuICAgIGVbN10gPSAwO1xuICAgIGVbOF0gPSAxO1xufTtcblxuLyoqXG4gKiBTZXQgYWxsIGVsZW1lbnRzIHRvIHplcm9cbiAqIEBtZXRob2Qgc2V0WmVyb1xuICovXG5NYXQzLnByb3RvdHlwZS5zZXRaZXJvID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgZVswXSA9IDA7XG4gICAgZVsxXSA9IDA7XG4gICAgZVsyXSA9IDA7XG4gICAgZVszXSA9IDA7XG4gICAgZVs0XSA9IDA7XG4gICAgZVs1XSA9IDA7XG4gICAgZVs2XSA9IDA7XG4gICAgZVs3XSA9IDA7XG4gICAgZVs4XSA9IDA7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIG1hdHJpeCBkaWFnb25hbCBlbGVtZW50cyBmcm9tIGEgVmVjM1xuICogQG1ldGhvZCBzZXRUcmFjZVxuICogQHBhcmFtIHtWZWMzfSB2ZWMzXG4gKi9cbk1hdDMucHJvdG90eXBlLnNldFRyYWNlID0gZnVuY3Rpb24odmVjMyl7XG4gICAgdmFyIGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgIGVbMF0gPSB2ZWMzLng7XG4gICAgZVs0XSA9IHZlYzMueTtcbiAgICBlWzhdID0gdmVjMy56O1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXRyaXggZGlhZ29uYWwgZWxlbWVudHNcbiAqIEBtZXRob2QgZ2V0VHJhY2VcbiAqIEByZXR1cm4ge1ZlYzN9XG4gKi9cbk1hdDMucHJvdG90eXBlLmdldFRyYWNlID0gZnVuY3Rpb24odGFyZ2V0KXtcbiAgICB2YXIgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBWZWMzKCk7XG4gICAgdmFyIGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgIHRhcmdldC54ID0gZVswXTtcbiAgICB0YXJnZXQueSA9IGVbNF07XG4gICAgdGFyZ2V0LnogPSBlWzhdO1xufTtcblxuLyoqXG4gKiBNYXRyaXgtVmVjdG9yIG11bHRpcGxpY2F0aW9uXG4gKiBAbWV0aG9kIHZtdWx0XG4gKiBAcGFyYW0ge1ZlYzN9IHYgVGhlIHZlY3RvciB0byBtdWx0aXBseSB3aXRoXG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldCBPcHRpb25hbCwgdGFyZ2V0IHRvIHNhdmUgdGhlIHJlc3VsdCBpbi5cbiAqL1xuTWF0My5wcm90b3R5cGUudm11bHQgPSBmdW5jdGlvbih2LHRhcmdldCl7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBWZWMzKCk7XG5cbiAgICB2YXIgZSA9IHRoaXMuZWxlbWVudHMsXG4gICAgICAgIHggPSB2LngsXG4gICAgICAgIHkgPSB2LnksXG4gICAgICAgIHogPSB2Lno7XG4gICAgdGFyZ2V0LnggPSBlWzBdKnggKyBlWzFdKnkgKyBlWzJdKno7XG4gICAgdGFyZ2V0LnkgPSBlWzNdKnggKyBlWzRdKnkgKyBlWzVdKno7XG4gICAgdGFyZ2V0LnogPSBlWzZdKnggKyBlWzddKnkgKyBlWzhdKno7XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcblxuLyoqXG4gKiBNYXRyaXgtc2NhbGFyIG11bHRpcGxpY2F0aW9uXG4gKiBAbWV0aG9kIHNtdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gc1xuICovXG5NYXQzLnByb3RvdHlwZS5zbXVsdCA9IGZ1bmN0aW9uKHMpe1xuICAgIGZvcih2YXIgaT0wOyBpPHRoaXMuZWxlbWVudHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB0aGlzLmVsZW1lbnRzW2ldICo9IHM7XG4gICAgfVxufTtcblxuLyoqXG4gKiBNYXRyaXggbXVsdGlwbGljYXRpb25cbiAqIEBtZXRob2QgbW11bHRcbiAqIEBwYXJhbSB7TWF0M30gbSBNYXRyaXggdG8gbXVsdGlwbHkgd2l0aCBmcm9tIGxlZnQgc2lkZS5cbiAqIEByZXR1cm4ge01hdDN9IFRoZSByZXN1bHQuXG4gKi9cbk1hdDMucHJvdG90eXBlLm1tdWx0ID0gZnVuY3Rpb24obSx0YXJnZXQpe1xuICAgIHZhciByID0gdGFyZ2V0IHx8IG5ldyBNYXQzKCk7XG4gICAgZm9yKHZhciBpPTA7IGk8MzsgaSsrKXtcbiAgICAgICAgZm9yKHZhciBqPTA7IGo8MzsgaisrKXtcbiAgICAgICAgICAgIHZhciBzdW0gPSAwLjA7XG4gICAgICAgICAgICBmb3IodmFyIGs9MDsgazwzOyBrKyspe1xuICAgICAgICAgICAgICAgIHN1bSArPSBtLmVsZW1lbnRzW2krayozXSAqIHRoaXMuZWxlbWVudHNbaytqKjNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgci5lbGVtZW50c1tpK2oqM10gPSBzdW07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG59O1xuXG4vKipcbiAqIFNjYWxlIGVhY2ggY29sdW1uIG9mIHRoZSBtYXRyaXhcbiAqIEBtZXRob2Qgc2NhbGVcbiAqIEBwYXJhbSB7VmVjM30gdlxuICogQHJldHVybiB7TWF0M30gVGhlIHJlc3VsdC5cbiAqL1xuTWF0My5wcm90b3R5cGUuc2NhbGUgPSBmdW5jdGlvbih2LHRhcmdldCl7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBNYXQzKCk7XG4gICAgdmFyIGUgPSB0aGlzLmVsZW1lbnRzLFxuICAgICAgICB0ID0gdGFyZ2V0LmVsZW1lbnRzO1xuICAgIGZvcih2YXIgaT0wOyBpIT09MzsgaSsrKXtcbiAgICAgICAgdFszKmkgKyAwXSA9IHYueCAqIGVbMyppICsgMF07XG4gICAgICAgIHRbMyppICsgMV0gPSB2LnkgKiBlWzMqaSArIDFdO1xuICAgICAgICB0WzMqaSArIDJdID0gdi56ICogZVszKmkgKyAyXTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8qKlxuICogU29sdmUgQXg9YlxuICogQG1ldGhvZCBzb2x2ZVxuICogQHBhcmFtIHtWZWMzfSBiIFRoZSByaWdodCBoYW5kIHNpZGVcbiAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0IE9wdGlvbmFsLiBUYXJnZXQgdmVjdG9yIHRvIHNhdmUgaW4uXG4gKiBAcmV0dXJuIHtWZWMzfSBUaGUgc29sdXRpb24geFxuICogQHRvZG8gc2hvdWxkIHJldXNlIGFycmF5c1xuICovXG5NYXQzLnByb3RvdHlwZS5zb2x2ZSA9IGZ1bmN0aW9uKGIsdGFyZ2V0KXtcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IFZlYzMoKTtcblxuICAgIC8vIENvbnN0cnVjdCBlcXVhdGlvbnNcbiAgICB2YXIgbnIgPSAzOyAvLyBudW0gcm93c1xuICAgIHZhciBuYyA9IDQ7IC8vIG51bSBjb2xzXG4gICAgdmFyIGVxbnMgPSBbXTtcbiAgICBmb3IodmFyIGk9MDsgaTxucipuYzsgaSsrKXtcbiAgICAgICAgZXFucy5wdXNoKDApO1xuICAgIH1cbiAgICB2YXIgaSxqO1xuICAgIGZvcihpPTA7IGk8MzsgaSsrKXtcbiAgICAgICAgZm9yKGo9MDsgajwzOyBqKyspe1xuICAgICAgICAgICAgZXFuc1tpK25jKmpdID0gdGhpcy5lbGVtZW50c1tpKzMqal07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXFuc1szKzQqMF0gPSBiLng7XG4gICAgZXFuc1szKzQqMV0gPSBiLnk7XG4gICAgZXFuc1szKzQqMl0gPSBiLno7XG5cbiAgICAvLyBDb21wdXRlIHJpZ2h0IHVwcGVyIHRyaWFuZ3VsYXIgdmVyc2lvbiBvZiB0aGUgbWF0cml4IC0gR2F1c3MgZWxpbWluYXRpb25cbiAgICB2YXIgbiA9IDMsIGsgPSBuLCBucDtcbiAgICB2YXIga3AgPSA0OyAvLyBudW0gcm93c1xuICAgIHZhciBwLCBlbHM7XG4gICAgZG8ge1xuICAgICAgICBpID0gayAtIG47XG4gICAgICAgIGlmIChlcW5zW2krbmMqaV0gPT09IDApIHtcbiAgICAgICAgICAgIC8vIHRoZSBwaXZvdCBpcyBudWxsLCBzd2FwIGxpbmVzXG4gICAgICAgICAgICBmb3IgKGogPSBpICsgMTsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChlcW5zW2krbmMqal0gIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbnAgPSBrcDtcbiAgICAgICAgICAgICAgICAgICAgZG8geyAgLy8gZG8gbGlnbmUoIGkgKSA9IGxpZ25lKCBpICkgKyBsaWduZSggayApXG4gICAgICAgICAgICAgICAgICAgICAgICBwID0ga3AgLSBucDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVxbnNbcCtuYyppXSArPSBlcW5zW3ArbmMqal07XG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbnApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVxbnNbaStuYyppXSAhPT0gMCkge1xuICAgICAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbXVsdGlwbGllciA9IGVxbnNbaStuYypqXSAvIGVxbnNbaStuYyppXTtcbiAgICAgICAgICAgICAgICBucCA9IGtwO1xuICAgICAgICAgICAgICAgIGRvIHsgIC8vIGRvIGxpZ25lKCBrICkgPSBsaWduZSggayApIC0gbXVsdGlwbGllciAqIGxpZ25lKCBpIClcbiAgICAgICAgICAgICAgICAgICAgcCA9IGtwIC0gbnA7XG4gICAgICAgICAgICAgICAgICAgIGVxbnNbcCtuYypqXSA9IHAgPD0gaSA/IDAgOiBlcW5zW3ArbmMqal0gLSBlcW5zW3ArbmMqaV0gKiBtdWx0aXBsaWVyIDtcbiAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW5wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICAvLyBHZXQgdGhlIHNvbHV0aW9uXG4gICAgdGFyZ2V0LnogPSBlcW5zWzIqbmMrM10gLyBlcW5zWzIqbmMrMl07XG4gICAgdGFyZ2V0LnkgPSAoZXFuc1sxKm5jKzNdIC0gZXFuc1sxKm5jKzJdKnRhcmdldC56KSAvIGVxbnNbMSpuYysxXTtcbiAgICB0YXJnZXQueCA9IChlcW5zWzAqbmMrM10gLSBlcW5zWzAqbmMrMl0qdGFyZ2V0LnogLSBlcW5zWzAqbmMrMV0qdGFyZ2V0LnkpIC8gZXFuc1swKm5jKzBdO1xuXG4gICAgaWYoaXNOYU4odGFyZ2V0LngpIHx8IGlzTmFOKHRhcmdldC55KSB8fCBpc05hTih0YXJnZXQueikgfHwgdGFyZ2V0Lng9PT1JbmZpbml0eSB8fCB0YXJnZXQueT09PUluZmluaXR5IHx8IHRhcmdldC56PT09SW5maW5pdHkpe1xuICAgICAgICB0aHJvdyBcIkNvdWxkIG5vdCBzb2x2ZSBlcXVhdGlvbiEgR290IHg9W1wiK3RhcmdldC50b1N0cmluZygpK1wiXSwgYj1bXCIrYi50b1N0cmluZygpK1wiXSwgQT1bXCIrdGhpcy50b1N0cmluZygpK1wiXVwiO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIEdldCBhbiBlbGVtZW50IGluIHRoZSBtYXRyaXggYnkgaW5kZXguIEluZGV4IHN0YXJ0cyBhdCAwLCBub3QgMSEhIVxuICogQG1ldGhvZCBlXG4gKiBAcGFyYW0ge051bWJlcn0gcm93XG4gKiBAcGFyYW0ge051bWJlcn0gY29sdW1uXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgT3B0aW9uYWwuIElmIHByb3ZpZGVkLCB0aGUgbWF0cml4IGVsZW1lbnQgd2lsbCBiZSBzZXQgdG8gdGhpcyB2YWx1ZS5cbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuTWF0My5wcm90b3R5cGUuZSA9IGZ1bmN0aW9uKCByb3cgLCBjb2x1bW4gLHZhbHVlKXtcbiAgICBpZih2YWx1ZT09PXVuZGVmaW5lZCl7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRzW2NvbHVtbiszKnJvd107XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2V0IHZhbHVlXG4gICAgICAgIHRoaXMuZWxlbWVudHNbY29sdW1uKzMqcm93XSA9IHZhbHVlO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ29weSBhbm90aGVyIG1hdHJpeCBpbnRvIHRoaXMgbWF0cml4IG9iamVjdC5cbiAqIEBtZXRob2QgY29weVxuICogQHBhcmFtIHtNYXQzfSBzb3VyY2VcbiAqIEByZXR1cm4ge01hdDN9IHRoaXNcbiAqL1xuTWF0My5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKHNvdXJjZSl7XG4gICAgZm9yKHZhciBpPTA7IGkgPCBzb3VyY2UuZWxlbWVudHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB0aGlzLmVsZW1lbnRzW2ldID0gc291cmNlLmVsZW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4LlxuICogQG1ldGhvZCB0b1N0cmluZ1xuICogQHJldHVybiBzdHJpbmdcbiAqL1xuTWF0My5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpe1xuICAgIHZhciByID0gXCJcIjtcbiAgICB2YXIgc2VwID0gXCIsXCI7XG4gICAgZm9yKHZhciBpPTA7IGk8OTsgaSsrKXtcbiAgICAgICAgciArPSB0aGlzLmVsZW1lbnRzW2ldICsgc2VwO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbn07XG5cbi8qKlxuICogcmV2ZXJzZSB0aGUgbWF0cml4XG4gKiBAbWV0aG9kIHJldmVyc2VcbiAqIEBwYXJhbSB7TWF0M30gdGFyZ2V0IE9wdGlvbmFsLiBUYXJnZXQgbWF0cml4IHRvIHNhdmUgaW4uXG4gKiBAcmV0dXJuIHtNYXQzfSBUaGUgc29sdXRpb24geFxuICovXG5NYXQzLnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24odGFyZ2V0KXtcblxuICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgTWF0MygpO1xuXG4gICAgLy8gQ29uc3RydWN0IGVxdWF0aW9uc1xuICAgIHZhciBuciA9IDM7IC8vIG51bSByb3dzXG4gICAgdmFyIG5jID0gNjsgLy8gbnVtIGNvbHNcbiAgICB2YXIgZXFucyA9IFtdO1xuICAgIGZvcih2YXIgaT0wOyBpPG5yKm5jOyBpKyspe1xuICAgICAgICBlcW5zLnB1c2goMCk7XG4gICAgfVxuICAgIHZhciBpLGo7XG4gICAgZm9yKGk9MDsgaTwzOyBpKyspe1xuICAgICAgICBmb3Ioaj0wOyBqPDM7IGorKyl7XG4gICAgICAgICAgICBlcW5zW2krbmMqal0gPSB0aGlzLmVsZW1lbnRzW2krMypqXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlcW5zWzMrNiowXSA9IDE7XG4gICAgZXFuc1szKzYqMV0gPSAwO1xuICAgIGVxbnNbMys2KjJdID0gMDtcbiAgICBlcW5zWzQrNiowXSA9IDA7XG4gICAgZXFuc1s0KzYqMV0gPSAxO1xuICAgIGVxbnNbNCs2KjJdID0gMDtcbiAgICBlcW5zWzUrNiowXSA9IDA7XG4gICAgZXFuc1s1KzYqMV0gPSAwO1xuICAgIGVxbnNbNSs2KjJdID0gMTtcblxuICAgIC8vIENvbXB1dGUgcmlnaHQgdXBwZXIgdHJpYW5ndWxhciB2ZXJzaW9uIG9mIHRoZSBtYXRyaXggLSBHYXVzcyBlbGltaW5hdGlvblxuICAgIHZhciBuID0gMywgayA9IG4sIG5wO1xuICAgIHZhciBrcCA9IG5jOyAvLyBudW0gcm93c1xuICAgIHZhciBwO1xuICAgIGRvIHtcbiAgICAgICAgaSA9IGsgLSBuO1xuICAgICAgICBpZiAoZXFuc1tpK25jKmldID09PSAwKSB7XG4gICAgICAgICAgICAvLyB0aGUgcGl2b3QgaXMgbnVsbCwgc3dhcCBsaW5lc1xuICAgICAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZXFuc1tpK25jKmpdICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5wID0ga3A7XG4gICAgICAgICAgICAgICAgICAgIGRvIHsgLy8gZG8gbGluZSggaSApID0gbGluZSggaSApICsgbGluZSggayApXG4gICAgICAgICAgICAgICAgICAgICAgICBwID0ga3AgLSBucDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVxbnNbcCtuYyppXSArPSBlcW5zW3ArbmMqal07XG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbnApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVxbnNbaStuYyppXSAhPT0gMCkge1xuICAgICAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbXVsdGlwbGllciA9IGVxbnNbaStuYypqXSAvIGVxbnNbaStuYyppXTtcbiAgICAgICAgICAgICAgICBucCA9IGtwO1xuICAgICAgICAgICAgICAgIGRvIHsgLy8gZG8gbGluZSggayApID0gbGluZSggayApIC0gbXVsdGlwbGllciAqIGxpbmUoIGkgKVxuICAgICAgICAgICAgICAgICAgICBwID0ga3AgLSBucDtcbiAgICAgICAgICAgICAgICAgICAgZXFuc1twK25jKmpdID0gcCA8PSBpID8gMCA6IGVxbnNbcCtuYypqXSAtIGVxbnNbcCtuYyppXSAqIG11bHRpcGxpZXIgO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbnApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSB3aGlsZSAoLS1uKTtcblxuICAgIC8vIGVsaW1pbmF0ZSB0aGUgdXBwZXIgbGVmdCB0cmlhbmdsZSBvZiB0aGUgbWF0cml4XG4gICAgaSA9IDI7XG4gICAgZG8ge1xuICAgICAgICBqID0gaS0xO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICB2YXIgbXVsdGlwbGllciA9IGVxbnNbaStuYypqXSAvIGVxbnNbaStuYyppXTtcbiAgICAgICAgICAgIG5wID0gbmM7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgcCA9IG5jIC0gbnA7XG4gICAgICAgICAgICAgICAgZXFuc1twK25jKmpdID0gIGVxbnNbcCtuYypqXSAtIGVxbnNbcCtuYyppXSAqIG11bHRpcGxpZXIgO1xuICAgICAgICAgICAgfSB3aGlsZSAoLS1ucCk7XG4gICAgICAgIH0gd2hpbGUgKGotLSk7XG4gICAgfSB3aGlsZSAoLS1pKTtcblxuICAgIC8vIG9wZXJhdGlvbnMgb24gdGhlIGRpYWdvbmFsXG4gICAgaSA9IDI7XG4gICAgZG8ge1xuICAgICAgICB2YXIgbXVsdGlwbGllciA9IDEgLyBlcW5zW2krbmMqaV07XG4gICAgICAgIG5wID0gbmM7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHAgPSBuYyAtIG5wO1xuICAgICAgICAgICAgZXFuc1twK25jKmldID0gZXFuc1twK25jKmldICogbXVsdGlwbGllciA7XG4gICAgICAgIH0gd2hpbGUgKC0tbnApO1xuICAgIH0gd2hpbGUgKGktLSk7XG5cbiAgICBpID0gMjtcbiAgICBkbyB7XG4gICAgICAgIGogPSAyO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBwID0gZXFuc1tucitqK25jKmldO1xuICAgICAgICAgICAgaWYoIGlzTmFOKCBwICkgfHwgcCA9PT1JbmZpbml0eSApe1xuICAgICAgICAgICAgICAgIHRocm93IFwiQ291bGQgbm90IHJldmVyc2UhIEE9W1wiK3RoaXMudG9TdHJpbmcoKStcIl1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldC5lKCBpICwgaiAsIHAgKTtcbiAgICAgICAgfSB3aGlsZSAoai0tKTtcbiAgICB9IHdoaWxlIChpLS0pO1xuXG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtYXRyaXggZnJvbSBhIHF1YXRlcmlvblxuICogQG1ldGhvZCBzZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHFcbiAqL1xuTWF0My5wcm90b3R5cGUuc2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbiA9IGZ1bmN0aW9uKCBxICkge1xuICAgIHZhciB4ID0gcS54LCB5ID0gcS55LCB6ID0gcS56LCB3ID0gcS53LFxuICAgICAgICB4MiA9IHggKyB4LCB5MiA9IHkgKyB5LCB6MiA9IHogKyB6LFxuICAgICAgICB4eCA9IHggKiB4MiwgeHkgPSB4ICogeTIsIHh6ID0geCAqIHoyLFxuICAgICAgICB5eSA9IHkgKiB5MiwgeXogPSB5ICogejIsIHp6ID0geiAqIHoyLFxuICAgICAgICB3eCA9IHcgKiB4Miwgd3kgPSB3ICogeTIsIHd6ID0gdyAqIHoyLFxuICAgICAgICBlID0gdGhpcy5lbGVtZW50cztcblxuICAgIGVbMyowICsgMF0gPSAxIC0gKCB5eSArIHp6ICk7XG4gICAgZVszKjAgKyAxXSA9IHh5IC0gd3o7XG4gICAgZVszKjAgKyAyXSA9IHh6ICsgd3k7XG5cbiAgICBlWzMqMSArIDBdID0geHkgKyB3ejtcbiAgICBlWzMqMSArIDFdID0gMSAtICggeHggKyB6eiApO1xuICAgIGVbMyoxICsgMl0gPSB5eiAtIHd4O1xuXG4gICAgZVszKjIgKyAwXSA9IHh6IC0gd3k7XG4gICAgZVszKjIgKyAxXSA9IHl6ICsgd3g7XG4gICAgZVszKjIgKyAyXSA9IDEgLSAoIHh4ICsgeXkgKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBUcmFuc3Bvc2UgdGhlIG1hdHJpeFxuICogQG1ldGhvZCB0cmFuc3Bvc2VcbiAqIEBwYXJhbSAge01hdDN9IHRhcmdldCBXaGVyZSB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICogQHJldHVybiB7TWF0M30gVGhlIHRhcmdldCBNYXQzLCBvciBhIG5ldyBNYXQzIGlmIHRhcmdldCB3YXMgb21pdHRlZC5cbiAqL1xuTWF0My5wcm90b3R5cGUudHJhbnNwb3NlID0gZnVuY3Rpb24oIHRhcmdldCApIHtcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IE1hdDMoKTtcblxuICAgIHZhciBNdCA9IHRhcmdldC5lbGVtZW50cyxcbiAgICAgICAgTSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICBmb3IodmFyIGk9MDsgaSE9PTM7IGkrKyl7XG4gICAgICAgIGZvcih2YXIgaj0wOyBqIT09MzsgaisrKXtcbiAgICAgICAgICAgIE10WzMqaSArIGpdID0gTVszKmogKyBpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG59LHtcIi4vVmVjM1wiOjMwfV0sMjg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBRdWF0ZXJuaW9uO1xuXG52YXIgVmVjMyA9IF9kZXJlcV8oJy4vVmVjMycpO1xuXG4vKipcbiAqIEEgUXVhdGVybmlvbiBkZXNjcmliZXMgYSByb3RhdGlvbiBpbiAzRCBzcGFjZS4gVGhlIFF1YXRlcm5pb24gaXMgbWF0aGVtYXRpY2FsbHkgZGVmaW5lZCBhcyBRID0geCppICsgeSpqICsgeiprICsgdywgd2hlcmUgKGksaixrKSBhcmUgaW1hZ2luYXJ5IGJhc2lzIHZlY3RvcnMuICh4LHkseikgY2FuIGJlIHNlZW4gYXMgYSB2ZWN0b3IgcmVsYXRlZCB0byB0aGUgYXhpcyBvZiByb3RhdGlvbiwgd2hpbGUgdGhlIHJlYWwgbXVsdGlwbGllciwgdywgaXMgcmVsYXRlZCB0byB0aGUgYW1vdW50IG9mIHJvdGF0aW9uLlxuICogQGNsYXNzIFF1YXRlcm5pb25cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggTXVsdGlwbGllciBvZiB0aGUgaW1hZ2luYXJ5IGJhc2lzIHZlY3RvciBpLlxuICogQHBhcmFtIHtOdW1iZXJ9IHkgTXVsdGlwbGllciBvZiB0aGUgaW1hZ2luYXJ5IGJhc2lzIHZlY3RvciBqLlxuICogQHBhcmFtIHtOdW1iZXJ9IHogTXVsdGlwbGllciBvZiB0aGUgaW1hZ2luYXJ5IGJhc2lzIHZlY3RvciBrLlxuICogQHBhcmFtIHtOdW1iZXJ9IHcgTXVsdGlwbGllciBvZiB0aGUgcmVhbCBwYXJ0LlxuICogQHNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1F1YXRlcm5pb25cbiAqL1xuZnVuY3Rpb24gUXVhdGVybmlvbih4LHkseix3KXtcbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0geFxuICAgICAqL1xuICAgIHRoaXMueCA9IHghPT11bmRlZmluZWQgPyB4IDogMDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB5XG4gICAgICovXG4gICAgdGhpcy55ID0geSE9PXVuZGVmaW5lZCA/IHkgOiAwO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHpcbiAgICAgKi9cbiAgICB0aGlzLnogPSB6IT09dW5kZWZpbmVkID8geiA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbXVsdGlwbGllciBvZiB0aGUgcmVhbCBxdWF0ZXJuaW9uIGJhc2lzIHZlY3Rvci5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gd1xuICAgICAqL1xuICAgIHRoaXMudyA9IHchPT11bmRlZmluZWQgPyB3IDogMTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIHRoZSBxdWF0ZXJuaW9uLlxuICogQG1ldGhvZCBzZXRcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHBhcmFtIHtOdW1iZXJ9IHpcbiAqIEBwYXJhbSB7TnVtYmVyfSB3XG4gKi9cblF1YXRlcm5pb24ucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKHgseSx6LHcpe1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLnogPSB6O1xuICAgIHRoaXMudyA9IHc7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgdG8gYSByZWFkYWJsZSBmb3JtYXRcbiAqIEBtZXRob2QgdG9TdHJpbmdcbiAqIEByZXR1cm4gc3RyaW5nXG4gKi9cblF1YXRlcm5pb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy54K1wiLFwiK3RoaXMueStcIixcIit0aGlzLnorXCIsXCIrdGhpcy53O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHRvIGFuIEFycmF5XG4gKiBAbWV0aG9kIHRvQXJyYXlcbiAqIEByZXR1cm4gQXJyYXlcbiAqL1xuUXVhdGVybmlvbi5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIFt0aGlzLngsIHRoaXMueSwgdGhpcy56LCB0aGlzLnddO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHF1YXRlcm5pb24gY29tcG9uZW50cyBnaXZlbiBhbiBheGlzIGFuZCBhbiBhbmdsZS5cbiAqIEBtZXRob2Qgc2V0RnJvbUF4aXNBbmdsZVxuICogQHBhcmFtIHtWZWMzfSBheGlzXG4gKiBAcGFyYW0ge051bWJlcn0gYW5nbGUgaW4gcmFkaWFuc1xuICovXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5zZXRGcm9tQXhpc0FuZ2xlID0gZnVuY3Rpb24oYXhpcyxhbmdsZSl7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihhbmdsZSowLjUpO1xuICAgIHRoaXMueCA9IGF4aXMueCAqIHM7XG4gICAgdGhpcy55ID0gYXhpcy55ICogcztcbiAgICB0aGlzLnogPSBheGlzLnogKiBzO1xuICAgIHRoaXMudyA9IE1hdGguY29zKGFuZ2xlKjAuNSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBxdWF0ZXJuaW9uIHRvIGF4aXMvYW5nbGUgcmVwcmVzZW50YXRpb24uXG4gKiBAbWV0aG9kIHRvQXhpc0FuZ2xlXG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldEF4aXMgT3B0aW9uYWwuIEEgdmVjdG9yIG9iamVjdCB0byByZXVzZSBmb3Igc3RvcmluZyB0aGUgYXhpcy5cbiAqIEByZXR1cm4gQXJyYXkgQW4gYXJyYXksIGZpcnN0IGVsZW1udCBpcyB0aGUgYXhpcyBhbmQgdGhlIHNlY29uZCBpcyB0aGUgYW5nbGUgaW4gcmFkaWFucy5cbiAqL1xuUXVhdGVybmlvbi5wcm90b3R5cGUudG9BeGlzQW5nbGUgPSBmdW5jdGlvbih0YXJnZXRBeGlzKXtcbiAgICB0YXJnZXRBeGlzID0gdGFyZ2V0QXhpcyB8fCBuZXcgVmVjMygpO1xuICAgIHRoaXMubm9ybWFsaXplKCk7IC8vIGlmIHc+MSBhY29zIGFuZCBzcXJ0IHdpbGwgcHJvZHVjZSBlcnJvcnMsIHRoaXMgY2FudCBoYXBwZW4gaWYgcXVhdGVybmlvbiBpcyBub3JtYWxpc2VkXG4gICAgdmFyIGFuZ2xlID0gMiAqIE1hdGguYWNvcyh0aGlzLncpO1xuICAgIHZhciBzID0gTWF0aC5zcXJ0KDEtdGhpcy53KnRoaXMudyk7IC8vIGFzc3VtaW5nIHF1YXRlcm5pb24gbm9ybWFsaXNlZCB0aGVuIHcgaXMgbGVzcyB0aGFuIDEsIHNvIHRlcm0gYWx3YXlzIHBvc2l0aXZlLlxuICAgIGlmIChzIDwgMC4wMDEpIHsgLy8gdGVzdCB0byBhdm9pZCBkaXZpZGUgYnkgemVybywgcyBpcyBhbHdheXMgcG9zaXRpdmUgZHVlIHRvIHNxcnRcbiAgICAgICAgLy8gaWYgcyBjbG9zZSB0byB6ZXJvIHRoZW4gZGlyZWN0aW9uIG9mIGF4aXMgbm90IGltcG9ydGFudFxuICAgICAgICB0YXJnZXRBeGlzLnggPSB0aGlzLng7IC8vIGlmIGl0IGlzIGltcG9ydGFudCB0aGF0IGF4aXMgaXMgbm9ybWFsaXNlZCB0aGVuIHJlcGxhY2Ugd2l0aCB4PTE7IHk9ej0wO1xuICAgICAgICB0YXJnZXRBeGlzLnkgPSB0aGlzLnk7XG4gICAgICAgIHRhcmdldEF4aXMueiA9IHRoaXMuejtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRBeGlzLnggPSB0aGlzLnggLyBzOyAvLyBub3JtYWxpc2UgYXhpc1xuICAgICAgICB0YXJnZXRBeGlzLnkgPSB0aGlzLnkgLyBzO1xuICAgICAgICB0YXJnZXRBeGlzLnogPSB0aGlzLnogLyBzO1xuICAgIH1cbiAgICByZXR1cm4gW3RhcmdldEF4aXMsYW5nbGVdO1xufTtcblxudmFyIHNmdl90MSA9IG5ldyBWZWMzKCksXG4gICAgc2Z2X3QyID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBTZXQgdGhlIHF1YXRlcm5pb24gdmFsdWUgZ2l2ZW4gdHdvIHZlY3RvcnMuIFRoZSByZXN1bHRpbmcgcm90YXRpb24gd2lsbCBiZSB0aGUgbmVlZGVkIHJvdGF0aW9uIHRvIHJvdGF0ZSB1IHRvIHYuXG4gKiBAbWV0aG9kIHNldEZyb21WZWN0b3JzXG4gKiBAcGFyYW0ge1ZlYzN9IHVcbiAqIEBwYXJhbSB7VmVjM30gdlxuICovXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5zZXRGcm9tVmVjdG9ycyA9IGZ1bmN0aW9uKHUsdil7XG4gICAgaWYodS5pc0FudGlwYXJhbGxlbFRvKHYpKXtcbiAgICAgICAgdmFyIHQxID0gc2Z2X3QxO1xuICAgICAgICB2YXIgdDIgPSBzZnZfdDI7XG5cbiAgICAgICAgdS50YW5nZW50cyh0MSx0Mik7XG4gICAgICAgIHRoaXMuc2V0RnJvbUF4aXNBbmdsZSh0MSxNYXRoLlBJKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYSA9IHUuY3Jvc3Modik7XG4gICAgICAgIHRoaXMueCA9IGEueDtcbiAgICAgICAgdGhpcy55ID0gYS55O1xuICAgICAgICB0aGlzLnogPSBhLno7XG4gICAgICAgIHRoaXMudyA9IE1hdGguc3FydChNYXRoLnBvdyh1Lm5vcm0oKSwyKSAqIE1hdGgucG93KHYubm9ybSgpLDIpKSArIHUuZG90KHYpO1xuICAgICAgICB0aGlzLm5vcm1hbGl6ZSgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUXVhdGVybmlvbiBtdWx0aXBsaWNhdGlvblxuICogQG1ldGhvZCBtdWx0XG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHFcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gdGFyZ2V0IE9wdGlvbmFsLlxuICogQHJldHVybiB7UXVhdGVybmlvbn1cbiAqL1xudmFyIFF1YXRlcm5pb25fbXVsdF92YSA9IG5ldyBWZWMzKCk7XG52YXIgUXVhdGVybmlvbl9tdWx0X3ZiID0gbmV3IFZlYzMoKTtcbnZhciBRdWF0ZXJuaW9uX211bHRfdmF4dmIgPSBuZXcgVmVjMygpO1xuUXVhdGVybmlvbi5wcm90b3R5cGUubXVsdCA9IGZ1bmN0aW9uKHEsdGFyZ2V0KXtcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IFF1YXRlcm5pb24oKTtcbiAgICB2YXIgdyA9IHRoaXMudyxcbiAgICAgICAgdmEgPSBRdWF0ZXJuaW9uX211bHRfdmEsXG4gICAgICAgIHZiID0gUXVhdGVybmlvbl9tdWx0X3ZiLFxuICAgICAgICB2YXh2YiA9IFF1YXRlcm5pb25fbXVsdF92YXh2YjtcblxuICAgIHZhLnNldCh0aGlzLngsdGhpcy55LHRoaXMueik7XG4gICAgdmIuc2V0KHEueCxxLnkscS56KTtcbiAgICB0YXJnZXQudyA9IHcqcS53IC0gdmEuZG90KHZiKTtcbiAgICB2YS5jcm9zcyh2Yix2YXh2Yik7XG5cbiAgICB0YXJnZXQueCA9IHcgKiB2Yi54ICsgcS53KnZhLnggKyB2YXh2Yi54O1xuICAgIHRhcmdldC55ID0gdyAqIHZiLnkgKyBxLncqdmEueSArIHZheHZiLnk7XG4gICAgdGFyZ2V0LnogPSB3ICogdmIueiArIHEudyp2YS56ICsgdmF4dmIuejtcblxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgaW52ZXJzZSBxdWF0ZXJuaW9uIHJvdGF0aW9uLlxuICogQG1ldGhvZCBpbnZlcnNlXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHRhcmdldFxuICogQHJldHVybiB7UXVhdGVybmlvbn1cbiAqL1xuUXVhdGVybmlvbi5wcm90b3R5cGUuaW52ZXJzZSA9IGZ1bmN0aW9uKHRhcmdldCl7XG4gICAgdmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLnosIHcgPSB0aGlzLnc7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBRdWF0ZXJuaW9uKCk7XG5cbiAgICB0aGlzLmNvbmp1Z2F0ZSh0YXJnZXQpO1xuICAgIHZhciBpbm9ybTIgPSAxLyh4KnggKyB5KnkgKyB6KnogKyB3KncpO1xuICAgIHRhcmdldC54ICo9IGlub3JtMjtcbiAgICB0YXJnZXQueSAqPSBpbm9ybTI7XG4gICAgdGFyZ2V0LnogKj0gaW5vcm0yO1xuICAgIHRhcmdldC53ICo9IGlub3JtMjtcblxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgcXVhdGVybmlvbiBjb25qdWdhdGVcbiAqIEBtZXRob2QgY29uanVnYXRlXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHRhcmdldFxuICogQHJldHVybiB7UXVhdGVybmlvbn1cbiAqL1xuUXVhdGVybmlvbi5wcm90b3R5cGUuY29uanVnYXRlID0gZnVuY3Rpb24odGFyZ2V0KXtcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IFF1YXRlcm5pb24oKTtcblxuICAgIHRhcmdldC54ID0gLXRoaXMueDtcbiAgICB0YXJnZXQueSA9IC10aGlzLnk7XG4gICAgdGFyZ2V0LnogPSAtdGhpcy56O1xuICAgIHRhcmdldC53ID0gdGhpcy53O1xuXG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIHRoZSBxdWF0ZXJuaW9uLiBOb3RlIHRoYXQgdGhpcyBjaGFuZ2VzIHRoZSB2YWx1ZXMgb2YgdGhlIHF1YXRlcm5pb24uXG4gKiBAbWV0aG9kIG5vcm1hbGl6ZVxuICovXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBsID0gTWF0aC5zcXJ0KHRoaXMueCp0aGlzLngrdGhpcy55KnRoaXMueSt0aGlzLnoqdGhpcy56K3RoaXMudyp0aGlzLncpO1xuICAgIGlmICggbCA9PT0gMCApIHtcbiAgICAgICAgdGhpcy54ID0gMDtcbiAgICAgICAgdGhpcy55ID0gMDtcbiAgICAgICAgdGhpcy56ID0gMDtcbiAgICAgICAgdGhpcy53ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsID0gMSAvIGw7XG4gICAgICAgIHRoaXMueCAqPSBsO1xuICAgICAgICB0aGlzLnkgKj0gbDtcbiAgICAgICAgdGhpcy56ICo9IGw7XG4gICAgICAgIHRoaXMudyAqPSBsO1xuICAgIH1cbn07XG5cbi8qKlxuICogQXBwcm94aW1hdGlvbiBvZiBxdWF0ZXJuaW9uIG5vcm1hbGl6YXRpb24uIFdvcmtzIGJlc3Qgd2hlbiBxdWF0IGlzIGFscmVhZHkgYWxtb3N0LW5vcm1hbGl6ZWQuXG4gKiBAbWV0aG9kIG5vcm1hbGl6ZUZhc3RcbiAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vZmFzdC1xdWF0ZXJuaW9uLW5vcm1hbGl6YXRpb25cbiAqIEBhdXRob3IgdW5waGFzZWQsIGh0dHBzOi8vZ2l0aHViLmNvbS91bnBoYXNlZFxuICovXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5ub3JtYWxpemVGYXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmID0gKDMuMC0odGhpcy54KnRoaXMueCt0aGlzLnkqdGhpcy55K3RoaXMueip0aGlzLnordGhpcy53KnRoaXMudykpLzIuMDtcbiAgICBpZiAoIGYgPT09IDAgKSB7XG4gICAgICAgIHRoaXMueCA9IDA7XG4gICAgICAgIHRoaXMueSA9IDA7XG4gICAgICAgIHRoaXMueiA9IDA7XG4gICAgICAgIHRoaXMudyA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy54ICo9IGY7XG4gICAgICAgIHRoaXMueSAqPSBmO1xuICAgICAgICB0aGlzLnogKj0gZjtcbiAgICAgICAgdGhpcy53ICo9IGY7XG4gICAgfVxufTtcblxuLyoqXG4gKiBNdWx0aXBseSB0aGUgcXVhdGVybmlvbiBieSBhIHZlY3RvclxuICogQG1ldGhvZCB2bXVsdFxuICogQHBhcmFtIHtWZWMzfSB2XG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldCBPcHRpb25hbFxuICogQHJldHVybiB7VmVjM31cbiAqL1xuUXVhdGVybmlvbi5wcm90b3R5cGUudm11bHQgPSBmdW5jdGlvbih2LHRhcmdldCl7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBWZWMzKCk7XG5cbiAgICB2YXIgeCA9IHYueCxcbiAgICAgICAgeSA9IHYueSxcbiAgICAgICAgeiA9IHYuejtcblxuICAgIHZhciBxeCA9IHRoaXMueCxcbiAgICAgICAgcXkgPSB0aGlzLnksXG4gICAgICAgIHF6ID0gdGhpcy56LFxuICAgICAgICBxdyA9IHRoaXMudztcblxuICAgIC8vIHEqdlxuICAgIHZhciBpeCA9ICBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHksXG4gICAgaXkgPSAgcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6LFxuICAgIGl6ID0gIHF3ICogeiArIHF4ICogeSAtIHF5ICogeCxcbiAgICBpdyA9IC1xeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7XG5cbiAgICB0YXJnZXQueCA9IGl4ICogcXcgKyBpdyAqIC1xeCArIGl5ICogLXF6IC0gaXogKiAtcXk7XG4gICAgdGFyZ2V0LnkgPSBpeSAqIHF3ICsgaXcgKiAtcXkgKyBpeiAqIC1xeCAtIGl4ICogLXF6O1xuICAgIHRhcmdldC56ID0gaXogKiBxdyArIGl3ICogLXF6ICsgaXggKiAtcXkgLSBpeSAqIC1xeDtcblxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIENvcGllcyB2YWx1ZSBvZiBzb3VyY2UgdG8gdGhpcyBxdWF0ZXJuaW9uLlxuICogQG1ldGhvZCBjb3B5XG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHNvdXJjZVxuICogQHJldHVybiB7UXVhdGVybmlvbn0gdGhpc1xuICovXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oc291cmNlKXtcbiAgICB0aGlzLnggPSBzb3VyY2UueDtcbiAgICB0aGlzLnkgPSBzb3VyY2UueTtcbiAgICB0aGlzLnogPSBzb3VyY2UuejtcbiAgICB0aGlzLncgPSBzb3VyY2UudztcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29udmVydCB0aGUgcXVhdGVybmlvbiB0byBldWxlciBhbmdsZSByZXByZXNlbnRhdGlvbi4gT3JkZXI6IFlaWCwgYXMgdGhpcyBwYWdlIGRlc2NyaWJlczogaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvc3RhbmRhcmRzL2luZGV4Lmh0bVxuICogQG1ldGhvZCB0b0V1bGVyXG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldFxuICogQHBhcmFtIHN0cmluZyBvcmRlciBUaHJlZS1jaGFyYWN0ZXIgc3RyaW5nIGUuZy4gXCJZWlhcIiwgd2hpY2ggYWxzbyBpcyBkZWZhdWx0LlxuICovXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS50b0V1bGVyID0gZnVuY3Rpb24odGFyZ2V0LG9yZGVyKXtcbiAgICBvcmRlciA9IG9yZGVyIHx8IFwiWVpYXCI7XG5cbiAgICB2YXIgaGVhZGluZywgYXR0aXR1ZGUsIGJhbms7XG4gICAgdmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLnosIHcgPSB0aGlzLnc7XG5cbiAgICBzd2l0Y2gob3JkZXIpe1xuICAgIGNhc2UgXCJZWlhcIjpcbiAgICAgICAgdmFyIHRlc3QgPSB4KnkgKyB6Knc7XG4gICAgICAgIGlmICh0ZXN0ID4gMC40OTkpIHsgLy8gc2luZ3VsYXJpdHkgYXQgbm9ydGggcG9sZVxuICAgICAgICAgICAgaGVhZGluZyA9IDIgKiBNYXRoLmF0YW4yKHgsdyk7XG4gICAgICAgICAgICBhdHRpdHVkZSA9IE1hdGguUEkvMjtcbiAgICAgICAgICAgIGJhbmsgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXN0IDwgLTAuNDk5KSB7IC8vIHNpbmd1bGFyaXR5IGF0IHNvdXRoIHBvbGVcbiAgICAgICAgICAgIGhlYWRpbmcgPSAtMiAqIE1hdGguYXRhbjIoeCx3KTtcbiAgICAgICAgICAgIGF0dGl0dWRlID0gLSBNYXRoLlBJLzI7XG4gICAgICAgICAgICBiYW5rID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZihpc05hTihoZWFkaW5nKSl7XG4gICAgICAgICAgICB2YXIgc3F4ID0geCp4O1xuICAgICAgICAgICAgdmFyIHNxeSA9IHkqeTtcbiAgICAgICAgICAgIHZhciBzcXogPSB6Kno7XG4gICAgICAgICAgICBoZWFkaW5nID0gTWF0aC5hdGFuMigyKnkqdyAtIDIqeCp6ICwgMSAtIDIqc3F5IC0gMipzcXopOyAvLyBIZWFkaW5nXG4gICAgICAgICAgICBhdHRpdHVkZSA9IE1hdGguYXNpbigyKnRlc3QpOyAvLyBhdHRpdHVkZVxuICAgICAgICAgICAgYmFuayA9IE1hdGguYXRhbjIoMip4KncgLSAyKnkqeiAsIDEgLSAyKnNxeCAtIDIqc3F6KTsgLy8gYmFua1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV1bGVyIG9yZGVyIFwiK29yZGVyK1wiIG5vdCBzdXBwb3J0ZWQgeWV0LlwiKTtcbiAgICB9XG5cbiAgICB0YXJnZXQueSA9IGhlYWRpbmc7XG4gICAgdGFyZ2V0LnogPSBhdHRpdHVkZTtcbiAgICB0YXJnZXQueCA9IGJhbms7XG59O1xuXG4vKipcbiAqIFNlZSBodHRwOi8vd3d3Lm1hdGh3b3Jrcy5jb20vbWF0bGFiY2VudHJhbC9maWxlZXhjaGFuZ2UvMjA2OTYtZnVuY3Rpb24tdG8tY29udmVydC1iZXR3ZWVuLWRjbS1ldWxlci1hbmdsZXMtcXVhdGVybmlvbnMtYW5kLWV1bGVyLXZlY3RvcnMvY29udGVudC9TcGluQ2FsYy5tXG4gKiBAbWV0aG9kIHNldEZyb21FdWxlclxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcGFyYW0ge051bWJlcn0gelxuICogQHBhcmFtIHtTdHJpbmd9IG9yZGVyIFRoZSBvcmRlciB0byBhcHBseSBhbmdsZXM6ICdYWVonIG9yICdZWFonIG9yIGFueSBvdGhlciBjb21iaW5hdGlvblxuICovXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5zZXRGcm9tRXVsZXIgPSBmdW5jdGlvbiAoIHgsIHksIHosIG9yZGVyICkge1xuICAgIG9yZGVyID0gb3JkZXIgfHwgXCJYWVpcIjtcblxuICAgIHZhciBjMSA9IE1hdGguY29zKCB4IC8gMiApO1xuICAgIHZhciBjMiA9IE1hdGguY29zKCB5IC8gMiApO1xuICAgIHZhciBjMyA9IE1hdGguY29zKCB6IC8gMiApO1xuICAgIHZhciBzMSA9IE1hdGguc2luKCB4IC8gMiApO1xuICAgIHZhciBzMiA9IE1hdGguc2luKCB5IC8gMiApO1xuICAgIHZhciBzMyA9IE1hdGguc2luKCB6IC8gMiApO1xuXG4gICAgaWYgKCBvcmRlciA9PT0gJ1hZWicgKSB7XG5cbiAgICAgICAgdGhpcy54ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuICAgICAgICB0aGlzLnkgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XG4gICAgICAgIHRoaXMueiA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMztcbiAgICAgICAgdGhpcy53ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXG4gICAgfSBlbHNlIGlmICggb3JkZXIgPT09ICdZWFonICkge1xuXG4gICAgICAgIHRoaXMueCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcbiAgICAgICAgdGhpcy55ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xuICAgICAgICB0aGlzLnogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG4gICAgICAgIHRoaXMudyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcblxuICAgIH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWlhZJyApIHtcblxuICAgICAgICB0aGlzLnggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XG4gICAgICAgIHRoaXMueSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcbiAgICAgICAgdGhpcy56ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuICAgICAgICB0aGlzLncgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XG5cbiAgICB9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pZWCcgKSB7XG5cbiAgICAgICAgdGhpcy54ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuICAgICAgICB0aGlzLnkgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XG4gICAgICAgIHRoaXMueiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcbiAgICAgICAgdGhpcy53ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXG4gICAgfSBlbHNlIGlmICggb3JkZXIgPT09ICdZWlgnICkge1xuXG4gICAgICAgIHRoaXMueCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcbiAgICAgICAgdGhpcy55ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xuICAgICAgICB0aGlzLnogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG4gICAgICAgIHRoaXMudyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcblxuICAgIH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWFpZJyApIHtcblxuICAgICAgICB0aGlzLnggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XG4gICAgICAgIHRoaXMueSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcbiAgICAgICAgdGhpcy56ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuICAgICAgICB0aGlzLncgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcblxufTtcblxuUXVhdGVybmlvbi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiBuZXcgUXVhdGVybmlvbih0aGlzLngsIHRoaXMueSwgdGhpcy56LCB0aGlzLncpO1xufTtcbn0se1wiLi9WZWMzXCI6MzB9XSwyOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgVmVjMyA9IF9kZXJlcV8oJy4vVmVjMycpO1xudmFyIFF1YXRlcm5pb24gPSBfZGVyZXFfKCcuL1F1YXRlcm5pb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbi8qKlxuICogQGNsYXNzIFRyYW5zZm9ybVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB7VmVjM30gcG9zaXRpb25cblx0ICovXG5cdHRoaXMucG9zaXRpb24gPSBuZXcgVmVjMygpO1xuICAgIGlmKG9wdGlvbnMucG9zaXRpb24pe1xuICAgICAgICB0aGlzLnBvc2l0aW9uLmNvcHkob3B0aW9ucy5wb3NpdGlvbik7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkge1F1YXRlcm5pb259IHF1YXRlcm5pb25cblx0ICovXG5cdHRoaXMucXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG4gICAgaWYob3B0aW9ucy5xdWF0ZXJuaW9uKXtcbiAgICAgICAgdGhpcy5xdWF0ZXJuaW9uLmNvcHkob3B0aW9ucy5xdWF0ZXJuaW9uKTtcbiAgICB9XG59XG5cbnZhciB0bXBRdWF0ID0gbmV3IFF1YXRlcm5pb24oKTtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIHBvaW50VG9Mb2NhRnJhbWVcbiAqIEBwYXJhbSB7VmVjM30gcG9zaXRpb25cbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcXVhdGVybmlvblxuICogQHBhcmFtIHtWZWMzfSB3b3JsZFBvaW50XG4gKiBAcGFyYW0ge1ZlYzN9IHJlc3VsdFxuICovXG5UcmFuc2Zvcm0ucG9pbnRUb0xvY2FsRnJhbWUgPSBmdW5jdGlvbihwb3NpdGlvbiwgcXVhdGVybmlvbiwgd29ybGRQb2ludCwgcmVzdWx0KXtcbiAgICB2YXIgcmVzdWx0ID0gcmVzdWx0IHx8IG5ldyBWZWMzKCk7XG4gICAgd29ybGRQb2ludC52c3ViKHBvc2l0aW9uLCByZXN1bHQpO1xuICAgIHF1YXRlcm5pb24uY29uanVnYXRlKHRtcFF1YXQpO1xuICAgIHRtcFF1YXQudm11bHQocmVzdWx0LCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEdldCBhIGdsb2JhbCBwb2ludCBpbiBsb2NhbCB0cmFuc2Zvcm0gY29vcmRpbmF0ZXMuXG4gKiBAbWV0aG9kIHBvaW50VG9Mb2NhbFxuICogQHBhcmFtICB7VmVjM30gcG9pbnRcbiAqIEBwYXJhbSAge1ZlYzN9IHJlc3VsdFxuICogQHJldHVybiB7VmVjM30gVGhlIFwicmVzdWx0XCIgdmVjdG9yIG9iamVjdFxuICovXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnBvaW50VG9Mb2NhbCA9IGZ1bmN0aW9uKHdvcmxkUG9pbnQsIHJlc3VsdCl7XG4gICAgcmV0dXJuIFRyYW5zZm9ybS5wb2ludFRvTG9jYWxGcmFtZSh0aGlzLnBvc2l0aW9uLCB0aGlzLnF1YXRlcm5pb24sIHdvcmxkUG9pbnQsIHJlc3VsdCk7XG59O1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgcG9pbnRUb1dvcmxkRnJhbWVcbiAqIEBwYXJhbSB7VmVjM30gcG9zaXRpb25cbiAqIEBwYXJhbSB7VmVjM30gcXVhdGVybmlvblxuICogQHBhcmFtIHtWZWMzfSBsb2NhbFBvaW50XG4gKiBAcGFyYW0ge1ZlYzN9IHJlc3VsdFxuICovXG5UcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUgPSBmdW5jdGlvbihwb3NpdGlvbiwgcXVhdGVybmlvbiwgbG9jYWxQb2ludCwgcmVzdWx0KXtcbiAgICB2YXIgcmVzdWx0ID0gcmVzdWx0IHx8IG5ldyBWZWMzKCk7XG4gICAgcXVhdGVybmlvbi52bXVsdChsb2NhbFBvaW50LCByZXN1bHQpO1xuICAgIHJlc3VsdC52YWRkKHBvc2l0aW9uLCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEdldCBhIGxvY2FsIHBvaW50IGluIGdsb2JhbCB0cmFuc2Zvcm0gY29vcmRpbmF0ZXMuXG4gKiBAbWV0aG9kIHBvaW50VG9Xb3JsZFxuICogQHBhcmFtICB7VmVjM30gcG9pbnRcbiAqIEBwYXJhbSAge1ZlYzN9IHJlc3VsdFxuICogQHJldHVybiB7VmVjM30gVGhlIFwicmVzdWx0XCIgdmVjdG9yIG9iamVjdFxuICovXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnBvaW50VG9Xb3JsZCA9IGZ1bmN0aW9uKGxvY2FsUG9pbnQsIHJlc3VsdCl7XG4gICAgcmV0dXJuIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZSh0aGlzLnBvc2l0aW9uLCB0aGlzLnF1YXRlcm5pb24sIGxvY2FsUG9pbnQsIHJlc3VsdCk7XG59O1xuXG5cblRyYW5zZm9ybS5wcm90b3R5cGUudmVjdG9yVG9Xb3JsZEZyYW1lID0gZnVuY3Rpb24obG9jYWxWZWN0b3IsIHJlc3VsdCl7XG4gICAgdmFyIHJlc3VsdCA9IHJlc3VsdCB8fCBuZXcgVmVjMygpO1xuICAgIHRoaXMucXVhdGVybmlvbi52bXVsdChsb2NhbFZlY3RvciwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuVHJhbnNmb3JtLnZlY3RvclRvV29ybGRGcmFtZSA9IGZ1bmN0aW9uKHF1YXRlcm5pb24sIGxvY2FsVmVjdG9yLCByZXN1bHQpe1xuICAgIHF1YXRlcm5pb24udm11bHQobG9jYWxWZWN0b3IsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblRyYW5zZm9ybS52ZWN0b3JUb0xvY2FsRnJhbWUgPSBmdW5jdGlvbihwb3NpdGlvbiwgcXVhdGVybmlvbiwgd29ybGRWZWN0b3IsIHJlc3VsdCl7XG4gICAgdmFyIHJlc3VsdCA9IHJlc3VsdCB8fCBuZXcgVmVjMygpO1xuICAgIHF1YXRlcm5pb24udyAqPSAtMTtcbiAgICBxdWF0ZXJuaW9uLnZtdWx0KHdvcmxkVmVjdG9yLCByZXN1bHQpO1xuICAgIHF1YXRlcm5pb24udyAqPSAtMTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxufSx7XCIuL1F1YXRlcm5pb25cIjoyOCxcIi4vVmVjM1wiOjMwfV0sMzA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBWZWMzO1xuXG52YXIgTWF0MyA9IF9kZXJlcV8oJy4vTWF0MycpO1xuXG4vKipcbiAqIDMtZGltZW5zaW9uYWwgdmVjdG9yXG4gKiBAY2xhc3MgVmVjM1xuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEBwYXJhbSB7TnVtYmVyfSB6XG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciB2ID0gbmV3IFZlYzMoMSwgMiwgMyk7XG4gKiAgICAgY29uc29sZS5sb2coJ3g9JyArIHYueCk7IC8vIHg9MVxuICovXG5mdW5jdGlvbiBWZWMzKHgseSx6KXtcbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgeFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy54ID0geHx8MC4wO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHlcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMueSA9IHl8fDAuMDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB6XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnogPSB6fHwwLjA7XG59XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtWZWMzfSBaRVJPXG4gKi9cblZlYzMuWkVSTyA9IG5ldyBWZWMzKDAsIDAsIDApO1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7VmVjM30gVU5JVF9YXG4gKi9cblZlYzMuVU5JVF9YID0gbmV3IFZlYzMoMSwgMCwgMCk7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtWZWMzfSBVTklUX1lcbiAqL1xuVmVjMy5VTklUX1kgPSBuZXcgVmVjMygwLCAxLCAwKTtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge1ZlYzN9IFVOSVRfWlxuICovXG5WZWMzLlVOSVRfWiA9IG5ldyBWZWMzKDAsIDAsIDEpO1xuXG4vKipcbiAqIFZlY3RvciBjcm9zcyBwcm9kdWN0XG4gKiBAbWV0aG9kIGNyb3NzXG4gKiBAcGFyYW0ge1ZlYzN9IHZcbiAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0IE9wdGlvbmFsLiBUYXJnZXQgdG8gc2F2ZSBpbi5cbiAqIEByZXR1cm4ge1ZlYzN9XG4gKi9cblZlYzMucHJvdG90eXBlLmNyb3NzID0gZnVuY3Rpb24odix0YXJnZXQpe1xuICAgIHZhciB2eD12LngsIHZ5PXYueSwgdno9di56LCB4PXRoaXMueCwgeT10aGlzLnksIHo9dGhpcy56O1xuICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgVmVjMygpO1xuXG4gICAgdGFyZ2V0LnggPSAoeSAqIHZ6KSAtICh6ICogdnkpO1xuICAgIHRhcmdldC55ID0gKHogKiB2eCkgLSAoeCAqIHZ6KTtcbiAgICB0YXJnZXQueiA9ICh4ICogdnkpIC0gKHkgKiB2eCk7XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHZlY3RvcnMnIDMgZWxlbWVudHNcbiAqIEBtZXRob2Qgc2V0XG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEBwYXJhbSB7TnVtYmVyfSB6XG4gKiBAcmV0dXJuIFZlYzNcbiAqL1xuVmVjMy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oeCx5LHope1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLnogPSB6O1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgYWxsIGNvbXBvbmVudHMgb2YgdGhlIHZlY3RvciB0byB6ZXJvLlxuICogQG1ldGhvZCBzZXRaZXJvXG4gKi9cblZlYzMucHJvdG90eXBlLnNldFplcm8gPSBmdW5jdGlvbigpe1xuICAgIHRoaXMueCA9IHRoaXMueSA9IHRoaXMueiA9IDA7XG59O1xuXG4vKipcbiAqIFZlY3RvciBhZGRpdGlvblxuICogQG1ldGhvZCB2YWRkXG4gKiBAcGFyYW0ge1ZlYzN9IHZcbiAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0IE9wdGlvbmFsLlxuICogQHJldHVybiB7VmVjM31cbiAqL1xuVmVjMy5wcm90b3R5cGUudmFkZCA9IGZ1bmN0aW9uKHYsdGFyZ2V0KXtcbiAgICBpZih0YXJnZXQpe1xuICAgICAgICB0YXJnZXQueCA9IHYueCArIHRoaXMueDtcbiAgICAgICAgdGFyZ2V0LnkgPSB2LnkgKyB0aGlzLnk7XG4gICAgICAgIHRhcmdldC56ID0gdi56ICsgdGhpcy56O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjMyh0aGlzLnggKyB2LngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55ICsgdi55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueiArIHYueik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBWZWN0b3Igc3VidHJhY3Rpb25cbiAqIEBtZXRob2QgdnN1YlxuICogQHBhcmFtIHtWZWMzfSB2XG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldCBPcHRpb25hbC4gVGFyZ2V0IHRvIHNhdmUgaW4uXG4gKiBAcmV0dXJuIHtWZWMzfVxuICovXG5WZWMzLnByb3RvdHlwZS52c3ViID0gZnVuY3Rpb24odix0YXJnZXQpe1xuICAgIGlmKHRhcmdldCl7XG4gICAgICAgIHRhcmdldC54ID0gdGhpcy54IC0gdi54O1xuICAgICAgICB0YXJnZXQueSA9IHRoaXMueSAtIHYueTtcbiAgICAgICAgdGFyZ2V0LnogPSB0aGlzLnogLSB2Lno7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMzKHRoaXMueC12LngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55LXYueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnotdi56KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY3Jvc3MgcHJvZHVjdCBtYXRyaXggYV9jcm9zcyBmcm9tIGEgdmVjdG9yLCBzdWNoIHRoYXQgYSB4IGIgPSBhX2Nyb3NzICogYiA9IGNcbiAqIEBtZXRob2QgY3Jvc3NtYXRcbiAqIEBzZWUgaHR0cDovL3d3dzguY3MudW11LnNlL2t1cnNlci9UREJEMjQvVlQwNi9sZWN0dXJlcy9MZWN0dXJlNi5wZGZcbiAqIEByZXR1cm4ge01hdDN9XG4gKi9cblZlYzMucHJvdG90eXBlLmNyb3NzbWF0ID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gbmV3IE1hdDMoWyAgICAgMCwgIC10aGlzLnosICAgdGhpcy55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueiwgICAgICAgIDAsICAtdGhpcy54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgLXRoaXMueSwgICB0aGlzLngsICAgICAgICAwXSk7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgdmVjdG9yLiBOb3RlIHRoYXQgdGhpcyBjaGFuZ2VzIHRoZSB2YWx1ZXMgaW4gdGhlIHZlY3Rvci5cbiAqIEBtZXRob2Qgbm9ybWFsaXplXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFJldHVybnMgdGhlIG5vcm0gb2YgdGhlIHZlY3RvclxuICovXG5WZWMzLnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbigpe1xuICAgIHZhciB4PXRoaXMueCwgeT10aGlzLnksIHo9dGhpcy56O1xuICAgIHZhciBuID0gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeik7XG4gICAgaWYobj4wLjApe1xuICAgICAgICB2YXIgaW52TiA9IDEvbjtcbiAgICAgICAgdGhpcy54ICo9IGludk47XG4gICAgICAgIHRoaXMueSAqPSBpbnZOO1xuICAgICAgICB0aGlzLnogKj0gaW52TjtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBNYWtlIHNvbWV0aGluZyB1cFxuICAgICAgICB0aGlzLnggPSAwO1xuICAgICAgICB0aGlzLnkgPSAwO1xuICAgICAgICB0aGlzLnogPSAwO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbn07XG5cbi8qKlxuICogR2V0IHRoZSB2ZXJzaW9uIG9mIHRoaXMgdmVjdG9yIHRoYXQgaXMgb2YgbGVuZ3RoIDEuXG4gKiBAbWV0aG9kIHVuaXRcbiAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0IE9wdGlvbmFsIHRhcmdldCB0byBzYXZlIGluXG4gKiBAcmV0dXJuIHtWZWMzfSBSZXR1cm5zIHRoZSB1bml0IHZlY3RvclxuICovXG5WZWMzLnByb3RvdHlwZS51bml0ID0gZnVuY3Rpb24odGFyZ2V0KXtcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IFZlYzMoKTtcbiAgICB2YXIgeD10aGlzLngsIHk9dGhpcy55LCB6PXRoaXMuejtcbiAgICB2YXIgbmludiA9IE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnopO1xuICAgIGlmKG5pbnY+MC4wKXtcbiAgICAgICAgbmludiA9IDEuMC9uaW52O1xuICAgICAgICB0YXJnZXQueCA9IHggKiBuaW52O1xuICAgICAgICB0YXJnZXQueSA9IHkgKiBuaW52O1xuICAgICAgICB0YXJnZXQueiA9IHogKiBuaW52O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldC54ID0gMTtcbiAgICAgICAgdGFyZ2V0LnkgPSAwO1xuICAgICAgICB0YXJnZXQueiA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbGVuZ3RoIG9mIHRoZSB2ZWN0b3JcbiAqIEBtZXRob2Qgbm9ybVxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGRlcHJlY2F0ZWQgVXNlIC5sZW5ndGgoKSBpbnN0ZWFkXG4gKi9cblZlYzMucHJvdG90eXBlLm5vcm0gPSBmdW5jdGlvbigpe1xuICAgIHZhciB4PXRoaXMueCwgeT10aGlzLnksIHo9dGhpcy56O1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6KTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBsZW5ndGggb2YgdGhlIHZlY3RvclxuICogQG1ldGhvZCBsZW5ndGhcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuVmVjMy5wcm90b3R5cGUubGVuZ3RoID0gVmVjMy5wcm90b3R5cGUubm9ybTtcblxuLyoqXG4gKiBHZXQgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIHRoZSB2ZWN0b3JcbiAqIEBtZXRob2Qgbm9ybTJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBkZXByZWNhdGVkIFVzZSAubGVuZ3RoU3F1YXJlZCgpIGluc3RlYWQuXG4gKi9cblZlYzMucHJvdG90eXBlLm5vcm0yID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5kb3QodGhpcyk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgc3F1YXJlZCBsZW5ndGggb2YgdGhlIHZlY3Rvci5cbiAqIEBtZXRob2QgbGVuZ3RoU3F1YXJlZFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5WZWMzLnByb3RvdHlwZS5sZW5ndGhTcXVhcmVkID0gVmVjMy5wcm90b3R5cGUubm9ybTI7XG5cbi8qKlxuICogR2V0IGRpc3RhbmNlIGZyb20gdGhpcyBwb2ludCB0byBhbm90aGVyIHBvaW50XG4gKiBAbWV0aG9kIGRpc3RhbmNlVG9cbiAqIEBwYXJhbSAge1ZlYzN9IHBcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuVmVjMy5wcm90b3R5cGUuZGlzdGFuY2VUbyA9IGZ1bmN0aW9uKHApe1xuICAgIHZhciB4PXRoaXMueCwgeT10aGlzLnksIHo9dGhpcy56O1xuICAgIHZhciBweD1wLngsIHB5PXAueSwgcHo9cC56O1xuICAgIHJldHVybiBNYXRoLnNxcnQoKHB4LXgpKihweC14KStcbiAgICAgICAgICAgICAgICAgICAgIChweS15KSoocHkteSkrXG4gICAgICAgICAgICAgICAgICAgICAocHoteikqKHB6LXopKTtcbn07XG5cbi8qKlxuICogR2V0IHNxdWFyZWQgZGlzdGFuY2UgZnJvbSB0aGlzIHBvaW50IHRvIGFub3RoZXIgcG9pbnRcbiAqIEBtZXRob2QgZGlzdGFuY2VTcXVhcmVkXG4gKiBAcGFyYW0gIHtWZWMzfSBwXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cblZlYzMucHJvdG90eXBlLmRpc3RhbmNlU3F1YXJlZCA9IGZ1bmN0aW9uKHApe1xuICAgIHZhciB4PXRoaXMueCwgeT10aGlzLnksIHo9dGhpcy56O1xuICAgIHZhciBweD1wLngsIHB5PXAueSwgcHo9cC56O1xuICAgIHJldHVybiAocHgteCkqKHB4LXgpICsgKHB5LXkpKihweS15KSArIChwei16KSoocHoteik7XG59O1xuXG4vKipcbiAqIE11bHRpcGx5IGFsbCB0aGUgY29tcG9uZW50cyBvZiB0aGUgdmVjdG9yIHdpdGggYSBzY2FsYXIuXG4gKiBAZGVwcmVjYXRlZCBVc2UgLnNjYWxlIGluc3RlYWRcbiAqIEBtZXRob2QgbXVsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxhclxuICogQHBhcmFtIHtWZWMzfSB0YXJnZXQgVGhlIHZlY3RvciB0byBzYXZlIHRoZSByZXN1bHQgaW4uXG4gKiBAcmV0dXJuIHtWZWMzfVxuICogQGRlcHJlY2F0ZWQgVXNlIC5zY2FsZSgpIGluc3RlYWRcbiAqL1xuVmVjMy5wcm90b3R5cGUubXVsdCA9IGZ1bmN0aW9uKHNjYWxhcix0YXJnZXQpe1xuICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgVmVjMygpO1xuICAgIHZhciB4ID0gdGhpcy54LFxuICAgICAgICB5ID0gdGhpcy55LFxuICAgICAgICB6ID0gdGhpcy56O1xuICAgIHRhcmdldC54ID0gc2NhbGFyICogeDtcbiAgICB0YXJnZXQueSA9IHNjYWxhciAqIHk7XG4gICAgdGFyZ2V0LnogPSBzY2FsYXIgKiB6O1xuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIE11bHRpcGx5IHRoZSB2ZWN0b3Igd2l0aCBhIHNjYWxhci5cbiAqIEBtZXRob2Qgc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsYXJcbiAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0XG4gKiBAcmV0dXJuIHtWZWMzfVxuICovXG5WZWMzLnByb3RvdHlwZS5zY2FsZSA9IFZlYzMucHJvdG90eXBlLm11bHQ7XG5cbi8qKlxuICogQ2FsY3VsYXRlIGRvdCBwcm9kdWN0XG4gKiBAbWV0aG9kIGRvdFxuICogQHBhcmFtIHtWZWMzfSB2XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cblZlYzMucHJvdG90eXBlLmRvdCA9IGZ1bmN0aW9uKHYpe1xuICAgIHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2LnkgKyB0aGlzLnogKiB2Lno7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgaXNaZXJvXG4gKiBAcmV0dXJuIGJvb2xcbiAqL1xuVmVjMy5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy54PT09MCAmJiB0aGlzLnk9PT0wICYmIHRoaXMuej09PTA7XG59O1xuXG4vKipcbiAqIE1ha2UgdGhlIHZlY3RvciBwb2ludCBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uLlxuICogQG1ldGhvZCBuZWdhdGVcbiAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0IE9wdGlvbmFsIHRhcmdldCB0byBzYXZlIGluXG4gKiBAcmV0dXJuIHtWZWMzfVxuICovXG5WZWMzLnByb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbih0YXJnZXQpe1xuICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgVmVjMygpO1xuICAgIHRhcmdldC54ID0gLXRoaXMueDtcbiAgICB0YXJnZXQueSA9IC10aGlzLnk7XG4gICAgdGFyZ2V0LnogPSAtdGhpcy56O1xuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIENvbXB1dGUgdHdvIGFydGlmaWNpYWwgdGFuZ2VudHMgdG8gdGhlIHZlY3RvclxuICogQG1ldGhvZCB0YW5nZW50c1xuICogQHBhcmFtIHtWZWMzfSB0MSBWZWN0b3Igb2JqZWN0IHRvIHNhdmUgdGhlIGZpcnN0IHRhbmdlbnQgaW5cbiAqIEBwYXJhbSB7VmVjM30gdDIgVmVjdG9yIG9iamVjdCB0byBzYXZlIHRoZSBzZWNvbmQgdGFuZ2VudCBpblxuICovXG52YXIgVmVjM190YW5nZW50c19uID0gbmV3IFZlYzMoKTtcbnZhciBWZWMzX3RhbmdlbnRzX3JhbmRWZWMgPSBuZXcgVmVjMygpO1xuVmVjMy5wcm90b3R5cGUudGFuZ2VudHMgPSBmdW5jdGlvbih0MSx0Mil7XG4gICAgdmFyIG5vcm0gPSB0aGlzLm5vcm0oKTtcbiAgICBpZihub3JtPjAuMCl7XG4gICAgICAgIHZhciBuID0gVmVjM190YW5nZW50c19uO1xuICAgICAgICB2YXIgaW5vcm0gPSAxL25vcm07XG4gICAgICAgIG4uc2V0KHRoaXMueCppbm9ybSx0aGlzLnkqaW5vcm0sdGhpcy56Kmlub3JtKTtcbiAgICAgICAgdmFyIHJhbmRWZWMgPSBWZWMzX3RhbmdlbnRzX3JhbmRWZWM7XG4gICAgICAgIGlmKE1hdGguYWJzKG4ueCkgPCAwLjkpe1xuICAgICAgICAgICAgcmFuZFZlYy5zZXQoMSwwLDApO1xuICAgICAgICAgICAgbi5jcm9zcyhyYW5kVmVjLHQxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJhbmRWZWMuc2V0KDAsMSwwKTtcbiAgICAgICAgICAgIG4uY3Jvc3MocmFuZFZlYyx0MSk7XG4gICAgICAgIH1cbiAgICAgICAgbi5jcm9zcyh0MSx0Mik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlIG5vcm1hbCBsZW5ndGggaXMgemVybywgbWFrZSBzb21ldGhpbmcgdXBcbiAgICAgICAgdDEuc2V0KDEsIDAsIDApO1xuICAgICAgICB0Mi5zZXQoMCwgMSwgMCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0byBhIG1vcmUgcmVhZGFibGUgZm9ybWF0XG4gKiBAbWV0aG9kIHRvU3RyaW5nXG4gKiBAcmV0dXJuIHN0cmluZ1xuICovXG5WZWMzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMueCtcIixcIit0aGlzLnkrXCIsXCIrdGhpcy56O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0byBhbiBhcnJheVxuICogQG1ldGhvZCB0b0FycmF5XG4gKiBAcmV0dXJuIEFycmF5XG4gKi9cblZlYzMucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiBbdGhpcy54LCB0aGlzLnksIHRoaXMuel07XG59O1xuXG4vKipcbiAqIENvcGllcyB2YWx1ZSBvZiBzb3VyY2UgdG8gdGhpcyB2ZWN0b3IuXG4gKiBAbWV0aG9kIGNvcHlcbiAqIEBwYXJhbSB7VmVjM30gc291cmNlXG4gKiBAcmV0dXJuIHtWZWMzfSB0aGlzXG4gKi9cblZlYzMucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbihzb3VyY2Upe1xuICAgIHRoaXMueCA9IHNvdXJjZS54O1xuICAgIHRoaXMueSA9IHNvdXJjZS55O1xuICAgIHRoaXMueiA9IHNvdXJjZS56O1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbiAqIERvIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjdG9yc1xuICogQG1ldGhvZCBsZXJwXG4gKiBAcGFyYW0ge1ZlYzN9IHZcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IEEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMS4gMCB3aWxsIG1ha2UgdGhpcyBmdW5jdGlvbiByZXR1cm4gdSwgYW5kIDEgd2lsbCBtYWtlIGl0IHJldHVybiB2LiBOdW1iZXJzIGluIGJldHdlZW4gd2lsbCBnZW5lcmF0ZSBhIHZlY3RvciBpbiBiZXR3ZWVuIHRoZW0uXG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldFxuICovXG5WZWMzLnByb3RvdHlwZS5sZXJwID0gZnVuY3Rpb24odix0LHRhcmdldCl7XG4gICAgdmFyIHg9dGhpcy54LCB5PXRoaXMueSwgej10aGlzLno7XG4gICAgdGFyZ2V0LnggPSB4ICsgKHYueC14KSp0O1xuICAgIHRhcmdldC55ID0geSArICh2LnkteSkqdDtcbiAgICB0YXJnZXQueiA9IHogKyAodi56LXopKnQ7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGEgdmVjdG9yIGVxdWFscyBpcyBhbG1vc3QgZXF1YWwgdG8gYW5vdGhlciBvbmUuXG4gKiBAbWV0aG9kIGFsbW9zdEVxdWFsc1xuICogQHBhcmFtIHtWZWMzfSB2XG4gKiBAcGFyYW0ge051bWJlcn0gcHJlY2lzaW9uXG4gKiBAcmV0dXJuIGJvb2xcbiAqL1xuVmVjMy5wcm90b3R5cGUuYWxtb3N0RXF1YWxzID0gZnVuY3Rpb24odixwcmVjaXNpb24pe1xuICAgIGlmKHByZWNpc2lvbj09PXVuZGVmaW5lZCl7XG4gICAgICAgIHByZWNpc2lvbiA9IDFlLTY7XG4gICAgfVxuICAgIGlmKCBNYXRoLmFicyh0aGlzLngtdi54KT5wcmVjaXNpb24gfHxcbiAgICAgICAgTWF0aC5hYnModGhpcy55LXYueSk+cHJlY2lzaW9uIHx8XG4gICAgICAgIE1hdGguYWJzKHRoaXMuei12LnopPnByZWNpc2lvbil7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGEgdmVjdG9yIGlzIGFsbW9zdCB6ZXJvXG4gKiBAbWV0aG9kIGFsbW9zdFplcm9cbiAqIEBwYXJhbSB7TnVtYmVyfSBwcmVjaXNpb25cbiAqL1xuVmVjMy5wcm90b3R5cGUuYWxtb3N0WmVybyA9IGZ1bmN0aW9uKHByZWNpc2lvbil7XG4gICAgaWYocHJlY2lzaW9uPT09dW5kZWZpbmVkKXtcbiAgICAgICAgcHJlY2lzaW9uID0gMWUtNjtcbiAgICB9XG4gICAgaWYoIE1hdGguYWJzKHRoaXMueCk+cHJlY2lzaW9uIHx8XG4gICAgICAgIE1hdGguYWJzKHRoaXMueSk+cHJlY2lzaW9uIHx8XG4gICAgICAgIE1hdGguYWJzKHRoaXMueik+cHJlY2lzaW9uKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciBhbnRpcF9uZWcgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSB2ZWN0b3IgaXMgYW50aS1wYXJhbGxlbCB0byBhbm90aGVyIHZlY3Rvci5cbiAqIEBtZXRob2QgaXNBbnRpcGFyYWxsZWxUb1xuICogQHBhcmFtICB7VmVjM30gIHZcbiAqIEBwYXJhbSAge051bWJlcn0gIHByZWNpc2lvbiBTZXQgdG8gemVybyBmb3IgZXhhY3QgY29tcGFyaXNvbnNcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblZlYzMucHJvdG90eXBlLmlzQW50aXBhcmFsbGVsVG8gPSBmdW5jdGlvbih2LHByZWNpc2lvbil7XG4gICAgdGhpcy5uZWdhdGUoYW50aXBfbmVnKTtcbiAgICByZXR1cm4gYW50aXBfbmVnLmFsbW9zdEVxdWFscyh2LHByZWNpc2lvbik7XG59O1xuXG4vKipcbiAqIENsb25lIHRoZSB2ZWN0b3JcbiAqIEBtZXRob2QgY2xvbmVcbiAqIEByZXR1cm4ge1ZlYzN9XG4gKi9cblZlYzMucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gbmV3IFZlYzModGhpcy54LCB0aGlzLnksIHRoaXMueik7XG59O1xufSx7XCIuL01hdDNcIjoyN31dLDMxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gQm9keTtcblxudmFyIEV2ZW50VGFyZ2V0ID0gX2RlcmVxXygnLi4vdXRpbHMvRXZlbnRUYXJnZXQnKTtcbnZhciBTaGFwZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9TaGFwZScpO1xudmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcbnZhciBNYXQzID0gX2RlcmVxXygnLi4vbWF0aC9NYXQzJyk7XG52YXIgUXVhdGVybmlvbiA9IF9kZXJlcV8oJy4uL21hdGgvUXVhdGVybmlvbicpO1xudmFyIE1hdGVyaWFsID0gX2RlcmVxXygnLi4vbWF0ZXJpYWwvTWF0ZXJpYWwnKTtcbnZhciBBQUJCID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL0FBQkInKTtcbnZhciBCb3ggPSBfZGVyZXFfKCcuLi9zaGFwZXMvQm94Jyk7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYWxsIGJvZHkgdHlwZXMuXG4gKiBAY2xhc3MgQm9keVxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBFdmVudFRhcmdldFxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5wb3NpdGlvbl1cbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMudmVsb2NpdHldXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmFuZ3VsYXJWZWxvY2l0eV1cbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gW29wdGlvbnMucXVhdGVybmlvbl1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXNzXVxuICogQHBhcmFtIHtNYXRlcmlhbH0gW29wdGlvbnMubWF0ZXJpYWxdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMudHlwZV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5saW5lYXJEYW1waW5nPTAuMDFdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuYW5ndWxhckRhbXBpbmc9MC4wMV1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYWxsb3dTbGVlcD10cnVlXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnNsZWVwU3BlZWRMaW1pdD0wLjFdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc2xlZXBUaW1lTGltaXQ9MV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJHcm91cD0xXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNvbGxpc2lvbkZpbHRlck1hc2s9MV1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZml4ZWRSb3RhdGlvbj1mYWxzZV1cbiAqIEBwYXJhbSB7Qm9keX0gW29wdGlvbnMuc2hhcGVdXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciBib2R5ID0gbmV3IEJvZHkoe1xuICogICAgICAgICBtYXNzOiAxXG4gKiAgICAgfSk7XG4gKiAgICAgdmFyIHNoYXBlID0gbmV3IFNwaGVyZSgxKTtcbiAqICAgICBib2R5LmFkZFNoYXBlKHNoYXBlKTtcbiAqICAgICB3b3JsZC5hZGQoYm9keSk7XG4gKi9cbmZ1bmN0aW9uIEJvZHkob3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBFdmVudFRhcmdldC5hcHBseSh0aGlzKTtcblxuICAgIHRoaXMuaWQgPSBCb2R5LmlkQ291bnRlcisrO1xuXG4gICAgLyoqXG4gICAgICogUmVmZXJlbmNlIHRvIHRoZSB3b3JsZCB0aGUgYm9keSBpcyBsaXZpbmcgaW5cbiAgICAgKiBAcHJvcGVydHkgd29ybGRcbiAgICAgKiBAdHlwZSB7V29ybGR9XG4gICAgICovXG4gICAgdGhpcy53b3JsZCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIHVzZWQgQkVGT1JFIHN0ZXBwaW5nIHRoZSBzeXN0ZW0uIFVzZSBpdCB0byBhcHBseSBmb3JjZXMsIGZvciBleGFtcGxlLiBJbnNpZGUgdGhlIGZ1bmN0aW9uLCBcInRoaXNcIiB3aWxsIHJlZmVyIHRvIHRoaXMgQm9keSBvYmplY3QuXG4gICAgICogQHByb3BlcnR5IHByZVN0ZXBcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIFdvcmxkIGV2ZW50cyBpbnN0ZWFkXG4gICAgICovXG4gICAgdGhpcy5wcmVTdGVwID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCBBRlRFUiBzdGVwcGluZyB0aGUgc3lzdGVtLiBJbnNpZGUgdGhlIGZ1bmN0aW9uLCBcInRoaXNcIiB3aWxsIHJlZmVyIHRvIHRoaXMgQm9keSBvYmplY3QuXG4gICAgICogQHByb3BlcnR5IHBvc3RTdGVwXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBXb3JsZCBldmVudHMgaW5zdGVhZFxuICAgICAqL1xuICAgIHRoaXMucG9zdFN0ZXAgPSBudWxsO1xuXG4gICAgdGhpcy52bGFtYmRhID0gbmV3IFZlYzMoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjb2xsaXNpb25GaWx0ZXJHcm91cFxuICAgICAqL1xuICAgIHRoaXMuY29sbGlzaW9uRmlsdGVyR3JvdXAgPSB0eXBlb2Yob3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJHcm91cCkgPT09ICdudW1iZXInID8gb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJHcm91cCA6IDE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gY29sbGlzaW9uRmlsdGVyTWFza1xuICAgICAqL1xuICAgIHRoaXMuY29sbGlzaW9uRmlsdGVyTWFzayA9IHR5cGVvZihvcHRpb25zLmNvbGxpc2lvbkZpbHRlck1hc2spID09PSAnbnVtYmVyJyA/IG9wdGlvbnMuY29sbGlzaW9uRmlsdGVyTWFzayA6IDE7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIHByb2R1Y2UgY29udGFjdCBmb3JjZXMgd2hlbiBpbiBjb250YWN0IHdpdGggb3RoZXIgYm9kaWVzLiBOb3RlIHRoYXQgY29udGFjdHMgd2lsbCBiZSBnZW5lcmF0ZWQsIGJ1dCB0aGV5IHdpbGwgYmUgZGlzYWJsZWQuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGNvbGxpc2lvblJlc3BvbnNlXG4gICAgICovXG5cdHRoaXMuY29sbGlzaW9uUmVzcG9uc2UgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHBvc2l0aW9uXG4gICAgICogQHR5cGUge1ZlYzN9XG4gICAgICovXG4gICAgdGhpcy5wb3NpdGlvbiA9IG5ldyBWZWMzKCk7XG5cbiAgICBpZihvcHRpb25zLnBvc2l0aW9uKXtcbiAgICAgICAgdGhpcy5wb3NpdGlvbi5jb3B5KG9wdGlvbnMucG9zaXRpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gcHJldmlvdXNQb3NpdGlvblxuICAgICAqL1xuICAgIHRoaXMucHJldmlvdXNQb3NpdGlvbiA9IG5ldyBWZWMzKCk7XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsIHBvc2l0aW9uIG9mIHRoZSBib2R5XG4gICAgICogQHByb3BlcnR5IGluaXRQb3NpdGlvblxuICAgICAqIEB0eXBlIHtWZWMzfVxuICAgICAqL1xuICAgIHRoaXMuaW5pdFBvc2l0aW9uID0gbmV3IFZlYzMoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB2ZWxvY2l0eVxuICAgICAqIEB0eXBlIHtWZWMzfVxuICAgICAqL1xuICAgIHRoaXMudmVsb2NpdHkgPSBuZXcgVmVjMygpO1xuXG4gICAgaWYob3B0aW9ucy52ZWxvY2l0eSl7XG4gICAgICAgIHRoaXMudmVsb2NpdHkuY29weShvcHRpb25zLnZlbG9jaXR5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5pdFZlbG9jaXR5XG4gICAgICogQHR5cGUge1ZlYzN9XG4gICAgICovXG4gICAgdGhpcy5pbml0VmVsb2NpdHkgPSBuZXcgVmVjMygpO1xuXG4gICAgLyoqXG4gICAgICogTGluZWFyIGZvcmNlIG9uIHRoZSBib2R5XG4gICAgICogQHByb3BlcnR5IGZvcmNlXG4gICAgICogQHR5cGUge1ZlYzN9XG4gICAgICovXG4gICAgdGhpcy5mb3JjZSA9IG5ldyBWZWMzKCk7XG5cbiAgICB2YXIgbWFzcyA9IHR5cGVvZihvcHRpb25zLm1hc3MpID09PSAnbnVtYmVyJyA/IG9wdGlvbnMubWFzcyA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgbWFzc1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMubWFzcyA9IG1hc3M7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW52TWFzc1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbnZNYXNzID0gbWFzcyA+IDAgPyAxLjAgLyBtYXNzIDogMDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBtYXRlcmlhbFxuICAgICAqIEB0eXBlIHtNYXRlcmlhbH1cbiAgICAgKi9cbiAgICB0aGlzLm1hdGVyaWFsID0gb3B0aW9ucy5tYXRlcmlhbCB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGxpbmVhckRhbXBpbmdcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGluZWFyRGFtcGluZyA9IHR5cGVvZihvcHRpb25zLmxpbmVhckRhbXBpbmcpID09PSAnbnVtYmVyJyA/IG9wdGlvbnMubGluZWFyRGFtcGluZyA6IDAuMDE7XG5cbiAgICAvKipcbiAgICAgKiBPbmUgb2Y6IEJvZHkuRFlOQU1JQywgQm9keS5TVEFUSUMgYW5kIEJvZHkuS0lORU1BVElDLlxuICAgICAqIEBwcm9wZXJ0eSB0eXBlXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSAobWFzcyA8PSAwLjAgPyBCb2R5LlNUQVRJQyA6IEJvZHkuRFlOQU1JQyk7XG4gICAgaWYodHlwZW9mKG9wdGlvbnMudHlwZSkgPT09IHR5cGVvZihCb2R5LlNUQVRJQykpe1xuICAgICAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdGhlIGJvZHkgd2lsbCBhdXRvbWF0aWNhbGx5IGZhbGwgdG8gc2xlZXAuXG4gICAgICogQHByb3BlcnR5IGFsbG93U2xlZXBcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgdGhpcy5hbGxvd1NsZWVwID0gdHlwZW9mKG9wdGlvbnMuYWxsb3dTbGVlcCkgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5hbGxvd1NsZWVwIDogdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgc2xlZXAgc3RhdGUuXG4gICAgICogQHByb3BlcnR5IHNsZWVwU3RhdGVcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc2xlZXBTdGF0ZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgc3BlZWQgKHRoZSBub3JtIG9mIHRoZSB2ZWxvY2l0eSkgaXMgc21hbGxlciB0aGFuIHRoaXMgdmFsdWUsIHRoZSBib2R5IGlzIGNvbnNpZGVyZWQgc2xlZXB5LlxuICAgICAqIEBwcm9wZXJ0eSBzbGVlcFNwZWVkTGltaXRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDAuMVxuICAgICAqL1xuICAgIHRoaXMuc2xlZXBTcGVlZExpbWl0ID0gdHlwZW9mKG9wdGlvbnMuc2xlZXBTcGVlZExpbWl0KSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLnNsZWVwU3BlZWRMaW1pdCA6IDAuMTtcblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBib2R5IGhhcyBiZWVuIHNsZWVweSBmb3IgdGhpcyBzbGVlcFRpbWVMaW1pdCBzZWNvbmRzLCBpdCBpcyBjb25zaWRlcmVkIHNsZWVwaW5nLlxuICAgICAqIEBwcm9wZXJ0eSBzbGVlcFRpbWVMaW1pdFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuICAgIHRoaXMuc2xlZXBUaW1lTGltaXQgPSB0eXBlb2Yob3B0aW9ucy5zbGVlcFRpbWVMaW1pdCkgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5zbGVlcFRpbWVMaW1pdCA6IDE7XG5cbiAgICB0aGlzLnRpbWVMYXN0U2xlZXB5ID0gMDtcblxuICAgIHRoaXMuX3dha2VVcEFmdGVyTmFycm93cGhhc2UgPSBmYWxzZTtcblxuXG4gICAgLyoqXG4gICAgICogUm90YXRpb25hbCBmb3JjZSBvbiB0aGUgYm9keSwgYXJvdW5kIGNlbnRlciBvZiBtYXNzXG4gICAgICogQHByb3BlcnR5IHtWZWMzfSB0b3JxdWVcbiAgICAgKi9cbiAgICB0aGlzLnRvcnF1ZSA9IG5ldyBWZWMzKCk7XG5cbiAgICAvKipcbiAgICAgKiBPcmllbnRhdGlvbiBvZiB0aGUgYm9keVxuICAgICAqIEBwcm9wZXJ0eSBxdWF0ZXJuaW9uXG4gICAgICogQHR5cGUge1F1YXRlcm5pb259XG4gICAgICovXG4gICAgdGhpcy5xdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcblxuICAgIGlmKG9wdGlvbnMucXVhdGVybmlvbil7XG4gICAgICAgIHRoaXMucXVhdGVybmlvbi5jb3B5KG9wdGlvbnMucXVhdGVybmlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluaXRRdWF0ZXJuaW9uXG4gICAgICogQHR5cGUge1F1YXRlcm5pb259XG4gICAgICovXG4gICAgdGhpcy5pbml0UXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgYW5ndWxhclZlbG9jaXR5XG4gICAgICogQHR5cGUge1ZlYzN9XG4gICAgICovXG4gICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkgPSBuZXcgVmVjMygpO1xuXG4gICAgaWYob3B0aW9ucy5hbmd1bGFyVmVsb2NpdHkpe1xuICAgICAgICB0aGlzLmFuZ3VsYXJWZWxvY2l0eS5jb3B5KG9wdGlvbnMuYW5ndWxhclZlbG9jaXR5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5pdEFuZ3VsYXJWZWxvY2l0eVxuICAgICAqIEB0eXBlIHtWZWMzfVxuICAgICAqL1xuICAgIHRoaXMuaW5pdEFuZ3VsYXJWZWxvY2l0eSA9IG5ldyBWZWMzKCk7XG5cbiAgICB0aGlzLmludGVycG9sYXRlZFBvc2l0aW9uID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLmludGVycG9sYXRlZFF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHNoYXBlc1xuICAgICAqIEB0eXBlIHthcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnNoYXBlcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHNoYXBlT2Zmc2V0c1xuICAgICAqIEB0eXBlIHthcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnNoYXBlT2Zmc2V0cyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHNoYXBlT3JpZW50YXRpb25zXG4gICAgICogQHR5cGUge2FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuc2hhcGVPcmllbnRhdGlvbnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpbmVydGlhXG4gICAgICogQHR5cGUge1ZlYzN9XG4gICAgICovXG4gICAgdGhpcy5pbmVydGlhID0gbmV3IFZlYzMoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gaW52SW5lcnRpYVxuICAgICAqL1xuICAgIHRoaXMuaW52SW5lcnRpYSA9IG5ldyBWZWMzKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge01hdDN9IGludkluZXJ0aWFXb3JsZFxuICAgICAqL1xuICAgIHRoaXMuaW52SW5lcnRpYVdvcmxkID0gbmV3IE1hdDMoKTtcblxuICAgIHRoaXMuaW52TWFzc1NvbHZlID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gaW52SW5lcnRpYVNvbHZlXG4gICAgICovXG4gICAgdGhpcy5pbnZJbmVydGlhU29sdmUgPSBuZXcgVmVjMygpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtNYXQzfSBpbnZJbmVydGlhV29ybGRTb2x2ZVxuICAgICAqL1xuICAgIHRoaXMuaW52SW5lcnRpYVdvcmxkU29sdmUgPSBuZXcgTWF0MygpO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgaWYgeW91IGRvbid0IHdhbnQgdGhlIGJvZHkgdG8gcm90YXRlLiBNYWtlIHN1cmUgdG8gcnVuIC51cGRhdGVNYXNzUHJvcGVydGllcygpIGFmdGVyIGNoYW5naW5nIHRoaXMuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBmaXhlZFJvdGF0aW9uXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICB0aGlzLmZpeGVkUm90YXRpb24gPSB0eXBlb2Yob3B0aW9ucy5maXhlZFJvdGF0aW9uKSAhPT0gXCJ1bmRlZmluZWRcIiA/IG9wdGlvbnMuZml4ZWRSb3RhdGlvbiA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGFuZ3VsYXJEYW1waW5nXG4gICAgICovXG4gICAgdGhpcy5hbmd1bGFyRGFtcGluZyA9IHR5cGVvZihvcHRpb25zLmFuZ3VsYXJEYW1waW5nKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmFuZ3VsYXJEYW1waW5nIDogMC4wMTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBhYWJiXG4gICAgICogQHR5cGUge0FBQkJ9XG4gICAgICovXG4gICAgdGhpcy5hYWJiID0gbmV3IEFBQkIoKTtcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiB0aGUgQUFCQiBuZWVkcyB0byBiZSB1cGRhdGVkIGJlZm9yZSB1c2UuXG4gICAgICogQHByb3BlcnR5IGFhYmJOZWVkc1VwZGF0ZVxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIHRoaXMud2xhbWJkYSA9IG5ldyBWZWMzKCk7XG5cbiAgICBpZihvcHRpb25zLnNoYXBlKXtcbiAgICAgICAgdGhpcy5hZGRTaGFwZShvcHRpb25zLnNoYXBlKTtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZU1hc3NQcm9wZXJ0aWVzKCk7XG59XG5Cb2R5LnByb3RvdHlwZSA9IG5ldyBFdmVudFRhcmdldCgpO1xuQm9keS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCb2R5O1xuXG4vKipcbiAqIEEgZHluYW1pYyBib2R5IGlzIGZ1bGx5IHNpbXVsYXRlZC4gQ2FuIGJlIG1vdmVkIG1hbnVhbGx5IGJ5IHRoZSB1c2VyLCBidXQgbm9ybWFsbHkgdGhleSBtb3ZlIGFjY29yZGluZyB0byBmb3JjZXMuIEEgZHluYW1pYyBib2R5IGNhbiBjb2xsaWRlIHdpdGggYWxsIGJvZHkgdHlwZXMuIEEgZHluYW1pYyBib2R5IGFsd2F5cyBoYXMgZmluaXRlLCBub24temVybyBtYXNzLlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IERZTkFNSUNcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cbkJvZHkuRFlOQU1JQyA9IDE7XG5cbi8qKlxuICogQSBzdGF0aWMgYm9keSBkb2VzIG5vdCBtb3ZlIGR1cmluZyBzaW11bGF0aW9uIGFuZCBiZWhhdmVzIGFzIGlmIGl0IGhhcyBpbmZpbml0ZSBtYXNzLiBTdGF0aWMgYm9kaWVzIGNhbiBiZSBtb3ZlZCBtYW51YWxseSBieSBzZXR0aW5nIHRoZSBwb3NpdGlvbiBvZiB0aGUgYm9keS4gVGhlIHZlbG9jaXR5IG9mIGEgc3RhdGljIGJvZHkgaXMgYWx3YXlzIHplcm8uIFN0YXRpYyBib2RpZXMgZG8gbm90IGNvbGxpZGUgd2l0aCBvdGhlciBzdGF0aWMgb3Iga2luZW1hdGljIGJvZGllcy5cbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSBTVEFUSUNcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cbkJvZHkuU1RBVElDID0gMjtcblxuLyoqXG4gKiBBIGtpbmVtYXRpYyBib2R5IG1vdmVzIHVuZGVyIHNpbXVsYXRpb24gYWNjb3JkaW5nIHRvIGl0cyB2ZWxvY2l0eS4gVGhleSBkbyBub3QgcmVzcG9uZCB0byBmb3JjZXMuIFRoZXkgY2FuIGJlIG1vdmVkIG1hbnVhbGx5LCBidXQgbm9ybWFsbHkgYSBraW5lbWF0aWMgYm9keSBpcyBtb3ZlZCBieSBzZXR0aW5nIGl0cyB2ZWxvY2l0eS4gQSBraW5lbWF0aWMgYm9keSBiZWhhdmVzIGFzIGlmIGl0IGhhcyBpbmZpbml0ZSBtYXNzLiBLaW5lbWF0aWMgYm9kaWVzIGRvIG5vdCBjb2xsaWRlIHdpdGggb3RoZXIgc3RhdGljIG9yIGtpbmVtYXRpYyBib2RpZXMuXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkgS0lORU1BVElDXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5Cb2R5LktJTkVNQVRJQyA9IDQ7XG5cblxuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSBBV0FLRVxuICogQHR5cGUge251bWJlcn1cbiAqL1xuQm9keS5BV0FLRSA9IDA7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IFNMRUVQWVxuICogQHR5cGUge251bWJlcn1cbiAqL1xuQm9keS5TTEVFUFkgPSAxO1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSBTTEVFUElOR1xuICogQHR5cGUge251bWJlcn1cbiAqL1xuQm9keS5TTEVFUElORyA9IDI7XG5cbkJvZHkuaWRDb3VudGVyID0gMDtcblxuLyoqXG4gKiBXYWtlIHRoZSBib2R5IHVwLlxuICogQG1ldGhvZCB3YWtlVXBcbiAqL1xuQm9keS5wcm90b3R5cGUud2FrZVVwID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcyA9IHRoaXMuc2xlZXBTdGF0ZTtcbiAgICB0aGlzLnNsZWVwU3RhdGUgPSAwO1xuICAgIGlmKHMgPT09IEJvZHkuU0xFRVBJTkcpe1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6XCJ3YWtldXBcIn0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogRm9yY2UgYm9keSBzbGVlcFxuICogQG1ldGhvZCBzbGVlcFxuICovXG5Cb2R5LnByb3RvdHlwZS5zbGVlcCA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5zbGVlcFN0YXRlID0gQm9keS5TTEVFUElORztcbiAgICB0aGlzLnZlbG9jaXR5LnNldCgwLDAsMCk7XG4gICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkuc2V0KDAsMCwwKTtcbn07XG5cbkJvZHkuc2xlZXB5RXZlbnQgPSB7XG4gICAgdHlwZTogXCJzbGVlcHlcIlxufTtcblxuQm9keS5zbGVlcEV2ZW50ID0ge1xuICAgIHR5cGU6IFwic2xlZXBcIlxufTtcblxuLyoqXG4gKiBDYWxsZWQgZXZlcnkgdGltZXN0ZXAgdG8gdXBkYXRlIGludGVybmFsIHNsZWVwIHRpbWVyIGFuZCBjaGFuZ2Ugc2xlZXAgc3RhdGUgaWYgbmVlZGVkLlxuICogQG1ldGhvZCBzbGVlcFRpY2tcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIFRoZSB3b3JsZCB0aW1lIGluIHNlY29uZHNcbiAqL1xuQm9keS5wcm90b3R5cGUuc2xlZXBUaWNrID0gZnVuY3Rpb24odGltZSl7XG4gICAgaWYodGhpcy5hbGxvd1NsZWVwKXtcbiAgICAgICAgdmFyIHNsZWVwU3RhdGUgPSB0aGlzLnNsZWVwU3RhdGU7XG4gICAgICAgIHZhciBzcGVlZFNxdWFyZWQgPSB0aGlzLnZlbG9jaXR5Lm5vcm0yKCkgKyB0aGlzLmFuZ3VsYXJWZWxvY2l0eS5ub3JtMigpO1xuICAgICAgICB2YXIgc3BlZWRMaW1pdFNxdWFyZWQgPSBNYXRoLnBvdyh0aGlzLnNsZWVwU3BlZWRMaW1pdCwyKTtcbiAgICAgICAgaWYoc2xlZXBTdGF0ZT09PUJvZHkuQVdBS0UgJiYgc3BlZWRTcXVhcmVkIDwgc3BlZWRMaW1pdFNxdWFyZWQpe1xuICAgICAgICAgICAgdGhpcy5zbGVlcFN0YXRlID0gQm9keS5TTEVFUFk7IC8vIFNsZWVweVxuICAgICAgICAgICAgdGhpcy50aW1lTGFzdFNsZWVweSA9IHRpbWU7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoQm9keS5zbGVlcHlFdmVudCk7XG4gICAgICAgIH0gZWxzZSBpZihzbGVlcFN0YXRlPT09Qm9keS5TTEVFUFkgJiYgc3BlZWRTcXVhcmVkID4gc3BlZWRMaW1pdFNxdWFyZWQpe1xuICAgICAgICAgICAgdGhpcy53YWtlVXAoKTsgLy8gV2FrZSB1cFxuICAgICAgICB9IGVsc2UgaWYoc2xlZXBTdGF0ZT09PUJvZHkuU0xFRVBZICYmICh0aW1lIC0gdGhpcy50aW1lTGFzdFNsZWVweSApID4gdGhpcy5zbGVlcFRpbWVMaW1pdCl7XG4gICAgICAgICAgICB0aGlzLnNsZWVwKCk7IC8vIFNsZWVwaW5nXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoQm9keS5zbGVlcEV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogSWYgdGhlIGJvZHkgaXMgc2xlZXBpbmcsIGl0IHNob3VsZCBiZSBpbW1vdmFibGUgLyBoYXZlIGluZmluaXRlIG1hc3MgZHVyaW5nIHNvbHZlLiBXZSBzb2x2ZSBpdCBieSBoYXZpbmcgYSBzZXBhcmF0ZSBcInNvbHZlIG1hc3NcIi5cbiAqIEBtZXRob2QgdXBkYXRlU29sdmVNYXNzUHJvcGVydGllc1xuICovXG5Cb2R5LnByb3RvdHlwZS51cGRhdGVTb2x2ZU1hc3NQcm9wZXJ0aWVzID0gZnVuY3Rpb24oKXtcbiAgICBpZih0aGlzLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcgfHwgdGhpcy50eXBlID09PSBCb2R5LktJTkVNQVRJQyl7XG4gICAgICAgIHRoaXMuaW52TWFzc1NvbHZlID0gMDtcbiAgICAgICAgdGhpcy5pbnZJbmVydGlhU29sdmUuc2V0WmVybygpO1xuICAgICAgICB0aGlzLmludkluZXJ0aWFXb3JsZFNvbHZlLnNldFplcm8oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmludk1hc3NTb2x2ZSA9IHRoaXMuaW52TWFzcztcbiAgICAgICAgdGhpcy5pbnZJbmVydGlhU29sdmUuY29weSh0aGlzLmludkluZXJ0aWEpO1xuICAgICAgICB0aGlzLmludkluZXJ0aWFXb3JsZFNvbHZlLmNvcHkodGhpcy5pbnZJbmVydGlhV29ybGQpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ29udmVydCBhIHdvcmxkIHBvaW50IHRvIGxvY2FsIGJvZHkgZnJhbWUuXG4gKiBAbWV0aG9kIHBvaW50VG9Mb2NhbEZyYW1lXG4gKiBAcGFyYW0gIHtWZWMzfSB3b3JsZFBvaW50XG4gKiBAcGFyYW0gIHtWZWMzfSByZXN1bHRcbiAqIEByZXR1cm4ge1ZlYzN9XG4gKi9cbkJvZHkucHJvdG90eXBlLnBvaW50VG9Mb2NhbEZyYW1lID0gZnVuY3Rpb24od29ybGRQb2ludCxyZXN1bHQpe1xuICAgIHZhciByZXN1bHQgPSByZXN1bHQgfHwgbmV3IFZlYzMoKTtcbiAgICB3b3JsZFBvaW50LnZzdWIodGhpcy5wb3NpdGlvbixyZXN1bHQpO1xuICAgIHRoaXMucXVhdGVybmlvbi5jb25qdWdhdGUoKS52bXVsdChyZXN1bHQscmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgd29ybGQgdmVjdG9yIHRvIGxvY2FsIGJvZHkgZnJhbWUuXG4gKiBAbWV0aG9kIHZlY3RvclRvTG9jYWxGcmFtZVxuICogQHBhcmFtICB7VmVjM30gd29ybGRQb2ludFxuICogQHBhcmFtICB7VmVjM30gcmVzdWx0XG4gKiBAcmV0dXJuIHtWZWMzfVxuICovXG5Cb2R5LnByb3RvdHlwZS52ZWN0b3JUb0xvY2FsRnJhbWUgPSBmdW5jdGlvbih3b3JsZFZlY3RvciwgcmVzdWx0KXtcbiAgICB2YXIgcmVzdWx0ID0gcmVzdWx0IHx8IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5xdWF0ZXJuaW9uLmNvbmp1Z2F0ZSgpLnZtdWx0KHdvcmxkVmVjdG9yLHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQ29udmVydCBhIGxvY2FsIGJvZHkgcG9pbnQgdG8gd29ybGQgZnJhbWUuXG4gKiBAbWV0aG9kIHBvaW50VG9Xb3JsZEZyYW1lXG4gKiBAcGFyYW0gIHtWZWMzfSBsb2NhbFBvaW50XG4gKiBAcGFyYW0gIHtWZWMzfSByZXN1bHRcbiAqIEByZXR1cm4ge1ZlYzN9XG4gKi9cbkJvZHkucHJvdG90eXBlLnBvaW50VG9Xb3JsZEZyYW1lID0gZnVuY3Rpb24obG9jYWxQb2ludCxyZXN1bHQpe1xuICAgIHZhciByZXN1bHQgPSByZXN1bHQgfHwgbmV3IFZlYzMoKTtcbiAgICB0aGlzLnF1YXRlcm5pb24udm11bHQobG9jYWxQb2ludCxyZXN1bHQpO1xuICAgIHJlc3VsdC52YWRkKHRoaXMucG9zaXRpb24scmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgbG9jYWwgYm9keSBwb2ludCB0byB3b3JsZCBmcmFtZS5cbiAqIEBtZXRob2QgdmVjdG9yVG9Xb3JsZEZyYW1lXG4gKiBAcGFyYW0gIHtWZWMzfSBsb2NhbFZlY3RvclxuICogQHBhcmFtICB7VmVjM30gcmVzdWx0XG4gKiBAcmV0dXJuIHtWZWMzfVxuICovXG5Cb2R5LnByb3RvdHlwZS52ZWN0b3JUb1dvcmxkRnJhbWUgPSBmdW5jdGlvbihsb2NhbFZlY3RvciwgcmVzdWx0KXtcbiAgICB2YXIgcmVzdWx0ID0gcmVzdWx0IHx8IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5xdWF0ZXJuaW9uLnZtdWx0KGxvY2FsVmVjdG9yLCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgdG1wVmVjID0gbmV3IFZlYzMoKTtcbnZhciB0bXBRdWF0ID0gbmV3IFF1YXRlcm5pb24oKTtcblxuLyoqXG4gKiBBZGQgYSBzaGFwZSB0byB0aGUgYm9keSB3aXRoIGEgbG9jYWwgb2Zmc2V0IGFuZCBvcmllbnRhdGlvbi5cbiAqIEBtZXRob2QgYWRkU2hhcGVcbiAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlXG4gKiBAcGFyYW0ge1ZlYzN9IG9mZnNldFxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxdWF0ZXJuaW9uXG4gKiBAcmV0dXJuIHtCb2R5fSBUaGUgYm9keSBvYmplY3QsIGZvciBjaGFpbmFiaWxpdHkuXG4gKi9cbkJvZHkucHJvdG90eXBlLmFkZFNoYXBlID0gZnVuY3Rpb24oc2hhcGUsIF9vZmZzZXQsIF9vcmllbnRhdGlvbil7XG4gICAgdmFyIG9mZnNldCA9IG5ldyBWZWMzKCk7XG4gICAgdmFyIG9yaWVudGF0aW9uID0gbmV3IFF1YXRlcm5pb24oKTtcblxuICAgIGlmKF9vZmZzZXQpe1xuICAgICAgICBvZmZzZXQuY29weShfb2Zmc2V0KTtcbiAgICB9XG4gICAgaWYoX29yaWVudGF0aW9uKXtcbiAgICAgICAgb3JpZW50YXRpb24uY29weShfb3JpZW50YXRpb24pO1xuICAgIH1cblxuICAgIHRoaXMuc2hhcGVzLnB1c2goc2hhcGUpO1xuICAgIHRoaXMuc2hhcGVPZmZzZXRzLnB1c2gob2Zmc2V0KTtcbiAgICB0aGlzLnNoYXBlT3JpZW50YXRpb25zLnB1c2gob3JpZW50YXRpb24pO1xuICAgIHRoaXMudXBkYXRlTWFzc1Byb3BlcnRpZXMoKTtcbiAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nUmFkaXVzKCk7XG5cbiAgICB0aGlzLmFhYmJOZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSBib3VuZGluZyByYWRpdXMgb2YgdGhlIGJvZHkuIFNob3VsZCBiZSBkb25lIGlmIGFueSBvZiB0aGUgc2hhcGVzIGFyZSBjaGFuZ2VkLlxuICogQG1ldGhvZCB1cGRhdGVCb3VuZGluZ1JhZGl1c1xuICovXG5Cb2R5LnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1JhZGl1cyA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHNoYXBlcyA9IHRoaXMuc2hhcGVzLFxuICAgICAgICBzaGFwZU9mZnNldHMgPSB0aGlzLnNoYXBlT2Zmc2V0cyxcbiAgICAgICAgTiA9IHNoYXBlcy5sZW5ndGgsXG4gICAgICAgIHJhZGl1cyA9IDA7XG5cbiAgICBmb3IodmFyIGk9MDsgaSE9PU47IGkrKyl7XG4gICAgICAgIHZhciBzaGFwZSA9IHNoYXBlc1tpXTtcbiAgICAgICAgc2hhcGUudXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKTtcbiAgICAgICAgdmFyIG9mZnNldCA9IHNoYXBlT2Zmc2V0c1tpXS5ub3JtKCksXG4gICAgICAgICAgICByID0gc2hhcGUuYm91bmRpbmdTcGhlcmVSYWRpdXM7XG4gICAgICAgIGlmKG9mZnNldCArIHIgPiByYWRpdXMpe1xuICAgICAgICAgICAgcmFkaXVzID0gb2Zmc2V0ICsgcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSByYWRpdXM7XG59O1xuXG52YXIgY29tcHV0ZUFBQkJfc2hhcGVBQUJCID0gbmV3IEFBQkIoKTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSAuYWFiYlxuICogQG1ldGhvZCBjb21wdXRlQUFCQlxuICogQHRvZG8gcmVuYW1lIHRvIHVwZGF0ZUFBQkIoKVxuICovXG5Cb2R5LnByb3RvdHlwZS5jb21wdXRlQUFCQiA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHNoYXBlcyA9IHRoaXMuc2hhcGVzLFxuICAgICAgICBzaGFwZU9mZnNldHMgPSB0aGlzLnNoYXBlT2Zmc2V0cyxcbiAgICAgICAgc2hhcGVPcmllbnRhdGlvbnMgPSB0aGlzLnNoYXBlT3JpZW50YXRpb25zLFxuICAgICAgICBOID0gc2hhcGVzLmxlbmd0aCxcbiAgICAgICAgb2Zmc2V0ID0gdG1wVmVjLFxuICAgICAgICBvcmllbnRhdGlvbiA9IHRtcFF1YXQsXG4gICAgICAgIGJvZHlRdWF0ID0gdGhpcy5xdWF0ZXJuaW9uLFxuICAgICAgICBhYWJiID0gdGhpcy5hYWJiLFxuICAgICAgICBzaGFwZUFBQkIgPSBjb21wdXRlQUFCQl9zaGFwZUFBQkI7XG5cbiAgICBmb3IodmFyIGk9MDsgaSE9PU47IGkrKyl7XG4gICAgICAgIHZhciBzaGFwZSA9IHNoYXBlc1tpXTtcblxuICAgICAgICAvLyBHZXQgc2hhcGUgd29ybGQgcXVhdGVybmlvblxuICAgICAgICBzaGFwZU9yaWVudGF0aW9uc1tpXS5tdWx0KGJvZHlRdWF0LCBvcmllbnRhdGlvbik7XG5cbiAgICAgICAgLy8gR2V0IHNoYXBlIHdvcmxkIHBvc2l0aW9uXG4gICAgICAgIG9yaWVudGF0aW9uLnZtdWx0KHNoYXBlT2Zmc2V0c1tpXSwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0LnZhZGQodGhpcy5wb3NpdGlvbiwgb2Zmc2V0KTtcblxuICAgICAgICAvLyB2ZWMyLnJvdGF0ZShvZmZzZXQsIHNoYXBlT2Zmc2V0c1tpXSwgYm9keUFuZ2xlKTtcbiAgICAgICAgLy8gdmVjMi5hZGQob2Zmc2V0LCBvZmZzZXQsIHRoaXMucG9zaXRpb24pO1xuXG4gICAgICAgIC8vIEdldCBzaGFwZSBBQUJCXG4gICAgICAgIHNoYXBlLmNhbGN1bGF0ZVdvcmxkQUFCQihvZmZzZXQsIG9yaWVudGF0aW9uLCBzaGFwZUFBQkIubG93ZXJCb3VuZCwgc2hhcGVBQUJCLnVwcGVyQm91bmQpO1xuXG4gICAgICAgIGlmKGkgPT09IDApe1xuICAgICAgICAgICAgYWFiYi5jb3B5KHNoYXBlQUFCQik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhYWJiLmV4dGVuZChzaGFwZUFBQkIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5hYWJiTmVlZHNVcGRhdGUgPSBmYWxzZTtcbn07XG5cbnZhciB1aXdfbTEgPSBuZXcgTWF0MygpLFxuICAgIHVpd19tMiA9IG5ldyBNYXQzKCksXG4gICAgdWl3X20zID0gbmV3IE1hdDMoKTtcblxuLyoqXG4gKiBVcGRhdGUgLmluZXJ0aWFXb3JsZCBhbmQgLmludkluZXJ0aWFXb3JsZFxuICogQG1ldGhvZCB1cGRhdGVJbmVydGlhV29ybGRcbiAqL1xuQm9keS5wcm90b3R5cGUudXBkYXRlSW5lcnRpYVdvcmxkID0gZnVuY3Rpb24oZm9yY2Upe1xuICAgIHZhciBJID0gdGhpcy5pbnZJbmVydGlhO1xuICAgIGlmIChJLnggPT09IEkueSAmJiBJLnkgPT09IEkueiAmJiAhZm9yY2UpIHtcbiAgICAgICAgLy8gSWYgaW5lcnRpYSBNID0gcypJLCB3aGVyZSBJIGlzIGlkZW50aXR5IGFuZCBzIGEgc2NhbGFyLCB0aGVuXG4gICAgICAgIC8vICAgIFIqTSpSJyA9IFIqKHMqSSkqUicgPSBzKlIqSSpSJyA9IHMqUipSJyA9IHMqSSA9IE1cbiAgICAgICAgLy8gd2hlcmUgUiBpcyB0aGUgcm90YXRpb24gbWF0cml4LlxuICAgICAgICAvLyBJbiBvdGhlciB3b3Jkcywgd2UgZG9uJ3QgaGF2ZSB0byB0cmFuc2Zvcm0gdGhlIGluZXJ0aWEgaWYgYWxsXG4gICAgICAgIC8vIGluZXJ0aWEgZGlhZ29uYWwgZW50cmllcyBhcmUgZXF1YWwuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG0xID0gdWl3X20xLFxuICAgICAgICAgICAgbTIgPSB1aXdfbTIsXG4gICAgICAgICAgICBtMyA9IHVpd19tMztcbiAgICAgICAgbTEuc2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbih0aGlzLnF1YXRlcm5pb24pO1xuICAgICAgICBtMS50cmFuc3Bvc2UobTIpO1xuICAgICAgICBtMS5zY2FsZShJLG0xKTtcbiAgICAgICAgbTEubW11bHQobTIsdGhpcy5pbnZJbmVydGlhV29ybGQpO1xuICAgICAgICAvL20zLmdldFRyYWNlKHRoaXMuaW52SW5lcnRpYVdvcmxkKTtcbiAgICB9XG5cbiAgICAvKlxuICAgIHRoaXMucXVhdGVybmlvbi52bXVsdCh0aGlzLmluZXJ0aWEsdGhpcy5pbmVydGlhV29ybGQpO1xuICAgIHRoaXMucXVhdGVybmlvbi52bXVsdCh0aGlzLmludkluZXJ0aWEsdGhpcy5pbnZJbmVydGlhV29ybGQpO1xuICAgICovXG59O1xuXG4vKipcbiAqIEFwcGx5IGZvcmNlIHRvIGEgd29ybGQgcG9pbnQuIFRoaXMgY291bGQgZm9yIGV4YW1wbGUgYmUgYSBwb2ludCBvbiB0aGUgQm9keSBzdXJmYWNlLiBBcHBseWluZyBmb3JjZSB0aGlzIHdheSB3aWxsIGFkZCB0byBCb2R5LmZvcmNlIGFuZCBCb2R5LnRvcnF1ZS5cbiAqIEBtZXRob2QgYXBwbHlGb3JjZVxuICogQHBhcmFtICB7VmVjM30gZm9yY2UgVGhlIGFtb3VudCBvZiBmb3JjZSB0byBhZGQuXG4gKiBAcGFyYW0gIHtWZWMzfSB3b3JsZFBvaW50IEEgd29ybGQgcG9pbnQgdG8gYXBwbHkgdGhlIGZvcmNlIG9uLlxuICovXG52YXIgQm9keV9hcHBseUZvcmNlX3IgPSBuZXcgVmVjMygpO1xudmFyIEJvZHlfYXBwbHlGb3JjZV9yb3RGb3JjZSA9IG5ldyBWZWMzKCk7XG5Cb2R5LnByb3RvdHlwZS5hcHBseUZvcmNlID0gZnVuY3Rpb24oZm9yY2Usd29ybGRQb2ludCl7XG4gICAgaWYodGhpcy50eXBlICE9PSBCb2R5LkRZTkFNSUMpe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBwb2ludCBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgYm9keSBjZW50ZXJcbiAgICB2YXIgciA9IEJvZHlfYXBwbHlGb3JjZV9yO1xuICAgIHdvcmxkUG9pbnQudnN1Yih0aGlzLnBvc2l0aW9uLHIpO1xuXG4gICAgLy8gQ29tcHV0ZSBwcm9kdWNlZCByb3RhdGlvbmFsIGZvcmNlXG4gICAgdmFyIHJvdEZvcmNlID0gQm9keV9hcHBseUZvcmNlX3JvdEZvcmNlO1xuICAgIHIuY3Jvc3MoZm9yY2Uscm90Rm9yY2UpO1xuXG4gICAgLy8gQWRkIGxpbmVhciBmb3JjZVxuICAgIHRoaXMuZm9yY2UudmFkZChmb3JjZSx0aGlzLmZvcmNlKTtcblxuICAgIC8vIEFkZCByb3RhdGlvbmFsIGZvcmNlXG4gICAgdGhpcy50b3JxdWUudmFkZChyb3RGb3JjZSx0aGlzLnRvcnF1ZSk7XG59O1xuXG4vKipcbiAqIEFwcGx5IGZvcmNlIHRvIGEgbG9jYWwgcG9pbnQgaW4gdGhlIGJvZHkuXG4gKiBAbWV0aG9kIGFwcGx5TG9jYWxGb3JjZVxuICogQHBhcmFtICB7VmVjM30gZm9yY2UgVGhlIGZvcmNlIHZlY3RvciB0byBhcHBseSwgZGVmaW5lZCBsb2NhbGx5IGluIHRoZSBib2R5IGZyYW1lLlxuICogQHBhcmFtICB7VmVjM30gbG9jYWxQb2ludCBBIGxvY2FsIHBvaW50IGluIHRoZSBib2R5IHRvIGFwcGx5IHRoZSBmb3JjZSBvbi5cbiAqL1xudmFyIEJvZHlfYXBwbHlMb2NhbEZvcmNlX3dvcmxkRm9yY2UgPSBuZXcgVmVjMygpO1xudmFyIEJvZHlfYXBwbHlMb2NhbEZvcmNlX3dvcmxkUG9pbnQgPSBuZXcgVmVjMygpO1xuQm9keS5wcm90b3R5cGUuYXBwbHlMb2NhbEZvcmNlID0gZnVuY3Rpb24obG9jYWxGb3JjZSwgbG9jYWxQb2ludCl7XG4gICAgaWYodGhpcy50eXBlICE9PSBCb2R5LkRZTkFNSUMpe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHdvcmxkRm9yY2UgPSBCb2R5X2FwcGx5TG9jYWxGb3JjZV93b3JsZEZvcmNlO1xuICAgIHZhciB3b3JsZFBvaW50ID0gQm9keV9hcHBseUxvY2FsRm9yY2Vfd29ybGRQb2ludDtcblxuICAgIC8vIFRyYW5zZm9ybSB0aGUgZm9yY2UgdmVjdG9yIHRvIHdvcmxkIHNwYWNlXG4gICAgdGhpcy52ZWN0b3JUb1dvcmxkRnJhbWUobG9jYWxGb3JjZSwgd29ybGRGb3JjZSk7XG4gICAgdGhpcy5wb2ludFRvV29ybGRGcmFtZShsb2NhbFBvaW50LCB3b3JsZFBvaW50KTtcblxuICAgIHRoaXMuYXBwbHlGb3JjZSh3b3JsZEZvcmNlLCB3b3JsZFBvaW50KTtcbn07XG5cbi8qKlxuICogQXBwbHkgaW1wdWxzZSB0byBhIHdvcmxkIHBvaW50LiBUaGlzIGNvdWxkIGZvciBleGFtcGxlIGJlIGEgcG9pbnQgb24gdGhlIEJvZHkgc3VyZmFjZS4gQW4gaW1wdWxzZSBpcyBhIGZvcmNlIGFkZGVkIHRvIGEgYm9keSBkdXJpbmcgYSBzaG9ydCBwZXJpb2Qgb2YgdGltZSAoaW1wdWxzZSA9IGZvcmNlICogdGltZSkuIEltcHVsc2VzIHdpbGwgYmUgYWRkZWQgdG8gQm9keS52ZWxvY2l0eSBhbmQgQm9keS5hbmd1bGFyVmVsb2NpdHkuXG4gKiBAbWV0aG9kIGFwcGx5SW1wdWxzZVxuICogQHBhcmFtICB7VmVjM30gaW1wdWxzZSBUaGUgYW1vdW50IG9mIGltcHVsc2UgdG8gYWRkLlxuICogQHBhcmFtICB7VmVjM30gd29ybGRQb2ludCBBIHdvcmxkIHBvaW50IHRvIGFwcGx5IHRoZSBmb3JjZSBvbi5cbiAqL1xudmFyIEJvZHlfYXBwbHlJbXB1bHNlX3IgPSBuZXcgVmVjMygpO1xudmFyIEJvZHlfYXBwbHlJbXB1bHNlX3ZlbG8gPSBuZXcgVmVjMygpO1xudmFyIEJvZHlfYXBwbHlJbXB1bHNlX3JvdFZlbG8gPSBuZXcgVmVjMygpO1xuQm9keS5wcm90b3R5cGUuYXBwbHlJbXB1bHNlID0gZnVuY3Rpb24oaW1wdWxzZSwgd29ybGRQb2ludCl7XG4gICAgaWYodGhpcy50eXBlICE9PSBCb2R5LkRZTkFNSUMpe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBwb2ludCBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgYm9keSBjZW50ZXJcbiAgICB2YXIgciA9IEJvZHlfYXBwbHlJbXB1bHNlX3I7XG4gICAgd29ybGRQb2ludC52c3ViKHRoaXMucG9zaXRpb24scik7XG5cbiAgICAvLyBDb21wdXRlIHByb2R1Y2VkIGNlbnRyYWwgaW1wdWxzZSB2ZWxvY2l0eVxuICAgIHZhciB2ZWxvID0gQm9keV9hcHBseUltcHVsc2VfdmVsbztcbiAgICB2ZWxvLmNvcHkoaW1wdWxzZSk7XG4gICAgdmVsby5tdWx0KHRoaXMuaW52TWFzcyx2ZWxvKTtcblxuICAgIC8vIEFkZCBsaW5lYXIgaW1wdWxzZVxuICAgIHRoaXMudmVsb2NpdHkudmFkZCh2ZWxvLCB0aGlzLnZlbG9jaXR5KTtcblxuICAgIC8vIENvbXB1dGUgcHJvZHVjZWQgcm90YXRpb25hbCBpbXB1bHNlIHZlbG9jaXR5XG4gICAgdmFyIHJvdFZlbG8gPSBCb2R5X2FwcGx5SW1wdWxzZV9yb3RWZWxvO1xuICAgIHIuY3Jvc3MoaW1wdWxzZSxyb3RWZWxvKTtcblxuICAgIC8qXG4gICAgcm90VmVsby54ICo9IHRoaXMuaW52SW5lcnRpYS54O1xuICAgIHJvdFZlbG8ueSAqPSB0aGlzLmludkluZXJ0aWEueTtcbiAgICByb3RWZWxvLnogKj0gdGhpcy5pbnZJbmVydGlhLno7XG4gICAgKi9cbiAgICB0aGlzLmludkluZXJ0aWFXb3JsZC52bXVsdChyb3RWZWxvLHJvdFZlbG8pO1xuXG4gICAgLy8gQWRkIHJvdGF0aW9uYWwgSW1wdWxzZVxuICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5LnZhZGQocm90VmVsbywgdGhpcy5hbmd1bGFyVmVsb2NpdHkpO1xufTtcblxuLyoqXG4gKiBBcHBseSBsb2NhbGx5LWRlZmluZWQgaW1wdWxzZSB0byBhIGxvY2FsIHBvaW50IGluIHRoZSBib2R5LlxuICogQG1ldGhvZCBhcHBseUxvY2FsSW1wdWxzZVxuICogQHBhcmFtICB7VmVjM30gZm9yY2UgVGhlIGZvcmNlIHZlY3RvciB0byBhcHBseSwgZGVmaW5lZCBsb2NhbGx5IGluIHRoZSBib2R5IGZyYW1lLlxuICogQHBhcmFtICB7VmVjM30gbG9jYWxQb2ludCBBIGxvY2FsIHBvaW50IGluIHRoZSBib2R5IHRvIGFwcGx5IHRoZSBmb3JjZSBvbi5cbiAqL1xudmFyIEJvZHlfYXBwbHlMb2NhbEltcHVsc2Vfd29ybGRJbXB1bHNlID0gbmV3IFZlYzMoKTtcbnZhciBCb2R5X2FwcGx5TG9jYWxJbXB1bHNlX3dvcmxkUG9pbnQgPSBuZXcgVmVjMygpO1xuQm9keS5wcm90b3R5cGUuYXBwbHlMb2NhbEltcHVsc2UgPSBmdW5jdGlvbihsb2NhbEltcHVsc2UsIGxvY2FsUG9pbnQpe1xuICAgIGlmKHRoaXMudHlwZSAhPT0gQm9keS5EWU5BTUlDKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB3b3JsZEltcHVsc2UgPSBCb2R5X2FwcGx5TG9jYWxJbXB1bHNlX3dvcmxkSW1wdWxzZTtcbiAgICB2YXIgd29ybGRQb2ludCA9IEJvZHlfYXBwbHlMb2NhbEltcHVsc2Vfd29ybGRQb2ludDtcblxuICAgIC8vIFRyYW5zZm9ybSB0aGUgZm9yY2UgdmVjdG9yIHRvIHdvcmxkIHNwYWNlXG4gICAgdGhpcy52ZWN0b3JUb1dvcmxkRnJhbWUobG9jYWxJbXB1bHNlLCB3b3JsZEltcHVsc2UpO1xuICAgIHRoaXMucG9pbnRUb1dvcmxkRnJhbWUobG9jYWxQb2ludCwgd29ybGRQb2ludCk7XG5cbiAgICB0aGlzLmFwcGx5SW1wdWxzZSh3b3JsZEltcHVsc2UsIHdvcmxkUG9pbnQpO1xufTtcblxudmFyIEJvZHlfdXBkYXRlTWFzc1Byb3BlcnRpZXNfaGFsZkV4dGVudHMgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgd2hlbmV2ZXIgeW91IGNoYW5nZSB0aGUgYm9keSBzaGFwZSBvciBtYXNzLlxuICogQG1ldGhvZCB1cGRhdGVNYXNzUHJvcGVydGllc1xuICovXG5Cb2R5LnByb3RvdHlwZS51cGRhdGVNYXNzUHJvcGVydGllcyA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGhhbGZFeHRlbnRzID0gQm9keV91cGRhdGVNYXNzUHJvcGVydGllc19oYWxmRXh0ZW50cztcblxuICAgIHRoaXMuaW52TWFzcyA9IHRoaXMubWFzcyA+IDAgPyAxLjAgLyB0aGlzLm1hc3MgOiAwO1xuICAgIHZhciBJID0gdGhpcy5pbmVydGlhO1xuICAgIHZhciBmaXhlZCA9IHRoaXMuZml4ZWRSb3RhdGlvbjtcblxuICAgIC8vIEFwcHJveGltYXRlIHdpdGggQUFCQiBib3hcbiAgICB0aGlzLmNvbXB1dGVBQUJCKCk7XG4gICAgaGFsZkV4dGVudHMuc2V0KFxuICAgICAgICAodGhpcy5hYWJiLnVwcGVyQm91bmQueC10aGlzLmFhYmIubG93ZXJCb3VuZC54KSAvIDIsXG4gICAgICAgICh0aGlzLmFhYmIudXBwZXJCb3VuZC55LXRoaXMuYWFiYi5sb3dlckJvdW5kLnkpIC8gMixcbiAgICAgICAgKHRoaXMuYWFiYi51cHBlckJvdW5kLnotdGhpcy5hYWJiLmxvd2VyQm91bmQueikgLyAyXG4gICAgKTtcbiAgICBCb3guY2FsY3VsYXRlSW5lcnRpYShoYWxmRXh0ZW50cywgdGhpcy5tYXNzLCBJKTtcblxuICAgIHRoaXMuaW52SW5lcnRpYS5zZXQoXG4gICAgICAgIEkueCA+IDAgJiYgIWZpeGVkID8gMS4wIC8gSS54IDogMCxcbiAgICAgICAgSS55ID4gMCAmJiAhZml4ZWQgPyAxLjAgLyBJLnkgOiAwLFxuICAgICAgICBJLnogPiAwICYmICFmaXhlZCA/IDEuMCAvIEkueiA6IDBcbiAgICApO1xuICAgIHRoaXMudXBkYXRlSW5lcnRpYVdvcmxkKHRydWUpO1xufTtcblxuLyoqXG4gKiBHZXQgd29ybGQgdmVsb2NpdHkgb2YgYSBwb2ludCBpbiB0aGUgYm9keS5cbiAqIEBtZXRob2QgZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnRcbiAqIEBwYXJhbSAge1ZlYzN9IHdvcmxkUG9pbnRcbiAqIEBwYXJhbSAge1ZlYzN9IHJlc3VsdFxuICogQHJldHVybiB7VmVjM30gVGhlIHJlc3VsdCB2ZWN0b3IuXG4gKi9cbkJvZHkucHJvdG90eXBlLmdldFZlbG9jaXR5QXRXb3JsZFBvaW50ID0gZnVuY3Rpb24od29ybGRQb2ludCwgcmVzdWx0KXtcbiAgICB2YXIgciA9IG5ldyBWZWMzKCk7XG4gICAgd29ybGRQb2ludC52c3ViKHRoaXMucG9zaXRpb24sIHIpO1xuICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5LmNyb3NzKHIsIHJlc3VsdCk7XG4gICAgdGhpcy52ZWxvY2l0eS52YWRkKHJlc3VsdCwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxufSx7XCIuLi9jb2xsaXNpb24vQUFCQlwiOjMsXCIuLi9tYXRlcmlhbC9NYXRlcmlhbFwiOjI1LFwiLi4vbWF0aC9NYXQzXCI6MjcsXCIuLi9tYXRoL1F1YXRlcm5pb25cIjoyOCxcIi4uL21hdGgvVmVjM1wiOjMwLFwiLi4vc2hhcGVzL0JveFwiOjM3LFwiLi4vc2hhcGVzL1NoYXBlXCI6NDMsXCIuLi91dGlscy9FdmVudFRhcmdldFwiOjQ5fV0sMzI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIEJvZHkgPSBfZGVyZXFfKCcuL0JvZHknKTtcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XG52YXIgUXVhdGVybmlvbiA9IF9kZXJlcV8oJy4uL21hdGgvUXVhdGVybmlvbicpO1xudmFyIFJheWNhc3RSZXN1bHQgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdCcpO1xudmFyIFJheSA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9SYXknKTtcbnZhciBXaGVlbEluZm8gPSBfZGVyZXFfKCcuLi9vYmplY3RzL1doZWVsSW5mbycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJheWNhc3RWZWhpY2xlO1xuXG4vKipcbiAqIFZlaGljbGUgaGVscGVyIGNsYXNzIHRoYXQgY2FzdHMgcmF5cyBmcm9tIHRoZSB3aGVlbCBwb3NpdGlvbnMgdG93YXJkcyB0aGUgZ3JvdW5kIGFuZCBhcHBsaWVzIGZvcmNlcy5cbiAqIEBjbGFzcyBSYXljYXN0VmVoaWNsZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0JvZHl9IFtvcHRpb25zLmNoYXNzaXNCb2R5XSBUaGUgY2FyIGNoYXNzaXMgYm9keS5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdGlvbnMuaW5kZXhSaWdodEF4aXNdIEF4aXMgdG8gdXNlIGZvciByaWdodC4geD0wLCB5PTEsIHo9MlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0aW9ucy5pbmRleExlZnRBeGlzXVxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0aW9ucy5pbmRleFVwQXhpc11cbiAqL1xuZnVuY3Rpb24gUmF5Y2FzdFZlaGljbGUob3B0aW9ucyl7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0JvZHl9IGNoYXNzaXNCb2R5XG4gICAgICovXG4gICAgdGhpcy5jaGFzc2lzQm9keSA9IG9wdGlvbnMuY2hhc3Npc0JvZHk7XG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBXaGVlbEluZm8gb2JqZWN0cy5cbiAgICAgKiBAcHJvcGVydHkge2FycmF5fSB3aGVlbEluZm9zXG4gICAgICovXG4gICAgdGhpcy53aGVlbEluZm9zID0gW107XG5cbiAgICAvKipcbiAgICAgKiBXaWxsIGJlIHNldCB0byB0cnVlIGlmIHRoZSBjYXIgaXMgc2xpZGluZy5cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHNsaWRpbmdcbiAgICAgKi9cbiAgICB0aGlzLnNsaWRpbmcgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7V29ybGR9IHdvcmxkXG4gICAgICovXG4gICAgdGhpcy53b3JsZCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBJbmRleCBvZiB0aGUgcmlnaHQgYXhpcywgMD14LCAxPXksIDI9elxuICAgICAqIEBwcm9wZXJ0eSB7aW50ZWdlcn0gaW5kZXhSaWdodEF4aXNcbiAgICAgKiBAZGVmYXVsdCAxXG4gICAgICovXG4gICAgdGhpcy5pbmRleFJpZ2h0QXhpcyA9IHR5cGVvZihvcHRpb25zLmluZGV4UmlnaHRBeGlzKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmluZGV4UmlnaHRBeGlzIDogMTtcblxuICAgIC8qKlxuICAgICAqIEluZGV4IG9mIHRoZSBmb3J3YXJkIGF4aXMsIDA9eCwgMT15LCAyPXpcbiAgICAgKiBAcHJvcGVydHkge2ludGVnZXJ9IGluZGV4Rm9yd2FyZEF4aXNcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy5pbmRleEZvcndhcmRBeGlzID0gdHlwZW9mKG9wdGlvbnMuaW5kZXhGb3J3YXJkQXhpcykgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5pbmRleEZvcndhcmRBeGlzIDogMDtcblxuICAgIC8qKlxuICAgICAqIEluZGV4IG9mIHRoZSB1cCBheGlzLCAwPXgsIDE9eSwgMj16XG4gICAgICogQHByb3BlcnR5IHtpbnRlZ2VyfSBpbmRleFVwQXhpc1xuICAgICAqIEBkZWZhdWx0IDJcbiAgICAgKi9cbiAgICB0aGlzLmluZGV4VXBBeGlzID0gdHlwZW9mKG9wdGlvbnMuaW5kZXhVcEF4aXMpICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuaW5kZXhVcEF4aXMgOiAyO1xufVxuXG52YXIgdG1wVmVjMSA9IG5ldyBWZWMzKCk7XG52YXIgdG1wVmVjMiA9IG5ldyBWZWMzKCk7XG52YXIgdG1wVmVjMyA9IG5ldyBWZWMzKCk7XG52YXIgdG1wVmVjNCA9IG5ldyBWZWMzKCk7XG52YXIgdG1wVmVjNSA9IG5ldyBWZWMzKCk7XG52YXIgdG1wVmVjNiA9IG5ldyBWZWMzKCk7XG52YXIgdG1wUmF5ID0gbmV3IFJheSgpO1xuXG4vKipcbiAqIEFkZCBhIHdoZWVsLiBGb3IgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9wdGlvbnMsIHNlZSBXaGVlbEluZm8uXG4gKiBAbWV0aG9kIGFkZFdoZWVsXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKi9cblJheWNhc3RWZWhpY2xlLnByb3RvdHlwZS5hZGRXaGVlbCA9IGZ1bmN0aW9uKG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIGluZm8gPSBuZXcgV2hlZWxJbmZvKG9wdGlvbnMpO1xuICAgIHZhciBpbmRleCA9IHRoaXMud2hlZWxJbmZvcy5sZW5ndGg7XG4gICAgdGhpcy53aGVlbEluZm9zLnB1c2goaW5mbyk7XG5cbiAgICByZXR1cm4gaW5kZXg7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgc3RlZXJpbmcgdmFsdWUgb2YgYSB3aGVlbC5cbiAqIEBtZXRob2Qgc2V0U3RlZXJpbmdWYWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHdoZWVsSW5kZXhcbiAqL1xuUmF5Y2FzdFZlaGljbGUucHJvdG90eXBlLnNldFN0ZWVyaW5nVmFsdWUgPSBmdW5jdGlvbih2YWx1ZSwgd2hlZWxJbmRleCl7XG4gICAgdmFyIHdoZWVsID0gdGhpcy53aGVlbEluZm9zW3doZWVsSW5kZXhdO1xuICAgIHdoZWVsLnN0ZWVyaW5nID0gdmFsdWU7XG59O1xuXG52YXIgdG9ycXVlID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBTZXQgdGhlIHdoZWVsIGZvcmNlIHRvIGFwcGx5IG9uIG9uZSBvZiB0aGUgd2hlZWxzIGVhY2ggdGltZSBzdGVwXG4gKiBAbWV0aG9kIGFwcGx5RW5naW5lRm9yY2VcbiAqIEBwYXJhbSAge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSAge2ludGVnZXJ9IHdoZWVsSW5kZXhcbiAqL1xuUmF5Y2FzdFZlaGljbGUucHJvdG90eXBlLmFwcGx5RW5naW5lRm9yY2UgPSBmdW5jdGlvbih2YWx1ZSwgd2hlZWxJbmRleCl7XG4gICAgdGhpcy53aGVlbEluZm9zW3doZWVsSW5kZXhdLmVuZ2luZUZvcmNlID0gdmFsdWU7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgYnJha2luZyBmb3JjZSBvZiBhIHdoZWVsXG4gKiBAbWV0aG9kIHNldEJyYWtlXG4gKiBAcGFyYW0ge251bWJlcn0gYnJha2VcbiAqIEBwYXJhbSB7aW50ZWdlcn0gd2hlZWxJbmRleFxuICovXG5SYXljYXN0VmVoaWNsZS5wcm90b3R5cGUuc2V0QnJha2UgPSBmdW5jdGlvbihicmFrZSwgd2hlZWxJbmRleCl7XG4gICAgdGhpcy53aGVlbEluZm9zW3doZWVsSW5kZXhdLmJyYWtlID0gYnJha2U7XG59O1xuXG4vKipcbiAqIEFkZCB0aGUgdmVoaWNsZSBpbmNsdWRpbmcgaXRzIGNvbnN0cmFpbnRzIHRvIHRoZSB3b3JsZC5cbiAqIEBtZXRob2QgYWRkVG9Xb3JsZFxuICogQHBhcmFtIHtXb3JsZH0gd29ybGRcbiAqL1xuUmF5Y2FzdFZlaGljbGUucHJvdG90eXBlLmFkZFRvV29ybGQgPSBmdW5jdGlvbih3b3JsZCl7XG4gICAgdmFyIGNvbnN0cmFpbnRzID0gdGhpcy5jb25zdHJhaW50cztcbiAgICB3b3JsZC5hZGQodGhpcy5jaGFzc2lzQm9keSk7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHRoaXMucHJlU3RlcENhbGxiYWNrID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdGhhdC51cGRhdGVWZWhpY2xlKHdvcmxkLmR0KTtcbiAgICB9O1xuICAgIHdvcmxkLmFkZEV2ZW50TGlzdGVuZXIoJ3ByZVN0ZXAnLCB0aGlzLnByZVN0ZXBDYWxsYmFjayk7XG4gICAgdGhpcy53b3JsZCA9IHdvcmxkO1xufTtcblxuLyoqXG4gKiBHZXQgb25lIG9mIHRoZSB3aGVlbCBheGxlcywgd29ybGQtb3JpZW50ZWQuXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCBnZXRWZWhpY2xlQXhpc1dvcmxkXG4gKiBAcGFyYW0gIHtpbnRlZ2VyfSBheGlzSW5kZXhcbiAqIEBwYXJhbSAge1ZlYzN9IHJlc3VsdFxuICovXG5SYXljYXN0VmVoaWNsZS5wcm90b3R5cGUuZ2V0VmVoaWNsZUF4aXNXb3JsZCA9IGZ1bmN0aW9uKGF4aXNJbmRleCwgcmVzdWx0KXtcbiAgICByZXN1bHQuc2V0KFxuICAgICAgICBheGlzSW5kZXggPT09IDAgPyAxIDogMCxcbiAgICAgICAgYXhpc0luZGV4ID09PSAxID8gMSA6IDAsXG4gICAgICAgIGF4aXNJbmRleCA9PT0gMiA/IDEgOiAwXG4gICAgKTtcbiAgICB0aGlzLmNoYXNzaXNCb2R5LnZlY3RvclRvV29ybGRGcmFtZShyZXN1bHQsIHJlc3VsdCk7XG59O1xuXG5SYXljYXN0VmVoaWNsZS5wcm90b3R5cGUudXBkYXRlVmVoaWNsZSA9IGZ1bmN0aW9uKHRpbWVTdGVwKXtcbiAgICB2YXIgd2hlZWxJbmZvcyA9IHRoaXMud2hlZWxJbmZvcztcbiAgICB2YXIgbnVtV2hlZWxzID0gd2hlZWxJbmZvcy5sZW5ndGg7XG4gICAgdmFyIGNoYXNzaXNCb2R5ID0gdGhpcy5jaGFzc2lzQm9keTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtV2hlZWxzOyBpKyspIHtcbiAgICAgICAgdGhpcy51cGRhdGVXaGVlbFRyYW5zZm9ybShpKTtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnRWZWhpY2xlU3BlZWRLbUhvdXIgPSAzLjYgKiBjaGFzc2lzQm9keS52ZWxvY2l0eS5ub3JtKCk7XG5cbiAgICB2YXIgZm9yd2FyZFdvcmxkID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLmdldFZlaGljbGVBeGlzV29ybGQodGhpcy5pbmRleEZvcndhcmRBeGlzLCBmb3J3YXJkV29ybGQpO1xuXG4gICAgaWYgKGZvcndhcmRXb3JsZC5kb3QoY2hhc3Npc0JvZHkudmVsb2NpdHkpIDwgMCl7XG4gICAgICAgIHRoaXMuY3VycmVudFZlaGljbGVTcGVlZEttSG91ciAqPSAtMTtcbiAgICB9XG5cbiAgICAvLyBzaW11bGF0ZSBzdXNwZW5zaW9uXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1XaGVlbHM7IGkrKykge1xuICAgICAgICB0aGlzLmNhc3RSYXkod2hlZWxJbmZvc1tpXSk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVTdXNwZW5zaW9uKHRpbWVTdGVwKTtcblxuICAgIHZhciBpbXB1bHNlID0gbmV3IFZlYzMoKTtcbiAgICB2YXIgcmVscG9zID0gbmV3IFZlYzMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVdoZWVsczsgaSsrKSB7XG4gICAgICAgIC8vYXBwbHkgc3VzcGVuc2lvbiBmb3JjZVxuICAgICAgICB2YXIgd2hlZWwgPSB3aGVlbEluZm9zW2ldO1xuICAgICAgICB2YXIgc3VzcGVuc2lvbkZvcmNlID0gd2hlZWwuc3VzcGVuc2lvbkZvcmNlO1xuICAgICAgICBpZiAoc3VzcGVuc2lvbkZvcmNlID4gd2hlZWwubWF4U3VzcGVuc2lvbkZvcmNlKSB7XG4gICAgICAgICAgICBzdXNwZW5zaW9uRm9yY2UgPSB3aGVlbC5tYXhTdXNwZW5zaW9uRm9yY2U7XG4gICAgICAgIH1cbiAgICAgICAgd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZC5zY2FsZShzdXNwZW5zaW9uRm9yY2UgKiB0aW1lU3RlcCwgaW1wdWxzZSk7XG5cbiAgICAgICAgd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkLnZzdWIoY2hhc3Npc0JvZHkucG9zaXRpb24sIHJlbHBvcyk7XG4gICAgICAgIGNoYXNzaXNCb2R5LmFwcGx5SW1wdWxzZShpbXB1bHNlLCB3aGVlbC5yYXljYXN0UmVzdWx0LmhpdFBvaW50V29ybGQvKnJlbHBvcyovKTtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZUZyaWN0aW9uKHRpbWVTdGVwKTtcblxuICAgIHZhciBoaXROb3JtYWxXb3JsZFNjYWxlZFdpdGhQcm9qID0gbmV3IFZlYzMoKTtcbiAgICB2YXIgZndkICA9IG5ldyBWZWMzKCk7XG4gICAgdmFyIHZlbCA9IG5ldyBWZWMzKCk7XG4gICAgZm9yIChpID0gMDsgaSA8IG51bVdoZWVsczsgaSsrKSB7XG4gICAgICAgIHZhciB3aGVlbCA9IHdoZWVsSW5mb3NbaV07XG4gICAgICAgIC8vdmFyIHJlbHBvcyA9IG5ldyBWZWMzKCk7XG4gICAgICAgIC8vd2hlZWwuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludFdvcmxkLnZzdWIoY2hhc3Npc0JvZHkucG9zaXRpb24sIHJlbHBvcyk7XG4gICAgICAgIGNoYXNzaXNCb2R5LmdldFZlbG9jaXR5QXRXb3JsZFBvaW50KHdoZWVsLmNoYXNzaXNDb25uZWN0aW9uUG9pbnRXb3JsZCwgdmVsKTtcblxuICAgICAgICAvLyBIYWNrIHRvIGdldCB0aGUgcm90YXRpb24gaW4gdGhlIGNvcnJlY3QgZGlyZWN0aW9uXG4gICAgICAgIHZhciBtID0gMTtcbiAgICAgICAgc3dpdGNoKHRoaXMuaW5kZXhVcEF4aXMpe1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBtID0gLTE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3aGVlbC5pc0luQ29udGFjdCkge1xuXG4gICAgICAgICAgICB0aGlzLmdldFZlaGljbGVBeGlzV29ybGQodGhpcy5pbmRleEZvcndhcmRBeGlzLCBmd2QpO1xuICAgICAgICAgICAgdmFyIHByb2ogPSBmd2QuZG90KHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQpO1xuICAgICAgICAgICAgd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZC5zY2FsZShwcm9qLCBoaXROb3JtYWxXb3JsZFNjYWxlZFdpdGhQcm9qKTtcblxuICAgICAgICAgICAgZndkLnZzdWIoaGl0Tm9ybWFsV29ybGRTY2FsZWRXaXRoUHJvaiwgZndkKTtcblxuICAgICAgICAgICAgdmFyIHByb2oyID0gZndkLmRvdCh2ZWwpO1xuICAgICAgICAgICAgd2hlZWwuZGVsdGFSb3RhdGlvbiA9IG0gKiBwcm9qMiAqIHRpbWVTdGVwIC8gd2hlZWwucmFkaXVzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoKHdoZWVsLnNsaWRpbmcgfHwgIXdoZWVsLmlzSW5Db250YWN0KSAmJiB3aGVlbC5lbmdpbmVGb3JjZSAhPT0gMCAmJiB3aGVlbC51c2VDdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkKXtcbiAgICAgICAgICAgIC8vIEFwcGx5IGN1c3RvbSByb3RhdGlvbiB3aGVuIGFjY2VsZXJhdGluZyBhbmQgc2xpZGluZ1xuICAgICAgICAgICAgd2hlZWwuZGVsdGFSb3RhdGlvbiA9ICh3aGVlbC5lbmdpbmVGb3JjZSA+IDAgPyAxIDogLTEpICogd2hlZWwuY3VzdG9tU2xpZGluZ1JvdGF0aW9uYWxTcGVlZCAqIHRpbWVTdGVwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTG9jayB3aGVlbHNcbiAgICAgICAgaWYoTWF0aC5hYnMod2hlZWwuYnJha2UpID4gTWF0aC5hYnMod2hlZWwuZW5naW5lRm9yY2UpKXtcbiAgICAgICAgICAgIHdoZWVsLmRlbHRhUm90YXRpb24gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hlZWwucm90YXRpb24gKz0gd2hlZWwuZGVsdGFSb3RhdGlvbjsgLy8gVXNlIHRoZSBvbGQgdmFsdWVcbiAgICAgICAgd2hlZWwuZGVsdGFSb3RhdGlvbiAqPSAwLjk5OyAvLyBkYW1waW5nIG9mIHJvdGF0aW9uIHdoZW4gbm90IGluIGNvbnRhY3RcbiAgICB9XG59O1xuXG5SYXljYXN0VmVoaWNsZS5wcm90b3R5cGUudXBkYXRlU3VzcGVuc2lvbiA9IGZ1bmN0aW9uKGRlbHRhVGltZSkge1xuICAgIHZhciBjaGFzc2lzQm9keSA9IHRoaXMuY2hhc3Npc0JvZHk7XG4gICAgdmFyIGNoYXNzaXNNYXNzID0gY2hhc3Npc0JvZHkubWFzcztcbiAgICB2YXIgd2hlZWxJbmZvcyA9IHRoaXMud2hlZWxJbmZvcztcbiAgICB2YXIgbnVtV2hlZWxzID0gd2hlZWxJbmZvcy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciB3X2l0ID0gMDsgd19pdCA8IG51bVdoZWVsczsgd19pdCsrKXtcbiAgICAgICAgdmFyIHdoZWVsID0gd2hlZWxJbmZvc1t3X2l0XTtcblxuICAgICAgICBpZiAod2hlZWwuaXNJbkNvbnRhY3Qpe1xuICAgICAgICAgICAgdmFyIGZvcmNlO1xuXG4gICAgICAgICAgICAvLyBTcHJpbmdcbiAgICAgICAgICAgIHZhciBzdXNwX2xlbmd0aCA9IHdoZWVsLnN1c3BlbnNpb25SZXN0TGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRfbGVuZ3RoID0gd2hlZWwuc3VzcGVuc2lvbkxlbmd0aDtcbiAgICAgICAgICAgIHZhciBsZW5ndGhfZGlmZiA9IChzdXNwX2xlbmd0aCAtIGN1cnJlbnRfbGVuZ3RoKTtcblxuICAgICAgICAgICAgZm9yY2UgPSB3aGVlbC5zdXNwZW5zaW9uU3RpZmZuZXNzICogbGVuZ3RoX2RpZmYgKiB3aGVlbC5jbGlwcGVkSW52Q29udGFjdERvdFN1c3BlbnNpb247XG5cbiAgICAgICAgICAgIC8vIERhbXBlclxuICAgICAgICAgICAgdmFyIHByb2plY3RlZF9yZWxfdmVsID0gd2hlZWwuc3VzcGVuc2lvblJlbGF0aXZlVmVsb2NpdHk7XG4gICAgICAgICAgICB2YXIgc3VzcF9kYW1waW5nO1xuICAgICAgICAgICAgaWYgKHByb2plY3RlZF9yZWxfdmVsIDwgMCkge1xuICAgICAgICAgICAgICAgIHN1c3BfZGFtcGluZyA9IHdoZWVsLmRhbXBpbmdDb21wcmVzc2lvbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3VzcF9kYW1waW5nID0gd2hlZWwuZGFtcGluZ1JlbGF4YXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3JjZSAtPSBzdXNwX2RhbXBpbmcgKiBwcm9qZWN0ZWRfcmVsX3ZlbDtcblxuICAgICAgICAgICAgd2hlZWwuc3VzcGVuc2lvbkZvcmNlID0gZm9yY2UgKiBjaGFzc2lzTWFzcztcbiAgICAgICAgICAgIGlmICh3aGVlbC5zdXNwZW5zaW9uRm9yY2UgPCAwKSB7XG4gICAgICAgICAgICAgICAgd2hlZWwuc3VzcGVuc2lvbkZvcmNlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoZWVsLnN1c3BlbnNpb25Gb3JjZSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgdmVoaWNsZSBpbmNsdWRpbmcgaXRzIGNvbnN0cmFpbnRzIGZyb20gdGhlIHdvcmxkLlxuICogQG1ldGhvZCByZW1vdmVGcm9tV29ybGRcbiAqIEBwYXJhbSB7V29ybGR9IHdvcmxkXG4gKi9cblJheWNhc3RWZWhpY2xlLnByb3RvdHlwZS5yZW1vdmVGcm9tV29ybGQgPSBmdW5jdGlvbih3b3JsZCl7XG4gICAgdmFyIGNvbnN0cmFpbnRzID0gdGhpcy5jb25zdHJhaW50cztcbiAgICB3b3JsZC5yZW1vdmUodGhpcy5jaGFzc2lzQm9keSk7XG4gICAgd29ybGQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncHJlU3RlcCcsIHRoaXMucHJlU3RlcENhbGxiYWNrKTtcbiAgICB0aGlzLndvcmxkID0gbnVsbDtcbn07XG5cbnZhciBjYXN0UmF5X3JheXZlY3RvciA9IG5ldyBWZWMzKCk7XG52YXIgY2FzdFJheV90YXJnZXQgPSBuZXcgVmVjMygpO1xuUmF5Y2FzdFZlaGljbGUucHJvdG90eXBlLmNhc3RSYXkgPSBmdW5jdGlvbih3aGVlbCkge1xuICAgIHZhciByYXl2ZWN0b3IgPSBjYXN0UmF5X3JheXZlY3RvcjtcbiAgICB2YXIgdGFyZ2V0ID0gY2FzdFJheV90YXJnZXQ7XG5cbiAgICB0aGlzLnVwZGF0ZVdoZWVsVHJhbnNmb3JtV29ybGQod2hlZWwpO1xuICAgIHZhciBjaGFzc2lzQm9keSA9IHRoaXMuY2hhc3Npc0JvZHk7XG5cbiAgICB2YXIgZGVwdGggPSAtMTtcblxuICAgIHZhciByYXlsZW4gPSB3aGVlbC5zdXNwZW5zaW9uUmVzdExlbmd0aCArIHdoZWVsLnJhZGl1cztcblxuICAgIHdoZWVsLmRpcmVjdGlvbldvcmxkLnNjYWxlKHJheWxlbiwgcmF5dmVjdG9yKTtcbiAgICB2YXIgc291cmNlID0gd2hlZWwuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludFdvcmxkO1xuICAgIHNvdXJjZS52YWRkKHJheXZlY3RvciwgdGFyZ2V0KTtcbiAgICB2YXIgcmF5Y2FzdFJlc3VsdCA9IHdoZWVsLnJheWNhc3RSZXN1bHQ7XG5cbiAgICB2YXIgcGFyYW0gPSAwO1xuXG4gICAgcmF5Y2FzdFJlc3VsdC5yZXNldCgpO1xuICAgIC8vIFR1cm4gb2ZmIHJheSBjb2xsaXNpb24gd2l0aCB0aGUgY2hhc3NpcyB0ZW1wb3JhcmlseVxuICAgIHZhciBvbGRTdGF0ZSA9IGNoYXNzaXNCb2R5LmNvbGxpc2lvblJlc3BvbnNlO1xuICAgIGNoYXNzaXNCb2R5LmNvbGxpc2lvblJlc3BvbnNlID0gZmFsc2U7XG5cbiAgICAvLyBDYXN0IHJheSBhZ2FpbnN0IHdvcmxkXG4gICAgdGhpcy53b3JsZC5yYXlUZXN0KHNvdXJjZSwgdGFyZ2V0LCByYXljYXN0UmVzdWx0KTtcbiAgICBjaGFzc2lzQm9keS5jb2xsaXNpb25SZXNwb25zZSA9IG9sZFN0YXRlO1xuXG4gICAgdmFyIG9iamVjdCA9IHJheWNhc3RSZXN1bHQuYm9keTtcblxuICAgIHdoZWVsLnJheWNhc3RSZXN1bHQuZ3JvdW5kT2JqZWN0ID0gMDtcblxuICAgIGlmIChvYmplY3QpIHtcbiAgICAgICAgZGVwdGggPSByYXljYXN0UmVzdWx0LmRpc3RhbmNlO1xuICAgICAgICB3aGVlbC5yYXljYXN0UmVzdWx0LmhpdE5vcm1hbFdvcmxkICA9IHJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQ7XG4gICAgICAgIHdoZWVsLmlzSW5Db250YWN0ID0gdHJ1ZTtcblxuICAgICAgICB2YXIgaGl0RGlzdGFuY2UgPSByYXljYXN0UmVzdWx0LmRpc3RhbmNlO1xuICAgICAgICB3aGVlbC5zdXNwZW5zaW9uTGVuZ3RoID0gaGl0RGlzdGFuY2UgLSB3aGVlbC5yYWRpdXM7XG5cbiAgICAgICAgLy8gY2xhbXAgb24gbWF4IHN1c3BlbnNpb24gdHJhdmVsXG4gICAgICAgIHZhciBtaW5TdXNwZW5zaW9uTGVuZ3RoID0gd2hlZWwuc3VzcGVuc2lvblJlc3RMZW5ndGggLSB3aGVlbC5tYXhTdXNwZW5zaW9uVHJhdmVsO1xuICAgICAgICB2YXIgbWF4U3VzcGVuc2lvbkxlbmd0aCA9IHdoZWVsLnN1c3BlbnNpb25SZXN0TGVuZ3RoICsgd2hlZWwubWF4U3VzcGVuc2lvblRyYXZlbDtcbiAgICAgICAgaWYgKHdoZWVsLnN1c3BlbnNpb25MZW5ndGggPCBtaW5TdXNwZW5zaW9uTGVuZ3RoKSB7XG4gICAgICAgICAgICB3aGVlbC5zdXNwZW5zaW9uTGVuZ3RoID0gbWluU3VzcGVuc2lvbkxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2hlZWwuc3VzcGVuc2lvbkxlbmd0aCA+IG1heFN1c3BlbnNpb25MZW5ndGgpIHtcbiAgICAgICAgICAgIHdoZWVsLnN1c3BlbnNpb25MZW5ndGggPSBtYXhTdXNwZW5zaW9uTGVuZ3RoO1xuICAgICAgICAgICAgd2hlZWwucmF5Y2FzdFJlc3VsdC5yZXNldCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlbm9taW5hdG9yID0gd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZC5kb3Qod2hlZWwuZGlyZWN0aW9uV29ybGQpO1xuXG4gICAgICAgIHZhciBjaGFzc2lzX3ZlbG9jaXR5X2F0X2NvbnRhY3RQb2ludCA9IG5ldyBWZWMzKCk7XG4gICAgICAgIGNoYXNzaXNCb2R5LmdldFZlbG9jaXR5QXRXb3JsZFBvaW50KHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0UG9pbnRXb3JsZCwgY2hhc3Npc192ZWxvY2l0eV9hdF9jb250YWN0UG9pbnQpO1xuXG4gICAgICAgIHZhciBwcm9qVmVsID0gd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZC5kb3QoIGNoYXNzaXNfdmVsb2NpdHlfYXRfY29udGFjdFBvaW50ICk7XG5cbiAgICAgICAgaWYgKGRlbm9taW5hdG9yID49IC0wLjEpIHtcbiAgICAgICAgICAgIHdoZWVsLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5ID0gMDtcbiAgICAgICAgICAgIHdoZWVsLmNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbiA9IDEgLyAwLjE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaW52ID0gLTEgLyBkZW5vbWluYXRvcjtcbiAgICAgICAgICAgIHdoZWVsLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5ID0gcHJvalZlbCAqIGludjtcbiAgICAgICAgICAgIHdoZWVsLmNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbiA9IGludjtcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICAvL3B1dCB3aGVlbCBpbmZvIGFzIGluIHJlc3QgcG9zaXRpb25cbiAgICAgICAgd2hlZWwuc3VzcGVuc2lvbkxlbmd0aCA9IHdoZWVsLnN1c3BlbnNpb25SZXN0TGVuZ3RoICsgMCAqIHdoZWVsLm1heFN1c3BlbnNpb25UcmF2ZWw7XG4gICAgICAgIHdoZWVsLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5ID0gMC4wO1xuICAgICAgICB3aGVlbC5kaXJlY3Rpb25Xb3JsZC5zY2FsZSgtMSwgd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZCk7XG4gICAgICAgIHdoZWVsLmNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbiA9IDEuMDtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVwdGg7XG59O1xuXG5SYXljYXN0VmVoaWNsZS5wcm90b3R5cGUudXBkYXRlV2hlZWxUcmFuc2Zvcm1Xb3JsZCA9IGZ1bmN0aW9uKHdoZWVsKXtcbiAgICB3aGVlbC5pc0luQ29udGFjdCA9IGZhbHNlO1xuICAgIHZhciBjaGFzc2lzQm9keSA9IHRoaXMuY2hhc3Npc0JvZHk7XG4gICAgY2hhc3Npc0JvZHkucG9pbnRUb1dvcmxkRnJhbWUod2hlZWwuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludExvY2FsLCB3aGVlbC5jaGFzc2lzQ29ubmVjdGlvblBvaW50V29ybGQpO1xuICAgIGNoYXNzaXNCb2R5LnZlY3RvclRvV29ybGRGcmFtZSh3aGVlbC5kaXJlY3Rpb25Mb2NhbCwgd2hlZWwuZGlyZWN0aW9uV29ybGQpO1xuICAgIGNoYXNzaXNCb2R5LnZlY3RvclRvV29ybGRGcmFtZSh3aGVlbC5heGxlTG9jYWwsIHdoZWVsLmF4bGVXb3JsZCk7XG59O1xuXG5cbi8qKlxuICogVXBkYXRlIG9uZSBvZiB0aGUgd2hlZWwgdHJhbnNmb3JtLlxuICogTm90ZSB3aGVuIHJlbmRlcmluZyB3aGVlbHM6IGR1cmluZyBlYWNoIHN0ZXAsIHdoZWVsIHRyYW5zZm9ybXMgYXJlIHVwZGF0ZWQgQkVGT1JFIHRoZSBjaGFzc2lzOyBpZS4gdGhlaXIgcG9zaXRpb24gYmVjb21lcyBpbnZhbGlkIGFmdGVyIHRoZSBzdGVwLiBUaHVzIHdoZW4geW91IHJlbmRlciB3aGVlbHMsIHlvdSBtdXN0IHVwZGF0ZSB3aGVlbCB0cmFuc2Zvcm1zIGJlZm9yZSByZW5kZXJpbmcgdGhlbS4gU2VlIHJheWNhc3RWZWhpY2xlIGRlbW8gZm9yIGFuIGV4YW1wbGUuXG4gKiBAbWV0aG9kIHVwZGF0ZVdoZWVsVHJhbnNmb3JtXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHdoZWVsSW5kZXggVGhlIHdoZWVsIGluZGV4IHRvIHVwZGF0ZS5cbiAqL1xuUmF5Y2FzdFZlaGljbGUucHJvdG90eXBlLnVwZGF0ZVdoZWVsVHJhbnNmb3JtID0gZnVuY3Rpb24od2hlZWxJbmRleCl7XG4gICAgdmFyIHVwID0gdG1wVmVjNDtcbiAgICB2YXIgcmlnaHQgPSB0bXBWZWM1O1xuICAgIHZhciBmd2QgPSB0bXBWZWM2O1xuXG4gICAgdmFyIHdoZWVsID0gdGhpcy53aGVlbEluZm9zW3doZWVsSW5kZXhdO1xuICAgIHRoaXMudXBkYXRlV2hlZWxUcmFuc2Zvcm1Xb3JsZCh3aGVlbCk7XG5cbiAgICB3aGVlbC5kaXJlY3Rpb25Mb2NhbC5zY2FsZSgtMSwgdXApO1xuICAgIHJpZ2h0LmNvcHkod2hlZWwuYXhsZUxvY2FsKTtcbiAgICB1cC5jcm9zcyhyaWdodCwgZndkKTtcbiAgICBmd2Qubm9ybWFsaXplKCk7XG4gICAgcmlnaHQubm9ybWFsaXplKCk7XG5cbiAgICAvLyBSb3RhdGUgYXJvdW5kIHN0ZWVyaW5nIG92ZXIgdGhlIHdoZWVsQXhsZVxuICAgIHZhciBzdGVlcmluZyA9IHdoZWVsLnN0ZWVyaW5nO1xuICAgIHZhciBzdGVlcmluZ09ybiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG4gICAgc3RlZXJpbmdPcm4uc2V0RnJvbUF4aXNBbmdsZSh1cCwgc3RlZXJpbmcpO1xuXG4gICAgdmFyIHJvdGF0aW5nT3JuID0gbmV3IFF1YXRlcm5pb24oKTtcbiAgICByb3RhdGluZ09ybi5zZXRGcm9tQXhpc0FuZ2xlKHJpZ2h0LCB3aGVlbC5yb3RhdGlvbik7XG5cbiAgICAvLyBXb3JsZCByb3RhdGlvbiBvZiB0aGUgd2hlZWxcbiAgICB2YXIgcSA9IHdoZWVsLndvcmxkVHJhbnNmb3JtLnF1YXRlcm5pb247XG4gICAgdGhpcy5jaGFzc2lzQm9keS5xdWF0ZXJuaW9uLm11bHQoc3RlZXJpbmdPcm4sIHEpO1xuICAgIHEubXVsdChyb3RhdGluZ09ybiwgcSk7XG5cbiAgICBxLm5vcm1hbGl6ZSgpO1xuXG4gICAgLy8gd29ybGQgcG9zaXRpb24gb2YgdGhlIHdoZWVsXG4gICAgdmFyIHAgPSB3aGVlbC53b3JsZFRyYW5zZm9ybS5wb3NpdGlvbjtcbiAgICBwLmNvcHkod2hlZWwuZGlyZWN0aW9uV29ybGQpO1xuICAgIHAuc2NhbGUod2hlZWwuc3VzcGVuc2lvbkxlbmd0aCwgcCk7XG4gICAgcC52YWRkKHdoZWVsLmNoYXNzaXNDb25uZWN0aW9uUG9pbnRXb3JsZCwgcCk7XG59O1xuXG52YXIgZGlyZWN0aW9ucyA9IFtcbiAgICBuZXcgVmVjMygxLCAwLCAwKSxcbiAgICBuZXcgVmVjMygwLCAxLCAwKSxcbiAgICBuZXcgVmVjMygwLCAwLCAxKVxuXTtcblxuLyoqXG4gKiBHZXQgdGhlIHdvcmxkIHRyYW5zZm9ybSBvZiBvbmUgb2YgdGhlIHdoZWVsc1xuICogQG1ldGhvZCBnZXRXaGVlbFRyYW5zZm9ybVdvcmxkXG4gKiBAcGFyYW0gIHtpbnRlZ2VyfSB3aGVlbEluZGV4XG4gKiBAcmV0dXJuIHtUcmFuc2Zvcm19XG4gKi9cblJheWNhc3RWZWhpY2xlLnByb3RvdHlwZS5nZXRXaGVlbFRyYW5zZm9ybVdvcmxkID0gZnVuY3Rpb24od2hlZWxJbmRleCkge1xuICAgIHJldHVybiB0aGlzLndoZWVsSW5mb3Nbd2hlZWxJbmRleF0ud29ybGRUcmFuc2Zvcm07XG59O1xuXG5cbnZhciB1cGRhdGVGcmljdGlvbl9zdXJmTm9ybWFsV1Nfc2NhbGVkX3Byb2ogPSBuZXcgVmVjMygpO1xudmFyIHVwZGF0ZUZyaWN0aW9uX2F4bGUgPSBbXTtcbnZhciB1cGRhdGVGcmljdGlvbl9mb3J3YXJkV1MgPSBbXTtcbnZhciBzaWRlRnJpY3Rpb25TdGlmZm5lc3MyID0gMTtcblJheWNhc3RWZWhpY2xlLnByb3RvdHlwZS51cGRhdGVGcmljdGlvbiA9IGZ1bmN0aW9uKHRpbWVTdGVwKSB7XG4gICAgdmFyIHN1cmZOb3JtYWxXU19zY2FsZWRfcHJvaiA9IHVwZGF0ZUZyaWN0aW9uX3N1cmZOb3JtYWxXU19zY2FsZWRfcHJvajtcblxuICAgIC8vY2FsY3VsYXRlIHRoZSBpbXB1bHNlLCBzbyB0aGF0IHRoZSB3aGVlbHMgZG9uJ3QgbW92ZSBzaWRld2FyZHNcbiAgICB2YXIgd2hlZWxJbmZvcyA9IHRoaXMud2hlZWxJbmZvcztcbiAgICB2YXIgbnVtV2hlZWxzID0gd2hlZWxJbmZvcy5sZW5ndGg7XG4gICAgdmFyIGNoYXNzaXNCb2R5ID0gdGhpcy5jaGFzc2lzQm9keTtcbiAgICB2YXIgZm9yd2FyZFdTID0gdXBkYXRlRnJpY3Rpb25fZm9yd2FyZFdTO1xuICAgIHZhciBheGxlID0gdXBkYXRlRnJpY3Rpb25fYXhsZTtcblxuICAgIHZhciBudW1XaGVlbHNPbkdyb3VuZCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVdoZWVsczsgaSsrKSB7XG4gICAgICAgIHZhciB3aGVlbCA9IHdoZWVsSW5mb3NbaV07XG5cbiAgICAgICAgdmFyIGdyb3VuZE9iamVjdCA9IHdoZWVsLnJheWNhc3RSZXN1bHQuYm9keTtcbiAgICAgICAgaWYgKGdyb3VuZE9iamVjdCl7XG4gICAgICAgICAgICBudW1XaGVlbHNPbkdyb3VuZCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hlZWwuc2lkZUltcHVsc2UgPSAwO1xuICAgICAgICB3aGVlbC5mb3J3YXJkSW1wdWxzZSA9IDA7XG4gICAgICAgIGlmKCFmb3J3YXJkV1NbaV0pe1xuICAgICAgICAgICAgZm9yd2FyZFdTW2ldID0gbmV3IFZlYzMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZighYXhsZVtpXSl7XG4gICAgICAgICAgICBheGxlW2ldID0gbmV3IFZlYzMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtV2hlZWxzOyBpKyspe1xuICAgICAgICB2YXIgd2hlZWwgPSB3aGVlbEluZm9zW2ldO1xuXG4gICAgICAgIHZhciBncm91bmRPYmplY3QgPSB3aGVlbC5yYXljYXN0UmVzdWx0LmJvZHk7XG5cbiAgICAgICAgaWYgKGdyb3VuZE9iamVjdCkge1xuICAgICAgICAgICAgdmFyIGF4bGVpID0gYXhsZVtpXTtcbiAgICAgICAgICAgIHZhciB3aGVlbFRyYW5zID0gdGhpcy5nZXRXaGVlbFRyYW5zZm9ybVdvcmxkKGkpO1xuXG4gICAgICAgICAgICAvLyBHZXQgd29ybGQgYXhsZVxuICAgICAgICAgICAgd2hlZWxUcmFucy52ZWN0b3JUb1dvcmxkRnJhbWUoZGlyZWN0aW9uc1t0aGlzLmluZGV4UmlnaHRBeGlzXSwgYXhsZWkpO1xuXG4gICAgICAgICAgICB2YXIgc3VyZk5vcm1hbFdTID0gd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZDtcbiAgICAgICAgICAgIHZhciBwcm9qID0gYXhsZWkuZG90KHN1cmZOb3JtYWxXUyk7XG4gICAgICAgICAgICBzdXJmTm9ybWFsV1Muc2NhbGUocHJvaiwgc3VyZk5vcm1hbFdTX3NjYWxlZF9wcm9qKTtcbiAgICAgICAgICAgIGF4bGVpLnZzdWIoc3VyZk5vcm1hbFdTX3NjYWxlZF9wcm9qLCBheGxlaSk7XG4gICAgICAgICAgICBheGxlaS5ub3JtYWxpemUoKTtcblxuICAgICAgICAgICAgc3VyZk5vcm1hbFdTLmNyb3NzKGF4bGVpLCBmb3J3YXJkV1NbaV0pO1xuICAgICAgICAgICAgZm9yd2FyZFdTW2ldLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgICAgICB3aGVlbC5zaWRlSW1wdWxzZSA9IHJlc29sdmVTaW5nbGVCaWxhdGVyYWwoXG4gICAgICAgICAgICAgICAgY2hhc3Npc0JvZHksXG4gICAgICAgICAgICAgICAgd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkLFxuICAgICAgICAgICAgICAgIGdyb3VuZE9iamVjdCxcbiAgICAgICAgICAgICAgICB3aGVlbC5yYXljYXN0UmVzdWx0LmhpdFBvaW50V29ybGQsXG4gICAgICAgICAgICAgICAgYXhsZWlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHdoZWVsLnNpZGVJbXB1bHNlICo9IHNpZGVGcmljdGlvblN0aWZmbmVzczI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2lkZUZhY3RvciA9IDE7XG4gICAgdmFyIGZ3ZEZhY3RvciA9IDAuNTtcblxuICAgIHRoaXMuc2xpZGluZyA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtV2hlZWxzOyBpKyspIHtcbiAgICAgICAgdmFyIHdoZWVsID0gd2hlZWxJbmZvc1tpXTtcbiAgICAgICAgdmFyIGdyb3VuZE9iamVjdCA9IHdoZWVsLnJheWNhc3RSZXN1bHQuYm9keTtcblxuICAgICAgICB2YXIgcm9sbGluZ0ZyaWN0aW9uID0gMDtcblxuICAgICAgICB3aGVlbC5zbGlwSW5mbyA9IDE7XG4gICAgICAgIGlmIChncm91bmRPYmplY3QpIHtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0Um9sbGluZ0ZyaWN0aW9uSW1wdWxzZSA9IDA7XG4gICAgICAgICAgICB2YXIgbWF4SW1wdWxzZSA9IHdoZWVsLmJyYWtlID8gd2hlZWwuYnJha2UgOiBkZWZhdWx0Um9sbGluZ0ZyaWN0aW9uSW1wdWxzZTtcblxuICAgICAgICAgICAgLy8gYnRXaGVlbENvbnRhY3RQb2ludCBjb250YWN0UHQoY2hhc3Npc0JvZHksZ3JvdW5kT2JqZWN0LHdoZWVsSW5mcmF5Y2FzdEluZm8uaGl0UG9pbnRXb3JsZCxmb3J3YXJkV1Nbd2hlZWxdLG1heEltcHVsc2UpO1xuICAgICAgICAgICAgLy8gcm9sbGluZ0ZyaWN0aW9uID0gY2FsY1JvbGxpbmdGcmljdGlvbihjb250YWN0UHQpO1xuICAgICAgICAgICAgcm9sbGluZ0ZyaWN0aW9uID0gY2FsY1JvbGxpbmdGcmljdGlvbihjaGFzc2lzQm9keSwgZ3JvdW5kT2JqZWN0LCB3aGVlbC5yYXljYXN0UmVzdWx0LmhpdFBvaW50V29ybGQsIGZvcndhcmRXU1tpXSwgbWF4SW1wdWxzZSk7XG5cbiAgICAgICAgICAgIHJvbGxpbmdGcmljdGlvbiArPSB3aGVlbC5lbmdpbmVGb3JjZSAqIHRpbWVTdGVwO1xuXG4gICAgICAgICAgICAvLyByb2xsaW5nRnJpY3Rpb24gPSAwO1xuICAgICAgICAgICAgdmFyIGZhY3RvciA9IG1heEltcHVsc2UgLyByb2xsaW5nRnJpY3Rpb247XG4gICAgICAgICAgICB3aGVlbC5zbGlwSW5mbyAqPSBmYWN0b3I7XG4gICAgICAgIH1cblxuICAgICAgICAvL3N3aXRjaCBiZXR3ZWVuIGFjdGl2ZSByb2xsaW5nICh0aHJvdHRsZSksIGJyYWtpbmcgYW5kIG5vbi1hY3RpdmUgcm9sbGluZyBmcmljdGlvbiAobnRocm90dGxlL2JyZWFrKVxuXG4gICAgICAgIHdoZWVsLmZvcndhcmRJbXB1bHNlID0gMDtcbiAgICAgICAgd2hlZWwuc2tpZEluZm8gPSAxO1xuXG4gICAgICAgIGlmIChncm91bmRPYmplY3QpIHtcbiAgICAgICAgICAgIHdoZWVsLnNraWRJbmZvID0gMTtcblxuICAgICAgICAgICAgdmFyIG1heGltcCA9IHdoZWVsLnN1c3BlbnNpb25Gb3JjZSAqIHRpbWVTdGVwICogd2hlZWwuZnJpY3Rpb25TbGlwO1xuICAgICAgICAgICAgdmFyIG1heGltcFNpZGUgPSBtYXhpbXA7XG5cbiAgICAgICAgICAgIHZhciBtYXhpbXBTcXVhcmVkID0gbWF4aW1wICogbWF4aW1wU2lkZTtcblxuICAgICAgICAgICAgd2hlZWwuZm9yd2FyZEltcHVsc2UgPSByb2xsaW5nRnJpY3Rpb247Ly93aGVlbEluZm8uZW5naW5lRm9yY2UqIHRpbWVTdGVwO1xuXG4gICAgICAgICAgICB2YXIgeCA9IHdoZWVsLmZvcndhcmRJbXB1bHNlICogZndkRmFjdG9yO1xuICAgICAgICAgICAgdmFyIHkgPSB3aGVlbC5zaWRlSW1wdWxzZSAqIHNpZGVGYWN0b3I7XG5cbiAgICAgICAgICAgIHZhciBpbXB1bHNlU3F1YXJlZCA9IHggKiB4ICsgeSAqIHk7XG5cbiAgICAgICAgICAgIHdoZWVsLnNsaWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChpbXB1bHNlU3F1YXJlZCA+IG1heGltcFNxdWFyZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNsaWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHdoZWVsLnNsaWRpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgdmFyIGZhY3RvciA9IG1heGltcCAvIE1hdGguc3FydChpbXB1bHNlU3F1YXJlZCk7XG5cbiAgICAgICAgICAgICAgICB3aGVlbC5za2lkSW5mbyAqPSBmYWN0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5zbGlkaW5nKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtV2hlZWxzOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB3aGVlbCA9IHdoZWVsSW5mb3NbaV07XG4gICAgICAgICAgICBpZiAod2hlZWwuc2lkZUltcHVsc2UgIT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAod2hlZWwuc2tpZEluZm8gPCAxKXtcbiAgICAgICAgICAgICAgICAgICAgd2hlZWwuZm9yd2FyZEltcHVsc2UgKj0gd2hlZWwuc2tpZEluZm87XG4gICAgICAgICAgICAgICAgICAgIHdoZWVsLnNpZGVJbXB1bHNlICo9IHdoZWVsLnNraWRJbmZvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFwcGx5IHRoZSBpbXB1bHNlc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtV2hlZWxzOyBpKyspIHtcbiAgICAgICAgdmFyIHdoZWVsID0gd2hlZWxJbmZvc1tpXTtcblxuICAgICAgICB2YXIgcmVsX3BvcyA9IG5ldyBWZWMzKCk7XG4gICAgICAgIC8vd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkLnZzdWIoY2hhc3Npc0JvZHkucG9zaXRpb24sIHJlbF9wb3MpO1xuICAgICAgICAvLyBjYW5ub25zIGFwcGx5aW1wdWxzZSBpcyB1c2luZyB3b3JsZCBjb29yZCBmb3IgdGhlIHBvc2l0aW9uXG4gICAgICAgIHJlbF9wb3MuY29weSh3aGVlbC5yYXljYXN0UmVzdWx0LmhpdFBvaW50V29ybGQpO1xuXG4gICAgICAgIGlmICh3aGVlbC5mb3J3YXJkSW1wdWxzZSAhPT0gMCkge1xuICAgICAgICAgICAgdmFyIGltcHVsc2UgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgZm9yd2FyZFdTW2ldLnNjYWxlKHdoZWVsLmZvcndhcmRJbXB1bHNlLCBpbXB1bHNlKTtcbiAgICAgICAgICAgIGNoYXNzaXNCb2R5LmFwcGx5SW1wdWxzZShpbXB1bHNlLCByZWxfcG9zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3aGVlbC5zaWRlSW1wdWxzZSAhPT0gMCl7XG4gICAgICAgICAgICB2YXIgZ3JvdW5kT2JqZWN0ID0gd2hlZWwucmF5Y2FzdFJlc3VsdC5ib2R5O1xuXG4gICAgICAgICAgICB2YXIgcmVsX3BvczIgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgLy93aGVlbC5yYXljYXN0UmVzdWx0LmhpdFBvaW50V29ybGQudnN1Yihncm91bmRPYmplY3QucG9zaXRpb24sIHJlbF9wb3MyKTtcbiAgICAgICAgICAgIHJlbF9wb3MyLmNvcHkod2hlZWwucmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkKTtcbiAgICAgICAgICAgIHZhciBzaWRlSW1wID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIGF4bGVbaV0uc2NhbGUod2hlZWwuc2lkZUltcHVsc2UsIHNpZGVJbXApO1xuXG4gICAgICAgICAgICAvLyBTY2FsZSB0aGUgcmVsYXRpdmUgcG9zaXRpb24gaW4gdGhlIHVwIGRpcmVjdGlvbiB3aXRoIHJvbGxJbmZsdWVuY2UuXG4gICAgICAgICAgICAvLyBJZiByb2xsSW5mbHVlbmNlIGlzIDEsIHRoZSBpbXB1bHNlIHdpbGwgYmUgYXBwbGllZCBvbiB0aGUgaGl0UG9pbnQgKGVhc3kgdG8gcm9sbCBvdmVyKSwgaWYgaXQgaXMgemVybyBpdCB3aWxsIGJlIGFwcGxpZWQgaW4gdGhlIHNhbWUgcGxhbmUgYXMgdGhlIGNlbnRlciBvZiBtYXNzIChub3QgZWFzeSB0byByb2xsIG92ZXIpLlxuICAgICAgICAgICAgY2hhc3Npc0JvZHkucG9pbnRUb0xvY2FsRnJhbWUocmVsX3BvcywgcmVsX3Bvcyk7XG4gICAgICAgICAgICByZWxfcG9zWyd4eXonW3RoaXMuaW5kZXhVcEF4aXNdXSAqPSB3aGVlbC5yb2xsSW5mbHVlbmNlO1xuICAgICAgICAgICAgY2hhc3Npc0JvZHkucG9pbnRUb1dvcmxkRnJhbWUocmVsX3BvcywgcmVsX3Bvcyk7XG4gICAgICAgICAgICBjaGFzc2lzQm9keS5hcHBseUltcHVsc2Uoc2lkZUltcCwgcmVsX3Bvcyk7XG5cbiAgICAgICAgICAgIC8vYXBwbHkgZnJpY3Rpb24gaW1wdWxzZSBvbiB0aGUgZ3JvdW5kXG4gICAgICAgICAgICBzaWRlSW1wLnNjYWxlKC0xLCBzaWRlSW1wKTtcbiAgICAgICAgICAgIGdyb3VuZE9iamVjdC5hcHBseUltcHVsc2Uoc2lkZUltcCwgcmVsX3BvczIpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIGNhbGNSb2xsaW5nRnJpY3Rpb25fdmVsMSA9IG5ldyBWZWMzKCk7XG52YXIgY2FsY1JvbGxpbmdGcmljdGlvbl92ZWwyID0gbmV3IFZlYzMoKTtcbnZhciBjYWxjUm9sbGluZ0ZyaWN0aW9uX3ZlbCA9IG5ldyBWZWMzKCk7XG5cbmZ1bmN0aW9uIGNhbGNSb2xsaW5nRnJpY3Rpb24oYm9keTAsIGJvZHkxLCBmcmljdGlvblBvc1dvcmxkLCBmcmljdGlvbkRpcmVjdGlvbldvcmxkLCBtYXhJbXB1bHNlKSB7XG4gICAgdmFyIGoxID0gMDtcbiAgICB2YXIgY29udGFjdFBvc1dvcmxkID0gZnJpY3Rpb25Qb3NXb3JsZDtcblxuICAgIC8vIHZhciByZWxfcG9zMSA9IG5ldyBWZWMzKCk7XG4gICAgLy8gdmFyIHJlbF9wb3MyID0gbmV3IFZlYzMoKTtcbiAgICB2YXIgdmVsMSA9IGNhbGNSb2xsaW5nRnJpY3Rpb25fdmVsMTtcbiAgICB2YXIgdmVsMiA9IGNhbGNSb2xsaW5nRnJpY3Rpb25fdmVsMjtcbiAgICB2YXIgdmVsID0gY2FsY1JvbGxpbmdGcmljdGlvbl92ZWw7XG4gICAgLy8gY29udGFjdFBvc1dvcmxkLnZzdWIoYm9keTAucG9zaXRpb24sIHJlbF9wb3MxKTtcbiAgICAvLyBjb250YWN0UG9zV29ybGQudnN1Yihib2R5MS5wb3NpdGlvbiwgcmVsX3BvczIpO1xuXG4gICAgYm9keTAuZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQoY29udGFjdFBvc1dvcmxkLCB2ZWwxKTtcbiAgICBib2R5MS5nZXRWZWxvY2l0eUF0V29ybGRQb2ludChjb250YWN0UG9zV29ybGQsIHZlbDIpO1xuICAgIHZlbDEudnN1Yih2ZWwyLCB2ZWwpO1xuXG4gICAgdmFyIHZyZWwgPSBmcmljdGlvbkRpcmVjdGlvbldvcmxkLmRvdCh2ZWwpO1xuXG4gICAgdmFyIGRlbm9tMCA9IGNvbXB1dGVJbXB1bHNlRGVub21pbmF0b3IoYm9keTAsIGZyaWN0aW9uUG9zV29ybGQsIGZyaWN0aW9uRGlyZWN0aW9uV29ybGQpO1xuICAgIHZhciBkZW5vbTEgPSBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yKGJvZHkxLCBmcmljdGlvblBvc1dvcmxkLCBmcmljdGlvbkRpcmVjdGlvbldvcmxkKTtcbiAgICB2YXIgcmVsYXhhdGlvbiA9IDE7XG4gICAgdmFyIGphY0RpYWdBQkludiA9IHJlbGF4YXRpb24gLyAoZGVub20wICsgZGVub20xKTtcblxuICAgIC8vIGNhbGN1bGF0ZSBqIHRoYXQgbW92ZXMgdXMgdG8gemVybyByZWxhdGl2ZSB2ZWxvY2l0eVxuICAgIGoxID0gLXZyZWwgKiBqYWNEaWFnQUJJbnY7XG5cbiAgICBpZiAobWF4SW1wdWxzZSA8IGoxKSB7XG4gICAgICAgIGoxID0gbWF4SW1wdWxzZTtcbiAgICB9XG4gICAgaWYgKGoxIDwgLW1heEltcHVsc2UpIHtcbiAgICAgICAgajEgPSAtbWF4SW1wdWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gajE7XG59XG5cbnZhciBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yX3IwID0gbmV3IFZlYzMoKTtcbnZhciBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yX2MwID0gbmV3IFZlYzMoKTtcbnZhciBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yX3ZlYyA9IG5ldyBWZWMzKCk7XG52YXIgY29tcHV0ZUltcHVsc2VEZW5vbWluYXRvcl9tID0gbmV3IFZlYzMoKTtcbmZ1bmN0aW9uIGNvbXB1dGVJbXB1bHNlRGVub21pbmF0b3IoYm9keSwgcG9zLCBub3JtYWwpIHtcbiAgICB2YXIgcjAgPSBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yX3IwO1xuICAgIHZhciBjMCA9IGNvbXB1dGVJbXB1bHNlRGVub21pbmF0b3JfYzA7XG4gICAgdmFyIHZlYyA9IGNvbXB1dGVJbXB1bHNlRGVub21pbmF0b3JfdmVjO1xuICAgIHZhciBtID0gY29tcHV0ZUltcHVsc2VEZW5vbWluYXRvcl9tO1xuXG4gICAgcG9zLnZzdWIoYm9keS5wb3NpdGlvbiwgcjApO1xuICAgIHIwLmNyb3NzKG5vcm1hbCwgYzApO1xuICAgIGJvZHkuaW52SW5lcnRpYVdvcmxkLnZtdWx0KGMwLCBtKTtcbiAgICBtLmNyb3NzKHIwLCB2ZWMpO1xuXG4gICAgcmV0dXJuIGJvZHkuaW52TWFzcyArIG5vcm1hbC5kb3QodmVjKTtcbn1cblxuXG52YXIgcmVzb2x2ZVNpbmdsZUJpbGF0ZXJhbF92ZWwxID0gbmV3IFZlYzMoKTtcbnZhciByZXNvbHZlU2luZ2xlQmlsYXRlcmFsX3ZlbDIgPSBuZXcgVmVjMygpO1xudmFyIHJlc29sdmVTaW5nbGVCaWxhdGVyYWxfdmVsID0gbmV3IFZlYzMoKTtcblxuLy9iaWxhdGVyYWwgY29uc3RyYWludCBiZXR3ZWVuIHR3byBkeW5hbWljIG9iamVjdHNcbmZ1bmN0aW9uIHJlc29sdmVTaW5nbGVCaWxhdGVyYWwoYm9keTEsIHBvczEsIGJvZHkyLCBwb3MyLCBub3JtYWwsIGltcHVsc2Upe1xuICAgIHZhciBub3JtYWxMZW5TcXIgPSBub3JtYWwubm9ybTIoKTtcbiAgICBpZiAobm9ybWFsTGVuU3FyID4gMS4xKXtcbiAgICAgICAgcmV0dXJuIDA7IC8vIG5vIGltcHVsc2VcbiAgICB9XG4gICAgLy8gdmFyIHJlbF9wb3MxID0gbmV3IFZlYzMoKTtcbiAgICAvLyB2YXIgcmVsX3BvczIgPSBuZXcgVmVjMygpO1xuICAgIC8vIHBvczEudnN1Yihib2R5MS5wb3NpdGlvbiwgcmVsX3BvczEpO1xuICAgIC8vIHBvczIudnN1Yihib2R5Mi5wb3NpdGlvbiwgcmVsX3BvczIpO1xuXG4gICAgdmFyIHZlbDEgPSByZXNvbHZlU2luZ2xlQmlsYXRlcmFsX3ZlbDE7XG4gICAgdmFyIHZlbDIgPSByZXNvbHZlU2luZ2xlQmlsYXRlcmFsX3ZlbDI7XG4gICAgdmFyIHZlbCA9IHJlc29sdmVTaW5nbGVCaWxhdGVyYWxfdmVsO1xuICAgIGJvZHkxLmdldFZlbG9jaXR5QXRXb3JsZFBvaW50KHBvczEsIHZlbDEpO1xuICAgIGJvZHkyLmdldFZlbG9jaXR5QXRXb3JsZFBvaW50KHBvczIsIHZlbDIpO1xuXG4gICAgdmVsMS52c3ViKHZlbDIsIHZlbCk7XG5cbiAgICB2YXIgcmVsX3ZlbCA9IG5vcm1hbC5kb3QodmVsKTtcblxuICAgIHZhciBjb250YWN0RGFtcGluZyA9IDAuMjtcbiAgICB2YXIgbWFzc1Rlcm0gPSAxIC8gKGJvZHkxLmludk1hc3MgKyBib2R5Mi5pbnZNYXNzKTtcbiAgICB2YXIgaW1wdWxzZSA9IC0gY29udGFjdERhbXBpbmcgKiByZWxfdmVsICogbWFzc1Rlcm07XG5cbiAgICByZXR1cm4gaW1wdWxzZTtcbn1cbn0se1wiLi4vY29sbGlzaW9uL1JheVwiOjksXCIuLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdFwiOjEwLFwiLi4vbWF0aC9RdWF0ZXJuaW9uXCI6MjgsXCIuLi9tYXRoL1ZlYzNcIjozMCxcIi4uL29iamVjdHMvV2hlZWxJbmZvXCI6MzYsXCIuL0JvZHlcIjozMX1dLDMzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBCb2R5ID0gX2RlcmVxXygnLi9Cb2R5Jyk7XG52YXIgU3BoZXJlID0gX2RlcmVxXygnLi4vc2hhcGVzL1NwaGVyZScpO1xudmFyIEJveCA9IF9kZXJlcV8oJy4uL3NoYXBlcy9Cb3gnKTtcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XG52YXIgSGluZ2VDb25zdHJhaW50ID0gX2RlcmVxXygnLi4vY29uc3RyYWludHMvSGluZ2VDb25zdHJhaW50Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmlnaWRWZWhpY2xlO1xuXG4vKipcbiAqIFNpbXBsZSB2ZWhpY2xlIGhlbHBlciBjbGFzcyB3aXRoIHNwaGVyaWNhbCByaWdpZCBib2R5IHdoZWVscy5cbiAqIEBjbGFzcyBSaWdpZFZlaGljbGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtCb2R5fSBbb3B0aW9ucy5jaGFzc2lzQm9keV1cbiAqL1xuZnVuY3Rpb24gUmlnaWRWZWhpY2xlKG9wdGlvbnMpe1xuICAgIHRoaXMud2hlZWxCb2RpZXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBjb29yZGluYXRlU3lzdGVtXG4gICAgICogQHR5cGUge1ZlYzN9XG4gICAgICovXG4gICAgdGhpcy5jb29yZGluYXRlU3lzdGVtID0gdHlwZW9mKG9wdGlvbnMuY29vcmRpbmF0ZVN5c3RlbSk9PT0ndW5kZWZpbmVkJyA/IG5ldyBWZWMzKDEsIDIsIDMpIDogb3B0aW9ucy5jb29yZGluYXRlU3lzdGVtLmNsb25lKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0JvZHl9IGNoYXNzaXNCb2R5XG4gICAgICovXG4gICAgdGhpcy5jaGFzc2lzQm9keSA9IG9wdGlvbnMuY2hhc3Npc0JvZHk7XG5cbiAgICBpZighdGhpcy5jaGFzc2lzQm9keSl7XG4gICAgICAgIC8vIE5vIGNoYXNzaXMgYm9keSBnaXZlbi4gQ3JlYXRlIGl0IVxuICAgICAgICB2YXIgY2hhc3Npc1NoYXBlID0gbmV3IEJveChuZXcgVmVjMyg1LCAyLCAwLjUpKTtcbiAgICAgICAgdGhpcy5jaGFzc2lzQm9keSA9IG5ldyBCb2R5KDEsIGNoYXNzaXNTaGFwZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGNvbnN0cmFpbnRzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuY29uc3RyYWludHMgPSBbXTtcblxuICAgIHRoaXMud2hlZWxBeGVzID0gW107XG4gICAgdGhpcy53aGVlbEZvcmNlcyA9IFtdO1xufVxuXG4vKipcbiAqIEFkZCBhIHdoZWVsXG4gKiBAbWV0aG9kIGFkZFdoZWVsXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pc0Zyb250V2hlZWxdXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLnBvc2l0aW9uXSBQb3NpdGlvbiBvZiB0aGUgd2hlZWwsIGxvY2FsbHkgaW4gdGhlIGNoYXNzaXMgYm9keS5cbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuZGlyZWN0aW9uXSBTbGlkZSBkaXJlY3Rpb24gb2YgdGhlIHdoZWVsIGFsb25nIHRoZSBzdXNwZW5zaW9uLlxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5heGlzXSBBeGlzIG9mIHJvdGF0aW9uIG9mIHRoZSB3aGVlbCwgbG9jYWxseSBkZWZpbmVkIGluIHRoZSBjaGFzc2lzLlxuICogQHBhcmFtIHtCb2R5fSBbb3B0aW9ucy5ib2R5XSBUaGUgd2hlZWwgYm9keS5cbiAqL1xuUmlnaWRWZWhpY2xlLnByb3RvdHlwZS5hZGRXaGVlbCA9IGZ1bmN0aW9uKG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciB3aGVlbEJvZHkgPSBvcHRpb25zLmJvZHk7XG4gICAgaWYoIXdoZWVsQm9keSl7XG4gICAgICAgIHdoZWVsQm9keSA9ICBuZXcgQm9keSgxLCBuZXcgU3BoZXJlKDEuMikpO1xuICAgIH1cbiAgICB0aGlzLndoZWVsQm9kaWVzLnB1c2god2hlZWxCb2R5KTtcbiAgICB0aGlzLndoZWVsRm9yY2VzLnB1c2goMCk7XG5cbiAgICAvLyBQb3NpdGlvbiBjb25zdHJhaW4gd2hlZWxzXG4gICAgdmFyIHplcm8gPSBuZXcgVmVjMygpO1xuICAgIHZhciBwb3NpdGlvbiA9IHR5cGVvZihvcHRpb25zLnBvc2l0aW9uKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLnBvc2l0aW9uLmNsb25lKCkgOiBuZXcgVmVjMygpO1xuXG4gICAgLy8gU2V0IHBvc2l0aW9uIGxvY2FsbHkgdG8gdGhlIGNoYXNzaXNcbiAgICB2YXIgd29ybGRQb3NpdGlvbiA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5jaGFzc2lzQm9keS5wb2ludFRvV29ybGRGcmFtZShwb3NpdGlvbiwgd29ybGRQb3NpdGlvbik7XG4gICAgd2hlZWxCb2R5LnBvc2l0aW9uLnNldCh3b3JsZFBvc2l0aW9uLngsIHdvcmxkUG9zaXRpb24ueSwgd29ybGRQb3NpdGlvbi56KTtcblxuICAgIC8vIENvbnN0cmFpbiB3aGVlbFxuICAgIHZhciBheGlzID0gdHlwZW9mKG9wdGlvbnMuYXhpcykgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5heGlzLmNsb25lKCkgOiBuZXcgVmVjMygwLCAxLCAwKTtcbiAgICB0aGlzLndoZWVsQXhlcy5wdXNoKGF4aXMpO1xuXG4gICAgdmFyIGhpbmdlQ29uc3RyYWludCA9IG5ldyBIaW5nZUNvbnN0cmFpbnQodGhpcy5jaGFzc2lzQm9keSwgd2hlZWxCb2R5LCB7XG4gICAgICAgIHBpdm90QTogcG9zaXRpb24sXG4gICAgICAgIGF4aXNBOiBheGlzLFxuICAgICAgICBwaXZvdEI6IFZlYzMuWkVSTyxcbiAgICAgICAgYXhpc0I6IGF4aXMsXG4gICAgICAgIGNvbGxpZGVDb25uZWN0ZWQ6IGZhbHNlXG4gICAgfSk7XG4gICAgdGhpcy5jb25zdHJhaW50cy5wdXNoKGhpbmdlQ29uc3RyYWludCk7XG5cbiAgICByZXR1cm4gdGhpcy53aGVlbEJvZGllcy5sZW5ndGggLSAxO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHN0ZWVyaW5nIHZhbHVlIG9mIGEgd2hlZWwuXG4gKiBAbWV0aG9kIHNldFN0ZWVyaW5nVmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtpbnRlZ2VyfSB3aGVlbEluZGV4XG4gKiBAdG9kbyBjaGVjayBjb29yZGluYXRlU3lzdGVtXG4gKi9cblJpZ2lkVmVoaWNsZS5wcm90b3R5cGUuc2V0U3RlZXJpbmdWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlLCB3aGVlbEluZGV4KXtcbiAgICAvLyBTZXQgYW5nbGUgb2YgdGhlIGhpbmdlIGF4aXNcbiAgICB2YXIgYXhpcyA9IHRoaXMud2hlZWxBeGVzW3doZWVsSW5kZXhdO1xuXG4gICAgdmFyIGMgPSBNYXRoLmNvcyh2YWx1ZSksXG4gICAgICAgIHMgPSBNYXRoLnNpbih2YWx1ZSksXG4gICAgICAgIHggPSBheGlzLngsXG4gICAgICAgIHkgPSBheGlzLnk7XG4gICAgdGhpcy5jb25zdHJhaW50c1t3aGVlbEluZGV4XS5heGlzQS5zZXQoXG4gICAgICAgIGMqeCAtcyp5LFxuICAgICAgICBzKnggK2MqeSxcbiAgICAgICAgMFxuICAgICk7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgdGFyZ2V0IHJvdGF0aW9uYWwgc3BlZWQgb2YgdGhlIGhpbmdlIGNvbnN0cmFpbnQuXG4gKiBAbWV0aG9kIHNldE1vdG9yU3BlZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtpbnRlZ2VyfSB3aGVlbEluZGV4XG4gKi9cblJpZ2lkVmVoaWNsZS5wcm90b3R5cGUuc2V0TW90b3JTcGVlZCA9IGZ1bmN0aW9uKHZhbHVlLCB3aGVlbEluZGV4KXtcbiAgICB2YXIgaGluZ2VDb25zdHJhaW50ID0gdGhpcy5jb25zdHJhaW50c1t3aGVlbEluZGV4XTtcbiAgICBoaW5nZUNvbnN0cmFpbnQuZW5hYmxlTW90b3IoKTtcbiAgICBoaW5nZUNvbnN0cmFpbnQubW90b3JUYXJnZXRWZWxvY2l0eSA9IHZhbHVlO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHRhcmdldCByb3RhdGlvbmFsIHNwZWVkIG9mIHRoZSBoaW5nZSBjb25zdHJhaW50LlxuICogQG1ldGhvZCBkaXNhYmxlTW90b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtpbnRlZ2VyfSB3aGVlbEluZGV4XG4gKi9cblJpZ2lkVmVoaWNsZS5wcm90b3R5cGUuZGlzYWJsZU1vdG9yID0gZnVuY3Rpb24od2hlZWxJbmRleCl7XG4gICAgdmFyIGhpbmdlQ29uc3RyYWludCA9IHRoaXMuY29uc3RyYWludHNbd2hlZWxJbmRleF07XG4gICAgaGluZ2VDb25zdHJhaW50LmRpc2FibGVNb3RvcigpO1xufTtcblxudmFyIHRvcnF1ZSA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogU2V0IHRoZSB3aGVlbCBmb3JjZSB0byBhcHBseSBvbiBvbmUgb2YgdGhlIHdoZWVscyBlYWNoIHRpbWUgc3RlcFxuICogQG1ldGhvZCBzZXRXaGVlbEZvcmNlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0gIHtpbnRlZ2VyfSB3aGVlbEluZGV4XG4gKi9cblJpZ2lkVmVoaWNsZS5wcm90b3R5cGUuc2V0V2hlZWxGb3JjZSA9IGZ1bmN0aW9uKHZhbHVlLCB3aGVlbEluZGV4KXtcbiAgICB0aGlzLndoZWVsRm9yY2VzW3doZWVsSW5kZXhdID0gdmFsdWU7XG59O1xuXG4vKipcbiAqIEFwcGx5IGEgdG9ycXVlIG9uIG9uZSBvZiB0aGUgd2hlZWxzLlxuICogQG1ldGhvZCBhcHBseVdoZWVsRm9yY2VcbiAqIEBwYXJhbSAge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSAge2ludGVnZXJ9IHdoZWVsSW5kZXhcbiAqL1xuUmlnaWRWZWhpY2xlLnByb3RvdHlwZS5hcHBseVdoZWVsRm9yY2UgPSBmdW5jdGlvbih2YWx1ZSwgd2hlZWxJbmRleCl7XG4gICAgdmFyIGF4aXMgPSB0aGlzLndoZWVsQXhlc1t3aGVlbEluZGV4XTtcbiAgICB2YXIgd2hlZWxCb2R5ID0gdGhpcy53aGVlbEJvZGllc1t3aGVlbEluZGV4XTtcbiAgICB2YXIgYm9keVRvcnF1ZSA9IHdoZWVsQm9keS50b3JxdWU7XG5cbiAgICBheGlzLnNjYWxlKHZhbHVlLCB0b3JxdWUpO1xuICAgIHdoZWVsQm9keS52ZWN0b3JUb1dvcmxkRnJhbWUodG9ycXVlLCB0b3JxdWUpO1xuICAgIGJvZHlUb3JxdWUudmFkZCh0b3JxdWUsIGJvZHlUb3JxdWUpO1xufTtcblxuLyoqXG4gKiBBZGQgdGhlIHZlaGljbGUgaW5jbHVkaW5nIGl0cyBjb25zdHJhaW50cyB0byB0aGUgd29ybGQuXG4gKiBAbWV0aG9kIGFkZFRvV29ybGRcbiAqIEBwYXJhbSB7V29ybGR9IHdvcmxkXG4gKi9cblJpZ2lkVmVoaWNsZS5wcm90b3R5cGUuYWRkVG9Xb3JsZCA9IGZ1bmN0aW9uKHdvcmxkKXtcbiAgICB2YXIgY29uc3RyYWludHMgPSB0aGlzLmNvbnN0cmFpbnRzO1xuICAgIHZhciBib2RpZXMgPSB0aGlzLndoZWVsQm9kaWVzLmNvbmNhdChbdGhpcy5jaGFzc2lzQm9keV0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgd29ybGQuYWRkKGJvZGllc1tpXSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb25zdHJhaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB3b3JsZC5hZGRDb25zdHJhaW50KGNvbnN0cmFpbnRzW2ldKTtcbiAgICB9XG5cbiAgICB3b3JsZC5hZGRFdmVudExpc3RlbmVyKCdwcmVTdGVwJywgdGhpcy5fdXBkYXRlLmJpbmQodGhpcykpO1xufTtcblxuUmlnaWRWZWhpY2xlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgd2hlZWxGb3JjZXMgPSB0aGlzLndoZWVsRm9yY2VzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd2hlZWxGb3JjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5hcHBseVdoZWVsRm9yY2Uod2hlZWxGb3JjZXNbaV0sIGkpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSB2ZWhpY2xlIGluY2x1ZGluZyBpdHMgY29uc3RyYWludHMgZnJvbSB0aGUgd29ybGQuXG4gKiBAbWV0aG9kIHJlbW92ZUZyb21Xb3JsZFxuICogQHBhcmFtIHtXb3JsZH0gd29ybGRcbiAqL1xuUmlnaWRWZWhpY2xlLnByb3RvdHlwZS5yZW1vdmVGcm9tV29ybGQgPSBmdW5jdGlvbih3b3JsZCl7XG4gICAgdmFyIGNvbnN0cmFpbnRzID0gdGhpcy5jb25zdHJhaW50cztcbiAgICB2YXIgYm9kaWVzID0gdGhpcy53aGVlbEJvZGllcy5jb25jYXQoW3RoaXMuY2hhc3Npc0JvZHldKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHdvcmxkLnJlbW92ZShib2RpZXNbaV0pO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29uc3RyYWludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgd29ybGQucmVtb3ZlQ29uc3RyYWludChjb25zdHJhaW50c1tpXSk7XG4gICAgfVxufTtcblxudmFyIHdvcmxkQXhpcyA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogR2V0IGN1cnJlbnQgcm90YXRpb25hbCB2ZWxvY2l0eSBvZiBhIHdoZWVsXG4gKiBAbWV0aG9kIGdldFdoZWVsU3BlZWRcbiAqIEBwYXJhbSB7aW50ZWdlcn0gd2hlZWxJbmRleFxuICovXG5SaWdpZFZlaGljbGUucHJvdG90eXBlLmdldFdoZWVsU3BlZWQgPSBmdW5jdGlvbih3aGVlbEluZGV4KXtcbiAgICB2YXIgYXhpcyA9IHRoaXMud2hlZWxBeGVzW3doZWVsSW5kZXhdO1xuICAgIHZhciB3aGVlbEJvZHkgPSB0aGlzLndoZWVsQm9kaWVzW3doZWVsSW5kZXhdO1xuICAgIHZhciB3ID0gd2hlZWxCb2R5LmFuZ3VsYXJWZWxvY2l0eTtcbiAgICB0aGlzLmNoYXNzaXNCb2R5LnZlY3RvclRvV29ybGRGcmFtZShheGlzLCB3b3JsZEF4aXMpO1xuICAgIHJldHVybiB3LmRvdCh3b3JsZEF4aXMpO1xufTtcblxufSx7XCIuLi9jb25zdHJhaW50cy9IaW5nZUNvbnN0cmFpbnRcIjoxNSxcIi4uL21hdGgvVmVjM1wiOjMwLFwiLi4vc2hhcGVzL0JveFwiOjM3LFwiLi4vc2hhcGVzL1NwaGVyZVwiOjQ0LFwiLi9Cb2R5XCI6MzF9XSwzNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IFNQSFN5c3RlbTtcblxudmFyIFNoYXBlID0gX2RlcmVxXygnLi4vc2hhcGVzL1NoYXBlJyk7XG52YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xudmFyIFF1YXRlcm5pb24gPSBfZGVyZXFfKCcuLi9tYXRoL1F1YXRlcm5pb24nKTtcbnZhciBQYXJ0aWNsZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9QYXJ0aWNsZScpO1xudmFyIEJvZHkgPSBfZGVyZXFfKCcuLi9vYmplY3RzL0JvZHknKTtcbnZhciBNYXRlcmlhbCA9IF9kZXJlcV8oJy4uL21hdGVyaWFsL01hdGVyaWFsJyk7XG5cbi8qKlxuICogU21vb3RoZWQtcGFydGljbGUgaHlkcm9keW5hbWljcyBzeXN0ZW1cbiAqIEBjbGFzcyBTUEhTeXN0ZW1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBTUEhTeXN0ZW0oKXtcbiAgICB0aGlzLnBhcnRpY2xlcyA9IFtdO1xuXHRcbiAgICAvKipcbiAgICAgKiBEZW5zaXR5IG9mIHRoZSBzeXN0ZW0gKGtnL20zKS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZGVuc2l0eVxuICAgICAqL1xuICAgIHRoaXMuZGVuc2l0eSA9IDE7XG5cdFxuICAgIC8qKlxuICAgICAqIERpc3RhbmNlIGJlbG93IHdoaWNoIHR3byBwYXJ0aWNsZXMgYXJlIGNvbnNpZGVyZWQgdG8gYmUgbmVpZ2hib3JzLlxuICAgICAqIEl0IHNob3VsZCBiZSBhZGp1c3RlZCBzbyB0aGVyZSBhcmUgYWJvdXQgMTUtMjAgbmVpZ2hib3IgcGFydGljbGVzIHdpdGhpbiB0aGlzIHJhZGl1cy5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc21vb3RoaW5nUmFkaXVzXG4gICAgICovXG4gICAgdGhpcy5zbW9vdGhpbmdSYWRpdXMgPSAxO1xuICAgIHRoaXMuc3BlZWRPZlNvdW5kID0gMTtcblx0XG4gICAgLyoqXG4gICAgICogVmlzY29zaXR5IG9mIHRoZSBzeXN0ZW0uXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHZpc2Nvc2l0eVxuICAgICAqL1xuICAgIHRoaXMudmlzY29zaXR5ID0gMC4wMTtcbiAgICB0aGlzLmVwcyA9IDAuMDAwMDAxO1xuXG4gICAgLy8gU3R1ZmYgQ29tcHV0ZWQgcGVyIHBhcnRpY2xlXG4gICAgdGhpcy5wcmVzc3VyZXMgPSBbXTtcbiAgICB0aGlzLmRlbnNpdGllcyA9IFtdO1xuICAgIHRoaXMubmVpZ2hib3JzID0gW107XG59XG5cbi8qKlxuICogQWRkIGEgcGFydGljbGUgdG8gdGhlIHN5c3RlbS5cbiAqIEBtZXRob2QgYWRkXG4gKiBAcGFyYW0ge0JvZHl9IHBhcnRpY2xlXG4gKi9cblNQSFN5c3RlbS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24ocGFydGljbGUpe1xuICAgIHRoaXMucGFydGljbGVzLnB1c2gocGFydGljbGUpO1xuICAgIGlmKHRoaXMubmVpZ2hib3JzLmxlbmd0aCA8IHRoaXMucGFydGljbGVzLmxlbmd0aCl7XG4gICAgICAgIHRoaXMubmVpZ2hib3JzLnB1c2goW10pO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgcGFydGljbGUgZnJvbSB0aGUgc3lzdGVtLlxuICogQG1ldGhvZCByZW1vdmVcbiAqIEBwYXJhbSB7Qm9keX0gcGFydGljbGVcbiAqL1xuU1BIU3lzdGVtLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihwYXJ0aWNsZSl7XG4gICAgdmFyIGlkeCA9IHRoaXMucGFydGljbGVzLmluZGV4T2YocGFydGljbGUpO1xuICAgIGlmKGlkeCAhPT0gLTEpe1xuICAgICAgICB0aGlzLnBhcnRpY2xlcy5zcGxpY2UoaWR4LDEpO1xuICAgICAgICBpZih0aGlzLm5laWdoYm9ycy5sZW5ndGggPiB0aGlzLnBhcnRpY2xlcy5sZW5ndGgpe1xuICAgICAgICAgICAgdGhpcy5uZWlnaGJvcnMucG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIEdldCBuZWlnaGJvcnMgd2l0aGluIHNtb290aGluZyB2b2x1bWUsIHNhdmUgaW4gdGhlIGFycmF5IG5laWdoYm9yc1xuICogQG1ldGhvZCBnZXROZWlnaGJvcnNcbiAqIEBwYXJhbSB7Qm9keX0gcGFydGljbGVcbiAqIEBwYXJhbSB7QXJyYXl9IG5laWdoYm9yc1xuICovXG52YXIgU1BIU3lzdGVtX2dldE5laWdoYm9yc19kaXN0ID0gbmV3IFZlYzMoKTtcblNQSFN5c3RlbS5wcm90b3R5cGUuZ2V0TmVpZ2hib3JzID0gZnVuY3Rpb24ocGFydGljbGUsbmVpZ2hib3JzKXtcbiAgICB2YXIgTiA9IHRoaXMucGFydGljbGVzLmxlbmd0aCxcbiAgICAgICAgaWQgPSBwYXJ0aWNsZS5pZCxcbiAgICAgICAgUjIgPSB0aGlzLnNtb290aGluZ1JhZGl1cyAqIHRoaXMuc21vb3RoaW5nUmFkaXVzLFxuICAgICAgICBkaXN0ID0gU1BIU3lzdGVtX2dldE5laWdoYm9yc19kaXN0O1xuICAgIGZvcih2YXIgaT0wOyBpIT09TjsgaSsrKXtcbiAgICAgICAgdmFyIHAgPSB0aGlzLnBhcnRpY2xlc1tpXTtcbiAgICAgICAgcC5wb3NpdGlvbi52c3ViKHBhcnRpY2xlLnBvc2l0aW9uLGRpc3QpO1xuICAgICAgICBpZihpZCE9PXAuaWQgJiYgZGlzdC5ub3JtMigpIDwgUjIpe1xuICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2gocCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vLyBUZW1wIHZlY3RvcnMgZm9yIGNhbGN1bGF0aW9uXG52YXIgU1BIU3lzdGVtX3VwZGF0ZV9kaXN0ID0gbmV3IFZlYzMoKSxcbiAgICBTUEhTeXN0ZW1fdXBkYXRlX2FfcHJlc3N1cmUgPSBuZXcgVmVjMygpLFxuICAgIFNQSFN5c3RlbV91cGRhdGVfYV92aXNjID0gbmV3IFZlYzMoKSxcbiAgICBTUEhTeXN0ZW1fdXBkYXRlX2dyYWRXID0gbmV3IFZlYzMoKSxcbiAgICBTUEhTeXN0ZW1fdXBkYXRlX3JfdmVjID0gbmV3IFZlYzMoKSxcbiAgICBTUEhTeXN0ZW1fdXBkYXRlX3UgPSBuZXcgVmVjMygpOyAvLyBSZWxhdGl2ZSB2ZWxvY2l0eVxuU1BIU3lzdGVtLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBOID0gdGhpcy5wYXJ0aWNsZXMubGVuZ3RoLFxuICAgICAgICBkaXN0ID0gU1BIU3lzdGVtX3VwZGF0ZV9kaXN0LFxuICAgICAgICBjcyA9IHRoaXMuc3BlZWRPZlNvdW5kLFxuICAgICAgICBlcHMgPSB0aGlzLmVwcztcblxuICAgIGZvcih2YXIgaT0wOyBpIT09TjsgaSsrKXtcbiAgICAgICAgdmFyIHAgPSB0aGlzLnBhcnRpY2xlc1tpXTsgLy8gQ3VycmVudCBwYXJ0aWNsZVxuICAgICAgICB2YXIgbmVpZ2hib3JzID0gdGhpcy5uZWlnaGJvcnNbaV07XG5cbiAgICAgICAgLy8gR2V0IG5laWdoYm9yc1xuICAgICAgICBuZWlnaGJvcnMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5nZXROZWlnaGJvcnMocCxuZWlnaGJvcnMpO1xuICAgICAgICBuZWlnaGJvcnMucHVzaCh0aGlzLnBhcnRpY2xlc1tpXSk7IC8vIEFkZCBjdXJyZW50IHRvb1xuICAgICAgICB2YXIgbnVtTmVpZ2hib3JzID0gbmVpZ2hib3JzLmxlbmd0aDtcblxuICAgICAgICAvLyBBY2N1bXVsYXRlIGRlbnNpdHkgZm9yIHRoZSBwYXJ0aWNsZVxuICAgICAgICB2YXIgc3VtID0gMC4wO1xuICAgICAgICBmb3IodmFyIGo9MDsgaiE9PW51bU5laWdoYm9yczsgaisrKXtcblxuICAgICAgICAgICAgLy9wcmludGYoXCJDdXJyZW50IHBhcnRpY2xlIGhhcyBwb3NpdGlvbiAlZiAlZiAlZlxcblwiLG9iamVjdHNbaWRdLnBvcy54KCksb2JqZWN0c1tpZF0ucG9zLnkoKSxvYmplY3RzW2lkXS5wb3MueigpKTtcbiAgICAgICAgICAgIHAucG9zaXRpb24udnN1YihuZWlnaGJvcnNbal0ucG9zaXRpb24sIGRpc3QpO1xuICAgICAgICAgICAgdmFyIGxlbiA9IGRpc3Qubm9ybSgpO1xuXG4gICAgICAgICAgICB2YXIgd2VpZ2h0ID0gdGhpcy53KGxlbik7XG4gICAgICAgICAgICBzdW0gKz0gbmVpZ2hib3JzW2pdLm1hc3MgKiB3ZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTYXZlXG4gICAgICAgIHRoaXMuZGVuc2l0aWVzW2ldID0gc3VtO1xuICAgICAgICB0aGlzLnByZXNzdXJlc1tpXSA9IGNzICogY3MgKiAodGhpcy5kZW5zaXRpZXNbaV0gLSB0aGlzLmRlbnNpdHkpO1xuICAgIH1cblxuICAgIC8vIEFkZCBmb3JjZXNcblxuICAgIC8vIFN1bSB0byB0aGVzZSBhY2NlbGVyYXRpb25zXG4gICAgdmFyIGFfcHJlc3N1cmU9IFNQSFN5c3RlbV91cGRhdGVfYV9wcmVzc3VyZTtcbiAgICB2YXIgYV92aXNjID0gICAgU1BIU3lzdGVtX3VwZGF0ZV9hX3Zpc2M7XG4gICAgdmFyIGdyYWRXID0gICAgIFNQSFN5c3RlbV91cGRhdGVfZ3JhZFc7XG4gICAgdmFyIHJfdmVjID0gICAgIFNQSFN5c3RlbV91cGRhdGVfcl92ZWM7XG4gICAgdmFyIHUgPSAgICAgICAgIFNQSFN5c3RlbV91cGRhdGVfdTtcblxuICAgIGZvcih2YXIgaT0wOyBpIT09TjsgaSsrKXtcblxuICAgICAgICB2YXIgcGFydGljbGUgPSB0aGlzLnBhcnRpY2xlc1tpXTtcblxuICAgICAgICBhX3ByZXNzdXJlLnNldCgwLDAsMCk7XG4gICAgICAgIGFfdmlzYy5zZXQoMCwwLDApO1xuXG4gICAgICAgIC8vIEluaXQgdmFyc1xuICAgICAgICB2YXIgUGlqO1xuICAgICAgICB2YXIgbmFibGE7XG4gICAgICAgIHZhciBWaWo7XG5cbiAgICAgICAgLy8gU3VtIHVwIGZvciBhbGwgb3RoZXIgbmVpZ2hib3JzXG4gICAgICAgIHZhciBuZWlnaGJvcnMgPSB0aGlzLm5laWdoYm9yc1tpXTtcbiAgICAgICAgdmFyIG51bU5laWdoYm9ycyA9IG5laWdoYm9ycy5sZW5ndGg7XG5cbiAgICAgICAgLy9wcmludGYoXCJOZWlnaGJvcnM6IFwiKTtcbiAgICAgICAgZm9yKHZhciBqPTA7IGohPT1udW1OZWlnaGJvcnM7IGorKyl7XG5cbiAgICAgICAgICAgIHZhciBuZWlnaGJvciA9IG5laWdoYm9yc1tqXTtcbiAgICAgICAgICAgIC8vcHJpbnRmKFwiJWQgXCIsbmopO1xuXG4gICAgICAgICAgICAvLyBHZXQgciBvbmNlIGZvciBhbGwuLlxuICAgICAgICAgICAgcGFydGljbGUucG9zaXRpb24udnN1YihuZWlnaGJvci5wb3NpdGlvbixyX3ZlYyk7XG4gICAgICAgICAgICB2YXIgciA9IHJfdmVjLm5vcm0oKTtcblxuICAgICAgICAgICAgLy8gUHJlc3N1cmUgY29udHJpYnV0aW9uXG4gICAgICAgICAgICBQaWogPSAtbmVpZ2hib3IubWFzcyAqICh0aGlzLnByZXNzdXJlc1tpXSAvICh0aGlzLmRlbnNpdGllc1tpXSp0aGlzLmRlbnNpdGllc1tpXSArIGVwcykgKyB0aGlzLnByZXNzdXJlc1tqXSAvICh0aGlzLmRlbnNpdGllc1tqXSp0aGlzLmRlbnNpdGllc1tqXSArIGVwcykpO1xuICAgICAgICAgICAgdGhpcy5ncmFkdyhyX3ZlYywgZ3JhZFcpO1xuICAgICAgICAgICAgLy8gQWRkIHRvIHByZXNzdXJlIGFjY2VsZXJhdGlvblxuICAgICAgICAgICAgZ3JhZFcubXVsdChQaWogLCBncmFkVyk7XG4gICAgICAgICAgICBhX3ByZXNzdXJlLnZhZGQoZ3JhZFcsIGFfcHJlc3N1cmUpO1xuXG4gICAgICAgICAgICAvLyBWaXNjb3NpdHkgY29udHJpYnV0aW9uXG4gICAgICAgICAgICBuZWlnaGJvci52ZWxvY2l0eS52c3ViKHBhcnRpY2xlLnZlbG9jaXR5LCB1KTtcbiAgICAgICAgICAgIHUubXVsdCggMS4wIC8gKDAuMDAwMSt0aGlzLmRlbnNpdGllc1tpXSAqIHRoaXMuZGVuc2l0aWVzW2pdKSAqIHRoaXMudmlzY29zaXR5ICogbmVpZ2hib3IubWFzcyAsIHUgKTtcbiAgICAgICAgICAgIG5hYmxhID0gdGhpcy5uYWJsYXcocik7XG4gICAgICAgICAgICB1Lm11bHQobmFibGEsdSk7XG4gICAgICAgICAgICAvLyBBZGQgdG8gdmlzY29zaXR5IGFjY2VsZXJhdGlvblxuICAgICAgICAgICAgYV92aXNjLnZhZGQoIHUsIGFfdmlzYyApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIGZvcmNlXG4gICAgICAgIGFfdmlzYy5tdWx0KHBhcnRpY2xlLm1hc3MsIGFfdmlzYyk7XG4gICAgICAgIGFfcHJlc3N1cmUubXVsdChwYXJ0aWNsZS5tYXNzLCBhX3ByZXNzdXJlKTtcblxuICAgICAgICAvLyBBZGQgZm9yY2UgdG8gcGFydGljbGVzXG4gICAgICAgIHBhcnRpY2xlLmZvcmNlLnZhZGQoYV92aXNjLCBwYXJ0aWNsZS5mb3JjZSk7XG4gICAgICAgIHBhcnRpY2xlLmZvcmNlLnZhZGQoYV9wcmVzc3VyZSwgcGFydGljbGUuZm9yY2UpO1xuICAgIH1cbn07XG5cbi8vIENhbGN1bGF0ZSB0aGUgd2VpZ2h0IHVzaW5nIHRoZSBXKHIpIHdlaWdodGZ1bmN0aW9uXG5TUEhTeXN0ZW0ucHJvdG90eXBlLncgPSBmdW5jdGlvbihyKXtcbiAgICAvLyAzMTVcbiAgICB2YXIgaCA9IHRoaXMuc21vb3RoaW5nUmFkaXVzO1xuICAgIHJldHVybiAzMTUuMC8oNjQuMCpNYXRoLlBJKk1hdGgucG93KGgsOSkpICogTWF0aC5wb3coaCpoLXIqciwzKTtcbn07XG5cbi8vIGNhbGN1bGF0ZSBncmFkaWVudCBvZiB0aGUgd2VpZ2h0IGZ1bmN0aW9uXG5TUEhTeXN0ZW0ucHJvdG90eXBlLmdyYWR3ID0gZnVuY3Rpb24oclZlYyxyZXN1bHRWZWMpe1xuICAgIHZhciByID0gclZlYy5ub3JtKCksXG4gICAgICAgIGggPSB0aGlzLnNtb290aGluZ1JhZGl1cztcbiAgICByVmVjLm11bHQoOTQ1LjAvKDMyLjAqTWF0aC5QSSpNYXRoLnBvdyhoLDkpKSAqIE1hdGgucG93KChoKmgtcipyKSwyKSAsIHJlc3VsdFZlYyk7XG59O1xuXG4vLyBDYWxjdWxhdGUgbmFibGEoVylcblNQSFN5c3RlbS5wcm90b3R5cGUubmFibGF3ID0gZnVuY3Rpb24ocil7XG4gICAgdmFyIGggPSB0aGlzLnNtb290aGluZ1JhZGl1cztcbiAgICB2YXIgbmFibGEgPSA5NDUuMC8oMzIuMCpNYXRoLlBJKk1hdGgucG93KGgsOSkpICogKGgqaC1yKnIpKig3KnIqciAtIDMqaCpoKTtcbiAgICByZXR1cm4gbmFibGE7XG59O1xuXG59LHtcIi4uL21hdGVyaWFsL01hdGVyaWFsXCI6MjUsXCIuLi9tYXRoL1F1YXRlcm5pb25cIjoyOCxcIi4uL21hdGgvVmVjM1wiOjMwLFwiLi4vb2JqZWN0cy9Cb2R5XCI6MzEsXCIuLi9zaGFwZXMvUGFydGljbGVcIjo0MSxcIi4uL3NoYXBlcy9TaGFwZVwiOjQzfV0sMzU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTcHJpbmc7XG5cbi8qKlxuICogQSBzcHJpbmcsIGNvbm5lY3RpbmcgdHdvIGJvZGllcy5cbiAqXG4gKiBAY2xhc3MgU3ByaW5nXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5yZXN0TGVuZ3RoXSAgIEEgbnVtYmVyID4gMC4gRGVmYXVsdDogMVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnN0aWZmbmVzc10gICAgQSBudW1iZXIgPj0gMC4gRGVmYXVsdDogMTAwXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZGFtcGluZ10gICAgICBBIG51bWJlciA+PSAwLiBEZWZhdWx0OiAxXG4gKiBAcGFyYW0ge1ZlYzN9ICBbb3B0aW9ucy53b3JsZEFuY2hvckFdIFdoZXJlIHRvIGhvb2sgdGhlIHNwcmluZyB0byBib2R5IEEsIGluIHdvcmxkIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtWZWMzfSAgW29wdGlvbnMud29ybGRBbmNob3JCXVxuICogQHBhcmFtIHtWZWMzfSAgW29wdGlvbnMubG9jYWxBbmNob3JBXSBXaGVyZSB0byBob29rIHRoZSBzcHJpbmcgdG8gYm9keSBBLCBpbiBsb2NhbCBib2R5IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtWZWMzfSAgW29wdGlvbnMubG9jYWxBbmNob3JCXVxuICovXG5mdW5jdGlvbiBTcHJpbmcoYm9keUEsYm9keUIsb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBSZXN0IGxlbmd0aCBvZiB0aGUgc3ByaW5nLlxuICAgICAqIEBwcm9wZXJ0eSByZXN0TGVuZ3RoXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc3RMZW5ndGggPSB0eXBlb2Yob3B0aW9ucy5yZXN0TGVuZ3RoKSA9PT0gXCJudW1iZXJcIiA/IG9wdGlvbnMucmVzdExlbmd0aCA6IDE7XG5cbiAgICAvKipcbiAgICAgKiBTdGlmZm5lc3Mgb2YgdGhlIHNwcmluZy5cbiAgICAgKiBAcHJvcGVydHkgc3RpZmZuZXNzXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnN0aWZmbmVzcyA9IG9wdGlvbnMuc3RpZmZuZXNzIHx8IDEwMDtcblxuICAgIC8qKlxuICAgICAqIERhbXBpbmcgb2YgdGhlIHNwcmluZy5cbiAgICAgKiBAcHJvcGVydHkgZGFtcGluZ1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kYW1waW5nID0gb3B0aW9ucy5kYW1waW5nIHx8IDE7XG5cbiAgICAvKipcbiAgICAgKiBGaXJzdCBjb25uZWN0ZWQgYm9keS5cbiAgICAgKiBAcHJvcGVydHkgYm9keUFcbiAgICAgKiBAdHlwZSB7Qm9keX1cbiAgICAgKi9cbiAgICB0aGlzLmJvZHlBID0gYm9keUE7XG5cbiAgICAvKipcbiAgICAgKiBTZWNvbmQgY29ubmVjdGVkIGJvZHkuXG4gICAgICogQHByb3BlcnR5IGJvZHlCXG4gICAgICogQHR5cGUge0JvZHl9XG4gICAgICovXG4gICAgdGhpcy5ib2R5QiA9IGJvZHlCO1xuXG4gICAgLyoqXG4gICAgICogQW5jaG9yIGZvciBib2R5QSBpbiBsb2NhbCBib2R5QSBjb29yZGluYXRlcy5cbiAgICAgKiBAcHJvcGVydHkgbG9jYWxBbmNob3JBXG4gICAgICogQHR5cGUge1ZlYzN9XG4gICAgICovXG4gICAgdGhpcy5sb2NhbEFuY2hvckEgPSBuZXcgVmVjMygpO1xuXG4gICAgLyoqXG4gICAgICogQW5jaG9yIGZvciBib2R5QiBpbiBsb2NhbCBib2R5QiBjb29yZGluYXRlcy5cbiAgICAgKiBAcHJvcGVydHkgbG9jYWxBbmNob3JCXG4gICAgICogQHR5cGUge1ZlYzN9XG4gICAgICovXG4gICAgdGhpcy5sb2NhbEFuY2hvckIgPSBuZXcgVmVjMygpO1xuXG4gICAgaWYob3B0aW9ucy5sb2NhbEFuY2hvckEpe1xuICAgICAgICB0aGlzLmxvY2FsQW5jaG9yQS5jb3B5KG9wdGlvbnMubG9jYWxBbmNob3JBKTtcbiAgICB9XG4gICAgaWYob3B0aW9ucy5sb2NhbEFuY2hvckIpe1xuICAgICAgICB0aGlzLmxvY2FsQW5jaG9yQi5jb3B5KG9wdGlvbnMubG9jYWxBbmNob3JCKTtcbiAgICB9XG4gICAgaWYob3B0aW9ucy53b3JsZEFuY2hvckEpe1xuICAgICAgICB0aGlzLnNldFdvcmxkQW5jaG9yQShvcHRpb25zLndvcmxkQW5jaG9yQSk7XG4gICAgfVxuICAgIGlmKG9wdGlvbnMud29ybGRBbmNob3JCKXtcbiAgICAgICAgdGhpcy5zZXRXb3JsZEFuY2hvckIob3B0aW9ucy53b3JsZEFuY2hvckIpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBTZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5IEEsIHVzaW5nIHdvcmxkIGNvb3JkaW5hdGVzLlxuICogQG1ldGhvZCBzZXRXb3JsZEFuY2hvckFcbiAqIEBwYXJhbSB7VmVjM30gd29ybGRBbmNob3JBXG4gKi9cblNwcmluZy5wcm90b3R5cGUuc2V0V29ybGRBbmNob3JBID0gZnVuY3Rpb24od29ybGRBbmNob3JBKXtcbiAgICB0aGlzLmJvZHlBLnBvaW50VG9Mb2NhbEZyYW1lKHdvcmxkQW5jaG9yQSx0aGlzLmxvY2FsQW5jaG9yQSk7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHkgQiwgdXNpbmcgd29ybGQgY29vcmRpbmF0ZXMuXG4gKiBAbWV0aG9kIHNldFdvcmxkQW5jaG9yQlxuICogQHBhcmFtIHtWZWMzfSB3b3JsZEFuY2hvckJcbiAqL1xuU3ByaW5nLnByb3RvdHlwZS5zZXRXb3JsZEFuY2hvckIgPSBmdW5jdGlvbih3b3JsZEFuY2hvckIpe1xuICAgIHRoaXMuYm9keUIucG9pbnRUb0xvY2FsRnJhbWUod29ybGRBbmNob3JCLHRoaXMubG9jYWxBbmNob3JCKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keSBBLCBpbiB3b3JsZCBjb29yZGluYXRlcy5cbiAqIEBtZXRob2QgZ2V0V29ybGRBbmNob3JBXG4gKiBAcGFyYW0ge1ZlYzN9IHJlc3VsdCBUaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXG4gKi9cblNwcmluZy5wcm90b3R5cGUuZ2V0V29ybGRBbmNob3JBID0gZnVuY3Rpb24ocmVzdWx0KXtcbiAgICB0aGlzLmJvZHlBLnBvaW50VG9Xb3JsZEZyYW1lKHRoaXMubG9jYWxBbmNob3JBLHJlc3VsdCk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHkgQiwgaW4gd29ybGQgY29vcmRpbmF0ZXMuXG4gKiBAbWV0aG9kIGdldFdvcmxkQW5jaG9yQlxuICogQHBhcmFtIHtWZWMzfSByZXN1bHQgVGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxuICovXG5TcHJpbmcucHJvdG90eXBlLmdldFdvcmxkQW5jaG9yQiA9IGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgdGhpcy5ib2R5Qi5wb2ludFRvV29ybGRGcmFtZSh0aGlzLmxvY2FsQW5jaG9yQixyZXN1bHQpO1xufTtcblxudmFyIGFwcGx5Rm9yY2VfciA9ICAgICAgICAgICAgICBuZXcgVmVjMygpLFxuICAgIGFwcGx5Rm9yY2Vfcl91bml0ID0gICAgICAgICBuZXcgVmVjMygpLFxuICAgIGFwcGx5Rm9yY2VfdSA9ICAgICAgICAgICAgICBuZXcgVmVjMygpLFxuICAgIGFwcGx5Rm9yY2VfZiA9ICAgICAgICAgICAgICBuZXcgVmVjMygpLFxuICAgIGFwcGx5Rm9yY2Vfd29ybGRBbmNob3JBID0gICBuZXcgVmVjMygpLFxuICAgIGFwcGx5Rm9yY2Vfd29ybGRBbmNob3JCID0gICBuZXcgVmVjMygpLFxuICAgIGFwcGx5Rm9yY2VfcmkgPSAgICAgICAgICAgICBuZXcgVmVjMygpLFxuICAgIGFwcGx5Rm9yY2VfcmogPSAgICAgICAgICAgICBuZXcgVmVjMygpLFxuICAgIGFwcGx5Rm9yY2VfcmlfeF9mID0gICAgICAgICBuZXcgVmVjMygpLFxuICAgIGFwcGx5Rm9yY2VfcmpfeF9mID0gICAgICAgICBuZXcgVmVjMygpLFxuICAgIGFwcGx5Rm9yY2VfdG1wID0gICAgICAgICAgICBuZXcgVmVjMygpO1xuXG4vKipcbiAqIEFwcGx5IHRoZSBzcHJpbmcgZm9yY2UgdG8gdGhlIGNvbm5lY3RlZCBib2RpZXMuXG4gKiBAbWV0aG9kIGFwcGx5Rm9yY2VcbiAqL1xuU3ByaW5nLnByb3RvdHlwZS5hcHBseUZvcmNlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgayA9IHRoaXMuc3RpZmZuZXNzLFxuICAgICAgICBkID0gdGhpcy5kYW1waW5nLFxuICAgICAgICBsID0gdGhpcy5yZXN0TGVuZ3RoLFxuICAgICAgICBib2R5QSA9IHRoaXMuYm9keUEsXG4gICAgICAgIGJvZHlCID0gdGhpcy5ib2R5QixcbiAgICAgICAgciA9IGFwcGx5Rm9yY2VfcixcbiAgICAgICAgcl91bml0ID0gYXBwbHlGb3JjZV9yX3VuaXQsXG4gICAgICAgIHUgPSBhcHBseUZvcmNlX3UsXG4gICAgICAgIGYgPSBhcHBseUZvcmNlX2YsXG4gICAgICAgIHRtcCA9IGFwcGx5Rm9yY2VfdG1wO1xuXG4gICAgdmFyIHdvcmxkQW5jaG9yQSA9IGFwcGx5Rm9yY2Vfd29ybGRBbmNob3JBLFxuICAgICAgICB3b3JsZEFuY2hvckIgPSBhcHBseUZvcmNlX3dvcmxkQW5jaG9yQixcbiAgICAgICAgcmkgPSBhcHBseUZvcmNlX3JpLFxuICAgICAgICByaiA9IGFwcGx5Rm9yY2VfcmosXG4gICAgICAgIHJpX3hfZiA9IGFwcGx5Rm9yY2VfcmlfeF9mLFxuICAgICAgICByal94X2YgPSBhcHBseUZvcmNlX3JqX3hfZjtcblxuICAgIC8vIEdldCB3b3JsZCBhbmNob3JzXG4gICAgdGhpcy5nZXRXb3JsZEFuY2hvckEod29ybGRBbmNob3JBKTtcbiAgICB0aGlzLmdldFdvcmxkQW5jaG9yQih3b3JsZEFuY2hvckIpO1xuXG4gICAgLy8gR2V0IG9mZnNldCBwb2ludHNcbiAgICB3b3JsZEFuY2hvckEudnN1Yihib2R5QS5wb3NpdGlvbixyaSk7XG4gICAgd29ybGRBbmNob3JCLnZzdWIoYm9keUIucG9zaXRpb24scmopO1xuXG4gICAgLy8gQ29tcHV0ZSBkaXN0YW5jZSB2ZWN0b3IgYmV0d2VlbiB3b3JsZCBhbmNob3IgcG9pbnRzXG4gICAgd29ybGRBbmNob3JCLnZzdWIod29ybGRBbmNob3JBLHIpO1xuICAgIHZhciBybGVuID0gci5ub3JtKCk7XG4gICAgcl91bml0LmNvcHkocik7XG4gICAgcl91bml0Lm5vcm1hbGl6ZSgpO1xuXG4gICAgLy8gQ29tcHV0ZSByZWxhdGl2ZSB2ZWxvY2l0eSBvZiB0aGUgYW5jaG9yIHBvaW50cywgdVxuICAgIGJvZHlCLnZlbG9jaXR5LnZzdWIoYm9keUEudmVsb2NpdHksdSk7XG4gICAgLy8gQWRkIHJvdGF0aW9uYWwgdmVsb2NpdHlcblxuICAgIGJvZHlCLmFuZ3VsYXJWZWxvY2l0eS5jcm9zcyhyaix0bXApO1xuICAgIHUudmFkZCh0bXAsdSk7XG4gICAgYm9keUEuYW5ndWxhclZlbG9jaXR5LmNyb3NzKHJpLHRtcCk7XG4gICAgdS52c3ViKHRtcCx1KTtcblxuICAgIC8vIEYgPSAtIGsgKiAoIHggLSBMICkgLSBEICogKCB1IClcbiAgICByX3VuaXQubXVsdCgtayoocmxlbi1sKSAtIGQqdS5kb3Qocl91bml0KSwgZik7XG5cbiAgICAvLyBBZGQgZm9yY2VzIHRvIGJvZGllc1xuICAgIGJvZHlBLmZvcmNlLnZzdWIoZixib2R5QS5mb3JjZSk7XG4gICAgYm9keUIuZm9yY2UudmFkZChmLGJvZHlCLmZvcmNlKTtcblxuICAgIC8vIEFuZ3VsYXIgZm9yY2VcbiAgICByaS5jcm9zcyhmLHJpX3hfZik7XG4gICAgcmouY3Jvc3MoZixyal94X2YpO1xuICAgIGJvZHlBLnRvcnF1ZS52c3ViKHJpX3hfZixib2R5QS50b3JxdWUpO1xuICAgIGJvZHlCLnRvcnF1ZS52YWRkKHJqX3hfZixib2R5Qi50b3JxdWUpO1xufTtcblxufSx7XCIuLi9tYXRoL1ZlYzNcIjozMH1dLDM2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XG52YXIgVHJhbnNmb3JtID0gX2RlcmVxXygnLi4vbWF0aC9UcmFuc2Zvcm0nKTtcbnZhciBSYXljYXN0UmVzdWx0ID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL1JheWNhc3RSZXN1bHQnKTtcbnZhciBVdGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzL1V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gV2hlZWxJbmZvO1xuXG4vKipcbiAqIEBjbGFzcyBXaGVlbEluZm9cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICpcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludExvY2FsXVxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5jaGFzc2lzQ29ubmVjdGlvblBvaW50V29ybGRdXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmRpcmVjdGlvbkxvY2FsXVxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5kaXJlY3Rpb25Xb3JsZF1cbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuYXhsZUxvY2FsXVxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5heGxlV29ybGRdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3VzcGVuc2lvblJlc3RMZW5ndGg9MV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zdXNwZW5zaW9uTWF4TGVuZ3RoPTJdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucmFkaXVzPTFdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3VzcGVuc2lvblN0aWZmbmVzcz0xMDBdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZGFtcGluZ0NvbXByZXNzaW9uPTEwXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmRhbXBpbmdSZWxheGF0aW9uPTEwXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmZyaWN0aW9uU2xpcD0xMDAwMF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zdGVlcmluZz0wXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJvdGF0aW9uPTBdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZGVsdGFSb3RhdGlvbj0wXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJvbGxJbmZsdWVuY2U9MC4wMV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhTdXNwZW5zaW9uRm9yY2VdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmlzRnJvbnRXaGVlbD10cnVlXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbj0xXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5PTBdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3VzcGVuc2lvbkZvcmNlPTBdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc2tpZEluZm89MF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zdXNwZW5zaW9uTGVuZ3RoPTBdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4U3VzcGVuc2lvblRyYXZlbD0xXVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy51c2VDdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkPWZhbHNlXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmN1c3RvbVNsaWRpbmdSb3RhdGlvbmFsU3BlZWQ9LTAuMV1cbiAqL1xuZnVuY3Rpb24gV2hlZWxJbmZvKG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBVdGlscy5kZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICAgIGNoYXNzaXNDb25uZWN0aW9uUG9pbnRMb2NhbDogbmV3IFZlYzMoKSxcbiAgICAgICAgY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludFdvcmxkOiBuZXcgVmVjMygpLFxuICAgICAgICBkaXJlY3Rpb25Mb2NhbDogbmV3IFZlYzMoKSxcbiAgICAgICAgZGlyZWN0aW9uV29ybGQ6IG5ldyBWZWMzKCksXG4gICAgICAgIGF4bGVMb2NhbDogbmV3IFZlYzMoKSxcbiAgICAgICAgYXhsZVdvcmxkOiBuZXcgVmVjMygpLFxuICAgICAgICBzdXNwZW5zaW9uUmVzdExlbmd0aDogMSxcbiAgICAgICAgc3VzcGVuc2lvbk1heExlbmd0aDogMixcbiAgICAgICAgcmFkaXVzOiAxLFxuICAgICAgICBzdXNwZW5zaW9uU3RpZmZuZXNzOiAxMDAsXG4gICAgICAgIGRhbXBpbmdDb21wcmVzc2lvbjogMTAsXG4gICAgICAgIGRhbXBpbmdSZWxheGF0aW9uOiAxMCxcbiAgICAgICAgZnJpY3Rpb25TbGlwOiAxMDAwMCxcbiAgICAgICAgc3RlZXJpbmc6IDAsXG4gICAgICAgIHJvdGF0aW9uOiAwLFxuICAgICAgICBkZWx0YVJvdGF0aW9uOiAwLFxuICAgICAgICByb2xsSW5mbHVlbmNlOiAwLjAxLFxuICAgICAgICBtYXhTdXNwZW5zaW9uRm9yY2U6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgIGlzRnJvbnRXaGVlbDogdHJ1ZSxcbiAgICAgICAgY2xpcHBlZEludkNvbnRhY3REb3RTdXNwZW5zaW9uOiAxLFxuICAgICAgICBzdXNwZW5zaW9uUmVsYXRpdmVWZWxvY2l0eTogMCxcbiAgICAgICAgc3VzcGVuc2lvbkZvcmNlOiAwLFxuICAgICAgICBza2lkSW5mbzogMCxcbiAgICAgICAgc3VzcGVuc2lvbkxlbmd0aDogMCxcbiAgICAgICAgbWF4U3VzcGVuc2lvblRyYXZlbDogMSxcbiAgICAgICAgdXNlQ3VzdG9tU2xpZGluZ1JvdGF0aW9uYWxTcGVlZDogZmFsc2UsXG4gICAgICAgIGN1c3RvbVNsaWRpbmdSb3RhdGlvbmFsU3BlZWQ6IC0wLjFcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIE1heCB0cmF2ZWwgZGlzdGFuY2Ugb2YgdGhlIHN1c3BlbnNpb24sIGluIG1ldGVycy5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWF4U3VzcGVuc2lvblRyYXZlbFxuICAgICAqL1xuICAgIHRoaXMubWF4U3VzcGVuc2lvblRyYXZlbCA9IG9wdGlvbnMubWF4U3VzcGVuc2lvblRyYXZlbDtcblxuICAgIC8qKlxuICAgICAqIFNwZWVkIHRvIGFwcGx5IHRvIHRoZSB3aGVlbCByb3RhdGlvbiB3aGVuIHRoZSB3aGVlbCBpcyBzbGlkaW5nLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkXG4gICAgICovXG4gICAgdGhpcy5jdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkID0gb3B0aW9ucy5jdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkO1xuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIGN1c3RvbVNsaWRpbmdSb3RhdGlvbmFsU3BlZWQgc2hvdWxkIGJlIHVzZWQuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSB1c2VDdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkXG4gICAgICovXG4gICAgdGhpcy51c2VDdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkID0gb3B0aW9ucy51c2VDdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBzbGlkaW5nXG4gICAgICovXG4gICAgdGhpcy5zbGlkaW5nID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBDb25uZWN0aW9uIHBvaW50LCBkZWZpbmVkIGxvY2FsbHkgaW4gdGhlIGNoYXNzaXMgYm9keSBmcmFtZS5cbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IGNoYXNzaXNDb25uZWN0aW9uUG9pbnRMb2NhbFxuICAgICAqL1xuICAgIHRoaXMuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludExvY2FsID0gb3B0aW9ucy5jaGFzc2lzQ29ubmVjdGlvblBvaW50TG9jYWwuY2xvbmUoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludFdvcmxkXG4gICAgICovXG4gICAgdGhpcy5jaGFzc2lzQ29ubmVjdGlvblBvaW50V29ybGQgPSBvcHRpb25zLmNoYXNzaXNDb25uZWN0aW9uUG9pbnRXb3JsZC5jbG9uZSgpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtWZWMzfSBkaXJlY3Rpb25Mb2NhbFxuICAgICAqL1xuICAgIHRoaXMuZGlyZWN0aW9uTG9jYWwgPSBvcHRpb25zLmRpcmVjdGlvbkxvY2FsLmNsb25lKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IGRpcmVjdGlvbldvcmxkXG4gICAgICovXG4gICAgdGhpcy5kaXJlY3Rpb25Xb3JsZCA9IG9wdGlvbnMuZGlyZWN0aW9uV29ybGQuY2xvbmUoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gYXhsZUxvY2FsXG4gICAgICovXG4gICAgdGhpcy5heGxlTG9jYWwgPSBvcHRpb25zLmF4bGVMb2NhbC5jbG9uZSgpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtWZWMzfSBheGxlV29ybGRcbiAgICAgKi9cbiAgICB0aGlzLmF4bGVXb3JsZCA9IG9wdGlvbnMuYXhsZVdvcmxkLmNsb25lKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc3VzcGVuc2lvblJlc3RMZW5ndGhcbiAgICAgKi9cbiAgICB0aGlzLnN1c3BlbnNpb25SZXN0TGVuZ3RoID0gb3B0aW9ucy5zdXNwZW5zaW9uUmVzdExlbmd0aDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdXNwZW5zaW9uTWF4TGVuZ3RoXG4gICAgICovXG4gICAgdGhpcy5zdXNwZW5zaW9uTWF4TGVuZ3RoID0gb3B0aW9ucy5zdXNwZW5zaW9uTWF4TGVuZ3RoO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHJhZGl1c1xuICAgICAqL1xuICAgIHRoaXMucmFkaXVzID0gb3B0aW9ucy5yYWRpdXM7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc3VzcGVuc2lvblN0aWZmbmVzc1xuICAgICAqL1xuICAgIHRoaXMuc3VzcGVuc2lvblN0aWZmbmVzcyA9IG9wdGlvbnMuc3VzcGVuc2lvblN0aWZmbmVzcztcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYW1waW5nQ29tcHJlc3Npb25cbiAgICAgKi9cbiAgICB0aGlzLmRhbXBpbmdDb21wcmVzc2lvbiA9IG9wdGlvbnMuZGFtcGluZ0NvbXByZXNzaW9uO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRhbXBpbmdSZWxheGF0aW9uXG4gICAgICovXG4gICAgdGhpcy5kYW1waW5nUmVsYXhhdGlvbiA9IG9wdGlvbnMuZGFtcGluZ1JlbGF4YXRpb247XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZnJpY3Rpb25TbGlwXG4gICAgICovXG4gICAgdGhpcy5mcmljdGlvblNsaXAgPSBvcHRpb25zLmZyaWN0aW9uU2xpcDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdGVlcmluZ1xuICAgICAqL1xuICAgIHRoaXMuc3RlZXJpbmcgPSAwO1xuXG4gICAgLyoqXG4gICAgICogUm90YXRpb24gdmFsdWUsIGluIHJhZGlhbnMuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHJvdGF0aW9uXG4gICAgICovXG4gICAgdGhpcy5yb3RhdGlvbiA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZGVsdGFSb3RhdGlvblxuICAgICAqL1xuICAgIHRoaXMuZGVsdGFSb3RhdGlvbiA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gcm9sbEluZmx1ZW5jZVxuICAgICAqL1xuICAgIHRoaXMucm9sbEluZmx1ZW5jZSA9IG9wdGlvbnMucm9sbEluZmx1ZW5jZTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhTdXNwZW5zaW9uRm9yY2VcbiAgICAgKi9cbiAgICB0aGlzLm1heFN1c3BlbnNpb25Gb3JjZSA9IG9wdGlvbnMubWF4U3VzcGVuc2lvbkZvcmNlO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGVuZ2luZUZvcmNlXG4gICAgICovXG4gICAgdGhpcy5lbmdpbmVGb3JjZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYnJha2VcbiAgICAgKi9cbiAgICB0aGlzLmJyYWtlID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpc0Zyb250V2hlZWxcbiAgICAgKi9cbiAgICB0aGlzLmlzRnJvbnRXaGVlbCA9IG9wdGlvbnMuaXNGcm9udFdoZWVsO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvblxuICAgICAqL1xuICAgIHRoaXMuY2xpcHBlZEludkNvbnRhY3REb3RTdXNwZW5zaW9uID0gMTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdXNwZW5zaW9uUmVsYXRpdmVWZWxvY2l0eVxuICAgICAqL1xuICAgIHRoaXMuc3VzcGVuc2lvblJlbGF0aXZlVmVsb2NpdHkgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHN1c3BlbnNpb25Gb3JjZVxuICAgICAqL1xuICAgIHRoaXMuc3VzcGVuc2lvbkZvcmNlID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBza2lkSW5mb1xuICAgICAqL1xuICAgIHRoaXMuc2tpZEluZm8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHN1c3BlbnNpb25MZW5ndGhcbiAgICAgKi9cbiAgICB0aGlzLnN1c3BlbnNpb25MZW5ndGggPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHNpZGVJbXB1bHNlXG4gICAgICovXG4gICAgdGhpcy5zaWRlSW1wdWxzZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZm9yd2FyZEltcHVsc2VcbiAgICAgKi9cbiAgICB0aGlzLmZvcndhcmRJbXB1bHNlID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSByZXN1bHQgZnJvbSByYXljYXN0aW5nXG4gICAgICogQHByb3BlcnR5IHtSYXljYXN0UmVzdWx0fSByYXljYXN0UmVzdWx0XG4gICAgICovXG4gICAgdGhpcy5yYXljYXN0UmVzdWx0ID0gbmV3IFJheWNhc3RSZXN1bHQoKTtcblxuICAgIC8qKlxuICAgICAqIFdoZWVsIHdvcmxkIHRyYW5zZm9ybVxuICAgICAqIEBwcm9wZXJ0eSB7VHJhbnNmb3JtfSB3b3JsZFRyYW5zZm9ybVxuICAgICAqL1xuICAgIHRoaXMud29ybGRUcmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzSW5Db250YWN0XG4gICAgICovXG4gICAgdGhpcy5pc0luQ29udGFjdCA9IGZhbHNlO1xufVxuXG52YXIgY2hhc3Npc192ZWxvY2l0eV9hdF9jb250YWN0UG9pbnQgPSBuZXcgVmVjMygpO1xudmFyIHJlbHBvcyA9IG5ldyBWZWMzKCk7XG52YXIgY2hhc3Npc192ZWxvY2l0eV9hdF9jb250YWN0UG9pbnQgPSBuZXcgVmVjMygpO1xuV2hlZWxJbmZvLnByb3RvdHlwZS51cGRhdGVXaGVlbCA9IGZ1bmN0aW9uKGNoYXNzaXMpe1xuICAgIHZhciByYXljYXN0UmVzdWx0ID0gdGhpcy5yYXljYXN0UmVzdWx0O1xuXG4gICAgaWYgKHRoaXMuaXNJbkNvbnRhY3Qpe1xuICAgICAgICB2YXIgcHJvamVjdD0gcmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZC5kb3QocmF5Y2FzdFJlc3VsdC5kaXJlY3Rpb25Xb3JsZCk7XG4gICAgICAgIHJheWNhc3RSZXN1bHQuaGl0UG9pbnRXb3JsZC52c3ViKGNoYXNzaXMucG9zaXRpb24sIHJlbHBvcyk7XG4gICAgICAgIGNoYXNzaXMuZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQocmVscG9zLCBjaGFzc2lzX3ZlbG9jaXR5X2F0X2NvbnRhY3RQb2ludCk7XG4gICAgICAgIHZhciBwcm9qVmVsID0gcmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZC5kb3QoIGNoYXNzaXNfdmVsb2NpdHlfYXRfY29udGFjdFBvaW50ICk7XG4gICAgICAgIGlmIChwcm9qZWN0ID49IC0wLjEpIHtcbiAgICAgICAgICAgIHRoaXMuc3VzcGVuc2lvblJlbGF0aXZlVmVsb2NpdHkgPSAwLjA7XG4gICAgICAgICAgICB0aGlzLmNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbiA9IDEuMCAvIDAuMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpbnYgPSAtMSAvIHByb2plY3Q7XG4gICAgICAgICAgICB0aGlzLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5ID0gcHJvalZlbCAqIGludjtcbiAgICAgICAgICAgIHRoaXMuY2xpcHBlZEludkNvbnRhY3REb3RTdXNwZW5zaW9uID0gaW52O1xuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb3QgaW4gY29udGFjdCA6IHBvc2l0aW9uIHdoZWVsIGluIGEgbmljZSAocmVzdCBsZW5ndGgpIHBvc2l0aW9uXG4gICAgICAgIHJheWNhc3RSZXN1bHQuc3VzcGVuc2lvbkxlbmd0aCA9IHRoaXMuc3VzcGVuc2lvblJlc3RMZW5ndGg7XG4gICAgICAgIHRoaXMuc3VzcGVuc2lvblJlbGF0aXZlVmVsb2NpdHkgPSAwLjA7XG4gICAgICAgIHJheWNhc3RSZXN1bHQuZGlyZWN0aW9uV29ybGQuc2NhbGUoLTEsIHJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQpO1xuICAgICAgICB0aGlzLmNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbiA9IDEuMDtcbiAgICB9XG59O1xufSx7XCIuLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdFwiOjEwLFwiLi4vbWF0aC9UcmFuc2Zvcm1cIjoyOSxcIi4uL21hdGgvVmVjM1wiOjMwLFwiLi4vdXRpbHMvVXRpbHNcIjo1M31dLDM3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gQm94O1xuXG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuL1NoYXBlJyk7XG52YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xudmFyIENvbnZleFBvbHloZWRyb24gPSBfZGVyZXFfKCcuL0NvbnZleFBvbHloZWRyb24nKTtcblxuLyoqXG4gKiBBIDNkIGJveCBzaGFwZS5cbiAqIEBjbGFzcyBCb3hcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtWZWMzfSBoYWxmRXh0ZW50c1xuICogQGF1dGhvciBzY2h0ZXBwZVxuICogQGV4dGVuZHMgU2hhcGVcbiAqL1xuZnVuY3Rpb24gQm94KGhhbGZFeHRlbnRzKXtcbiAgICBTaGFwZS5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy50eXBlID0gU2hhcGUudHlwZXMuQk9YO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGhhbGZFeHRlbnRzXG4gICAgICogQHR5cGUge1ZlYzN9XG4gICAgICovXG4gICAgdGhpcy5oYWxmRXh0ZW50cyA9IGhhbGZFeHRlbnRzO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSB0aGUgY29udGFjdCBnZW5lcmF0b3IgdG8gbWFrZSBjb250YWN0cyB3aXRoIG90aGVyIGNvbnZleCBwb2x5aGVkcmEgZm9yIGV4YW1wbGVcbiAgICAgKiBAcHJvcGVydHkgY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uXG4gICAgICogQHR5cGUge0NvbnZleFBvbHloZWRyb259XG4gICAgICovXG4gICAgdGhpcy5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24gPSBudWxsO1xuXG4gICAgdGhpcy51cGRhdGVDb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24oKTtcbiAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCk7XG59XG5Cb3gucHJvdG90eXBlID0gbmV3IFNoYXBlKCk7XG5Cb3gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQm94O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIGxvY2FsIGNvbnZleCBwb2x5aGVkcm9uIHJlcHJlc2VudGF0aW9uIHVzZWQgZm9yIHNvbWUgY29sbGlzaW9ucy5cbiAqIEBtZXRob2QgdXBkYXRlQ29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uXG4gKi9cbkJveC5wcm90b3R5cGUudXBkYXRlQ29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgc3ggPSB0aGlzLmhhbGZFeHRlbnRzLng7XG4gICAgdmFyIHN5ID0gdGhpcy5oYWxmRXh0ZW50cy55O1xuICAgIHZhciBzeiA9IHRoaXMuaGFsZkV4dGVudHMuejtcbiAgICB2YXIgViA9IFZlYzM7XG5cbiAgICB2YXIgdmVydGljZXMgPSBbXG4gICAgICAgIG5ldyBWKC1zeCwtc3ksLXN6KSxcbiAgICAgICAgbmV3IFYoIHN4LC1zeSwtc3opLFxuICAgICAgICBuZXcgViggc3gsIHN5LC1zeiksXG4gICAgICAgIG5ldyBWKC1zeCwgc3ksLXN6KSxcbiAgICAgICAgbmV3IFYoLXN4LC1zeSwgc3opLFxuICAgICAgICBuZXcgViggc3gsLXN5LCBzeiksXG4gICAgICAgIG5ldyBWKCBzeCwgc3ksIHN6KSxcbiAgICAgICAgbmV3IFYoLXN4LCBzeSwgc3opXG4gICAgXTtcblxuICAgIHZhciBpbmRpY2VzID0gW1xuICAgICAgICBbMywyLDEsMF0sIC8vIC16XG4gICAgICAgIFs0LDUsNiw3XSwgLy8gK3pcbiAgICAgICAgWzUsNCwwLDFdLCAvLyAteVxuICAgICAgICBbMiwzLDcsNl0sIC8vICt5XG4gICAgICAgIFswLDQsNywzXSwgLy8gLXhcbiAgICAgICAgWzEsMiw2LDVdLCAvLyAreFxuICAgIF07XG5cbiAgICB2YXIgYXhlcyA9IFtcbiAgICAgICAgbmV3IFYoMCwgMCwgMSksXG4gICAgICAgIG5ldyBWKDAsIDEsIDApLFxuICAgICAgICBuZXcgVigxLCAwLCAwKVxuICAgIF07XG5cbiAgICB2YXIgaCA9IG5ldyBDb252ZXhQb2x5aGVkcm9uKHZlcnRpY2VzLCBpbmRpY2VzKTtcbiAgICB0aGlzLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbiA9IGg7XG4gICAgaC5tYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWw7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgY2FsY3VsYXRlTG9jYWxJbmVydGlhXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG1hc3NcbiAqIEBwYXJhbSAge1ZlYzN9IHRhcmdldFxuICogQHJldHVybiB7VmVjM31cbiAqL1xuQm94LnByb3RvdHlwZS5jYWxjdWxhdGVMb2NhbEluZXJ0aWEgPSBmdW5jdGlvbihtYXNzLHRhcmdldCl7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBWZWMzKCk7XG4gICAgQm94LmNhbGN1bGF0ZUluZXJ0aWEodGhpcy5oYWxmRXh0ZW50cywgbWFzcywgdGFyZ2V0KTtcbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcblxuQm94LmNhbGN1bGF0ZUluZXJ0aWEgPSBmdW5jdGlvbihoYWxmRXh0ZW50cyxtYXNzLHRhcmdldCl7XG4gICAgdmFyIGUgPSBoYWxmRXh0ZW50cztcbiAgICB0YXJnZXQueCA9IDEuMCAvIDEyLjAgKiBtYXNzICogKCAgIDIqZS55KjIqZS55ICsgMiplLnoqMiplLnogKTtcbiAgICB0YXJnZXQueSA9IDEuMCAvIDEyLjAgKiBtYXNzICogKCAgIDIqZS54KjIqZS54ICsgMiplLnoqMiplLnogKTtcbiAgICB0YXJnZXQueiA9IDEuMCAvIDEyLjAgKiBtYXNzICogKCAgIDIqZS55KjIqZS55ICsgMiplLngqMiplLnggKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBib3ggNiBzaWRlIG5vcm1hbHNcbiAqIEBtZXRob2QgZ2V0U2lkZU5vcm1hbHNcbiAqIEBwYXJhbSB7YXJyYXl9ICAgICAgc2l4VGFyZ2V0VmVjdG9ycyBBbiBhcnJheSBvZiA2IHZlY3RvcnMsIHRvIHN0b3JlIHRoZSByZXN1bHRpbmcgc2lkZSBub3JtYWxzIGluLlxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxdWF0ICAgICAgICAgICAgIE9yaWVudGF0aW9uIHRvIGFwcGx5IHRvIHRoZSBub3JtYWwgdmVjdG9ycy4gSWYgbm90IHByb3ZpZGVkLCB0aGUgdmVjdG9ycyB3aWxsIGJlIGluIHJlc3BlY3QgdG8gdGhlIGxvY2FsIGZyYW1lLlxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbkJveC5wcm90b3R5cGUuZ2V0U2lkZU5vcm1hbHMgPSBmdW5jdGlvbihzaXhUYXJnZXRWZWN0b3JzLHF1YXQpe1xuICAgIHZhciBzaWRlcyA9IHNpeFRhcmdldFZlY3RvcnM7XG4gICAgdmFyIGV4ID0gdGhpcy5oYWxmRXh0ZW50cztcbiAgICBzaWRlc1swXS5zZXQoICBleC54LCAgICAgMCwgICAgIDApO1xuICAgIHNpZGVzWzFdLnNldCggICAgIDAsICBleC55LCAgICAgMCk7XG4gICAgc2lkZXNbMl0uc2V0KCAgICAgMCwgICAgIDAsICBleC56KTtcbiAgICBzaWRlc1szXS5zZXQoIC1leC54LCAgICAgMCwgICAgIDApO1xuICAgIHNpZGVzWzRdLnNldCggICAgIDAsIC1leC55LCAgICAgMCk7XG4gICAgc2lkZXNbNV0uc2V0KCAgICAgMCwgICAgIDAsIC1leC56KTtcblxuICAgIGlmKHF1YXQhPT11bmRlZmluZWQpe1xuICAgICAgICBmb3IodmFyIGk9MDsgaSE9PXNpZGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHF1YXQudm11bHQoc2lkZXNbaV0sc2lkZXNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNpZGVzO1xufTtcblxuQm94LnByb3RvdHlwZS52b2x1bWUgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiA4LjAgKiB0aGlzLmhhbGZFeHRlbnRzLnggKiB0aGlzLmhhbGZFeHRlbnRzLnkgKiB0aGlzLmhhbGZFeHRlbnRzLno7XG59O1xuXG5Cb3gucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzID0gdGhpcy5oYWxmRXh0ZW50cy5ub3JtKCk7XG59O1xuXG52YXIgd29ybGRDb3JuZXJUZW1wUG9zID0gbmV3IFZlYzMoKTtcbnZhciB3b3JsZENvcm5lclRlbXBOZWcgPSBuZXcgVmVjMygpO1xuQm94LnByb3RvdHlwZS5mb3JFYWNoV29ybGRDb3JuZXIgPSBmdW5jdGlvbihwb3MscXVhdCxjYWxsYmFjayl7XG5cbiAgICB2YXIgZSA9IHRoaXMuaGFsZkV4dGVudHM7XG4gICAgdmFyIGNvcm5lcnMgPSBbWyAgZS54LCAgZS55LCAgZS56XSxcbiAgICAgICAgICAgICAgICAgICBbIC1lLngsICBlLnksICBlLnpdLFxuICAgICAgICAgICAgICAgICAgIFsgLWUueCwgLWUueSwgIGUuel0sXG4gICAgICAgICAgICAgICAgICAgWyAtZS54LCAtZS55LCAtZS56XSxcbiAgICAgICAgICAgICAgICAgICBbICBlLngsIC1lLnksIC1lLnpdLFxuICAgICAgICAgICAgICAgICAgIFsgIGUueCwgIGUueSwgLWUuel0sXG4gICAgICAgICAgICAgICAgICAgWyAtZS54LCAgZS55LCAtZS56XSxcbiAgICAgICAgICAgICAgICAgICBbICBlLngsIC1lLnksICBlLnpdXTtcbiAgICBmb3IodmFyIGk9MDsgaTxjb3JuZXJzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgd29ybGRDb3JuZXJUZW1wUG9zLnNldChjb3JuZXJzW2ldWzBdLGNvcm5lcnNbaV1bMV0sY29ybmVyc1tpXVsyXSk7XG4gICAgICAgIHF1YXQudm11bHQod29ybGRDb3JuZXJUZW1wUG9zLHdvcmxkQ29ybmVyVGVtcFBvcyk7XG4gICAgICAgIHBvcy52YWRkKHdvcmxkQ29ybmVyVGVtcFBvcyx3b3JsZENvcm5lclRlbXBQb3MpO1xuICAgICAgICBjYWxsYmFjayh3b3JsZENvcm5lclRlbXBQb3MueCxcbiAgICAgICAgICAgICAgICAgd29ybGRDb3JuZXJUZW1wUG9zLnksXG4gICAgICAgICAgICAgICAgIHdvcmxkQ29ybmVyVGVtcFBvcy56KTtcbiAgICB9XG59O1xuXG52YXIgd29ybGRDb3JuZXJzVGVtcCA9IFtcbiAgICBuZXcgVmVjMygpLFxuICAgIG5ldyBWZWMzKCksXG4gICAgbmV3IFZlYzMoKSxcbiAgICBuZXcgVmVjMygpLFxuICAgIG5ldyBWZWMzKCksXG4gICAgbmV3IFZlYzMoKSxcbiAgICBuZXcgVmVjMygpLFxuICAgIG5ldyBWZWMzKClcbl07XG5Cb3gucHJvdG90eXBlLmNhbGN1bGF0ZVdvcmxkQUFCQiA9IGZ1bmN0aW9uKHBvcyxxdWF0LG1pbixtYXgpe1xuXG4gICAgdmFyIGUgPSB0aGlzLmhhbGZFeHRlbnRzO1xuICAgIHdvcmxkQ29ybmVyc1RlbXBbMF0uc2V0KGUueCwgZS55LCBlLnopO1xuICAgIHdvcmxkQ29ybmVyc1RlbXBbMV0uc2V0KC1lLngsICBlLnksIGUueik7XG4gICAgd29ybGRDb3JuZXJzVGVtcFsyXS5zZXQoLWUueCwgLWUueSwgZS56KTtcbiAgICB3b3JsZENvcm5lcnNUZW1wWzNdLnNldCgtZS54LCAtZS55LCAtZS56KTtcbiAgICB3b3JsZENvcm5lcnNUZW1wWzRdLnNldChlLngsIC1lLnksIC1lLnopO1xuICAgIHdvcmxkQ29ybmVyc1RlbXBbNV0uc2V0KGUueCwgIGUueSwgLWUueik7XG4gICAgd29ybGRDb3JuZXJzVGVtcFs2XS5zZXQoLWUueCwgIGUueSwgLWUueik7XG4gICAgd29ybGRDb3JuZXJzVGVtcFs3XS5zZXQoZS54LCAtZS55LCAgZS56KTtcblxuICAgIHZhciB3YyA9IHdvcmxkQ29ybmVyc1RlbXBbMF07XG4gICAgcXVhdC52bXVsdCh3Yywgd2MpO1xuICAgIHBvcy52YWRkKHdjLCB3Yyk7XG4gICAgbWF4LmNvcHkod2MpO1xuICAgIG1pbi5jb3B5KHdjKTtcbiAgICBmb3IodmFyIGk9MTsgaTw4OyBpKyspe1xuICAgICAgICB2YXIgd2MgPSB3b3JsZENvcm5lcnNUZW1wW2ldO1xuICAgICAgICBxdWF0LnZtdWx0KHdjLCB3Yyk7XG4gICAgICAgIHBvcy52YWRkKHdjLCB3Yyk7XG4gICAgICAgIHZhciB4ID0gd2MueDtcbiAgICAgICAgdmFyIHkgPSB3Yy55O1xuICAgICAgICB2YXIgeiA9IHdjLno7XG4gICAgICAgIGlmKHggPiBtYXgueCl7XG4gICAgICAgICAgICBtYXgueCA9IHg7XG4gICAgICAgIH1cbiAgICAgICAgaWYoeSA+IG1heC55KXtcbiAgICAgICAgICAgIG1heC55ID0geTtcbiAgICAgICAgfVxuICAgICAgICBpZih6ID4gbWF4Lnope1xuICAgICAgICAgICAgbWF4LnogPSB6O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoeCA8IG1pbi54KXtcbiAgICAgICAgICAgIG1pbi54ID0geDtcbiAgICAgICAgfVxuICAgICAgICBpZih5IDwgbWluLnkpe1xuICAgICAgICAgICAgbWluLnkgPSB5O1xuICAgICAgICB9XG4gICAgICAgIGlmKHogPCBtaW4ueil7XG4gICAgICAgICAgICBtaW4ueiA9IHo7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBHZXQgZWFjaCBheGlzIG1heFxuICAgIC8vIG1pbi5zZXQoSW5maW5pdHksSW5maW5pdHksSW5maW5pdHkpO1xuICAgIC8vIG1heC5zZXQoLUluZmluaXR5LC1JbmZpbml0eSwtSW5maW5pdHkpO1xuICAgIC8vIHRoaXMuZm9yRWFjaFdvcmxkQ29ybmVyKHBvcyxxdWF0LGZ1bmN0aW9uKHgseSx6KXtcbiAgICAvLyAgICAgaWYoeCA+IG1heC54KXtcbiAgICAvLyAgICAgICAgIG1heC54ID0geDtcbiAgICAvLyAgICAgfVxuICAgIC8vICAgICBpZih5ID4gbWF4Lnkpe1xuICAgIC8vICAgICAgICAgbWF4LnkgPSB5O1xuICAgIC8vICAgICB9XG4gICAgLy8gICAgIGlmKHogPiBtYXgueil7XG4gICAgLy8gICAgICAgICBtYXgueiA9IHo7XG4gICAgLy8gICAgIH1cblxuICAgIC8vICAgICBpZih4IDwgbWluLngpe1xuICAgIC8vICAgICAgICAgbWluLnggPSB4O1xuICAgIC8vICAgICB9XG4gICAgLy8gICAgIGlmKHkgPCBtaW4ueSl7XG4gICAgLy8gICAgICAgICBtaW4ueSA9IHk7XG4gICAgLy8gICAgIH1cbiAgICAvLyAgICAgaWYoeiA8IG1pbi56KXtcbiAgICAvLyAgICAgICAgIG1pbi56ID0gejtcbiAgICAvLyAgICAgfVxuICAgIC8vIH0pO1xufTtcblxufSx7XCIuLi9tYXRoL1ZlYzNcIjozMCxcIi4vQ29udmV4UG9seWhlZHJvblwiOjM4LFwiLi9TaGFwZVwiOjQzfV0sMzg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBDb252ZXhQb2x5aGVkcm9uO1xuXG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuL1NoYXBlJyk7XG52YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xudmFyIFF1YXRlcm5pb24gPSBfZGVyZXFfKCcuLi9tYXRoL1F1YXRlcm5pb24nKTtcbnZhciBUcmFuc2Zvcm0gPSBfZGVyZXFfKCcuLi9tYXRoL1RyYW5zZm9ybScpO1xuXG4vKipcbiAqIEEgc2V0IG9mIHBvbHlnb25zIGRlc2NyaWJpbmcgYSBjb252ZXggc2hhcGUuXG4gKiBAY2xhc3MgQ29udmV4UG9seWhlZHJvblxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBTaGFwZVxuICogQGRlc2NyaXB0aW9uIFRoZSBzaGFwZSBNVVNUIGJlIGNvbnZleCBmb3IgdGhlIGNvZGUgdG8gd29yayBwcm9wZXJseS4gTm8gcG9seWdvbnMgbWF5IGJlIGNvcGxhbmFyIChjb250YWluZWRcbiAqIGluIHRoZSBzYW1lIDNEIHBsYW5lKSwgaW5zdGVhZCB0aGVzZSBzaG91bGQgYmUgbWVyZ2VkIGludG8gb25lIHBvbHlnb24uXG4gKlxuICogQHBhcmFtIHthcnJheX0gcG9pbnRzIEFuIGFycmF5IG9mIFZlYzMnc1xuICogQHBhcmFtIHthcnJheX0gZmFjZXMgQXJyYXkgb2YgaW50ZWdlciBhcnJheXMsIGRlc2NyaWJpbmcgd2hpY2ggdmVydGljZXMgdGhhdCBpcyBpbmNsdWRlZCBpbiBlYWNoIGZhY2UuXG4gKlxuICogQGF1dGhvciBxaWFvIC8gaHR0cHM6Ly9naXRodWIuY29tL3FpYW8gKG9yaWdpbmFsIGF1dGhvciwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9xaWFvL3RocmVlLmpzL2NvbW1pdC84NTAyNmYwYzc2OWU0MDAwMTQ4YTY3ZDQ1YTllOWI5YzUxMDg4MzZmKVxuICogQGF1dGhvciBzY2h0ZXBwZSAvIGh0dHBzOi8vZ2l0aHViLmNvbS9zY2h0ZXBwZVxuICogQHNlZSBodHRwOi8vd3d3LmFsdGRldmJsb2dhZGF5LmNvbS8yMDExLzA1LzEzL2NvbnRhY3QtZ2VuZXJhdGlvbi1iZXR3ZWVuLTNkLWNvbnZleC1tZXNoZXMvXG4gKiBAc2VlIGh0dHA6Ly9idWxsZXQuZ29vZ2xlY29kZS5jb20vc3ZuL3RydW5rL3NyYy9CdWxsZXRDb2xsaXNpb24vTmFycm93UGhhc2VDb2xsaXNpb24vYnRQb2x5aGVkcmFsQ29udGFjdENsaXBwaW5nLmNwcFxuICpcbiAqIEB0b2RvIE1vdmUgdGhlIGNsaXBwaW5nIGZ1bmN0aW9ucyB0byBDb250YWN0R2VuZXJhdG9yP1xuICogQHRvZG8gQXV0b21hdGljYWxseSBtZXJnZSBjb3BsYW5hciBwb2x5Z29ucyBpbiBjb25zdHJ1Y3Rvci5cbiAqL1xuZnVuY3Rpb24gQ29udmV4UG9seWhlZHJvbihwb2ludHMsIGZhY2VzLCB1bmlxdWVBeGVzKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIFNoYXBlLmNhbGwodGhpcyk7XG4gICAgdGhpcy50eXBlID0gU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTjtcblxuICAgIC8qKlxuICAgICAqIEFycmF5IG9mIFZlYzNcbiAgICAgKiBAcHJvcGVydHkgdmVydGljZXNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy52ZXJ0aWNlcyA9IHBvaW50c3x8W107XG5cbiAgICB0aGlzLndvcmxkVmVydGljZXMgPSBbXTsgLy8gV29ybGQgdHJhbnNmb3JtZWQgdmVyc2lvbiBvZiAudmVydGljZXNcbiAgICB0aGlzLndvcmxkVmVydGljZXNOZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiBpbnRlZ2VyIGFycmF5cywgaW5kaWNhdGluZyB3aGljaCB2ZXJ0aWNlcyBlYWNoIGZhY2UgY29uc2lzdHMgb2ZcbiAgICAgKiBAcHJvcGVydHkgZmFjZXNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5mYWNlcyA9IGZhY2VzfHxbXTtcblxuICAgIC8qKlxuICAgICAqIEFycmF5IG9mIFZlYzNcbiAgICAgKiBAcHJvcGVydHkgZmFjZU5vcm1hbHNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5mYWNlTm9ybWFscyA9IFtdO1xuICAgIHRoaXMuY29tcHV0ZU5vcm1hbHMoKTtcblxuICAgIHRoaXMud29ybGRGYWNlTm9ybWFsc05lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB0aGlzLndvcmxkRmFjZU5vcm1hbHMgPSBbXTsgLy8gV29ybGQgdHJhbnNmb3JtZWQgdmVyc2lvbiBvZiAuZmFjZU5vcm1hbHNcblxuICAgIC8qKlxuICAgICAqIEFycmF5IG9mIFZlYzNcbiAgICAgKiBAcHJvcGVydHkgdW5pcXVlRWRnZXNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy51bmlxdWVFZGdlcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogSWYgZ2l2ZW4sIHRoZXNlIGxvY2FsbHkgZGVmaW5lZCwgbm9ybWFsaXplZCBheGVzIGFyZSB0aGUgb25seSBvbmVzIGJlaW5nIGNoZWNrZWQgd2hlbiBkb2luZyBzZXBhcmF0aW5nIGF4aXMgY2hlY2suXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gdW5pcXVlQXhlc1xuICAgICAqL1xuICAgIHRoaXMudW5pcXVlQXhlcyA9IHVuaXF1ZUF4ZXMgPyB1bmlxdWVBeGVzLnNsaWNlKCkgOiBudWxsO1xuXG4gICAgdGhpcy5jb21wdXRlRWRnZXMoKTtcbiAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCk7XG59XG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZSA9IG5ldyBTaGFwZSgpO1xuQ29udmV4UG9seWhlZHJvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb252ZXhQb2x5aGVkcm9uO1xuXG52YXIgY29tcHV0ZUVkZ2VzX3RtcEVkZ2UgPSBuZXcgVmVjMygpO1xuLyoqXG4gKiBDb21wdXRlcyB1bmlxdWVFZGdlc1xuICogQG1ldGhvZCBjb21wdXRlRWRnZXNcbiAqL1xuQ29udmV4UG9seWhlZHJvbi5wcm90b3R5cGUuY29tcHV0ZUVkZ2VzID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZmFjZXMgPSB0aGlzLmZhY2VzO1xuICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XG4gICAgdmFyIG52ID0gdmVydGljZXMubGVuZ3RoO1xuICAgIHZhciBlZGdlcyA9IHRoaXMudW5pcXVlRWRnZXM7XG5cbiAgICBlZGdlcy5sZW5ndGggPSAwO1xuXG4gICAgdmFyIGVkZ2UgPSBjb21wdXRlRWRnZXNfdG1wRWRnZTtcblxuICAgIGZvcih2YXIgaT0wOyBpICE9PSBmYWNlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBmYWNlID0gZmFjZXNbaV07XG4gICAgICAgIHZhciBudW1WZXJ0aWNlcyA9IGZhY2UubGVuZ3RoO1xuICAgICAgICBmb3IodmFyIGogPSAwOyBqICE9PSBudW1WZXJ0aWNlczsgaisrKXtcbiAgICAgICAgICAgIHZhciBrID0gKCBqKzEgKSAlIG51bVZlcnRpY2VzO1xuICAgICAgICAgICAgdmVydGljZXNbZmFjZVtqXV0udnN1Yih2ZXJ0aWNlc1tmYWNlW2tdXSwgZWRnZSk7XG4gICAgICAgICAgICBlZGdlLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IodmFyIHA9MDsgcCAhPT0gZWRnZXMubGVuZ3RoOyBwKyspe1xuICAgICAgICAgICAgICAgIGlmIChlZGdlc1twXS5hbG1vc3RFcXVhbHMoZWRnZSkgfHwgZWRnZXNbcF0uYWxtb3N0RXF1YWxzKGVkZ2UpKXtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZm91bmQpe1xuICAgICAgICAgICAgICAgIGVkZ2VzLnB1c2goZWRnZS5jbG9uZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgbm9ybWFscyBvZiB0aGUgZmFjZXMuIFdpbGwgcmV1c2UgZXhpc3RpbmcgVmVjMyBvYmplY3RzIGluIHRoZSAuZmFjZU5vcm1hbHMgYXJyYXkgaWYgdGhleSBleGlzdC5cbiAqIEBtZXRob2QgY29tcHV0ZU5vcm1hbHNcbiAqL1xuQ29udmV4UG9seWhlZHJvbi5wcm90b3R5cGUuY29tcHV0ZU5vcm1hbHMgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuZmFjZU5vcm1hbHMubGVuZ3RoID0gdGhpcy5mYWNlcy5sZW5ndGg7XG5cbiAgICAvLyBHZW5lcmF0ZSBub3JtYWxzXG4gICAgZm9yKHZhciBpPTA7IGk8dGhpcy5mYWNlcy5sZW5ndGg7IGkrKyl7XG5cbiAgICAgICAgLy8gQ2hlY2sgc28gYWxsIHZlcnRpY2VzIGV4aXN0cyBmb3IgdGhpcyBmYWNlXG4gICAgICAgIGZvcih2YXIgaj0wOyBqPHRoaXMuZmFjZXNbaV0ubGVuZ3RoOyBqKyspe1xuICAgICAgICAgICAgaWYoIXRoaXMudmVydGljZXNbdGhpcy5mYWNlc1tpXVtqXV0pe1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZlcnRleCBcIit0aGlzLmZhY2VzW2ldW2pdK1wiIG5vdCBmb3VuZCFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbiA9IHRoaXMuZmFjZU5vcm1hbHNbaV0gfHwgbmV3IFZlYzMoKTtcbiAgICAgICAgdGhpcy5nZXRGYWNlTm9ybWFsKGksbik7XG4gICAgICAgIG4ubmVnYXRlKG4pO1xuICAgICAgICB0aGlzLmZhY2VOb3JtYWxzW2ldID0gbjtcbiAgICAgICAgdmFyIHZlcnRleCA9IHRoaXMudmVydGljZXNbdGhpcy5mYWNlc1tpXVswXV07XG4gICAgICAgIGlmKG4uZG90KHZlcnRleCkgPCAwKXtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCIuZmFjZU5vcm1hbHNbXCIgKyBpICsgXCJdID0gVmVjMyhcIituLnRvU3RyaW5nKCkrXCIpIGxvb2tzIGxpa2UgaXQgcG9pbnRzIGludG8gdGhlIHNoYXBlPyBUaGUgdmVydGljZXMgZm9sbG93LiBNYWtlIHN1cmUgdGhleSBhcmUgb3JkZXJlZCBDQ1cgYXJvdW5kIHRoZSBub3JtYWwsIHVzaW5nIHRoZSByaWdodCBoYW5kIHJ1bGUuXCIpO1xuICAgICAgICAgICAgZm9yKHZhciBqPTA7IGo8dGhpcy5mYWNlc1tpXS5sZW5ndGg7IGorKyl7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiLnZlcnRpY2VzW1wiK3RoaXMuZmFjZXNbaV1bal0rXCJdID0gVmVjMyhcIit0aGlzLnZlcnRpY2VzW3RoaXMuZmFjZXNbaV1bal1dLnRvU3RyaW5nKCkrXCIpXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBHZXQgZmFjZSBub3JtYWwgZ2l2ZW4gMyB2ZXJ0aWNlc1xuICogQHN0YXRpY1xuICogQG1ldGhvZCBnZXRGYWNlTm9ybWFsXG4gKiBAcGFyYW0ge1ZlYzN9IHZhXG4gKiBAcGFyYW0ge1ZlYzN9IHZiXG4gKiBAcGFyYW0ge1ZlYzN9IHZjXG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldFxuICovXG52YXIgY2IgPSBuZXcgVmVjMygpO1xudmFyIGFiID0gbmV3IFZlYzMoKTtcbkNvbnZleFBvbHloZWRyb24uY29tcHV0ZU5vcm1hbCA9IGZ1bmN0aW9uICggdmEsIHZiLCB2YywgdGFyZ2V0ICkge1xuICAgIHZiLnZzdWIodmEsYWIpO1xuICAgIHZjLnZzdWIodmIsY2IpO1xuICAgIGNiLmNyb3NzKGFiLHRhcmdldCk7XG4gICAgaWYgKCAhdGFyZ2V0LmlzWmVybygpICkge1xuICAgICAgICB0YXJnZXQubm9ybWFsaXplKCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBub3JtYWwgb2YgYSBmYWNlIGZyb20gaXRzIHZlcnRpY2VzXG4gKiBAbWV0aG9kIGdldEZhY2VOb3JtYWxcbiAqIEBwYXJhbSAge051bWJlcn0gaVxuICogQHBhcmFtICB7VmVjM30gdGFyZ2V0XG4gKi9cbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLmdldEZhY2VOb3JtYWwgPSBmdW5jdGlvbihpLHRhcmdldCl7XG4gICAgdmFyIGYgPSB0aGlzLmZhY2VzW2ldO1xuICAgIHZhciB2YSA9IHRoaXMudmVydGljZXNbZlswXV07XG4gICAgdmFyIHZiID0gdGhpcy52ZXJ0aWNlc1tmWzFdXTtcbiAgICB2YXIgdmMgPSB0aGlzLnZlcnRpY2VzW2ZbMl1dO1xuICAgIHJldHVybiBDb252ZXhQb2x5aGVkcm9uLmNvbXB1dGVOb3JtYWwodmEsdmIsdmMsdGFyZ2V0KTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBjbGlwQWdhaW5zdEh1bGxcbiAqIEBwYXJhbSB7VmVjM30gcG9zQVxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxdWF0QVxuICogQHBhcmFtIHtDb252ZXhQb2x5aGVkcm9ufSBodWxsQlxuICogQHBhcmFtIHtWZWMzfSBwb3NCXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHF1YXRCXG4gKiBAcGFyYW0ge1ZlYzN9IHNlcGFyYXRpbmdOb3JtYWxcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaW5EaXN0IENsYW1wIGRpc3RhbmNlXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4RGlzdFxuICogQHBhcmFtIHthcnJheX0gcmVzdWx0IFRoZSBhbiBhcnJheSBvZiBjb250YWN0IHBvaW50IG9iamVjdHMsIHNlZSBjbGlwRmFjZUFnYWluc3RIdWxsXG4gKiBAc2VlIGh0dHA6Ly9idWxsZXQuZ29vZ2xlY29kZS5jb20vc3ZuL3RydW5rL3NyYy9CdWxsZXRDb2xsaXNpb24vTmFycm93UGhhc2VDb2xsaXNpb24vYnRQb2x5aGVkcmFsQ29udGFjdENsaXBwaW5nLmNwcFxuICovXG52YXIgY2FoX1dvcmxkTm9ybWFsID0gbmV3IFZlYzMoKTtcbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLmNsaXBBZ2FpbnN0SHVsbCA9IGZ1bmN0aW9uKHBvc0EscXVhdEEsaHVsbEIscG9zQixxdWF0QixzZXBhcmF0aW5nTm9ybWFsLG1pbkRpc3QsbWF4RGlzdCxyZXN1bHQpe1xuICAgIHZhciBXb3JsZE5vcm1hbCA9IGNhaF9Xb3JsZE5vcm1hbDtcbiAgICB2YXIgaHVsbEEgPSB0aGlzO1xuICAgIHZhciBjdXJNYXhEaXN0ID0gbWF4RGlzdDtcbiAgICB2YXIgY2xvc2VzdEZhY2VCID0gLTE7XG4gICAgdmFyIGRtYXggPSAtTnVtYmVyLk1BWF9WQUxVRTtcbiAgICBmb3IodmFyIGZhY2U9MDsgZmFjZSA8IGh1bGxCLmZhY2VzLmxlbmd0aDsgZmFjZSsrKXtcbiAgICAgICAgV29ybGROb3JtYWwuY29weShodWxsQi5mYWNlTm9ybWFsc1tmYWNlXSk7XG4gICAgICAgIHF1YXRCLnZtdWx0KFdvcmxkTm9ybWFsLFdvcmxkTm9ybWFsKTtcbiAgICAgICAgLy9wb3NCLnZhZGQoV29ybGROb3JtYWwsV29ybGROb3JtYWwpO1xuICAgICAgICB2YXIgZCA9IFdvcmxkTm9ybWFsLmRvdChzZXBhcmF0aW5nTm9ybWFsKTtcbiAgICAgICAgaWYgKGQgPiBkbWF4KXtcbiAgICAgICAgICAgIGRtYXggPSBkO1xuICAgICAgICAgICAgY2xvc2VzdEZhY2VCID0gZmFjZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgd29ybGRWZXJ0c0IxID0gW107XG4gICAgdmFyIHBvbHlCID0gaHVsbEIuZmFjZXNbY2xvc2VzdEZhY2VCXTtcbiAgICB2YXIgbnVtVmVydGljZXMgPSBwb2x5Qi5sZW5ndGg7XG4gICAgZm9yKHZhciBlMD0wOyBlMDxudW1WZXJ0aWNlczsgZTArKyl7XG4gICAgICAgIHZhciBiID0gaHVsbEIudmVydGljZXNbcG9seUJbZTBdXTtcbiAgICAgICAgdmFyIHdvcmxkYiA9IG5ldyBWZWMzKCk7XG4gICAgICAgIHdvcmxkYi5jb3B5KGIpO1xuICAgICAgICBxdWF0Qi52bXVsdCh3b3JsZGIsd29ybGRiKTtcbiAgICAgICAgcG9zQi52YWRkKHdvcmxkYix3b3JsZGIpO1xuICAgICAgICB3b3JsZFZlcnRzQjEucHVzaCh3b3JsZGIpO1xuICAgIH1cblxuICAgIGlmIChjbG9zZXN0RmFjZUI+PTApe1xuICAgICAgICB0aGlzLmNsaXBGYWNlQWdhaW5zdEh1bGwoc2VwYXJhdGluZ05vcm1hbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc0EsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWF0QSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmxkVmVydHNCMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbkRpc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhEaXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEZpbmQgdGhlIHNlcGFyYXRpbmcgYXhpcyBiZXR3ZWVuIHRoaXMgaHVsbCBhbmQgYW5vdGhlclxuICogQG1ldGhvZCBmaW5kU2VwYXJhdGluZ0F4aXNcbiAqIEBwYXJhbSB7Q29udmV4UG9seWhlZHJvbn0gaHVsbEJcbiAqIEBwYXJhbSB7VmVjM30gcG9zQVxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxdWF0QVxuICogQHBhcmFtIHtWZWMzfSBwb3NCXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHF1YXRCXG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldCBUaGUgdGFyZ2V0IHZlY3RvciB0byBzYXZlIHRoZSBheGlzIGluXG4gKiBAcmV0dXJuIHtib29sfSBSZXR1cm5zIGZhbHNlIGlmIGEgc2VwYXJhdGlvbiBpcyBmb3VuZCwgZWxzZSB0cnVlXG4gKi9cbnZhciBmc2FfZmFjZUFOb3JtYWxXUzMgPSBuZXcgVmVjMygpLFxuICAgIGZzYV9Xb3JsZG5vcm1hbDEgPSBuZXcgVmVjMygpLFxuICAgIGZzYV9kZWx0YUMgPSBuZXcgVmVjMygpLFxuICAgIGZzYV93b3JsZEVkZ2UwID0gbmV3IFZlYzMoKSxcbiAgICBmc2Ffd29ybGRFZGdlMSA9IG5ldyBWZWMzKCksXG4gICAgZnNhX0Nyb3NzID0gbmV3IFZlYzMoKTtcbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLmZpbmRTZXBhcmF0aW5nQXhpcyA9IGZ1bmN0aW9uKGh1bGxCLHBvc0EscXVhdEEscG9zQixxdWF0Qix0YXJnZXQsIGZhY2VMaXN0QSwgZmFjZUxpc3RCKXtcbiAgICB2YXIgZmFjZUFOb3JtYWxXUzMgPSBmc2FfZmFjZUFOb3JtYWxXUzMsXG4gICAgICAgIFdvcmxkbm9ybWFsMSA9IGZzYV9Xb3JsZG5vcm1hbDEsXG4gICAgICAgIGRlbHRhQyA9IGZzYV9kZWx0YUMsXG4gICAgICAgIHdvcmxkRWRnZTAgPSBmc2Ffd29ybGRFZGdlMCxcbiAgICAgICAgd29ybGRFZGdlMSA9IGZzYV93b3JsZEVkZ2UxLFxuICAgICAgICBDcm9zcyA9IGZzYV9Dcm9zcztcblxuICAgIHZhciBkbWluID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICB2YXIgaHVsbEEgPSB0aGlzO1xuICAgIHZhciBjdXJQbGFuZVRlc3RzPTA7XG5cbiAgICBpZighaHVsbEEudW5pcXVlQXhlcyl7XG5cbiAgICAgICAgdmFyIG51bUZhY2VzQSA9IGZhY2VMaXN0QSA/IGZhY2VMaXN0QS5sZW5ndGggOiBodWxsQS5mYWNlcy5sZW5ndGg7XG5cbiAgICAgICAgLy8gVGVzdCBmYWNlIG5vcm1hbHMgZnJvbSBodWxsQVxuICAgICAgICBmb3IodmFyIGk9MDsgaTxudW1GYWNlc0E7IGkrKyl7XG4gICAgICAgICAgICB2YXIgZmkgPSBmYWNlTGlzdEEgPyBmYWNlTGlzdEFbaV0gOiBpO1xuXG4gICAgICAgICAgICAvLyBHZXQgd29ybGQgZmFjZSBub3JtYWxcbiAgICAgICAgICAgIGZhY2VBTm9ybWFsV1MzLmNvcHkoaHVsbEEuZmFjZU5vcm1hbHNbZmldKTtcbiAgICAgICAgICAgIHF1YXRBLnZtdWx0KGZhY2VBTm9ybWFsV1MzLGZhY2VBTm9ybWFsV1MzKTtcblxuICAgICAgICAgICAgdmFyIGQgPSBodWxsQS50ZXN0U2VwQXhpcyhmYWNlQU5vcm1hbFdTMywgaHVsbEIsIHBvc0EsIHF1YXRBLCBwb3NCLCBxdWF0Qik7XG4gICAgICAgICAgICBpZihkPT09ZmFsc2Upe1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoZDxkbWluKXtcbiAgICAgICAgICAgICAgICBkbWluID0gZDtcbiAgICAgICAgICAgICAgICB0YXJnZXQuY29weShmYWNlQU5vcm1hbFdTMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gVGVzdCB1bmlxdWUgYXhlc1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpICE9PSBodWxsQS51bmlxdWVBeGVzLmxlbmd0aDsgaSsrKXtcblxuICAgICAgICAgICAgLy8gR2V0IHdvcmxkIGF4aXNcbiAgICAgICAgICAgIHF1YXRBLnZtdWx0KGh1bGxBLnVuaXF1ZUF4ZXNbaV0sZmFjZUFOb3JtYWxXUzMpO1xuXG4gICAgICAgICAgICB2YXIgZCA9IGh1bGxBLnRlc3RTZXBBeGlzKGZhY2VBTm9ybWFsV1MzLCBodWxsQiwgcG9zQSwgcXVhdEEsIHBvc0IsIHF1YXRCKTtcbiAgICAgICAgICAgIGlmKGQ9PT1mYWxzZSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihkPGRtaW4pe1xuICAgICAgICAgICAgICAgIGRtaW4gPSBkO1xuICAgICAgICAgICAgICAgIHRhcmdldC5jb3B5KGZhY2VBTm9ybWFsV1MzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKCFodWxsQi51bmlxdWVBeGVzKXtcblxuICAgICAgICAvLyBUZXN0IGZhY2Ugbm9ybWFscyBmcm9tIGh1bGxCXG4gICAgICAgIHZhciBudW1GYWNlc0IgPSBmYWNlTGlzdEIgPyBmYWNlTGlzdEIubGVuZ3RoIDogaHVsbEIuZmFjZXMubGVuZ3RoO1xuICAgICAgICBmb3IodmFyIGk9MDtpPG51bUZhY2VzQjtpKyspe1xuXG4gICAgICAgICAgICB2YXIgZmkgPSBmYWNlTGlzdEIgPyBmYWNlTGlzdEJbaV0gOiBpO1xuXG4gICAgICAgICAgICBXb3JsZG5vcm1hbDEuY29weShodWxsQi5mYWNlTm9ybWFsc1tmaV0pO1xuICAgICAgICAgICAgcXVhdEIudm11bHQoV29ybGRub3JtYWwxLFdvcmxkbm9ybWFsMSk7XG4gICAgICAgICAgICBjdXJQbGFuZVRlc3RzKys7XG4gICAgICAgICAgICB2YXIgZCA9IGh1bGxBLnRlc3RTZXBBeGlzKFdvcmxkbm9ybWFsMSwgaHVsbEIscG9zQSxxdWF0QSxwb3NCLHF1YXRCKTtcbiAgICAgICAgICAgIGlmKGQ9PT1mYWxzZSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihkPGRtaW4pe1xuICAgICAgICAgICAgICAgIGRtaW4gPSBkO1xuICAgICAgICAgICAgICAgIHRhcmdldC5jb3B5KFdvcmxkbm9ybWFsMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIFRlc3QgdW5pcXVlIGF4ZXMgaW4gQlxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpICE9PSBodWxsQi51bmlxdWVBeGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHF1YXRCLnZtdWx0KGh1bGxCLnVuaXF1ZUF4ZXNbaV0sV29ybGRub3JtYWwxKTtcblxuICAgICAgICAgICAgY3VyUGxhbmVUZXN0cysrO1xuICAgICAgICAgICAgdmFyIGQgPSBodWxsQS50ZXN0U2VwQXhpcyhXb3JsZG5vcm1hbDEsIGh1bGxCLHBvc0EscXVhdEEscG9zQixxdWF0Qik7XG4gICAgICAgICAgICBpZihkPT09ZmFsc2Upe1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoZDxkbWluKXtcbiAgICAgICAgICAgICAgICBkbWluID0gZDtcbiAgICAgICAgICAgICAgICB0YXJnZXQuY29weShXb3JsZG5vcm1hbDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGVzdCBlZGdlc1xuICAgIGZvcih2YXIgZTA9MDsgZTAgIT09IGh1bGxBLnVuaXF1ZUVkZ2VzLmxlbmd0aDsgZTArKyl7XG5cbiAgICAgICAgLy8gR2V0IHdvcmxkIGVkZ2VcbiAgICAgICAgcXVhdEEudm11bHQoaHVsbEEudW5pcXVlRWRnZXNbZTBdLHdvcmxkRWRnZTApO1xuXG4gICAgICAgIGZvcih2YXIgZTE9MDsgZTEgIT09IGh1bGxCLnVuaXF1ZUVkZ2VzLmxlbmd0aDsgZTErKyl7XG5cbiAgICAgICAgICAgIC8vIEdldCB3b3JsZCBlZGdlIDJcbiAgICAgICAgICAgIHF1YXRCLnZtdWx0KGh1bGxCLnVuaXF1ZUVkZ2VzW2UxXSwgd29ybGRFZGdlMSk7XG4gICAgICAgICAgICB3b3JsZEVkZ2UwLmNyb3NzKHdvcmxkRWRnZTEsQ3Jvc3MpO1xuXG4gICAgICAgICAgICBpZighQ3Jvc3MuYWxtb3N0WmVybygpKXtcbiAgICAgICAgICAgICAgICBDcm9zcy5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgICB2YXIgZGlzdCA9IGh1bGxBLnRlc3RTZXBBeGlzKENyb3NzLCBodWxsQiwgcG9zQSwgcXVhdEEsIHBvc0IsIHF1YXRCKTtcbiAgICAgICAgICAgICAgICBpZihkaXN0ID09PSBmYWxzZSl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoZGlzdCA8IGRtaW4pe1xuICAgICAgICAgICAgICAgICAgICBkbWluID0gZGlzdDtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmNvcHkoQ3Jvc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHBvc0IudnN1Yihwb3NBLGRlbHRhQyk7XG4gICAgaWYoKGRlbHRhQy5kb3QodGFyZ2V0KSk+MC4wKXtcbiAgICAgICAgdGFyZ2V0Lm5lZ2F0ZSh0YXJnZXQpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcblxudmFyIG1heG1pbkE9W10sIG1heG1pbkI9W107XG5cbi8qKlxuICogVGVzdCBzZXBhcmF0aW5nIGF4aXMgYWdhaW5zdCB0d28gaHVsbHMuIEJvdGggaHVsbHMgYXJlIHByb2plY3RlZCBvbnRvIHRoZSBheGlzIGFuZCB0aGUgb3ZlcmxhcCBzaXplIGlzIHJldHVybmVkIGlmIHRoZXJlIGlzIG9uZS5cbiAqIEBtZXRob2QgdGVzdFNlcEF4aXNcbiAqIEBwYXJhbSB7VmVjM30gYXhpc1xuICogQHBhcmFtIHtDb252ZXhQb2x5aGVkcm9ufSBodWxsQlxuICogQHBhcmFtIHtWZWMzfSBwb3NBXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHF1YXRBXG4gKiBAcGFyYW0ge1ZlYzN9IHBvc0JcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcXVhdEJcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG92ZXJsYXAgZGVwdGgsIG9yIEZBTFNFIGlmIG5vIHBlbmV0cmF0aW9uLlxuICovXG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS50ZXN0U2VwQXhpcyA9IGZ1bmN0aW9uKGF4aXMsIGh1bGxCLCBwb3NBLCBxdWF0QSwgcG9zQiwgcXVhdEIpe1xuICAgIHZhciBodWxsQT10aGlzO1xuICAgIENvbnZleFBvbHloZWRyb24ucHJvamVjdChodWxsQSwgYXhpcywgcG9zQSwgcXVhdEEsIG1heG1pbkEpO1xuICAgIENvbnZleFBvbHloZWRyb24ucHJvamVjdChodWxsQiwgYXhpcywgcG9zQiwgcXVhdEIsIG1heG1pbkIpO1xuICAgIHZhciBtYXhBID0gbWF4bWluQVswXTtcbiAgICB2YXIgbWluQSA9IG1heG1pbkFbMV07XG4gICAgdmFyIG1heEIgPSBtYXhtaW5CWzBdO1xuICAgIHZhciBtaW5CID0gbWF4bWluQlsxXTtcbiAgICBpZihtYXhBPG1pbkIgfHwgbWF4QjxtaW5BKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBTZXBhcmF0ZWRcbiAgICB9XG4gICAgdmFyIGQwID0gbWF4QSAtIG1pbkI7XG4gICAgdmFyIGQxID0gbWF4QiAtIG1pbkE7XG4gICAgdmFyIGRlcHRoID0gZDA8ZDEgPyBkMDpkMTtcbiAgICByZXR1cm4gZGVwdGg7XG59O1xuXG52YXIgY2xpX2FhYmJtaW4gPSBuZXcgVmVjMygpLFxuICAgIGNsaV9hYWJibWF4ID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBAbWV0aG9kIGNhbGN1bGF0ZUxvY2FsSW5lcnRpYVxuICogQHBhcmFtICB7TnVtYmVyfSBtYXNzXG4gKiBAcGFyYW0gIHtWZWMzfSB0YXJnZXRcbiAqL1xuQ29udmV4UG9seWhlZHJvbi5wcm90b3R5cGUuY2FsY3VsYXRlTG9jYWxJbmVydGlhID0gZnVuY3Rpb24obWFzcyx0YXJnZXQpe1xuICAgIC8vIEFwcHJveGltYXRlIHdpdGggYm94IGluZXJ0aWFcbiAgICAvLyBFeGFjdCBpbmVydGlhIGNhbGN1bGF0aW9uIGlzIG92ZXJraWxsLCBidXQgc2VlIGh0dHA6Ly9nZW9tZXRyaWN0b29scy5jb20vRG9jdW1lbnRhdGlvbi9Qb2x5aGVkcmFsTWFzc1Byb3BlcnRpZXMucGRmIGZvciB0aGUgY29ycmVjdCB3YXkgdG8gZG8gaXRcbiAgICB0aGlzLmNvbXB1dGVMb2NhbEFBQkIoY2xpX2FhYmJtaW4sY2xpX2FhYmJtYXgpO1xuICAgIHZhciB4ID0gY2xpX2FhYmJtYXgueCAtIGNsaV9hYWJibWluLngsXG4gICAgICAgIHkgPSBjbGlfYWFiYm1heC55IC0gY2xpX2FhYmJtaW4ueSxcbiAgICAgICAgeiA9IGNsaV9hYWJibWF4LnogLSBjbGlfYWFiYm1pbi56O1xuICAgIHRhcmdldC54ID0gMS4wIC8gMTIuMCAqIG1hc3MgKiAoIDIqeSoyKnkgKyAyKnoqMip6ICk7XG4gICAgdGFyZ2V0LnkgPSAxLjAgLyAxMi4wICogbWFzcyAqICggMip4KjIqeCArIDIqeioyKnogKTtcbiAgICB0YXJnZXQueiA9IDEuMCAvIDEyLjAgKiBtYXNzICogKCAyKnkqMip5ICsgMip4KjIqeCApO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGdldFBsYW5lQ29uc3RhbnRPZkZhY2VcbiAqIEBwYXJhbSAge051bWJlcn0gZmFjZV9pIEluZGV4IG9mIHRoZSBmYWNlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLmdldFBsYW5lQ29uc3RhbnRPZkZhY2UgPSBmdW5jdGlvbihmYWNlX2kpe1xuICAgIHZhciBmID0gdGhpcy5mYWNlc1tmYWNlX2ldO1xuICAgIHZhciBuID0gdGhpcy5mYWNlTm9ybWFsc1tmYWNlX2ldO1xuICAgIHZhciB2ID0gdGhpcy52ZXJ0aWNlc1tmWzBdXTtcbiAgICB2YXIgYyA9IC1uLmRvdCh2KTtcbiAgICByZXR1cm4gYztcbn07XG5cbi8qKlxuICogQ2xpcCBhIGZhY2UgYWdhaW5zdCBhIGh1bGwuXG4gKiBAbWV0aG9kIGNsaXBGYWNlQWdhaW5zdEh1bGxcbiAqIEBwYXJhbSB7VmVjM30gc2VwYXJhdGluZ05vcm1hbFxuICogQHBhcmFtIHtWZWMzfSBwb3NBXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHF1YXRBXG4gKiBAcGFyYW0ge0FycmF5fSB3b3JsZFZlcnRzQjEgQW4gYXJyYXkgb2YgVmVjMyB3aXRoIHZlcnRpY2VzIGluIHRoZSB3b3JsZCBmcmFtZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBtaW5EaXN0IERpc3RhbmNlIGNsYW1waW5nXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4RGlzdFxuICogQHBhcmFtIEFycmF5IHJlc3VsdCBBcnJheSB0byBzdG9yZSByZXN1bHRpbmcgY29udGFjdCBwb2ludHMgaW4uIFdpbGwgYmUgb2JqZWN0cyB3aXRoIHByb3BlcnRpZXM6IHBvaW50LCBkZXB0aCwgbm9ybWFsLiBUaGVzZSBhcmUgcmVwcmVzZW50ZWQgaW4gd29ybGQgY29vcmRpbmF0ZXMuXG4gKi9cbnZhciBjZmFoX2ZhY2VBTm9ybWFsV1MgPSBuZXcgVmVjMygpLFxuICAgIGNmYWhfZWRnZTAgPSBuZXcgVmVjMygpLFxuICAgIGNmYWhfV29ybGRFZGdlMCA9IG5ldyBWZWMzKCksXG4gICAgY2ZhaF93b3JsZFBsYW5lQW5vcm1hbDEgPSBuZXcgVmVjMygpLFxuICAgIGNmYWhfcGxhbmVOb3JtYWxXUzEgPSBuZXcgVmVjMygpLFxuICAgIGNmYWhfd29ybGRBMSA9IG5ldyBWZWMzKCksXG4gICAgY2ZhaF9sb2NhbFBsYW5lTm9ybWFsID0gbmV3IFZlYzMoKSxcbiAgICBjZmFoX3BsYW5lTm9ybWFsV1MgPSBuZXcgVmVjMygpO1xuQ29udmV4UG9seWhlZHJvbi5wcm90b3R5cGUuY2xpcEZhY2VBZ2FpbnN0SHVsbCA9IGZ1bmN0aW9uKHNlcGFyYXRpbmdOb3JtYWwsIHBvc0EsIHF1YXRBLCB3b3JsZFZlcnRzQjEsIG1pbkRpc3QsIG1heERpc3QscmVzdWx0KXtcbiAgICB2YXIgZmFjZUFOb3JtYWxXUyA9IGNmYWhfZmFjZUFOb3JtYWxXUyxcbiAgICAgICAgZWRnZTAgPSBjZmFoX2VkZ2UwLFxuICAgICAgICBXb3JsZEVkZ2UwID0gY2ZhaF9Xb3JsZEVkZ2UwLFxuICAgICAgICB3b3JsZFBsYW5lQW5vcm1hbDEgPSBjZmFoX3dvcmxkUGxhbmVBbm9ybWFsMSxcbiAgICAgICAgcGxhbmVOb3JtYWxXUzEgPSBjZmFoX3BsYW5lTm9ybWFsV1MxLFxuICAgICAgICB3b3JsZEExID0gY2ZhaF93b3JsZEExLFxuICAgICAgICBsb2NhbFBsYW5lTm9ybWFsID0gY2ZhaF9sb2NhbFBsYW5lTm9ybWFsLFxuICAgICAgICBwbGFuZU5vcm1hbFdTID0gY2ZhaF9wbGFuZU5vcm1hbFdTO1xuXG4gICAgdmFyIGh1bGxBID0gdGhpcztcbiAgICB2YXIgd29ybGRWZXJ0c0IyID0gW107XG4gICAgdmFyIHBWdHhJbiA9IHdvcmxkVmVydHNCMTtcbiAgICB2YXIgcFZ0eE91dCA9IHdvcmxkVmVydHNCMjtcbiAgICAvLyBGaW5kIHRoZSBmYWNlIHdpdGggbm9ybWFsIGNsb3Nlc3QgdG8gdGhlIHNlcGFyYXRpbmcgYXhpc1xuICAgIHZhciBjbG9zZXN0RmFjZUEgPSAtMTtcbiAgICB2YXIgZG1pbiA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgZm9yKHZhciBmYWNlPTA7IGZhY2U8aHVsbEEuZmFjZXMubGVuZ3RoOyBmYWNlKyspe1xuICAgICAgICBmYWNlQU5vcm1hbFdTLmNvcHkoaHVsbEEuZmFjZU5vcm1hbHNbZmFjZV0pO1xuICAgICAgICBxdWF0QS52bXVsdChmYWNlQU5vcm1hbFdTLGZhY2VBTm9ybWFsV1MpO1xuICAgICAgICAvL3Bvc0EudmFkZChmYWNlQU5vcm1hbFdTLGZhY2VBTm9ybWFsV1MpO1xuICAgICAgICB2YXIgZCA9IGZhY2VBTm9ybWFsV1MuZG90KHNlcGFyYXRpbmdOb3JtYWwpO1xuICAgICAgICBpZiAoZCA8IGRtaW4pe1xuICAgICAgICAgICAgZG1pbiA9IGQ7XG4gICAgICAgICAgICBjbG9zZXN0RmFjZUEgPSBmYWNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjbG9zZXN0RmFjZUEgPCAwKXtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCItLS0gZGlkIG5vdCBmaW5kIGFueSBjbG9zZXN0IGZhY2UuLi4gLS0tXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vY29uc29sZS5sb2coXCJjbG9zZXN0IEE6IFwiLGNsb3Nlc3RGYWNlQSk7XG4gICAgLy8gR2V0IHRoZSBmYWNlIGFuZCBjb25zdHJ1Y3QgY29ubmVjdGVkIGZhY2VzXG4gICAgdmFyIHBvbHlBID0gaHVsbEEuZmFjZXNbY2xvc2VzdEZhY2VBXTtcbiAgICBwb2x5QS5jb25uZWN0ZWRGYWNlcyA9IFtdO1xuICAgIGZvcih2YXIgaT0wOyBpPGh1bGxBLmZhY2VzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgZm9yKHZhciBqPTA7IGo8aHVsbEEuZmFjZXNbaV0ubGVuZ3RoOyBqKyspe1xuICAgICAgICAgICAgaWYocG9seUEuaW5kZXhPZihodWxsQS5mYWNlc1tpXVtqXSkhPT0tMSAvKiBTaGFyaW5nIGEgdmVydGV4Ki8gJiYgaSE9PWNsb3Nlc3RGYWNlQSAvKiBOb3QgdGhlIG9uZSB3ZSBhcmUgbG9va2luZyBmb3IgY29ubmVjdGlvbnMgZnJvbSAqLyAmJiBwb2x5QS5jb25uZWN0ZWRGYWNlcy5pbmRleE9mKGkpPT09LTEgLyogTm90IGFscmVhZHkgYWRkZWQgKi8gKXtcbiAgICAgICAgICAgICAgICBwb2x5QS5jb25uZWN0ZWRGYWNlcy5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENsaXAgdGhlIHBvbHlnb24gdG8gdGhlIGJhY2sgb2YgdGhlIHBsYW5lcyBvZiBhbGwgZmFjZXMgb2YgaHVsbCBBLCB0aGF0IGFyZSBhZGphY2VudCB0byB0aGUgd2l0bmVzcyBmYWNlXG4gICAgdmFyIG51bUNvbnRhY3RzID0gcFZ0eEluLmxlbmd0aDtcbiAgICB2YXIgbnVtVmVydGljZXNBID0gcG9seUEubGVuZ3RoO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IodmFyIGUwPTA7IGUwPG51bVZlcnRpY2VzQTsgZTArKyl7XG4gICAgICAgIHZhciBhID0gaHVsbEEudmVydGljZXNbcG9seUFbZTBdXTtcbiAgICAgICAgdmFyIGIgPSBodWxsQS52ZXJ0aWNlc1twb2x5QVsoZTArMSklbnVtVmVydGljZXNBXV07XG4gICAgICAgIGEudnN1YihiLGVkZ2UwKTtcbiAgICAgICAgV29ybGRFZGdlMC5jb3B5KGVkZ2UwKTtcbiAgICAgICAgcXVhdEEudm11bHQoV29ybGRFZGdlMCxXb3JsZEVkZ2UwKTtcbiAgICAgICAgcG9zQS52YWRkKFdvcmxkRWRnZTAsV29ybGRFZGdlMCk7XG4gICAgICAgIHdvcmxkUGxhbmVBbm9ybWFsMS5jb3B5KHRoaXMuZmFjZU5vcm1hbHNbY2xvc2VzdEZhY2VBXSk7Ly90cmFuc0EuZ2V0QmFzaXMoKSogYnRWZWN0b3IzKHBvbHlBLm1fcGxhbmVbMF0scG9seUEubV9wbGFuZVsxXSxwb2x5QS5tX3BsYW5lWzJdKTtcbiAgICAgICAgcXVhdEEudm11bHQod29ybGRQbGFuZUFub3JtYWwxLHdvcmxkUGxhbmVBbm9ybWFsMSk7XG4gICAgICAgIHBvc0EudmFkZCh3b3JsZFBsYW5lQW5vcm1hbDEsd29ybGRQbGFuZUFub3JtYWwxKTtcbiAgICAgICAgV29ybGRFZGdlMC5jcm9zcyh3b3JsZFBsYW5lQW5vcm1hbDEscGxhbmVOb3JtYWxXUzEpO1xuICAgICAgICBwbGFuZU5vcm1hbFdTMS5uZWdhdGUocGxhbmVOb3JtYWxXUzEpO1xuICAgICAgICB3b3JsZEExLmNvcHkoYSk7XG4gICAgICAgIHF1YXRBLnZtdWx0KHdvcmxkQTEsd29ybGRBMSk7XG4gICAgICAgIHBvc0EudmFkZCh3b3JsZEExLHdvcmxkQTEpO1xuICAgICAgICB2YXIgcGxhbmVFcVdTMSA9IC13b3JsZEExLmRvdChwbGFuZU5vcm1hbFdTMSk7XG4gICAgICAgIHZhciBwbGFuZUVxV1M7XG4gICAgICAgIGlmKHRydWUpe1xuICAgICAgICAgICAgdmFyIG90aGVyRmFjZSA9IHBvbHlBLmNvbm5lY3RlZEZhY2VzW2UwXTtcbiAgICAgICAgICAgIGxvY2FsUGxhbmVOb3JtYWwuY29weSh0aGlzLmZhY2VOb3JtYWxzW290aGVyRmFjZV0pO1xuICAgICAgICAgICAgdmFyIGxvY2FsUGxhbmVFcSA9IHRoaXMuZ2V0UGxhbmVDb25zdGFudE9mRmFjZShvdGhlckZhY2UpO1xuXG4gICAgICAgICAgICBwbGFuZU5vcm1hbFdTLmNvcHkobG9jYWxQbGFuZU5vcm1hbCk7XG4gICAgICAgICAgICBxdWF0QS52bXVsdChwbGFuZU5vcm1hbFdTLHBsYW5lTm9ybWFsV1MpO1xuICAgICAgICAgICAgLy9wb3NBLnZhZGQocGxhbmVOb3JtYWxXUyxwbGFuZU5vcm1hbFdTKTtcbiAgICAgICAgICAgIHZhciBwbGFuZUVxV1MgPSBsb2NhbFBsYW5lRXEgLSBwbGFuZU5vcm1hbFdTLmRvdChwb3NBKTtcbiAgICAgICAgfSBlbHNlICB7XG4gICAgICAgICAgICBwbGFuZU5vcm1hbFdTLmNvcHkocGxhbmVOb3JtYWxXUzEpO1xuICAgICAgICAgICAgcGxhbmVFcVdTID0gcGxhbmVFcVdTMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENsaXAgZmFjZSBhZ2FpbnN0IG91ciBjb25zdHJ1Y3RlZCBwbGFuZVxuICAgICAgICB0aGlzLmNsaXBGYWNlQWdhaW5zdFBsYW5lKHBWdHhJbiwgcFZ0eE91dCwgcGxhbmVOb3JtYWxXUywgcGxhbmVFcVdTKTtcblxuICAgICAgICAvLyBUaHJvdyBhd2F5IGFsbCBjbGlwcGVkIHBvaW50cywgYnV0IHNhdmUgdGhlIHJlYW1pbmluZyB1bnRpbCBuZXh0IGNsaXBcbiAgICAgICAgd2hpbGUocFZ0eEluLmxlbmd0aCl7XG4gICAgICAgICAgICBwVnR4SW4uc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZShwVnR4T3V0Lmxlbmd0aCl7XG4gICAgICAgICAgICBwVnR4SW4ucHVzaChwVnR4T3V0LnNoaWZ0KCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy9jb25zb2xlLmxvZyhcIlJlc3VsdGluZyBwb2ludHMgYWZ0ZXIgY2xpcDpcIixwVnR4SW4pO1xuXG4gICAgLy8gb25seSBrZWVwIGNvbnRhY3QgcG9pbnRzIHRoYXQgYXJlIGJlaGluZCB0aGUgd2l0bmVzcyBmYWNlXG4gICAgbG9jYWxQbGFuZU5vcm1hbC5jb3B5KHRoaXMuZmFjZU5vcm1hbHNbY2xvc2VzdEZhY2VBXSk7XG5cbiAgICB2YXIgbG9jYWxQbGFuZUVxID0gdGhpcy5nZXRQbGFuZUNvbnN0YW50T2ZGYWNlKGNsb3Nlc3RGYWNlQSk7XG4gICAgcGxhbmVOb3JtYWxXUy5jb3B5KGxvY2FsUGxhbmVOb3JtYWwpO1xuICAgIHF1YXRBLnZtdWx0KHBsYW5lTm9ybWFsV1MscGxhbmVOb3JtYWxXUyk7XG5cbiAgICB2YXIgcGxhbmVFcVdTID0gbG9jYWxQbGFuZUVxIC0gcGxhbmVOb3JtYWxXUy5kb3QocG9zQSk7XG4gICAgZm9yICh2YXIgaT0wOyBpPHBWdHhJbi5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBkZXB0aCA9IHBsYW5lTm9ybWFsV1MuZG90KHBWdHhJbltpXSkgKyBwbGFuZUVxV1M7IC8vPz8/XG4gICAgICAgIC8qY29uc29sZS5sb2coXCJkZXB0aCBjYWxjIGZyb20gbm9ybWFsPVwiLHBsYW5lTm9ybWFsV1MudG9TdHJpbmcoKSxcIiBhbmQgY29uc3RhbnQgXCIrcGxhbmVFcVdTK1wiIGFuZCB2ZXJ0ZXggXCIscFZ0eEluW2ldLnRvU3RyaW5nKCksXCIgZ2l2ZXMgXCIrZGVwdGgpOyovXG4gICAgICAgIGlmIChkZXB0aCA8PW1pbkRpc3Qpe1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJjbGFtcGVkOiBkZXB0aD1cIitkZXB0aCtcIiB0byBtaW5EaXN0PVwiKyhtaW5EaXN0K1wiXCIpKTtcbiAgICAgICAgICAgIGRlcHRoID0gbWluRGlzdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZXB0aCA8PW1heERpc3Qpe1xuICAgICAgICAgICAgdmFyIHBvaW50ID0gcFZ0eEluW2ldO1xuICAgICAgICAgICAgaWYoZGVwdGg8PTApe1xuICAgICAgICAgICAgICAgIC8qY29uc29sZS5sb2coXCJHb3QgY29udGFjdCBwb2ludCBcIixwb2ludC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgXCIsIGRlcHRoPVwiLGRlcHRoLFxuICAgICAgICAgICAgICAgICAgXCJjb250YWN0IG5vcm1hbD1cIixzZXBhcmF0aW5nTm9ybWFsLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICBcInBsYW5lXCIscGxhbmVOb3JtYWxXUy50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgXCJwbGFuZUNvbnN0YW50XCIscGxhbmVFcVdTKTsqL1xuICAgICAgICAgICAgICAgIHZhciBwID0ge1xuICAgICAgICAgICAgICAgICAgICBwb2ludDpwb2ludCxcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsOnBsYW5lTm9ybWFsV1MsXG4gICAgICAgICAgICAgICAgICAgIGRlcHRoOiBkZXB0aCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBDbGlwIGEgZmFjZSBpbiBhIGh1bGwgYWdhaW5zdCB0aGUgYmFjayBvZiBhIHBsYW5lLlxuICogQG1ldGhvZCBjbGlwRmFjZUFnYWluc3RQbGFuZVxuICogQHBhcmFtIHtBcnJheX0gaW5WZXJ0aWNlc1xuICogQHBhcmFtIHtBcnJheX0gb3V0VmVydGljZXNcbiAqIEBwYXJhbSB7VmVjM30gcGxhbmVOb3JtYWxcbiAqIEBwYXJhbSB7TnVtYmVyfSBwbGFuZUNvbnN0YW50IFRoZSBjb25zdGFudCBpbiB0aGUgbWF0aGVtYXRpY2FsIHBsYW5lIGVxdWF0aW9uXG4gKi9cbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLmNsaXBGYWNlQWdhaW5zdFBsYW5lID0gZnVuY3Rpb24oaW5WZXJ0aWNlcyxvdXRWZXJ0aWNlcywgcGxhbmVOb3JtYWwsIHBsYW5lQ29uc3RhbnQpe1xuICAgIHZhciBuX2RvdF9maXJzdCwgbl9kb3RfbGFzdDtcbiAgICB2YXIgbnVtVmVydHMgPSBpblZlcnRpY2VzLmxlbmd0aDtcblxuICAgIGlmKG51bVZlcnRzIDwgMil7XG4gICAgICAgIHJldHVybiBvdXRWZXJ0aWNlcztcbiAgICB9XG5cbiAgICB2YXIgZmlyc3RWZXJ0ZXggPSBpblZlcnRpY2VzW2luVmVydGljZXMubGVuZ3RoLTFdLFxuICAgICAgICBsYXN0VmVydGV4ID0gICBpblZlcnRpY2VzWzBdO1xuXG4gICAgbl9kb3RfZmlyc3QgPSBwbGFuZU5vcm1hbC5kb3QoZmlyc3RWZXJ0ZXgpICsgcGxhbmVDb25zdGFudDtcblxuICAgIGZvcih2YXIgdmkgPSAwOyB2aSA8IG51bVZlcnRzOyB2aSsrKXtcbiAgICAgICAgbGFzdFZlcnRleCA9IGluVmVydGljZXNbdmldO1xuICAgICAgICBuX2RvdF9sYXN0ID0gcGxhbmVOb3JtYWwuZG90KGxhc3RWZXJ0ZXgpICsgcGxhbmVDb25zdGFudDtcbiAgICAgICAgaWYobl9kb3RfZmlyc3QgPCAwKXtcbiAgICAgICAgICAgIGlmKG5fZG90X2xhc3QgPCAwKXtcbiAgICAgICAgICAgICAgICAvLyBTdGFydCA8IDAsIGVuZCA8IDAsIHNvIG91dHB1dCBsYXN0VmVydGV4XG4gICAgICAgICAgICAgICAgdmFyIG5ld3YgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgICAgIG5ld3YuY29weShsYXN0VmVydGV4KTtcbiAgICAgICAgICAgICAgICBvdXRWZXJ0aWNlcy5wdXNoKG5ld3YpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTdGFydCA8IDAsIGVuZCA+PSAwLCBzbyBvdXRwdXQgaW50ZXJzZWN0aW9uXG4gICAgICAgICAgICAgICAgdmFyIG5ld3YgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgICAgIGZpcnN0VmVydGV4LmxlcnAobGFzdFZlcnRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5fZG90X2ZpcnN0IC8gKG5fZG90X2ZpcnN0IC0gbl9kb3RfbGFzdCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXd2KTtcbiAgICAgICAgICAgICAgICBvdXRWZXJ0aWNlcy5wdXNoKG5ld3YpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYobl9kb3RfbGFzdDwwKXtcbiAgICAgICAgICAgICAgICAvLyBTdGFydCA+PSAwLCBlbmQgPCAwIHNvIG91dHB1dCBpbnRlcnNlY3Rpb24gYW5kIGVuZFxuICAgICAgICAgICAgICAgIHZhciBuZXd2ID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgICAgICBmaXJzdFZlcnRleC5sZXJwKGxhc3RWZXJ0ZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuX2RvdF9maXJzdCAvIChuX2RvdF9maXJzdCAtIG5fZG90X2xhc3QpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3dik7XG4gICAgICAgICAgICAgICAgb3V0VmVydGljZXMucHVzaChuZXd2KTtcbiAgICAgICAgICAgICAgICBvdXRWZXJ0aWNlcy5wdXNoKGxhc3RWZXJ0ZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpcnN0VmVydGV4ID0gbGFzdFZlcnRleDtcbiAgICAgICAgbl9kb3RfZmlyc3QgPSBuX2RvdF9sYXN0O1xuICAgIH1cbiAgICByZXR1cm4gb3V0VmVydGljZXM7XG59O1xuXG4vLyBVcGRhdGVzIC53b3JsZFZlcnRpY2VzIGFuZCBzZXRzIC53b3JsZFZlcnRpY2VzTmVlZHNVcGRhdGUgdG8gZmFsc2UuXG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS5jb21wdXRlV29ybGRWZXJ0aWNlcyA9IGZ1bmN0aW9uKHBvc2l0aW9uLHF1YXQpe1xuICAgIHZhciBOID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XG4gICAgd2hpbGUodGhpcy53b3JsZFZlcnRpY2VzLmxlbmd0aCA8IE4pe1xuICAgICAgICB0aGlzLndvcmxkVmVydGljZXMucHVzaCggbmV3IFZlYzMoKSApO1xuICAgIH1cblxuICAgIHZhciB2ZXJ0cyA9IHRoaXMudmVydGljZXMsXG4gICAgICAgIHdvcmxkVmVydHMgPSB0aGlzLndvcmxkVmVydGljZXM7XG4gICAgZm9yKHZhciBpPTA7IGkhPT1OOyBpKyspe1xuICAgICAgICBxdWF0LnZtdWx0KCB2ZXJ0c1tpXSAsIHdvcmxkVmVydHNbaV0gKTtcbiAgICAgICAgcG9zaXRpb24udmFkZCggd29ybGRWZXJ0c1tpXSAsIHdvcmxkVmVydHNbaV0gKTtcbiAgICB9XG5cbiAgICB0aGlzLndvcmxkVmVydGljZXNOZWVkc1VwZGF0ZSA9IGZhbHNlO1xufTtcblxudmFyIGNvbXB1dGVMb2NhbEFBQkJfd29ybGRWZXJ0ID0gbmV3IFZlYzMoKTtcbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLmNvbXB1dGVMb2NhbEFBQkIgPSBmdW5jdGlvbihhYWJibWluLGFhYmJtYXgpe1xuICAgIHZhciBuID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGgsXG4gICAgICAgIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcyxcbiAgICAgICAgd29ybGRWZXJ0ID0gY29tcHV0ZUxvY2FsQUFCQl93b3JsZFZlcnQ7XG5cbiAgICBhYWJibWluLnNldChOdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICBhYWJibWF4LnNldCgtTnVtYmVyLk1BWF9WQUxVRSwgLU51bWJlci5NQVhfVkFMVUUsIC1OdW1iZXIuTUFYX1ZBTFVFKTtcblxuICAgIGZvcih2YXIgaT0wOyBpPG47IGkrKyl7XG4gICAgICAgIHZhciB2ID0gdmVydGljZXNbaV07XG4gICAgICAgIGlmICAgICAodi54IDwgYWFiYm1pbi54KXtcbiAgICAgICAgICAgIGFhYmJtaW4ueCA9IHYueDtcbiAgICAgICAgfSBlbHNlIGlmKHYueCA+IGFhYmJtYXgueCl7XG4gICAgICAgICAgICBhYWJibWF4LnggPSB2Lng7XG4gICAgICAgIH1cbiAgICAgICAgaWYgICAgICh2LnkgPCBhYWJibWluLnkpe1xuICAgICAgICAgICAgYWFiYm1pbi55ID0gdi55O1xuICAgICAgICB9IGVsc2UgaWYodi55ID4gYWFiYm1heC55KXtcbiAgICAgICAgICAgIGFhYmJtYXgueSA9IHYueTtcbiAgICAgICAgfVxuICAgICAgICBpZiAgICAgKHYueiA8IGFhYmJtaW4ueil7XG4gICAgICAgICAgICBhYWJibWluLnogPSB2Lno7XG4gICAgICAgIH0gZWxzZSBpZih2LnogPiBhYWJibWF4Lnope1xuICAgICAgICAgICAgYWFiYm1heC56ID0gdi56O1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBVcGRhdGVzIC53b3JsZFZlcnRpY2VzIGFuZCBzZXRzIC53b3JsZFZlcnRpY2VzTmVlZHNVcGRhdGUgdG8gZmFsc2UuXG4gKiBAbWV0aG9kIGNvbXB1dGVXb3JsZEZhY2VOb3JtYWxzXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxdWF0XG4gKi9cbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLmNvbXB1dGVXb3JsZEZhY2VOb3JtYWxzID0gZnVuY3Rpb24ocXVhdCl7XG4gICAgdmFyIE4gPSB0aGlzLmZhY2VOb3JtYWxzLmxlbmd0aDtcbiAgICB3aGlsZSh0aGlzLndvcmxkRmFjZU5vcm1hbHMubGVuZ3RoIDwgTil7XG4gICAgICAgIHRoaXMud29ybGRGYWNlTm9ybWFscy5wdXNoKCBuZXcgVmVjMygpICk7XG4gICAgfVxuXG4gICAgdmFyIG5vcm1hbHMgPSB0aGlzLmZhY2VOb3JtYWxzLFxuICAgICAgICB3b3JsZE5vcm1hbHMgPSB0aGlzLndvcmxkRmFjZU5vcm1hbHM7XG4gICAgZm9yKHZhciBpPTA7IGkhPT1OOyBpKyspe1xuICAgICAgICBxdWF0LnZtdWx0KCBub3JtYWxzW2ldICwgd29ybGROb3JtYWxzW2ldICk7XG4gICAgfVxuXG4gICAgdGhpcy53b3JsZEZhY2VOb3JtYWxzTmVlZHNVcGRhdGUgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCB1cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1c1xuICovXG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cyA9IGZ1bmN0aW9uKCl7XG4gICAgLy8gQXNzdW1lIHBvaW50cyBhcmUgZGlzdHJpYnV0ZWQgd2l0aCBsb2NhbCAoMCwwLDApIGFzIGNlbnRlclxuICAgIHZhciBtYXgyID0gMDtcbiAgICB2YXIgdmVydHMgPSB0aGlzLnZlcnRpY2VzO1xuICAgIGZvcih2YXIgaT0wLCBOPXZlcnRzLmxlbmd0aDsgaSE9PU47IGkrKykge1xuICAgICAgICB2YXIgbm9ybTIgPSB2ZXJ0c1tpXS5ub3JtMigpO1xuICAgICAgICBpZihub3JtMiA+IG1heDIpe1xuICAgICAgICAgICAgbWF4MiA9IG5vcm0yO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMgPSBNYXRoLnNxcnQobWF4Mik7XG59O1xuXG52YXIgdGVtcFdvcmxkVmVydGV4ID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBAbWV0aG9kIGNhbGN1bGF0ZVdvcmxkQUFCQlxuICogQHBhcmFtIHtWZWMzfSAgICAgICAgcG9zXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259ICBxdWF0XG4gKiBAcGFyYW0ge1ZlYzN9ICAgICAgICBtaW5cbiAqIEBwYXJhbSB7VmVjM30gICAgICAgIG1heFxuICovXG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS5jYWxjdWxhdGVXb3JsZEFBQkIgPSBmdW5jdGlvbihwb3MscXVhdCxtaW4sbWF4KXtcbiAgICB2YXIgbiA9IHRoaXMudmVydGljZXMubGVuZ3RoLCB2ZXJ0cyA9IHRoaXMudmVydGljZXM7XG4gICAgdmFyIG1pbngsbWlueSxtaW56LG1heHgsbWF4eSxtYXh6O1xuICAgIGZvcih2YXIgaT0wOyBpPG47IGkrKyl7XG4gICAgICAgIHRlbXBXb3JsZFZlcnRleC5jb3B5KHZlcnRzW2ldKTtcbiAgICAgICAgcXVhdC52bXVsdCh0ZW1wV29ybGRWZXJ0ZXgsdGVtcFdvcmxkVmVydGV4KTtcbiAgICAgICAgcG9zLnZhZGQodGVtcFdvcmxkVmVydGV4LHRlbXBXb3JsZFZlcnRleCk7XG4gICAgICAgIHZhciB2ID0gdGVtcFdvcmxkVmVydGV4O1xuICAgICAgICBpZiAgICAgKHYueCA8IG1pbnggfHwgbWlueD09PXVuZGVmaW5lZCl7XG4gICAgICAgICAgICBtaW54ID0gdi54O1xuICAgICAgICB9IGVsc2UgaWYodi54ID4gbWF4eCB8fCBtYXh4PT09dW5kZWZpbmVkKXtcbiAgICAgICAgICAgIG1heHggPSB2Lng7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAgICAgKHYueSA8IG1pbnkgfHwgbWlueT09PXVuZGVmaW5lZCl7XG4gICAgICAgICAgICBtaW55ID0gdi55O1xuICAgICAgICB9IGVsc2UgaWYodi55ID4gbWF4eSB8fCBtYXh5PT09dW5kZWZpbmVkKXtcbiAgICAgICAgICAgIG1heHkgPSB2Lnk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAgICAgKHYueiA8IG1pbnogfHwgbWluej09PXVuZGVmaW5lZCl7XG4gICAgICAgICAgICBtaW56ID0gdi56O1xuICAgICAgICB9IGVsc2UgaWYodi56ID4gbWF4eiB8fCBtYXh6PT09dW5kZWZpbmVkKXtcbiAgICAgICAgICAgIG1heHogPSB2Lno7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWluLnNldChtaW54LG1pbnksbWlueik7XG4gICAgbWF4LnNldChtYXh4LG1heHksbWF4eik7XG59O1xuXG4vKipcbiAqIEdldCBhcHByb3hpbWF0ZSBjb252ZXggdm9sdW1lXG4gKiBAbWV0aG9kIHZvbHVtZVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS52b2x1bWUgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiA0LjAgKiBNYXRoLlBJICogdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyAvIDMuMDtcbn07XG5cbi8qKlxuICogR2V0IGFuIGF2ZXJhZ2Ugb2YgYWxsIHRoZSB2ZXJ0aWNlcyBwb3NpdGlvbnNcbiAqIEBtZXRob2QgZ2V0QXZlcmFnZVBvaW50TG9jYWxcbiAqIEBwYXJhbSAge1ZlYzN9IHRhcmdldFxuICogQHJldHVybiB7VmVjM31cbiAqL1xuQ29udmV4UG9seWhlZHJvbi5wcm90b3R5cGUuZ2V0QXZlcmFnZVBvaW50TG9jYWwgPSBmdW5jdGlvbih0YXJnZXQpe1xuICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgVmVjMygpO1xuICAgIHZhciBuID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGgsXG4gICAgICAgIHZlcnRzID0gdGhpcy52ZXJ0aWNlcztcbiAgICBmb3IodmFyIGk9MDsgaTxuOyBpKyspe1xuICAgICAgICB0YXJnZXQudmFkZCh2ZXJ0c1tpXSx0YXJnZXQpO1xuICAgIH1cbiAgICB0YXJnZXQubXVsdCgxL24sdGFyZ2V0KTtcbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYWxsIGxvY2FsIHBvaW50cy4gV2lsbCBjaGFuZ2UgdGhlIC52ZXJ0aWNlc1xuICogQG1ldGhvZCB0cmFuc2Zvcm1BbGxQb2ludHNcbiAqIEBwYXJhbSAge1ZlYzN9IG9mZnNldFxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcXVhdFxuICovXG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS50cmFuc2Zvcm1BbGxQb2ludHMgPSBmdW5jdGlvbihvZmZzZXQscXVhdCl7XG4gICAgdmFyIG4gPSB0aGlzLnZlcnRpY2VzLmxlbmd0aCxcbiAgICAgICAgdmVydHMgPSB0aGlzLnZlcnRpY2VzO1xuXG4gICAgLy8gQXBwbHkgcm90YXRpb25cbiAgICBpZihxdWF0KXtcbiAgICAgICAgLy8gUm90YXRlIHZlcnRpY2VzXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPG47IGkrKyl7XG4gICAgICAgICAgICB2YXIgdiA9IHZlcnRzW2ldO1xuICAgICAgICAgICAgcXVhdC52bXVsdCh2LHYpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJvdGF0ZSBmYWNlIG5vcm1hbHNcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8dGhpcy5mYWNlTm9ybWFscy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB2YXIgdiA9IHRoaXMuZmFjZU5vcm1hbHNbaV07XG4gICAgICAgICAgICBxdWF0LnZtdWx0KHYsdik7XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgLy8gUm90YXRlIGVkZ2VzXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHRoaXMudW5pcXVlRWRnZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIHYgPSB0aGlzLnVuaXF1ZUVkZ2VzW2ldO1xuICAgICAgICAgICAgcXVhdC52bXVsdCh2LHYpO1xuICAgICAgICB9Ki9cbiAgICB9XG5cbiAgICAvLyBBcHBseSBvZmZzZXRcbiAgICBpZihvZmZzZXQpe1xuICAgICAgICBmb3IodmFyIGk9MDsgaTxuOyBpKyspe1xuICAgICAgICAgICAgdmFyIHYgPSB2ZXJ0c1tpXTtcbiAgICAgICAgICAgIHYudmFkZChvZmZzZXQsdik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHAgaXMgaW5zaWRlIHRoZSBwb2x5aGVkcmEuIE11c3QgYmUgaW4gbG9jYWwgY29vcmRzLiBUaGUgcG9pbnQgbGllcyBvdXRzaWRlIG9mIHRoZSBjb252ZXggaHVsbCBvZiB0aGUgb3RoZXIgcG9pbnRzIGlmIGFuZCBvbmx5IGlmIHRoZSBkaXJlY3Rpb24gb2YgYWxsIHRoZSB2ZWN0b3JzIGZyb20gaXQgdG8gdGhvc2Ugb3RoZXIgcG9pbnRzIGFyZSBvbiBsZXNzIHRoYW4gb25lIGhhbGYgb2YgYSBzcGhlcmUgYXJvdW5kIGl0LlxuICogQG1ldGhvZCBwb2ludElzSW5zaWRlXG4gKiBAcGFyYW0gIHtWZWMzfSBwICAgICAgQSBwb2ludCBnaXZlbiBpbiBsb2NhbCBjb29yZGluYXRlc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIENvbnZleFBvbHloZWRyb25fcG9pbnRJc0luc2lkZSA9IG5ldyBWZWMzKCk7XG52YXIgQ29udmV4UG9seWhlZHJvbl92VG9QID0gbmV3IFZlYzMoKTtcbnZhciBDb252ZXhQb2x5aGVkcm9uX3ZUb1BvaW50SW5zaWRlID0gbmV3IFZlYzMoKTtcbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLnBvaW50SXNJbnNpZGUgPSBmdW5jdGlvbihwKXtcbiAgICB2YXIgbiA9IHRoaXMudmVydGljZXMubGVuZ3RoLFxuICAgICAgICB2ZXJ0cyA9IHRoaXMudmVydGljZXMsXG4gICAgICAgIGZhY2VzID0gdGhpcy5mYWNlcyxcbiAgICAgICAgbm9ybWFscyA9IHRoaXMuZmFjZU5vcm1hbHM7XG4gICAgdmFyIHBvc2l0aXZlUmVzdWx0ID0gbnVsbDtcbiAgICB2YXIgTiA9IHRoaXMuZmFjZXMubGVuZ3RoO1xuICAgIHZhciBwb2ludEluc2lkZSA9IENvbnZleFBvbHloZWRyb25fcG9pbnRJc0luc2lkZTtcbiAgICB0aGlzLmdldEF2ZXJhZ2VQb2ludExvY2FsKHBvaW50SW5zaWRlKTtcbiAgICBmb3IodmFyIGk9MDsgaTxOOyBpKyspe1xuICAgICAgICB2YXIgbnVtVmVydGljZXMgPSB0aGlzLmZhY2VzW2ldLmxlbmd0aDtcbiAgICAgICAgdmFyIG4gPSBub3JtYWxzW2ldO1xuICAgICAgICB2YXIgdiA9IHZlcnRzW2ZhY2VzW2ldWzBdXTsgLy8gV2Ugb25seSBuZWVkIG9uZSBwb2ludCBpbiB0aGUgZmFjZVxuXG4gICAgICAgIC8vIFRoaXMgZG90IHByb2R1Y3QgZGV0ZXJtaW5lcyB3aGljaCBzaWRlIG9mIHRoZSBlZGdlIHRoZSBwb2ludCBpc1xuICAgICAgICB2YXIgdlRvUCA9IENvbnZleFBvbHloZWRyb25fdlRvUDtcbiAgICAgICAgcC52c3ViKHYsdlRvUCk7XG4gICAgICAgIHZhciByMSA9IG4uZG90KHZUb1ApO1xuXG4gICAgICAgIHZhciB2VG9Qb2ludEluc2lkZSA9IENvbnZleFBvbHloZWRyb25fdlRvUG9pbnRJbnNpZGU7XG4gICAgICAgIHBvaW50SW5zaWRlLnZzdWIodix2VG9Qb2ludEluc2lkZSk7XG4gICAgICAgIHZhciByMiA9IG4uZG90KHZUb1BvaW50SW5zaWRlKTtcblxuICAgICAgICBpZigocjE8MCAmJiByMj4wKSB8fCAocjE+MCAmJiByMjwwKSl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIEVuY291bnRlcmVkIHNvbWUgb3RoZXIgc2lnbi4gRXhpdC5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHdlIGdvdCBoZXJlLCBhbGwgZG90IHByb2R1Y3RzIHdlcmUgb2YgdGhlIHNhbWUgc2lnbi5cbiAgICByZXR1cm4gcG9zaXRpdmVSZXN1bHQgPyAxIDogLTE7XG59O1xuXG4vKipcbiAqIEdldCBtYXggYW5kIG1pbiBkb3QgcHJvZHVjdCBvZiBhIGNvbnZleCBodWxsIGF0IHBvc2l0aW9uIChwb3MscXVhdCkgcHJvamVjdGVkIG9udG8gYW4gYXhpcy4gUmVzdWx0cyBhcmUgc2F2ZWQgaW4gdGhlIGFycmF5IG1heG1pbi5cbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgcHJvamVjdFxuICogQHBhcmFtIHtDb252ZXhQb2x5aGVkcm9ufSBodWxsXG4gKiBAcGFyYW0ge1ZlYzN9IGF4aXNcbiAqIEBwYXJhbSB7VmVjM30gcG9zXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHF1YXRcbiAqIEBwYXJhbSB7YXJyYXl9IHJlc3VsdCByZXN1bHRbMF0gYW5kIHJlc3VsdFsxXSB3aWxsIGJlIHNldCB0byBtYXhpbXVtIGFuZCBtaW5pbXVtLCByZXNwZWN0aXZlbHkuXG4gKi9cbnZhciBwcm9qZWN0X3dvcmxkVmVydGV4ID0gbmV3IFZlYzMoKTtcbnZhciBwcm9qZWN0X2xvY2FsQXhpcyA9IG5ldyBWZWMzKCk7XG52YXIgcHJvamVjdF9sb2NhbE9yaWdpbiA9IG5ldyBWZWMzKCk7XG5Db252ZXhQb2x5aGVkcm9uLnByb2plY3QgPSBmdW5jdGlvbihodWxsLCBheGlzLCBwb3MsIHF1YXQsIHJlc3VsdCl7XG4gICAgdmFyIG4gPSBodWxsLnZlcnRpY2VzLmxlbmd0aCxcbiAgICAgICAgd29ybGRWZXJ0ZXggPSBwcm9qZWN0X3dvcmxkVmVydGV4LFxuICAgICAgICBsb2NhbEF4aXMgPSBwcm9qZWN0X2xvY2FsQXhpcyxcbiAgICAgICAgbWF4ID0gMCxcbiAgICAgICAgbWluID0gMCxcbiAgICAgICAgbG9jYWxPcmlnaW4gPSBwcm9qZWN0X2xvY2FsT3JpZ2luLFxuICAgICAgICB2cyA9IGh1bGwudmVydGljZXM7XG5cbiAgICBsb2NhbE9yaWdpbi5zZXRaZXJvKCk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gdGhlIGF4aXMgdG8gbG9jYWxcbiAgICBUcmFuc2Zvcm0udmVjdG9yVG9Mb2NhbEZyYW1lKHBvcywgcXVhdCwgYXhpcywgbG9jYWxBeGlzKTtcbiAgICBUcmFuc2Zvcm0ucG9pbnRUb0xvY2FsRnJhbWUocG9zLCBxdWF0LCBsb2NhbE9yaWdpbiwgbG9jYWxPcmlnaW4pO1xuICAgIHZhciBhZGQgPSBsb2NhbE9yaWdpbi5kb3QobG9jYWxBeGlzKTtcblxuICAgIG1pbiA9IG1heCA9IHZzWzBdLmRvdChsb2NhbEF4aXMpO1xuXG4gICAgZm9yKHZhciBpID0gMTsgaSA8IG47IGkrKyl7XG4gICAgICAgIHZhciB2YWwgPSB2c1tpXS5kb3QobG9jYWxBeGlzKTtcblxuICAgICAgICBpZih2YWwgPiBtYXgpe1xuICAgICAgICAgICAgbWF4ID0gdmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodmFsIDwgbWluKXtcbiAgICAgICAgICAgIG1pbiA9IHZhbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1pbiAtPSBhZGQ7XG4gICAgbWF4IC09IGFkZDtcblxuICAgIGlmKG1pbiA+IG1heCl7XG4gICAgICAgIC8vIEluY29uc2lzdGVudCAtIHN3YXBcbiAgICAgICAgdmFyIHRlbXAgPSBtaW47XG4gICAgICAgIG1pbiA9IG1heDtcbiAgICAgICAgbWF4ID0gdGVtcDtcbiAgICB9XG4gICAgLy8gT3V0cHV0XG4gICAgcmVzdWx0WzBdID0gbWF4O1xuICAgIHJlc3VsdFsxXSA9IG1pbjtcbn07XG5cbn0se1wiLi4vbWF0aC9RdWF0ZXJuaW9uXCI6MjgsXCIuLi9tYXRoL1RyYW5zZm9ybVwiOjI5LFwiLi4vbWF0aC9WZWMzXCI6MzAsXCIuL1NoYXBlXCI6NDN9XSwzOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IEN5bGluZGVyO1xuXG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuL1NoYXBlJyk7XG52YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xudmFyIFF1YXRlcm5pb24gPSBfZGVyZXFfKCcuLi9tYXRoL1F1YXRlcm5pb24nKTtcbnZhciBDb252ZXhQb2x5aGVkcm9uID0gX2RlcmVxXygnLi9Db252ZXhQb2x5aGVkcm9uJyk7XG5cbi8qKlxuICogQGNsYXNzIEN5bGluZGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIENvbnZleFBvbHloZWRyb25cbiAqIEBhdXRob3Igc2NodGVwcGUgLyBodHRwczovL2dpdGh1Yi5jb20vc2NodGVwcGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNUb3BcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNCb3R0b21cbiAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW1TZWdtZW50cyBUaGUgbnVtYmVyIG9mIHNlZ21lbnRzIHRvIGJ1aWxkIHRoZSBjeWxpbmRlciBvdXQgb2ZcbiAqL1xuZnVuY3Rpb24gQ3lsaW5kZXIoIHJhZGl1c1RvcCwgcmFkaXVzQm90dG9tLCBoZWlnaHQgLCBudW1TZWdtZW50cyApIHtcbiAgICB2YXIgTiA9IG51bVNlZ21lbnRzLFxuICAgICAgICB2ZXJ0cyA9IFtdLFxuICAgICAgICBheGVzID0gW10sXG4gICAgICAgIGZhY2VzID0gW10sXG4gICAgICAgIGJvdHRvbWZhY2UgPSBbXSxcbiAgICAgICAgdG9wZmFjZSA9IFtdLFxuICAgICAgICBjb3MgPSBNYXRoLmNvcyxcbiAgICAgICAgc2luID0gTWF0aC5zaW47XG5cbiAgICAvLyBGaXJzdCBib3R0b20gcG9pbnRcbiAgICB2ZXJ0cy5wdXNoKG5ldyBWZWMzKHJhZGl1c0JvdHRvbSpjb3MoMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzQm90dG9tKnNpbigwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtaGVpZ2h0KjAuNSkpO1xuICAgIGJvdHRvbWZhY2UucHVzaCgwKTtcblxuICAgIC8vIEZpcnN0IHRvcCBwb2ludFxuICAgIHZlcnRzLnB1c2gobmV3IFZlYzMocmFkaXVzVG9wKmNvcygwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYWRpdXNUb3Aqc2luKDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCowLjUpKTtcbiAgICB0b3BmYWNlLnB1c2goMSk7XG5cbiAgICBmb3IodmFyIGk9MDsgaTxOOyBpKyspe1xuICAgICAgICB2YXIgdGhldGEgPSAyKk1hdGguUEkvTiAqIChpKzEpO1xuICAgICAgICB2YXIgdGhldGFOID0gMipNYXRoLlBJL04gKiAoaSswLjUpO1xuICAgICAgICBpZihpPE4tMSl7XG4gICAgICAgICAgICAvLyBCb3R0b21cbiAgICAgICAgICAgIHZlcnRzLnB1c2gobmV3IFZlYzMocmFkaXVzQm90dG9tKmNvcyh0aGV0YSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYWRpdXNCb3R0b20qc2luKHRoZXRhKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC1oZWlnaHQqMC41KSk7XG4gICAgICAgICAgICBib3R0b21mYWNlLnB1c2goMippKzIpO1xuICAgICAgICAgICAgLy8gVG9wXG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKG5ldyBWZWMzKHJhZGl1c1RvcCpjb3ModGhldGEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzVG9wKnNpbih0aGV0YSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQqMC41KSk7XG4gICAgICAgICAgICB0b3BmYWNlLnB1c2goMippKzMpO1xuXG4gICAgICAgICAgICAvLyBGYWNlXG4gICAgICAgICAgICBmYWNlcy5wdXNoKFsyKmkrMiwgMippKzMsIDIqaSsxLDIqaV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmFjZXMucHVzaChbMCwxLCAyKmkrMSwgMippXSk7IC8vIENvbm5lY3RcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEF4aXM6IHdlIGNhbiBjdXQgb2ZmIGhhbGYgb2YgdGhlbSBpZiB3ZSBoYXZlIGV2ZW4gbnVtYmVyIG9mIHNlZ21lbnRzXG4gICAgICAgIGlmKE4gJSAyID09PSAxIHx8IGkgPCBOIC8gMil7XG4gICAgICAgICAgICBheGVzLnB1c2gobmV3IFZlYzMoY29zKHRoZXRhTiksIHNpbih0aGV0YU4pLCAwKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmFjZXMucHVzaCh0b3BmYWNlKTtcbiAgICBheGVzLnB1c2gobmV3IFZlYzMoMCwwLDEpKTtcblxuICAgIC8vIFJlb3JkZXIgYm90dG9tIGZhY2VcbiAgICB2YXIgdGVtcCA9IFtdO1xuICAgIGZvcih2YXIgaT0wOyBpPGJvdHRvbWZhY2UubGVuZ3RoOyBpKyspe1xuICAgICAgICB0ZW1wLnB1c2goYm90dG9tZmFjZVtib3R0b21mYWNlLmxlbmd0aCAtIGkgLSAxXSk7XG4gICAgfVxuICAgIGZhY2VzLnB1c2godGVtcCk7XG5cbiAgICB0aGlzLnR5cGUgPSBTaGFwZS50eXBlcy5DT05WRVhQT0xZSEVEUk9OO1xuICAgIENvbnZleFBvbHloZWRyb24uY2FsbCggdGhpcywgdmVydHMsIGZhY2VzLCBheGVzICk7XG59XG5cbkN5bGluZGVyLnByb3RvdHlwZSA9IG5ldyBDb252ZXhQb2x5aGVkcm9uKCk7XG5cbn0se1wiLi4vbWF0aC9RdWF0ZXJuaW9uXCI6MjgsXCIuLi9tYXRoL1ZlYzNcIjozMCxcIi4vQ29udmV4UG9seWhlZHJvblwiOjM4LFwiLi9TaGFwZVwiOjQzfV0sNDA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIFNoYXBlID0gX2RlcmVxXygnLi9TaGFwZScpO1xudmFyIENvbnZleFBvbHloZWRyb24gPSBfZGVyZXFfKCcuL0NvbnZleFBvbHloZWRyb24nKTtcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XG52YXIgVXRpbHMgPSBfZGVyZXFfKCcuLi91dGlscy9VdGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhlaWdodGZpZWxkO1xuXG4vKipcbiAqIEhlaWdodGZpZWxkIHNoYXBlIGNsYXNzLiBIZWlnaHQgZGF0YSBpcyBnaXZlbiBhcyBhbiBhcnJheS4gVGhlc2UgZGF0YSBwb2ludHMgYXJlIHNwcmVhZCBvdXQgZXZlbmx5IHdpdGggYSBnaXZlbiBkaXN0YW5jZS5cbiAqIEBjbGFzcyBIZWlnaHRmaWVsZFxuICogQGV4dGVuZHMgU2hhcGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gZGF0YSBBbiBhcnJheSBvZiBZIHZhbHVlcyB0aGF0IHdpbGwgYmUgdXNlZCB0byBjb25zdHJ1Y3QgdGhlIHRlcnJhaW4uXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1pblZhbHVlXSBNaW5pbXVtIHZhbHVlIG9mIHRoZSBkYXRhIHBvaW50cyBpbiB0aGUgZGF0YSBhcnJheS4gV2lsbCBiZSBjb21wdXRlZCBhdXRvbWF0aWNhbGx5IGlmIG5vdCBnaXZlbi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhWYWx1ZV0gTWF4aW11bSB2YWx1ZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5lbGVtZW50U2l6ZT0wLjFdIFdvcmxkIHNwYWNpbmcgYmV0d2VlbiB0aGUgZGF0YSBwb2ludHMgaW4gWCBkaXJlY3Rpb24uXG4gKiBAdG9kbyBTaG91bGQgYmUgcG9zc2libGUgdG8gdXNlIGFsb25nIGFsbCBheGVzLCBub3QganVzdCB5XG4gKlxuICogQGV4YW1wbGVcbiAqICAgICAvLyBHZW5lcmF0ZSBzb21lIGhlaWdodCBkYXRhICh5LXZhbHVlcykuXG4gKiAgICAgdmFyIGRhdGEgPSBbXTtcbiAqICAgICBmb3IodmFyIGkgPSAwOyBpIDwgMTAwMDsgaSsrKXtcbiAqICAgICAgICAgdmFyIHkgPSAwLjUgKiBNYXRoLmNvcygwLjIgKiBpKTtcbiAqICAgICAgICAgZGF0YS5wdXNoKHkpO1xuICogICAgIH1cbiAqXG4gKiAgICAgLy8gQ3JlYXRlIHRoZSBoZWlnaHRmaWVsZCBzaGFwZVxuICogICAgIHZhciBoZWlnaHRmaWVsZFNoYXBlID0gbmV3IEhlaWdodGZpZWxkKGRhdGEsIHtcbiAqICAgICAgICAgZWxlbWVudFNpemU6IDEgLy8gRGlzdGFuY2UgYmV0d2VlbiB0aGUgZGF0YSBwb2ludHMgaW4gWCBhbmQgWSBkaXJlY3Rpb25zXG4gKiAgICAgfSk7XG4gKiAgICAgdmFyIGhlaWdodGZpZWxkQm9keSA9IG5ldyBCb2R5KCk7XG4gKiAgICAgaGVpZ2h0ZmllbGRCb2R5LmFkZFNoYXBlKGhlaWdodGZpZWxkU2hhcGUpO1xuICogICAgIHdvcmxkLmFkZEJvZHkoaGVpZ2h0ZmllbGRCb2R5KTtcbiAqL1xuZnVuY3Rpb24gSGVpZ2h0ZmllbGQoZGF0YSwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgICAgbWF4VmFsdWUgOiBudWxsLFxuICAgICAgICBtaW5WYWx1ZSA6IG51bGwsXG4gICAgICAgIGVsZW1lbnRTaXplIDogMVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgbnVtYmVycywgb3IgaGVpZ2h0IHZhbHVlcywgdGhhdCBhcmUgc3ByZWFkIG91dCBhbG9uZyB0aGUgeCBheGlzLlxuICAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9IGRhdGFcbiAgICAgKi9cbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuXG4gICAgLyoqXG4gICAgICogTWF4IHZhbHVlIG9mIHRoZSBkYXRhXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1heFZhbHVlXG4gICAgICovXG4gICAgdGhpcy5tYXhWYWx1ZSA9IG9wdGlvbnMubWF4VmFsdWU7XG5cbiAgICAvKipcbiAgICAgKiBNYXggdmFsdWUgb2YgdGhlIGRhdGFcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWluVmFsdWVcbiAgICAgKi9cbiAgICB0aGlzLm1pblZhbHVlID0gb3B0aW9ucy5taW5WYWx1ZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCBvZiBlYWNoIGVsZW1lbnRcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZWxlbWVudFNpemVcbiAgICAgKiBAdG9kbyBlbGVtZW50U2l6ZVggYW5kIFlcbiAgICAgKi9cbiAgICB0aGlzLmVsZW1lbnRTaXplID0gb3B0aW9ucy5lbGVtZW50U2l6ZTtcblxuICAgIGlmKG9wdGlvbnMubWluVmFsdWUgPT09IG51bGwpe1xuICAgICAgICB0aGlzLnVwZGF0ZU1pblZhbHVlKCk7XG4gICAgfVxuICAgIGlmKG9wdGlvbnMubWF4VmFsdWUgPT09IG51bGwpe1xuICAgICAgICB0aGlzLnVwZGF0ZU1heFZhbHVlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5jYWNoZUVuYWJsZWQgPSB0cnVlO1xuXG4gICAgU2hhcGUuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMucGlsbGFyQ29udmV4ID0gbmV3IENvbnZleFBvbHloZWRyb24oKTtcbiAgICB0aGlzLnBpbGxhck9mZnNldCA9IG5ldyBWZWMzKCk7XG5cbiAgICB0aGlzLnR5cGUgPSBTaGFwZS50eXBlcy5IRUlHSFRGSUVMRDtcbiAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCk7XG5cbiAgICAvLyBcImlfal9pc1VwcGVyXCIgPT4geyBjb252ZXg6IC4uLiwgb2Zmc2V0OiAuLi4gfVxuICAgIC8vIGZvciBleGFtcGxlOlxuICAgIC8vIF9jYWNoZWRQaWxsYXJzW1wiMF8yXzFcIl1cbiAgICB0aGlzLl9jYWNoZWRQaWxsYXJzID0ge307XG59XG5IZWlnaHRmaWVsZC5wcm90b3R5cGUgPSBuZXcgU2hhcGUoKTtcblxuLyoqXG4gKiBDYWxsIHdoZW5ldmVyIHlvdSBjaGFuZ2UgdGhlIGRhdGEgYXJyYXkuXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICovXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLl9jYWNoZWRQaWxsYXJzID0ge307XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgLm1pblZhbHVlIHByb3BlcnR5XG4gKiBAbWV0aG9kIHVwZGF0ZU1pblZhbHVlXG4gKi9cbkhlaWdodGZpZWxkLnByb3RvdHlwZS51cGRhdGVNaW5WYWx1ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgdmFyIG1pblZhbHVlID0gZGF0YVswXVswXTtcbiAgICBmb3IodmFyIGk9MDsgaSAhPT0gZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGZvcih2YXIgaj0wOyBqICE9PSBkYXRhW2ldLmxlbmd0aDsgaisrKXtcbiAgICAgICAgICAgIHZhciB2ID0gZGF0YVtpXVtqXTtcbiAgICAgICAgICAgIGlmKHYgPCBtaW5WYWx1ZSl7XG4gICAgICAgICAgICAgICAgbWluVmFsdWUgPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMubWluVmFsdWUgPSBtaW5WYWx1ZTtcbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSAubWF4VmFsdWUgcHJvcGVydHlcbiAqIEBtZXRob2QgdXBkYXRlTWF4VmFsdWVcbiAqL1xuSGVpZ2h0ZmllbGQucHJvdG90eXBlLnVwZGF0ZU1heFZhbHVlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgbWF4VmFsdWUgPSBkYXRhWzBdWzBdO1xuICAgIGZvcih2YXIgaT0wOyBpICE9PSBkYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgZm9yKHZhciBqPTA7IGogIT09IGRhdGFbaV0ubGVuZ3RoOyBqKyspe1xuICAgICAgICAgICAgdmFyIHYgPSBkYXRhW2ldW2pdO1xuICAgICAgICAgICAgaWYodiA+IG1heFZhbHVlKXtcbiAgICAgICAgICAgICAgICBtYXhWYWx1ZSA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5tYXhWYWx1ZSA9IG1heFZhbHVlO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGhlaWdodCB2YWx1ZSBhdCBhbiBpbmRleC4gRG9uJ3QgZm9yZ2V0IHRvIHVwZGF0ZSBtYXhWYWx1ZSBhbmQgbWluVmFsdWUgYWZ0ZXIgeW91J3JlIGRvbmUuXG4gKiBAbWV0aG9kIHNldEhlaWdodFZhbHVlQXRJbmRleFxuICogQHBhcmFtIHtpbnRlZ2VyfSB4aVxuICogQHBhcmFtIHtpbnRlZ2VyfSB5aVxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKi9cbkhlaWdodGZpZWxkLnByb3RvdHlwZS5zZXRIZWlnaHRWYWx1ZUF0SW5kZXggPSBmdW5jdGlvbih4aSwgeWksIHZhbHVlKXtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBkYXRhW3hpXVt5aV0gPSB2YWx1ZTtcblxuICAgIC8vIEludmFsaWRhdGUgY2FjaGVcbiAgICB0aGlzLmNsZWFyQ2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGksIHlpLCBmYWxzZSk7XG4gICAgaWYoeGkgPiAwKXtcbiAgICAgICAgdGhpcy5jbGVhckNhY2hlZENvbnZleFRyaWFuZ2xlUGlsbGFyKHhpIC0gMSwgeWksIHRydWUpO1xuICAgICAgICB0aGlzLmNsZWFyQ2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGkgLSAxLCB5aSwgZmFsc2UpO1xuICAgIH1cbiAgICBpZih5aSA+IDApe1xuICAgICAgICB0aGlzLmNsZWFyQ2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGksIHlpIC0gMSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuY2xlYXJDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhcih4aSwgeWkgLSAxLCBmYWxzZSk7XG4gICAgfVxuICAgIGlmKHlpID4gMCAmJiB4aSA+IDApe1xuICAgICAgICB0aGlzLmNsZWFyQ2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGkgLSAxLCB5aSAtIDEsIHRydWUpO1xuICAgIH1cbn07XG5cbi8qKlxuICogR2V0IG1heC9taW4gaW4gYSByZWN0YW5nbGUgaW4gdGhlIG1hdHJpeCBkYXRhXG4gKiBAbWV0aG9kIGdldFJlY3RNaW5NYXhcbiAqIEBwYXJhbSAge2ludGVnZXJ9IGlNaW5YXG4gKiBAcGFyYW0gIHtpbnRlZ2VyfSBpTWluWVxuICogQHBhcmFtICB7aW50ZWdlcn0gaU1heFhcbiAqIEBwYXJhbSAge2ludGVnZXJ9IGlNYXhZXG4gKiBAcGFyYW0gIHthcnJheX0gW3Jlc3VsdF0gQW4gYXJyYXkgdG8gc3RvcmUgdGhlIHJlc3VsdHMgaW4uXG4gKiBAcmV0dXJuIHthcnJheX0gVGhlIHJlc3VsdCBhcnJheSwgaWYgaXQgd2FzIHBhc3NlZCBpbi4gTWluaW11bSB3aWxsIGJlIGF0IHBvc2l0aW9uIDAgYW5kIG1heCBhdCAxLlxuICovXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUuZ2V0UmVjdE1pbk1heCA9IGZ1bmN0aW9uIChpTWluWCwgaU1pblksIGlNYXhYLCBpTWF4WSwgcmVzdWx0KSB7XG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IFtdO1xuXG4gICAgLy8gR2V0IG1heCBhbmQgbWluIG9mIHRoZSBkYXRhXG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGEsXG4gICAgICAgIG1heCA9IHRoaXMubWluVmFsdWU7IC8vIFNldCBmaXJzdCB2YWx1ZVxuICAgIGZvcih2YXIgaSA9IGlNaW5YOyBpIDw9IGlNYXhYOyBpKyspe1xuICAgICAgICBmb3IodmFyIGogPSBpTWluWTsgaiA8PSBpTWF4WTsgaisrKXtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBkYXRhW2ldW2pdO1xuICAgICAgICAgICAgaWYoaGVpZ2h0ID4gbWF4KXtcbiAgICAgICAgICAgICAgICBtYXggPSBoZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXN1bHRbMF0gPSB0aGlzLm1pblZhbHVlO1xuICAgIHJlc3VsdFsxXSA9IG1heDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBpbmRleCBvZiBhIGxvY2FsIHBvc2l0aW9uIG9uIHRoZSBoZWlnaHRmaWVsZC4gVGhlIGluZGV4ZXMgaW5kaWNhdGUgdGhlIHJlY3RhbmdsZXMsIHNvIGlmIHlvdXIgdGVycmFpbiBpcyBtYWRlIG9mIE4geCBOIGhlaWdodCBkYXRhIHBvaW50cywgeW91IHdpbGwgaGF2ZSByZWN0YW5nbGUgaW5kZXhlcyByYW5naW5nIGZyb20gMCB0byBOLTEuXG4gKiBAbWV0aG9kIGdldEluZGV4T2ZQb3NpdGlvblxuICogQHBhcmFtICB7bnVtYmVyfSB4XG4gKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAqIEBwYXJhbSAge2FycmF5fSByZXN1bHQgVHdvLWVsZW1lbnQgYXJyYXlcbiAqIEBwYXJhbSAge2Jvb2xlYW59IGNsYW1wIElmIHRoZSBwb3NpdGlvbiBzaG91bGQgYmUgY2xhbXBlZCB0byB0aGUgaGVpZ2h0ZmllbGQgZWRnZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbkhlaWdodGZpZWxkLnByb3RvdHlwZS5nZXRJbmRleE9mUG9zaXRpb24gPSBmdW5jdGlvbiAoeCwgeSwgcmVzdWx0LCBjbGFtcCkge1xuXG4gICAgLy8gR2V0IHRoZSBpbmRleCBvZiB0aGUgZGF0YSBwb2ludHMgdG8gdGVzdCBhZ2FpbnN0XG4gICAgdmFyIHcgPSB0aGlzLmVsZW1lbnRTaXplO1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgIHZhciB4aSA9IE1hdGguZmxvb3IoeCAvIHcpO1xuICAgIHZhciB5aSA9IE1hdGguZmxvb3IoeSAvIHcpO1xuXG4gICAgcmVzdWx0WzBdID0geGk7XG4gICAgcmVzdWx0WzFdID0geWk7XG5cbiAgICBpZihjbGFtcCl7XG4gICAgICAgIC8vIENsYW1wIGluZGV4IHRvIGVkZ2VzXG4gICAgICAgIGlmKHhpIDwgMCl7IHhpID0gMDsgfVxuICAgICAgICBpZih5aSA8IDApeyB5aSA9IDA7IH1cbiAgICAgICAgaWYoeGkgPj0gZGF0YS5sZW5ndGggLSAxKXsgeGkgPSBkYXRhLmxlbmd0aCAtIDE7IH1cbiAgICAgICAgaWYoeWkgPj0gZGF0YVswXS5sZW5ndGggLSAxKXsgeWkgPSBkYXRhWzBdLmxlbmd0aCAtIDE7IH1cbiAgICB9XG5cbiAgICAvLyBCYWlsIG91dCBpZiB3ZSBhcmUgb3V0IG9mIHRoZSB0ZXJyYWluXG4gICAgaWYoeGkgPCAwIHx8IHlpIDwgMCB8fCB4aSA+PSBkYXRhLmxlbmd0aC0xIHx8IHlpID49IGRhdGFbMF0ubGVuZ3RoLTEpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUuZ2V0SGVpZ2h0QXQgPSBmdW5jdGlvbih4LCB5LCBlZGdlQ2xhbXApe1xuICAgIHZhciBpZHggPSBbXTtcbiAgICB0aGlzLmdldEluZGV4T2ZQb3NpdGlvbih4LCB5LCBpZHgsIGVkZ2VDbGFtcCk7XG5cbiAgICAvLyBUT0RPOiBnZXQgdXBwZXIgb3IgbG93ZXIgdHJpYW5nbGUsIHRoZW4gdXNlIGJhcnljZW50cmljIGludGVycG9sYXRpb24gdG8gZ2V0IHRoZSBoZWlnaHQgaW4gdGhlIHRyaWFuZ2xlLlxuICAgIHZhciBtaW5tYXggPSBbXTtcbiAgICB0aGlzLmdldFJlY3RNaW5NYXgoaWR4WzBdLCBpZHhbMV0gKyAxLCBpZHhbMF0sIGlkeFsxXSArIDEsIG1pbm1heCk7XG5cbiAgICByZXR1cm4gKG1pbm1heFswXSArIG1pbm1heFsxXSkgLyAyOyAvLyBhdmVyYWdlXG59O1xuXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUuZ2V0Q2FjaGVDb252ZXhUcmlhbmdsZVBpbGxhcktleSA9IGZ1bmN0aW9uKHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSl7XG4gICAgcmV0dXJuIHhpICsgJ18nICsgeWkgKyAnXycgKyAoZ2V0VXBwZXJUcmlhbmdsZSA/IDEgOiAwKTtcbn07XG5cbkhlaWdodGZpZWxkLnByb3RvdHlwZS5nZXRDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhciA9IGZ1bmN0aW9uKHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSl7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZFBpbGxhcnNbdGhpcy5nZXRDYWNoZUNvbnZleFRyaWFuZ2xlUGlsbGFyS2V5KHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSldO1xufTtcblxuSGVpZ2h0ZmllbGQucHJvdG90eXBlLnNldENhY2hlZENvbnZleFRyaWFuZ2xlUGlsbGFyID0gZnVuY3Rpb24oeGksIHlpLCBnZXRVcHBlclRyaWFuZ2xlLCBjb252ZXgsIG9mZnNldCl7XG4gICAgdGhpcy5fY2FjaGVkUGlsbGFyc1t0aGlzLmdldENhY2hlQ29udmV4VHJpYW5nbGVQaWxsYXJLZXkoeGksIHlpLCBnZXRVcHBlclRyaWFuZ2xlKV0gPSB7XG4gICAgICAgIGNvbnZleDogY29udmV4LFxuICAgICAgICBvZmZzZXQ6IG9mZnNldFxuICAgIH07XG59O1xuXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUuY2xlYXJDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhciA9IGZ1bmN0aW9uKHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSl7XG4gICAgZGVsZXRlIHRoaXMuX2NhY2hlZFBpbGxhcnNbdGhpcy5nZXRDYWNoZUNvbnZleFRyaWFuZ2xlUGlsbGFyS2V5KHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSldO1xufTtcblxuLyoqXG4gKiBHZXQgYSB0cmlhbmdsZSBpbiB0aGUgdGVycmFpbiBpbiB0aGUgZm9ybSBvZiBhIHRyaWFuZ3VsYXIgY29udmV4IHNoYXBlLlxuICogQG1ldGhvZCBnZXRDb252ZXhUcmlhbmdsZVBpbGxhclxuICogQHBhcmFtICB7aW50ZWdlcn0gaVxuICogQHBhcmFtICB7aW50ZWdlcn0galxuICogQHBhcmFtICB7Ym9vbGVhbn0gZ2V0VXBwZXJUcmlhbmdsZVxuICovXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUuZ2V0Q29udmV4VHJpYW5nbGVQaWxsYXIgPSBmdW5jdGlvbih4aSwgeWksIGdldFVwcGVyVHJpYW5nbGUpe1xuICAgIHZhciByZXN1bHQgPSB0aGlzLnBpbGxhckNvbnZleDtcbiAgICB2YXIgb2Zmc2V0UmVzdWx0ID0gdGhpcy5waWxsYXJPZmZzZXQ7XG5cbiAgICBpZih0aGlzLmNhY2hlRW5hYmxlZCl7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5nZXRDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhcih4aSwgeWksIGdldFVwcGVyVHJpYW5nbGUpO1xuICAgICAgICBpZihkYXRhKXtcbiAgICAgICAgICAgIHRoaXMucGlsbGFyQ29udmV4ID0gZGF0YS5jb252ZXg7XG4gICAgICAgICAgICB0aGlzLnBpbGxhck9mZnNldCA9IGRhdGEub2Zmc2V0O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gbmV3IENvbnZleFBvbHloZWRyb24oKTtcbiAgICAgICAgb2Zmc2V0UmVzdWx0ID0gbmV3IFZlYzMoKTtcblxuICAgICAgICB0aGlzLnBpbGxhckNvbnZleCA9IHJlc3VsdDtcbiAgICAgICAgdGhpcy5waWxsYXJPZmZzZXQgPSBvZmZzZXRSZXN1bHQ7XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgdmFyIGVsZW1lbnRTaXplID0gdGhpcy5lbGVtZW50U2l6ZTtcbiAgICB2YXIgZmFjZXMgPSByZXN1bHQuZmFjZXM7XG5cbiAgICAvLyBSZXVzZSB2ZXJ0cyBpZiBwb3NzaWJsZVxuICAgIHJlc3VsdC52ZXJ0aWNlcy5sZW5ndGggPSA2O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICAgIGlmKCFyZXN1bHQudmVydGljZXNbaV0pe1xuICAgICAgICAgICAgcmVzdWx0LnZlcnRpY2VzW2ldID0gbmV3IFZlYzMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldXNlIGZhY2VzIGlmIHBvc3NpYmxlXG4gICAgZmFjZXMubGVuZ3RoID0gNTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICBpZighZmFjZXNbaV0pe1xuICAgICAgICAgICAgZmFjZXNbaV0gPSBbXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB2ZXJ0cyA9IHJlc3VsdC52ZXJ0aWNlcztcblxuICAgIHZhciBoID0gKE1hdGgubWluKFxuICAgICAgICBkYXRhW3hpXVt5aV0sXG4gICAgICAgIGRhdGFbeGkrMV1beWldLFxuICAgICAgICBkYXRhW3hpXVt5aSsxXSxcbiAgICAgICAgZGF0YVt4aSsxXVt5aSsxXVxuICAgICkgLSB0aGlzLm1pblZhbHVlICkgLyAyICsgdGhpcy5taW5WYWx1ZTtcblxuICAgIGlmICghZ2V0VXBwZXJUcmlhbmdsZSkge1xuXG4gICAgICAgIC8vIENlbnRlciBvZiB0aGUgdHJpYW5nbGUgcGlsbGFyIC0gYWxsIHBvbHlnb25zIGFyZSBnaXZlbiByZWxhdGl2ZSB0byB0aGlzIG9uZVxuICAgICAgICBvZmZzZXRSZXN1bHQuc2V0KFxuICAgICAgICAgICAgKHhpICsgMC4yNSkgKiBlbGVtZW50U2l6ZSwgLy8gc29ydCBvZiBjZW50ZXIgb2YgYSB0cmlhbmdsZVxuICAgICAgICAgICAgKHlpICsgMC4yNSkgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgIGggLy8gdmVydGljYWwgY2VudGVyXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gVG9wIHRyaWFuZ2xlIHZlcnRzXG4gICAgICAgIHZlcnRzWzBdLnNldChcbiAgICAgICAgICAgIC0wLjI1ICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICAtMC4yNSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgZGF0YVt4aV1beWldIC0gaFxuICAgICAgICApO1xuICAgICAgICB2ZXJ0c1sxXS5zZXQoXG4gICAgICAgICAgICAwLjc1ICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICAtMC4yNSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgZGF0YVt4aSArIDFdW3lpXSAtIGhcbiAgICAgICAgKTtcbiAgICAgICAgdmVydHNbMl0uc2V0KFxuICAgICAgICAgICAgLTAuMjUgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgIDAuNzUgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgIGRhdGFbeGldW3lpICsgMV0gLSBoXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gYm90dG9tIHRyaWFuZ2xlIHZlcnRzXG4gICAgICAgIHZlcnRzWzNdLnNldChcbiAgICAgICAgICAgIC0wLjI1ICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICAtMC4yNSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgLWgtMVxuICAgICAgICApO1xuICAgICAgICB2ZXJ0c1s0XS5zZXQoXG4gICAgICAgICAgICAwLjc1ICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICAtMC4yNSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgLWgtMVxuICAgICAgICApO1xuICAgICAgICB2ZXJ0c1s1XS5zZXQoXG4gICAgICAgICAgICAtMC4yNSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgMC43NSAgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgIC1oLTFcbiAgICAgICAgKTtcblxuICAgICAgICAvLyB0b3AgdHJpYW5nbGVcbiAgICAgICAgZmFjZXNbMF1bMF0gPSAwO1xuICAgICAgICBmYWNlc1swXVsxXSA9IDE7XG4gICAgICAgIGZhY2VzWzBdWzJdID0gMjtcblxuICAgICAgICAvLyBib3R0b20gdHJpYW5nbGVcbiAgICAgICAgZmFjZXNbMV1bMF0gPSA1O1xuICAgICAgICBmYWNlc1sxXVsxXSA9IDQ7XG4gICAgICAgIGZhY2VzWzFdWzJdID0gMztcblxuICAgICAgICAvLyAteCBmYWNpbmcgcXVhZFxuICAgICAgICBmYWNlc1syXVswXSA9IDA7XG4gICAgICAgIGZhY2VzWzJdWzFdID0gMjtcbiAgICAgICAgZmFjZXNbMl1bMl0gPSA1O1xuICAgICAgICBmYWNlc1syXVszXSA9IDM7XG5cbiAgICAgICAgLy8gLXkgZmFjaW5nIHF1YWRcbiAgICAgICAgZmFjZXNbM11bMF0gPSAxO1xuICAgICAgICBmYWNlc1szXVsxXSA9IDA7XG4gICAgICAgIGZhY2VzWzNdWzJdID0gMztcbiAgICAgICAgZmFjZXNbM11bM10gPSA0O1xuXG4gICAgICAgIC8vICt4eSBmYWNpbmcgcXVhZFxuICAgICAgICBmYWNlc1s0XVswXSA9IDQ7XG4gICAgICAgIGZhY2VzWzRdWzFdID0gNTtcbiAgICAgICAgZmFjZXNbNF1bMl0gPSAyO1xuICAgICAgICBmYWNlc1s0XVszXSA9IDE7XG5cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gQ2VudGVyIG9mIHRoZSB0cmlhbmdsZSBwaWxsYXIgLSBhbGwgcG9seWdvbnMgYXJlIGdpdmVuIHJlbGF0aXZlIHRvIHRoaXMgb25lXG4gICAgICAgIG9mZnNldFJlc3VsdC5zZXQoXG4gICAgICAgICAgICAoeGkgKyAwLjc1KSAqIGVsZW1lbnRTaXplLCAvLyBzb3J0IG9mIGNlbnRlciBvZiBhIHRyaWFuZ2xlXG4gICAgICAgICAgICAoeWkgKyAwLjc1KSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgaCAvLyB2ZXJ0aWNhbCBjZW50ZXJcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBUb3AgdHJpYW5nbGUgdmVydHNcbiAgICAgICAgdmVydHNbMF0uc2V0KFxuICAgICAgICAgICAgMC4yNSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgMC4yNSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgZGF0YVt4aSArIDFdW3lpICsgMV0gLSBoXG4gICAgICAgICk7XG4gICAgICAgIHZlcnRzWzFdLnNldChcbiAgICAgICAgICAgIC0wLjc1ICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICAwLjI1ICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICBkYXRhW3hpXVt5aSArIDFdIC0gaFxuICAgICAgICApO1xuICAgICAgICB2ZXJ0c1syXS5zZXQoXG4gICAgICAgICAgICAwLjI1ICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICAtMC43NSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgZGF0YVt4aSArIDFdW3lpXSAtIGhcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBib3R0b20gdHJpYW5nbGUgdmVydHNcbiAgICAgICAgdmVydHNbM10uc2V0KFxuICAgICAgICAgICAgMC4yNSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgMC4yNSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgLSBoLTFcbiAgICAgICAgKTtcbiAgICAgICAgdmVydHNbNF0uc2V0KFxuICAgICAgICAgICAgLTAuNzUgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgIDAuMjUgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgIC0gaC0xXG4gICAgICAgICk7XG4gICAgICAgIHZlcnRzWzVdLnNldChcbiAgICAgICAgICAgIDAuMjUgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgIC0wLjc1ICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICAtIGgtMVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFRvcCB0cmlhbmdsZVxuICAgICAgICBmYWNlc1swXVswXSA9IDA7XG4gICAgICAgIGZhY2VzWzBdWzFdID0gMTtcbiAgICAgICAgZmFjZXNbMF1bMl0gPSAyO1xuXG4gICAgICAgIC8vIGJvdHRvbSB0cmlhbmdsZVxuICAgICAgICBmYWNlc1sxXVswXSA9IDU7XG4gICAgICAgIGZhY2VzWzFdWzFdID0gNDtcbiAgICAgICAgZmFjZXNbMV1bMl0gPSAzO1xuXG4gICAgICAgIC8vICt4IGZhY2luZyBxdWFkXG4gICAgICAgIGZhY2VzWzJdWzBdID0gMjtcbiAgICAgICAgZmFjZXNbMl1bMV0gPSA1O1xuICAgICAgICBmYWNlc1syXVsyXSA9IDM7XG4gICAgICAgIGZhY2VzWzJdWzNdID0gMDtcblxuICAgICAgICAvLyAreSBmYWNpbmcgcXVhZFxuICAgICAgICBmYWNlc1szXVswXSA9IDM7XG4gICAgICAgIGZhY2VzWzNdWzFdID0gNDtcbiAgICAgICAgZmFjZXNbM11bMl0gPSAxO1xuICAgICAgICBmYWNlc1szXVszXSA9IDA7XG5cbiAgICAgICAgLy8gLXh5IGZhY2luZyBxdWFkXG4gICAgICAgIGZhY2VzWzRdWzBdID0gMTtcbiAgICAgICAgZmFjZXNbNF1bMV0gPSA0O1xuICAgICAgICBmYWNlc1s0XVsyXSA9IDU7XG4gICAgICAgIGZhY2VzWzRdWzNdID0gMjtcbiAgICB9XG5cbiAgICByZXN1bHQuY29tcHV0ZU5vcm1hbHMoKTtcbiAgICByZXN1bHQuY29tcHV0ZUVkZ2VzKCk7XG4gICAgcmVzdWx0LnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCk7XG5cbiAgICB0aGlzLnNldENhY2hlZENvbnZleFRyaWFuZ2xlUGlsbGFyKHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSwgcmVzdWx0LCBvZmZzZXRSZXN1bHQpO1xufTtcblxuSGVpZ2h0ZmllbGQucHJvdG90eXBlLmNhbGN1bGF0ZUxvY2FsSW5lcnRpYSA9IGZ1bmN0aW9uKG1hc3MsIHRhcmdldCl7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBWZWMzKCk7XG4gICAgdGFyZ2V0LnNldCgwLCAwLCAwKTtcbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcblxuSGVpZ2h0ZmllbGQucHJvdG90eXBlLnZvbHVtZSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7IC8vIFRoZSB0ZXJyYWluIGlzIGluZmluaXRlXG59O1xuXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUuY2FsY3VsYXRlV29ybGRBQUJCID0gZnVuY3Rpb24ocG9zLCBxdWF0LCBtaW4sIG1heCl7XG4gICAgLy8gVE9ETzogZG8gaXQgcHJvcGVybHlcbiAgICBtaW4uc2V0KC1OdW1iZXIuTUFYX1ZBTFVFLCAtTnVtYmVyLk1BWF9WQUxVRSwgLU51bWJlci5NQVhfVkFMVUUpO1xuICAgIG1heC5zZXQoTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRSk7XG59O1xuXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMgPSBmdW5jdGlvbigpe1xuICAgIC8vIFVzZSB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBtaW4vbWF4IHZhbHVlc1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhLFxuICAgICAgICBzID0gdGhpcy5lbGVtZW50U2l6ZTtcbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzID0gbmV3IFZlYzMoZGF0YS5sZW5ndGggKiBzLCBkYXRhWzBdLmxlbmd0aCAqIHMsIE1hdGgubWF4KE1hdGguYWJzKHRoaXMubWF4VmFsdWUpLCBNYXRoLmFicyh0aGlzLm1pblZhbHVlKSkpLm5vcm0oKTtcbn07XG5cbn0se1wiLi4vbWF0aC9WZWMzXCI6MzAsXCIuLi91dGlscy9VdGlsc1wiOjUzLFwiLi9Db252ZXhQb2x5aGVkcm9uXCI6MzgsXCIuL1NoYXBlXCI6NDN9XSw0MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IFBhcnRpY2xlO1xuXG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuL1NoYXBlJyk7XG52YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xuXG4vKipcbiAqIFBhcnRpY2xlIHNoYXBlLlxuICogQGNsYXNzIFBhcnRpY2xlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhdXRob3Igc2NodGVwcGVcbiAqIEBleHRlbmRzIFNoYXBlXG4gKi9cbmZ1bmN0aW9uIFBhcnRpY2xlKCl7XG4gICAgU2hhcGUuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMudHlwZSA9IFNoYXBlLnR5cGVzLlBBUlRJQ0xFO1xufVxuUGFydGljbGUucHJvdG90eXBlID0gbmV3IFNoYXBlKCk7XG5QYXJ0aWNsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQYXJ0aWNsZTtcblxuLyoqXG4gKiBAbWV0aG9kIGNhbGN1bGF0ZUxvY2FsSW5lcnRpYVxuICogQHBhcmFtICB7TnVtYmVyfSBtYXNzXG4gKiBAcGFyYW0gIHtWZWMzfSB0YXJnZXRcbiAqIEByZXR1cm4ge1ZlYzN9XG4gKi9cblBhcnRpY2xlLnByb3RvdHlwZS5jYWxjdWxhdGVMb2NhbEluZXJ0aWEgPSBmdW5jdGlvbihtYXNzLHRhcmdldCl7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBWZWMzKCk7XG4gICAgdGFyZ2V0LnNldCgwLCAwLCAwKTtcbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcblxuUGFydGljbGUucHJvdG90eXBlLnZvbHVtZSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIDA7XG59O1xuXG5QYXJ0aWNsZS5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMgPSAwO1xufTtcblxuUGFydGljbGUucHJvdG90eXBlLmNhbGN1bGF0ZVdvcmxkQUFCQiA9IGZ1bmN0aW9uKHBvcyxxdWF0LG1pbixtYXgpe1xuICAgIC8vIEdldCBlYWNoIGF4aXMgbWF4XG4gICAgbWluLmNvcHkocG9zKTtcbiAgICBtYXguY29weShwb3MpO1xufTtcblxufSx7XCIuLi9tYXRoL1ZlYzNcIjozMCxcIi4vU2hhcGVcIjo0M31dLDQyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gUGxhbmU7XG5cbnZhciBTaGFwZSA9IF9kZXJlcV8oJy4vU2hhcGUnKTtcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XG5cbi8qKlxuICogQSBwbGFuZSwgZmFjaW5nIGluIHRoZSBaIGRpcmVjdGlvbi4gVGhlIHBsYW5lIGhhcyBpdHMgc3VyZmFjZSBhdCB6PTAgYW5kIGV2ZXJ5dGhpbmcgYmVsb3cgej0wIGlzIGFzc3VtZWQgdG8gYmUgc29saWQgcGxhbmUuIFRvIG1ha2UgdGhlIHBsYW5lIGZhY2UgaW4gc29tZSBvdGhlciBkaXJlY3Rpb24gdGhhbiB6LCB5b3UgbXVzdCBwdXQgaXQgaW5zaWRlIGEgUmlnaWRCb2R5IGFuZCByb3RhdGUgdGhhdCBib2R5LiBTZWUgdGhlIGRlbW9zLlxuICogQGNsYXNzIFBsYW5lXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFNoYXBlXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKi9cbmZ1bmN0aW9uIFBsYW5lKCl7XG4gICAgU2hhcGUuY2FsbCh0aGlzKTtcbiAgICB0aGlzLnR5cGUgPSBTaGFwZS50eXBlcy5QTEFORTtcblxuICAgIC8vIFdvcmxkIG9yaWVudGVkIG5vcm1hbFxuICAgIHRoaXMud29ybGROb3JtYWwgPSBuZXcgVmVjMygpO1xuICAgIHRoaXMud29ybGROb3JtYWxOZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzID0gTnVtYmVyLk1BWF9WQUxVRTtcbn1cblBsYW5lLnByb3RvdHlwZSA9IG5ldyBTaGFwZSgpO1xuUGxhbmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGxhbmU7XG5cblBsYW5lLnByb3RvdHlwZS5jb21wdXRlV29ybGROb3JtYWwgPSBmdW5jdGlvbihxdWF0KXtcbiAgICB2YXIgbiA9IHRoaXMud29ybGROb3JtYWw7XG4gICAgbi5zZXQoMCwwLDEpO1xuICAgIHF1YXQudm11bHQobixuKTtcbiAgICB0aGlzLndvcmxkTm9ybWFsTmVlZHNVcGRhdGUgPSBmYWxzZTtcbn07XG5cblBsYW5lLnByb3RvdHlwZS5jYWxjdWxhdGVMb2NhbEluZXJ0aWEgPSBmdW5jdGlvbihtYXNzLHRhcmdldCl7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBWZWMzKCk7XG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG5cblBsYW5lLnByb3RvdHlwZS52b2x1bWUgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFOyAvLyBUaGUgcGxhbmUgaXMgaW5maW5pdGUuLi5cbn07XG5cbnZhciB0ZW1wTm9ybWFsID0gbmV3IFZlYzMoKTtcblBsYW5lLnByb3RvdHlwZS5jYWxjdWxhdGVXb3JsZEFBQkIgPSBmdW5jdGlvbihwb3MsIHF1YXQsIG1pbiwgbWF4KXtcbiAgICAvLyBUaGUgcGxhbmUgQUFCQiBpcyBpbmZpbml0ZSwgZXhjZXB0IGlmIHRoZSBub3JtYWwgaXMgcG9pbnRpbmcgYWxvbmcgYW55IGF4aXNcbiAgICB0ZW1wTm9ybWFsLnNldCgwLDAsMSk7IC8vIERlZmF1bHQgcGxhbmUgbm9ybWFsIGlzIHpcbiAgICBxdWF0LnZtdWx0KHRlbXBOb3JtYWwsdGVtcE5vcm1hbCk7XG4gICAgdmFyIG1heFZhbCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgbWluLnNldCgtbWF4VmFsLCAtbWF4VmFsLCAtbWF4VmFsKTtcbiAgICBtYXguc2V0KG1heFZhbCwgbWF4VmFsLCBtYXhWYWwpO1xuXG4gICAgaWYodGVtcE5vcm1hbC54ID09PSAxKXsgbWF4LnggPSBwb3MueDsgfVxuICAgIGlmKHRlbXBOb3JtYWwueSA9PT0gMSl7IG1heC55ID0gcG9zLnk7IH1cbiAgICBpZih0ZW1wTm9ybWFsLnogPT09IDEpeyBtYXgueiA9IHBvcy56OyB9XG5cbiAgICBpZih0ZW1wTm9ybWFsLnggPT09IC0xKXsgbWluLnggPSBwb3MueDsgfVxuICAgIGlmKHRlbXBOb3JtYWwueSA9PT0gLTEpeyBtaW4ueSA9IHBvcy55OyB9XG4gICAgaWYodGVtcE5vcm1hbC56ID09PSAtMSl7IG1pbi56ID0gcG9zLno7IH1cbn07XG5cblBsYW5lLnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cyA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyA9IE51bWJlci5NQVhfVkFMVUU7XG59O1xufSx7XCIuLi9tYXRoL1ZlYzNcIjozMCxcIi4vU2hhcGVcIjo0M31dLDQzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gU2hhcGU7XG5cbnZhciBTaGFwZSA9IF9kZXJlcV8oJy4vU2hhcGUnKTtcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XG52YXIgUXVhdGVybmlvbiA9IF9kZXJlcV8oJy4uL21hdGgvUXVhdGVybmlvbicpO1xudmFyIE1hdGVyaWFsID0gX2RlcmVxXygnLi4vbWF0ZXJpYWwvTWF0ZXJpYWwnKTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBzaGFwZXNcbiAqIEBjbGFzcyBTaGFwZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAdG9kbyBTaG91bGQgaGF2ZSBhIG1lY2hhbmlzbSBmb3IgY2FjaGluZyBib3VuZGluZyBzcGhlcmUgcmFkaXVzIGluc3RlYWQgb2YgY2FsY3VsYXRpbmcgaXQgZWFjaCB0aW1lXG4gKi9cbmZ1bmN0aW9uIFNoYXBlKCl7XG5cbiAgICAvKipcbiAgICAgKiBJZGVudGlmeWVyIG9mIHRoZSBTaGFwZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaWRcbiAgICAgKi9cbiAgICB0aGlzLmlkID0gU2hhcGUuaWRDb3VudGVyKys7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGlzIHNoYXBlLiBNdXN0IGJlIHNldCB0byBhbiBpbnQgPiAwIGJ5IHN1YmNsYXNzZXMuXG4gICAgICogQHByb3BlcnR5IHR5cGVcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBzZWUgU2hhcGUudHlwZXNcbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxvY2FsIGJvdW5kaW5nIHNwaGVyZSByYWRpdXMgb2YgdGhpcyBzaGFwZS5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gYm91bmRpbmdTcGhlcmVSYWRpdXNcbiAgICAgKi9cbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzID0gMDtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gcHJvZHVjZSBjb250YWN0IGZvcmNlcyB3aGVuIGluIGNvbnRhY3Qgd2l0aCBvdGhlciBib2RpZXMuIE5vdGUgdGhhdCBjb250YWN0cyB3aWxsIGJlIGdlbmVyYXRlZCwgYnV0IHRoZXkgd2lsbCBiZSBkaXNhYmxlZC5cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGNvbGxpc2lvblJlc3BvbnNlXG4gICAgICovXG4gICAgdGhpcy5jb2xsaXNpb25SZXNwb25zZSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge01hdGVyaWFsfSBtYXRlcmlhbFxuICAgICAqL1xuICAgIHRoaXMubWF0ZXJpYWwgPSBudWxsO1xufVxuU2hhcGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2hhcGU7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGJvdW5kaW5nIHNwaGVyZSByYWRpdXMuIFRoZSByZXN1bHQgaXMgc3RvcmVkIGluIHRoZSBwcm9wZXJ0eSAuYm91bmRpbmdTcGhlcmVSYWRpdXNcbiAqIEBtZXRob2QgdXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXNcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuU2hhcGUucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICB0aHJvdyBcImNvbXB1dGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpIG5vdCBpbXBsZW1lbnRlZCBmb3Igc2hhcGUgdHlwZSBcIit0aGlzLnR5cGU7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdm9sdW1lIG9mIHRoaXMgc2hhcGVcbiAqIEBtZXRob2Qgdm9sdW1lXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cblNoYXBlLnByb3RvdHlwZS52b2x1bWUgPSBmdW5jdGlvbigpe1xuICAgIHRocm93IFwidm9sdW1lKCkgbm90IGltcGxlbWVudGVkIGZvciBzaGFwZSB0eXBlIFwiK3RoaXMudHlwZTtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgaW5lcnRpYSBpbiB0aGUgbG9jYWwgZnJhbWUgZm9yIHRoaXMgc2hhcGUuXG4gKiBAbWV0aG9kIGNhbGN1bGF0ZUxvY2FsSW5lcnRpYVxuICogQHJldHVybiB7VmVjM31cbiAqIEBzZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaXN0X29mX21vbWVudHNfb2ZfaW5lcnRpYVxuICovXG5TaGFwZS5wcm90b3R5cGUuY2FsY3VsYXRlTG9jYWxJbmVydGlhID0gZnVuY3Rpb24obWFzcyx0YXJnZXQpe1xuICAgIHRocm93IFwiY2FsY3VsYXRlTG9jYWxJbmVydGlhKCkgbm90IGltcGxlbWVudGVkIGZvciBzaGFwZSB0eXBlIFwiK3RoaXMudHlwZTtcbn07XG5cblNoYXBlLmlkQ291bnRlciA9IDA7XG5cbi8qKlxuICogVGhlIGF2YWlsYWJsZSBzaGFwZSB0eXBlcy5cbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB0eXBlc1xuICogQHR5cGUge09iamVjdH1cbiAqL1xuU2hhcGUudHlwZXMgPSB7XG4gICAgU1BIRVJFOjEsXG4gICAgUExBTkU6MixcbiAgICBCT1g6NCxcbiAgICBDT01QT1VORDo4LFxuICAgIENPTlZFWFBPTFlIRURST046MTYsXG4gICAgSEVJR0hURklFTEQ6MzIsXG4gICAgUEFSVElDTEU6NjQsXG4gICAgQ1lMSU5ERVI6MTI4LFxuICAgIFRSSU1FU0g6MjU2XG59O1xuXG5cbn0se1wiLi4vbWF0ZXJpYWwvTWF0ZXJpYWxcIjoyNSxcIi4uL21hdGgvUXVhdGVybmlvblwiOjI4LFwiLi4vbWF0aC9WZWMzXCI6MzAsXCIuL1NoYXBlXCI6NDN9XSw0NDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IFNwaGVyZTtcblxudmFyIFNoYXBlID0gX2RlcmVxXygnLi9TaGFwZScpO1xudmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcblxuLyoqXG4gKiBTcGhlcmljYWwgc2hhcGVcbiAqIEBjbGFzcyBTcGhlcmVcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgU2hhcGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXMgVGhlIHJhZGl1cyBvZiB0aGUgc3BoZXJlLCBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuXG4gKiBAYXV0aG9yIHNjaHRlcHBlIC8gaHR0cDovL2dpdGh1Yi5jb20vc2NodGVwcGVcbiAqL1xuZnVuY3Rpb24gU3BoZXJlKHJhZGl1cyl7XG4gICAgU2hhcGUuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSByYWRpdXNcbiAgICAgKi9cbiAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cyE9PXVuZGVmaW5lZCA/IE51bWJlcihyYWRpdXMpIDogMS4wO1xuICAgIHRoaXMudHlwZSA9IFNoYXBlLnR5cGVzLlNQSEVSRTtcblxuICAgIGlmKHRoaXMucmFkaXVzIDwgMCl7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHNwaGVyZSByYWRpdXMgY2Fubm90IGJlIG5lZ2F0aXZlLicpO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKTtcbn1cblNwaGVyZS5wcm90b3R5cGUgPSBuZXcgU2hhcGUoKTtcblNwaGVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTcGhlcmU7XG5cblNwaGVyZS5wcm90b3R5cGUuY2FsY3VsYXRlTG9jYWxJbmVydGlhID0gZnVuY3Rpb24obWFzcyx0YXJnZXQpe1xuICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgVmVjMygpO1xuICAgIHZhciBJID0gMi4wKm1hc3MqdGhpcy5yYWRpdXMqdGhpcy5yYWRpdXMvNS4wO1xuICAgIHRhcmdldC54ID0gSTtcbiAgICB0YXJnZXQueSA9IEk7XG4gICAgdGFyZ2V0LnogPSBJO1xuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG5TcGhlcmUucHJvdG90eXBlLnZvbHVtZSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIDQuMCAqIE1hdGguUEkgKiB0aGlzLnJhZGl1cyAvIDMuMDtcbn07XG5cblNwaGVyZS5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMgPSB0aGlzLnJhZGl1cztcbn07XG5cblNwaGVyZS5wcm90b3R5cGUuY2FsY3VsYXRlV29ybGRBQUJCID0gZnVuY3Rpb24ocG9zLHF1YXQsbWluLG1heCl7XG4gICAgdmFyIHIgPSB0aGlzLnJhZGl1cztcbiAgICB2YXIgYXhlcyA9IFsneCcsJ3knLCd6J107XG4gICAgZm9yKHZhciBpPTA7IGk8YXhlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBheCA9IGF4ZXNbaV07XG4gICAgICAgIG1pbltheF0gPSBwb3NbYXhdIC0gcjtcbiAgICAgICAgbWF4W2F4XSA9IHBvc1theF0gKyByO1xuICAgIH1cbn07XG5cbn0se1wiLi4vbWF0aC9WZWMzXCI6MzAsXCIuL1NoYXBlXCI6NDN9XSw0NTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IFRyaW1lc2g7XG5cbnZhciBTaGFwZSA9IF9kZXJlcV8oJy4vU2hhcGUnKTtcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XG52YXIgUXVhdGVybmlvbiA9IF9kZXJlcV8oJy4uL21hdGgvUXVhdGVybmlvbicpO1xudmFyIFRyYW5zZm9ybSA9IF9kZXJlcV8oJy4uL21hdGgvVHJhbnNmb3JtJyk7XG52YXIgQUFCQiA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9BQUJCJyk7XG52YXIgT2N0cmVlID0gX2RlcmVxXygnLi4vdXRpbHMvT2N0cmVlJyk7XG5cbi8qKlxuICogQGNsYXNzIFRyaW1lc2hcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHthcnJheX0gdmVydGljZXNcbiAqIEBwYXJhbSB7YXJyYXl9IGluZGljZXNcbiAqIEBleHRlbmRzIFNoYXBlXG4gKiBAZXhhbXBsZVxuICogICAgIC8vIEhvdyB0byBtYWtlIGEgbWVzaCB3aXRoIGEgc2luZ2xlIHRyaWFuZ2xlXG4gKiAgICAgdmFyIHZlcnRpY2VzID0gW1xuICogICAgICAgICAwLCAwLCAwLCAvLyB2ZXJ0ZXggMFxuICogICAgICAgICAxLCAwLCAwLCAvLyB2ZXJ0ZXggMVxuICogICAgICAgICAwLCAxLCAwICAvLyB2ZXJ0ZXggMlxuICogICAgIF07XG4gKiAgICAgdmFyIGluZGljZXMgPSBbXG4gKiAgICAgICAgIDAsIDEsIDIgIC8vIHRyaWFuZ2xlIDBcbiAqICAgICBdO1xuICogICAgIHZhciB0cmltZXNoU2hhcGUgPSBuZXcgVHJpbWVzaCh2ZXJ0aWNlcywgaW5kaWNlcyk7XG4gKi9cbmZ1bmN0aW9uIFRyaW1lc2godmVydGljZXMsIGluZGljZXMpIHtcbiAgICBTaGFwZS5jYWxsKHRoaXMpO1xuICAgIHRoaXMudHlwZSA9IFNoYXBlLnR5cGVzLlRSSU1FU0g7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgdmVydGljZXNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy52ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkodmVydGljZXMpO1xuXG4gICAgLyoqXG4gICAgICogQXJyYXkgb2YgaW50ZWdlcnMsIGluZGljYXRpbmcgd2hpY2ggdmVydGljZXMgZWFjaCB0cmlhbmdsZSBjb25zaXN0cyBvZi4gVGhlIGxlbmd0aCBvZiB0aGlzIGFycmF5IGlzIHRodXMgMyB0aW1lcyB0aGUgbnVtYmVyIG9mIHRyaWFuZ2xlcy5cbiAgICAgKiBAcHJvcGVydHkgaW5kaWNlc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmluZGljZXMgPSBuZXcgSW50MTZBcnJheShpbmRpY2VzKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBub3JtYWxzIGRhdGEuXG4gICAgICogQHByb3BlcnR5IG5vcm1hbHNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5ub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheShpbmRpY2VzLmxlbmd0aCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbG9jYWwgQUFCQiBvZiB0aGUgbWVzaC5cbiAgICAgKiBAcHJvcGVydHkgYWFiYlxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmFhYmIgPSBuZXcgQUFCQigpO1xuXG4gICAgLyoqXG4gICAgICogUmVmZXJlbmNlcyB0byB2ZXJ0ZXggcGFpcnMsIG1ha2luZyB1cCBhbGwgdW5pcXVlIGVkZ2VzIGluIHRoZSB0cmltZXNoLlxuICAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9IGVkZ2VzXG4gICAgICovXG4gICAgdGhpcy5lZGdlcyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBMb2NhbCBzY2FsaW5nIG9mIHRoZSBtZXNoLiBVc2UgLnNldFNjYWxlKCkgdG8gc2V0IGl0LlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gc2NhbGVcbiAgICAgKi9cbiAgICB0aGlzLnNjYWxlID0gbmV3IFZlYzMoMSwgMSwgMSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5kZXhlZCB0cmlhbmdsZXMuIFVzZSAudXBkYXRlVHJlZSgpIHRvIHVwZGF0ZSBpdC5cbiAgICAgKiBAcHJvcGVydHkge09jdHJlZX0gdHJlZVxuICAgICAqL1xuICAgIHRoaXMudHJlZSA9IG5ldyBPY3RyZWUoKTtcblxuICAgIHRoaXMudXBkYXRlRWRnZXMoKTtcbiAgICB0aGlzLnVwZGF0ZU5vcm1hbHMoKTtcbiAgICB0aGlzLnVwZGF0ZUFBQkIoKTtcbiAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCk7XG4gICAgdGhpcy51cGRhdGVUcmVlKCk7XG59XG5UcmltZXNoLnByb3RvdHlwZSA9IG5ldyBTaGFwZSgpO1xuVHJpbWVzaC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUcmltZXNoO1xuXG52YXIgY29tcHV0ZU5vcm1hbHNfbiA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogQG1ldGhvZCB1cGRhdGVUcmVlXG4gKi9cblRyaW1lc2gucHJvdG90eXBlLnVwZGF0ZVRyZWUgPSBmdW5jdGlvbigpe1xuICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuXG4gICAgdHJlZS5yZXNldCgpO1xuICAgIHRyZWUuYWFiYi5jb3B5KHRoaXMuYWFiYik7XG4gICAgdmFyIHNjYWxlID0gdGhpcy5zY2FsZTsgLy8gVGhlIGxvY2FsIG1lc2ggQUFCQiBpcyBzY2FsZWQsIGJ1dCB0aGUgb2N0cmVlIEFBQkIgc2hvdWxkIGJlIHVuc2NhbGVkXG4gICAgdHJlZS5hYWJiLmxvd2VyQm91bmQueCAqPSAxIC8gc2NhbGUueDtcbiAgICB0cmVlLmFhYmIubG93ZXJCb3VuZC55ICo9IDEgLyBzY2FsZS55O1xuICAgIHRyZWUuYWFiYi5sb3dlckJvdW5kLnogKj0gMSAvIHNjYWxlLno7XG4gICAgdHJlZS5hYWJiLnVwcGVyQm91bmQueCAqPSAxIC8gc2NhbGUueDtcbiAgICB0cmVlLmFhYmIudXBwZXJCb3VuZC55ICo9IDEgLyBzY2FsZS55O1xuICAgIHRyZWUuYWFiYi51cHBlckJvdW5kLnogKj0gMSAvIHNjYWxlLno7XG5cbiAgICAvLyBJbnNlcnQgYWxsIHRyaWFuZ2xlc1xuICAgIHZhciB0cmlhbmdsZUFBQkIgPSBuZXcgQUFCQigpO1xuICAgIHZhciBhID0gbmV3IFZlYzMoKTtcbiAgICB2YXIgYiA9IG5ldyBWZWMzKCk7XG4gICAgdmFyIGMgPSBuZXcgVmVjMygpO1xuICAgIHZhciBwb2ludHMgPSBbYSwgYiwgY107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluZGljZXMubGVuZ3RoIC8gMzsgaSsrKSB7XG4gICAgICAgIC8vdGhpcy5nZXRUcmlhbmdsZVZlcnRpY2VzKGksIGEsIGIsIGMpO1xuXG4gICAgICAgIC8vIEdldCB1bnNjYWxlZCB0cmlhbmdsZSB2ZXJ0c1xuICAgICAgICB2YXIgaTMgPSBpICogMztcbiAgICAgICAgdGhpcy5fZ2V0VW5zY2FsZWRWZXJ0ZXgodGhpcy5pbmRpY2VzW2kzXSwgYSk7XG4gICAgICAgIHRoaXMuX2dldFVuc2NhbGVkVmVydGV4KHRoaXMuaW5kaWNlc1tpMyArIDFdLCBiKTtcbiAgICAgICAgdGhpcy5fZ2V0VW5zY2FsZWRWZXJ0ZXgodGhpcy5pbmRpY2VzW2kzICsgMl0sIGMpO1xuXG4gICAgICAgIHRyaWFuZ2xlQUFCQi5zZXRGcm9tUG9pbnRzKHBvaW50cyk7XG4gICAgICAgIHRyZWUuaW5zZXJ0KHRyaWFuZ2xlQUFCQiwgaSk7XG4gICAgfVxuICAgIHRyZWUucmVtb3ZlRW1wdHlOb2RlcygpO1xufTtcblxudmFyIHVuc2NhbGVkQUFCQiA9IG5ldyBBQUJCKCk7XG5cbi8qKlxuICogR2V0IHRyaWFuZ2xlcyBpbiBhIGxvY2FsIEFBQkIgZnJvbSB0aGUgdHJpbWVzaC5cbiAqIEBtZXRob2QgZ2V0VHJpYW5nbGVzSW5BQUJCXG4gKiBAcGFyYW0gIHtBQUJCfSBhYWJiXG4gKiBAcGFyYW0gIHthcnJheX0gcmVzdWx0IEFuIGFycmF5IG9mIGludGVnZXJzLCByZWZlcmVuY2luZyB0aGUgcXVlcmllZCB0cmlhbmdsZXMuXG4gKi9cblRyaW1lc2gucHJvdG90eXBlLmdldFRyaWFuZ2xlc0luQUFCQiA9IGZ1bmN0aW9uKGFhYmIsIHJlc3VsdCl7XG4gICAgdW5zY2FsZWRBQUJCLmNvcHkoYWFiYik7XG5cbiAgICAvLyBTY2FsZSBpdCB0byBsb2NhbFxuICAgIHZhciBzY2FsZSA9IHRoaXMuc2NhbGU7XG4gICAgdmFyIGlzeCA9IHNjYWxlLng7XG4gICAgdmFyIGlzeSA9IHNjYWxlLnk7XG4gICAgdmFyIGlzeiA9IHNjYWxlLno7XG4gICAgdmFyIGwgPSB1bnNjYWxlZEFBQkIubG93ZXJCb3VuZDtcbiAgICB2YXIgdSA9IHVuc2NhbGVkQUFCQi51cHBlckJvdW5kO1xuICAgIGwueCAvPSBpc3g7XG4gICAgbC55IC89IGlzeTtcbiAgICBsLnogLz0gaXN6O1xuICAgIHUueCAvPSBpc3g7XG4gICAgdS55IC89IGlzeTtcbiAgICB1LnogLz0gaXN6O1xuXG4gICAgcmV0dXJuIHRoaXMudHJlZS5hYWJiUXVlcnkodW5zY2FsZWRBQUJCLCByZXN1bHQpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHNldFNjYWxlXG4gKiBAcGFyYW0ge1ZlYzN9IHNjYWxlXG4gKi9cblRyaW1lc2gucHJvdG90eXBlLnNldFNjYWxlID0gZnVuY3Rpb24oc2NhbGUpe1xuICAgIHZhciB3YXNVbmlmb3JtID0gdGhpcy5zY2FsZS54ID09PSB0aGlzLnNjYWxlLnkgPT09IHRoaXMuc2NhbGUuejtcbiAgICB2YXIgaXNVbmlmb3JtID0gc2NhbGUueCA9PT0gc2NhbGUueSA9PT0gc2NhbGUuejtcblxuICAgIGlmKCEod2FzVW5pZm9ybSAmJiBpc1VuaWZvcm0pKXtcbiAgICAgICAgLy8gTm9uLXVuaWZvcm0gc2NhbGluZy4gTmVlZCB0byB1cGRhdGUgbm9ybWFscy5cbiAgICAgICAgdGhpcy51cGRhdGVOb3JtYWxzKCk7XG4gICAgfVxuICAgIHRoaXMuc2NhbGUuY29weShzY2FsZSk7XG4gICAgdGhpcy51cGRhdGVBQUJCKCk7XG4gICAgdGhpcy51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpO1xufTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBub3JtYWxzIG9mIHRoZSBmYWNlcy4gV2lsbCBzYXZlIGluIHRoZSAubm9ybWFscyBhcnJheS5cbiAqIEBtZXRob2QgdXBkYXRlTm9ybWFsc1xuICovXG5UcmltZXNoLnByb3RvdHlwZS51cGRhdGVOb3JtYWxzID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgbiA9IGNvbXB1dGVOb3JtYWxzX247XG5cbiAgICAvLyBHZW5lcmF0ZSBub3JtYWxzXG4gICAgdmFyIG5vcm1hbHMgPSB0aGlzLm5vcm1hbHM7XG4gICAgZm9yKHZhciBpPTA7IGkgPCB0aGlzLmluZGljZXMubGVuZ3RoIC8gMzsgaSsrKXtcbiAgICAgICAgdmFyIGkzID0gaSAqIDM7XG5cbiAgICAgICAgdmFyIGEgPSB0aGlzLmluZGljZXNbaTNdLFxuICAgICAgICAgICAgYiA9IHRoaXMuaW5kaWNlc1tpMyArIDFdLFxuICAgICAgICAgICAgYyA9IHRoaXMuaW5kaWNlc1tpMyArIDJdO1xuXG4gICAgICAgIHRoaXMuZ2V0VmVydGV4KGEsIHZhKTtcbiAgICAgICAgdGhpcy5nZXRWZXJ0ZXgoYiwgdmIpO1xuICAgICAgICB0aGlzLmdldFZlcnRleChjLCB2Yyk7XG5cbiAgICAgICAgVHJpbWVzaC5jb21wdXRlTm9ybWFsKHZiLCB2YSwgdmMsIG4pO1xuXG4gICAgICAgIG5vcm1hbHNbaTNdID0gbi54O1xuICAgICAgICBub3JtYWxzW2kzICsgMV0gPSBuLnk7XG4gICAgICAgIG5vcm1hbHNbaTMgKyAyXSA9IG4uejtcbiAgICB9XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgLmVkZ2VzIHByb3BlcnR5XG4gKiBAbWV0aG9kIHVwZGF0ZUVkZ2VzXG4gKi9cblRyaW1lc2gucHJvdG90eXBlLnVwZGF0ZUVkZ2VzID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZWRnZXMgPSB7fTtcbiAgICB2YXIgYWRkID0gZnVuY3Rpb24oaW5kZXhBLCBpbmRleEIpe1xuICAgICAgICB2YXIga2V5ID0gYSA8IGIgPyBhICsgJ18nICsgYiA6IGIgKyAnXycgKyBhO1xuICAgICAgICBlZGdlc1trZXldID0gdHJ1ZTtcbiAgICB9O1xuICAgIGZvcih2YXIgaT0wOyBpIDwgdGhpcy5pbmRpY2VzLmxlbmd0aCAvIDM7IGkrKyl7XG4gICAgICAgIHZhciBpMyA9IGkgKiAzO1xuICAgICAgICB2YXIgYSA9IHRoaXMuaW5kaWNlc1tpM10sXG4gICAgICAgICAgICBiID0gdGhpcy5pbmRpY2VzW2kzICsgMV0sXG4gICAgICAgICAgICBjID0gdGhpcy5pbmRpY2VzW2kzICsgMl07XG4gICAgICAgIGFkZChhLGIpO1xuICAgICAgICBhZGQoYixjKTtcbiAgICAgICAgYWRkKGMsYSk7XG4gICAgfVxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZWRnZXMpO1xuICAgIHRoaXMuZWRnZXMgPSBuZXcgSW50MTZBcnJheShrZXlzLmxlbmd0aCAqIDIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaW5kaWNlcyA9IGtleXNbaV0uc3BsaXQoJ18nKTtcbiAgICAgICAgdGhpcy5lZGdlc1syICogaV0gPSBwYXJzZUludChpbmRpY2VzWzBdLCAxMCk7XG4gICAgICAgIHRoaXMuZWRnZXNbMiAqIGkgKyAxXSA9IHBhcnNlSW50KGluZGljZXNbMV0sIDEwKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEdldCBhbiBlZGdlIHZlcnRleFxuICogQG1ldGhvZCBnZXRFZGdlVmVydGV4XG4gKiBAcGFyYW0gIHtudW1iZXJ9IGVkZ2VJbmRleFxuICogQHBhcmFtICB7bnVtYmVyfSBmaXJzdE9yU2Vjb25kIDAgb3IgMSwgZGVwZW5kaW5nIG9uIHdoaWNoIG9uZSBvZiB0aGUgdmVydGljZXMgeW91IG5lZWQuXG4gKiBAcGFyYW0gIHtWZWMzfSB2ZXJ0ZXhTdG9yZSBXaGVyZSB0byBzdG9yZSB0aGUgcmVzdWx0XG4gKi9cblRyaW1lc2gucHJvdG90eXBlLmdldEVkZ2VWZXJ0ZXggPSBmdW5jdGlvbihlZGdlSW5kZXgsIGZpcnN0T3JTZWNvbmQsIHZlcnRleFN0b3JlKXtcbiAgICB2YXIgdmVydGV4SW5kZXggPSB0aGlzLmVkZ2VzW2VkZ2VJbmRleCAqIDIgKyAoZmlyc3RPclNlY29uZCA/IDEgOiAwKV07XG4gICAgdGhpcy5nZXRWZXJ0ZXgodmVydGV4SW5kZXgsIHZlcnRleFN0b3JlKTtcbn07XG5cbnZhciBnZXRFZGdlVmVjdG9yX3ZhID0gbmV3IFZlYzMoKTtcbnZhciBnZXRFZGdlVmVjdG9yX3ZiID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBHZXQgYSB2ZWN0b3IgYWxvbmcgYW4gZWRnZS5cbiAqIEBtZXRob2QgZ2V0RWRnZVZlY3RvclxuICogQHBhcmFtICB7bnVtYmVyfSBlZGdlSW5kZXhcbiAqIEBwYXJhbSAge1ZlYzN9IHZlY3RvclN0b3JlXG4gKi9cblRyaW1lc2gucHJvdG90eXBlLmdldEVkZ2VWZWN0b3IgPSBmdW5jdGlvbihlZGdlSW5kZXgsIHZlY3RvclN0b3JlKXtcbiAgICB2YXIgdmEgPSBnZXRFZGdlVmVjdG9yX3ZhO1xuICAgIHZhciB2YiA9IGdldEVkZ2VWZWN0b3JfdmI7XG4gICAgdGhpcy5nZXRFZGdlVmVydGV4KGVkZ2VJbmRleCwgMCwgdmEpO1xuICAgIHRoaXMuZ2V0RWRnZVZlcnRleChlZGdlSW5kZXgsIDEsIHZiKTtcbiAgICB2Yi52c3ViKHZhLCB2ZWN0b3JTdG9yZSk7XG59O1xuXG4vKipcbiAqIEdldCBmYWNlIG5vcm1hbCBnaXZlbiAzIHZlcnRpY2VzXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGNvbXB1dGVOb3JtYWxcbiAqIEBwYXJhbSB7VmVjM30gdmFcbiAqIEBwYXJhbSB7VmVjM30gdmJcbiAqIEBwYXJhbSB7VmVjM30gdmNcbiAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0XG4gKi9cbnZhciBjYiA9IG5ldyBWZWMzKCk7XG52YXIgYWIgPSBuZXcgVmVjMygpO1xuVHJpbWVzaC5jb21wdXRlTm9ybWFsID0gZnVuY3Rpb24gKCB2YSwgdmIsIHZjLCB0YXJnZXQgKSB7XG4gICAgdmIudnN1Yih2YSxhYik7XG4gICAgdmMudnN1Yih2YixjYik7XG4gICAgY2IuY3Jvc3MoYWIsdGFyZ2V0KTtcbiAgICBpZiAoICF0YXJnZXQuaXNaZXJvKCkgKSB7XG4gICAgICAgIHRhcmdldC5ub3JtYWxpemUoKTtcbiAgICB9XG59O1xuXG52YXIgdmEgPSBuZXcgVmVjMygpO1xudmFyIHZiID0gbmV3IFZlYzMoKTtcbnZhciB2YyA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogR2V0IHZlcnRleCBpLlxuICogQG1ldGhvZCBnZXRWZXJ0ZXhcbiAqIEBwYXJhbSAge251bWJlcn0gaVxuICogQHBhcmFtICB7VmVjM30gb3V0XG4gKiBAcmV0dXJuIHtWZWMzfSBUaGUgXCJvdXRcIiB2ZWN0b3Igb2JqZWN0XG4gKi9cblRyaW1lc2gucHJvdG90eXBlLmdldFZlcnRleCA9IGZ1bmN0aW9uKGksIG91dCl7XG4gICAgdmFyIHNjYWxlID0gdGhpcy5zY2FsZTtcbiAgICB0aGlzLl9nZXRVbnNjYWxlZFZlcnRleChpLCBvdXQpO1xuICAgIG91dC54ICo9IHNjYWxlLng7XG4gICAgb3V0LnkgKj0gc2NhbGUueTtcbiAgICBvdXQueiAqPSBzY2FsZS56O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdldCByYXcgdmVydGV4IGlcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIF9nZXRVbnNjYWxlZFZlcnRleFxuICogQHBhcmFtICB7bnVtYmVyfSBpXG4gKiBAcGFyYW0gIHtWZWMzfSBvdXRcbiAqIEByZXR1cm4ge1ZlYzN9IFRoZSBcIm91dFwiIHZlY3RvciBvYmplY3RcbiAqL1xuVHJpbWVzaC5wcm90b3R5cGUuX2dldFVuc2NhbGVkVmVydGV4ID0gZnVuY3Rpb24oaSwgb3V0KXtcbiAgICB2YXIgaTMgPSBpICogMztcbiAgICB2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xuICAgIHJldHVybiBvdXQuc2V0KFxuICAgICAgICB2ZXJ0aWNlc1tpM10sXG4gICAgICAgIHZlcnRpY2VzW2kzICsgMV0sXG4gICAgICAgIHZlcnRpY2VzW2kzICsgMl1cbiAgICApO1xufTtcblxuLyoqXG4gKiBHZXQgYSB2ZXJ0ZXggZnJvbSB0aGUgdHJpbWVzaCx0cmFuc2Zvcm1lZCBieSB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIHF1YXRlcm5pb24uXG4gKiBAbWV0aG9kIGdldFdvcmxkVmVydGV4XG4gKiBAcGFyYW0gIHtudW1iZXJ9IGlcbiAqIEBwYXJhbSAge1ZlYzN9IHBvc1xuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcXVhdFxuICogQHBhcmFtICB7VmVjM30gb3V0XG4gKiBAcmV0dXJuIHtWZWMzfSBUaGUgXCJvdXRcIiB2ZWN0b3Igb2JqZWN0XG4gKi9cblRyaW1lc2gucHJvdG90eXBlLmdldFdvcmxkVmVydGV4ID0gZnVuY3Rpb24oaSwgcG9zLCBxdWF0LCBvdXQpe1xuICAgIHRoaXMuZ2V0VmVydGV4KGksIG91dCk7XG4gICAgVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKHBvcywgcXVhdCwgb3V0LCBvdXQpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdGhyZWUgdmVydGljZXMgZm9yIHRyaWFuZ2xlIGkuXG4gKiBAbWV0aG9kIGdldFRyaWFuZ2xlVmVydGljZXNcbiAqIEBwYXJhbSAge251bWJlcn0gaVxuICogQHBhcmFtICB7VmVjM30gYVxuICogQHBhcmFtICB7VmVjM30gYlxuICogQHBhcmFtICB7VmVjM30gY1xuICovXG5UcmltZXNoLnByb3RvdHlwZS5nZXRUcmlhbmdsZVZlcnRpY2VzID0gZnVuY3Rpb24oaSwgYSwgYiwgYyl7XG4gICAgdmFyIGkzID0gaSAqIDM7XG4gICAgdGhpcy5nZXRWZXJ0ZXgodGhpcy5pbmRpY2VzW2kzXSwgYSk7XG4gICAgdGhpcy5nZXRWZXJ0ZXgodGhpcy5pbmRpY2VzW2kzICsgMV0sIGIpO1xuICAgIHRoaXMuZ2V0VmVydGV4KHRoaXMuaW5kaWNlc1tpMyArIDJdLCBjKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgbm9ybWFsIG9mIHRyaWFuZ2xlIGkuXG4gKiBAbWV0aG9kIGdldE5vcm1hbFxuICogQHBhcmFtICB7TnVtYmVyfSBpXG4gKiBAcGFyYW0gIHtWZWMzfSB0YXJnZXRcbiAqIEByZXR1cm4ge1ZlYzN9IFRoZSBcInRhcmdldFwiIHZlY3RvciBvYmplY3RcbiAqL1xuVHJpbWVzaC5wcm90b3R5cGUuZ2V0Tm9ybWFsID0gZnVuY3Rpb24oaSwgdGFyZ2V0KXtcbiAgICB2YXIgaTMgPSBpICogMztcbiAgICByZXR1cm4gdGFyZ2V0LnNldChcbiAgICAgICAgdGhpcy5ub3JtYWxzW2kzXSxcbiAgICAgICAgdGhpcy5ub3JtYWxzW2kzICsgMV0sXG4gICAgICAgIHRoaXMubm9ybWFsc1tpMyArIDJdXG4gICAgKTtcbn07XG5cbnZhciBjbGlfYWFiYiA9IG5ldyBBQUJCKCk7XG5cbi8qKlxuICogQG1ldGhvZCBjYWxjdWxhdGVMb2NhbEluZXJ0aWFcbiAqIEBwYXJhbSAge051bWJlcn0gbWFzc1xuICogQHBhcmFtICB7VmVjM30gdGFyZ2V0XG4gKiBAcmV0dXJuIHtWZWMzfSBUaGUgXCJ0YXJnZXRcIiB2ZWN0b3Igb2JqZWN0XG4gKi9cblRyaW1lc2gucHJvdG90eXBlLmNhbGN1bGF0ZUxvY2FsSW5lcnRpYSA9IGZ1bmN0aW9uKG1hc3MsdGFyZ2V0KXtcbiAgICAvLyBBcHByb3hpbWF0ZSB3aXRoIGJveCBpbmVydGlhXG4gICAgLy8gRXhhY3QgaW5lcnRpYSBjYWxjdWxhdGlvbiBpcyBvdmVya2lsbCwgYnV0IHNlZSBodHRwOi8vZ2VvbWV0cmljdG9vbHMuY29tL0RvY3VtZW50YXRpb24vUG9seWhlZHJhbE1hc3NQcm9wZXJ0aWVzLnBkZiBmb3IgdGhlIGNvcnJlY3Qgd2F5IHRvIGRvIGl0XG4gICAgdGhpcy5jb21wdXRlTG9jYWxBQUJCKGNsaV9hYWJiKTtcbiAgICB2YXIgeCA9IGNsaV9hYWJiLnVwcGVyQm91bmQueCAtIGNsaV9hYWJiLmxvd2VyQm91bmQueCxcbiAgICAgICAgeSA9IGNsaV9hYWJiLnVwcGVyQm91bmQueSAtIGNsaV9hYWJiLmxvd2VyQm91bmQueSxcbiAgICAgICAgeiA9IGNsaV9hYWJiLnVwcGVyQm91bmQueiAtIGNsaV9hYWJiLmxvd2VyQm91bmQuejtcbiAgICByZXR1cm4gdGFyZ2V0LnNldChcbiAgICAgICAgMS4wIC8gMTIuMCAqIG1hc3MgKiAoIDIqeSoyKnkgKyAyKnoqMip6ICksXG4gICAgICAgIDEuMCAvIDEyLjAgKiBtYXNzICogKCAyKngqMip4ICsgMip6KjIqeiApLFxuICAgICAgICAxLjAgLyAxMi4wICogbWFzcyAqICggMip5KjIqeSArIDIqeCoyKnggKVxuICAgICk7XG59O1xuXG52YXIgY29tcHV0ZUxvY2FsQUFCQl93b3JsZFZlcnQgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIGxvY2FsIEFBQkIgZm9yIHRoZSB0cmltZXNoXG4gKiBAbWV0aG9kIGNvbXB1dGVMb2NhbEFBQkJcbiAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcbiAqL1xuVHJpbWVzaC5wcm90b3R5cGUuY29tcHV0ZUxvY2FsQUFCQiA9IGZ1bmN0aW9uKGFhYmIpe1xuICAgIHZhciBsID0gYWFiYi5sb3dlckJvdW5kLFxuICAgICAgICB1ID0gYWFiYi51cHBlckJvdW5kLFxuICAgICAgICBuID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGgsXG4gICAgICAgIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcyxcbiAgICAgICAgdiA9IGNvbXB1dGVMb2NhbEFBQkJfd29ybGRWZXJ0O1xuXG4gICAgdGhpcy5nZXRWZXJ0ZXgoMCwgdik7XG4gICAgbC5jb3B5KHYpO1xuICAgIHUuY29weSh2KTtcblxuICAgIGZvcih2YXIgaT0wOyBpICE9PSBuOyBpKyspe1xuICAgICAgICB0aGlzLmdldFZlcnRleChpLCB2KTtcblxuICAgICAgICBpZih2LnggPCBsLngpe1xuICAgICAgICAgICAgbC54ID0gdi54O1xuICAgICAgICB9IGVsc2UgaWYodi54ID4gdS54KXtcbiAgICAgICAgICAgIHUueCA9IHYueDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHYueSA8IGwueSl7XG4gICAgICAgICAgICBsLnkgPSB2Lnk7XG4gICAgICAgIH0gZWxzZSBpZih2LnkgPiB1Lnkpe1xuICAgICAgICAgICAgdS55ID0gdi55O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodi56IDwgbC56KXtcbiAgICAgICAgICAgIGwueiA9IHYuejtcbiAgICAgICAgfSBlbHNlIGlmKHYueiA+IHUueil7XG4gICAgICAgICAgICB1LnogPSB2Lno7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbi8qKlxuICogVXBkYXRlIHRoZSAuYWFiYiBwcm9wZXJ0eVxuICogQG1ldGhvZCB1cGRhdGVBQUJCXG4gKi9cblRyaW1lc2gucHJvdG90eXBlLnVwZGF0ZUFBQkIgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuY29tcHV0ZUxvY2FsQUFCQih0aGlzLmFhYmIpO1xufTtcblxuLyoqXG4gKiBXaWxsIHVwZGF0ZSB0aGUgLmJvdW5kaW5nU3BoZXJlUmFkaXVzIHByb3BlcnR5XG4gKiBAbWV0aG9kIHVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzXG4gKi9cblRyaW1lc2gucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICAvLyBBc3N1bWUgcG9pbnRzIGFyZSBkaXN0cmlidXRlZCB3aXRoIGxvY2FsICgwLDAsMCkgYXMgY2VudGVyXG4gICAgdmFyIG1heDIgPSAwO1xuICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XG4gICAgdmFyIHYgPSBuZXcgVmVjMygpO1xuICAgIGZvcih2YXIgaT0wLCBOPXZlcnRpY2VzLmxlbmd0aCAvIDM7IGkgIT09IE47IGkrKykge1xuICAgICAgICB0aGlzLmdldFZlcnRleChpLCB2KTtcbiAgICAgICAgdmFyIG5vcm0yID0gdi5ub3JtMigpO1xuICAgICAgICBpZihub3JtMiA+IG1heDIpe1xuICAgICAgICAgICAgbWF4MiA9IG5vcm0yO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMgPSBNYXRoLnNxcnQobWF4Mik7XG59O1xuXG52YXIgdGVtcFdvcmxkVmVydGV4ID0gbmV3IFZlYzMoKTtcbnZhciBjYWxjdWxhdGVXb3JsZEFBQkJfZnJhbWUgPSBuZXcgVHJhbnNmb3JtKCk7XG52YXIgY2FsY3VsYXRlV29ybGRBQUJCX2FhYmIgPSBuZXcgQUFCQigpO1xuXG4vKipcbiAqIEBtZXRob2QgY2FsY3VsYXRlV29ybGRBQUJCXG4gKiBAcGFyYW0ge1ZlYzN9ICAgICAgICBwb3NcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gIHF1YXRcbiAqIEBwYXJhbSB7VmVjM30gICAgICAgIG1pblxuICogQHBhcmFtIHtWZWMzfSAgICAgICAgbWF4XG4gKi9cblRyaW1lc2gucHJvdG90eXBlLmNhbGN1bGF0ZVdvcmxkQUFCQiA9IGZ1bmN0aW9uKHBvcyxxdWF0LG1pbixtYXgpe1xuICAgIC8qXG4gICAgdmFyIG4gPSB0aGlzLnZlcnRpY2VzLmxlbmd0aCAvIDMsXG4gICAgICAgIHZlcnRzID0gdGhpcy52ZXJ0aWNlcztcbiAgICB2YXIgbWlueCxtaW55LG1pbnosbWF4eCxtYXh5LG1heHo7XG5cbiAgICB2YXIgdiA9IHRlbXBXb3JsZFZlcnRleDtcbiAgICBmb3IodmFyIGk9MDsgaTxuOyBpKyspe1xuICAgICAgICB0aGlzLmdldFZlcnRleChpLCB2KTtcbiAgICAgICAgcXVhdC52bXVsdCh2LCB2KTtcbiAgICAgICAgcG9zLnZhZGQodiwgdik7XG4gICAgICAgIGlmICh2LnggPCBtaW54IHx8IG1pbng9PT11bmRlZmluZWQpe1xuICAgICAgICAgICAgbWlueCA9IHYueDtcbiAgICAgICAgfSBlbHNlIGlmKHYueCA+IG1heHggfHwgbWF4eD09PXVuZGVmaW5lZCl7XG4gICAgICAgICAgICBtYXh4ID0gdi54O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHYueSA8IG1pbnkgfHwgbWlueT09PXVuZGVmaW5lZCl7XG4gICAgICAgICAgICBtaW55ID0gdi55O1xuICAgICAgICB9IGVsc2UgaWYodi55ID4gbWF4eSB8fCBtYXh5PT09dW5kZWZpbmVkKXtcbiAgICAgICAgICAgIG1heHkgPSB2Lnk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodi56IDwgbWlueiB8fCBtaW56PT09dW5kZWZpbmVkKXtcbiAgICAgICAgICAgIG1pbnogPSB2Lno7XG4gICAgICAgIH0gZWxzZSBpZih2LnogPiBtYXh6IHx8IG1heHo9PT11bmRlZmluZWQpe1xuICAgICAgICAgICAgbWF4eiA9IHYuejtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtaW4uc2V0KG1pbngsbWlueSxtaW56KTtcbiAgICBtYXguc2V0KG1heHgsbWF4eSxtYXh6KTtcbiAgICAqL1xuXG4gICAgLy8gRmFzdGVyIGFwcHJveGltYXRpb24gdXNpbmcgbG9jYWwgQUFCQlxuICAgIHZhciBmcmFtZSA9IGNhbGN1bGF0ZVdvcmxkQUFCQl9mcmFtZTtcbiAgICB2YXIgcmVzdWx0ID0gY2FsY3VsYXRlV29ybGRBQUJCX2FhYmI7XG4gICAgZnJhbWUucG9zaXRpb24gPSBwb3M7XG4gICAgZnJhbWUucXVhdGVybmlvbiA9IHF1YXQ7XG4gICAgdGhpcy5hYWJiLnRvV29ybGRGcmFtZShmcmFtZSwgcmVzdWx0KTtcbiAgICBtaW4uY29weShyZXN1bHQubG93ZXJCb3VuZCk7XG4gICAgbWF4LmNvcHkocmVzdWx0LnVwcGVyQm91bmQpO1xufTtcblxuLyoqXG4gKiBHZXQgYXBwcm94aW1hdGUgdm9sdW1lXG4gKiBAbWV0aG9kIHZvbHVtZVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5UcmltZXNoLnByb3RvdHlwZS52b2x1bWUgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiA0LjAgKiBNYXRoLlBJICogdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyAvIDMuMDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgVHJpbWVzaCBpbnN0YW5jZSwgc2hhcGVkIGFzIGEgdG9ydXMuXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGNyZWF0ZVRvcnVzXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtyYWRpdXM9MV1cbiAqIEBwYXJhbSAge251bWJlcn0gW3R1YmU9MC41XVxuICogQHBhcmFtICB7bnVtYmVyfSBbcmFkaWFsU2VnbWVudHM9OF1cbiAqIEBwYXJhbSAge251bWJlcn0gW3R1YnVsYXJTZWdtZW50cz02XVxuICogQHBhcmFtICB7bnVtYmVyfSBbYXJjPTYuMjgzMTg1MzA3MTc5NTg2XVxuICogQHJldHVybiB7VHJpbWVzaH0gQSB0b3J1c1xuICovXG5UcmltZXNoLmNyZWF0ZVRvcnVzID0gZnVuY3Rpb24gKHJhZGl1cywgdHViZSwgcmFkaWFsU2VnbWVudHMsIHR1YnVsYXJTZWdtZW50cywgYXJjKSB7XG4gICAgcmFkaXVzID0gcmFkaXVzIHx8IDE7XG4gICAgdHViZSA9IHR1YmUgfHwgMC41O1xuICAgIHJhZGlhbFNlZ21lbnRzID0gcmFkaWFsU2VnbWVudHMgfHwgODtcbiAgICB0dWJ1bGFyU2VnbWVudHMgPSB0dWJ1bGFyU2VnbWVudHMgfHwgNjtcbiAgICBhcmMgPSBhcmMgfHwgTWF0aC5QSSAqIDI7XG5cbiAgICB2YXIgdmVydGljZXMgPSBbXTtcbiAgICB2YXIgaW5kaWNlcyA9IFtdO1xuXG4gICAgZm9yICggdmFyIGogPSAwOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyBqICsrICkge1xuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPD0gdHVidWxhclNlZ21lbnRzOyBpICsrICkge1xuICAgICAgICAgICAgdmFyIHUgPSBpIC8gdHVidWxhclNlZ21lbnRzICogYXJjO1xuICAgICAgICAgICAgdmFyIHYgPSBqIC8gcmFkaWFsU2VnbWVudHMgKiBNYXRoLlBJICogMjtcblxuICAgICAgICAgICAgdmFyIHggPSAoIHJhZGl1cyArIHR1YmUgKiBNYXRoLmNvcyggdiApICkgKiBNYXRoLmNvcyggdSApO1xuICAgICAgICAgICAgdmFyIHkgPSAoIHJhZGl1cyArIHR1YmUgKiBNYXRoLmNvcyggdiApICkgKiBNYXRoLnNpbiggdSApO1xuICAgICAgICAgICAgdmFyIHogPSB0dWJlICogTWF0aC5zaW4oIHYgKTtcblxuICAgICAgICAgICAgdmVydGljZXMucHVzaCggeCwgeSwgeiApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yICggdmFyIGogPSAxOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyBqICsrICkge1xuICAgICAgICBmb3IgKCB2YXIgaSA9IDE7IGkgPD0gdHVidWxhclNlZ21lbnRzOyBpICsrICkge1xuICAgICAgICAgICAgdmFyIGEgPSAoIHR1YnVsYXJTZWdtZW50cyArIDEgKSAqIGogKyBpIC0gMTtcbiAgICAgICAgICAgIHZhciBiID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyBpIC0gMTtcbiAgICAgICAgICAgIHZhciBjID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyBpO1xuICAgICAgICAgICAgdmFyIGQgPSAoIHR1YnVsYXJTZWdtZW50cyArIDEgKSAqIGogKyBpO1xuXG4gICAgICAgICAgICBpbmRpY2VzLnB1c2goYSwgYiwgZCk7XG4gICAgICAgICAgICBpbmRpY2VzLnB1c2goYiwgYywgZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFRyaW1lc2godmVydGljZXMsIGluZGljZXMpO1xufTtcblxufSx7XCIuLi9jb2xsaXNpb24vQUFCQlwiOjMsXCIuLi9tYXRoL1F1YXRlcm5pb25cIjoyOCxcIi4uL21hdGgvVHJhbnNmb3JtXCI6MjksXCIuLi9tYXRoL1ZlYzNcIjozMCxcIi4uL3V0aWxzL09jdHJlZVwiOjUwLFwiLi9TaGFwZVwiOjQzfV0sNDY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBHU1NvbHZlcjtcblxudmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcbnZhciBRdWF0ZXJuaW9uID0gX2RlcmVxXygnLi4vbWF0aC9RdWF0ZXJuaW9uJyk7XG52YXIgU29sdmVyID0gX2RlcmVxXygnLi9Tb2x2ZXInKTtcblxuLyoqXG4gKiBDb25zdHJhaW50IGVxdWF0aW9uIEdhdXNzLVNlaWRlbCBzb2x2ZXIuXG4gKiBAY2xhc3MgR1NTb2x2ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHRvZG8gVGhlIHNwb29rIHBhcmFtZXRlcnMgc2hvdWxkIGJlIHNwZWNpZmllZCBmb3IgZWFjaCBjb25zdHJhaW50LCBub3QgZ2xvYmFsbHkuXG4gKiBAYXV0aG9yIHNjaHRlcHBlIC8gaHR0cHM6Ly9naXRodWIuY29tL3NjaHRlcHBlXG4gKiBAc2VlIGh0dHBzOi8vd3d3OC5jcy51bXUuc2Uva3Vyc2VyLzVEVjA1OC9WVDA5L2xlY3R1cmVzL3Nwb29rbm90ZXMucGRmXG4gKiBAZXh0ZW5kcyBTb2x2ZXJcbiAqL1xuZnVuY3Rpb24gR1NTb2x2ZXIoKXtcbiAgICBTb2x2ZXIuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2Ygc29sdmVyIGl0ZXJhdGlvbnMgZGV0ZXJtaW5lcyBxdWFsaXR5IG9mIHRoZSBjb25zdHJhaW50cyBpbiB0aGUgd29ybGQuIFRoZSBtb3JlIGl0ZXJhdGlvbnMsIHRoZSBtb3JlIGNvcnJlY3Qgc2ltdWxhdGlvbi4gTW9yZSBpdGVyYXRpb25zIG5lZWQgbW9yZSBjb21wdXRhdGlvbnMgdGhvdWdoLiBJZiB5b3UgaGF2ZSBhIGxhcmdlIGdyYXZpdHkgZm9yY2UgaW4geW91ciB3b3JsZCwgeW91IHdpbGwgbmVlZCBtb3JlIGl0ZXJhdGlvbnMuXG4gICAgICogQHByb3BlcnR5IGl0ZXJhdGlvbnNcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEB0b2RvIHdyaXRlIG1vcmUgYWJvdXQgc29sdmVyIGFuZCBpdGVyYXRpb25zIGluIHRoZSB3aWtpXG4gICAgICovXG4gICAgdGhpcy5pdGVyYXRpb25zID0gMTA7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRvbGVyYW5jZSBpcyByZWFjaGVkLCB0aGUgc3lzdGVtIGlzIGFzc3VtZWQgdG8gYmUgY29udmVyZ2VkLlxuICAgICAqIEBwcm9wZXJ0eSB0b2xlcmFuY2VcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudG9sZXJhbmNlID0gMWUtNztcbn1cbkdTU29sdmVyLnByb3RvdHlwZSA9IG5ldyBTb2x2ZXIoKTtcblxudmFyIEdTU29sdmVyX3NvbHZlX2xhbWJkYSA9IFtdOyAvLyBKdXN0IHRlbXBvcmFyeSBudW1iZXIgaG9sZGVycyB0aGF0IHdlIHdhbnQgdG8gcmV1c2UgZWFjaCBzb2x2ZS5cbnZhciBHU1NvbHZlcl9zb2x2ZV9pbnZDcyA9IFtdO1xudmFyIEdTU29sdmVyX3NvbHZlX0JzID0gW107XG5HU1NvbHZlci5wcm90b3R5cGUuc29sdmUgPSBmdW5jdGlvbihkdCx3b3JsZCl7XG4gICAgdmFyIGl0ZXIgPSAwLFxuICAgICAgICBtYXhJdGVyID0gdGhpcy5pdGVyYXRpb25zLFxuICAgICAgICB0b2xTcXVhcmVkID0gdGhpcy50b2xlcmFuY2UqdGhpcy50b2xlcmFuY2UsXG4gICAgICAgIGVxdWF0aW9ucyA9IHRoaXMuZXF1YXRpb25zLFxuICAgICAgICBOZXEgPSBlcXVhdGlvbnMubGVuZ3RoLFxuICAgICAgICBib2RpZXMgPSB3b3JsZC5ib2RpZXMsXG4gICAgICAgIE5ib2RpZXMgPSBib2RpZXMubGVuZ3RoLFxuICAgICAgICBoID0gZHQsXG4gICAgICAgIHEsIEIsIGludkMsIGRlbHRhbGFtYmRhLCBkZWx0YWxhbWJkYVRvdCwgR1dsYW1iZGEsIGxhbWJkYWo7XG5cbiAgICAvLyBVcGRhdGUgc29sdmUgbWFzc1xuICAgIGlmKE5lcSAhPT0gMCl7XG4gICAgICAgIGZvcih2YXIgaT0wOyBpIT09TmJvZGllczsgaSsrKXtcbiAgICAgICAgICAgIGJvZGllc1tpXS51cGRhdGVTb2x2ZU1hc3NQcm9wZXJ0aWVzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGluZ3MgdGhhdCBkb2VzIG5vdCBjaGFuZ2UgZHVyaW5nIGl0ZXJhdGlvbiBjYW4gYmUgY29tcHV0ZWQgb25jZVxuICAgIHZhciBpbnZDcyA9IEdTU29sdmVyX3NvbHZlX2ludkNzLFxuICAgICAgICBCcyA9IEdTU29sdmVyX3NvbHZlX0JzLFxuICAgICAgICBsYW1iZGEgPSBHU1NvbHZlcl9zb2x2ZV9sYW1iZGE7XG4gICAgaW52Q3MubGVuZ3RoID0gTmVxO1xuICAgIEJzLmxlbmd0aCA9IE5lcTtcbiAgICBsYW1iZGEubGVuZ3RoID0gTmVxO1xuICAgIGZvcih2YXIgaT0wOyBpIT09TmVxOyBpKyspe1xuICAgICAgICB2YXIgYyA9IGVxdWF0aW9uc1tpXTtcbiAgICAgICAgbGFtYmRhW2ldID0gMC4wO1xuICAgICAgICBCc1tpXSA9IGMuY29tcHV0ZUIoaCk7XG4gICAgICAgIGludkNzW2ldID0gMS4wIC8gYy5jb21wdXRlQygpO1xuICAgIH1cblxuICAgIGlmKE5lcSAhPT0gMCl7XG5cbiAgICAgICAgLy8gUmVzZXQgdmxhbWJkYVxuICAgICAgICBmb3IodmFyIGk9MDsgaSE9PU5ib2RpZXM7IGkrKyl7XG4gICAgICAgICAgICB2YXIgYj1ib2RpZXNbaV0sXG4gICAgICAgICAgICAgICAgdmxhbWJkYT1iLnZsYW1iZGEsXG4gICAgICAgICAgICAgICAgd2xhbWJkYT1iLndsYW1iZGE7XG4gICAgICAgICAgICB2bGFtYmRhLnNldCgwLDAsMCk7XG4gICAgICAgICAgICBpZih3bGFtYmRhKXtcbiAgICAgICAgICAgICAgICB3bGFtYmRhLnNldCgwLDAsMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgZXF1YXRpb25zXG4gICAgICAgIGZvcihpdGVyPTA7IGl0ZXIhPT1tYXhJdGVyOyBpdGVyKyspe1xuXG4gICAgICAgICAgICAvLyBBY2N1bXVsYXRlIHRoZSB0b3RhbCBlcnJvciBmb3IgZWFjaCBpdGVyYXRpb24uXG4gICAgICAgICAgICBkZWx0YWxhbWJkYVRvdCA9IDAuMDtcblxuICAgICAgICAgICAgZm9yKHZhciBqPTA7IGohPT1OZXE7IGorKyl7XG5cbiAgICAgICAgICAgICAgICB2YXIgYyA9IGVxdWF0aW9uc1tqXTtcblxuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgaXRlcmF0aW9uXG4gICAgICAgICAgICAgICAgQiA9IEJzW2pdO1xuICAgICAgICAgICAgICAgIGludkMgPSBpbnZDc1tqXTtcbiAgICAgICAgICAgICAgICBsYW1iZGFqID0gbGFtYmRhW2pdO1xuICAgICAgICAgICAgICAgIEdXbGFtYmRhID0gYy5jb21wdXRlR1dsYW1iZGEoKTtcbiAgICAgICAgICAgICAgICBkZWx0YWxhbWJkYSA9IGludkMgKiAoIEIgLSBHV2xhbWJkYSAtIGMuZXBzICogbGFtYmRhaiApO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2xhbXAgaWYgd2UgYXJlIG5vdCB3aXRoaW4gdGhlIG1pbi9tYXggaW50ZXJ2YWxcbiAgICAgICAgICAgICAgICBpZihsYW1iZGFqICsgZGVsdGFsYW1iZGEgPCBjLm1pbkZvcmNlKXtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFsYW1iZGEgPSBjLm1pbkZvcmNlIC0gbGFtYmRhajtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYobGFtYmRhaiArIGRlbHRhbGFtYmRhID4gYy5tYXhGb3JjZSl7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhbGFtYmRhID0gYy5tYXhGb3JjZSAtIGxhbWJkYWo7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhbWJkYVtqXSArPSBkZWx0YWxhbWJkYTtcblxuICAgICAgICAgICAgICAgIGRlbHRhbGFtYmRhVG90ICs9IGRlbHRhbGFtYmRhID4gMC4wID8gZGVsdGFsYW1iZGEgOiAtZGVsdGFsYW1iZGE7IC8vIGFicyhkZWx0YWxhbWJkYSlcblxuICAgICAgICAgICAgICAgIGMuYWRkVG9XbGFtYmRhKGRlbHRhbGFtYmRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhlIHRvdGFsIGVycm9yIGlzIHNtYWxsIGVub3VnaCAtIHN0b3AgaXRlcmF0ZVxuICAgICAgICAgICAgaWYoZGVsdGFsYW1iZGFUb3QqZGVsdGFsYW1iZGFUb3QgPCB0b2xTcXVhcmVkKXtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCByZXN1bHQgdG8gdmVsb2NpdHlcbiAgICAgICAgZm9yKHZhciBpPTA7IGkhPT1OYm9kaWVzOyBpKyspe1xuICAgICAgICAgICAgdmFyIGI9Ym9kaWVzW2ldLFxuICAgICAgICAgICAgICAgIHY9Yi52ZWxvY2l0eSxcbiAgICAgICAgICAgICAgICB3PWIuYW5ndWxhclZlbG9jaXR5O1xuICAgICAgICAgICAgdi52YWRkKGIudmxhbWJkYSwgdik7XG4gICAgICAgICAgICBpZih3KXtcbiAgICAgICAgICAgICAgICB3LnZhZGQoYi53bGFtYmRhLCB3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpdGVyO1xufTtcblxufSx7XCIuLi9tYXRoL1F1YXRlcm5pb25cIjoyOCxcIi4uL21hdGgvVmVjM1wiOjMwLFwiLi9Tb2x2ZXJcIjo0N31dLDQ3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gU29sdmVyO1xuXG4vKipcbiAqIENvbnN0cmFpbnQgZXF1YXRpb24gc29sdmVyIGJhc2UgY2xhc3MuXG4gKiBAY2xhc3MgU29sdmVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhdXRob3Igc2NodGVwcGUgLyBodHRwczovL2dpdGh1Yi5jb20vc2NodGVwcGVcbiAqL1xuZnVuY3Rpb24gU29sdmVyKCl7XG4gICAgLyoqXG4gICAgICogQWxsIGVxdWF0aW9ucyB0byBiZSBzb2x2ZWRcbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBlcXVhdGlvbnNcbiAgICAgKi9cbiAgICB0aGlzLmVxdWF0aW9ucyA9IFtdO1xufVxuXG4vKipcbiAqIFNob3VsZCBiZSBpbXBsZW1lbnRlZCBpbiBzdWJjbGFzc2VzIVxuICogQG1ldGhvZCBzb2x2ZVxuICogQHBhcmFtICB7TnVtYmVyfSBkdFxuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXG4gKi9cblNvbHZlci5wcm90b3R5cGUuc29sdmUgPSBmdW5jdGlvbihkdCx3b3JsZCl7XG4gICAgLy8gU2hvdWxkIHJldHVybiB0aGUgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgZG9uZSFcbiAgICByZXR1cm4gMDtcbn07XG5cbi8qKlxuICogQWRkIGFuIGVxdWF0aW9uXG4gKiBAbWV0aG9kIGFkZEVxdWF0aW9uXG4gKiBAcGFyYW0ge0VxdWF0aW9ufSBlcVxuICovXG5Tb2x2ZXIucHJvdG90eXBlLmFkZEVxdWF0aW9uID0gZnVuY3Rpb24oZXEpe1xuICAgIGlmIChlcS5lbmFibGVkKSB7XG4gICAgICAgIHRoaXMuZXF1YXRpb25zLnB1c2goZXEpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGVxdWF0aW9uXG4gKiBAbWV0aG9kIHJlbW92ZUVxdWF0aW9uXG4gKiBAcGFyYW0ge0VxdWF0aW9ufSBlcVxuICovXG5Tb2x2ZXIucHJvdG90eXBlLnJlbW92ZUVxdWF0aW9uID0gZnVuY3Rpb24oZXEpe1xuICAgIHZhciBlcXMgPSB0aGlzLmVxdWF0aW9ucztcbiAgICB2YXIgaSA9IGVxcy5pbmRleE9mKGVxKTtcbiAgICBpZihpICE9PSAtMSl7XG4gICAgICAgIGVxcy5zcGxpY2UoaSwxKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEFkZCBhbGwgZXF1YXRpb25zXG4gKiBAbWV0aG9kIHJlbW92ZUFsbEVxdWF0aW9uc1xuICovXG5Tb2x2ZXIucHJvdG90eXBlLnJlbW92ZUFsbEVxdWF0aW9ucyA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5lcXVhdGlvbnMubGVuZ3RoID0gMDtcbn07XG5cblxufSx7fV0sNDg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBTcGxpdFNvbHZlcjtcblxudmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcbnZhciBRdWF0ZXJuaW9uID0gX2RlcmVxXygnLi4vbWF0aC9RdWF0ZXJuaW9uJyk7XG52YXIgU29sdmVyID0gX2RlcmVxXygnLi9Tb2x2ZXInKTtcbnZhciBCb2R5ID0gX2RlcmVxXygnLi4vb2JqZWN0cy9Cb2R5Jyk7XG5cbi8qKlxuICogU3BsaXRzIHRoZSBlcXVhdGlvbnMgaW50byBpc2xhbmRzIGFuZCBzb2x2ZXMgdGhlbSBpbmRlcGVuZGVudGx5LiBDYW4gaW1wcm92ZSBwZXJmb3JtYW5jZS5cbiAqIEBjbGFzcyBTcGxpdFNvbHZlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBTb2x2ZXJcbiAqIEBwYXJhbSB7U29sdmVyfSBzdWJzb2x2ZXJcbiAqL1xuZnVuY3Rpb24gU3BsaXRTb2x2ZXIoc3Vic29sdmVyKXtcbiAgICBTb2x2ZXIuY2FsbCh0aGlzKTtcbiAgICB0aGlzLml0ZXJhdGlvbnMgPSAxMDtcbiAgICB0aGlzLnRvbGVyYW5jZSA9IDFlLTc7XG4gICAgdGhpcy5zdWJzb2x2ZXIgPSBzdWJzb2x2ZXI7XG4gICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgIHRoaXMubm9kZVBvb2wgPSBbXTtcblxuICAgIC8vIENyZWF0ZSBuZWVkZWQgbm9kZXMsIHJldXNlIGlmIHBvc3NpYmxlXG4gICAgd2hpbGUodGhpcy5ub2RlUG9vbC5sZW5ndGggPCAxMjgpe1xuICAgICAgICB0aGlzLm5vZGVQb29sLnB1c2godGhpcy5jcmVhdGVOb2RlKCkpO1xuICAgIH1cbn1cblNwbGl0U29sdmVyLnByb3RvdHlwZSA9IG5ldyBTb2x2ZXIoKTtcblxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIHN1YnN5c3RlbXNcbnZhciBTcGxpdFNvbHZlcl9zb2x2ZV9ub2RlcyA9IFtdOyAvLyBBbGwgYWxsb2NhdGVkIG5vZGUgb2JqZWN0c1xudmFyIFNwbGl0U29sdmVyX3NvbHZlX25vZGVQb29sID0gW107IC8vIEFsbCBhbGxvY2F0ZWQgbm9kZSBvYmplY3RzXG52YXIgU3BsaXRTb2x2ZXJfc29sdmVfZXFzID0gW107ICAgLy8gVGVtcCBhcnJheVxudmFyIFNwbGl0U29sdmVyX3NvbHZlX2JkcyA9IFtdOyAgIC8vIFRlbXAgYXJyYXlcbnZhciBTcGxpdFNvbHZlcl9zb2x2ZV9kdW1teVdvcmxkID0ge2JvZGllczpbXX07IC8vIFRlbXAgb2JqZWN0XG5cbnZhciBTVEFUSUMgPSBCb2R5LlNUQVRJQztcbmZ1bmN0aW9uIGdldFVudmlzaXRlZE5vZGUobm9kZXMpe1xuICAgIHZhciBObm9kZXMgPSBub2Rlcy5sZW5ndGg7XG4gICAgZm9yKHZhciBpPTA7IGkhPT1Obm9kZXM7IGkrKyl7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmKCFub2RlLnZpc2l0ZWQgJiYgIShub2RlLmJvZHkudHlwZSAmIFNUQVRJQykpe1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgcXVldWUgPSBbXTtcbmZ1bmN0aW9uIGJmcyhyb290LHZpc2l0RnVuYyxiZHMsZXFzKXtcbiAgICBxdWV1ZS5wdXNoKHJvb3QpO1xuICAgIHJvb3QudmlzaXRlZCA9IHRydWU7XG4gICAgdmlzaXRGdW5jKHJvb3QsYmRzLGVxcyk7XG4gICAgd2hpbGUocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHZhciBub2RlID0gcXVldWUucG9wKCk7XG4gICAgICAgIC8vIExvb3Agb3ZlciB1bnZpc2l0ZWQgY2hpbGQgbm9kZXNcbiAgICAgICAgdmFyIGNoaWxkO1xuICAgICAgICB3aGlsZSgoY2hpbGQgPSBnZXRVbnZpc2l0ZWROb2RlKG5vZGUuY2hpbGRyZW4pKSkge1xuICAgICAgICAgICAgY2hpbGQudmlzaXRlZCA9IHRydWU7XG4gICAgICAgICAgICB2aXNpdEZ1bmMoY2hpbGQsYmRzLGVxcyk7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gdmlzaXRGdW5jKG5vZGUsYmRzLGVxcyl7XG4gICAgYmRzLnB1c2gobm9kZS5ib2R5KTtcbiAgICB2YXIgTmVxcyA9IG5vZGUuZXFzLmxlbmd0aDtcbiAgICBmb3IodmFyIGk9MDsgaSE9PU5lcXM7IGkrKyl7XG4gICAgICAgIHZhciBlcSA9IG5vZGUuZXFzW2ldO1xuICAgICAgICBpZihlcXMuaW5kZXhPZihlcSkgPT09IC0xKXtcbiAgICAgICAgICAgIGVxcy5wdXNoKGVxKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuU3BsaXRTb2x2ZXIucHJvdG90eXBlLmNyZWF0ZU5vZGUgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB7IGJvZHk6bnVsbCwgY2hpbGRyZW46W10sIGVxczpbXSwgdmlzaXRlZDpmYWxzZSB9O1xufTtcblxuLyoqXG4gKiBTb2x2ZSB0aGUgc3Vic3lzdGVtc1xuICogQG1ldGhvZCBzb2x2ZVxuICogQHBhcmFtICB7TnVtYmVyfSBkdFxuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXG4gKi9cblNwbGl0U29sdmVyLnByb3RvdHlwZS5zb2x2ZSA9IGZ1bmN0aW9uKGR0LHdvcmxkKXtcbiAgICB2YXIgbm9kZXM9U3BsaXRTb2x2ZXJfc29sdmVfbm9kZXMsXG4gICAgICAgIG5vZGVQb29sPXRoaXMubm9kZVBvb2wsXG4gICAgICAgIGJvZGllcz13b3JsZC5ib2RpZXMsXG4gICAgICAgIGVxdWF0aW9ucz10aGlzLmVxdWF0aW9ucyxcbiAgICAgICAgTmVxPWVxdWF0aW9ucy5sZW5ndGgsXG4gICAgICAgIE5ib2RpZXM9Ym9kaWVzLmxlbmd0aCxcbiAgICAgICAgc3Vic29sdmVyPXRoaXMuc3Vic29sdmVyO1xuXG4gICAgLy8gQ3JlYXRlIG5lZWRlZCBub2RlcywgcmV1c2UgaWYgcG9zc2libGVcbiAgICB3aGlsZShub2RlUG9vbC5sZW5ndGggPCBOYm9kaWVzKXtcbiAgICAgICAgbm9kZVBvb2wucHVzaCh0aGlzLmNyZWF0ZU5vZGUoKSk7XG4gICAgfVxuICAgIG5vZGVzLmxlbmd0aCA9IE5ib2RpZXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOYm9kaWVzOyBpKyspIHtcbiAgICAgICAgbm9kZXNbaV0gPSBub2RlUG9vbFtpXTtcbiAgICB9XG5cbiAgICAvLyBSZXNldCBub2RlIHZhbHVlc1xuICAgIGZvcih2YXIgaT0wOyBpIT09TmJvZGllczsgaSsrKXtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgbm9kZS5ib2R5ID0gYm9kaWVzW2ldO1xuICAgICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gICAgICAgIG5vZGUuZXFzLmxlbmd0aCA9IDA7XG4gICAgICAgIG5vZGUudmlzaXRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBmb3IodmFyIGs9MDsgayE9PU5lcTsgaysrKXtcbiAgICAgICAgdmFyIGVxPWVxdWF0aW9uc1trXSxcbiAgICAgICAgICAgIGk9Ym9kaWVzLmluZGV4T2YoZXEuYmkpLFxuICAgICAgICAgICAgaj1ib2RpZXMuaW5kZXhPZihlcS5iaiksXG4gICAgICAgICAgICBuaT1ub2Rlc1tpXSxcbiAgICAgICAgICAgIG5qPW5vZGVzW2pdO1xuICAgICAgICBuaS5jaGlsZHJlbi5wdXNoKG5qKTtcbiAgICAgICAgbmkuZXFzLnB1c2goZXEpO1xuICAgICAgICBuai5jaGlsZHJlbi5wdXNoKG5pKTtcbiAgICAgICAgbmouZXFzLnB1c2goZXEpO1xuICAgIH1cblxuICAgIHZhciBjaGlsZCwgbj0wLCBlcXM9U3BsaXRTb2x2ZXJfc29sdmVfZXFzO1xuXG4gICAgc3Vic29sdmVyLnRvbGVyYW5jZSA9IHRoaXMudG9sZXJhbmNlO1xuICAgIHN1YnNvbHZlci5pdGVyYXRpb25zID0gdGhpcy5pdGVyYXRpb25zO1xuXG4gICAgdmFyIGR1bW15V29ybGQgPSBTcGxpdFNvbHZlcl9zb2x2ZV9kdW1teVdvcmxkO1xuICAgIHdoaWxlKChjaGlsZCA9IGdldFVudmlzaXRlZE5vZGUobm9kZXMpKSl7XG4gICAgICAgIGVxcy5sZW5ndGggPSAwO1xuICAgICAgICBkdW1teVdvcmxkLmJvZGllcy5sZW5ndGggPSAwO1xuICAgICAgICBiZnMoY2hpbGQsIHZpc2l0RnVuYywgZHVtbXlXb3JsZC5ib2RpZXMsIGVxcyk7XG5cbiAgICAgICAgdmFyIE5lcXMgPSBlcXMubGVuZ3RoO1xuXG4gICAgICAgIGVxcyA9IGVxcy5zb3J0KHNvcnRCeUlkKTtcblxuICAgICAgICBmb3IodmFyIGk9MDsgaSE9PU5lcXM7IGkrKyl7XG4gICAgICAgICAgICBzdWJzb2x2ZXIuYWRkRXF1YXRpb24oZXFzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpdGVyID0gc3Vic29sdmVyLnNvbHZlKGR0LGR1bW15V29ybGQpO1xuICAgICAgICBzdWJzb2x2ZXIucmVtb3ZlQWxsRXF1YXRpb25zKCk7XG4gICAgICAgIG4rKztcbiAgICB9XG5cbiAgICByZXR1cm4gbjtcbn07XG5cbmZ1bmN0aW9uIHNvcnRCeUlkKGEsIGIpe1xuICAgIHJldHVybiBiLmlkIC0gYS5pZDtcbn1cbn0se1wiLi4vbWF0aC9RdWF0ZXJuaW9uXCI6MjgsXCIuLi9tYXRoL1ZlYzNcIjozMCxcIi4uL29iamVjdHMvQm9keVwiOjMxLFwiLi9Tb2x2ZXJcIjo0N31dLDQ5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQmFzZSBjbGFzcyBmb3Igb2JqZWN0cyB0aGF0IGRpc3BhdGNoZXMgZXZlbnRzLlxuICogQGNsYXNzIEV2ZW50VGFyZ2V0XG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEV2ZW50VGFyZ2V0ID0gZnVuY3Rpb24gKCkge1xuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50VGFyZ2V0O1xuXG5FdmVudFRhcmdldC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IEV2ZW50VGFyZ2V0LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyXG4gICAgICogQG1ldGhvZCBhZGRFdmVudExpc3RlbmVyXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB0eXBlXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAgICogQHJldHVybiB7RXZlbnRUYXJnZXR9IFRoZSBzZWxmIG9iamVjdCwgZm9yIGNoYWluYWJpbGl0eS5cbiAgICAgKi9cbiAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyICkge1xuICAgICAgICBpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICl7IHRoaXMuX2xpc3RlbmVycyA9IHt9OyB9XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgICAgIGlmICggbGlzdGVuZXJzWyB0eXBlIF0gPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgIGxpc3RlbmVyc1sgdHlwZSBdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCBsaXN0ZW5lcnNbIHR5cGUgXS5pbmRleE9mKCBsaXN0ZW5lciApID09PSAtIDEgKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnNbIHR5cGUgXS5wdXNoKCBsaXN0ZW5lciApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhbiBldmVudCBsaXN0ZW5lciBpcyBhZGRlZFxuICAgICAqIEBtZXRob2QgaGFzRXZlbnRMaXN0ZW5lclxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdHlwZVxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKCB0eXBlLCBsaXN0ZW5lciApIHtcbiAgICAgICAgaWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICAgICAgaWYgKCBsaXN0ZW5lcnNbIHR5cGUgXSAhPT0gdW5kZWZpbmVkICYmIGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICkgIT09IC0gMSApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyXG4gICAgICogQG1ldGhvZCByZW1vdmVFdmVudExpc3RlbmVyXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB0eXBlXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAgICogQHJldHVybiB7RXZlbnRUYXJnZXR9IFRoZSBzZWxmIG9iamVjdCwgZm9yIGNoYWluYWJpbGl0eS5cbiAgICAgKi9cbiAgICByZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyICkge1xuICAgICAgICBpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICl7IHJldHVybiB0aGlzOyB9XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgICAgIGlmICggbGlzdGVuZXJzW3R5cGVdID09PSB1bmRlZmluZWQgKXsgcmV0dXJuIHRoaXM7IH1cbiAgICAgICAgdmFyIGluZGV4ID0gbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKTtcbiAgICAgICAgaWYgKCBpbmRleCAhPT0gLSAxICkge1xuICAgICAgICAgICAgbGlzdGVuZXJzWyB0eXBlIF0uc3BsaWNlKCBpbmRleCwgMSApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbWl0IGFuIGV2ZW50LlxuICAgICAqIEBtZXRob2QgZGlzcGF0Y2hFdmVudFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gZXZlbnRcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGV2ZW50LnR5cGVcbiAgICAgKiBAcmV0dXJuIHtFdmVudFRhcmdldH0gVGhlIHNlbGYgb2JqZWN0LCBmb3IgY2hhaW5hYmlsaXR5LlxuICAgICAqL1xuICAgIGRpc3BhdGNoRXZlbnQ6IGZ1bmN0aW9uICggZXZlbnQgKSB7XG4gICAgICAgIGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKXsgcmV0dXJuIHRoaXM7IH1cbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICAgICAgdmFyIGxpc3RlbmVyQXJyYXkgPSBsaXN0ZW5lcnNbIGV2ZW50LnR5cGUgXTtcbiAgICAgICAgaWYgKCBsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICBldmVudC50YXJnZXQgPSB0aGlzO1xuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gbGlzdGVuZXJBcnJheS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyQXJyYXlbIGkgXS5jYWxsKCB0aGlzLCBldmVudCApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG5cbn0se31dLDUwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBBQUJCID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL0FBQkInKTtcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gT2N0cmVlO1xuXG4vKipcbiAqIEBjbGFzcyBPY3RyZWVOb2RlXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge09jdHJlZX0gW29wdGlvbnMucm9vdF1cbiAqIEBwYXJhbSB7QUFCQn0gW29wdGlvbnMuYWFiYl1cbiAqL1xuZnVuY3Rpb24gT2N0cmVlTm9kZShvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByb290IG5vZGVcbiAgICAgKiBAcHJvcGVydHkge09jdHJlZU5vZGV9IHJvb3RcbiAgICAgKi9cbiAgICB0aGlzLnJvb3QgPSBvcHRpb25zLnJvb3QgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEJvdW5kYXJ5IG9mIHRoaXMgbm9kZVxuICAgICAqIEBwcm9wZXJ0eSB7QUFCQn0gYWFiYlxuICAgICAqL1xuICAgIHRoaXMuYWFiYiA9IG9wdGlvbnMuYWFiYiA/IG9wdGlvbnMuYWFiYi5jbG9uZSgpIDogbmV3IEFBQkIoKTtcblxuICAgIC8qKlxuICAgICAqIENvbnRhaW5lZCBkYXRhIGF0IHRoZSBjdXJyZW50IG5vZGUgbGV2ZWwuXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gZGF0YVxuICAgICAqL1xuICAgIHRoaXMuZGF0YSA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQ2hpbGRyZW4gdG8gdGhpcyBub2RlXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gY2hpbGRyZW5cbiAgICAgKi9cbiAgICB0aGlzLmNoaWxkcmVuID0gW107XG59XG5cbi8qKlxuICogQGNsYXNzIE9jdHJlZVxuICogQHBhcmFtIHtBQUJCfSBhYWJiIFRoZSB0b3RhbCBBQUJCIG9mIHRoZSB0cmVlXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4RGVwdGg9OF1cbiAqIEBleHRlbmRzIE9jdHJlZU5vZGVcbiAqL1xuZnVuY3Rpb24gT2N0cmVlKGFhYmIsIG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMucm9vdCA9IG51bGw7XG4gICAgb3B0aW9ucy5hYWJiID0gYWFiYjtcbiAgICBPY3RyZWVOb2RlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBNYXhpbXVtIHN1YmRpdmlzaW9uIGRlcHRoXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1heERlcHRoXG4gICAgICovXG4gICAgdGhpcy5tYXhEZXB0aCA9IHR5cGVvZihvcHRpb25zLm1heERlcHRoKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLm1heERlcHRoIDogODtcbn1cbk9jdHJlZS5wcm90b3R5cGUgPSBuZXcgT2N0cmVlTm9kZSgpO1xuXG5PY3RyZWVOb2RlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKGFhYmIsIG9wdGlvbnMpe1xuICAgIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID0gdGhpcy5kYXRhLmxlbmd0aCA9IDA7XG59O1xuXG4vKipcbiAqIEluc2VydCBkYXRhIGludG8gdGhpcyBub2RlXG4gKiBAbWV0aG9kIGluc2VydFxuICogQHBhcmFtICB7QUFCQn0gYWFiYlxuICogQHBhcmFtICB7b2JqZWN0fSBlbGVtZW50RGF0YVxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBzdWNjZXNzZnVsLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuT2N0cmVlTm9kZS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24oYWFiYiwgZWxlbWVudERhdGEsIGxldmVsKXtcbiAgICB2YXIgbm9kZURhdGEgPSB0aGlzLmRhdGE7XG4gICAgbGV2ZWwgPSBsZXZlbCB8fCAwO1xuXG4gICAgLy8gSWdub3JlIG9iamVjdHMgdGhhdCBkbyBub3QgYmVsb25nIGluIHRoaXMgbm9kZVxuICAgIGlmICghdGhpcy5hYWJiLmNvbnRhaW5zKGFhYmIpKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBvYmplY3QgY2Fubm90IGJlIGFkZGVkXG4gICAgfVxuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcblxuICAgIGlmKGxldmVsIDwgKHRoaXMubWF4RGVwdGggfHwgdGhpcy5yb290Lm1heERlcHRoKSl7XG4gICAgICAgIC8vIFN1YmRpdmlkZSBpZiB0aGVyZSBhcmUgbm8gY2hpbGRyZW4geWV0XG4gICAgICAgIHZhciBzdWJkaXZpZGVkID0gZmFsc2U7XG4gICAgICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKXtcbiAgICAgICAgICAgIHRoaXMuc3ViZGl2aWRlKCk7XG4gICAgICAgICAgICBzdWJkaXZpZGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCB0byB3aGljaGV2ZXIgbm9kZSB3aWxsIGFjY2VwdCBpdFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gODsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGRyZW5baV0uaW5zZXJ0KGFhYmIsIGVsZW1lbnREYXRhLCBsZXZlbCArIDEpKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHN1YmRpdmlkZWQpe1xuICAgICAgICAgICAgLy8gTm8gY2hpbGRyZW4gYWNjZXB0ZWQhIE1pZ2h0IGFzIHdlbGwganVzdCByZW1vdmUgZW0gc2luY2UgdGhleSBjb250YWluIG5vbmVcbiAgICAgICAgICAgIGNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUb28gZGVlcCwgb3IgY2hpbGRyZW4gZGlkbnQgd2FudCBpdC4gYWRkIGl0IGluIGN1cnJlbnQgbm9kZVxuICAgIG5vZGVEYXRhLnB1c2goZWxlbWVudERhdGEpO1xuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgaGFsZkRpYWdvbmFsID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBDcmVhdGUgOCBlcXVhbGx5IHNpemVkIGNoaWxkcmVuIG5vZGVzIGFuZCBwdXQgdGhlbSBpbiB0aGUgLmNoaWxkcmVuIGFycmF5LlxuICogQG1ldGhvZCBzdWJkaXZpZGVcbiAqL1xuT2N0cmVlTm9kZS5wcm90b3R5cGUuc3ViZGl2aWRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFhYmIgPSB0aGlzLmFhYmI7XG4gICAgdmFyIGwgPSBhYWJiLmxvd2VyQm91bmQ7XG4gICAgdmFyIHUgPSBhYWJiLnVwcGVyQm91bmQ7XG5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXG4gICAgY2hpbGRyZW4ucHVzaChcbiAgICAgICAgbmV3IE9jdHJlZU5vZGUoeyBhYWJiOiBuZXcgQUFCQih7IGxvd2VyQm91bmQ6IG5ldyBWZWMzKDAsMCwwKSB9KSB9KSxcbiAgICAgICAgbmV3IE9jdHJlZU5vZGUoeyBhYWJiOiBuZXcgQUFCQih7IGxvd2VyQm91bmQ6IG5ldyBWZWMzKDEsMCwwKSB9KSB9KSxcbiAgICAgICAgbmV3IE9jdHJlZU5vZGUoeyBhYWJiOiBuZXcgQUFCQih7IGxvd2VyQm91bmQ6IG5ldyBWZWMzKDEsMSwwKSB9KSB9KSxcbiAgICAgICAgbmV3IE9jdHJlZU5vZGUoeyBhYWJiOiBuZXcgQUFCQih7IGxvd2VyQm91bmQ6IG5ldyBWZWMzKDEsMSwxKSB9KSB9KSxcbiAgICAgICAgbmV3IE9jdHJlZU5vZGUoeyBhYWJiOiBuZXcgQUFCQih7IGxvd2VyQm91bmQ6IG5ldyBWZWMzKDAsMSwxKSB9KSB9KSxcbiAgICAgICAgbmV3IE9jdHJlZU5vZGUoeyBhYWJiOiBuZXcgQUFCQih7IGxvd2VyQm91bmQ6IG5ldyBWZWMzKDAsMCwxKSB9KSB9KSxcbiAgICAgICAgbmV3IE9jdHJlZU5vZGUoeyBhYWJiOiBuZXcgQUFCQih7IGxvd2VyQm91bmQ6IG5ldyBWZWMzKDEsMCwxKSB9KSB9KSxcbiAgICAgICAgbmV3IE9jdHJlZU5vZGUoeyBhYWJiOiBuZXcgQUFCQih7IGxvd2VyQm91bmQ6IG5ldyBWZWMzKDAsMSwwKSB9KSB9KVxuICAgICk7XG5cbiAgICB1LnZzdWIobCwgaGFsZkRpYWdvbmFsKTtcbiAgICBoYWxmRGlhZ29uYWwuc2NhbGUoMC41LCBoYWxmRGlhZ29uYWwpO1xuXG4gICAgdmFyIHJvb3QgPSB0aGlzLnJvb3QgfHwgdGhpcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSA4OyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG5cbiAgICAgICAgLy8gU2V0IGN1cnJlbnQgbm9kZSBhcyByb290XG4gICAgICAgIGNoaWxkLnJvb3QgPSByb290O1xuXG4gICAgICAgIC8vIENvbXB1dGUgYm91bmRzXG4gICAgICAgIHZhciBsb3dlckJvdW5kID0gY2hpbGQuYWFiYi5sb3dlckJvdW5kO1xuICAgICAgICBsb3dlckJvdW5kLnggKj0gaGFsZkRpYWdvbmFsLng7XG4gICAgICAgIGxvd2VyQm91bmQueSAqPSBoYWxmRGlhZ29uYWwueTtcbiAgICAgICAgbG93ZXJCb3VuZC56ICo9IGhhbGZEaWFnb25hbC56O1xuXG4gICAgICAgIGxvd2VyQm91bmQudmFkZChsLCBsb3dlckJvdW5kKTtcblxuICAgICAgICAvLyBVcHBlciBib3VuZCBpcyBhbHdheXMgbG93ZXIgYm91bmQgKyBoYWxmRGlhZ29uYWxcbiAgICAgICAgbG93ZXJCb3VuZC52YWRkKGhhbGZEaWFnb25hbCwgY2hpbGQuYWFiYi51cHBlckJvdW5kKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEdldCBhbGwgZGF0YSwgcG90ZW50aWFsbHkgd2l0aGluIGFuIEFBQkJcbiAqIEBtZXRob2QgYWFiYlF1ZXJ5XG4gKiBAcGFyYW0gIHtBQUJCfSBhYWJiXG4gKiBAcGFyYW0gIHthcnJheX0gcmVzdWx0XG4gKiBAcmV0dXJuIHthcnJheX0gVGhlIFwicmVzdWx0XCIgb2JqZWN0XG4gKi9cbk9jdHJlZU5vZGUucHJvdG90eXBlLmFhYmJRdWVyeSA9IGZ1bmN0aW9uKGFhYmIsIHJlc3VsdCkge1xuXG4gICAgdmFyIG5vZGVEYXRhID0gdGhpcy5kYXRhO1xuXG4gICAgLy8gYWJvcnQgaWYgdGhlIHJhbmdlIGRvZXMgbm90IGludGVyc2VjdCB0aGlzIG5vZGVcbiAgICAvLyBpZiAoIXRoaXMuYWFiYi5vdmVybGFwcyhhYWJiKSl7XG4gICAgLy8gICAgIHJldHVybiByZXN1bHQ7XG4gICAgLy8gfVxuXG4gICAgLy8gQWRkIG9iamVjdHMgYXQgdGhpcyBsZXZlbFxuICAgIC8vIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHJlc3VsdCwgbm9kZURhdGEpO1xuXG4gICAgLy8gQWRkIGNoaWxkIGRhdGFcbiAgICAvLyBAdG9kbyB1bndyYXAgcmVjdXJzaW9uIGludG8gYSBxdWV1ZSAvIGxvb3AsIHRoYXQncyBmYXN0ZXIgaW4gSlNcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXG5cbiAgICAvLyBmb3IgKHZhciBpID0gMCwgTiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpICE9PSBOOyBpKyspIHtcbiAgICAvLyAgICAgY2hpbGRyZW5baV0uYWFiYlF1ZXJ5KGFhYmIsIHJlc3VsdCk7XG4gICAgLy8gfVxuXG4gICAgdmFyIHF1ZXVlID0gW3RoaXNdO1xuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBxdWV1ZS5wb3AoKTtcbiAgICAgICAgaWYgKG5vZGUuYWFiYi5vdmVybGFwcyhhYWJiKSl7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShyZXN1bHQsIG5vZGUuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkocXVldWUsIG5vZGUuY2hpbGRyZW4pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgdG1wQUFCQiA9IG5ldyBBQUJCKCk7XG5cbi8qKlxuICogR2V0IGFsbCBkYXRhLCBwb3RlbnRpYWxseSBpbnRlcnNlY3RlZCBieSBhIHJheS5cbiAqIEBtZXRob2QgcmF5UXVlcnlcbiAqIEBwYXJhbSAge1JheX0gcmF5XG4gKiBAcGFyYW0gIHtUcmFuc2Zvcm19IHRyZWVUcmFuc2Zvcm1cbiAqIEBwYXJhbSAge2FycmF5fSByZXN1bHRcbiAqIEByZXR1cm4ge2FycmF5fSBUaGUgXCJyZXN1bHRcIiBvYmplY3RcbiAqL1xuT2N0cmVlTm9kZS5wcm90b3R5cGUucmF5UXVlcnkgPSBmdW5jdGlvbihyYXksIHRyZWVUcmFuc2Zvcm0sIHJlc3VsdCkge1xuXG4gICAgLy8gVXNlIGFhYmIgcXVlcnkgZm9yIG5vdy5cbiAgICAvLyBAdG9kbyBpbXBsZW1lbnQgcmVhbCByYXkgcXVlcnkgd2hpY2ggbmVlZHMgbGVzcyBsb29rdXBzXG4gICAgcmF5LmdldEFBQkIodG1wQUFCQik7XG4gICAgdG1wQUFCQi50b0xvY2FsRnJhbWUodHJlZVRyYW5zZm9ybSwgdG1wQUFCQik7XG4gICAgdGhpcy5hYWJiUXVlcnkodG1wQUFCQiwgcmVzdWx0KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgcmVtb3ZlRW1wdHlOb2Rlc1xuICovXG5PY3RyZWVOb2RlLnByb3RvdHlwZS5yZW1vdmVFbXB0eU5vZGVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHF1ZXVlID0gW3RoaXNdO1xuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBxdWV1ZS5wb3AoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmKCFub2RlLmNoaWxkcmVuW2ldLmRhdGEubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShxdWV1ZSwgbm9kZS5jaGlsZHJlbik7XG4gICAgfVxufTtcblxufSx7XCIuLi9jb2xsaXNpb24vQUFCQlwiOjMsXCIuLi9tYXRoL1ZlYzNcIjozMH1dLDUxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gUG9vbDtcblxuLyoqXG4gKiBGb3IgcG9vbGluZyBvYmplY3RzIHRoYXQgY2FuIGJlIHJldXNlZC5cbiAqIEBjbGFzcyBQb29sXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gUG9vbCgpe1xuICAgIC8qKlxuICAgICAqIFRoZSBwb29sZWQgb2JqZWN0c1xuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IG9iamVjdHNcbiAgICAgKi9cbiAgICB0aGlzLm9iamVjdHMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIG9mIHRoZSBvYmplY3RzXG4gICAgICogQHByb3BlcnR5IHttaXhlZH0gdHlwZVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IE9iamVjdDtcbn1cblxuLyoqXG4gKiBSZWxlYXNlIGFuIG9iamVjdCBhZnRlciB1c2VcbiAqIEBtZXRob2QgcmVsZWFzZVxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICovXG5Qb29sLnByb3RvdHlwZS5yZWxlYXNlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgTmFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGZvcih2YXIgaT0wOyBpIT09TmFyZ3M7IGkrKyl7XG4gICAgICAgIHRoaXMub2JqZWN0cy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBHZXQgYW4gb2JqZWN0XG4gKiBAbWV0aG9kIGdldFxuICogQHJldHVybiB7bWl4ZWR9XG4gKi9cblBvb2wucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKCl7XG4gICAgaWYodGhpcy5vYmplY3RzLmxlbmd0aD09PTApe1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RPYmplY3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5vYmplY3RzLnBvcCgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ29uc3RydWN0IGFuIG9iamVjdC4gU2hvdWxkIGJlIGltcGxtZW50ZWQgaW4gZWFjaCBzdWJjbGFzcy5cbiAqIEBtZXRob2QgY29uc3RydWN0T2JqZWN0XG4gKiBAcmV0dXJuIHttaXhlZH1cbiAqL1xuUG9vbC5wcm90b3R5cGUuY29uc3RydWN0T2JqZWN0ID0gZnVuY3Rpb24oKXtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb25zdHJ1Y3RPYmplY3QoKSBub3QgaW1wbGVtZW50ZWQgaW4gdGhpcyBQb29sIHN1YmNsYXNzIHlldCFcIik7XG59O1xuXG59LHt9XSw1MjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IFR1cGxlRGljdGlvbmFyeTtcblxuLyoqXG4gKiBAY2xhc3MgVHVwbGVEaWN0aW9uYXJ5XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gVHVwbGVEaWN0aW9uYXJ5KCkge1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRhdGEgc3RvcmFnZVxuICAgICAqIEBwcm9wZXJ0eSBkYXRhXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLmRhdGEgPSB7IGtleXM6W10gfTtcbn1cblxuLyoqXG4gKiBAbWV0aG9kIGdldFxuICogQHBhcmFtICB7TnVtYmVyfSBpXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuVHVwbGVEaWN0aW9uYXJ5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihpLCBqKSB7XG4gICAgaWYgKGkgPiBqKSB7XG4gICAgICAgIC8vIHN3YXBcbiAgICAgICAgdmFyIHRlbXAgPSBqO1xuICAgICAgICBqID0gaTtcbiAgICAgICAgaSA9IHRlbXA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRhdGFbaSsnLScral07XG59O1xuXG4vKipcbiAqIEBtZXRob2Qgc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGlcbiAqIEBwYXJhbSAge051bWJlcn0galxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gKi9cblR1cGxlRGljdGlvbmFyeS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oaSwgaiwgdmFsdWUpIHtcbiAgICBpZiAoaSA+IGopIHtcbiAgICAgICAgdmFyIHRlbXAgPSBqO1xuICAgICAgICBqID0gaTtcbiAgICAgICAgaSA9IHRlbXA7XG4gICAgfVxuICAgIHZhciBrZXkgPSBpKyctJytqO1xuXG4gICAgLy8gQ2hlY2sgaWYga2V5IGFscmVhZHkgZXhpc3RzXG4gICAgaWYoIXRoaXMuZ2V0KGksaikpe1xuICAgICAgICB0aGlzLmRhdGEua2V5cy5wdXNoKGtleSk7XG4gICAgfVxuXG4gICAgdGhpcy5kYXRhW2tleV0gPSB2YWx1ZTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCByZXNldFxuICovXG5UdXBsZURpY3Rpb25hcnkucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGEsXG4gICAgICAgIGtleXMgPSBkYXRhLmtleXM7XG4gICAgd2hpbGUoa2V5cy5sZW5ndGggPiAwKXtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGRlbGV0ZSBkYXRhW2tleV07XG4gICAgfVxufTtcblxufSx7fV0sNTM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuZnVuY3Rpb24gVXRpbHMoKXt9XG5cbm1vZHVsZS5leHBvcnRzID0gVXRpbHM7XG5cbi8qKlxuICogRXh0ZW5kIGFuIG9wdGlvbnMgb2JqZWN0IHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGRlZmF1bHRzXG4gKiBAcGFyYW0gIHtvYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgb2JqZWN0LiBNYXkgYmUgZmFsc3k6IGluIHRoaXMgY2FzZSwgYSBuZXcgb2JqZWN0IGlzIGNyZWF0ZWQgYW5kIHJldHVybmVkLlxuICogQHBhcmFtICB7b2JqZWN0fSBkZWZhdWx0cyBBbiBvYmplY3QgY29udGFpbmluZyBkZWZhdWx0IHZhbHVlcy5cbiAqIEByZXR1cm4ge29iamVjdH0gVGhlIG1vZGlmaWVkIG9wdGlvbnMgb2JqZWN0LlxuICovXG5VdGlscy5kZWZhdWx0cyA9IGZ1bmN0aW9uKG9wdGlvbnMsIGRlZmF1bHRzKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGZvcih2YXIga2V5IGluIGRlZmF1bHRzKXtcbiAgICAgICAgaWYoIShrZXkgaW4gb3B0aW9ucykpe1xuICAgICAgICAgICAgb3B0aW9uc1trZXldID0gZGVmYXVsdHNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvcHRpb25zO1xufTtcblxufSx7fV0sNTQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBWZWMzUG9vbDtcblxudmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcbnZhciBQb29sID0gX2RlcmVxXygnLi9Qb29sJyk7XG5cbi8qKlxuICogQGNsYXNzIFZlYzNQb29sXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFBvb2xcbiAqL1xuZnVuY3Rpb24gVmVjM1Bvb2woKXtcbiAgICBQb29sLmNhbGwodGhpcyk7XG4gICAgdGhpcy50eXBlID0gVmVjMztcbn1cblZlYzNQb29sLnByb3RvdHlwZSA9IG5ldyBQb29sKCk7XG5cbi8qKlxuICogQ29uc3RydWN0IGEgdmVjdG9yXG4gKiBAbWV0aG9kIGNvbnN0cnVjdE9iamVjdFxuICogQHJldHVybiB7VmVjM31cbiAqL1xuVmVjM1Bvb2wucHJvdG90eXBlLmNvbnN0cnVjdE9iamVjdCA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIG5ldyBWZWMzKCk7XG59O1xuXG59LHtcIi4uL21hdGgvVmVjM1wiOjMwLFwiLi9Qb29sXCI6NTF9XSw1NTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IE5hcnJvd3BoYXNlO1xuXG52YXIgQUFCQiA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9BQUJCJyk7XG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvU2hhcGUnKTtcbnZhciBSYXkgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vUmF5Jyk7XG52YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xudmFyIFRyYW5zZm9ybSA9IF9kZXJlcV8oJy4uL21hdGgvVHJhbnNmb3JtJyk7XG52YXIgQ29udmV4UG9seWhlZHJvbiA9IF9kZXJlcV8oJy4uL3NoYXBlcy9Db252ZXhQb2x5aGVkcm9uJyk7XG52YXIgUXVhdGVybmlvbiA9IF9kZXJlcV8oJy4uL21hdGgvUXVhdGVybmlvbicpO1xudmFyIFNvbHZlciA9IF9kZXJlcV8oJy4uL3NvbHZlci9Tb2x2ZXInKTtcbnZhciBWZWMzUG9vbCA9IF9kZXJlcV8oJy4uL3V0aWxzL1ZlYzNQb29sJyk7XG52YXIgQ29udGFjdEVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvbicpO1xudmFyIEZyaWN0aW9uRXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvRnJpY3Rpb25FcXVhdGlvbicpO1xuXG4vKipcbiAqIEhlbHBlciBjbGFzcyBmb3IgdGhlIFdvcmxkLiBHZW5lcmF0ZXMgQ29udGFjdEVxdWF0aW9ucy5cbiAqIEBjbGFzcyBOYXJyb3dwaGFzZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAdG9kbyBTcGhlcmUtQ29udmV4UG9seWhlZHJvbiBjb250YWN0c1xuICogQHRvZG8gQ29udGFjdCByZWR1Y3Rpb25cbiAqIEB0b2RvICBzaG91bGQgbW92ZSBtZXRob2RzIHRvIHByb3RvdHlwZVxuICovXG5mdW5jdGlvbiBOYXJyb3dwaGFzZSh3b3JsZCl7XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBzdG9yYWdlIG9mIHBvb2xlZCBjb250YWN0IHBvaW50cy5cbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBjb250YWN0UG9pbnRQb29sXG4gICAgICovXG4gICAgdGhpcy5jb250YWN0UG9pbnRQb29sID0gW107XG5cbiAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25Qb29sID0gW107XG5cbiAgICB0aGlzLnJlc3VsdCA9IFtdO1xuICAgIHRoaXMuZnJpY3Rpb25SZXN1bHQgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFBvb2xlZCB2ZWN0b3JzLlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM1Bvb2x9IHYzcG9vbFxuICAgICAqL1xuICAgIHRoaXMudjNwb29sID0gbmV3IFZlYzNQb29sKCk7XG5cbiAgICB0aGlzLndvcmxkID0gd29ybGQ7XG4gICAgdGhpcy5jdXJyZW50Q29udGFjdE1hdGVyaWFsID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb25cbiAgICAgKi9cbiAgICB0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uID0gZmFsc2U7XG59XG5cbi8qKlxuICogTWFrZSBhIGNvbnRhY3Qgb2JqZWN0LCBieSB1c2luZyB0aGUgaW50ZXJuYWwgcG9vbCBvciBjcmVhdGluZyBhIG5ldyBvbmUuXG4gKiBAbWV0aG9kIGNyZWF0ZUNvbnRhY3RFcXVhdGlvblxuICogQHJldHVybiB7Q29udGFjdEVxdWF0aW9ufVxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY3JlYXRlQ29udGFjdEVxdWF0aW9uID0gZnVuY3Rpb24oYmksIGJqLCBzaSwgc2osIHJzaSwgcnNqKXtcbiAgICB2YXIgYztcbiAgICBpZih0aGlzLmNvbnRhY3RQb2ludFBvb2wubGVuZ3RoKXtcbiAgICAgICAgYyA9IHRoaXMuY29udGFjdFBvaW50UG9vbC5wb3AoKTtcbiAgICAgICAgYy5iaSA9IGJpO1xuICAgICAgICBjLmJqID0gYmo7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYyA9IG5ldyBDb250YWN0RXF1YXRpb24oYmksIGJqKTtcbiAgICB9XG5cbiAgICBjLmVuYWJsZWQgPSBiaS5jb2xsaXNpb25SZXNwb25zZSAmJiBiai5jb2xsaXNpb25SZXNwb25zZSAmJiBzaS5jb2xsaXNpb25SZXNwb25zZSAmJiBzai5jb2xsaXNpb25SZXNwb25zZTtcblxuICAgIHZhciBjbSA9IHRoaXMuY3VycmVudENvbnRhY3RNYXRlcmlhbDtcblxuICAgIGMucmVzdGl0dXRpb24gPSBjbS5yZXN0aXR1dGlvbjtcblxuICAgIGMuc2V0U3Bvb2tQYXJhbXMoXG4gICAgICAgIGNtLmNvbnRhY3RFcXVhdGlvblN0aWZmbmVzcyxcbiAgICAgICAgY20uY29udGFjdEVxdWF0aW9uUmVsYXhhdGlvbixcbiAgICAgICAgdGhpcy53b3JsZC5kdFxuICAgICk7XG5cbiAgICB2YXIgbWF0QSA9IHNpLm1hdGVyaWFsIHx8IGJpLm1hdGVyaWFsO1xuICAgIHZhciBtYXRCID0gc2oubWF0ZXJpYWwgfHwgYmoubWF0ZXJpYWw7XG4gICAgaWYobWF0QSAmJiBtYXRCICYmIG1hdEEucmVzdGl0dXRpb24gPj0gMCAmJiBtYXRCLnJlc3RpdHV0aW9uID49IDApe1xuICAgICAgICBjLnJlc3RpdHV0aW9uID0gbWF0QS5yZXN0aXR1dGlvbiAqIG1hdEIucmVzdGl0dXRpb247XG4gICAgfVxuXG4gICAgYy5zaSA9IHJzaSB8fCBzaTtcbiAgICBjLnNqID0gcnNqIHx8IHNqO1xuXG4gICAgcmV0dXJuIGM7XG59O1xuXG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdCA9IGZ1bmN0aW9uKGNvbnRhY3RFcXVhdGlvbiwgb3V0QXJyYXkpe1xuICAgIHZhciBib2R5QSA9IGNvbnRhY3RFcXVhdGlvbi5iaTtcbiAgICB2YXIgYm9keUIgPSBjb250YWN0RXF1YXRpb24uYmo7XG4gICAgdmFyIHNoYXBlQSA9IGNvbnRhY3RFcXVhdGlvbi5zaTtcbiAgICB2YXIgc2hhcGVCID0gY29udGFjdEVxdWF0aW9uLnNqO1xuXG4gICAgdmFyIHdvcmxkID0gdGhpcy53b3JsZDtcbiAgICB2YXIgY20gPSB0aGlzLmN1cnJlbnRDb250YWN0TWF0ZXJpYWw7XG5cbiAgICAvLyBJZiBmcmljdGlvbiBvciByZXN0aXR1dGlvbiB3ZXJlIHNwZWNpZmllZCBpbiB0aGUgbWF0ZXJpYWwsIHVzZSB0aGVtXG4gICAgdmFyIGZyaWN0aW9uID0gY20uZnJpY3Rpb247XG4gICAgdmFyIG1hdEEgPSBzaGFwZUEubWF0ZXJpYWwgfHwgYm9keUEubWF0ZXJpYWw7XG4gICAgdmFyIG1hdEIgPSBzaGFwZUIubWF0ZXJpYWwgfHwgYm9keUIubWF0ZXJpYWw7XG4gICAgaWYobWF0QSAmJiBtYXRCICYmIG1hdEEuZnJpY3Rpb24gPj0gMCAmJiBtYXRCLmZyaWN0aW9uID49IDApe1xuICAgICAgICBmcmljdGlvbiA9IG1hdEEuZnJpY3Rpb24gKiBtYXRCLmZyaWN0aW9uO1xuICAgIH1cblxuICAgIGlmKGZyaWN0aW9uID4gMCl7XG5cbiAgICAgICAgLy8gQ3JlYXRlIDIgdGFuZ2VudCBlcXVhdGlvbnNcbiAgICAgICAgdmFyIG11ZyA9IGZyaWN0aW9uICogd29ybGQuZ3Jhdml0eS5sZW5ndGgoKTtcbiAgICAgICAgdmFyIHJlZHVjZWRNYXNzID0gKGJvZHlBLmludk1hc3MgKyBib2R5Qi5pbnZNYXNzKTtcbiAgICAgICAgaWYocmVkdWNlZE1hc3MgPiAwKXtcbiAgICAgICAgICAgIHJlZHVjZWRNYXNzID0gMS9yZWR1Y2VkTWFzcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcG9vbCA9IHRoaXMuZnJpY3Rpb25FcXVhdGlvblBvb2w7XG4gICAgICAgIHZhciBjMSA9IHBvb2wubGVuZ3RoID8gcG9vbC5wb3AoKSA6IG5ldyBGcmljdGlvbkVxdWF0aW9uKGJvZHlBLGJvZHlCLG11ZypyZWR1Y2VkTWFzcyk7XG4gICAgICAgIHZhciBjMiA9IHBvb2wubGVuZ3RoID8gcG9vbC5wb3AoKSA6IG5ldyBGcmljdGlvbkVxdWF0aW9uKGJvZHlBLGJvZHlCLG11ZypyZWR1Y2VkTWFzcyk7XG5cbiAgICAgICAgYzEuYmkgPSBjMi5iaSA9IGJvZHlBO1xuICAgICAgICBjMS5iaiA9IGMyLmJqID0gYm9keUI7XG4gICAgICAgIGMxLm1pbkZvcmNlID0gYzIubWluRm9yY2UgPSAtbXVnKnJlZHVjZWRNYXNzO1xuICAgICAgICBjMS5tYXhGb3JjZSA9IGMyLm1heEZvcmNlID0gbXVnKnJlZHVjZWRNYXNzO1xuXG4gICAgICAgIC8vIENvcHkgb3ZlciB0aGUgcmVsYXRpdmUgdmVjdG9yc1xuICAgICAgICBjMS5yaS5jb3B5KGNvbnRhY3RFcXVhdGlvbi5yaSk7XG4gICAgICAgIGMxLnJqLmNvcHkoY29udGFjdEVxdWF0aW9uLnJqKTtcbiAgICAgICAgYzIucmkuY29weShjb250YWN0RXF1YXRpb24ucmkpO1xuICAgICAgICBjMi5yai5jb3B5KGNvbnRhY3RFcXVhdGlvbi5yaik7XG5cbiAgICAgICAgLy8gQ29uc3RydWN0IHRhbmdlbnRzXG4gICAgICAgIGNvbnRhY3RFcXVhdGlvbi5uaS50YW5nZW50cyhjMS50LCBjMi50KTtcblxuICAgICAgICAvLyBTZXQgc3Bvb2sgcGFyYW1zXG4gICAgICAgIGMxLnNldFNwb29rUGFyYW1zKGNtLmZyaWN0aW9uRXF1YXRpb25TdGlmZm5lc3MsIGNtLmZyaWN0aW9uRXF1YXRpb25SZWxheGF0aW9uLCB3b3JsZC5kdCk7XG4gICAgICAgIGMyLnNldFNwb29rUGFyYW1zKGNtLmZyaWN0aW9uRXF1YXRpb25TdGlmZm5lc3MsIGNtLmZyaWN0aW9uRXF1YXRpb25SZWxheGF0aW9uLCB3b3JsZC5kdCk7XG5cbiAgICAgICAgYzEuZW5hYmxlZCA9IGMyLmVuYWJsZWQgPSBjb250YWN0RXF1YXRpb24uZW5hYmxlZDtcblxuICAgICAgICBvdXRBcnJheS5wdXNoKGMxLCBjMik7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxudmFyIGF2ZXJhZ2VOb3JtYWwgPSBuZXcgVmVjMygpO1xudmFyIGF2ZXJhZ2VDb250YWN0UG9pbnRBID0gbmV3IFZlYzMoKTtcbnZhciBhdmVyYWdlQ29udGFjdFBvaW50QiA9IG5ldyBWZWMzKCk7XG5cbi8vIFRha2UgdGhlIGF2ZXJhZ2UgTiBsYXRlc3QgY29udGFjdCBwb2ludCBvbiB0aGUgcGxhbmUuXG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY3JlYXRlRnJpY3Rpb25Gcm9tQXZlcmFnZSA9IGZ1bmN0aW9uKG51bUNvbnRhY3RzKXtcbiAgICAvLyBUaGUgbGFzdCBjb250YWN0RXF1YXRpb25cbiAgICB2YXIgYyA9IHRoaXMucmVzdWx0W3RoaXMucmVzdWx0Lmxlbmd0aCAtIDFdO1xuXG4gICAgLy8gQ3JlYXRlIHRoZSByZXN1bHQ6IHR3byBcImF2ZXJhZ2VcIiBmcmljdGlvbiBlcXVhdGlvbnNcbiAgICBpZiAoIXRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChjLCB0aGlzLmZyaWN0aW9uUmVzdWx0KSB8fCBudW1Db250YWN0cyA9PT0gMSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGYxID0gdGhpcy5mcmljdGlvblJlc3VsdFt0aGlzLmZyaWN0aW9uUmVzdWx0Lmxlbmd0aCAtIDJdO1xuICAgIHZhciBmMiA9IHRoaXMuZnJpY3Rpb25SZXN1bHRbdGhpcy5mcmljdGlvblJlc3VsdC5sZW5ndGggLSAxXTtcblxuICAgIGF2ZXJhZ2VOb3JtYWwuc2V0WmVybygpO1xuICAgIGF2ZXJhZ2VDb250YWN0UG9pbnRBLnNldFplcm8oKTtcbiAgICBhdmVyYWdlQ29udGFjdFBvaW50Qi5zZXRaZXJvKCk7XG5cbiAgICB2YXIgYm9keUEgPSBjLmJpO1xuICAgIHZhciBib2R5QiA9IGMuYmo7XG4gICAgZm9yKHZhciBpPTA7IGkhPT1udW1Db250YWN0czsgaSsrKXtcbiAgICAgICAgYyA9IHRoaXMucmVzdWx0W3RoaXMucmVzdWx0Lmxlbmd0aCAtIDEgLSBpXTtcbiAgICAgICAgaWYoYy5ib2R5QSAhPT0gYm9keUEpe1xuICAgICAgICAgICAgYXZlcmFnZU5vcm1hbC52YWRkKGMubmksIGF2ZXJhZ2VOb3JtYWwpOyAvLyB2ZWMyLmFkZChlcS50LCBlcS50LCBjLm5vcm1hbEEpO1xuICAgICAgICAgICAgYXZlcmFnZUNvbnRhY3RQb2ludEEudmFkZChjLnJpLCBhdmVyYWdlQ29udGFjdFBvaW50QSk7IC8vIHZlYzIuYWRkKGVxLmNvbnRhY3RQb2ludEEsIGVxLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSk7XG4gICAgICAgICAgICBhdmVyYWdlQ29udGFjdFBvaW50Qi52YWRkKGMucmosIGF2ZXJhZ2VDb250YWN0UG9pbnRCKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF2ZXJhZ2VOb3JtYWwudnN1YihjLm5pLCBhdmVyYWdlTm9ybWFsKTsgLy8gdmVjMi5zdWIoZXEudCwgZXEudCwgYy5ub3JtYWxBKTtcbiAgICAgICAgICAgIGF2ZXJhZ2VDb250YWN0UG9pbnRBLnZhZGQoYy5yaiwgYXZlcmFnZUNvbnRhY3RQb2ludEEpOyAvLyB2ZWMyLmFkZChlcS5jb250YWN0UG9pbnRBLCBlcS5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEpO1xuICAgICAgICAgICAgYXZlcmFnZUNvbnRhY3RQb2ludEIudmFkZChjLnJpLCBhdmVyYWdlQ29udGFjdFBvaW50Qik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaW52TnVtQ29udGFjdHMgPSAxIC8gbnVtQ29udGFjdHM7XG4gICAgYXZlcmFnZUNvbnRhY3RQb2ludEEuc2NhbGUoaW52TnVtQ29udGFjdHMsIGYxLnJpKTsgLy8gdmVjMi5zY2FsZShlcS5jb250YWN0UG9pbnRBLCBlcS5jb250YWN0UG9pbnRBLCBpbnZOdW1Db250YWN0cyk7XG4gICAgYXZlcmFnZUNvbnRhY3RQb2ludEIuc2NhbGUoaW52TnVtQ29udGFjdHMsIGYxLnJqKTsgLy8gdmVjMi5zY2FsZShlcS5jb250YWN0UG9pbnRCLCBlcS5jb250YWN0UG9pbnRCLCBpbnZOdW1Db250YWN0cyk7XG4gICAgZjIucmkuY29weShmMS5yaSk7IC8vIFNob3VsZCBiZSB0aGUgc2FtZVxuICAgIGYyLnJqLmNvcHkoZjEucmopO1xuICAgIGF2ZXJhZ2VOb3JtYWwubm9ybWFsaXplKCk7XG4gICAgYXZlcmFnZU5vcm1hbC50YW5nZW50cyhmMS50LCBmMi50KTtcbiAgICAvLyByZXR1cm4gZXE7XG59O1xuXG5cbnZhciB0bXBWZWMxID0gbmV3IFZlYzMoKTtcbnZhciB0bXBWZWMyID0gbmV3IFZlYzMoKTtcbnZhciB0bXBRdWF0MSA9IG5ldyBRdWF0ZXJuaW9uKCk7XG52YXIgdG1wUXVhdDIgPSBuZXcgUXVhdGVybmlvbigpO1xuXG4vKipcbiAqIEdlbmVyYXRlIGFsbCBjb250YWN0cyBiZXR3ZWVuIGEgbGlzdCBvZiBib2R5IHBhaXJzXG4gKiBAbWV0aG9kIGdldENvbnRhY3RzXG4gKiBAcGFyYW0ge2FycmF5fSBwMSBBcnJheSBvZiBib2R5IGluZGljZXNcbiAqIEBwYXJhbSB7YXJyYXl9IHAyIEFycmF5IG9mIGJvZHkgaW5kaWNlc1xuICogQHBhcmFtIHtXb3JsZH0gd29ybGRcbiAqIEBwYXJhbSB7YXJyYXl9IHJlc3VsdCBBcnJheSB0byBzdG9yZSBnZW5lcmF0ZWQgY29udGFjdHNcbiAqIEBwYXJhbSB7YXJyYXl9IG9sZGNvbnRhY3RzIE9wdGlvbmFsLiBBcnJheSBvZiByZXVzYWJsZSBjb250YWN0IG9iamVjdHNcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlLmdldENvbnRhY3RzID0gZnVuY3Rpb24ocDEsIHAyLCB3b3JsZCwgcmVzdWx0LCBvbGRjb250YWN0cywgZnJpY3Rpb25SZXN1bHQsIGZyaWN0aW9uUG9vbCl7XG4gICAgLy8gU2F2ZSBvbGQgY29udGFjdCBvYmplY3RzXG4gICAgdGhpcy5jb250YWN0UG9pbnRQb29sID0gb2xkY29udGFjdHM7XG4gICAgdGhpcy5mcmljdGlvbkVxdWF0aW9uUG9vbCA9IGZyaWN0aW9uUG9vbDtcbiAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICB0aGlzLmZyaWN0aW9uUmVzdWx0ID0gZnJpY3Rpb25SZXN1bHQ7XG5cbiAgICB2YXIgcWkgPSB0bXBRdWF0MTtcbiAgICB2YXIgcWogPSB0bXBRdWF0MjtcbiAgICB2YXIgeGkgPSB0bXBWZWMxO1xuICAgIHZhciB4aiA9IHRtcFZlYzI7XG5cbiAgICBmb3IodmFyIGs9MCwgTj1wMS5sZW5ndGg7IGshPT1OOyBrKyspe1xuXG4gICAgICAgIC8vIEdldCBjdXJyZW50IGNvbGxpc2lvbiBib2RpZXNcbiAgICAgICAgdmFyIGJpID0gcDFba10sXG4gICAgICAgICAgICBiaiA9IHAyW2tdO1xuXG4gICAgICAgIC8vIEdldCBjb250YWN0IG1hdGVyaWFsXG4gICAgICAgIHZhciBib2R5Q29udGFjdE1hdGVyaWFsID0gbnVsbDtcbiAgICAgICAgaWYoYmkubWF0ZXJpYWwgJiYgYmoubWF0ZXJpYWwpe1xuICAgICAgICAgICAgYm9keUNvbnRhY3RNYXRlcmlhbCA9IHdvcmxkLmdldENvbnRhY3RNYXRlcmlhbChiaS5tYXRlcmlhbCxiai5tYXRlcmlhbCkgfHwgbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmkuc2hhcGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBiaS5xdWF0ZXJuaW9uLm11bHQoYmkuc2hhcGVPcmllbnRhdGlvbnNbaV0sIHFpKTtcbiAgICAgICAgICAgIGJpLnF1YXRlcm5pb24udm11bHQoYmkuc2hhcGVPZmZzZXRzW2ldLCB4aSk7XG4gICAgICAgICAgICB4aS52YWRkKGJpLnBvc2l0aW9uLCB4aSk7XG4gICAgICAgICAgICB2YXIgc2kgPSBiaS5zaGFwZXNbaV07XG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYmouc2hhcGVzLmxlbmd0aDsgaisrKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIHdvcmxkIHRyYW5zZm9ybSBvZiBzaGFwZXNcbiAgICAgICAgICAgICAgICBiai5xdWF0ZXJuaW9uLm11bHQoYmouc2hhcGVPcmllbnRhdGlvbnNbal0sIHFqKTtcbiAgICAgICAgICAgICAgICBiai5xdWF0ZXJuaW9uLnZtdWx0KGJqLnNoYXBlT2Zmc2V0c1tqXSwgeGopO1xuICAgICAgICAgICAgICAgIHhqLnZhZGQoYmoucG9zaXRpb24sIHhqKTtcbiAgICAgICAgICAgICAgICB2YXIgc2ogPSBiai5zaGFwZXNbal07XG5cbiAgICAgICAgICAgICAgICBpZih4aS5kaXN0YW5jZVRvKHhqKSA+IHNpLmJvdW5kaW5nU3BoZXJlUmFkaXVzICsgc2ouYm91bmRpbmdTcGhlcmVSYWRpdXMpe1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgY29sbGlzaW9uIG1hdGVyaWFsXG4gICAgICAgICAgICAgICAgdmFyIHNoYXBlQ29udGFjdE1hdGVyaWFsID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZihzaS5tYXRlcmlhbCAmJiBzai5tYXRlcmlhbCl7XG4gICAgICAgICAgICAgICAgICAgIHNoYXBlQ29udGFjdE1hdGVyaWFsID0gd29ybGQuZ2V0Q29udGFjdE1hdGVyaWFsKHNpLm1hdGVyaWFsLHNqLm1hdGVyaWFsKSB8fCBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudENvbnRhY3RNYXRlcmlhbCA9IHNoYXBlQ29udGFjdE1hdGVyaWFsIHx8IGJvZHlDb250YWN0TWF0ZXJpYWwgfHwgd29ybGQuZGVmYXVsdENvbnRhY3RNYXRlcmlhbDtcblxuICAgICAgICAgICAgICAgIC8vIEdldCBjb250YWN0c1xuICAgICAgICAgICAgICAgIHZhciByZXNvbHZlciA9IHRoaXNbc2kudHlwZSB8IHNqLnR5cGVdO1xuICAgICAgICAgICAgICAgIGlmKHJlc29sdmVyKXtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpLnR5cGUgPCBzai50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlci5jYWxsKHRoaXMsIHNpLCBzaiwgeGksIHhqLCBxaSwgcWosIGJpLCBiaiwgc2ksIHNqKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVyLmNhbGwodGhpcywgc2osIHNpLCB4aiwgeGksIHFqLCBxaSwgYmosIGJpLCBzaSwgc2opO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIG51bVdhcm5pbmdzID0gMDtcbnZhciBtYXhXYXJuaW5ncyA9IDEwO1xuXG5mdW5jdGlvbiB3YXJuKG1zZyl7XG4gICAgaWYobnVtV2FybmluZ3MgPiBtYXhXYXJuaW5ncyl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBudW1XYXJuaW5ncysrO1xuXG4gICAgY29uc29sZS53YXJuKG1zZyk7XG59XG5cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5CT1ggfCBTaGFwZS50eXBlcy5CT1hdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5ib3hCb3ggPSBmdW5jdGlvbihzaSxzaix4aSx4aixxaSxxaixiaSxiail7XG4gICAgc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLm1hdGVyaWFsID0gc2kubWF0ZXJpYWw7XG4gICAgc2ouY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLm1hdGVyaWFsID0gc2oubWF0ZXJpYWw7XG4gICAgc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLmNvbGxpc2lvblJlc3BvbnNlID0gc2kuY29sbGlzaW9uUmVzcG9uc2U7XG4gICAgc2ouY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLmNvbGxpc2lvblJlc3BvbnNlID0gc2ouY29sbGlzaW9uUmVzcG9uc2U7XG4gICAgdGhpcy5jb252ZXhDb252ZXgoc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLHNqLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbix4aSx4aixxaSxxaixiaSxiaixzaSxzaik7XG59O1xuXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuQk9YIHwgU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTl0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmJveENvbnZleCA9IGZ1bmN0aW9uKHNpLHNqLHhpLHhqLHFpLHFqLGJpLGJqKXtcbiAgICBzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24ubWF0ZXJpYWwgPSBzaS5tYXRlcmlhbDtcbiAgICBzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24uY29sbGlzaW9uUmVzcG9uc2UgPSBzaS5jb2xsaXNpb25SZXNwb25zZTtcbiAgICB0aGlzLmNvbnZleENvbnZleChzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24sc2oseGkseGoscWkscWosYmksYmosc2ksc2opO1xufTtcblxuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLnR5cGVzLkJPWCB8IFNoYXBlLnR5cGVzLlBBUlRJQ0xFXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuYm94UGFydGljbGUgPSBmdW5jdGlvbihzaSxzaix4aSx4aixxaSxxaixiaSxiail7XG4gICAgc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLm1hdGVyaWFsID0gc2kubWF0ZXJpYWw7XG4gICAgc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLmNvbGxpc2lvblJlc3BvbnNlID0gc2kuY29sbGlzaW9uUmVzcG9uc2U7XG4gICAgdGhpcy5jb252ZXhQYXJ0aWNsZShzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24sc2oseGkseGoscWkscWosYmksYmosc2ksc2opO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHNwaGVyZVNwaGVyZVxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2lcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNqXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4aVxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGpcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFpXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxalxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmlcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJqXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5TUEhFUkVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5zcGhlcmVTcGhlcmUgPSBmdW5jdGlvbihzaSxzaix4aSx4aixxaSxxaixiaSxiail7XG4gICAgLy8gV2Ugd2lsbCBoYXZlIG9ubHkgb25lIGNvbnRhY3QgaW4gdGhpcyBjYXNlXG4gICAgdmFyIHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSxiaixzaSxzaik7XG5cbiAgICAvLyBDb250YWN0IG5vcm1hbFxuICAgIHhqLnZzdWIoeGksIHIubmkpO1xuICAgIHIubmkubm9ybWFsaXplKCk7XG5cbiAgICAvLyBDb250YWN0IHBvaW50IGxvY2F0aW9uc1xuICAgIHIucmkuY29weShyLm5pKTtcbiAgICByLnJqLmNvcHkoci5uaSk7XG4gICAgci5yaS5tdWx0KHNpLnJhZGl1cywgci5yaSk7XG4gICAgci5yai5tdWx0KC1zai5yYWRpdXMsIHIucmopO1xuXG4gICAgci5yaS52YWRkKHhpLCByLnJpKTtcbiAgICByLnJpLnZzdWIoYmkucG9zaXRpb24sIHIucmkpO1xuXG4gICAgci5yai52YWRkKHhqLCByLnJqKTtcbiAgICByLnJqLnZzdWIoYmoucG9zaXRpb24sIHIucmopO1xuXG4gICAgdGhpcy5yZXN1bHQucHVzaChyKTtcblxuICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBwbGFuZVRyaW1lc2hcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNpXG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzalxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGlcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhqXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxaVxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWpcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJpXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBialxuICovXG52YXIgcGxhbmVUcmltZXNoX25vcm1hbCA9IG5ldyBWZWMzKCk7XG52YXIgcGxhbmVUcmltZXNoX3JlbHBvcyA9IG5ldyBWZWMzKCk7XG52YXIgcGxhbmVUcmltZXNoX3Byb2plY3RlZCA9IG5ldyBWZWMzKCk7XG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuUExBTkUgfCBTaGFwZS50eXBlcy5UUklNRVNIXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUucGxhbmVUcmltZXNoID0gZnVuY3Rpb24oXG4gICAgcGxhbmVTaGFwZSxcbiAgICB0cmltZXNoU2hhcGUsXG4gICAgcGxhbmVQb3MsXG4gICAgdHJpbWVzaFBvcyxcbiAgICBwbGFuZVF1YXQsXG4gICAgdHJpbWVzaFF1YXQsXG4gICAgcGxhbmVCb2R5LFxuICAgIHRyaW1lc2hCb2R5XG4pe1xuICAgIC8vIE1ha2UgY29udGFjdHMhXG4gICAgdmFyIHYgPSBuZXcgVmVjMygpO1xuXG4gICAgdmFyIG5vcm1hbCA9IHBsYW5lVHJpbWVzaF9ub3JtYWw7XG4gICAgbm9ybWFsLnNldCgwLDAsMSk7XG4gICAgcGxhbmVRdWF0LnZtdWx0KG5vcm1hbCxub3JtYWwpOyAvLyBUdXJuIG5vcm1hbCBhY2NvcmRpbmcgdG8gcGxhbmVcblxuICAgIGZvcih2YXIgaT0wOyBpPHRyaW1lc2hTaGFwZS52ZXJ0aWNlcy5sZW5ndGggLyAzOyBpKyspe1xuXG4gICAgICAgIC8vIEdldCB3b3JsZCB2ZXJ0ZXggZnJvbSB0cmltZXNoXG4gICAgICAgIHRyaW1lc2hTaGFwZS5nZXRWZXJ0ZXgoaSwgdik7XG5cbiAgICAgICAgLy8gU2FmZSB1cFxuICAgICAgICB2YXIgdjIgPSBuZXcgVmVjMygpO1xuICAgICAgICB2Mi5jb3B5KHYpO1xuICAgICAgICBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUodHJpbWVzaFBvcywgdHJpbWVzaFF1YXQsIHYyLCB2KTtcblxuICAgICAgICAvLyBDaGVjayBwbGFuZSBzaWRlXG4gICAgICAgIHZhciByZWxwb3MgPSBwbGFuZVRyaW1lc2hfcmVscG9zO1xuICAgICAgICB2LnZzdWIocGxhbmVQb3MsIHJlbHBvcyk7XG4gICAgICAgIHZhciBkb3QgPSBub3JtYWwuZG90KHJlbHBvcyk7XG5cbiAgICAgICAgaWYoZG90IDw9IDAuMCl7XG4gICAgICAgICAgICB2YXIgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKHBsYW5lQm9keSx0cmltZXNoQm9keSxwbGFuZVNoYXBlLHRyaW1lc2hTaGFwZSk7XG5cbiAgICAgICAgICAgIHIubmkuY29weShub3JtYWwpOyAvLyBDb250YWN0IG5vcm1hbCBpcyB0aGUgcGxhbmUgbm9ybWFsXG5cbiAgICAgICAgICAgIC8vIEdldCB2ZXJ0ZXggcG9zaXRpb24gcHJvamVjdGVkIG9uIHBsYW5lXG4gICAgICAgICAgICB2YXIgcHJvamVjdGVkID0gcGxhbmVUcmltZXNoX3Byb2plY3RlZDtcbiAgICAgICAgICAgIG5vcm1hbC5zY2FsZShyZWxwb3MuZG90KG5vcm1hbCksIHByb2plY3RlZCk7XG4gICAgICAgICAgICB2LnZzdWIocHJvamVjdGVkLHByb2plY3RlZCk7XG5cbiAgICAgICAgICAgIC8vIHJpIGlzIHRoZSBwcm9qZWN0ZWQgd29ybGQgcG9zaXRpb24gbWludXMgcGxhbmUgcG9zaXRpb25cbiAgICAgICAgICAgIHIucmkuY29weShwcm9qZWN0ZWQpO1xuICAgICAgICAgICAgci5yaS52c3ViKHBsYW5lQm9keS5wb3NpdGlvbiwgci5yaSk7XG5cbiAgICAgICAgICAgIHIucmouY29weSh2KTtcbiAgICAgICAgICAgIHIucmoudnN1Yih0cmltZXNoQm9keS5wb3NpdGlvbiwgci5yaik7XG5cbiAgICAgICAgICAgIC8vIFN0b3JlIHJlc3VsdFxuICAgICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogQG1ldGhvZCBzcGhlcmVUcmltZXNoXG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzcGhlcmVTaGFwZVxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgdHJpbWVzaFNoYXBlXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICBzcGhlcmVQb3NcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHRyaW1lc2hQb3NcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHNwaGVyZVF1YXRcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHRyaW1lc2hRdWF0XG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBzcGhlcmVCb2R5XG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICB0cmltZXNoQm9keVxuICovXG52YXIgc3BoZXJlVHJpbWVzaF9ub3JtYWwgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZVRyaW1lc2hfcmVscG9zID0gbmV3IFZlYzMoKTtcbnZhciBzcGhlcmVUcmltZXNoX3Byb2plY3RlZCA9IG5ldyBWZWMzKCk7XG52YXIgc3BoZXJlVHJpbWVzaF92ID0gbmV3IFZlYzMoKTtcbnZhciBzcGhlcmVUcmltZXNoX3YyID0gbmV3IFZlYzMoKTtcbnZhciBzcGhlcmVUcmltZXNoX2VkZ2VWZXJ0ZXhBID0gbmV3IFZlYzMoKTtcbnZhciBzcGhlcmVUcmltZXNoX2VkZ2VWZXJ0ZXhCID0gbmV3IFZlYzMoKTtcbnZhciBzcGhlcmVUcmltZXNoX2VkZ2VWZWN0b3IgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZVRyaW1lc2hfZWRnZVZlY3RvclVuaXQgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZVRyaW1lc2hfbG9jYWxTcGhlcmVQb3MgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZVRyaW1lc2hfdG1wID0gbmV3IFZlYzMoKTtcbnZhciBzcGhlcmVUcmltZXNoX3ZhID0gbmV3IFZlYzMoKTtcbnZhciBzcGhlcmVUcmltZXNoX3ZiID0gbmV3IFZlYzMoKTtcbnZhciBzcGhlcmVUcmltZXNoX3ZjID0gbmV3IFZlYzMoKTtcbnZhciBzcGhlcmVUcmltZXNoX2xvY2FsU3BoZXJlQUFCQiA9IG5ldyBBQUJCKCk7XG52YXIgc3BoZXJlVHJpbWVzaF90cmlhbmdsZXMgPSBbXTtcbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5TUEhFUkUgfCBTaGFwZS50eXBlcy5UUklNRVNIXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuc3BoZXJlVHJpbWVzaCA9IGZ1bmN0aW9uIChcbiAgICBzcGhlcmVTaGFwZSxcbiAgICB0cmltZXNoU2hhcGUsXG4gICAgc3BoZXJlUG9zLFxuICAgIHRyaW1lc2hQb3MsXG4gICAgc3BoZXJlUXVhdCxcbiAgICB0cmltZXNoUXVhdCxcbiAgICBzcGhlcmVCb2R5LFxuICAgIHRyaW1lc2hCb2R5XG4pIHtcblxuICAgIHZhciBlZGdlVmVydGV4QSA9IHNwaGVyZVRyaW1lc2hfZWRnZVZlcnRleEE7XG4gICAgdmFyIGVkZ2VWZXJ0ZXhCID0gc3BoZXJlVHJpbWVzaF9lZGdlVmVydGV4QjtcbiAgICB2YXIgZWRnZVZlY3RvciA9IHNwaGVyZVRyaW1lc2hfZWRnZVZlY3RvcjtcbiAgICB2YXIgZWRnZVZlY3RvclVuaXQgPSBzcGhlcmVUcmltZXNoX2VkZ2VWZWN0b3JVbml0O1xuICAgIHZhciBsb2NhbFNwaGVyZVBvcyA9IHNwaGVyZVRyaW1lc2hfbG9jYWxTcGhlcmVQb3M7XG4gICAgdmFyIHRtcCA9IHNwaGVyZVRyaW1lc2hfdG1wO1xuICAgIHZhciBsb2NhbFNwaGVyZUFBQkIgPSBzcGhlcmVUcmltZXNoX2xvY2FsU3BoZXJlQUFCQjtcbiAgICB2YXIgdjIgPSBzcGhlcmVUcmltZXNoX3YyO1xuICAgIHZhciByZWxwb3MgPSBzcGhlcmVUcmltZXNoX3JlbHBvcztcbiAgICB2YXIgdHJpYW5nbGVzID0gc3BoZXJlVHJpbWVzaF90cmlhbmdsZXM7XG5cbiAgICAvLyBDb252ZXJ0IHNwaGVyZSBwb3NpdGlvbiB0byBsb2NhbCBpbiB0aGUgdHJpbWVzaFxuICAgIFRyYW5zZm9ybS5wb2ludFRvTG9jYWxGcmFtZSh0cmltZXNoUG9zLCB0cmltZXNoUXVhdCwgc3BoZXJlUG9zLCBsb2NhbFNwaGVyZVBvcyk7XG5cbiAgICAvLyBHZXQgdGhlIGFhYmIgb2YgdGhlIHNwaGVyZSBsb2NhbGx5IGluIHRoZSB0cmltZXNoXG4gICAgdmFyIHNwaGVyZVJhZGl1cyA9IHNwaGVyZVNoYXBlLnJhZGl1cztcbiAgICBsb2NhbFNwaGVyZUFBQkIubG93ZXJCb3VuZC5zZXQoXG4gICAgICAgIGxvY2FsU3BoZXJlUG9zLnggLSBzcGhlcmVSYWRpdXMsXG4gICAgICAgIGxvY2FsU3BoZXJlUG9zLnkgLSBzcGhlcmVSYWRpdXMsXG4gICAgICAgIGxvY2FsU3BoZXJlUG9zLnogLSBzcGhlcmVSYWRpdXNcbiAgICApO1xuICAgIGxvY2FsU3BoZXJlQUFCQi51cHBlckJvdW5kLnNldChcbiAgICAgICAgbG9jYWxTcGhlcmVQb3MueCArIHNwaGVyZVJhZGl1cyxcbiAgICAgICAgbG9jYWxTcGhlcmVQb3MueSArIHNwaGVyZVJhZGl1cyxcbiAgICAgICAgbG9jYWxTcGhlcmVQb3MueiArIHNwaGVyZVJhZGl1c1xuICAgICk7XG5cbiAgICB0cmltZXNoU2hhcGUuZ2V0VHJpYW5nbGVzSW5BQUJCKGxvY2FsU3BoZXJlQUFCQiwgdHJpYW5nbGVzKTtcbiAgICAvL2ZvciAodmFyIGkgPSAwOyBpIDwgdHJpbWVzaFNoYXBlLmluZGljZXMubGVuZ3RoIC8gMzsgaSsrKSB0cmlhbmdsZXMucHVzaChpKTsgLy8gQWxsXG5cbiAgICAvLyBWZXJ0aWNlc1xuICAgIHZhciB2ID0gc3BoZXJlVHJpbWVzaF92O1xuICAgIHZhciByYWRpdXNTcXVhcmVkID0gc3BoZXJlU2hhcGUucmFkaXVzICogc3BoZXJlU2hhcGUucmFkaXVzO1xuICAgIGZvcih2YXIgaT0wOyBpPHRyaWFuZ2xlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgMzsgaisrKSB7XG5cbiAgICAgICAgICAgIHRyaW1lc2hTaGFwZS5nZXRWZXJ0ZXgodHJpbWVzaFNoYXBlLmluZGljZXNbdHJpYW5nbGVzW2ldICogMyArIGpdLCB2KTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgdmVydGV4IG92ZXJsYXAgaW4gc3BoZXJlXG4gICAgICAgICAgICB2LnZzdWIobG9jYWxTcGhlcmVQb3MsIHJlbHBvcyk7XG5cbiAgICAgICAgICAgIGlmKHJlbHBvcy5ub3JtMigpIDw9IHJhZGl1c1NxdWFyZWQpe1xuXG4gICAgICAgICAgICAgICAgLy8gU2FmZSB1cFxuICAgICAgICAgICAgICAgIHYyLmNvcHkodik7XG4gICAgICAgICAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKHRyaW1lc2hQb3MsIHRyaW1lc2hRdWF0LCB2Miwgdik7XG5cbiAgICAgICAgICAgICAgICB2LnZzdWIoc3BoZXJlUG9zLCByZWxwb3MpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihzcGhlcmVCb2R5LHRyaW1lc2hCb2R5LHNwaGVyZVNoYXBlLHRyaW1lc2hTaGFwZSk7XG4gICAgICAgICAgICAgICAgci5uaS5jb3B5KHJlbHBvcyk7XG4gICAgICAgICAgICAgICAgci5uaS5ub3JtYWxpemUoKTtcblxuICAgICAgICAgICAgICAgIC8vIHJpIGlzIHRoZSB2ZWN0b3IgZnJvbSBzcGhlcmUgY2VudGVyIHRvIHRoZSBzcGhlcmUgc3VyZmFjZVxuICAgICAgICAgICAgICAgIHIucmkuY29weShyLm5pKTtcbiAgICAgICAgICAgICAgICByLnJpLnNjYWxlKHNwaGVyZVNoYXBlLnJhZGl1cywgci5yaSk7XG4gICAgICAgICAgICAgICAgci5yaS52YWRkKHNwaGVyZVBvcywgci5yaSk7XG4gICAgICAgICAgICAgICAgci5yaS52c3ViKHNwaGVyZUJvZHkucG9zaXRpb24sIHIucmkpO1xuXG4gICAgICAgICAgICAgICAgci5yai5jb3B5KHYpO1xuICAgICAgICAgICAgICAgIHIucmoudnN1Yih0cmltZXNoQm9keS5wb3NpdGlvbiwgci5yaik7XG5cbiAgICAgICAgICAgICAgICAvLyBTdG9yZSByZXN1bHRcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGFsbCBlZGdlc1xuICAgIGZvcih2YXIgaT0wOyBpPHRyaWFuZ2xlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgMzsgaisrKSB7XG5cbiAgICAgICAgICAgIHRyaW1lc2hTaGFwZS5nZXRWZXJ0ZXgodHJpbWVzaFNoYXBlLmluZGljZXNbdHJpYW5nbGVzW2ldICogMyArIGpdLCBlZGdlVmVydGV4QSk7XG4gICAgICAgICAgICB0cmltZXNoU2hhcGUuZ2V0VmVydGV4KHRyaW1lc2hTaGFwZS5pbmRpY2VzW3RyaWFuZ2xlc1tpXSAqIDMgKyAoKGorMSklMyldLCBlZGdlVmVydGV4Qik7XG4gICAgICAgICAgICBlZGdlVmVydGV4Qi52c3ViKGVkZ2VWZXJ0ZXhBLCBlZGdlVmVjdG9yKTtcblxuICAgICAgICAgICAgLy8gUHJvamVjdCBzcGhlcmUgcG9zaXRpb24gdG8gdGhlIGVkZ2VcbiAgICAgICAgICAgIGxvY2FsU3BoZXJlUG9zLnZzdWIoZWRnZVZlcnRleEIsIHRtcCk7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb25BbG9uZ0VkZ2VCID0gdG1wLmRvdChlZGdlVmVjdG9yKTtcblxuICAgICAgICAgICAgbG9jYWxTcGhlcmVQb3MudnN1YihlZGdlVmVydGV4QSwgdG1wKTtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbkFsb25nRWRnZUEgPSB0bXAuZG90KGVkZ2VWZWN0b3IpO1xuXG4gICAgICAgICAgICBpZihwb3NpdGlvbkFsb25nRWRnZUEgPiAwICYmIHBvc2l0aW9uQWxvbmdFZGdlQiA8IDApe1xuXG4gICAgICAgICAgICAgICAgLy8gTm93IGNoZWNrIHRoZSBvcnRob2dvbmFsIGRpc3RhbmNlIGZyb20gZWRnZSB0byBzcGhlcmUgY2VudGVyXG4gICAgICAgICAgICAgICAgbG9jYWxTcGhlcmVQb3MudnN1YihlZGdlVmVydGV4QSwgdG1wKTtcblxuICAgICAgICAgICAgICAgIGVkZ2VWZWN0b3JVbml0LmNvcHkoZWRnZVZlY3Rvcik7XG4gICAgICAgICAgICAgICAgZWRnZVZlY3RvclVuaXQubm9ybWFsaXplKCk7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25BbG9uZ0VkZ2VBID0gdG1wLmRvdChlZGdlVmVjdG9yVW5pdCk7XG5cbiAgICAgICAgICAgICAgICBlZGdlVmVjdG9yVW5pdC5zY2FsZShwb3NpdGlvbkFsb25nRWRnZUEsIHRtcCk7XG4gICAgICAgICAgICAgICAgdG1wLnZhZGQoZWRnZVZlcnRleEEsIHRtcCk7XG5cbiAgICAgICAgICAgICAgICAvLyB0bXAgaXMgbm93IHRoZSBzcGhlcmUgY2VudGVyIHBvc2l0aW9uIHByb2plY3RlZCB0byB0aGUgZWRnZSwgZGVmaW5lZCBsb2NhbGx5IGluIHRoZSB0cmltZXNoIGZyYW1lXG4gICAgICAgICAgICAgICAgdmFyIGRpc3QgPSB0bXAuZGlzdGFuY2VUbyhsb2NhbFNwaGVyZVBvcyk7XG4gICAgICAgICAgICAgICAgaWYoZGlzdCA8IHNwaGVyZVNoYXBlLnJhZGl1cyl7XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oc3BoZXJlQm9keSwgdHJpbWVzaEJvZHksIHNwaGVyZVNoYXBlLCB0cmltZXNoU2hhcGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRtcC52c3ViKGxvY2FsU3BoZXJlUG9zLCByLm5pKTtcbiAgICAgICAgICAgICAgICAgICAgci5uaS5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgci5uaS5zY2FsZShzcGhlcmVTaGFwZS5yYWRpdXMsIHIucmkpO1xuXG4gICAgICAgICAgICAgICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZSh0cmltZXNoUG9zLCB0cmltZXNoUXVhdCwgdG1wLCB0bXApO1xuICAgICAgICAgICAgICAgICAgICB0bXAudnN1Yih0cmltZXNoQm9keS5wb3NpdGlvbiwgci5yaik7XG5cbiAgICAgICAgICAgICAgICAgICAgVHJhbnNmb3JtLnZlY3RvclRvV29ybGRGcmFtZSh0cmltZXNoUXVhdCwgci5uaSwgci5uaSk7XG4gICAgICAgICAgICAgICAgICAgIFRyYW5zZm9ybS52ZWN0b3JUb1dvcmxkRnJhbWUodHJpbWVzaFF1YXQsIHIucmksIHIucmkpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUcmlhbmdsZSBmYWNlc1xuICAgIHZhciB2YSA9IHNwaGVyZVRyaW1lc2hfdmE7XG4gICAgdmFyIHZiID0gc3BoZXJlVHJpbWVzaF92YjtcbiAgICB2YXIgdmMgPSBzcGhlcmVUcmltZXNoX3ZjO1xuICAgIHZhciBub3JtYWwgPSBzcGhlcmVUcmltZXNoX25vcm1hbDtcbiAgICBmb3IodmFyIGk9MCwgTiA9IHRyaWFuZ2xlcy5sZW5ndGg7IGkgIT09IE47IGkrKyl7XG4gICAgICAgIHRyaW1lc2hTaGFwZS5nZXRUcmlhbmdsZVZlcnRpY2VzKHRyaWFuZ2xlc1tpXSwgdmEsIHZiLCB2Yyk7XG4gICAgICAgIHRyaW1lc2hTaGFwZS5nZXROb3JtYWwodHJpYW5nbGVzW2ldLCBub3JtYWwpO1xuICAgICAgICBsb2NhbFNwaGVyZVBvcy52c3ViKHZhLCB0bXApO1xuICAgICAgICB2YXIgZGlzdCA9IHRtcC5kb3Qobm9ybWFsKTtcbiAgICAgICAgbm9ybWFsLnNjYWxlKGRpc3QsIHRtcCk7XG4gICAgICAgIGxvY2FsU3BoZXJlUG9zLnZzdWIodG1wLCB0bXApO1xuXG4gICAgICAgIC8vIHRtcCBpcyBub3cgdGhlIHNwaGVyZSBwb3NpdGlvbiBwcm9qZWN0ZWQgdG8gdGhlIHRyaWFuZ2xlIHBsYW5lXG4gICAgICAgIGRpc3QgPSB0bXAuZGlzdGFuY2VUbyhsb2NhbFNwaGVyZVBvcyk7XG4gICAgICAgIGlmKFJheS5wb2ludEluVHJpYW5nbGUodG1wLCB2YSwgdmIsIHZjKSAmJiBkaXN0IDwgc3BoZXJlU2hhcGUucmFkaXVzKXtcbiAgICAgICAgICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oc3BoZXJlQm9keSwgdHJpbWVzaEJvZHksIHNwaGVyZVNoYXBlLCB0cmltZXNoU2hhcGUpO1xuXG4gICAgICAgICAgICB0bXAudnN1Yihsb2NhbFNwaGVyZVBvcywgci5uaSk7XG4gICAgICAgICAgICByLm5pLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgci5uaS5zY2FsZShzcGhlcmVTaGFwZS5yYWRpdXMsIHIucmkpO1xuXG4gICAgICAgICAgICBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUodHJpbWVzaFBvcywgdHJpbWVzaFF1YXQsIHRtcCwgdG1wKTtcbiAgICAgICAgICAgIHRtcC52c3ViKHRyaW1lc2hCb2R5LnBvc2l0aW9uLCByLnJqKTtcblxuICAgICAgICAgICAgVHJhbnNmb3JtLnZlY3RvclRvV29ybGRGcmFtZSh0cmltZXNoUXVhdCwgci5uaSwgci5uaSk7XG4gICAgICAgICAgICBUcmFuc2Zvcm0udmVjdG9yVG9Xb3JsZEZyYW1lKHRyaW1lc2hRdWF0LCByLnJpLCByLnJpKTtcblxuICAgICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRyaWFuZ2xlcy5sZW5ndGggPSAwO1xufTtcblxudmFyIHBvaW50X29uX3BsYW5lX3RvX3NwaGVyZSA9IG5ldyBWZWMzKCk7XG52YXIgcGxhbmVfdG9fc3BoZXJlX29ydGhvID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBAbWV0aG9kIHNwaGVyZVBsYW5lXG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzaVxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2pcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhpXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4alxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWlcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFqXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBiaVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmpcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLnR5cGVzLlNQSEVSRSB8IFNoYXBlLnR5cGVzLlBMQU5FXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuc3BoZXJlUGxhbmUgPSBmdW5jdGlvbihzaSxzaix4aSx4aixxaSxxaixiaSxiail7XG4gICAgLy8gV2Ugd2lsbCBoYXZlIG9uZSBjb250YWN0IGluIHRoaXMgY2FzZVxuICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYmksYmosc2ksc2opO1xuXG4gICAgLy8gQ29udGFjdCBub3JtYWxcbiAgICByLm5pLnNldCgwLDAsMSk7XG4gICAgcWoudm11bHQoci5uaSwgci5uaSk7XG4gICAgci5uaS5uZWdhdGUoci5uaSk7IC8vIGJvZHkgaSBpcyB0aGUgc3BoZXJlLCBmbGlwIG5vcm1hbFxuICAgIHIubmkubm9ybWFsaXplKCk7IC8vIE5lZWRlZD9cblxuICAgIC8vIFZlY3RvciBmcm9tIHNwaGVyZSBjZW50ZXIgdG8gY29udGFjdCBwb2ludFxuICAgIHIubmkubXVsdChzaS5yYWRpdXMsIHIucmkpO1xuXG4gICAgLy8gUHJvamVjdCBkb3duIHNwaGVyZSBvbiBwbGFuZVxuICAgIHhpLnZzdWIoeGosIHBvaW50X29uX3BsYW5lX3RvX3NwaGVyZSk7XG4gICAgci5uaS5tdWx0KHIubmkuZG90KHBvaW50X29uX3BsYW5lX3RvX3NwaGVyZSksIHBsYW5lX3RvX3NwaGVyZV9vcnRobyk7XG4gICAgcG9pbnRfb25fcGxhbmVfdG9fc3BoZXJlLnZzdWIocGxhbmVfdG9fc3BoZXJlX29ydGhvLHIucmopOyAvLyBUaGUgc3BoZXJlIHBvc2l0aW9uIHByb2plY3RlZCB0byBwbGFuZVxuXG4gICAgaWYoLXBvaW50X29uX3BsYW5lX3RvX3NwaGVyZS5kb3Qoci5uaSkgPD0gc2kucmFkaXVzKXtcblxuICAgICAgICAvLyBNYWtlIGl0IHJlbGF0aXZlIHRvIHRoZSBib2R5XG4gICAgICAgIHZhciByaSA9IHIucmk7XG4gICAgICAgIHZhciByaiA9IHIucmo7XG4gICAgICAgIHJpLnZhZGQoeGksIHJpKTtcbiAgICAgICAgcmkudnN1YihiaS5wb3NpdGlvbiwgcmkpO1xuICAgICAgICByai52YWRkKHhqLCByaik7XG4gICAgICAgIHJqLnZzdWIoYmoucG9zaXRpb24sIHJqKTtcblxuICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xuICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XG4gICAgfVxufTtcblxuLy8gU2VlIGh0dHA6Ly9idWxsZXRwaHlzaWNzLmNvbS9CdWxsZXQvQnVsbGV0RnVsbC9TcGhlcmVUcmlhbmdsZURldGVjdG9yXzhjcHBfc291cmNlLmh0bWxcbnZhciBwb2ludEluUG9seWdvbl9lZGdlID0gbmV3IFZlYzMoKTtcbnZhciBwb2ludEluUG9seWdvbl9lZGdlX3hfbm9ybWFsID0gbmV3IFZlYzMoKTtcbnZhciBwb2ludEluUG9seWdvbl92dHAgPSBuZXcgVmVjMygpO1xuZnVuY3Rpb24gcG9pbnRJblBvbHlnb24odmVydHMsIG5vcm1hbCwgcCl7XG4gICAgdmFyIHBvc2l0aXZlUmVzdWx0ID0gbnVsbDtcbiAgICB2YXIgTiA9IHZlcnRzLmxlbmd0aDtcbiAgICBmb3IodmFyIGk9MDsgaSE9PU47IGkrKyl7XG4gICAgICAgIHZhciB2ID0gdmVydHNbaV07XG5cbiAgICAgICAgLy8gR2V0IGVkZ2UgdG8gdGhlIG5leHQgdmVydGV4XG4gICAgICAgIHZhciBlZGdlID0gcG9pbnRJblBvbHlnb25fZWRnZTtcbiAgICAgICAgdmVydHNbKGkrMSkgJSAoTildLnZzdWIodixlZGdlKTtcblxuICAgICAgICAvLyBHZXQgY3Jvc3MgcHJvZHVjdCBiZXR3ZWVuIHBvbHlnb24gbm9ybWFsIGFuZCB0aGUgZWRnZVxuICAgICAgICB2YXIgZWRnZV94X25vcm1hbCA9IHBvaW50SW5Qb2x5Z29uX2VkZ2VfeF9ub3JtYWw7XG4gICAgICAgIC8vdmFyIGVkZ2VfeF9ub3JtYWwgPSBuZXcgVmVjMygpO1xuICAgICAgICBlZGdlLmNyb3NzKG5vcm1hbCxlZGdlX3hfbm9ybWFsKTtcblxuICAgICAgICAvLyBHZXQgdmVjdG9yIGJldHdlZW4gcG9pbnQgYW5kIGN1cnJlbnQgdmVydGV4XG4gICAgICAgIHZhciB2ZXJ0ZXhfdG9fcCA9IHBvaW50SW5Qb2x5Z29uX3Z0cDtcbiAgICAgICAgcC52c3ViKHYsdmVydGV4X3RvX3ApO1xuXG4gICAgICAgIC8vIFRoaXMgZG90IHByb2R1Y3QgZGV0ZXJtaW5lcyB3aGljaCBzaWRlIG9mIHRoZSBlZGdlIHRoZSBwb2ludCBpc1xuICAgICAgICB2YXIgciA9IGVkZ2VfeF9ub3JtYWwuZG90KHZlcnRleF90b19wKTtcblxuICAgICAgICAvLyBJZiBhbGwgc3VjaCBkb3QgcHJvZHVjdHMgaGF2ZSBzYW1lIHNpZ24sIHdlIGFyZSBpbnNpZGUgdGhlIHBvbHlnb24uXG4gICAgICAgIGlmKHBvc2l0aXZlUmVzdWx0PT09bnVsbCB8fCAocj4wICYmIHBvc2l0aXZlUmVzdWx0PT09dHJ1ZSkgfHwgKHI8PTAgJiYgcG9zaXRpdmVSZXN1bHQ9PT1mYWxzZSkpe1xuICAgICAgICAgICAgaWYocG9zaXRpdmVSZXN1bHQ9PT1udWxsKXtcbiAgICAgICAgICAgICAgICBwb3NpdGl2ZVJlc3VsdCA9IHI+MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBFbmNvdW50ZXJlZCBzb21lIG90aGVyIHNpZ24uIEV4aXQuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBnb3QgaGVyZSwgYWxsIGRvdCBwcm9kdWN0cyB3ZXJlIG9mIHRoZSBzYW1lIHNpZ24uXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbnZhciBib3hfdG9fc3BoZXJlID0gbmV3IFZlYzMoKTtcbnZhciBzcGhlcmVCb3hfbnMgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZUJveF9uczEgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZUJveF9uczIgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZUJveF9zaWRlcyA9IFtuZXcgVmVjMygpLG5ldyBWZWMzKCksbmV3IFZlYzMoKSxuZXcgVmVjMygpLG5ldyBWZWMzKCksbmV3IFZlYzMoKV07XG52YXIgc3BoZXJlQm94X3NwaGVyZV90b19jb3JuZXIgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZUJveF9zaWRlX25zID0gbmV3IFZlYzMoKTtcbnZhciBzcGhlcmVCb3hfc2lkZV9uczEgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZUJveF9zaWRlX25zMiA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogQG1ldGhvZCBzcGhlcmVCb3hcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNpXG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzalxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGlcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhqXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxaVxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWpcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJpXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBialxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuU1BIRVJFIHwgU2hhcGUudHlwZXMuQk9YXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuc3BoZXJlQm94ID0gZnVuY3Rpb24oc2ksc2oseGkseGoscWkscWosYmksYmope1xuICAgIHZhciB2M3Bvb2wgPSB0aGlzLnYzcG9vbDtcblxuICAgIC8vIHdlIHJlZmVyIHRvIHRoZSBib3ggYXMgYm9keSBqXG4gICAgdmFyIHNpZGVzID0gc3BoZXJlQm94X3NpZGVzO1xuICAgIHhpLnZzdWIoeGosYm94X3RvX3NwaGVyZSk7XG4gICAgc2ouZ2V0U2lkZU5vcm1hbHMoc2lkZXMscWopO1xuICAgIHZhciBSID0gICAgIHNpLnJhZGl1cztcbiAgICB2YXIgcGVuZXRyYXRpbmdfc2lkZXMgPSBbXTtcblxuICAgIC8vIENoZWNrIHNpZGUgKHBsYW5lKSBpbnRlcnNlY3Rpb25zXG4gICAgdmFyIGZvdW5kID0gZmFsc2U7XG5cbiAgICAvLyBTdG9yZSB0aGUgcmVzdWx0aW5nIHNpZGUgcGVuZXRyYXRpb24gaW5mb1xuICAgIHZhciBzaWRlX25zID0gc3BoZXJlQm94X3NpZGVfbnM7XG4gICAgdmFyIHNpZGVfbnMxID0gc3BoZXJlQm94X3NpZGVfbnMxO1xuICAgIHZhciBzaWRlX25zMiA9IHNwaGVyZUJveF9zaWRlX25zMjtcbiAgICB2YXIgc2lkZV9oID0gbnVsbDtcbiAgICB2YXIgc2lkZV9wZW5ldHJhdGlvbnMgPSAwO1xuICAgIHZhciBzaWRlX2RvdDEgPSAwO1xuICAgIHZhciBzaWRlX2RvdDIgPSAwO1xuICAgIHZhciBzaWRlX2Rpc3RhbmNlID0gbnVsbDtcbiAgICBmb3IodmFyIGlkeD0wLG5zaWRlcz1zaWRlcy5sZW5ndGg7IGlkeCE9PW5zaWRlcyAmJiBmb3VuZD09PWZhbHNlOyBpZHgrKyl7XG4gICAgICAgIC8vIEdldCB0aGUgcGxhbmUgc2lkZSBub3JtYWwgKG5zKVxuICAgICAgICB2YXIgbnMgPSBzcGhlcmVCb3hfbnM7XG4gICAgICAgIG5zLmNvcHkoc2lkZXNbaWR4XSk7XG5cbiAgICAgICAgdmFyIGggPSBucy5ub3JtKCk7XG4gICAgICAgIG5zLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgIC8vIFRoZSBub3JtYWwvZGlzdGFuY2UgZG90IHByb2R1Y3QgdGVsbHMgd2hpY2ggc2lkZSBvZiB0aGUgcGxhbmUgd2UgYXJlXG4gICAgICAgIHZhciBkb3QgPSBib3hfdG9fc3BoZXJlLmRvdChucyk7XG5cbiAgICAgICAgaWYoZG90PGgrUiAmJiBkb3Q+MCl7XG4gICAgICAgICAgICAvLyBJbnRlcnNlY3RzIHBsYW5lLiBOb3cgY2hlY2sgdGhlIG90aGVyIHR3byBkaW1lbnNpb25zXG4gICAgICAgICAgICB2YXIgbnMxID0gc3BoZXJlQm94X25zMTtcbiAgICAgICAgICAgIHZhciBuczIgPSBzcGhlcmVCb3hfbnMyO1xuICAgICAgICAgICAgbnMxLmNvcHkoc2lkZXNbKGlkeCsxKSUzXSk7XG4gICAgICAgICAgICBuczIuY29weShzaWRlc1soaWR4KzIpJTNdKTtcbiAgICAgICAgICAgIHZhciBoMSA9IG5zMS5ub3JtKCk7XG4gICAgICAgICAgICB2YXIgaDIgPSBuczIubm9ybSgpO1xuICAgICAgICAgICAgbnMxLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgbnMyLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgdmFyIGRvdDEgPSBib3hfdG9fc3BoZXJlLmRvdChuczEpO1xuICAgICAgICAgICAgdmFyIGRvdDIgPSBib3hfdG9fc3BoZXJlLmRvdChuczIpO1xuICAgICAgICAgICAgaWYoZG90MTxoMSAmJiBkb3QxPi1oMSAmJiBkb3QyPGgyICYmIGRvdDI+LWgyKXtcbiAgICAgICAgICAgICAgICB2YXIgZGlzdCA9IE1hdGguYWJzKGRvdC1oLVIpO1xuICAgICAgICAgICAgICAgIGlmKHNpZGVfZGlzdGFuY2U9PT1udWxsIHx8IGRpc3QgPCBzaWRlX2Rpc3RhbmNlKXtcbiAgICAgICAgICAgICAgICAgICAgc2lkZV9kaXN0YW5jZSA9IGRpc3Q7XG4gICAgICAgICAgICAgICAgICAgIHNpZGVfZG90MSA9IGRvdDE7XG4gICAgICAgICAgICAgICAgICAgIHNpZGVfZG90MiA9IGRvdDI7XG4gICAgICAgICAgICAgICAgICAgIHNpZGVfaCA9IGg7XG4gICAgICAgICAgICAgICAgICAgIHNpZGVfbnMuY29weShucyk7XG4gICAgICAgICAgICAgICAgICAgIHNpZGVfbnMxLmNvcHkobnMxKTtcbiAgICAgICAgICAgICAgICAgICAgc2lkZV9uczIuY29weShuczIpO1xuICAgICAgICAgICAgICAgICAgICBzaWRlX3BlbmV0cmF0aW9ucysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZihzaWRlX3BlbmV0cmF0aW9ucyl7XG4gICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgdmFyIHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSxiaixzaSxzaik7XG4gICAgICAgIHNpZGVfbnMubXVsdCgtUixyLnJpKTsgLy8gU3BoZXJlIHJcbiAgICAgICAgci5uaS5jb3B5KHNpZGVfbnMpO1xuICAgICAgICByLm5pLm5lZ2F0ZShyLm5pKTsgLy8gTm9ybWFsIHNob3VsZCBiZSBvdXQgb2Ygc3BoZXJlXG4gICAgICAgIHNpZGVfbnMubXVsdChzaWRlX2gsc2lkZV9ucyk7XG4gICAgICAgIHNpZGVfbnMxLm11bHQoc2lkZV9kb3QxLHNpZGVfbnMxKTtcbiAgICAgICAgc2lkZV9ucy52YWRkKHNpZGVfbnMxLHNpZGVfbnMpO1xuICAgICAgICBzaWRlX25zMi5tdWx0KHNpZGVfZG90MixzaWRlX25zMik7XG4gICAgICAgIHNpZGVfbnMudmFkZChzaWRlX25zMixyLnJqKTtcblxuICAgICAgICAvLyBNYWtlIHJlbGF0aXZlIHRvIGJvZGllc1xuICAgICAgICByLnJpLnZhZGQoeGksIHIucmkpO1xuICAgICAgICByLnJpLnZzdWIoYmkucG9zaXRpb24sIHIucmkpO1xuICAgICAgICByLnJqLnZhZGQoeGosIHIucmopO1xuICAgICAgICByLnJqLnZzdWIoYmoucG9zaXRpb24sIHIucmopO1xuXG4gICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7XG4gICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBjb3JuZXJzXG4gICAgdmFyIHJqID0gdjNwb29sLmdldCgpO1xuICAgIHZhciBzcGhlcmVfdG9fY29ybmVyID0gc3BoZXJlQm94X3NwaGVyZV90b19jb3JuZXI7XG4gICAgZm9yKHZhciBqPTA7IGohPT0yICYmICFmb3VuZDsgaisrKXtcbiAgICAgICAgZm9yKHZhciBrPTA7IGshPT0yICYmICFmb3VuZDsgaysrKXtcbiAgICAgICAgICAgIGZvcih2YXIgbD0wOyBsIT09MiAmJiAhZm91bmQ7IGwrKyl7XG4gICAgICAgICAgICAgICAgcmouc2V0KDAsMCwwKTtcbiAgICAgICAgICAgICAgICBpZihqKXtcbiAgICAgICAgICAgICAgICAgICAgcmoudmFkZChzaWRlc1swXSxyaik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmoudnN1YihzaWRlc1swXSxyaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKGspe1xuICAgICAgICAgICAgICAgICAgICByai52YWRkKHNpZGVzWzFdLHJqKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByai52c3ViKHNpZGVzWzFdLHJqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYobCl7XG4gICAgICAgICAgICAgICAgICAgIHJqLnZhZGQoc2lkZXNbMl0scmopO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJqLnZzdWIoc2lkZXNbMl0scmopO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFdvcmxkIHBvc2l0aW9uIG9mIGNvcm5lclxuICAgICAgICAgICAgICAgIHhqLnZhZGQocmosc3BoZXJlX3RvX2Nvcm5lcik7XG4gICAgICAgICAgICAgICAgc3BoZXJlX3RvX2Nvcm5lci52c3ViKHhpLHNwaGVyZV90b19jb3JuZXIpO1xuXG4gICAgICAgICAgICAgICAgaWYoc3BoZXJlX3RvX2Nvcm5lci5ub3JtMigpIDwgUipSKXtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLGJqLHNpLHNqKTtcbiAgICAgICAgICAgICAgICAgICAgci5yaS5jb3B5KHNwaGVyZV90b19jb3JuZXIpO1xuICAgICAgICAgICAgICAgICAgICByLnJpLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgICAgICAgICByLm5pLmNvcHkoci5yaSk7XG4gICAgICAgICAgICAgICAgICAgIHIucmkubXVsdChSLHIucmkpO1xuICAgICAgICAgICAgICAgICAgICByLnJqLmNvcHkocmopO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2UgcmVsYXRpdmUgdG8gYm9kaWVzXG4gICAgICAgICAgICAgICAgICAgIHIucmkudmFkZCh4aSwgci5yaSk7XG4gICAgICAgICAgICAgICAgICAgIHIucmkudnN1YihiaS5wb3NpdGlvbiwgci5yaSk7XG4gICAgICAgICAgICAgICAgICAgIHIucmoudmFkZCh4aiwgci5yaik7XG4gICAgICAgICAgICAgICAgICAgIHIucmoudnN1Yihiai5wb3NpdGlvbiwgci5yaik7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHIsIHRoaXMuZnJpY3Rpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2M3Bvb2wucmVsZWFzZShyaik7XG4gICAgcmogPSBudWxsO1xuXG4gICAgLy8gQ2hlY2sgZWRnZXNcbiAgICB2YXIgZWRnZVRhbmdlbnQgPSB2M3Bvb2wuZ2V0KCk7XG4gICAgdmFyIGVkZ2VDZW50ZXIgPSB2M3Bvb2wuZ2V0KCk7XG4gICAgdmFyIHIgPSB2M3Bvb2wuZ2V0KCk7IC8vIHIgPSBlZGdlIGNlbnRlciB0byBzcGhlcmUgY2VudGVyXG4gICAgdmFyIG9ydGhvZ29uYWwgPSB2M3Bvb2wuZ2V0KCk7XG4gICAgdmFyIGRpc3QgPSB2M3Bvb2wuZ2V0KCk7XG4gICAgdmFyIE5zaWRlcyA9IHNpZGVzLmxlbmd0aDtcbiAgICBmb3IodmFyIGo9MDsgaiE9PU5zaWRlcyAmJiAhZm91bmQ7IGorKyl7XG4gICAgICAgIGZvcih2YXIgaz0wOyBrIT09TnNpZGVzICYmICFmb3VuZDsgaysrKXtcbiAgICAgICAgICAgIGlmKGolMyAhPT0gayUzKXtcbiAgICAgICAgICAgICAgICAvLyBHZXQgZWRnZSB0YW5nZW50XG4gICAgICAgICAgICAgICAgc2lkZXNba10uY3Jvc3Moc2lkZXNbal0sZWRnZVRhbmdlbnQpO1xuICAgICAgICAgICAgICAgIGVkZ2VUYW5nZW50Lm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgICAgIHNpZGVzW2pdLnZhZGQoc2lkZXNba10sIGVkZ2VDZW50ZXIpO1xuICAgICAgICAgICAgICAgIHIuY29weSh4aSk7XG4gICAgICAgICAgICAgICAgci52c3ViKGVkZ2VDZW50ZXIscik7XG4gICAgICAgICAgICAgICAgci52c3ViKHhqLHIpO1xuICAgICAgICAgICAgICAgIHZhciBvcnRob25vcm0gPSByLmRvdChlZGdlVGFuZ2VudCk7IC8vIGRpc3RhbmNlIGZyb20gZWRnZSBjZW50ZXIgdG8gc3BoZXJlIGNlbnRlciBpbiB0aGUgdGFuZ2VudCBkaXJlY3Rpb25cbiAgICAgICAgICAgICAgICBlZGdlVGFuZ2VudC5tdWx0KG9ydGhvbm9ybSxvcnRob2dvbmFsKTsgLy8gVmVjdG9yIGZyb20gZWRnZSBjZW50ZXIgdG8gc3BoZXJlIGNlbnRlciBpbiB0aGUgdGFuZ2VudCBkaXJlY3Rpb25cblxuICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIHRoaXJkIHNpZGUgb3J0aG9nb25hbCB0byB0aGlzIG9uZVxuICAgICAgICAgICAgICAgIHZhciBsID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZShsPT09aiUzIHx8IGw9PT1rJTMpe1xuICAgICAgICAgICAgICAgICAgICBsKys7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gdmVjIGZyb20gZWRnZSBjZW50ZXIgdG8gc3BoZXJlIHByb2plY3RlZCB0byB0aGUgcGxhbmUgb3J0aG9nb25hbCB0byB0aGUgZWRnZSB0YW5nZW50XG4gICAgICAgICAgICAgICAgZGlzdC5jb3B5KHhpKTtcbiAgICAgICAgICAgICAgICBkaXN0LnZzdWIob3J0aG9nb25hbCxkaXN0KTtcbiAgICAgICAgICAgICAgICBkaXN0LnZzdWIoZWRnZUNlbnRlcixkaXN0KTtcbiAgICAgICAgICAgICAgICBkaXN0LnZzdWIoeGosZGlzdCk7XG5cbiAgICAgICAgICAgICAgICAvLyBEaXN0YW5jZXMgaW4gdGFuZ2VudCBkaXJlY3Rpb24gYW5kIGRpc3RhbmNlIGluIHRoZSBwbGFuZSBvcnRob2dvbmFsIHRvIGl0XG4gICAgICAgICAgICAgICAgdmFyIHRkaXN0ID0gTWF0aC5hYnMob3J0aG9ub3JtKTtcbiAgICAgICAgICAgICAgICB2YXIgbmRpc3QgPSBkaXN0Lm5vcm0oKTtcblxuICAgICAgICAgICAgICAgIGlmKHRkaXN0IDwgc2lkZXNbbF0ubm9ybSgpICYmIG5kaXN0PFIpe1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSxiaixzaSxzaik7XG4gICAgICAgICAgICAgICAgICAgIGVkZ2VDZW50ZXIudmFkZChvcnRob2dvbmFsLHJlcy5yaik7IC8vIGJveCByalxuICAgICAgICAgICAgICAgICAgICByZXMucmouY29weShyZXMucmopO1xuICAgICAgICAgICAgICAgICAgICBkaXN0Lm5lZ2F0ZShyZXMubmkpO1xuICAgICAgICAgICAgICAgICAgICByZXMubmkubm9ybWFsaXplKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVzLnJpLmNvcHkocmVzLnJqKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnJpLnZhZGQoeGoscmVzLnJpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnJpLnZzdWIoeGkscmVzLnJpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnJpLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXMucmkubXVsdChSLHJlcy5yaSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSByZWxhdGl2ZSB0byBib2RpZXNcbiAgICAgICAgICAgICAgICAgICAgcmVzLnJpLnZhZGQoeGksIHJlcy5yaSk7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5yaS52c3ViKGJpLnBvc2l0aW9uLCByZXMucmkpO1xuICAgICAgICAgICAgICAgICAgICByZXMucmoudmFkZCh4aiwgcmVzLnJqKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnJqLnZzdWIoYmoucG9zaXRpb24sIHJlcy5yaik7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyZXMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QocmVzLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdjNwb29sLnJlbGVhc2UoZWRnZVRhbmdlbnQsZWRnZUNlbnRlcixyLG9ydGhvZ29uYWwsZGlzdCk7XG59O1xuXG52YXIgY29udmV4X3RvX3NwaGVyZSA9IG5ldyBWZWMzKCk7XG52YXIgc3BoZXJlQ29udmV4X2VkZ2UgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZUNvbnZleF9lZGdlVW5pdCA9IG5ldyBWZWMzKCk7XG52YXIgc3BoZXJlQ29udmV4X3NwaGVyZVRvQ29ybmVyID0gbmV3IFZlYzMoKTtcbnZhciBzcGhlcmVDb252ZXhfd29ybGRDb3JuZXIgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZUNvbnZleF93b3JsZE5vcm1hbCA9IG5ldyBWZWMzKCk7XG52YXIgc3BoZXJlQ29udmV4X3dvcmxkUG9pbnQgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZUNvbnZleF93b3JsZFNwaGVyZVBvaW50Q2xvc2VzdFRvUGxhbmUgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZUNvbnZleF9wZW5ldHJhdGlvblZlYyA9IG5ldyBWZWMzKCk7XG52YXIgc3BoZXJlQ29udmV4X3NwaGVyZVRvV29ybGRQb2ludCA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogQG1ldGhvZCBzcGhlcmVDb252ZXhcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNpXG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzalxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGlcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhqXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxaVxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWpcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJpXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBialxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuU1BIRVJFIHwgU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTl0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLnNwaGVyZUNvbnZleCA9IGZ1bmN0aW9uKHNpLHNqLHhpLHhqLHFpLHFqLGJpLGJqKXtcbiAgICB2YXIgdjNwb29sID0gdGhpcy52M3Bvb2w7XG4gICAgeGkudnN1Yih4aixjb252ZXhfdG9fc3BoZXJlKTtcbiAgICB2YXIgbm9ybWFscyA9IHNqLmZhY2VOb3JtYWxzO1xuICAgIHZhciBmYWNlcyA9IHNqLmZhY2VzO1xuICAgIHZhciB2ZXJ0cyA9IHNqLnZlcnRpY2VzO1xuICAgIHZhciBSID0gICAgIHNpLnJhZGl1cztcbiAgICB2YXIgcGVuZXRyYXRpbmdfc2lkZXMgPSBbXTtcblxuICAgIC8vIGlmKGNvbnZleF90b19zcGhlcmUubm9ybTIoKSA+IHNpLmJvdW5kaW5nU3BoZXJlUmFkaXVzICsgc2ouYm91bmRpbmdTcGhlcmVSYWRpdXMpe1xuICAgIC8vICAgICByZXR1cm47XG4gICAgLy8gfVxuXG4gICAgLy8gQ2hlY2sgY29ybmVyc1xuICAgIGZvcih2YXIgaT0wOyBpIT09dmVydHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgdiA9IHZlcnRzW2ldO1xuXG4gICAgICAgIC8vIFdvcmxkIHBvc2l0aW9uIG9mIGNvcm5lclxuICAgICAgICB2YXIgd29ybGRDb3JuZXIgPSBzcGhlcmVDb252ZXhfd29ybGRDb3JuZXI7XG4gICAgICAgIHFqLnZtdWx0KHYsd29ybGRDb3JuZXIpO1xuICAgICAgICB4ai52YWRkKHdvcmxkQ29ybmVyLHdvcmxkQ29ybmVyKTtcbiAgICAgICAgdmFyIHNwaGVyZV90b19jb3JuZXIgPSBzcGhlcmVDb252ZXhfc3BoZXJlVG9Db3JuZXI7XG4gICAgICAgIHdvcmxkQ29ybmVyLnZzdWIoeGksIHNwaGVyZV90b19jb3JuZXIpO1xuICAgICAgICBpZihzcGhlcmVfdG9fY29ybmVyLm5vcm0yKCkgPCBSICogUil7XG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLGJqLHNpLHNqKTtcbiAgICAgICAgICAgIHIucmkuY29weShzcGhlcmVfdG9fY29ybmVyKTtcbiAgICAgICAgICAgIHIucmkubm9ybWFsaXplKCk7XG4gICAgICAgICAgICByLm5pLmNvcHkoci5yaSk7XG4gICAgICAgICAgICByLnJpLm11bHQoUixyLnJpKTtcbiAgICAgICAgICAgIHdvcmxkQ29ybmVyLnZzdWIoeGosci5yaik7XG5cbiAgICAgICAgICAgIC8vIFNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYm9keS5cbiAgICAgICAgICAgIHIucmkudmFkZCh4aSwgci5yaSk7XG4gICAgICAgICAgICByLnJpLnZzdWIoYmkucG9zaXRpb24sIHIucmkpO1xuXG4gICAgICAgICAgICAvLyBTaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJvZHkuXG4gICAgICAgICAgICByLnJqLnZhZGQoeGosIHIucmopO1xuICAgICAgICAgICAgci5yai52c3ViKGJqLnBvc2l0aW9uLCByLnJqKTtcblxuICAgICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIHNpZGUgKHBsYW5lKSBpbnRlcnNlY3Rpb25zXG4gICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgZm9yKHZhciBpPTAsIG5mYWNlcz1mYWNlcy5sZW5ndGg7IGkhPT1uZmFjZXMgJiYgZm91bmQ9PT1mYWxzZTsgaSsrKXtcbiAgICAgICAgdmFyIG5vcm1hbCA9IG5vcm1hbHNbaV07XG4gICAgICAgIHZhciBmYWNlID0gZmFjZXNbaV07XG5cbiAgICAgICAgLy8gR2V0IHdvcmxkLXRyYW5zZm9ybWVkIG5vcm1hbCBvZiB0aGUgZmFjZVxuICAgICAgICB2YXIgd29ybGROb3JtYWwgPSBzcGhlcmVDb252ZXhfd29ybGROb3JtYWw7XG4gICAgICAgIHFqLnZtdWx0KG5vcm1hbCx3b3JsZE5vcm1hbCk7XG5cbiAgICAgICAgLy8gR2V0IGEgd29ybGQgdmVydGV4IGZyb20gdGhlIGZhY2VcbiAgICAgICAgdmFyIHdvcmxkUG9pbnQgPSBzcGhlcmVDb252ZXhfd29ybGRQb2ludDtcbiAgICAgICAgcWoudm11bHQodmVydHNbZmFjZVswXV0sd29ybGRQb2ludCk7XG4gICAgICAgIHdvcmxkUG9pbnQudmFkZCh4aix3b3JsZFBvaW50KTtcblxuICAgICAgICAvLyBHZXQgYSBwb2ludCBvbiB0aGUgc3BoZXJlLCBjbG9zZXN0IHRvIHRoZSBmYWNlIG5vcm1hbFxuICAgICAgICB2YXIgd29ybGRTcGhlcmVQb2ludENsb3Nlc3RUb1BsYW5lID0gc3BoZXJlQ29udmV4X3dvcmxkU3BoZXJlUG9pbnRDbG9zZXN0VG9QbGFuZTtcbiAgICAgICAgd29ybGROb3JtYWwubXVsdCgtUiwgd29ybGRTcGhlcmVQb2ludENsb3Nlc3RUb1BsYW5lKTtcbiAgICAgICAgeGkudmFkZCh3b3JsZFNwaGVyZVBvaW50Q2xvc2VzdFRvUGxhbmUsIHdvcmxkU3BoZXJlUG9pbnRDbG9zZXN0VG9QbGFuZSk7XG5cbiAgICAgICAgLy8gVmVjdG9yIGZyb20gYSBmYWNlIHBvaW50IHRvIHRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSBzcGhlcmVcbiAgICAgICAgdmFyIHBlbmV0cmF0aW9uVmVjID0gc3BoZXJlQ29udmV4X3BlbmV0cmF0aW9uVmVjO1xuICAgICAgICB3b3JsZFNwaGVyZVBvaW50Q2xvc2VzdFRvUGxhbmUudnN1Yih3b3JsZFBvaW50LHBlbmV0cmF0aW9uVmVjKTtcblxuICAgICAgICAvLyBUaGUgcGVuZXRyYXRpb24uIE5lZ2F0aXZlIHZhbHVlIG1lYW5zIG92ZXJsYXAuXG4gICAgICAgIHZhciBwZW5ldHJhdGlvbiA9IHBlbmV0cmF0aW9uVmVjLmRvdCh3b3JsZE5vcm1hbCk7XG5cbiAgICAgICAgdmFyIHdvcmxkUG9pbnRUb1NwaGVyZSA9IHNwaGVyZUNvbnZleF9zcGhlcmVUb1dvcmxkUG9pbnQ7XG4gICAgICAgIHhpLnZzdWIod29ybGRQb2ludCwgd29ybGRQb2ludFRvU3BoZXJlKTtcblxuICAgICAgICBpZihwZW5ldHJhdGlvbiA8IDAgJiYgd29ybGRQb2ludFRvU3BoZXJlLmRvdCh3b3JsZE5vcm1hbCk+MCl7XG4gICAgICAgICAgICAvLyBJbnRlcnNlY3RzIHBsYW5lLiBOb3cgY2hlY2sgaWYgdGhlIHNwaGVyZSBpcyBpbnNpZGUgdGhlIGZhY2UgcG9seWdvblxuICAgICAgICAgICAgdmFyIGZhY2VWZXJ0cyA9IFtdOyAvLyBGYWNlIHZlcnRpY2VzLCBpbiB3b3JsZCBjb29yZHNcbiAgICAgICAgICAgIGZvcih2YXIgaj0wLCBOdmVydHM9ZmFjZS5sZW5ndGg7IGohPT1OdmVydHM7IGorKyl7XG4gICAgICAgICAgICAgICAgdmFyIHdvcmxkVmVydGV4ID0gdjNwb29sLmdldCgpO1xuICAgICAgICAgICAgICAgIHFqLnZtdWx0KHZlcnRzW2ZhY2Vbal1dLCB3b3JsZFZlcnRleCk7XG4gICAgICAgICAgICAgICAgeGoudmFkZCh3b3JsZFZlcnRleCx3b3JsZFZlcnRleCk7XG4gICAgICAgICAgICAgICAgZmFjZVZlcnRzLnB1c2god29ybGRWZXJ0ZXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihwb2ludEluUG9seWdvbihmYWNlVmVydHMsd29ybGROb3JtYWwseGkpKXsgLy8gSXMgdGhlIHNwaGVyZSBjZW50ZXIgaW4gdGhlIGZhY2UgcG9seWdvbj9cbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSxiaixzaSxzaik7XG5cbiAgICAgICAgICAgICAgICB3b3JsZE5vcm1hbC5tdWx0KC1SLCByLnJpKTsgLy8gQ29udGFjdCBvZmZzZXQsIGZyb20gc3BoZXJlIGNlbnRlciB0byBjb250YWN0XG4gICAgICAgICAgICAgICAgd29ybGROb3JtYWwubmVnYXRlKHIubmkpOyAvLyBOb3JtYWwgcG9pbnRpbmcgb3V0IG9mIHNwaGVyZVxuXG4gICAgICAgICAgICAgICAgdmFyIHBlbmV0cmF0aW9uVmVjMiA9IHYzcG9vbC5nZXQoKTtcbiAgICAgICAgICAgICAgICB3b3JsZE5vcm1hbC5tdWx0KC1wZW5ldHJhdGlvbiwgcGVuZXRyYXRpb25WZWMyKTtcbiAgICAgICAgICAgICAgICB2YXIgcGVuZXRyYXRpb25TcGhlcmVQb2ludCA9IHYzcG9vbC5nZXQoKTtcbiAgICAgICAgICAgICAgICB3b3JsZE5vcm1hbC5tdWx0KC1SLCBwZW5ldHJhdGlvblNwaGVyZVBvaW50KTtcblxuICAgICAgICAgICAgICAgIC8veGkudnN1Yih4aikudmFkZChwZW5ldHJhdGlvblNwaGVyZVBvaW50KS52YWRkKHBlbmV0cmF0aW9uVmVjMiAsIHIucmopO1xuICAgICAgICAgICAgICAgIHhpLnZzdWIoeGosci5yaik7XG4gICAgICAgICAgICAgICAgci5yai52YWRkKHBlbmV0cmF0aW9uU3BoZXJlUG9pbnQsci5yaik7XG4gICAgICAgICAgICAgICAgci5yai52YWRkKHBlbmV0cmF0aW9uVmVjMiAsIHIucmopO1xuXG4gICAgICAgICAgICAgICAgLy8gU2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBib2R5LlxuICAgICAgICAgICAgICAgIHIucmoudmFkZCh4aiwgci5yaik7XG4gICAgICAgICAgICAgICAgci5yai52c3ViKGJqLnBvc2l0aW9uLCByLnJqKTtcblxuICAgICAgICAgICAgICAgIC8vIFNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYm9keS5cbiAgICAgICAgICAgICAgICByLnJpLnZhZGQoeGksIHIucmkpO1xuICAgICAgICAgICAgICAgIHIucmkudnN1YihiaS5wb3NpdGlvbiwgci5yaSk7XG5cbiAgICAgICAgICAgICAgICB2M3Bvb2wucmVsZWFzZShwZW5ldHJhdGlvblZlYzIpO1xuICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHBlbmV0cmF0aW9uU3BoZXJlUG9pbnQpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XG5cbiAgICAgICAgICAgICAgICAvLyBSZWxlYXNlIHdvcmxkIHZlcnRpY2VzXG4gICAgICAgICAgICAgICAgZm9yKHZhciBqPTAsIE5mYWNldmVydHM9ZmFjZVZlcnRzLmxlbmd0aDsgaiE9PU5mYWNldmVydHM7IGorKyl7XG4gICAgICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKGZhY2VWZXJ0c1tqXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBXZSBvbmx5IGV4cGVjdCAqb25lKiBmYWNlIGNvbnRhY3RcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRWRnZT9cbiAgICAgICAgICAgICAgICBmb3IodmFyIGo9MDsgaiE9PWZhY2UubGVuZ3RoOyBqKyspe1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0d28gd29ybGQgdHJhbnNmb3JtZWQgdmVydGljZXNcbiAgICAgICAgICAgICAgICAgICAgdmFyIHYxID0gdjNwb29sLmdldCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdjIgPSB2M3Bvb2wuZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIHFqLnZtdWx0KHZlcnRzW2ZhY2VbKGorMSklZmFjZS5sZW5ndGhdXSwgdjEpO1xuICAgICAgICAgICAgICAgICAgICBxai52bXVsdCh2ZXJ0c1tmYWNlWyhqKzIpJWZhY2UubGVuZ3RoXV0sIHYyKTtcbiAgICAgICAgICAgICAgICAgICAgeGoudmFkZCh2MSwgdjEpO1xuICAgICAgICAgICAgICAgICAgICB4ai52YWRkKHYyLCB2Mik7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uc3RydWN0IGVkZ2UgdmVjdG9yXG4gICAgICAgICAgICAgICAgICAgIHZhciBlZGdlID0gc3BoZXJlQ29udmV4X2VkZ2U7XG4gICAgICAgICAgICAgICAgICAgIHYyLnZzdWIodjEsZWRnZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uc3RydWN0IHRoZSBzYW1lIHZlY3RvciwgYnV0IG5vcm1hbGl6ZWRcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVkZ2VVbml0ID0gc3BoZXJlQ29udmV4X2VkZ2VVbml0O1xuICAgICAgICAgICAgICAgICAgICBlZGdlLnVuaXQoZWRnZVVuaXQpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHAgaXMgeGkgcHJvamVjdGVkIG9udG8gdGhlIGVkZ2VcbiAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSB2M3Bvb2wuZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2MV90b194aSA9IHYzcG9vbC5nZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgeGkudnN1Yih2MSwgdjFfdG9feGkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG90ID0gdjFfdG9feGkuZG90KGVkZ2VVbml0KTtcbiAgICAgICAgICAgICAgICAgICAgZWRnZVVuaXQubXVsdChkb3QsIHApO1xuICAgICAgICAgICAgICAgICAgICBwLnZhZGQodjEsIHApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgYSB2ZWN0b3IgZnJvbSBwIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHNwaGVyZVxuICAgICAgICAgICAgICAgICAgICB2YXIgeGlfdG9fcCA9IHYzcG9vbC5nZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgcC52c3ViKHhpLCB4aV90b19wKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDb2xsaXNpb24gaWYgdGhlIGVkZ2Utc3BoZXJlIGRpc3RhbmNlIGlzIGxlc3MgdGhhbiB0aGUgcmFkaXVzXG4gICAgICAgICAgICAgICAgICAgIC8vIEFORCBpZiBwIGlzIGluIGJldHdlZW4gdjEgYW5kIHYyXG4gICAgICAgICAgICAgICAgICAgIGlmKGRvdCA+IDAgJiYgZG90KmRvdDxlZGdlLm5vcm0yKCkgJiYgeGlfdG9fcC5ub3JtMigpIDwgUipSKXsgLy8gQ29sbGlzaW9uIGlmIHRoZSBlZGdlLXNwaGVyZSBkaXN0YW5jZSBpcyBsZXNzIHRoYW4gdGhlIHJhZGl1c1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRWRnZSBjb250YWN0IVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSxiaixzaSxzaik7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLnZzdWIoeGosci5yaik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHAudnN1Yih4aSxyLm5pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIubmkubm9ybWFsaXplKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHIubmkubXVsdChSLHIucmkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJvZHkuXG4gICAgICAgICAgICAgICAgICAgICAgICByLnJqLnZhZGQoeGosIHIucmopO1xuICAgICAgICAgICAgICAgICAgICAgICAgci5yai52c3ViKGJqLnBvc2l0aW9uLCByLnJqKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBib2R5LlxuICAgICAgICAgICAgICAgICAgICAgICAgci5yaS52YWRkKHhpLCByLnJpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIucmkudnN1YihiaS5wb3NpdGlvbiwgci5yaSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbGVhc2Ugd29ybGQgdmVydGljZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaj0wLCBOZmFjZXZlcnRzPWZhY2VWZXJ0cy5sZW5ndGg7IGohPT1OZmFjZXZlcnRzOyBqKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKGZhY2VWZXJ0c1tqXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHYxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHYyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UoeGlfdG9fcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2M3Bvb2wucmVsZWFzZSh2MV90b194aSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHYxKTtcbiAgICAgICAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UodjIpO1xuICAgICAgICAgICAgICAgICAgICB2M3Bvb2wucmVsZWFzZShwKTtcbiAgICAgICAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UoeGlfdG9fcCk7XG4gICAgICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHYxX3RvX3hpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlbGVhc2Ugd29ybGQgdmVydGljZXNcbiAgICAgICAgICAgIGZvcih2YXIgaj0wLCBOZmFjZXZlcnRzPWZhY2VWZXJ0cy5sZW5ndGg7IGohPT1OZmFjZXZlcnRzOyBqKyspe1xuICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKGZhY2VWZXJ0c1tqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgcGxhbmVCb3hfbm9ybWFsID0gbmV3IFZlYzMoKTtcbnZhciBwbGFuZV90b19jb3JuZXIgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIEBtZXRob2QgcGxhbmVCb3hcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIHJlc3VsdFxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2lcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNqXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4aVxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGpcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFpXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxalxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmlcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJqXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5QTEFORSB8IFNoYXBlLnR5cGVzLkJPWF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLnBsYW5lQm94ID0gZnVuY3Rpb24oc2ksc2oseGkseGoscWkscWosYmksYmope1xuICAgIHNqLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5tYXRlcmlhbCA9IHNqLm1hdGVyaWFsO1xuICAgIHNqLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5jb2xsaXNpb25SZXNwb25zZSA9IHNqLmNvbGxpc2lvblJlc3BvbnNlO1xuICAgIHRoaXMucGxhbmVDb252ZXgoc2ksc2ouY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLHhpLHhqLHFpLHFqLGJpLGJqKTtcbn07XG5cbnZhciBwbGFuZUNvbnZleF92ID0gbmV3IFZlYzMoKTtcbnZhciBwbGFuZUNvbnZleF9ub3JtYWwgPSBuZXcgVmVjMygpO1xudmFyIHBsYW5lQ29udmV4X3JlbHBvcyA9IG5ldyBWZWMzKCk7XG52YXIgcGxhbmVDb252ZXhfcHJvamVjdGVkID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBAbWV0aG9kIHBsYW5lQ29udmV4XG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzaVxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2pcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhpXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4alxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWlcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFqXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBiaVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmpcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLnR5cGVzLlBMQU5FIHwgU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTl0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLnBsYW5lQ29udmV4ID0gZnVuY3Rpb24oXG4gICAgcGxhbmVTaGFwZSxcbiAgICBjb252ZXhTaGFwZSxcbiAgICBwbGFuZVBvc2l0aW9uLFxuICAgIGNvbnZleFBvc2l0aW9uLFxuICAgIHBsYW5lUXVhdCxcbiAgICBjb252ZXhRdWF0LFxuICAgIHBsYW5lQm9keSxcbiAgICBjb252ZXhCb2R5XG4pe1xuICAgIC8vIFNpbXBseSByZXR1cm4gdGhlIHBvaW50cyBiZWhpbmQgdGhlIHBsYW5lLlxuICAgIHZhciB3b3JsZFZlcnRleCA9IHBsYW5lQ29udmV4X3YsXG4gICAgICAgIHdvcmxkTm9ybWFsID0gcGxhbmVDb252ZXhfbm9ybWFsO1xuICAgIHdvcmxkTm9ybWFsLnNldCgwLDAsMSk7XG4gICAgcGxhbmVRdWF0LnZtdWx0KHdvcmxkTm9ybWFsLHdvcmxkTm9ybWFsKTsgLy8gVHVybiBub3JtYWwgYWNjb3JkaW5nIHRvIHBsYW5lIG9yaWVudGF0aW9uXG5cbiAgICB2YXIgbnVtQ29udGFjdHMgPSAwO1xuICAgIHZhciByZWxwb3MgPSBwbGFuZUNvbnZleF9yZWxwb3M7XG4gICAgZm9yKHZhciBpID0gMDsgaSAhPT0gY29udmV4U2hhcGUudmVydGljZXMubGVuZ3RoOyBpKyspe1xuXG4gICAgICAgIC8vIEdldCB3b3JsZCBjb252ZXggdmVydGV4XG4gICAgICAgIHdvcmxkVmVydGV4LmNvcHkoY29udmV4U2hhcGUudmVydGljZXNbaV0pO1xuICAgICAgICBjb252ZXhRdWF0LnZtdWx0KHdvcmxkVmVydGV4LCB3b3JsZFZlcnRleCk7XG4gICAgICAgIGNvbnZleFBvc2l0aW9uLnZhZGQod29ybGRWZXJ0ZXgsIHdvcmxkVmVydGV4KTtcbiAgICAgICAgd29ybGRWZXJ0ZXgudnN1YihwbGFuZVBvc2l0aW9uLCByZWxwb3MpO1xuXG4gICAgICAgIHZhciBkb3QgPSB3b3JsZE5vcm1hbC5kb3QocmVscG9zKTtcbiAgICAgICAgaWYoZG90IDw9IDAuMCl7XG5cbiAgICAgICAgICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24ocGxhbmVCb2R5LCBjb252ZXhCb2R5LCBwbGFuZVNoYXBlLCBjb252ZXhTaGFwZSk7XG5cbiAgICAgICAgICAgIC8vIEdldCB2ZXJ0ZXggcG9zaXRpb24gcHJvamVjdGVkIG9uIHBsYW5lXG4gICAgICAgICAgICB2YXIgcHJvamVjdGVkID0gcGxhbmVDb252ZXhfcHJvamVjdGVkO1xuICAgICAgICAgICAgd29ybGROb3JtYWwubXVsdCh3b3JsZE5vcm1hbC5kb3QocmVscG9zKSxwcm9qZWN0ZWQpO1xuICAgICAgICAgICAgd29ybGRWZXJ0ZXgudnN1Yihwcm9qZWN0ZWQsIHByb2plY3RlZCk7XG4gICAgICAgICAgICBwcm9qZWN0ZWQudnN1YihwbGFuZVBvc2l0aW9uLCByLnJpKTsgLy8gRnJvbSBwbGFuZSB0byB2ZXJ0ZXggcHJvamVjdGVkIG9uIHBsYW5lXG5cbiAgICAgICAgICAgIHIubmkuY29weSh3b3JsZE5vcm1hbCk7IC8vIENvbnRhY3Qgbm9ybWFsIGlzIHRoZSBwbGFuZSBub3JtYWwgb3V0IGZyb20gcGxhbmVcblxuICAgICAgICAgICAgLy8gcmogaXMgbm93IGp1c3QgdGhlIHZlY3RvciBmcm9tIHRoZSBjb252ZXggY2VudGVyIHRvIHRoZSB2ZXJ0ZXhcbiAgICAgICAgICAgIHdvcmxkVmVydGV4LnZzdWIoY29udmV4UG9zaXRpb24sIHIucmopO1xuXG4gICAgICAgICAgICAvLyBNYWtlIGl0IHJlbGF0aXZlIHRvIHRoZSBib2R5XG4gICAgICAgICAgICByLnJpLnZhZGQocGxhbmVQb3NpdGlvbiwgci5yaSk7XG4gICAgICAgICAgICByLnJpLnZzdWIocGxhbmVCb2R5LnBvc2l0aW9uLCByLnJpKTtcbiAgICAgICAgICAgIHIucmoudmFkZChjb252ZXhQb3NpdGlvbiwgci5yaik7XG4gICAgICAgICAgICByLnJqLnZzdWIoY29udmV4Qm9keS5wb3NpdGlvbiwgci5yaik7XG5cbiAgICAgICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7XG4gICAgICAgICAgICBudW1Db250YWN0cysrO1xuICAgICAgICAgICAgaWYoIXRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24gJiYgbnVtQ29udGFjdHMpe1xuICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUF2ZXJhZ2UobnVtQ29udGFjdHMpO1xuICAgIH1cbn07XG5cbnZhciBjb252ZXhDb252ZXhfc2VwQXhpcyA9IG5ldyBWZWMzKCk7XG52YXIgY29udmV4Q29udmV4X3EgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIEBtZXRob2QgY29udmV4Q29udmV4XG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzaVxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2pcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhpXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4alxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWlcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFqXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBiaVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmpcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLnR5cGVzLkNPTlZFWFBPTFlIRURST05dID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jb252ZXhDb252ZXggPSBmdW5jdGlvbihzaSxzaix4aSx4aixxaSxxaixiaSxiaixyc2kscnNqLGZhY2VMaXN0QSxmYWNlTGlzdEIpe1xuICAgIHZhciBzZXBBeGlzID0gY29udmV4Q29udmV4X3NlcEF4aXM7XG5cbiAgICBpZih4aS5kaXN0YW5jZVRvKHhqKSA+IHNpLmJvdW5kaW5nU3BoZXJlUmFkaXVzICsgc2ouYm91bmRpbmdTcGhlcmVSYWRpdXMpe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYoc2kuZmluZFNlcGFyYXRpbmdBeGlzKHNqLHhpLHFpLHhqLHFqLHNlcEF4aXMsZmFjZUxpc3RBLGZhY2VMaXN0Qikpe1xuICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgIHZhciBxID0gY29udmV4Q29udmV4X3E7XG4gICAgICAgIHNpLmNsaXBBZ2FpbnN0SHVsbCh4aSxxaSxzaix4aixxaixzZXBBeGlzLC0xMDAsMTAwLHJlcyk7XG4gICAgICAgIHZhciBudW1Db250YWN0cyA9IDA7XG4gICAgICAgIGZvcih2YXIgaiA9IDA7IGogIT09IHJlcy5sZW5ndGg7IGorKyl7XG4gICAgICAgICAgICB2YXIgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLGJqLHNpLHNqLHJzaSxyc2opLFxuICAgICAgICAgICAgICAgIHJpID0gci5yaSxcbiAgICAgICAgICAgICAgICByaiA9IHIucmo7XG4gICAgICAgICAgICBzZXBBeGlzLm5lZ2F0ZShyLm5pKTtcbiAgICAgICAgICAgIHJlc1tqXS5ub3JtYWwubmVnYXRlKHEpO1xuICAgICAgICAgICAgcS5tdWx0KHJlc1tqXS5kZXB0aCwgcSk7XG4gICAgICAgICAgICByZXNbal0ucG9pbnQudmFkZChxLCByaSk7XG4gICAgICAgICAgICByai5jb3B5KHJlc1tqXS5wb2ludCk7XG5cbiAgICAgICAgICAgIC8vIENvbnRhY3QgcG9pbnRzIGFyZSBpbiB3b3JsZCBjb29yZGluYXRlcy4gVHJhbnNmb3JtIGJhY2sgdG8gcmVsYXRpdmVcbiAgICAgICAgICAgIHJpLnZzdWIoeGkscmkpO1xuICAgICAgICAgICAgcmoudnN1Yih4aixyaik7XG5cbiAgICAgICAgICAgIC8vIE1ha2UgcmVsYXRpdmUgdG8gYm9kaWVzXG4gICAgICAgICAgICByaS52YWRkKHhpLCByaSk7XG4gICAgICAgICAgICByaS52c3ViKGJpLnBvc2l0aW9uLCByaSk7XG4gICAgICAgICAgICByai52YWRkKHhqLCByaik7XG4gICAgICAgICAgICByai52c3ViKGJqLnBvc2l0aW9uLCByaik7XG5cbiAgICAgICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7XG4gICAgICAgICAgICBudW1Db250YWN0cysrO1xuICAgICAgICAgICAgaWYoIXRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uICYmIG51bUNvbnRhY3RzKXtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQXZlcmFnZShudW1Db250YWN0cyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbi8qKlxuICogQG1ldGhvZCBjb252ZXhUcmltZXNoXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICByZXN1bHRcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNpXG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzalxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGlcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhqXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxaVxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWpcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJpXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBialxuICovXG4vLyBOYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTiB8IFNoYXBlLnR5cGVzLlRSSU1FU0hdID1cbi8vIE5hcnJvd3BoYXNlLnByb3RvdHlwZS5jb252ZXhUcmltZXNoID0gZnVuY3Rpb24oc2ksc2oseGkseGoscWkscWosYmksYmoscnNpLHJzaixmYWNlTGlzdEEsZmFjZUxpc3RCKXtcbi8vICAgICB2YXIgc2VwQXhpcyA9IGNvbnZleENvbnZleF9zZXBBeGlzO1xuXG4vLyAgICAgaWYoeGkuZGlzdGFuY2VUbyh4aikgPiBzaS5ib3VuZGluZ1NwaGVyZVJhZGl1cyArIHNqLmJvdW5kaW5nU3BoZXJlUmFkaXVzKXtcbi8vICAgICAgICAgcmV0dXJuO1xuLy8gICAgIH1cblxuLy8gICAgIC8vIENvbnN0cnVjdCBhIHRlbXAgaHVsbCBmb3IgZWFjaCB0cmlhbmdsZVxuLy8gICAgIHZhciBodWxsQiA9IG5ldyBDb252ZXhQb2x5aGVkcm9uKCk7XG5cbi8vICAgICBodWxsQi5mYWNlcyA9IFtbMCwxLDJdXTtcbi8vICAgICB2YXIgdmEgPSBuZXcgVmVjMygpO1xuLy8gICAgIHZhciB2YiA9IG5ldyBWZWMzKCk7XG4vLyAgICAgdmFyIHZjID0gbmV3IFZlYzMoKTtcbi8vICAgICBodWxsQi52ZXJ0aWNlcyA9IFtcbi8vICAgICAgICAgdmEsXG4vLyAgICAgICAgIHZiLFxuLy8gICAgICAgICB2Y1xuLy8gICAgIF07XG5cbi8vICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNqLmluZGljZXMubGVuZ3RoIC8gMzsgaSsrKSB7XG5cbi8vICAgICAgICAgdmFyIHRyaWFuZ2xlTm9ybWFsID0gbmV3IFZlYzMoKTtcbi8vICAgICAgICAgc2ouZ2V0Tm9ybWFsKGksIHRyaWFuZ2xlTm9ybWFsKTtcbi8vICAgICAgICAgaHVsbEIuZmFjZU5vcm1hbHMgPSBbdHJpYW5nbGVOb3JtYWxdO1xuXG4vLyAgICAgICAgIHNqLmdldFRyaWFuZ2xlVmVydGljZXMoaSwgdmEsIHZiLCB2Yyk7XG5cbi8vICAgICAgICAgdmFyIGQgPSBzaS50ZXN0U2VwQXhpcyh0cmlhbmdsZU5vcm1hbCwgaHVsbEIsIHhpLCBxaSwgeGosIHFqKTtcbi8vICAgICAgICAgaWYoIWQpe1xuLy8gICAgICAgICAgICAgdHJpYW5nbGVOb3JtYWwuc2NhbGUoLTEsIHRyaWFuZ2xlTm9ybWFsKTtcbi8vICAgICAgICAgICAgIGQgPSBzaS50ZXN0U2VwQXhpcyh0cmlhbmdsZU5vcm1hbCwgaHVsbEIsIHhpLCBxaSwgeGosIHFqKTtcblxuLy8gICAgICAgICAgICAgaWYoIWQpe1xuLy8gICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuLy8gICAgICAgICAgICAgfVxuLy8gICAgICAgICB9XG5cbi8vICAgICAgICAgdmFyIHJlcyA9IFtdO1xuLy8gICAgICAgICB2YXIgcSA9IGNvbnZleENvbnZleF9xO1xuLy8gICAgICAgICBzaS5jbGlwQWdhaW5zdEh1bGwoeGkscWksaHVsbEIseGoscWosdHJpYW5nbGVOb3JtYWwsLTEwMCwxMDAscmVzKTtcbi8vICAgICAgICAgZm9yKHZhciBqID0gMDsgaiAhPT0gcmVzLmxlbmd0aDsgaisrKXtcbi8vICAgICAgICAgICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYmksYmosc2ksc2oscnNpLHJzaiksXG4vLyAgICAgICAgICAgICAgICAgcmkgPSByLnJpLFxuLy8gICAgICAgICAgICAgICAgIHJqID0gci5yajtcbi8vICAgICAgICAgICAgIHIubmkuY29weSh0cmlhbmdsZU5vcm1hbCk7XG4vLyAgICAgICAgICAgICByLm5pLm5lZ2F0ZShyLm5pKTtcbi8vICAgICAgICAgICAgIHJlc1tqXS5ub3JtYWwubmVnYXRlKHEpO1xuLy8gICAgICAgICAgICAgcS5tdWx0KHJlc1tqXS5kZXB0aCwgcSk7XG4vLyAgICAgICAgICAgICByZXNbal0ucG9pbnQudmFkZChxLCByaSk7XG4vLyAgICAgICAgICAgICByai5jb3B5KHJlc1tqXS5wb2ludCk7XG5cbi8vICAgICAgICAgICAgIC8vIENvbnRhY3QgcG9pbnRzIGFyZSBpbiB3b3JsZCBjb29yZGluYXRlcy4gVHJhbnNmb3JtIGJhY2sgdG8gcmVsYXRpdmVcbi8vICAgICAgICAgICAgIHJpLnZzdWIoeGkscmkpO1xuLy8gICAgICAgICAgICAgcmoudnN1Yih4aixyaik7XG5cbi8vICAgICAgICAgICAgIC8vIE1ha2UgcmVsYXRpdmUgdG8gYm9kaWVzXG4vLyAgICAgICAgICAgICByaS52YWRkKHhpLCByaSk7XG4vLyAgICAgICAgICAgICByaS52c3ViKGJpLnBvc2l0aW9uLCByaSk7XG4vLyAgICAgICAgICAgICByai52YWRkKHhqLCByaik7XG4vLyAgICAgICAgICAgICByai52c3ViKGJqLnBvc2l0aW9uLCByaik7XG5cbi8vICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHIpO1xuLy8gICAgICAgICB9XG4vLyAgICAgfVxuLy8gfTtcblxudmFyIHBhcnRpY2xlUGxhbmVfbm9ybWFsID0gbmV3IFZlYzMoKTtcbnZhciBwYXJ0aWNsZVBsYW5lX3JlbHBvcyA9IG5ldyBWZWMzKCk7XG52YXIgcGFydGljbGVQbGFuZV9wcm9qZWN0ZWQgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIEBtZXRob2QgcGFydGljbGVQbGFuZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgcmVzdWx0XG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzaVxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2pcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhpXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4alxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWlcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFqXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBiaVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmpcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLnR5cGVzLlBMQU5FIHwgU2hhcGUudHlwZXMuUEFSVElDTEVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5wbGFuZVBhcnRpY2xlID0gZnVuY3Rpb24oc2osc2kseGoseGkscWoscWksYmosYmkpe1xuICAgIHZhciBub3JtYWwgPSBwYXJ0aWNsZVBsYW5lX25vcm1hbDtcbiAgICBub3JtYWwuc2V0KDAsMCwxKTtcbiAgICBiai5xdWF0ZXJuaW9uLnZtdWx0KG5vcm1hbCxub3JtYWwpOyAvLyBUdXJuIG5vcm1hbCBhY2NvcmRpbmcgdG8gcGxhbmUgb3JpZW50YXRpb25cbiAgICB2YXIgcmVscG9zID0gcGFydGljbGVQbGFuZV9yZWxwb3M7XG4gICAgeGkudnN1Yihiai5wb3NpdGlvbixyZWxwb3MpO1xuICAgIHZhciBkb3QgPSBub3JtYWwuZG90KHJlbHBvcyk7XG4gICAgaWYoZG90IDw9IDAuMCl7XG4gICAgICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYmksYmosc2ksc2opO1xuICAgICAgICByLm5pLmNvcHkobm9ybWFsKTsgLy8gQ29udGFjdCBub3JtYWwgaXMgdGhlIHBsYW5lIG5vcm1hbFxuICAgICAgICByLm5pLm5lZ2F0ZShyLm5pKTtcbiAgICAgICAgci5yaS5zZXQoMCwwLDApOyAvLyBDZW50ZXIgb2YgcGFydGljbGVcblxuICAgICAgICAvLyBHZXQgcGFydGljbGUgcG9zaXRpb24gcHJvamVjdGVkIG9uIHBsYW5lXG4gICAgICAgIHZhciBwcm9qZWN0ZWQgPSBwYXJ0aWNsZVBsYW5lX3Byb2plY3RlZDtcbiAgICAgICAgbm9ybWFsLm11bHQobm9ybWFsLmRvdCh4aSkscHJvamVjdGVkKTtcbiAgICAgICAgeGkudnN1Yihwcm9qZWN0ZWQscHJvamVjdGVkKTtcbiAgICAgICAgLy9wcm9qZWN0ZWQudmFkZChiai5wb3NpdGlvbixwcm9qZWN0ZWQpO1xuXG4gICAgICAgIC8vIHJqIGlzIG5vdyB0aGUgcHJvamVjdGVkIHdvcmxkIHBvc2l0aW9uIG1pbnVzIHBsYW5lIHBvc2l0aW9uXG4gICAgICAgIHIucmouY29weShwcm9qZWN0ZWQpO1xuICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xuICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XG4gICAgfVxufTtcblxudmFyIHBhcnRpY2xlU3BoZXJlX25vcm1hbCA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogQG1ldGhvZCBwYXJ0aWNsZVNwaGVyZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgcmVzdWx0XG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzaVxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2pcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhpXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4alxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWlcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFqXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBiaVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmpcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLnR5cGVzLlBBUlRJQ0xFIHwgU2hhcGUudHlwZXMuU1BIRVJFXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuc3BoZXJlUGFydGljbGUgPSBmdW5jdGlvbihzaixzaSx4aix4aSxxaixxaSxiaixiaSl7XG4gICAgLy8gVGhlIG5vcm1hbCBpcyB0aGUgdW5pdCB2ZWN0b3IgZnJvbSBzcGhlcmUgY2VudGVyIHRvIHBhcnRpY2xlIGNlbnRlclxuICAgIHZhciBub3JtYWwgPSBwYXJ0aWNsZVNwaGVyZV9ub3JtYWw7XG4gICAgbm9ybWFsLnNldCgwLDAsMSk7XG4gICAgeGkudnN1Yih4aixub3JtYWwpO1xuICAgIHZhciBsZW5ndGhTcXVhcmVkID0gbm9ybWFsLm5vcm0yKCk7XG5cbiAgICBpZihsZW5ndGhTcXVhcmVkIDw9IHNqLnJhZGl1cyAqIHNqLnJhZGl1cyl7XG4gICAgICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYmksYmosc2ksc2opO1xuICAgICAgICBub3JtYWwubm9ybWFsaXplKCk7XG4gICAgICAgIHIucmouY29weShub3JtYWwpO1xuICAgICAgICByLnJqLm11bHQoc2oucmFkaXVzLHIucmopO1xuICAgICAgICByLm5pLmNvcHkobm9ybWFsKTsgLy8gQ29udGFjdCBub3JtYWxcbiAgICAgICAgci5uaS5uZWdhdGUoci5uaSk7XG4gICAgICAgIHIucmkuc2V0KDAsMCwwKTsgLy8gQ2VudGVyIG9mIHBhcnRpY2xlXG4gICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7XG4gICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICB9XG59O1xuXG4vLyBXSVBcbnZhciBjcWogPSBuZXcgUXVhdGVybmlvbigpO1xudmFyIGNvbnZleFBhcnRpY2xlX2xvY2FsID0gbmV3IFZlYzMoKTtcbnZhciBjb252ZXhQYXJ0aWNsZV9ub3JtYWwgPSBuZXcgVmVjMygpO1xudmFyIGNvbnZleFBhcnRpY2xlX3BlbmV0cmF0ZWRGYWNlTm9ybWFsID0gbmV3IFZlYzMoKTtcbnZhciBjb252ZXhQYXJ0aWNsZV92ZXJ0ZXhUb1BhcnRpY2xlID0gbmV3IFZlYzMoKTtcbnZhciBjb252ZXhQYXJ0aWNsZV93b3JsZFBlbmV0cmF0aW9uVmVjID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBAbWV0aG9kIGNvbnZleFBhcnRpY2xlXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICByZXN1bHRcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNpXG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzalxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGlcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhqXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxaVxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWpcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJpXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBialxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuUEFSVElDTEUgfCBTaGFwZS50eXBlcy5DT05WRVhQT0xZSEVEUk9OXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY29udmV4UGFydGljbGUgPSBmdW5jdGlvbihzaixzaSx4aix4aSxxaixxaSxiaixiaSl7XG4gICAgdmFyIHBlbmV0cmF0ZWRGYWNlSW5kZXggPSAtMTtcbiAgICB2YXIgcGVuZXRyYXRlZEZhY2VOb3JtYWwgPSBjb252ZXhQYXJ0aWNsZV9wZW5ldHJhdGVkRmFjZU5vcm1hbDtcbiAgICB2YXIgd29ybGRQZW5ldHJhdGlvblZlYyA9IGNvbnZleFBhcnRpY2xlX3dvcmxkUGVuZXRyYXRpb25WZWM7XG4gICAgdmFyIG1pblBlbmV0cmF0aW9uID0gbnVsbDtcbiAgICB2YXIgbnVtRGV0ZWN0ZWRGYWNlcyA9IDA7XG5cbiAgICAvLyBDb252ZXJ0IHBhcnRpY2xlIHBvc2l0aW9uIHhpIHRvIGxvY2FsIGNvb3JkcyBpbiB0aGUgY29udmV4XG4gICAgdmFyIGxvY2FsID0gY29udmV4UGFydGljbGVfbG9jYWw7XG4gICAgbG9jYWwuY29weSh4aSk7XG4gICAgbG9jYWwudnN1Yih4aixsb2NhbCk7IC8vIENvbnZlcnQgcG9zaXRpb24gdG8gcmVsYXRpdmUgdGhlIGNvbnZleCBvcmlnaW5cbiAgICBxai5jb25qdWdhdGUoY3FqKTtcbiAgICBjcWoudm11bHQobG9jYWwsbG9jYWwpO1xuXG4gICAgaWYoc2oucG9pbnRJc0luc2lkZShsb2NhbCkpe1xuXG4gICAgICAgIGlmKHNqLndvcmxkVmVydGljZXNOZWVkc1VwZGF0ZSl7XG4gICAgICAgICAgICBzai5jb21wdXRlV29ybGRWZXJ0aWNlcyh4aixxaik7XG4gICAgICAgIH1cbiAgICAgICAgaWYoc2oud29ybGRGYWNlTm9ybWFsc05lZWRzVXBkYXRlKXtcbiAgICAgICAgICAgIHNqLmNvbXB1dGVXb3JsZEZhY2VOb3JtYWxzKHFqKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZvciBlYWNoIHdvcmxkIHBvbHlnb24gaW4gdGhlIHBvbHloZWRyYVxuICAgICAgICBmb3IodmFyIGk9MCxuZmFjZXM9c2ouZmFjZXMubGVuZ3RoOyBpIT09bmZhY2VzOyBpKyspe1xuXG4gICAgICAgICAgICAvLyBDb25zdHJ1Y3Qgd29ybGQgZmFjZSB2ZXJ0aWNlc1xuICAgICAgICAgICAgdmFyIHZlcnRzID0gWyBzai53b3JsZFZlcnRpY2VzWyBzai5mYWNlc1tpXVswXSBdIF07XG4gICAgICAgICAgICB2YXIgbm9ybWFsID0gc2oud29ybGRGYWNlTm9ybWFsc1tpXTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgaG93IG11Y2ggdGhlIHBhcnRpY2xlIHBlbmV0cmF0ZXMgdGhlIHBvbHlnb24gcGxhbmUuXG4gICAgICAgICAgICB4aS52c3ViKHZlcnRzWzBdLGNvbnZleFBhcnRpY2xlX3ZlcnRleFRvUGFydGljbGUpO1xuICAgICAgICAgICAgdmFyIHBlbmV0cmF0aW9uID0gLW5vcm1hbC5kb3QoY29udmV4UGFydGljbGVfdmVydGV4VG9QYXJ0aWNsZSk7XG4gICAgICAgICAgICBpZihtaW5QZW5ldHJhdGlvbj09PW51bGwgfHwgTWF0aC5hYnMocGVuZXRyYXRpb24pPE1hdGguYWJzKG1pblBlbmV0cmF0aW9uKSl7XG4gICAgICAgICAgICAgICAgbWluUGVuZXRyYXRpb24gPSBwZW5ldHJhdGlvbjtcbiAgICAgICAgICAgICAgICBwZW5ldHJhdGVkRmFjZUluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBwZW5ldHJhdGVkRmFjZU5vcm1hbC5jb3B5KG5vcm1hbCk7XG4gICAgICAgICAgICAgICAgbnVtRGV0ZWN0ZWRGYWNlcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYocGVuZXRyYXRlZEZhY2VJbmRleCE9PS0xKXtcbiAgICAgICAgICAgIC8vIFNldHVwIGNvbnRhY3RcbiAgICAgICAgICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYmksYmosc2ksc2opO1xuICAgICAgICAgICAgcGVuZXRyYXRlZEZhY2VOb3JtYWwubXVsdChtaW5QZW5ldHJhdGlvbiwgd29ybGRQZW5ldHJhdGlvblZlYyk7XG5cbiAgICAgICAgICAgIC8vIHJqIGlzIHRoZSBwYXJ0aWNsZSBwb3NpdGlvbiBwcm9qZWN0ZWQgdG8gdGhlIGZhY2VcbiAgICAgICAgICAgIHdvcmxkUGVuZXRyYXRpb25WZWMudmFkZCh4aSx3b3JsZFBlbmV0cmF0aW9uVmVjKTtcbiAgICAgICAgICAgIHdvcmxkUGVuZXRyYXRpb25WZWMudnN1Yih4aix3b3JsZFBlbmV0cmF0aW9uVmVjKTtcbiAgICAgICAgICAgIHIucmouY29weSh3b3JsZFBlbmV0cmF0aW9uVmVjKTtcbiAgICAgICAgICAgIC8vdmFyIHByb2plY3RlZFRvRmFjZSA9IHhpLnZzdWIoeGopLnZhZGQod29ybGRQZW5ldHJhdGlvblZlYyk7XG4gICAgICAgICAgICAvL3Byb2plY3RlZFRvRmFjZS5jb3B5KHIucmopO1xuXG4gICAgICAgICAgICAvL3FqLnZtdWx0KHIucmosci5yaik7XG4gICAgICAgICAgICBwZW5ldHJhdGVkRmFjZU5vcm1hbC5uZWdhdGUoIHIubmkgKTsgLy8gQ29udGFjdCBub3JtYWxcbiAgICAgICAgICAgIHIucmkuc2V0KDAsMCwwKTsgLy8gQ2VudGVyIG9mIHBhcnRpY2xlXG5cbiAgICAgICAgICAgIHZhciByaSA9IHIucmksXG4gICAgICAgICAgICAgICAgcmogPSByLnJqO1xuXG4gICAgICAgICAgICAvLyBNYWtlIHJlbGF0aXZlIHRvIGJvZGllc1xuICAgICAgICAgICAgcmkudmFkZCh4aSwgcmkpO1xuICAgICAgICAgICAgcmkudnN1YihiaS5wb3NpdGlvbiwgcmkpO1xuICAgICAgICAgICAgcmoudmFkZCh4aiwgcmopO1xuICAgICAgICAgICAgcmoudnN1Yihiai5wb3NpdGlvbiwgcmopO1xuXG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHIsIHRoaXMuZnJpY3Rpb25SZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiUG9pbnQgZm91bmQgaW5zaWRlIGNvbnZleCwgYnV0IGRpZCBub3QgZmluZCBwZW5ldHJhdGluZyBmYWNlIVwiKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5CT1ggfCBTaGFwZS50eXBlcy5IRUlHSFRGSUVMRF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmJveEhlaWdodGZpZWxkID0gZnVuY3Rpb24gKHNpLHNqLHhpLHhqLHFpLHFqLGJpLGJqKXtcbiAgICBzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24ubWF0ZXJpYWwgPSBzaS5tYXRlcmlhbDtcbiAgICBzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24uY29sbGlzaW9uUmVzcG9uc2UgPSBzaS5jb2xsaXNpb25SZXNwb25zZTtcbiAgICB0aGlzLmNvbnZleEhlaWdodGZpZWxkKHNpLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbixzaix4aSx4aixxaSxxaixiaSxiaik7XG59O1xuXG52YXIgY29udmV4SGVpZ2h0ZmllbGRfdG1wMSA9IG5ldyBWZWMzKCk7XG52YXIgY29udmV4SGVpZ2h0ZmllbGRfdG1wMiA9IG5ldyBWZWMzKCk7XG52YXIgY29udmV4SGVpZ2h0ZmllbGRfZmFjZUxpc3QgPSBbMF07XG5cbi8qKlxuICogQG1ldGhvZCBjb252ZXhIZWlnaHRmaWVsZFxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTiB8IFNoYXBlLnR5cGVzLkhFSUdIVEZJRUxEXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY29udmV4SGVpZ2h0ZmllbGQgPSBmdW5jdGlvbiAoXG4gICAgY29udmV4U2hhcGUsXG4gICAgaGZTaGFwZSxcbiAgICBjb252ZXhQb3MsXG4gICAgaGZQb3MsXG4gICAgY29udmV4UXVhdCxcbiAgICBoZlF1YXQsXG4gICAgY29udmV4Qm9keSxcbiAgICBoZkJvZHlcbil7XG4gICAgdmFyIGRhdGEgPSBoZlNoYXBlLmRhdGEsXG4gICAgICAgIHcgPSBoZlNoYXBlLmVsZW1lbnRTaXplLFxuICAgICAgICByYWRpdXMgPSBjb252ZXhTaGFwZS5ib3VuZGluZ1NwaGVyZVJhZGl1cyxcbiAgICAgICAgd29ybGRQaWxsYXJPZmZzZXQgPSBjb252ZXhIZWlnaHRmaWVsZF90bXAyLFxuICAgICAgICBmYWNlTGlzdCA9IGNvbnZleEhlaWdodGZpZWxkX2ZhY2VMaXN0O1xuXG4gICAgLy8gR2V0IHNwaGVyZSBwb3NpdGlvbiB0byBoZWlnaHRmaWVsZCBsb2NhbCFcbiAgICB2YXIgbG9jYWxDb252ZXhQb3MgPSBjb252ZXhIZWlnaHRmaWVsZF90bXAxO1xuICAgIFRyYW5zZm9ybS5wb2ludFRvTG9jYWxGcmFtZShoZlBvcywgaGZRdWF0LCBjb252ZXhQb3MsIGxvY2FsQ29udmV4UG9zKTtcblxuICAgIC8vIEdldCB0aGUgaW5kZXggb2YgdGhlIGRhdGEgcG9pbnRzIHRvIHRlc3QgYWdhaW5zdFxuICAgIHZhciBpTWluWCA9IE1hdGguZmxvb3IoKGxvY2FsQ29udmV4UG9zLnggLSByYWRpdXMpIC8gdykgLSAxLFxuICAgICAgICBpTWF4WCA9IE1hdGguY2VpbCgobG9jYWxDb252ZXhQb3MueCArIHJhZGl1cykgLyB3KSArIDEsXG4gICAgICAgIGlNaW5ZID0gTWF0aC5mbG9vcigobG9jYWxDb252ZXhQb3MueSAtIHJhZGl1cykgLyB3KSAtIDEsXG4gICAgICAgIGlNYXhZID0gTWF0aC5jZWlsKChsb2NhbENvbnZleFBvcy55ICsgcmFkaXVzKSAvIHcpICsgMTtcblxuICAgIC8vIEJhaWwgb3V0IGlmIHdlIGFyZSBvdXQgb2YgdGhlIHRlcnJhaW5cbiAgICBpZihpTWF4WCA8IDAgfHwgaU1heFkgPCAwIHx8IGlNaW5YID4gZGF0YS5sZW5ndGggfHwgaU1pblkgPiBkYXRhWzBdLmxlbmd0aCl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDbGFtcCBpbmRleCB0byBlZGdlc1xuICAgIGlmKGlNaW5YIDwgMCl7IGlNaW5YID0gMDsgfVxuICAgIGlmKGlNYXhYIDwgMCl7IGlNYXhYID0gMDsgfVxuICAgIGlmKGlNaW5ZIDwgMCl7IGlNaW5ZID0gMDsgfVxuICAgIGlmKGlNYXhZIDwgMCl7IGlNYXhZID0gMDsgfVxuICAgIGlmKGlNaW5YID49IGRhdGEubGVuZ3RoKXsgaU1pblggPSBkYXRhLmxlbmd0aCAtIDE7IH1cbiAgICBpZihpTWF4WCA+PSBkYXRhLmxlbmd0aCl7IGlNYXhYID0gZGF0YS5sZW5ndGggLSAxOyB9XG4gICAgaWYoaU1heFkgPj0gZGF0YVswXS5sZW5ndGgpeyBpTWF4WSA9IGRhdGFbMF0ubGVuZ3RoIC0gMTsgfVxuICAgIGlmKGlNaW5ZID49IGRhdGFbMF0ubGVuZ3RoKXsgaU1pblkgPSBkYXRhWzBdLmxlbmd0aCAtIDE7IH1cblxuICAgIHZhciBtaW5NYXggPSBbXTtcbiAgICBoZlNoYXBlLmdldFJlY3RNaW5NYXgoaU1pblgsIGlNaW5ZLCBpTWF4WCwgaU1heFksIG1pbk1heCk7XG4gICAgdmFyIG1pbiA9IG1pbk1heFswXTtcbiAgICB2YXIgbWF4ID0gbWluTWF4WzFdO1xuXG4gICAgLy8gQmFpbCBvdXQgaWYgd2UncmUgY2FudCB0b3VjaCB0aGUgYm91bmRpbmcgaGVpZ2h0IGJveFxuICAgIGlmKGxvY2FsQ29udmV4UG9zLnogLSByYWRpdXMgPiBtYXggfHwgbG9jYWxDb252ZXhQb3MueiArIHJhZGl1cyA8IG1pbil7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IodmFyIGkgPSBpTWluWDsgaSA8IGlNYXhYOyBpKyspe1xuICAgICAgICBmb3IodmFyIGogPSBpTWluWTsgaiA8IGlNYXhZOyBqKyspe1xuXG4gICAgICAgICAgICAvLyBMb3dlciB0cmlhbmdsZVxuICAgICAgICAgICAgaGZTaGFwZS5nZXRDb252ZXhUcmlhbmdsZVBpbGxhcihpLCBqLCBmYWxzZSk7XG4gICAgICAgICAgICBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUoaGZQb3MsIGhmUXVhdCwgaGZTaGFwZS5waWxsYXJPZmZzZXQsIHdvcmxkUGlsbGFyT2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChjb252ZXhQb3MuZGlzdGFuY2VUbyh3b3JsZFBpbGxhck9mZnNldCkgPCBoZlNoYXBlLnBpbGxhckNvbnZleC5ib3VuZGluZ1NwaGVyZVJhZGl1cyArIGNvbnZleFNoYXBlLmJvdW5kaW5nU3BoZXJlUmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb252ZXhDb252ZXgoY29udmV4U2hhcGUsIGhmU2hhcGUucGlsbGFyQ29udmV4LCBjb252ZXhQb3MsIHdvcmxkUGlsbGFyT2Zmc2V0LCBjb252ZXhRdWF0LCBoZlF1YXQsIGNvbnZleEJvZHksIGhmQm9keSwgbnVsbCwgbnVsbCwgZmFjZUxpc3QsIG51bGwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVcHBlciB0cmlhbmdsZVxuICAgICAgICAgICAgaGZTaGFwZS5nZXRDb252ZXhUcmlhbmdsZVBpbGxhcihpLCBqLCB0cnVlKTtcbiAgICAgICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZShoZlBvcywgaGZRdWF0LCBoZlNoYXBlLnBpbGxhck9mZnNldCwgd29ybGRQaWxsYXJPZmZzZXQpO1xuICAgICAgICAgICAgaWYgKGNvbnZleFBvcy5kaXN0YW5jZVRvKHdvcmxkUGlsbGFyT2Zmc2V0KSA8IGhmU2hhcGUucGlsbGFyQ29udmV4LmJvdW5kaW5nU3BoZXJlUmFkaXVzICsgY29udmV4U2hhcGUuYm91bmRpbmdTcGhlcmVSYWRpdXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnZleENvbnZleChjb252ZXhTaGFwZSwgaGZTaGFwZS5waWxsYXJDb252ZXgsIGNvbnZleFBvcywgd29ybGRQaWxsYXJPZmZzZXQsIGNvbnZleFF1YXQsIGhmUXVhdCwgY29udmV4Qm9keSwgaGZCb2R5LCBudWxsLCBudWxsLCBmYWNlTGlzdCwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgc3BoZXJlSGVpZ2h0ZmllbGRfdG1wMSA9IG5ldyBWZWMzKCk7XG52YXIgc3BoZXJlSGVpZ2h0ZmllbGRfdG1wMiA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogQG1ldGhvZCBzcGhlcmVIZWlnaHRmaWVsZFxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuU1BIRVJFIHwgU2hhcGUudHlwZXMuSEVJR0hURklFTERdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5zcGhlcmVIZWlnaHRmaWVsZCA9IGZ1bmN0aW9uIChcbiAgICBzcGhlcmVTaGFwZSxcbiAgICBoZlNoYXBlLFxuICAgIHNwaGVyZVBvcyxcbiAgICBoZlBvcyxcbiAgICBzcGhlcmVRdWF0LFxuICAgIGhmUXVhdCxcbiAgICBzcGhlcmVCb2R5LFxuICAgIGhmQm9keVxuKXtcbiAgICB2YXIgZGF0YSA9IGhmU2hhcGUuZGF0YSxcbiAgICAgICAgcmFkaXVzID0gc3BoZXJlU2hhcGUucmFkaXVzLFxuICAgICAgICB3ID0gaGZTaGFwZS5lbGVtZW50U2l6ZSxcbiAgICAgICAgd29ybGRQaWxsYXJPZmZzZXQgPSBzcGhlcmVIZWlnaHRmaWVsZF90bXAyO1xuXG4gICAgLy8gR2V0IHNwaGVyZSBwb3NpdGlvbiB0byBoZWlnaHRmaWVsZCBsb2NhbCFcbiAgICB2YXIgbG9jYWxTcGhlcmVQb3MgPSBzcGhlcmVIZWlnaHRmaWVsZF90bXAxO1xuICAgIFRyYW5zZm9ybS5wb2ludFRvTG9jYWxGcmFtZShoZlBvcywgaGZRdWF0LCBzcGhlcmVQb3MsIGxvY2FsU3BoZXJlUG9zKTtcblxuICAgIC8vIEdldCB0aGUgaW5kZXggb2YgdGhlIGRhdGEgcG9pbnRzIHRvIHRlc3QgYWdhaW5zdFxuICAgIHZhciBpTWluWCA9IE1hdGguZmxvb3IoKGxvY2FsU3BoZXJlUG9zLnggLSByYWRpdXMpIC8gdykgLSAxLFxuICAgICAgICBpTWF4WCA9IE1hdGguY2VpbCgobG9jYWxTcGhlcmVQb3MueCArIHJhZGl1cykgLyB3KSArIDEsXG4gICAgICAgIGlNaW5ZID0gTWF0aC5mbG9vcigobG9jYWxTcGhlcmVQb3MueSAtIHJhZGl1cykgLyB3KSAtIDEsXG4gICAgICAgIGlNYXhZID0gTWF0aC5jZWlsKChsb2NhbFNwaGVyZVBvcy55ICsgcmFkaXVzKSAvIHcpICsgMTtcblxuICAgIC8vIEJhaWwgb3V0IGlmIHdlIGFyZSBvdXQgb2YgdGhlIHRlcnJhaW5cbiAgICBpZihpTWF4WCA8IDAgfHwgaU1heFkgPCAwIHx8IGlNaW5YID4gZGF0YS5sZW5ndGggfHwgaU1heFkgPiBkYXRhWzBdLmxlbmd0aCl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDbGFtcCBpbmRleCB0byBlZGdlc1xuICAgIGlmKGlNaW5YIDwgMCl7IGlNaW5YID0gMDsgfVxuICAgIGlmKGlNYXhYIDwgMCl7IGlNYXhYID0gMDsgfVxuICAgIGlmKGlNaW5ZIDwgMCl7IGlNaW5ZID0gMDsgfVxuICAgIGlmKGlNYXhZIDwgMCl7IGlNYXhZID0gMDsgfVxuICAgIGlmKGlNaW5YID49IGRhdGEubGVuZ3RoKXsgaU1pblggPSBkYXRhLmxlbmd0aCAtIDE7IH1cbiAgICBpZihpTWF4WCA+PSBkYXRhLmxlbmd0aCl7IGlNYXhYID0gZGF0YS5sZW5ndGggLSAxOyB9XG4gICAgaWYoaU1heFkgPj0gZGF0YVswXS5sZW5ndGgpeyBpTWF4WSA9IGRhdGFbMF0ubGVuZ3RoIC0gMTsgfVxuICAgIGlmKGlNaW5ZID49IGRhdGFbMF0ubGVuZ3RoKXsgaU1pblkgPSBkYXRhWzBdLmxlbmd0aCAtIDE7IH1cblxuICAgIHZhciBtaW5NYXggPSBbXTtcbiAgICBoZlNoYXBlLmdldFJlY3RNaW5NYXgoaU1pblgsIGlNaW5ZLCBpTWF4WCwgaU1heFksIG1pbk1heCk7XG4gICAgdmFyIG1pbiA9IG1pbk1heFswXTtcbiAgICB2YXIgbWF4ID0gbWluTWF4WzFdO1xuXG4gICAgLy8gQmFpbCBvdXQgaWYgd2UncmUgY2FudCB0b3VjaCB0aGUgYm91bmRpbmcgaGVpZ2h0IGJveFxuICAgIGlmKGxvY2FsU3BoZXJlUG9zLnogLSByYWRpdXMgPiBtYXggfHwgbG9jYWxTcGhlcmVQb3MueiArIHJhZGl1cyA8IG1pbil7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5yZXN1bHQ7XG4gICAgZm9yKHZhciBpID0gaU1pblg7IGkgPCBpTWF4WDsgaSsrKXtcbiAgICAgICAgZm9yKHZhciBqID0gaU1pblk7IGogPCBpTWF4WTsgaisrKXtcblxuICAgICAgICAgICAgdmFyIG51bUNvbnRhY3RzQmVmb3JlID0gcmVzdWx0Lmxlbmd0aDtcblxuICAgICAgICAgICAgLy8gTG93ZXIgdHJpYW5nbGVcbiAgICAgICAgICAgIGhmU2hhcGUuZ2V0Q29udmV4VHJpYW5nbGVQaWxsYXIoaSwgaiwgZmFsc2UpO1xuICAgICAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKGhmUG9zLCBoZlF1YXQsIGhmU2hhcGUucGlsbGFyT2Zmc2V0LCB3b3JsZFBpbGxhck9mZnNldCk7XG4gICAgICAgICAgICBpZiAoc3BoZXJlUG9zLmRpc3RhbmNlVG8od29ybGRQaWxsYXJPZmZzZXQpIDwgaGZTaGFwZS5waWxsYXJDb252ZXguYm91bmRpbmdTcGhlcmVSYWRpdXMgKyBzcGhlcmVTaGFwZS5ib3VuZGluZ1NwaGVyZVJhZGl1cykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3BoZXJlQ29udmV4KHNwaGVyZVNoYXBlLCBoZlNoYXBlLnBpbGxhckNvbnZleCwgc3BoZXJlUG9zLCB3b3JsZFBpbGxhck9mZnNldCwgc3BoZXJlUXVhdCwgaGZRdWF0LCBzcGhlcmVCb2R5LCBoZkJvZHkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVcHBlciB0cmlhbmdsZVxuICAgICAgICAgICAgaGZTaGFwZS5nZXRDb252ZXhUcmlhbmdsZVBpbGxhcihpLCBqLCB0cnVlKTtcbiAgICAgICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZShoZlBvcywgaGZRdWF0LCBoZlNoYXBlLnBpbGxhck9mZnNldCwgd29ybGRQaWxsYXJPZmZzZXQpO1xuICAgICAgICAgICAgaWYgKHNwaGVyZVBvcy5kaXN0YW5jZVRvKHdvcmxkUGlsbGFyT2Zmc2V0KSA8IGhmU2hhcGUucGlsbGFyQ29udmV4LmJvdW5kaW5nU3BoZXJlUmFkaXVzICsgc3BoZXJlU2hhcGUuYm91bmRpbmdTcGhlcmVSYWRpdXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNwaGVyZUNvbnZleChzcGhlcmVTaGFwZSwgaGZTaGFwZS5waWxsYXJDb252ZXgsIHNwaGVyZVBvcywgd29ybGRQaWxsYXJPZmZzZXQsIHNwaGVyZVF1YXQsIGhmUXVhdCwgc3BoZXJlQm9keSwgaGZCb2R5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG51bUNvbnRhY3RzID0gcmVzdWx0Lmxlbmd0aCAtIG51bUNvbnRhY3RzQmVmb3JlO1xuXG4gICAgICAgICAgICBpZihudW1Db250YWN0cyA+IDIpe1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAvLyBTa2lwIGFsbCBidXQgMVxuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBudW1Db250YWN0cyAtIDE7IGsrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICovXG4gICAgICAgIH1cbiAgICB9XG59O1xuXG59LHtcIi4uL2NvbGxpc2lvbi9BQUJCXCI6MyxcIi4uL2NvbGxpc2lvbi9SYXlcIjo5LFwiLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvblwiOjE5LFwiLi4vZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb25cIjoyMSxcIi4uL21hdGgvUXVhdGVybmlvblwiOjI4LFwiLi4vbWF0aC9UcmFuc2Zvcm1cIjoyOSxcIi4uL21hdGgvVmVjM1wiOjMwLFwiLi4vc2hhcGVzL0NvbnZleFBvbHloZWRyb25cIjozOCxcIi4uL3NoYXBlcy9TaGFwZVwiOjQzLFwiLi4vc29sdmVyL1NvbHZlclwiOjQ3LFwiLi4vdXRpbHMvVmVjM1Bvb2xcIjo1NH1dLDU2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qIGdsb2JhbCBwZXJmb3JtYW5jZSAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdvcmxkO1xuXG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvU2hhcGUnKTtcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XG52YXIgUXVhdGVybmlvbiA9IF9kZXJlcV8oJy4uL21hdGgvUXVhdGVybmlvbicpO1xudmFyIEdTU29sdmVyID0gX2RlcmVxXygnLi4vc29sdmVyL0dTU29sdmVyJyk7XG52YXIgVmVjM1Bvb2wgPSBfZGVyZXFfKCcuLi91dGlscy9WZWMzUG9vbCcpO1xudmFyIENvbnRhY3RFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9Db250YWN0RXF1YXRpb24nKTtcbnZhciBGcmljdGlvbkVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb24nKTtcbnZhciBOYXJyb3dwaGFzZSA9IF9kZXJlcV8oJy4vTmFycm93cGhhc2UnKTtcbnZhciBFdmVudFRhcmdldCA9IF9kZXJlcV8oJy4uL3V0aWxzL0V2ZW50VGFyZ2V0Jyk7XG52YXIgQXJyYXlDb2xsaXNpb25NYXRyaXggPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vQXJyYXlDb2xsaXNpb25NYXRyaXgnKTtcbnZhciBNYXRlcmlhbCA9IF9kZXJlcV8oJy4uL21hdGVyaWFsL01hdGVyaWFsJyk7XG52YXIgQ29udGFjdE1hdGVyaWFsID0gX2RlcmVxXygnLi4vbWF0ZXJpYWwvQ29udGFjdE1hdGVyaWFsJyk7XG52YXIgQm9keSA9IF9kZXJlcV8oJy4uL29iamVjdHMvQm9keScpO1xudmFyIFR1cGxlRGljdGlvbmFyeSA9IF9kZXJlcV8oJy4uL3V0aWxzL1R1cGxlRGljdGlvbmFyeScpO1xudmFyIFJheWNhc3RSZXN1bHQgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdCcpO1xudmFyIEFBQkIgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vQUFCQicpO1xudmFyIFJheSA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9SYXknKTtcbnZhciBOYWl2ZUJyb2FkcGhhc2UgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vTmFpdmVCcm9hZHBoYXNlJyk7XG5cbi8qKlxuICogVGhlIHBoeXNpY3Mgd29ybGRcbiAqIEBjbGFzcyBXb3JsZFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBFdmVudFRhcmdldFxuICovXG5mdW5jdGlvbiBXb3JsZCgpe1xuICAgIEV2ZW50VGFyZ2V0LmFwcGx5KHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudGx5IC8gbGFzdCB1c2VkIHRpbWVzdGVwLiBJcyBzZXQgdG8gLTEgaWYgbm90IGF2YWlsYWJsZS4gVGhpcyB2YWx1ZSBpcyB1cGRhdGVkIGJlZm9yZSBlYWNoIGludGVybmFsIHN0ZXAsIHdoaWNoIG1lYW5zIHRoYXQgaXQgaXMgXCJmcmVzaFwiIGluc2lkZSBldmVudCBjYWxsYmFja3MuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGR0XG4gICAgICovXG4gICAgdGhpcy5kdCA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogTWFrZXMgYm9kaWVzIGdvIHRvIHNsZWVwIHdoZW4gdGhleSd2ZSBiZWVuIGluYWN0aXZlXG4gICAgICogQHByb3BlcnR5IGFsbG93U2xlZXBcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmFsbG93U2xlZXAgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEFsbCB0aGUgY3VycmVudCBjb250YWN0cyAoaW5zdGFuY2VzIG9mIENvbnRhY3RFcXVhdGlvbikgaW4gdGhlIHdvcmxkLlxuICAgICAqIEBwcm9wZXJ0eSBjb250YWN0c1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRhY3RzID0gW107XG4gICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogSG93IG9mdGVuIHRvIG5vcm1hbGl6ZSBxdWF0ZXJuaW9ucy4gU2V0IHRvIDAgZm9yIGV2ZXJ5IHN0ZXAsIDEgZm9yIGV2ZXJ5IHNlY29uZCBldGMuLiBBIGxhcmdlciB2YWx1ZSBpbmNyZWFzZXMgcGVyZm9ybWFuY2UuIElmIGJvZGllcyB0ZW5kIHRvIGV4cGxvZGUsIHNldCB0byBhIHNtYWxsZXIgdmFsdWUgKHplcm8gdG8gYmUgc3VyZSBub3RoaW5nIGNhbiBnbyB3cm9uZykuXG4gICAgICogQHByb3BlcnR5IHF1YXROb3JtYWxpemVTa2lwXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnF1YXROb3JtYWxpemVTa2lwID0gMDtcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIHRvIHVzZSBmYXN0IHF1YXRlcm5pb24gbm9ybWFsaXphdGlvbi4gSXQgaXMgb2Z0ZW4gZW5vdWdoIGFjY3VyYXRlIHRvIHVzZS4gSWYgYm9kaWVzIHRlbmQgdG8gZXhwbG9kZSwgc2V0IHRvIGZhbHNlLlxuICAgICAqIEBwcm9wZXJ0eSBxdWF0Tm9ybWFsaXplRmFzdFxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBzZWUgUXVhdGVybmlvbi5ub3JtYWxpemVGYXN0XG4gICAgICogQHNlZSBRdWF0ZXJuaW9uLm5vcm1hbGl6ZVxuICAgICAqL1xuICAgIHRoaXMucXVhdE5vcm1hbGl6ZUZhc3QgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB3YWxsLWNsb2NrIHRpbWUgc2luY2Ugc2ltdWxhdGlvbiBzdGFydFxuICAgICAqIEBwcm9wZXJ0eSB0aW1lXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRpbWUgPSAwLjA7XG5cbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2YgdGltZXN0ZXBzIHRha2VuIHNpbmNlIHN0YXJ0XG4gICAgICogQHByb3BlcnR5IHN0ZXBudW1iZXJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc3RlcG51bWJlciA9IDA7XG5cbiAgICAvLy8gRGVmYXVsdCBhbmQgbGFzdCB0aW1lc3RlcCBzaXplc1xuICAgIHRoaXMuZGVmYXVsdF9kdCA9IDEvNjA7XG5cbiAgICB0aGlzLm5leHRJZCA9IDA7XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGdyYXZpdHlcbiAgICAgKiBAdHlwZSB7VmVjM31cbiAgICAgKi9cbiAgICB0aGlzLmdyYXZpdHkgPSBuZXcgVmVjMygpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGJyb2FkcGhhc2VcbiAgICAgKiBAdHlwZSB7QnJvYWRwaGFzZX1cbiAgICAgKi9cbiAgICB0aGlzLmJyb2FkcGhhc2UgPSBuZXcgTmFpdmVCcm9hZHBoYXNlKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgYm9kaWVzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuYm9kaWVzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgc29sdmVyXG4gICAgICogQHR5cGUge1NvbHZlcn1cbiAgICAgKi9cbiAgICB0aGlzLnNvbHZlciA9IG5ldyBHU1NvbHZlcigpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGNvbnN0cmFpbnRzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuY29uc3RyYWludHMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBuYXJyb3dwaGFzZVxuICAgICAqIEB0eXBlIHtOYXJyb3dwaGFzZX1cbiAgICAgKi9cbiAgICB0aGlzLm5hcnJvd3BoYXNlID0gbmV3IE5hcnJvd3BoYXNlKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtBcnJheUNvbGxpc2lvbk1hdHJpeH0gY29sbGlzaW9uTWF0cml4XG5cdCAqIEB0eXBlIHtBcnJheUNvbGxpc2lvbk1hdHJpeH1cblx0ICovXG5cdHRoaXMuY29sbGlzaW9uTWF0cml4ID0gbmV3IEFycmF5Q29sbGlzaW9uTWF0cml4KCk7XG5cbiAgICAvKipcbiAgICAgKiBDb2xsaXNpb25NYXRyaXggZnJvbSB0aGUgcHJldmlvdXMgc3RlcC5cbiAgICAgKiBAcHJvcGVydHkge0FycmF5Q29sbGlzaW9uTWF0cml4fSBjb2xsaXNpb25NYXRyaXhQcmV2aW91c1xuXHQgKiBAdHlwZSB7QXJyYXlDb2xsaXNpb25NYXRyaXh9XG5cdCAqL1xuXHR0aGlzLmNvbGxpc2lvbk1hdHJpeFByZXZpb3VzID0gbmV3IEFycmF5Q29sbGlzaW9uTWF0cml4KCk7XG5cbiAgICAvKipcbiAgICAgKiBBbGwgYWRkZWQgbWF0ZXJpYWxzXG4gICAgICogQHByb3BlcnR5IG1hdGVyaWFsc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLm1hdGVyaWFscyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGNvbnRhY3RtYXRlcmlhbHNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5jb250YWN0bWF0ZXJpYWxzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGxvb2sgdXAgYSBDb250YWN0TWF0ZXJpYWwgZ2l2ZW4gdHdvIGluc3RhbmNlcyBvZiBNYXRlcmlhbC5cbiAgICAgKiBAcHJvcGVydHkge1R1cGxlRGljdGlvbmFyeX0gY29udGFjdE1hdGVyaWFsVGFibGVcbiAgICAgKi9cbiAgICB0aGlzLmNvbnRhY3RNYXRlcmlhbFRhYmxlID0gbmV3IFR1cGxlRGljdGlvbmFyeSgpO1xuXG4gICAgdGhpcy5kZWZhdWx0TWF0ZXJpYWwgPSBuZXcgTWF0ZXJpYWwoXCJkZWZhdWx0XCIpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBjb250YWN0IG1hdGVyaWFsIGlzIHVzZWQgaWYgbm8gc3VpdGFibGUgY29udGFjdG1hdGVyaWFsIGlzIGZvdW5kIGZvciBhIGNvbnRhY3QuXG4gICAgICogQHByb3BlcnR5IGRlZmF1bHRDb250YWN0TWF0ZXJpYWxcbiAgICAgKiBAdHlwZSB7Q29udGFjdE1hdGVyaWFsfVxuICAgICAqL1xuICAgIHRoaXMuZGVmYXVsdENvbnRhY3RNYXRlcmlhbCA9IG5ldyBDb250YWN0TWF0ZXJpYWwodGhpcy5kZWZhdWx0TWF0ZXJpYWwsIHRoaXMuZGVmYXVsdE1hdGVyaWFsLCB7IGZyaWN0aW9uOiAwLjMsIHJlc3RpdHV0aW9uOiAwLjAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgZG9Qcm9maWxpbmdcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmRvUHJvZmlsaW5nID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgcHJvZmlsZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5wcm9maWxlID0ge1xuICAgICAgICBzb2x2ZTowLFxuICAgICAgICBtYWtlQ29udGFjdENvbnN0cmFpbnRzOjAsXG4gICAgICAgIGJyb2FkcGhhc2U6MCxcbiAgICAgICAgaW50ZWdyYXRlOjAsXG4gICAgICAgIG5hcnJvd3BoYXNlOjAsXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBzdWJzeXN0ZW1zXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuc3Vic3lzdGVtcyA9IFtdO1xuXG4gICAgdGhpcy5hZGRCb2R5RXZlbnQgPSB7XG4gICAgICAgIHR5cGU6XCJhZGRCb2R5XCIsXG4gICAgICAgIGJvZHkgOiBudWxsLFxuICAgIH07XG5cbiAgICB0aGlzLnJlbW92ZUJvZHlFdmVudCA9IHtcbiAgICAgICAgdHlwZTpcInJlbW92ZUJvZHlcIixcbiAgICAgICAgYm9keSA6IG51bGwsXG4gICAgfTtcbn1cbldvcmxkLnByb3RvdHlwZSA9IG5ldyBFdmVudFRhcmdldCgpO1xuXG4vLyBUZW1wIHN0dWZmXG52YXIgdG1wQUFCQjEgPSBuZXcgQUFCQigpO1xudmFyIHRtcEFycmF5MSA9IFtdO1xudmFyIHRtcFJheSA9IG5ldyBSYXkoKTtcblxuLyoqXG4gKiBHZXQgdGhlIGNvbnRhY3QgbWF0ZXJpYWwgYmV0d2VlbiBtYXRlcmlhbHMgbTEgYW5kIG0yXG4gKiBAbWV0aG9kIGdldENvbnRhY3RNYXRlcmlhbFxuICogQHBhcmFtIHtNYXRlcmlhbH0gbTFcbiAqIEBwYXJhbSB7TWF0ZXJpYWx9IG0yXG4gKiBAcmV0dXJuIHtDb250YWN0TWF0ZXJpYWx9IFRoZSBjb250YWN0IG1hdGVyaWFsIGlmIGl0IHdhcyBmb3VuZC5cbiAqL1xuV29ybGQucHJvdG90eXBlLmdldENvbnRhY3RNYXRlcmlhbCA9IGZ1bmN0aW9uKG0xLG0yKXtcbiAgICByZXR1cm4gdGhpcy5jb250YWN0TWF0ZXJpYWxUYWJsZS5nZXQobTEuaWQsbTIuaWQpOyAvL3RoaXMuY29udGFjdG1hdGVyaWFsc1t0aGlzLm1hdHMyY21hdFtpK2oqdGhpcy5tYXRlcmlhbHMubGVuZ3RoXV07XG59O1xuXG4vKipcbiAqIEdldCBudW1iZXIgb2Ygb2JqZWN0cyBpbiB0aGUgd29ybGQuXG4gKiBAbWV0aG9kIG51bU9iamVjdHNcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBkZXByZWNhdGVkXG4gKi9cbldvcmxkLnByb3RvdHlwZS5udW1PYmplY3RzID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5ib2RpZXMubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBTdG9yZSBvbGQgY29sbGlzaW9uIHN0YXRlIGluZm9cbiAqIEBtZXRob2QgY29sbGlzaW9uTWF0cml4VGlja1xuICovXG5Xb3JsZC5wcm90b3R5cGUuY29sbGlzaW9uTWF0cml4VGljayA9IGZ1bmN0aW9uKCl7XG5cdHZhciB0ZW1wID0gdGhpcy5jb2xsaXNpb25NYXRyaXhQcmV2aW91cztcblx0dGhpcy5jb2xsaXNpb25NYXRyaXhQcmV2aW91cyA9IHRoaXMuY29sbGlzaW9uTWF0cml4O1xuXHR0aGlzLmNvbGxpc2lvbk1hdHJpeCA9IHRlbXA7XG5cdHRoaXMuY29sbGlzaW9uTWF0cml4LnJlc2V0KCk7XG59O1xuXG4vKipcbiAqIEFkZCBhIHJpZ2lkIGJvZHkgdG8gdGhlIHNpbXVsYXRpb24uXG4gKiBAbWV0aG9kIGFkZFxuICogQHBhcmFtIHtCb2R5fSBib2R5XG4gKiBAdG9kbyBJZiB0aGUgc2ltdWxhdGlvbiBoYXMgbm90IHlldCBzdGFydGVkLCB3aHkgcmVjcmV0ZSBhbmQgY29weSBhcnJheXMgZm9yIGVhY2ggYm9keT8gQWNjdW11bGF0ZSBpbiBkeW5hbWljIGFycmF5cyBpbiB0aGlzIGNhc2UuXG4gKiBAdG9kbyBBZGRpbmcgYW4gYXJyYXkgb2YgYm9kaWVzIHNob3VsZCBiZSBwb3NzaWJsZS4gVGhpcyB3b3VsZCBzYXZlIHNvbWUgbG9vcHMgdG9vXG4gKiBAZGVwcmVjYXRlZCBVc2UgLmFkZEJvZHkgaW5zdGVhZFxuICovXG5Xb3JsZC5wcm90b3R5cGUuYWRkID0gV29ybGQucHJvdG90eXBlLmFkZEJvZHkgPSBmdW5jdGlvbihib2R5KXtcbiAgICBpZih0aGlzLmJvZGllcy5pbmRleE9mKGJvZHkpICE9PSAtMSl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYm9keS5pbmRleCA9IHRoaXMuYm9kaWVzLmxlbmd0aDtcbiAgICB0aGlzLmJvZGllcy5wdXNoKGJvZHkpO1xuICAgIGJvZHkud29ybGQgPSB0aGlzO1xuICAgIGJvZHkuaW5pdFBvc2l0aW9uLmNvcHkoYm9keS5wb3NpdGlvbik7XG4gICAgYm9keS5pbml0VmVsb2NpdHkuY29weShib2R5LnZlbG9jaXR5KTtcbiAgICBib2R5LnRpbWVMYXN0U2xlZXB5ID0gdGhpcy50aW1lO1xuICAgIGlmKGJvZHkgaW5zdGFuY2VvZiBCb2R5KXtcbiAgICAgICAgYm9keS5pbml0QW5ndWxhclZlbG9jaXR5LmNvcHkoYm9keS5hbmd1bGFyVmVsb2NpdHkpO1xuICAgICAgICBib2R5LmluaXRRdWF0ZXJuaW9uLmNvcHkoYm9keS5xdWF0ZXJuaW9uKTtcbiAgICB9XG5cdHRoaXMuY29sbGlzaW9uTWF0cml4LnNldE51bU9iamVjdHModGhpcy5ib2RpZXMubGVuZ3RoKTtcbiAgICB0aGlzLmFkZEJvZHlFdmVudC5ib2R5ID0gYm9keTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQodGhpcy5hZGRCb2R5RXZlbnQpO1xufTtcblxuLyoqXG4gKiBBZGQgYSBjb25zdHJhaW50IHRvIHRoZSBzaW11bGF0aW9uLlxuICogQG1ldGhvZCBhZGRDb25zdHJhaW50XG4gKiBAcGFyYW0ge0NvbnN0cmFpbnR9IGNcbiAqL1xuV29ybGQucHJvdG90eXBlLmFkZENvbnN0cmFpbnQgPSBmdW5jdGlvbihjKXtcbiAgICB0aGlzLmNvbnN0cmFpbnRzLnB1c2goYyk7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBjb25zdHJhaW50XG4gKiBAbWV0aG9kIHJlbW92ZUNvbnN0cmFpbnRcbiAqIEBwYXJhbSB7Q29uc3RyYWludH0gY1xuICovXG5Xb3JsZC5wcm90b3R5cGUucmVtb3ZlQ29uc3RyYWludCA9IGZ1bmN0aW9uKGMpe1xuICAgIHZhciBpZHggPSB0aGlzLmNvbnN0cmFpbnRzLmluZGV4T2YoYyk7XG4gICAgaWYoaWR4IT09LTEpe1xuICAgICAgICB0aGlzLmNvbnN0cmFpbnRzLnNwbGljZShpZHgsMSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSYXljYXN0IHRlc3RcbiAqIEBtZXRob2QgcmF5VGVzdFxuICogQHBhcmFtIHtWZWMzfSBmcm9tXG4gKiBAcGFyYW0ge1ZlYzN9IHRvXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufFJheWNhc3RSZXN1bHR9IHJlc3VsdFxuICogQGRlcHJlY2F0ZWQgVXNlIC5yYXljYXN0QWxsLCAucmF5Y2FzdENsb3Nlc3Qgb3IgLnJheWNhc3RBbnkgaW5zdGVhZC5cbiAqL1xuV29ybGQucHJvdG90eXBlLnJheVRlc3QgPSBmdW5jdGlvbihmcm9tLCB0bywgcmVzdWx0KXtcbiAgICBpZihyZXN1bHQgaW5zdGFuY2VvZiBSYXljYXN0UmVzdWx0KXtcbiAgICAgICAgLy8gRG8gcmF5Y2FzdGNsb3Nlc3RcbiAgICAgICAgdGhpcy5yYXljYXN0Q2xvc2VzdChmcm9tLCB0bywge1xuICAgICAgICAgICAgc2tpcEJhY2tmYWNlczogdHJ1ZVxuICAgICAgICB9LCByZXN1bHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERvIHJheWNhc3RBbGxcbiAgICAgICAgdGhpcy5yYXljYXN0QWxsKGZyb20sIHRvLCB7XG4gICAgICAgICAgICBza2lwQmFja2ZhY2VzOiB0cnVlXG4gICAgICAgIH0sIHJlc3VsdCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSYXkgY2FzdCBhZ2FpbnN0IGFsbCBib2RpZXMuIFRoZSBwcm92aWRlZCBjYWxsYmFjayB3aWxsIGJlIGV4ZWN1dGVkIGZvciBlYWNoIGhpdCB3aXRoIGEgUmF5Y2FzdFJlc3VsdCBhcyBzaW5nbGUgYXJndW1lbnQuXG4gKiBAbWV0aG9kIHJheWNhc3RBbGxcbiAqIEBwYXJhbSAge1ZlYzN9IGZyb21cbiAqIEBwYXJhbSAge1ZlYzN9IHRvXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uRmlsdGVyTWFzaz0tMV1cbiAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uRmlsdGVyR3JvdXA9LTFdXG4gKiBAcGFyYW0gIHtib29sZWFufSBbb3B0aW9ucy5za2lwQmFja2ZhY2VzPWZhbHNlXVxuICogQHBhcmFtICB7Ym9vbGVhbn0gW29wdGlvbnMuY2hlY2tDb2xsaXNpb25SZXNwb25zZT10cnVlXVxuICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFueSBib2R5IHdhcyBoaXQuXG4gKi9cbldvcmxkLnByb3RvdHlwZS5yYXljYXN0QWxsID0gZnVuY3Rpb24oZnJvbSwgdG8sIG9wdGlvbnMsIGNhbGxiYWNrKXtcbiAgICBvcHRpb25zLm1vZGUgPSBSYXkuQUxMO1xuICAgIG9wdGlvbnMuZnJvbSA9IGZyb207XG4gICAgb3B0aW9ucy50byA9IHRvO1xuICAgIG9wdGlvbnMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICByZXR1cm4gdG1wUmF5LmludGVyc2VjdFdvcmxkKHRoaXMsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBSYXkgY2FzdCwgYW5kIHN0b3AgYXQgdGhlIGZpcnN0IHJlc3VsdC4gTm90ZSB0aGF0IHRoZSBvcmRlciBpcyByYW5kb20gLSBidXQgdGhlIG1ldGhvZCBpcyBmYXN0LlxuICogQG1ldGhvZCByYXljYXN0QW55XG4gKiBAcGFyYW0gIHtWZWMzfSBmcm9tXG4gKiBAcGFyYW0gIHtWZWMzfSB0b1xuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLmNvbGxpc2lvbkZpbHRlck1hc2s9LTFdXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLmNvbGxpc2lvbkZpbHRlckdyb3VwPS0xXVxuICogQHBhcmFtICB7Ym9vbGVhbn0gW29wdGlvbnMuc2tpcEJhY2tmYWNlcz1mYWxzZV1cbiAqIEBwYXJhbSAge2Jvb2xlYW59IFtvcHRpb25zLmNoZWNrQ29sbGlzaW9uUmVzcG9uc2U9dHJ1ZV1cbiAqIEBwYXJhbSAge1JheWNhc3RSZXN1bHR9IHJlc3VsdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbnkgYm9keSB3YXMgaGl0LlxuICovXG5Xb3JsZC5wcm90b3R5cGUucmF5Y2FzdEFueSA9IGZ1bmN0aW9uKGZyb20sIHRvLCBvcHRpb25zLCByZXN1bHQpe1xuICAgIG9wdGlvbnMubW9kZSA9IFJheS5BTlk7XG4gICAgb3B0aW9ucy5mcm9tID0gZnJvbTtcbiAgICBvcHRpb25zLnRvID0gdG87XG4gICAgb3B0aW9ucy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgcmV0dXJuIHRtcFJheS5pbnRlcnNlY3RXb3JsZCh0aGlzLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogUmF5IGNhc3QsIGFuZCByZXR1cm4gaW5mb3JtYXRpb24gb2YgdGhlIGNsb3Nlc3QgaGl0LlxuICogQG1ldGhvZCByYXljYXN0Q2xvc2VzdFxuICogQHBhcmFtICB7VmVjM30gZnJvbVxuICogQHBhcmFtICB7VmVjM30gdG9cbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJNYXNrPS0xXVxuICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJHcm91cD0tMV1cbiAqIEBwYXJhbSAge2Jvb2xlYW59IFtvcHRpb25zLnNraXBCYWNrZmFjZXM9ZmFsc2VdXG4gKiBAcGFyYW0gIHtib29sZWFufSBbb3B0aW9ucy5jaGVja0NvbGxpc2lvblJlc3BvbnNlPXRydWVdXG4gKiBAcGFyYW0gIHtSYXljYXN0UmVzdWx0fSByZXN1bHRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW55IGJvZHkgd2FzIGhpdC5cbiAqL1xuV29ybGQucHJvdG90eXBlLnJheWNhc3RDbG9zZXN0ID0gZnVuY3Rpb24oZnJvbSwgdG8sIG9wdGlvbnMsIHJlc3VsdCl7XG4gICAgb3B0aW9ucy5tb2RlID0gUmF5LkNMT1NFU1Q7XG4gICAgb3B0aW9ucy5mcm9tID0gZnJvbTtcbiAgICBvcHRpb25zLnRvID0gdG87XG4gICAgb3B0aW9ucy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgcmV0dXJuIHRtcFJheS5pbnRlcnNlY3RXb3JsZCh0aGlzLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgcmlnaWQgYm9keSBmcm9tIHRoZSBzaW11bGF0aW9uLlxuICogQG1ldGhvZCByZW1vdmVcbiAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICogQGRlcHJlY2F0ZWQgVXNlIC5yZW1vdmVCb2R5IGluc3RlYWRcbiAqL1xuV29ybGQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGJvZHkpe1xuICAgIGJvZHkud29ybGQgPSBudWxsO1xuICAgIHZhciBuID0gdGhpcy5ib2RpZXMubGVuZ3RoLTEsXG4gICAgICAgIGJvZGllcyA9IHRoaXMuYm9kaWVzLFxuICAgICAgICBpZHggPSBib2RpZXMuaW5kZXhPZihib2R5KTtcbiAgICBpZihpZHggIT09IC0xKXtcbiAgICAgICAgYm9kaWVzLnNwbGljZShpZHgsIDEpOyAvLyBUb2RvOiBzaG91bGQgdXNlIGEgZ2FyYmFnZSBmcmVlIG1ldGhvZFxuXG4gICAgICAgIC8vIFJlY29tcHV0ZSBpbmRleFxuICAgICAgICBmb3IodmFyIGk9MDsgaSE9PWJvZGllcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBib2RpZXNbaV0uaW5kZXggPSBpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb2xsaXNpb25NYXRyaXguc2V0TnVtT2JqZWN0cyhuKTtcbiAgICAgICAgdGhpcy5yZW1vdmVCb2R5RXZlbnQuYm9keSA9IGJvZHk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh0aGlzLnJlbW92ZUJvZHlFdmVudCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgYSByaWdpZCBib2R5IGZyb20gdGhlIHNpbXVsYXRpb24uXG4gKiBAbWV0aG9kIHJlbW92ZUJvZHlcbiAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICovXG5Xb3JsZC5wcm90b3R5cGUucmVtb3ZlQm9keSA9IFdvcmxkLnByb3RvdHlwZS5yZW1vdmU7XG5cbi8qKlxuICogQWRkcyBhIG1hdGVyaWFsIHRvIHRoZSBXb3JsZC5cbiAqIEBtZXRob2QgYWRkTWF0ZXJpYWxcbiAqIEBwYXJhbSB7TWF0ZXJpYWx9IG1cbiAqIEB0b2RvIE5lY2Vzc2FyeT9cbiAqL1xuV29ybGQucHJvdG90eXBlLmFkZE1hdGVyaWFsID0gZnVuY3Rpb24obSl7XG4gICAgdGhpcy5tYXRlcmlhbHMucHVzaChtKTtcbn07XG5cbi8qKlxuICogQWRkcyBhIGNvbnRhY3QgbWF0ZXJpYWwgdG8gdGhlIFdvcmxkXG4gKiBAbWV0aG9kIGFkZENvbnRhY3RNYXRlcmlhbFxuICogQHBhcmFtIHtDb250YWN0TWF0ZXJpYWx9IGNtYXRcbiAqL1xuV29ybGQucHJvdG90eXBlLmFkZENvbnRhY3RNYXRlcmlhbCA9IGZ1bmN0aW9uKGNtYXQpIHtcblxuICAgIC8vIEFkZCBjb250YWN0IG1hdGVyaWFsXG4gICAgdGhpcy5jb250YWN0bWF0ZXJpYWxzLnB1c2goY21hdCk7XG5cbiAgICAvLyBBZGQgY3VycmVudCBjb250YWN0IG1hdGVyaWFsIHRvIHRoZSBtYXRlcmlhbCB0YWJsZVxuICAgIHRoaXMuY29udGFjdE1hdGVyaWFsVGFibGUuc2V0KGNtYXQubWF0ZXJpYWxzWzBdLmlkLGNtYXQubWF0ZXJpYWxzWzFdLmlkLGNtYXQpO1xufTtcblxuLy8gcGVyZm9ybWFuY2Uubm93KClcbmlmKHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ3VuZGVmaW5lZCcpe1xuICAgIHBlcmZvcm1hbmNlID0ge307XG59XG5pZighcGVyZm9ybWFuY2Uubm93KXtcbiAgICB2YXIgbm93T2Zmc2V0ID0gRGF0ZS5ub3coKTtcbiAgICBpZiAocGVyZm9ybWFuY2UudGltaW5nICYmIHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQpe1xuICAgICAgICBub3dPZmZzZXQgPSBwZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0O1xuICAgIH1cbiAgICBwZXJmb3JtYW5jZS5ub3cgPSBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIG5vd09mZnNldDtcbiAgICB9O1xufVxuXG52YXIgc3RlcF90bXAxID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBTdGVwIHRoZSBwaHlzaWNzIHdvcmxkIGZvcndhcmQgaW4gdGltZS5cbiAqXG4gKiBUaGVyZSBhcmUgdHdvIG1vZGVzLiBUaGUgc2ltcGxlIG1vZGUgaXMgZml4ZWQgdGltZXN0ZXBwaW5nIHdpdGhvdXQgaW50ZXJwb2xhdGlvbi4gSW4gdGhpcyBjYXNlIHlvdSBvbmx5IHVzZSB0aGUgZmlyc3QgYXJndW1lbnQuIFRoZSBzZWNvbmQgY2FzZSB1c2VzIGludGVycG9sYXRpb24uIEluIHRoYXQgeW91IGFsc28gcHJvdmlkZSB0aGUgdGltZSBzaW5jZSB0aGUgZnVuY3Rpb24gd2FzIGxhc3QgdXNlZCwgYXMgd2VsbCBhcyB0aGUgbWF4aW11bSBmaXhlZCB0aW1lc3RlcHMgdG8gdGFrZS5cbiAqXG4gKiBAbWV0aG9kIHN0ZXBcbiAqIEBwYXJhbSB7TnVtYmVyfSBkdCAgICAgICAgICAgICAgICAgICAgICAgVGhlIGZpeGVkIHRpbWUgc3RlcCBzaXplIHRvIHVzZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbdGltZVNpbmNlTGFzdENhbGxlZF0gICAgVGhlIHRpbWUgZWxhcHNlZCBzaW5jZSB0aGUgZnVuY3Rpb24gd2FzIGxhc3QgY2FsbGVkLlxuICogQHBhcmFtIHtOdW1iZXJ9IFttYXhTdWJTdGVwcz0xMF0gICAgICAgICBNYXhpbXVtIG51bWJlciBvZiBmaXhlZCBzdGVwcyB0byB0YWtlIHBlciBmdW5jdGlvbiBjYWxsLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgICAgLy8gZml4ZWQgdGltZXN0ZXBwaW5nIHdpdGhvdXQgaW50ZXJwb2xhdGlvblxuICogICAgIHdvcmxkLnN0ZXAoMS82MCk7XG4gKlxuICogQHNlZSBodHRwOi8vYnVsbGV0cGh5c2ljcy5vcmcvbWVkaWF3aWtpLTEuNS44L2luZGV4LnBocC9TdGVwcGluZ19UaGVfV29ybGRcbiAqL1xuV29ybGQucHJvdG90eXBlLnN0ZXAgPSBmdW5jdGlvbihkdCwgdGltZVNpbmNlTGFzdENhbGxlZCwgbWF4U3ViU3RlcHMpe1xuICAgIG1heFN1YlN0ZXBzID0gbWF4U3ViU3RlcHMgfHwgMTA7XG4gICAgdGltZVNpbmNlTGFzdENhbGxlZCA9IHRpbWVTaW5jZUxhc3RDYWxsZWQgfHwgMDtcblxuICAgIGlmKHRpbWVTaW5jZUxhc3RDYWxsZWQgPT09IDApeyAvLyBGaXhlZCwgc2ltcGxlIHN0ZXBwaW5nXG5cbiAgICAgICAgdGhpcy5pbnRlcm5hbFN0ZXAoZHQpO1xuXG4gICAgICAgIC8vIEluY3JlbWVudCB0aW1lXG4gICAgICAgIHRoaXMudGltZSArPSBkdDtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgbnVtYmVyIG9mIGZpeGVkIHN0ZXBzIHdlIHNob3VsZCBoYXZlIHRha2VuIHNpbmNlIHRoZSBsYXN0IHN0ZXBcbiAgICAgICAgdmFyIGludGVybmFsU3RlcHMgPSBNYXRoLmZsb29yKCh0aGlzLnRpbWUgKyB0aW1lU2luY2VMYXN0Q2FsbGVkKSAvIGR0KSAtIE1hdGguZmxvb3IodGhpcy50aW1lIC8gZHQpO1xuICAgICAgICBpbnRlcm5hbFN0ZXBzID0gTWF0aC5taW4oaW50ZXJuYWxTdGVwcyxtYXhTdWJTdGVwcyk7XG5cbiAgICAgICAgLy8gRG8gc29tZSBmaXhlZCBzdGVwcyB0byBjYXRjaCB1cFxuICAgICAgICB2YXIgdDAgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgZm9yKHZhciBpPTA7IGkhPT1pbnRlcm5hbFN0ZXBzOyBpKyspe1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbFN0ZXAoZHQpO1xuICAgICAgICAgICAgaWYocGVyZm9ybWFuY2Uubm93KCkgLSB0MCA+IGR0ICogMTAwMCl7XG4gICAgICAgICAgICAgICAgLy8gV2UgYXJlIHNsb3dlciB0aGFuIHJlYWwtdGltZS4gQmV0dGVyIGJhaWwgb3V0LlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5jcmVtZW50IGludGVybmFsIGNsb2NrXG4gICAgICAgIHRoaXMudGltZSArPSB0aW1lU2luY2VMYXN0Q2FsbGVkO1xuXG4gICAgICAgIC8vIENvbXB1dGUgXCJMZWZ0IG92ZXJcIiB0aW1lIHN0ZXBcbiAgICAgICAgdmFyIGggPSB0aGlzLnRpbWUgJSBkdDtcbiAgICAgICAgdmFyIGhfZGl2X2R0ID0gaCAvIGR0O1xuICAgICAgICB2YXIgaW50ZXJwdmVsbyA9IHN0ZXBfdG1wMTtcbiAgICAgICAgdmFyIGJvZGllcyA9IHRoaXMuYm9kaWVzO1xuXG4gICAgICAgIGZvcih2YXIgaj0wOyBqICE9PSBib2RpZXMubGVuZ3RoOyBqKyspe1xuICAgICAgICAgICAgdmFyIGIgPSBib2RpZXNbal07XG4gICAgICAgICAgICBpZihiLnR5cGUgIT09IEJvZHkuU1RBVElDICYmIGIuc2xlZXBTdGF0ZSAhPT0gQm9keS5TTEVFUElORyl7XG5cbiAgICAgICAgICAgICAgICAvLyBJbnRlcnBvbGF0ZVxuICAgICAgICAgICAgICAgIGIucG9zaXRpb24udnN1YihiLnByZXZpb3VzUG9zaXRpb24sIGludGVycHZlbG8pO1xuICAgICAgICAgICAgICAgIGludGVycHZlbG8uc2NhbGUoaF9kaXZfZHQsIGludGVycHZlbG8pO1xuICAgICAgICAgICAgICAgIGIucG9zaXRpb24udmFkZChpbnRlcnB2ZWxvLCBiLmludGVycG9sYXRlZFBvc2l0aW9uKTtcblxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGludGVycG9sYXRlIHF1YXRlcm5pb25cbiAgICAgICAgICAgICAgICAvLyBiLmludGVycG9sYXRlZEFuZ2xlID0gYi5hbmdsZSArIChiLmFuZ2xlIC0gYi5wcmV2aW91c0FuZ2xlKSAqIGhfZGl2X2R0O1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gRm9yIHN0YXRpYyBib2RpZXMsIGp1c3QgY29weS4gV2hvIGVsc2Ugd2lsbCBkbyBpdD9cbiAgICAgICAgICAgICAgICBiLmludGVycG9sYXRlZFBvc2l0aW9uLmNvcHkoYi5wb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgYi5pbnRlcnBvbGF0ZWRRdWF0ZXJuaW9uLmNvcHkoYi5xdWF0ZXJuaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogU3RlcCB0aGUgc2ltdWxhdGlvblxuICogQG1ldGhvZCBzdGVwXG4gKiBAcGFyYW0ge051bWJlcn0gZHRcbiAqL1xudmFyIFdvcmxkX3N0ZXBfcG9zdFN0ZXBFdmVudCA9IHt0eXBlOlwicG9zdFN0ZXBcIn0sIC8vIFJldXNhYmxlIGV2ZW50IG9iamVjdHMgdG8gc2F2ZSBtZW1vcnlcbiAgICBXb3JsZF9zdGVwX3ByZVN0ZXBFdmVudCA9IHt0eXBlOlwicHJlU3RlcFwifSxcbiAgICBXb3JsZF9zdGVwX2NvbGxpZGVFdmVudCA9IHt0eXBlOlwiY29sbGlkZVwiLCBib2R5Om51bGwsIGNvbnRhY3Q6bnVsbCB9LFxuICAgIFdvcmxkX3N0ZXBfb2xkQ29udGFjdHMgPSBbXSwgLy8gUG9vbHMgZm9yIHVudXNlZCBvYmplY3RzXG4gICAgV29ybGRfc3RlcF9mcmljdGlvbkVxdWF0aW9uUG9vbCA9IFtdLFxuICAgIFdvcmxkX3N0ZXBfcDEgPSBbXSwgLy8gUmV1c2FibGUgYXJyYXlzIGZvciBjb2xsaXNpb24gcGFpcnNcbiAgICBXb3JsZF9zdGVwX3AyID0gW10sXG4gICAgV29ybGRfc3RlcF9ndmVjID0gbmV3IFZlYzMoKSwgLy8gVGVtcG9yYXJ5IHZlY3RvcnMgYW5kIHF1YXRzXG4gICAgV29ybGRfc3RlcF92aSA9IG5ldyBWZWMzKCksXG4gICAgV29ybGRfc3RlcF92aiA9IG5ldyBWZWMzKCksXG4gICAgV29ybGRfc3RlcF93aSA9IG5ldyBWZWMzKCksXG4gICAgV29ybGRfc3RlcF93aiA9IG5ldyBWZWMzKCksXG4gICAgV29ybGRfc3RlcF90MSA9IG5ldyBWZWMzKCksXG4gICAgV29ybGRfc3RlcF90MiA9IG5ldyBWZWMzKCksXG4gICAgV29ybGRfc3RlcF9yaXhuID0gbmV3IFZlYzMoKSxcbiAgICBXb3JsZF9zdGVwX3JqeG4gPSBuZXcgVmVjMygpLFxuICAgIFdvcmxkX3N0ZXBfc3RlcF9xID0gbmV3IFF1YXRlcm5pb24oKSxcbiAgICBXb3JsZF9zdGVwX3N0ZXBfdyA9IG5ldyBRdWF0ZXJuaW9uKCksXG4gICAgV29ybGRfc3RlcF9zdGVwX3dxID0gbmV3IFF1YXRlcm5pb24oKSxcbiAgICBpbnZJX3RhdV9kdCA9IG5ldyBWZWMzKCk7XG5Xb3JsZC5wcm90b3R5cGUuaW50ZXJuYWxTdGVwID0gZnVuY3Rpb24oZHQpe1xuICAgIHRoaXMuZHQgPSBkdDtcblxuICAgIHZhciB3b3JsZCA9IHRoaXMsXG4gICAgICAgIHRoYXQgPSB0aGlzLFxuICAgICAgICBjb250YWN0cyA9IHRoaXMuY29udGFjdHMsXG4gICAgICAgIHAxID0gV29ybGRfc3RlcF9wMSxcbiAgICAgICAgcDIgPSBXb3JsZF9zdGVwX3AyLFxuICAgICAgICBOID0gdGhpcy5udW1PYmplY3RzKCksXG4gICAgICAgIGJvZGllcyA9IHRoaXMuYm9kaWVzLFxuICAgICAgICBzb2x2ZXIgPSB0aGlzLnNvbHZlcixcbiAgICAgICAgZ3Jhdml0eSA9IHRoaXMuZ3Jhdml0eSxcbiAgICAgICAgZG9Qcm9maWxpbmcgPSB0aGlzLmRvUHJvZmlsaW5nLFxuICAgICAgICBwcm9maWxlID0gdGhpcy5wcm9maWxlLFxuICAgICAgICBEWU5BTUlDID0gQm9keS5EWU5BTUlDLFxuICAgICAgICBwcm9maWxpbmdTdGFydCxcbiAgICAgICAgY29uc3RyYWludHMgPSB0aGlzLmNvbnN0cmFpbnRzLFxuICAgICAgICBmcmljdGlvbkVxdWF0aW9uUG9vbCA9IFdvcmxkX3N0ZXBfZnJpY3Rpb25FcXVhdGlvblBvb2wsXG4gICAgICAgIGdub3JtID0gZ3Jhdml0eS5ub3JtKCksXG4gICAgICAgIGd4ID0gZ3Jhdml0eS54LFxuICAgICAgICBneSA9IGdyYXZpdHkueSxcbiAgICAgICAgZ3ogPSBncmF2aXR5LnosXG4gICAgICAgIGk9MDtcblxuICAgIGlmKGRvUHJvZmlsaW5nKXtcbiAgICAgICAgcHJvZmlsaW5nU3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgZ3Jhdml0eSB0byBhbGwgb2JqZWN0c1xuICAgIGZvcihpPTA7IGkhPT1OOyBpKyspe1xuICAgICAgICB2YXIgYmkgPSBib2RpZXNbaV07XG4gICAgICAgIGlmKGJpLnR5cGUgJiBEWU5BTUlDKXsgLy8gT25seSBmb3IgZHluYW1pYyBib2RpZXNcbiAgICAgICAgICAgIHZhciBmID0gYmkuZm9yY2UsIG0gPSBiaS5tYXNzO1xuICAgICAgICAgICAgZi54ICs9IG0qZ3g7XG4gICAgICAgICAgICBmLnkgKz0gbSpneTtcbiAgICAgICAgICAgIGYueiArPSBtKmd6O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHN1YnN5c3RlbXNcbiAgICBmb3IodmFyIGk9MCwgTnN1YnN5c3RlbXM9dGhpcy5zdWJzeXN0ZW1zLmxlbmd0aDsgaSE9PU5zdWJzeXN0ZW1zOyBpKyspe1xuICAgICAgICB0aGlzLnN1YnN5c3RlbXNbaV0udXBkYXRlKCk7XG4gICAgfVxuXG4gICAgLy8gQ29sbGlzaW9uIGRldGVjdGlvblxuICAgIGlmKGRvUHJvZmlsaW5nKXsgcHJvZmlsaW5nU3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTsgfVxuICAgIHAxLmxlbmd0aCA9IDA7IC8vIENsZWFuIHVwIHBhaXIgYXJyYXlzIGZyb20gbGFzdCBzdGVwXG4gICAgcDIubGVuZ3RoID0gMDtcbiAgICB0aGlzLmJyb2FkcGhhc2UuY29sbGlzaW9uUGFpcnModGhpcyxwMSxwMik7XG4gICAgaWYoZG9Qcm9maWxpbmcpeyBwcm9maWxlLmJyb2FkcGhhc2UgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHByb2ZpbGluZ1N0YXJ0OyB9XG5cbiAgICAvLyBSZW1vdmUgY29uc3RyYWluZWQgcGFpcnMgd2l0aCBjb2xsaWRlQ29ubmVjdGVkID09IGZhbHNlXG4gICAgdmFyIE5jb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzLmxlbmd0aDtcbiAgICBmb3IoaT0wOyBpIT09TmNvbnN0cmFpbnRzOyBpKyspe1xuICAgICAgICB2YXIgYyA9IGNvbnN0cmFpbnRzW2ldO1xuICAgICAgICBpZighYy5jb2xsaWRlQ29ubmVjdGVkKXtcbiAgICAgICAgICAgIGZvcih2YXIgaiA9IHAxLmxlbmd0aC0xOyBqPj0wOyBqLT0xKXtcbiAgICAgICAgICAgICAgICBpZiggKGMuYm9keUEgPT09IHAxW2pdICYmIGMuYm9keUIgPT09IHAyW2pdKSB8fFxuICAgICAgICAgICAgICAgICAgICAoYy5ib2R5QiA9PT0gcDFbal0gJiYgYy5ib2R5QSA9PT0gcDJbal0pKXtcbiAgICAgICAgICAgICAgICAgICAgcDEuc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgICAgICAgICBwMi5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jb2xsaXNpb25NYXRyaXhUaWNrKCk7XG5cbiAgICAvLyBHZW5lcmF0ZSBjb250YWN0c1xuICAgIGlmKGRvUHJvZmlsaW5nKXsgcHJvZmlsaW5nU3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTsgfVxuICAgIHZhciBvbGRjb250YWN0cyA9IFdvcmxkX3N0ZXBfb2xkQ29udGFjdHM7XG4gICAgdmFyIE5vbGRDb250YWN0cyA9IGNvbnRhY3RzLmxlbmd0aDtcblxuICAgIGZvcihpPTA7IGkhPT1Ob2xkQ29udGFjdHM7IGkrKyl7XG4gICAgICAgIG9sZGNvbnRhY3RzLnB1c2goY29udGFjdHNbaV0pO1xuICAgIH1cbiAgICBjb250YWN0cy5sZW5ndGggPSAwO1xuXG4gICAgLy8gVHJhbnNmZXIgRnJpY3Rpb25FcXVhdGlvbiBmcm9tIGN1cnJlbnQgbGlzdCB0byB0aGUgcG9vbCBmb3IgcmV1c2VcbiAgICB2YXIgTm9sZEZyaWN0aW9uRXF1YXRpb25zID0gdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5sZW5ndGg7XG4gICAgZm9yKGk9MDsgaSE9PU5vbGRGcmljdGlvbkVxdWF0aW9uczsgaSsrKXtcbiAgICAgICAgZnJpY3Rpb25FcXVhdGlvblBvb2wucHVzaCh0aGlzLmZyaWN0aW9uRXF1YXRpb25zW2ldKTtcbiAgICB9XG4gICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5sZW5ndGggPSAwO1xuXG4gICAgdGhpcy5uYXJyb3dwaGFzZS5nZXRDb250YWN0cyhcbiAgICAgICAgcDEsXG4gICAgICAgIHAyLFxuICAgICAgICB0aGlzLFxuICAgICAgICBjb250YWN0cyxcbiAgICAgICAgb2xkY29udGFjdHMsIC8vIFRvIGJlIHJldXNlZFxuICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLFxuICAgICAgICBmcmljdGlvbkVxdWF0aW9uUG9vbFxuICAgICk7XG5cbiAgICBpZihkb1Byb2ZpbGluZyl7XG4gICAgICAgIHByb2ZpbGUubmFycm93cGhhc2UgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHByb2ZpbGluZ1N0YXJ0O1xuICAgIH1cblxuICAgIC8vIExvb3Agb3ZlciBhbGwgY29sbGlzaW9uc1xuICAgIGlmKGRvUHJvZmlsaW5nKXtcbiAgICAgICAgcHJvZmlsaW5nU3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgYWxsIGZyaWN0aW9uIGVxc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzb2x2ZXIuYWRkRXF1YXRpb24odGhpcy5mcmljdGlvbkVxdWF0aW9uc1tpXSk7XG4gICAgfVxuXG4gICAgdmFyIG5jb250YWN0cyA9IGNvbnRhY3RzLmxlbmd0aDtcbiAgICBmb3IodmFyIGs9MDsgayE9PW5jb250YWN0czsgaysrKXtcblxuICAgICAgICAvLyBDdXJyZW50IGNvbnRhY3RcbiAgICAgICAgdmFyIGMgPSBjb250YWN0c1trXTtcblxuICAgICAgICAvLyBHZXQgY3VycmVudCBjb2xsaXNpb24gaW5kZWNlc1xuICAgICAgICB2YXIgYmkgPSBjLmJpLFxuICAgICAgICAgICAgYmogPSBjLmJqLFxuICAgICAgICAgICAgc2kgPSBjLnNpLFxuICAgICAgICAgICAgc2ogPSBjLnNqO1xuXG4gICAgICAgIC8vIEdldCBjb2xsaXNpb24gcHJvcGVydGllc1xuICAgICAgICB2YXIgY207XG4gICAgICAgIGlmKGJpLm1hdGVyaWFsICYmIGJqLm1hdGVyaWFsKXtcbiAgICAgICAgICAgIGNtID0gdGhpcy5nZXRDb250YWN0TWF0ZXJpYWwoYmkubWF0ZXJpYWwsYmoubWF0ZXJpYWwpIHx8IHRoaXMuZGVmYXVsdENvbnRhY3RNYXRlcmlhbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNtID0gdGhpcy5kZWZhdWx0Q29udGFjdE1hdGVyaWFsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYy5lbmFibGVkID0gYmkuY29sbGlzaW9uUmVzcG9uc2UgJiYgYmouY29sbGlzaW9uUmVzcG9uc2UgJiYgc2kuY29sbGlzaW9uUmVzcG9uc2UgJiYgc2ouY29sbGlzaW9uUmVzcG9uc2U7XG5cbiAgICAgICAgdmFyIG11ID0gY20uZnJpY3Rpb247XG4gICAgICAgIC8vIGMucmVzdGl0dXRpb24gPSBjbS5yZXN0aXR1dGlvbjtcblxuICAgICAgICAvLyBJZiBmcmljdGlvbiBvciByZXN0aXR1dGlvbiB3ZXJlIHNwZWNpZmllZCBpbiB0aGUgbWF0ZXJpYWwsIHVzZSB0aGVtXG4gICAgICAgIGlmKGJpLm1hdGVyaWFsICYmIGJqLm1hdGVyaWFsKXtcbiAgICAgICAgICAgIGlmKGJpLm1hdGVyaWFsLmZyaWN0aW9uID49IDAgJiYgYmoubWF0ZXJpYWwuZnJpY3Rpb24gPj0gMCl7XG4gICAgICAgICAgICAgICAgbXUgPSBiaS5tYXRlcmlhbC5mcmljdGlvbiAqIGJqLm1hdGVyaWFsLmZyaWN0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihiaS5tYXRlcmlhbC5yZXN0aXR1dGlvbiA+PSAwICYmIGJqLm1hdGVyaWFsLnJlc3RpdHV0aW9uID49IDApe1xuICAgICAgICAgICAgICAgIGMucmVzdGl0dXRpb24gPSBiaS5tYXRlcmlhbC5yZXN0aXR1dGlvbiAqIGJqLm1hdGVyaWFsLnJlc3RpdHV0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblx0XHQvLyBjLnNldFNwb29rUGFyYW1zKFxuICAvLyAgICAgICAgICAgY20uY29udGFjdEVxdWF0aW9uU3RpZmZuZXNzLFxuICAvLyAgICAgICAgICAgY20uY29udGFjdEVxdWF0aW9uUmVsYXhhdGlvbixcbiAgLy8gICAgICAgICAgIGR0XG4gIC8vICAgICAgICk7XG5cblx0XHRzb2x2ZXIuYWRkRXF1YXRpb24oYyk7XG5cblx0XHQvLyAvLyBBZGQgZnJpY3Rpb24gY29uc3RyYWludCBlcXVhdGlvblxuXHRcdC8vIGlmKG11ID4gMCl7XG5cblx0XHQvLyBcdC8vIENyZWF0ZSAyIHRhbmdlbnQgZXF1YXRpb25zXG5cdFx0Ly8gXHR2YXIgbXVnID0gbXUgKiBnbm9ybTtcblx0XHQvLyBcdHZhciByZWR1Y2VkTWFzcyA9IChiaS5pbnZNYXNzICsgYmouaW52TWFzcyk7XG5cdFx0Ly8gXHRpZihyZWR1Y2VkTWFzcyA+IDApe1xuXHRcdC8vIFx0XHRyZWR1Y2VkTWFzcyA9IDEvcmVkdWNlZE1hc3M7XG5cdFx0Ly8gXHR9XG5cdFx0Ly8gXHR2YXIgcG9vbCA9IGZyaWN0aW9uRXF1YXRpb25Qb29sO1xuXHRcdC8vIFx0dmFyIGMxID0gcG9vbC5sZW5ndGggPyBwb29sLnBvcCgpIDogbmV3IEZyaWN0aW9uRXF1YXRpb24oYmksYmosbXVnKnJlZHVjZWRNYXNzKTtcblx0XHQvLyBcdHZhciBjMiA9IHBvb2wubGVuZ3RoID8gcG9vbC5wb3AoKSA6IG5ldyBGcmljdGlvbkVxdWF0aW9uKGJpLGJqLG11ZypyZWR1Y2VkTWFzcyk7XG5cdFx0Ly8gXHR0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2goYzEsIGMyKTtcblxuXHRcdC8vIFx0YzEuYmkgPSBjMi5iaSA9IGJpO1xuXHRcdC8vIFx0YzEuYmogPSBjMi5iaiA9IGJqO1xuXHRcdC8vIFx0YzEubWluRm9yY2UgPSBjMi5taW5Gb3JjZSA9IC1tdWcqcmVkdWNlZE1hc3M7XG5cdFx0Ly8gXHRjMS5tYXhGb3JjZSA9IGMyLm1heEZvcmNlID0gbXVnKnJlZHVjZWRNYXNzO1xuXG5cdFx0Ly8gXHQvLyBDb3B5IG92ZXIgdGhlIHJlbGF0aXZlIHZlY3RvcnNcblx0XHQvLyBcdGMxLnJpLmNvcHkoYy5yaSk7XG5cdFx0Ly8gXHRjMS5yai5jb3B5KGMucmopO1xuXHRcdC8vIFx0YzIucmkuY29weShjLnJpKTtcblx0XHQvLyBcdGMyLnJqLmNvcHkoYy5yaik7XG5cblx0XHQvLyBcdC8vIENvbnN0cnVjdCB0YW5nZW50c1xuXHRcdC8vIFx0Yy5uaS50YW5nZW50cyhjMS50LCBjMi50KTtcblxuICAvLyAgICAgICAgICAgLy8gU2V0IHNwb29rIHBhcmFtc1xuICAvLyAgICAgICAgICAgYzEuc2V0U3Bvb2tQYXJhbXMoY20uZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzcywgY20uZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb24sIGR0KTtcbiAgLy8gICAgICAgICAgIGMyLnNldFNwb29rUGFyYW1zKGNtLmZyaWN0aW9uRXF1YXRpb25TdGlmZm5lc3MsIGNtLmZyaWN0aW9uRXF1YXRpb25SZWxheGF0aW9uLCBkdCk7XG5cbiAgLy8gICAgICAgICAgIGMxLmVuYWJsZWQgPSBjMi5lbmFibGVkID0gYy5lbmFibGVkO1xuXG5cdFx0Ly8gXHQvLyBBZGQgZXF1YXRpb25zIHRvIHNvbHZlclxuXHRcdC8vIFx0c29sdmVyLmFkZEVxdWF0aW9uKGMxKTtcblx0XHQvLyBcdHNvbHZlci5hZGRFcXVhdGlvbihjMik7XG5cdFx0Ly8gfVxuXG4gICAgICAgIGlmKCBiaS5hbGxvd1NsZWVwICYmXG4gICAgICAgICAgICBiaS50eXBlID09PSBCb2R5LkRZTkFNSUMgJiZcbiAgICAgICAgICAgIGJpLnNsZWVwU3RhdGUgID09PSBCb2R5LlNMRUVQSU5HICYmXG4gICAgICAgICAgICBiai5zbGVlcFN0YXRlICA9PT0gQm9keS5BV0FLRSAmJlxuICAgICAgICAgICAgYmoudHlwZSAhPT0gQm9keS5TVEFUSUNcbiAgICAgICAgKXtcbiAgICAgICAgICAgIHZhciBzcGVlZFNxdWFyZWRCID0gYmoudmVsb2NpdHkubm9ybTIoKSArIGJqLmFuZ3VsYXJWZWxvY2l0eS5ub3JtMigpO1xuICAgICAgICAgICAgdmFyIHNwZWVkTGltaXRTcXVhcmVkQiA9IE1hdGgucG93KGJqLnNsZWVwU3BlZWRMaW1pdCwyKTtcbiAgICAgICAgICAgIGlmKHNwZWVkU3F1YXJlZEIgPj0gc3BlZWRMaW1pdFNxdWFyZWRCKjIpe1xuICAgICAgICAgICAgICAgIGJpLl93YWtlVXBBZnRlck5hcnJvd3BoYXNlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBiai5hbGxvd1NsZWVwICYmXG4gICAgICAgICAgICBiai50eXBlID09PSBCb2R5LkRZTkFNSUMgJiZcbiAgICAgICAgICAgIGJqLnNsZWVwU3RhdGUgID09PSBCb2R5LlNMRUVQSU5HICYmXG4gICAgICAgICAgICBiaS5zbGVlcFN0YXRlICA9PT0gQm9keS5BV0FLRSAmJlxuICAgICAgICAgICAgYmkudHlwZSAhPT0gQm9keS5TVEFUSUNcbiAgICAgICAgKXtcbiAgICAgICAgICAgIHZhciBzcGVlZFNxdWFyZWRBID0gYmkudmVsb2NpdHkubm9ybTIoKSArIGJpLmFuZ3VsYXJWZWxvY2l0eS5ub3JtMigpO1xuICAgICAgICAgICAgdmFyIHNwZWVkTGltaXRTcXVhcmVkQSA9IE1hdGgucG93KGJpLnNsZWVwU3BlZWRMaW1pdCwyKTtcbiAgICAgICAgICAgIGlmKHNwZWVkU3F1YXJlZEEgPj0gc3BlZWRMaW1pdFNxdWFyZWRBKjIpe1xuICAgICAgICAgICAgICAgIGJqLl93YWtlVXBBZnRlck5hcnJvd3BoYXNlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vdyB3ZSBrbm93IHRoYXQgaSBhbmQgaiBhcmUgaW4gY29udGFjdC4gU2V0IGNvbGxpc2lvbiBtYXRyaXggc3RhdGVcblx0XHR0aGlzLmNvbGxpc2lvbk1hdHJpeC5zZXQoYmksIGJqLCB0cnVlKTtcblxuICAgICAgICBpZiAoIXRoaXMuY29sbGlzaW9uTWF0cml4UHJldmlvdXMuZ2V0KGJpLCBiaikpIHtcbiAgICAgICAgICAgIC8vIEZpcnN0IGNvbnRhY3QhXG4gICAgICAgICAgICAvLyBXZSByZXVzZSB0aGUgY29sbGlkZUV2ZW50IG9iamVjdCwgb3RoZXJ3aXNlIHdlIHdpbGwgZW5kIHVwIGNyZWF0aW5nIG5ldyBvYmplY3RzIGZvciBlYWNoIG5ldyBjb250YWN0LCBldmVuIGlmIHRoZXJlJ3Mgbm8gZXZlbnQgbGlzdGVuZXIgYXR0YWNoZWQuXG4gICAgICAgICAgICBXb3JsZF9zdGVwX2NvbGxpZGVFdmVudC5ib2R5ID0gYmo7XG4gICAgICAgICAgICBXb3JsZF9zdGVwX2NvbGxpZGVFdmVudC5jb250YWN0ID0gYztcbiAgICAgICAgICAgIGJpLmRpc3BhdGNoRXZlbnQoV29ybGRfc3RlcF9jb2xsaWRlRXZlbnQpO1xuXG4gICAgICAgICAgICBXb3JsZF9zdGVwX2NvbGxpZGVFdmVudC5ib2R5ID0gYmk7XG4gICAgICAgICAgICBiai5kaXNwYXRjaEV2ZW50KFdvcmxkX3N0ZXBfY29sbGlkZUV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZihkb1Byb2ZpbGluZyl7XG4gICAgICAgIHByb2ZpbGUubWFrZUNvbnRhY3RDb25zdHJhaW50cyA9IHBlcmZvcm1hbmNlLm5vdygpIC0gcHJvZmlsaW5nU3RhcnQ7XG4gICAgICAgIHByb2ZpbGluZ1N0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfVxuXG4gICAgLy8gV2FrZSB1cCBib2RpZXNcbiAgICBmb3IoaT0wOyBpIT09TjsgaSsrKXtcbiAgICAgICAgdmFyIGJpID0gYm9kaWVzW2ldO1xuICAgICAgICBpZihiaS5fd2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZSl7XG4gICAgICAgICAgICBiaS53YWtlVXAoKTtcbiAgICAgICAgICAgIGJpLl93YWtlVXBBZnRlck5hcnJvd3BoYXNlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgdXNlci1hZGRlZCBjb25zdHJhaW50c1xuICAgIHZhciBOY29uc3RyYWludHMgPSBjb25zdHJhaW50cy5sZW5ndGg7XG4gICAgZm9yKGk9MDsgaSE9PU5jb25zdHJhaW50czsgaSsrKXtcbiAgICAgICAgdmFyIGMgPSBjb25zdHJhaW50c1tpXTtcbiAgICAgICAgYy51cGRhdGUoKTtcbiAgICAgICAgZm9yKHZhciBqPTAsIE5lcT1jLmVxdWF0aW9ucy5sZW5ndGg7IGohPT1OZXE7IGorKyl7XG4gICAgICAgICAgICB2YXIgZXEgPSBjLmVxdWF0aW9uc1tqXTtcbiAgICAgICAgICAgIHNvbHZlci5hZGRFcXVhdGlvbihlcSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTb2x2ZSB0aGUgY29uc3RyYWluZWQgc3lzdGVtXG4gICAgc29sdmVyLnNvbHZlKGR0LHRoaXMpO1xuXG4gICAgaWYoZG9Qcm9maWxpbmcpe1xuICAgICAgICBwcm9maWxlLnNvbHZlID0gcGVyZm9ybWFuY2Uubm93KCkgLSBwcm9maWxpbmdTdGFydDtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgYWxsIGNvbnRhY3RzIGZyb20gc29sdmVyXG4gICAgc29sdmVyLnJlbW92ZUFsbEVxdWF0aW9ucygpO1xuXG4gICAgLy8gQXBwbHkgZGFtcGluZywgc2VlIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9idWxsZXQvaXNzdWVzL2RldGFpbD9pZD03NCBmb3IgZGV0YWlsc1xuICAgIHZhciBwb3cgPSBNYXRoLnBvdztcbiAgICBmb3IoaT0wOyBpIT09TjsgaSsrKXtcbiAgICAgICAgdmFyIGJpID0gYm9kaWVzW2ldO1xuICAgICAgICBpZihiaS50eXBlICYgRFlOQU1JQyl7IC8vIE9ubHkgZm9yIGR5bmFtaWMgYm9kaWVzXG4gICAgICAgICAgICB2YXIgbGQgPSBwb3coMS4wIC0gYmkubGluZWFyRGFtcGluZyxkdCk7XG4gICAgICAgICAgICB2YXIgdiA9IGJpLnZlbG9jaXR5O1xuICAgICAgICAgICAgdi5tdWx0KGxkLHYpO1xuICAgICAgICAgICAgdmFyIGF2ID0gYmkuYW5ndWxhclZlbG9jaXR5O1xuICAgICAgICAgICAgaWYoYXYpe1xuICAgICAgICAgICAgICAgIHZhciBhZCA9IHBvdygxLjAgLSBiaS5hbmd1bGFyRGFtcGluZyxkdCk7XG4gICAgICAgICAgICAgICAgYXYubXVsdChhZCxhdik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoV29ybGRfc3RlcF9wcmVTdGVwRXZlbnQpO1xuXG4gICAgLy8gSW52b2tlIHByZS1zdGVwIGNhbGxiYWNrc1xuICAgIGZvcihpPTA7IGkhPT1OOyBpKyspe1xuICAgICAgICB2YXIgYmkgPSBib2RpZXNbaV07XG4gICAgICAgIGlmKGJpLnByZVN0ZXApe1xuICAgICAgICAgICAgYmkucHJlU3RlcC5jYWxsKGJpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIExlYXAgZnJvZ1xuICAgIC8vIHZuZXcgPSB2ICsgaCpmL21cbiAgICAvLyB4bmV3ID0geCArIGgqdm5ld1xuICAgIGlmKGRvUHJvZmlsaW5nKXtcbiAgICAgICAgcHJvZmlsaW5nU3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9XG4gICAgdmFyIHEgPSBXb3JsZF9zdGVwX3N0ZXBfcTtcbiAgICB2YXIgdyA9IFdvcmxkX3N0ZXBfc3RlcF93O1xuICAgIHZhciB3cSA9IFdvcmxkX3N0ZXBfc3RlcF93cTtcbiAgICB2YXIgc3RlcG51bWJlciA9IHRoaXMuc3RlcG51bWJlcjtcbiAgICB2YXIgRFlOQU1JQ19PUl9LSU5FTUFUSUMgPSBCb2R5LkRZTkFNSUMgfCBCb2R5LktJTkVNQVRJQztcbiAgICB2YXIgcXVhdE5vcm1hbGl6ZSA9IHN0ZXBudW1iZXIgJSAodGhpcy5xdWF0Tm9ybWFsaXplU2tpcCsxKSA9PT0gMDtcbiAgICB2YXIgcXVhdE5vcm1hbGl6ZUZhc3QgPSB0aGlzLnF1YXROb3JtYWxpemVGYXN0O1xuICAgIHZhciBoYWxmX2R0ID0gZHQgKiAwLjU7XG4gICAgdmFyIFBMQU5FID0gU2hhcGUudHlwZXMuUExBTkUsXG4gICAgICAgIENPTlZFWCA9IFNoYXBlLnR5cGVzLkNPTlZFWFBPTFlIRURST047XG5cbiAgICBmb3IoaT0wOyBpIT09TjsgaSsrKXtcbiAgICAgICAgdmFyIGIgPSBib2RpZXNbaV0sXG4gICAgICAgICAgICBmb3JjZSA9IGIuZm9yY2UsXG4gICAgICAgICAgICB0YXUgPSBiLnRvcnF1ZTtcbiAgICAgICAgaWYoKGIudHlwZSAmIERZTkFNSUNfT1JfS0lORU1BVElDKSAmJiBiLnNsZWVwU3RhdGUgIT09IEJvZHkuU0xFRVBJTkcpeyAvLyBPbmx5IGZvciBkeW5hbWljXG4gICAgICAgICAgICB2YXIgdmVsbyA9IGIudmVsb2NpdHksXG4gICAgICAgICAgICAgICAgYW5ndWxhclZlbG8gPSBiLmFuZ3VsYXJWZWxvY2l0eSxcbiAgICAgICAgICAgICAgICBwb3MgPSBiLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIHF1YXQgPSBiLnF1YXRlcm5pb24sXG4gICAgICAgICAgICAgICAgaW52TWFzcyA9IGIuaW52TWFzcyxcbiAgICAgICAgICAgICAgICBpbnZJbmVydGlhID0gYi5pbnZJbmVydGlhV29ybGQ7XG5cbiAgICAgICAgICAgIHZlbG8ueCArPSBmb3JjZS54ICogaW52TWFzcyAqIGR0O1xuICAgICAgICAgICAgdmVsby55ICs9IGZvcmNlLnkgKiBpbnZNYXNzICogZHQ7XG4gICAgICAgICAgICB2ZWxvLnogKz0gZm9yY2UueiAqIGludk1hc3MgKiBkdDtcblxuICAgICAgICAgICAgaWYoYi5hbmd1bGFyVmVsb2NpdHkpe1xuICAgICAgICAgICAgICAgIGludkluZXJ0aWEudm11bHQodGF1LGludklfdGF1X2R0KTtcbiAgICAgICAgICAgICAgICBpbnZJX3RhdV9kdC5tdWx0KGR0LGludklfdGF1X2R0KTtcbiAgICAgICAgICAgICAgICBpbnZJX3RhdV9kdC52YWRkKGFuZ3VsYXJWZWxvLGFuZ3VsYXJWZWxvKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXNlIG5ldyB2ZWxvY2l0eSAgLSBsZWFwIGZyb2dcbiAgICAgICAgICAgIHBvcy54ICs9IHZlbG8ueCAqIGR0O1xuICAgICAgICAgICAgcG9zLnkgKz0gdmVsby55ICogZHQ7XG4gICAgICAgICAgICBwb3MueiArPSB2ZWxvLnogKiBkdDtcblxuICAgICAgICAgICAgaWYoYi5hbmd1bGFyVmVsb2NpdHkpe1xuICAgICAgICAgICAgICAgIHcuc2V0KGFuZ3VsYXJWZWxvLngsIGFuZ3VsYXJWZWxvLnksIGFuZ3VsYXJWZWxvLnosIDApO1xuICAgICAgICAgICAgICAgIHcubXVsdChxdWF0LHdxKTtcbiAgICAgICAgICAgICAgICBxdWF0LnggKz0gaGFsZl9kdCAqIHdxLng7XG4gICAgICAgICAgICAgICAgcXVhdC55ICs9IGhhbGZfZHQgKiB3cS55O1xuICAgICAgICAgICAgICAgIHF1YXQueiArPSBoYWxmX2R0ICogd3EuejtcbiAgICAgICAgICAgICAgICBxdWF0LncgKz0gaGFsZl9kdCAqIHdxLnc7XG4gICAgICAgICAgICAgICAgaWYocXVhdE5vcm1hbGl6ZSl7XG4gICAgICAgICAgICAgICAgICAgIGlmKHF1YXROb3JtYWxpemVGYXN0KXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YXQubm9ybWFsaXplRmFzdCgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVhdC5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoYi5hYWJiKXtcbiAgICAgICAgICAgICAgICBiLmFhYmJOZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB3b3JsZCBpbmVydGlhXG4gICAgICAgICAgICBpZihiLnVwZGF0ZUluZXJ0aWFXb3JsZCl7XG4gICAgICAgICAgICAgICAgYi51cGRhdGVJbmVydGlhV29ybGQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNsZWFyRm9yY2VzKCk7XG5cbiAgICB0aGlzLmJyb2FkcGhhc2UuZGlydHkgPSB0cnVlO1xuXG4gICAgaWYoZG9Qcm9maWxpbmcpe1xuICAgICAgICBwcm9maWxlLmludGVncmF0ZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gcHJvZmlsaW5nU3RhcnQ7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHdvcmxkIHRpbWVcbiAgICB0aGlzLnRpbWUgKz0gZHQ7XG4gICAgdGhpcy5zdGVwbnVtYmVyICs9IDE7XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoV29ybGRfc3RlcF9wb3N0U3RlcEV2ZW50KTtcblxuICAgIC8vIEludm9rZSBwb3N0LXN0ZXAgY2FsbGJhY2tzXG4gICAgZm9yKGk9MDsgaSE9PU47IGkrKyl7XG4gICAgICAgIHZhciBiaSA9IGJvZGllc1tpXTtcbiAgICAgICAgdmFyIHBvc3RTdGVwID0gYmkucG9zdFN0ZXA7XG4gICAgICAgIGlmKHBvc3RTdGVwKXtcbiAgICAgICAgICAgIHBvc3RTdGVwLmNhbGwoYmkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2xlZXBpbmcgdXBkYXRlXG4gICAgaWYodGhpcy5hbGxvd1NsZWVwKXtcbiAgICAgICAgZm9yKGk9MDsgaSE9PU47IGkrKyl7XG4gICAgICAgICAgICBib2RpZXNbaV0uc2xlZXBUaWNrKHRoaXMudGltZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFNldHMgYWxsIGJvZHkgZm9yY2VzIGluIHRoZSB3b3JsZCB0byB6ZXJvLlxuICogQG1ldGhvZCBjbGVhckZvcmNlc1xuICovXG5Xb3JsZC5wcm90b3R5cGUuY2xlYXJGb3JjZXMgPSBmdW5jdGlvbigpe1xuICAgIHZhciBib2RpZXMgPSB0aGlzLmJvZGllcztcbiAgICB2YXIgTiA9IGJvZGllcy5sZW5ndGg7XG4gICAgZm9yKHZhciBpPTA7IGkgIT09IE47IGkrKyl7XG4gICAgICAgIHZhciBiID0gYm9kaWVzW2ldLFxuICAgICAgICAgICAgZm9yY2UgPSBiLmZvcmNlLFxuICAgICAgICAgICAgdGF1ID0gYi50b3JxdWU7XG5cbiAgICAgICAgYi5mb3JjZS5zZXQoMCwwLDApO1xuICAgICAgICBiLnRvcnF1ZS5zZXQoMCwwLDApO1xuICAgIH1cbn07XG5cbn0se1wiLi4vY29sbGlzaW9uL0FBQkJcIjozLFwiLi4vY29sbGlzaW9uL0FycmF5Q29sbGlzaW9uTWF0cml4XCI6NCxcIi4uL2NvbGxpc2lvbi9OYWl2ZUJyb2FkcGhhc2VcIjo3LFwiLi4vY29sbGlzaW9uL1JheVwiOjksXCIuLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdFwiOjEwLFwiLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvblwiOjE5LFwiLi4vZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb25cIjoyMSxcIi4uL21hdGVyaWFsL0NvbnRhY3RNYXRlcmlhbFwiOjI0LFwiLi4vbWF0ZXJpYWwvTWF0ZXJpYWxcIjoyNSxcIi4uL21hdGgvUXVhdGVybmlvblwiOjI4LFwiLi4vbWF0aC9WZWMzXCI6MzAsXCIuLi9vYmplY3RzL0JvZHlcIjozMSxcIi4uL3NoYXBlcy9TaGFwZVwiOjQzLFwiLi4vc29sdmVyL0dTU29sdmVyXCI6NDYsXCIuLi91dGlscy9FdmVudFRhcmdldFwiOjQ5LFwiLi4vdXRpbHMvVHVwbGVEaWN0aW9uYXJ5XCI6NTIsXCIuLi91dGlscy9WZWMzUG9vbFwiOjU0LFwiLi9OYXJyb3dwaGFzZVwiOjU1fV19LHt9LFsyXSlcbigyKVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvZG1pbGxldC9Qcm9qZWN0cy9mcHQvZnB0LW9sZC9+L2Nhbm5vbi9idWlsZC9jYW5ub24uanNcbiAqKiBtb2R1bGUgaWQgPSA5XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMSAyXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _System = __webpack_require__(4);\n\nvar _System2 = _interopRequireDefault(_System);\n\nvar _PiecesComponent = __webpack_require__(11);\n\nvar _PiecesComponent2 = _interopRequireDefault(_PiecesComponent);\n\nvar _Terrain = __webpack_require__(12);\n\nvar _Terrain2 = _interopRequireDefault(_Terrain);\n\nvar _Entity = __webpack_require__(13);\n\nvar _Entity2 = _interopRequireDefault(_Entity);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Level = _System2.default.createClass({\n\n\tconstructor: function constructor() {\n\t\tvar entity = this.entity = _Entity2.default.create();\n\t\tvar pieces = _PiecesComponent2.default.create();\n\t\tentity.set('pieces', pieces);\n\t\tthis.terrain = _Terrain2.default.create({\n\t\t\tsolver: this.generateSolver\n\t\t});\n\t\tif (this.exported) {\n\t\t\tvar x = new XMLHttpRequest();\n\t\t\tx.open('GET', this.exported, false);\n\t\t\tx.send();\n\t\t\tthis.import(JSON.parse(x.responseText));\n\t\t}\n\t\tif (this.generate) {\n\t\t\tthis.terrain.generateRange(this.generateRange.low, this.generateRange.high);\n\t\t}\n\t\tpieces.add(this.terrain);\n\t},\n\n\tgenerate: true,\n\n\tgenerateSolver: function generateSolver(x, y, z) {\n\t\treturn 0;\n\t},\n\n\tgenerateRange: {\n\t\tlow: {\n\t\t\tx: -1,\n\t\t\ty: -1,\n\t\t\tz: -1\n\t\t},\n\t\thigh: {\n\t\t\tx: 1,\n\t\t\ty: 1,\n\t\t\tz: 1\n\t\t}\n\t},\n\n\texported: null,\n\n\texport: function _export() {\n\t\treturn {\n\t\t\tterrain: this.terrain.export()\n\t\t};\n\t},\n\n\timport: function _import(exported) {\n\t\tif (!this.generate) {\n\t\t\tthis.terrain.import(exported.terrain);\n\t\t}\n\t},\n\n\tonLoaded: function onLoaded(callback) {\n\t\tsetTimeout(callback, 3000);\n\t}\n\n});\n\nLevel.createClass = function (props) {\n\tfunction Klass() {\n\t\tLevel.call(this);\n\t\tprops.constructor.apply(this, arguments);\n\t};\n\tKlass.prototype = props;\n\tprops.__proto__ = Level.prototype;\n\treturn Klass;\n};\n\nexports.default = Level;//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbGV2ZWxzL0xldmVsLmpzPzM1MzEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBLElBQUksUUFBUSxpQkFBTyxXQUFQLENBQW1COztBQUU5QixjQUFhLHVCQUFXO0FBQ3ZCLE1BQUksU0FBUyxLQUFLLE1BQUwsR0FBYyxpQkFBTyxNQUFQLEVBQTNCO0FBQ0EsTUFBSSxTQUFTLDBCQUFnQixNQUFoQixFQUFiO0FBQ0EsU0FBTyxHQUFQLENBQVcsUUFBWCxFQUFxQixNQUFyQjtBQUNBLE9BQUssT0FBTCxHQUFlLGtCQUFRLE1BQVIsQ0FBZTtBQUM3QixXQUFRLEtBQUs7QUFEZ0IsR0FBZixDQUFmO0FBR0EsTUFBSSxLQUFLLFFBQVQsRUFBbUI7QUFDbEIsT0FBSSxJQUFJLElBQUksY0FBSixFQUFSO0FBQ0EsS0FBRSxJQUFGLENBQU8sS0FBUCxFQUFjLEtBQUssUUFBbkIsRUFBNkIsS0FBN0I7QUFDQSxLQUFFLElBQUY7QUFDQSxRQUFLLE1BQUwsQ0FBWSxLQUFLLEtBQUwsQ0FBVyxFQUFFLFlBQWIsQ0FBWjtBQUNBO0FBQ0QsTUFBSSxLQUFLLFFBQVQsRUFBbUI7QUFDbEIsUUFBSyxPQUFMLENBQWEsYUFBYixDQUEyQixLQUFLLGFBQUwsQ0FBbUIsR0FBOUMsRUFBbUQsS0FBSyxhQUFMLENBQW1CLElBQXRFO0FBQ0E7QUFDRCxTQUFPLEdBQVAsQ0FBVyxLQUFLLE9BQWhCO0FBQ0EsRUFuQjZCOztBQXFCOUIsV0FBVSxJQXJCb0I7O0FBdUI5QixpQkFBZ0Isd0JBQVMsQ0FBVCxFQUFZLENBQVosRUFBZSxDQUFmLEVBQWtCO0FBQ2pDLFNBQU8sQ0FBUDtBQUNBLEVBekI2Qjs7QUEyQjlCLGdCQUFlO0FBQ2QsT0FBSztBQUNKLE1BQUcsQ0FBQyxDQURBO0FBRUosTUFBRyxDQUFDLENBRkE7QUFHSixNQUFHLENBQUM7QUFIQSxHQURTO0FBTWQsUUFBTTtBQUNMLE1BQUcsQ0FERTtBQUVMLE1BQUcsQ0FGRTtBQUdMLE1BQUc7QUFIRTtBQU5RLEVBM0JlOztBQXdDOUIsV0FBVSxJQXhDb0I7O0FBMEM5QixTQUFRLG1CQUFXO0FBQ2xCLFNBQU87QUFDTixZQUFTLEtBQUssT0FBTCxDQUFhLE1BQWI7QUFESCxHQUFQO0FBR0EsRUE5QzZCOztBQWdEOUIsU0FBUSxpQkFBUyxRQUFULEVBQW1CO0FBQzFCLE1BQUksQ0FBQyxLQUFLLFFBQVYsRUFBb0I7QUFDbkIsUUFBSyxPQUFMLENBQWEsTUFBYixDQUFvQixTQUFTLE9BQTdCO0FBQ0E7QUFDRCxFQXBENkI7O0FBc0Q5QixXQUFVLGtCQUFTLFFBQVQsRUFBbUI7QUFDNUIsYUFBVyxRQUFYLEVBQXFCLElBQXJCO0FBQ0E7O0FBeEQ2QixDQUFuQixDQUFaOztBQTREQSxNQUFNLFdBQU4sR0FBb0IsVUFBUyxLQUFULEVBQWdCO0FBQ25DLFVBQVMsS0FBVCxHQUFpQjtBQUNoQixRQUFNLElBQU4sQ0FBVyxJQUFYO0FBQ0EsUUFBTSxXQUFOLENBQWtCLEtBQWxCLENBQXdCLElBQXhCLEVBQTZCLFNBQTdCO0FBQ0E7QUFDRCxPQUFNLFNBQU4sR0FBa0IsS0FBbEI7QUFDQSxPQUFNLFNBQU4sR0FBa0IsTUFBTSxTQUF4QjtBQUNBLFFBQU8sS0FBUDtBQUNBLENBUkQ7O2tCQVVlLEsiLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCBTeXN0ZW0gZnJvbSAnLi4vZ2FtZS9lY3MvU3lzdGVtJztcbmltcG9ydCBQaWVjZXNDb21wb25lbnQgZnJvbSAnLi4vZ2FtZS9QaWVjZXNDb21wb25lbnQnO1xuaW1wb3J0IFRlcnJhaW4gZnJvbSAnLi4vZ2FtZS90ZXJyYWluL1RlcnJhaW4nO1xuaW1wb3J0IEVudGl0eSBmcm9tICcuLi9nYW1lL2Vjcy9FbnRpdHknO1xuXG5sZXQgTGV2ZWwgPSBTeXN0ZW0uY3JlYXRlQ2xhc3Moe1xuXG5cdGNvbnN0cnVjdG9yOiBmdW5jdGlvbigpIHtcblx0XHRsZXQgZW50aXR5ID0gdGhpcy5lbnRpdHkgPSBFbnRpdHkuY3JlYXRlKCk7XG5cdFx0bGV0IHBpZWNlcyA9IFBpZWNlc0NvbXBvbmVudC5jcmVhdGUoKTtcblx0XHRlbnRpdHkuc2V0KCdwaWVjZXMnLCBwaWVjZXMpO1xuXHRcdHRoaXMudGVycmFpbiA9IFRlcnJhaW4uY3JlYXRlKHtcblx0XHRcdHNvbHZlcjogdGhpcy5nZW5lcmF0ZVNvbHZlclxuXHRcdH0pO1xuXHRcdGlmICh0aGlzLmV4cG9ydGVkKSB7XG5cdFx0XHRsZXQgeCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXHRcdFx0eC5vcGVuKCdHRVQnLCB0aGlzLmV4cG9ydGVkLCBmYWxzZSk7XG5cdFx0XHR4LnNlbmQoKTtcblx0XHRcdHRoaXMuaW1wb3J0KEpTT04ucGFyc2UoeC5yZXNwb25zZVRleHQpKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMuZ2VuZXJhdGUpIHtcblx0XHRcdHRoaXMudGVycmFpbi5nZW5lcmF0ZVJhbmdlKHRoaXMuZ2VuZXJhdGVSYW5nZS5sb3csIHRoaXMuZ2VuZXJhdGVSYW5nZS5oaWdoKTtcblx0XHR9XG5cdFx0cGllY2VzLmFkZCh0aGlzLnRlcnJhaW4pO1xuXHR9LFxuXG5cdGdlbmVyYXRlOiB0cnVlLFxuXG5cdGdlbmVyYXRlU29sdmVyOiBmdW5jdGlvbih4LCB5LCB6KSB7XG5cdFx0cmV0dXJuIDA7XG5cdH0sXG5cblx0Z2VuZXJhdGVSYW5nZToge1xuXHRcdGxvdzoge1xuXHRcdFx0eDogLTEsXG5cdFx0XHR5OiAtMSxcblx0XHRcdHo6IC0xXG5cdFx0fSxcblx0XHRoaWdoOiB7XG5cdFx0XHR4OiAxLFxuXHRcdFx0eTogMSxcblx0XHRcdHo6IDFcblx0XHR9XG5cdH0sXG5cblx0ZXhwb3J0ZWQ6IG51bGwsXG5cblx0ZXhwb3J0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dGVycmFpbjogdGhpcy50ZXJyYWluLmV4cG9ydCgpXG5cdFx0fTtcblx0fSxcblxuXHRpbXBvcnQ6IGZ1bmN0aW9uKGV4cG9ydGVkKSB7XG5cdFx0aWYgKCF0aGlzLmdlbmVyYXRlKSB7XG5cdFx0XHR0aGlzLnRlcnJhaW4uaW1wb3J0KGV4cG9ydGVkLnRlcnJhaW4pO1xuXHRcdH1cblx0fSxcblxuXHRvbkxvYWRlZDogZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRzZXRUaW1lb3V0KGNhbGxiYWNrLCAzMDAwKTtcblx0fVxuXG59KTtcblxuTGV2ZWwuY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbihwcm9wcykge1xuXHRmdW5jdGlvbiBLbGFzcygpIHtcblx0XHRMZXZlbC5jYWxsKHRoaXMpO1xuXHRcdHByb3BzLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtcblx0fTtcblx0S2xhc3MucHJvdG90eXBlID0gcHJvcHM7XG5cdHByb3BzLl9fcHJvdG9fXyA9IExldmVsLnByb3RvdHlwZTtcblx0cmV0dXJuIEtsYXNzO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgTGV2ZWw7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9sZXZlbHMvTGV2ZWwuanNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _EntityCollection = __webpack_require__(6);\n\nvar _EntityCollection2 = _interopRequireDefault(_EntityCollection);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar PiecesComponent = _EntityCollection2.default;\n\nexports.default = PiecesComponent;//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vZ2FtZS9QaWVjZXNDb21wb25lbnQuanM/Nzg4NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQTs7Ozs7O0FBRUEsSUFBSSw0Q0FBSjs7a0JBRWUsZSIsImZpbGUiOiIxMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IEVudGl0eUNvbGxlY3Rpb24gZnJvbSAnLi9lY3MvRW50aXR5Q29sbGVjdGlvbic7XG5cbmxldCBQaWVjZXNDb21wb25lbnQgPSBFbnRpdHlDb2xsZWN0aW9uO1xuXG5leHBvcnQgZGVmYXVsdCBQaWVjZXNDb21wb25lbnQ7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9nYW1lL1BpZWNlc0NvbXBvbmVudC5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _Entity = __webpack_require__(13);\n\nvar _Entity2 = _interopRequireDefault(_Entity);\n\nvar _voxel = __webpack_require__(14);\n\nvar _voxel2 = _interopRequireDefault(_voxel);\n\nvar _TerrainPhysics = __webpack_require__(23);\n\nvar _TerrainPhysics2 = _interopRequireDefault(_TerrainPhysics);\n\nvar _PiecesComponent = __webpack_require__(11);\n\nvar _PiecesComponent2 = _interopRequireDefault(_PiecesComponent);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Terrain = _Entity2.default.createClass({\n\n\tconstructor: function constructor(options) {\n\n\t\tthis.set('voxels', (0, _voxel2.default)({\n\t\t\tgenerateVoxelChunk: function (low, high) {\n\t\t\t\treturn _voxel2.default.generate(low, high, options.solver);\n\t\t\t}.bind(this),\n\t\t\tcubeSize: 1\n\t\t}));\n\n\t\tthis.set('pieces', _PiecesComponent2.default.create());\n\t},\n\n\tgenerateRange: function generateRange(low, high) {\n\t\tvar voxels = this.get('voxels');\n\t\tvar chunkLow = voxels.chunkAtCoordinates(low.x, low.y, low.z);\n\t\tvar chunkHigh = voxels.chunkAtCoordinates(high.x, high.y, high.z);\n\t\tthis.generateChunkBlock({\n\t\t\tx: chunkLow[0],\n\t\t\ty: chunkLow[1],\n\t\t\tz: chunkLow[2]\n\t\t}, {\n\t\t\tx: chunkHigh[0],\n\t\t\ty: chunkHigh[1],\n\t\t\tz: chunkHigh[2]\n\t\t});\n\t},\n\n\tgenerateChunkBlock: function generateChunkBlock(low, high) {\n\t\tvar voxels = this.get('voxels');\n\t\tfor (var x = low.x; x <= high.x; x++) {\n\t\t\tfor (var y = low.y; y <= high.y; y++) {\n\t\t\t\tfor (var z = low.z; z <= high.z; z++) {\n\t\t\t\t\tvoxels.generateChunk(x, y, z);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.set('terrain-physics', _TerrainPhysics2.default.create(this));\n\t},\n\n\tgetBlockAt: function getBlockAt(pos) {\n\t\tpos = this._parseVectorArguments(arguments);\n\t\treturn this.get('voxels').voxelAtPosition(pos);\n\t},\n\n\texport: function _export() {\n\t\tvar voxels = this.get('voxels');\n\t\tvar result = {\n\t\t\tchunkSize: voxels.chunkSize,\n\t\t\tchunks: JSON.parse(JSON.stringify(voxels.chunks))\n\t\t};\n\t\t// discard empty chunks\n\t\tfor (var chunkId in result.chunks) {\n\t\t\tvar remove = true;\n\t\t\tfor (var voxelId in result.chunks[chunkId].voxels) {\n\t\t\t\tif (result.chunks[chunkId].voxels[voxelId]) {\n\t\t\t\t\tremove = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (remove) {\n\t\t\t\tdelete result.chunks[chunkId];\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t},\n\n\timport: function _import(exported) {\n\t\tvar voxels = this.get('voxels');\n\t\tvoxels.chunkSize = exported.chunkSize;\n\t\tvoxels.chunks = exported.chunks;\n\t\tthis.set('terrain-physics', _TerrainPhysics2.default.create(this));\n\t},\n\n\t_parseVectorArguments: function _parseVectorArguments(args) {\n\t\tif (!args) return false;\n\t\tif (args[0] instanceof Array) return args[0];\n\t\treturn [args[0], args[1], args[2]];\n\t}\n});\n\nTerrain.create = function (opts) {\n\treturn new Terrain(opts);\n};\n\nexports.default = Terrain;//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vZ2FtZS90ZXJyYWluL1RlcnJhaW4uanM/ZDY1NSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUEsSUFBSSxVQUFVLGlCQUFPLFdBQVAsQ0FBbUI7O0FBRWhDLGNBQWEscUJBQVMsT0FBVCxFQUFrQjs7QUFFOUIsT0FBSyxHQUFMLENBQ0MsUUFERCxFQUVDLHFCQUFNO0FBQ0wsdUJBQW9CLFVBQVMsR0FBVCxFQUFjLElBQWQsRUFBb0I7QUFDdkMsV0FBTyxnQkFBTSxRQUFOLENBQWUsR0FBZixFQUFvQixJQUFwQixFQUEwQixRQUFRLE1BQWxDLENBQVA7QUFDQSxJQUZtQixDQUVsQixJQUZrQixDQUViLElBRmEsQ0FEZjtBQUlMLGFBQVU7QUFKTCxHQUFOLENBRkQ7O0FBVUEsT0FBSyxHQUFMLENBQ0MsUUFERCxFQUVDLDBCQUFnQixNQUFoQixFQUZEO0FBS0EsRUFuQitCOztBQXFCaEMsZ0JBQWUsdUJBQVMsR0FBVCxFQUFjLElBQWQsRUFBb0I7QUFDbEMsTUFBSSxTQUFTLEtBQUssR0FBTCxDQUFTLFFBQVQsQ0FBYjtBQUNBLE1BQUksV0FBVyxPQUFPLGtCQUFQLENBQTBCLElBQUksQ0FBOUIsRUFBaUMsSUFBSSxDQUFyQyxFQUF3QyxJQUFJLENBQTVDLENBQWY7QUFDQSxNQUFJLFlBQVksT0FBTyxrQkFBUCxDQUEwQixLQUFLLENBQS9CLEVBQWtDLEtBQUssQ0FBdkMsRUFBMEMsS0FBSyxDQUEvQyxDQUFoQjtBQUNBLE9BQUssa0JBQUwsQ0FDQztBQUNDLE1BQUcsU0FBUyxDQUFULENBREo7QUFFQyxNQUFHLFNBQVMsQ0FBVCxDQUZKO0FBR0MsTUFBRyxTQUFTLENBQVQ7QUFISixHQURELEVBTUM7QUFDQyxNQUFHLFVBQVUsQ0FBVixDQURKO0FBRUMsTUFBRyxVQUFVLENBQVYsQ0FGSjtBQUdDLE1BQUcsVUFBVSxDQUFWO0FBSEosR0FORDtBQWFBLEVBdEMrQjs7QUF3Q2hDLHFCQUFvQiw0QkFBUyxHQUFULEVBQWMsSUFBZCxFQUFvQjtBQUN2QyxNQUFJLFNBQVMsS0FBSyxHQUFMLENBQVMsUUFBVCxDQUFiO0FBQ0EsT0FBSyxJQUFJLElBQUksSUFBSSxDQUFqQixFQUFvQixLQUFLLEtBQUssQ0FBOUIsRUFBaUMsR0FBakMsRUFBc0M7QUFDckMsUUFBSyxJQUFJLElBQUksSUFBSSxDQUFqQixFQUFvQixLQUFLLEtBQUssQ0FBOUIsRUFBaUMsR0FBakMsRUFBc0M7QUFDckMsU0FBSyxJQUFJLElBQUksSUFBSSxDQUFqQixFQUFvQixLQUFLLEtBQUssQ0FBOUIsRUFBaUMsR0FBakMsRUFBc0M7QUFDckMsWUFBTyxhQUFQLENBQXFCLENBQXJCLEVBQXdCLENBQXhCLEVBQTJCLENBQTNCO0FBQ0E7QUFDRDtBQUNEO0FBQ0QsT0FBSyxHQUFMLENBQ0MsaUJBREQsRUFFQyx5QkFBZSxNQUFmLENBQXNCLElBQXRCLENBRkQ7QUFJQSxFQXJEK0I7O0FBdURoQyxhQUFZLG9CQUFTLEdBQVQsRUFBYztBQUN6QixRQUFNLEtBQUsscUJBQUwsQ0FBMkIsU0FBM0IsQ0FBTjtBQUNBLFNBQU8sS0FBSyxHQUFMLENBQVMsUUFBVCxFQUFtQixlQUFuQixDQUFtQyxHQUFuQyxDQUFQO0FBQ0EsRUExRCtCOztBQTREaEMsU0FBUSxtQkFBVztBQUNsQixNQUFJLFNBQVMsS0FBSyxHQUFMLENBQVMsUUFBVCxDQUFiO0FBQ0EsTUFBSSxTQUFTO0FBQ1osY0FBVyxPQUFPLFNBRE47QUFFWixXQUFRLEtBQUssS0FBTCxDQUFXLEtBQUssU0FBTCxDQUFlLE9BQU8sTUFBdEIsQ0FBWDtBQUZJLEdBQWI7O0FBS0EsT0FBSyxJQUFJLE9BQVQsSUFBb0IsT0FBTyxNQUEzQixFQUFtQztBQUNsQyxPQUFJLFNBQVMsSUFBYjtBQUNBLFFBQUssSUFBSSxPQUFULElBQW9CLE9BQU8sTUFBUCxDQUFjLE9BQWQsRUFBdUIsTUFBM0MsRUFBbUQ7QUFDbEQsUUFBSSxPQUFPLE1BQVAsQ0FBYyxPQUFkLEVBQXVCLE1BQXZCLENBQThCLE9BQTlCLENBQUosRUFBNEM7QUFDM0MsY0FBUyxLQUFUO0FBQ0E7QUFDQTtBQUNEO0FBQ0QsT0FBSSxNQUFKLEVBQVk7QUFDWCxXQUFPLE9BQU8sTUFBUCxDQUFjLE9BQWQsQ0FBUDtBQUNBO0FBQ0Q7O0FBRUQsU0FBTyxNQUFQO0FBQ0EsRUFqRitCOztBQW1GaEMsU0FBUSxpQkFBUyxRQUFULEVBQW1CO0FBQzFCLE1BQUksU0FBUyxLQUFLLEdBQUwsQ0FBUyxRQUFULENBQWI7QUFDQSxTQUFPLFNBQVAsR0FBbUIsU0FBUyxTQUE1QjtBQUNBLFNBQU8sTUFBUCxHQUFnQixTQUFTLE1BQXpCO0FBQ0EsT0FBSyxHQUFMLENBQ0MsaUJBREQsRUFFQyx5QkFBZSxNQUFmLENBQXNCLElBQXRCLENBRkQ7QUFJQSxFQTNGK0I7O0FBNkZoQyx3QkFBdUIsK0JBQVMsSUFBVCxFQUFlO0FBQ3JDLE1BQUksQ0FBQyxJQUFMLEVBQVcsT0FBTyxLQUFQO0FBQ1gsTUFBSSxLQUFLLENBQUwsYUFBbUIsS0FBdkIsRUFBOEIsT0FBTyxLQUFLLENBQUwsQ0FBUDtBQUM5QixTQUFPLENBQUMsS0FBSyxDQUFMLENBQUQsRUFBVSxLQUFLLENBQUwsQ0FBVixFQUFtQixLQUFLLENBQUwsQ0FBbkIsQ0FBUDtBQUNBO0FBakcrQixDQUFuQixDQUFkOztBQW9HQSxRQUFRLE1BQVIsR0FBaUIsVUFBUyxJQUFULEVBQWU7QUFDL0IsUUFBTyxJQUFJLE9BQUosQ0FBWSxJQUFaLENBQVA7QUFDQSxDQUZEOztrQkFJZSxPIiwiZmlsZSI6IjEyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgRW50aXR5IGZyb20gJy4uL2Vjcy9FbnRpdHknO1xuaW1wb3J0IHZveGVsIGZyb20gJ3ZveGVsJztcbmltcG9ydCBUZXJyYWluUGh5c2ljcyBmcm9tICcuL1RlcnJhaW5QaHlzaWNzJztcbmltcG9ydCBQaWVjZXNDb21wb25lbnQgZnJvbSAnLi4vUGllY2VzQ29tcG9uZW50JztcblxubGV0IFRlcnJhaW4gPSBFbnRpdHkuY3JlYXRlQ2xhc3Moe1xuXG5cdGNvbnN0cnVjdG9yOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cblx0XHR0aGlzLnNldChcblx0XHRcdCd2b3hlbHMnLFxuXHRcdFx0dm94ZWwoe1xuXHRcdFx0XHRnZW5lcmF0ZVZveGVsQ2h1bms6IGZ1bmN0aW9uKGxvdywgaGlnaCkge1xuXHRcdFx0XHRcdHJldHVybiB2b3hlbC5nZW5lcmF0ZShsb3csIGhpZ2gsIG9wdGlvbnMuc29sdmVyKTtcblx0XHRcdFx0fS5iaW5kKHRoaXMpLFxuXHRcdFx0XHRjdWJlU2l6ZTogMVxuXHRcdFx0fSlcblx0XHQpO1xuXG5cdFx0dGhpcy5zZXQoXG5cdFx0XHQncGllY2VzJyxcblx0XHRcdFBpZWNlc0NvbXBvbmVudC5jcmVhdGUoKVxuXHRcdCk7XG5cblx0fSxcblxuXHRnZW5lcmF0ZVJhbmdlOiBmdW5jdGlvbihsb3csIGhpZ2gpIHtcblx0XHRsZXQgdm94ZWxzID0gdGhpcy5nZXQoJ3ZveGVscycpO1xuXHRcdGxldCBjaHVua0xvdyA9IHZveGVscy5jaHVua0F0Q29vcmRpbmF0ZXMobG93LngsIGxvdy55LCBsb3cueik7XG5cdFx0bGV0IGNodW5rSGlnaCA9IHZveGVscy5jaHVua0F0Q29vcmRpbmF0ZXMoaGlnaC54LCBoaWdoLnksIGhpZ2gueik7XG5cdFx0dGhpcy5nZW5lcmF0ZUNodW5rQmxvY2soXG5cdFx0XHR7XG5cdFx0XHRcdHg6IGNodW5rTG93WzBdLFxuXHRcdFx0XHR5OiBjaHVua0xvd1sxXSxcblx0XHRcdFx0ejogY2h1bmtMb3dbMl1cblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdHg6IGNodW5rSGlnaFswXSxcblx0XHRcdFx0eTogY2h1bmtIaWdoWzFdLFxuXHRcdFx0XHR6OiBjaHVua0hpZ2hbMl1cblx0XHRcdH1cblx0XHQpO1xuXG5cdH0sXG5cblx0Z2VuZXJhdGVDaHVua0Jsb2NrOiBmdW5jdGlvbihsb3csIGhpZ2gpIHtcblx0XHRsZXQgdm94ZWxzID0gdGhpcy5nZXQoJ3ZveGVscycpO1xuXHRcdGZvciAobGV0IHggPSBsb3cueDsgeCA8PSBoaWdoLng7IHgrKykge1xuXHRcdFx0Zm9yIChsZXQgeSA9IGxvdy55OyB5IDw9IGhpZ2gueTsgeSsrKSB7XG5cdFx0XHRcdGZvciAobGV0IHogPSBsb3cuejsgeiA8PSBoaWdoLno7IHorKykge1xuXHRcdFx0XHRcdHZveGVscy5nZW5lcmF0ZUNodW5rKHgsIHksIHopO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuc2V0KFxuXHRcdFx0J3RlcnJhaW4tcGh5c2ljcycsXG5cdFx0XHRUZXJyYWluUGh5c2ljcy5jcmVhdGUodGhpcylcblx0XHQpO1xuXHR9LFxuXG5cdGdldEJsb2NrQXQ6IGZ1bmN0aW9uKHBvcykge1xuXHRcdHBvcyA9IHRoaXMuX3BhcnNlVmVjdG9yQXJndW1lbnRzKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0KCd2b3hlbHMnKS52b3hlbEF0UG9zaXRpb24ocG9zKTtcblx0fSxcblxuXHRleHBvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdGxldCB2b3hlbHMgPSB0aGlzLmdldCgndm94ZWxzJyk7XG5cdFx0bGV0IHJlc3VsdCA9IHtcblx0XHRcdGNodW5rU2l6ZTogdm94ZWxzLmNodW5rU2l6ZSxcblx0XHRcdGNodW5rczogSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh2b3hlbHMuY2h1bmtzKSlcblx0XHR9O1xuXHRcdC8vIGRpc2NhcmQgZW1wdHkgY2h1bmtzXG5cdFx0Zm9yIChsZXQgY2h1bmtJZCBpbiByZXN1bHQuY2h1bmtzKSB7XG5cdFx0XHRsZXQgcmVtb3ZlID0gdHJ1ZTtcblx0XHRcdGZvciAobGV0IHZveGVsSWQgaW4gcmVzdWx0LmNodW5rc1tjaHVua0lkXS52b3hlbHMpIHtcblx0XHRcdFx0aWYgKHJlc3VsdC5jaHVua3NbY2h1bmtJZF0udm94ZWxzW3ZveGVsSWRdKSB7XG5cdFx0XHRcdFx0cmVtb3ZlID0gZmFsc2U7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChyZW1vdmUpIHtcblx0XHRcdFx0ZGVsZXRlIHJlc3VsdC5jaHVua3NbY2h1bmtJZF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSxcblxuXHRpbXBvcnQ6IGZ1bmN0aW9uKGV4cG9ydGVkKSB7XG5cdFx0bGV0IHZveGVscyA9IHRoaXMuZ2V0KCd2b3hlbHMnKTtcblx0XHR2b3hlbHMuY2h1bmtTaXplID0gZXhwb3J0ZWQuY2h1bmtTaXplO1xuXHRcdHZveGVscy5jaHVua3MgPSBleHBvcnRlZC5jaHVua3M7XG5cdFx0dGhpcy5zZXQoXG5cdFx0XHQndGVycmFpbi1waHlzaWNzJyxcblx0XHRcdFRlcnJhaW5QaHlzaWNzLmNyZWF0ZSh0aGlzKVxuXHRcdCk7XG5cdH0sXG5cblx0X3BhcnNlVmVjdG9yQXJndW1lbnRzOiBmdW5jdGlvbihhcmdzKSB7XG5cdFx0aWYgKCFhcmdzKSByZXR1cm4gZmFsc2U7XG5cdFx0aWYgKGFyZ3NbMF0gaW5zdGFuY2VvZiBBcnJheSkgcmV0dXJuIGFyZ3NbMF07XG5cdFx0cmV0dXJuIFthcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdXTtcblx0fVxufSk7XG5cblRlcnJhaW4uY3JlYXRlID0gZnVuY3Rpb24ob3B0cykge1xuXHRyZXR1cm4gbmV3IFRlcnJhaW4ob3B0cyk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBUZXJyYWluO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL2dhbWUvdGVycmFpbi9UZXJyYWluLmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 13 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Entity = function () {\n\t_createClass(Entity, null, [{\n\t\tkey: \"createClass\",\n\t\tvalue: function createClass(props) {\n\t\t\tfunction Klass() {\n\t\t\t\tEntity.call(this);\n\t\t\t\tprops.constructor.apply(this, arguments);\n\t\t\t};\n\t\t\tKlass.prototype = props;\n\t\t\tprops.__proto__ = Entity.prototype;\n\t\t\treturn Klass;\n\t\t}\n\t}, {\n\t\tkey: \"create\",\n\t\tvalue: function create() {\n\t\t\treturn new Entity();\n\t\t}\n\t}]);\n\n\tfunction Entity() {\n\t\t_classCallCheck(this, Entity);\n\n\t\tthis.components = {};\n\t}\n\n\t_createClass(Entity, [{\n\t\tkey: \"set\",\n\t\tvalue: function set(name, value) {\n\t\t\tthis.components[name] = value;\n\t\t}\n\t}, {\n\t\tkey: \"get\",\n\t\tvalue: function get(name) {\n\t\t\treturn this.components[name];\n\t\t}\n\t}]);\n\n\treturn Entity;\n}();\n\nexports.default = Entity;//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vZ2FtZS9lY3MvRW50aXR5LmpzP2I1YmEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztJQUNNLE07Y0FBQSxNOzs4QkFFYyxLLEVBQU87QUFDekIsWUFBUyxLQUFULEdBQWlCO0FBQ2hCLFdBQU8sSUFBUCxDQUFZLElBQVo7QUFDQSxVQUFNLFdBQU4sQ0FBa0IsS0FBbEIsQ0FBd0IsSUFBeEIsRUFBNkIsU0FBN0I7QUFDQTtBQUNELFNBQU0sU0FBTixHQUFrQixLQUFsQjtBQUNBLFNBQU0sU0FBTixHQUFrQixPQUFPLFNBQXpCO0FBQ0EsVUFBTyxLQUFQO0FBQ0E7OzsyQkFFZTtBQUNmLFVBQU8sSUFBSSxNQUFKLEVBQVA7QUFDQTs7O0FBRUQsVUFoQkssTUFnQkwsR0FBYztBQUFBLHdCQWhCVCxNQWdCUzs7QUFDYixPQUFLLFVBQUwsR0FBa0IsRUFBbEI7QUFDQTs7Y0FsQkksTTs7c0JBb0JELEksRUFBTSxLLEVBQU87QUFDaEIsUUFBSyxVQUFMLENBQWdCLElBQWhCLElBQXdCLEtBQXhCO0FBQ0E7OztzQkFFRyxJLEVBQU07QUFDVCxVQUFPLEtBQUssVUFBTCxDQUFnQixJQUFoQixDQUFQO0FBQ0E7OztRQTFCSSxNOzs7a0JBOEJTLE0iLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbmNsYXNzIEVudGl0eSB7XG5cdFxuXHRzdGF0aWMgY3JlYXRlQ2xhc3MocHJvcHMpIHtcblx0XHRmdW5jdGlvbiBLbGFzcygpIHtcblx0XHRcdEVudGl0eS5jYWxsKHRoaXMpO1xuXHRcdFx0cHJvcHMuY29uc3RydWN0b3IuYXBwbHkodGhpcyxhcmd1bWVudHMpO1xuXHRcdH07XG5cdFx0S2xhc3MucHJvdG90eXBlID0gcHJvcHM7XG5cdFx0cHJvcHMuX19wcm90b19fID0gRW50aXR5LnByb3RvdHlwZTtcblx0XHRyZXR1cm4gS2xhc3M7XG5cdH1cblxuXHRzdGF0aWMgY3JlYXRlKCkge1xuXHRcdHJldHVybiBuZXcgRW50aXR5KCk7XG5cdH1cblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLmNvbXBvbmVudHMgPSB7fTtcblx0fVxuXG5cdHNldChuYW1lLCB2YWx1ZSkge1xuXHRcdHRoaXMuY29tcG9uZW50c1tuYW1lXSA9IHZhbHVlO1xuXHR9XG5cblx0Z2V0KG5hbWUpIHtcblx0XHRyZXR1cm4gdGhpcy5jb21wb25lbnRzW25hbWVdO1xuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgRW50aXR5O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vZ2FtZS9lY3MvRW50aXR5LmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	eval("var chunker = __webpack_require__(15)\n\nmodule.exports = function(opts) {\n  if (!opts.generateVoxelChunk) opts.generateVoxelChunk = function(low, high) {\n    return generate(low, high, module.exports.generator['Valley'])\n  }\n  return chunker(opts)\n}\n\nmodule.exports.meshers = {\n  culled: __webpack_require__(18).mesher,\n  greedy: __webpack_require__(19).mesher,\n  transgreedy: __webpack_require__(20).mesher,\n  monotone: __webpack_require__(21).mesher,\n  stupid: __webpack_require__(22).mesher\n}\n\nmodule.exports.Chunker = chunker.Chunker\nmodule.exports.geometry = {}\nmodule.exports.generator = {}\nmodule.exports.generate = generate\n\n// from https://github.com/mikolalysenko/mikolalysenko.github.com/blob/master/MinecraftMeshes2/js/testdata.js#L4\nfunction generate(l, h, f, game) {\n  var d = [ h[0]-l[0], h[1]-l[1], h[2]-l[2] ]\n  var v = new Int8Array(d[0]*d[1]*d[2])\n  var n = 0\n  for(var k=l[2]; k<h[2]; ++k)\n  for(var j=l[1]; j<h[1]; ++j)\n  for(var i=l[0]; i<h[0]; ++i, ++n) {\n    v[n] = f(i,j,k,n,game)\n  }\n  return {voxels:v, dims:d}\n}\n\n// shape and terrain generator functions\nmodule.exports.generator['Sphere'] = function(i,j,k) {\n  return i*i+j*j+k*k <= 16*16 ? 1 : 0\n}\n\nmodule.exports.generator['Noise'] = function(i,j,k) {\n  return Math.random() < 0.1 ? Math.random() * 0xffffff : 0;\n}\n\nmodule.exports.generator['Dense Noise'] = function(i,j,k) {\n  return Math.round(Math.random() * 0xffffff);\n}\n\nmodule.exports.generator['Checker'] = function(i,j,k) {\n  return !!((i+j+k)&1) ? (((i^j^k)&2) ? 1 : 0xffffff) : 0;\n}\n\nmodule.exports.generator['Hill'] = function(i,j,k) {\n  return j <= 16 * Math.exp(-(i*i + k*k) / 64) ? 1 : 0;\n}\n\nmodule.exports.generator['Valley'] = function(i,j,k) {\n  return j <= (i*i + k*k) * 31 / (32*32*2) + 1 ? 1 : 0;\n}\n\nmodule.exports.generator['Hilly Terrain'] = function(i,j,k) {\n  var h0 = 3.0 * Math.sin(Math.PI * i / 12.0 - Math.PI * k * 0.1) + 27;    \n  if(j > h0+1) {\n    return 0;\n  }\n  if(h0 <= j) {\n    return 1;\n  }\n  var h1 = 2.0 * Math.sin(Math.PI * i * 0.25 - Math.PI * k * 0.3) + 20;\n  if(h1 <= j) {\n    return 2;\n  }\n  if(2 < j) {\n    return Math.random() < 0.1 ? 0x222222 : 0xaaaaaa;\n  }\n  return 3;\n}\n\nmodule.exports.scale = function ( x, fromLow, fromHigh, toLow, toHigh ) {\n  return ( x - fromLow ) * ( toHigh - toLow ) / ( fromHigh - fromLow ) + toLow\n}\n\n// convenience function that uses the above functions to prebake some simple voxel geometries\nmodule.exports.generateExamples = function() {\n  return {\n    'Sphere': generate([-16,-16,-16], [16,16,16], module.exports.generator['Sphere']),\n    'Noise': generate([0,0,0], [16,16,16], module.exports.generator['Noise']),\n    'Dense Noise': generate([0,0,0], [16,16,16], module.exports.generator['Dense Noise']),\n    'Checker': generate([0,0,0], [8,8,8], module.exports.generator['Checker']),\n    'Hill': generate([-16, 0, -16], [16,16,16], module.exports.generator['Hill']),\n    'Valley': generate([0,0,0], [32,32,32], module.exports.generator['Valley']),\n    'Hilly Terrain': generate([0, 0, 0], [32,32,32], module.exports.generator['Hilly Terrain'])\n  }\n}\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2RtaWxsZXQvUHJvamVjdHMvZnB0L2ZwdC1vbGQvfi92b3hlbC9pbmRleC5qcz8yYzdjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekIsaUJBQWlCLFFBQVE7QUFDekIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxNC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBjaHVua2VyID0gcmVxdWlyZSgnLi9jaHVua2VyJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcHRzKSB7XG4gIGlmICghb3B0cy5nZW5lcmF0ZVZveGVsQ2h1bmspIG9wdHMuZ2VuZXJhdGVWb3hlbENodW5rID0gZnVuY3Rpb24obG93LCBoaWdoKSB7XG4gICAgcmV0dXJuIGdlbmVyYXRlKGxvdywgaGlnaCwgbW9kdWxlLmV4cG9ydHMuZ2VuZXJhdG9yWydWYWxsZXknXSlcbiAgfVxuICByZXR1cm4gY2h1bmtlcihvcHRzKVxufVxuXG5tb2R1bGUuZXhwb3J0cy5tZXNoZXJzID0ge1xuICBjdWxsZWQ6IHJlcXVpcmUoJy4vbWVzaGVycy9jdWxsZWQnKS5tZXNoZXIsXG4gIGdyZWVkeTogcmVxdWlyZSgnLi9tZXNoZXJzL2dyZWVkeScpLm1lc2hlcixcbiAgdHJhbnNncmVlZHk6IHJlcXVpcmUoJy4vbWVzaGVycy90cmFuc2dyZWVkeScpLm1lc2hlcixcbiAgbW9ub3RvbmU6IHJlcXVpcmUoJy4vbWVzaGVycy9tb25vdG9uZScpLm1lc2hlcixcbiAgc3R1cGlkOiByZXF1aXJlKCcuL21lc2hlcnMvc3R1cGlkJykubWVzaGVyXG59XG5cbm1vZHVsZS5leHBvcnRzLkNodW5rZXIgPSBjaHVua2VyLkNodW5rZXJcbm1vZHVsZS5leHBvcnRzLmdlb21ldHJ5ID0ge31cbm1vZHVsZS5leHBvcnRzLmdlbmVyYXRvciA9IHt9XG5tb2R1bGUuZXhwb3J0cy5nZW5lcmF0ZSA9IGdlbmVyYXRlXG5cbi8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21pa29sYWx5c2Vua28vbWlrb2xhbHlzZW5rby5naXRodWIuY29tL2Jsb2IvbWFzdGVyL01pbmVjcmFmdE1lc2hlczIvanMvdGVzdGRhdGEuanMjTDRcbmZ1bmN0aW9uIGdlbmVyYXRlKGwsIGgsIGYsIGdhbWUpIHtcbiAgdmFyIGQgPSBbIGhbMF0tbFswXSwgaFsxXS1sWzFdLCBoWzJdLWxbMl0gXVxuICB2YXIgdiA9IG5ldyBJbnQ4QXJyYXkoZFswXSpkWzFdKmRbMl0pXG4gIHZhciBuID0gMFxuICBmb3IodmFyIGs9bFsyXTsgazxoWzJdOyArK2spXG4gIGZvcih2YXIgaj1sWzFdOyBqPGhbMV07ICsrailcbiAgZm9yKHZhciBpPWxbMF07IGk8aFswXTsgKytpLCArK24pIHtcbiAgICB2W25dID0gZihpLGosayxuLGdhbWUpXG4gIH1cbiAgcmV0dXJuIHt2b3hlbHM6diwgZGltczpkfVxufVxuXG4vLyBzaGFwZSBhbmQgdGVycmFpbiBnZW5lcmF0b3IgZnVuY3Rpb25zXG5tb2R1bGUuZXhwb3J0cy5nZW5lcmF0b3JbJ1NwaGVyZSddID0gZnVuY3Rpb24oaSxqLGspIHtcbiAgcmV0dXJuIGkqaStqKmorayprIDw9IDE2KjE2ID8gMSA6IDBcbn1cblxubW9kdWxlLmV4cG9ydHMuZ2VuZXJhdG9yWydOb2lzZSddID0gZnVuY3Rpb24oaSxqLGspIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkgPCAwLjEgPyBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmYgOiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5nZW5lcmF0b3JbJ0RlbnNlIE5vaXNlJ10gPSBmdW5jdGlvbihpLGosaykge1xuICByZXR1cm4gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogMHhmZmZmZmYpO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5nZW5lcmF0b3JbJ0NoZWNrZXInXSA9IGZ1bmN0aW9uKGksaixrKSB7XG4gIHJldHVybiAhISgoaStqK2spJjEpID8gKCgoaV5qXmspJjIpID8gMSA6IDB4ZmZmZmZmKSA6IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzLmdlbmVyYXRvclsnSGlsbCddID0gZnVuY3Rpb24oaSxqLGspIHtcbiAgcmV0dXJuIGogPD0gMTYgKiBNYXRoLmV4cCgtKGkqaSArIGsqaykgLyA2NCkgPyAxIDogMDtcbn1cblxubW9kdWxlLmV4cG9ydHMuZ2VuZXJhdG9yWydWYWxsZXknXSA9IGZ1bmN0aW9uKGksaixrKSB7XG4gIHJldHVybiBqIDw9IChpKmkgKyBrKmspICogMzEgLyAoMzIqMzIqMikgKyAxID8gMSA6IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzLmdlbmVyYXRvclsnSGlsbHkgVGVycmFpbiddID0gZnVuY3Rpb24oaSxqLGspIHtcbiAgdmFyIGgwID0gMy4wICogTWF0aC5zaW4oTWF0aC5QSSAqIGkgLyAxMi4wIC0gTWF0aC5QSSAqIGsgKiAwLjEpICsgMjc7ICAgIFxuICBpZihqID4gaDArMSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmKGgwIDw9IGopIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICB2YXIgaDEgPSAyLjAgKiBNYXRoLnNpbihNYXRoLlBJICogaSAqIDAuMjUgLSBNYXRoLlBJICogayAqIDAuMykgKyAyMDtcbiAgaWYoaDEgPD0gaikge1xuICAgIHJldHVybiAyO1xuICB9XG4gIGlmKDIgPCBqKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgPCAwLjEgPyAweDIyMjIyMiA6IDB4YWFhYWFhO1xuICB9XG4gIHJldHVybiAzO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5zY2FsZSA9IGZ1bmN0aW9uICggeCwgZnJvbUxvdywgZnJvbUhpZ2gsIHRvTG93LCB0b0hpZ2ggKSB7XG4gIHJldHVybiAoIHggLSBmcm9tTG93ICkgKiAoIHRvSGlnaCAtIHRvTG93ICkgLyAoIGZyb21IaWdoIC0gZnJvbUxvdyApICsgdG9Mb3dcbn1cblxuLy8gY29udmVuaWVuY2UgZnVuY3Rpb24gdGhhdCB1c2VzIHRoZSBhYm92ZSBmdW5jdGlvbnMgdG8gcHJlYmFrZSBzb21lIHNpbXBsZSB2b3hlbCBnZW9tZXRyaWVzXG5tb2R1bGUuZXhwb3J0cy5nZW5lcmF0ZUV4YW1wbGVzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgJ1NwaGVyZSc6IGdlbmVyYXRlKFstMTYsLTE2LC0xNl0sIFsxNiwxNiwxNl0sIG1vZHVsZS5leHBvcnRzLmdlbmVyYXRvclsnU3BoZXJlJ10pLFxuICAgICdOb2lzZSc6IGdlbmVyYXRlKFswLDAsMF0sIFsxNiwxNiwxNl0sIG1vZHVsZS5leHBvcnRzLmdlbmVyYXRvclsnTm9pc2UnXSksXG4gICAgJ0RlbnNlIE5vaXNlJzogZ2VuZXJhdGUoWzAsMCwwXSwgWzE2LDE2LDE2XSwgbW9kdWxlLmV4cG9ydHMuZ2VuZXJhdG9yWydEZW5zZSBOb2lzZSddKSxcbiAgICAnQ2hlY2tlcic6IGdlbmVyYXRlKFswLDAsMF0sIFs4LDgsOF0sIG1vZHVsZS5leHBvcnRzLmdlbmVyYXRvclsnQ2hlY2tlciddKSxcbiAgICAnSGlsbCc6IGdlbmVyYXRlKFstMTYsIDAsIC0xNl0sIFsxNiwxNiwxNl0sIG1vZHVsZS5leHBvcnRzLmdlbmVyYXRvclsnSGlsbCddKSxcbiAgICAnVmFsbGV5JzogZ2VuZXJhdGUoWzAsMCwwXSwgWzMyLDMyLDMyXSwgbW9kdWxlLmV4cG9ydHMuZ2VuZXJhdG9yWydWYWxsZXknXSksXG4gICAgJ0hpbGx5IFRlcnJhaW4nOiBnZW5lcmF0ZShbMCwgMCwgMF0sIFszMiwzMiwzMl0sIG1vZHVsZS5leHBvcnRzLmdlbmVyYXRvclsnSGlsbHkgVGVycmFpbiddKVxuICB9XG59XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL2RtaWxsZXQvUHJvamVjdHMvZnB0L2ZwdC1vbGQvfi92b3hlbC9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDE0XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMSAyXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	eval("var events = __webpack_require__(16)\nvar inherits = __webpack_require__(17)\n\nmodule.exports = function(opts) {\n  return new Chunker(opts)\n}\n\nmodule.exports.Chunker = Chunker\n\nfunction Chunker(opts) {\n  this.distance = opts.chunkDistance || 2\n  this.chunkSize = opts.chunkSize || 32\n  this.cubeSize = opts.cubeSize || 25\n  this.generateVoxelChunk = opts.generateVoxelChunk\n  this.chunks = {}\n  this.meshes = {}\n\n  if (this.chunkSize & this.chunkSize-1 !== 0)\n    throw new Error('chunkSize must be a power of 2')\n  var bits = 0;\n  for (var size = this.chunkSize; size > 0; size >>= 1) bits++;\n  this.chunkBits = bits - 1;\n}\n\ninherits(Chunker, events.EventEmitter)\n\nChunker.prototype.nearbyChunks = function(position, distance) {\n  var current = this.chunkAtPosition(position)\n  var x = current[0]\n  var y = current[1]\n  var z = current[2]\n  var dist = distance || this.distance\n  var nearby = []\n  for (var cx = (x - dist); cx !== (x + dist); ++cx) {\n    for (var cy = (y - dist); cy !== (y + dist); ++cy) {\n      for (var cz = (z - dist); cz !== (z + dist); ++cz) {\n        nearby.push([cx, cy, cz])\n      }\n    }\n  }\n  return nearby\n}\n\nChunker.prototype.requestMissingChunks = function(position) {\n  var self = this\n  this.nearbyChunks(position).map(function(chunk) {\n    if (!self.chunks[chunk.join('|')]) {\n      self.emit('missingChunk', chunk)\n    }\n  })\n}\n\nChunker.prototype.getBounds = function(x, y, z) {\n  var bits = this.chunkBits\n  var low = [x << bits, y << bits, z << bits]\n  var high = [(x+1) << bits, (y+1) << bits, (z+1) << bits]\n  return [low, high]\n}\n\nChunker.prototype.generateChunk = function(x, y, z) {\n  var self = this\n  var bounds = this.getBounds(x, y, z)\n  var chunk = this.generateVoxelChunk(bounds[0], bounds[1], x, y, z)\n  var position = [x, y, z]\n  chunk.position = position\n  this.chunks[position.join('|')] = chunk\n  return chunk\n}\n\nChunker.prototype.chunkAtCoordinates = function(x, y, z) {\n  var bits = this.chunkBits;\n  var cx = x >> bits;\n  var cy = y >> bits;\n  var cz = z >> bits;\n  var chunkPos = [cx, cy, cz];\n  return chunkPos;\n}\n\nChunker.prototype.chunkAtPosition = function(position) {\n  var cubeSize = this.cubeSize;\n  var x = Math.floor(position[0] / cubeSize)\n  var y = Math.floor(position[1] / cubeSize)\n  var z = Math.floor(position[2] / cubeSize)\n  var chunkPos = this.chunkAtCoordinates(x, y, z)\n  return chunkPos\n};\n\nChunker.prototype.voxelIndexFromCoordinates = function(x, y, z) {\n  var bits = this.chunkBits\n  var mask = (1 << bits) - 1\n  var vidx = (x & mask) + ((y & mask) << bits) + ((z & mask) << bits * 2)\n  return vidx\n}\n\nChunker.prototype.voxelIndexFromPosition = function(pos) {\n  var v = this.voxelVector(pos)\n  return this.voxelIndex(v)\n}\n\nChunker.prototype.voxelAtCoordinates = function(x, y, z, val) {\n  var ckey = this.chunkAtCoordinates(x, y, z).join('|')\n  var chunk = this.chunks[ckey]\n  if (!chunk) return false\n  var vidx = this.voxelIndexFromCoordinates(x, y, z)\n  var v = chunk.voxels[vidx]\n  if (typeof val !== 'undefined') {\n    chunk.voxels[vidx] = val\n  }\n  return v\n}\n\nChunker.prototype.voxelAtPosition = function(pos, val) {\n  var cubeSize = this.cubeSize;\n  var x = Math.floor(pos[0] / cubeSize)\n  var y = Math.floor(pos[1] / cubeSize)\n  var z = Math.floor(pos[2] / cubeSize)\n  var v = this.voxelAtCoordinates(x, y, z, val)\n  return v;\n}\n\n// deprecated\nChunker.prototype.voxelIndex = function(voxelVector) {\n  var vidx = this.voxelIndexFromCoordinates(voxelVector[0], voxelVector[1], voxelVector[2])\n  return vidx\n}\n\n// deprecated\nChunker.prototype.voxelVector = function(pos) {\n  var cubeSize = this.cubeSize\n  var mask = (1 << this.chunkBits) - 1\n  var vx = (Math.floor(pos[0] / cubeSize)) & mask\n  var vy = (Math.floor(pos[1] / cubeSize)) & mask\n  var vz = (Math.floor(pos[2] / cubeSize)) & mask\n  return [vx, vy, vz]\n};\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2RtaWxsZXQvUHJvamVjdHMvZnB0L2ZwdC1vbGQvfi92b3hlbC9jaHVua2VyLmpzPzg3YmMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFVBQVU7QUFDM0M7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtQkFBbUI7QUFDOUMsNkJBQTZCLG1CQUFtQjtBQUNoRCwrQkFBK0IsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxNS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBldmVudHMgPSByZXF1aXJlKCdldmVudHMnKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdHMpIHtcbiAgcmV0dXJuIG5ldyBDaHVua2VyKG9wdHMpXG59XG5cbm1vZHVsZS5leHBvcnRzLkNodW5rZXIgPSBDaHVua2VyXG5cbmZ1bmN0aW9uIENodW5rZXIob3B0cykge1xuICB0aGlzLmRpc3RhbmNlID0gb3B0cy5jaHVua0Rpc3RhbmNlIHx8IDJcbiAgdGhpcy5jaHVua1NpemUgPSBvcHRzLmNodW5rU2l6ZSB8fCAzMlxuICB0aGlzLmN1YmVTaXplID0gb3B0cy5jdWJlU2l6ZSB8fCAyNVxuICB0aGlzLmdlbmVyYXRlVm94ZWxDaHVuayA9IG9wdHMuZ2VuZXJhdGVWb3hlbENodW5rXG4gIHRoaXMuY2h1bmtzID0ge31cbiAgdGhpcy5tZXNoZXMgPSB7fVxuXG4gIGlmICh0aGlzLmNodW5rU2l6ZSAmIHRoaXMuY2h1bmtTaXplLTEgIT09IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjaHVua1NpemUgbXVzdCBiZSBhIHBvd2VyIG9mIDInKVxuICB2YXIgYml0cyA9IDA7XG4gIGZvciAodmFyIHNpemUgPSB0aGlzLmNodW5rU2l6ZTsgc2l6ZSA+IDA7IHNpemUgPj49IDEpIGJpdHMrKztcbiAgdGhpcy5jaHVua0JpdHMgPSBiaXRzIC0gMTtcbn1cblxuaW5oZXJpdHMoQ2h1bmtlciwgZXZlbnRzLkV2ZW50RW1pdHRlcilcblxuQ2h1bmtlci5wcm90b3R5cGUubmVhcmJ5Q2h1bmtzID0gZnVuY3Rpb24ocG9zaXRpb24sIGRpc3RhbmNlKSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5jaHVua0F0UG9zaXRpb24ocG9zaXRpb24pXG4gIHZhciB4ID0gY3VycmVudFswXVxuICB2YXIgeSA9IGN1cnJlbnRbMV1cbiAgdmFyIHogPSBjdXJyZW50WzJdXG4gIHZhciBkaXN0ID0gZGlzdGFuY2UgfHwgdGhpcy5kaXN0YW5jZVxuICB2YXIgbmVhcmJ5ID0gW11cbiAgZm9yICh2YXIgY3ggPSAoeCAtIGRpc3QpOyBjeCAhPT0gKHggKyBkaXN0KTsgKytjeCkge1xuICAgIGZvciAodmFyIGN5ID0gKHkgLSBkaXN0KTsgY3kgIT09ICh5ICsgZGlzdCk7ICsrY3kpIHtcbiAgICAgIGZvciAodmFyIGN6ID0gKHogLSBkaXN0KTsgY3ogIT09ICh6ICsgZGlzdCk7ICsrY3opIHtcbiAgICAgICAgbmVhcmJ5LnB1c2goW2N4LCBjeSwgY3pdKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbmVhcmJ5XG59XG5cbkNodW5rZXIucHJvdG90eXBlLnJlcXVlc3RNaXNzaW5nQ2h1bmtzID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHRoaXMubmVhcmJ5Q2h1bmtzKHBvc2l0aW9uKS5tYXAoZnVuY3Rpb24oY2h1bmspIHtcbiAgICBpZiAoIXNlbGYuY2h1bmtzW2NodW5rLmpvaW4oJ3wnKV0pIHtcbiAgICAgIHNlbGYuZW1pdCgnbWlzc2luZ0NodW5rJywgY2h1bmspXG4gICAgfVxuICB9KVxufVxuXG5DaHVua2VyLnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gIHZhciBiaXRzID0gdGhpcy5jaHVua0JpdHNcbiAgdmFyIGxvdyA9IFt4IDw8IGJpdHMsIHkgPDwgYml0cywgeiA8PCBiaXRzXVxuICB2YXIgaGlnaCA9IFsoeCsxKSA8PCBiaXRzLCAoeSsxKSA8PCBiaXRzLCAoeisxKSA8PCBiaXRzXVxuICByZXR1cm4gW2xvdywgaGlnaF1cbn1cblxuQ2h1bmtlci5wcm90b3R5cGUuZ2VuZXJhdGVDaHVuayA9IGZ1bmN0aW9uKHgsIHksIHopIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBib3VuZHMgPSB0aGlzLmdldEJvdW5kcyh4LCB5LCB6KVxuICB2YXIgY2h1bmsgPSB0aGlzLmdlbmVyYXRlVm94ZWxDaHVuayhib3VuZHNbMF0sIGJvdW5kc1sxXSwgeCwgeSwgeilcbiAgdmFyIHBvc2l0aW9uID0gW3gsIHksIHpdXG4gIGNodW5rLnBvc2l0aW9uID0gcG9zaXRpb25cbiAgdGhpcy5jaHVua3NbcG9zaXRpb24uam9pbignfCcpXSA9IGNodW5rXG4gIHJldHVybiBjaHVua1xufVxuXG5DaHVua2VyLnByb3RvdHlwZS5jaHVua0F0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gIHZhciBiaXRzID0gdGhpcy5jaHVua0JpdHM7XG4gIHZhciBjeCA9IHggPj4gYml0cztcbiAgdmFyIGN5ID0geSA+PiBiaXRzO1xuICB2YXIgY3ogPSB6ID4+IGJpdHM7XG4gIHZhciBjaHVua1BvcyA9IFtjeCwgY3ksIGN6XTtcbiAgcmV0dXJuIGNodW5rUG9zO1xufVxuXG5DaHVua2VyLnByb3RvdHlwZS5jaHVua0F0UG9zaXRpb24gPSBmdW5jdGlvbihwb3NpdGlvbikge1xuICB2YXIgY3ViZVNpemUgPSB0aGlzLmN1YmVTaXplO1xuICB2YXIgeCA9IE1hdGguZmxvb3IocG9zaXRpb25bMF0gLyBjdWJlU2l6ZSlcbiAgdmFyIHkgPSBNYXRoLmZsb29yKHBvc2l0aW9uWzFdIC8gY3ViZVNpemUpXG4gIHZhciB6ID0gTWF0aC5mbG9vcihwb3NpdGlvblsyXSAvIGN1YmVTaXplKVxuICB2YXIgY2h1bmtQb3MgPSB0aGlzLmNodW5rQXRDb29yZGluYXRlcyh4LCB5LCB6KVxuICByZXR1cm4gY2h1bmtQb3Ncbn07XG5cbkNodW5rZXIucHJvdG90eXBlLnZveGVsSW5kZXhGcm9tQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gIHZhciBiaXRzID0gdGhpcy5jaHVua0JpdHNcbiAgdmFyIG1hc2sgPSAoMSA8PCBiaXRzKSAtIDFcbiAgdmFyIHZpZHggPSAoeCAmIG1hc2spICsgKCh5ICYgbWFzaykgPDwgYml0cykgKyAoKHogJiBtYXNrKSA8PCBiaXRzICogMilcbiAgcmV0dXJuIHZpZHhcbn1cblxuQ2h1bmtlci5wcm90b3R5cGUudm94ZWxJbmRleEZyb21Qb3NpdGlvbiA9IGZ1bmN0aW9uKHBvcykge1xuICB2YXIgdiA9IHRoaXMudm94ZWxWZWN0b3IocG9zKVxuICByZXR1cm4gdGhpcy52b3hlbEluZGV4KHYpXG59XG5cbkNodW5rZXIucHJvdG90eXBlLnZveGVsQXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uKHgsIHksIHosIHZhbCkge1xuICB2YXIgY2tleSA9IHRoaXMuY2h1bmtBdENvb3JkaW5hdGVzKHgsIHksIHopLmpvaW4oJ3wnKVxuICB2YXIgY2h1bmsgPSB0aGlzLmNodW5rc1tja2V5XVxuICBpZiAoIWNodW5rKSByZXR1cm4gZmFsc2VcbiAgdmFyIHZpZHggPSB0aGlzLnZveGVsSW5kZXhGcm9tQ29vcmRpbmF0ZXMoeCwgeSwgeilcbiAgdmFyIHYgPSBjaHVuay52b3hlbHNbdmlkeF1cbiAgaWYgKHR5cGVvZiB2YWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY2h1bmsudm94ZWxzW3ZpZHhdID0gdmFsXG4gIH1cbiAgcmV0dXJuIHZcbn1cblxuQ2h1bmtlci5wcm90b3R5cGUudm94ZWxBdFBvc2l0aW9uID0gZnVuY3Rpb24ocG9zLCB2YWwpIHtcbiAgdmFyIGN1YmVTaXplID0gdGhpcy5jdWJlU2l6ZTtcbiAgdmFyIHggPSBNYXRoLmZsb29yKHBvc1swXSAvIGN1YmVTaXplKVxuICB2YXIgeSA9IE1hdGguZmxvb3IocG9zWzFdIC8gY3ViZVNpemUpXG4gIHZhciB6ID0gTWF0aC5mbG9vcihwb3NbMl0gLyBjdWJlU2l6ZSlcbiAgdmFyIHYgPSB0aGlzLnZveGVsQXRDb29yZGluYXRlcyh4LCB5LCB6LCB2YWwpXG4gIHJldHVybiB2O1xufVxuXG4vLyBkZXByZWNhdGVkXG5DaHVua2VyLnByb3RvdHlwZS52b3hlbEluZGV4ID0gZnVuY3Rpb24odm94ZWxWZWN0b3IpIHtcbiAgdmFyIHZpZHggPSB0aGlzLnZveGVsSW5kZXhGcm9tQ29vcmRpbmF0ZXModm94ZWxWZWN0b3JbMF0sIHZveGVsVmVjdG9yWzFdLCB2b3hlbFZlY3RvclsyXSlcbiAgcmV0dXJuIHZpZHhcbn1cblxuLy8gZGVwcmVjYXRlZFxuQ2h1bmtlci5wcm90b3R5cGUudm94ZWxWZWN0b3IgPSBmdW5jdGlvbihwb3MpIHtcbiAgdmFyIGN1YmVTaXplID0gdGhpcy5jdWJlU2l6ZVxuICB2YXIgbWFzayA9ICgxIDw8IHRoaXMuY2h1bmtCaXRzKSAtIDFcbiAgdmFyIHZ4ID0gKE1hdGguZmxvb3IocG9zWzBdIC8gY3ViZVNpemUpKSAmIG1hc2tcbiAgdmFyIHZ5ID0gKE1hdGguZmxvb3IocG9zWzFdIC8gY3ViZVNpemUpKSAmIG1hc2tcbiAgdmFyIHZ6ID0gKE1hdGguZmxvb3IocG9zWzJdIC8gY3ViZVNpemUpKSAmIG1hc2tcbiAgcmV0dXJuIFt2eCwgdnksIHZ6XVxufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL2RtaWxsZXQvUHJvamVjdHMvZnB0L2ZwdC1vbGQvfi92b3hlbC9jaHVua2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxIDJcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 16 */
/***/ function(module, exports) {

	eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      }\n      throw TypeError('Uncaught, unspecified \"error\" event.');\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL34vbm9kZS1saWJzLWJyb3dzZXIvfi9ldmVudHMvZXZlbnRzLmpzPzQ2YjMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSCxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiIxNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuJyk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodGhpcy5fZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgICBpZiAoaXNGdW5jdGlvbihldmxpc3RlbmVyKSlcbiAgICAgIHJldHVybiAxO1xuICAgIGVsc2UgaWYgKGV2bGlzdGVuZXIpXG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spL34vbm9kZS1saWJzLWJyb3dzZXIvfi9ldmVudHMvZXZlbnRzLmpzXG4gKiogbW9kdWxlIGlkID0gMTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxIDJcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 17 */
/***/ function(module, exports) {

	eval("module.exports = inherits\n\nfunction inherits (c, p, proto) {\n  proto = proto || {}\n  var e = {}\n  ;[c.prototype, proto].forEach(function (s) {\n    Object.getOwnPropertyNames(s).forEach(function (k) {\n      e[k] = Object.getOwnPropertyDescriptor(s, k)\n    })\n  })\n  c.prototype = Object.create(p.prototype, e)\n  c.super = p\n}\n\n//function Child () {\n//  Child.super.call(this)\n//  console.error([this\n//                ,this.constructor\n//                ,this.constructor === Child\n//                ,this.constructor.super === Parent\n//                ,Object.getPrototypeOf(this) === Child.prototype\n//                ,Object.getPrototypeOf(Object.getPrototypeOf(this))\n//                 === Parent.prototype\n//                ,this instanceof Child\n//                ,this instanceof Parent])\n//}\n//function Parent () {}\n//inherits(Child, Parent)\n//new Child\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2RtaWxsZXQvUHJvamVjdHMvZnB0L2ZwdC1vbGQvfi92b3hlbC9+L2luaGVyaXRzL2luaGVyaXRzLmpzPzY3OGEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGluaGVyaXRzXG5cbmZ1bmN0aW9uIGluaGVyaXRzIChjLCBwLCBwcm90bykge1xuICBwcm90byA9IHByb3RvIHx8IHt9XG4gIHZhciBlID0ge31cbiAgO1tjLnByb3RvdHlwZSwgcHJvdG9dLmZvckVhY2goZnVuY3Rpb24gKHMpIHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICBlW2tdID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzLCBrKVxuICAgIH0pXG4gIH0pXG4gIGMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwLnByb3RvdHlwZSwgZSlcbiAgYy5zdXBlciA9IHBcbn1cblxuLy9mdW5jdGlvbiBDaGlsZCAoKSB7XG4vLyAgQ2hpbGQuc3VwZXIuY2FsbCh0aGlzKVxuLy8gIGNvbnNvbGUuZXJyb3IoW3RoaXNcbi8vICAgICAgICAgICAgICAgICx0aGlzLmNvbnN0cnVjdG9yXG4vLyAgICAgICAgICAgICAgICAsdGhpcy5jb25zdHJ1Y3RvciA9PT0gQ2hpbGRcbi8vICAgICAgICAgICAgICAgICx0aGlzLmNvbnN0cnVjdG9yLnN1cGVyID09PSBQYXJlbnRcbi8vICAgICAgICAgICAgICAgICxPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykgPT09IENoaWxkLnByb3RvdHlwZVxuLy8gICAgICAgICAgICAgICAgLE9iamVjdC5nZXRQcm90b3R5cGVPZihPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykpXG4vLyAgICAgICAgICAgICAgICAgPT09IFBhcmVudC5wcm90b3R5cGVcbi8vICAgICAgICAgICAgICAgICx0aGlzIGluc3RhbmNlb2YgQ2hpbGRcbi8vICAgICAgICAgICAgICAgICx0aGlzIGluc3RhbmNlb2YgUGFyZW50XSlcbi8vfVxuLy9mdW5jdGlvbiBQYXJlbnQgKCkge31cbi8vaW5oZXJpdHMoQ2hpbGQsIFBhcmVudClcbi8vbmV3IENoaWxkXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9kbWlsbGV0L1Byb2plY3RzL2ZwdC9mcHQtb2xkL34vdm94ZWwvfi9pbmhlcml0cy9pbmhlcml0cy5qc1xuICoqIG1vZHVsZSBpZCA9IDE3XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMSAyXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 18 */
/***/ function(module, exports) {

	eval("//Naive meshing (with face culling)\nfunction CulledMesh(volume, dims) {\n  //Precalculate direction vectors for convenience\n  var dir = new Array(3);\n  for(var i=0; i<3; ++i) {\n    dir[i] = [[0,0,0], [0,0,0]];\n    dir[i][0][(i+1)%3] = 1;\n    dir[i][1][(i+2)%3] = 1;\n  }\n  //March over the volume\n  var vertices = []\n    , faces = []\n    , x = [0,0,0]\n    , B = [[false,true]    //Incrementally update bounds (this is a bit ugly)\n          ,[false,true]\n          ,[false,true]]\n    , n = -dims[0]*dims[1];\n  for(           B[2]=[false,true],x[2]=-1; x[2]<dims[2]; B[2]=[true,(++x[2]<dims[2]-1)])\n  for(n-=dims[0],B[1]=[false,true],x[1]=-1; x[1]<dims[1]; B[1]=[true,(++x[1]<dims[1]-1)])\n  for(n-=1,      B[0]=[false,true],x[0]=-1; x[0]<dims[0]; B[0]=[true,(++x[0]<dims[0]-1)], ++n) {\n    //Read current voxel and 3 neighboring voxels using bounds check results\n    var p =   (B[0][0] && B[1][0] && B[2][0]) ? volume[n]                 : 0\n      , b = [ (B[0][1] && B[1][0] && B[2][0]) ? volume[n+1]               : 0\n            , (B[0][0] && B[1][1] && B[2][0]) ? volume[n+dims[0]]         : 0\n            , (B[0][0] && B[1][0] && B[2][1]) ? volume[n+dims[0]*dims[1]] : 0\n          ];\n    //Generate faces\n    for(var d=0; d<3; ++d)\n    if((!!p) !== (!!b[d])) {\n      var s = !p ? 1 : 0;\n      var t = [x[0],x[1],x[2]]\n        , u = dir[d][s]\n        , v = dir[d][s^1];\n      ++t[d];\n      \n      var vertex_count = vertices.length;\n      vertices.push([t[0],           t[1],           t[2]          ]);\n      vertices.push([t[0]+u[0],      t[1]+u[1],      t[2]+u[2]     ]);\n      vertices.push([t[0]+u[0]+v[0], t[1]+u[1]+v[1], t[2]+u[2]+v[2]]);\n      vertices.push([t[0]     +v[0], t[1]     +v[1], t[2]     +v[2]]);\n      faces.push([vertex_count, vertex_count+1, vertex_count+2, vertex_count+3, s ? b[d] : p]);\n    }\n  }\n  return { vertices:vertices, faces:faces };\n}\n\n\nif(exports) {\n  exports.mesher = CulledMesh;\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2RtaWxsZXQvUHJvamVjdHMvZnB0L2ZwdC1vbGQvfi92b3hlbC9tZXNoZXJzL2N1bGxlZC5qcz9jMzcxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxLQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxjQUFjO0FBQ3pELDJDQUEyQyxjQUFjO0FBQ3pELDJDQUEyQyxjQUFjO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7OztBQUdBO0FBQ0E7QUFDQSIsImZpbGUiOiIxOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vTmFpdmUgbWVzaGluZyAod2l0aCBmYWNlIGN1bGxpbmcpXG5mdW5jdGlvbiBDdWxsZWRNZXNoKHZvbHVtZSwgZGltcykge1xuICAvL1ByZWNhbGN1bGF0ZSBkaXJlY3Rpb24gdmVjdG9ycyBmb3IgY29udmVuaWVuY2VcbiAgdmFyIGRpciA9IG5ldyBBcnJheSgzKTtcbiAgZm9yKHZhciBpPTA7IGk8MzsgKytpKSB7XG4gICAgZGlyW2ldID0gW1swLDAsMF0sIFswLDAsMF1dO1xuICAgIGRpcltpXVswXVsoaSsxKSUzXSA9IDE7XG4gICAgZGlyW2ldWzFdWyhpKzIpJTNdID0gMTtcbiAgfVxuICAvL01hcmNoIG92ZXIgdGhlIHZvbHVtZVxuICB2YXIgdmVydGljZXMgPSBbXVxuICAgICwgZmFjZXMgPSBbXVxuICAgICwgeCA9IFswLDAsMF1cbiAgICAsIEIgPSBbW2ZhbHNlLHRydWVdICAgIC8vSW5jcmVtZW50YWxseSB1cGRhdGUgYm91bmRzICh0aGlzIGlzIGEgYml0IHVnbHkpXG4gICAgICAgICAgLFtmYWxzZSx0cnVlXVxuICAgICAgICAgICxbZmFsc2UsdHJ1ZV1dXG4gICAgLCBuID0gLWRpbXNbMF0qZGltc1sxXTtcbiAgZm9yKCAgICAgICAgICAgQlsyXT1bZmFsc2UsdHJ1ZV0seFsyXT0tMTsgeFsyXTxkaW1zWzJdOyBCWzJdPVt0cnVlLCgrK3hbMl08ZGltc1syXS0xKV0pXG4gIGZvcihuLT1kaW1zWzBdLEJbMV09W2ZhbHNlLHRydWVdLHhbMV09LTE7IHhbMV08ZGltc1sxXTsgQlsxXT1bdHJ1ZSwoKyt4WzFdPGRpbXNbMV0tMSldKVxuICBmb3Iobi09MSwgICAgICBCWzBdPVtmYWxzZSx0cnVlXSx4WzBdPS0xOyB4WzBdPGRpbXNbMF07IEJbMF09W3RydWUsKCsreFswXTxkaW1zWzBdLTEpXSwgKytuKSB7XG4gICAgLy9SZWFkIGN1cnJlbnQgdm94ZWwgYW5kIDMgbmVpZ2hib3Jpbmcgdm94ZWxzIHVzaW5nIGJvdW5kcyBjaGVjayByZXN1bHRzXG4gICAgdmFyIHAgPSAgIChCWzBdWzBdICYmIEJbMV1bMF0gJiYgQlsyXVswXSkgPyB2b2x1bWVbbl0gICAgICAgICAgICAgICAgIDogMFxuICAgICAgLCBiID0gWyAoQlswXVsxXSAmJiBCWzFdWzBdICYmIEJbMl1bMF0pID8gdm9sdW1lW24rMV0gICAgICAgICAgICAgICA6IDBcbiAgICAgICAgICAgICwgKEJbMF1bMF0gJiYgQlsxXVsxXSAmJiBCWzJdWzBdKSA/IHZvbHVtZVtuK2RpbXNbMF1dICAgICAgICAgOiAwXG4gICAgICAgICAgICAsIChCWzBdWzBdICYmIEJbMV1bMF0gJiYgQlsyXVsxXSkgPyB2b2x1bWVbbitkaW1zWzBdKmRpbXNbMV1dIDogMFxuICAgICAgICAgIF07XG4gICAgLy9HZW5lcmF0ZSBmYWNlc1xuICAgIGZvcih2YXIgZD0wOyBkPDM7ICsrZClcbiAgICBpZigoISFwKSAhPT0gKCEhYltkXSkpIHtcbiAgICAgIHZhciBzID0gIXAgPyAxIDogMDtcbiAgICAgIHZhciB0ID0gW3hbMF0seFsxXSx4WzJdXVxuICAgICAgICAsIHUgPSBkaXJbZF1bc11cbiAgICAgICAgLCB2ID0gZGlyW2RdW3NeMV07XG4gICAgICArK3RbZF07XG4gICAgICBcbiAgICAgIHZhciB2ZXJ0ZXhfY291bnQgPSB2ZXJ0aWNlcy5sZW5ndGg7XG4gICAgICB2ZXJ0aWNlcy5wdXNoKFt0WzBdLCAgICAgICAgICAgdFsxXSwgICAgICAgICAgIHRbMl0gICAgICAgICAgXSk7XG4gICAgICB2ZXJ0aWNlcy5wdXNoKFt0WzBdK3VbMF0sICAgICAgdFsxXSt1WzFdLCAgICAgIHRbMl0rdVsyXSAgICAgXSk7XG4gICAgICB2ZXJ0aWNlcy5wdXNoKFt0WzBdK3VbMF0rdlswXSwgdFsxXSt1WzFdK3ZbMV0sIHRbMl0rdVsyXSt2WzJdXSk7XG4gICAgICB2ZXJ0aWNlcy5wdXNoKFt0WzBdICAgICArdlswXSwgdFsxXSAgICAgK3ZbMV0sIHRbMl0gICAgICt2WzJdXSk7XG4gICAgICBmYWNlcy5wdXNoKFt2ZXJ0ZXhfY291bnQsIHZlcnRleF9jb3VudCsxLCB2ZXJ0ZXhfY291bnQrMiwgdmVydGV4X2NvdW50KzMsIHMgPyBiW2RdIDogcF0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyB2ZXJ0aWNlczp2ZXJ0aWNlcywgZmFjZXM6ZmFjZXMgfTtcbn1cblxuXG5pZihleHBvcnRzKSB7XG4gIGV4cG9ydHMubWVzaGVyID0gQ3VsbGVkTWVzaDtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL2RtaWxsZXQvUHJvamVjdHMvZnB0L2ZwdC1vbGQvfi92b3hlbC9tZXNoZXJzL2N1bGxlZC5qc1xuICoqIG1vZHVsZSBpZCA9IDE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMSAyXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 19 */
/***/ function(module, exports) {

	eval("var GreedyMesh = (function() {\n//Cache buffer internally\nvar mask = new Int32Array(4096);\n\nreturn function(volume, dims) {\n  var vertices = [], faces = []\n    , dimsX = dims[0]\n    , dimsY = dims[1]\n    , dimsXY = dimsX * dimsY;\n\n  //Sweep over 3-axes\n  for(var d=0; d<3; ++d) {\n    var i, j, k, l, w, W, h, n, c\n      , u = (d+1)%3\n      , v = (d+2)%3\n      , x = [0,0,0]\n      , q = [0,0,0]\n      , du = [0,0,0]\n      , dv = [0,0,0]\n      , dimsD = dims[d]\n      , dimsU = dims[u]\n      , dimsV = dims[v]\n      , qdimsX, qdimsXY\n      , xd\n\n    if (mask.length < dimsU * dimsV) {\n      mask = new Int32Array(dimsU * dimsV);\n    }\n\n    q[d] =  1;\n    x[d] = -1;\n\n    qdimsX  = dimsX  * q[1]\n    qdimsXY = dimsXY * q[2]\n\n    // Compute mask\n    while (x[d] < dimsD) {\n      xd = x[d]\n      n = 0;\n\n      for(x[v] = 0; x[v] < dimsV; ++x[v]) {\n        for(x[u] = 0; x[u] < dimsU; ++x[u], ++n) {\n          var a = xd >= 0      && volume[x[0]      + dimsX * x[1]          + dimsXY * x[2]          ]\n            , b = xd < dimsD-1 && volume[x[0]+q[0] + dimsX * x[1] + qdimsX + dimsXY * x[2] + qdimsXY]\n          if (a ? b : !b) {\n            mask[n] = 0; continue;\n          }\n          mask[n] = a ? a : -b;\n        }\n      }\n\n      ++x[d];\n\n      // Generate mesh for mask using lexicographic ordering\n      n = 0;\n      for (j=0; j < dimsV; ++j) {\n        for (i=0; i < dimsU; ) {\n          c = mask[n];\n          if (!c) {\n            i++;  n++; continue;\n          }\n\n          //Compute width\n          w = 1;\n          while (c === mask[n+w] && i+w < dimsU) w++;\n\n          //Compute height (this is slightly awkward)\n          for (h=1; j+h < dimsV; ++h) {\n            k = 0;\n            while (k < w && c === mask[n+k+h*dimsU]) k++\n            if (k < w) break;\n          }\n\n          // Add quad\n          // The du/dv arrays are reused/reset\n          // for each iteration.\n          du[d] = 0; dv[d] = 0;\n          x[u]  = i;  x[v] = j;\n\n          if (c > 0) {\n            dv[v] = h; dv[u] = 0;\n            du[u] = w; du[v] = 0;\n          } else {\n            c = -c;\n            du[v] = h; du[u] = 0;\n            dv[u] = w; dv[v] = 0;\n          }\n          var vertex_count = vertices.length;\n          vertices.push([x[0],             x[1],             x[2]            ]);\n          vertices.push([x[0]+du[0],       x[1]+du[1],       x[2]+du[2]      ]);\n          vertices.push([x[0]+du[0]+dv[0], x[1]+du[1]+dv[1], x[2]+du[2]+dv[2]]);\n          vertices.push([x[0]      +dv[0], x[1]      +dv[1], x[2]      +dv[2]]);\n          faces.push([vertex_count, vertex_count+1, vertex_count+2, vertex_count+3, c]);\n\n          //Zero-out mask\n          W = n + w;\n          for(l=0; l<h; ++l) {\n            for(k=n; k<W; ++k) {\n              mask[k+l*dimsU] = 0;\n            }\n          }\n\n          //Increment counters and continue\n          i += w; n += w;\n        }\n      }\n    }\n  }\n  return { vertices:vertices, faces:faces };\n}\n})();\n\nif(exports) {\n  exports.mesher = GreedyMesh;\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2RtaWxsZXQvUHJvamVjdHMvZnB0L2ZwdC1vbGQvfi92b3hlbC9tZXNoZXJzL2dyZWVkeS5qcz8zZGE3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxLQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixjQUFjO0FBQ2pDLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGlCQUFpQixXQUFXO0FBQzVCO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsYUFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsb0JBQW9COztBQUVwQjtBQUNBLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsV0FBVztBQUNYO0FBQ0Esc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLEtBQUs7QUFDdkIsb0JBQW9CLEtBQUs7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EiLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgR3JlZWR5TWVzaCA9IChmdW5jdGlvbigpIHtcbi8vQ2FjaGUgYnVmZmVyIGludGVybmFsbHlcbnZhciBtYXNrID0gbmV3IEludDMyQXJyYXkoNDA5Nik7XG5cbnJldHVybiBmdW5jdGlvbih2b2x1bWUsIGRpbXMpIHtcbiAgdmFyIHZlcnRpY2VzID0gW10sIGZhY2VzID0gW11cbiAgICAsIGRpbXNYID0gZGltc1swXVxuICAgICwgZGltc1kgPSBkaW1zWzFdXG4gICAgLCBkaW1zWFkgPSBkaW1zWCAqIGRpbXNZO1xuXG4gIC8vU3dlZXAgb3ZlciAzLWF4ZXNcbiAgZm9yKHZhciBkPTA7IGQ8MzsgKytkKSB7XG4gICAgdmFyIGksIGosIGssIGwsIHcsIFcsIGgsIG4sIGNcbiAgICAgICwgdSA9IChkKzEpJTNcbiAgICAgICwgdiA9IChkKzIpJTNcbiAgICAgICwgeCA9IFswLDAsMF1cbiAgICAgICwgcSA9IFswLDAsMF1cbiAgICAgICwgZHUgPSBbMCwwLDBdXG4gICAgICAsIGR2ID0gWzAsMCwwXVxuICAgICAgLCBkaW1zRCA9IGRpbXNbZF1cbiAgICAgICwgZGltc1UgPSBkaW1zW3VdXG4gICAgICAsIGRpbXNWID0gZGltc1t2XVxuICAgICAgLCBxZGltc1gsIHFkaW1zWFlcbiAgICAgICwgeGRcblxuICAgIGlmIChtYXNrLmxlbmd0aCA8IGRpbXNVICogZGltc1YpIHtcbiAgICAgIG1hc2sgPSBuZXcgSW50MzJBcnJheShkaW1zVSAqIGRpbXNWKTtcbiAgICB9XG5cbiAgICBxW2RdID0gIDE7XG4gICAgeFtkXSA9IC0xO1xuXG4gICAgcWRpbXNYICA9IGRpbXNYICAqIHFbMV1cbiAgICBxZGltc1hZID0gZGltc1hZICogcVsyXVxuXG4gICAgLy8gQ29tcHV0ZSBtYXNrXG4gICAgd2hpbGUgKHhbZF0gPCBkaW1zRCkge1xuICAgICAgeGQgPSB4W2RdXG4gICAgICBuID0gMDtcblxuICAgICAgZm9yKHhbdl0gPSAwOyB4W3ZdIDwgZGltc1Y7ICsreFt2XSkge1xuICAgICAgICBmb3IoeFt1XSA9IDA7IHhbdV0gPCBkaW1zVTsgKyt4W3VdLCArK24pIHtcbiAgICAgICAgICB2YXIgYSA9IHhkID49IDAgICAgICAmJiB2b2x1bWVbeFswXSAgICAgICsgZGltc1ggKiB4WzFdICAgICAgICAgICsgZGltc1hZICogeFsyXSAgICAgICAgICBdXG4gICAgICAgICAgICAsIGIgPSB4ZCA8IGRpbXNELTEgJiYgdm9sdW1lW3hbMF0rcVswXSArIGRpbXNYICogeFsxXSArIHFkaW1zWCArIGRpbXNYWSAqIHhbMl0gKyBxZGltc1hZXVxuICAgICAgICAgIGlmIChhID8gYiA6ICFiKSB7XG4gICAgICAgICAgICBtYXNrW25dID0gMDsgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1hc2tbbl0gPSBhID8gYSA6IC1iO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgICsreFtkXTtcblxuICAgICAgLy8gR2VuZXJhdGUgbWVzaCBmb3IgbWFzayB1c2luZyBsZXhpY29ncmFwaGljIG9yZGVyaW5nXG4gICAgICBuID0gMDtcbiAgICAgIGZvciAoaj0wOyBqIDwgZGltc1Y7ICsraikge1xuICAgICAgICBmb3IgKGk9MDsgaSA8IGRpbXNVOyApIHtcbiAgICAgICAgICBjID0gbWFza1tuXTtcbiAgICAgICAgICBpZiAoIWMpIHtcbiAgICAgICAgICAgIGkrKzsgIG4rKzsgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy9Db21wdXRlIHdpZHRoXG4gICAgICAgICAgdyA9IDE7XG4gICAgICAgICAgd2hpbGUgKGMgPT09IG1hc2tbbit3XSAmJiBpK3cgPCBkaW1zVSkgdysrO1xuXG4gICAgICAgICAgLy9Db21wdXRlIGhlaWdodCAodGhpcyBpcyBzbGlnaHRseSBhd2t3YXJkKVxuICAgICAgICAgIGZvciAoaD0xOyBqK2ggPCBkaW1zVjsgKytoKSB7XG4gICAgICAgICAgICBrID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChrIDwgdyAmJiBjID09PSBtYXNrW24raytoKmRpbXNVXSkgaysrXG4gICAgICAgICAgICBpZiAoayA8IHcpIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEFkZCBxdWFkXG4gICAgICAgICAgLy8gVGhlIGR1L2R2IGFycmF5cyBhcmUgcmV1c2VkL3Jlc2V0XG4gICAgICAgICAgLy8gZm9yIGVhY2ggaXRlcmF0aW9uLlxuICAgICAgICAgIGR1W2RdID0gMDsgZHZbZF0gPSAwO1xuICAgICAgICAgIHhbdV0gID0gaTsgIHhbdl0gPSBqO1xuXG4gICAgICAgICAgaWYgKGMgPiAwKSB7XG4gICAgICAgICAgICBkdlt2XSA9IGg7IGR2W3VdID0gMDtcbiAgICAgICAgICAgIGR1W3VdID0gdzsgZHVbdl0gPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjID0gLWM7XG4gICAgICAgICAgICBkdVt2XSA9IGg7IGR1W3VdID0gMDtcbiAgICAgICAgICAgIGR2W3VdID0gdzsgZHZbdl0gPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdmVydGV4X2NvdW50ID0gdmVydGljZXMubGVuZ3RoO1xuICAgICAgICAgIHZlcnRpY2VzLnB1c2goW3hbMF0sICAgICAgICAgICAgIHhbMV0sICAgICAgICAgICAgIHhbMl0gICAgICAgICAgICBdKTtcbiAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKFt4WzBdK2R1WzBdLCAgICAgICB4WzFdK2R1WzFdLCAgICAgICB4WzJdK2R1WzJdICAgICAgXSk7XG4gICAgICAgICAgdmVydGljZXMucHVzaChbeFswXStkdVswXStkdlswXSwgeFsxXStkdVsxXStkdlsxXSwgeFsyXStkdVsyXStkdlsyXV0pO1xuICAgICAgICAgIHZlcnRpY2VzLnB1c2goW3hbMF0gICAgICArZHZbMF0sIHhbMV0gICAgICArZHZbMV0sIHhbMl0gICAgICArZHZbMl1dKTtcbiAgICAgICAgICBmYWNlcy5wdXNoKFt2ZXJ0ZXhfY291bnQsIHZlcnRleF9jb3VudCsxLCB2ZXJ0ZXhfY291bnQrMiwgdmVydGV4X2NvdW50KzMsIGNdKTtcblxuICAgICAgICAgIC8vWmVyby1vdXQgbWFza1xuICAgICAgICAgIFcgPSBuICsgdztcbiAgICAgICAgICBmb3IobD0wOyBsPGg7ICsrbCkge1xuICAgICAgICAgICAgZm9yKGs9bjsgazxXOyArK2spIHtcbiAgICAgICAgICAgICAgbWFza1trK2wqZGltc1VdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvL0luY3JlbWVudCBjb3VudGVycyBhbmQgY29udGludWVcbiAgICAgICAgICBpICs9IHc7IG4gKz0gdztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4geyB2ZXJ0aWNlczp2ZXJ0aWNlcywgZmFjZXM6ZmFjZXMgfTtcbn1cbn0pKCk7XG5cbmlmKGV4cG9ydHMpIHtcbiAgZXhwb3J0cy5tZXNoZXIgPSBHcmVlZHlNZXNoO1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvZG1pbGxldC9Qcm9qZWN0cy9mcHQvZnB0LW9sZC9+L3ZveGVsL21lc2hlcnMvZ3JlZWR5LmpzXG4gKiogbW9kdWxlIGlkID0gMTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxIDJcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 20 */
/***/ function(module, exports) {

	eval("var GreedyMesh = (function greedyLoader() {\n    \n// contains all forward faces (in terms of scan direction)\nvar mask = new Int32Array(4096);\n// and all backwards faces. needed when there are two transparent blocks\n// next to each other.\nvar invMask = new Int32Array(4096);\n\n// setting 16th bit if transparent\nvar kTransparentMask    = 0x8000;\nvar kNoFlagsMask        = 0x7FFF;\nvar kTransparentTypes   = [];\n\nkTransparentTypes[16] = true\n\nfunction isTransparent(v) {\n  return (v & kTransparentMask) === kTransparentMask;\n}\n\nfunction removeFlags(v) {\n  return (v & kNoFlagsMask);\n}\n\nreturn function ohSoGreedyMesher(volume, dims, mesherExtraData) {\n  var vertices = [], faces = []\n    , dimsX = dims[0]\n    , dimsY = dims[1]\n    , dimsXY = dimsX * dimsY;\n\n  var tVertices = [], tFaces = []\n\n  var transparentTypes = mesherExtraData ? (mesherExtraData.transparentTypes || {}) : {};\n  var getType = function(voxels, offset) {\n    var type = voxels[offset];\n    return type | (type in transparentTypes ? kTransparentMask : 0);\n  }\n\n\n  //Sweep over 3-axes\n  for(var d=0; d<3; ++d) {\n    var i, j, k, l, w, W, h, n, c\n      , u = (d+1)%3\n      , v = (d+2)%3\n      , x = [0,0,0]\n      , q = [0,0,0]\n      , du = [0,0,0]\n      , dv = [0,0,0]\n      , dimsD = dims[d]\n      , dimsU = dims[u]\n      , dimsV = dims[v]\n      , qdimsX, qdimsXY\n      , xd\n\n    if (mask.length < dimsU * dimsV) {\n      mask = new Int32Array(dimsU * dimsV);\n      invMask = new Int32Array(dimsU * dimsV);\n    }\n\n    q[d] =  1;\n    x[d] = -1;\n\n    qdimsX  = dimsX  * q[1]\n    qdimsXY = dimsXY * q[2]\n\n    // Compute mask\n    while (x[d] < dimsD) {\n      xd = x[d]\n      n = 0;\n\n      for(x[v] = 0; x[v] < dimsV; ++x[v]) {\n        for(x[u] = 0; x[u] < dimsU; ++x[u], ++n) {\n          // Modified to read through getType()\n          var a = xd >= 0      && getType(volume, x[0]      + dimsX * x[1]          + dimsXY * x[2]          )\n            , b = xd < dimsD-1 && getType(volume, x[0]+q[0] + dimsX * x[1] + qdimsX + dimsXY * x[2] + qdimsXY)\n\n          // both are transparent, add to both directions\n          if (isTransparent(a) && isTransparent(b)) {\n            mask[n] = a;\n            invMask[n] = b;\n          // if a is solid and b is not there or transparent\n          } else if (a && (!b || isTransparent(b))) {\n            mask[n] = a;\n            invMask[n] = 0\n          // if b is solid and a is not there or transparent\n          } else if (b && (!a || isTransparent(a))) {\n            mask[n] = 0\n            invMask[n] = b;\n          // dont draw this face\n          } else {\n            mask[n] = 0\n            invMask[n] = 0\n          }\n        }\n      }\n\n      ++x[d];\n\n      // Generate mesh for mask using lexicographic ordering\n      function generateMesh(mask, dimsV, dimsU, vertices, faces, clockwise) {\n        clockwise = clockwise === undefined ? true : clockwise;\n        var n, j, i, c, w, h, k, du = [0,0,0], dv = [0,0,0];\n        n = 0;\n        for (j=0; j < dimsV; ++j) {\n          for (i=0; i < dimsU; ) {\n            c = mask[n];\n            if (!c) {\n              i++;  n++; continue;\n            }\n\n            //Compute width\n            w = 1;\n            while (c === mask[n+w] && i+w < dimsU) w++;\n\n            //Compute height (this is slightly awkward)\n            for (h=1; j+h < dimsV; ++h) {\n              k = 0;\n              while (k < w && c === mask[n+k+h*dimsU]) k++\n              if (k < w) break;\n            }\n\n            // Add quad\n            // The du/dv arrays are reused/reset\n            // for each iteration.\n            du[d] = 0; dv[d] = 0;\n            x[u]  = i;  x[v] = j;\n\n            if (clockwise) {\n            // if (c > 0) {\n              dv[v] = h; dv[u] = 0;\n              du[u] = w; du[v] = 0;\n            } else {\n              // c = -c;\n              du[v] = h; du[u] = 0;\n              dv[u] = w; dv[v] = 0;\n            }\n            \n            // ## enable code to ensure that transparent faces are last in the list\n            // if (!isTransparent(c)) {\n              var vertex_count = vertices.length;\n              vertices.push([x[0],             x[1],             x[2]            ]);\n              vertices.push([x[0]+du[0],       x[1]+du[1],       x[2]+du[2]      ]);\n              vertices.push([x[0]+du[0]+dv[0], x[1]+du[1]+dv[1], x[2]+du[2]+dv[2]]);\n              vertices.push([x[0]      +dv[0], x[1]      +dv[1], x[2]      +dv[2]]);\n              faces.push([vertex_count, vertex_count+1, vertex_count+2, vertex_count+3, removeFlags(c)]);\n            // } else {\n            //   var vertex_count = tVertices.length;\n            //   tVertices.push([x[0],             x[1],             x[2]            ]);\n            //   tVertices.push([x[0]+du[0],       x[1]+du[1],       x[2]+du[2]      ]);\n            //   tVertices.push([x[0]+du[0]+dv[0], x[1]+du[1]+dv[1], x[2]+du[2]+dv[2]]);\n            //   tVertices.push([x[0]      +dv[0], x[1]      +dv[1], x[2]      +dv[2]]);\n            //   tFaces.push([vertex_count, vertex_count+1, vertex_count+2, vertex_count+3, removeFlags(c)]);\n            // }\n\n            //Zero-out mask\n            W = n + w;\n            for(l=0; l<h; ++l) {\n              for(k=n; k<W; ++k) {\n                mask[k+l*dimsU] = 0;\n              }\n            }\n\n            //Increment counters and continue\n            i += w; n += w;\n          }\n        }\n      }\n      generateMesh(mask, dimsV, dimsU, vertices, faces, true)\n      generateMesh(invMask, dimsV, dimsU, vertices, faces, false)\n    }\n  }\n  \n  // ## enable code to ensure that transparent faces are last in the list\n  // var vertex_count = vertices.length;\n  // var newFaces = tFaces.map(function(v) {\n  //   return [vertex_count+v[0], vertex_count+v[1], vertex_count+v[2], vertex_count+v[3], v[4]]\n  // })\n  // \n  // return { vertices:vertices.concat(tVertices), faces:faces.concat(newFaces) };\n  \n  // TODO: Try sorting by texture to see if we can reduce draw calls.\n  // faces.sort(function sortFaces(a, b) {\n  //   return b[4] - a[4];\n  // })\n  return { vertices:vertices, faces:faces };\n}\n})();\n\nif(exports) {\n  exports.mesher = GreedyMesh;\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2RtaWxsZXQvUHJvamVjdHMvZnB0L2ZwdC1vbGQvfi92b3hlbC9tZXNoZXJzL3RyYW5zZ3JlZWR5LmpzP2Y1ZDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLGNBQWMsS0FBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixjQUFjO0FBQ2pDLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFdBQVc7QUFDNUIsbUJBQW1CLFdBQVc7QUFDOUI7QUFDQTtBQUNBLGtCQUFrQixNQUFNO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLGFBQWE7QUFDYjtBQUNBLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLEtBQUs7QUFDekIsc0JBQXNCLEtBQUs7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sVUFBVTtBQUNWO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EiLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgR3JlZWR5TWVzaCA9IChmdW5jdGlvbiBncmVlZHlMb2FkZXIoKSB7XG4gICAgXG4vLyBjb250YWlucyBhbGwgZm9yd2FyZCBmYWNlcyAoaW4gdGVybXMgb2Ygc2NhbiBkaXJlY3Rpb24pXG52YXIgbWFzayA9IG5ldyBJbnQzMkFycmF5KDQwOTYpO1xuLy8gYW5kIGFsbCBiYWNrd2FyZHMgZmFjZXMuIG5lZWRlZCB3aGVuIHRoZXJlIGFyZSB0d28gdHJhbnNwYXJlbnQgYmxvY2tzXG4vLyBuZXh0IHRvIGVhY2ggb3RoZXIuXG52YXIgaW52TWFzayA9IG5ldyBJbnQzMkFycmF5KDQwOTYpO1xuXG4vLyBzZXR0aW5nIDE2dGggYml0IGlmIHRyYW5zcGFyZW50XG52YXIga1RyYW5zcGFyZW50TWFzayAgICA9IDB4ODAwMDtcbnZhciBrTm9GbGFnc01hc2sgICAgICAgID0gMHg3RkZGO1xudmFyIGtUcmFuc3BhcmVudFR5cGVzICAgPSBbXTtcblxua1RyYW5zcGFyZW50VHlwZXNbMTZdID0gdHJ1ZVxuXG5mdW5jdGlvbiBpc1RyYW5zcGFyZW50KHYpIHtcbiAgcmV0dXJuICh2ICYga1RyYW5zcGFyZW50TWFzaykgPT09IGtUcmFuc3BhcmVudE1hc2s7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUZsYWdzKHYpIHtcbiAgcmV0dXJuICh2ICYga05vRmxhZ3NNYXNrKTtcbn1cblxucmV0dXJuIGZ1bmN0aW9uIG9oU29HcmVlZHlNZXNoZXIodm9sdW1lLCBkaW1zLCBtZXNoZXJFeHRyYURhdGEpIHtcbiAgdmFyIHZlcnRpY2VzID0gW10sIGZhY2VzID0gW11cbiAgICAsIGRpbXNYID0gZGltc1swXVxuICAgICwgZGltc1kgPSBkaW1zWzFdXG4gICAgLCBkaW1zWFkgPSBkaW1zWCAqIGRpbXNZO1xuXG4gIHZhciB0VmVydGljZXMgPSBbXSwgdEZhY2VzID0gW11cblxuICB2YXIgdHJhbnNwYXJlbnRUeXBlcyA9IG1lc2hlckV4dHJhRGF0YSA/IChtZXNoZXJFeHRyYURhdGEudHJhbnNwYXJlbnRUeXBlcyB8fCB7fSkgOiB7fTtcbiAgdmFyIGdldFR5cGUgPSBmdW5jdGlvbih2b3hlbHMsIG9mZnNldCkge1xuICAgIHZhciB0eXBlID0gdm94ZWxzW29mZnNldF07XG4gICAgcmV0dXJuIHR5cGUgfCAodHlwZSBpbiB0cmFuc3BhcmVudFR5cGVzID8ga1RyYW5zcGFyZW50TWFzayA6IDApO1xuICB9XG5cblxuICAvL1N3ZWVwIG92ZXIgMy1heGVzXG4gIGZvcih2YXIgZD0wOyBkPDM7ICsrZCkge1xuICAgIHZhciBpLCBqLCBrLCBsLCB3LCBXLCBoLCBuLCBjXG4gICAgICAsIHUgPSAoZCsxKSUzXG4gICAgICAsIHYgPSAoZCsyKSUzXG4gICAgICAsIHggPSBbMCwwLDBdXG4gICAgICAsIHEgPSBbMCwwLDBdXG4gICAgICAsIGR1ID0gWzAsMCwwXVxuICAgICAgLCBkdiA9IFswLDAsMF1cbiAgICAgICwgZGltc0QgPSBkaW1zW2RdXG4gICAgICAsIGRpbXNVID0gZGltc1t1XVxuICAgICAgLCBkaW1zViA9IGRpbXNbdl1cbiAgICAgICwgcWRpbXNYLCBxZGltc1hZXG4gICAgICAsIHhkXG5cbiAgICBpZiAobWFzay5sZW5ndGggPCBkaW1zVSAqIGRpbXNWKSB7XG4gICAgICBtYXNrID0gbmV3IEludDMyQXJyYXkoZGltc1UgKiBkaW1zVik7XG4gICAgICBpbnZNYXNrID0gbmV3IEludDMyQXJyYXkoZGltc1UgKiBkaW1zVik7XG4gICAgfVxuXG4gICAgcVtkXSA9ICAxO1xuICAgIHhbZF0gPSAtMTtcblxuICAgIHFkaW1zWCAgPSBkaW1zWCAgKiBxWzFdXG4gICAgcWRpbXNYWSA9IGRpbXNYWSAqIHFbMl1cblxuICAgIC8vIENvbXB1dGUgbWFza1xuICAgIHdoaWxlICh4W2RdIDwgZGltc0QpIHtcbiAgICAgIHhkID0geFtkXVxuICAgICAgbiA9IDA7XG5cbiAgICAgIGZvcih4W3ZdID0gMDsgeFt2XSA8IGRpbXNWOyArK3hbdl0pIHtcbiAgICAgICAgZm9yKHhbdV0gPSAwOyB4W3VdIDwgZGltc1U7ICsreFt1XSwgKytuKSB7XG4gICAgICAgICAgLy8gTW9kaWZpZWQgdG8gcmVhZCB0aHJvdWdoIGdldFR5cGUoKVxuICAgICAgICAgIHZhciBhID0geGQgPj0gMCAgICAgICYmIGdldFR5cGUodm9sdW1lLCB4WzBdICAgICAgKyBkaW1zWCAqIHhbMV0gICAgICAgICAgKyBkaW1zWFkgKiB4WzJdICAgICAgICAgIClcbiAgICAgICAgICAgICwgYiA9IHhkIDwgZGltc0QtMSAmJiBnZXRUeXBlKHZvbHVtZSwgeFswXStxWzBdICsgZGltc1ggKiB4WzFdICsgcWRpbXNYICsgZGltc1hZICogeFsyXSArIHFkaW1zWFkpXG5cbiAgICAgICAgICAvLyBib3RoIGFyZSB0cmFuc3BhcmVudCwgYWRkIHRvIGJvdGggZGlyZWN0aW9uc1xuICAgICAgICAgIGlmIChpc1RyYW5zcGFyZW50KGEpICYmIGlzVHJhbnNwYXJlbnQoYikpIHtcbiAgICAgICAgICAgIG1hc2tbbl0gPSBhO1xuICAgICAgICAgICAgaW52TWFza1tuXSA9IGI7XG4gICAgICAgICAgLy8gaWYgYSBpcyBzb2xpZCBhbmQgYiBpcyBub3QgdGhlcmUgb3IgdHJhbnNwYXJlbnRcbiAgICAgICAgICB9IGVsc2UgaWYgKGEgJiYgKCFiIHx8IGlzVHJhbnNwYXJlbnQoYikpKSB7XG4gICAgICAgICAgICBtYXNrW25dID0gYTtcbiAgICAgICAgICAgIGludk1hc2tbbl0gPSAwXG4gICAgICAgICAgLy8gaWYgYiBpcyBzb2xpZCBhbmQgYSBpcyBub3QgdGhlcmUgb3IgdHJhbnNwYXJlbnRcbiAgICAgICAgICB9IGVsc2UgaWYgKGIgJiYgKCFhIHx8IGlzVHJhbnNwYXJlbnQoYSkpKSB7XG4gICAgICAgICAgICBtYXNrW25dID0gMFxuICAgICAgICAgICAgaW52TWFza1tuXSA9IGI7XG4gICAgICAgICAgLy8gZG9udCBkcmF3IHRoaXMgZmFjZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXNrW25dID0gMFxuICAgICAgICAgICAgaW52TWFza1tuXSA9IDBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgKyt4W2RdO1xuXG4gICAgICAvLyBHZW5lcmF0ZSBtZXNoIGZvciBtYXNrIHVzaW5nIGxleGljb2dyYXBoaWMgb3JkZXJpbmdcbiAgICAgIGZ1bmN0aW9uIGdlbmVyYXRlTWVzaChtYXNrLCBkaW1zViwgZGltc1UsIHZlcnRpY2VzLCBmYWNlcywgY2xvY2t3aXNlKSB7XG4gICAgICAgIGNsb2Nrd2lzZSA9IGNsb2Nrd2lzZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGNsb2Nrd2lzZTtcbiAgICAgICAgdmFyIG4sIGosIGksIGMsIHcsIGgsIGssIGR1ID0gWzAsMCwwXSwgZHYgPSBbMCwwLDBdO1xuICAgICAgICBuID0gMDtcbiAgICAgICAgZm9yIChqPTA7IGogPCBkaW1zVjsgKytqKSB7XG4gICAgICAgICAgZm9yIChpPTA7IGkgPCBkaW1zVTsgKSB7XG4gICAgICAgICAgICBjID0gbWFza1tuXTtcbiAgICAgICAgICAgIGlmICghYykge1xuICAgICAgICAgICAgICBpKys7ICBuKys7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL0NvbXB1dGUgd2lkdGhcbiAgICAgICAgICAgIHcgPSAxO1xuICAgICAgICAgICAgd2hpbGUgKGMgPT09IG1hc2tbbit3XSAmJiBpK3cgPCBkaW1zVSkgdysrO1xuXG4gICAgICAgICAgICAvL0NvbXB1dGUgaGVpZ2h0ICh0aGlzIGlzIHNsaWdodGx5IGF3a3dhcmQpXG4gICAgICAgICAgICBmb3IgKGg9MTsgaitoIDwgZGltc1Y7ICsraCkge1xuICAgICAgICAgICAgICBrID0gMDtcbiAgICAgICAgICAgICAgd2hpbGUgKGsgPCB3ICYmIGMgPT09IG1hc2tbbitrK2gqZGltc1VdKSBrKytcbiAgICAgICAgICAgICAgaWYgKGsgPCB3KSBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIHF1YWRcbiAgICAgICAgICAgIC8vIFRoZSBkdS9kdiBhcnJheXMgYXJlIHJldXNlZC9yZXNldFxuICAgICAgICAgICAgLy8gZm9yIGVhY2ggaXRlcmF0aW9uLlxuICAgICAgICAgICAgZHVbZF0gPSAwOyBkdltkXSA9IDA7XG4gICAgICAgICAgICB4W3VdICA9IGk7ICB4W3ZdID0gajtcblxuICAgICAgICAgICAgaWYgKGNsb2Nrd2lzZSkge1xuICAgICAgICAgICAgLy8gaWYgKGMgPiAwKSB7XG4gICAgICAgICAgICAgIGR2W3ZdID0gaDsgZHZbdV0gPSAwO1xuICAgICAgICAgICAgICBkdVt1XSA9IHc7IGR1W3ZdID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGMgPSAtYztcbiAgICAgICAgICAgICAgZHVbdl0gPSBoOyBkdVt1XSA9IDA7XG4gICAgICAgICAgICAgIGR2W3VdID0gdzsgZHZbdl0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyAjIyBlbmFibGUgY29kZSB0byBlbnN1cmUgdGhhdCB0cmFuc3BhcmVudCBmYWNlcyBhcmUgbGFzdCBpbiB0aGUgbGlzdFxuICAgICAgICAgICAgLy8gaWYgKCFpc1RyYW5zcGFyZW50KGMpKSB7XG4gICAgICAgICAgICAgIHZhciB2ZXJ0ZXhfY291bnQgPSB2ZXJ0aWNlcy5sZW5ndGg7XG4gICAgICAgICAgICAgIHZlcnRpY2VzLnB1c2goW3hbMF0sICAgICAgICAgICAgIHhbMV0sICAgICAgICAgICAgIHhbMl0gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgdmVydGljZXMucHVzaChbeFswXStkdVswXSwgICAgICAgeFsxXStkdVsxXSwgICAgICAgeFsyXStkdVsyXSAgICAgIF0pO1xuICAgICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKFt4WzBdK2R1WzBdK2R2WzBdLCB4WzFdK2R1WzFdK2R2WzFdLCB4WzJdK2R1WzJdK2R2WzJdXSk7XG4gICAgICAgICAgICAgIHZlcnRpY2VzLnB1c2goW3hbMF0gICAgICArZHZbMF0sIHhbMV0gICAgICArZHZbMV0sIHhbMl0gICAgICArZHZbMl1dKTtcbiAgICAgICAgICAgICAgZmFjZXMucHVzaChbdmVydGV4X2NvdW50LCB2ZXJ0ZXhfY291bnQrMSwgdmVydGV4X2NvdW50KzIsIHZlcnRleF9jb3VudCszLCByZW1vdmVGbGFncyhjKV0pO1xuICAgICAgICAgICAgLy8gfSBlbHNlIHtcbiAgICAgICAgICAgIC8vICAgdmFyIHZlcnRleF9jb3VudCA9IHRWZXJ0aWNlcy5sZW5ndGg7XG4gICAgICAgICAgICAvLyAgIHRWZXJ0aWNlcy5wdXNoKFt4WzBdLCAgICAgICAgICAgICB4WzFdLCAgICAgICAgICAgICB4WzJdICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAvLyAgIHRWZXJ0aWNlcy5wdXNoKFt4WzBdK2R1WzBdLCAgICAgICB4WzFdK2R1WzFdLCAgICAgICB4WzJdK2R1WzJdICAgICAgXSk7XG4gICAgICAgICAgICAvLyAgIHRWZXJ0aWNlcy5wdXNoKFt4WzBdK2R1WzBdK2R2WzBdLCB4WzFdK2R1WzFdK2R2WzFdLCB4WzJdK2R1WzJdK2R2WzJdXSk7XG4gICAgICAgICAgICAvLyAgIHRWZXJ0aWNlcy5wdXNoKFt4WzBdICAgICAgK2R2WzBdLCB4WzFdICAgICAgK2R2WzFdLCB4WzJdICAgICAgK2R2WzJdXSk7XG4gICAgICAgICAgICAvLyAgIHRGYWNlcy5wdXNoKFt2ZXJ0ZXhfY291bnQsIHZlcnRleF9jb3VudCsxLCB2ZXJ0ZXhfY291bnQrMiwgdmVydGV4X2NvdW50KzMsIHJlbW92ZUZsYWdzKGMpXSk7XG4gICAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAgIC8vWmVyby1vdXQgbWFza1xuICAgICAgICAgICAgVyA9IG4gKyB3O1xuICAgICAgICAgICAgZm9yKGw9MDsgbDxoOyArK2wpIHtcbiAgICAgICAgICAgICAgZm9yKGs9bjsgazxXOyArK2spIHtcbiAgICAgICAgICAgICAgICBtYXNrW2srbCpkaW1zVV0gPSAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vSW5jcmVtZW50IGNvdW50ZXJzIGFuZCBjb250aW51ZVxuICAgICAgICAgICAgaSArPSB3OyBuICs9IHc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBnZW5lcmF0ZU1lc2gobWFzaywgZGltc1YsIGRpbXNVLCB2ZXJ0aWNlcywgZmFjZXMsIHRydWUpXG4gICAgICBnZW5lcmF0ZU1lc2goaW52TWFzaywgZGltc1YsIGRpbXNVLCB2ZXJ0aWNlcywgZmFjZXMsIGZhbHNlKVxuICAgIH1cbiAgfVxuICBcbiAgLy8gIyMgZW5hYmxlIGNvZGUgdG8gZW5zdXJlIHRoYXQgdHJhbnNwYXJlbnQgZmFjZXMgYXJlIGxhc3QgaW4gdGhlIGxpc3RcbiAgLy8gdmFyIHZlcnRleF9jb3VudCA9IHZlcnRpY2VzLmxlbmd0aDtcbiAgLy8gdmFyIG5ld0ZhY2VzID0gdEZhY2VzLm1hcChmdW5jdGlvbih2KSB7XG4gIC8vICAgcmV0dXJuIFt2ZXJ0ZXhfY291bnQrdlswXSwgdmVydGV4X2NvdW50K3ZbMV0sIHZlcnRleF9jb3VudCt2WzJdLCB2ZXJ0ZXhfY291bnQrdlszXSwgdls0XV1cbiAgLy8gfSlcbiAgLy8gXG4gIC8vIHJldHVybiB7IHZlcnRpY2VzOnZlcnRpY2VzLmNvbmNhdCh0VmVydGljZXMpLCBmYWNlczpmYWNlcy5jb25jYXQobmV3RmFjZXMpIH07XG4gIFxuICAvLyBUT0RPOiBUcnkgc29ydGluZyBieSB0ZXh0dXJlIHRvIHNlZSBpZiB3ZSBjYW4gcmVkdWNlIGRyYXcgY2FsbHMuXG4gIC8vIGZhY2VzLnNvcnQoZnVuY3Rpb24gc29ydEZhY2VzKGEsIGIpIHtcbiAgLy8gICByZXR1cm4gYls0XSAtIGFbNF07XG4gIC8vIH0pXG4gIHJldHVybiB7IHZlcnRpY2VzOnZlcnRpY2VzLCBmYWNlczpmYWNlcyB9O1xufVxufSkoKTtcblxuaWYoZXhwb3J0cykge1xuICBleHBvcnRzLm1lc2hlciA9IEdyZWVkeU1lc2g7XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9kbWlsbGV0L1Byb2plY3RzL2ZwdC9mcHQtb2xkL34vdm94ZWwvbWVzaGVycy90cmFuc2dyZWVkeS5qc1xuICoqIG1vZHVsZSBpZCA9IDIwXG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMSAyXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 21 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nvar MonotoneMesh = (function(){\n\nfunction MonotonePolygon(c, v, ul, ur) {\n  this.color  = c;\n  this.left   = [[ul, v]];\n  this.right  = [[ur, v]];\n};\n\nMonotonePolygon.prototype.close_off = function(v) {\n  this.left.push([ this.left[this.left.length-1][0], v ]);\n  this.right.push([ this.right[this.right.length-1][0], v ]);\n};\n\nMonotonePolygon.prototype.merge_run = function(v, u_l, u_r) {\n  var l = this.left[this.left.length-1][0]\n    , r = this.right[this.right.length-1][0]; \n  if(l !== u_l) {\n    this.left.push([ l, v ]);\n    this.left.push([ u_l, v ]);\n  }\n  if(r !== u_r) {\n    this.right.push([ r, v ]);\n    this.right.push([ u_r, v ]);\n  }\n};\n\n\nreturn function(volume, dims) {\n  function f(i,j,k) {\n    return volume[i + dims[0] * (j + dims[1] * k)];\n  }\n  //Sweep over 3-axes\n  var vertices = [], faces = [];\n  for(var d=0; d<3; ++d) {\n    var i, j, k\n      , u = (d+1)%3   //u and v are orthogonal directions to d\n      , v = (d+2)%3\n      , x = new Int32Array(3)\n      , q = new Int32Array(3)\n      , runs = new Int32Array(2 * (dims[u]+1))\n      , frontier = new Int32Array(dims[u])  //Frontier is list of pointers to polygons\n      , next_frontier = new Int32Array(dims[u])\n      , left_index = new Int32Array(2 * dims[v])\n      , right_index = new Int32Array(2 * dims[v])\n      , stack = new Int32Array(24 * dims[v])\n      , delta = [[0,0], [0,0]];\n    //q points along d-direction\n    q[d] = 1;\n    //Initialize sentinel\n    for(x[d]=-1; x[d]<dims[d]; ) {\n      // --- Perform monotone polygon subdivision ---\n      var n = 0\n        , polygons = []\n        , nf = 0;\n      for(x[v]=0; x[v]<dims[v]; ++x[v]) {\n        //Make one pass over the u-scan line of the volume to run-length encode polygon\n        var nr = 0, p = 0, c = 0;\n        for(x[u]=0; x[u]<dims[u]; ++x[u], p = c) {\n          //Compute the type for this face\n          var a = (0    <= x[d]      ? f(x[0],      x[1],      x[2])      : 0)\n            , b = (x[d] <  dims[d]-1 ? f(x[0]+q[0], x[1]+q[1], x[2]+q[2]) : 0);\n          c = a;\n          if((!a) === (!b)) {\n            c = 0;\n          } else if(!a) {\n            c = -b;\n          }\n          //If cell type doesn't match, start a new run\n          if(p !== c) {\n            runs[nr++] = x[u];\n            runs[nr++] = c;\n          }\n        }\n        //Add sentinel run\n        runs[nr++] = dims[u];\n        runs[nr++] = 0;\n        //Update frontier by merging runs\n        var fp = 0;\n        for(var i=0, j=0; i<nf && j<nr-2; ) {\n          var p    = polygons[frontier[i]]\n            , p_l  = p.left[p.left.length-1][0]\n            , p_r  = p.right[p.right.length-1][0]\n            , p_c  = p.color\n            , r_l  = runs[j]    //Start of run\n            , r_r  = runs[j+2]  //End of run\n            , r_c  = runs[j+1]; //Color of run\n          //Check if we can merge run with polygon\n          if(r_r > p_l && p_r > r_l && r_c === p_c) {\n            //Merge run\n            p.merge_run(x[v], r_l, r_r);\n            //Insert polygon into frontier\n            next_frontier[fp++] = frontier[i];\n            ++i;\n            j += 2;\n          } else {\n            //Check if we need to advance the run pointer\n            if(r_r <= p_r) {\n              if(!!r_c) {\n                var n_poly = new MonotonePolygon(r_c, x[v], r_l, r_r);\n                next_frontier[fp++] = polygons.length;\n                polygons.push(n_poly);\n              }\n              j += 2;\n            }\n            //Check if we need to advance the frontier pointer\n            if(p_r <= r_r) {\n              p.close_off(x[v]);\n              ++i;\n            }\n          }\n        }\n        //Close off any residual polygons\n        for(; i<nf; ++i) {\n          polygons[frontier[i]].close_off(x[v]);\n        }\n        //Add any extra runs to frontier\n        for(; j<nr-2; j+=2) {\n          var r_l  = runs[j]\n            , r_r  = runs[j+2]\n            , r_c  = runs[j+1];\n          if(!!r_c) {\n            var n_poly = new MonotonePolygon(r_c, x[v], r_l, r_r);\n            next_frontier[fp++] = polygons.length;\n            polygons.push(n_poly);\n          }\n        }\n        //Swap frontiers\n        var tmp = next_frontier;\n        next_frontier = frontier;\n        frontier = tmp;\n        nf = fp;\n      }\n      //Close off frontier\n      for(var i=0; i<nf; ++i) {\n        var p = polygons[frontier[i]];\n        p.close_off(dims[v]);\n      }\n      // --- Monotone subdivision of polygon is complete at this point ---\n      \n      x[d]++;\n      \n      //Now we just need to triangulate each monotone polygon\n      for(var i=0; i<polygons.length; ++i) {\n        var p = polygons[i]\n          , c = p.color\n          , flipped = false;\n        if(c < 0) {\n          flipped = true;\n          c = -c;\n        }\n        for(var j=0; j<p.left.length; ++j) {\n          left_index[j] = vertices.length;\n          var y = [0.0,0.0,0.0]\n            , z = p.left[j];\n          y[d] = x[d];\n          y[u] = z[0];\n          y[v] = z[1];\n          vertices.push(y);\n        }\n        for(var j=0; j<p.right.length; ++j) {\n          right_index[j] = vertices.length;\n          var y = [0.0,0.0,0.0]\n            , z = p.right[j];\n          y[d] = x[d];\n          y[u] = z[0];\n          y[v] = z[1];\n          vertices.push(y);\n        }\n        //Triangulate the monotone polygon\n        var bottom = 0\n          , top = 0\n          , l_i = 1\n          , r_i = 1\n          , side = true;  //true = right, false = left\n        \n        stack[top++] = left_index[0];\n        stack[top++] = p.left[0][0];\n        stack[top++] = p.left[0][1];\n        \n        stack[top++] = right_index[0];\n        stack[top++] = p.right[0][0];\n        stack[top++] = p.right[0][1];\n        \n        while(l_i < p.left.length || r_i < p.right.length) {\n          //Compute next side\n          var n_side = false;\n          if(l_i === p.left.length) {\n            n_side = true;\n          } else if(r_i !== p.right.length) {\n            var l = p.left[l_i]\n              , r = p.right[r_i];\n            n_side = l[1] > r[1];\n          }\n          var idx = n_side ? right_index[r_i] : left_index[l_i]\n            , vert = n_side ? p.right[r_i] : p.left[l_i];\n          if(n_side !== side) {\n            //Opposite side\n            while(bottom+3 < top) {\n              if(flipped === n_side) {\n                faces.push([ stack[bottom], stack[bottom+3], idx, c]);\n              } else {\n                faces.push([ stack[bottom+3], stack[bottom], idx, c]);              \n              }\n              bottom += 3;\n            }\n          } else {\n            //Same side\n            while(bottom+3 < top) {\n              //Compute convexity\n              for(var j=0; j<2; ++j)\n              for(var k=0; k<2; ++k) {\n                delta[j][k] = stack[top-3*(j+1)+k+1] - vert[k];\n              }\n              var det = delta[0][0] * delta[1][1] - delta[1][0] * delta[0][1];\n              if(n_side === (det > 0)) {\n                break;\n              }\n              if(det !== 0) {\n                if(flipped === n_side) {\n                  faces.push([ stack[top-3], stack[top-6], idx, c ]);\n                } else {\n                  faces.push([ stack[top-6], stack[top-3], idx, c ]);\n                }\n              }\n              top -= 3;\n            }\n          }\n          //Push vertex\n          stack[top++] = idx;\n          stack[top++] = vert[0];\n          stack[top++] = vert[1];\n          //Update loop index\n          if(n_side) {\n            ++r_i;\n          } else {\n            ++l_i;\n          }\n          side = n_side;\n        }\n      }\n    }\n  }\n  return { vertices:vertices, faces:faces };\n}\n})();\n\nif(exports) {\n  exports.mesher = MonotoneMesh;\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2RtaWxsZXQvUHJvamVjdHMvZnB0L2ZwdC1vbGQvfi92b3hlbC9tZXNoZXJzL21vbm90b25lLmpzPzNkNzkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsS0FBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixjQUFjO0FBQy9CO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0JBQWdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE1BQU07QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Ysc0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLEtBQUs7QUFDL0IsMEJBQTBCLEtBQUs7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EiLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIE1vbm90b25lTWVzaCA9IChmdW5jdGlvbigpe1xuXG5mdW5jdGlvbiBNb25vdG9uZVBvbHlnb24oYywgdiwgdWwsIHVyKSB7XG4gIHRoaXMuY29sb3IgID0gYztcbiAgdGhpcy5sZWZ0ICAgPSBbW3VsLCB2XV07XG4gIHRoaXMucmlnaHQgID0gW1t1ciwgdl1dO1xufTtcblxuTW9ub3RvbmVQb2x5Z29uLnByb3RvdHlwZS5jbG9zZV9vZmYgPSBmdW5jdGlvbih2KSB7XG4gIHRoaXMubGVmdC5wdXNoKFsgdGhpcy5sZWZ0W3RoaXMubGVmdC5sZW5ndGgtMV1bMF0sIHYgXSk7XG4gIHRoaXMucmlnaHQucHVzaChbIHRoaXMucmlnaHRbdGhpcy5yaWdodC5sZW5ndGgtMV1bMF0sIHYgXSk7XG59O1xuXG5Nb25vdG9uZVBvbHlnb24ucHJvdG90eXBlLm1lcmdlX3J1biA9IGZ1bmN0aW9uKHYsIHVfbCwgdV9yKSB7XG4gIHZhciBsID0gdGhpcy5sZWZ0W3RoaXMubGVmdC5sZW5ndGgtMV1bMF1cbiAgICAsIHIgPSB0aGlzLnJpZ2h0W3RoaXMucmlnaHQubGVuZ3RoLTFdWzBdOyBcbiAgaWYobCAhPT0gdV9sKSB7XG4gICAgdGhpcy5sZWZ0LnB1c2goWyBsLCB2IF0pO1xuICAgIHRoaXMubGVmdC5wdXNoKFsgdV9sLCB2IF0pO1xuICB9XG4gIGlmKHIgIT09IHVfcikge1xuICAgIHRoaXMucmlnaHQucHVzaChbIHIsIHYgXSk7XG4gICAgdGhpcy5yaWdodC5wdXNoKFsgdV9yLCB2IF0pO1xuICB9XG59O1xuXG5cbnJldHVybiBmdW5jdGlvbih2b2x1bWUsIGRpbXMpIHtcbiAgZnVuY3Rpb24gZihpLGosaykge1xuICAgIHJldHVybiB2b2x1bWVbaSArIGRpbXNbMF0gKiAoaiArIGRpbXNbMV0gKiBrKV07XG4gIH1cbiAgLy9Td2VlcCBvdmVyIDMtYXhlc1xuICB2YXIgdmVydGljZXMgPSBbXSwgZmFjZXMgPSBbXTtcbiAgZm9yKHZhciBkPTA7IGQ8MzsgKytkKSB7XG4gICAgdmFyIGksIGosIGtcbiAgICAgICwgdSA9IChkKzEpJTMgICAvL3UgYW5kIHYgYXJlIG9ydGhvZ29uYWwgZGlyZWN0aW9ucyB0byBkXG4gICAgICAsIHYgPSAoZCsyKSUzXG4gICAgICAsIHggPSBuZXcgSW50MzJBcnJheSgzKVxuICAgICAgLCBxID0gbmV3IEludDMyQXJyYXkoMylcbiAgICAgICwgcnVucyA9IG5ldyBJbnQzMkFycmF5KDIgKiAoZGltc1t1XSsxKSlcbiAgICAgICwgZnJvbnRpZXIgPSBuZXcgSW50MzJBcnJheShkaW1zW3VdKSAgLy9Gcm9udGllciBpcyBsaXN0IG9mIHBvaW50ZXJzIHRvIHBvbHlnb25zXG4gICAgICAsIG5leHRfZnJvbnRpZXIgPSBuZXcgSW50MzJBcnJheShkaW1zW3VdKVxuICAgICAgLCBsZWZ0X2luZGV4ID0gbmV3IEludDMyQXJyYXkoMiAqIGRpbXNbdl0pXG4gICAgICAsIHJpZ2h0X2luZGV4ID0gbmV3IEludDMyQXJyYXkoMiAqIGRpbXNbdl0pXG4gICAgICAsIHN0YWNrID0gbmV3IEludDMyQXJyYXkoMjQgKiBkaW1zW3ZdKVxuICAgICAgLCBkZWx0YSA9IFtbMCwwXSwgWzAsMF1dO1xuICAgIC8vcSBwb2ludHMgYWxvbmcgZC1kaXJlY3Rpb25cbiAgICBxW2RdID0gMTtcbiAgICAvL0luaXRpYWxpemUgc2VudGluZWxcbiAgICBmb3IoeFtkXT0tMTsgeFtkXTxkaW1zW2RdOyApIHtcbiAgICAgIC8vIC0tLSBQZXJmb3JtIG1vbm90b25lIHBvbHlnb24gc3ViZGl2aXNpb24gLS0tXG4gICAgICB2YXIgbiA9IDBcbiAgICAgICAgLCBwb2x5Z29ucyA9IFtdXG4gICAgICAgICwgbmYgPSAwO1xuICAgICAgZm9yKHhbdl09MDsgeFt2XTxkaW1zW3ZdOyArK3hbdl0pIHtcbiAgICAgICAgLy9NYWtlIG9uZSBwYXNzIG92ZXIgdGhlIHUtc2NhbiBsaW5lIG9mIHRoZSB2b2x1bWUgdG8gcnVuLWxlbmd0aCBlbmNvZGUgcG9seWdvblxuICAgICAgICB2YXIgbnIgPSAwLCBwID0gMCwgYyA9IDA7XG4gICAgICAgIGZvcih4W3VdPTA7IHhbdV08ZGltc1t1XTsgKyt4W3VdLCBwID0gYykge1xuICAgICAgICAgIC8vQ29tcHV0ZSB0aGUgdHlwZSBmb3IgdGhpcyBmYWNlXG4gICAgICAgICAgdmFyIGEgPSAoMCAgICA8PSB4W2RdICAgICAgPyBmKHhbMF0sICAgICAgeFsxXSwgICAgICB4WzJdKSAgICAgIDogMClcbiAgICAgICAgICAgICwgYiA9ICh4W2RdIDwgIGRpbXNbZF0tMSA/IGYoeFswXStxWzBdLCB4WzFdK3FbMV0sIHhbMl0rcVsyXSkgOiAwKTtcbiAgICAgICAgICBjID0gYTtcbiAgICAgICAgICBpZigoIWEpID09PSAoIWIpKSB7XG4gICAgICAgICAgICBjID0gMDtcbiAgICAgICAgICB9IGVsc2UgaWYoIWEpIHtcbiAgICAgICAgICAgIGMgPSAtYjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy9JZiBjZWxsIHR5cGUgZG9lc24ndCBtYXRjaCwgc3RhcnQgYSBuZXcgcnVuXG4gICAgICAgICAgaWYocCAhPT0gYykge1xuICAgICAgICAgICAgcnVuc1tucisrXSA9IHhbdV07XG4gICAgICAgICAgICBydW5zW25yKytdID0gYztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy9BZGQgc2VudGluZWwgcnVuXG4gICAgICAgIHJ1bnNbbnIrK10gPSBkaW1zW3VdO1xuICAgICAgICBydW5zW25yKytdID0gMDtcbiAgICAgICAgLy9VcGRhdGUgZnJvbnRpZXIgYnkgbWVyZ2luZyBydW5zXG4gICAgICAgIHZhciBmcCA9IDA7XG4gICAgICAgIGZvcih2YXIgaT0wLCBqPTA7IGk8bmYgJiYgajxuci0yOyApIHtcbiAgICAgICAgICB2YXIgcCAgICA9IHBvbHlnb25zW2Zyb250aWVyW2ldXVxuICAgICAgICAgICAgLCBwX2wgID0gcC5sZWZ0W3AubGVmdC5sZW5ndGgtMV1bMF1cbiAgICAgICAgICAgICwgcF9yICA9IHAucmlnaHRbcC5yaWdodC5sZW5ndGgtMV1bMF1cbiAgICAgICAgICAgICwgcF9jICA9IHAuY29sb3JcbiAgICAgICAgICAgICwgcl9sICA9IHJ1bnNbal0gICAgLy9TdGFydCBvZiBydW5cbiAgICAgICAgICAgICwgcl9yICA9IHJ1bnNbaisyXSAgLy9FbmQgb2YgcnVuXG4gICAgICAgICAgICAsIHJfYyAgPSBydW5zW2orMV07IC8vQ29sb3Igb2YgcnVuXG4gICAgICAgICAgLy9DaGVjayBpZiB3ZSBjYW4gbWVyZ2UgcnVuIHdpdGggcG9seWdvblxuICAgICAgICAgIGlmKHJfciA+IHBfbCAmJiBwX3IgPiByX2wgJiYgcl9jID09PSBwX2MpIHtcbiAgICAgICAgICAgIC8vTWVyZ2UgcnVuXG4gICAgICAgICAgICBwLm1lcmdlX3J1bih4W3ZdLCByX2wsIHJfcik7XG4gICAgICAgICAgICAvL0luc2VydCBwb2x5Z29uIGludG8gZnJvbnRpZXJcbiAgICAgICAgICAgIG5leHRfZnJvbnRpZXJbZnArK10gPSBmcm9udGllcltpXTtcbiAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgIGogKz0gMjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9DaGVjayBpZiB3ZSBuZWVkIHRvIGFkdmFuY2UgdGhlIHJ1biBwb2ludGVyXG4gICAgICAgICAgICBpZihyX3IgPD0gcF9yKSB7XG4gICAgICAgICAgICAgIGlmKCEhcl9jKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5fcG9seSA9IG5ldyBNb25vdG9uZVBvbHlnb24ocl9jLCB4W3ZdLCByX2wsIHJfcik7XG4gICAgICAgICAgICAgICAgbmV4dF9mcm9udGllcltmcCsrXSA9IHBvbHlnb25zLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBwb2x5Z29ucy5wdXNoKG5fcG9seSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaiArPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9DaGVjayBpZiB3ZSBuZWVkIHRvIGFkdmFuY2UgdGhlIGZyb250aWVyIHBvaW50ZXJcbiAgICAgICAgICAgIGlmKHBfciA8PSByX3IpIHtcbiAgICAgICAgICAgICAgcC5jbG9zZV9vZmYoeFt2XSk7XG4gICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy9DbG9zZSBvZmYgYW55IHJlc2lkdWFsIHBvbHlnb25zXG4gICAgICAgIGZvcig7IGk8bmY7ICsraSkge1xuICAgICAgICAgIHBvbHlnb25zW2Zyb250aWVyW2ldXS5jbG9zZV9vZmYoeFt2XSk7XG4gICAgICAgIH1cbiAgICAgICAgLy9BZGQgYW55IGV4dHJhIHJ1bnMgdG8gZnJvbnRpZXJcbiAgICAgICAgZm9yKDsgajxuci0yOyBqKz0yKSB7XG4gICAgICAgICAgdmFyIHJfbCAgPSBydW5zW2pdXG4gICAgICAgICAgICAsIHJfciAgPSBydW5zW2orMl1cbiAgICAgICAgICAgICwgcl9jICA9IHJ1bnNbaisxXTtcbiAgICAgICAgICBpZighIXJfYykge1xuICAgICAgICAgICAgdmFyIG5fcG9seSA9IG5ldyBNb25vdG9uZVBvbHlnb24ocl9jLCB4W3ZdLCByX2wsIHJfcik7XG4gICAgICAgICAgICBuZXh0X2Zyb250aWVyW2ZwKytdID0gcG9seWdvbnMubGVuZ3RoO1xuICAgICAgICAgICAgcG9seWdvbnMucHVzaChuX3BvbHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvL1N3YXAgZnJvbnRpZXJzXG4gICAgICAgIHZhciB0bXAgPSBuZXh0X2Zyb250aWVyO1xuICAgICAgICBuZXh0X2Zyb250aWVyID0gZnJvbnRpZXI7XG4gICAgICAgIGZyb250aWVyID0gdG1wO1xuICAgICAgICBuZiA9IGZwO1xuICAgICAgfVxuICAgICAgLy9DbG9zZSBvZmYgZnJvbnRpZXJcbiAgICAgIGZvcih2YXIgaT0wOyBpPG5mOyArK2kpIHtcbiAgICAgICAgdmFyIHAgPSBwb2x5Z29uc1tmcm9udGllcltpXV07XG4gICAgICAgIHAuY2xvc2Vfb2ZmKGRpbXNbdl0pO1xuICAgICAgfVxuICAgICAgLy8gLS0tIE1vbm90b25lIHN1YmRpdmlzaW9uIG9mIHBvbHlnb24gaXMgY29tcGxldGUgYXQgdGhpcyBwb2ludCAtLS1cbiAgICAgIFxuICAgICAgeFtkXSsrO1xuICAgICAgXG4gICAgICAvL05vdyB3ZSBqdXN0IG5lZWQgdG8gdHJpYW5ndWxhdGUgZWFjaCBtb25vdG9uZSBwb2x5Z29uXG4gICAgICBmb3IodmFyIGk9MDsgaTxwb2x5Z29ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcCA9IHBvbHlnb25zW2ldXG4gICAgICAgICAgLCBjID0gcC5jb2xvclxuICAgICAgICAgICwgZmxpcHBlZCA9IGZhbHNlO1xuICAgICAgICBpZihjIDwgMCkge1xuICAgICAgICAgIGZsaXBwZWQgPSB0cnVlO1xuICAgICAgICAgIGMgPSAtYztcbiAgICAgICAgfVxuICAgICAgICBmb3IodmFyIGo9MDsgajxwLmxlZnQubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICBsZWZ0X2luZGV4W2pdID0gdmVydGljZXMubGVuZ3RoO1xuICAgICAgICAgIHZhciB5ID0gWzAuMCwwLjAsMC4wXVxuICAgICAgICAgICAgLCB6ID0gcC5sZWZ0W2pdO1xuICAgICAgICAgIHlbZF0gPSB4W2RdO1xuICAgICAgICAgIHlbdV0gPSB6WzBdO1xuICAgICAgICAgIHlbdl0gPSB6WzFdO1xuICAgICAgICAgIHZlcnRpY2VzLnB1c2goeSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yKHZhciBqPTA7IGo8cC5yaWdodC5sZW5ndGg7ICsraikge1xuICAgICAgICAgIHJpZ2h0X2luZGV4W2pdID0gdmVydGljZXMubGVuZ3RoO1xuICAgICAgICAgIHZhciB5ID0gWzAuMCwwLjAsMC4wXVxuICAgICAgICAgICAgLCB6ID0gcC5yaWdodFtqXTtcbiAgICAgICAgICB5W2RdID0geFtkXTtcbiAgICAgICAgICB5W3VdID0gelswXTtcbiAgICAgICAgICB5W3ZdID0gelsxXTtcbiAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKHkpO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJpYW5ndWxhdGUgdGhlIG1vbm90b25lIHBvbHlnb25cbiAgICAgICAgdmFyIGJvdHRvbSA9IDBcbiAgICAgICAgICAsIHRvcCA9IDBcbiAgICAgICAgICAsIGxfaSA9IDFcbiAgICAgICAgICAsIHJfaSA9IDFcbiAgICAgICAgICAsIHNpZGUgPSB0cnVlOyAgLy90cnVlID0gcmlnaHQsIGZhbHNlID0gbGVmdFxuICAgICAgICBcbiAgICAgICAgc3RhY2tbdG9wKytdID0gbGVmdF9pbmRleFswXTtcbiAgICAgICAgc3RhY2tbdG9wKytdID0gcC5sZWZ0WzBdWzBdO1xuICAgICAgICBzdGFja1t0b3ArK10gPSBwLmxlZnRbMF1bMV07XG4gICAgICAgIFxuICAgICAgICBzdGFja1t0b3ArK10gPSByaWdodF9pbmRleFswXTtcbiAgICAgICAgc3RhY2tbdG9wKytdID0gcC5yaWdodFswXVswXTtcbiAgICAgICAgc3RhY2tbdG9wKytdID0gcC5yaWdodFswXVsxXTtcbiAgICAgICAgXG4gICAgICAgIHdoaWxlKGxfaSA8IHAubGVmdC5sZW5ndGggfHwgcl9pIDwgcC5yaWdodC5sZW5ndGgpIHtcbiAgICAgICAgICAvL0NvbXB1dGUgbmV4dCBzaWRlXG4gICAgICAgICAgdmFyIG5fc2lkZSA9IGZhbHNlO1xuICAgICAgICAgIGlmKGxfaSA9PT0gcC5sZWZ0Lmxlbmd0aCkge1xuICAgICAgICAgICAgbl9zaWRlID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYocl9pICE9PSBwLnJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGwgPSBwLmxlZnRbbF9pXVxuICAgICAgICAgICAgICAsIHIgPSBwLnJpZ2h0W3JfaV07XG4gICAgICAgICAgICBuX3NpZGUgPSBsWzFdID4gclsxXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGlkeCA9IG5fc2lkZSA/IHJpZ2h0X2luZGV4W3JfaV0gOiBsZWZ0X2luZGV4W2xfaV1cbiAgICAgICAgICAgICwgdmVydCA9IG5fc2lkZSA/IHAucmlnaHRbcl9pXSA6IHAubGVmdFtsX2ldO1xuICAgICAgICAgIGlmKG5fc2lkZSAhPT0gc2lkZSkge1xuICAgICAgICAgICAgLy9PcHBvc2l0ZSBzaWRlXG4gICAgICAgICAgICB3aGlsZShib3R0b20rMyA8IHRvcCkge1xuICAgICAgICAgICAgICBpZihmbGlwcGVkID09PSBuX3NpZGUpIHtcbiAgICAgICAgICAgICAgICBmYWNlcy5wdXNoKFsgc3RhY2tbYm90dG9tXSwgc3RhY2tbYm90dG9tKzNdLCBpZHgsIGNdKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmYWNlcy5wdXNoKFsgc3RhY2tbYm90dG9tKzNdLCBzdGFja1tib3R0b21dLCBpZHgsIGNdKTsgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJvdHRvbSArPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL1NhbWUgc2lkZVxuICAgICAgICAgICAgd2hpbGUoYm90dG9tKzMgPCB0b3ApIHtcbiAgICAgICAgICAgICAgLy9Db21wdXRlIGNvbnZleGl0eVxuICAgICAgICAgICAgICBmb3IodmFyIGo9MDsgajwyOyArK2opXG4gICAgICAgICAgICAgIGZvcih2YXIgaz0wOyBrPDI7ICsraykge1xuICAgICAgICAgICAgICAgIGRlbHRhW2pdW2tdID0gc3RhY2tbdG9wLTMqKGorMSkraysxXSAtIHZlcnRba107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGRldCA9IGRlbHRhWzBdWzBdICogZGVsdGFbMV1bMV0gLSBkZWx0YVsxXVswXSAqIGRlbHRhWzBdWzFdO1xuICAgICAgICAgICAgICBpZihuX3NpZGUgPT09IChkZXQgPiAwKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmKGRldCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmKGZsaXBwZWQgPT09IG5fc2lkZSkge1xuICAgICAgICAgICAgICAgICAgZmFjZXMucHVzaChbIHN0YWNrW3RvcC0zXSwgc3RhY2tbdG9wLTZdLCBpZHgsIGMgXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGZhY2VzLnB1c2goWyBzdGFja1t0b3AtNl0sIHN0YWNrW3RvcC0zXSwgaWR4LCBjIF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0b3AgLT0gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy9QdXNoIHZlcnRleFxuICAgICAgICAgIHN0YWNrW3RvcCsrXSA9IGlkeDtcbiAgICAgICAgICBzdGFja1t0b3ArK10gPSB2ZXJ0WzBdO1xuICAgICAgICAgIHN0YWNrW3RvcCsrXSA9IHZlcnRbMV07XG4gICAgICAgICAgLy9VcGRhdGUgbG9vcCBpbmRleFxuICAgICAgICAgIGlmKG5fc2lkZSkge1xuICAgICAgICAgICAgKytyX2k7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICsrbF9pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzaWRlID0gbl9zaWRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB7IHZlcnRpY2VzOnZlcnRpY2VzLCBmYWNlczpmYWNlcyB9O1xufVxufSkoKTtcblxuaWYoZXhwb3J0cykge1xuICBleHBvcnRzLm1lc2hlciA9IE1vbm90b25lTWVzaDtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL2RtaWxsZXQvUHJvamVjdHMvZnB0L2ZwdC1vbGQvfi92b3hlbC9tZXNoZXJzL21vbm90b25lLmpzXG4gKiogbW9kdWxlIGlkID0gMjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxIDJcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 22 */
/***/ function(module, exports) {

	eval("//The stupidest possible way to generate a Minecraft mesh (I think)\nfunction StupidMesh(volume, dims) {\n  var vertices = [], faces = [], x = [0,0,0], n = 0;\n  for(x[2]=0; x[2]<dims[2]; ++x[2])\n  for(x[1]=0; x[1]<dims[1]; ++x[1])\n  for(x[0]=0; x[0]<dims[0]; ++x[0], ++n)\n  if(!!volume[n]) {\n    for(var d=0; d<3; ++d) {\n      var t = [x[0], x[1], x[2]]\n        , u = [0,0,0]\n        , v = [0,0,0];\n      u[(d+1)%3] = 1;\n      v[(d+2)%3] = 1;\n      for(var s=0; s<2; ++s) {\n        t[d] = x[d] + s;\n        var tmp = u;\n        u = v;\n        v = tmp;\n        var vertex_count = vertices.length;\n        vertices.push([t[0],           t[1],           t[2]          ]);\n        vertices.push([t[0]+u[0],      t[1]+u[1],      t[2]+u[2]     ]);\n        vertices.push([t[0]+u[0]+v[0], t[1]+u[1]+v[1], t[2]+u[2]+v[2]]);\n        vertices.push([t[0]     +v[0], t[1]     +v[1], t[2]     +v[2]]);\n        faces.push([vertex_count, vertex_count+1, vertex_count+2, vertex_count+3, volume[n]]);\n      }\n    }\n  }\n  return { vertices:vertices, faces:faces };\n}\n\n\nif(exports) {\n  exports.mesher = StupidMesh;\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2RtaWxsZXQvUHJvamVjdHMvZnB0L2ZwdC1vbGQvfi92b3hlbC9tZXNoZXJzL3N0dXBpZC5qcz9mYzAyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQixhQUFhLGNBQWM7QUFDM0IsYUFBYSxjQUFjO0FBQzNCO0FBQ0EsZ0JBQWdCLEtBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixLQUFLO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOzs7QUFHQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvL1RoZSBzdHVwaWRlc3QgcG9zc2libGUgd2F5IHRvIGdlbmVyYXRlIGEgTWluZWNyYWZ0IG1lc2ggKEkgdGhpbmspXG5mdW5jdGlvbiBTdHVwaWRNZXNoKHZvbHVtZSwgZGltcykge1xuICB2YXIgdmVydGljZXMgPSBbXSwgZmFjZXMgPSBbXSwgeCA9IFswLDAsMF0sIG4gPSAwO1xuICBmb3IoeFsyXT0wOyB4WzJdPGRpbXNbMl07ICsreFsyXSlcbiAgZm9yKHhbMV09MDsgeFsxXTxkaW1zWzFdOyArK3hbMV0pXG4gIGZvcih4WzBdPTA7IHhbMF08ZGltc1swXTsgKyt4WzBdLCArK24pXG4gIGlmKCEhdm9sdW1lW25dKSB7XG4gICAgZm9yKHZhciBkPTA7IGQ8MzsgKytkKSB7XG4gICAgICB2YXIgdCA9IFt4WzBdLCB4WzFdLCB4WzJdXVxuICAgICAgICAsIHUgPSBbMCwwLDBdXG4gICAgICAgICwgdiA9IFswLDAsMF07XG4gICAgICB1WyhkKzEpJTNdID0gMTtcbiAgICAgIHZbKGQrMiklM10gPSAxO1xuICAgICAgZm9yKHZhciBzPTA7IHM8MjsgKytzKSB7XG4gICAgICAgIHRbZF0gPSB4W2RdICsgcztcbiAgICAgICAgdmFyIHRtcCA9IHU7XG4gICAgICAgIHUgPSB2O1xuICAgICAgICB2ID0gdG1wO1xuICAgICAgICB2YXIgdmVydGV4X2NvdW50ID0gdmVydGljZXMubGVuZ3RoO1xuICAgICAgICB2ZXJ0aWNlcy5wdXNoKFt0WzBdLCAgICAgICAgICAgdFsxXSwgICAgICAgICAgIHRbMl0gICAgICAgICAgXSk7XG4gICAgICAgIHZlcnRpY2VzLnB1c2goW3RbMF0rdVswXSwgICAgICB0WzFdK3VbMV0sICAgICAgdFsyXSt1WzJdICAgICBdKTtcbiAgICAgICAgdmVydGljZXMucHVzaChbdFswXSt1WzBdK3ZbMF0sIHRbMV0rdVsxXSt2WzFdLCB0WzJdK3VbMl0rdlsyXV0pO1xuICAgICAgICB2ZXJ0aWNlcy5wdXNoKFt0WzBdICAgICArdlswXSwgdFsxXSAgICAgK3ZbMV0sIHRbMl0gICAgICt2WzJdXSk7XG4gICAgICAgIGZhY2VzLnB1c2goW3ZlcnRleF9jb3VudCwgdmVydGV4X2NvdW50KzEsIHZlcnRleF9jb3VudCsyLCB2ZXJ0ZXhfY291bnQrMywgdm9sdW1lW25dXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB7IHZlcnRpY2VzOnZlcnRpY2VzLCBmYWNlczpmYWNlcyB9O1xufVxuXG5cbmlmKGV4cG9ydHMpIHtcbiAgZXhwb3J0cy5tZXNoZXIgPSBTdHVwaWRNZXNoO1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvZG1pbGxldC9Qcm9qZWN0cy9mcHQvZnB0LW9sZC9+L3ZveGVsL21lc2hlcnMvc3R1cGlkLmpzXG4gKiogbW9kdWxlIGlkID0gMjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxIDJcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _cannon = __webpack_require__(9);\n\nvar _cannon2 = _interopRequireDefault(_cannon);\n\nvar _terrainPhysicsMerge = __webpack_require__(24);\n\nvar _terrainPhysicsMerge2 = _interopRequireDefault(_terrainPhysicsMerge);\n\nvar _Terrain = __webpack_require__(12);\n\nvar _Terrain2 = _interopRequireDefault(_Terrain);\n\nvar _TerrainPiece = __webpack_require__(25);\n\nvar _TerrainPiece2 = _interopRequireDefault(_TerrainPiece);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar X = 0;\nvar Y = 1;\nvar Z = 2;\n\nvar WIDTH = 0;\nvar HEIGHT = 1;\nvar DEPTH = 2;\n\nvar TerrainPhysics = function () {\n\t_createClass(TerrainPhysics, null, [{\n\t\tkey: 'create',\n\t\tvalue: function create(terrain) {\n\t\t\treturn new TerrainPhysics(terrain);\n\t\t}\n\t}]);\n\n\tfunction TerrainPhysics(terrain) {\n\t\t_classCallCheck(this, TerrainPhysics);\n\n\t\tthis.terrain = terrain;\n\n\t\tvar voxels = terrain.get('voxels');\n\n\t\tfor (var chunkPos in voxels.chunks) {\n\t\t\tvar chunk = voxels.chunks[chunkPos];\n\t\t\tif (chunk) {\n\t\t\t\tthis.createChunkPhysics(chunk);\n\t\t\t}\n\t\t}\n\t}\n\n\t_createClass(TerrainPhysics, [{\n\t\tkey: 'createChunkPhysics',\n\t\tvalue: function createChunkPhysics(chunk) {\n\t\t\tvar cache = {};\n\t\t\tvar pieces = this.terrain.get('pieces');\n\n\t\t\tfunction isProcessed(pos) {\n\t\t\t\treturn cache[pos.join('|')] || false;\n\t\t\t}\n\n\t\t\tfunction markProcessed(pos) {\n\t\t\t\treturn cache[pos.join('|')] = true;\n\t\t\t}\n\n\t\t\tthis.createChunkPhysics.items = this.createChunkPhysics.items || {};\n\t\t\tvar chunkItems = this.createChunkPhysics.items[chunk.position.join('|')];\n\t\t\tif (chunkItems) {\n\t\t\t\tchunkItems.forEach(function (item) {\n\t\t\t\t\tif (item.mesh) {\n\t\t\t\t\t\tthis.scene.remove(item.mesh);\n\t\t\t\t\t}\n\t\t\t\t\t//this.world.remove(item.body);\n\t\t\t\t}.bind(this));\n\t\t\t}\n\t\t\tchunkItems = this.createChunkPhysics.items[chunk.position.join('|')] = [];\n\n\t\t\t_terrainPhysicsMerge2.default.all(function (pos) {\n\t\t\t\treturn this.terrain.getBlockAt(pos) && !isProcessed(pos);\n\t\t\t}.bind(this), chunk, function (result) {\n\n\t\t\t\t_terrainPhysicsMerge2.default.voxelsIn(result).forEach(function (pos) {\n\t\t\t\t\tmarkProcessed(pos);\n\t\t\t\t});\n\t\t\t\tvar position = result.position.map(function (v, i) {\n\t\t\t\t\treturn v + result.dims[i] / 2;\n\t\t\t\t});\n\n\t\t\t\tvar boxShape = new _cannon2.default.Box(new _cannon2.default.Vec3(result.dims[WIDTH] / 2, result.dims[HEIGHT] / 2, result.dims[DEPTH] / 2));\n\t\t\t\tvar box = new _cannon2.default.Body({\n\t\t\t\t\tmass: 0\n\t\t\t\t});\n\t\t\t\tbox.addShape(boxShape);\n\t\t\t\tbox.position.set.apply(box.position, position);\n\n\t\t\t\tvar item = {\n\t\t\t\t\tmesh: null,\n\t\t\t\t\tbody: box\n\t\t\t\t};\n\n\t\t\t\tchunkItems.push(item);\n\n\t\t\t\tvar piece = _TerrainPiece2.default.create({\n\t\t\t\t\tcannon: box\n\t\t\t\t});\n\n\t\t\t\tpieces.add(piece);\n\t\t\t}.bind(this));\n\t\t}\n\t}]);\n\n\treturn TerrainPhysics;\n}();\n\nexports.default = TerrainPhysics;//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vZ2FtZS90ZXJyYWluL1RlcnJhaW5QaHlzaWNzLmpzPzdmZjUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7QUFFQSxJQUFJLElBQUksQ0FBUjtBQUNBLElBQUksSUFBSSxDQUFSO0FBQ0EsSUFBSSxJQUFJLENBQVI7O0FBRUEsSUFBSSxRQUFRLENBQVo7QUFDQSxJQUFJLFNBQVMsQ0FBYjtBQUNBLElBQUksUUFBUSxDQUFaOztJQUVxQixjO2NBQUEsYzs7eUJBRU4sTyxFQUFTO0FBQ3RCLFVBQU8sSUFBSSxjQUFKLENBQW1CLE9BQW5CLENBQVA7QUFDQTs7O0FBRUQsVUFOb0IsY0FNcEIsQ0FBWSxPQUFaLEVBQXFCO0FBQUEsd0JBTkQsY0FNQzs7QUFFcEIsT0FBSyxPQUFMLEdBQWUsT0FBZjs7QUFFQSxNQUFJLFNBQVMsUUFBUSxHQUFSLENBQVksUUFBWixDQUFiOztBQUVBLE9BQUssSUFBSSxRQUFULElBQXFCLE9BQU8sTUFBNUIsRUFBb0M7QUFDbkMsT0FBSSxRQUFRLE9BQU8sTUFBUCxDQUFjLFFBQWQsQ0FBWjtBQUNBLE9BQUksS0FBSixFQUFXO0FBQ1YsU0FBSyxrQkFBTCxDQUF3QixLQUF4QjtBQUNBO0FBQ0Q7QUFFRDs7Y0FuQm1CLGM7O3FDQXFCRCxLLEVBQU87QUFDekIsT0FBSSxRQUFRLEVBQVo7QUFDQSxPQUFJLFNBQVMsS0FBSyxPQUFMLENBQWEsR0FBYixDQUFpQixRQUFqQixDQUFiOztBQUVBLFlBQVMsV0FBVCxDQUFxQixHQUFyQixFQUEwQjtBQUN6QixXQUFPLE1BQU0sSUFBSSxJQUFKLENBQVMsR0FBVCxDQUFOLEtBQXdCLEtBQS9CO0FBQ0E7O0FBRUQsWUFBUyxhQUFULENBQXVCLEdBQXZCLEVBQTRCO0FBQzNCLFdBQU8sTUFBTSxJQUFJLElBQUosQ0FBUyxHQUFULENBQU4sSUFBdUIsSUFBOUI7QUFDQTs7QUFFRCxRQUFLLGtCQUFMLENBQXdCLEtBQXhCLEdBQWdDLEtBQUssa0JBQUwsQ0FBd0IsS0FBeEIsSUFBaUMsRUFBakU7QUFDQSxPQUFJLGFBQWEsS0FBSyxrQkFBTCxDQUF3QixLQUF4QixDQUE4QixNQUFNLFFBQU4sQ0FBZSxJQUFmLENBQW9CLEdBQXBCLENBQTlCLENBQWpCO0FBQ0EsT0FBSSxVQUFKLEVBQWdCO0FBQ2YsZUFBVyxPQUFYLENBQW1CLFVBQVMsSUFBVCxFQUFlO0FBQ2pDLFNBQUcsS0FBSyxJQUFSLEVBQWM7QUFDYixXQUFLLEtBQUwsQ0FBVyxNQUFYLENBQWtCLEtBQUssSUFBdkI7QUFDQTs7QUFFRCxLQUxrQixDQUtqQixJQUxpQixDQUtaLElBTFksQ0FBbkI7QUFNQTtBQUNELGdCQUFhLEtBQUssa0JBQUwsQ0FBd0IsS0FBeEIsQ0FBOEIsTUFBTSxRQUFOLENBQWUsSUFBZixDQUFvQixHQUFwQixDQUE5QixJQUEwRCxFQUF2RTs7QUFFQSxpQ0FBTSxHQUFOLENBRUMsVUFBUyxHQUFULEVBQWM7QUFDYixXQUFPLEtBQUssT0FBTCxDQUFhLFVBQWIsQ0FBd0IsR0FBeEIsS0FBZ0MsQ0FBQyxZQUFZLEdBQVosQ0FBeEM7QUFDQSxJQUZELENBRUUsSUFGRixDQUVPLElBRlAsQ0FGRCxFQU1DLEtBTkQsRUFRQyxVQUFTLE1BQVQsRUFBaUI7O0FBRWhCLGtDQUFNLFFBQU4sQ0FBZSxNQUFmLEVBQXVCLE9BQXZCLENBQStCLFVBQVMsR0FBVCxFQUFjO0FBQzVDLG1CQUFjLEdBQWQ7QUFDQSxLQUZEO0FBR0EsUUFBSSxXQUFXLE9BQU8sUUFBUCxDQUFnQixHQUFoQixDQUFvQixVQUFTLENBQVQsRUFBWSxDQUFaLEVBQWU7QUFBQyxZQUFPLElBQUksT0FBTyxJQUFQLENBQVksQ0FBWixJQUFpQixDQUE1QjtBQUErQixLQUFuRSxDQUFmOztBQUVBLFFBQUksV0FBVyxJQUFJLGlCQUFPLEdBQVgsQ0FBZSxJQUFJLGlCQUFPLElBQVgsQ0FBZ0IsT0FBTyxJQUFQLENBQVksS0FBWixJQUFxQixDQUFyQyxFQUF3QyxPQUFPLElBQVAsQ0FBWSxNQUFaLElBQXNCLENBQTlELEVBQWlFLE9BQU8sSUFBUCxDQUFZLEtBQVosSUFBcUIsQ0FBdEYsQ0FBZixDQUFmO0FBQ0EsUUFBSSxNQUFNLElBQUksaUJBQU8sSUFBWCxDQUFnQjtBQUN6QixXQUFNO0FBRG1CLEtBQWhCLENBQVY7QUFHQSxRQUFJLFFBQUosQ0FBYSxRQUFiO0FBQ0EsUUFBSSxRQUFKLENBQWEsR0FBYixDQUFpQixLQUFqQixDQUF1QixJQUFJLFFBQTNCLEVBQXFDLFFBQXJDOztBQUVBLFFBQUksT0FBTztBQUNWLFdBQU0sSUFESTtBQUVWLFdBQU07QUFGSSxLQUFYOztBQUtBLGVBQVcsSUFBWCxDQUFnQixJQUFoQjs7QUFFQSxRQUFJLFFBQVEsdUJBQWEsTUFBYixDQUFvQjtBQUMvQixhQUFRO0FBRHVCLEtBQXBCLENBQVo7O0FBSUEsV0FBTyxHQUFQLENBQVcsS0FBWDtBQUVBLElBM0JELENBMkJFLElBM0JGLENBMkJPLElBM0JQLENBUkQ7QUFxQ0E7OztRQWxGbUIsYzs7O2tCQUFBLGMiLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCBDQU5OT04gZnJvbSAnY2Fubm9uJztcbmltcG9ydCBtZXJnZSBmcm9tICcuL3RlcnJhaW5QaHlzaWNzLW1lcmdlJztcbmltcG9ydCBUZXJyYWluIGZyb20gJy4vVGVycmFpbic7XG5pbXBvcnQgVGVycmFpblBpZWNlIGZyb20gJy4vVGVycmFpblBpZWNlJztcblxudmFyIFggPSAwO1xudmFyIFkgPSAxO1xudmFyIFogPSAyO1xuXG52YXIgV0lEVEggPSAwO1xudmFyIEhFSUdIVCA9IDE7XG52YXIgREVQVEggPSAyO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXJyYWluUGh5c2ljcyB7XG5cblx0c3RhdGljIGNyZWF0ZSh0ZXJyYWluKSB7XG5cdFx0cmV0dXJuIG5ldyBUZXJyYWluUGh5c2ljcyh0ZXJyYWluKTtcblx0fVxuXG5cdGNvbnN0cnVjdG9yKHRlcnJhaW4pIHtcblxuXHRcdHRoaXMudGVycmFpbiA9IHRlcnJhaW47XG5cblx0XHRsZXQgdm94ZWxzID0gdGVycmFpbi5nZXQoJ3ZveGVscycpO1xuXG5cdFx0Zm9yICh2YXIgY2h1bmtQb3MgaW4gdm94ZWxzLmNodW5rcykge1xuXHRcdFx0dmFyIGNodW5rID0gdm94ZWxzLmNodW5rc1tjaHVua1Bvc107XG5cdFx0XHRpZiAoY2h1bmspIHtcblx0XHRcdFx0dGhpcy5jcmVhdGVDaHVua1BoeXNpY3MoY2h1bmspO1xuXHRcdFx0fVxuXHRcdH1cblxuXHR9XG5cblx0Y3JlYXRlQ2h1bmtQaHlzaWNzKGNodW5rKSB7XG5cdFx0dmFyIGNhY2hlID0ge307XG5cdFx0dmFyIHBpZWNlcyA9IHRoaXMudGVycmFpbi5nZXQoJ3BpZWNlcycpO1xuXG5cdFx0ZnVuY3Rpb24gaXNQcm9jZXNzZWQocG9zKSB7XG5cdFx0XHRyZXR1cm4gY2FjaGVbcG9zLmpvaW4oJ3wnKV0gfHwgZmFsc2U7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbWFya1Byb2Nlc3NlZChwb3MpIHtcblx0XHRcdHJldHVybiBjYWNoZVtwb3Muam9pbignfCcpXSA9IHRydWU7XG5cdFx0fVxuXG5cdFx0dGhpcy5jcmVhdGVDaHVua1BoeXNpY3MuaXRlbXMgPSB0aGlzLmNyZWF0ZUNodW5rUGh5c2ljcy5pdGVtcyB8fCB7fTtcblx0XHR2YXIgY2h1bmtJdGVtcyA9IHRoaXMuY3JlYXRlQ2h1bmtQaHlzaWNzLml0ZW1zW2NodW5rLnBvc2l0aW9uLmpvaW4oJ3wnKV07XG5cdFx0aWYgKGNodW5rSXRlbXMpIHtcblx0XHRcdGNodW5rSXRlbXMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRcdGlmKGl0ZW0ubWVzaCkge1xuXHRcdFx0XHRcdHRoaXMuc2NlbmUucmVtb3ZlKGl0ZW0ubWVzaCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly90aGlzLndvcmxkLnJlbW92ZShpdGVtLmJvZHkpO1xuXHRcdFx0fS5iaW5kKHRoaXMpKTtcblx0XHR9XG5cdFx0Y2h1bmtJdGVtcyA9IHRoaXMuY3JlYXRlQ2h1bmtQaHlzaWNzLml0ZW1zW2NodW5rLnBvc2l0aW9uLmpvaW4oJ3wnKV0gPSBbXVxuXG5cdFx0bWVyZ2UuYWxsKFxuXG5cdFx0XHRmdW5jdGlvbihwb3MpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMudGVycmFpbi5nZXRCbG9ja0F0KHBvcykgJiYgIWlzUHJvY2Vzc2VkKHBvcylcblx0XHRcdH0uYmluZCh0aGlzKSxcblxuXHRcdFx0Y2h1bmssXG5cblx0XHRcdGZ1bmN0aW9uKHJlc3VsdCkge1xuXG5cdFx0XHRcdG1lcmdlLnZveGVsc0luKHJlc3VsdCkuZm9yRWFjaChmdW5jdGlvbihwb3MpIHtcblx0XHRcdFx0XHRtYXJrUHJvY2Vzc2VkKHBvcyk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHR2YXIgcG9zaXRpb24gPSByZXN1bHQucG9zaXRpb24ubWFwKGZ1bmN0aW9uKHYsIGkpIHtyZXR1cm4gdiArIHJlc3VsdC5kaW1zW2ldIC8gMjt9KTtcblxuXHRcdFx0XHR2YXIgYm94U2hhcGUgPSBuZXcgQ0FOTk9OLkJveChuZXcgQ0FOTk9OLlZlYzMocmVzdWx0LmRpbXNbV0lEVEhdIC8gMiwgcmVzdWx0LmRpbXNbSEVJR0hUXSAvIDIsIHJlc3VsdC5kaW1zW0RFUFRIXSAvIDIpKTtcblx0XHRcdFx0dmFyIGJveCA9IG5ldyBDQU5OT04uQm9keSh7XG5cdFx0XHRcdFx0bWFzczogMFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0Ym94LmFkZFNoYXBlKGJveFNoYXBlKTtcblx0XHRcdFx0Ym94LnBvc2l0aW9uLnNldC5hcHBseShib3gucG9zaXRpb24sIHBvc2l0aW9uKTtcblxuXHRcdFx0XHR2YXIgaXRlbSA9IHtcblx0XHRcdFx0XHRtZXNoOiBudWxsLFxuXHRcdFx0XHRcdGJvZHk6IGJveFxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdGNodW5rSXRlbXMucHVzaChpdGVtKTtcblxuXHRcdFx0XHRsZXQgcGllY2UgPSBUZXJyYWluUGllY2UuY3JlYXRlKHtcblx0XHRcdFx0XHRjYW5ub246IGJveFxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRwaWVjZXMuYWRkKHBpZWNlKTtcblxuXHRcdFx0fS5iaW5kKHRoaXMpXG5cdFx0KTtcblx0fVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vZ2FtZS90ZXJyYWluL1RlcnJhaW5QaHlzaWNzLmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 24 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nvar X = 0;\nvar Y = 1;\nvar Z = 2;\n\nvar WIDTH = 0;\nvar HEIGHT = 1;\nvar DEPTH = 2;\n\nfunction findConvexBox(check, startPos, chunk) {\n  if (arguments.length === 2) {\n    chunk = startPos;\n    startPos = chunk.position.map(function (v, i) {\n      return v * chunk.dims[i];\n    });\n  }\n  if (!chunk.voxels) throw new Error('Requires game chunk');\n\n  var endPos = chunk.position.map(function (v, i) {\n    return v * chunk.dims[i] + chunk.dims[i];\n  });\n\n  var box = {\n    dims: startPos.map(function (v, i) {\n      return endPos[i] - v;\n    }),\n    position: [0, 0, 0]\n  };\n  if (!check(startPos)) {\n    return false;\n  }\n  var found = false;\n  for (var x = startPos[X]; !found && x < endPos[X]; x++) {\n    var y = startPos[Y];\n    var z = startPos[Z];\n    if (!check([x, y, z])) {\n      if (box.dims[WIDTH] > x - startPos[X]) box.dims[WIDTH] = x - startPos[X];\n    }\n  }\n\n  var found = false;\n  for (var z = startPos[Z] + 1; !found && z < endPos[Z]; z++) {\n    for (var x = startPos[X]; !found && x < startPos[X] + box.dims[WIDTH]; x++) {\n      var y = startPos[Y];\n      if (!check([x, y, z])) {\n        if (box.dims[DEPTH] > z - startPos[Z]) box.dims[DEPTH] = z - startPos[Z];\n      }\n    }\n  }\n\n  var found = false;\n  for (var y = startPos[Y] + 1; !found && y < endPos[Y]; y++) {\n    for (var x = startPos[X]; !found && x < startPos[X] + box.dims[WIDTH]; x++) {\n      for (var z = startPos[Z]; !found && z < startPos[Z] + box.dims[DEPTH]; z++) {\n        if (!check([x, y, z])) {\n          if (box.dims[HEIGHT] > y - startPos[Y]) box.dims[HEIGHT] = y - startPos[Y];\n        }\n      }\n    }\n  }\n\n  if (box.dims[WIDTH] == 0) box.dims[WIDTH] = 1;\n  if (box.dims[HEIGHT] == 0) box.dims[HEIGHT] = 1;\n  if (box.dims[DEPTH] == 0) box.dims[DEPTH] = 1;\n  box.position[X] = startPos[X]; //+ box.dims[WIDTH]\n  box.position[Y] = startPos[Y]; //+ box.dims[HEIGHT]\n  box.position[Z] = startPos[Z]; //+ box.dims[DEPTH]\n  return box;\n}\n\nfindConvexBox.all = function (check, chunk, done) {\n  var results = [];\n  findConvexBox.voxelsIn(chunk).forEach(function (pos) {\n    var result = findConvexBox(check, pos, chunk);\n    if (result) {\n      done(result);\n      results.push(result);\n    }\n  });\n  return results;\n};\n\nfindConvexBox.voxelsIn = function voxelsIn(chunk) {\n  if (chunk.voxels) {\n    chunk = {\n      dims: chunk.dims.map(function (v) {\n        return v;\n      }),\n      position: chunk.position.map(function (v, i) {\n        return v * chunk.dims[i];\n      })\n    };\n  }\n\n  var points = [];\n  for (var x = chunk.position[X]; x < chunk.position[X] + chunk.dims[WIDTH]; x++) {\n    for (var y = chunk.position[Y]; y < chunk.position[Y] + chunk.dims[HEIGHT]; y++) {\n      for (var z = chunk.position[Z]; z < chunk.position[Z] + chunk.dims[DEPTH]; z++) {\n        points.push([x, y, z]);\n      }\n    }\n  }\n  return points;\n};\n\nmodule.exports = findConvexBox;//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vZ2FtZS90ZXJyYWluL3RlcnJhaW5QaHlzaWNzLW1lcmdlLmpzPzgxYzAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUEsSUFBSSxJQUFJLENBQVI7QUFDQSxJQUFJLElBQUksQ0FBUjtBQUNBLElBQUksSUFBSSxDQUFSOztBQUVBLElBQUksUUFBUSxDQUFaO0FBQ0EsSUFBSSxTQUFTLENBQWI7QUFDQSxJQUFJLFFBQVEsQ0FBWjs7QUFFQSxTQUFTLGFBQVQsQ0FBdUIsS0FBdkIsRUFBOEIsUUFBOUIsRUFBd0MsS0FBeEMsRUFBK0M7QUFDN0MsTUFBSSxVQUFVLE1BQVYsS0FBcUIsQ0FBekIsRUFBNEI7QUFDMUIsWUFBUSxRQUFSO0FBQ0EsZUFBVyxNQUFNLFFBQU4sQ0FBZSxHQUFmLENBQW1CLFVBQVMsQ0FBVCxFQUFZLENBQVosRUFBZTtBQUMzQyxhQUFPLElBQUksTUFBTSxJQUFOLENBQVcsQ0FBWCxDQUFYO0FBQ0QsS0FGVSxDQUFYO0FBR0Q7QUFDRCxNQUFJLENBQUMsTUFBTSxNQUFYLEVBQW1CLE1BQU0sSUFBSSxLQUFKLENBQVUscUJBQVYsQ0FBTjs7QUFFbkIsTUFBSSxTQUFTLE1BQU0sUUFBTixDQUFlLEdBQWYsQ0FBbUIsVUFBUyxDQUFULEVBQVksQ0FBWixFQUFlO0FBQzdDLFdBQU8sSUFBSSxNQUFNLElBQU4sQ0FBVyxDQUFYLENBQUosR0FBb0IsTUFBTSxJQUFOLENBQVcsQ0FBWCxDQUEzQjtBQUNELEdBRlksQ0FBYjs7QUFJQSxNQUFJLE1BQU07QUFDUixVQUFNLFNBQVMsR0FBVCxDQUFhLFVBQVMsQ0FBVCxFQUFZLENBQVosRUFBZTtBQUFDLGFBQU8sT0FBTyxDQUFQLElBQVksQ0FBbkI7QUFBcUIsS0FBbEQsQ0FERTtBQUVSLGNBQVUsQ0FBQyxDQUFELEVBQUcsQ0FBSCxFQUFLLENBQUw7QUFGRixHQUFWO0FBSUEsTUFBSSxDQUFDLE1BQU0sUUFBTixDQUFMLEVBQXNCO0FBQ3BCLFdBQU8sS0FB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QUFJLE1BQU0sUUFBTixDQUFlLENBQWYsQ0FBYixFQUFnQyxJQUFJLE1BQU0sUUFBTixDQUFlLENBQWYsSUFBb0IsTUFBTSxJQUFOLENBQVcsS0FBWCxDQUF4RCxFQUEyRSxHQUEzRSxFQUFnRjtBQUM5RSxlQUFPLElBQVAsQ0FBWSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUFaO0FBQ0Q7QUFDRjtBQUNGO0FBQ0QsU0FBTyxNQUFQO0FBQ0QsQ0FqQkQ7O0FBbUJBLE9BQU8sT0FBUCxHQUFpQixhQUFqQiIsImZpbGUiOiIyNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiXG5cbnZhciBYID0gMFxudmFyIFkgPSAxXG52YXIgWiA9IDJcblxudmFyIFdJRFRIID0gMFxudmFyIEhFSUdIVCA9IDFcbnZhciBERVBUSCA9IDJcblxuZnVuY3Rpb24gZmluZENvbnZleEJveChjaGVjaywgc3RhcnRQb3MsIGNodW5rKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgY2h1bmsgPSBzdGFydFBvc1xuICAgIHN0YXJ0UG9zID0gY2h1bmsucG9zaXRpb24ubWFwKGZ1bmN0aW9uKHYsIGkpIHtcbiAgICAgIHJldHVybiB2ICogY2h1bmsuZGltc1tpXVxuICAgIH0pXG4gIH1cbiAgaWYgKCFjaHVuay52b3hlbHMpIHRocm93IG5ldyBFcnJvcignUmVxdWlyZXMgZ2FtZSBjaHVuaycpXG5cbiAgdmFyIGVuZFBvcyA9IGNodW5rLnBvc2l0aW9uLm1hcChmdW5jdGlvbih2LCBpKSB7XG4gICAgcmV0dXJuIHYgKiBjaHVuay5kaW1zW2ldICsgY2h1bmsuZGltc1tpXVxuICB9KVxuXG4gIHZhciBib3ggPSB7XG4gICAgZGltczogc3RhcnRQb3MubWFwKGZ1bmN0aW9uKHYsIGkpIHtyZXR1cm4gZW5kUG9zW2ldIC0gdn0pLFxuICAgIHBvc2l0aW9uOiBbMCwwLDBdXG4gIH1cbiAgaWYgKCFjaGVjayhzdGFydFBvcykpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB2YXIgZm91bmQgPSBmYWxzZVxuICBmb3IgKHZhciB4ID0gc3RhcnRQb3NbWF07ICFmb3VuZCAmJiB4IDwgZW5kUG9zW1hdOyB4KyspIHtcbiAgICB2YXIgeSA9IHN0YXJ0UG9zW1ldXG4gICAgdmFyIHogPSBzdGFydFBvc1taXVxuICAgIGlmICghY2hlY2soW3gsIHksIHpdKSkge1xuICAgICAgaWYgKGJveC5kaW1zW1dJRFRIXSA+IHggLSBzdGFydFBvc1tYXSkgYm94LmRpbXNbV0lEVEhdID0geCAtIHN0YXJ0UG9zW1hdXG4gICAgfVxuICB9XG5cbiAgdmFyIGZvdW5kID0gZmFsc2VcbiAgZm9yICh2YXIgeiA9IHN0YXJ0UG9zW1pdICsgMTsgIWZvdW5kICYmIHogPCBlbmRQb3NbWl07IHorKykge1xuICAgIGZvciAodmFyIHggPSBzdGFydFBvc1tYXTsgIWZvdW5kICYmIHggPCBzdGFydFBvc1tYXSArIGJveC5kaW1zW1dJRFRIXTsgeCsrKSB7XG4gICAgICB2YXIgeSA9IHN0YXJ0UG9zW1ldXG4gICAgICBpZiAoIWNoZWNrKFt4LCB5LCB6XSkpIHtcbiAgICAgICAgaWYgKGJveC5kaW1zW0RFUFRIXSA+IHogLSBzdGFydFBvc1taXSkgYm94LmRpbXNbREVQVEhdID0geiAtIHN0YXJ0UG9zW1pdXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGZvdW5kID0gZmFsc2VcbiAgZm9yICh2YXIgeSA9IHN0YXJ0UG9zW1ldICsgMTsgIWZvdW5kICYmIHkgPCBlbmRQb3NbWV07IHkrKykge1xuICAgIGZvciAodmFyIHggPSBzdGFydFBvc1tYXTsgIWZvdW5kICYmIHggPCBzdGFydFBvc1tYXSArIGJveC5kaW1zW1dJRFRIXTsgeCsrKSB7XG4gICAgICBmb3IgKHZhciB6ID0gc3RhcnRQb3NbWl07ICFmb3VuZCAmJiB6IDwgc3RhcnRQb3NbWl0gKyBib3guZGltc1tERVBUSF07IHorKykge1xuICAgICAgICBpZiAoIWNoZWNrKFt4LCB5LCB6XSkpIHtcbiAgICAgICAgICBpZiAoYm94LmRpbXNbSEVJR0hUXSA+IHkgLSBzdGFydFBvc1tZXSkgYm94LmRpbXNbSEVJR0hUXSA9IHkgLSBzdGFydFBvc1tZXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGJveC5kaW1zW1dJRFRIXSA9PSAwKSBib3guZGltc1tXSURUSF0gPSAxO1xuICBpZiAoYm94LmRpbXNbSEVJR0hUXSA9PSAwKSBib3guZGltc1tIRUlHSFRdID0gMTtcbiAgaWYgKGJveC5kaW1zW0RFUFRIXSA9PSAwKSBib3guZGltc1tERVBUSF0gPSAxO1xuICBib3gucG9zaXRpb25bWF0gPSBzdGFydFBvc1tYXSAvLysgYm94LmRpbXNbV0lEVEhdXG4gIGJveC5wb3NpdGlvbltZXSA9IHN0YXJ0UG9zW1ldIC8vKyBib3guZGltc1tIRUlHSFRdXG4gIGJveC5wb3NpdGlvbltaXSA9IHN0YXJ0UG9zW1pdIC8vKyBib3guZGltc1tERVBUSF1cbiAgcmV0dXJuIGJveFxufVxuXG5maW5kQ29udmV4Qm94LmFsbCA9IGZ1bmN0aW9uKGNoZWNrLCBjaHVuaywgZG9uZSkge1xuICB2YXIgcmVzdWx0cyA9IFtdXG4gIGZpbmRDb252ZXhCb3gudm94ZWxzSW4oY2h1bmspLmZvckVhY2goZnVuY3Rpb24ocG9zKSB7XG4gICAgdmFyIHJlc3VsdCA9IGZpbmRDb252ZXhCb3goY2hlY2ssIHBvcywgY2h1bmspXG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgZG9uZShyZXN1bHQpXG4gICAgICByZXN1bHRzLnB1c2gocmVzdWx0KVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIHJlc3VsdHNcbn1cblxuXG5maW5kQ29udmV4Qm94LnZveGVsc0luID0gZnVuY3Rpb24gdm94ZWxzSW4oY2h1bmspIHtcbiAgaWYgKGNodW5rLnZveGVscykge1xuICAgIGNodW5rID0ge1xuICAgICAgZGltczogY2h1bmsuZGltcy5tYXAoZnVuY3Rpb24odikge3JldHVybiB2fSksXG4gICAgICBwb3NpdGlvbjogY2h1bmsucG9zaXRpb24ubWFwKGZ1bmN0aW9uKHYsIGkpIHtyZXR1cm4gdiAqIGNodW5rLmRpbXNbaV19KVxuICAgIH1cbiAgfVxuXG4gIHZhciBwb2ludHMgPSBbXVxuICBmb3IgKHZhciB4ID0gY2h1bmsucG9zaXRpb25bWF07IHggPCBjaHVuay5wb3NpdGlvbltYXSArIGNodW5rLmRpbXNbV0lEVEhdOyB4KyspIHtcbiAgICBmb3IgKHZhciB5ID0gY2h1bmsucG9zaXRpb25bWV07IHkgPCBjaHVuay5wb3NpdGlvbltZXSArIGNodW5rLmRpbXNbSEVJR0hUXTsgeSsrKSB7XG4gICAgICBmb3IgKHZhciB6ID0gY2h1bmsucG9zaXRpb25bWl07IHogPCBjaHVuay5wb3NpdGlvbltaXSArIGNodW5rLmRpbXNbREVQVEhdOyB6KyspIHtcbiAgICAgICAgcG9pbnRzLnB1c2goW3gsIHksIHpdKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcG9pbnRzXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmluZENvbnZleEJveDtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL2dhbWUvdGVycmFpbi90ZXJyYWluUGh5c2ljcy1tZXJnZS5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _Entity = __webpack_require__(13);\n\nvar _Entity2 = _interopRequireDefault(_Entity);\n\nvar _PhysicsComponent = __webpack_require__(26);\n\nvar _PhysicsComponent2 = _interopRequireDefault(_PhysicsComponent);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar TerrainPiece = _Entity2.default.createClass({\n\tconstructor: function constructor(options) {\n\t\tvar physics = _PhysicsComponent2.default.create();\n\t\tphysics.cannon = options.cannon;\n\t\tthis.set('physics', physics);\n\t}\n});\n\nTerrainPiece.create = function (options) {\n\treturn new TerrainPiece(options);\n};\n\nexports.default = TerrainPiece;//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vZ2FtZS90ZXJyYWluL1RlcnJhaW5QaWVjZS5qcz9mODhiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBLElBQUksZUFBZSxpQkFBTyxXQUFQLENBQW1CO0FBQ3JDLGNBQWEscUJBQVMsT0FBVCxFQUFrQjtBQUM5QixNQUFJLFVBQVUsMkJBQWlCLE1BQWpCLEVBQWQ7QUFDQSxVQUFRLE1BQVIsR0FBaUIsUUFBUSxNQUF6QjtBQUNBLE9BQUssR0FBTCxDQUFTLFNBQVQsRUFBb0IsT0FBcEI7QUFDQTtBQUxvQyxDQUFuQixDQUFuQjs7QUFRQSxhQUFhLE1BQWIsR0FBc0IsVUFBUyxPQUFULEVBQWtCO0FBQ3ZDLFFBQU8sSUFBSSxZQUFKLENBQWlCLE9BQWpCLENBQVA7QUFDQSxDQUZEOztrQkFJZSxZIiwiZmlsZSI6IjI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgRW50aXR5IGZyb20gJy4uL2Vjcy9FbnRpdHknO1xuaW1wb3J0IFBoeXNpY3NDb21wb25lbnQgZnJvbSAnLi4vcGh5c2ljcy9QaHlzaWNzQ29tcG9uZW50JztcblxubGV0IFRlcnJhaW5QaWVjZSA9IEVudGl0eS5jcmVhdGVDbGFzcyh7XG5cdGNvbnN0cnVjdG9yOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0dmFyIHBoeXNpY3MgPSBQaHlzaWNzQ29tcG9uZW50LmNyZWF0ZSgpO1xuXHRcdHBoeXNpY3MuY2Fubm9uID0gb3B0aW9ucy5jYW5ub247XG5cdFx0dGhpcy5zZXQoJ3BoeXNpY3MnLCBwaHlzaWNzKTtcblx0fVxufSk7XG5cblRlcnJhaW5QaWVjZS5jcmVhdGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cdHJldHVybiBuZXcgVGVycmFpblBpZWNlKG9wdGlvbnMpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgVGVycmFpblBpZWNlO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vZ2FtZS90ZXJyYWluL1RlcnJhaW5QaWVjZS5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _cannon = __webpack_require__(9);\n\nvar _cannon2 = _interopRequireDefault(_cannon);\n\nvar _Position = __webpack_require__(27);\n\nvar _Position2 = _interopRequireDefault(_Position);\n\nvar _Rotation = __webpack_require__(29);\n\nvar _Rotation2 = _interopRequireDefault(_Rotation);\n\nvar _Velocity = __webpack_require__(30);\n\nvar _Velocity2 = _interopRequireDefault(_Velocity);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar PhysicsComponent = function () {\n\t_createClass(PhysicsComponent, null, [{\n\t\tkey: 'create',\n\t\tvalue: function create(opts) {\n\t\t\treturn new PhysicsComponent(opts);\n\t\t}\n\t}]);\n\n\tfunction PhysicsComponent(options) {\n\t\t_classCallCheck(this, PhysicsComponent);\n\n\t\toptions = options || {};\n\t\tvar shape = new _cannon2.default.Box(new _cannon2.default.Vec3(.5, .5, .5));\n\t\tvar body = new _cannon2.default.Body({\n\t\t\tmass: 1\n\t\t});\n\t\tbody.addShape(shape);\n\t\tif (options.position) {\n\t\t\tbody.position.set(options.position.x, options.position.y, options.position.z);\n\t\t}\n\t\tthis.cannon = body;\n\t\t_Position2.default.shim(this, body.position);\n\t\t_Rotation2.default.shim(this, body.quaternion);\n\t\t_Velocity2.default.shim(this, body.velocity);\n\t\tthis.constraints = [];\n\t}\n\n\t_createClass(PhysicsComponent, [{\n\t\tkey: 'dynamicRotation',\n\t\tget: function get() {\n\t\t\treturn !this.cannon.fixedRotation;\n\t\t},\n\t\tset: function set(bool) {\n\t\t\tthis.cannon.fixedRotation = !bool;\n\t\t\tthis.cannon.updateMassProperties();\n\t\t}\n\t}]);\n\n\treturn PhysicsComponent;\n}();\n\nexports.default = PhysicsComponent;//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vZ2FtZS9waHlzaWNzL1BoeXNpY3NDb21wb25lbnQuanM/NTgwMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7OztJQUVNLGdCO2NBQUEsZ0I7O3lCQUVTLEksRUFBTTtBQUNuQixVQUFPLElBQUksZ0JBQUosQ0FBcUIsSUFBckIsQ0FBUDtBQUNBOzs7QUFFRCxVQU5LLGdCQU1MLENBQVksT0FBWixFQUFxQjtBQUFBLHdCQU5oQixnQkFNZ0I7O0FBQ3BCLFlBQVUsV0FBVyxFQUFyQjtBQUNBLE1BQUksUUFBUSxJQUFJLGlCQUFPLEdBQVgsQ0FBZSxJQUFJLGlCQUFPLElBQVgsQ0FBZ0IsRUFBaEIsRUFBb0IsRUFBcEIsRUFBd0IsRUFBeEIsQ0FBZixDQUFaO0FBQ0EsTUFBSSxPQUFPLElBQUksaUJBQU8sSUFBWCxDQUFnQjtBQUMxQixTQUFNO0FBRG9CLEdBQWhCLENBQVg7QUFHQSxPQUFLLFFBQUwsQ0FBYyxLQUFkO0FBQ0EsTUFBSSxRQUFRLFFBQVosRUFBc0I7QUFDckIsUUFBSyxRQUFMLENBQWMsR0FBZCxDQUFrQixRQUFRLFFBQVIsQ0FBaUIsQ0FBbkMsRUFBc0MsUUFBUSxRQUFSLENBQWlCLENBQXZELEVBQTBELFFBQVEsUUFBUixDQUFpQixDQUEzRTtBQUNBO0FBQ0QsT0FBSyxNQUFMLEdBQWMsSUFBZDtBQUNBLHFCQUFTLElBQVQsQ0FBYyxJQUFkLEVBQW9CLEtBQUssUUFBekI7QUFDQSxxQkFBUyxJQUFULENBQWMsSUFBZCxFQUFvQixLQUFLLFVBQXpCO0FBQ0EscUJBQVMsSUFBVCxDQUFjLElBQWQsRUFBb0IsS0FBSyxRQUF6QjtBQUNBLE9BQUssV0FBTCxHQUFtQixFQUFuQjtBQUNBOztjQXJCSSxnQjs7c0JBdUJpQjtBQUNyQixVQUFPLENBQUMsS0FBSyxNQUFMLENBQVksYUFBcEI7QUFDQSxHO29CQUVtQixJLEVBQU07QUFDekIsUUFBSyxNQUFMLENBQVksYUFBWixHQUE0QixDQUFDLElBQTdCO0FBQ0EsUUFBSyxNQUFMLENBQVksb0JBQVo7QUFDQTs7O1FBOUJJLGdCOzs7a0JBa0NTLGdCIiwiZmlsZSI6IjI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgQ0FOTk9OIGZyb20gJ2Nhbm5vbic7XG5pbXBvcnQgUG9zaXRpb24gZnJvbSAnLi9Qb3NpdGlvbic7XG5pbXBvcnQgUm90YXRpb24gZnJvbSAnLi9Sb3RhdGlvbic7XG5pbXBvcnQgVmVsb2NpdHkgZnJvbSAnLi9WZWxvY2l0eSc7XG5cbmNsYXNzIFBoeXNpY3NDb21wb25lbnQge1xuXG5cdHN0YXRpYyBjcmVhdGUob3B0cykge1xuXHRcdHJldHVybiBuZXcgUGh5c2ljc0NvbXBvbmVudChvcHRzKTtcblx0fVxuXG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRsZXQgc2hhcGUgPSBuZXcgQ0FOTk9OLkJveChuZXcgQ0FOTk9OLlZlYzMoLjUsIC41LCAuNSkpO1xuXHRcdGxldCBib2R5ID0gbmV3IENBTk5PTi5Cb2R5KHtcblx0XHRcdG1hc3M6IDFcblx0XHR9KTtcblx0XHRib2R5LmFkZFNoYXBlKHNoYXBlKTtcblx0XHRpZiAob3B0aW9ucy5wb3NpdGlvbikge1xuXHRcdFx0Ym9keS5wb3NpdGlvbi5zZXQob3B0aW9ucy5wb3NpdGlvbi54LCBvcHRpb25zLnBvc2l0aW9uLnksIG9wdGlvbnMucG9zaXRpb24ueik7XG5cdFx0fVxuXHRcdHRoaXMuY2Fubm9uID0gYm9keTtcblx0XHRQb3NpdGlvbi5zaGltKHRoaXMsIGJvZHkucG9zaXRpb24pO1xuXHRcdFJvdGF0aW9uLnNoaW0odGhpcywgYm9keS5xdWF0ZXJuaW9uKTtcblx0XHRWZWxvY2l0eS5zaGltKHRoaXMsIGJvZHkudmVsb2NpdHkpO1xuXHRcdHRoaXMuY29uc3RyYWludHMgPSBbXTtcblx0fVxuXG5cdGdldCBkeW5hbWljUm90YXRpb24oKSB7XG5cdFx0cmV0dXJuICF0aGlzLmNhbm5vbi5maXhlZFJvdGF0aW9uO1xuXHR9XG5cblx0c2V0IGR5bmFtaWNSb3RhdGlvbihib29sKSB7XG5cdFx0dGhpcy5jYW5ub24uZml4ZWRSb3RhdGlvbiA9ICFib29sO1xuXHRcdHRoaXMuY2Fubm9uLnVwZGF0ZU1hc3NQcm9wZXJ0aWVzKCk7XG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBQaHlzaWNzQ29tcG9uZW50O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vZ2FtZS9waHlzaWNzL1BoeXNpY3NDb21wb25lbnQuanNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _Vector = __webpack_require__(28);\n\nvar _Vector2 = _interopRequireDefault(_Vector);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Position = _Vector2.default.createClass({ x: 0, y: 0, z: 0 });\n\nPosition.shim = function (targetObject, hiddenVector) {\n\t_Vector2.default.shim(targetObject, 'position', new Position(), hiddenVector);\n};\n\nexports.default = Position;//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vZ2FtZS9waHlzaWNzL1Bvc2l0aW9uLmpzP2YyZDQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQ0E7Ozs7OztBQUVBLElBQUksV0FBVyxpQkFBTyxXQUFQLENBQW1CLEVBQUMsR0FBRyxDQUFKLEVBQU8sR0FBRyxDQUFWLEVBQWEsR0FBRyxDQUFoQixFQUFuQixDQUFmOztBQUVBLFNBQVMsSUFBVCxHQUFnQixVQUFTLFlBQVQsRUFBdUIsWUFBdkIsRUFBcUM7QUFDcEQsa0JBQU8sSUFBUCxDQUFZLFlBQVosRUFBMEIsVUFBMUIsRUFBc0MsSUFBSSxRQUFKLEVBQXRDLEVBQXNELFlBQXREO0FBQ0EsQ0FGRDs7a0JBSWUsUSIsImZpbGUiOiIyNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IFZlY3RvciBmcm9tICcuL1ZlY3Rvcic7XG5cbmxldCBQb3NpdGlvbiA9IFZlY3Rvci5jcmVhdGVDbGFzcyh7eDogMCwgeTogMCwgejogMH0pO1xuXG5Qb3NpdGlvbi5zaGltID0gZnVuY3Rpb24odGFyZ2V0T2JqZWN0LCBoaWRkZW5WZWN0b3IpIHtcblx0VmVjdG9yLnNoaW0odGFyZ2V0T2JqZWN0LCAncG9zaXRpb24nLCBuZXcgUG9zaXRpb24oKSwgaGlkZGVuVmVjdG9yKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgUG9zaXRpb247XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9nYW1lL3BoeXNpY3MvUG9zaXRpb24uanNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 28 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Vector = function () {\n\t_createClass(Vector, null, [{\n\t\tkey: \"createClass\",\n\t\tvalue: function createClass(vals) {\n\t\t\tfunction Klass() {\n\t\t\t\tthis.points = Object.keys(vals);\n\t\t\t\tthis.set(vals);\n\t\t\t};\n\t\t\tKlass.prototype.__proto__ = Vector.prototype;\n\t\t\treturn Klass;\n\t\t}\n\t}]);\n\n\tfunction Vector(vals) {\n\t\t_classCallCheck(this, Vector);\n\n\t\tthis.points = Object.keys(vals);\n\t\tthis.set(vals);\n\t}\n\n\t_createClass(Vector, [{\n\t\tkey: \"set\",\n\t\tvalue: function set(vals) {\n\t\t\tfor (var prop in vals) {\n\t\t\t\tthis[prop] = vals[prop];\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: \"get\",\n\t\tvalue: function get() {\n\t\t\tvar result = {};\n\t\t\tthis.points.forEach(function (dim) {\n\t\t\t\tresult[dim] = this[dim];\n\t\t\t}.bind(this));\n\t\t\treturn result;\n\t\t}\n\t}]);\n\n\treturn Vector;\n}();\n\nexports.default = Vector;\n\n\nVector.shim = function (targetObject, publicProperty, publicVector, hiddenVector) {\n\n\tpublicVector.points.forEach(function (prop) {\n\n\t\tdelete publicVector[prop];\n\n\t\tObject.defineProperty(publicVector, prop, {\n\t\t\tget: function get() {\n\t\t\t\treturn hiddenVector[prop];\n\t\t\t},\n\t\t\tset: function set(val) {\n\t\t\t\thiddenVector[prop] = val;\n\t\t\t}\n\t\t});\n\t});\n\n\tObject.defineProperty(targetObject, publicProperty, {\n\t\tget: function get() {\n\t\t\treturn publicVector;\n\t\t},\n\t\tset: function set(val) {\n\t\t\tpublicVector.set(val);\n\t\t}\n\t});\n};//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vZ2FtZS9waHlzaWNzL1ZlY3Rvci5qcz9iYWRmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7SUFDcUIsTTtjQUFBLE07OzhCQUVELEksRUFBTTtBQUN4QixZQUFTLEtBQVQsR0FBaUI7QUFDaEIsU0FBSyxNQUFMLEdBQWMsT0FBTyxJQUFQLENBQVksSUFBWixDQUFkO0FBQ0EsU0FBSyxHQUFMLENBQVMsSUFBVDtBQUNBO0FBQ0QsU0FBTSxTQUFOLENBQWdCLFNBQWhCLEdBQTRCLE9BQU8sU0FBbkM7QUFDQSxVQUFPLEtBQVA7QUFDQTs7O0FBRUQsVUFYb0IsTUFXcEIsQ0FBWSxJQUFaLEVBQWtCO0FBQUEsd0JBWEUsTUFXRjs7QUFDakIsT0FBSyxNQUFMLEdBQWMsT0FBTyxJQUFQLENBQVksSUFBWixDQUFkO0FBQ0EsT0FBSyxHQUFMLENBQVMsSUFBVDtBQUNBOztjQWRtQixNOztzQkFnQmhCLEksRUFBTTtBQUNULFFBQUssSUFBSSxJQUFULElBQWlCLElBQWpCLEVBQXVCO0FBQ3RCLFNBQUssSUFBTCxJQUFhLEtBQUssSUFBTCxDQUFiO0FBQ0E7QUFDRDs7O3dCQUVLO0FBQ0wsT0FBSSxTQUFTLEVBQWI7QUFDQSxRQUFLLE1BQUwsQ0FBWSxPQUFaLENBQW9CLFVBQVMsR0FBVCxFQUFjO0FBQ2pDLFdBQU8sR0FBUCxJQUFjLEtBQUssR0FBTCxDQUFkO0FBQ0EsSUFGbUIsQ0FFbEIsSUFGa0IsQ0FFYixJQUZhLENBQXBCO0FBR0EsVUFBTyxNQUFQO0FBQ0E7OztRQTVCbUIsTTs7O2tCQUFBLE07OztBQWdDckIsT0FBTyxJQUFQLEdBQWMsVUFBUyxZQUFULEVBQXVCLGNBQXZCLEVBQXVDLFlBQXZDLEVBQXFELFlBQXJELEVBQW1FOztBQUVoRixjQUFhLE1BQWIsQ0FBb0IsT0FBcEIsQ0FBNEIsVUFBUyxJQUFULEVBQWU7O0FBRTFDLFNBQU8sYUFBYSxJQUFiLENBQVA7O0FBRUEsU0FBTyxjQUFQLENBQXNCLFlBQXRCLEVBQW9DLElBQXBDLEVBQTBDO0FBQ3pDLFFBQUssZUFBVztBQUNmLFdBQU8sYUFBYSxJQUFiLENBQVA7QUFDQSxJQUh3QztBQUl6QyxRQUFLLGFBQVMsR0FBVCxFQUFjO0FBQ2xCLGlCQUFhLElBQWIsSUFBcUIsR0FBckI7QUFDQTtBQU53QyxHQUExQztBQVNBLEVBYkQ7O0FBZUEsUUFBTyxjQUFQLENBQXNCLFlBQXRCLEVBQW9DLGNBQXBDLEVBQW9EO0FBQ25ELE9BQUssZUFBVztBQUNmLFVBQU8sWUFBUDtBQUNBLEdBSGtEO0FBSW5ELE9BQUssYUFBUyxHQUFULEVBQWM7QUFDbEIsZ0JBQWEsR0FBYixDQUFpQixHQUFqQjtBQUNBO0FBTmtELEVBQXBEO0FBU0EsQ0ExQkQiLCJmaWxlIjoiMjguanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZlY3RvciB7XG5cblx0c3RhdGljIGNyZWF0ZUNsYXNzKHZhbHMpIHtcblx0XHRmdW5jdGlvbiBLbGFzcygpIHtcblx0XHRcdHRoaXMucG9pbnRzID0gT2JqZWN0LmtleXModmFscyk7XG5cdFx0XHR0aGlzLnNldCh2YWxzKTtcblx0XHR9O1xuXHRcdEtsYXNzLnByb3RvdHlwZS5fX3Byb3RvX18gPSBWZWN0b3IucHJvdG90eXBlO1xuXHRcdHJldHVybiBLbGFzcztcblx0fVxuXHRcblx0Y29uc3RydWN0b3IodmFscykge1xuXHRcdHRoaXMucG9pbnRzID0gT2JqZWN0LmtleXModmFscyk7XG5cdFx0dGhpcy5zZXQodmFscyk7XG5cdH1cblxuXHRzZXQodmFscykge1xuXHRcdGZvciAobGV0IHByb3AgaW4gdmFscykge1xuXHRcdFx0dGhpc1twcm9wXSA9IHZhbHNbcHJvcF07XG5cdFx0fVxuXHR9XG5cblx0Z2V0KCkge1xuXHRcdHZhciByZXN1bHQgPSB7fTtcblx0XHR0aGlzLnBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uKGRpbSkge1xuXHRcdFx0cmVzdWx0W2RpbV0gPSB0aGlzW2RpbV07XG5cdFx0fS5iaW5kKHRoaXMpKTtcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cbn1cblxuVmVjdG9yLnNoaW0gPSBmdW5jdGlvbih0YXJnZXRPYmplY3QsIHB1YmxpY1Byb3BlcnR5LCBwdWJsaWNWZWN0b3IsIGhpZGRlblZlY3Rvcikge1xuXG5cdHB1YmxpY1ZlY3Rvci5wb2ludHMuZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XG5cblx0XHRkZWxldGUgcHVibGljVmVjdG9yW3Byb3BdO1xuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHB1YmxpY1ZlY3RvciwgcHJvcCwge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIGhpZGRlblZlY3Rvcltwcm9wXTtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKHZhbCkge1xuXHRcdFx0XHRoaWRkZW5WZWN0b3JbcHJvcF0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0fSk7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldE9iamVjdCwgcHVibGljUHJvcGVydHksIHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1YmxpY1ZlY3Rvcjtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24odmFsKSB7XG5cdFx0XHRwdWJsaWNWZWN0b3Iuc2V0KHZhbCk7XG5cdFx0fVxuXHR9KTtcblxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vZ2FtZS9waHlzaWNzL1ZlY3Rvci5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _Vector = __webpack_require__(28);\n\nvar _Vector2 = _interopRequireDefault(_Vector);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Rotation = _Vector2.default.createClass({ w: 1, x: 0, y: 0, z: 0 });\n\nRotation.prototype.normalize = function () {\n\tvar length = Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);\n\tif (length === 0) {\n\t\tthis.w = this.x = this.y = this.z = 0;\n\t} else {\n\t\tlength = 1 / length;\n\t\tthis.w *= length;\n\t\tthis.x *= length;\n\t\tthis.y *= length;\n\t\tthis.z *= length;\n\t}\n};\n\nRotation.prototype.rotate = function (vector4) {\n\tvar a = this;\n\tvar b = vector4;\n\tthis.set({\n\t\tw: a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z, // 1\n\t\tx: a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y, // i\n\t\ty: a.w * b.y - a.x * b.z + a.y * b.w + a.z * b.x, // j\n\t\tz: a.w * b.z + a.x * b.y - a.y * b.x + a.z * b.w // k\n\t});\n\tthis.normalize();\n};\n\nRotation.prototype.setFromEuler = function (euler) {\n\n\tvar bank = euler.x;\n\tvar heading = euler.y;\n\tvar attitude = euler.z;\n\n\tvar c1 = Math.cos(heading / 2);\n\tvar c2 = Math.cos(attitude / 2);\n\tvar c3 = Math.cos(bank / 2);\n\tvar s1 = Math.sin(heading / 2);\n\tvar s2 = Math.sin(attitude / 2);\n\tvar s3 = Math.sin(bank / 2);\n\n\tthis.set({\n\t\tw: c1 * c2 * c3 - s1 * s2 * s3,\n\t\tx: s1 * s2 * c3 + c1 * c2 * s3,\n\t\ty: s1 * c2 * c3 + c1 * s2 * s3,\n\t\tz: c1 * s2 * c3 - s1 * c2 * s3\n\t});\n};\n\nRotation.shim = function (targetObject, hiddenVector) {\n\t_Vector2.default.shim(targetObject, 'rotation', new Rotation(), hiddenVector);\n};\n\nRotation.createFromAxisAngle = function (vector3, radians) {\n\tvar factor = Math.sin(radians / 2);\n\tvar rotation = new Rotation();\n\trotation.set({\n\t\tx: vector3.x * factor,\n\t\ty: vector3.y * factor,\n\t\tz: vector3.z * factor,\n\t\tw: Math.cos(radians / 2)\n\t});\n\trotation.normalize();\n\treturn rotation;\n};\n\nexports.default = Rotation;//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vZ2FtZS9waHlzaWNzL1JvdGF0aW9uLmpzPzY4NWQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQ0E7Ozs7OztBQUVBLElBQUksV0FBVyxpQkFBTyxXQUFQLENBQW1CLEVBQUMsR0FBRyxDQUFKLEVBQU8sR0FBRyxDQUFWLEVBQWEsR0FBRyxDQUFoQixFQUFtQixHQUFHLENBQXRCLEVBQW5CLENBQWY7O0FBRUEsU0FBUyxTQUFULENBQW1CLFNBQW5CLEdBQStCLFlBQVc7QUFDekMsS0FBSSxTQUFTLEtBQUssSUFBTCxDQUFVLEtBQUssQ0FBTCxHQUFTLEtBQUssQ0FBZCxHQUFrQixLQUFLLENBQUwsR0FBUyxLQUFLLENBQWhDLEdBQW9DLEtBQUssQ0FBTCxHQUFTLEtBQUssQ0FBbEQsR0FBc0QsS0FBSyxDQUFMLEdBQVMsS0FBSyxDQUE5RSxDQUFiO0FBQ0EsS0FBSSxXQUFXLENBQWYsRUFBa0I7QUFDakIsT0FBSyxDQUFMLEdBQVMsS0FBSyxDQUFMLEdBQVMsS0FBSyxDQUFMLEdBQVMsS0FBSyxDQUFMLEdBQVMsQ0FBcEM7QUFDQSxFQUZELE1BRU87QUFDTixXQUFTLElBQUUsTUFBWDtBQUNBLE9BQUssQ0FBTCxJQUFVLE1BQVY7QUFDQSxPQUFLLENBQUwsSUFBVSxNQUFWO0FBQ0EsT0FBSyxDQUFMLElBQVUsTUFBVjtBQUNBLE9BQUssQ0FBTCxJQUFVLE1BQVY7QUFDQTtBQUNELENBWEQ7O0FBYUEsU0FBUyxTQUFULENBQW1CLE1BQW5CLEdBQTRCLFVBQVMsT0FBVCxFQUFrQjtBQUM3QyxLQUFJLElBQUksSUFBUjtBQUNBLEtBQUksSUFBSSxPQUFSO0FBQ0EsTUFBSyxHQUFMLENBQVM7QUFDRixLQUFHLEVBQUUsQ0FBRixHQUFNLEVBQUUsQ0FBUixHQUFZLEVBQUUsQ0FBRixHQUFNLEVBQUUsQ0FBcEIsR0FBd0IsRUFBRSxDQUFGLEdBQU0sRUFBRSxDQUFoQyxHQUFvQyxFQUFFLENBQUYsR0FBTSxFQUFFLENBRDdDLEU7QUFFRixLQUFHLEVBQUUsQ0FBRixHQUFNLEVBQUUsQ0FBUixHQUFZLEVBQUUsQ0FBRixHQUFNLEVBQUUsQ0FBcEIsR0FBd0IsRUFBRSxDQUFGLEdBQU0sRUFBRSxDQUFoQyxHQUFvQyxFQUFFLENBQUYsR0FBTSxFQUFFLENBRjdDLEU7QUFHRixLQUFHLEVBQUUsQ0FBRixHQUFNLEVBQUUsQ0FBUixHQUFZLEVBQUUsQ0FBRixHQUFNLEVBQUUsQ0FBcEIsR0FBd0IsRUFBRSxDQUFGLEdBQU0sRUFBRSxDQUFoQyxHQUFvQyxFQUFFLENBQUYsR0FBTSxFQUFFLENBSDdDLEU7QUFJRixLQUFHLEVBQUUsQ0FBRixHQUFNLEVBQUUsQ0FBUixHQUFZLEVBQUUsQ0FBRixHQUFNLEVBQUUsQ0FBcEIsR0FBd0IsRUFBRSxDQUFGLEdBQU0sRUFBRSxDQUFoQyxHQUFvQyxFQUFFLENBQUYsR0FBTSxFQUFFLEM7QUFKN0MsRUFBVDtBQU1BLE1BQUssU0FBTDtBQUNBLENBVkQ7O0FBWUEsU0FBUyxTQUFULENBQW1CLFlBQW5CLEdBQWtDLFVBQVMsS0FBVCxFQUFnQjs7QUFFakQsS0FBSSxPQUFPLE1BQU0sQ0FBakI7QUFDQSxLQUFJLFVBQVUsTUFBTSxDQUFwQjtBQUNBLEtBQUksV0FBVyxNQUFNLENBQXJCOztBQUVBLEtBQUksS0FBSyxLQUFLLEdBQUwsQ0FBUyxVQUFVLENBQW5CLENBQVQ7QUFDQSxLQUFJLEtBQUssS0FBSyxHQUFMLENBQVMsV0FBVyxDQUFwQixDQUFUO0FBQ0EsS0FBSSxLQUFLLEtBQUssR0FBTCxDQUFTLE9BQU8sQ0FBaEIsQ0FBVDtBQUNBLEtBQUksS0FBSyxLQUFLLEdBQUwsQ0FBUyxVQUFVLENBQW5CLENBQVQ7QUFDQSxLQUFJLEtBQUssS0FBSyxHQUFMLENBQVMsV0FBVyxDQUFwQixDQUFUO0FBQ0EsS0FBSSxLQUFLLEtBQUssR0FBTCxDQUFTLE9BQU8sQ0FBaEIsQ0FBVDs7QUFFQSxNQUFLLEdBQUwsQ0FBUztBQUNSLEtBQUcsS0FBSyxFQUFMLEdBQVUsRUFBVixHQUFlLEtBQUssRUFBTCxHQUFVLEVBRHBCO0FBRVIsS0FBRyxLQUFLLEVBQUwsR0FBVSxFQUFWLEdBQWUsS0FBSyxFQUFMLEdBQVUsRUFGcEI7QUFHUixLQUFHLEtBQUssRUFBTCxHQUFVLEVBQVYsR0FBZSxLQUFLLEVBQUwsR0FBVSxFQUhwQjtBQUlSLEtBQUcsS0FBSyxFQUFMLEdBQVUsRUFBVixHQUFlLEtBQUssRUFBTCxHQUFVO0FBSnBCLEVBQVQ7QUFNQSxDQW5CRDs7QUFxQkEsU0FBUyxJQUFULEdBQWdCLFVBQVMsWUFBVCxFQUF1QixZQUF2QixFQUFxQztBQUNwRCxrQkFBTyxJQUFQLENBQVksWUFBWixFQUEwQixVQUExQixFQUFzQyxJQUFJLFFBQUosRUFBdEMsRUFBc0QsWUFBdEQ7QUFDQSxDQUZEOztBQUlBLFNBQVMsbUJBQVQsR0FBK0IsVUFBUyxPQUFULEVBQWtCLE9BQWxCLEVBQTJCO0FBQ3pELEtBQUksU0FBUyxLQUFLLEdBQUwsQ0FBUyxVQUFRLENBQWpCLENBQWI7QUFDQSxLQUFJLFdBQVcsSUFBSSxRQUFKLEVBQWY7QUFDQSxVQUFTLEdBQVQsQ0FBYTtBQUNaLEtBQUcsUUFBUSxDQUFSLEdBQVksTUFESDtBQUVaLEtBQUcsUUFBUSxDQUFSLEdBQVksTUFGSDtBQUdaLEtBQUcsUUFBUSxDQUFSLEdBQVksTUFISDtBQUlaLEtBQUcsS0FBSyxHQUFMLENBQVMsVUFBUSxDQUFqQjtBQUpTLEVBQWI7QUFNQSxVQUFTLFNBQVQ7QUFDQSxRQUFPLFFBQVA7QUFDQSxDQVhEOztrQkFhZSxRIiwiZmlsZSI6IjI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgVmVjdG9yIGZyb20gJy4vVmVjdG9yJztcblxubGV0IFJvdGF0aW9uID0gVmVjdG9yLmNyZWF0ZUNsYXNzKHt3OiAxLCB4OiAwLCB5OiAwLCB6OiAwfSk7XG5cblJvdGF0aW9uLnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbigpIHtcblx0dmFyIGxlbmd0aCA9IE1hdGguc3FydCh0aGlzLncgKiB0aGlzLncgKyB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnopO1xuXHRpZiAobGVuZ3RoID09PSAwKSB7XG5cdFx0dGhpcy53ID0gdGhpcy54ID0gdGhpcy55ID0gdGhpcy56ID0gMDtcblx0fSBlbHNlIHtcblx0XHRsZW5ndGggPSAxL2xlbmd0aDtcblx0XHR0aGlzLncgKj0gbGVuZ3RoO1xuXHRcdHRoaXMueCAqPSBsZW5ndGg7XG5cdFx0dGhpcy55ICo9IGxlbmd0aDtcblx0XHR0aGlzLnogKj0gbGVuZ3RoO1xuXHR9XG59O1xuXG5Sb3RhdGlvbi5wcm90b3R5cGUucm90YXRlID0gZnVuY3Rpb24odmVjdG9yNCkge1xuXHR2YXIgYSA9IHRoaXM7XG5cdHZhciBiID0gdmVjdG9yNDtcblx0dGhpcy5zZXQoe1xuICAgICAgICB3OiBhLncgKiBiLncgLSBhLnggKiBiLnggLSBhLnkgKiBiLnkgLSBhLnogKiBiLnosICAvLyAxXG4gICAgICAgIHg6IGEudyAqIGIueCArIGEueCAqIGIudyArIGEueSAqIGIueiAtIGEueiAqIGIueSwgIC8vIGlcbiAgICAgICAgeTogYS53ICogYi55IC0gYS54ICogYi56ICsgYS55ICogYi53ICsgYS56ICogYi54LCAgLy8galxuICAgICAgICB6OiBhLncgKiBiLnogKyBhLnggKiBiLnkgLSBhLnkgKiBiLnggKyBhLnogKiBiLncgICAvLyBrXG5cdH0pO1xuXHR0aGlzLm5vcm1hbGl6ZSgpO1xufTtcblxuUm90YXRpb24ucHJvdG90eXBlLnNldEZyb21FdWxlciA9IGZ1bmN0aW9uKGV1bGVyKSB7XG5cblx0dmFyIGJhbmsgPSBldWxlci54O1xuXHR2YXIgaGVhZGluZyA9IGV1bGVyLnk7XG5cdHZhciBhdHRpdHVkZSA9IGV1bGVyLno7XG5cblx0dmFyIGMxID0gTWF0aC5jb3MoaGVhZGluZyAvIDIpO1xuXHR2YXIgYzIgPSBNYXRoLmNvcyhhdHRpdHVkZSAvIDIpXG5cdHZhciBjMyA9IE1hdGguY29zKGJhbmsgLyAyKVxuXHR2YXIgczEgPSBNYXRoLnNpbihoZWFkaW5nIC8gMilcblx0dmFyIHMyID0gTWF0aC5zaW4oYXR0aXR1ZGUgLyAyKVxuXHR2YXIgczMgPSBNYXRoLnNpbihiYW5rIC8gMilcblxuXHR0aGlzLnNldCh7XG5cdFx0dzogYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzLFxuXHRcdHg6IHMxICogczIgKiBjMyArIGMxICogYzIgKiBzMyxcblx0XHR5OiBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczMsXG5cdFx0ejogYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzXG5cdH0pO1xufTtcblxuUm90YXRpb24uc2hpbSA9IGZ1bmN0aW9uKHRhcmdldE9iamVjdCwgaGlkZGVuVmVjdG9yKSB7XG5cdFZlY3Rvci5zaGltKHRhcmdldE9iamVjdCwgJ3JvdGF0aW9uJywgbmV3IFJvdGF0aW9uKCksIGhpZGRlblZlY3Rvcik7XG59O1xuXG5Sb3RhdGlvbi5jcmVhdGVGcm9tQXhpc0FuZ2xlID0gZnVuY3Rpb24odmVjdG9yMywgcmFkaWFucykge1xuXHR2YXIgZmFjdG9yID0gTWF0aC5zaW4ocmFkaWFucy8yKTtcblx0dmFyIHJvdGF0aW9uID0gbmV3IFJvdGF0aW9uKCk7XG5cdHJvdGF0aW9uLnNldCh7XG5cdFx0eDogdmVjdG9yMy54ICogZmFjdG9yLFxuXHRcdHk6IHZlY3RvcjMueSAqIGZhY3Rvcixcblx0XHR6OiB2ZWN0b3IzLnogKiBmYWN0b3IsXG5cdFx0dzogTWF0aC5jb3MocmFkaWFucy8yKVxuXHR9KTtcblx0cm90YXRpb24ubm9ybWFsaXplKCk7XG5cdHJldHVybiByb3RhdGlvbjtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFJvdGF0aW9uO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vZ2FtZS9waHlzaWNzL1JvdGF0aW9uLmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _Vector = __webpack_require__(28);\n\nvar _Vector2 = _interopRequireDefault(_Vector);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Velocity = _Vector2.default.createClass({ x: 0, y: 0, z: 0 });\n\nVelocity.shim = function (targetObject, hiddenVector) {\n\t_Vector2.default.shim(targetObject, 'velocity', new Velocity(), hiddenVector);\n};\n\nexports.default = Velocity;//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vZ2FtZS9waHlzaWNzL1ZlbG9jaXR5LmpzPzRlMzgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQ0E7Ozs7OztBQUVBLElBQUksV0FBVyxpQkFBTyxXQUFQLENBQW1CLEVBQUMsR0FBRyxDQUFKLEVBQU8sR0FBRyxDQUFWLEVBQWEsR0FBRyxDQUFoQixFQUFuQixDQUFmOztBQUVBLFNBQVMsSUFBVCxHQUFnQixVQUFTLFlBQVQsRUFBdUIsWUFBdkIsRUFBcUM7QUFDcEQsa0JBQU8sSUFBUCxDQUFZLFlBQVosRUFBMEIsVUFBMUIsRUFBc0MsSUFBSSxRQUFKLEVBQXRDLEVBQXNELFlBQXREO0FBQ0EsQ0FGRDs7a0JBSWUsUSIsImZpbGUiOiIzMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IFZlY3RvciBmcm9tICcuL1ZlY3Rvcic7XG5cbmxldCBWZWxvY2l0eSA9IFZlY3Rvci5jcmVhdGVDbGFzcyh7eDogMCwgeTogMCwgejogMH0pO1xuXG5WZWxvY2l0eS5zaGltID0gZnVuY3Rpb24odGFyZ2V0T2JqZWN0LCBoaWRkZW5WZWN0b3IpIHtcblx0VmVjdG9yLnNoaW0odGFyZ2V0T2JqZWN0LCAndmVsb2NpdHknLCBuZXcgVmVsb2NpdHkoKSwgaGlkZGVuVmVjdG9yKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgVmVsb2NpdHk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9nYW1lL3BoeXNpY3MvVmVsb2NpdHkuanNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(32);\n\nvar _three2 = _interopRequireDefault(_three);\n\nvar _TerrainView = __webpack_require__(34);\n\nvar _TerrainView2 = _interopRequireDefault(_TerrainView);\n\nvar _System = __webpack_require__(4);\n\nvar _System2 = _interopRequireDefault(_System);\n\nvar _MeshComponent = __webpack_require__(41);\n\nvar _MeshComponent2 = _interopRequireDefault(_MeshComponent);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar FPTGameView = _System2.default.createClass({\n\n\tconstructor: function constructor(fptGame) {\n\t\tthis.game = fptGame;\n\n\t\tthis.scene = new _three2.default.Scene();\n\t\tthis.camera = new _three2.default.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n\t\tthis.camera.position.setZ(10);\n\t\tthis.scene.add(this.camera);\n\n\t\tthis.renderer = new _three2.default.WebGLRenderer();\n\t\tthis.renderer.shadowMapType = _three2.default.PCFSoftShadowMap;\n\t\tthis.renderer.shadowMapEnabled = true;\n\t\tthis.renderer.shadowMapSoft = true;\n\t\tthis.renderer.setClearColorHex(0xffffff);\n\t\tthis.renderer.setSize(window.innerWidth, window.innerHeight);\n\t\tthis.element = this.renderer.domElement;\n\n\t\tthis.terrain = _TerrainView2.default.create(fptGame.level.terrain);\n\t\tthis.scene.add(this.terrain.three);\n\n\t\tvar tick = function () {\n\t\t\tthis.tick();\n\t\t\trequestAnimationFrame(tick);\n\t\t}.bind(this);\n\n\t\trequestAnimationFrame(tick);\n\t},\n\n\ttick: function tick() {\n\t\tthis.tickSubsystems();\n\t\tthis.game.entities.forEach(this.tickEntity.bind(this));\n\t\tthis.renderer.render(this.scene, this.camera);\n\t},\n\ttickEntity: function tickEntity(entity) {\n\t\tvar view = entity.get('view');\n\t\tvar physics = entity.get('physics');\n\t\tvar mesh = entity.get('mesh');\n\t\tif (view && physics) {\n\t\t\tif (!mesh) {\n\t\t\t\tmesh = _MeshComponent2.default.create();\n\t\t\t\tthis.scene.add(mesh.three);\n\t\t\t\tentity.set('mesh', mesh);\n\t\t\t}\n\t\t\tvar position = physics.position;\n\t\t\tvar rotation = physics.rotation;\n\t\t\tmesh.three.position.set(position.x, position.y, position.z);\n\t\t\tmesh.three.useQuaternion = true;\n\t\t\tmesh.three.quaternion.set(rotation.x, rotation.y, rotation.z, rotation.w);\n\t\t}\n\t\tvar pieces = entity.get('pieces');\n\t\tif (pieces) {\n\t\t\tpieces.forEach(this.tickEntity.bind(this));\n\t\t}\n\t},\n\texportLevel: function exportLevel() {\n\t\tvar w = window.open(\"\", \"\");\n\t\tw.document.write(JSON.stringify(this.game.level.export()));\n\t\tw.document.close();\n\t}\n});\n\nFPTGameView.create = function (fptGame) {\n\treturn new FPTGameView(fptGame);\n};\n\nexports.default = FPTGameView;//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi92aWV3L0ZQVEdhbWVWaWV3LmpzP2E0N2IiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBLElBQUksY0FBYyxpQkFBTyxXQUFQLENBQW1COztBQUVwQyxjQUFhLHFCQUFTLE9BQVQsRUFBa0I7QUFDOUIsT0FBSyxJQUFMLEdBQVksT0FBWjs7QUFFQSxPQUFLLEtBQUwsR0FBYSxJQUFJLGdCQUFNLEtBQVYsRUFBYjtBQUNBLE9BQUssTUFBTCxHQUFjLElBQUksZ0JBQU0saUJBQVYsQ0FDYixFQURhLEVBQ1QsT0FBTyxVQUFQLEdBQW9CLE9BQU8sV0FEbEIsRUFDK0IsR0FEL0IsRUFDb0MsSUFEcEMsQ0FBZDtBQUdBLE9BQUssTUFBTCxDQUFZLFFBQVosQ0FBcUIsSUFBckIsQ0FBMEIsRUFBMUI7QUFDQSxPQUFLLEtBQUwsQ0FBVyxHQUFYLENBQWUsS0FBSyxNQUFwQjs7QUFFQSxPQUFLLFFBQUwsR0FBZ0IsSUFBSSxnQkFBTSxhQUFWLEVBQWhCO0FBQ0EsT0FBSyxRQUFMLENBQWMsYUFBZCxHQUE4QixnQkFBTSxnQkFBcEM7QUFDRyxPQUFLLFFBQUwsQ0FBYyxnQkFBZCxHQUFpQyxJQUFqQztBQUNBLE9BQUssUUFBTCxDQUFjLGFBQWQsR0FBOEIsSUFBOUI7QUFDSCxPQUFLLFFBQUwsQ0FBYyxnQkFBZCxDQUFnQyxRQUFoQztBQUNBLE9BQUssUUFBTCxDQUFjLE9BQWQsQ0FBdUIsT0FBTyxVQUE5QixFQUEwQyxPQUFPLFdBQWpEO0FBQ0EsT0FBSyxPQUFMLEdBQWUsS0FBSyxRQUFMLENBQWMsVUFBN0I7O0FBRUEsT0FBSyxPQUFMLEdBQWUsc0JBQVksTUFBWixDQUFtQixRQUFRLEtBQVIsQ0FBYyxPQUFqQyxDQUFmO0FBQ0EsT0FBSyxLQUFMLENBQVcsR0FBWCxDQUFlLEtBQUssT0FBTCxDQUFhLEtBQTVCOztBQUVBLE1BQUksT0FBTyxZQUFXO0FBQ3JCLFFBQUssSUFBTDtBQUNBLHlCQUFzQixJQUF0QjtBQUNBLEdBSFUsQ0FHVCxJQUhTLENBR0osSUFISSxDQUFYOztBQUtBLHdCQUFzQixJQUF0QjtBQUVBLEVBOUJtQzs7QUFnQ3BDLEtBaENvQyxrQkFnQzdCO0FBQ04sT0FBSyxjQUFMO0FBQ0EsT0FBSyxJQUFMLENBQVUsUUFBVixDQUFtQixPQUFuQixDQUEyQixLQUFLLFVBQUwsQ0FBZ0IsSUFBaEIsQ0FBcUIsSUFBckIsQ0FBM0I7QUFDQSxPQUFLLFFBQUwsQ0FBYyxNQUFkLENBQXFCLEtBQUssS0FBMUIsRUFBaUMsS0FBSyxNQUF0QztBQUNBLEVBcENtQztBQXNDcEMsV0F0Q29DLHNCQXNDekIsTUF0Q3lCLEVBc0NqQjtBQUNsQixNQUFJLE9BQU8sT0FBTyxHQUFQLENBQVcsTUFBWCxDQUFYO0FBQ0EsTUFBSSxVQUFVLE9BQU8sR0FBUCxDQUFXLFNBQVgsQ0FBZDtBQUNBLE1BQUksT0FBTyxPQUFPLEdBQVAsQ0FBVyxNQUFYLENBQVg7QUFDQSxNQUFJLFFBQVEsT0FBWixFQUFxQjtBQUNwQixPQUFJLENBQUMsSUFBTCxFQUFXO0FBQ1YsV0FBTyx3QkFBYyxNQUFkLEVBQVA7QUFDQSxTQUFLLEtBQUwsQ0FBVyxHQUFYLENBQWUsS0FBSyxLQUFwQjtBQUNBLFdBQU8sR0FBUCxDQUFXLE1BQVgsRUFBbUIsSUFBbkI7QUFDQTtBQUNELE9BQUksV0FBVyxRQUFRLFFBQXZCO0FBQ0EsT0FBSSxXQUFXLFFBQVEsUUFBdkI7QUFDQSxRQUFLLEtBQUwsQ0FBVyxRQUFYLENBQW9CLEdBQXBCLENBQXdCLFNBQVMsQ0FBakMsRUFBb0MsU0FBUyxDQUE3QyxFQUFnRCxTQUFTLENBQXpEO0FBQ0EsUUFBSyxLQUFMLENBQVcsYUFBWCxHQUEyQixJQUEzQjtBQUNBLFFBQUssS0FBTCxDQUFXLFVBQVgsQ0FBc0IsR0FBdEIsQ0FBMEIsU0FBUyxDQUFuQyxFQUFzQyxTQUFTLENBQS9DLEVBQWtELFNBQVMsQ0FBM0QsRUFBOEQsU0FBUyxDQUF2RTtBQUNBO0FBQ0QsTUFBSSxTQUFTLE9BQU8sR0FBUCxDQUFXLFFBQVgsQ0FBYjtBQUNBLE1BQUksTUFBSixFQUFZO0FBQ1gsVUFBTyxPQUFQLENBQWUsS0FBSyxVQUFMLENBQWdCLElBQWhCLENBQXFCLElBQXJCLENBQWY7QUFDQTtBQUNELEVBMURtQztBQTREcEMsWUE1RG9DLHlCQTREdEI7QUFDYixNQUFJLElBQUksT0FBTyxJQUFQLENBQVksRUFBWixFQUFlLEVBQWYsQ0FBUjtBQUNBLElBQUUsUUFBRixDQUFXLEtBQVgsQ0FBaUIsS0FBSyxTQUFMLENBQWUsS0FBSyxJQUFMLENBQVUsS0FBVixDQUFnQixNQUFoQixFQUFmLENBQWpCO0FBQ0EsSUFBRSxRQUFGLENBQVcsS0FBWDtBQUNBO0FBaEVtQyxDQUFuQixDQUFsQjs7QUFvRUEsWUFBWSxNQUFaLEdBQXFCLFVBQVMsT0FBVCxFQUFrQjtBQUN0QyxRQUFPLElBQUksV0FBSixDQUFnQixPQUFoQixDQUFQO0FBQ0EsQ0FGRDs7a0JBSWUsVyIsImZpbGUiOiIzMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCBUZXJyYWluVmlldyBmcm9tICcuL1RlcnJhaW5WaWV3JztcbmltcG9ydCBTeXN0ZW0gZnJvbSAnLi4vLi4vZ2FtZS9lY3MvU3lzdGVtJztcbmltcG9ydCBNZXNoQ29tcG9uZW50IGZyb20gJy4vTWVzaENvbXBvbmVudCc7XG5cbmxldCBGUFRHYW1lVmlldyA9IFN5c3RlbS5jcmVhdGVDbGFzcyh7XG5cblx0Y29uc3RydWN0b3I6IGZ1bmN0aW9uKGZwdEdhbWUpIHtcblx0XHR0aGlzLmdhbWUgPSBmcHRHYW1lO1xuXG5cdFx0dGhpcy5zY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpO1xuXHRcdHRoaXMuY2FtZXJhID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKFxuXHRcdFx0NzUsIHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0LCAwLjEsIDEwMDBcblx0XHQpO1xuXHRcdHRoaXMuY2FtZXJhLnBvc2l0aW9uLnNldFooMTApO1xuXHRcdHRoaXMuc2NlbmUuYWRkKHRoaXMuY2FtZXJhKTtcblxuXHRcdHRoaXMucmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcigpO1xuXHRcdHRoaXMucmVuZGVyZXIuc2hhZG93TWFwVHlwZSA9IFRIUkVFLlBDRlNvZnRTaGFkb3dNYXA7XG5cdCAgICB0aGlzLnJlbmRlcmVyLnNoYWRvd01hcEVuYWJsZWQgPSB0cnVlO1xuXHQgICAgdGhpcy5yZW5kZXJlci5zaGFkb3dNYXBTb2Z0ID0gdHJ1ZTtcblx0XHR0aGlzLnJlbmRlcmVyLnNldENsZWFyQ29sb3JIZXgoIDB4ZmZmZmZmICk7XG5cdFx0dGhpcy5yZW5kZXJlci5zZXRTaXplKCB3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0ICk7XG5cdFx0dGhpcy5lbGVtZW50ID0gdGhpcy5yZW5kZXJlci5kb21FbGVtZW50O1xuXG5cdFx0dGhpcy50ZXJyYWluID0gVGVycmFpblZpZXcuY3JlYXRlKGZwdEdhbWUubGV2ZWwudGVycmFpbik7XG5cdFx0dGhpcy5zY2VuZS5hZGQodGhpcy50ZXJyYWluLnRocmVlKTtcblxuXHRcdGxldCB0aWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnRpY2soKTtcblx0XHRcdHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aWNrKTtcblx0XHR9LmJpbmQodGhpcyk7XG5cblx0XHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGljayk7XG5cblx0fSxcblxuXHR0aWNrKCkge1xuXHRcdHRoaXMudGlja1N1YnN5c3RlbXMoKTtcblx0XHR0aGlzLmdhbWUuZW50aXRpZXMuZm9yRWFjaCh0aGlzLnRpY2tFbnRpdHkuYmluZCh0aGlzKSk7XG5cdFx0dGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuXHR9LFxuXG5cdHRpY2tFbnRpdHkoZW50aXR5KSB7XG5cdFx0dmFyIHZpZXcgPSBlbnRpdHkuZ2V0KCd2aWV3Jyk7XG5cdFx0dmFyIHBoeXNpY3MgPSBlbnRpdHkuZ2V0KCdwaHlzaWNzJyk7XG5cdFx0bGV0IG1lc2ggPSBlbnRpdHkuZ2V0KCdtZXNoJyk7XG5cdFx0aWYgKHZpZXcgJiYgcGh5c2ljcykge1xuXHRcdFx0aWYgKCFtZXNoKSB7XG5cdFx0XHRcdG1lc2ggPSBNZXNoQ29tcG9uZW50LmNyZWF0ZSgpO1xuXHRcdFx0XHR0aGlzLnNjZW5lLmFkZChtZXNoLnRocmVlKTtcblx0XHRcdFx0ZW50aXR5LnNldCgnbWVzaCcsIG1lc2gpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHBvc2l0aW9uID0gcGh5c2ljcy5wb3NpdGlvbjtcblx0XHRcdHZhciByb3RhdGlvbiA9IHBoeXNpY3Mucm90YXRpb247XG5cdFx0XHRtZXNoLnRocmVlLnBvc2l0aW9uLnNldChwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56KTtcblx0XHRcdG1lc2gudGhyZWUudXNlUXVhdGVybmlvbiA9IHRydWU7XG5cdFx0XHRtZXNoLnRocmVlLnF1YXRlcm5pb24uc2V0KHJvdGF0aW9uLngsIHJvdGF0aW9uLnksIHJvdGF0aW9uLnosIHJvdGF0aW9uLncpO1xuXHRcdH1cblx0XHRsZXQgcGllY2VzID0gZW50aXR5LmdldCgncGllY2VzJyk7XG5cdFx0aWYgKHBpZWNlcykge1xuXHRcdFx0cGllY2VzLmZvckVhY2godGhpcy50aWNrRW50aXR5LmJpbmQodGhpcykpO1xuXHRcdH1cblx0fSxcblxuXHRleHBvcnRMZXZlbCgpIHtcblx0XHRsZXQgdyA9IHdpbmRvdy5vcGVuKFwiXCIsXCJcIik7XG5cdFx0dy5kb2N1bWVudC53cml0ZShKU09OLnN0cmluZ2lmeSh0aGlzLmdhbWUubGV2ZWwuZXhwb3J0KCkpKTtcblx0XHR3LmRvY3VtZW50LmNsb3NlKCk7XG5cdH1cblxufSk7XG5cbkZQVEdhbWVWaWV3LmNyZWF0ZSA9IGZ1bmN0aW9uKGZwdEdhbWUpIHtcblx0cmV0dXJuIG5ldyBGUFRHYW1lVmlldyhmcHRHYW1lKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEZQVEdhbWVWaWV3O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi92aWV3L0ZQVEdhbWVWaWV3LmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {\r\nvar window = window || {};\r\nvar self = self || {};\r\n\r\n// High-resulution counter: emulate window.performance.now() for THREE.CLOCK\r\nif( window.performance === undefined ) {\r\n\r\n\twindow.performance = { };\r\n\r\n}\r\n\r\nif( window.performance.now === undefined ) {\r\n\r\n\twindow.performance.now = function () {\r\n\r\n\t\tvar time = process.hrtime();\r\n\t\treturn ( time[0] + time[1] / 1e9 ) * 1000;\r\n\r\n\t};\r\n\r\n}\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author Larry Battle / http://bateru.com/news\r\n */\r\n\r\nvar THREE = THREE || { REVISION: '56' };\r\n\r\nself.console = self.console || {\r\n\r\n\tinfo: function () {},\r\n\tlog: function () {},\r\n\tdebug: function () {},\r\n\twarn: function () {},\r\n\terror: function () {}\r\n\r\n};\r\n\r\nself.Int32Array = self.Int32Array || Array;\r\nself.Float32Array = self.Float32Array || Array;\r\n\r\nString.prototype.trim = String.prototype.trim || function () {\r\n\r\n\treturn this.replace( /^\\s+|\\s+$/g, '' );\r\n\r\n};\r\n\r\n// based on https://github.com/documentcloud/underscore/blob/bf657be243a075b5e72acc8a83e6f12a564d8f55/underscore.js#L767\r\nTHREE.extend = function ( obj, source ) {\r\n\r\n\t// ECMAScript5 compatibility based on: http://www.nczonline.net/blog/2012/12/11/are-your-mixins-ecmascript-5-compatible/\r\n\tif ( Object.keys ) {\r\n\r\n\t\tvar keys = Object.keys( source );\r\n\r\n\t\tfor (var i = 0, il = keys.length; i < il; i++) {\r\n\r\n\t\t\tvar prop = keys[i];\r\n\t\t\tObject.defineProperty( obj, prop, Object.getOwnPropertyDescriptor( source, prop ) );\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tvar safeHasOwnProperty = {}.hasOwnProperty;\r\n\r\n\t\tfor ( var prop in source ) {\r\n\r\n\t\t\tif ( safeHasOwnProperty.call( source, prop ) ) {\r\n\r\n\t\t\t\tobj[prop] = source[prop];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn obj;\r\n\r\n};\r\n\r\n// http://paulirish.com/2011/requestanimationframe-for-smart-animating/\r\n// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\r\n\r\n// requestAnimationFrame polyfill by Erik Möller\r\n// fixes from Paul Irish and Tino Zijdel\r\n\r\n( function () {\r\n\r\n\tvar lastTime = 0;\r\n\tvar vendors = [ 'ms', 'moz', 'webkit', 'o' ];\r\n\r\n\tfor ( var x = 0; x < vendors.length && !window.requestAnimationFrame; ++ x ) {\r\n\r\n\t\twindow.requestAnimationFrame = window[ vendors[ x ] + 'RequestAnimationFrame' ];\r\n\t\twindow.cancelAnimationFrame = window[ vendors[ x ] + 'CancelAnimationFrame' ] || window[ vendors[ x ] + 'CancelRequestAnimationFrame' ];\r\n\r\n\t}\r\n\r\n\tif ( window.requestAnimationFrame === undefined ) {\r\n\r\n\t\twindow.requestAnimationFrame = function ( callback ) {\r\n\r\n\t\t\tvar currTime = Date.now(), timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );\r\n\t\t\tvar id = window.setTimeout( function() { callback( currTime + timeToCall ); }, timeToCall );\r\n\t\t\tlastTime = currTime + timeToCall;\r\n\t\t\treturn id;\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n\twindow.cancelAnimationFrame = window.cancelAnimationFrame || function ( id ) { window.clearTimeout( id ) };\r\n\r\n}() );\r\n\r\n// GL STATE CONSTANTS\r\n\r\nTHREE.CullFaceNone = 0;\r\nTHREE.CullFaceBack = 1;\r\nTHREE.CullFaceFront = 2;\r\nTHREE.CullFaceFrontBack = 3;\r\n\r\nTHREE.FrontFaceDirectionCW = 0;\r\nTHREE.FrontFaceDirectionCCW = 1;\r\n\r\n// SHADOWING TYPES\r\n\r\nTHREE.BasicShadowMap = 0;\r\nTHREE.PCFShadowMap = 1;\r\nTHREE.PCFSoftShadowMap = 2;\r\n\r\n// MATERIAL CONSTANTS\r\n\r\n// side\r\n\r\nTHREE.FrontSide = 0;\r\nTHREE.BackSide = 1;\r\nTHREE.DoubleSide = 2;\r\n\r\n// shading\r\n\r\nTHREE.NoShading = 0;\r\nTHREE.FlatShading = 1;\r\nTHREE.SmoothShading = 2;\r\n\r\n// colors\r\n\r\nTHREE.NoColors = 0;\r\nTHREE.FaceColors = 1;\r\nTHREE.VertexColors = 2;\r\n\r\n// blending modes\r\n\r\nTHREE.NoBlending = 0;\r\nTHREE.NormalBlending = 1;\r\nTHREE.AdditiveBlending = 2;\r\nTHREE.SubtractiveBlending = 3;\r\nTHREE.MultiplyBlending = 4;\r\nTHREE.CustomBlending = 5;\r\n\r\n// custom blending equations\r\n// (numbers start from 100 not to clash with other\r\n//  mappings to OpenGL constants defined in Texture.js)\r\n\r\nTHREE.AddEquation = 100;\r\nTHREE.SubtractEquation = 101;\r\nTHREE.ReverseSubtractEquation = 102;\r\n\r\n// custom blending destination factors\r\n\r\nTHREE.ZeroFactor = 200;\r\nTHREE.OneFactor = 201;\r\nTHREE.SrcColorFactor = 202;\r\nTHREE.OneMinusSrcColorFactor = 203;\r\nTHREE.SrcAlphaFactor = 204;\r\nTHREE.OneMinusSrcAlphaFactor = 205;\r\nTHREE.DstAlphaFactor = 206;\r\nTHREE.OneMinusDstAlphaFactor = 207;\r\n\r\n// custom blending source factors\r\n\r\n//THREE.ZeroFactor = 200;\r\n//THREE.OneFactor = 201;\r\n//THREE.SrcAlphaFactor = 204;\r\n//THREE.OneMinusSrcAlphaFactor = 205;\r\n//THREE.DstAlphaFactor = 206;\r\n//THREE.OneMinusDstAlphaFactor = 207;\r\nTHREE.DstColorFactor = 208;\r\nTHREE.OneMinusDstColorFactor = 209;\r\nTHREE.SrcAlphaSaturateFactor = 210;\r\n\r\n\r\n// TEXTURE CONSTANTS\r\n\r\nTHREE.MultiplyOperation = 0;\r\nTHREE.MixOperation = 1;\r\nTHREE.AddOperation = 2;\r\n\r\n// Mapping modes\r\n\r\nTHREE.UVMapping = function () {};\r\n\r\nTHREE.CubeReflectionMapping = function () {};\r\nTHREE.CubeRefractionMapping = function () {};\r\n\r\nTHREE.SphericalReflectionMapping = function () {};\r\nTHREE.SphericalRefractionMapping = function () {};\r\n\r\n// Wrapping modes\r\n\r\nTHREE.RepeatWrapping = 1000;\r\nTHREE.ClampToEdgeWrapping = 1001;\r\nTHREE.MirroredRepeatWrapping = 1002;\r\n\r\n// Filters\r\n\r\nTHREE.NearestFilter = 1003;\r\nTHREE.NearestMipMapNearestFilter = 1004;\r\nTHREE.NearestMipMapLinearFilter = 1005;\r\nTHREE.LinearFilter = 1006;\r\nTHREE.LinearMipMapNearestFilter = 1007;\r\nTHREE.LinearMipMapLinearFilter = 1008;\r\n\r\n// Data types\r\n\r\nTHREE.UnsignedByteType = 1009;\r\nTHREE.ByteType = 1010;\r\nTHREE.ShortType = 1011;\r\nTHREE.UnsignedShortType = 1012;\r\nTHREE.IntType = 1013;\r\nTHREE.UnsignedIntType = 1014;\r\nTHREE.FloatType = 1015;\r\n\r\n// Pixel types\r\n\r\n//THREE.UnsignedByteType = 1009;\r\nTHREE.UnsignedShort4444Type = 1016;\r\nTHREE.UnsignedShort5551Type = 1017;\r\nTHREE.UnsignedShort565Type = 1018;\r\n\r\n// Pixel formats\r\n\r\nTHREE.AlphaFormat = 1019;\r\nTHREE.RGBFormat = 1020;\r\nTHREE.RGBAFormat = 1021;\r\nTHREE.LuminanceFormat = 1022;\r\nTHREE.LuminanceAlphaFormat = 1023;\r\n\r\n// Compressed texture formats\r\n\r\nTHREE.RGB_S3TC_DXT1_Format = 2001;\r\nTHREE.RGBA_S3TC_DXT1_Format = 2002;\r\nTHREE.RGBA_S3TC_DXT3_Format = 2003;\r\nTHREE.RGBA_S3TC_DXT5_Format = 2004;\r\n\r\n/*\r\n// Potential future PVRTC compressed texture formats\r\nTHREE.RGB_PVRTC_4BPPV1_Format = 2100;\r\nTHREE.RGB_PVRTC_2BPPV1_Format = 2101;\r\nTHREE.RGBA_PVRTC_4BPPV1_Format = 2102;\r\nTHREE.RGBA_PVRTC_2BPPV1_Format = 2103;\r\n*/\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Color = function ( value ) {\r\n\r\n\tif ( value !== undefined ) this.set( value );\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nTHREE.extend( THREE.Color.prototype, {\r\n\r\n\tr: 1, g: 1, b: 1,\r\n\r\n\tset: function ( value ) {\r\n\r\n\t\tswitch ( typeof value ) {\r\n\r\n\t\t\tcase \"number\":\r\n\t\t\t\tthis.setHex( value );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase \"string\":\r\n\t\t\t\tthis.setStyle( value );\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tsetHex: function ( hex ) {\r\n\r\n\t\thex = Math.floor( hex );\r\n\r\n\t\tthis.r = ( hex >> 16 & 255 ) / 255;\r\n\t\tthis.g = ( hex >> 8 & 255 ) / 255;\r\n\t\tthis.b = ( hex & 255 ) / 255;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetRGB: function ( r, g, b ) {\r\n\r\n\t\tthis.r = r;\r\n\t\tthis.g = g;\r\n\t\tthis.b = b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetHSV: function ( h, s, v ) {\r\n\r\n\t\tconsole.log( 'DEPRECATED: Color\\'s .setHSV() will be removed. Use .setHSL( h, s, l ) instead.' );\r\n\t\treturn this.setHSL(h,s*v/((h=(2-s)*v)<1?h:2-h),h/2); // https://gist.github.com/xpansive/1337890\r\n\r\n\t},\r\n\r\n\tsetHSL: function ( h, s, l ) {\r\n\r\n\t\t// h,s,l ranges are in 0.0 - 1.0\r\n\r\n\t\tif ( s === 0 ) {\r\n\r\n\t\t\tthis.r = this.g = this.b = l;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar hue2rgb = function ( p, q, t ) {\r\n\r\n\t\t\t\tif ( t < 0 ) t += 1;\r\n\t\t\t\tif ( t > 1 ) t -= 1;\r\n\t\t\t\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\r\n\t\t\t\tif ( t < 1 / 2 ) return q;\r\n\t\t\t\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\r\n\t\t\t\treturn p;\r\n\r\n\t\t\t};\r\n\r\n\t\t\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\r\n\t\t\tvar q = ( 2 * l ) - p;\r\n\r\n\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\r\n\t\t\tthis.g = hue2rgb( q, p, h );\r\n\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetStyle: function ( style ) {\r\n\r\n\t\t// rgb(255,0,0)\r\n\r\n\t\tif ( /^rgb\\((\\d+),(\\d+),(\\d+)\\)$/i.test( style ) ) {\r\n\r\n\t\t\tvar color = /^rgb\\((\\d+),(\\d+),(\\d+)\\)$/i.exec( style );\r\n\r\n\t\t\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\r\n\t\t\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\r\n\t\t\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t// rgb(100%,0%,0%)\r\n\r\n\t\tif ( /^rgb\\((\\d+)\\%,(\\d+)\\%,(\\d+)\\%\\)$/i.test( style ) ) {\r\n\r\n\t\t\tvar color = /^rgb\\((\\d+)\\%,(\\d+)\\%,(\\d+)\\%\\)$/i.exec( style );\r\n\r\n\t\t\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\r\n\t\t\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\r\n\t\t\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t// #ff0000\r\n\r\n\t\tif ( /^\\#([0-9a-f]{6})$/i.test( style ) ) {\r\n\r\n\t\t\tvar color = /^\\#([0-9a-f]{6})$/i.exec( style );\r\n\r\n\t\t\tthis.setHex( parseInt( color[ 1 ], 16 ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t// #f00\r\n\r\n\t\tif ( /^\\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test( style ) ) {\r\n\r\n\t\t\tvar color = /^\\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec( style );\r\n\r\n\t\t\tthis.setHex( parseInt( color[ 1 ] + color[ 1 ] + color[ 2 ] + color[ 2 ] + color[ 3 ] + color[ 3 ], 16 ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t// red\r\n\r\n\t\tif ( /^(\\w+)$/i.test( style ) ) {\r\n\r\n\t\t\tthis.setHex( THREE.ColorKeywords[ style ] );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\r\n\t},\r\n\r\n\tcopy: function ( color ) {\r\n\r\n\t\tthis.r = color.r;\r\n\t\tthis.g = color.g;\r\n\t\tthis.b = color.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyGammaToLinear: function ( color ) {\r\n\r\n\t\tthis.r = color.r * color.r;\r\n\t\tthis.g = color.g * color.g;\r\n\t\tthis.b = color.b * color.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyLinearToGamma: function ( color ) {\r\n\r\n\t\tthis.r = Math.sqrt( color.r );\r\n\t\tthis.g = Math.sqrt( color.g );\r\n\t\tthis.b = Math.sqrt( color.b );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tconvertGammaToLinear: function () {\r\n\r\n\t\tvar r = this.r, g = this.g, b = this.b;\r\n\r\n\t\tthis.r = r * r;\r\n\t\tthis.g = g * g;\r\n\t\tthis.b = b * b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tconvertLinearToGamma: function () {\r\n\r\n\t\tthis.r = Math.sqrt( this.r );\r\n\t\tthis.g = Math.sqrt( this.g );\r\n\t\tthis.b = Math.sqrt( this.b );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetHex: function () {\r\n\r\n\t\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\r\n\r\n\t},\r\n\r\n\tgetHexString: function () {\r\n\r\n\t\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\r\n\r\n\t},\r\n\r\n\tgetHSL: function () {\r\n\r\n\t\tvar hsl = { h: 0, s: 0, l: 0 };\r\n\r\n\t\treturn function () {\r\n\r\n\t\t\t// h,s,l ranges are in 0.0 - 1.0\r\n\r\n\t\t\tvar r = this.r, g = this.g, b = this.b;\r\n\r\n\t\t\tvar max = Math.max( r, g, b );\r\n\t\t\tvar min = Math.min( r, g, b );\r\n\r\n\t\t\tvar hue, saturation;\r\n\t\t\tvar lightness = ( min + max ) / 2.0;\r\n\r\n\t\t\tif ( min === max ) {\r\n\r\n\t\t\t\thue = 0;\r\n\t\t\t\tsaturation = 0;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar delta = max - min;\r\n\r\n\t\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\r\n\r\n\t\t\t\tswitch ( max ) {\r\n\r\n\t\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\r\n\t\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\r\n\t\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\thue /= 6;\r\n\r\n\t\t\t}\r\n\r\n\t\t\thsl.h = hue;\r\n\t\t\thsl.s = saturation;\r\n\t\t\thsl.l = lightness;\r\n\r\n\t\t\treturn hsl;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tgetStyle: function () {\r\n\r\n\t\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\r\n\r\n\t},\r\n\r\n\toffsetHSL: function ( h, s, l ) {\r\n\r\n\t\tvar hsl = this.getHSL();\r\n\r\n\t\thsl.h += h; hsl.s += s; hsl.l += l;\r\n\r\n\t\tthis.setHSL( hsl.h, hsl.s, hsl.l );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tadd: function ( color ) {\r\n\r\n\t\tthis.r += color.r;\r\n\t\tthis.g += color.g;\r\n\t\tthis.b += color.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddColors: function ( color1, color2 ) {\r\n\r\n\t\tthis.r = color1.r + color2.r;\r\n\t\tthis.g = color1.g + color2.g;\r\n\t\tthis.b = color1.b + color2.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.r += s;\r\n\t\tthis.g += s;\r\n\t\tthis.b += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiply: function ( color ) {\r\n\r\n\t\tthis.r *= color.r;\r\n\t\tthis.g *= color.g;\r\n\t\tthis.b *= color.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( s ) {\r\n\r\n\t\tthis.r *= s;\r\n\t\tthis.g *= s;\r\n\t\tthis.b *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerp: function ( color, alpha ) {\r\n\r\n\t\tthis.r += ( color.r - this.r ) * alpha;\r\n\t\tthis.g += ( color.g - this.g ) * alpha;\r\n\t\tthis.b += ( color.b - this.b ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Color().setRGB( this.r, this.g, this.b );\r\n\r\n\t}\r\n\r\n} );\r\n\r\nTHREE.ColorKeywords = { \"aliceblue\": 0xF0F8FF, \"antiquewhite\": 0xFAEBD7, \"aqua\": 0x00FFFF, \"aquamarine\": 0x7FFFD4, \"azure\": 0xF0FFFF,\r\n\"beige\": 0xF5F5DC, \"bisque\": 0xFFE4C4, \"black\": 0x000000, \"blanchedalmond\": 0xFFEBCD, \"blue\": 0x0000FF, \"blueviolet\": 0x8A2BE2,\r\n\"brown\": 0xA52A2A, \"burlywood\": 0xDEB887, \"cadetblue\": 0x5F9EA0, \"chartreuse\": 0x7FFF00, \"chocolate\": 0xD2691E, \"coral\": 0xFF7F50,\r\n\"cornflowerblue\": 0x6495ED, \"cornsilk\": 0xFFF8DC, \"crimson\": 0xDC143C, \"cyan\": 0x00FFFF, \"darkblue\": 0x00008B, \"darkcyan\": 0x008B8B,\r\n\"darkgoldenrod\": 0xB8860B, \"darkgray\": 0xA9A9A9, \"darkgreen\": 0x006400, \"darkgrey\": 0xA9A9A9, \"darkkhaki\": 0xBDB76B, \"darkmagenta\": 0x8B008B,\r\n\"darkolivegreen\": 0x556B2F, \"darkorange\": 0xFF8C00, \"darkorchid\": 0x9932CC, \"darkred\": 0x8B0000, \"darksalmon\": 0xE9967A, \"darkseagreen\": 0x8FBC8F,\r\n\"darkslateblue\": 0x483D8B, \"darkslategray\": 0x2F4F4F, \"darkslategrey\": 0x2F4F4F, \"darkturquoise\": 0x00CED1, \"darkviolet\": 0x9400D3,\r\n\"deeppink\": 0xFF1493, \"deepskyblue\": 0x00BFFF, \"dimgray\": 0x696969, \"dimgrey\": 0x696969, \"dodgerblue\": 0x1E90FF, \"firebrick\": 0xB22222,\r\n\"floralwhite\": 0xFFFAF0, \"forestgreen\": 0x228B22, \"fuchsia\": 0xFF00FF, \"gainsboro\": 0xDCDCDC, \"ghostwhite\": 0xF8F8FF, \"gold\": 0xFFD700,\r\n\"goldenrod\": 0xDAA520, \"gray\": 0x808080, \"green\": 0x008000, \"greenyellow\": 0xADFF2F, \"grey\": 0x808080, \"honeydew\": 0xF0FFF0, \"hotpink\": 0xFF69B4,\r\n\"indianred\": 0xCD5C5C, \"indigo\": 0x4B0082, \"ivory\": 0xFFFFF0, \"khaki\": 0xF0E68C, \"lavender\": 0xE6E6FA, \"lavenderblush\": 0xFFF0F5, \"lawngreen\": 0x7CFC00,\r\n\"lemonchiffon\": 0xFFFACD, \"lightblue\": 0xADD8E6, \"lightcoral\": 0xF08080, \"lightcyan\": 0xE0FFFF, \"lightgoldenrodyellow\": 0xFAFAD2, \"lightgray\": 0xD3D3D3,\r\n\"lightgreen\": 0x90EE90, \"lightgrey\": 0xD3D3D3, \"lightpink\": 0xFFB6C1, \"lightsalmon\": 0xFFA07A, \"lightseagreen\": 0x20B2AA, \"lightskyblue\": 0x87CEFA,\r\n\"lightslategray\": 0x778899, \"lightslategrey\": 0x778899, \"lightsteelblue\": 0xB0C4DE, \"lightyellow\": 0xFFFFE0, \"lime\": 0x00FF00, \"limegreen\": 0x32CD32,\r\n\"linen\": 0xFAF0E6, \"magenta\": 0xFF00FF, \"maroon\": 0x800000, \"mediumaquamarine\": 0x66CDAA, \"mediumblue\": 0x0000CD, \"mediumorchid\": 0xBA55D3,\r\n\"mediumpurple\": 0x9370DB, \"mediumseagreen\": 0x3CB371, \"mediumslateblue\": 0x7B68EE, \"mediumspringgreen\": 0x00FA9A, \"mediumturquoise\": 0x48D1CC,\r\n\"mediumvioletred\": 0xC71585, \"midnightblue\": 0x191970, \"mintcream\": 0xF5FFFA, \"mistyrose\": 0xFFE4E1, \"moccasin\": 0xFFE4B5, \"navajowhite\": 0xFFDEAD,\r\n\"navy\": 0x000080, \"oldlace\": 0xFDF5E6, \"olive\": 0x808000, \"olivedrab\": 0x6B8E23, \"orange\": 0xFFA500, \"orangered\": 0xFF4500, \"orchid\": 0xDA70D6,\r\n\"palegoldenrod\": 0xEEE8AA, \"palegreen\": 0x98FB98, \"paleturquoise\": 0xAFEEEE, \"palevioletred\": 0xDB7093, \"papayawhip\": 0xFFEFD5, \"peachpuff\": 0xFFDAB9,\r\n\"peru\": 0xCD853F, \"pink\": 0xFFC0CB, \"plum\": 0xDDA0DD, \"powderblue\": 0xB0E0E6, \"purple\": 0x800080, \"red\": 0xFF0000, \"rosybrown\": 0xBC8F8F,\r\n\"royalblue\": 0x4169E1, \"saddlebrown\": 0x8B4513, \"salmon\": 0xFA8072, \"sandybrown\": 0xF4A460, \"seagreen\": 0x2E8B57, \"seashell\": 0xFFF5EE,\r\n\"sienna\": 0xA0522D, \"silver\": 0xC0C0C0, \"skyblue\": 0x87CEEB, \"slateblue\": 0x6A5ACD, \"slategray\": 0x708090, \"slategrey\": 0x708090, \"snow\": 0xFFFAFA,\r\n\"springgreen\": 0x00FF7F, \"steelblue\": 0x4682B4, \"tan\": 0xD2B48C, \"teal\": 0x008080, \"thistle\": 0xD8BFD8, \"tomato\": 0xFF6347, \"turquoise\": 0x40E0D0,\r\n\"violet\": 0xEE82EE, \"wheat\": 0xF5DEB3, \"white\": 0xFFFFFF, \"whitesmoke\": 0xF5F5F5, \"yellow\": 0xFFFF00, \"yellowgreen\": 0x9ACD32 };\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Quaternion = function( x, y, z, w ) {\r\n\r\n\tthis.x = x || 0;\r\n\tthis.y = y || 0;\r\n\tthis.z = z || 0;\r\n\tthis.w = ( w !== undefined ) ? w : 1;\r\n\r\n};\r\n\r\nTHREE.extend( THREE.Quaternion.prototype, {\r\n\r\n\tset: function ( x, y, z, w ) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.z = z;\r\n\t\tthis.w = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( q ) {\r\n\r\n\t\tthis.x = q.x;\r\n\t\tthis.y = q.y;\r\n\t\tthis.z = q.z;\r\n\t\tthis.w = q.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromEuler: function ( v, order ) {\r\n\r\n\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\r\n\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\r\n\t\t//\tcontent/SpinCalc.m\r\n\r\n\t\tvar c1 = Math.cos( v.x / 2 );\r\n\t\tvar c2 = Math.cos( v.y / 2 );\r\n\t\tvar c3 = Math.cos( v.z / 2 );\r\n\t\tvar s1 = Math.sin( v.x / 2 );\r\n\t\tvar s2 = Math.sin( v.y / 2 );\r\n\t\tvar s3 = Math.sin( v.z / 2 );\r\n\r\n\t\tif ( order === undefined || order === 'XYZ' ) {\r\n\r\n\t\t\tthis.x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\tthis.y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\tthis.z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\tthis.w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n\t\t} else if ( order === 'YXZ' ) {\r\n\r\n\t\t\tthis.x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\tthis.y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\tthis.z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\tthis.w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n\t\t} else if ( order === 'ZXY' ) {\r\n\r\n\t\t\tthis.x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\tthis.y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\tthis.z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\tthis.w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n\t\t} else if ( order === 'ZYX' ) {\r\n\r\n\t\t\tthis.x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\tthis.y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\tthis.z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\tthis.w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n\t\t} else if ( order === 'YZX' ) {\r\n\r\n\t\t\tthis.x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\tthis.y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\tthis.z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\tthis.w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n\t\t} else if ( order === 'XZY' ) {\r\n\r\n\t\t\tthis.x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\tthis.y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\tthis.z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\tthis.w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromAxisAngle: function ( axis, angle ) {\r\n\r\n\t\t// from http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\r\n\t\t// axis have to be normalized\r\n\r\n\t\tvar halfAngle = angle / 2,\r\n\t\t\ts = Math.sin( halfAngle );\r\n\r\n\t\tthis.x = axis.x * s;\r\n\t\tthis.y = axis.y * s;\r\n\t\tthis.z = axis.z * s;\r\n\t\tthis.w = Math.cos( halfAngle );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromRotationMatrix: function ( m ) {\r\n\r\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\tvar te = m.elements,\r\n\r\n\t\t\tm11 = te[0], m12 = te[4], m13 = te[8],\r\n\t\t\tm21 = te[1], m22 = te[5], m23 = te[9],\r\n\t\t\tm31 = te[2], m32 = te[6], m33 = te[10],\r\n\r\n\t\t\ttrace = m11 + m22 + m33,\r\n\t\t\ts;\r\n\r\n\t\tif ( trace > 0 ) {\r\n\r\n\t\t\ts = 0.5 / Math.sqrt( trace + 1.0 );\r\n\r\n\t\t\tthis.w = 0.25 / s;\r\n\t\t\tthis.x = ( m32 - m23 ) * s;\r\n\t\t\tthis.y = ( m13 - m31 ) * s;\r\n\t\t\tthis.z = ( m21 - m12 ) * s;\r\n\r\n\t\t} else if ( m11 > m22 && m11 > m33 ) {\r\n\r\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\r\n\r\n\t\t\tthis.w = (m32 - m23 ) / s;\r\n\t\t\tthis.x = 0.25 * s;\r\n\t\t\tthis.y = (m12 + m21 ) / s;\r\n\t\t\tthis.z = (m13 + m31 ) / s;\r\n\r\n\t\t} else if ( m22 > m33 ) {\r\n\r\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\r\n\r\n\t\t\tthis.w = (m13 - m31 ) / s;\r\n\t\t\tthis.x = (m12 + m21 ) / s;\r\n\t\t\tthis.y = 0.25 * s;\r\n\t\t\tthis.z = (m23 + m32 ) / s;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\r\n\r\n\t\t\tthis.w = ( m21 - m12 ) / s;\r\n\t\t\tthis.x = ( m13 + m31 ) / s;\r\n\t\t\tthis.y = ( m23 + m32 ) / s;\r\n\t\t\tthis.z = 0.25 * s;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tinverse: function () {\r\n\r\n\t\tthis.conjugate().normalize();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tconjugate: function () {\r\n\r\n\t\tthis.x *= -1;\r\n\t\tthis.y *= -1;\r\n\t\tthis.z *= -1;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\tvar l = this.length();\r\n\r\n\t\tif ( l === 0 ) {\r\n\r\n\t\t\tthis.x = 0;\r\n\t\t\tthis.y = 0;\r\n\t\t\tthis.z = 0;\r\n\t\t\tthis.w = 1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tl = 1 / l;\r\n\r\n\t\t\tthis.x = this.x * l;\r\n\t\t\tthis.y = this.y * l;\r\n\t\t\tthis.z = this.z * l;\r\n\t\t\tthis.w = this.w * l;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiply: function ( q, p ) {\r\n\r\n\t\tif ( p !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'DEPRECATED: Quaternion\\'s .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\r\n\t\t\treturn this.multiplyQuaternions( q, p );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.multiplyQuaternions( this, q );\r\n\r\n\t},\r\n\r\n\tmultiplyQuaternions: function ( a, b ) {\r\n\r\n\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\r\n\r\n\t\tvar qax = a.x, qay = a.y, qaz = a.z, qaw = a.w;\r\n\t\tvar qbx = b.x, qby = b.y, qbz = b.z, qbw = b.w;\r\n\r\n\t\tthis.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\r\n\t\tthis.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\r\n\t\tthis.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\r\n\t\tthis.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyVector3: function ( vector ) {\r\n\r\n\t\tconsole.warn( 'DEPRECATED: Quaternion\\'s .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\r\n\t\treturn vector.applyQuaternion( this );\r\n\r\n\t},\r\n\r\n\tslerp: function ( qb, t ) {\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z, w = this.w;\r\n\r\n\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\r\n\r\n\t\tvar cosHalfTheta = w * qb.w + x * qb.x + y * qb.y + z * qb.z;\r\n\r\n\t\tif ( cosHalfTheta < 0 ) {\r\n\r\n\t\t\tthis.w = -qb.w;\r\n\t\t\tthis.x = -qb.x;\r\n\t\t\tthis.y = -qb.y;\r\n\t\t\tthis.z = -qb.z;\r\n\r\n\t\t\tcosHalfTheta = -cosHalfTheta;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.copy( qb );\r\n\r\n\t\t}\r\n\r\n\t\tif ( cosHalfTheta >= 1.0 ) {\r\n\r\n\t\t\tthis.w = w;\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\t\tthis.z = z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tvar halfTheta = Math.acos( cosHalfTheta );\r\n\t\tvar sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\r\n\r\n\t\tif ( Math.abs( sinHalfTheta ) < 0.001 ) {\r\n\r\n\t\t\tthis.w = 0.5 * ( w + this.w );\r\n\t\t\tthis.x = 0.5 * ( x + this.x );\r\n\t\t\tthis.y = 0.5 * ( y + this.y );\r\n\t\t\tthis.z = 0.5 * ( z + this.z );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\r\n\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\r\n\r\n\t\tthis.w = ( w * ratioA + this.w * ratioB );\r\n\t\tthis.x = ( x * ratioA + this.x * ratioB );\r\n\t\tthis.y = ( y * ratioA + this.y * ratioB );\r\n\t\tthis.z = ( z * ratioA + this.z * ratioB );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( v ) {\r\n\r\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Quaternion( this.x, this.y, this.z, this.w );\r\n\r\n\t}\r\n\r\n} );\r\n\r\nTHREE.Quaternion.slerp = function ( qa, qb, qm, t ) {\r\n\r\n\treturn qm.copy( qa ).slerp( qb, t );\r\n\r\n}\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author egraether / http://egraether.com/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n */\r\n\r\nTHREE.Vector2 = function ( x, y ) {\r\n\r\n\tthis.x = x || 0;\r\n\tthis.y = y || 0;\r\n\r\n};\r\n\r\nTHREE.extend( THREE.Vector2.prototype, {\r\n\r\n\tset: function ( x, y ) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetX: function ( x ) {\r\n\r\n\t\tthis.x = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetY: function ( y ) {\r\n\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\r\n\tsetComponent: function ( index, value ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: this.x = value; break;\r\n\t\t\tcase 1: this.y = value; break;\r\n\t\t\tdefault: throw new Error( \"index is out of range: \" + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetComponent: function ( index ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: return this.x;\r\n\t\t\tcase 1: return this.y;\r\n\t\t\tdefault: throw new Error( \"index is out of range: \" + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcopy: function ( v ) {\r\n\r\n\t\tthis.x = v.x;\r\n\t\tthis.y = v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tadd: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'DEPRECATED: Vector2\\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\treturn this.addVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x += v.x;\r\n\t\tthis.y += v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x + b.x;\r\n\t\tthis.y = a.y + b.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.x += s;\r\n\t\tthis.y += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsub: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'DEPRECATED: Vector2\\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\treturn this.subVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x -= v.x;\r\n\t\tthis.y -= v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x - b.x;\r\n\t\tthis.y = a.y - b.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( s ) {\r\n\r\n\t\tthis.x *= s;\r\n\t\tthis.y *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivideScalar: function ( s ) {\r\n\r\n\t\tif ( s !== 0 ) {\r\n\r\n\t\t\tthis.x /= s;\r\n\t\t\tthis.y /= s;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.set( 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmin: function ( v ) {\r\n\r\n\t\tif ( this.x > v.x ) {\r\n\r\n\t\t\tthis.x = v.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y > v.y ) {\r\n\r\n\t\t\tthis.y = v.y;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmax: function ( v ) {\r\n\r\n\t\tif ( this.x < v.x ) {\r\n\r\n\t\t\tthis.x = v.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y < v.y ) {\r\n\r\n\t\t\tthis.y = v.y;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclamp: function ( min, max ) {\r\n\r\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\r\n\t\tif ( this.x < min.x ) {\r\n\r\n\t\t\tthis.x = min.x;\r\n\r\n\t\t} else if ( this.x > max.x ) {\r\n\r\n\t\t\tthis.x = max.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y < min.y ) {\r\n\r\n\t\t\tthis.y = min.y;\r\n\r\n\t\t} else if ( this.y > max.y ) {\r\n\r\n\t\t\tthis.y = max.y;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnegate: function() {\r\n\r\n\t\treturn this.multiplyScalar( - 1 );\r\n\r\n\t},\r\n\r\n\tdot: function ( v ) {\r\n\r\n\t\treturn this.x * v.x + this.y * v.y;\r\n\r\n\t},\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this.x * this.x + this.y * this.y;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\treturn this.divideScalar( this.length() );\r\n\r\n\t},\r\n\r\n\tdistanceTo: function ( v ) {\r\n\r\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\r\n\r\n\t},\r\n\r\n\tdistanceToSquared: function ( v ) {\r\n\r\n\t\tvar dx = this.x - v.x, dy = this.y - v.y;\r\n\t\treturn dx * dx + dy * dy;\r\n\r\n\t},\r\n\r\n\tsetLength: function ( l ) {\r\n\r\n\t\tvar oldLength = this.length();\r\n\r\n\t\tif ( oldLength !== 0 && l !== oldLength ) {\r\n\r\n\t\t\tthis.multiplyScalar( l / oldLength );\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerp: function ( v, alpha ) {\r\n\r\n\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function( v ) {\r\n\r\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\r\n\r\n\t},\r\n\r\n\ttoArray: function () {\r\n\r\n\t\treturn [ this.x, this.y ];\r\n\t\t\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Vector2( this.x, this.y );\r\n\r\n\t}\r\n\r\n} );\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author *kile / http://kile.stravaganza.org/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author egraether / http://egraether.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.Vector3 = function ( x, y, z ) {\r\n\r\n\tthis.x = x || 0;\r\n\tthis.y = y || 0;\r\n\tthis.z = z || 0;\r\n\r\n};\r\n\r\nTHREE.extend( THREE.Vector3.prototype, {\r\n\r\n\tset: function ( x, y, z ) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.z = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetX: function ( x ) {\r\n\r\n\t\tthis.x = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetY: function ( y ) {\r\n\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetZ: function ( z ) {\r\n\r\n\t\tthis.z = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetComponent: function ( index, value ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: this.x = value; break;\r\n\t\t\tcase 1: this.y = value; break;\r\n\t\t\tcase 2: this.z = value; break;\r\n\t\t\tdefault: throw new Error( \"index is out of range: \" + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetComponent: function ( index ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: return this.x;\r\n\t\t\tcase 1: return this.y;\r\n\t\t\tcase 2: return this.z;\r\n\t\t\tdefault: throw new Error( \"index is out of range: \" + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcopy: function ( v ) {\r\n\r\n\t\tthis.x = v.x;\r\n\t\tthis.y = v.y;\r\n\t\tthis.z = v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tadd: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'DEPRECATED: Vector3\\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\treturn this.addVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x += v.x;\r\n\t\tthis.y += v.y;\r\n\t\tthis.z += v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.x += s;\r\n\t\tthis.y += s;\r\n\t\tthis.z += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x + b.x;\r\n\t\tthis.y = a.y + b.y;\r\n\t\tthis.z = a.z + b.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsub: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'DEPRECATED: Vector3\\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\treturn this.subVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x -= v.x;\r\n\t\tthis.y -= v.y;\r\n\t\tthis.z -= v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x - b.x;\r\n\t\tthis.y = a.y - b.y;\r\n\t\tthis.z = a.z - b.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiply: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'DEPRECATED: Vector3\\'s .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\r\n\t\t\treturn this.multiplyVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x *= v.x;\r\n\t\tthis.y *= v.y;\r\n\t\tthis.z *= v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( s ) {\r\n\r\n\t\tthis.x *= s;\r\n\t\tthis.y *= s;\r\n\t\tthis.z *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x * b.x;\r\n\t\tthis.y = a.y * b.y;\r\n\t\tthis.z = a.z * b.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyMatrix3: function ( m ) {\r\n\r\n\t\tvar x = this.x;\r\n\t\tvar y = this.y;\r\n\t\tvar z = this.z;\r\n\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[0] * x + e[3] * y + e[6] * z;\r\n\t\tthis.y = e[1] * x + e[4] * y + e[7] * z;\r\n\t\tthis.z = e[2] * x + e[5] * y + e[8] * z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function ( m ) {\r\n\r\n\t\t// input: THREE.Matrix4 affine matrix\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[0] * x + e[4] * y + e[8]  * z + e[12];\r\n\t\tthis.y = e[1] * x + e[5] * y + e[9]  * z + e[13];\r\n\t\tthis.z = e[2] * x + e[6] * y + e[10] * z + e[14];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyProjection: function ( m ) {\r\n\r\n\t\t// input: THREE.Matrix4 projection matrix\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\r\n\t\tvar e = m.elements;\r\n\t\tvar d = 1 / ( e[3] * x + e[7] * y + e[11] * z + e[15] ); // perspective divide\r\n\r\n\t\tthis.x = ( e[0] * x + e[4] * y + e[8]  * z + e[12] ) * d;\r\n\t\tthis.y = ( e[1] * x + e[5] * y + e[9]  * z + e[13] ) * d;\r\n\t\tthis.z = ( e[2] * x + e[6] * y + e[10] * z + e[14] ) * d;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyQuaternion: function ( q ) {\r\n\r\n\t\tvar x = this.x;\r\n\t\tvar y = this.y;\r\n\t\tvar z = this.z;\r\n\r\n\t\tvar qx = q.x;\r\n\t\tvar qy = q.y;\r\n\t\tvar qz = q.z;\r\n\t\tvar qw = q.w;\r\n\r\n\t\t// calculate quat * vector\r\n\r\n\t\tvar ix =  qw * x + qy * z - qz * y;\r\n\t\tvar iy =  qw * y + qz * x - qx * z;\r\n\t\tvar iz =  qw * z + qx * y - qy * x;\r\n\t\tvar iw = -qx * x - qy * y - qz * z;\r\n\r\n\t\t// calculate result * inverse quat\r\n\r\n\t\tthis.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\r\n\t\tthis.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\r\n\t\tthis.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyEuler: function () {\r\n\r\n\t\tvar q1 = new THREE.Quaternion();\r\n\r\n\t\treturn function ( v, eulerOrder ) {\r\n\r\n\t\t\tvar quaternion = q1.setFromEuler( v, eulerOrder );\r\n\r\n\t\t\tthis.applyQuaternion( quaternion );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tapplyAxisAngle: function () {\r\n\r\n\t\tvar q1 = new THREE.Quaternion();\r\n\r\n\t\treturn function ( axis, angle ) {\r\n\r\n\t\t\tvar quaternion = q1.setFromAxisAngle( axis, angle );\r\n\r\n\t\t\tthis.applyQuaternion( quaternion );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttransformDirection: function ( m ) {\r\n\r\n\t\t// input: THREE.Matrix4 affine matrix\r\n\t\t// vector interpreted as a direction\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[0] * x + e[4] * y + e[8]  * z;\r\n\t\tthis.y = e[1] * x + e[5] * y + e[9]  * z;\r\n\t\tthis.z = e[2] * x + e[6] * y + e[10] * z;\r\n\r\n\t\tthis.normalize();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivide: function ( v ) {\r\n\r\n\t\tthis.x /= v.x;\r\n\t\tthis.y /= v.y;\r\n\t\tthis.z /= v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivideScalar: function ( s ) {\r\n\r\n\t\tif ( s !== 0 ) {\r\n\r\n\t\t\tthis.x /= s;\r\n\t\t\tthis.y /= s;\r\n\t\t\tthis.z /= s;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.x = 0;\r\n\t\t\tthis.y = 0;\r\n\t\t\tthis.z = 0;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmin: function ( v ) {\r\n\r\n\t\tif ( this.x > v.x ) {\r\n\r\n\t\t\tthis.x = v.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y > v.y ) {\r\n\r\n\t\t\tthis.y = v.y;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.z > v.z ) {\r\n\r\n\t\t\tthis.z = v.z;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmax: function ( v ) {\r\n\r\n\t\tif ( this.x < v.x ) {\r\n\r\n\t\t\tthis.x = v.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y < v.y ) {\r\n\r\n\t\t\tthis.y = v.y;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.z < v.z ) {\r\n\r\n\t\t\tthis.z = v.z;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclamp: function ( min, max ) {\r\n\r\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\r\n\t\tif ( this.x < min.x ) {\r\n\r\n\t\t\tthis.x = min.x;\r\n\r\n\t\t} else if ( this.x > max.x ) {\r\n\r\n\t\t\tthis.x = max.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y < min.y ) {\r\n\r\n\t\t\tthis.y = min.y;\r\n\r\n\t\t} else if ( this.y > max.y ) {\r\n\r\n\t\t\tthis.y = max.y;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.z < min.z ) {\r\n\r\n\t\t\tthis.z = min.z;\r\n\r\n\t\t} else if ( this.z > max.z ) {\r\n\r\n\t\t\tthis.z = max.z;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnegate: function () {\r\n\r\n\t\treturn this.multiplyScalar( - 1 );\r\n\r\n\t},\r\n\r\n\tdot: function ( v ) {\r\n\r\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\r\n\r\n\t},\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\r\n\r\n\t},\r\n\r\n\tlengthManhattan: function () {\r\n\r\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\treturn this.divideScalar( this.length() );\r\n\r\n\t},\r\n\r\n\tsetLength: function ( l ) {\r\n\r\n\t\tvar oldLength = this.length();\r\n\r\n\t\tif ( oldLength !== 0 && l !== oldLength  ) {\r\n\r\n\t\t\tthis.multiplyScalar( l / oldLength );\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerp: function ( v, alpha ) {\r\n\r\n\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\t\tthis.z += ( v.z - this.z ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcross: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'DEPRECATED: Vector3\\'s .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\r\n\t\t\treturn this.crossVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\r\n\t\tthis.x = y * v.z - z * v.y;\r\n\t\tthis.y = z * v.x - x * v.z;\r\n\t\tthis.z = x * v.y - y * v.x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcrossVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.y * b.z - a.z * b.y;\r\n\t\tthis.y = a.z * b.x - a.x * b.z;\r\n\t\tthis.z = a.x * b.y - a.y * b.x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tprojectOnVector: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function( vector ) {\r\n\r\n\t\t\tv1.copy( vector ).normalize();\r\n\t\t\tvar d = this.dot( v1 );\r\n\t\t\treturn this.copy( v1 ).multiplyScalar( d );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tprojectOnPlane: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function( planeNormal ) {\r\n\r\n\t\t\tv1.copy( this ).projectOnVector( planeNormal );\r\n\r\n\t\t\treturn this.sub( v1 );\r\n\r\n\t\t}\r\n\r\n\t}(),\r\n\r\n\treflect: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( vector ) {\r\n\r\n\t\t    v1.copy( this ).projectOnVector( vector ).multiplyScalar( 2 );\r\n\r\n\t\t    return this.subVectors( v1, this );\r\n\r\n\t\t}\r\n\r\n\t}(),\r\n\r\n\tangleTo: function ( v ) {\r\n\r\n\t\tvar theta = this.dot( v ) / ( this.length() * v.length() );\r\n\r\n\t\t// clamp, to handle numerical problems\r\n\r\n\t\treturn Math.acos( THREE.Math.clamp( theta, -1, 1 ) );\r\n\r\n\t},\r\n\r\n\tdistanceTo: function ( v ) {\r\n\r\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\r\n\r\n\t},\r\n\r\n\tdistanceToSquared: function ( v ) {\r\n\r\n\t\tvar dx = this.x - v.x;\r\n\t\tvar dy = this.y - v.y;\r\n\t\tvar dz = this.z - v.z;\r\n\r\n\t\treturn dx * dx + dy * dy + dz * dz;\r\n\r\n\t},\r\n\r\n\tgetPositionFromMatrix: function ( m ) {\r\n\r\n\t\tthis.x = m.elements[12];\r\n\t\tthis.y = m.elements[13];\r\n\t\tthis.z = m.elements[14];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetEulerFromRotationMatrix: function ( m, order ) {\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\t// clamp, to handle numerical problems\r\n\r\n\t\tfunction clamp( x ) {\r\n\r\n\t\t\treturn Math.min( Math.max( x, -1 ), 1 );\r\n\r\n\t\t}\r\n\r\n\t\tvar te = m.elements;\r\n\t\tvar m11 = te[0], m12 = te[4], m13 = te[8];\r\n\t\tvar m21 = te[1], m22 = te[5], m23 = te[9];\r\n\t\tvar m31 = te[2], m32 = te[6], m33 = te[10];\r\n\r\n\t\tif ( order === undefined || order === 'XYZ' ) {\r\n\r\n\t\t\tthis.y = Math.asin( clamp( m13 ) );\r\n\r\n\t\t\tif ( Math.abs( m13 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis.x = Math.atan2( - m23, m33 );\r\n\t\t\t\tthis.z = Math.atan2( - m12, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.x = Math.atan2( m32, m22 );\r\n\t\t\t\tthis.z = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'YXZ' ) {\r\n\r\n\t\t\tthis.x = Math.asin( - clamp( m23 ) );\r\n\r\n\t\t\tif ( Math.abs( m23 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis.y = Math.atan2( m13, m33 );\r\n\t\t\t\tthis.z = Math.atan2( m21, m22 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.y = Math.atan2( - m31, m11 );\r\n\t\t\t\tthis.z = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'ZXY' ) {\r\n\r\n\t\t\tthis.x = Math.asin( clamp( m32 ) );\r\n\r\n\t\t\tif ( Math.abs( m32 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis.y = Math.atan2( - m31, m33 );\r\n\t\t\t\tthis.z = Math.atan2( - m12, m22 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.y = 0;\r\n\t\t\t\tthis.z = Math.atan2( m21, m11 );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'ZYX' ) {\r\n\r\n\t\t\tthis.y = Math.asin( - clamp( m31 ) );\r\n\r\n\t\t\tif ( Math.abs( m31 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis.x = Math.atan2( m32, m33 );\r\n\t\t\t\tthis.z = Math.atan2( m21, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.x = 0;\r\n\t\t\t\tthis.z = Math.atan2( - m12, m22 );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'YZX' ) {\r\n\r\n\t\t\tthis.z = Math.asin( clamp( m21 ) );\r\n\r\n\t\t\tif ( Math.abs( m21 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis.x = Math.atan2( - m23, m22 );\r\n\t\t\t\tthis.y = Math.atan2( - m31, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.x = 0;\r\n\t\t\t\tthis.y = Math.atan2( m13, m33 );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'XZY' ) {\r\n\r\n\t\t\tthis.z = Math.asin( - clamp( m12 ) );\r\n\r\n\t\t\tif ( Math.abs( m12 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis.x = Math.atan2( m32, m22 );\r\n\t\t\t\tthis.y = Math.atan2( m13, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.x = Math.atan2( - m23, m33 );\r\n\t\t\t\tthis.y = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetEulerFromQuaternion: function ( q, order ) {\r\n\r\n\t\t// q is assumed to be normalized\r\n\r\n\t\t// clamp, to handle numerical problems\r\n\r\n\t\tfunction clamp( x ) {\r\n\r\n\t\t\treturn Math.min( Math.max( x, -1 ), 1 );\r\n\r\n\t\t}\r\n\r\n\t\t// http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m\r\n\r\n\t\tvar sqx = q.x * q.x;\r\n\t\tvar sqy = q.y * q.y;\r\n\t\tvar sqz = q.z * q.z;\r\n\t\tvar sqw = q.w * q.w;\r\n\r\n\t\tif ( order === undefined || order === 'XYZ' ) {\r\n\r\n\t\t\tthis.x = Math.atan2( 2 * ( q.x * q.w - q.y * q.z ), ( sqw - sqx - sqy + sqz ) );\r\n\t\t\tthis.y = Math.asin(  clamp( 2 * ( q.x * q.z + q.y * q.w ) ) );\r\n\t\t\tthis.z = Math.atan2( 2 * ( q.z * q.w - q.x * q.y ), ( sqw + sqx - sqy - sqz ) );\r\n\r\n\t\t} else if ( order ===  'YXZ' ) {\r\n\r\n\t\t\tthis.x = Math.asin(  clamp( 2 * ( q.x * q.w - q.y * q.z ) ) );\r\n\t\t\tthis.y = Math.atan2( 2 * ( q.x * q.z + q.y * q.w ), ( sqw - sqx - sqy + sqz ) );\r\n\t\t\tthis.z = Math.atan2( 2 * ( q.x * q.y + q.z * q.w ), ( sqw - sqx + sqy - sqz ) );\r\n\r\n\t\t} else if ( order === 'ZXY' ) {\r\n\r\n\t\t\tthis.x = Math.asin(  clamp( 2 * ( q.x * q.w + q.y * q.z ) ) );\r\n\t\t\tthis.y = Math.atan2( 2 * ( q.y * q.w - q.z * q.x ), ( sqw - sqx - sqy + sqz ) );\r\n\t\t\tthis.z = Math.atan2( 2 * ( q.z * q.w - q.x * q.y ), ( sqw - sqx + sqy - sqz ) );\r\n\r\n\t\t} else if ( order === 'ZYX' ) {\r\n\r\n\t\t\tthis.x = Math.atan2( 2 * ( q.x * q.w + q.z * q.y ), ( sqw - sqx - sqy + sqz ) );\r\n\t\t\tthis.y = Math.asin(  clamp( 2 * ( q.y * q.w - q.x * q.z ) ) );\r\n\t\t\tthis.z = Math.atan2( 2 * ( q.x * q.y + q.z * q.w ), ( sqw + sqx - sqy - sqz ) );\r\n\r\n\t\t} else if ( order === 'YZX' ) {\r\n\r\n\t\t\tthis.x = Math.atan2( 2 * ( q.x * q.w - q.z * q.y ), ( sqw - sqx + sqy - sqz ) );\r\n\t\t\tthis.y = Math.atan2( 2 * ( q.y * q.w - q.x * q.z ), ( sqw + sqx - sqy - sqz ) );\r\n\t\t\tthis.z = Math.asin(  clamp( 2 * ( q.x * q.y + q.z * q.w ) ) );\r\n\r\n\t\t} else if ( order === 'XZY' ) {\r\n\r\n\t\t\tthis.x = Math.atan2( 2 * ( q.x * q.w + q.y * q.z ), ( sqw - sqx + sqy - sqz ) );\r\n\t\t\tthis.y = Math.atan2( 2 * ( q.x * q.z + q.y * q.w ), ( sqw + sqx - sqy - sqz ) );\r\n\t\t\tthis.z = Math.asin(  clamp( 2 * ( q.z * q.w - q.x * q.y ) ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetScaleFromMatrix: function ( m ) {\r\n\r\n\t\tvar sx = this.set( m.elements[0], m.elements[1], m.elements[2] ).length();\r\n\t\tvar sy = this.set( m.elements[4], m.elements[5], m.elements[6] ).length();\r\n\t\tvar sz = this.set( m.elements[8], m.elements[9], m.elements[10] ).length();\r\n\r\n\t\tthis.x = sx;\r\n\t\tthis.y = sy;\r\n\t\tthis.z = sz;\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tequals: function ( v ) {\r\n\r\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\r\n\r\n\t},\r\n\r\n\ttoArray: function () {\r\n\r\n\t\treturn [ this.x, this.y, this.z ];\r\n\t\t\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Vector3( this.x, this.y, this.z );\r\n\r\n\t}\r\n\r\n} );\r\n/**\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author egraether / http://egraether.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.Vector4 = function ( x, y, z, w ) {\r\n\r\n\tthis.x = x || 0;\r\n\tthis.y = y || 0;\r\n\tthis.z = z || 0;\r\n\tthis.w = ( w !== undefined ) ? w : 1;\r\n\r\n};\r\n\r\nTHREE.extend( THREE.Vector4.prototype, {\r\n\r\n\tset: function ( x, y, z, w ) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.z = z;\r\n\t\tthis.w = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetX: function ( x ) {\r\n\r\n\t\tthis.x = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetY: function ( y ) {\r\n\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetZ: function ( z ) {\r\n\r\n\t\tthis.z = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetW: function ( w ) {\r\n\r\n\t\tthis.w = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetComponent: function ( index, value ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: this.x = value; break;\r\n\t\t\tcase 1: this.y = value; break;\r\n\t\t\tcase 2: this.z = value; break;\r\n\t\t\tcase 3: this.w = value; break;\r\n\t\t\tdefault: throw new Error( \"index is out of range: \" + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetComponent: function ( index ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: return this.x;\r\n\t\t\tcase 1: return this.y;\r\n\t\t\tcase 2: return this.z;\r\n\t\t\tcase 3: return this.w;\r\n\t\t\tdefault: throw new Error( \"index is out of range: \" + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcopy: function ( v ) {\r\n\r\n\t\tthis.x = v.x;\r\n\t\tthis.y = v.y;\r\n\t\tthis.z = v.z;\r\n\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tadd: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'DEPRECATED: Vector4\\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\treturn this.addVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x += v.x;\r\n\t\tthis.y += v.y;\r\n\t\tthis.z += v.z;\r\n\t\tthis.w += v.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.x += s;\r\n\t\tthis.y += s;\r\n\t\tthis.z += s;\r\n\t\tthis.w += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x + b.x;\r\n\t\tthis.y = a.y + b.y;\r\n\t\tthis.z = a.z + b.z;\r\n\t\tthis.w = a.w + b.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsub: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'DEPRECATED: Vector4\\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\treturn this.subVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x -= v.x;\r\n\t\tthis.y -= v.y;\r\n\t\tthis.z -= v.z;\r\n\t\tthis.w -= v.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x - b.x;\r\n\t\tthis.y = a.y - b.y;\r\n\t\tthis.z = a.z - b.z;\r\n\t\tthis.w = a.w - b.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( s ) {\r\n\r\n\t\tthis.x *= s;\r\n\t\tthis.y *= s;\r\n\t\tthis.z *= s;\r\n\t\tthis.w *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function ( m ) {\r\n\r\n\t\tvar x = this.x;\r\n\t\tvar y = this.y;\r\n\t\tvar z = this.z;\r\n\t\tvar w = this.w;\r\n\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;\r\n\t\tthis.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;\r\n\t\tthis.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;\r\n\t\tthis.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivideScalar: function ( s ) {\r\n\r\n\t\tif ( s !== 0 ) {\r\n\r\n\t\t\tthis.x /= s;\r\n\t\t\tthis.y /= s;\r\n\t\t\tthis.z /= s;\r\n\t\t\tthis.w /= s;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.x = 0;\r\n\t\t\tthis.y = 0;\r\n\t\t\tthis.z = 0;\r\n\t\t\tthis.w = 1;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetAxisAngleFromQuaternion: function ( q ) {\r\n\r\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\r\n\r\n\t\t// q is assumed to be normalized\r\n\r\n\t\tthis.w = 2 * Math.acos( q.w );\r\n\r\n\t\tvar s = Math.sqrt( 1 - q.w * q.w );\r\n\r\n\t\tif ( s < 0.0001 ) {\r\n\r\n\t\t\t this.x = 1;\r\n\t\t\t this.y = 0;\r\n\t\t\t this.z = 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t this.x = q.x / s;\r\n\t\t\t this.y = q.y / s;\r\n\t\t\t this.z = q.z / s;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetAxisAngleFromRotationMatrix: function ( m ) {\r\n\r\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\tvar angle, x, y, z,\t\t// variables for result\r\n\t\t\tepsilon = 0.01,\t\t// margin to allow for rounding errors\r\n\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\r\n\r\n\t\t\tte = m.elements,\r\n\r\n\t\t\tm11 = te[0], m12 = te[4], m13 = te[8],\r\n\t\t\tm21 = te[1], m22 = te[5], m23 = te[9],\r\n\t\t\tm31 = te[2], m32 = te[6], m33 = te[10];\r\n\r\n\t\tif ( ( Math.abs( m12 - m21 ) < epsilon )\r\n\t\t  && ( Math.abs( m13 - m31 ) < epsilon )\r\n\t\t  && ( Math.abs( m23 - m32 ) < epsilon ) ) {\r\n\r\n\t\t\t// singularity found\r\n\t\t\t// first check for identity matrix which must have +1 for all terms\r\n\t\t\t// in leading diagonal and zero in other terms\r\n\r\n\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 )\r\n\t\t\t  && ( Math.abs( m13 + m31 ) < epsilon2 )\r\n\t\t\t  && ( Math.abs( m23 + m32 ) < epsilon2 )\r\n\t\t\t  && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\r\n\r\n\t\t\t\t// this singularity is identity matrix so angle = 0\r\n\r\n\t\t\t\tthis.set( 1, 0, 0, 0 );\r\n\r\n\t\t\t\treturn this; // zero angle, arbitrary axis\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// otherwise this singularity is angle = 180\r\n\r\n\t\t\tangle = Math.PI;\r\n\r\n\t\t\tvar xx = ( m11 + 1 ) / 2;\r\n\t\t\tvar yy = ( m22 + 1 ) / 2;\r\n\t\t\tvar zz = ( m33 + 1 ) / 2;\r\n\t\t\tvar xy = ( m12 + m21 ) / 4;\r\n\t\t\tvar xz = ( m13 + m31 ) / 4;\r\n\t\t\tvar yz = ( m23 + m32 ) / 4;\r\n\r\n\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) { // m11 is the largest diagonal term\r\n\r\n\t\t\t\tif ( xx < epsilon ) {\r\n\r\n\t\t\t\t\tx = 0;\r\n\t\t\t\t\ty = 0.707106781;\r\n\t\t\t\t\tz = 0.707106781;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tx = Math.sqrt( xx );\r\n\t\t\t\t\ty = xy / x;\r\n\t\t\t\t\tz = xz / x;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( yy > zz ) { // m22 is the largest diagonal term\r\n\r\n\t\t\t\tif ( yy < epsilon ) {\r\n\r\n\t\t\t\t\tx = 0.707106781;\r\n\t\t\t\t\ty = 0;\r\n\t\t\t\t\tz = 0.707106781;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ty = Math.sqrt( yy );\r\n\t\t\t\t\tx = xy / y;\r\n\t\t\t\t\tz = yz / y;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else { // m33 is the largest diagonal term so base result on this\r\n\r\n\t\t\t\tif ( zz < epsilon ) {\r\n\r\n\t\t\t\t\tx = 0.707106781;\r\n\t\t\t\t\ty = 0.707106781;\r\n\t\t\t\t\tz = 0;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tz = Math.sqrt( zz );\r\n\t\t\t\t\tx = xz / z;\r\n\t\t\t\t\ty = yz / z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.set( x, y, z, angle );\r\n\r\n\t\t\treturn this; // return 180 deg rotation\r\n\r\n\t\t}\r\n\r\n\t\t// as we have reached here there are no singularities so we can handle normally\r\n\r\n\t\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )\r\n\t\t\t\t\t\t + ( m13 - m31 ) * ( m13 - m31 )\r\n\t\t\t\t\t\t + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\r\n\r\n\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\r\n\r\n\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\r\n\t\t// caught by singularity test above, but I've left it in just in case\r\n\r\n\t\tthis.x = ( m32 - m23 ) / s;\r\n\t\tthis.y = ( m13 - m31 ) / s;\r\n\t\tthis.z = ( m21 - m12 ) / s;\r\n\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmin: function ( v ) {\r\n\r\n\t\tif ( this.x > v.x ) {\r\n\r\n\t\t\tthis.x = v.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y > v.y ) {\r\n\r\n\t\t\tthis.y = v.y;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.z > v.z ) {\r\n\r\n\t\t\tthis.z = v.z;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.w > v.w ) {\r\n\r\n\t\t\tthis.w = v.w;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmax: function ( v ) {\r\n\r\n\t\tif ( this.x < v.x ) {\r\n\r\n\t\t\tthis.x = v.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y < v.y ) {\r\n\r\n\t\t\tthis.y = v.y;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.z < v.z ) {\r\n\r\n\t\t\tthis.z = v.z;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.w < v.w ) {\r\n\r\n\t\t\tthis.w = v.w;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclamp: function ( min, max ) {\r\n\r\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\r\n\t\tif ( this.x < min.x ) {\r\n\r\n\t\t\tthis.x = min.x;\r\n\r\n\t\t} else if ( this.x > max.x ) {\r\n\r\n\t\t\tthis.x = max.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y < min.y ) {\r\n\r\n\t\t\tthis.y = min.y;\r\n\r\n\t\t} else if ( this.y > max.y ) {\r\n\r\n\t\t\tthis.y = max.y;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.z < min.z ) {\r\n\r\n\t\t\tthis.z = min.z;\r\n\r\n\t\t} else if ( this.z > max.z ) {\r\n\r\n\t\t\tthis.z = max.z;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.w < min.w ) {\r\n\r\n\t\t\tthis.w = min.w;\r\n\r\n\t\t} else if ( this.w > max.w ) {\r\n\r\n\t\t\tthis.w = max.w;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnegate: function() {\r\n\r\n\t\treturn this.multiplyScalar( -1 );\r\n\r\n\t},\r\n\r\n\tdot: function ( v ) {\r\n\r\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\r\n\r\n\t},\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\r\n\r\n\t},\r\n\r\n\tlengthManhattan: function () {\r\n\r\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\treturn this.divideScalar( this.length() );\r\n\r\n\t},\r\n\r\n\tsetLength: function ( l ) {\r\n\r\n\t\tvar oldLength = this.length();\r\n\r\n\t\tif ( oldLength !== 0 && l !== oldLength ) {\r\n\r\n\t\t\tthis.multiplyScalar( l / oldLength );\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerp: function ( v, alpha ) {\r\n\r\n\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\t\tthis.z += ( v.z - this.z ) * alpha;\r\n\t\tthis.w += ( v.w - this.w ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( v ) {\r\n\r\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\r\n\r\n\t},\r\n\r\n\ttoArray: function () {\r\n\r\n\t\treturn [ this.x, this.y, this.z, this.w ];\r\n\t\t\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Vector4( this.x, this.y, this.z, this.w );\r\n\r\n\t}\r\n\r\n} );\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Box2 = function ( min, max ) {\r\n\r\n\tthis.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );\r\n\tthis.max = ( max !== undefined ) ? max : new THREE.Vector2( -Infinity, -Infinity );\r\n\r\n};\r\n\r\nTHREE.extend( THREE.Box2.prototype, {\r\n\r\n\tset: function ( min, max ) {\r\n\r\n\t\tthis.min.copy( min );\r\n\t\tthis.max.copy( max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromPoints: function ( points ) {\r\n\r\n\t\tif ( points.length > 0 ) {\r\n\r\n\t\t\tvar point = points[ 0 ];\r\n\r\n\t\t\tthis.min.copy( point );\r\n\t\t\tthis.max.copy( point );\r\n\r\n\t\t\tfor ( var i = 1, il = points.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tpoint = points[ i ];\r\n\r\n\t\t\t\tif ( point.x < this.min.x ) {\r\n\r\n\t\t\t\t\tthis.min.x = point.x;\r\n\r\n\t\t\t\t} else if ( point.x > this.max.x ) {\r\n\r\n\t\t\t\t\tthis.max.x = point.x;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( point.y < this.min.y ) {\r\n\r\n\t\t\t\t\tthis.min.y = point.y;\r\n\r\n\t\t\t\t} else if ( point.y > this.max.y ) {\r\n\r\n\t\t\t\t\tthis.max.y = point.y;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.makeEmpty();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromCenterAndSize: function() {\r\n\r\n\t\tvar v1 = new THREE.Vector2();\r\n\r\n\t\treturn function ( center, size ) {\r\n\r\n\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\r\n\t\t\tthis.min.copy( center ).sub( halfSize );\r\n\t\t\tthis.max.copy( center ).add( halfSize );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tcopy: function ( box ) {\r\n\r\n\t\tthis.min.copy( box.min );\r\n\t\tthis.max.copy( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeEmpty: function () {\r\n\r\n\t\tthis.min.x = this.min.y = Infinity;\r\n\t\tthis.max.x = this.max.y = -Infinity;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tempty: function () {\r\n\r\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\r\n\r\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\r\n\r\n\t},\r\n\r\n\tcenter: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\r\n\r\n\t},\r\n\r\n\tsize: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\treturn result.subVectors( this.max, this.min );\r\n\r\n\t},\r\n\r\n\texpandByPoint: function ( point ) {\r\n\r\n\t\tthis.min.min( point );\r\n\t\tthis.max.max( point );\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\texpandByVector: function ( vector ) {\r\n\r\n\t\tthis.min.sub( vector );\r\n\t\tthis.max.add( vector );\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\texpandByScalar: function ( scalar ) {\r\n\r\n\t\tthis.min.addScalar( -scalar );\r\n\t\tthis.max.addScalar( scalar );\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\tif ( point.x < this.min.x || point.x > this.max.x ||\r\n\t\t     point.y < this.min.y || point.y > this.max.y ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tcontainsBox: function ( box ) {\r\n\r\n\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\r\n\t\t     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t},\r\n\r\n\tgetParameter: function ( point ) {\r\n\r\n\t\t// This can potentially have a divide by zero if the box\r\n\t\t// has a size dimension of 0.\r\n\r\n\t\treturn new THREE.Vector2(\r\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\r\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\r\n\t\t);\r\n\r\n\t},\r\n\r\n\tisIntersectionBox: function ( box ) {\r\n\r\n\t\t// using 6 splitting planes to rule out intersections.\r\n\r\n\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\r\n\t\t     box.max.y < this.min.y || box.min.y > this.max.y ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tclampPoint: function ( point, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\treturn result.copy( point ).clamp( this.min, this.max );\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function() {\r\n\r\n\t\tvar v1 = new THREE.Vector2();\r\n\r\n\t\treturn function ( point ) {\r\n\r\n\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\r\n\t\t\treturn clampedPoint.sub( point ).length();\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersect: function ( box ) {\r\n\r\n\t\tthis.min.max( box.min );\r\n\t\tthis.max.min( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tunion: function ( box ) {\r\n\r\n\t\tthis.min.min( box.min );\r\n\t\tthis.max.max( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttranslate: function ( offset ) {\r\n\r\n\t\tthis.min.add( offset );\r\n\t\tthis.max.add( offset );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( box ) {\r\n\r\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Box2().copy( this );\r\n\r\n\t}\r\n\r\n} );\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Box3 = function ( min, max ) {\r\n\r\n\tthis.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );\r\n\tthis.max = ( max !== undefined ) ? max : new THREE.Vector3( -Infinity, -Infinity, -Infinity );\r\n\r\n};\r\n\r\nTHREE.extend( THREE.Box3.prototype, {\r\n\r\n\tset: function ( min, max ) {\r\n\r\n\t\tthis.min.copy( min );\r\n\t\tthis.max.copy( max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromPoints: function ( points ) {\r\n\r\n\t\tif ( points.length > 0 ) {\r\n\r\n\t\t\tvar point = points[ 0 ];\r\n\r\n\t\t\tthis.min.copy( point );\r\n\t\t\tthis.max.copy( point );\r\n\r\n\t\t\tfor ( var i = 1, il = points.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tpoint = points[ i ];\r\n\r\n\t\t\t\tif ( point.x < this.min.x ) {\r\n\r\n\t\t\t\t\tthis.min.x = point.x;\r\n\r\n\t\t\t\t} else if ( point.x > this.max.x ) {\r\n\r\n\t\t\t\t\tthis.max.x = point.x;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( point.y < this.min.y ) {\r\n\r\n\t\t\t\t\tthis.min.y = point.y;\r\n\r\n\t\t\t\t} else if ( point.y > this.max.y ) {\r\n\r\n\t\t\t\t\tthis.max.y = point.y;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( point.z < this.min.z ) {\r\n\r\n\t\t\t\t\tthis.min.z = point.z;\r\n\r\n\t\t\t\t} else if ( point.z > this.max.z ) {\r\n\r\n\t\t\t\t\tthis.max.z = point.z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.makeEmpty();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromCenterAndSize: function() {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( center, size ) {\r\n\r\n\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\r\n\r\n\t\t\tthis.min.copy( center ).sub( halfSize );\r\n\t\t\tthis.max.copy( center ).add( halfSize );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tcopy: function ( box ) {\r\n\r\n\t\tthis.min.copy( box.min );\r\n\t\tthis.max.copy( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeEmpty: function () {\r\n\r\n\t\tthis.min.x = this.min.y = this.min.z = Infinity;\r\n\t\tthis.max.x = this.max.y = this.max.z = -Infinity;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tempty: function () {\r\n\r\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\r\n\r\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\r\n\r\n\t},\r\n\r\n\tcenter: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\r\n\r\n\t},\r\n\r\n\tsize: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.subVectors( this.max, this.min );\r\n\r\n\t},\r\n\r\n\texpandByPoint: function ( point ) {\r\n\r\n\t\tthis.min.min( point );\r\n\t\tthis.max.max( point );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\texpandByVector: function ( vector ) {\r\n\r\n\t\tthis.min.sub( vector );\r\n\t\tthis.max.add( vector );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\texpandByScalar: function ( scalar ) {\r\n\r\n\t\tthis.min.addScalar( -scalar );\r\n\t\tthis.max.addScalar( scalar );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\tif ( point.x < this.min.x || point.x > this.max.x ||\r\n\t\t     point.y < this.min.y || point.y > this.max.y ||\r\n\t\t     point.z < this.min.z || point.z > this.max.z ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tcontainsBox: function ( box ) {\r\n\r\n\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\r\n\t\t\t ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&\r\n\t\t\t ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t},\r\n\r\n\tgetParameter: function ( point ) {\r\n\r\n\t\t// This can potentially have a divide by zero if the box\r\n\t\t// has a size dimension of 0.\r\n\r\n\t\treturn new THREE.Vector3(\r\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\r\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\r\n\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\r\n\t\t);\r\n\r\n\t},\r\n\r\n\tisIntersectionBox: function ( box ) {\r\n\r\n\t\t// using 6 splitting planes to rule out intersections.\r\n\r\n\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\r\n\t\t     box.max.y < this.min.y || box.min.y > this.max.y ||\r\n\t\t     box.max.z < this.min.z || box.min.z > this.max.z ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tclampPoint: function ( point, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.copy( point ).clamp( this.min, this.max );\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function() {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( point ) {\r\n\r\n\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\r\n\t\t\treturn clampedPoint.sub( point ).length();\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tgetBoundingSphere: function() {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( optionalTarget ) {\r\n\r\n\t\t\tvar result = optionalTarget || new THREE.Sphere();\r\n\r\n\t\t\tresult.center = this.center();\r\n\t\t\tresult.radius = this.size( v1 ).length() * 0.5;\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersect: function ( box ) {\r\n\r\n\t\tthis.min.max( box.min );\r\n\t\tthis.max.min( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tunion: function ( box ) {\r\n\r\n\t\tthis.min.min( box.min );\r\n\t\tthis.max.max( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function() {\r\n\r\n\t\tvar points = [\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3()\r\n\t\t\t];\r\n\r\n\t\treturn function ( matrix ) {\r\n\r\n\t\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\r\n\t\t\tpoints[0].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\r\n\t\t\tpoints[1].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\r\n\t\t\tpoints[2].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\r\n\t\t\tpoints[3].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\r\n\t\t\tpoints[4].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\r\n\t\t\tpoints[5].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\r\n\t\t\tpoints[6].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\r\n\t\t\tpoints[7].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );  // 111\r\n\r\n\t\t\tthis.makeEmpty();\r\n\t\t\tthis.setFromPoints( points );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslate: function ( offset ) {\r\n\r\n\t\tthis.min.add( offset );\r\n\t\tthis.max.add( offset );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( box ) {\r\n\r\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Box3().copy( this );\r\n\r\n\t}\r\n\r\n} );\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Matrix3 = function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\r\n\r\n\tthis.elements = new Float32Array(9);\r\n\r\n\tthis.set(\r\n\r\n\t\t( n11 !== undefined ) ? n11 : 1, n12 || 0, n13 || 0,\r\n\t\tn21 || 0, ( n22 !== undefined ) ? n22 : 1, n23 || 0,\r\n\t\tn31 || 0, n32 || 0, ( n33 !== undefined ) ? n33 : 1\r\n\r\n\t);\r\n};\r\n\r\nTHREE.extend( THREE.Matrix3.prototype, {\r\n\r\n\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[0] = n11; te[3] = n12; te[6] = n13;\r\n\t\tte[1] = n21; te[4] = n22; te[7] = n23;\r\n\t\tte[2] = n31; te[5] = n32; te[8] = n33;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tidentity: function () {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0,\r\n\t\t\t0, 1, 0,\r\n\t\t\t0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( m ) {\r\n\r\n\t\tvar me = m.elements;\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tme[0], me[3], me[6],\r\n\t\t\tme[1], me[4], me[7],\r\n\t\t\tme[2], me[5], me[8]\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyVector3: function ( vector ) {\r\n\r\n\t\tconsole.warn( 'DEPRECATED: Matrix3\\'s .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\r\n\t\treturn vector.applyMatrix3( this );\r\n\r\n\t},\r\n\r\n\tmultiplyVector3Array: function() {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( a ) {\r\n\r\n\t\t\tfor ( var i = 0, il = a.length; i < il; i += 3 ) {\r\n\r\n\t\t\t\tv1.x = a[ i ];\r\n\t\t\t\tv1.y = a[ i + 1 ];\r\n\t\t\t\tv1.z = a[ i + 2 ];\r\n\r\n\t\t\t\tv1.applyMatrix3(this);\r\n\r\n\t\t\t\ta[ i ]     = v1.x;\r\n\t\t\t\ta[ i + 1 ] = v1.y;\r\n\t\t\t\ta[ i + 2 ] = v1.z;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn a;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmultiplyScalar: function ( s ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[0] *= s; te[3] *= s; te[6] *= s;\r\n\t\tte[1] *= s; te[4] *= s; te[7] *= s;\r\n\t\tte[2] *= s; te[5] *= s; te[8] *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdeterminant: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar a = te[0], b = te[1], c = te[2],\r\n\t\t\td = te[3], e = te[4], f = te[5],\r\n\t\t\tg = te[6], h = te[7], i = te[8];\r\n\r\n\t\treturn a*e*i - a*f*h - b*d*i + b*f*g + c*d*h - c*e*g;\r\n\r\n\t},\r\n\r\n\tgetInverse: function ( matrix, throwOnInvertible ) {\r\n\r\n\t\t// input: THREE.Matrix4\r\n\t\t// ( based on http://code.google.com/p/webgl-mjs/ )\r\n\r\n\t\tvar me = matrix.elements;\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 0 ] =   me[10] * me[5] - me[6] * me[9];\r\n\t\tte[ 1 ] = - me[10] * me[1] + me[2] * me[9];\r\n\t\tte[ 2 ] =   me[6] * me[1] - me[2] * me[5];\r\n\t\tte[ 3 ] = - me[10] * me[4] + me[6] * me[8];\r\n\t\tte[ 4 ] =   me[10] * me[0] - me[2] * me[8];\r\n\t\tte[ 5 ] = - me[6] * me[0] + me[2] * me[4];\r\n\t\tte[ 6 ] =   me[9] * me[4] - me[5] * me[8];\r\n\t\tte[ 7 ] = - me[9] * me[0] + me[1] * me[8];\r\n\t\tte[ 8 ] =   me[5] * me[0] - me[1] * me[4];\r\n\r\n\t\tvar det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];\r\n\r\n\t\t// no inverse\r\n\r\n\t\tif ( det === 0 ) {\r\n\r\n\t\t\tvar msg = \"Matrix3.getInverse(): can't invert matrix, determinant is 0\";\r\n\r\n\t\t\tif ( throwOnInvertible || false ) {\r\n\r\n\t\t\t\tthrow new Error( msg ); \r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.warn( msg );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.identity();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tthis.multiplyScalar( 1.0 / det );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttranspose: function () {\r\n\r\n\t\tvar tmp, m = this.elements;\r\n\r\n\t\ttmp = m[1]; m[1] = m[3]; m[3] = tmp;\r\n\t\ttmp = m[2]; m[2] = m[6]; m[6] = tmp;\r\n\t\ttmp = m[5]; m[5] = m[7]; m[7] = tmp;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetNormalMatrix: function ( m ) {\r\n\r\n\t\t// input: THREE.Matrix4\r\n\r\n\t\tthis.getInverse( m ).transpose();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttransposeIntoArray: function ( r ) {\r\n\r\n\t\tvar m = this.elements;\r\n\r\n\t\tr[ 0 ] = m[ 0 ];\r\n\t\tr[ 1 ] = m[ 3 ];\r\n\t\tr[ 2 ] = m[ 6 ];\r\n\t\tr[ 3 ] = m[ 1 ];\r\n\t\tr[ 4 ] = m[ 4 ];\r\n\t\tr[ 5 ] = m[ 7 ];\r\n\t\tr[ 6 ] = m[ 2 ];\r\n\t\tr[ 7 ] = m[ 5 ];\r\n\t\tr[ 8 ] = m[ 8 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\treturn new THREE.Matrix3(\r\n\r\n\t\t\tte[0], te[3], te[6],\r\n\t\t\tte[1], te[4], te[7],\r\n\t\t\tte[2], te[5], te[8]\r\n\r\n\t\t);\r\n\r\n\t}\r\n\r\n} );\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author jordi_ros / http://plattsoft.com\r\n * @author D1plo1d / http://github.com/D1plo1d\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author timknip / http://www.floorplanner.com/\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\n\r\nTHREE.Matrix4 = function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\r\n\r\n\tvar te = this.elements = new Float32Array( 16 );\r\n\r\n\t// TODO: if n11 is undefined, then just set to identity, otherwise copy all other values into matrix\r\n\t//   we should not support semi specification of Matrix4, it is just weird.\r\n\r\n\tte[0] = ( n11 !== undefined ) ? n11 : 1; te[4] = n12 || 0; te[8] = n13 || 0; te[12] = n14 || 0;\r\n\tte[1] = n21 || 0; te[5] = ( n22 !== undefined ) ? n22 : 1; te[9] = n23 || 0; te[13] = n24 || 0;\r\n\tte[2] = n31 || 0; te[6] = n32 || 0; te[10] = ( n33 !== undefined ) ? n33 : 1; te[14] = n34 || 0;\r\n\tte[3] = n41 || 0; te[7] = n42 || 0; te[11] = n43 || 0; te[15] = ( n44 !== undefined ) ? n44 : 1;\r\n\r\n};\r\n\r\nTHREE.extend( THREE.Matrix4.prototype, {\r\n\r\n\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[0] = n11; te[4] = n12; te[8] = n13; te[12] = n14;\r\n\t\tte[1] = n21; te[5] = n22; te[9] = n23; te[13] = n24;\r\n\t\tte[2] = n31; te[6] = n32; te[10] = n33; te[14] = n34;\r\n\t\tte[3] = n41; te[7] = n42; te[11] = n43; te[15] = n44;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tidentity: function () {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0, 0,\r\n\t\t\t0, 1, 0, 0,\r\n\t\t\t0, 0, 1, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( m ) {\r\n\r\n\t\tvar me = m.elements;\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tme[0], me[4], me[8], me[12],\r\n\t\t\tme[1], me[5], me[9], me[13],\r\n\t\t\tme[2], me[6], me[10], me[14],\r\n\t\t\tme[3], me[7], me[11], me[15]\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetRotationFromEuler: function ( v, order ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar x = v.x, y = v.y, z = v.z;\r\n\t\tvar a = Math.cos( x ), b = Math.sin( x );\r\n\t\tvar c = Math.cos( y ), d = Math.sin( y );\r\n\t\tvar e = Math.cos( z ), f = Math.sin( z );\r\n\r\n\t\tif ( order === undefined || order === 'XYZ' ) {\r\n\r\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\r\n\t\t\tte[0] = c * e;\r\n\t\t\tte[4] = - c * f;\r\n\t\t\tte[8] = d;\r\n\r\n\t\t\tte[1] = af + be * d;\r\n\t\t\tte[5] = ae - bf * d;\r\n\t\t\tte[9] = - b * c;\r\n\r\n\t\t\tte[2] = bf - ae * d;\r\n\t\t\tte[6] = be + af * d;\r\n\t\t\tte[10] = a * c;\r\n\r\n\t\t} else if ( order === 'YXZ' ) {\r\n\r\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\r\n\t\t\tte[0] = ce + df * b;\r\n\t\t\tte[4] = de * b - cf;\r\n\t\t\tte[8] = a * d;\r\n\r\n\t\t\tte[1] = a * f;\r\n\t\t\tte[5] = a * e;\r\n\t\t\tte[9] = - b;\r\n\r\n\t\t\tte[2] = cf * b - de;\r\n\t\t\tte[6] = df + ce * b;\r\n\t\t\tte[10] = a * c;\r\n\r\n\t\t} else if ( order === 'ZXY' ) {\r\n\r\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\r\n\t\t\tte[0] = ce - df * b;\r\n\t\t\tte[4] = - a * f;\r\n\t\t\tte[8] = de + cf * b;\r\n\r\n\t\t\tte[1] = cf + de * b;\r\n\t\t\tte[5] = a * e;\r\n\t\t\tte[9] = df - ce * b;\r\n\r\n\t\t\tte[2] = - a * d;\r\n\t\t\tte[6] = b;\r\n\t\t\tte[10] = a * c;\r\n\r\n\t\t} else if ( order === 'ZYX' ) {\r\n\r\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\r\n\t\t\tte[0] = c * e;\r\n\t\t\tte[4] = be * d - af;\r\n\t\t\tte[8] = ae * d + bf;\r\n\r\n\t\t\tte[1] = c * f;\r\n\t\t\tte[5] = bf * d + ae;\r\n\t\t\tte[9] = af * d - be;\r\n\r\n\t\t\tte[2] = - d;\r\n\t\t\tte[6] = b * c;\r\n\t\t\tte[10] = a * c;\r\n\r\n\t\t} else if ( order === 'YZX' ) {\r\n\r\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\r\n\t\t\tte[0] = c * e;\r\n\t\t\tte[4] = bd - ac * f;\r\n\t\t\tte[8] = bc * f + ad;\r\n\r\n\t\t\tte[1] = f;\r\n\t\t\tte[5] = a * e;\r\n\t\t\tte[9] = - b * e;\r\n\r\n\t\t\tte[2] = - d * e;\r\n\t\t\tte[6] = ad * f + bc;\r\n\t\t\tte[10] = ac - bd * f;\r\n\r\n\t\t} else if ( order === 'XZY' ) {\r\n\r\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\r\n\t\t\tte[0] = c * e;\r\n\t\t\tte[4] = - f;\r\n\t\t\tte[8] = d * e;\r\n\r\n\t\t\tte[1] = ac * f + bd;\r\n\t\t\tte[5] = a * e;\r\n\t\t\tte[9] = ad * f - bc;\r\n\r\n\t\t\tte[2] = bc * f - ad;\r\n\t\t\tte[6] = b * e;\r\n\t\t\tte[10] = bd * f + ac;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetRotationFromQuaternion: function ( q ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar x = q.x, y = q.y, z = q.z, w = q.w;\r\n\t\tvar x2 = x + x, y2 = y + y, z2 = z + z;\r\n\t\tvar xx = x * x2, xy = x * y2, xz = x * z2;\r\n\t\tvar yy = y * y2, yz = y * z2, zz = z * z2;\r\n\t\tvar wx = w * x2, wy = w * y2, wz = w * z2;\r\n\r\n\t\tte[0] = 1 - ( yy + zz );\r\n\t\tte[4] = xy - wz;\r\n\t\tte[8] = xz + wy;\r\n\r\n\t\tte[1] = xy + wz;\r\n\t\tte[5] = 1 - ( xx + zz );\r\n\t\tte[9] = yz - wx;\r\n\r\n\t\tte[2] = xz - wy;\r\n\t\tte[6] = yz + wx;\r\n\t\tte[10] = 1 - ( xx + yy );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlookAt: function() {\r\n\r\n\t\tvar x = new THREE.Vector3();\r\n\t\tvar y = new THREE.Vector3();\r\n\t\tvar z = new THREE.Vector3();\r\n\r\n\t\treturn function ( eye, target, up ) {\r\n\r\n\t\t\tvar te = this.elements;\r\n\r\n\t\t\tz.subVectors( eye, target ).normalize();\r\n\r\n\t\t\tif ( z.length() === 0 ) {\r\n\r\n\t\t\t\tz.z = 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tx.crossVectors( up, z ).normalize();\r\n\r\n\t\t\tif ( x.length() === 0 ) {\r\n\r\n\t\t\t\tz.x += 0.0001;\r\n\t\t\t\tx.crossVectors( up, z ).normalize();\r\n\r\n\t\t\t}\r\n\r\n\t\t\ty.crossVectors( z, x );\r\n\r\n\r\n\t\t\tte[0] = x.x; te[4] = y.x; te[8] = z.x;\r\n\t\t\tte[1] = x.y; te[5] = y.y; te[9] = z.y;\r\n\t\t\tte[2] = x.z; te[6] = y.z; te[10] = z.z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmultiply: function ( m, n ) {\r\n\r\n\t\tif ( n !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\r\n\t\t\treturn this.multiplyMatrices( m, n );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.multiplyMatrices( this, m );\r\n\r\n\t},\r\n\r\n\tmultiplyMatrices: function ( a, b ) {\r\n\r\n\t\tvar ae = a.elements;\r\n\t\tvar be = b.elements;\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];\r\n\t\tvar a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];\r\n\t\tvar a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];\r\n\t\tvar a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];\r\n\r\n\t\tvar b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];\r\n\t\tvar b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];\r\n\t\tvar b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];\r\n\t\tvar b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];\r\n\r\n\t\tte[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\r\n\t\tte[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\r\n\t\tte[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\r\n\t\tte[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\r\n\r\n\t\tte[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\r\n\t\tte[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\r\n\t\tte[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\r\n\t\tte[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\r\n\r\n\t\tte[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\r\n\t\tte[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\r\n\t\tte[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\r\n\t\tte[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\r\n\r\n\t\tte[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\r\n\t\tte[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\r\n\t\tte[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\r\n\t\tte[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyToArray: function ( a, b, r ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tthis.multiplyMatrices( a, b );\r\n\r\n\t\tr[ 0 ] = te[0]; r[ 1 ] = te[1]; r[ 2 ] = te[2]; r[ 3 ] = te[3];\r\n\t\tr[ 4 ] = te[4]; r[ 5 ] = te[5]; r[ 6 ] = te[6]; r[ 7 ] = te[7];\r\n\t\tr[ 8 ]  = te[8]; r[ 9 ]  = te[9]; r[ 10 ] = te[10]; r[ 11 ] = te[11];\r\n\t\tr[ 12 ] = te[12]; r[ 13 ] = te[13]; r[ 14 ] = te[14]; r[ 15 ] = te[15];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( s ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[0] *= s; te[4] *= s; te[8] *= s; te[12] *= s;\r\n\t\tte[1] *= s; te[5] *= s; te[9] *= s; te[13] *= s;\r\n\t\tte[2] *= s; te[6] *= s; te[10] *= s; te[14] *= s;\r\n\t\tte[3] *= s; te[7] *= s; te[11] *= s; te[15] *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyVector3: function ( vector ) {\r\n\r\n\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );\r\n\t\treturn vector.applyProjection( this );\r\n\r\n\t},\r\n\r\n\tmultiplyVector4: function ( vector ) {\r\n\r\n\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\r\n\t\treturn vector.applyMatrix4( this );\r\n\r\n\t},\r\n\r\n\tmultiplyVector3Array: function() {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( a ) {\r\n\r\n\t\t\tfor ( var i = 0, il = a.length; i < il; i += 3 ) {\r\n\r\n\t\t\t\tv1.x = a[ i ];\r\n\t\t\t\tv1.y = a[ i + 1 ];\r\n\t\t\t\tv1.z = a[ i + 2 ];\r\n\r\n\t\t\t\tv1.applyProjection( this );\r\n\r\n\t\t\t\ta[ i ]     = v1.x;\r\n\t\t\t\ta[ i + 1 ] = v1.y;\r\n\t\t\t\ta[ i + 2 ] = v1.z;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn a;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateAxis: function ( v ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar vx = v.x, vy = v.y, vz = v.z;\r\n\r\n\t\tv.x = vx * te[0] + vy * te[4] + vz * te[8];\r\n\t\tv.y = vx * te[1] + vy * te[5] + vz * te[9];\r\n\t\tv.z = vx * te[2] + vy * te[6] + vz * te[10];\r\n\r\n\t\tv.normalize();\r\n\r\n\t\treturn v;\r\n\r\n\t},\r\n\r\n\tcrossVector: function ( a ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar v = new THREE.Vector4();\r\n\r\n\t\tv.x = te[0] * a.x + te[4] * a.y + te[8] * a.z + te[12] * a.w;\r\n\t\tv.y = te[1] * a.x + te[5] * a.y + te[9] * a.z + te[13] * a.w;\r\n\t\tv.z = te[2] * a.x + te[6] * a.y + te[10] * a.z + te[14] * a.w;\r\n\r\n\t\tv.w = ( a.w ) ? te[3] * a.x + te[7] * a.y + te[11] * a.z + te[15] * a.w : 1;\r\n\r\n\t\treturn v;\r\n\r\n\t},\r\n\r\n\tdeterminant: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];\r\n\t\tvar n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];\r\n\t\tvar n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];\r\n\t\tvar n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];\r\n\r\n\t\t//TODO: make this more efficient\r\n\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\r\n\r\n\t\treturn (\r\n\t\t\tn41 * (\r\n\t\t\t\t+n14 * n23 * n32\r\n\t\t\t\t-n13 * n24 * n32\r\n\t\t\t\t-n14 * n22 * n33\r\n\t\t\t\t+n12 * n24 * n33\r\n\t\t\t\t+n13 * n22 * n34\r\n\t\t\t\t-n12 * n23 * n34\r\n\t\t\t) +\r\n\t\t\tn42 * (\r\n\t\t\t\t+n11 * n23 * n34\r\n\t\t\t\t-n11 * n24 * n33\r\n\t\t\t\t+n14 * n21 * n33\r\n\t\t\t\t-n13 * n21 * n34\r\n\t\t\t\t+n13 * n24 * n31\r\n\t\t\t\t-n14 * n23 * n31\r\n\t\t\t) +\r\n\t\t\tn43 * (\r\n\t\t\t\t+n11 * n24 * n32\r\n\t\t\t\t-n11 * n22 * n34\r\n\t\t\t\t-n14 * n21 * n32\r\n\t\t\t\t+n12 * n21 * n34\r\n\t\t\t\t+n14 * n22 * n31\r\n\t\t\t\t-n12 * n24 * n31\r\n\t\t\t) +\r\n\t\t\tn44 * (\r\n\t\t\t\t-n13 * n22 * n31\r\n\t\t\t\t-n11 * n23 * n32\r\n\t\t\t\t+n11 * n22 * n33\r\n\t\t\t\t+n13 * n21 * n32\r\n\t\t\t\t-n12 * n21 * n33\r\n\t\t\t\t+n12 * n23 * n31\r\n\t\t\t)\r\n\r\n\t\t);\r\n\r\n\t},\r\n\r\n\ttranspose: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar tmp;\r\n\r\n\t\ttmp = te[1]; te[1] = te[4]; te[4] = tmp;\r\n\t\ttmp = te[2]; te[2] = te[8]; te[8] = tmp;\r\n\t\ttmp = te[6]; te[6] = te[9]; te[9] = tmp;\r\n\r\n\t\ttmp = te[3]; te[3] = te[12]; te[12] = tmp;\r\n\t\ttmp = te[7]; te[7] = te[13]; te[13] = tmp;\r\n\t\ttmp = te[11]; te[11] = te[14]; te[14] = tmp;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tflattenToArray: function ( flat ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tflat[ 0 ] = te[0]; flat[ 1 ] = te[1]; flat[ 2 ] = te[2]; flat[ 3 ] = te[3];\r\n\t\tflat[ 4 ] = te[4]; flat[ 5 ] = te[5]; flat[ 6 ] = te[6]; flat[ 7 ] = te[7];\r\n\t\tflat[ 8 ] = te[8]; flat[ 9 ] = te[9]; flat[ 10 ] = te[10]; flat[ 11 ] = te[11];\r\n\t\tflat[ 12 ] = te[12]; flat[ 13 ] = te[13]; flat[ 14 ] = te[14]; flat[ 15 ] = te[15];\r\n\r\n\t\treturn flat;\r\n\r\n\t},\r\n\r\n\tflattenToArrayOffset: function( flat, offset ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tflat[ offset ] = te[0];\r\n\t\tflat[ offset + 1 ] = te[1];\r\n\t\tflat[ offset + 2 ] = te[2];\r\n\t\tflat[ offset + 3 ] = te[3];\r\n\r\n\t\tflat[ offset + 4 ] = te[4];\r\n\t\tflat[ offset + 5 ] = te[5];\r\n\t\tflat[ offset + 6 ] = te[6];\r\n\t\tflat[ offset + 7 ] = te[7];\r\n\r\n\t\tflat[ offset + 8 ]  = te[8];\r\n\t\tflat[ offset + 9 ]  = te[9];\r\n\t\tflat[ offset + 10 ] = te[10];\r\n\t\tflat[ offset + 11 ] = te[11];\r\n\r\n\t\tflat[ offset + 12 ] = te[12];\r\n\t\tflat[ offset + 13 ] = te[13];\r\n\t\tflat[ offset + 14 ] = te[14];\r\n\t\tflat[ offset + 15 ] = te[15];\r\n\r\n\t\treturn flat;\r\n\r\n\t},\r\n\r\n\tgetPosition: function() {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function () {\r\n\r\n\t\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .getPosition() has been removed. Use Vector3.getPositionFromMatrix( matrix ) instead.' );\r\n\r\n\t\t\tvar te = this.elements;\r\n\t\t\treturn v1.set( te[12], te[13], te[14] );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tsetPosition: function ( v ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[12] = v.x;\r\n\t\tte[13] = v.y;\r\n\t\tte[14] = v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetInverse: function ( m, throwOnInvertible ) {\r\n\r\n\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\r\n\t\tvar te = this.elements;\r\n\t\tvar me = m.elements;\r\n\r\n\t\tvar n11 = me[0], n12 = me[4], n13 = me[8], n14 = me[12];\r\n\t\tvar n21 = me[1], n22 = me[5], n23 = me[9], n24 = me[13];\r\n\t\tvar n31 = me[2], n32 = me[6], n33 = me[10], n34 = me[14];\r\n\t\tvar n41 = me[3], n42 = me[7], n43 = me[11], n44 = me[15];\r\n\r\n\t\tte[0] = n23*n34*n42 - n24*n33*n42 + n24*n32*n43 - n22*n34*n43 - n23*n32*n44 + n22*n33*n44;\r\n\t\tte[4] = n14*n33*n42 - n13*n34*n42 - n14*n32*n43 + n12*n34*n43 + n13*n32*n44 - n12*n33*n44;\r\n\t\tte[8] = n13*n24*n42 - n14*n23*n42 + n14*n22*n43 - n12*n24*n43 - n13*n22*n44 + n12*n23*n44;\r\n\t\tte[12] = n14*n23*n32 - n13*n24*n32 - n14*n22*n33 + n12*n24*n33 + n13*n22*n34 - n12*n23*n34;\r\n\t\tte[1] = n24*n33*n41 - n23*n34*n41 - n24*n31*n43 + n21*n34*n43 + n23*n31*n44 - n21*n33*n44;\r\n\t\tte[5] = n13*n34*n41 - n14*n33*n41 + n14*n31*n43 - n11*n34*n43 - n13*n31*n44 + n11*n33*n44;\r\n\t\tte[9] = n14*n23*n41 - n13*n24*n41 - n14*n21*n43 + n11*n24*n43 + n13*n21*n44 - n11*n23*n44;\r\n\t\tte[13] = n13*n24*n31 - n14*n23*n31 + n14*n21*n33 - n11*n24*n33 - n13*n21*n34 + n11*n23*n34;\r\n\t\tte[2] = n22*n34*n41 - n24*n32*n41 + n24*n31*n42 - n21*n34*n42 - n22*n31*n44 + n21*n32*n44;\r\n\t\tte[6] = n14*n32*n41 - n12*n34*n41 - n14*n31*n42 + n11*n34*n42 + n12*n31*n44 - n11*n32*n44;\r\n\t\tte[10] = n12*n24*n41 - n14*n22*n41 + n14*n21*n42 - n11*n24*n42 - n12*n21*n44 + n11*n22*n44;\r\n\t\tte[14] = n14*n22*n31 - n12*n24*n31 - n14*n21*n32 + n11*n24*n32 + n12*n21*n34 - n11*n22*n34;\r\n\t\tte[3] = n23*n32*n41 - n22*n33*n41 - n23*n31*n42 + n21*n33*n42 + n22*n31*n43 - n21*n32*n43;\r\n\t\tte[7] = n12*n33*n41 - n13*n32*n41 + n13*n31*n42 - n11*n33*n42 - n12*n31*n43 + n11*n32*n43;\r\n\t\tte[11] = n13*n22*n41 - n12*n23*n41 - n13*n21*n42 + n11*n23*n42 + n12*n21*n43 - n11*n22*n43;\r\n\t\tte[15] = n12*n23*n31 - n13*n22*n31 + n13*n21*n32 - n11*n23*n32 - n12*n21*n33 + n11*n22*n33;\r\n\r\n\t\tvar det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 4 ] + me[ 2 ] * te[ 8 ] + me[ 3 ] * te[ 12 ];\r\n\r\n\t\tif ( det == 0 ) {\r\n\r\n\t\t\tvar msg = \"Matrix4.getInverse(): can't invert matrix, determinant is 0\";\r\n\r\n\t\t\tif ( throwOnInvertible || false ) {\r\n\r\n\t\t\t\tthrow new Error( msg ); \r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.warn( msg );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.identity();\r\n\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tthis.multiplyScalar( 1 / det );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcompose: function() {\r\n\r\n\t\tvar mRotation = new THREE.Matrix4(),\r\n\t\t\tmScale = new THREE.Matrix4();\r\n\t\t\r\n\t\treturn function ( translation, rotation, scale ) {\r\n\r\n\t\t\tvar te = this.elements;\r\n\r\n\t\t\tmRotation.identity();\r\n\t\t\tmRotation.setRotationFromQuaternion( rotation );\r\n\r\n\t\t\tmScale.makeScale( scale.x, scale.y, scale.z );\r\n\r\n\t\t\tthis.multiplyMatrices( mRotation, mScale );\r\n\r\n\t\t\tte[12] = translation.x;\r\n\t\t\tte[13] = translation.y;\r\n\t\t\tte[14] = translation.z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tdecompose: function() {\r\n\r\n\t\tvar x = new THREE.Vector3(),\r\n\t\t\ty = new THREE.Vector3(),\r\n\t\t\tz = new THREE.Vector3(),\r\n\t\t\tmatrix = new THREE.Matrix4();\r\n\r\n\t\treturn function ( translation, rotation, scale ) {\r\n\r\n\t\t\tvar te = this.elements;\r\n\r\n\t\t\t// grab the axis vectors\r\n\t\t\tx.set( te[0], te[1], te[2] );\r\n\t\t\ty.set( te[4], te[5], te[6] );\r\n\t\t\tz.set( te[8], te[9], te[10] );\r\n\r\n\t\t\ttranslation = ( translation instanceof THREE.Vector3 ) ? translation : new THREE.Vector3();\r\n\t\t\trotation = ( rotation instanceof THREE.Quaternion ) ? rotation : new THREE.Quaternion();\r\n\t\t\tscale = ( scale instanceof THREE.Vector3 ) ? scale : new THREE.Vector3();\r\n\r\n\t\t\tscale.x = x.length();\r\n\t\t\tscale.y = y.length();\r\n\t\t\tscale.z = z.length();\r\n\r\n\t\t\ttranslation.x = te[12];\r\n\t\t\ttranslation.y = te[13];\r\n\t\t\ttranslation.z = te[14];\r\n\r\n\t\t\t// scale the rotation part\r\n\r\n\t\t\tmatrix.copy( this );\r\n\r\n\t\t\tmatrix.elements[0] /= scale.x;\r\n\t\t\tmatrix.elements[1] /= scale.x;\r\n\t\t\tmatrix.elements[2] /= scale.x;\r\n\r\n\t\t\tmatrix.elements[4] /= scale.y;\r\n\t\t\tmatrix.elements[5] /= scale.y;\r\n\t\t\tmatrix.elements[6] /= scale.y;\r\n\r\n\t\t\tmatrix.elements[8] /= scale.z;\r\n\t\t\tmatrix.elements[9] /= scale.z;\r\n\t\t\tmatrix.elements[10] /= scale.z;\r\n\r\n\t\t\trotation.setFromRotationMatrix( matrix );\r\n\r\n\t\t\treturn [ translation, rotation, scale ];\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\textractPosition: function ( m ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar me = m.elements;\r\n\r\n\t\tte[12] = me[12];\r\n\t\tte[13] = me[13];\r\n\t\tte[14] = me[14];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\textractRotation: function() {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( m ) {\r\n\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar me = m.elements;\r\n\r\n\t\t\tvar scaleX = 1 / v1.set( me[0], me[1], me[2] ).length();\r\n\t\t\tvar scaleY = 1 / v1.set( me[4], me[5], me[6] ).length();\r\n\t\t\tvar scaleZ = 1 / v1.set( me[8], me[9], me[10] ).length();\r\n\r\n\t\t\tte[0] = me[0] * scaleX;\r\n\t\t\tte[1] = me[1] * scaleX;\r\n\t\t\tte[2] = me[2] * scaleX;\r\n\r\n\t\t\tte[4] = me[4] * scaleY;\r\n\t\t\tte[5] = me[5] * scaleY;\r\n\t\t\tte[6] = me[6] * scaleY;\r\n\r\n\t\t\tte[8] = me[8] * scaleZ;\r\n\t\t\tte[9] = me[9] * scaleZ;\r\n\t\t\tte[10] = me[10] * scaleZ;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslate: function ( v ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar x = v.x, y = v.y, z = v.z;\r\n\r\n\t\tte[12] = te[0] * x + te[4] * y + te[8] * z + te[12];\r\n\t\tte[13] = te[1] * x + te[5] * y + te[9] * z + te[13];\r\n\t\tte[14] = te[2] * x + te[6] * y + te[10] * z + te[14];\r\n\t\tte[15] = te[3] * x + te[7] * y + te[11] * z + te[15];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\trotateX: function ( angle ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar m12 = te[4];\r\n\t\tvar m22 = te[5];\r\n\t\tvar m32 = te[6];\r\n\t\tvar m42 = te[7];\r\n\t\tvar m13 = te[8];\r\n\t\tvar m23 = te[9];\r\n\t\tvar m33 = te[10];\r\n\t\tvar m43 = te[11];\r\n\t\tvar c = Math.cos( angle );\r\n\t\tvar s = Math.sin( angle );\r\n\r\n\t\tte[4] = c * m12 + s * m13;\r\n\t\tte[5] = c * m22 + s * m23;\r\n\t\tte[6] = c * m32 + s * m33;\r\n\t\tte[7] = c * m42 + s * m43;\r\n\r\n\t\tte[8] = c * m13 - s * m12;\r\n\t\tte[9] = c * m23 - s * m22;\r\n\t\tte[10] = c * m33 - s * m32;\r\n\t\tte[11] = c * m43 - s * m42;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\trotateY: function ( angle ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar m11 = te[0];\r\n\t\tvar m21 = te[1];\r\n\t\tvar m31 = te[2];\r\n\t\tvar m41 = te[3];\r\n\t\tvar m13 = te[8];\r\n\t\tvar m23 = te[9];\r\n\t\tvar m33 = te[10];\r\n\t\tvar m43 = te[11];\r\n\t\tvar c = Math.cos( angle );\r\n\t\tvar s = Math.sin( angle );\r\n\r\n\t\tte[0] = c * m11 - s * m13;\r\n\t\tte[1] = c * m21 - s * m23;\r\n\t\tte[2] = c * m31 - s * m33;\r\n\t\tte[3] = c * m41 - s * m43;\r\n\r\n\t\tte[8] = c * m13 + s * m11;\r\n\t\tte[9] = c * m23 + s * m21;\r\n\t\tte[10] = c * m33 + s * m31;\r\n\t\tte[11] = c * m43 + s * m41;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\trotateZ: function ( angle ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar m11 = te[0];\r\n\t\tvar m21 = te[1];\r\n\t\tvar m31 = te[2];\r\n\t\tvar m41 = te[3];\r\n\t\tvar m12 = te[4];\r\n\t\tvar m22 = te[5];\r\n\t\tvar m32 = te[6];\r\n\t\tvar m42 = te[7];\r\n\t\tvar c = Math.cos( angle );\r\n\t\tvar s = Math.sin( angle );\r\n\r\n\t\tte[0] = c * m11 + s * m12;\r\n\t\tte[1] = c * m21 + s * m22;\r\n\t\tte[2] = c * m31 + s * m32;\r\n\t\tte[3] = c * m41 + s * m42;\r\n\r\n\t\tte[4] = c * m12 - s * m11;\r\n\t\tte[5] = c * m22 - s * m21;\r\n\t\tte[6] = c * m32 - s * m31;\r\n\t\tte[7] = c * m42 - s * m41;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\trotateByAxis: function ( axis, angle ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\t// optimize by checking axis\r\n\r\n\t\tif ( axis.x === 1 && axis.y === 0 && axis.z === 0 ) {\r\n\r\n\t\t\treturn this.rotateX( angle );\r\n\r\n\t\t} else if ( axis.x === 0 && axis.y === 1 && axis.z === 0 ) {\r\n\r\n\t\t\treturn this.rotateY( angle );\r\n\r\n\t\t} else if ( axis.x === 0 && axis.y === 0 && axis.z === 1 ) {\r\n\r\n\t\t\treturn this.rotateZ( angle );\r\n\r\n\t\t}\r\n\r\n\t\tvar x = axis.x, y = axis.y, z = axis.z;\r\n\t\tvar n = Math.sqrt(x * x + y * y + z * z);\r\n\r\n\t\tx /= n;\r\n\t\ty /= n;\r\n\t\tz /= n;\r\n\r\n\t\tvar xx = x * x, yy = y * y, zz = z * z;\r\n\t\tvar c = Math.cos( angle );\r\n\t\tvar s = Math.sin( angle );\r\n\t\tvar oneMinusCosine = 1 - c;\r\n\t\tvar xy = x * y * oneMinusCosine;\r\n\t\tvar xz = x * z * oneMinusCosine;\r\n\t\tvar yz = y * z * oneMinusCosine;\r\n\t\tvar xs = x * s;\r\n\t\tvar ys = y * s;\r\n\t\tvar zs = z * s;\r\n\r\n\t\tvar r11 = xx + (1 - xx) * c;\r\n\t\tvar r21 = xy + zs;\r\n\t\tvar r31 = xz - ys;\r\n\t\tvar r12 = xy - zs;\r\n\t\tvar r22 = yy + (1 - yy) * c;\r\n\t\tvar r32 = yz + xs;\r\n\t\tvar r13 = xz + ys;\r\n\t\tvar r23 = yz - xs;\r\n\t\tvar r33 = zz + (1 - zz) * c;\r\n\r\n\t\tvar m11 = te[0], m21 = te[1], m31 = te[2], m41 = te[3];\r\n\t\tvar m12 = te[4], m22 = te[5], m32 = te[6], m42 = te[7];\r\n\t\tvar m13 = te[8], m23 = te[9], m33 = te[10], m43 = te[11];\r\n\r\n\t\tte[0] = r11 * m11 + r21 * m12 + r31 * m13;\r\n\t\tte[1] = r11 * m21 + r21 * m22 + r31 * m23;\r\n\t\tte[2] = r11 * m31 + r21 * m32 + r31 * m33;\r\n\t\tte[3] = r11 * m41 + r21 * m42 + r31 * m43;\r\n\r\n\t\tte[4] = r12 * m11 + r22 * m12 + r32 * m13;\r\n\t\tte[5] = r12 * m21 + r22 * m22 + r32 * m23;\r\n\t\tte[6] = r12 * m31 + r22 * m32 + r32 * m33;\r\n\t\tte[7] = r12 * m41 + r22 * m42 + r32 * m43;\r\n\r\n\t\tte[8] = r13 * m11 + r23 * m12 + r33 * m13;\r\n\t\tte[9] = r13 * m21 + r23 * m22 + r33 * m23;\r\n\t\tte[10] = r13 * m31 + r23 * m32 + r33 * m33;\r\n\t\tte[11] = r13 * m41 + r23 * m42 + r33 * m43;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tscale: function ( v ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar x = v.x, y = v.y, z = v.z;\r\n\r\n\t\tte[0] *= x; te[4] *= y; te[8] *= z;\r\n\t\tte[1] *= x; te[5] *= y; te[9] *= z;\r\n\t\tte[2] *= x; te[6] *= y; te[10] *= z;\r\n\t\tte[3] *= x; te[7] *= y; te[11] *= z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetMaxScaleOnAxis: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];\r\n\t\tvar scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];\r\n\t\tvar scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];\r\n\r\n\t\treturn Math.sqrt( Math.max( scaleXSq, Math.max( scaleYSq, scaleZSq ) ) );\r\n\r\n\t},\r\n\r\n\tmakeTranslation: function ( x, y, z ) {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0, x,\r\n\t\t\t0, 1, 0, y,\r\n\t\t\t0, 0, 1, z,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationX: function ( theta ) {\r\n\r\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0,  0, 0,\r\n\t\t\t0, c, -s, 0,\r\n\t\t\t0, s,  c, 0,\r\n\t\t\t0, 0,  0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationY: function ( theta ) {\r\n\r\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t c, 0, s, 0,\r\n\t\t\t 0, 1, 0, 0,\r\n\t\t\t-s, 0, c, 0,\r\n\t\t\t 0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationZ: function ( theta ) {\r\n\r\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tc, -s, 0, 0,\r\n\t\t\ts,  c, 0, 0,\r\n\t\t\t0,  0, 1, 0,\r\n\t\t\t0,  0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationAxis: function ( axis, angle ) {\r\n\r\n\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\r\n\r\n\t\tvar c = Math.cos( angle );\r\n\t\tvar s = Math.sin( angle );\r\n\t\tvar t = 1 - c;\r\n\t\tvar x = axis.x, y = axis.y, z = axis.z;\r\n\t\tvar tx = t * x, ty = t * y;\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\r\n\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\r\n\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\t return this;\r\n\r\n\t},\r\n\r\n\tmakeScale: function ( x, y, z ) {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tx, 0, 0, 0,\r\n\t\t\t0, y, 0, 0,\r\n\t\t\t0, 0, z, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeFrustum: function ( left, right, bottom, top, near, far ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar x = 2 * near / ( right - left );\r\n\t\tvar y = 2 * near / ( top - bottom );\r\n\r\n\t\tvar a = ( right + left ) / ( right - left );\r\n\t\tvar b = ( top + bottom ) / ( top - bottom );\r\n\t\tvar c = - ( far + near ) / ( far - near );\r\n\t\tvar d = - 2 * far * near / ( far - near );\r\n\r\n\t\tte[0] = x;\tte[4] = 0;\tte[8] = a;\tte[12] = 0;\r\n\t\tte[1] = 0;\tte[5] = y;\tte[9] = b;\tte[13] = 0;\r\n\t\tte[2] = 0;\tte[6] = 0;\tte[10] = c;\tte[14] = d;\r\n\t\tte[3] = 0;\tte[7] = 0;\tte[11] = - 1;\tte[15] = 0;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakePerspective: function ( fov, aspect, near, far ) {\r\n\r\n\t\tvar ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );\r\n\t\tvar ymin = - ymax;\r\n\t\tvar xmin = ymin * aspect;\r\n\t\tvar xmax = ymax * aspect;\r\n\r\n\t\treturn this.makeFrustum( xmin, xmax, ymin, ymax, near, far );\r\n\r\n\t},\r\n\r\n\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar w = right - left;\r\n\t\tvar h = top - bottom;\r\n\t\tvar p = far - near;\r\n\r\n\t\tvar x = ( right + left ) / w;\r\n\t\tvar y = ( top + bottom ) / h;\r\n\t\tvar z = ( far + near ) / p;\r\n\r\n\t\tte[0] = 2 / w;\tte[4] = 0;\tte[8] = 0;\tte[12] = -x;\r\n\t\tte[1] = 0;\tte[5] = 2 / h;\tte[9] = 0;\tte[13] = -y;\r\n\t\tte[2] = 0;\tte[6] = 0;\tte[10] = -2/p;\tte[14] = -z;\r\n\t\tte[3] = 0;\tte[7] = 0;\tte[11] = 0;\tte[15] = 1;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\treturn new THREE.Matrix4(\r\n\r\n\t\t\tte[0], te[4], te[8], te[12],\r\n\t\t\tte[1], te[5], te[9], te[13],\r\n\t\t\tte[2], te[6], te[10], te[14],\r\n\t\t\tte[3], te[7], te[11], te[15]\r\n\r\n\t\t);\r\n\r\n\t}\r\n\r\n} );\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Ray = function ( origin, direction ) {\r\n\r\n\tthis.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();\r\n\tthis.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();\r\n\r\n};\r\n\r\nTHREE.extend( THREE.Ray.prototype, {\r\n\r\n\tset: function ( origin, direction ) {\r\n\r\n\t\tthis.origin.copy( origin );\r\n\t\tthis.direction.copy( direction );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( ray ) {\r\n\r\n\t\tthis.origin.copy( ray.origin );\r\n\t\tthis.direction.copy( ray.direction );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tat: function( t, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\treturn result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\r\n\r\n\t},\r\n\r\n\trecast: function() {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( t ) {\r\n\r\n\t\t\tthis.origin.copy( this.at( t, v1 ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclosestPointToPoint: function ( point, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\tresult.subVectors( point, this.origin );\r\n\t\tvar directionDistance = result.dot( this.direction );\r\n\r\n\t\treturn result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function() {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( point ) {\r\n\r\n\t\t\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\r\n\t\t\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\r\n\r\n\t\t\treturn v1.distanceTo( point );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tisIntersectionSphere: function( sphere ) {\r\n\r\n\t\treturn ( this.distanceToPoint( sphere.center ) <= sphere.radius );\r\n\r\n\t},\r\n\r\n\tisIntersectionPlane: function ( plane ) {\r\n\r\n\t\t// check if the line and plane are non-perpendicular, if they\r\n\t\t// eventually they will intersect.\r\n\t\tvar denominator = plane.normal.dot( this.direction );\r\n\t\tif ( denominator != 0 ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\t// line is coplanar, return origin\r\n\t\tif( plane.distanceToPoint( this.origin ) == 0 ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t},\r\n\r\n\tdistanceToPlane: function ( plane ) {\r\n\r\n\t\tvar denominator = plane.normal.dot( this.direction );\r\n\t\tif ( denominator == 0 ) {\r\n\r\n\t\t\t// line is coplanar, return origin\r\n\t\t\tif( plane.distanceToPoint( this.origin ) == 0 ) {\r\n\r\n\t\t\t\treturn 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Unsure if this is the correct method to handle this case.\r\n\t\t\treturn undefined;\r\n\r\n\t\t}\r\n\r\n\t\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\r\n\r\n\t\treturn t;\r\n\r\n\t},\r\n\r\n\tintersectPlane: function ( plane, optionalTarget ) {\r\n\r\n\t\tvar t = this.distanceToPlane( plane );\r\n\r\n\t\tif ( t === undefined ) {\r\n\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\r\n\t\treturn this.at( t, optionalTarget );\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function ( matrix4 ) {\r\n\r\n\t\tthis.direction.add( this.origin ).applyMatrix4( matrix4 );\r\n\t\tthis.origin.applyMatrix4( matrix4 );\r\n\t\tthis.direction.sub( this.origin );\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tequals: function ( ray ) {\r\n\r\n\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Ray().copy( this );\r\n\r\n\t}\r\n\r\n} );\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Sphere = function ( center, radius ) {\r\n\r\n\tthis.center = ( center !== undefined ) ? center : new THREE.Vector3();\r\n\tthis.radius = ( radius !== undefined ) ? radius : 0;\r\n\r\n};\r\n\r\nTHREE.extend( THREE.Sphere.prototype, {\r\n\r\n\tset: function ( center, radius ) {\r\n\r\n\t\tthis.center.copy( center );\r\n\t\tthis.radius = radius;\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetFromCenterAndPoints: function ( center, points ) {\r\n\r\n\t\tvar maxRadiusSq = 0;\r\n\r\n\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar radiusSq = center.distanceToSquared( points[ i ] );\r\n\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, radiusSq );\r\n\r\n\t\t}\r\n\r\n\t\tthis.center = center;\r\n\t\tthis.radius = Math.sqrt( maxRadiusSq );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( sphere ) {\r\n\r\n\t\tthis.center.copy( sphere.center );\r\n\t\tthis.radius = sphere.radius;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tempty: function () {\r\n\r\n\t\treturn ( this.radius <= 0 );\r\n\r\n\t},\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function ( point ) {\r\n\r\n\t\treturn ( point.distanceTo( this.center ) - this.radius );\r\n\r\n\t},\r\n\r\n\tintersectsSphere: function ( sphere ) {\r\n\r\n\t\tvar radiusSum = this.radius + sphere.radius;\r\n\r\n\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\r\n\r\n\t},\r\n\r\n\tclampPoint: function ( point, optionalTarget ) {\r\n\r\n\t\tvar deltaLengthSq = this.center.distanceToSquared( point );\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\tresult.copy( point );\r\n\r\n\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\r\n\r\n\t\t\tresult.sub( this.center ).normalize();\r\n\t\t\tresult.multiplyScalar( this.radius ).add( this.center );\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t},\r\n\r\n\tgetBoundingBox: function ( optionalTarget ) {\r\n\r\n\t\tvar box = optionalTarget || new THREE.Box3();\r\n\r\n\t\tbox.set( this.center, this.center );\r\n\t\tbox.expandByScalar( this.radius );\r\n\r\n\t\treturn box;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function ( matrix ) {\r\n\r\n\t\tthis.center.applyMatrix4( matrix );\r\n\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttranslate: function ( offset ) {\r\n\r\n\t\tthis.center.add( offset );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( sphere ) {\r\n\r\n\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Sphere().copy( this );\r\n\r\n\t}\r\n\r\n} );\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {\r\n\r\n\tthis.planes = [\r\n\r\n\t\t( p0 !== undefined ) ? p0 : new THREE.Plane(),\r\n\t\t( p1 !== undefined ) ? p1 : new THREE.Plane(),\r\n\t\t( p2 !== undefined ) ? p2 : new THREE.Plane(),\r\n\t\t( p3 !== undefined ) ? p3 : new THREE.Plane(),\r\n\t\t( p4 !== undefined ) ? p4 : new THREE.Plane(),\r\n\t\t( p5 !== undefined ) ? p5 : new THREE.Plane()\r\n\r\n\t];\r\n\r\n};\r\n\r\nTHREE.extend( THREE.Frustum.prototype, {\r\n\r\n\tset: function ( p0, p1, p2, p3, p4, p5 ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\r\n\t\tplanes[0].copy( p0 );\r\n\t\tplanes[1].copy( p1 );\r\n\t\tplanes[2].copy( p2 );\r\n\t\tplanes[3].copy( p3 );\r\n\t\tplanes[4].copy( p4 );\r\n\t\tplanes[5].copy( p5 );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( frustum ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\r\n\t\tfor( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tplanes[i].copy( frustum.planes[i] );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromMatrix: function ( m ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\t\tvar me = m.elements;\r\n\t\tvar me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];\r\n\t\tvar me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];\r\n\t\tvar me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];\r\n\t\tvar me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];\r\n\r\n\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\r\n\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\r\n\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\r\n\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\r\n\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\r\n\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tintersectsObject: function () {\r\n\r\n\t\tvar center = new THREE.Vector3();\r\n\r\n\t\treturn function ( object ) {\r\n\r\n\t\t\t// this method is expanded inlined for performance reasons.\r\n\r\n\t\t\tvar matrix = object.matrixWorld;\r\n\t\t\tvar planes = this.planes;\r\n\t\t\tvar negRadius = - object.geometry.boundingSphere.radius * matrix.getMaxScaleOnAxis();\r\n\r\n\t\t\tcenter.getPositionFromMatrix( matrix );\r\n\r\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\tvar distance = planes[ i ].distanceToPoint( center );\r\n\r\n\t\t\t\tif ( distance < negRadius ) {\r\n\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersectsSphere: function ( sphere ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\t\tvar center = sphere.center;\r\n\t\tvar negRadius = -sphere.radius;\r\n\r\n\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tvar distance = planes[ i ].distanceToPoint( center );\r\n\r\n\t\t\tif ( distance < negRadius ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\r\n\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Frustum().copy( this );\r\n\r\n\t}\r\n\r\n} );\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Plane = function ( normal, constant ) {\r\n\r\n\tthis.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );\r\n\tthis.constant = ( constant !== undefined ) ? constant : 0;\r\n\r\n};\r\n\r\nTHREE.extend( THREE.Plane.prototype, {\r\n\r\n\tset: function ( normal, constant ) {\r\n\r\n\t\tthis.normal.copy( normal );\r\n\t\tthis.constant = constant;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetComponents: function ( x, y, z, w ) {\r\n\r\n\t\tthis.normal.set( x, y, z );\r\n\t\tthis.constant = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\r\n\r\n\t\tthis.normal.copy( normal );\r\n\t\tthis.constant = - point.dot( this.normal );\t// must be this.normal, not normal, as this.normal is normalized\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromCoplanarPoints: function() {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\tvar v2 = new THREE.Vector3();\r\n\r\n\t\treturn function ( a, b, c ) {\r\n\r\n\t\t\tvar normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\r\n\r\n\t\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\r\n\r\n\t\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\r\n\tcopy: function ( plane ) {\r\n\r\n\t\tthis.normal.copy( plane.normal );\r\n\t\tthis.constant = plane.constant;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\t// Note: will lead to a divide by zero if the plane is invalid.\r\n\r\n\t\tvar inverseNormalLength = 1.0 / this.normal.length();\r\n\t\tthis.normal.multiplyScalar( inverseNormalLength );\r\n\t\tthis.constant *= inverseNormalLength;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnegate: function () {\r\n\r\n\t\tthis.constant *= -1;\r\n\t\tthis.normal.negate();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function ( point ) {\r\n\r\n\t\treturn this.normal.dot( point ) + this.constant;\r\n\r\n\t},\r\n\r\n\tdistanceToSphere: function ( sphere ) {\r\n\r\n\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\r\n\r\n\t},\r\n\r\n\tprojectPoint: function ( point, optionalTarget ) {\r\n\r\n\t\treturn this.orthoPoint( point, optionalTarget ).sub( point ).negate();\r\n\r\n\t},\r\n\r\n\torthoPoint: function ( point, optionalTarget ) {\r\n\r\n\t\tvar perpendicularMagnitude = this.distanceToPoint( point );\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );\r\n\r\n\t},\r\n\r\n\tisIntersectionLine: function ( line ) {\r\n\r\n\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\r\n\r\n\t\tvar startSign = this.distanceToPoint( line.start );\r\n\t\tvar endSign = this.distanceToPoint( line.end );\r\n\r\n\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\r\n\r\n\t},\r\n\r\n\tintersectLine: function() {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( line, optionalTarget ) {\r\n\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\t\tvar direction = line.delta( v1 );\r\n\r\n\t\t\tvar denominator = this.normal.dot( direction );\r\n\r\n\t\t\tif ( denominator == 0 ) {\r\n\r\n\t\t\t\t// line is coplanar, return origin\r\n\t\t\t\tif( this.distanceToPoint( line.start ) == 0 ) {\r\n\r\n\t\t\t\t\treturn result.copy( line.start );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Unsure if this is the correct method to handle this case.\r\n\t\t\t\treturn undefined;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\r\n\r\n\t\t\tif( t < 0 || t > 1 ) {\r\n\r\n\t\t\t\treturn undefined;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn result.copy( direction ).multiplyScalar( t ).add( line.start );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\r\n\tcoplanarPoint: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.copy( this.normal ).multiplyScalar( - this.constant );\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function() {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\tvar v2 = new THREE.Vector3();\r\n\r\n\t\treturn function ( matrix, optionalNormalMatrix ) {\r\n\r\n\t\t\t// compute new normal based on theory here:\r\n\t\t\t// http://www.songho.ca/opengl/gl_normaltransform.html\r\n\t\t\toptionalNormalMatrix = optionalNormalMatrix || new THREE.Matrix3().getInverse( matrix ).transpose();\r\n\t\t\tvar newNormal = v1.copy( this.normal ).applyMatrix3( optionalNormalMatrix );\r\n\r\n\t\t\tvar newCoplanarPoint = this.coplanarPoint( v2 );\r\n\t\t\tnewCoplanarPoint.applyMatrix4( matrix );\r\n\r\n\t\t\tthis.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslate: function ( offset ) {\r\n\r\n\t\tthis.constant = this.constant - offset.dot( this.normal );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( plane ) {\r\n\r\n\t\treturn plane.normal.equals( this.normal ) && ( plane.constant == this.constant );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Plane().copy( this );\r\n\r\n\t}\r\n\r\n} );\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Math = {\r\n\r\n\t// Clamp value to range <a, b>\r\n\r\n\tclamp: function ( x, a, b ) {\r\n\r\n\t\treturn ( x < a ) ? a : ( ( x > b ) ? b : x );\r\n\r\n\t},\r\n\r\n\t// Clamp value to range <a, inf)\r\n\r\n\tclampBottom: function ( x, a ) {\r\n\r\n\t\treturn x < a ? a : x;\r\n\r\n\t},\r\n\r\n\t// Linear mapping from range <a1, a2> to range <b1, b2>\r\n\r\n\tmapLinear: function ( x, a1, a2, b1, b2 ) {\r\n\r\n\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\r\n\r\n\t},\r\n\r\n\t// http://en.wikipedia.org/wiki/Smoothstep\r\n\r\n\tsmoothstep: function ( x, min, max ) {\r\n\r\n\t\tif ( x <= min ) return 0;\r\n\t\tif ( x >= max ) return 1;\r\n\r\n\t\tx = ( x - min )/( max - min );\r\n\r\n\t\treturn x*x*(3 - 2*x);\r\n\r\n\t},\r\n\r\n\tsmootherstep: function ( x, min, max ) {\r\n\r\n\t\tif ( x <= min ) return 0;\r\n\t\tif ( x >= max ) return 1;\r\n\r\n\t\tx = ( x - min )/( max - min );\r\n\r\n\t\treturn x*x*x*(x*(x*6 - 15) + 10);\r\n\r\n\t},\r\n\r\n\t// Random float from <0, 1> with 16 bits of randomness\r\n\t// (standard Math.random() creates repetitive patterns when applied over larger space)\r\n\r\n\trandom16: function () {\r\n\r\n\t\treturn ( 65280 * Math.random() + 255 * Math.random() ) / 65535;\r\n\r\n\t},\r\n\r\n\t// Random integer from <low, high> interval\r\n\r\n\trandInt: function ( low, high ) {\r\n\r\n\t\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\r\n\r\n\t},\r\n\r\n\t// Random float from <low, high> interval\r\n\r\n\trandFloat: function ( low, high ) {\r\n\r\n\t\treturn low + Math.random() * ( high - low );\r\n\r\n\t},\r\n\r\n\t// Random float from <-range/2, range/2> interval\r\n\r\n\trandFloatSpread: function ( range ) {\r\n\r\n\t\treturn range * ( 0.5 - Math.random() );\r\n\r\n\t},\r\n\r\n\tsign: function ( x ) {\r\n\r\n\t\treturn ( x < 0 ) ? -1 : ( ( x > 0 ) ? 1 : 0 );\r\n\r\n\t},\r\n\r\n\tdegToRad: function() {\r\n\r\n\t\tvar degreeToRadiansFactor = Math.PI / 180;\r\n\r\n\t\treturn function ( degrees ) {\r\n\r\n\t\t\treturn degrees * degreeToRadiansFactor;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tradToDeg: function() {\r\n\r\n\t\tvar radianToDegreesFactor = 180 / Math.PI;\r\n\r\n\t\treturn function ( radians ) {\r\n\r\n\t\t\treturn radians * radianToDegreesFactor;\r\n\r\n\t\t};\r\n\r\n\t}()\r\n\r\n};\r\n/**\r\n * Spline from Tween.js, slightly optimized (and trashed)\r\n * http://sole.github.com/tween.js/examples/05_spline.html\r\n *\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Spline = function ( points ) {\r\n\r\n\tthis.points = points;\r\n\r\n\tvar c = [], v3 = { x: 0, y: 0, z: 0 },\r\n\tpoint, intPoint, weight, w2, w3,\r\n\tpa, pb, pc, pd;\r\n\r\n\tthis.initFromArray = function( a ) {\r\n\r\n\t\tthis.points = [];\r\n\r\n\t\tfor ( var i = 0; i < a.length; i++ ) {\r\n\r\n\t\t\tthis.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.getPoint = function ( k ) {\r\n\r\n\t\tpoint = ( this.points.length - 1 ) * k;\r\n\t\tintPoint = Math.floor( point );\r\n\t\tweight = point - intPoint;\r\n\r\n\t\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\r\n\t\tc[ 1 ] = intPoint;\r\n\t\tc[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;\r\n\t\tc[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;\r\n\r\n\t\tpa = this.points[ c[ 0 ] ];\r\n\t\tpb = this.points[ c[ 1 ] ];\r\n\t\tpc = this.points[ c[ 2 ] ];\r\n\t\tpd = this.points[ c[ 3 ] ];\r\n\r\n\t\tw2 = weight * weight;\r\n\t\tw3 = weight * w2;\r\n\r\n\t\tv3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );\r\n\t\tv3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );\r\n\t\tv3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );\r\n\r\n\t\treturn v3;\r\n\r\n\t};\r\n\r\n\tthis.getControlPointsArray = function () {\r\n\r\n\t\tvar i, p, l = this.points.length,\r\n\t\t\tcoords = [];\r\n\r\n\t\tfor ( i = 0; i < l; i ++ ) {\r\n\r\n\t\t\tp = this.points[ i ];\r\n\t\t\tcoords[ i ] = [ p.x, p.y, p.z ];\r\n\r\n\t\t}\r\n\r\n\t\treturn coords;\r\n\r\n\t};\r\n\r\n\t// approximate length by summing linear segments\r\n\r\n\tthis.getLength = function ( nSubDivisions ) {\r\n\r\n\t\tvar i, index, nSamples, position,\r\n\t\t\tpoint = 0, intPoint = 0, oldIntPoint = 0,\r\n\t\t\toldPosition = new THREE.Vector3(),\r\n\t\t\ttmpVec = new THREE.Vector3(),\r\n\t\t\tchunkLengths = [],\r\n\t\t\ttotalLength = 0;\r\n\r\n\t\t// first point has 0 length\r\n\r\n\t\tchunkLengths[ 0 ] = 0;\r\n\r\n\t\tif ( !nSubDivisions ) nSubDivisions = 100;\r\n\r\n\t\tnSamples = this.points.length * nSubDivisions;\r\n\r\n\t\toldPosition.copy( this.points[ 0 ] );\r\n\r\n\t\tfor ( i = 1; i < nSamples; i ++ ) {\r\n\r\n\t\t\tindex = i / nSamples;\r\n\r\n\t\t\tposition = this.getPoint( index );\r\n\t\t\ttmpVec.copy( position );\r\n\r\n\t\t\ttotalLength += tmpVec.distanceTo( oldPosition );\r\n\r\n\t\t\toldPosition.copy( position );\r\n\r\n\t\t\tpoint = ( this.points.length - 1 ) * index;\r\n\t\t\tintPoint = Math.floor( point );\r\n\r\n\t\t\tif ( intPoint != oldIntPoint ) {\r\n\r\n\t\t\t\tchunkLengths[ intPoint ] = totalLength;\r\n\t\t\t\toldIntPoint = intPoint;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// last point ends with total length\r\n\r\n\t\tchunkLengths[ chunkLengths.length ] = totalLength;\r\n\r\n\t\treturn { chunks: chunkLengths, total: totalLength };\r\n\r\n\t};\r\n\r\n\tthis.reparametrizeByArcLength = function ( samplingCoef ) {\r\n\r\n\t\tvar i, j,\r\n\t\t\tindex, indexCurrent, indexNext,\r\n\t\t\tlinearDistance, realDistance,\r\n\t\t\tsampling, position,\r\n\t\t\tnewpoints = [],\r\n\t\t\ttmpVec = new THREE.Vector3(),\r\n\t\t\tsl = this.getLength();\r\n\r\n\t\tnewpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );\r\n\r\n\t\tfor ( i = 1; i < this.points.length; i++ ) {\r\n\r\n\t\t\t//tmpVec.copy( this.points[ i - 1 ] );\r\n\t\t\t//linearDistance = tmpVec.distanceTo( this.points[ i ] );\r\n\r\n\t\t\trealDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];\r\n\r\n\t\t\tsampling = Math.ceil( samplingCoef * realDistance / sl.total );\r\n\r\n\t\t\tindexCurrent = ( i - 1 ) / ( this.points.length - 1 );\r\n\t\t\tindexNext = i / ( this.points.length - 1 );\r\n\r\n\t\t\tfor ( j = 1; j < sampling - 1; j++ ) {\r\n\r\n\t\t\t\tindex = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );\r\n\r\n\t\t\t\tposition = this.getPoint( index );\r\n\t\t\t\tnewpoints.push( tmpVec.copy( position ).clone() );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tnewpoints.push( tmpVec.copy( this.points[ i ] ).clone() );\r\n\r\n\t\t}\r\n\r\n\t\tthis.points = newpoints;\r\n\r\n\t};\r\n\r\n\t// Catmull-Rom\r\n\r\n\tfunction interpolate( p0, p1, p2, p3, t, t2, t3 ) {\r\n\r\n\t\tvar v0 = ( p2 - p0 ) * 0.5,\r\n\t\t\tv1 = ( p3 - p1 ) * 0.5;\r\n\r\n\t\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\r\n\t};\r\n\r\n};\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Triangle = function ( a, b, c ) {\r\n\r\n\tthis.a = ( a !== undefined ) ? a : new THREE.Vector3();\r\n\tthis.b = ( b !== undefined ) ? b : new THREE.Vector3();\r\n\tthis.c = ( c !== undefined ) ? c : new THREE.Vector3();\r\n\r\n};\r\n\r\nTHREE.Triangle.normal = function() {\r\n\r\n\tvar v0 = new THREE.Vector3();\r\n\r\n\treturn function( a, b, c, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\tresult.subVectors( c, b );\r\n\t\tv0.subVectors( a, b );\r\n\t\tresult.cross( v0 );\r\n\r\n\t\tvar resultLengthSq = result.lengthSq();\r\n\t\tif( resultLengthSq > 0 ) {\r\n\r\n\t\t\treturn result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn result.set( 0, 0, 0 );\r\n\r\n\t};\r\n\r\n}();\r\n\r\n// static/instance method to calculate barycoordinates\r\n// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\r\nTHREE.Triangle.barycoordFromPoint = function() {\r\n\r\n\tvar v0 = new THREE.Vector3(),\r\n\t\tv1 = new THREE.Vector3(),\r\n\t\tv2 = new THREE.Vector3();\r\n\r\n\treturn function ( point, a, b, c, optionalTarget ) {\r\n\r\n\t\tv0.subVectors( c, a );\r\n\t\tv1.subVectors( b, a );\r\n\t\tv2.subVectors( point, a );\r\n\r\n\t\tvar dot00 = v0.dot( v0 );\r\n\t\tvar dot01 = v0.dot( v1 );\r\n\t\tvar dot02 = v0.dot( v2 );\r\n\t\tvar dot11 = v1.dot( v1 );\r\n\t\tvar dot12 = v1.dot( v2 );\r\n\r\n\t\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\t// colinear or singular triangle\r\n\t\tif( denom == 0 ) {\r\n\t\t\t// arbitrary location outside of triangle?\r\n\t\t\t// not sure if this is the best idea, maybe should be returning undefined\r\n\t\t\treturn result.set( -2, -1, -1 );\r\n\t\t}\r\n\r\n\t\tvar invDenom = 1 / denom;\r\n\t\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\r\n\t\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\r\n\r\n\t\t// barycoordinates must always sum to 1\r\n\t\treturn result.set( 1 - u - v, v, u );\r\n\r\n\t};\r\n\r\n}();\r\n\r\nTHREE.Triangle.containsPoint = function() {\r\n\r\n\tvar v1 = new THREE.Vector3();\r\n\r\n\treturn function ( point, a, b, c ) {\r\n\r\n\t\tvar result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );\r\n\r\n\t\treturn ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );\r\n\r\n\t};\r\n\r\n}();\r\n\r\nTHREE.extend( THREE.Triangle.prototype, {\r\n\r\n\tconstructor: THREE.Triangle,\r\n\r\n\tset: function ( a, b, c ) {\r\n\r\n\t\tthis.a.copy( a );\r\n\t\tthis.b.copy( b );\r\n\t\tthis.c.copy( c );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\r\n\r\n\t\tthis.a.copy( points[i0] );\r\n\t\tthis.b.copy( points[i1] );\r\n\t\tthis.c.copy( points[i2] );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( triangle ) {\r\n\r\n\t\tthis.a.copy( triangle.a );\r\n\t\tthis.b.copy( triangle.b );\r\n\t\tthis.c.copy( triangle.c );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tarea: function() {\r\n\r\n\t\tvar v0 = new THREE.Vector3();\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function () {\r\n\r\n\t\t\tv0.subVectors( this.c, this.b );\r\n\t\t\tv1.subVectors( this.a, this.b );\r\n\r\n\t\t\treturn v0.cross( v1 ).length() * 0.5;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmidpoint: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\r\n\r\n\t},\r\n\r\n\tnormal: function ( optionalTarget ) {\r\n\r\n\t\treturn THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );\r\n\r\n\t},\r\n\r\n\tplane: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Plane();\r\n\r\n\t\treturn result.setFromCoplanarPoints( this.a, this.b, this.c );\r\n\r\n\t},\r\n\r\n\tbarycoordFromPoint: function ( point, optionalTarget ) {\r\n\r\n\t\treturn THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );\r\n\r\n\t},\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\treturn THREE.Triangle.containsPoint( point, this.a, this.b, this.c );\r\n\r\n\t},\r\n\r\n\tequals: function ( triangle ) {\r\n\r\n\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Triangle().copy( this );\r\n\r\n\t}\r\n\r\n} );\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Vertex = function ( v ) {\r\n\r\n\tconsole.warn( 'THREE.Vertex has been DEPRECATED. Use THREE.Vector3 instead.')\r\n\treturn v;\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.UV = function ( u, v ) {\r\n\r\n\tconsole.warn( 'THREE.UV has been DEPRECATED. Use THREE.Vector2 instead.')\r\n\treturn new THREE.Vector2( u, v );\r\n\r\n};\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Clock = function ( autoStart ) {\r\n\r\n\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\r\n\r\n\tthis.startTime = 0;\r\n\tthis.oldTime = 0;\r\n\tthis.elapsedTime = 0;\r\n\r\n\tthis.running = false;\r\n\r\n};\r\n\r\nTHREE.extend( THREE.Clock.prototype, {\r\n\r\n\tstart: function () {\r\n\r\n\t\tthis.startTime = window.performance !== undefined && window.performance.now !== undefined\r\n\t\t\t\t\t? window.performance.now()\r\n\t\t\t\t\t: Date.now();\r\n\r\n\t\tthis.oldTime = this.startTime;\r\n\t\tthis.running = true;\r\n\t},\r\n\r\n\tstop: function () {\r\n\r\n\t\tthis.getElapsedTime();\r\n\t\tthis.running = false;\r\n\r\n\t},\r\n\r\n\tgetElapsedTime: function () {\r\n\r\n\t\tthis.getDelta();\r\n\t\treturn this.elapsedTime;\r\n\r\n\t},\r\n\r\n\tgetDelta: function () {\r\n\r\n\t\tvar diff = 0;\r\n\r\n\t\tif ( this.autoStart && ! this.running ) {\r\n\r\n\t\t\tthis.start();\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.running ) {\r\n\r\n\t\t\tvar newTime = window.performance !== undefined && window.performance.now !== undefined\r\n\t\t\t\t\t? window.performance.now()\r\n\t\t\t\t\t: Date.now();\r\n\r\n\t\t\tdiff = 0.001 * ( newTime - this.oldTime );\r\n\t\t\tthis.oldTime = newTime;\r\n\r\n\t\t\tthis.elapsedTime += diff;\r\n\r\n\t\t}\r\n\r\n\t\treturn diff;\r\n\r\n\t}\r\n\r\n} );\r\n/**\r\n * https://github.com/mrdoob/eventdispatcher.js/\r\n */\r\n\r\nTHREE.EventDispatcher = function () {\r\n\r\n\tvar listeners = {};\r\n\r\n\tthis.addEventListener = function ( type, listener ) {\r\n\r\n\t\tif ( listeners[ type ] === undefined ) {\r\n\r\n\t\t\tlisteners[ type ] = [];\r\n\r\n\t\t}\r\n\r\n\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\r\n\r\n\t\t\tlisteners[ type ].push( listener );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.removeEventListener = function ( type, listener ) {\r\n\r\n\t\tvar index = listeners[ type ].indexOf( listener );\r\n\r\n\t\tif ( index !== - 1 ) {\r\n\r\n\t\t\tlisteners[ type ].splice( index, 1 );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.dispatchEvent = function ( event ) {\r\n\r\n\t\tvar listenerArray = listeners[ event.type ];\r\n\r\n\t\tif ( listenerArray !== undefined ) {\r\n\r\n\t\t\tevent.target = this;\r\n\r\n\t\t\tfor ( var i = 0, l = listenerArray.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tlistenerArray[ i ].call( this, event );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author bhouston / http://exocortex.com/\r\n */\r\n\r\n( function ( THREE ) {\r\n\r\n\tTHREE.Raycaster = function ( origin, direction, near, far ) {\r\n\r\n\t\tthis.ray = new THREE.Ray( origin, direction );\r\n\r\n\t\t// normalized ray.direction required for accurate distance calculations\r\n\t\tif( this.ray.direction.lengthSq() > 0 ) {\r\n\r\n\t\t\tthis.ray.direction.normalize();\r\n\r\n\t\t}\r\n\r\n\t\tthis.near = near || 0;\r\n\t\tthis.far = far || Infinity;\r\n\r\n\t};\r\n\r\n\tvar sphere = new THREE.Sphere();\r\n\tvar localRay = new THREE.Ray();\r\n\tvar facePlane = new THREE.Plane();\r\n\tvar intersectPoint = new THREE.Vector3();\r\n\tvar matrixPosition = new THREE.Vector3();\r\n\r\n\tvar inverseMatrix = new THREE.Matrix4();\r\n\r\n\tvar descSort = function ( a, b ) {\r\n\r\n\t\treturn a.distance - b.distance;\r\n\r\n\t};\r\n\r\n\tvar intersectObject = function ( object, raycaster, intersects ) {\r\n\r\n\t\tif ( object instanceof THREE.Particle ) {\r\n\r\n\t\t\tmatrixPosition.getPositionFromMatrix( object.matrixWorld );\r\n\t\t\tvar distance = raycaster.ray.distanceToPoint( matrixPosition );\r\n\r\n\t\t\tif ( distance > object.scale.x ) {\r\n\r\n\t\t\t\treturn intersects;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tintersects.push( {\r\n\r\n\t\t\t\tdistance: distance,\r\n\t\t\t\tpoint: object.position,\r\n\t\t\t\tface: null,\r\n\t\t\t\tobject: object\r\n\r\n\t\t\t} );\r\n\r\n\t\t} else if ( object instanceof THREE.Mesh ) {\r\n\r\n\t\t\t// Checking boundingSphere distance to ray\r\n\t\t\tmatrixPosition.getPositionFromMatrix( object.matrixWorld );\r\n\t\t\tsphere.set(\r\n\t\t\t\tmatrixPosition,\r\n\t\t\t\tobject.geometry.boundingSphere.radius * object.matrixWorld.getMaxScaleOnAxis() );\r\n\r\n\t\t\tif ( ! raycaster.ray.isIntersectionSphere( sphere ) ) {\r\n\r\n\t\t\t\treturn intersects;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Checking faces\r\n\r\n\t\t\tvar geometry = object.geometry;\r\n\t\t\tvar vertices = geometry.vertices;\r\n\r\n\t\t\tvar isFaceMaterial = object.material instanceof THREE.MeshFaceMaterial;\r\n\t\t\tvar objectMaterials = isFaceMaterial === true ? object.material.materials : null;\r\n\r\n\t\t\tvar side = object.material.side;\r\n\r\n\t\t\tvar a, b, c, d;\r\n\t\t\tvar precision = raycaster.precision;\r\n\r\n\t\t\tobject.matrixRotationWorld.extractRotation( object.matrixWorld );\r\n\r\n\t\t\tinverseMatrix.getInverse( object.matrixWorld );\r\n\r\n\t\t\tlocalRay.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\r\n\t\t\tfor ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tvar face = geometry.faces[ f ];\r\n\r\n\t\t\t\tvar material = isFaceMaterial === true ? objectMaterials[ face.materialIndex ] : object.material;\r\n\r\n\t\t\t\tif ( material === undefined ) continue;\r\n\r\n\t\t\t\tfacePlane.setFromNormalAndCoplanarPoint( face.normal, vertices[face.a] );\r\n\r\n\t\t\t\tvar planeDistance = localRay.distanceToPlane( facePlane );\r\n\r\n\t\t\t\t// bail if raycaster and plane are parallel\r\n\t\t\t\tif ( Math.abs( planeDistance ) < precision ) continue;\r\n\r\n\t\t\t\t// if negative distance, then plane is behind raycaster\r\n\t\t\t\tif ( planeDistance < 0 ) continue;\r\n\r\n\t\t\t\t// check if we hit the wrong side of a single sided face\r\n\t\t\t\tside = material.side;\r\n\t\t\t\tif( side !== THREE.DoubleSide ) {\r\n\r\n\t\t\t\t\tvar planeSign = localRay.direction.dot( facePlane.normal );\r\n\r\n\t\t\t\t\tif( ! ( side === THREE.FrontSide ? planeSign < 0 : planeSign > 0 ) ) continue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// this can be done using the planeDistance from localRay because localRay wasn't normalized, but ray was\r\n\t\t\t\tif ( planeDistance < raycaster.near || planeDistance > raycaster.far ) continue;\r\n\r\n\t\t\t\tintersectPoint = localRay.at( planeDistance, intersectPoint ); // passing in intersectPoint avoids a copy\r\n\r\n\t\t\t\tif ( face instanceof THREE.Face3 ) {\r\n\r\n\t\t\t\t\ta = vertices[ face.a ];\r\n\t\t\t\t\tb = vertices[ face.b ];\r\n\t\t\t\t\tc = vertices[ face.c ];\r\n\r\n\t\t\t\t\tif ( ! THREE.Triangle.containsPoint( intersectPoint, a, b, c ) ) continue;\r\n\r\n\t\t\t\t} else if ( face instanceof THREE.Face4 ) {\r\n\r\n\t\t\t\t\ta = vertices[ face.a ];\r\n\t\t\t\t\tb = vertices[ face.b ];\r\n\t\t\t\t\tc = vertices[ face.c ];\r\n\t\t\t\t\td = vertices[ face.d ];\r\n\r\n\t\t\t\t\tif ( ( ! THREE.Triangle.containsPoint( intersectPoint, a, b, d ) ) &&\r\n\t\t\t\t\t\t ( ! THREE.Triangle.containsPoint( intersectPoint, b, c, d ) ) ) continue;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// This is added because if we call out of this if/else group when none of the cases\r\n\t\t\t\t\t//    match it will add a point to the intersection list erroneously.\r\n\t\t\t\t\tthrow Error( \"face type not supported\" );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tintersects.push( {\r\n\r\n\t\t\t\t\tdistance: planeDistance,\t// this works because the original ray was normalized, and the transformed localRay wasn't\r\n\t\t\t\t\tpoint: raycaster.ray.at( planeDistance ),\r\n\t\t\t\t\tface: face,\r\n\t\t\t\t\tfaceIndex: f,\r\n\t\t\t\t\tobject: object\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar intersectDescendants = function ( object, raycaster, intersects ) {\r\n\r\n\t\tvar descendants = object.getDescendants();\r\n\r\n\t\tfor ( var i = 0, l = descendants.length; i < l; i ++ ) {\r\n\r\n\t\t\tintersectObject( descendants[ i ], raycaster, intersects );\r\n\r\n\t\t}\r\n\t};\r\n\r\n\t//\r\n\r\n\tTHREE.Raycaster.prototype.precision = 0.0001;\r\n\r\n\tTHREE.Raycaster.prototype.set = function ( origin, direction ) {\r\n\r\n\t\tthis.ray.set( origin, direction );\r\n\r\n\t\t// normalized ray.direction required for accurate distance calculations\r\n\t\tif( this.ray.direction.length() > 0 ) {\r\n\r\n\t\t\tthis.ray.direction.normalize();\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tTHREE.Raycaster.prototype.intersectObject = function ( object, recursive ) {\r\n\r\n\t\tvar intersects = [];\r\n\r\n\t\tif ( recursive === true ) {\r\n\r\n\t\t\tintersectDescendants( object, this, intersects );\r\n\r\n\t\t}\r\n\r\n\t\tintersectObject( object, this, intersects );\r\n\r\n\t\tintersects.sort( descSort );\r\n\r\n\t\treturn intersects;\r\n\r\n\t};\r\n\r\n\tTHREE.Raycaster.prototype.intersectObjects = function ( objects, recursive ) {\r\n\r\n\t\tvar intersects = [];\r\n\r\n\t\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\r\n\r\n\t\t\tintersectObject( objects[ i ], this, intersects );\r\n\r\n\t\t\tif ( recursive === true ) {\r\n\r\n\t\t\t\tintersectDescendants( objects[ i ], this, intersects );\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tintersects.sort( descSort );\r\n\r\n\t\treturn intersects;\r\n\r\n\t};\r\n\r\n}( THREE ) );\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Object3D = function () {\r\n\r\n\tthis.id = THREE.Object3DIdCount ++;\r\n\r\n\tthis.name = '';\r\n\tthis.properties = {};\r\n\r\n\tthis.parent = undefined;\r\n\tthis.children = [];\r\n\r\n\tthis.up = new THREE.Vector3( 0, 1, 0 );\r\n\r\n\tthis.position = new THREE.Vector3();\r\n\tthis.rotation = new THREE.Vector3();\r\n\tthis.eulerOrder = THREE.Object3D.defaultEulerOrder;\r\n\tthis.scale = new THREE.Vector3( 1, 1, 1 );\r\n\r\n\tthis.renderDepth = null;\r\n\r\n\tthis.rotationAutoUpdate = true;\r\n\r\n\tthis.matrix = new THREE.Matrix4();\r\n\tthis.matrixWorld = new THREE.Matrix4();\r\n\tthis.matrixRotationWorld = new THREE.Matrix4();\r\n\r\n\tthis.matrixAutoUpdate = true;\r\n\tthis.matrixWorldNeedsUpdate = true;\r\n\r\n\tthis.quaternion = new THREE.Quaternion();\r\n\tthis.useQuaternion = false;\r\n\r\n\tthis.visible = true;\r\n\r\n\tthis.castShadow = false;\r\n\tthis.receiveShadow = false;\r\n\r\n\tthis.frustumCulled = true;\r\n\r\n\tthis._vector = new THREE.Vector3();\r\n\r\n};\r\n\r\n\r\nTHREE.Object3D.prototype = {\r\n\r\n\tconstructor: THREE.Object3D,\r\n\r\n\tapplyMatrix: function ( matrix ) {\r\n\r\n\t\tthis.matrix.multiplyMatrices( matrix, this.matrix );\r\n\r\n\t\tthis.scale.getScaleFromMatrix( this.matrix );\r\n\r\n\t\tvar mat = new THREE.Matrix4().extractRotation( this.matrix );\r\n\t\tthis.rotation.setEulerFromRotationMatrix( mat, this.eulerOrder );\r\n\r\n\t\tthis.position.getPositionFromMatrix( this.matrix );\r\n\r\n\t},\r\n\r\n\ttranslate: function ( distance, axis ) {\r\n\r\n\t\tthis.matrix.rotateAxis( axis );\r\n\t\tthis.position.add( axis.multiplyScalar( distance ) );\r\n\r\n\t},\r\n\r\n\ttranslateX: function ( distance ) {\r\n\r\n\t\tthis.translate( distance, this._vector.set( 1, 0, 0 ) );\r\n\r\n\t},\r\n\r\n\ttranslateY: function ( distance ) {\r\n\r\n\t\tthis.translate( distance, this._vector.set( 0, 1, 0 ) );\r\n\r\n\t},\r\n\r\n\ttranslateZ: function ( distance ) {\r\n\r\n\t\tthis.translate( distance, this._vector.set( 0, 0, 1 ) );\r\n\r\n\t},\r\n\r\n\tlocalToWorld: function ( vector ) {\r\n\r\n\t\treturn vector.applyMatrix4( this.matrixWorld );\r\n\r\n\t},\r\n\r\n\tworldToLocal: function ( vector ) {\r\n\r\n\t\treturn vector.applyMatrix4( THREE.Object3D.__m1.getInverse( this.matrixWorld ) );\r\n\r\n\t},\r\n\r\n\tlookAt: function ( vector ) {\r\n\r\n\t\t// TODO: Add hierarchy support.\r\n\r\n\t\tthis.matrix.lookAt( vector, this.position, this.up );\r\n\r\n\t\tif ( this.rotationAutoUpdate ) {\r\n\r\n\t\t\tif ( this.useQuaternion === false )  {\r\n\r\n\t\t\t\tthis.rotation.setEulerFromRotationMatrix( this.matrix, this.eulerOrder );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.quaternion.copy( this.matrix.decompose()[ 1 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tadd: function ( object ) {\r\n\r\n\t\tif ( object === this ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Object3D.add: An object can\\'t be added as a child of itself.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( object instanceof THREE.Object3D ) {\r\n\r\n\t\t\tif ( object.parent !== undefined ) {\r\n\r\n\t\t\t\tobject.parent.remove( object );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobject.parent = this;\r\n\t\t\tthis.children.push( object );\r\n\r\n\t\t\t// add to scene\r\n\r\n\t\t\tvar scene = this;\r\n\r\n\t\t\twhile ( scene.parent !== undefined ) {\r\n\r\n\t\t\t\tscene = scene.parent;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( scene !== undefined && scene instanceof THREE.Scene )  {\r\n\r\n\t\t\t\tscene.__addObject( object );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tremove: function ( object ) {\r\n\r\n\t\tvar index = this.children.indexOf( object );\r\n\r\n\t\tif ( index !== - 1 ) {\r\n\r\n\t\t\tobject.parent = undefined;\r\n\t\t\tthis.children.splice( index, 1 );\r\n\r\n\t\t\t// remove from scene\r\n\r\n\t\t\tvar scene = this;\r\n\r\n\t\t\twhile ( scene.parent !== undefined ) {\r\n\r\n\t\t\t\tscene = scene.parent;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( scene !== undefined && scene instanceof THREE.Scene ) {\r\n\r\n\t\t\t\tscene.__removeObject( object );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ttraverse: function ( callback ) {\r\n\r\n\t\tcallback( this );\r\n\r\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n\t\t\tthis.children[ i ].traverse( callback );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetChildByName: function ( name, recursive ) {\r\n\r\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar child = this.children[ i ];\r\n\r\n\t\t\tif ( child.name === name ) {\r\n\r\n\t\t\t\treturn child;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( recursive === true ) {\r\n\r\n\t\t\t\tchild = child.getChildByName( name, recursive );\r\n\r\n\t\t\t\tif ( child !== undefined ) {\r\n\r\n\t\t\t\t\treturn child;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn undefined;\r\n\r\n\t},\r\n\r\n\tgetDescendants: function ( array ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\r\n\t\tArray.prototype.push.apply( array, this.children );\r\n\r\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n\t\t\tthis.children[ i ].getDescendants( array );\r\n\r\n\t\t}\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tupdateMatrix: function () {\r\n\r\n\t\tthis.matrix.setPosition( this.position );\r\n\r\n\t\tif ( this.useQuaternion === false )  {\r\n\r\n\t\t\tthis.matrix.setRotationFromEuler( this.rotation, this.eulerOrder );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.matrix.setRotationFromQuaternion( this.quaternion );\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.scale.x !== 1 || this.scale.y !== 1 || this.scale.z !== 1 ) {\r\n\r\n\t\t\tthis.matrix.scale( this.scale );\r\n\r\n\t\t}\r\n\r\n\t\tthis.matrixWorldNeedsUpdate = true;\r\n\r\n\t},\r\n\r\n\tupdateMatrixWorld: function ( force ) {\r\n\r\n\t\tif ( this.matrixAutoUpdate === true ) this.updateMatrix();\r\n\r\n\t\tif ( this.matrixWorldNeedsUpdate === true || force === true ) {\r\n\r\n\t\t\tif ( this.parent === undefined ) {\r\n\r\n\t\t\t\tthis.matrixWorld.copy( this.matrix );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.matrixWorldNeedsUpdate = false;\r\n\r\n\t\t\tforce = true;\r\n\r\n\t\t}\r\n\r\n\t\t// update children\r\n\r\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n\t\t\tthis.children[ i ].updateMatrixWorld( force );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tclone: function ( object ) {\r\n\r\n\t\tif ( object === undefined ) object = new THREE.Object3D();\r\n\r\n\t\tobject.name = this.name;\r\n\r\n\t\tobject.up.copy( this.up );\r\n\r\n\t\tobject.position.copy( this.position );\r\n\t\tif ( object.rotation instanceof THREE.Vector3 ) object.rotation.copy( this.rotation ); // because of Sprite madness\r\n\t\tobject.eulerOrder = this.eulerOrder;\r\n\t\tobject.scale.copy( this.scale );\r\n\r\n\t\tobject.renderDepth = this.renderDepth;\r\n\r\n\t\tobject.rotationAutoUpdate = this.rotationAutoUpdate;\r\n\r\n\t\tobject.matrix.copy( this.matrix );\r\n\t\tobject.matrixWorld.copy( this.matrixWorld );\r\n\t\tobject.matrixRotationWorld.copy( this.matrixRotationWorld );\r\n\r\n\t\tobject.matrixAutoUpdate = this.matrixAutoUpdate;\r\n\t\tobject.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;\r\n\r\n\t\tobject.quaternion.copy( this.quaternion );\r\n\t\tobject.useQuaternion = this.useQuaternion;\r\n\r\n\t\tobject.visible = this.visible;\r\n\r\n\t\tobject.castShadow = this.castShadow;\r\n\t\tobject.receiveShadow = this.receiveShadow;\r\n\r\n\t\tobject.frustumCulled = this.frustumCulled;\r\n\r\n\t\tfor ( var i = 0; i < this.children.length; i ++ ) {\r\n\r\n\t\t\tvar child = this.children[ i ];\r\n\t\t\tobject.add( child.clone() );\r\n\r\n\t\t}\r\n\r\n\t\treturn object;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Object3D.__m1 = new THREE.Matrix4();\r\nTHREE.Object3D.defaultEulerOrder = 'XYZ',\r\n\r\nTHREE.Object3DIdCount = 0;\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author julianwa / https://github.com/julianwa\r\n */\r\n\r\nTHREE.Projector = function () {\r\n\r\n\tvar _object, _objectCount, _objectPool = [], _objectPoolLength = 0,\r\n\t_vertex, _vertexCount, _vertexPool = [], _vertexPoolLength = 0,\r\n\t_face, _face3Count, _face3Pool = [], _face3PoolLength = 0,\r\n\t_face4Count, _face4Pool = [], _face4PoolLength = 0,\r\n\t_line, _lineCount, _linePool = [], _linePoolLength = 0,\r\n\t_particle, _particleCount, _particlePool = [], _particlePoolLength = 0,\r\n\r\n\t_renderData = { objects: [], sprites: [], lights: [], elements: [] },\r\n\r\n\t_vector3 = new THREE.Vector3(),\r\n\t_vector4 = new THREE.Vector4(),\r\n\r\n\t_clipBox = new THREE.Box3( new THREE.Vector3( -1, -1, -1 ), new THREE.Vector3( 1, 1, 1 ) ),\r\n\t_boundingBox = new THREE.Box3(),\r\n\t_points3 = new Array( 3 ),\r\n\t_points4 = new Array( 4 ),\r\n\r\n\t_viewMatrix = new THREE.Matrix4(),\r\n\t_viewProjectionMatrix = new THREE.Matrix4(),\r\n\r\n\t_modelMatrix,\r\n\t_modelViewProjectionMatrix = new THREE.Matrix4(),\r\n\r\n\t_normalMatrix = new THREE.Matrix3(),\r\n\t_normalViewMatrix = new THREE.Matrix3(),\r\n\r\n\t_centroid = new THREE.Vector3(),\r\n\r\n\t_frustum = new THREE.Frustum(),\r\n\r\n\t_clippedVertex1PositionScreen = new THREE.Vector4(),\r\n\t_clippedVertex2PositionScreen = new THREE.Vector4();\r\n\r\n\tthis.projectVector = function ( vector, camera ) {\r\n\r\n\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\r\n\r\n\t\t_viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\r\n\r\n\t\treturn vector.applyProjection( _viewProjectionMatrix );\r\n\r\n\t};\r\n\r\n\tthis.unprojectVector = function ( vector, camera ) {\r\n\r\n\t\tcamera.projectionMatrixInverse.getInverse( camera.projectionMatrix );\r\n\r\n\t\t_viewProjectionMatrix.multiplyMatrices( camera.matrixWorld, camera.projectionMatrixInverse );\r\n\r\n\t\treturn vector.applyProjection( _viewProjectionMatrix );\r\n\r\n\t};\r\n\r\n\tthis.pickingRay = function ( vector, camera ) {\r\n\r\n\t\t// set two vectors with opposing z values\r\n\t\tvector.z = -1.0;\r\n\t\tvar end = new THREE.Vector3( vector.x, vector.y, 1.0 );\r\n\r\n\t\tthis.unprojectVector( vector, camera );\r\n\t\tthis.unprojectVector( end, camera );\r\n\r\n\t\t// find direction from vector to end\r\n\t\tend.sub( vector ).normalize();\r\n\r\n\t\treturn new THREE.Raycaster( vector, end );\r\n\r\n\t};\r\n\r\n\tvar projectGraph = function ( root, sortObjects ) {\r\n\r\n\t\t_objectCount = 0;\r\n\r\n\t\t_renderData.objects.length = 0;\r\n\t\t_renderData.sprites.length = 0;\r\n\t\t_renderData.lights.length = 0;\r\n\r\n\t\tvar projectObject = function ( parent ) {\r\n\r\n\t\t\tfor ( var c = 0, cl = parent.children.length; c < cl; c ++ ) {\r\n\r\n\t\t\t\tvar object = parent.children[ c ];\r\n\r\n\t\t\t\tif ( object.visible === false ) continue;\r\n\r\n\t\t\t\tif ( object instanceof THREE.Light ) {\r\n\r\n\t\t\t\t\t_renderData.lights.push( object );\r\n\r\n\t\t\t\t} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line ) {\r\n\r\n\t\t\t\t\tif ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {\r\n\r\n\t\t\t\t\t\t_object = getNextObjectInPool();\r\n\t\t\t\t\t\t_object.object = object;\r\n\r\n\t\t\t\t\t\tif ( object.renderDepth !== null ) {\r\n\r\n\t\t\t\t\t\t\t_object.z = object.renderDepth;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t_vector3.getPositionFromMatrix( object.matrixWorld );\r\n\t\t\t\t\t\t\t_vector3.applyProjection( _viewProjectionMatrix );\r\n\t\t\t\t\t\t\t_object.z = _vector3.z;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t_renderData.objects.push( _object );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( object instanceof THREE.Sprite || object instanceof THREE.Particle ) {\r\n\r\n\t\t\t\t\t_object = getNextObjectInPool();\r\n\t\t\t\t\t_object.object = object;\r\n\r\n\t\t\t\t\t// TODO: Find an elegant and performant solution and remove this dupe code.\r\n\r\n\t\t\t\t\tif ( object.renderDepth !== null ) {\r\n\r\n\t\t\t\t\t\t_object.z = object.renderDepth;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t_vector3.getPositionFromMatrix( object.matrixWorld );\r\n\t\t\t\t\t\t_vector3.applyProjection( _viewProjectionMatrix );\r\n\t\t\t\t\t\t_object.z = _vector3.z;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t_renderData.sprites.push( _object );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t_object = getNextObjectInPool();\r\n\t\t\t\t\t_object.object = object;\r\n\r\n\t\t\t\t\tif ( object.renderDepth !== null ) {\r\n\r\n\t\t\t\t\t\t_object.z = object.renderDepth;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t_vector3.getPositionFromMatrix( object.matrixWorld );\r\n\t\t\t\t\t\t_vector3.applyProjection( _viewProjectionMatrix );\r\n\t\t\t\t\t\t_object.z = _vector3.z;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t_renderData.objects.push( _object );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tprojectObject( object );\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tprojectObject( root );\r\n\r\n\t\tif ( sortObjects === true ) _renderData.objects.sort( painterSort );\r\n\r\n\t\treturn _renderData;\r\n\r\n\t};\r\n\r\n\tthis.projectScene = function ( scene, camera, sortObjects, sortElements ) {\r\n\r\n\t\tvar visible = false,\r\n\t\to, ol, v, vl, f, fl, n, nl, c, cl, u, ul, object,\r\n\t\tgeometry, vertices, faces, face, faceVertexNormals, faceVertexUvs, uvs,\r\n\t\tv1, v2, v3, v4, isFaceMaterial, objectMaterials;\r\n\r\n\t\t_face3Count = 0;\r\n\t\t_face4Count = 0;\r\n\t\t_lineCount = 0;\r\n\t\t_particleCount = 0;\r\n\r\n\t\t_renderData.elements.length = 0;\r\n\r\n\t\tscene.updateMatrixWorld();\r\n\r\n\t\tif ( camera.parent === undefined ) camera.updateMatrixWorld();\r\n\r\n\t\t_viewMatrix.copy( camera.matrixWorldInverse.getInverse( camera.matrixWorld ) );\r\n\t\t_viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, _viewMatrix );\r\n\r\n\t\t_normalViewMatrix.getInverse( _viewMatrix );\r\n\t\t_normalViewMatrix.transpose();\r\n\r\n\t\t_frustum.setFromMatrix( _viewProjectionMatrix );\r\n\r\n\t\t_renderData = projectGraph( scene, sortObjects );\r\n\r\n\t\tfor ( o = 0, ol = _renderData.objects.length; o < ol; o ++ ) {\r\n\r\n\t\t\tobject = _renderData.objects[ o ].object;\r\n\r\n\t\t\t_modelMatrix = object.matrixWorld;\r\n\r\n\t\t\t_vertexCount = 0;\r\n\r\n\t\t\tif ( object instanceof THREE.Mesh ) {\r\n\r\n\t\t\t\tgeometry = object.geometry;\r\n\r\n\t\t\t\tvertices = geometry.vertices;\r\n\t\t\t\tfaces = geometry.faces;\r\n\t\t\t\tfaceVertexUvs = geometry.faceVertexUvs;\r\n\r\n\t\t\t\t_normalMatrix.getInverse( _modelMatrix );\r\n\t\t\t\t_normalMatrix.transpose();\r\n\r\n\t\t\t\tisFaceMaterial = object.material instanceof THREE.MeshFaceMaterial;\r\n\t\t\t\tobjectMaterials = isFaceMaterial === true ? object.material : null;\r\n\r\n\t\t\t\tfor ( v = 0, vl = vertices.length; v < vl; v ++ ) {\r\n\r\n\t\t\t\t\t_vertex = getNextVertexInPool();\r\n\r\n\t\t\t\t\t_vertex.positionWorld.copy( vertices[ v ] ).applyMatrix4( _modelMatrix );\r\n\t\t\t\t\t_vertex.positionScreen.copy( _vertex.positionWorld ).applyMatrix4( _viewProjectionMatrix );\r\n\r\n\t\t\t\t\t_vertex.positionScreen.x /= _vertex.positionScreen.w;\r\n\t\t\t\t\t_vertex.positionScreen.y /= _vertex.positionScreen.w;\r\n\t\t\t\t\t_vertex.positionScreen.z /= _vertex.positionScreen.w;\r\n\r\n\t\t\t\t\t_vertex.visible = ! ( _vertex.positionScreen.x < -1 || _vertex.positionScreen.x > 1 ||\r\n\t\t\t\t\t\t\t      _vertex.positionScreen.y < -1 || _vertex.positionScreen.y > 1 ||\r\n\t\t\t\t\t\t\t      _vertex.positionScreen.z < -1 || _vertex.positionScreen.z > 1 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( f = 0, fl = faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\tface = faces[ f ];\r\n\r\n\t\t\t\t\tvar material = isFaceMaterial === true\r\n\t\t\t\t\t\t? objectMaterials.materials[ face.materialIndex ]\r\n\t\t\t\t\t\t: object.material;\r\n\r\n\t\t\t\t\tif ( material === undefined ) continue;\r\n\r\n\t\t\t\t\tvar side = material.side;\r\n\r\n\t\t\t\t\tif ( face instanceof THREE.Face3 ) {\r\n\r\n\t\t\t\t\t\tv1 = _vertexPool[ face.a ];\r\n\t\t\t\t\t\tv2 = _vertexPool[ face.b ];\r\n\t\t\t\t\t\tv3 = _vertexPool[ face.c ];\r\n\r\n\t\t\t\t\t\t_points3[ 0 ] = v1.positionScreen;\r\n\t\t\t\t\t\t_points3[ 1 ] = v2.positionScreen;\r\n\t\t\t\t\t\t_points3[ 2 ] = v3.positionScreen;\r\n\r\n\t\t\t\t\t\tif ( v1.visible === true || v2.visible === true || v3.visible === true ||\r\n\t\t\t\t\t\t\t_clipBox.isIntersectionBox( _boundingBox.setFromPoints( _points3 ) ) ) {\r\n\r\n\t\t\t\t\t\t\tvisible = ( ( v3.positionScreen.x - v1.positionScreen.x ) * ( v2.positionScreen.y - v1.positionScreen.y ) -\r\n\t\t\t\t\t\t\t\t( v3.positionScreen.y - v1.positionScreen.y ) * ( v2.positionScreen.x - v1.positionScreen.x ) ) < 0;\r\n\r\n\t\t\t\t\t\t\tif ( side === THREE.DoubleSide || visible === ( side === THREE.FrontSide ) ) {\r\n\r\n\t\t\t\t\t\t\t\t_face = getNextFace3InPool();\r\n\r\n\t\t\t\t\t\t\t\t_face.v1.copy( v1 );\r\n\t\t\t\t\t\t\t\t_face.v2.copy( v2 );\r\n\t\t\t\t\t\t\t\t_face.v3.copy( v3 );\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( face instanceof THREE.Face4 ) {\r\n\r\n\t\t\t\t\t\tv1 = _vertexPool[ face.a ];\r\n\t\t\t\t\t\tv2 = _vertexPool[ face.b ];\r\n\t\t\t\t\t\tv3 = _vertexPool[ face.c ];\r\n\t\t\t\t\t\tv4 = _vertexPool[ face.d ];\r\n\r\n\t\t\t\t\t\t_points4[ 0 ] = v1.positionScreen;\r\n\t\t\t\t\t\t_points4[ 1 ] = v2.positionScreen;\r\n\t\t\t\t\t\t_points4[ 2 ] = v3.positionScreen;\r\n\t\t\t\t\t\t_points4[ 3 ] = v4.positionScreen;\r\n\r\n\t\t\t\t\t\tif ( v1.visible === true || v2.visible === true || v3.visible === true || v4.visible === true ||\r\n\t\t\t\t\t\t\t_clipBox.isIntersectionBox( _boundingBox.setFromPoints( _points4 ) ) ) {\r\n\r\n\t\t\t\t\t\t\tvisible = ( v4.positionScreen.x - v1.positionScreen.x ) * ( v2.positionScreen.y - v1.positionScreen.y ) -\r\n\t\t\t\t\t\t\t\t( v4.positionScreen.y - v1.positionScreen.y ) * ( v2.positionScreen.x - v1.positionScreen.x ) < 0 ||\r\n\t\t\t\t\t\t\t\t( v2.positionScreen.x - v3.positionScreen.x ) * ( v4.positionScreen.y - v3.positionScreen.y ) -\r\n\t\t\t\t\t\t\t\t( v2.positionScreen.y - v3.positionScreen.y ) * ( v4.positionScreen.x - v3.positionScreen.x ) < 0;\r\n\r\n\r\n\t\t\t\t\t\t\tif ( side === THREE.DoubleSide || visible === ( side === THREE.FrontSide ) ) {\r\n\r\n\t\t\t\t\t\t\t\t_face = getNextFace4InPool();\r\n\r\n\t\t\t\t\t\t\t\t_face.v1.copy( v1 );\r\n\t\t\t\t\t\t\t\t_face.v2.copy( v2 );\r\n\t\t\t\t\t\t\t\t_face.v3.copy( v3 );\r\n\t\t\t\t\t\t\t\t_face.v4.copy( v4 );\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t_face.normalModel.copy( face.normal );\r\n\r\n\t\t\t\t\tif ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {\r\n\r\n\t\t\t\t\t\t_face.normalModel.negate();\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t_face.normalModel.applyMatrix3( _normalMatrix ).normalize();\r\n\r\n\t\t\t\t\t_face.normalModelView.copy( _face.normalModel ).applyMatrix3( _normalViewMatrix );\r\n\r\n\t\t\t\t\t_face.centroidModel.copy( face.centroid ).applyMatrix4( _modelMatrix );\r\n\r\n\t\t\t\t\tfaceVertexNormals = face.vertexNormals;\r\n\r\n\t\t\t\t\tfor ( n = 0, nl = faceVertexNormals.length; n < nl; n ++ ) {\r\n\r\n\t\t\t\t\t\tvar normalModel = _face.vertexNormalsModel[ n ];\r\n\t\t\t\t\t\tnormalModel.copy( faceVertexNormals[ n ] );\r\n\r\n\t\t\t\t\t\tif ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {\r\n\r\n\t\t\t\t\t\t\tnormalModel.negate();\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tnormalModel.applyMatrix3( _normalMatrix ).normalize();\r\n\r\n\t\t\t\t\t\tvar normalModelView = _face.vertexNormalsModelView[ n ];\r\n\t\t\t\t\t\tnormalModelView.copy( normalModel ).applyMatrix3( _normalViewMatrix );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t_face.vertexNormalsLength = faceVertexNormals.length;\r\n\r\n\t\t\t\t\tfor ( c = 0, cl = faceVertexUvs.length; c < cl; c ++ ) {\r\n\r\n\t\t\t\t\t\tuvs = faceVertexUvs[ c ][ f ];\r\n\r\n\t\t\t\t\t\tif ( uvs === undefined ) continue;\r\n\r\n\t\t\t\t\t\tfor ( u = 0, ul = uvs.length; u < ul; u ++ ) {\r\n\r\n\t\t\t\t\t\t\t_face.uvs[ c ][ u ] = uvs[ u ];\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t_face.color = face.color;\r\n\t\t\t\t\t_face.material = material;\r\n\r\n\t\t\t\t\t_centroid.copy( _face.centroidModel ).applyProjection( _viewProjectionMatrix );\r\n\r\n\t\t\t\t\t_face.z = _centroid.z;\r\n\r\n\t\t\t\t\t_renderData.elements.push( _face );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( object instanceof THREE.Line ) {\r\n\r\n\t\t\t\t_modelViewProjectionMatrix.multiplyMatrices( _viewProjectionMatrix, _modelMatrix );\r\n\r\n\t\t\t\tvertices = object.geometry.vertices;\r\n\r\n\t\t\t\tv1 = getNextVertexInPool();\r\n\t\t\t\tv1.positionScreen.copy( vertices[ 0 ] ).applyMatrix4( _modelViewProjectionMatrix );\r\n\r\n\t\t\t\t// Handle LineStrip and LinePieces\r\n\t\t\t\tvar step = object.type === THREE.LinePieces ? 2 : 1;\r\n\r\n\t\t\t\tfor ( v = 1, vl = vertices.length; v < vl; v ++ ) {\r\n\r\n\t\t\t\t\tv1 = getNextVertexInPool();\r\n\t\t\t\t\tv1.positionScreen.copy( vertices[ v ] ).applyMatrix4( _modelViewProjectionMatrix );\r\n\r\n\t\t\t\t\tif ( ( v + 1 ) % step > 0 ) continue;\r\n\r\n\t\t\t\t\tv2 = _vertexPool[ _vertexCount - 2 ];\r\n\r\n\t\t\t\t\t_clippedVertex1PositionScreen.copy( v1.positionScreen );\r\n\t\t\t\t\t_clippedVertex2PositionScreen.copy( v2.positionScreen );\r\n\r\n\t\t\t\t\tif ( clipLine( _clippedVertex1PositionScreen, _clippedVertex2PositionScreen ) === true ) {\r\n\r\n\t\t\t\t\t\t// Perform the perspective divide\r\n\t\t\t\t\t\t_clippedVertex1PositionScreen.multiplyScalar( 1 / _clippedVertex1PositionScreen.w );\r\n\t\t\t\t\t\t_clippedVertex2PositionScreen.multiplyScalar( 1 / _clippedVertex2PositionScreen.w );\r\n\r\n\t\t\t\t\t\t_line = getNextLineInPool();\r\n\t\t\t\t\t\t_line.v1.positionScreen.copy( _clippedVertex1PositionScreen );\r\n\t\t\t\t\t\t_line.v2.positionScreen.copy( _clippedVertex2PositionScreen );\r\n\r\n\t\t\t\t\t\t_line.z = Math.max( _clippedVertex1PositionScreen.z, _clippedVertex2PositionScreen.z );\r\n\r\n\t\t\t\t\t\t_line.material = object.material;\r\n\r\n\t\t\t\t\t\t_renderData.elements.push( _line );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( o = 0, ol = _renderData.sprites.length; o < ol; o++ ) {\r\n\r\n\t\t\tobject = _renderData.sprites[ o ].object;\r\n\r\n\t\t\t_modelMatrix = object.matrixWorld;\r\n\r\n\t\t\tif ( object instanceof THREE.Particle ) {\r\n\r\n\t\t\t\t_vector4.set( _modelMatrix.elements[12], _modelMatrix.elements[13], _modelMatrix.elements[14], 1 );\r\n\t\t\t\t_vector4.applyMatrix4( _viewProjectionMatrix );\r\n\r\n\t\t\t\t_vector4.z /= _vector4.w;\r\n\r\n\t\t\t\tif ( _vector4.z > 0 && _vector4.z < 1 ) {\r\n\r\n\t\t\t\t\t_particle = getNextParticleInPool();\r\n\t\t\t\t\t_particle.object = object;\r\n\t\t\t\t\t_particle.x = _vector4.x / _vector4.w;\r\n\t\t\t\t\t_particle.y = _vector4.y / _vector4.w;\r\n\t\t\t\t\t_particle.z = _vector4.z;\r\n\r\n\t\t\t\t\t_particle.rotation = object.rotation.z;\r\n\r\n\t\t\t\t\t_particle.scale.x = object.scale.x * Math.abs( _particle.x - ( _vector4.x + camera.projectionMatrix.elements[0] ) / ( _vector4.w + camera.projectionMatrix.elements[12] ) );\r\n\t\t\t\t\t_particle.scale.y = object.scale.y * Math.abs( _particle.y - ( _vector4.y + camera.projectionMatrix.elements[5] ) / ( _vector4.w + camera.projectionMatrix.elements[13] ) );\r\n\r\n\t\t\t\t\t_particle.material = object.material;\r\n\r\n\t\t\t\t\t_renderData.elements.push( _particle );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( sortElements === true ) _renderData.elements.sort( painterSort );\r\n\r\n\t\treturn _renderData;\r\n\r\n\t};\r\n\r\n\t// Pools\r\n\r\n\tfunction getNextObjectInPool() {\r\n\r\n\t\tif ( _objectCount === _objectPoolLength ) {\r\n\r\n\t\t\tvar object = new THREE.RenderableObject();\r\n\t\t\t_objectPool.push( object );\r\n\t\t\t_objectPoolLength ++;\r\n\t\t\t_objectCount ++;\r\n\t\t\treturn object;\r\n\r\n\t\t}\r\n\r\n\t\treturn _objectPool[ _objectCount ++ ];\r\n\r\n\t}\r\n\r\n\tfunction getNextVertexInPool() {\r\n\r\n\t\tif ( _vertexCount === _vertexPoolLength ) {\r\n\r\n\t\t\tvar vertex = new THREE.RenderableVertex();\r\n\t\t\t_vertexPool.push( vertex );\r\n\t\t\t_vertexPoolLength ++;\r\n\t\t\t_vertexCount ++;\r\n\t\t\treturn vertex;\r\n\r\n\t\t}\r\n\r\n\t\treturn _vertexPool[ _vertexCount ++ ];\r\n\r\n\t}\r\n\r\n\tfunction getNextFace3InPool() {\r\n\r\n\t\tif ( _face3Count === _face3PoolLength ) {\r\n\r\n\t\t\tvar face = new THREE.RenderableFace3();\r\n\t\t\t_face3Pool.push( face );\r\n\t\t\t_face3PoolLength ++;\r\n\t\t\t_face3Count ++;\r\n\t\t\treturn face;\r\n\r\n\t\t}\r\n\r\n\t\treturn _face3Pool[ _face3Count ++ ];\r\n\r\n\r\n\t}\r\n\r\n\tfunction getNextFace4InPool() {\r\n\r\n\t\tif ( _face4Count === _face4PoolLength ) {\r\n\r\n\t\t\tvar face = new THREE.RenderableFace4();\r\n\t\t\t_face4Pool.push( face );\r\n\t\t\t_face4PoolLength ++;\r\n\t\t\t_face4Count ++;\r\n\t\t\treturn face;\r\n\r\n\t\t}\r\n\r\n\t\treturn _face4Pool[ _face4Count ++ ];\r\n\r\n\t}\r\n\r\n\tfunction getNextLineInPool() {\r\n\r\n\t\tif ( _lineCount === _linePoolLength ) {\r\n\r\n\t\t\tvar line = new THREE.RenderableLine();\r\n\t\t\t_linePool.push( line );\r\n\t\t\t_linePoolLength ++;\r\n\t\t\t_lineCount ++\r\n\t\t\treturn line;\r\n\r\n\t\t}\r\n\r\n\t\treturn _linePool[ _lineCount ++ ];\r\n\r\n\t}\r\n\r\n\tfunction getNextParticleInPool() {\r\n\r\n\t\tif ( _particleCount === _particlePoolLength ) {\r\n\r\n\t\t\tvar particle = new THREE.RenderableParticle();\r\n\t\t\t_particlePool.push( particle );\r\n\t\t\t_particlePoolLength ++;\r\n\t\t\t_particleCount ++\r\n\t\t\treturn particle;\r\n\r\n\t\t}\r\n\r\n\t\treturn _particlePool[ _particleCount ++ ];\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tfunction painterSort( a, b ) {\r\n\r\n\t\treturn b.z - a.z;\r\n\r\n\t}\r\n\r\n\tfunction clipLine( s1, s2 ) {\r\n\r\n\t\tvar alpha1 = 0, alpha2 = 1,\r\n\r\n\t\t// Calculate the boundary coordinate of each vertex for the near and far clip planes,\r\n\t\t// Z = -1 and Z = +1, respectively.\r\n\t\tbc1near =  s1.z + s1.w,\r\n\t\tbc2near =  s2.z + s2.w,\r\n\t\tbc1far =  - s1.z + s1.w,\r\n\t\tbc2far =  - s2.z + s2.w;\r\n\r\n\t\tif ( bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0 ) {\r\n\r\n\t\t\t// Both vertices lie entirely within all clip planes.\r\n\t\t\treturn true;\r\n\r\n\t\t} else if ( ( bc1near < 0 && bc2near < 0) || (bc1far < 0 && bc2far < 0 ) ) {\r\n\r\n\t\t\t// Both vertices lie entirely outside one of the clip planes.\r\n\t\t\treturn false;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// The line segment spans at least one clip plane.\r\n\r\n\t\t\tif ( bc1near < 0 ) {\r\n\r\n\t\t\t\t// v1 lies outside the near plane, v2 inside\r\n\t\t\t\talpha1 = Math.max( alpha1, bc1near / ( bc1near - bc2near ) );\r\n\r\n\t\t\t} else if ( bc2near < 0 ) {\r\n\r\n\t\t\t\t// v2 lies outside the near plane, v1 inside\r\n\t\t\t\talpha2 = Math.min( alpha2, bc1near / ( bc1near - bc2near ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( bc1far < 0 ) {\r\n\r\n\t\t\t\t// v1 lies outside the far plane, v2 inside\r\n\t\t\t\talpha1 = Math.max( alpha1, bc1far / ( bc1far - bc2far ) );\r\n\r\n\t\t\t} else if ( bc2far < 0 ) {\r\n\r\n\t\t\t\t// v2 lies outside the far plane, v2 inside\r\n\t\t\t\talpha2 = Math.min( alpha2, bc1far / ( bc1far - bc2far ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( alpha2 < alpha1 ) {\r\n\r\n\t\t\t\t// The line segment spans two boundaries, but is outside both of them.\r\n\t\t\t\t// (This can't happen when we're only clipping against just near/far but good\r\n\t\t\t\t//  to leave the check here for future usage if other clip planes are added.)\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Update the s1 and s2 vertices to match the clipped line segment.\r\n\t\t\t\ts1.lerp( s2, alpha1 );\r\n\t\t\t\ts2.lerp( s1, 1 - alpha2 );\r\n\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {\r\n\r\n\tthis.a = a;\r\n\tthis.b = b;\r\n\tthis.c = c;\r\n\r\n\tthis.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();\r\n\tthis.vertexNormals = normal instanceof Array ? normal : [ ];\r\n\r\n\tthis.color = color instanceof THREE.Color ? color : new THREE.Color();\r\n\tthis.vertexColors = color instanceof Array ? color : [];\r\n\r\n\tthis.vertexTangents = [];\r\n\r\n\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\r\n\r\n\tthis.centroid = new THREE.Vector3();\r\n\r\n};\r\n\r\nTHREE.Face3.prototype = {\r\n\r\n\tconstructor: THREE.Face3,\r\n\r\n\tclone: function () {\r\n\r\n\t\tvar face = new THREE.Face3( this.a, this.b, this.c );\r\n\r\n\t\tface.normal.copy( this.normal );\r\n\t\tface.color.copy( this.color );\r\n\t\tface.centroid.copy( this.centroid );\r\n\r\n\t\tface.materialIndex = this.materialIndex;\r\n\r\n\t\tvar i, il;\r\n\t\tfor ( i = 0, il = this.vertexNormals.length; i < il; i ++ ) face.vertexNormals[ i ] = this.vertexNormals[ i ].clone();\r\n\t\tfor ( i = 0, il = this.vertexColors.length; i < il; i ++ ) face.vertexColors[ i ] = this.vertexColors[ i ].clone();\r\n\t\tfor ( i = 0, il = this.vertexTangents.length; i < il; i ++ ) face.vertexTangents[ i ] = this.vertexTangents[ i ].clone();\r\n\r\n\t\treturn face;\r\n\r\n\t}\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {\r\n\r\n\tthis.a = a;\r\n\tthis.b = b;\r\n\tthis.c = c;\r\n\tthis.d = d;\r\n\r\n\tthis.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();\r\n\tthis.vertexNormals = normal instanceof Array ? normal : [ ];\r\n\r\n\tthis.color = color instanceof THREE.Color ? color : new THREE.Color();\r\n\tthis.vertexColors = color instanceof Array ? color : [];\r\n\r\n\tthis.vertexTangents = [];\r\n\r\n\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\r\n\r\n\tthis.centroid = new THREE.Vector3();\r\n\r\n};\r\n\r\nTHREE.Face4.prototype = {\r\n\r\n\tconstructor: THREE.Face4,\r\n\r\n\tclone: function () {\r\n\r\n\t\tvar face = new THREE.Face4( this.a, this.b, this.c, this.d );\r\n\r\n\t\tface.normal.copy( this.normal );\r\n\t\tface.color.copy( this.color );\r\n\t\tface.centroid.copy( this.centroid );\r\n\r\n\t\tface.materialIndex = this.materialIndex;\r\n\r\n\t\tvar i, il;\r\n\t\tfor ( i = 0, il = this.vertexNormals.length; i < il; i ++ ) face.vertexNormals[ i ] = this.vertexNormals[ i ].clone();\r\n\t\tfor ( i = 0, il = this.vertexColors.length; i < il; i ++ ) face.vertexColors[ i ] = this.vertexColors[ i ].clone();\r\n\t\tfor ( i = 0, il = this.vertexTangents.length; i < il; i ++ ) face.vertexTangents[ i ] = this.vertexTangents[ i ].clone();\r\n\r\n\t\treturn face;\r\n\r\n\t}\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author kile / http://kile.stravaganza.org/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Geometry = function () {\r\n\r\n\tTHREE.EventDispatcher.call( this );\r\n\r\n\tthis.id = THREE.GeometryIdCount ++;\r\n\r\n\tthis.name = '';\r\n\r\n\tthis.vertices = [];\r\n\tthis.colors = [];  // one-to-one vertex colors, used in ParticleSystem, Line and Ribbon\r\n\tthis.normals = []; // one-to-one vertex normals, used in Ribbon\r\n\r\n\tthis.faces = [];\r\n\r\n\tthis.faceUvs = [[]];\r\n\tthis.faceVertexUvs = [[]];\r\n\r\n\tthis.morphTargets = [];\r\n\tthis.morphColors = [];\r\n\tthis.morphNormals = [];\r\n\r\n\tthis.skinWeights = [];\r\n\tthis.skinIndices = [];\r\n\r\n\tthis.lineDistances = [];\r\n\r\n\tthis.boundingBox = null;\r\n\tthis.boundingSphere = null;\r\n\r\n\tthis.hasTangents = false;\r\n\r\n\tthis.dynamic = true; // the intermediate typed arrays will be deleted when set to false\r\n\r\n\t// update flags\r\n\r\n\tthis.verticesNeedUpdate = false;\r\n\tthis.elementsNeedUpdate = false;\r\n\tthis.uvsNeedUpdate = false;\r\n\tthis.normalsNeedUpdate = false;\r\n\tthis.tangentsNeedUpdate = false;\r\n\tthis.colorsNeedUpdate = false;\r\n\tthis.lineDistancesNeedUpdate = false;\r\n\r\n\tthis.buffersNeedUpdate = false;\r\n\r\n};\r\n\r\nTHREE.Geometry.prototype = {\r\n\r\n\tconstructor: THREE.Geometry,\r\n\r\n\tapplyMatrix: function ( matrix ) {\r\n\r\n\t\tvar normalMatrix = new THREE.Matrix3().getInverse( matrix ).transpose();\r\n\r\n\t\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar vertex = this.vertices[ i ];\r\n\t\t\tvertex.applyMatrix4( matrix );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar face = this.faces[ i ];\r\n\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tface.centroid.applyMatrix4( matrix );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeCentroids: function () {\r\n\r\n\t\tvar f, fl, face;\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\t\t\tface.centroid.set( 0, 0, 0 );\r\n\r\n\t\t\tif ( face instanceof THREE.Face3 ) {\r\n\r\n\t\t\t\tface.centroid.add( this.vertices[ face.a ] );\r\n\t\t\t\tface.centroid.add( this.vertices[ face.b ] );\r\n\t\t\t\tface.centroid.add( this.vertices[ face.c ] );\r\n\t\t\t\tface.centroid.divideScalar( 3 );\r\n\r\n\t\t\t} else if ( face instanceof THREE.Face4 ) {\r\n\r\n\t\t\t\tface.centroid.add( this.vertices[ face.a ] );\r\n\t\t\t\tface.centroid.add( this.vertices[ face.b ] );\r\n\t\t\t\tface.centroid.add( this.vertices[ face.c ] );\r\n\t\t\t\tface.centroid.add( this.vertices[ face.d ] );\r\n\t\t\t\tface.centroid.divideScalar( 4 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeFaceNormals: function () {\r\n\r\n\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\r\n\r\n\t\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tvar face = this.faces[ f ];\r\n\r\n\t\t\tvar vA = this.vertices[ face.a ];\r\n\t\t\tvar vB = this.vertices[ face.b ];\r\n\t\t\tvar vC = this.vertices[ face.c ];\r\n\r\n\t\t\tcb.subVectors( vC, vB );\r\n\t\t\tab.subVectors( vA, vB );\r\n\t\t\tcb.cross( ab );\r\n\r\n\t\t\tcb.normalize();\r\n\r\n\t\t\tface.normal.copy( cb );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeVertexNormals: function ( areaWeighted ) {\r\n\r\n\t\tvar v, vl, f, fl, face, vertices;\r\n\r\n\t\t// create internal buffers for reuse when calling this method repeatedly\r\n\t\t// (otherwise memory allocation / deallocation every frame is big resource hog)\r\n\r\n\t\tif ( this.__tmpVertices === undefined ) {\r\n\r\n\t\t\tthis.__tmpVertices = new Array( this.vertices.length );\r\n\t\t\tvertices = this.__tmpVertices;\r\n\r\n\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\r\n\t\t\t\tvertices[ v ] = new THREE.Vector3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\t\tif ( face instanceof THREE.Face3 ) {\r\n\r\n\t\t\t\t\tface.vertexNormals = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];\r\n\r\n\t\t\t\t} else if ( face instanceof THREE.Face4 ) {\r\n\r\n\t\t\t\t\tface.vertexNormals = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvertices = this.__tmpVertices;\r\n\r\n\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\r\n\t\t\t\tvertices[ v ].set( 0, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( areaWeighted ) {\r\n\r\n\t\t\t// vertex normals weighted by triangle areas\r\n\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\r\n\r\n\t\t\tvar vA, vB, vC, vD;\r\n\t\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3(),\r\n\t\t\t\tdb = new THREE.Vector3(), dc = new THREE.Vector3(), bc = new THREE.Vector3();\r\n\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\t\tif ( face instanceof THREE.Face3 ) {\r\n\r\n\t\t\t\t\tvA = this.vertices[ face.a ];\r\n\t\t\t\t\tvB = this.vertices[ face.b ];\r\n\t\t\t\t\tvC = this.vertices[ face.c ];\r\n\r\n\t\t\t\t\tcb.subVectors( vC, vB );\r\n\t\t\t\t\tab.subVectors( vA, vB );\r\n\t\t\t\t\tcb.cross( ab );\r\n\r\n\t\t\t\t\tvertices[ face.a ].add( cb );\r\n\t\t\t\t\tvertices[ face.b ].add( cb );\r\n\t\t\t\t\tvertices[ face.c ].add( cb );\r\n\r\n\t\t\t\t} else if ( face instanceof THREE.Face4 ) {\r\n\r\n\t\t\t\t\tvA = this.vertices[ face.a ];\r\n\t\t\t\t\tvB = this.vertices[ face.b ];\r\n\t\t\t\t\tvC = this.vertices[ face.c ];\r\n\t\t\t\t\tvD = this.vertices[ face.d ];\r\n\r\n\t\t\t\t\t// abd\r\n\r\n\t\t\t\t\tdb.subVectors( vD, vB );\r\n\t\t\t\t\tab.subVectors( vA, vB );\r\n\t\t\t\t\tdb.cross( ab );\r\n\r\n\t\t\t\t\tvertices[ face.a ].add( db );\r\n\t\t\t\t\tvertices[ face.b ].add( db );\r\n\t\t\t\t\tvertices[ face.d ].add( db );\r\n\r\n\t\t\t\t\t// bcd\r\n\r\n\t\t\t\t\tdc.subVectors( vD, vC );\r\n\t\t\t\t\tbc.subVectors( vB, vC );\r\n\t\t\t\t\tdc.cross( bc );\r\n\r\n\t\t\t\t\tvertices[ face.b ].add( dc );\r\n\t\t\t\t\tvertices[ face.c ].add( dc );\r\n\t\t\t\t\tvertices[ face.d ].add( dc );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\t\tif ( face instanceof THREE.Face3 ) {\r\n\r\n\t\t\t\t\tvertices[ face.a ].add( face.normal );\r\n\t\t\t\t\tvertices[ face.b ].add( face.normal );\r\n\t\t\t\t\tvertices[ face.c ].add( face.normal );\r\n\r\n\t\t\t\t} else if ( face instanceof THREE.Face4 ) {\r\n\r\n\t\t\t\t\tvertices[ face.a ].add( face.normal );\r\n\t\t\t\t\tvertices[ face.b ].add( face.normal );\r\n\t\t\t\t\tvertices[ face.c ].add( face.normal );\r\n\t\t\t\t\tvertices[ face.d ].add( face.normal );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\r\n\t\t\tvertices[ v ].normalize();\r\n\r\n\t\t}\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\tif ( face instanceof THREE.Face3 ) {\r\n\r\n\t\t\t\tface.vertexNormals[ 0 ].copy( vertices[ face.a ] );\r\n\t\t\t\tface.vertexNormals[ 1 ].copy( vertices[ face.b ] );\r\n\t\t\t\tface.vertexNormals[ 2 ].copy( vertices[ face.c ] );\r\n\r\n\t\t\t} else if ( face instanceof THREE.Face4 ) {\r\n\r\n\t\t\t\tface.vertexNormals[ 0 ].copy( vertices[ face.a ] );\r\n\t\t\t\tface.vertexNormals[ 1 ].copy( vertices[ face.b ] );\r\n\t\t\t\tface.vertexNormals[ 2 ].copy( vertices[ face.c ] );\r\n\t\t\t\tface.vertexNormals[ 3 ].copy( vertices[ face.d ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeMorphNormals: function () {\r\n\r\n\t\tvar i, il, f, fl, face;\r\n\r\n\t\t// save original normals\r\n\t\t// - create temp variables on first access\r\n\t\t//   otherwise just copy (for faster repeated calls)\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\tif ( ! face.__originalFaceNormal ) {\r\n\r\n\t\t\t\tface.__originalFaceNormal = face.normal.clone();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tface.__originalFaceNormal.copy( face.normal );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\r\n\r\n\t\t\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\r\n\r\n\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// use temp geometry to compute face and vertex normals for each morph\r\n\r\n\t\tvar tmpGeo = new THREE.Geometry();\r\n\t\ttmpGeo.faces = this.faces;\r\n\r\n\t\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\r\n\r\n\t\t\t// create on first access\r\n\r\n\t\t\tif ( ! this.morphNormals[ i ] ) {\r\n\r\n\t\t\t\tthis.morphNormals[ i ] = {};\r\n\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\r\n\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\r\n\r\n\t\t\t\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\r\n\t\t\t\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\r\n\r\n\t\t\t\tvar faceNormal, vertexNormals;\r\n\r\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\t\t\tfaceNormal = new THREE.Vector3();\r\n\r\n\t\t\t\t\tif ( face instanceof THREE.Face3 ) {\r\n\r\n\t\t\t\t\t\tvertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tvertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3(), d: new THREE.Vector3() };\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tdstNormalsFace.push( faceNormal );\r\n\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar morphNormals = this.morphNormals[ i ];\r\n\r\n\t\t\t// set vertices to morph target\r\n\r\n\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\r\n\r\n\t\t\t// compute morph normals\r\n\r\n\t\t\ttmpGeo.computeFaceNormals();\r\n\t\t\ttmpGeo.computeVertexNormals();\r\n\r\n\t\t\t// store morph normals\r\n\r\n\t\t\tvar faceNormal, vertexNormals;\r\n\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\t\tfaceNormal = morphNormals.faceNormals[ f ];\r\n\t\t\t\tvertexNormals = morphNormals.vertexNormals[ f ];\r\n\r\n\t\t\t\tfaceNormal.copy( face.normal );\r\n\r\n\t\t\t\tif ( face instanceof THREE.Face3 ) {\r\n\r\n\t\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\r\n\t\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\r\n\t\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\r\n\t\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\r\n\t\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\r\n\t\t\t\t\tvertexNormals.d.copy( face.vertexNormals[ 3 ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// restore original normals\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\tface.normal = face.__originalFaceNormal;\r\n\t\t\tface.vertexNormals = face.__originalVertexNormals;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeTangents: function () {\r\n\r\n\t\t// based on http://www.terathon.com/code/tangent.html\r\n\t\t// tangents go to vertices\r\n\r\n\t\tvar f, fl, v, vl, i, il, vertexIndex,\r\n\t\t\tface, uv, vA, vB, vC, uvA, uvB, uvC,\r\n\t\t\tx1, x2, y1, y2, z1, z2,\r\n\t\t\ts1, s2, t1, t2, r, t, test,\r\n\t\t\ttan1 = [], tan2 = [],\r\n\t\t\tsdir = new THREE.Vector3(), tdir = new THREE.Vector3(),\r\n\t\t\ttmp = new THREE.Vector3(), tmp2 = new THREE.Vector3(),\r\n\t\t\tn = new THREE.Vector3(), w;\r\n\r\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\r\n\t\t\ttan1[ v ] = new THREE.Vector3();\r\n\t\t\ttan2[ v ] = new THREE.Vector3();\r\n\r\n\t\t}\r\n\r\n\t\tfunction handleTriangle( context, a, b, c, ua, ub, uc ) {\r\n\r\n\t\t\tvA = context.vertices[ a ];\r\n\t\t\tvB = context.vertices[ b ];\r\n\t\t\tvC = context.vertices[ c ];\r\n\r\n\t\t\tuvA = uv[ ua ];\r\n\t\t\tuvB = uv[ ub ];\r\n\t\t\tuvC = uv[ uc ];\r\n\r\n\t\t\tx1 = vB.x - vA.x;\r\n\t\t\tx2 = vC.x - vA.x;\r\n\t\t\ty1 = vB.y - vA.y;\r\n\t\t\ty2 = vC.y - vA.y;\r\n\t\t\tz1 = vB.z - vA.z;\r\n\t\t\tz2 = vC.z - vA.z;\r\n\r\n\t\t\ts1 = uvB.x - uvA.x;\r\n\t\t\ts2 = uvC.x - uvA.x;\r\n\t\t\tt1 = uvB.y - uvA.y;\r\n\t\t\tt2 = uvC.y - uvA.y;\r\n\r\n\t\t\tr = 1.0 / ( s1 * t2 - s2 * t1 );\r\n\t\t\tsdir.set( ( t2 * x1 - t1 * x2 ) * r,\r\n\t\t\t\t\t  ( t2 * y1 - t1 * y2 ) * r,\r\n\t\t\t\t\t  ( t2 * z1 - t1 * z2 ) * r );\r\n\t\t\ttdir.set( ( s1 * x2 - s2 * x1 ) * r,\r\n\t\t\t\t\t  ( s1 * y2 - s2 * y1 ) * r,\r\n\t\t\t\t\t  ( s1 * z2 - s2 * z1 ) * r );\r\n\r\n\t\t\ttan1[ a ].add( sdir );\r\n\t\t\ttan1[ b ].add( sdir );\r\n\t\t\ttan1[ c ].add( sdir );\r\n\r\n\t\t\ttan2[ a ].add( tdir );\r\n\t\t\ttan2[ b ].add( tdir );\r\n\t\t\ttan2[ c ].add( tdir );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\t\t\tuv = this.faceVertexUvs[ 0 ][ f ]; // use UV layer 0 for tangents\r\n\r\n\t\t\tif ( face instanceof THREE.Face3 ) {\r\n\r\n\t\t\t\thandleTriangle( this, face.a, face.b, face.c, 0, 1, 2 );\r\n\r\n\t\t\t} else if ( face instanceof THREE.Face4 ) {\r\n\r\n\t\t\t\thandleTriangle( this, face.a, face.b, face.d, 0, 1, 3 );\r\n\t\t\t\thandleTriangle( this, face.b, face.c, face.d, 1, 2, 3 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar faceIndex = [ 'a', 'b', 'c', 'd' ];\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\tfor ( i = 0; i < face.vertexNormals.length; i++ ) {\r\n\r\n\t\t\t\tn.copy( face.vertexNormals[ i ] );\r\n\r\n\t\t\t\tvertexIndex = face[ faceIndex[ i ] ];\r\n\r\n\t\t\t\tt = tan1[ vertexIndex ];\r\n\r\n\t\t\t\t// Gram-Schmidt orthogonalize\r\n\r\n\t\t\t\ttmp.copy( t );\r\n\t\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\r\n\r\n\t\t\t\t// Calculate handedness\r\n\r\n\t\t\t\ttmp2.crossVectors( face.vertexNormals[ i ], t );\r\n\t\t\t\ttest = tmp2.dot( tan2[ vertexIndex ] );\r\n\t\t\t\tw = (test < 0.0) ? -1.0 : 1.0;\r\n\r\n\t\t\t\tface.vertexTangents[ i ] = new THREE.Vector4( tmp.x, tmp.y, tmp.z, w );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.hasTangents = true;\r\n\r\n\t},\r\n\r\n\tcomputeLineDistances: function ( ) {\r\n\r\n\t\tvar d = 0;\r\n\t\tvar vertices = this.vertices;\r\n\r\n\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tif ( i > 0 ) {\r\n\r\n\t\t\t\td += vertices[ i ].distanceTo( vertices[ i - 1 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.lineDistances[ i ] = d;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeBoundingBox: function () {\r\n\r\n\t\tif ( this.boundingBox === null ) {\r\n\r\n\t\t\tthis.boundingBox = new THREE.Box3();\r\n\r\n\t\t}\r\n\r\n\t\tthis.boundingBox.setFromPoints( this.vertices );\r\n\r\n\t},\r\n\r\n\tcomputeBoundingSphere: function () {\r\n\r\n\t\tif ( this.boundingSphere === null ) {\r\n\r\n\t\t\tthis.boundingSphere = new THREE.Sphere();\r\n\r\n\t\t}\r\n\r\n\t\tthis.boundingSphere.setFromCenterAndPoints( this.boundingSphere.center, this.vertices );\r\n\r\n\t},\r\n\r\n\t/*\r\n\t * Checks for duplicate vertices with hashmap.\r\n\t * Duplicated vertices are removed\r\n\t * and faces' vertices are updated.\r\n\t */\r\n\r\n\tmergeVertices: function () {\r\n\r\n\t\tvar verticesMap = {}; // Hashmap for looking up vertice by position coordinates (and making sure they are unique)\r\n\t\tvar unique = [], changes = [];\r\n\r\n\t\tvar v, key;\r\n\t\tvar precisionPoints = 4; // number of decimal points, eg. 4 for epsilon of 0.0001\r\n\t\tvar precision = Math.pow( 10, precisionPoints );\r\n\t\tvar i,il, face;\r\n\t\tvar indices, k, j, jl, u;\r\n\r\n\t\t// reset cache of vertices as it now will be changing.\r\n\t\tthis.__tmpVertices = undefined;\r\n\r\n\t\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tv = this.vertices[ i ];\r\n\t\t\tkey = [ Math.round( v.x * precision ), Math.round( v.y * precision ), Math.round( v.z * precision ) ].join( '_' );\r\n\r\n\t\t\tif ( verticesMap[ key ] === undefined ) {\r\n\r\n\t\t\t\tverticesMap[ key ] = i;\r\n\t\t\t\tunique.push( this.vertices[ i ] );\r\n\t\t\t\tchanges[ i ] = unique.length - 1;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\r\n\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\r\n\t\t// if faces are completely degenerate after merging vertices, we\r\n\t\t// have to remove them from the geometry.\r\n\t\tvar faceIndicesToRemove = [];\r\n\r\n\t\tfor( i = 0, il = this.faces.length; i < il; i ++ ) {\r\n\r\n\t\t\tface = this.faces[ i ];\r\n\r\n\t\t\tif ( face instanceof THREE.Face3 ) {\r\n\r\n\t\t\t\tface.a = changes[ face.a ];\r\n\t\t\t\tface.b = changes[ face.b ];\r\n\t\t\t\tface.c = changes[ face.c ];\r\n\r\n\t\t\t\tindices = [ face.a, face.b, face.c ];\r\n\r\n\t\t\t\tvar dupIndex = -1;\r\n\r\n\t\t\t\t// if any duplicate vertices are found in a Face3\r\n\t\t\t\t// we have to remove the face as nothing can be saved\r\n\t\t\t\tfor ( var n = 0; n < 3; n ++ ) {\r\n\t\t\t\t\tif ( indices[ n ] == indices[ ( n + 1 ) % 3 ] ) {\r\n\r\n\t\t\t\t\t\tdupIndex = n;\r\n\t\t\t\t\t\tfaceIndicesToRemove.push( i );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( face instanceof THREE.Face4 ) {\r\n\r\n\t\t\t\tface.a = changes[ face.a ];\r\n\t\t\t\tface.b = changes[ face.b ];\r\n\t\t\t\tface.c = changes[ face.c ];\r\n\t\t\t\tface.d = changes[ face.d ];\r\n\r\n\t\t\t\t// check dups in (a, b, c, d) and convert to -> face3\r\n\r\n\t\t\t\tindices = [ face.a, face.b, face.c, face.d ];\r\n\r\n\t\t\t\tvar dupIndex = -1;\r\n\r\n\t\t\t\tfor ( var n = 0; n < 4; n ++ ) {\r\n\r\n\t\t\t\t\tif ( indices[ n ] == indices[ ( n + 1 ) % 4 ] ) {\r\n\r\n\t\t\t\t\t\t// if more than one duplicated vertex is found\r\n\t\t\t\t\t\t// we can't generate any valid Face3's, thus\r\n\t\t\t\t\t\t// we need to remove this face complete.\r\n\t\t\t\t\t\tif ( dupIndex >= 0 ) {\r\n\r\n\t\t\t\t\t\t\tfaceIndicesToRemove.push( i );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tdupIndex = n;\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( dupIndex >= 0 ) {\r\n\r\n\t\t\t\t\tindices.splice( dupIndex, 1 );\r\n\r\n\t\t\t\t\tvar newFace = new THREE.Face3( indices[0], indices[1], indices[2], face.normal, face.color, face.materialIndex );\r\n\r\n\t\t\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\tu = this.faceVertexUvs[ j ][ i ];\r\n\r\n\t\t\t\t\t\tif ( u ) {\r\n\t\t\t\t\t\t\tu.splice( dupIndex, 1 );\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif( face.vertexNormals && face.vertexNormals.length > 0) {\r\n\r\n\t\t\t\t\t\tnewFace.vertexNormals = face.vertexNormals;\r\n\t\t\t\t\t\tnewFace.vertexNormals.splice( dupIndex, 1 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif( face.vertexColors && face.vertexColors.length > 0 ) {\r\n\r\n\t\t\t\t\t\tnewFace.vertexColors = face.vertexColors;\r\n\t\t\t\t\t\tnewFace.vertexColors.splice( dupIndex, 1 );\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis.faces[ i ] = newFace;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\r\n\r\n\t\t\tthis.faces.splice( i, 1 );\r\n\r\n\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tthis.faceVertexUvs[ j ].splice( i, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Use unique set of vertices\r\n\r\n\t\tvar diff = this.vertices.length - unique.length;\r\n\t\tthis.vertices = unique;\r\n\t\treturn diff;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\tvar geometry = new THREE.Geometry();\r\n\r\n\t\tvar vertices = this.vertices;\r\n\r\n\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tgeometry.vertices.push( vertices[ i ].clone() );\r\n\r\n\t\t}\r\n\r\n\t\tvar faces = this.faces;\r\n\r\n\t\tfor ( var i = 0, il = faces.length; i < il; i ++ ) {\r\n\r\n\t\t\tgeometry.faces.push( faces[ i ].clone() );\r\n\r\n\t\t}\r\n\r\n\t\tvar uvs = this.faceVertexUvs[ 0 ];\r\n\r\n\t\tfor ( var i = 0, il = uvs.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar uv = uvs[ i ], uvCopy = [];\r\n\r\n\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tuvCopy.push( new THREE.Vector2( uv[ j ].x, uv[ j ].y ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.faceVertexUvs[ 0 ].push( uvCopy );\r\n\r\n\t\t}\r\n\r\n\t\treturn geometry;\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.GeometryIdCount = 0;\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.BufferGeometry = function () {\r\n\r\n\tTHREE.EventDispatcher.call( this );\r\n\r\n\tthis.id = THREE.GeometryIdCount ++;\r\n\r\n\t// attributes\r\n\r\n\tthis.attributes = {};\r\n\r\n\t// attributes typed arrays are kept only if dynamic flag is set\r\n\r\n\tthis.dynamic = false;\r\n\r\n\t// offsets for chunks when using indexed elements\r\n\r\n\tthis.offsets = [];\r\n\r\n\t// boundings\r\n\r\n\tthis.boundingBox = null;\r\n\tthis.boundingSphere = null;\r\n\r\n\tthis.hasTangents = false;\r\n\r\n\t// for compatibility\r\n\r\n\tthis.morphTargets = [];\r\n\r\n};\r\n\r\nTHREE.BufferGeometry.prototype = {\r\n\r\n\tconstructor : THREE.BufferGeometry,\r\n\r\n\tapplyMatrix: function ( matrix ) {\r\n\r\n\t\tvar positionArray;\r\n\t\tvar normalArray;\r\n\r\n\t\tif ( this.attributes[ \"position\" ] ) positionArray = this.attributes[ \"position\" ].array;\r\n\t\tif ( this.attributes[ \"normal\" ] ) normalArray = this.attributes[ \"normal\" ].array;\r\n\r\n\t\tif ( positionArray !== undefined ) {\r\n\r\n\t\t\tmatrix.multiplyVector3Array( positionArray );\r\n\t\t\tthis.verticesNeedUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( normalArray !== undefined ) {\r\n\r\n\t\t\tvar normalMatrix = new THREE.Matrix3();\r\n\t\t\tnormalMatrix.getInverse( matrix ).transpose();\r\n\r\n\t\t\tnormalMatrix.multiplyVector3Array( normalArray );\r\n\r\n\t\t\tthis.normalizeNormals();\r\n\r\n\t\t\tthis.normalsNeedUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeBoundingBox: function () {\r\n\r\n\t\tif ( this.boundingBox === null ) {\r\n\r\n\t\t\tthis.boundingBox = new THREE.Box3();\r\n\r\n\t\t}\r\n\r\n\t\tvar positions = this.attributes[ \"position\" ].array;\r\n\r\n\t\tif ( positions ) {\r\n\r\n\t\t\tvar bb = this.boundingBox;\r\n\t\t\tvar x, y, z;\r\n\r\n\t\t\tif( positions.length >= 3 ) {\r\n\t\t\t\tbb.min.x = bb.max.x = positions[ 0 ];\r\n\t\t\t\tbb.min.y = bb.max.y = positions[ 1 ];\r\n\t\t\t\tbb.min.z = bb.max.z = positions[ 2 ];\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 3, il = positions.length; i < il; i += 3 ) {\r\n\r\n\t\t\t\tx = positions[ i ];\r\n\t\t\t\ty = positions[ i + 1 ];\r\n\t\t\t\tz = positions[ i + 2 ];\r\n\r\n\t\t\t\t// bounding box\r\n\r\n\t\t\t\tif ( x < bb.min.x ) {\r\n\r\n\t\t\t\t\tbb.min.x = x;\r\n\r\n\t\t\t\t} else if ( x > bb.max.x ) {\r\n\r\n\t\t\t\t\tbb.max.x = x;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( y < bb.min.y ) {\r\n\r\n\t\t\t\t\tbb.min.y = y;\r\n\r\n\t\t\t\t} else if ( y > bb.max.y ) {\r\n\r\n\t\t\t\t\tbb.max.y = y;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( z < bb.min.z ) {\r\n\r\n\t\t\t\t\tbb.min.z = z;\r\n\r\n\t\t\t\t} else if ( z > bb.max.z ) {\r\n\r\n\t\t\t\t\tbb.max.z = z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( positions === undefined || positions.length === 0 ) {\r\n\r\n\t\t\tthis.boundingBox.min.set( 0, 0, 0 );\r\n\t\t\tthis.boundingBox.max.set( 0, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeBoundingSphere: function () {\r\n\r\n\t\tif ( this.boundingSphere === null ) {\r\n\r\n\t\t\tthis.boundingSphere = new THREE.Sphere();\r\n\r\n\t\t}\r\n\r\n\t\tvar positions = this.attributes[ \"position\" ].array;\r\n\r\n\t\tif ( positions ) {\r\n\r\n\t\t\tvar radiusSq, maxRadiusSq = 0;\r\n\t\t\tvar x, y, z;\r\n\r\n\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\r\n\r\n\t\t\t\tx = positions[ i ];\r\n\t\t\t\ty = positions[ i + 1 ];\r\n\t\t\t\tz = positions[ i + 2 ];\r\n\r\n\t\t\t\tradiusSq =  x * x + y * y + z * z;\r\n\t\t\t\tif ( radiusSq > maxRadiusSq ) maxRadiusSq = radiusSq;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeVertexNormals: function () {\r\n\r\n\t\tif ( this.attributes[ \"position\" ] ) {\r\n\r\n\t\t\tvar i, il;\r\n\t\t\tvar j, jl;\r\n\r\n\t\t\tvar nVertexElements = this.attributes[ \"position\" ].array.length;\r\n\r\n\t\t\tif ( this.attributes[ \"normal\" ] === undefined ) {\r\n\r\n\t\t\t\tthis.attributes[ \"normal\" ] = {\r\n\r\n\t\t\t\t\titemSize: 3,\r\n\t\t\t\t\tarray: new Float32Array( nVertexElements ),\r\n\t\t\t\t\tnumItems: nVertexElements\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// reset existing normals to zero\r\n\r\n\t\t\t\tfor ( i = 0, il = this.attributes[ \"normal\" ].array.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tthis.attributes[ \"normal\" ].array[ i ] = 0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar positions = this.attributes[ \"position\" ].array;\r\n\t\t\tvar normals = this.attributes[ \"normal\" ].array;\r\n\r\n\t\t\tvar vA, vB, vC, x, y, z,\r\n\r\n\t\t\tpA = new THREE.Vector3(),\r\n\t\t\tpB = new THREE.Vector3(),\r\n\t\t\tpC = new THREE.Vector3(),\r\n\r\n\t\t\tcb = new THREE.Vector3(),\r\n\t\t\tab = new THREE.Vector3();\r\n\r\n\t\t\t// indexed elements\r\n\r\n\t\t\tif ( this.attributes[ \"index\" ] ) {\r\n\r\n\t\t\t\tvar indices = this.attributes[ \"index\" ].array;\r\n\r\n\t\t\t\tvar offsets = this.offsets;\r\n\r\n\t\t\t\tfor ( j = 0, jl = offsets.length; j < jl; ++ j ) {\r\n\r\n\t\t\t\t\tvar start = offsets[ j ].start;\r\n\t\t\t\t\tvar count = offsets[ j ].count;\r\n\t\t\t\t\tvar index = offsets[ j ].index;\r\n\r\n\t\t\t\t\tfor ( i = start, il = start + count; i < il; i += 3 ) {\r\n\r\n\t\t\t\t\t\tvA = index + indices[ i ];\r\n\t\t\t\t\t\tvB = index + indices[ i + 1 ];\r\n\t\t\t\t\t\tvC = index + indices[ i + 2 ];\r\n\r\n\t\t\t\t\t\tx = positions[ vA * 3 ];\r\n\t\t\t\t\t\ty = positions[ vA * 3 + 1 ];\r\n\t\t\t\t\t\tz = positions[ vA * 3 + 2 ];\r\n\t\t\t\t\t\tpA.set( x, y, z );\r\n\r\n\t\t\t\t\t\tx = positions[ vB * 3 ];\r\n\t\t\t\t\t\ty = positions[ vB * 3 + 1 ];\r\n\t\t\t\t\t\tz = positions[ vB * 3 + 2 ];\r\n\t\t\t\t\t\tpB.set( x, y, z );\r\n\r\n\t\t\t\t\t\tx = positions[ vC * 3 ];\r\n\t\t\t\t\t\ty = positions[ vC * 3 + 1 ];\r\n\t\t\t\t\t\tz = positions[ vC * 3 + 2 ];\r\n\t\t\t\t\t\tpC.set( x, y, z );\r\n\r\n\t\t\t\t\t\tcb.subVectors( pC, pB );\r\n\t\t\t\t\t\tab.subVectors( pA, pB );\r\n\t\t\t\t\t\tcb.cross( ab );\r\n\r\n\t\t\t\t\t\tnormals[ vA * 3 ]     += cb.x;\r\n\t\t\t\t\t\tnormals[ vA * 3 + 1 ] += cb.y;\r\n\t\t\t\t\t\tnormals[ vA * 3 + 2 ] += cb.z;\r\n\r\n\t\t\t\t\t\tnormals[ vB * 3 ]     += cb.x;\r\n\t\t\t\t\t\tnormals[ vB * 3 + 1 ] += cb.y;\r\n\t\t\t\t\t\tnormals[ vB * 3 + 2 ] += cb.z;\r\n\r\n\t\t\t\t\t\tnormals[ vC * 3 ]     += cb.x;\r\n\t\t\t\t\t\tnormals[ vC * 3 + 1 ] += cb.y;\r\n\t\t\t\t\t\tnormals[ vC * 3 + 2 ] += cb.z;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t// non-indexed elements (unconnected triangle soup)\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfor ( i = 0, il = positions.length; i < il; i += 9 ) {\r\n\r\n\t\t\t\t\tx = positions[ i ];\r\n\t\t\t\t\ty = positions[ i + 1 ];\r\n\t\t\t\t\tz = positions[ i + 2 ];\r\n\t\t\t\t\tpA.set( x, y, z );\r\n\r\n\t\t\t\t\tx = positions[ i + 3 ];\r\n\t\t\t\t\ty = positions[ i + 4 ];\r\n\t\t\t\t\tz = positions[ i + 5 ];\r\n\t\t\t\t\tpB.set( x, y, z );\r\n\r\n\t\t\t\t\tx = positions[ i + 6 ];\r\n\t\t\t\t\ty = positions[ i + 7 ];\r\n\t\t\t\t\tz = positions[ i + 8 ];\r\n\t\t\t\t\tpC.set( x, y, z );\r\n\r\n\t\t\t\t\tcb.subVectors( pC, pB );\r\n\t\t\t\t\tab.subVectors( pA, pB );\r\n\t\t\t\t\tcb.cross( ab );\r\n\r\n\t\t\t\t\tnormals[ i ] \t = cb.x;\r\n\t\t\t\t\tnormals[ i + 1 ] = cb.y;\r\n\t\t\t\t\tnormals[ i + 2 ] = cb.z;\r\n\r\n\t\t\t\t\tnormals[ i + 3 ] = cb.x;\r\n\t\t\t\t\tnormals[ i + 4 ] = cb.y;\r\n\t\t\t\t\tnormals[ i + 5 ] = cb.z;\r\n\r\n\t\t\t\t\tnormals[ i + 6 ] = cb.x;\r\n\t\t\t\t\tnormals[ i + 7 ] = cb.y;\r\n\t\t\t\t\tnormals[ i + 8 ] = cb.z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.normalizeNormals();\r\n\r\n\t\t\tthis.normalsNeedUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tnormalizeNormals: function () {\r\n\r\n\t\tvar normals = this.attributes[ \"normal\" ].array;\r\n\r\n\t\tvar x, y, z, n;\r\n\r\n\t\tfor ( var i = 0, il = normals.length; i < il; i += 3 ) {\r\n\r\n\t\t\tx = normals[ i ];\r\n\t\t\ty = normals[ i + 1 ];\r\n\t\t\tz = normals[ i + 2 ];\r\n\r\n\t\t\tn = 1.0 / Math.sqrt( x * x + y * y + z * z );\r\n\r\n\t\t\tnormals[ i ] \t *= n;\r\n\t\t\tnormals[ i + 1 ] *= n;\r\n\t\t\tnormals[ i + 2 ] *= n;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeTangents: function () {\r\n\r\n\t\t// based on http://www.terathon.com/code/tangent.html\r\n\t\t// (per vertex tangents)\r\n\r\n\t\tif ( this.attributes[ \"index\" ] === undefined ||\r\n\t\t\t this.attributes[ \"position\" ] === undefined ||\r\n\t\t\t this.attributes[ \"normal\" ] === undefined ||\r\n\t\t\t this.attributes[ \"uv\" ] === undefined ) {\r\n\r\n\t\t\tconsole.warn( \"Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()\" );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar indices = this.attributes[ \"index\" ].array;\r\n\t\tvar positions = this.attributes[ \"position\" ].array;\r\n\t\tvar normals = this.attributes[ \"normal\" ].array;\r\n\t\tvar uvs = this.attributes[ \"uv\" ].array;\r\n\r\n\t\tvar nVertices = positions.length / 3;\r\n\r\n\t\tif ( this.attributes[ \"tangent\" ] === undefined ) {\r\n\r\n\t\t\tvar nTangentElements = 4 * nVertices;\r\n\r\n\t\t\tthis.attributes[ \"tangent\" ] = {\r\n\r\n\t\t\t\titemSize: 4,\r\n\t\t\t\tarray: new Float32Array( nTangentElements ),\r\n\t\t\t\tnumItems: nTangentElements\r\n\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tvar tangents = this.attributes[ \"tangent\" ].array;\r\n\r\n\t\tvar tan1 = [], tan2 = [];\r\n\r\n\t\tfor ( var k = 0; k < nVertices; k ++ ) {\r\n\r\n\t\t\ttan1[ k ] = new THREE.Vector3();\r\n\t\t\ttan2[ k ] = new THREE.Vector3();\r\n\r\n\t\t}\r\n\r\n\t\tvar xA, yA, zA,\r\n\t\t\txB, yB, zB,\r\n\t\t\txC, yC, zC,\r\n\r\n\t\t\tuA, vA,\r\n\t\t\tuB, vB,\r\n\t\t\tuC, vC,\r\n\r\n\t\t\tx1, x2, y1, y2, z1, z2,\r\n\t\t\ts1, s2, t1, t2, r;\r\n\r\n\t\tvar sdir = new THREE.Vector3(), tdir = new THREE.Vector3();\r\n\r\n\t\tfunction handleTriangle( a, b, c ) {\r\n\r\n\t\t\txA = positions[ a * 3 ];\r\n\t\t\tyA = positions[ a * 3 + 1 ];\r\n\t\t\tzA = positions[ a * 3 + 2 ];\r\n\r\n\t\t\txB = positions[ b * 3 ];\r\n\t\t\tyB = positions[ b * 3 + 1 ];\r\n\t\t\tzB = positions[ b * 3 + 2 ];\r\n\r\n\t\t\txC = positions[ c * 3 ];\r\n\t\t\tyC = positions[ c * 3 + 1 ];\r\n\t\t\tzC = positions[ c * 3 + 2 ];\r\n\r\n\t\t\tuA = uvs[ a * 2 ];\r\n\t\t\tvA = uvs[ a * 2 + 1 ];\r\n\r\n\t\t\tuB = uvs[ b * 2 ];\r\n\t\t\tvB = uvs[ b * 2 + 1 ];\r\n\r\n\t\t\tuC = uvs[ c * 2 ];\r\n\t\t\tvC = uvs[ c * 2 + 1 ];\r\n\r\n\t\t\tx1 = xB - xA;\r\n\t\t\tx2 = xC - xA;\r\n\r\n\t\t\ty1 = yB - yA;\r\n\t\t\ty2 = yC - yA;\r\n\r\n\t\t\tz1 = zB - zA;\r\n\t\t\tz2 = zC - zA;\r\n\r\n\t\t\ts1 = uB - uA;\r\n\t\t\ts2 = uC - uA;\r\n\r\n\t\t\tt1 = vB - vA;\r\n\t\t\tt2 = vC - vA;\r\n\r\n\t\t\tr = 1.0 / ( s1 * t2 - s2 * t1 );\r\n\r\n\t\t\tsdir.set(\r\n\t\t\t\t( t2 * x1 - t1 * x2 ) * r,\r\n\t\t\t\t( t2 * y1 - t1 * y2 ) * r,\r\n\t\t\t\t( t2 * z1 - t1 * z2 ) * r\r\n\t\t\t);\r\n\r\n\t\t\ttdir.set(\r\n\t\t\t\t( s1 * x2 - s2 * x1 ) * r,\r\n\t\t\t\t( s1 * y2 - s2 * y1 ) * r,\r\n\t\t\t\t( s1 * z2 - s2 * z1 ) * r\r\n\t\t\t);\r\n\r\n\t\t\ttan1[ a ].add( sdir );\r\n\t\t\ttan1[ b ].add( sdir );\r\n\t\t\ttan1[ c ].add( sdir );\r\n\r\n\t\t\ttan2[ a ].add( tdir );\r\n\t\t\ttan2[ b ].add( tdir );\r\n\t\t\ttan2[ c ].add( tdir );\r\n\r\n\t\t}\r\n\r\n\t\tvar i, il;\r\n\t\tvar j, jl;\r\n\t\tvar iA, iB, iC;\r\n\r\n\t\tvar offsets = this.offsets;\r\n\r\n\t\tfor ( j = 0, jl = offsets.length; j < jl; ++ j ) {\r\n\r\n\t\t\tvar start = offsets[ j ].start;\r\n\t\t\tvar count = offsets[ j ].count;\r\n\t\t\tvar index = offsets[ j ].index;\r\n\r\n\t\t\tfor ( i = start, il = start + count; i < il; i += 3 ) {\r\n\r\n\t\t\t\tiA = index + indices[ i ];\r\n\t\t\t\tiB = index + indices[ i + 1 ];\r\n\t\t\t\tiC = index + indices[ i + 2 ];\r\n\r\n\t\t\t\thandleTriangle( iA, iB, iC );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3();\r\n\t\tvar n = new THREE.Vector3(), n2 = new THREE.Vector3();\r\n\t\tvar w, t, test;\r\n\r\n\t\tfunction handleVertex( v ) {\r\n\r\n\t\t\tn.x = normals[ v * 3 ];\r\n\t\t\tn.y = normals[ v * 3 + 1 ];\r\n\t\t\tn.z = normals[ v * 3 + 2 ];\r\n\r\n\t\t\tn2.copy( n );\r\n\r\n\t\t\tt = tan1[ v ];\r\n\r\n\t\t\t// Gram-Schmidt orthogonalize\r\n\r\n\t\t\ttmp.copy( t );\r\n\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\r\n\r\n\t\t\t// Calculate handedness\r\n\r\n\t\t\ttmp2.crossVectors( n2, t );\r\n\t\t\ttest = tmp2.dot( tan2[ v ] );\r\n\t\t\tw = ( test < 0.0 ) ? -1.0 : 1.0;\r\n\r\n\t\t\ttangents[ v * 4 ] \t  = tmp.x;\r\n\t\t\ttangents[ v * 4 + 1 ] = tmp.y;\r\n\t\t\ttangents[ v * 4 + 2 ] = tmp.z;\r\n\t\t\ttangents[ v * 4 + 3 ] = w;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( j = 0, jl = offsets.length; j < jl; ++ j ) {\r\n\r\n\t\t\tvar start = offsets[ j ].start;\r\n\t\t\tvar count = offsets[ j ].count;\r\n\t\t\tvar index = offsets[ j ].index;\r\n\r\n\t\t\tfor ( i = start, il = start + count; i < il; i += 3 ) {\r\n\r\n\t\t\t\tiA = index + indices[ i ];\r\n\t\t\t\tiB = index + indices[ i + 1 ];\r\n\t\t\t\tiC = index + indices[ i + 2 ];\r\n\r\n\t\t\t\thandleVertex( iA );\r\n\t\t\t\thandleVertex( iB );\r\n\t\t\t\thandleVertex( iC );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.hasTangents = true;\r\n\t\tthis.tangentsNeedUpdate = true;\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n */\r\n\r\nTHREE.Camera = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.matrixWorldInverse = new THREE.Matrix4();\r\n\r\n\tthis.projectionMatrix = new THREE.Matrix4();\r\n\tthis.projectionMatrixInverse = new THREE.Matrix4();\r\n\r\n};\r\n\r\nTHREE.Camera.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.Camera.prototype.lookAt = function ( vector ) {\r\n\r\n\t// TODO: Add hierarchy support.\r\n\r\n\tthis.matrix.lookAt( this.position, vector, this.up );\r\n\r\n\tif ( this.rotationAutoUpdate === true ) {\r\n\r\n\t\tif ( this.useQuaternion === false )  {\r\n\r\n\t\t\tthis.rotation.setEulerFromRotationMatrix( this.matrix, this.eulerOrder );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.quaternion.copy( this.matrix.decompose()[ 1 ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {\r\n\r\n\tTHREE.Camera.call( this );\r\n\r\n\tthis.left = left;\r\n\tthis.right = right;\r\n\tthis.top = top;\r\n\tthis.bottom = bottom;\r\n\r\n\tthis.near = ( near !== undefined ) ? near : 0.1;\r\n\tthis.far = ( far !== undefined ) ? far : 2000;\r\n\r\n\tthis.updateProjectionMatrix();\r\n\r\n};\r\n\r\nTHREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );\r\n\r\nTHREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {\r\n\r\n\tthis.projectionMatrix.makeOrthographic( this.left, this.right, this.top, this.bottom, this.near, this.far );\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author greggman / http://games.greggman.com/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n */\r\n\r\nTHREE.PerspectiveCamera = function ( fov, aspect, near, far ) {\r\n\r\n\tTHREE.Camera.call( this );\r\n\r\n\tthis.fov = fov !== undefined ? fov : 50;\r\n\tthis.aspect = aspect !== undefined ? aspect : 1;\r\n\tthis.near = near !== undefined ? near : 0.1;\r\n\tthis.far = far !== undefined ? far : 2000;\r\n\r\n\tthis.updateProjectionMatrix();\r\n\r\n};\r\n\r\nTHREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );\r\n\r\n\r\n/**\r\n * Uses Focal Length (in mm) to estimate and set FOV\r\n * 35mm (fullframe) camera is used if frame size is not specified;\r\n * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html\r\n */\r\n\r\nTHREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {\r\n\r\n\tif ( frameHeight === undefined ) frameHeight = 24;\r\n\r\n\tthis.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );\r\n\tthis.updateProjectionMatrix();\r\n\r\n}\r\n\r\n\r\n/**\r\n * Sets an offset in a larger frustum. This is useful for multi-window or\r\n * multi-monitor/multi-machine setups.\r\n *\r\n * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\r\n * the monitors are in grid like this\r\n *\r\n *   +---+---+---+\r\n *   | A | B | C |\r\n *   +---+---+---+\r\n *   | D | E | F |\r\n *   +---+---+---+\r\n *\r\n * then for each monitor you would call it like this\r\n *\r\n *   var w = 1920;\r\n *   var h = 1080;\r\n *   var fullWidth = w * 3;\r\n *   var fullHeight = h * 2;\r\n *\r\n *   --A--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\r\n *   --B--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\r\n *   --C--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\r\n *   --D--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\r\n *   --E--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\r\n *   --F--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\r\n *\r\n *   Note there is no reason monitors have to be the same size or in a grid.\r\n */\r\n\r\nTHREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {\r\n\r\n\tthis.fullWidth = fullWidth;\r\n\tthis.fullHeight = fullHeight;\r\n\tthis.x = x;\r\n\tthis.y = y;\r\n\tthis.width = width;\r\n\tthis.height = height;\r\n\r\n\tthis.updateProjectionMatrix();\r\n\r\n};\r\n\r\n\r\nTHREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {\r\n\r\n\tif ( this.fullWidth ) {\r\n\r\n\t\tvar aspect = this.fullWidth / this.fullHeight;\r\n\t\tvar top = Math.tan( THREE.Math.degToRad( this.fov * 0.5 ) ) * this.near;\r\n\t\tvar bottom = -top;\r\n\t\tvar left = aspect * bottom;\r\n\t\tvar right = aspect * top;\r\n\t\tvar width = Math.abs( right - left );\r\n\t\tvar height = Math.abs( top - bottom );\r\n\r\n\t\tthis.projectionMatrix.makeFrustum(\r\n\t\t\tleft + this.x * width / this.fullWidth,\r\n\t\t\tleft + ( this.x + this.width ) * width / this.fullWidth,\r\n\t\t\ttop - ( this.y + this.height ) * height / this.fullHeight,\r\n\t\t\ttop - this.y * height / this.fullHeight,\r\n\t\t\tthis.near,\r\n\t\t\tthis.far\r\n\t\t);\r\n\r\n\t} else {\r\n\r\n\t\tthis.projectionMatrix.makePerspective( this.fov, this.aspect, this.near, this.far );\r\n\r\n\t}\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n \r\nTHREE.Light = function ( hex ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.color = new THREE.Color( hex );\r\n\r\n};\r\n\r\nTHREE.Light.prototype = Object.create( THREE.Object3D.prototype );\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.AmbientLight = function ( hex ) {\r\n\r\n\tTHREE.Light.call( this, hex );\r\n\r\n};\r\n\r\nTHREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );\r\n/**\r\n * @author MPanknin / http://www.redplant.de/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.AreaLight = function ( hex, intensity ) {\r\n\r\n\tTHREE.Light.call( this, hex );\r\n\r\n\tthis.normal = new THREE.Vector3( 0, -1, 0 );\r\n\tthis.right = new THREE.Vector3( 1, 0, 0 );\r\n\r\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n\r\n\tthis.width = 1.0;\r\n\tthis.height = 1.0;\r\n\r\n\tthis.constantAttenuation = 1.5;\r\n\tthis.linearAttenuation = 0.5;\r\n\tthis.quadraticAttenuation = 0.1;\r\n\r\n};\r\n\r\nTHREE.AreaLight.prototype = Object.create( THREE.Light.prototype );\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.DirectionalLight = function ( hex, intensity ) {\r\n\r\n\tTHREE.Light.call( this, hex );\r\n\r\n\tthis.position = new THREE.Vector3( 0, 1, 0 );\r\n\tthis.target = new THREE.Object3D();\r\n\r\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n\r\n\tthis.castShadow = false;\r\n\tthis.onlyShadow = false;\r\n\r\n\t//\r\n\r\n\tthis.shadowCameraNear = 50;\r\n\tthis.shadowCameraFar = 5000;\r\n\r\n\tthis.shadowCameraLeft = -500;\r\n\tthis.shadowCameraRight = 500;\r\n\tthis.shadowCameraTop = 500;\r\n\tthis.shadowCameraBottom = -500;\r\n\r\n\tthis.shadowCameraVisible = false;\r\n\r\n\tthis.shadowBias = 0;\r\n\tthis.shadowDarkness = 0.5;\r\n\r\n\tthis.shadowMapWidth = 512;\r\n\tthis.shadowMapHeight = 512;\r\n\r\n\t//\r\n\r\n\tthis.shadowCascade = false;\r\n\r\n\tthis.shadowCascadeOffset = new THREE.Vector3( 0, 0, -1000 );\r\n\tthis.shadowCascadeCount = 2;\r\n\r\n\tthis.shadowCascadeBias = [ 0, 0, 0 ];\r\n\tthis.shadowCascadeWidth = [ 512, 512, 512 ];\r\n\tthis.shadowCascadeHeight = [ 512, 512, 512 ];\r\n\r\n\tthis.shadowCascadeNearZ = [ -1.000, 0.990, 0.998 ];\r\n\tthis.shadowCascadeFarZ  = [  0.990, 0.998, 1.000 ];\r\n\r\n\tthis.shadowCascadeArray = [];\r\n\r\n\t//\r\n\r\n\tthis.shadowMap = null;\r\n\tthis.shadowMapSize = null;\r\n\tthis.shadowCamera = null;\r\n\tthis.shadowMatrix = null;\r\n\r\n};\r\n\r\nTHREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.HemisphereLight = function ( skyColorHex, groundColorHex, intensity ) {\r\n\r\n\tTHREE.Light.call( this, skyColorHex );\r\n\r\n\tthis.groundColor = new THREE.Color( groundColorHex );\r\n\r\n\tthis.position = new THREE.Vector3( 0, 100, 0 );\r\n\r\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n\r\n};\r\n\r\nTHREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.PointLight = function ( hex, intensity, distance ) {\r\n\r\n\tTHREE.Light.call( this, hex );\r\n\r\n\tthis.position = new THREE.Vector3( 0, 0, 0 );\r\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\r\n\r\n};\r\n\r\nTHREE.PointLight.prototype = Object.create( THREE.Light.prototype );\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.SpotLight = function ( hex, intensity, distance, angle, exponent ) {\r\n\r\n\tTHREE.Light.call( this, hex );\r\n\r\n\tthis.position = new THREE.Vector3( 0, 1, 0 );\r\n\tthis.target = new THREE.Object3D();\r\n\r\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\r\n\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 2;\r\n\tthis.exponent = ( exponent !== undefined ) ? exponent : 10;\r\n\r\n\tthis.castShadow = false;\r\n\tthis.onlyShadow = false;\r\n\r\n\t//\r\n\r\n\tthis.shadowCameraNear = 50;\r\n\tthis.shadowCameraFar = 5000;\r\n\tthis.shadowCameraFov = 50;\r\n\r\n\tthis.shadowCameraVisible = false;\r\n\r\n\tthis.shadowBias = 0;\r\n\tthis.shadowDarkness = 0.5;\r\n\r\n\tthis.shadowMapWidth = 512;\r\n\tthis.shadowMapHeight = 512;\r\n\r\n\t//\r\n\r\n\tthis.shadowMap = null;\r\n\tthis.shadowMapSize = null;\r\n\tthis.shadowCamera = null;\r\n\tthis.shadowMatrix = null;\r\n\r\n};\r\n\r\nTHREE.SpotLight.prototype = Object.create( THREE.Light.prototype );\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Loader = function ( showStatus ) {\r\n\r\n\tthis.showStatus = showStatus;\r\n\tthis.statusDomElement = showStatus ? THREE.Loader.prototype.addStatusElement() : null;\r\n\r\n\tthis.onLoadStart = function () {};\r\n\tthis.onLoadProgress = function () {};\r\n\tthis.onLoadComplete = function () {};\r\n\r\n};\r\n\r\nTHREE.Loader.prototype = {\r\n\r\n\tconstructor: THREE.Loader,\r\n\r\n\tcrossOrigin: 'anonymous',\r\n\r\n\taddStatusElement: function () {\r\n\r\n\t\tvar e = document.createElement( \"div\" );\r\n\r\n\t\te.style.position = \"absolute\";\r\n\t\te.style.right = \"0px\";\r\n\t\te.style.top = \"0px\";\r\n\t\te.style.fontSize = \"0.8em\";\r\n\t\te.style.textAlign = \"left\";\r\n\t\te.style.background = \"rgba(0,0,0,0.25)\";\r\n\t\te.style.color = \"#fff\";\r\n\t\te.style.width = \"120px\";\r\n\t\te.style.padding = \"0.5em 0.5em 0.5em 0.5em\";\r\n\t\te.style.zIndex = 1000;\r\n\r\n\t\te.innerHTML = \"Loading ...\";\r\n\r\n\t\treturn e;\r\n\r\n\t},\r\n\r\n\tupdateProgress: function ( progress ) {\r\n\r\n\t\tvar message = \"Loaded \";\r\n\r\n\t\tif ( progress.total ) {\r\n\r\n\t\t\tmessage += ( 100 * progress.loaded / progress.total ).toFixed(0) + \"%\";\r\n\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmessage += ( progress.loaded / 1000 ).toFixed(2) + \" KB\";\r\n\r\n\t\t}\r\n\r\n\t\tthis.statusDomElement.innerHTML = message;\r\n\r\n\t},\r\n\r\n\textractUrlBase: function ( url ) {\r\n\r\n\t\tvar parts = url.split( '/' );\r\n\t\tparts.pop();\r\n\t\treturn ( parts.length < 1 ? '.' : parts.join( '/' ) ) + '/';\r\n\r\n\t},\r\n\r\n\tinitMaterials: function ( materials, texturePath ) {\r\n\r\n\t\tvar array = [];\r\n\r\n\t\tfor ( var i = 0; i < materials.length; ++ i ) {\r\n\r\n\t\t\tarray[ i ] = THREE.Loader.prototype.createMaterial( materials[ i ], texturePath );\r\n\r\n\t\t}\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tneedsTangents: function ( materials ) {\r\n\r\n\t\tfor( var i = 0, il = materials.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar m = materials[ i ];\r\n\r\n\t\t\tif ( m instanceof THREE.ShaderMaterial ) return true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t},\r\n\r\n\tcreateMaterial: function ( m, texturePath ) {\r\n\r\n\t\tvar _this = this;\r\n\r\n\t\tfunction is_pow2( n ) {\r\n\r\n\t\t\tvar l = Math.log( n ) / Math.LN2;\r\n\t\t\treturn Math.floor( l ) == l;\r\n\r\n\t\t}\r\n\r\n\t\tfunction nearest_pow2( n ) {\r\n\r\n\t\t\tvar l = Math.log( n ) / Math.LN2;\r\n\t\t\treturn Math.pow( 2, Math.round(  l ) );\r\n\r\n\t\t}\r\n\r\n\t\tfunction load_image( where, url ) {\r\n\r\n\t\t\tvar image = new Image();\r\n\r\n\t\t\timage.onload = function () {\r\n\r\n\t\t\t\tif ( !is_pow2( this.width ) || !is_pow2( this.height ) ) {\r\n\r\n\t\t\t\t\tvar width = nearest_pow2( this.width );\r\n\t\t\t\t\tvar height = nearest_pow2( this.height );\r\n\r\n\t\t\t\t\twhere.image.width = width;\r\n\t\t\t\t\twhere.image.height = height;\r\n\t\t\t\t\twhere.image.getContext( '2d' ).drawImage( this, 0, 0, width, height );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\twhere.image = this;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\twhere.needsUpdate = true;\r\n\r\n\t\t\t};\r\n\r\n\t\t\timage.crossOrigin = _this.crossOrigin;\r\n\t\t\timage.src = url;\r\n\r\n\t\t}\r\n\r\n\t\tfunction create_texture( where, name, sourceFile, repeat, offset, wrap, anisotropy ) {\r\n\r\n\t\t\tvar isCompressed = /\\.dds$/i.test( sourceFile );\r\n\t\t\tvar fullPath = texturePath + \"/\" + sourceFile;\r\n\r\n\t\t\tif ( isCompressed ) {\r\n\r\n\t\t\t\tvar texture = THREE.ImageUtils.loadCompressedTexture( fullPath );\r\n\r\n\t\t\t\twhere[ name ] = texture;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar texture = document.createElement( 'canvas' );\r\n\r\n\t\t\t\twhere[ name ] = new THREE.Texture( texture );\r\n\r\n\t\t\t}\r\n\r\n\t\t\twhere[ name ].sourceFile = sourceFile;\r\n\r\n\t\t\tif( repeat ) {\r\n\r\n\t\t\t\twhere[ name ].repeat.set( repeat[ 0 ], repeat[ 1 ] );\r\n\r\n\t\t\t\tif ( repeat[ 0 ] !== 1 ) where[ name ].wrapS = THREE.RepeatWrapping;\r\n\t\t\t\tif ( repeat[ 1 ] !== 1 ) where[ name ].wrapT = THREE.RepeatWrapping;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( offset ) {\r\n\r\n\t\t\t\twhere[ name ].offset.set( offset[ 0 ], offset[ 1 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( wrap ) {\r\n\r\n\t\t\t\tvar wrapMap = {\r\n\t\t\t\t\t\"repeat\": THREE.RepeatWrapping,\r\n\t\t\t\t\t\"mirror\": THREE.MirroredRepeatWrapping\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( wrapMap[ wrap[ 0 ] ] !== undefined ) where[ name ].wrapS = wrapMap[ wrap[ 0 ] ];\r\n\t\t\t\tif ( wrapMap[ wrap[ 1 ] ] !== undefined ) where[ name ].wrapT = wrapMap[ wrap[ 1 ] ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( anisotropy ) {\r\n\r\n\t\t\t\twhere[ name ].anisotropy = anisotropy;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! isCompressed ) {\r\n\r\n\t\t\t\tload_image( where[ name ], fullPath );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction rgb2hex( rgb ) {\r\n\r\n\t\t\treturn ( rgb[ 0 ] * 255 << 16 ) + ( rgb[ 1 ] * 255 << 8 ) + rgb[ 2 ] * 255;\r\n\r\n\t\t}\r\n\r\n\t\t// defaults\r\n\r\n\t\tvar mtype = \"MeshLambertMaterial\";\r\n\t\tvar mpars = { color: 0xeeeeee, opacity: 1.0, map: null, lightMap: null, normalMap: null, bumpMap: null, wireframe: false };\r\n\r\n\t\t// parameters from model file\r\n\r\n\t\tif ( m.shading ) {\r\n\r\n\t\t\tvar shading = m.shading.toLowerCase();\r\n\r\n\t\t\tif ( shading === \"phong\" ) mtype = \"MeshPhongMaterial\";\r\n\t\t\telse if ( shading === \"basic\" ) mtype = \"MeshBasicMaterial\";\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.blending !== undefined && THREE[ m.blending ] !== undefined ) {\r\n\r\n\t\t\tmpars.blending = THREE[ m.blending ];\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.transparent !== undefined || m.opacity < 1.0 ) {\r\n\r\n\t\t\tmpars.transparent = m.transparent;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.depthTest !== undefined ) {\r\n\r\n\t\t\tmpars.depthTest = m.depthTest;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.depthWrite !== undefined ) {\r\n\r\n\t\t\tmpars.depthWrite = m.depthWrite;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.visible !== undefined ) {\r\n\r\n\t\t\tmpars.visible = m.visible;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.flipSided !== undefined ) {\r\n\r\n\t\t\tmpars.side = THREE.BackSide;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.doubleSided !== undefined ) {\r\n\r\n\t\t\tmpars.side = THREE.DoubleSide;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.wireframe !== undefined ) {\r\n\r\n\t\t\tmpars.wireframe = m.wireframe;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.vertexColors !== undefined ) {\r\n\r\n\t\t\tif ( m.vertexColors === \"face\" ) {\r\n\r\n\t\t\t\tmpars.vertexColors = THREE.FaceColors;\r\n\r\n\t\t\t} else if ( m.vertexColors ) {\r\n\r\n\t\t\t\tmpars.vertexColors = THREE.VertexColors;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// colors\r\n\r\n\t\tif ( m.colorDiffuse ) {\r\n\r\n\t\t\tmpars.color = rgb2hex( m.colorDiffuse );\r\n\r\n\t\t} else if ( m.DbgColor ) {\r\n\r\n\t\t\tmpars.color = m.DbgColor;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.colorSpecular ) {\r\n\r\n\t\t\tmpars.specular = rgb2hex( m.colorSpecular );\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.colorAmbient ) {\r\n\r\n\t\t\tmpars.ambient = rgb2hex( m.colorAmbient );\r\n\r\n\t\t}\r\n\r\n\t\t// modifiers\r\n\r\n\t\tif ( m.transparency ) {\r\n\r\n\t\t\tmpars.opacity = m.transparency;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.specularCoef ) {\r\n\r\n\t\t\tmpars.shininess = m.specularCoef;\r\n\r\n\t\t}\r\n\r\n\t\t// textures\r\n\r\n\t\tif ( m.mapDiffuse && texturePath ) {\r\n\r\n\t\t\tcreate_texture( mpars, \"map\", m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.mapLight && texturePath ) {\r\n\r\n\t\t\tcreate_texture( mpars, \"lightMap\", m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.mapBump && texturePath ) {\r\n\r\n\t\t\tcreate_texture( mpars, \"bumpMap\", m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.mapNormal && texturePath ) {\r\n\r\n\t\t\tcreate_texture( mpars, \"normalMap\", m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.mapSpecular && texturePath ) {\r\n\r\n\t\t\tcreate_texture( mpars, \"specularMap\", m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tif ( m.mapBumpScale ) {\r\n\r\n\t\t\tmpars.bumpScale = m.mapBumpScale;\r\n\r\n\t\t}\r\n\r\n\t\t// special case for normal mapped material\r\n\r\n\t\tif ( m.mapNormal ) {\r\n\r\n\t\t\tvar shader = THREE.ShaderLib[ \"normalmap\" ];\r\n\t\t\tvar uniforms = THREE.UniformsUtils.clone( shader.uniforms );\r\n\r\n\t\t\tuniforms[ \"tNormal\" ].value = mpars.normalMap;\r\n\r\n\t\t\tif ( m.mapNormalFactor ) {\r\n\r\n\t\t\t\tuniforms[ \"uNormalScale\" ].value.set( m.mapNormalFactor, m.mapNormalFactor );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( mpars.map ) {\r\n\r\n\t\t\t\tuniforms[ \"tDiffuse\" ].value = mpars.map;\r\n\t\t\t\tuniforms[ \"enableDiffuse\" ].value = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( mpars.specularMap ) {\r\n\r\n\t\t\t\tuniforms[ \"tSpecular\" ].value = mpars.specularMap;\r\n\t\t\t\tuniforms[ \"enableSpecular\" ].value = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( mpars.lightMap ) {\r\n\r\n\t\t\t\tuniforms[ \"tAO\" ].value = mpars.lightMap;\r\n\t\t\t\tuniforms[ \"enableAO\" ].value = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// for the moment don't handle displacement texture\r\n\r\n\t\t\tuniforms[ \"uDiffuseColor\" ].value.setHex( mpars.color );\r\n\t\t\tuniforms[ \"uSpecularColor\" ].value.setHex( mpars.specular );\r\n\t\t\tuniforms[ \"uAmbientColor\" ].value.setHex( mpars.ambient );\r\n\r\n\t\t\tuniforms[ \"uShininess\" ].value = mpars.shininess;\r\n\r\n\t\t\tif ( mpars.opacity !== undefined ) {\r\n\r\n\t\t\t\tuniforms[ \"uOpacity\" ].value = mpars.opacity;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms, lights: true, fog: true };\r\n\t\t\tvar material = new THREE.ShaderMaterial( parameters );\r\n\r\n\t\t\tif ( mpars.transparent ) {\r\n\r\n\t\t\t\tmaterial.transparent = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar material = new THREE[ mtype ]( mpars );\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.DbgName !== undefined ) material.name = m.DbgName;\r\n\r\n\t\treturn material;\r\n\r\n\t}\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.ImageLoader = function () {\r\n\r\n\tTHREE.EventDispatcher.call( this );\r\n\r\n\tthis.crossOrigin = null;\r\n\r\n};\r\n\r\nTHREE.ImageLoader.prototype = {\r\n\r\n\tconstructor: THREE.ImageLoader,\r\n\r\n\tload: function ( url, image ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tif ( image === undefined ) image = new Image();\r\n\r\n\t\timage.addEventListener( 'load', function () {\r\n\r\n\t\t\tscope.dispatchEvent( { type: 'load', content: image } );\r\n\r\n\t\t}, false );\r\n\r\n\t\timage.addEventListener( 'error', function () {\r\n\r\n\t\t\tscope.dispatchEvent( { type: 'error', message: 'Couldn\\'t load URL [' + url + ']' } );\r\n\r\n\t\t}, false );\r\n\r\n\t\tif ( scope.crossOrigin ) image.crossOrigin = scope.crossOrigin;\r\n\r\n\t\timage.src = url;\r\n\r\n\t}\r\n\r\n}\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.JSONLoader = function ( showStatus ) {\r\n\r\n\tTHREE.Loader.call( this, showStatus );\r\n\r\n\tthis.withCredentials = false;\r\n\r\n};\r\n\r\nTHREE.JSONLoader.prototype = Object.create( THREE.Loader.prototype );\r\n\r\nTHREE.JSONLoader.prototype.load = function ( url, callback, texturePath ) {\r\n\r\n\tvar scope = this;\r\n\r\n\t// todo: unify load API to for easier SceneLoader use\r\n\r\n\ttexturePath = texturePath && ( typeof texturePath === \"string\" ) ? texturePath : this.extractUrlBase( url );\r\n\r\n\tthis.onLoadStart();\r\n\tthis.loadAjaxJSON( this, url, callback, texturePath );\r\n\r\n};\r\n\r\nTHREE.JSONLoader.prototype.loadAjaxJSON = function ( context, url, callback, texturePath, callbackProgress ) {\r\n\r\n\tvar xhr = new XMLHttpRequest();\r\n\r\n\tvar length = 0;\r\n\r\n\txhr.onreadystatechange = function () {\r\n\r\n\t\tif ( xhr.readyState === xhr.DONE ) {\r\n\r\n\t\t\tif ( xhr.status === 200 || xhr.status === 0 ) {\r\n\r\n\t\t\t\tif ( xhr.responseText ) {\r\n\r\n\t\t\t\t\tvar json = JSON.parse( xhr.responseText );\r\n\t\t\t\t\tcontext.createModel( json, callback, texturePath );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.warn( \"THREE.JSONLoader: [\" + url + \"] seems to be unreachable or file there is empty\" );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// in context of more complex asset initialization\r\n\t\t\t\t// do not block on single failed file\r\n\t\t\t\t// maybe should go even one more level up\r\n\r\n\t\t\t\tcontext.onLoadComplete();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.error( \"THREE.JSONLoader: Couldn't load [\" + url + \"] [\" + xhr.status + \"]\" );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( xhr.readyState === xhr.LOADING ) {\r\n\r\n\t\t\tif ( callbackProgress ) {\r\n\r\n\t\t\t\tif ( length === 0 ) {\r\n\r\n\t\t\t\t\tlength = xhr.getResponseHeader( \"Content-Length\" );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcallbackProgress( { total: length, loaded: xhr.responseText.length } );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( xhr.readyState === xhr.HEADERS_RECEIVED ) {\r\n\r\n\t\t\tlength = xhr.getResponseHeader( \"Content-Length\" );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\txhr.open( \"GET\", url, true );\r\n\txhr.withCredentials = this.withCredentials;\r\n\txhr.send( null );\r\n\r\n};\r\n\r\nTHREE.JSONLoader.prototype.createModel = function ( json, callback, texturePath ) {\r\n\r\n\tvar scope = this,\r\n\tgeometry = new THREE.Geometry(),\r\n\tscale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;\r\n\r\n\tparseModel( scale );\r\n\r\n\tparseSkin();\r\n\tparseMorphing( scale );\r\n\r\n\tgeometry.computeCentroids();\r\n\tgeometry.computeFaceNormals();\r\n\r\n\tfunction parseModel( scale ) {\r\n\r\n\t\tfunction isBitSet( value, position ) {\r\n\r\n\t\t\treturn value & ( 1 << position );\r\n\r\n\t\t}\r\n\r\n\t\tvar i, j, fi,\r\n\r\n\t\toffset, zLength, nVertices,\r\n\r\n\t\tcolorIndex, normalIndex, uvIndex, materialIndex,\r\n\r\n\t\ttype,\r\n\t\tisQuad,\r\n\t\thasMaterial,\r\n\t\thasFaceUv, hasFaceVertexUv,\r\n\t\thasFaceNormal, hasFaceVertexNormal,\r\n\t\thasFaceColor, hasFaceVertexColor,\r\n\r\n\t\tvertex, face, color, normal,\r\n\r\n\t\tuvLayer, uvs, u, v,\r\n\r\n\t\tfaces = json.faces,\r\n\t\tvertices = json.vertices,\r\n\t\tnormals = json.normals,\r\n\t\tcolors = json.colors,\r\n\r\n\t\tnUvLayers = 0;\r\n\r\n\t\t// disregard empty arrays\r\n\r\n\t\tfor ( i = 0; i < json.uvs.length; i++ ) {\r\n\r\n\t\t\tif ( json.uvs[ i ].length ) nUvLayers ++;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( i = 0; i < nUvLayers; i++ ) {\r\n\r\n\t\t\tgeometry.faceUvs[ i ] = [];\r\n\t\t\tgeometry.faceVertexUvs[ i ] = [];\r\n\r\n\t\t}\r\n\r\n\t\toffset = 0;\r\n\t\tzLength = vertices.length;\r\n\r\n\t\twhile ( offset < zLength ) {\r\n\r\n\t\t\tvertex = new THREE.Vector3();\r\n\r\n\t\t\tvertex.x = vertices[ offset ++ ] * scale;\r\n\t\t\tvertex.y = vertices[ offset ++ ] * scale;\r\n\t\t\tvertex.z = vertices[ offset ++ ] * scale;\r\n\r\n\t\t\tgeometry.vertices.push( vertex );\r\n\r\n\t\t}\r\n\r\n\t\toffset = 0;\r\n\t\tzLength = faces.length;\r\n\r\n\t\twhile ( offset < zLength ) {\r\n\r\n\t\t\ttype = faces[ offset ++ ];\r\n\r\n\r\n\t\t\tisQuad          \t= isBitSet( type, 0 );\r\n\t\t\thasMaterial         = isBitSet( type, 1 );\r\n\t\t\thasFaceUv           = isBitSet( type, 2 );\r\n\t\t\thasFaceVertexUv     = isBitSet( type, 3 );\r\n\t\t\thasFaceNormal       = isBitSet( type, 4 );\r\n\t\t\thasFaceVertexNormal = isBitSet( type, 5 );\r\n\t\t\thasFaceColor\t    = isBitSet( type, 6 );\r\n\t\t\thasFaceVertexColor  = isBitSet( type, 7 );\r\n\r\n\t\t\t//console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceUv, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\r\n\r\n\t\t\tif ( isQuad ) {\r\n\r\n\t\t\t\tface = new THREE.Face4();\r\n\r\n\t\t\t\tface.a = faces[ offset ++ ];\r\n\t\t\t\tface.b = faces[ offset ++ ];\r\n\t\t\t\tface.c = faces[ offset ++ ];\r\n\t\t\t\tface.d = faces[ offset ++ ];\r\n\r\n\t\t\t\tnVertices = 4;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tface = new THREE.Face3();\r\n\r\n\t\t\t\tface.a = faces[ offset ++ ];\r\n\t\t\t\tface.b = faces[ offset ++ ];\r\n\t\t\t\tface.c = faces[ offset ++ ];\r\n\r\n\t\t\t\tnVertices = 3;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasMaterial ) {\r\n\r\n\t\t\t\tmaterialIndex = faces[ offset ++ ];\r\n\t\t\t\tface.materialIndex = materialIndex;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// to get face <=> uv index correspondence\r\n\r\n\t\t\tfi = geometry.faces.length;\r\n\r\n\t\t\tif ( hasFaceUv ) {\r\n\r\n\t\t\t\tfor ( i = 0; i < nUvLayers; i++ ) {\r\n\r\n\t\t\t\t\tuvLayer = json.uvs[ i ];\r\n\r\n\t\t\t\t\tuvIndex = faces[ offset ++ ];\r\n\r\n\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\r\n\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\r\n\r\n\t\t\t\t\tgeometry.faceUvs[ i ][ fi ] = new THREE.Vector2( u, v );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceVertexUv ) {\r\n\r\n\t\t\t\tfor ( i = 0; i < nUvLayers; i++ ) {\r\n\r\n\t\t\t\t\tuvLayer = json.uvs[ i ];\r\n\r\n\t\t\t\t\tuvs = [];\r\n\r\n\t\t\t\t\tfor ( j = 0; j < nVertices; j ++ ) {\r\n\r\n\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\r\n\r\n\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\r\n\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\r\n\r\n\t\t\t\t\t\tuvs[ j ] = new THREE.Vector2( u, v );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = uvs;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceNormal ) {\r\n\r\n\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\r\n\t\t\t\tnormal = new THREE.Vector3();\r\n\r\n\t\t\t\tnormal.x = normals[ normalIndex ++ ];\r\n\t\t\t\tnormal.y = normals[ normalIndex ++ ];\r\n\t\t\t\tnormal.z = normals[ normalIndex ];\r\n\r\n\t\t\t\tface.normal = normal;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceVertexNormal ) {\r\n\r\n\t\t\t\tfor ( i = 0; i < nVertices; i++ ) {\r\n\r\n\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\r\n\t\t\t\t\tnormal = new THREE.Vector3();\r\n\r\n\t\t\t\t\tnormal.x = normals[ normalIndex ++ ];\r\n\t\t\t\t\tnormal.y = normals[ normalIndex ++ ];\r\n\t\t\t\t\tnormal.z = normals[ normalIndex ];\r\n\r\n\t\t\t\t\tface.vertexNormals.push( normal );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tif ( hasFaceColor ) {\r\n\r\n\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\r\n\t\t\t\tcolor = new THREE.Color( colors[ colorIndex ] );\r\n\t\t\t\tface.color = color;\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tif ( hasFaceVertexColor ) {\r\n\r\n\t\t\t\tfor ( i = 0; i < nVertices; i++ ) {\r\n\r\n\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\r\n\t\t\t\t\tcolor = new THREE.Color( colors[ colorIndex ] );\r\n\t\t\t\t\tface.vertexColors.push( color );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.faces.push( face );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction parseSkin() {\r\n\r\n\t\tvar i, l, x, y, z, w, a, b, c, d;\r\n\r\n\t\tif ( json.skinWeights ) {\r\n\r\n\t\t\tfor ( i = 0, l = json.skinWeights.length; i < l; i += 2 ) {\r\n\r\n\t\t\t\tx = json.skinWeights[ i     ];\r\n\t\t\t\ty = json.skinWeights[ i + 1 ];\r\n\t\t\t\tz = 0;\r\n\t\t\t\tw = 0;\r\n\r\n\t\t\t\tgeometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( json.skinIndices ) {\r\n\r\n\t\t\tfor ( i = 0, l = json.skinIndices.length; i < l; i += 2 ) {\r\n\r\n\t\t\t\ta = json.skinIndices[ i     ];\r\n\t\t\t\tb = json.skinIndices[ i + 1 ];\r\n\t\t\t\tc = 0;\r\n\t\t\t\td = 0;\r\n\r\n\t\t\t\tgeometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tgeometry.bones = json.bones;\r\n\t\tgeometry.animation = json.animation;\r\n\r\n\t};\r\n\r\n\tfunction parseMorphing( scale ) {\r\n\r\n\t\tif ( json.morphTargets !== undefined ) {\r\n\r\n\t\t\tvar i, l, v, vl, dstVertices, srcVertices;\r\n\r\n\t\t\tfor ( i = 0, l = json.morphTargets.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tgeometry.morphTargets[ i ] = {};\r\n\t\t\t\tgeometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\r\n\t\t\t\tgeometry.morphTargets[ i ].vertices = [];\r\n\r\n\t\t\t\tdstVertices = geometry.morphTargets[ i ].vertices;\r\n\t\t\t\tsrcVertices = json.morphTargets [ i ].vertices;\r\n\r\n\t\t\t\tfor( v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\r\n\r\n\t\t\t\t\tvar vertex = new THREE.Vector3();\r\n\t\t\t\t\tvertex.x = srcVertices[ v ] * scale;\r\n\t\t\t\t\tvertex.y = srcVertices[ v + 1 ] * scale;\r\n\t\t\t\t\tvertex.z = srcVertices[ v + 2 ] * scale;\r\n\r\n\t\t\t\t\tdstVertices.push( vertex );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( json.morphColors !== undefined ) {\r\n\r\n\t\t\tvar i, l, c, cl, dstColors, srcColors, color;\r\n\r\n\t\t\tfor ( i = 0, l = json.morphColors.length; i < l; i++ ) {\r\n\r\n\t\t\t\tgeometry.morphColors[ i ] = {};\r\n\t\t\t\tgeometry.morphColors[ i ].name = json.morphColors[ i ].name;\r\n\t\t\t\tgeometry.morphColors[ i ].colors = [];\r\n\r\n\t\t\t\tdstColors = geometry.morphColors[ i ].colors;\r\n\t\t\t\tsrcColors = json.morphColors [ i ].colors;\r\n\r\n\t\t\t\tfor ( c = 0, cl = srcColors.length; c < cl; c += 3 ) {\r\n\r\n\t\t\t\t\tcolor = new THREE.Color( 0xffaa00 );\r\n\t\t\t\t\tcolor.setRGB( srcColors[ c ], srcColors[ c + 1 ], srcColors[ c + 2 ] );\r\n\t\t\t\t\tdstColors.push( color );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar materials = this.initMaterials( json.materials, texturePath );\r\n\r\n\tif ( this.needsTangents( materials ) ) geometry.computeTangents();\r\n\r\n\tcallback( geometry, materials );\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.LoadingMonitor = function () {\r\n\r\n\tTHREE.EventDispatcher.call( this );\r\n\r\n\tvar scope = this;\r\n\r\n\tvar loaded = 0;\r\n\tvar total = 0;\r\n\r\n\tvar onLoad = function ( event ) {\r\n\r\n\t\tloaded ++;\r\n\r\n\t\tscope.dispatchEvent( { type: 'progress', loaded: loaded, total: total } );\r\n\r\n\t\tif ( loaded === total ) {\r\n\r\n\t\t\tscope.dispatchEvent( { type: 'load' } );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.add = function ( loader ) {\r\n\r\n\t\ttotal ++;\r\n\r\n\t\tloader.addEventListener( 'load', onLoad, false );\r\n\r\n\t};\r\n\r\n};\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.SceneLoader = function () {\r\n\r\n\tthis.onLoadStart = function () {};\r\n\tthis.onLoadProgress = function() {};\r\n\tthis.onLoadComplete = function () {};\r\n\r\n\tthis.callbackSync = function () {};\r\n\tthis.callbackProgress = function () {};\r\n\r\n\tthis.geometryHandlerMap = {};\r\n\tthis.hierarchyHandlerMap = {};\r\n\r\n\tthis.addGeometryHandler( \"ascii\", THREE.JSONLoader );\r\n\r\n};\r\n\r\nTHREE.SceneLoader.prototype.constructor = THREE.SceneLoader;\r\n\r\nTHREE.SceneLoader.prototype.load = function ( url, callbackFinished ) {\r\n\r\n\tvar scope = this;\r\n\r\n\tvar xhr = new XMLHttpRequest();\r\n\r\n\txhr.onreadystatechange = function () {\r\n\r\n\t\tif ( xhr.readyState === 4 ) {\r\n\r\n\t\t\tif ( xhr.status === 200 || xhr.status === 0 ) {\r\n\r\n\t\t\t\tvar json = JSON.parse( xhr.responseText );\r\n\t\t\t\tscope.parse( json, callbackFinished, url );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.error( \"THREE.SceneLoader: Couldn't load [\" + url + \"] [\" + xhr.status + \"]\" );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\txhr.open( \"GET\", url, true );\r\n\txhr.send( null );\r\n\r\n};\r\n\r\nTHREE.SceneLoader.prototype.addGeometryHandler = function ( typeID, loaderClass ) {\r\n\r\n\tthis.geometryHandlerMap[ typeID ] = { \"loaderClass\": loaderClass };\r\n\r\n};\r\n\r\nTHREE.SceneLoader.prototype.addHierarchyHandler = function ( typeID, loaderClass ) {\r\n\r\n\tthis.hierarchyHandlerMap[ typeID ] = { \"loaderClass\": loaderClass };\r\n\r\n};\r\n\r\nTHREE.SceneLoader.prototype.parse = function ( json, callbackFinished, url ) {\r\n\r\n\tvar scope = this;\r\n\r\n\tvar urlBase = THREE.Loader.prototype.extractUrlBase( url );\r\n\r\n\tvar geometry, material, camera, fog,\r\n\t\ttexture, images, color,\r\n\t\tlight, hex, intensity,\r\n\t\tcounter_models, counter_textures,\r\n\t\ttotal_models, total_textures,\r\n\t\tresult;\r\n\r\n\tvar target_array = [];\r\n\r\n\tvar data = json;\r\n\r\n\t// async geometry loaders\r\n\r\n\tfor ( var typeID in this.geometryHandlerMap ) {\r\n\r\n\t\tvar loaderClass = this.geometryHandlerMap[ typeID ][ \"loaderClass\" ];\r\n\t\tthis.geometryHandlerMap[ typeID ][ \"loaderObject\" ] = new loaderClass();\r\n\r\n\t}\r\n\r\n\t// async hierachy loaders\r\n\r\n\tfor ( var typeID in this.hierarchyHandlerMap ) {\r\n\r\n\t\tvar loaderClass = this.hierarchyHandlerMap[ typeID ][ \"loaderClass\" ];\r\n\t\tthis.hierarchyHandlerMap[ typeID ][ \"loaderObject\" ] = new loaderClass();\r\n\r\n\t}\r\n\r\n\tcounter_models = 0;\r\n\tcounter_textures = 0;\r\n\r\n\tresult = {\r\n\r\n\t\tscene: new THREE.Scene(),\r\n\t\tgeometries: {},\r\n\t\tface_materials: {},\r\n\t\tmaterials: {},\r\n\t\ttextures: {},\r\n\t\tobjects: {},\r\n\t\tcameras: {},\r\n\t\tlights: {},\r\n\t\tfogs: {},\r\n\t\tempties: {},\r\n\t\tgroups: {}\r\n\r\n\t};\r\n\r\n\tif ( data.transform ) {\r\n\r\n\t\tvar position = data.transform.position,\r\n\t\t\trotation = data.transform.rotation,\r\n\t\t\tscale = data.transform.scale;\r\n\r\n\t\tif ( position )\r\n\t\t\tresult.scene.position.set( position[ 0 ], position[ 1 ], position [ 2 ] );\r\n\r\n\t\tif ( rotation )\r\n\t\t\tresult.scene.rotation.set( rotation[ 0 ], rotation[ 1 ], rotation [ 2 ] );\r\n\r\n\t\tif ( scale )\r\n\t\t\tresult.scene.scale.set( scale[ 0 ], scale[ 1 ], scale [ 2 ] );\r\n\r\n\t\tif ( position || rotation || scale ) {\r\n\r\n\t\t\tresult.scene.updateMatrix();\r\n\t\t\tresult.scene.updateMatrixWorld();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction get_url( source_url, url_type ) {\r\n\r\n\t\tif ( url_type == \"relativeToHTML\" ) {\r\n\r\n\t\t\treturn source_url;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn urlBase + \"/\" + source_url;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// toplevel loader function, delegates to handle_children\r\n\r\n\tfunction handle_objects() {\r\n\r\n\t\thandle_children( result.scene, data.objects );\r\n\r\n\t}\r\n\r\n\t// handle all the children from the loaded json and attach them to given parent\r\n\r\n\tfunction handle_children( parent, children ) {\r\n\r\n\t\tvar mat, dst, pos, rot, scl, quat;\r\n\r\n\t\tfor ( var objID in children ) {\r\n\r\n\t\t\t// check by id if child has already been handled,\r\n\t\t\t// if not, create new object\r\n\r\n\t\t\tif ( result.objects[ objID ] === undefined ) {\r\n\r\n\t\t\t\tvar objJSON = children[ objID ];\r\n\r\n\t\t\t\tvar object = null;\r\n\r\n\t\t\t\t// meshes\r\n\r\n\t\t\t\tif ( objJSON.type && ( objJSON.type in scope.hierarchyHandlerMap ) ) {\r\n\r\n\t\t\t\t\tif ( objJSON.loading === undefined ) {\r\n\r\n\t\t\t\t\t\tvar reservedTypes = { \"type\": 1, \"url\": 1, \"material\": 1,\r\n\t\t\t\t\t\t\t\t\t\t\t  \"position\": 1, \"rotation\": 1, \"scale\" : 1,\r\n\t\t\t\t\t\t\t\t\t\t\t  \"visible\": 1, \"children\": 1, \"properties\": 1,\r\n\t\t\t\t\t\t\t\t\t\t\t  \"skin\": 1, \"morph\": 1, \"mirroredLoop\": 1, \"duration\": 1 };\r\n\r\n\t\t\t\t\t\tvar loaderParameters = {};\r\n\r\n\t\t\t\t\t\tfor ( var parType in objJSON ) {\r\n\r\n\t\t\t\t\t\t\tif ( ! ( parType in reservedTypes ) ) {\r\n\r\n\t\t\t\t\t\t\t\tloaderParameters[ parType ] = objJSON[ parType ];\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tmaterial = result.materials[ objJSON.material ];\r\n\r\n\t\t\t\t\t\tobjJSON.loading = true;\r\n\r\n\t\t\t\t\t\tvar loader = scope.hierarchyHandlerMap[ objJSON.type ][ \"loaderObject\" ];\r\n\r\n\t\t\t\t\t\t// ColladaLoader\r\n\r\n\t\t\t\t\t\tif ( loader.options ) {\r\n\r\n\t\t\t\t\t\t\tloader.load( get_url( objJSON.url, data.urlBaseType ), create_callback_hierachy( objID, parent, material, objJSON ) );\r\n\r\n\t\t\t\t\t\t// UTF8Loader\r\n\t\t\t\t\t\t// OBJLoader\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tloader.load( get_url( objJSON.url, data.urlBaseType ), create_callback_hierachy( objID, parent, material, objJSON ), loaderParameters );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( objJSON.geometry !== undefined ) {\r\n\r\n\t\t\t\t\tgeometry = result.geometries[ objJSON.geometry ];\r\n\r\n\t\t\t\t\t// geometry already loaded\r\n\r\n\t\t\t\t\tif ( geometry ) {\r\n\r\n\t\t\t\t\t\tvar needsTangents = false;\r\n\r\n\t\t\t\t\t\tmaterial = result.materials[ objJSON.material ];\r\n\t\t\t\t\t\tneedsTangents = material instanceof THREE.ShaderMaterial;\r\n\r\n\t\t\t\t\t\tpos = objJSON.position;\r\n\t\t\t\t\t\trot = objJSON.rotation;\r\n\t\t\t\t\t\tscl = objJSON.scale;\r\n\t\t\t\t\t\tmat = objJSON.matrix;\r\n\t\t\t\t\t\tquat = objJSON.quaternion;\r\n\r\n\t\t\t\t\t\t// use materials from the model file\r\n\t\t\t\t\t\t// if there is no material specified in the object\r\n\r\n\t\t\t\t\t\tif ( ! objJSON.material ) {\r\n\r\n\t\t\t\t\t\t\tmaterial = new THREE.MeshFaceMaterial( result.face_materials[ objJSON.geometry ] );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// use materials from the model file\r\n\t\t\t\t\t\t// if there is just empty face material\r\n\t\t\t\t\t\t// (must create new material as each model has its own face material)\r\n\r\n\t\t\t\t\t\tif ( ( material instanceof THREE.MeshFaceMaterial ) && material.materials.length === 0 ) {\r\n\r\n\t\t\t\t\t\t\tmaterial = new THREE.MeshFaceMaterial( result.face_materials[ objJSON.geometry ] );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( material instanceof THREE.MeshFaceMaterial ) {\r\n\r\n\t\t\t\t\t\t\tfor ( var i = 0; i < material.materials.length; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tneedsTangents = needsTangents || ( material.materials[ i ] instanceof THREE.ShaderMaterial );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( needsTangents ) {\r\n\r\n\t\t\t\t\t\t\tgeometry.computeTangents();\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( objJSON.skin ) {\r\n\r\n\t\t\t\t\t\t\tobject = new THREE.SkinnedMesh( geometry, material );\r\n\r\n\t\t\t\t\t\t} else if ( objJSON.morph ) {\r\n\r\n\t\t\t\t\t\t\tobject = new THREE.MorphAnimMesh( geometry, material );\r\n\r\n\t\t\t\t\t\t\tif ( objJSON.duration !== undefined ) {\r\n\r\n\t\t\t\t\t\t\t\tobject.duration = objJSON.duration;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( objJSON.time !== undefined ) {\r\n\r\n\t\t\t\t\t\t\t\tobject.time = objJSON.time;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( objJSON.mirroredLoop !== undefined ) {\r\n\r\n\t\t\t\t\t\t\t\tobject.mirroredLoop = objJSON.mirroredLoop;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( material.morphNormals ) {\r\n\r\n\t\t\t\t\t\t\t\tgeometry.computeMorphNormals();\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tobject = new THREE.Mesh( geometry, material );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tobject.name = objID;\r\n\r\n\t\t\t\t\t\tif ( mat ) {\r\n\r\n\t\t\t\t\t\t\tobject.matrixAutoUpdate = false;\r\n\t\t\t\t\t\t\tobject.matrix.set(\r\n\t\t\t\t\t\t\t\tmat[0],  mat[1],  mat[2],  mat[3],\r\n\t\t\t\t\t\t\t\tmat[4],  mat[5],  mat[6],  mat[7],\r\n\t\t\t\t\t\t\t\tmat[8],  mat[9],  mat[10], mat[11],\r\n\t\t\t\t\t\t\t\tmat[12], mat[13], mat[14], mat[15]\r\n\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tobject.position.set( pos[0], pos[1], pos[2] );\r\n\r\n\t\t\t\t\t\t\tif ( quat ) {\r\n\r\n\t\t\t\t\t\t\t\tobject.quaternion.set( quat[0], quat[1], quat[2], quat[3] );\r\n\t\t\t\t\t\t\t\tobject.useQuaternion = true;\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tobject.rotation.set( rot[0], rot[1], rot[2] );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tobject.scale.set( scl[0], scl[1], scl[2] );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tobject.visible = objJSON.visible;\r\n\t\t\t\t\t\tobject.castShadow = objJSON.castShadow;\r\n\t\t\t\t\t\tobject.receiveShadow = objJSON.receiveShadow;\r\n\r\n\t\t\t\t\t\tparent.add( object );\r\n\r\n\t\t\t\t\t\tresult.objects[ objID ] = object;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t// lights\r\n\r\n\t\t\t\t} else if ( objJSON.type === \"DirectionalLight\" || objJSON.type === \"PointLight\" || objJSON.type === \"AmbientLight\" ) {\r\n\r\n\t\t\t\t\thex = ( objJSON.color !== undefined ) ? objJSON.color : 0xffffff;\r\n\t\t\t\t\tintensity = ( objJSON.intensity !== undefined ) ? objJSON.intensity : 1;\r\n\r\n\t\t\t\t\tif ( objJSON.type === \"DirectionalLight\" ) {\r\n\r\n\t\t\t\t\t\tpos = objJSON.direction;\r\n\r\n\t\t\t\t\t\tlight = new THREE.DirectionalLight( hex, intensity );\r\n\t\t\t\t\t\tlight.position.set( pos[0], pos[1], pos[2] );\r\n\r\n\t\t\t\t\t\tif ( objJSON.target ) {\r\n\r\n\t\t\t\t\t\t\ttarget_array.push( { \"object\": light, \"targetName\" : objJSON.target } );\r\n\r\n\t\t\t\t\t\t\t// kill existing default target\r\n\t\t\t\t\t\t\t// otherwise it gets added to scene when parent gets added\r\n\r\n\t\t\t\t\t\t\tlight.target = null;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( objJSON.type === \"PointLight\" ) {\r\n\r\n\t\t\t\t\t\tpos = objJSON.position;\r\n\t\t\t\t\t\tdst = objJSON.distance;\r\n\r\n\t\t\t\t\t\tlight = new THREE.PointLight( hex, intensity, dst );\r\n\t\t\t\t\t\tlight.position.set( pos[0], pos[1], pos[2] );\r\n\r\n\t\t\t\t\t} else if ( objJSON.type === \"AmbientLight\" ) {\r\n\r\n\t\t\t\t\t\tlight = new THREE.AmbientLight( hex );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tparent.add( light );\r\n\r\n\t\t\t\t\tlight.name = objID;\r\n\t\t\t\t\tresult.lights[ objID ] = light;\r\n\t\t\t\t\tresult.objects[ objID ] = light;\r\n\r\n\t\t\t\t// cameras\r\n\r\n\t\t\t\t} else if ( objJSON.type === \"PerspectiveCamera\" || objJSON.type === \"OrthographicCamera\" ) {\r\n\r\n\t\t\t\t\tif ( objJSON.type === \"PerspectiveCamera\" ) {\r\n\r\n\t\t\t\t\t\tcamera = new THREE.PerspectiveCamera( objJSON.fov, objJSON.aspect, objJSON.near, objJSON.far );\r\n\r\n\t\t\t\t\t} else if ( objJSON.type === \"OrthographicCamera\" ) {\r\n\r\n\t\t\t\t\t\tcamera = new THREE.OrthographicCamera( objJSON.left, objJSON.right, objJSON.top, objJSON.bottom, objJSON.near, objJSON.far );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tpos = objJSON.position;\r\n\t\t\t\t\tcamera.position.set( pos[0], pos[1], pos[2] );\r\n\t\t\t\t\tparent.add( camera );\r\n\r\n\t\t\t\t\tcamera.name = objID;\r\n\t\t\t\t\tresult.cameras[ objID ] = camera;\r\n\t\t\t\t\tresult.objects[ objID ] = camera;\r\n\r\n\t\t\t\t// pure Object3D\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tpos = objJSON.position;\r\n\t\t\t\t\trot = objJSON.rotation;\r\n\t\t\t\t\tscl = objJSON.scale;\r\n\t\t\t\t\tquat = objJSON.quaternion;\r\n\r\n\t\t\t\t\tobject = new THREE.Object3D();\r\n\t\t\t\t\tobject.name = objID;\r\n\t\t\t\t\tobject.position.set( pos[0], pos[1], pos[2] );\r\n\r\n\t\t\t\t\tif ( quat ) {\r\n\r\n\t\t\t\t\t\tobject.quaternion.set( quat[0], quat[1], quat[2], quat[3] );\r\n\t\t\t\t\t\tobject.useQuaternion = true;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tobject.rotation.set( rot[0], rot[1], rot[2] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tobject.scale.set( scl[0], scl[1], scl[2] );\r\n\t\t\t\t\tobject.visible = ( objJSON.visible !== undefined ) ? objJSON.visible : false;\r\n\r\n\t\t\t\t\tparent.add( object );\r\n\r\n\t\t\t\t\tresult.objects[ objID ] = object;\r\n\t\t\t\t\tresult.empties[ objID ] = object;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( object ) {\r\n\r\n\t\t\t\t\tif ( objJSON.properties !== undefined )  {\r\n\r\n\t\t\t\t\t\tfor ( var key in objJSON.properties ) {\r\n\r\n\t\t\t\t\t\t\tvar value = objJSON.properties[ key ];\r\n\t\t\t\t\t\t\tobject.properties[ key ] = value;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( objJSON.groups !== undefined ) {\r\n\r\n\t\t\t\t\t\tfor ( var i = 0; i < objJSON.groups.length; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tvar groupID = objJSON.groups[ i ];\r\n\r\n\t\t\t\t\t\t\tif ( result.groups[ groupID ] === undefined ) {\r\n\r\n\t\t\t\t\t\t\t\tresult.groups[ groupID ] = [];\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tresult.groups[ groupID ].push( objID );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( objJSON.children !== undefined ) {\r\n\r\n\t\t\t\t\t\thandle_children( object, objJSON.children );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction handle_mesh( geo, mat, id ) {\r\n\r\n\t\tresult.geometries[ id ] = geo;\r\n\t\tresult.face_materials[ id ] = mat;\r\n\t\thandle_objects();\r\n\r\n\t};\r\n\r\n\tfunction handle_hierarchy( node, id, parent, material, obj ) {\r\n\r\n\t\tvar p = obj.position;\r\n\t\tvar r = obj.rotation;\r\n\t\tvar q = obj.quaternion;\r\n\t\tvar s = obj.scale;\r\n\r\n\t\tnode.position.set( p[0], p[1], p[2] );\r\n\r\n\t\tif ( q ) {\r\n\r\n\t\t\tnode.quaternion.set( q[0], q[1], q[2], q[3] );\r\n\t\t\tnode.useQuaternion = true;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tnode.rotation.set( r[0], r[1], r[2] );\r\n\r\n\t\t}\r\n\r\n\t\tnode.scale.set( s[0], s[1], s[2] );\r\n\r\n\t\t// override children materials\r\n\t\t// if object material was specified in JSON explicitly\r\n\r\n\t\tif ( material ) {\r\n\r\n\t\t\tnode.traverse( function ( child )  {\r\n\r\n\t\t\t\tchild.material = material;\r\n\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\t// override children visibility\r\n\t\t// with root node visibility as specified in JSON\r\n\r\n\t\tvar visible = ( obj.visible !== undefined ) ? obj.visible : true;\r\n\r\n\t\tnode.traverse( function ( child )  {\r\n\r\n\t\t\tchild.visible = visible;\r\n\r\n\t\t} );\r\n\r\n\t\tparent.add( node );\r\n\r\n\t\tnode.name = id;\r\n\r\n\t\tresult.objects[ id ] = node;\r\n\t\thandle_objects();\r\n\r\n\t};\r\n\r\n\tfunction create_callback_geometry( id ) {\r\n\r\n\t\treturn function( geo, mat ) {\r\n\r\n\t\t\thandle_mesh( geo, mat, id );\r\n\r\n\t\t\tcounter_models -= 1;\r\n\r\n\t\t\tscope.onLoadComplete();\r\n\r\n\t\t\tasync_callback_gate();\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction create_callback_hierachy( id, parent, material, obj ) {\r\n\r\n\t\treturn function( event ) {\r\n\r\n\t\t\tvar result;\r\n\r\n\t\t\t// loaders which use EventDispatcher\r\n\r\n\t\t\tif ( event.content ) {\r\n\r\n\t\t\t\tresult = event.content;\r\n\r\n\t\t\t// ColladaLoader\r\n\r\n\t\t\t} else if ( event.dae ) {\r\n\r\n\t\t\t\tresult = event.scene;\r\n\r\n\r\n\t\t\t// UTF8Loader\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tresult = event;\r\n\r\n\t\t\t}\r\n\r\n\t\t\thandle_hierarchy( result, id, parent, material, obj );\r\n\r\n\t\t\tcounter_models -= 1;\r\n\r\n\t\t\tscope.onLoadComplete();\r\n\r\n\t\t\tasync_callback_gate();\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction create_callback_embed( id ) {\r\n\r\n\t\treturn function( geo, mat ) {\r\n\r\n\t\t\tresult.geometries[ id ] = geo;\r\n\t\t\tresult.face_materials[ id ] = mat;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction async_callback_gate() {\r\n\r\n\t\tvar progress = {\r\n\r\n\t\t\ttotalModels : total_models,\r\n\t\t\ttotalTextures : total_textures,\r\n\t\t\tloadedModels : total_models - counter_models,\r\n\t\t\tloadedTextures : total_textures - counter_textures\r\n\r\n\t\t};\r\n\r\n\t\tscope.callbackProgress( progress, result );\r\n\r\n\t\tscope.onLoadProgress();\r\n\r\n\t\tif ( counter_models === 0 && counter_textures === 0 ) {\r\n\r\n\t\t\tfinalize();\r\n\t\t\tcallbackFinished( result );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction finalize() {\r\n\r\n\t\t// take care of targets which could be asynchronously loaded objects\r\n\r\n\t\tfor ( var i = 0; i < target_array.length; i ++ ) {\r\n\r\n\t\t\tvar ta = target_array[ i ];\r\n\r\n\t\t\tvar target = result.objects[ ta.targetName ];\r\n\r\n\t\t\tif ( target ) {\r\n\r\n\t\t\t\tta.object.target = target;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// if there was error and target of specified name doesn't exist in the scene file\r\n\t\t\t\t// create instead dummy target\r\n\t\t\t\t// (target must be added to scene explicitly as parent is already added)\r\n\r\n\t\t\t\tta.object.target = new THREE.Object3D();\r\n\t\t\t\tresult.scene.add( ta.object.target );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tta.object.target.properties.targetInverse = ta.object;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar callbackTexture = function ( count ) {\r\n\r\n\t\tcounter_textures -= count;\r\n\t\tasync_callback_gate();\r\n\r\n\t\tscope.onLoadComplete();\r\n\r\n\t};\r\n\r\n\t// must use this instead of just directly calling callbackTexture\r\n\t// because of closure in the calling context loop\r\n\r\n\tvar generateTextureCallback = function ( count ) {\r\n\r\n\t\treturn function() {\r\n\r\n\t\t\tcallbackTexture( count );\r\n\r\n\t\t};\r\n\r\n\t};\r\n\r\n\t// first go synchronous elements\r\n\r\n\t// fogs\r\n\r\n\tvar fogID, fogJSON;\r\n\r\n\tfor ( fogID in data.fogs ) {\r\n\r\n\t\tfogJSON = data.fogs[ fogID ];\r\n\r\n\t\tif ( fogJSON.type === \"linear\" ) {\r\n\r\n\t\t\tfog = new THREE.Fog( 0x000000, fogJSON.near, fogJSON.far );\r\n\r\n\t\t} else if ( fogJSON.type === \"exp2\" ) {\r\n\r\n\t\t\tfog = new THREE.FogExp2( 0x000000, fogJSON.density );\r\n\r\n\t\t}\r\n\r\n\t\tcolor = fogJSON.color;\r\n\t\tfog.color.setRGB( color[0], color[1], color[2] );\r\n\r\n\t\tresult.fogs[ fogID ] = fog;\r\n\r\n\t}\r\n\r\n\t// now come potentially asynchronous elements\r\n\r\n\t// geometries\r\n\r\n\t// count how many geometries will be loaded asynchronously\r\n\r\n\tvar geoID, geoJSON;\r\n\r\n\tfor ( geoID in data.geometries ) {\r\n\r\n\t\tgeoJSON = data.geometries[ geoID ];\r\n\r\n\t\tif ( geoJSON.type in this.geometryHandlerMap ) {\r\n\r\n\t\t\tcounter_models += 1;\r\n\r\n\t\t\tscope.onLoadStart();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// count how many hierarchies will be loaded asynchronously\r\n\r\n\tvar objID, objJSON;\r\n\r\n\tfor ( objID in data.objects ) {\r\n\r\n\t\tobjJSON = data.objects[ objID ];\r\n\r\n\t\tif ( objJSON.type && ( objJSON.type in this.hierarchyHandlerMap ) ) {\r\n\r\n\t\t\tcounter_models += 1;\r\n\r\n\t\t\tscope.onLoadStart();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\ttotal_models = counter_models;\r\n\r\n\tfor ( geoID in data.geometries ) {\r\n\r\n\t\tgeoJSON = data.geometries[ geoID ];\r\n\r\n\t\tif ( geoJSON.type === \"cube\" ) {\r\n\r\n\t\t\tgeometry = new THREE.CubeGeometry( geoJSON.width, geoJSON.height, geoJSON.depth, geoJSON.widthSegments, geoJSON.heightSegments, geoJSON.depthSegments );\r\n\t\t\tresult.geometries[ geoID ] = geometry;\r\n\r\n\t\t} else if ( geoJSON.type === \"plane\" ) {\r\n\r\n\t\t\tgeometry = new THREE.PlaneGeometry( geoJSON.width, geoJSON.height, geoJSON.widthSegments, geoJSON.heightSegments );\r\n\t\t\tresult.geometries[ geoID ] = geometry;\r\n\r\n\t\t} else if ( geoJSON.type === \"sphere\" ) {\r\n\r\n\t\t\tgeometry = new THREE.SphereGeometry( geoJSON.radius, geoJSON.widthSegments, geoJSON.heightSegments );\r\n\t\t\tresult.geometries[ geoID ] = geometry;\r\n\r\n\t\t} else if ( geoJSON.type === \"cylinder\" ) {\r\n\r\n\t\t\tgeometry = new THREE.CylinderGeometry( geoJSON.topRad, geoJSON.botRad, geoJSON.height, geoJSON.radSegs, geoJSON.heightSegs );\r\n\t\t\tresult.geometries[ geoID ] = geometry;\r\n\r\n\t\t} else if ( geoJSON.type === \"torus\" ) {\r\n\r\n\t\t\tgeometry = new THREE.TorusGeometry( geoJSON.radius, geoJSON.tube, geoJSON.segmentsR, geoJSON.segmentsT );\r\n\t\t\tresult.geometries[ geoID ] = geometry;\r\n\r\n\t\t} else if ( geoJSON.type === \"icosahedron\" ) {\r\n\r\n\t\t\tgeometry = new THREE.IcosahedronGeometry( geoJSON.radius, geoJSON.subdivisions );\r\n\t\t\tresult.geometries[ geoID ] = geometry;\r\n\r\n\t\t} else if ( geoJSON.type in this.geometryHandlerMap ) {\r\n\r\n\t\t\tvar loaderParameters = {};\r\n\r\n\t\t\tfor ( var parType in geoJSON ) {\r\n\r\n\t\t\t\tif ( parType !== \"type\" && parType !== \"url\" ) {\r\n\r\n\t\t\t\t\tloaderParameters[ parType ] = geoJSON[ parType ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar loader = this.geometryHandlerMap[ geoJSON.type ][ \"loaderObject\" ];\r\n\t\t\tloader.load( get_url( geoJSON.url, data.urlBaseType ), create_callback_geometry( geoID ), loaderParameters );\r\n\r\n\t\t} else if ( geoJSON.type === \"embedded\" ) {\r\n\r\n\t\t\tvar modelJson = data.embeds[ geoJSON.id ],\r\n\t\t\t\ttexture_path = \"\";\r\n\r\n\t\t\t// pass metadata along to jsonLoader so it knows the format version\r\n\r\n\t\t\tmodelJson.metadata = data.metadata;\r\n\r\n\t\t\tif ( modelJson ) {\r\n\r\n\t\t\t\tvar jsonLoader = this.geometryHandlerMap[ \"ascii\" ][ \"loaderObject\" ];\r\n\t\t\t\tjsonLoader.createModel( modelJson, create_callback_embed( geoID ), texture_path );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// textures\r\n\r\n\t// count how many textures will be loaded asynchronously\r\n\r\n\tvar textureID, textureJSON;\r\n\r\n\tfor ( textureID in data.textures ) {\r\n\r\n\t\ttextureJSON = data.textures[ textureID ];\r\n\r\n\t\tif ( textureJSON.url instanceof Array ) {\r\n\r\n\t\t\tcounter_textures += textureJSON.url.length;\r\n\r\n\t\t\tfor( var n = 0; n < textureJSON.url.length; n ++ ) {\r\n\r\n\t\t\t\tscope.onLoadStart();\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tcounter_textures += 1;\r\n\r\n\t\t\tscope.onLoadStart();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\ttotal_textures = counter_textures;\r\n\r\n\tfor ( textureID in data.textures ) {\r\n\r\n\t\ttextureJSON = data.textures[ textureID ];\r\n\r\n\t\tif ( textureJSON.mapping !== undefined && THREE[ textureJSON.mapping ] !== undefined  ) {\r\n\r\n\t\t\ttextureJSON.mapping = new THREE[ textureJSON.mapping ]();\r\n\r\n\t\t}\r\n\r\n\t\tif ( textureJSON.url instanceof Array ) {\r\n\r\n\t\t\tvar count = textureJSON.url.length;\r\n\t\t\tvar url_array = [];\r\n\r\n\t\t\tfor( var i = 0; i < count; i ++ ) {\r\n\r\n\t\t\t\turl_array[ i ] = get_url( textureJSON.url[ i ], data.urlBaseType );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar isCompressed = /\\.dds$/i.test( url_array[ 0 ] );\r\n\r\n\t\t\tif ( isCompressed ) {\r\n\r\n\t\t\t\ttexture = THREE.ImageUtils.loadCompressedTextureCube( url_array, textureJSON.mapping, generateTextureCallback( count ) );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ttexture = THREE.ImageUtils.loadTextureCube( url_array, textureJSON.mapping, generateTextureCallback( count ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar isCompressed = /\\.dds$/i.test( textureJSON.url );\r\n\t\t\tvar fullUrl = get_url( textureJSON.url, data.urlBaseType );\r\n\t\t\tvar textureCallback = generateTextureCallback( 1 );\r\n\r\n\t\t\tif ( isCompressed ) {\r\n\r\n\t\t\t\ttexture = THREE.ImageUtils.loadCompressedTexture( fullUrl, textureJSON.mapping, textureCallback );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ttexture = THREE.ImageUtils.loadTexture( fullUrl, textureJSON.mapping, textureCallback );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( THREE[ textureJSON.minFilter ] !== undefined )\r\n\t\t\t\ttexture.minFilter = THREE[ textureJSON.minFilter ];\r\n\r\n\t\t\tif ( THREE[ textureJSON.magFilter ] !== undefined )\r\n\t\t\t\ttexture.magFilter = THREE[ textureJSON.magFilter ];\r\n\r\n\t\t\tif ( textureJSON.anisotropy ) texture.anisotropy = textureJSON.anisotropy;\r\n\r\n\t\t\tif ( textureJSON.repeat ) {\r\n\r\n\t\t\t\ttexture.repeat.set( textureJSON.repeat[ 0 ], textureJSON.repeat[ 1 ] );\r\n\r\n\t\t\t\tif ( textureJSON.repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;\r\n\t\t\t\tif ( textureJSON.repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( textureJSON.offset ) {\r\n\r\n\t\t\t\ttexture.offset.set( textureJSON.offset[ 0 ], textureJSON.offset[ 1 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// handle wrap after repeat so that default repeat can be overriden\r\n\r\n\t\t\tif ( textureJSON.wrap ) {\r\n\r\n\t\t\t\tvar wrapMap = {\r\n\t\t\t\t\"repeat\" \t: THREE.RepeatWrapping,\r\n\t\t\t\t\"mirror\"\t: THREE.MirroredRepeatWrapping\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( wrapMap[ textureJSON.wrap[ 0 ] ] !== undefined ) texture.wrapS = wrapMap[ textureJSON.wrap[ 0 ] ];\r\n\t\t\t\tif ( wrapMap[ textureJSON.wrap[ 1 ] ] !== undefined ) texture.wrapT = wrapMap[ textureJSON.wrap[ 1 ] ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tresult.textures[ textureID ] = texture;\r\n\r\n\t}\r\n\r\n\t// materials\r\n\r\n\tvar matID, matJSON;\r\n\tvar parID;\r\n\r\n\tfor ( matID in data.materials ) {\r\n\r\n\t\tmatJSON = data.materials[ matID ];\r\n\r\n\t\tfor ( parID in matJSON.parameters ) {\r\n\r\n\t\t\tif ( parID === \"envMap\" || parID === \"map\" || parID === \"lightMap\" || parID === \"bumpMap\" ) {\r\n\r\n\t\t\t\tmatJSON.parameters[ parID ] = result.textures[ matJSON.parameters[ parID ] ];\r\n\r\n\t\t\t} else if ( parID === \"shading\" ) {\r\n\r\n\t\t\t\tmatJSON.parameters[ parID ] = ( matJSON.parameters[ parID ] === \"flat\" ) ? THREE.FlatShading : THREE.SmoothShading;\r\n\r\n\t\t\t} else if ( parID === \"side\" ) {\r\n\r\n\t\t\t\tif ( matJSON.parameters[ parID ] == \"double\" ) {\r\n\r\n\t\t\t\t\tmatJSON.parameters[ parID ] = THREE.DoubleSide;\r\n\r\n\t\t\t\t} else if ( matJSON.parameters[ parID ] == \"back\" ) {\r\n\r\n\t\t\t\t\tmatJSON.parameters[ parID ] = THREE.BackSide;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tmatJSON.parameters[ parID ] = THREE.FrontSide;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( parID === \"blending\" ) {\r\n\r\n\t\t\t\tmatJSON.parameters[ parID ] = matJSON.parameters[ parID ] in THREE ? THREE[ matJSON.parameters[ parID ] ] : THREE.NormalBlending;\r\n\r\n\t\t\t} else if ( parID === \"combine\" ) {\r\n\r\n\t\t\t\tmatJSON.parameters[ parID ] = matJSON.parameters[ parID ] in THREE ? THREE[ matJSON.parameters[ parID ] ] : THREE.MultiplyOperation;\r\n\r\n\t\t\t} else if ( parID === \"vertexColors\" ) {\r\n\r\n\t\t\t\tif ( matJSON.parameters[ parID ] == \"face\" ) {\r\n\r\n\t\t\t\t\tmatJSON.parameters[ parID ] = THREE.FaceColors;\r\n\r\n\t\t\t\t// default to vertex colors if \"vertexColors\" is anything else face colors or 0 / null / false\r\n\r\n\t\t\t\t} else if ( matJSON.parameters[ parID ] )   {\r\n\r\n\t\t\t\t\tmatJSON.parameters[ parID ] = THREE.VertexColors;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( parID === \"wrapRGB\" ) {\r\n\r\n\t\t\t\tvar v3 = matJSON.parameters[ parID ];\r\n\t\t\t\tmatJSON.parameters[ parID ] = new THREE.Vector3( v3[ 0 ], v3[ 1 ], v3[ 2 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( matJSON.parameters.opacity !== undefined && matJSON.parameters.opacity < 1.0 ) {\r\n\r\n\t\t\tmatJSON.parameters.transparent = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( matJSON.parameters.normalMap ) {\r\n\r\n\t\t\tvar shader = THREE.ShaderLib[ \"normalmap\" ];\r\n\t\t\tvar uniforms = THREE.UniformsUtils.clone( shader.uniforms );\r\n\r\n\t\t\tvar diffuse = matJSON.parameters.color;\r\n\t\t\tvar specular = matJSON.parameters.specular;\r\n\t\t\tvar ambient = matJSON.parameters.ambient;\r\n\t\t\tvar shininess = matJSON.parameters.shininess;\r\n\r\n\t\t\tuniforms[ \"tNormal\" ].value = result.textures[ matJSON.parameters.normalMap ];\r\n\r\n\t\t\tif ( matJSON.parameters.normalScale ) {\r\n\r\n\t\t\t\tuniforms[ \"uNormalScale\" ].value.set( matJSON.parameters.normalScale[ 0 ], matJSON.parameters.normalScale[ 1 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( matJSON.parameters.map ) {\r\n\r\n\t\t\t\tuniforms[ \"tDiffuse\" ].value = matJSON.parameters.map;\r\n\t\t\t\tuniforms[ \"enableDiffuse\" ].value = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( matJSON.parameters.envMap ) {\r\n\r\n\t\t\t\tuniforms[ \"tCube\" ].value = matJSON.parameters.envMap;\r\n\t\t\t\tuniforms[ \"enableReflection\" ].value = true;\r\n\t\t\t\tuniforms[ \"uReflectivity\" ].value = matJSON.parameters.reflectivity;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( matJSON.parameters.lightMap ) {\r\n\r\n\t\t\t\tuniforms[ \"tAO\" ].value = matJSON.parameters.lightMap;\r\n\t\t\t\tuniforms[ \"enableAO\" ].value = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( matJSON.parameters.specularMap ) {\r\n\r\n\t\t\t\tuniforms[ \"tSpecular\" ].value = result.textures[ matJSON.parameters.specularMap ];\r\n\t\t\t\tuniforms[ \"enableSpecular\" ].value = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( matJSON.parameters.displacementMap ) {\r\n\r\n\t\t\t\tuniforms[ \"tDisplacement\" ].value = result.textures[ matJSON.parameters.displacementMap ];\r\n\t\t\t\tuniforms[ \"enableDisplacement\" ].value = true;\r\n\r\n\t\t\t\tuniforms[ \"uDisplacementBias\" ].value = matJSON.parameters.displacementBias;\r\n\t\t\t\tuniforms[ \"uDisplacementScale\" ].value = matJSON.parameters.displacementScale;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tuniforms[ \"uDiffuseColor\" ].value.setHex( diffuse );\r\n\t\t\tuniforms[ \"uSpecularColor\" ].value.setHex( specular );\r\n\t\t\tuniforms[ \"uAmbientColor\" ].value.setHex( ambient );\r\n\r\n\t\t\tuniforms[ \"uShininess\" ].value = shininess;\r\n\r\n\t\t\tif ( matJSON.parameters.opacity ) {\r\n\r\n\t\t\t\tuniforms[ \"uOpacity\" ].value = matJSON.parameters.opacity;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms, lights: true, fog: true };\r\n\r\n\t\t\tmaterial = new THREE.ShaderMaterial( parameters );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmaterial = new THREE[ matJSON.type ]( matJSON.parameters );\r\n\r\n\t\t}\r\n\r\n\t\tresult.materials[ matID ] = material;\r\n\r\n\t}\r\n\r\n\t// second pass through all materials to initialize MeshFaceMaterials\r\n\t// that could be referring to other materials out of order\r\n\r\n\tfor ( matID in data.materials ) {\r\n\r\n\t\tmatJSON = data.materials[ matID ];\r\n\r\n\t\tif ( matJSON.parameters.materials ) {\r\n\r\n\t\t\tvar materialArray = [];\r\n\r\n\t\t\tfor ( var i = 0; i < matJSON.parameters.materials.length; i ++ ) {\r\n\r\n\t\t\t\tvar label = matJSON.parameters.materials[ i ];\r\n\t\t\t\tmaterialArray.push( result.materials[ label ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tresult.materials[ matID ].materials = materialArray;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// objects ( synchronous init of procedural primitives )\r\n\r\n\thandle_objects();\r\n\r\n\t// defaults\r\n\r\n\tif ( result.cameras && data.defaults.camera ) {\r\n\r\n\t\tresult.currentCamera = result.cameras[ data.defaults.camera ];\r\n\r\n\t}\r\n\r\n\tif ( result.fogs && data.defaults.fog ) {\r\n\r\n\t\tresult.scene.fog = result.fogs[ data.defaults.fog ];\r\n\r\n\t}\r\n\r\n\t// synchronous callback\r\n\r\n\tscope.callbackSync( result );\r\n\r\n\t// just in case there are no async elements\r\n\r\n\tasync_callback_gate();\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.TextureLoader = function () {\r\n\r\n\tTHREE.EventDispatcher.call( this );\r\n\r\n\tthis.crossOrigin = null;\r\n\r\n};\r\n\r\nTHREE.TextureLoader.prototype = {\r\n\r\n\tconstructor: THREE.TextureLoader,\r\n\r\n\tload: function ( url ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar image = new Image();\r\n\r\n\t\timage.addEventListener( 'load', function () {\r\n\r\n\t\t\tvar texture = new THREE.Texture( image );\r\n\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\tscope.dispatchEvent( { type: 'load', content: texture } );\r\n\r\n\t\t}, false );\r\n\r\n\t\timage.addEventListener( 'error', function () {\r\n\r\n\t\t\tscope.dispatchEvent( { type: 'error', message: 'Couldn\\'t load URL [' + url + ']' } );\r\n\r\n\t\t}, false );\r\n\r\n\t\tif ( scope.crossOrigin ) image.crossOrigin = scope.crossOrigin;\r\n\r\n\t\timage.src = url;\r\n\r\n\t}\r\n\r\n}\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Material = function () {\r\n\r\n\tTHREE.EventDispatcher.call( this );\r\n\r\n\tthis.id = THREE.MaterialIdCount ++;\r\n\r\n\tthis.name = '';\r\n\r\n\tthis.side = THREE.FrontSide;\r\n\r\n\tthis.opacity = 1;\r\n\tthis.transparent = false;\r\n\r\n\tthis.blending = THREE.NormalBlending;\r\n\r\n\tthis.blendSrc = THREE.SrcAlphaFactor;\r\n\tthis.blendDst = THREE.OneMinusSrcAlphaFactor;\r\n\tthis.blendEquation = THREE.AddEquation;\r\n\r\n\tthis.depthTest = true;\r\n\tthis.depthWrite = true;\r\n\r\n\tthis.polygonOffset = false;\r\n\tthis.polygonOffsetFactor = 0;\r\n\tthis.polygonOffsetUnits = 0;\r\n\r\n\tthis.alphaTest = 0;\r\n\r\n\tthis.overdraw = false; // Boolean for fixing antialiasing gaps in CanvasRenderer\r\n\r\n\tthis.visible = true;\r\n\r\n\tthis.needsUpdate = true;\r\n\r\n};\r\n\r\nTHREE.Material.prototype.setValues = function ( values ) {\r\n\r\n\tif ( values === undefined ) return;\r\n\r\n\tfor ( var key in values ) {\r\n\r\n\t\tvar newValue = values[ key ];\r\n\r\n\t\tif ( newValue === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Material: \\'' + key + '\\' parameter is undefined.' );\r\n\t\t\tcontinue;\r\n\r\n\t\t}\r\n\r\n\t\tif ( key in this ) {\r\n\r\n\t\t\tvar currentValue = this[ key ];\r\n\r\n\t\t\tif ( currentValue instanceof THREE.Color && newValue instanceof THREE.Color ) {\r\n\r\n\t\t\t\tcurrentValue.copy( newValue );\r\n\r\n\t\t\t} else if ( currentValue instanceof THREE.Color ) {\r\n\r\n\t\t\t\tcurrentValue.set( newValue );\r\n\r\n\t\t\t} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {\r\n\r\n\t\t\t\tcurrentValue.copy( newValue );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis[ key ] = newValue;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Material.prototype.clone = function ( material ) {\r\n\r\n\tif ( material === undefined ) material = new THREE.Material();\r\n\r\n\tmaterial.name = this.name;\r\n\r\n\tmaterial.side = this.side;\r\n\r\n\tmaterial.opacity = this.opacity;\r\n\tmaterial.transparent = this.transparent;\r\n\r\n\tmaterial.blending = this.blending;\r\n\r\n\tmaterial.blendSrc = this.blendSrc;\r\n\tmaterial.blendDst = this.blendDst;\r\n\tmaterial.blendEquation = this.blendEquation;\r\n\r\n\tmaterial.depthTest = this.depthTest;\r\n\tmaterial.depthWrite = this.depthWrite;\r\n\r\n\tmaterial.polygonOffset = this.polygonOffset;\r\n\tmaterial.polygonOffsetFactor = this.polygonOffsetFactor;\r\n\tmaterial.polygonOffsetUnits = this.polygonOffsetUnits;\r\n\r\n\tmaterial.alphaTest = this.alphaTest;\r\n\r\n\tmaterial.overdraw = this.overdraw;\r\n\r\n\tmaterial.visible = this.visible;\r\n\r\n\treturn material;\r\n\r\n};\r\n\r\nTHREE.Material.prototype.dispose = function () {\r\n\r\n\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n};\r\n\r\nTHREE.MaterialIdCount = 0;\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  linewidth: <float>,\r\n *  linecap: \"round\",\r\n *  linejoin: \"round\",\r\n *\r\n *  vertexColors: <bool>\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.LineBasicMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.color = new THREE.Color( 0xffffff );\r\n\r\n\tthis.linewidth = 1;\r\n\tthis.linecap = 'round';\r\n\tthis.linejoin = 'round';\r\n\r\n\tthis.vertexColors = false;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\r\nTHREE.LineBasicMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.LineBasicMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.color.copy( this.color );\r\n\r\n\tmaterial.linewidth = this.linewidth;\r\n\tmaterial.linecap = this.linecap;\r\n\tmaterial.linejoin = this.linejoin;\r\n\r\n\tmaterial.vertexColors = this.vertexColors;\r\n\r\n\tmaterial.fog = this.fog;\r\n\r\n\treturn material;\r\n\r\n};\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  linewidth: <float>,\r\n *\r\n *  scale: <float>,\r\n *  dashSize: <float>,\r\n *  gapSize: <float>,\r\n *\r\n *  vertexColors: <bool>\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.LineDashedMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.color = new THREE.Color( 0xffffff );\r\n\r\n\tthis.linewidth = 1;\r\n\r\n\tthis.scale = 1;\r\n\tthis.dashSize = 3;\r\n\tthis.gapSize = 1;\r\n\r\n\tthis.vertexColors = false;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\r\nTHREE.LineDashedMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.LineDashedMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.color.copy( this.color );\r\n\r\n\tmaterial.linewidth = this.linewidth;\r\n\r\n\tmaterial.scale = this.scale;\r\n\tmaterial.dashSize = this.dashSize;\r\n\tmaterial.gapSize = this.gapSize;\r\n\r\n\tmaterial.vertexColors = this.vertexColors;\r\n\r\n\tmaterial.fog = this.fog;\r\n\r\n\treturn material;\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  lightMap: new THREE.Texture( <Image> ),\r\n *\r\n *  specularMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n *  combine: THREE.Multiply,\r\n *  reflectivity: <float>,\r\n *  refractionRatio: <float>,\r\n *\r\n *  shading: THREE.SmoothShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.MeshBasicMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.color = new THREE.Color( 0xffffff ); // emissive\r\n\r\n\tthis.map = null;\r\n\r\n\tthis.lightMap = null;\r\n\r\n\tthis.specularMap = null;\r\n\r\n\tthis.envMap = null;\r\n\tthis.combine = THREE.MultiplyOperation;\r\n\tthis.reflectivity = 1;\r\n\tthis.refractionRatio = 0.98;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.shading = THREE.SmoothShading;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\tthis.wireframeLinecap = 'round';\r\n\tthis.wireframeLinejoin = 'round';\r\n\r\n\tthis.vertexColors = THREE.NoColors;\r\n\r\n\tthis.skinning = false;\r\n\tthis.morphTargets = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\r\nTHREE.MeshBasicMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.MeshBasicMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.color.copy( this.color );\r\n\r\n\tmaterial.map = this.map;\r\n\r\n\tmaterial.lightMap = this.lightMap;\r\n\r\n\tmaterial.specularMap = this.specularMap;\r\n\r\n\tmaterial.envMap = this.envMap;\r\n\tmaterial.combine = this.combine;\r\n\tmaterial.reflectivity = this.reflectivity;\r\n\tmaterial.refractionRatio = this.refractionRatio;\r\n\r\n\tmaterial.fog = this.fog;\r\n\r\n\tmaterial.shading = this.shading;\r\n\r\n\tmaterial.wireframe = this.wireframe;\r\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\r\n\tmaterial.wireframeLinecap = this.wireframeLinecap;\r\n\tmaterial.wireframeLinejoin = this.wireframeLinejoin;\r\n\r\n\tmaterial.vertexColors = this.vertexColors;\r\n\r\n\tmaterial.skinning = this.skinning;\r\n\tmaterial.morphTargets = this.morphTargets;\r\n\r\n\treturn material;\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  ambient: <hex>,\r\n *  emissive: <hex>,\r\n *  opacity: <float>,\r\n *\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  lightMap: new THREE.Texture( <Image> ),\r\n *\r\n *  specularMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n *  combine: THREE.Multiply,\r\n *  reflectivity: <float>,\r\n *  refractionRatio: <float>,\r\n *\r\n *  shading: THREE.SmoothShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>,\r\n *\r\n *\tfog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.MeshLambertMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\r\n\tthis.ambient = new THREE.Color( 0xffffff );\r\n\tthis.emissive = new THREE.Color( 0x000000 );\r\n\r\n\tthis.wrapAround = false;\r\n\tthis.wrapRGB = new THREE.Vector3( 1, 1, 1 );\r\n\r\n\tthis.map = null;\r\n\r\n\tthis.lightMap = null;\r\n\r\n\tthis.specularMap = null;\r\n\r\n\tthis.envMap = null;\r\n\tthis.combine = THREE.MultiplyOperation;\r\n\tthis.reflectivity = 1;\r\n\tthis.refractionRatio = 0.98;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.shading = THREE.SmoothShading;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\tthis.wireframeLinecap = 'round';\r\n\tthis.wireframeLinejoin = 'round';\r\n\r\n\tthis.vertexColors = THREE.NoColors;\r\n\r\n\tthis.skinning = false;\r\n\tthis.morphTargets = false;\r\n\tthis.morphNormals = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\r\nTHREE.MeshLambertMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.MeshLambertMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.color.copy( this.color );\r\n\tmaterial.ambient.copy( this.ambient );\r\n\tmaterial.emissive.copy( this.emissive );\r\n\r\n\tmaterial.wrapAround = this.wrapAround;\r\n\tmaterial.wrapRGB.copy( this.wrapRGB );\r\n\r\n\tmaterial.map = this.map;\r\n\r\n\tmaterial.lightMap = this.lightMap;\r\n\r\n\tmaterial.specularMap = this.specularMap;\r\n\r\n\tmaterial.envMap = this.envMap;\r\n\tmaterial.combine = this.combine;\r\n\tmaterial.reflectivity = this.reflectivity;\r\n\tmaterial.refractionRatio = this.refractionRatio;\r\n\r\n\tmaterial.fog = this.fog;\r\n\r\n\tmaterial.shading = this.shading;\r\n\r\n\tmaterial.wireframe = this.wireframe;\r\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\r\n\tmaterial.wireframeLinecap = this.wireframeLinecap;\r\n\tmaterial.wireframeLinejoin = this.wireframeLinejoin;\r\n\r\n\tmaterial.vertexColors = this.vertexColors;\r\n\r\n\tmaterial.skinning = this.skinning;\r\n\tmaterial.morphTargets = this.morphTargets;\r\n\tmaterial.morphNormals = this.morphNormals;\r\n\r\n\treturn material;\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  ambient: <hex>,\r\n *  emissive: <hex>,\r\n *  specular: <hex>,\r\n *  shininess: <float>,\r\n *  opacity: <float>,\r\n *\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  lightMap: new THREE.Texture( <Image> ),\r\n *\r\n *  bumpMap: new THREE.Texture( <Image> ),\r\n *  bumpScale: <float>,\r\n *\r\n *  normalMap: new THREE.Texture( <Image> ),\r\n *  normalScale: <Vector2>,\r\n *\r\n *  specularMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n *  combine: THREE.Multiply,\r\n *  reflectivity: <float>,\r\n *  refractionRatio: <float>,\r\n *\r\n *  shading: THREE.SmoothShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>,\r\n *\r\n *\tfog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.MeshPhongMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\r\n\tthis.ambient = new THREE.Color( 0xffffff );\r\n\tthis.emissive = new THREE.Color( 0x000000 );\r\n\tthis.specular = new THREE.Color( 0x111111 );\r\n\tthis.shininess = 30;\r\n\r\n\tthis.metal = false;\r\n\tthis.perPixel = true;\r\n\r\n\tthis.wrapAround = false;\r\n\tthis.wrapRGB = new THREE.Vector3( 1, 1, 1 );\r\n\r\n\tthis.map = null;\r\n\r\n\tthis.lightMap = null;\r\n\r\n\tthis.bumpMap = null;\r\n\tthis.bumpScale = 1;\r\n\r\n\tthis.normalMap = null;\r\n\tthis.normalScale = new THREE.Vector2( 1, 1 );\r\n\r\n\tthis.specularMap = null;\r\n\r\n\tthis.envMap = null;\r\n\tthis.combine = THREE.MultiplyOperation;\r\n\tthis.reflectivity = 1;\r\n\tthis.refractionRatio = 0.98;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.shading = THREE.SmoothShading;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\tthis.wireframeLinecap = 'round';\r\n\tthis.wireframeLinejoin = 'round';\r\n\r\n\tthis.vertexColors = THREE.NoColors;\r\n\r\n\tthis.skinning = false;\r\n\tthis.morphTargets = false;\r\n\tthis.morphNormals = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\r\nTHREE.MeshPhongMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.MeshPhongMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.color.copy( this.color );\r\n\tmaterial.ambient.copy( this.ambient );\r\n\tmaterial.emissive.copy( this.emissive );\r\n\tmaterial.specular.copy( this.specular );\r\n\tmaterial.shininess = this.shininess;\r\n\r\n\tmaterial.metal = this.metal;\r\n\tmaterial.perPixel = this.perPixel;\r\n\r\n\tmaterial.wrapAround = this.wrapAround;\r\n\tmaterial.wrapRGB.copy( this.wrapRGB );\r\n\r\n\tmaterial.map = this.map;\r\n\r\n\tmaterial.lightMap = this.lightMap;\r\n\r\n\tmaterial.bumpMap = this.bumpMap;\r\n\tmaterial.bumpScale = this.bumpScale;\r\n\r\n\tmaterial.normalMap = this.normalMap;\r\n\tmaterial.normalScale.copy( this.normalScale );\r\n\r\n\tmaterial.specularMap = this.specularMap;\r\n\r\n\tmaterial.envMap = this.envMap;\r\n\tmaterial.combine = this.combine;\r\n\tmaterial.reflectivity = this.reflectivity;\r\n\tmaterial.refractionRatio = this.refractionRatio;\r\n\r\n\tmaterial.fog = this.fog;\r\n\r\n\tmaterial.shading = this.shading;\r\n\r\n\tmaterial.wireframe = this.wireframe;\r\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\r\n\tmaterial.wireframeLinecap = this.wireframeLinecap;\r\n\tmaterial.wireframeLinejoin = this.wireframeLinejoin;\r\n\r\n\tmaterial.vertexColors = this.vertexColors;\r\n\r\n\tmaterial.skinning = this.skinning;\r\n\tmaterial.morphTargets = this.morphTargets;\r\n\tmaterial.morphNormals = this.morphNormals;\r\n\r\n\treturn material;\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  opacity: <float>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>\r\n * }\r\n */\r\n\r\nTHREE.MeshDepthMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\r\nTHREE.MeshDepthMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.LineBasicMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.wireframe = this.wireframe;\r\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\r\n\r\n\treturn material;\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n *\r\n * parameters = {\r\n *  opacity: <float>,\r\n *\r\n *  shading: THREE.FlatShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>\r\n * }\r\n */\r\n\r\nTHREE.MeshNormalMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this, parameters );\r\n\r\n\tthis.shading = THREE.FlatShading;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\r\nTHREE.MeshNormalMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.MeshNormalMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.shading = this.shading;\r\n\r\n\tmaterial.wireframe = this.wireframe;\r\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\r\n\r\n\treturn material;\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.MeshFaceMaterial = function ( materials ) {\r\n\r\n\tthis.materials = materials instanceof Array ? materials : [];\r\n\r\n};\r\n\r\nTHREE.MeshFaceMaterial.prototype.clone = function () {\r\n\r\n\treturn new THREE.MeshFaceMaterial( this.materials.slice( 0 ) );\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  size: <float>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  vertexColors: <bool>,\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.ParticleBasicMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.color = new THREE.Color( 0xffffff );\r\n\r\n\tthis.map = null;\r\n\r\n\tthis.size = 1;\r\n\tthis.sizeAttenuation = true;\r\n\r\n\tthis.vertexColors = false;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.ParticleBasicMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\r\nTHREE.ParticleBasicMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.ParticleBasicMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.color.copy( this.color );\r\n\r\n\tmaterial.map = this.map;\r\n\r\n\tmaterial.size = this.size;\r\n\tmaterial.sizeAttenuation = this.sizeAttenuation;\r\n\r\n\tmaterial.vertexColors = this.vertexColors;\r\n\r\n\tmaterial.fog = this.fog;\r\n\r\n\treturn material;\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  program: <function>,\r\n *  opacity: <float>,\r\n *  blending: THREE.NormalBlending\r\n * }\r\n */\r\n\r\nTHREE.ParticleCanvasMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.color = new THREE.Color( 0xffffff );\r\n\tthis.program = function ( context, color ) {};\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.ParticleCanvasMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\r\nTHREE.ParticleCanvasMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.ParticleCanvasMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.color.copy( this.color );\r\n\tmaterial.program = this.program;\r\n\r\n\treturn material;\r\n\r\n};\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  fragmentShader: <string>,\r\n *  vertexShader: <string>,\r\n *\r\n *  uniforms: { \"parameter1\": { type: \"f\", value: 1.0 }, \"parameter2\": { type: \"i\" value2: 2 } },\r\n *\r\n *  defines: { \"label\" : \"value\" },\r\n *\r\n *  shading: THREE.SmoothShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  lights: <bool>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>,\r\n *\r\n *\tfog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.ShaderMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.fragmentShader = \"void main() {}\";\r\n\tthis.vertexShader = \"void main() {}\";\r\n\tthis.uniforms = {};\r\n\tthis.defines = {};\r\n\tthis.attributes = null;\r\n\r\n\tthis.shading = THREE.SmoothShading;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\r\n\tthis.fog = false; // set to use scene fog\r\n\r\n\tthis.lights = false; // set to use scene lights\r\n\r\n\tthis.vertexColors = THREE.NoColors; // set to use \"color\" attribute stream\r\n\r\n\tthis.skinning = false; // set to use skinning attribute streams\r\n\r\n\tthis.morphTargets = false; // set to use morph targets\r\n\tthis.morphNormals = false; // set to use morph normals\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\r\nTHREE.ShaderMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.ShaderMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.fragmentShader = this.fragmentShader;\r\n\tmaterial.vertexShader = this.vertexShader;\r\n\r\n\tmaterial.uniforms = THREE.UniformsUtils.clone( this.uniforms );\r\n\r\n\tmaterial.attributes = this.attributes;\r\n\tmaterial.defines = this.defines;\r\n\r\n\tmaterial.shading = this.shading;\r\n\r\n\tmaterial.wireframe = this.wireframe;\r\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\r\n\r\n\tmaterial.fog = this.fog;\r\n\r\n\tmaterial.lights = this.lights;\r\n\r\n\tmaterial.vertexColors = this.vertexColors;\r\n\r\n\tmaterial.skinning = this.skinning;\r\n\r\n\tmaterial.morphTargets = this.morphTargets;\r\n\tmaterial.morphNormals = this.morphNormals;\r\n\r\n\treturn material;\r\n\r\n};\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  useScreenCoordinates: <bool>,\r\n *  sizeAttenuation: <bool>,\r\n *  scaleByViewport: <bool>,\r\n *  alignment: THREE.SpriteAlignment.center,\r\n *\r\n *\tuvOffset: new THREE.Vector2(),\r\n *\tuvScale: new THREE.Vector2(),\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.SpriteMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\t// defaults\r\n\r\n\tthis.color = new THREE.Color( 0xffffff );\r\n\tthis.map = new THREE.Texture();\r\n\r\n\tthis.useScreenCoordinates = true;\r\n\tthis.depthTest = !this.useScreenCoordinates;\r\n\tthis.sizeAttenuation = !this.useScreenCoordinates;\r\n\tthis.scaleByViewport = !this.sizeAttenuation;\r\n\tthis.alignment = THREE.SpriteAlignment.center.clone();\r\n\r\n\tthis.fog = false;\r\n\r\n\tthis.uvOffset = new THREE.Vector2( 0, 0 );\r\n\tthis.uvScale  = new THREE.Vector2( 1, 1 );\r\n\r\n\t// set parameters\r\n\r\n\tthis.setValues( parameters );\r\n\r\n\t// override coupled defaults if not specified explicitly by parameters\r\n\r\n\tparameters = parameters || {};\r\n\r\n\tif ( parameters.depthTest === undefined ) this.depthTest = !this.useScreenCoordinates;\r\n\tif ( parameters.sizeAttenuation === undefined ) this.sizeAttenuation = !this.useScreenCoordinates;\r\n\tif ( parameters.scaleByViewport === undefined ) this.scaleByViewport = !this.sizeAttenuation;\r\n\r\n};\r\n\r\nTHREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\r\nTHREE.SpriteMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.SpriteMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.color.copy( this.color );\r\n\tmaterial.map = this.map;\r\n\r\n\tmaterial.useScreenCoordinates = this.useScreenCoordinates;\r\n\tmaterial.sizeAttenuation = this.sizeAttenuation;\r\n\tmaterial.scaleByViewport = this.scaleByViewport;\r\n\tmaterial.alignment.copy( this.alignment );\r\n\r\n\tmaterial.uvOffset.copy( this.uvOffset );\r\n\tmaterial.uvScale.copy( this.uvScale );\r\n\r\n\tmaterial.fog = this.fog;\r\n\r\n\treturn material;\r\n\r\n};\r\n\r\n// Alignment enums\r\n\r\nTHREE.SpriteAlignment = {};\r\nTHREE.SpriteAlignment.topLeft = new THREE.Vector2( 1, -1 );\r\nTHREE.SpriteAlignment.topCenter = new THREE.Vector2( 0, -1 );\r\nTHREE.SpriteAlignment.topRight = new THREE.Vector2( -1, -1 );\r\nTHREE.SpriteAlignment.centerLeft = new THREE.Vector2( 1, 0 );\r\nTHREE.SpriteAlignment.center = new THREE.Vector2( 0, 0 );\r\nTHREE.SpriteAlignment.centerRight = new THREE.Vector2( -1, 0 );\r\nTHREE.SpriteAlignment.bottomLeft = new THREE.Vector2( 1, 1 );\r\nTHREE.SpriteAlignment.bottomCenter = new THREE.Vector2( 0, 1 );\r\nTHREE.SpriteAlignment.bottomRight = new THREE.Vector2( -1, 1 );\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author szimek / https://github.com/szimek/\r\n */\r\n\r\nTHREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\r\n\tTHREE.EventDispatcher.call( this );\r\n\r\n\tthis.id = THREE.TextureIdCount ++;\r\n\r\n\tthis.name = '';\r\n\r\n\tthis.image = image;\r\n\tthis.mipmaps = [];\r\n\r\n\tthis.mapping = mapping !== undefined ? mapping : new THREE.UVMapping();\r\n\r\n\tthis.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;\r\n\tthis.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;\r\n\r\n\tthis.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;\r\n\tthis.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;\r\n\r\n\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\r\n\r\n\tthis.format = format !== undefined ? format : THREE.RGBAFormat;\r\n\tthis.type = type !== undefined ? type : THREE.UnsignedByteType;\r\n\r\n\tthis.offset = new THREE.Vector2( 0, 0 );\r\n\tthis.repeat = new THREE.Vector2( 1, 1 );\r\n\r\n\tthis.generateMipmaps = true;\r\n\tthis.premultiplyAlpha = false;\r\n\tthis.flipY = true;\r\n\tthis.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\r\n\r\n\tthis.needsUpdate = false;\r\n\tthis.onUpdate = null;\r\n\r\n};\r\n\r\nTHREE.Texture.prototype = {\r\n\r\n\tconstructor: THREE.Texture,\r\n\r\n\tclone: function ( texture ) {\r\n\r\n\t\tif ( texture === undefined ) texture = new THREE.Texture();\r\n\r\n\t\ttexture.image = this.image;\r\n\t\ttexture.mipmaps = this.mipmaps.slice(0);\r\n\r\n\t\ttexture.mapping = this.mapping;\r\n\r\n\t\ttexture.wrapS = this.wrapS;\r\n\t\ttexture.wrapT = this.wrapT;\r\n\r\n\t\ttexture.magFilter = this.magFilter;\r\n\t\ttexture.minFilter = this.minFilter;\r\n\r\n\t\ttexture.anisotropy = this.anisotropy;\r\n\r\n\t\ttexture.format = this.format;\r\n\t\ttexture.type = this.type;\r\n\r\n\t\ttexture.offset.copy( this.offset );\r\n\t\ttexture.repeat.copy( this.repeat );\r\n\r\n\t\ttexture.generateMipmaps = this.generateMipmaps;\r\n\t\ttexture.premultiplyAlpha = this.premultiplyAlpha;\r\n\t\ttexture.flipY = this.flipY;\r\n\t\ttexture.unpackAlignment = this.unpackAlignment;\r\n\r\n\t\treturn texture;\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.TextureIdCount = 0;\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\r\n\r\n\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\r\n\tthis.image = { width: width, height: height };\r\n\tthis.mipmaps = mipmaps;\r\n\r\n\tthis.generateMipmaps = false; // WebGL currently can't generate mipmaps for compressed textures, they must be embedded in DDS file\r\n\r\n};\r\n\r\nTHREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );\r\n\r\nTHREE.CompressedTexture.prototype.clone = function () {\r\n\r\n\tvar texture = new THREE.CompressedTexture();\r\n\r\n\tTHREE.Texture.prototype.clone.call( this, texture );\r\n\r\n\treturn texture;\r\n\r\n};\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\r\n\r\n\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\r\n\tthis.image = { data: data, width: width, height: height };\r\n\r\n};\r\n\r\nTHREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );\r\n\r\nTHREE.DataTexture.prototype.clone = function () {\r\n\r\n\tvar texture = new THREE.DataTexture();\r\n\r\n\tTHREE.Texture.prototype.clone.call( this, texture );\r\n\r\n\treturn texture;\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Particle = function ( material ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.material = material;\r\n\r\n};\r\n\r\nTHREE.Particle.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.Particle.prototype.clone = function ( object ) {\r\n\r\n\tif ( object === undefined ) object = new THREE.Particle( this.material );\r\n\r\n\tTHREE.Object3D.prototype.clone.call( this, object );\r\n\r\n\treturn object;\r\n\r\n};\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.ParticleSystem = function ( geometry, material ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.geometry = geometry;\r\n\tthis.material = ( material !== undefined ) ? material : new THREE.ParticleBasicMaterial( { color: Math.random() * 0xffffff } );\r\n\r\n\tthis.sortParticles = false;\r\n\r\n\tif ( this.geometry ) {\r\n\r\n\t\t// calc bound radius\r\n\r\n\t\tif( this.geometry.boundingSphere === null ) {\r\n\r\n\t\t\tthis.geometry.computeBoundingSphere();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.frustumCulled = false;\r\n\r\n};\r\n\r\nTHREE.ParticleSystem.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.ParticleSystem.prototype.clone = function ( object ) {\r\n\r\n\tif ( object === undefined ) object = new THREE.ParticleSystem( this.geometry, this.material );\r\n\tobject.sortParticles = this.sortParticles;\r\n\r\n\tTHREE.Object3D.prototype.clone.call( this, object );\r\n\r\n\treturn object;\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Line = function ( geometry, material, type ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.geometry = geometry;\r\n\tthis.material = ( material !== undefined ) ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );\r\n\tthis.type = ( type !== undefined ) ? type : THREE.LineStrip;\r\n\r\n\tif ( this.geometry ) {\r\n\r\n\t\tif ( ! this.geometry.boundingSphere ) {\r\n\r\n\t\t\tthis.geometry.computeBoundingSphere();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.LineStrip = 0;\r\nTHREE.LinePieces = 1;\r\n\r\nTHREE.Line.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.Line.prototype.clone = function ( object ) {\r\n\r\n\tif ( object === undefined ) object = new THREE.Line( this.geometry, this.material, this.type );\r\n\r\n\tTHREE.Object3D.prototype.clone.call( this, object );\r\n\r\n\treturn object;\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author jonobr1 / http://jonobr1.com/\r\n */\r\n\r\nTHREE.Mesh = function ( geometry, material ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.geometry = geometry;\r\n\tthis.material = ( material !== undefined ) ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff, wireframe: true } );\r\n\r\n\tif ( this.geometry !== undefined ) {\r\n\r\n\t\tif ( this.geometry.boundingSphere === null ) {\r\n\r\n\t\t\tthis.geometry.computeBoundingSphere();\r\n\r\n\t\t}\r\n\r\n\t\tthis.updateMorphTargets();\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.Mesh.prototype.updateMorphTargets = function () {\r\n\r\n\tif ( this.geometry.morphTargets.length > 0 ) {\r\n\r\n\t\tthis.morphTargetBase = -1;\r\n\t\tthis.morphTargetForcedOrder = [];\r\n\t\tthis.morphTargetInfluences = [];\r\n\t\tthis.morphTargetDictionary = {};\r\n\r\n\t\tfor ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {\r\n\r\n\t\t\tthis.morphTargetInfluences.push( 0 );\r\n\t\t\tthis.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {\r\n\r\n\tif ( this.morphTargetDictionary[ name ] !== undefined ) {\r\n\r\n\t\treturn this.morphTargetDictionary[ name ];\r\n\r\n\t}\r\n\r\n\tconsole.log( \"THREE.Mesh.getMorphTargetIndexByName: morph target \" + name + \" does not exist. Returning 0.\" );\r\n\r\n\treturn 0;\r\n\r\n};\r\n\r\nTHREE.Mesh.prototype.clone = function ( object ) {\r\n\r\n\tif ( object === undefined ) object = new THREE.Mesh( this.geometry, this.material );\r\n\r\n\tTHREE.Object3D.prototype.clone.call( this, object );\r\n\r\n\treturn object;\r\n\r\n};\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Bone = function( belongsToSkin ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.skin = belongsToSkin;\r\n\tthis.skinMatrix = new THREE.Matrix4();\r\n\r\n};\r\n\r\nTHREE.Bone.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.Bone.prototype.update = function ( parentSkinMatrix, forceUpdate ) {\r\n\r\n\t// update local\r\n\r\n\tif ( this.matrixAutoUpdate ) {\r\n\r\n\t\tforceUpdate |= this.updateMatrix();\r\n\r\n\t}\r\n\r\n\t// update skin matrix\r\n\r\n\tif ( forceUpdate || this.matrixWorldNeedsUpdate ) {\r\n\r\n\t\tif( parentSkinMatrix ) {\r\n\r\n\t\t\tthis.skinMatrix.multiplyMatrices( parentSkinMatrix, this.matrix );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.skinMatrix.copy( this.matrix );\r\n\r\n\t\t}\r\n\r\n\t\tthis.matrixWorldNeedsUpdate = false;\r\n\t\tforceUpdate = true;\r\n\r\n\t}\r\n\r\n\t// update children\r\n\r\n\tvar child, i, l = this.children.length;\r\n\r\n\tfor ( i = 0; i < l; i ++ ) {\r\n\r\n\t\tthis.children[ i ].update( this.skinMatrix, forceUpdate );\r\n\r\n\t}\r\n\r\n};\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {\r\n\r\n\tTHREE.Mesh.call( this, geometry, material );\r\n\r\n\t//\r\n\r\n\tthis.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;\r\n\r\n\t// init bones\r\n\r\n\tthis.identityMatrix = new THREE.Matrix4();\r\n\r\n\tthis.bones = [];\r\n\tthis.boneMatrices = [];\r\n\r\n\tvar b, bone, gbone, p, q, s;\r\n\r\n\tif ( this.geometry && this.geometry.bones !== undefined ) {\r\n\r\n\t\tfor ( b = 0; b < this.geometry.bones.length; b ++ ) {\r\n\r\n\t\t\tgbone = this.geometry.bones[ b ];\r\n\r\n\t\t\tp = gbone.pos;\r\n\t\t\tq = gbone.rotq;\r\n\t\t\ts = gbone.scl;\r\n\r\n\t\t\tbone = this.addBone();\r\n\r\n\t\t\tbone.name = gbone.name;\r\n\t\t\tbone.position.set( p[0], p[1], p[2] );\r\n\t\t\tbone.quaternion.set( q[0], q[1], q[2], q[3] );\r\n\t\t\tbone.useQuaternion = true;\r\n\r\n\t\t\tif ( s !== undefined ) {\r\n\r\n\t\t\t\tbone.scale.set( s[0], s[1], s[2] );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbone.scale.set( 1, 1, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( b = 0; b < this.bones.length; b ++ ) {\r\n\r\n\t\t\tgbone = this.geometry.bones[ b ];\r\n\t\t\tbone = this.bones[ b ];\r\n\r\n\t\t\tif ( gbone.parent === -1 ) {\r\n\r\n\t\t\t\tthis.add( bone );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.bones[ gbone.parent ].add( bone );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tvar nBones = this.bones.length;\r\n\r\n\t\tif ( this.useVertexTexture ) {\r\n\r\n\t\t\t// layout (1 matrix = 4 pixels)\r\n\t\t\t//\tRGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\r\n\t\t\t//  with  8x8  pixel texture max   16 bones  (8 * 8  / 4)\r\n\t\t\t//  \t 16x16 pixel texture max   64 bones (16 * 16 / 4)\r\n\t\t\t//  \t 32x32 pixel texture max  256 bones (32 * 32 / 4)\r\n\t\t\t//  \t 64x64 pixel texture max 1024 bones (64 * 64 / 4)\r\n\r\n\t\t\tvar size;\r\n\r\n\t\t\tif ( nBones > 256 )\r\n\t\t\t\tsize = 64;\r\n\t\t\telse if ( nBones > 64 )\r\n\t\t\t\tsize = 32;\r\n\t\t\telse if ( nBones > 16 )\r\n\t\t\t\tsize = 16;\r\n\t\t\telse\r\n\t\t\t\tsize = 8;\r\n\r\n\t\t\tthis.boneTextureWidth = size;\r\n\t\t\tthis.boneTextureHeight = size;\r\n\r\n\t\t\tthis.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel\r\n\t\t\tthis.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );\r\n\t\t\tthis.boneTexture.minFilter = THREE.NearestFilter;\r\n\t\t\tthis.boneTexture.magFilter = THREE.NearestFilter;\r\n\t\t\tthis.boneTexture.generateMipmaps = false;\r\n\t\t\tthis.boneTexture.flipY = false;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.boneMatrices = new Float32Array( 16 * nBones );\r\n\r\n\t\t}\r\n\r\n\t\tthis.pose();\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );\r\n\r\nTHREE.SkinnedMesh.prototype.addBone = function( bone ) {\r\n\r\n\tif ( bone === undefined ) {\r\n\r\n\t\tbone = new THREE.Bone( this );\r\n\r\n\t}\r\n\r\n\tthis.bones.push( bone );\r\n\r\n\treturn bone;\r\n\r\n};\r\n\r\nTHREE.SkinnedMesh.prototype.updateMatrixWorld = function ( force ) {\r\n\r\n\tthis.matrixAutoUpdate && this.updateMatrix();\r\n\r\n\t// update matrixWorld\r\n\r\n\tif ( this.matrixWorldNeedsUpdate || force ) {\r\n\r\n\t\tif ( this.parent ) {\r\n\r\n\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.matrixWorld.copy( this.matrix );\r\n\r\n\t\t}\r\n\r\n\t\tthis.matrixWorldNeedsUpdate = false;\r\n\r\n\t\tforce = true;\r\n\r\n\t}\r\n\r\n\t// update children\r\n\r\n\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n\t\tvar child = this.children[ i ];\r\n\r\n\t\tif ( child instanceof THREE.Bone ) {\r\n\r\n\t\t\tchild.update( this.identityMatrix, false );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tchild.updateMatrixWorld( true );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// make a snapshot of the bones' rest position\r\n\r\n\tif ( this.boneInverses == undefined ) {\r\n\r\n\t\tthis.boneInverses = [];\r\n\r\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n\t\t\tvar inverse = new THREE.Matrix4();\r\n\r\n\t\t\tinverse.getInverse( this.bones[ b ].skinMatrix );\r\n\r\n\t\t\tthis.boneInverses.push( inverse );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// flatten bone matrices to array\r\n\r\n\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n\t\t// compute the offset between the current and the original transform;\r\n\r\n\t\t//TODO: we could get rid of this multiplication step if the skinMatrix\r\n\t\t// was already representing the offset; however, this requires some\r\n\t\t// major changes to the animation system\r\n\r\n\t\tTHREE.SkinnedMesh.offsetMatrix.multiplyMatrices( this.bones[ b ].skinMatrix, this.boneInverses[ b ] );\r\n\r\n\t\tTHREE.SkinnedMesh.offsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );\r\n\r\n\t}\r\n\r\n\tif ( this.useVertexTexture ) {\r\n\r\n\t\tthis.boneTexture.needsUpdate = true;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.SkinnedMesh.prototype.pose = function () {\r\n\r\n\tthis.updateMatrixWorld( true );\r\n\r\n\tfor ( var i = 0; i < this.geometry.skinIndices.length; i ++ ) {\r\n\r\n\t\t// normalize weights\r\n\r\n\t\tvar sw = this.geometry.skinWeights[ i ];\r\n\r\n\t\tvar scale = 1.0 / sw.lengthManhattan();\r\n\r\n\t\tif ( scale !== Infinity ) {\r\n\r\n\t\t\tsw.multiplyScalar( scale );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tsw.set( 1 ); // this will be normalized by the shader anyway\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.SkinnedMesh.prototype.clone = function ( object ) {\r\n\r\n\tif ( object === undefined ) object = new THREE.SkinnedMesh( this.geometry, this.material, this.useVertexTexture );\r\n\r\n\tTHREE.Mesh.prototype.clone.call( this, object );\r\n\r\n\treturn object;\r\n\r\n};\r\n\r\nTHREE.SkinnedMesh.offsetMatrix = new THREE.Matrix4();\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.MorphAnimMesh = function ( geometry, material ) {\r\n\r\n\tTHREE.Mesh.call( this, geometry, material );\r\n\r\n\t// API\r\n\r\n\tthis.duration = 1000; // milliseconds\r\n\tthis.mirroredLoop = false;\r\n\tthis.time = 0;\r\n\r\n\t// internals\r\n\r\n\tthis.lastKeyframe = 0;\r\n\tthis.currentKeyframe = 0;\r\n\r\n\tthis.direction = 1;\r\n\tthis.directionBackwards = false;\r\n\r\n\tthis.setFrameRange( 0, this.geometry.morphTargets.length - 1 );\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype = Object.create( THREE.Mesh.prototype );\r\n\r\nTHREE.MorphAnimMesh.prototype.setFrameRange = function ( start, end ) {\r\n\r\n\tthis.startKeyframe = start;\r\n\tthis.endKeyframe = end;\r\n\r\n\tthis.length = this.endKeyframe - this.startKeyframe + 1;\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.setDirectionForward = function () {\r\n\r\n\tthis.direction = 1;\r\n\tthis.directionBackwards = false;\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.setDirectionBackward = function () {\r\n\r\n\tthis.direction = -1;\r\n\tthis.directionBackwards = true;\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.parseAnimations = function () {\r\n\r\n\tvar geometry = this.geometry;\r\n\r\n\tif ( ! geometry.animations ) geometry.animations = {};\r\n\r\n\tvar firstAnimation, animations = geometry.animations;\r\n\r\n\tvar pattern = /([a-z]+)(\\d+)/;\r\n\r\n\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\r\n\r\n\t\tvar morph = geometry.morphTargets[ i ];\r\n\t\tvar parts = morph.name.match( pattern );\r\n\r\n\t\tif ( parts && parts.length > 1 ) {\r\n\r\n\t\t\tvar label = parts[ 1 ];\r\n\t\t\tvar num = parts[ 2 ];\r\n\r\n\t\t\tif ( ! animations[ label ] ) animations[ label ] = { start: Infinity, end: -Infinity };\r\n\r\n\t\t\tvar animation = animations[ label ];\r\n\r\n\t\t\tif ( i < animation.start ) animation.start = i;\r\n\t\t\tif ( i > animation.end ) animation.end = i;\r\n\r\n\t\t\tif ( ! firstAnimation ) firstAnimation = label;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgeometry.firstAnimation = firstAnimation;\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.setAnimationLabel = function ( label, start, end ) {\r\n\r\n\tif ( ! this.geometry.animations ) this.geometry.animations = {};\r\n\r\n\tthis.geometry.animations[ label ] = { start: start, end: end };\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.playAnimation = function ( label, fps ) {\r\n\r\n\tvar animation = this.geometry.animations[ label ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tthis.setFrameRange( animation.start, animation.end );\r\n\t\tthis.duration = 1000 * ( ( animation.end - animation.start ) / fps );\r\n\t\tthis.time = 0;\r\n\r\n\t} else {\r\n\r\n\t\tconsole.warn( \"animation[\" + label + \"] undefined\" );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.updateAnimation = function ( delta ) {\r\n\r\n\tvar frameTime = this.duration / this.length;\r\n\r\n\tthis.time += this.direction * delta;\r\n\r\n\tif ( this.mirroredLoop ) {\r\n\r\n\t\tif ( this.time > this.duration || this.time < 0 ) {\r\n\r\n\t\t\tthis.direction *= -1;\r\n\r\n\t\t\tif ( this.time > this.duration ) {\r\n\r\n\t\t\t\tthis.time = this.duration;\r\n\t\t\t\tthis.directionBackwards = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( this.time < 0 ) {\r\n\r\n\t\t\t\tthis.time = 0;\r\n\t\t\t\tthis.directionBackwards = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tthis.time = this.time % this.duration;\r\n\r\n\t\tif ( this.time < 0 ) this.time += this.duration;\r\n\r\n\t}\r\n\r\n\tvar keyframe = this.startKeyframe + THREE.Math.clamp( Math.floor( this.time / frameTime ), 0, this.length - 1 );\r\n\r\n\tif ( keyframe !== this.currentKeyframe ) {\r\n\r\n\t\tthis.morphTargetInfluences[ this.lastKeyframe ] = 0;\r\n\t\tthis.morphTargetInfluences[ this.currentKeyframe ] = 1;\r\n\r\n\t\tthis.morphTargetInfluences[ keyframe ] = 0;\r\n\r\n\t\tthis.lastKeyframe = this.currentKeyframe;\r\n\t\tthis.currentKeyframe = keyframe;\r\n\r\n\t}\r\n\r\n\tvar mix = ( this.time % frameTime ) / frameTime;\r\n\r\n\tif ( this.directionBackwards ) {\r\n\r\n\t\tmix = 1 - mix;\r\n\r\n\t}\r\n\r\n\tthis.morphTargetInfluences[ this.currentKeyframe ] = mix;\r\n\tthis.morphTargetInfluences[ this.lastKeyframe ] = 1 - mix;\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.clone = function ( object ) {\r\n\r\n\tif ( object === undefined ) object = new THREE.MorphAnimMesh( this.geometry, this.material );\r\n\r\n\tobject.duration = this.duration;\r\n\tobject.mirroredLoop = this.mirroredLoop;\r\n\tobject.time = this.time;\r\n\r\n\tobject.lastKeyframe = this.lastKeyframe;\r\n\tobject.currentKeyframe = this.currentKeyframe;\r\n\r\n\tobject.direction = this.direction;\r\n\tobject.directionBackwards = this.directionBackwards;\r\n\r\n\tTHREE.Mesh.prototype.clone.call( this, object );\r\n\r\n\treturn object;\r\n\r\n};\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Ribbon = function ( geometry, material ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.geometry = geometry;\r\n\tthis.material = material;\r\n\r\n};\r\n\r\nTHREE.Ribbon.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.Ribbon.prototype.clone = function ( object ) {\r\n\r\n\tif ( object === undefined ) object = new THREE.Ribbon( this.geometry, this.material );\r\n\r\n\tTHREE.Object3D.prototype.clone.call( this, object );\r\n\r\n\treturn object;\r\n\r\n};\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.LOD = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.LODs = [];\r\n\r\n};\r\n\r\n\r\nTHREE.LOD.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.LOD.prototype.addLevel = function ( object3D, visibleAtDistance ) {\r\n\r\n\tif ( visibleAtDistance === undefined ) {\r\n\r\n\t\tvisibleAtDistance = 0;\r\n\r\n\t}\r\n\r\n\tvisibleAtDistance = Math.abs( visibleAtDistance );\r\n\r\n\tfor ( var l = 0; l < this.LODs.length; l ++ ) {\r\n\r\n\t\tif ( visibleAtDistance < this.LODs[ l ].visibleAtDistance ) {\r\n\r\n\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.LODs.splice( l, 0, { visibleAtDistance: visibleAtDistance, object3D: object3D } );\r\n\tthis.add( object3D );\r\n\r\n};\r\n\r\nTHREE.LOD.prototype.update = function ( camera ) {\r\n\r\n\tif ( this.LODs.length > 1 ) {\r\n\r\n\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\r\n\r\n\t\tvar inverse  = camera.matrixWorldInverse;\r\n\t\tvar distance = -( inverse.elements[2] * this.matrixWorld.elements[12] + inverse.elements[6] * this.matrixWorld.elements[13] + inverse.elements[10] * this.matrixWorld.elements[14] + inverse.elements[14] );\r\n\r\n\t\tthis.LODs[ 0 ].object3D.visible = true;\r\n\r\n\t\tfor ( var l = 1; l < this.LODs.length; l ++ ) {\r\n\r\n\t\t\tif( distance >= this.LODs[ l ].visibleAtDistance ) {\r\n\r\n\t\t\t\tthis.LODs[ l - 1 ].object3D.visible = false;\r\n\t\t\t\tthis.LODs[ l     ].object3D.visible = true;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor( ; l < this.LODs.length; l ++ ) {\r\n\r\n\t\t\tthis.LODs[ l ].object3D.visible = false;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.LOD.prototype.clone = function () {\r\n\r\n\t// TODO\r\n\r\n};\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Sprite = function ( material ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();\r\n\r\n\tthis.rotation3d = this.rotation;\r\n\tthis.rotation = 0;\r\n\r\n};\r\n\r\nTHREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\n/*\r\n * Custom update matrix\r\n */\r\n\r\nTHREE.Sprite.prototype.updateMatrix = function () {\r\n\r\n\tthis.matrix.setPosition( this.position );\r\n\r\n\tthis.rotation3d.set( 0, 0, this.rotation );\r\n\tthis.matrix.setRotationFromEuler( this.rotation3d );\r\n\r\n\tif ( this.scale.x !== 1 || this.scale.y !== 1 ) {\r\n\r\n\t\tthis.matrix.scale( this.scale );\r\n\r\n\t}\r\n\r\n\tthis.matrixWorldNeedsUpdate = true;\r\n\r\n};\r\n\r\nTHREE.Sprite.prototype.clone = function ( object ) {\r\n\r\n\tif ( object === undefined ) object = new THREE.Sprite( this.material );\r\n\r\n\tTHREE.Object3D.prototype.clone.call( this, object );\r\n\r\n\treturn object;\r\n\r\n};\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Scene = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.fog = null;\r\n\tthis.overrideMaterial = null;\r\n\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tthis.__objects = [];\r\n\tthis.__lights = [];\r\n\r\n\tthis.__objectsAdded = [];\r\n\tthis.__objectsRemoved = [];\r\n\r\n};\r\n\r\nTHREE.Scene.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.Scene.prototype.__addObject = function ( object ) {\r\n\r\n\tif ( object instanceof THREE.Light ) {\r\n\r\n\t\tif ( this.__lights.indexOf( object ) === - 1 ) {\r\n\r\n\t\t\tthis.__lights.push( object );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.target && object.target.parent === undefined ) {\r\n\r\n\t\t\tthis.add( object.target );\r\n\r\n\t\t}\r\n\r\n\t} else if ( !( object instanceof THREE.Camera || object instanceof THREE.Bone ) ) {\r\n\r\n\t\tif ( this.__objects.indexOf( object ) === - 1 ) {\r\n\r\n\t\t\tthis.__objects.push( object );\r\n\t\t\tthis.__objectsAdded.push( object );\r\n\r\n\t\t\t// check if previously removed\r\n\r\n\t\t\tvar i = this.__objectsRemoved.indexOf( object );\r\n\r\n\t\t\tif ( i !== -1 ) {\r\n\r\n\t\t\t\tthis.__objectsRemoved.splice( i, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfor ( var c = 0; c < object.children.length; c ++ ) {\r\n\r\n\t\tthis.__addObject( object.children[ c ] );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Scene.prototype.__removeObject = function ( object ) {\r\n\r\n\tif ( object instanceof THREE.Light ) {\r\n\r\n\t\tvar i = this.__lights.indexOf( object );\r\n\r\n\t\tif ( i !== -1 ) {\r\n\r\n\t\t\tthis.__lights.splice( i, 1 );\r\n\r\n\t\t}\r\n\r\n\t} else if ( !( object instanceof THREE.Camera ) ) {\r\n\r\n\t\tvar i = this.__objects.indexOf( object );\r\n\r\n\t\tif( i !== -1 ) {\r\n\r\n\t\t\tthis.__objects.splice( i, 1 );\r\n\t\t\tthis.__objectsRemoved.push( object );\r\n\r\n\t\t\t// check if previously added\r\n\r\n\t\t\tvar ai = this.__objectsAdded.indexOf( object );\r\n\r\n\t\t\tif ( ai !== -1 ) {\r\n\r\n\t\t\t\tthis.__objectsAdded.splice( ai, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfor ( var c = 0; c < object.children.length; c ++ ) {\r\n\r\n\t\tthis.__removeObject( object.children[ c ] );\r\n\r\n\t}\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Fog = function ( hex, near, far ) {\r\n\r\n\tthis.name = '';\r\n\r\n\tthis.color = new THREE.Color( hex );\r\n\r\n\tthis.near = ( near !== undefined ) ? near : 1;\r\n\tthis.far = ( far !== undefined ) ? far : 1000;\r\n\r\n};\r\n\r\nTHREE.Fog.prototype.clone = function () {\r\n\r\n\treturn new THREE.Fog( this.color.getHex(), this.near, this.far );\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.FogExp2 = function ( hex, density ) {\r\n\r\n\tthis.name = '';\r\n\tthis.color = new THREE.Color( hex );\r\n\tthis.density = ( density !== undefined ) ? density : 0.00025;\r\n\r\n};\r\n\r\nTHREE.FogExp2.prototype.clone = function () {\r\n\r\n\treturn new THREE.FogExp2( this.color.getHex(), this.density );\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.CanvasRenderer = function ( parameters ) {\r\n\r\n\tconsole.log( 'THREE.CanvasRenderer', THREE.REVISION );\r\n\r\n\tvar smoothstep = THREE.Math.smoothstep;\r\n\r\n\tparameters = parameters || {};\r\n\r\n\tvar _this = this,\r\n\t_renderData, _elements, _lights,\r\n\t_projector = new THREE.Projector(),\r\n\r\n\t_canvas = parameters.canvas !== undefined\r\n\t\t\t? parameters.canvas\r\n\t\t\t: document.createElement( 'canvas' ),\r\n\r\n\t_canvasWidth, _canvasHeight, _canvasWidthHalf, _canvasHeightHalf,\r\n\t_context = _canvas.getContext( '2d' ),\r\n\r\n\t_clearColor = new THREE.Color( 0x000000 ),\r\n\t_clearOpacity = 0,\r\n\r\n\t_contextGlobalAlpha = 1,\r\n\t_contextGlobalCompositeOperation = 0,\r\n\t_contextStrokeStyle = null,\r\n\t_contextFillStyle = null,\r\n\t_contextLineWidth = null,\r\n\t_contextLineCap = null,\r\n\t_contextLineJoin = null,\r\n\t_contextDashSize = null,\r\n\t_contextGapSize = 0,\r\n\r\n\t_v1, _v2, _v3, _v4,\r\n\t_v5 = new THREE.RenderableVertex(),\r\n\t_v6 = new THREE.RenderableVertex(),\r\n\r\n\t_v1x, _v1y, _v2x, _v2y, _v3x, _v3y,\r\n\t_v4x, _v4y, _v5x, _v5y, _v6x, _v6y,\r\n\r\n\t_color = new THREE.Color(),\r\n\t_color1 = new THREE.Color(),\r\n\t_color2 = new THREE.Color(),\r\n\t_color3 = new THREE.Color(),\r\n\t_color4 = new THREE.Color(),\r\n\r\n\t_diffuseColor = new THREE.Color(),\r\n\t_emissiveColor = new THREE.Color(),\r\n\r\n\t_lightColor = new THREE.Color(),\r\n\r\n\t_patterns = {}, _imagedatas = {},\r\n\r\n\t_near, _far,\r\n\r\n\t_image, _uvs,\r\n\t_uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y,\r\n\r\n\t_clipBox = new THREE.Box2(),\r\n\t_clearBox = new THREE.Box2(),\r\n\t_elemBox = new THREE.Box2(),\r\n\r\n\t_enableLighting = false,\r\n\t_ambientLight = new THREE.Color(),\r\n\t_directionalLights = new THREE.Color(),\r\n\t_pointLights = new THREE.Color(),\r\n\r\n\t_vector3 = new THREE.Vector3(), // Needed for PointLight\r\n\r\n\t_pixelMap, _pixelMapContext, _pixelMapImage, _pixelMapData,\r\n\t_gradientMap, _gradientMapContext, _gradientMapQuality = 16;\r\n\r\n\t_pixelMap = document.createElement( 'canvas' );\r\n\t_pixelMap.width = _pixelMap.height = 2;\r\n\r\n\t_pixelMapContext = _pixelMap.getContext( '2d' );\r\n\t_pixelMapContext.fillStyle = 'rgba(0,0,0,1)';\r\n\t_pixelMapContext.fillRect( 0, 0, 2, 2 );\r\n\r\n\t_pixelMapImage = _pixelMapContext.getImageData( 0, 0, 2, 2 );\r\n\t_pixelMapData = _pixelMapImage.data;\r\n\r\n\t_gradientMap = document.createElement( 'canvas' );\r\n\t_gradientMap.width = _gradientMap.height = _gradientMapQuality;\r\n\r\n\t_gradientMapContext = _gradientMap.getContext( '2d' );\r\n\t_gradientMapContext.translate( - _gradientMapQuality / 2, - _gradientMapQuality / 2 );\r\n\t_gradientMapContext.scale( _gradientMapQuality, _gradientMapQuality );\r\n\r\n\t_gradientMapQuality --; // Fix UVs\r\n\r\n\t// dash+gap fallbacks for Firefox and everything else\r\n\r\n\tif ( _context.setLineDash === undefined ) {\r\n\r\n\t\tif ( _context.mozDash !== undefined ) {\r\n\r\n\t\t\t_context.setLineDash = function ( values ) {\r\n\r\n\t\t\t\t_context.mozDash = values[ 0 ] !== null ? values : null;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_context.setLineDash = function () {}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.domElement = _canvas;\r\n\r\n\tthis.devicePixelRatio = parameters.devicePixelRatio !== undefined\r\n\t\t\t\t? parameters.devicePixelRatio\r\n\t\t\t\t: window.devicePixelRatio !== undefined\r\n\t\t\t\t\t? window.devicePixelRatio\r\n\t\t\t\t\t: 1;\r\n\r\n\tthis.autoClear = true;\r\n\tthis.sortObjects = true;\r\n\tthis.sortElements = true;\r\n\r\n\tthis.info = {\r\n\r\n\t\trender: {\r\n\r\n\t\t\tvertices: 0,\r\n\t\t\tfaces: 0\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// WebGLRenderer compatibility\r\n\r\n\tthis.supportsVertexTextures = function () {};\r\n\tthis.setFaceCulling = function () {};\r\n\r\n\tthis.setSize = function ( width, height ) {\r\n\r\n\t\t_canvasWidth = width * this.devicePixelRatio;\r\n\t\t_canvasHeight = height * this.devicePixelRatio;\r\n\r\n\t\t_canvasWidthHalf = Math.floor( _canvasWidth / 2 );\r\n\t\t_canvasHeightHalf = Math.floor( _canvasHeight / 2 );\r\n\r\n\t\t_canvas.width = _canvasWidth;\r\n\t\t_canvas.height = _canvasHeight;\r\n\r\n\t\t_canvas.style.width = width + 'px';\r\n\t\t_canvas.style.height = height + 'px';\r\n\r\n\t\t_clipBox.set(\r\n\t\t\tnew THREE.Vector2( - _canvasWidthHalf, - _canvasHeightHalf ),\r\n\t\t\tnew THREE.Vector2( _canvasWidthHalf, _canvasHeightHalf )\r\n\t\t);\r\n\r\n\t\t_clearBox.set(\r\n\t\t\tnew THREE.Vector2( - _canvasWidthHalf, - _canvasHeightHalf ),\r\n\t\t\tnew THREE.Vector2( _canvasWidthHalf, _canvasHeightHalf )\r\n\t\t);\r\n\r\n\t\t_contextGlobalAlpha = 1;\r\n\t\t_contextGlobalCompositeOperation = 0;\r\n\t\t_contextStrokeStyle = null;\r\n\t\t_contextFillStyle = null;\r\n\t\t_contextLineWidth = null;\r\n\t\t_contextLineCap = null;\r\n\t\t_contextLineJoin = null;\r\n\r\n\t};\r\n\r\n\tthis.setClearColor = function ( color, opacity ) {\r\n\r\n\t\t_clearColor.copy( color );\r\n\t\t_clearOpacity = opacity !== undefined ? opacity : 1;\r\n\r\n\t\t_clearBox.set(\r\n\t\t\tnew THREE.Vector2( - _canvasWidthHalf, - _canvasHeightHalf ),\r\n\t\t\tnew THREE.Vector2( _canvasWidthHalf, _canvasHeightHalf )\r\n\t\t);\r\n\r\n\t};\r\n\r\n\tthis.setClearColorHex = function ( hex, opacity ) {\r\n\r\n\t\t_clearColor.setHex( hex );\r\n\t\t_clearOpacity = opacity !== undefined ? opacity : 1;\r\n\r\n\t\t_clearBox.set(\r\n\t\t\tnew THREE.Vector2( - _canvasWidthHalf, - _canvasHeightHalf ),\r\n\t\t\tnew THREE.Vector2( _canvasWidthHalf, _canvasHeightHalf )\r\n\t\t);\r\n\r\n\t};\r\n\r\n\tthis.getMaxAnisotropy  = function () {\r\n\r\n\t\treturn 0;\r\n\r\n\t};\r\n\r\n\tthis.clear = function () {\r\n\r\n\t\t_context.setTransform( 1, 0, 0, - 1, _canvasWidthHalf, _canvasHeightHalf );\r\n\r\n\t\tif ( _clearBox.empty() === false ) {\r\n\r\n\t\t\t_clearBox.intersect( _clipBox );\r\n\t\t\t_clearBox.expandByScalar( 2 );\r\n\r\n\t\t\tif ( _clearOpacity < 1 ) {\r\n\r\n\t\t\t\t_context.clearRect(\r\n\t\t\t\t\t_clearBox.min.x | 0,\r\n\t\t\t\t\t_clearBox.min.y | 0,\r\n\t\t\t\t\t( _clearBox.max.x - _clearBox.min.x ) | 0,\r\n\t\t\t\t\t( _clearBox.max.y - _clearBox.min.y ) | 0\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( _clearOpacity > 0 ) {\r\n\r\n\t\t\t\tsetBlending( THREE.NormalBlending );\r\n\t\t\t\tsetOpacity( 1 );\r\n\r\n\t\t\t\tsetFillStyle( 'rgba(' + Math.floor( _clearColor.r * 255 ) + ',' + Math.floor( _clearColor.g * 255 ) + ',' + Math.floor( _clearColor.b * 255 ) + ',' + _clearOpacity + ')' );\r\n\r\n\t\t\t\t_context.fillRect(\r\n\t\t\t\t\t_clearBox.min.x | 0,\r\n\t\t\t\t\t_clearBox.min.y | 0,\r\n\t\t\t\t\t( _clearBox.max.x - _clearBox.min.x ) | 0,\r\n\t\t\t\t\t( _clearBox.max.y - _clearBox.min.y ) | 0\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_clearBox.makeEmpty();\r\n\r\n\t\t}\r\n\r\n\r\n\t};\r\n\r\n\tthis.render = function ( scene, camera ) {\r\n\r\n\t\tif ( camera instanceof THREE.Camera === false ) {\r\n\r\n\t\t\tconsole.error( 'THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.autoClear === true ) {\r\n\r\n\t\t\tthis.clear();\r\n\r\n\t\t}\r\n\r\n\t\t_context.setTransform( 1, 0, 0, - 1, _canvasWidthHalf, _canvasHeightHalf );\r\n\r\n\t\t_this.info.render.vertices = 0;\r\n\t\t_this.info.render.faces = 0;\r\n\r\n\t\t_renderData = _projector.projectScene( scene, camera, this.sortObjects, this.sortElements );\r\n\t\t_elements = _renderData.elements;\r\n\t\t_lights = _renderData.lights;\r\n\r\n\t\t/* DEBUG\r\n\t\tsetFillStyle( 'rgba( 0, 255, 255, 0.5 )' );\r\n\t\t_context.fillRect( _clipBox.min.x, _clipBox.min.y, _clipBox.max.x - _clipBox.min.x, _clipBox.max.y - _clipBox.min.y );\r\n\t\t*/\r\n\r\n\t\t_enableLighting = _lights.length > 0;\r\n\r\n\t\tif ( _enableLighting === true ) {\r\n\r\n\t\t\t calculateLights();\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var e = 0, el = _elements.length; e < el; e++ ) {\r\n\r\n\t\t\tvar element = _elements[ e ];\r\n\r\n\t\t\tvar material = element.material;\r\n\r\n\t\t\tif ( material === undefined || material.visible === false ) continue;\r\n\r\n\t\t\t_elemBox.makeEmpty();\r\n\r\n\t\t\tif ( element instanceof THREE.RenderableParticle ) {\r\n\r\n\t\t\t\t_v1 = element;\r\n\t\t\t\t_v1.x *= _canvasWidthHalf; _v1.y *= _canvasHeightHalf;\r\n\r\n\t\t\t\trenderParticle( _v1, element, material );\r\n\r\n\t\t\t} else if ( element instanceof THREE.RenderableLine ) {\r\n\r\n\t\t\t\t_v1 = element.v1; _v2 = element.v2;\r\n\r\n\t\t\t\t_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;\r\n\t\t\t\t_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;\r\n\r\n\t\t\t\t_elemBox.setFromPoints( [ _v1.positionScreen, _v2.positionScreen ] );\r\n\r\n\t\t\t\tif ( _clipBox.isIntersectionBox( _elemBox ) === true ) {\r\n\r\n\t\t\t\t\trenderLine( _v1, _v2, element, material );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( element instanceof THREE.RenderableFace3 ) {\r\n\r\n\t\t\t\t_v1 = element.v1; _v2 = element.v2; _v3 = element.v3;\r\n\r\n\t\t\t\tif ( _v1.positionScreen.z < -1 || _v1.positionScreen.z > 1 ) continue;\r\n\t\t\t\tif ( _v2.positionScreen.z < -1 || _v2.positionScreen.z > 1 ) continue;\r\n\t\t\t\tif ( _v3.positionScreen.z < -1 || _v3.positionScreen.z > 1 ) continue;\r\n\r\n\t\t\t\t_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;\r\n\t\t\t\t_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;\r\n\t\t\t\t_v3.positionScreen.x *= _canvasWidthHalf; _v3.positionScreen.y *= _canvasHeightHalf;\r\n\r\n\t\t\t\tif ( material.overdraw === true ) {\r\n\r\n\t\t\t\t\texpand( _v1.positionScreen, _v2.positionScreen );\r\n\t\t\t\t\texpand( _v2.positionScreen, _v3.positionScreen );\r\n\t\t\t\t\texpand( _v3.positionScreen, _v1.positionScreen );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_elemBox.setFromPoints( [ _v1.positionScreen, _v2.positionScreen, _v3.positionScreen ] );\r\n\r\n\t\t\t\trenderFace3( _v1, _v2, _v3, 0, 1, 2, element, material );\r\n\r\n\t\t\t} else if ( element instanceof THREE.RenderableFace4 ) {\r\n\r\n\t\t\t\t_v1 = element.v1; _v2 = element.v2; _v3 = element.v3; _v4 = element.v4;\r\n\r\n\t\t\t\tif ( _v1.positionScreen.z < -1 || _v1.positionScreen.z > 1 ) continue;\r\n\t\t\t\tif ( _v2.positionScreen.z < -1 || _v2.positionScreen.z > 1 ) continue;\r\n\t\t\t\tif ( _v3.positionScreen.z < -1 || _v3.positionScreen.z > 1 ) continue;\r\n\t\t\t\tif ( _v4.positionScreen.z < -1 || _v4.positionScreen.z > 1 ) continue;\r\n\r\n\t\t\t\t_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;\r\n\t\t\t\t_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;\r\n\t\t\t\t_v3.positionScreen.x *= _canvasWidthHalf; _v3.positionScreen.y *= _canvasHeightHalf;\r\n\t\t\t\t_v4.positionScreen.x *= _canvasWidthHalf; _v4.positionScreen.y *= _canvasHeightHalf;\r\n\r\n\t\t\t\t_v5.positionScreen.copy( _v2.positionScreen );\r\n\t\t\t\t_v6.positionScreen.copy( _v4.positionScreen );\r\n\r\n\t\t\t\tif ( material.overdraw === true ) {\r\n\r\n\t\t\t\t\texpand( _v1.positionScreen, _v2.positionScreen );\r\n\t\t\t\t\texpand( _v2.positionScreen, _v4.positionScreen );\r\n\t\t\t\t\texpand( _v4.positionScreen, _v1.positionScreen );\r\n\r\n\t\t\t\t\texpand( _v3.positionScreen, _v5.positionScreen );\r\n\t\t\t\t\texpand( _v3.positionScreen, _v6.positionScreen );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_elemBox.setFromPoints( [ _v1.positionScreen, _v2.positionScreen, _v3.positionScreen, _v4.positionScreen ] );\r\n\r\n\t\t\t\trenderFace4( _v1, _v2, _v3, _v4, _v5, _v6, element, material, scene );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t/* DEBUG\r\n\t\t\tsetLineWidth( 1 );\r\n\t\t\tsetStrokeStyle( 'rgba( 0, 255, 0, 0.5 )' );\r\n\t\t\t_context.strokeRect( _elemBox.min.x, _elemBox.min.y, _elemBox.max.x - _elemBox.min.x, _elemBox.max.y - _elemBox.min.y );\r\n\t\t\t*/\r\n\r\n\t\t\t_clearBox.union( _elemBox );\r\n\r\n\t\t}\r\n\r\n\t\t/* DEBUG\r\n\t\tsetLineWidth( 1 );\r\n\t\tsetStrokeStyle( 'rgba( 255, 0, 0, 0.5 )' );\r\n\t\t_context.strokeRect( _clearBox.min.x, _clearBox.min.y, _clearBox.max.x - _clearBox.min.x, _clearBox.max.y - _clearBox.min.y );\r\n\t\t*/\r\n\r\n\t\t_context.setTransform( 1, 0, 0, 1, 0, 0 );\r\n\r\n\t\t//\r\n\r\n\t\tfunction calculateLights() {\r\n\r\n\t\t\t_ambientLight.setRGB( 0, 0, 0 );\r\n\t\t\t_directionalLights.setRGB( 0, 0, 0 );\r\n\t\t\t_pointLights.setRGB( 0, 0, 0 );\r\n\r\n\t\t\tfor ( var l = 0, ll = _lights.length; l < ll; l ++ ) {\r\n\r\n\t\t\t\tvar light = _lights[ l ];\r\n\t\t\t\tvar lightColor = light.color;\r\n\r\n\t\t\t\tif ( light instanceof THREE.AmbientLight ) {\r\n\r\n\t\t\t\t\t_ambientLight.add( lightColor );\r\n\r\n\t\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\r\n\r\n\t\t\t\t\t// for particles\r\n\r\n\t\t\t\t\t_directionalLights.add( lightColor );\r\n\r\n\t\t\t\t} else if ( light instanceof THREE.PointLight ) {\r\n\r\n\t\t\t\t\t// for particles\r\n\r\n\t\t\t\t\t_pointLights.add( lightColor );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction calculateLight( position, normal, color ) {\r\n\r\n\t\t\tfor ( var l = 0, ll = _lights.length; l < ll; l ++ ) {\r\n\r\n\t\t\t\tvar light = _lights[ l ];\r\n\r\n\t\t\t\t_lightColor.copy( light.color );\r\n\r\n\t\t\t\tif ( light instanceof THREE.DirectionalLight ) {\r\n\r\n\t\t\t\t\tvar lightPosition = _vector3.getPositionFromMatrix( light.matrixWorld ).normalize();\r\n\r\n\t\t\t\t\tvar amount = normal.dot( lightPosition );\r\n\r\n\t\t\t\t\tif ( amount <= 0 ) continue;\r\n\r\n\t\t\t\t\tamount *= light.intensity;\r\n\r\n\t\t\t\t\tcolor.add( _lightColor.multiplyScalar( amount ) );\r\n\r\n\t\t\t\t} else if ( light instanceof THREE.PointLight ) {\r\n\r\n\t\t\t\t\tvar lightPosition = _vector3.getPositionFromMatrix( light.matrixWorld );\r\n\r\n\t\t\t\t\tvar amount = normal.dot( _vector3.subVectors( lightPosition, position ).normalize() );\r\n\r\n\t\t\t\t\tif ( amount <= 0 ) continue;\r\n\r\n\t\t\t\t\tamount *= light.distance == 0 ? 1 : 1 - Math.min( position.distanceTo( lightPosition ) / light.distance, 1 );\r\n\r\n\t\t\t\t\tif ( amount == 0 ) continue;\r\n\r\n\t\t\t\t\tamount *= light.intensity;\r\n\r\n\t\t\t\t\tcolor.add( _lightColor.multiplyScalar( amount ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction renderParticle( v1, element, material ) {\r\n\r\n\t\t\tsetOpacity( material.opacity );\r\n\t\t\tsetBlending( material.blending );\r\n\r\n\t\t\tvar width, height, scaleX, scaleY,\r\n\t\t\tbitmap, bitmapWidth, bitmapHeight;\r\n\r\n\t\t\tif ( material instanceof THREE.ParticleBasicMaterial ) {\r\n\r\n\t\t\t\tif ( material.map === null ) {\r\n\r\n\t\t\t\t\tscaleX = element.object.scale.x;\r\n\t\t\t\t\tscaleY = element.object.scale.y;\r\n\r\n\t\t\t\t\t// TODO: Be able to disable this\r\n\r\n\t\t\t\t\tscaleX *= element.scale.x * _canvasWidthHalf;\r\n\t\t\t\t\tscaleY *= element.scale.y * _canvasHeightHalf;\r\n\r\n\t\t\t\t\t_elemBox.min.set( v1.x - scaleX, v1.y - scaleY );\r\n\t\t\t\t\t_elemBox.max.set( v1.x + scaleX, v1.y + scaleY );\r\n\r\n\t\t\t\t\tif ( _clipBox.isIntersectionBox( _elemBox ) === false ) {\r\n\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tsetFillStyle( material.color.getStyle() );\r\n\r\n\t\t\t\t\t_context.save();\r\n\t\t\t\t\t_context.translate( v1.x, v1.y );\r\n\t\t\t\t\t_context.rotate( - element.rotation );\r\n\t\t\t\t\t_context.scale( scaleX, scaleY );\r\n\t\t\t\t\t_context.fillRect( -1, -1, 2, 2 );\r\n\t\t\t\t\t_context.restore();\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tbitmap = material.map.image;\r\n\t\t\t\t\tbitmapWidth = bitmap.width >> 1;\r\n\t\t\t\t\tbitmapHeight = bitmap.height >> 1;\r\n\r\n\t\t\t\t\tscaleX = element.scale.x * _canvasWidthHalf;\r\n\t\t\t\t\tscaleY = element.scale.y * _canvasHeightHalf;\r\n\r\n\t\t\t\t\twidth = scaleX * bitmapWidth;\r\n\t\t\t\t\theight = scaleY * bitmapHeight;\r\n\r\n\t\t\t\t\t// TODO: Rotations break this...\r\n\r\n\t\t\t\t\t_elemBox.min.set( v1.x - width, v1.y - height );\r\n\t\t\t\t\t_elemBox.max.set( v1.x + width, v1.y + height );\r\n\r\n\t\t\t\t\tif ( _clipBox.isIntersectionBox( _elemBox ) === false ) {\r\n\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t_context.save();\r\n\t\t\t\t\t_context.translate( v1.x, v1.y );\r\n\t\t\t\t\t_context.rotate( - element.rotation );\r\n\t\t\t\t\t_context.scale( scaleX, - scaleY );\r\n\r\n\t\t\t\t\t_context.translate( - bitmapWidth, - bitmapHeight );\r\n\t\t\t\t\t_context.drawImage( bitmap, 0, 0 );\r\n\t\t\t\t\t_context.restore();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/* DEBUG\r\n\t\t\t\tsetStrokeStyle( 'rgb(255,255,0)' );\r\n\t\t\t\t_context.beginPath();\r\n\t\t\t\t_context.moveTo( v1.x - 10, v1.y );\r\n\t\t\t\t_context.lineTo( v1.x + 10, v1.y );\r\n\t\t\t\t_context.moveTo( v1.x, v1.y - 10 );\r\n\t\t\t\t_context.lineTo( v1.x, v1.y + 10 );\r\n\t\t\t\t_context.stroke();\r\n\t\t\t\t*/\r\n\r\n\t\t\t} else if ( material instanceof THREE.ParticleCanvasMaterial ) {\r\n\r\n\t\t\t\twidth = element.scale.x * _canvasWidthHalf;\r\n\t\t\t\theight = element.scale.y * _canvasHeightHalf;\r\n\r\n\t\t\t\t_elemBox.min.set( v1.x - width, v1.y - height );\r\n\t\t\t\t_elemBox.max.set( v1.x + width, v1.y + height );\r\n\r\n\t\t\t\tif ( _clipBox.isIntersectionBox( _elemBox ) === false ) {\r\n\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tsetStrokeStyle( material.color.getStyle() );\r\n\t\t\t\tsetFillStyle( material.color.getStyle() );\r\n\r\n\t\t\t\t_context.save();\r\n\t\t\t\t_context.translate( v1.x, v1.y );\r\n\t\t\t\t_context.rotate( - element.rotation );\r\n\t\t\t\t_context.scale( width, height );\r\n\r\n\t\t\t\tmaterial.program( _context );\r\n\r\n\t\t\t\t_context.restore();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction renderLine( v1, v2, element, material ) {\r\n\r\n\t\t\tsetOpacity( material.opacity );\r\n\t\t\tsetBlending( material.blending );\r\n\r\n\t\t\t_context.beginPath();\r\n\t\t\t_context.moveTo( v1.positionScreen.x, v1.positionScreen.y );\r\n\t\t\t_context.lineTo( v2.positionScreen.x, v2.positionScreen.y );\r\n\r\n\t\t\tif ( material instanceof THREE.LineBasicMaterial ) {\r\n\r\n\t\t\t\tsetLineWidth( material.linewidth );\r\n\t\t\t\tsetLineCap( material.linecap );\r\n\t\t\t\tsetLineJoin( material.linejoin );\r\n\t\t\t\tsetStrokeStyle( material.color.getStyle() );\r\n\t\t\t\tsetDashAndGap( null, null );\r\n\r\n\t\t\t\t_context.stroke();\r\n\t\t\t\t_elemBox.expandByScalar( material.linewidth * 2 );\r\n\r\n\t\t\t} else if ( material instanceof THREE.LineDashedMaterial ) {\r\n\r\n\t\t\t\tsetLineWidth( material.linewidth );\r\n\t\t\t\tsetLineCap( material.linecap );\r\n\t\t\t\tsetLineJoin( material.linejoin );\r\n\t\t\t\tsetStrokeStyle( material.color.getStyle() );\r\n\t\t\t\tsetDashAndGap( material.dashSize, material.gapSize );\r\n\r\n\t\t\t\t_context.stroke();\r\n\t\t\t\t_elemBox.expandByScalar( material.linewidth * 2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction renderFace3( v1, v2, v3, uv1, uv2, uv3, element, material ) {\r\n\r\n\t\t\t_this.info.render.vertices += 3;\r\n\t\t\t_this.info.render.faces ++;\r\n\r\n\t\t\tsetOpacity( material.opacity );\r\n\t\t\tsetBlending( material.blending );\r\n\r\n\t\t\t_v1x = v1.positionScreen.x; _v1y = v1.positionScreen.y;\r\n\t\t\t_v2x = v2.positionScreen.x; _v2y = v2.positionScreen.y;\r\n\t\t\t_v3x = v3.positionScreen.x; _v3y = v3.positionScreen.y;\r\n\r\n\t\t\tdrawTriangle( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y );\r\n\r\n\t\t\tif ( ( material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial ) && material.map === null ) {\r\n\r\n\t\t\t\t_diffuseColor.copy( material.color );\r\n\t\t\t\t_emissiveColor.copy( material.emissive );\r\n\r\n\t\t\t\tif ( material.vertexColors === THREE.FaceColors ) {\r\n\r\n\t\t\t\t\t_diffuseColor.multiply( element.color );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( _enableLighting === true ) {\r\n\r\n\t\t\t\t\tif ( material.wireframe === false && material.shading == THREE.SmoothShading && element.vertexNormalsLength == 3 ) {\r\n\r\n\t\t\t\t\t\t_color1.copy( _ambientLight );\r\n\t\t\t\t\t\t_color2.copy( _ambientLight );\r\n\t\t\t\t\t\t_color3.copy( _ambientLight );\r\n\r\n\t\t\t\t\t\tcalculateLight( element.v1.positionWorld, element.vertexNormalsModel[ 0 ], _color1 );\r\n\t\t\t\t\t\tcalculateLight( element.v2.positionWorld, element.vertexNormalsModel[ 1 ], _color2 );\r\n\t\t\t\t\t\tcalculateLight( element.v3.positionWorld, element.vertexNormalsModel[ 2 ], _color3 );\r\n\r\n\t\t\t\t\t\t_color1.multiply( _diffuseColor ).add( _emissiveColor );\r\n\t\t\t\t\t\t_color2.multiply( _diffuseColor ).add( _emissiveColor );\r\n\t\t\t\t\t\t_color3.multiply( _diffuseColor ).add( _emissiveColor );\r\n\t\t\t\t\t\t_color4.addColors( _color2, _color3 ).multiplyScalar( 0.5 );\r\n\r\n\t\t\t\t\t\t_image = getGradientTexture( _color1, _color2, _color3, _color4 );\r\n\r\n\t\t\t\t\t\tclipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t_color.copy( _ambientLight );\r\n\r\n\t\t\t\t\t\tcalculateLight( element.centroidModel, element.normalModel, _color );\r\n\r\n\t\t\t\t\t\t_color.multiply( _diffuseColor ).add( _emissiveColor );\r\n\r\n\t\t\t\t\t\tmaterial.wireframe === true\r\n\t\t\t\t\t\t\t? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\r\n\t\t\t\t\t\t\t: fillPath( _color );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tmaterial.wireframe === true\r\n\t\t\t\t\t\t? strokePath( material.color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\r\n\t\t\t\t\t\t: fillPath( material.color );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshBasicMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial ) {\r\n\r\n\t\t\t\tif ( material.map !== null ) {\r\n\r\n\t\t\t\t\tif ( material.map.mapping instanceof THREE.UVMapping ) {\r\n\r\n\t\t\t\t\t\t_uvs = element.uvs[ 0 ];\r\n\t\t\t\t\t\tpatternPath( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uvs[ uv1 ].x, _uvs[ uv1 ].y, _uvs[ uv2 ].x, _uvs[ uv2 ].y, _uvs[ uv3 ].x, _uvs[ uv3 ].y, material.map );\r\n\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t} else if ( material.envMap !== null ) {\r\n\r\n\t\t\t\t\tif ( material.envMap.mapping instanceof THREE.SphericalReflectionMapping ) {\r\n\r\n\t\t\t\t\t\t_vector3.copy( element.vertexNormalsModelView[ uv1 ] );\r\n\t\t\t\t\t\t_uv1x = 0.5 * _vector3.x + 0.5;\r\n\t\t\t\t\t\t_uv1y = 0.5 * _vector3.y + 0.5;\r\n\r\n\t\t\t\t\t\t_vector3.copy( element.vertexNormalsModelView[ uv2 ] );\r\n\t\t\t\t\t\t_uv2x = 0.5 * _vector3.x + 0.5;\r\n\t\t\t\t\t\t_uv2y = 0.5 * _vector3.y + 0.5;\r\n\r\n\t\t\t\t\t\t_vector3.copy( element.vertexNormalsModelView[ uv3 ] );\r\n\t\t\t\t\t\t_uv3x = 0.5 * _vector3.x + 0.5;\r\n\t\t\t\t\t\t_uv3y = 0.5 * _vector3.y + 0.5;\r\n\r\n\t\t\t\t\t\tpatternPath( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y, material.envMap );\r\n\r\n\t\t\t\t\t}/* else if ( material.envMap.mapping == THREE.SphericalRefractionMapping ) {\r\n\r\n\r\n\r\n\t\t\t\t\t}*/\r\n\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t_color.copy( material.color );\r\n\r\n\t\t\t\t\tif ( material.vertexColors === THREE.FaceColors ) {\r\n\r\n\t\t\t\t\t\t_color.multiply( element.color );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tmaterial.wireframe === true\r\n\t\t\t\t\t\t? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\r\n\t\t\t\t\t\t: fillPath( _color );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshDepthMaterial ) {\r\n\r\n\t\t\t\t_near = camera.near;\r\n\t\t\t\t_far = camera.far;\r\n\r\n\t\t\t\t_color1.r = _color1.g = _color1.b = 1 - smoothstep( v1.positionScreen.z * v1.positionScreen.w, _near, _far );\r\n\t\t\t\t_color2.r = _color2.g = _color2.b = 1 - smoothstep( v2.positionScreen.z * v2.positionScreen.w, _near, _far );\r\n\t\t\t\t_color3.r = _color3.g = _color3.b = 1 - smoothstep( v3.positionScreen.z * v3.positionScreen.w, _near, _far );\r\n\t\t\t\t_color4.addColors( _color2, _color3 ).multiplyScalar( 0.5 );\r\n\r\n\t\t\t\t_image = getGradientTexture( _color1, _color2, _color3, _color4 );\r\n\r\n\t\t\t\tclipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\r\n\r\n\t\t\t\tvar normal;\r\n\r\n\t\t\t\tif ( material.shading == THREE.FlatShading ) {\r\n\r\n\t\t\t\t\tnormal = element.normalModelView;\r\n\r\n\t\t\t\t\t_color.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\r\n\r\n\t\t\t\t\tmaterial.wireframe === true\r\n\t\t\t\t\t\t? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\r\n\t\t\t\t\t\t: fillPath( _color );\r\n\r\n\t\t\t\t} else if ( material.shading == THREE.SmoothShading ) {\r\n\r\n\t\t\t\t\tnormal = element.vertexNormalsModelView[ uv1 ];\r\n\t\t\t\t\t_color1.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\r\n\r\n\t\t\t\t\tnormal = element.vertexNormalsModelView[ uv2 ];\r\n\t\t\t\t\t_color2.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\r\n\r\n\t\t\t\t\tnormal = element.vertexNormalsModelView[ uv3 ];\r\n\t\t\t\t\t_color3.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\r\n\r\n\t\t\t\t\t_color4.addColors( _color2, _color3 ).multiplyScalar( 0.5 );\r\n\r\n\t\t\t\t\t_image = getGradientTexture( _color1, _color2, _color3, _color4 );\r\n\r\n\t\t\t\t\tclipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction renderFace4( v1, v2, v3, v4, v5, v6, element, material ) {\r\n\r\n\t\t\t_this.info.render.vertices += 4;\r\n\t\t\t_this.info.render.faces ++;\r\n\r\n\t\t\tsetOpacity( material.opacity );\r\n\t\t\tsetBlending( material.blending );\r\n\r\n\t\t\tif ( ( material.map !== undefined && material.map !== null ) || ( material.envMap !== undefined && material.envMap !== null ) ) {\r\n\r\n\t\t\t\t// Let renderFace3() handle this\r\n\r\n\t\t\t\trenderFace3( v1, v2, v4, 0, 1, 3, element, material );\r\n\t\t\t\trenderFace3( v5, v3, v6, 1, 2, 3, element, material );\r\n\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_v1x = v1.positionScreen.x; _v1y = v1.positionScreen.y;\r\n\t\t\t_v2x = v2.positionScreen.x; _v2y = v2.positionScreen.y;\r\n\t\t\t_v3x = v3.positionScreen.x; _v3y = v3.positionScreen.y;\r\n\t\t\t_v4x = v4.positionScreen.x; _v4y = v4.positionScreen.y;\r\n\t\t\t_v5x = v5.positionScreen.x; _v5y = v5.positionScreen.y;\r\n\t\t\t_v6x = v6.positionScreen.x; _v6y = v6.positionScreen.y;\r\n\r\n\t\t\tif ( material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial ) {\r\n\r\n\t\t\t\t_diffuseColor.copy( material.color );\r\n\t\t\t\t_emissiveColor.copy( material.emissive );\r\n\r\n\t\t\t\tif ( material.vertexColors === THREE.FaceColors ) {\r\n\r\n\t\t\t\t\t_diffuseColor.multiply( element.color );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( _enableLighting === true ) {\r\n\r\n\t\t\t\t\tif ( material.wireframe === false && material.shading == THREE.SmoothShading && element.vertexNormalsLength == 4 ) {\r\n\r\n\t\t\t\t\t\t_color1.copy( _ambientLight );\r\n\t\t\t\t\t\t_color2.copy( _ambientLight );\r\n\t\t\t\t\t\t_color3.copy( _ambientLight );\r\n\t\t\t\t\t\t_color4.copy( _ambientLight );\r\n\r\n\t\t\t\t\t\tcalculateLight( element.v1.positionWorld, element.vertexNormalsModel[ 0 ], _color1 );\r\n\t\t\t\t\t\tcalculateLight( element.v2.positionWorld, element.vertexNormalsModel[ 1 ], _color2 );\r\n\t\t\t\t\t\tcalculateLight( element.v4.positionWorld, element.vertexNormalsModel[ 3 ], _color3 );\r\n\t\t\t\t\t\tcalculateLight( element.v3.positionWorld, element.vertexNormalsModel[ 2 ], _color4 );\r\n\r\n\t\t\t\t\t\t_color1.multiply( _diffuseColor ).add( _emissiveColor );\r\n\t\t\t\t\t\t_color2.multiply( _diffuseColor ).add( _emissiveColor );\r\n\t\t\t\t\t\t_color3.multiply( _diffuseColor ).add( _emissiveColor );\r\n\t\t\t\t\t\t_color4.multiply( _diffuseColor ).add( _emissiveColor );\r\n\r\n\t\t\t\t\t\t_image = getGradientTexture( _color1, _color2, _color3, _color4 );\r\n\r\n\t\t\t\t\t\t// TODO: UVs are incorrect, v4->v3?\r\n\r\n\t\t\t\t\t\tdrawTriangle( _v1x, _v1y, _v2x, _v2y, _v4x, _v4y );\r\n\t\t\t\t\t\tclipImage( _v1x, _v1y, _v2x, _v2y, _v4x, _v4y, 0, 0, 1, 0, 0, 1, _image );\r\n\r\n\t\t\t\t\t\tdrawTriangle( _v5x, _v5y, _v3x, _v3y, _v6x, _v6y );\r\n\t\t\t\t\t\tclipImage( _v5x, _v5y, _v3x, _v3y, _v6x, _v6y, 1, 0, 1, 1, 0, 1, _image );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t_color.copy( _ambientLight );\r\n\r\n\t\t\t\t\t\tcalculateLight( element.centroidModel, element.normalModel, _color );\r\n\r\n\t\t\t\t\t\t_color.multiply( _diffuseColor ).add( _emissiveColor );\r\n\r\n\t\t\t\t\t\tdrawQuad( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _v4x, _v4y );\r\n\r\n\t\t\t\t\t\tmaterial.wireframe === true\r\n\t\t\t\t\t\t\t? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\r\n\t\t\t\t\t\t\t: fillPath( _color );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t_color.addColors( _diffuseColor, _emissiveColor );\r\n\r\n\t\t\t\t\tdrawQuad( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _v4x, _v4y );\r\n\r\n\t\t\t\t\tmaterial.wireframe === true\r\n\t\t\t\t\t\t? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\r\n\t\t\t\t\t\t: fillPath( _color );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshBasicMaterial ) {\r\n\r\n\t\t\t\t_color.copy( material.color );\r\n\r\n\t\t\t\tif ( material.vertexColors === THREE.FaceColors ) {\r\n\r\n\t\t\t\t\t_color.multiply( element.color );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdrawQuad( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _v4x, _v4y );\r\n\r\n\t\t\t\tmaterial.wireframe === true\r\n\t\t\t\t\t? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\r\n\t\t\t\t\t: fillPath( _color );\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\r\n\r\n\t\t\t\tvar normal;\r\n\r\n\t\t\t\tif ( material.shading == THREE.FlatShading ) {\r\n\r\n\t\t\t\t\tnormal = element.normalModelView;\r\n\t\t\t\t\t_color.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\r\n\r\n\t\t\t\t\tdrawQuad( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _v4x, _v4y );\r\n\r\n\t\t\t\t\tmaterial.wireframe === true\r\n\t\t\t\t\t\t? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\r\n\t\t\t\t\t\t: fillPath( _color );\r\n\r\n\t\t\t\t} else if ( material.shading == THREE.SmoothShading ) {\r\n\r\n\t\t\t\t\tnormal = element.vertexNormalsModelView[ 0 ];\r\n\t\t\t\t\t_color1.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\r\n\r\n\t\t\t\t\tnormal = element.vertexNormalsModelView[ 1 ];\r\n\t\t\t\t\t_color2.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\r\n\r\n\t\t\t\t\tnormal = element.vertexNormalsModelView[ 3 ];\r\n\t\t\t\t\t_color3.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\r\n\r\n\t\t\t\t\tnormal = element.vertexNormalsModelView[ 2 ];\r\n\t\t\t\t\t_color4.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\r\n\r\n\t\t\t\t\t_image = getGradientTexture( _color1, _color2, _color3, _color4 );\r\n\r\n\t\t\t\t\tdrawTriangle( _v1x, _v1y, _v2x, _v2y, _v4x, _v4y );\r\n\t\t\t\t\tclipImage( _v1x, _v1y, _v2x, _v2y, _v4x, _v4y, 0, 0, 1, 0, 0, 1, _image );\r\n\r\n\t\t\t\t\tdrawTriangle( _v5x, _v5y, _v3x, _v3y, _v6x, _v6y );\r\n\t\t\t\t\tclipImage( _v5x, _v5y, _v3x, _v3y, _v6x, _v6y, 1, 0, 1, 1, 0, 1, _image );\r\n\r\n\t\t\t\t}\r\n\r\n\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshDepthMaterial ) {\r\n\r\n\t\t\t\t_near = camera.near;\r\n\t\t\t\t_far = camera.far;\r\n\r\n\t\t\t\t_color1.r = _color1.g = _color1.b = 1 - smoothstep( v1.positionScreen.z * v1.positionScreen.w, _near, _far );\r\n\t\t\t\t_color2.r = _color2.g = _color2.b = 1 - smoothstep( v2.positionScreen.z * v2.positionScreen.w, _near, _far );\r\n\t\t\t\t_color3.r = _color3.g = _color3.b = 1 - smoothstep( v4.positionScreen.z * v4.positionScreen.w, _near, _far );\r\n\t\t\t\t_color4.r = _color4.g = _color4.b = 1 - smoothstep( v3.positionScreen.z * v3.positionScreen.w, _near, _far );\r\n\r\n\t\t\t\t_image = getGradientTexture( _color1, _color2, _color3, _color4 );\r\n\r\n\t\t\t\t// TODO: UVs are incorrect, v4->v3?\r\n\r\n\t\t\t\tdrawTriangle( _v1x, _v1y, _v2x, _v2y, _v4x, _v4y );\r\n\t\t\t\tclipImage( _v1x, _v1y, _v2x, _v2y, _v4x, _v4y, 0, 0, 1, 0, 0, 1, _image );\r\n\r\n\t\t\t\tdrawTriangle( _v5x, _v5y, _v3x, _v3y, _v6x, _v6y );\r\n\t\t\t\tclipImage( _v5x, _v5y, _v3x, _v3y, _v6x, _v6y, 1, 0, 1, 1, 0, 1, _image );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tfunction drawTriangle( x0, y0, x1, y1, x2, y2 ) {\r\n\r\n\t\t\t_context.beginPath();\r\n\t\t\t_context.moveTo( x0, y0 );\r\n\t\t\t_context.lineTo( x1, y1 );\r\n\t\t\t_context.lineTo( x2, y2 );\r\n\t\t\t_context.closePath();\r\n\r\n\t\t}\r\n\r\n\t\tfunction drawQuad( x0, y0, x1, y1, x2, y2, x3, y3 ) {\r\n\r\n\t\t\t_context.beginPath();\r\n\t\t\t_context.moveTo( x0, y0 );\r\n\t\t\t_context.lineTo( x1, y1 );\r\n\t\t\t_context.lineTo( x2, y2 );\r\n\t\t\t_context.lineTo( x3, y3 );\r\n\t\t\t_context.closePath();\r\n\r\n\t\t}\r\n\r\n\t\tfunction strokePath( color, linewidth, linecap, linejoin ) {\r\n\r\n\t\t\tsetLineWidth( linewidth );\r\n\t\t\tsetLineCap( linecap );\r\n\t\t\tsetLineJoin( linejoin );\r\n\t\t\tsetStrokeStyle( color.getStyle() );\r\n\r\n\t\t\t_context.stroke();\r\n\r\n\t\t\t_elemBox.expandByScalar( linewidth * 2 );\r\n\r\n\t\t}\r\n\r\n\t\tfunction fillPath( color ) {\r\n\r\n\t\t\tsetFillStyle( color.getStyle() );\r\n\t\t\t_context.fill();\r\n\r\n\t\t}\r\n\r\n\t\tfunction patternPath( x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, texture ) {\r\n\r\n\t\t\tif ( texture instanceof THREE.DataTexture || texture.image === undefined || texture.image.width == 0 ) return;\r\n\r\n\t\t\tif ( texture.needsUpdate === true ) {\r\n\r\n\t\t\t\tvar repeatX = texture.wrapS == THREE.RepeatWrapping;\r\n\t\t\t\tvar repeatY = texture.wrapT == THREE.RepeatWrapping;\r\n\r\n\t\t\t\t_patterns[ texture.id ] = _context.createPattern(\r\n\t\t\t\t\ttexture.image, repeatX === true && repeatY === true\r\n\t\t\t\t\t\t? 'repeat'\r\n\t\t\t\t\t\t: repeatX === true && repeatY === false\r\n\t\t\t\t\t\t\t? 'repeat-x'\r\n\t\t\t\t\t\t\t: repeatX === false && repeatY === true\r\n\t\t\t\t\t\t\t\t? 'repeat-y'\r\n\t\t\t\t\t\t\t\t: 'no-repeat'\r\n\t\t\t\t);\r\n\r\n\t\t\t\ttexture.needsUpdate = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_patterns[ texture.id ] === undefined\r\n\t\t\t\t? setFillStyle( 'rgba(0,0,0,1)' )\r\n\t\t\t\t: setFillStyle( _patterns[ texture.id ] );\r\n\r\n\t\t\t// http://extremelysatisfactorytotalitarianism.com/blog/?p=2120\r\n\r\n\t\t\tvar a, b, c, d, e, f, det, idet,\r\n\t\t\toffsetX = texture.offset.x / texture.repeat.x,\r\n\t\t\toffsetY = texture.offset.y / texture.repeat.y,\r\n\t\t\twidth = texture.image.width * texture.repeat.x,\r\n\t\t\theight = texture.image.height * texture.repeat.y;\r\n\r\n\t\t\tu0 = ( u0 + offsetX ) * width;\r\n\t\t\tv0 = ( 1.0 - v0 + offsetY ) * height;\r\n\r\n\t\t\tu1 = ( u1 + offsetX ) * width;\r\n\t\t\tv1 = ( 1.0 - v1 + offsetY ) * height;\r\n\r\n\t\t\tu2 = ( u2 + offsetX ) * width;\r\n\t\t\tv2 = ( 1.0 - v2 + offsetY ) * height;\r\n\r\n\t\t\tx1 -= x0; y1 -= y0;\r\n\t\t\tx2 -= x0; y2 -= y0;\r\n\r\n\t\t\tu1 -= u0; v1 -= v0;\r\n\t\t\tu2 -= u0; v2 -= v0;\r\n\r\n\t\t\tdet = u1 * v2 - u2 * v1;\r\n\r\n\t\t\tif ( det === 0 ) {\r\n\r\n\t\t\t\tif ( _imagedatas[ texture.id ] === undefined ) {\r\n\r\n\t\t\t\t\tvar canvas = document.createElement( 'canvas' )\r\n\t\t\t\t\tcanvas.width = texture.image.width;\r\n\t\t\t\t\tcanvas.height = texture.image.height;\r\n\r\n\t\t\t\t\tvar context = canvas.getContext( '2d' );\r\n\t\t\t\t\tcontext.drawImage( texture.image, 0, 0 );\r\n\r\n\t\t\t\t\t_imagedatas[ texture.id ] = context.getImageData( 0, 0, texture.image.width, texture.image.height ).data;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar data = _imagedatas[ texture.id ];\r\n\t\t\t\tvar index = ( Math.floor( u0 ) + Math.floor( v0 ) * texture.image.width ) * 4;\r\n\r\n\t\t\t\t_color.setRGB( data[ index ] / 255, data[ index + 1 ] / 255, data[ index + 2 ] / 255 );\r\n\t\t\t\tfillPath( _color );\r\n\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tidet = 1 / det;\r\n\r\n\t\t\ta = ( v2 * x1 - v1 * x2 ) * idet;\r\n\t\t\tb = ( v2 * y1 - v1 * y2 ) * idet;\r\n\t\t\tc = ( u1 * x2 - u2 * x1 ) * idet;\r\n\t\t\td = ( u1 * y2 - u2 * y1 ) * idet;\r\n\r\n\t\t\te = x0 - a * u0 - c * v0;\r\n\t\t\tf = y0 - b * u0 - d * v0;\r\n\r\n\t\t\t_context.save();\r\n\t\t\t_context.transform( a, b, c, d, e, f );\r\n\t\t\t_context.fill();\r\n\t\t\t_context.restore();\r\n\r\n\t\t}\r\n\r\n\t\tfunction clipImage( x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, image ) {\r\n\r\n\t\t\t// http://extremelysatisfactorytotalitarianism.com/blog/?p=2120\r\n\r\n\t\t\tvar a, b, c, d, e, f, det, idet,\r\n\t\t\twidth = image.width - 1,\r\n\t\t\theight = image.height - 1;\r\n\r\n\t\t\tu0 *= width; v0 *= height;\r\n\t\t\tu1 *= width; v1 *= height;\r\n\t\t\tu2 *= width; v2 *= height;\r\n\r\n\t\t\tx1 -= x0; y1 -= y0;\r\n\t\t\tx2 -= x0; y2 -= y0;\r\n\r\n\t\t\tu1 -= u0; v1 -= v0;\r\n\t\t\tu2 -= u0; v2 -= v0;\r\n\r\n\t\t\tdet = u1 * v2 - u2 * v1;\r\n\r\n\t\t\tidet = 1 / det;\r\n\r\n\t\t\ta = ( v2 * x1 - v1 * x2 ) * idet;\r\n\t\t\tb = ( v2 * y1 - v1 * y2 ) * idet;\r\n\t\t\tc = ( u1 * x2 - u2 * x1 ) * idet;\r\n\t\t\td = ( u1 * y2 - u2 * y1 ) * idet;\r\n\r\n\t\t\te = x0 - a * u0 - c * v0;\r\n\t\t\tf = y0 - b * u0 - d * v0;\r\n\r\n\t\t\t_context.save();\r\n\t\t\t_context.transform( a, b, c, d, e, f );\r\n\t\t\t_context.clip();\r\n\t\t\t_context.drawImage( image, 0, 0 );\r\n\t\t\t_context.restore();\r\n\r\n\t\t}\r\n\r\n\t\tfunction getGradientTexture( color1, color2, color3, color4 ) {\r\n\r\n\t\t\t// http://mrdoob.com/blog/post/710\r\n\r\n\t\t\t_pixelMapData[ 0 ] = ( color1.r * 255 ) | 0;\r\n\t\t\t_pixelMapData[ 1 ] = ( color1.g * 255 ) | 0;\r\n\t\t\t_pixelMapData[ 2 ] = ( color1.b * 255 ) | 0;\r\n\r\n\t\t\t_pixelMapData[ 4 ] = ( color2.r * 255 ) | 0;\r\n\t\t\t_pixelMapData[ 5 ] = ( color2.g * 255 ) | 0;\r\n\t\t\t_pixelMapData[ 6 ] = ( color2.b * 255 ) | 0;\r\n\r\n\t\t\t_pixelMapData[ 8 ] = ( color3.r * 255 ) | 0;\r\n\t\t\t_pixelMapData[ 9 ] = ( color3.g * 255 ) | 0;\r\n\t\t\t_pixelMapData[ 10 ] = ( color3.b * 255 ) | 0;\r\n\r\n\t\t\t_pixelMapData[ 12 ] = ( color4.r * 255 ) | 0;\r\n\t\t\t_pixelMapData[ 13 ] = ( color4.g * 255 ) | 0;\r\n\t\t\t_pixelMapData[ 14 ] = ( color4.b * 255 ) | 0;\r\n\r\n\t\t\t_pixelMapContext.putImageData( _pixelMapImage, 0, 0 );\r\n\t\t\t_gradientMapContext.drawImage( _pixelMap, 0, 0 );\r\n\r\n\t\t\treturn _gradientMap;\r\n\r\n\t\t}\r\n\r\n\t\t// Hide anti-alias gaps\r\n\r\n\t\tfunction expand( v1, v2 ) {\r\n\r\n\t\t\tvar x = v2.x - v1.x, y =  v2.y - v1.y,\r\n\t\t\tdet = x * x + y * y, idet;\r\n\r\n\t\t\tif ( det === 0 ) return;\r\n\r\n\t\t\tidet = 1 / Math.sqrt( det );\r\n\r\n\t\t\tx *= idet; y *= idet;\r\n\r\n\t\t\tv2.x += x; v2.y += y;\r\n\t\t\tv1.x -= x; v1.y -= y;\r\n\r\n\t\t}\r\n\t};\r\n\r\n\t// Context cached methods.\r\n\r\n\tfunction setOpacity( value ) {\r\n\r\n\t\tif ( _contextGlobalAlpha !== value ) {\r\n\r\n\t\t\t_context.globalAlpha = value;\r\n\t\t\t_contextGlobalAlpha = value;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setBlending( value ) {\r\n\r\n\t\tif ( _contextGlobalCompositeOperation !== value ) {\r\n\r\n\t\t\tif ( value === THREE.NormalBlending ) {\r\n\r\n\t\t\t\t_context.globalCompositeOperation = 'source-over';\r\n\r\n\t\t\t} else if ( value === THREE.AdditiveBlending ) {\r\n\r\n\t\t\t\t_context.globalCompositeOperation = 'lighter';\r\n\r\n\t\t\t} else if ( value === THREE.SubtractiveBlending ) {\r\n\r\n\t\t\t\t_context.globalCompositeOperation = 'darker';\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_contextGlobalCompositeOperation = value;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setLineWidth( value ) {\r\n\r\n\t\tif ( _contextLineWidth !== value ) {\r\n\r\n\t\t\t_context.lineWidth = value;\r\n\t\t\t_contextLineWidth = value;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setLineCap( value ) {\r\n\r\n\t\t// \"butt\", \"round\", \"square\"\r\n\r\n\t\tif ( _contextLineCap !== value ) {\r\n\r\n\t\t\t_context.lineCap = value;\r\n\t\t\t_contextLineCap = value;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setLineJoin( value ) {\r\n\r\n\t\t// \"round\", \"bevel\", \"miter\"\r\n\r\n\t\tif ( _contextLineJoin !== value ) {\r\n\r\n\t\t\t_context.lineJoin = value;\r\n\t\t\t_contextLineJoin = value;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setStrokeStyle( value ) {\r\n\r\n\t\tif ( _contextStrokeStyle !== value ) {\r\n\r\n\t\t\t_context.strokeStyle = value;\r\n\t\t\t_contextStrokeStyle = value;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setFillStyle( value ) {\r\n\r\n\t\tif ( _contextFillStyle !== value ) {\r\n\r\n\t\t\t_context.fillStyle = value;\r\n\t\t\t_contextFillStyle = value;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setDashAndGap( dashSizeValue, gapSizeValue ) {\r\n\r\n\t\tif ( _contextDashSize !== dashSizeValue || _contextGapSize !== gapSizeValue ) {\r\n\r\n\t\t\t_context.setLineDash( [ dashSizeValue, gapSizeValue ] );\r\n\t\t\t_contextDashSize = dashSizeValue;\r\n\t\t\t_contextGapSize = gapSizeValue;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n */\r\n\r\nTHREE.ShaderChunk = {\r\n\r\n\t// FOG\r\n\r\n\tfog_pars_fragment: [\r\n\r\n\t\t\"#ifdef USE_FOG\",\r\n\r\n\t\t\t\"uniform vec3 fogColor;\",\r\n\r\n\t\t\t\"#ifdef FOG_EXP2\",\r\n\r\n\t\t\t\t\"uniform float fogDensity;\",\r\n\r\n\t\t\t\"#else\",\r\n\r\n\t\t\t\t\"uniform float fogNear;\",\r\n\t\t\t\t\"uniform float fogFar;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tfog_fragment: [\r\n\r\n\t\t\"#ifdef USE_FOG\",\r\n\r\n\t\t\t\"float depth = gl_FragCoord.z / gl_FragCoord.w;\",\r\n\r\n\t\t\t\"#ifdef FOG_EXP2\",\r\n\r\n\t\t\t\t\"const float LOG2 = 1.442695;\",\r\n\t\t\t\t\"float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\",\r\n\t\t\t\t\"fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\",\r\n\r\n\t\t\t\"#else\",\r\n\r\n\t\t\t\t\"float fogFactor = smoothstep( fogNear, fogFar, depth );\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// ENVIRONMENT MAP\r\n\r\n\tenvmap_pars_fragment: [\r\n\r\n\t\t\"#ifdef USE_ENVMAP\",\r\n\r\n\t\t\t\"uniform float reflectivity;\",\r\n\t\t\t\"uniform samplerCube envMap;\",\r\n\t\t\t\"uniform float flipEnvMap;\",\r\n\t\t\t\"uniform int combine;\",\r\n\r\n\t\t\t\"#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\",\r\n\r\n\t\t\t\t\"uniform bool useRefract;\",\r\n\t\t\t\t\"uniform float refractionRatio;\",\r\n\r\n\t\t\t\"#else\",\r\n\r\n\t\t\t\t\"varying vec3 vReflect;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tenvmap_fragment: [\r\n\r\n\t\t\"#ifdef USE_ENVMAP\",\r\n\r\n\t\t\t\"vec3 reflectVec;\",\r\n\r\n\t\t\t\"#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\",\r\n\r\n\t\t\t\t\"vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\",\r\n\r\n\t\t\t\t\"if ( useRefract ) {\",\r\n\r\n\t\t\t\t\t\"reflectVec = refract( cameraToVertex, normal, refractionRatio );\",\r\n\r\n\t\t\t\t\"} else { \",\r\n\r\n\t\t\t\t\t\"reflectVec = reflect( cameraToVertex, normal );\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\"#else\",\r\n\r\n\t\t\t\t\"reflectVec = vReflect;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\"float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\",\r\n\t\t\t\t\"vec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\",\r\n\r\n\t\t\t\"#else\",\r\n\r\n\t\t\t\t\"vec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#ifdef GAMMA_INPUT\",\r\n\r\n\t\t\t\t\"cubeColor.xyz *= cubeColor.xyz;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"if ( combine == 1 ) {\",\r\n\r\n\t\t\t\t\"gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );\",\r\n\r\n\t\t\t\"} else if ( combine == 2 ) {\",\r\n\r\n\t\t\t\t\"gl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;\",\r\n\r\n\t\t\t\"} else {\",\r\n\r\n\t\t\t\t\"gl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tenvmap_pars_vertex: [\r\n\r\n\t\t\"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\",\r\n\r\n\t\t\t\"varying vec3 vReflect;\",\r\n\r\n\t\t\t\"uniform float refractionRatio;\",\r\n\t\t\t\"uniform bool useRefract;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tworldpos_vertex : [\r\n\r\n\t\t\"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\",\r\n\r\n\t\t\t\"#ifdef USE_SKINNING\",\r\n\r\n\t\t\t\t\"vec4 worldPosition = modelMatrix * skinned;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\",\r\n\r\n\t\t\t\t\"vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\",\r\n\r\n\t\t\t\t\"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tenvmap_vertex : [\r\n\r\n\t\t\"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\",\r\n\r\n\t\t\t\"vec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;\",\r\n\t\t\t\"worldNormal = normalize( worldNormal );\",\r\n\r\n\t\t\t\"vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\",\r\n\r\n\t\t\t\"if ( useRefract ) {\",\r\n\r\n\t\t\t\t\"vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\",\r\n\r\n\t\t\t\"} else {\",\r\n\r\n\t\t\t\t\"vReflect = reflect( cameraToVertex, worldNormal );\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// COLOR MAP (particles)\r\n\r\n\tmap_particle_pars_fragment: [\r\n\r\n\t\t\"#ifdef USE_MAP\",\r\n\r\n\t\t\t\"uniform sampler2D map;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\r\n\tmap_particle_fragment: [\r\n\r\n\t\t\"#ifdef USE_MAP\",\r\n\r\n\t\t\t\"gl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// COLOR MAP (triangles)\r\n\r\n\tmap_pars_vertex: [\r\n\r\n\t\t\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\",\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\t\t\t\"uniform vec4 offsetRepeat;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tmap_pars_fragment: [\r\n\r\n\t\t\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\",\r\n\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#ifdef USE_MAP\",\r\n\r\n\t\t\t\"uniform sampler2D map;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tmap_vertex: [\r\n\r\n\t\t\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\",\r\n\r\n\t\t\t\"vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tmap_fragment: [\r\n\r\n\t\t\"#ifdef USE_MAP\",\r\n\r\n\t\t\t\"vec4 texelColor = texture2D( map, vUv );\",\r\n\r\n\t\t\t\"#ifdef GAMMA_INPUT\",\r\n\r\n\t\t\t\t\"texelColor.xyz *= texelColor.xyz;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"gl_FragColor = gl_FragColor * texelColor;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// LIGHT MAP\r\n\r\n\tlightmap_pars_fragment: [\r\n\r\n\t\t\"#ifdef USE_LIGHTMAP\",\r\n\r\n\t\t\t\"varying vec2 vUv2;\",\r\n\t\t\t\"uniform sampler2D lightMap;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tlightmap_pars_vertex: [\r\n\r\n\t\t\"#ifdef USE_LIGHTMAP\",\r\n\r\n\t\t\t\"varying vec2 vUv2;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tlightmap_fragment: [\r\n\r\n\t\t\"#ifdef USE_LIGHTMAP\",\r\n\r\n\t\t\t\"gl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tlightmap_vertex: [\r\n\r\n\t\t\"#ifdef USE_LIGHTMAP\",\r\n\r\n\t\t\t\"vUv2 = uv2;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// BUMP MAP\r\n\r\n\tbumpmap_pars_fragment: [\r\n\r\n\t\t\"#ifdef USE_BUMPMAP\",\r\n\r\n\t\t\t\"uniform sampler2D bumpMap;\",\r\n\t\t\t\"uniform float bumpScale;\",\r\n\r\n\t\t\t// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\r\n\t\t\t//\thttp://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\r\n\r\n\t\t\t// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\r\n\r\n\t\t\t\"vec2 dHdxy_fwd() {\",\r\n\r\n\t\t\t\t\"vec2 dSTdx = dFdx( vUv );\",\r\n\t\t\t\t\"vec2 dSTdy = dFdy( vUv );\",\r\n\r\n\t\t\t\t\"float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\",\r\n\t\t\t\t\"float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\",\r\n\t\t\t\t\"float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\",\r\n\r\n\t\t\t\t\"return vec2( dBx, dBy );\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\",\r\n\r\n\t\t\t\t\"vec3 vSigmaX = dFdx( surf_pos );\",\r\n\t\t\t\t\"vec3 vSigmaY = dFdy( surf_pos );\",\r\n\t\t\t\t\"vec3 vN = surf_norm;\",\t\t// normalized\r\n\r\n\t\t\t\t\"vec3 R1 = cross( vSigmaY, vN );\",\r\n\t\t\t\t\"vec3 R2 = cross( vN, vSigmaX );\",\r\n\r\n\t\t\t\t\"float fDet = dot( vSigmaX, R1 );\",\r\n\r\n\t\t\t\t\"vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\",\r\n\t\t\t\t\"return normalize( abs( fDet ) * surf_norm - vGrad );\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// NORMAL MAP\r\n\r\n\tnormalmap_pars_fragment: [\r\n\r\n\t\t\"#ifdef USE_NORMALMAP\",\r\n\r\n\t\t\t\"uniform sampler2D normalMap;\",\r\n\t\t\t\"uniform vec2 normalScale;\",\r\n\r\n\t\t\t// Per-Pixel Tangent Space Normal Mapping\r\n\t\t\t// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\r\n\r\n\t\t\t\"vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\",\r\n\r\n\t\t\t\t\"vec3 q0 = dFdx( eye_pos.xyz );\",\r\n\t\t\t\t\"vec3 q1 = dFdy( eye_pos.xyz );\",\r\n\t\t\t\t\"vec2 st0 = dFdx( vUv.st );\",\r\n\t\t\t\t\"vec2 st1 = dFdy( vUv.st );\",\r\n\r\n\t\t\t\t\"vec3 S = normalize(  q0 * st1.t - q1 * st0.t );\",\r\n\t\t\t\t\"vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\",\r\n\t\t\t\t\"vec3 N = normalize( surf_norm );\",\r\n\r\n\t\t\t\t\"vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\",\r\n\t\t\t\t\"mapN.xy = normalScale * mapN.xy;\",\r\n\t\t\t\t\"mat3 tsn = mat3( S, T, N );\",\r\n\t\t\t\t\"return normalize( tsn * mapN );\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// SPECULAR MAP\r\n\r\n\tspecularmap_pars_fragment: [\r\n\r\n\t\t\"#ifdef USE_SPECULARMAP\",\r\n\r\n\t\t\t\"uniform sampler2D specularMap;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tspecularmap_fragment: [\r\n\r\n\t\t\"float specularStrength;\",\r\n\r\n\t\t\"#ifdef USE_SPECULARMAP\",\r\n\r\n\t\t\t\"vec4 texelSpecular = texture2D( specularMap, vUv );\",\r\n\t\t\t\"specularStrength = texelSpecular.r;\",\r\n\r\n\t\t\"#else\",\r\n\r\n\t\t\t\"specularStrength = 1.0;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// LIGHTS LAMBERT\r\n\r\n\tlights_lambert_pars_vertex: [\r\n\r\n\t\t\"uniform vec3 ambient;\",\r\n\t\t\"uniform vec3 diffuse;\",\r\n\t\t\"uniform vec3 emissive;\",\r\n\r\n\t\t\"uniform vec3 ambientLightColor;\",\r\n\r\n\t\t\"#if MAX_DIR_LIGHTS > 0\",\r\n\r\n\t\t\t\"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_HEMI_LIGHTS > 0\",\r\n\r\n\t\t\t\"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\r\n\r\n\t\t\t\"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\",\r\n\t\t\t\"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\r\n\r\n\t\t\t\"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\"uniform vec3 wrapRGB;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tlights_lambert_vertex: [\r\n\r\n\t\t\"vLightFront = vec3( 0.0 );\",\r\n\r\n\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\"vLightBack = vec3( 0.0 );\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"transformedNormal = normalize( transformedNormal );\",\r\n\r\n\t\t\"#if MAX_DIR_LIGHTS > 0\",\r\n\r\n\t\t\"for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\",\r\n\t\t\t\"vec3 dirVector = normalize( lDirection.xyz );\",\r\n\r\n\t\t\t\"float dotProduct = dot( transformedNormal, dirVector );\",\r\n\t\t\t\"vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\",\r\n\r\n\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\"vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\",\r\n\r\n\t\t\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\t\t\"vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\t\"vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\",\r\n\t\t\t\t\"directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\",\r\n\r\n\t\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\t\"directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"vLightFront += directionalLightColor[ i ] * directionalLightWeighting;\",\r\n\r\n\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\"vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\"}\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\r\n\r\n\t\t\t\"for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\",\r\n\t\t\t\t\"vec3 lVector = lPosition.xyz - mvPosition.xyz;\",\r\n\r\n\t\t\t\t\"float lDistance = 1.0;\",\r\n\t\t\t\t\"if ( pointLightDistance[ i ] > 0.0 )\",\r\n\t\t\t\t\t\"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\",\r\n\r\n\t\t\t\t\"lVector = normalize( lVector );\",\r\n\t\t\t\t\"float dotProduct = dot( transformedNormal, lVector );\",\r\n\r\n\t\t\t\t\"vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\",\r\n\r\n\t\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\t\"vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\",\r\n\r\n\t\t\t\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\t\t\t\"vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\t\t\"vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\",\r\n\t\t\t\t\t\"pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\",\r\n\r\n\t\t\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\t\t\"pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;\",\r\n\r\n\t\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\t\"vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\r\n\r\n\t\t\t\"for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\",\r\n\t\t\t\t\"vec3 lVector = lPosition.xyz - mvPosition.xyz;\",\r\n\r\n\t\t\t\t\"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\",\r\n\r\n\t\t\t\t\"if ( spotEffect > spotLightAngleCos[ i ] ) {\",\r\n\r\n\t\t\t\t\t\"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\",\r\n\r\n\t\t\t\t\t\"float lDistance = 1.0;\",\r\n\t\t\t\t\t\"if ( spotLightDistance[ i ] > 0.0 )\",\r\n\t\t\t\t\t\t\"lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\",\r\n\r\n\t\t\t\t\t\"lVector = normalize( lVector );\",\r\n\r\n\t\t\t\t\t\"float dotProduct = dot( transformedNormal, lVector );\",\r\n\t\t\t\t\t\"vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\",\r\n\r\n\t\t\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\t\t\"vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\",\r\n\r\n\t\t\t\t\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\t\t\t\t\"vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\",\r\n\r\n\t\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\t\t\t\"vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\",\r\n\t\t\t\t\t\t\"spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\",\r\n\r\n\t\t\t\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\t\t\t\"spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\",\r\n\r\n\t\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\t\"vLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;\",\r\n\r\n\t\t\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\t\t\"vLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_HEMI_LIGHTS > 0\",\r\n\r\n\t\t\t\"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\",\r\n\t\t\t\t\"vec3 lVector = normalize( lDirection.xyz );\",\r\n\r\n\t\t\t\t\"float dotProduct = dot( transformedNormal, lVector );\",\r\n\r\n\t\t\t\t\"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\",\r\n\t\t\t\t\"float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\",\r\n\r\n\t\t\t\t\"vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\",\r\n\r\n\t\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\t\"vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"vLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;\",\r\n\r\n\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\"vLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// LIGHTS PHONG\r\n\r\n\tlights_phong_pars_vertex: [\r\n\r\n\t\t\"#ifndef PHONG_PER_PIXEL\",\r\n\r\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\r\n\r\n\t\t\t\"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\",\r\n\t\t\t\"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\",\r\n\r\n\t\t\t\"varying vec4 vPointLight[ MAX_POINT_LIGHTS ];\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\r\n\r\n\t\t\t\"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\",\r\n\r\n\t\t\t\"varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\",\r\n\r\n\t\t\t\"varying vec3 vWorldPosition;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\r\n\tlights_phong_vertex: [\r\n\r\n\t\t\"#ifndef PHONG_PER_PIXEL\",\r\n\r\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\r\n\r\n\t\t\t\"for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\",\r\n\t\t\t\t\"vec3 lVector = lPosition.xyz - mvPosition.xyz;\",\r\n\r\n\t\t\t\t\"float lDistance = 1.0;\",\r\n\t\t\t\t\"if ( pointLightDistance[ i ] > 0.0 )\",\r\n\t\t\t\t\t\"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\",\r\n\r\n\t\t\t\t\"vPointLight[ i ] = vec4( lVector, lDistance );\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\r\n\r\n\t\t\t\"for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\",\r\n\t\t\t\t\"vec3 lVector = lPosition.xyz - mvPosition.xyz;\",\r\n\r\n\t\t\t\t\"float lDistance = 1.0;\",\r\n\t\t\t\t\"if ( spotLightDistance[ i ] > 0.0 )\",\r\n\t\t\t\t\t\"lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\",\r\n\r\n\t\t\t\t\"vSpotLight[ i ] = vec4( lVector, lDistance );\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\",\r\n\r\n\t\t\t\"vWorldPosition = worldPosition.xyz;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tlights_phong_pars_fragment: [\r\n\r\n\t\t\"uniform vec3 ambientLightColor;\",\r\n\r\n\t\t\"#if MAX_DIR_LIGHTS > 0\",\r\n\r\n\t\t\t\"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_HEMI_LIGHTS > 0\",\r\n\r\n\t\t\t\"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\r\n\r\n\t\t\t\"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\",\r\n\r\n\t\t\t\"#ifdef PHONG_PER_PIXEL\",\r\n\r\n\t\t\t\t\"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\",\r\n\t\t\t\t\"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\",\r\n\r\n\t\t\t\"#else\",\r\n\r\n\t\t\t\t\"varying vec4 vPointLight[ MAX_POINT_LIGHTS ];\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\r\n\r\n\t\t\t\"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\",\r\n\r\n\t\t\t\"#ifdef PHONG_PER_PIXEL\",\r\n\r\n\t\t\t\t\"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\",\r\n\r\n\t\t\t\"#else\",\r\n\r\n\t\t\t\t\"varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\",\r\n\r\n\t\t\t\"varying vec3 vWorldPosition;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\"uniform vec3 wrapRGB;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"varying vec3 vViewPosition;\",\r\n\t\t\"varying vec3 vNormal;\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tlights_phong_fragment: [\r\n\r\n\t\t\"vec3 normal = normalize( vNormal );\",\r\n\t\t\"vec3 viewPosition = normalize( vViewPosition );\",\r\n\r\n\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\"normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#ifdef USE_NORMALMAP\",\r\n\r\n\t\t\t\"normal = perturbNormal2Arb( -viewPosition, normal );\",\r\n\r\n\t\t\"#elif defined( USE_BUMPMAP )\",\r\n\r\n\t\t\t\"normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\r\n\r\n\t\t\t\"vec3 pointDiffuse  = vec3( 0.0 );\",\r\n\t\t\t\"vec3 pointSpecular = vec3( 0.0 );\",\r\n\r\n\t\t\t\"for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\"#ifdef PHONG_PER_PIXEL\",\r\n\r\n\t\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\",\r\n\t\t\t\t\t\"vec3 lVector = lPosition.xyz + vViewPosition.xyz;\",\r\n\r\n\t\t\t\t\t\"float lDistance = 1.0;\",\r\n\t\t\t\t\t\"if ( pointLightDistance[ i ] > 0.0 )\",\r\n\t\t\t\t\t\t\"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\",\r\n\r\n\t\t\t\t\t\"lVector = normalize( lVector );\",\r\n\r\n\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\"vec3 lVector = normalize( vPointLight[ i ].xyz );\",\r\n\t\t\t\t\t\"float lDistance = vPointLight[ i ].w;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t// diffuse\r\n\r\n\t\t\t\t\"float dotProduct = dot( normal, lVector );\",\r\n\r\n\t\t\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\t\t\"float pointDiffuseWeightFull = max( dotProduct, 0.0 );\",\r\n\t\t\t\t\t\"float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\",\r\n\r\n\t\t\t\t\t\"vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\",\r\n\r\n\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\"float pointDiffuseWeight = max( dotProduct, 0.0 );\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"pointDiffuse  += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\",\r\n\r\n\t\t\t\t// specular\r\n\r\n\t\t\t\t\"vec3 pointHalfVector = normalize( lVector + viewPosition );\",\r\n\t\t\t\t\"float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\",\r\n\t\t\t\t\"float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\",\r\n\r\n\t\t\t\t\"#ifdef PHYSICALLY_BASED_SHADING\",\r\n\r\n\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\r\n\r\n\t\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\r\n\r\n\t\t\t\t\t\"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, pointHalfVector ), 5.0 );\",\r\n\t\t\t\t\t\"pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\",\r\n\r\n\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\"pointSpecular += specular * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\r\n\r\n\t\t\t\"vec3 spotDiffuse  = vec3( 0.0 );\",\r\n\t\t\t\"vec3 spotSpecular = vec3( 0.0 );\",\r\n\r\n\t\t\t\"for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\"#ifdef PHONG_PER_PIXEL\",\r\n\r\n\t\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\",\r\n\t\t\t\t\t\"vec3 lVector = lPosition.xyz + vViewPosition.xyz;\",\r\n\r\n\t\t\t\t\t\"float lDistance = 1.0;\",\r\n\t\t\t\t\t\"if ( spotLightDistance[ i ] > 0.0 )\",\r\n\t\t\t\t\t\t\"lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\",\r\n\r\n\t\t\t\t\t\"lVector = normalize( lVector );\",\r\n\r\n\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\"vec3 lVector = normalize( vSpotLight[ i ].xyz );\",\r\n\t\t\t\t\t\"float lDistance = vSpotLight[ i ].w;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\",\r\n\r\n\t\t\t\t\"if ( spotEffect > spotLightAngleCos[ i ] ) {\",\r\n\r\n\t\t\t\t\t\"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\",\r\n\r\n\t\t\t\t\t// diffuse\r\n\r\n\t\t\t\t\t\"float dotProduct = dot( normal, lVector );\",\r\n\r\n\t\t\t\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\t\t\t\"float spotDiffuseWeightFull = max( dotProduct, 0.0 );\",\r\n\t\t\t\t\t\t\"float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\",\r\n\r\n\t\t\t\t\t\t\"vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\",\r\n\r\n\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\"float spotDiffuseWeight = max( dotProduct, 0.0 );\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\t\"spotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;\",\r\n\r\n\t\t\t\t\t// specular\r\n\r\n\t\t\t\t\t\"vec3 spotHalfVector = normalize( lVector + viewPosition );\",\r\n\t\t\t\t\t\"float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\",\r\n\t\t\t\t\t\"float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\",\r\n\r\n\t\t\t\t\t\"#ifdef PHYSICALLY_BASED_SHADING\",\r\n\r\n\t\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\r\n\r\n\t\t\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\r\n\r\n\t\t\t\t\t\t\"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, spotHalfVector ), 5.0 );\",\r\n\t\t\t\t\t\t\"spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;\",\r\n\r\n\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\"spotSpecular += specular * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * spotEffect;\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_DIR_LIGHTS > 0\",\r\n\r\n\t\t\t\"vec3 dirDiffuse  = vec3( 0.0 );\",\r\n\t\t\t\"vec3 dirSpecular = vec3( 0.0 );\" ,\r\n\r\n\t\t\t\"for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\",\r\n\t\t\t\t\"vec3 dirVector = normalize( lDirection.xyz );\",\r\n\r\n\t\t\t\t// diffuse\r\n\r\n\t\t\t\t\"float dotProduct = dot( normal, dirVector );\",\r\n\r\n\t\t\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\t\t\"float dirDiffuseWeightFull = max( dotProduct, 0.0 );\",\r\n\t\t\t\t\t\"float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\",\r\n\r\n\t\t\t\t\t\"vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\",\r\n\r\n\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\"float dirDiffuseWeight = max( dotProduct, 0.0 );\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"dirDiffuse  += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\",\r\n\r\n\t\t\t\t// specular\r\n\r\n\t\t\t\t\"vec3 dirHalfVector = normalize( dirVector + viewPosition );\",\r\n\t\t\t\t\"float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\",\r\n\t\t\t\t\"float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\",\r\n\r\n\t\t\t\t\"#ifdef PHYSICALLY_BASED_SHADING\",\r\n\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t// fresnel term from skin shader\r\n\t\t\t\t\t\"const float F0 = 0.128;\",\r\n\r\n\t\t\t\t\t\"float base = 1.0 - dot( viewPosition, dirHalfVector );\",\r\n\t\t\t\t\t\"float exponential = pow( base, 5.0 );\",\r\n\r\n\t\t\t\t\t\"float fresnel = exponential + F0 * ( 1.0 - exponential );\",\r\n\t\t\t\t\t*/\r\n\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t// fresnel term from fresnel shader\r\n\t\t\t\t\t\"const float mFresnelBias = 0.08;\",\r\n\t\t\t\t\t\"const float mFresnelScale = 0.3;\",\r\n\t\t\t\t\t\"const float mFresnelPower = 5.0;\",\r\n\r\n\t\t\t\t\t\"float fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\",\r\n\t\t\t\t\t*/\r\n\r\n\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\r\n\r\n\t\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\r\n\r\n\t\t\t\t\t//\"dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\",\r\n\r\n\t\t\t\t\t\"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );\",\r\n\t\t\t\t\t\"dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\",\r\n\r\n\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\"dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_HEMI_LIGHTS > 0\",\r\n\r\n\t\t\t\"vec3 hemiDiffuse  = vec3( 0.0 );\",\r\n\t\t\t\"vec3 hemiSpecular = vec3( 0.0 );\" ,\r\n\r\n\t\t\t\"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\",\r\n\t\t\t\t\"vec3 lVector = normalize( lDirection.xyz );\",\r\n\r\n\t\t\t\t// diffuse\r\n\r\n\t\t\t\t\"float dotProduct = dot( normal, lVector );\",\r\n\t\t\t\t\"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\",\r\n\r\n\t\t\t\t\"vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\",\r\n\r\n\t\t\t\t\"hemiDiffuse += diffuse * hemiColor;\",\r\n\r\n\t\t\t\t// specular (sky light)\r\n\r\n\t\t\t\t\"vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\",\r\n\t\t\t\t\"float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\",\r\n\t\t\t\t\"float hemiSpecularWeightSky = specularStrength * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );\",\r\n\r\n\t\t\t\t// specular (ground light)\r\n\r\n\t\t\t\t\"vec3 lVectorGround = -lVector;\",\r\n\r\n\t\t\t\t\"vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\",\r\n\t\t\t\t\"float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\",\r\n\t\t\t\t\"float hemiSpecularWeightGround = specularStrength * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );\",\r\n\r\n\t\t\t\t\"#ifdef PHYSICALLY_BASED_SHADING\",\r\n\r\n\t\t\t\t\t\"float dotProductGround = dot( normal, lVectorGround );\",\r\n\r\n\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\r\n\r\n\t\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\r\n\r\n\t\t\t\t\t\"vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );\",\r\n\t\t\t\t\t\"vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );\",\r\n\t\t\t\t\t\"hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\",\r\n\r\n\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\"hemiSpecular += specular * hemiColor * ( hemiSpecularWeightSky + hemiSpecularWeightGround ) * hemiDiffuseWeight;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"vec3 totalDiffuse = vec3( 0.0 );\",\r\n\t\t\"vec3 totalSpecular = vec3( 0.0 );\",\r\n\r\n\t\t\"#if MAX_DIR_LIGHTS > 0\",\r\n\r\n\t\t\t\"totalDiffuse += dirDiffuse;\",\r\n\t\t\t\"totalSpecular += dirSpecular;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_HEMI_LIGHTS > 0\",\r\n\r\n\t\t\t\"totalDiffuse += hemiDiffuse;\",\r\n\t\t\t\"totalSpecular += hemiSpecular;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\r\n\r\n\t\t\t\"totalDiffuse += pointDiffuse;\",\r\n\t\t\t\"totalSpecular += pointSpecular;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\r\n\r\n\t\t\t\"totalDiffuse += spotDiffuse;\",\r\n\t\t\t\"totalSpecular += spotSpecular;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#ifdef METAL\",\r\n\r\n\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );\",\r\n\r\n\t\t\"#else\",\r\n\r\n\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// VERTEX COLORS\r\n\r\n\tcolor_pars_fragment: [\r\n\r\n\t\t\"#ifdef USE_COLOR\",\r\n\r\n\t\t\t\"varying vec3 vColor;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\r\n\tcolor_fragment: [\r\n\r\n\t\t\"#ifdef USE_COLOR\",\r\n\r\n\t\t\t\"gl_FragColor = gl_FragColor * vec4( vColor, opacity );\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tcolor_pars_vertex: [\r\n\r\n\t\t\"#ifdef USE_COLOR\",\r\n\r\n\t\t\t\"varying vec3 vColor;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\r\n\tcolor_vertex: [\r\n\r\n\t\t\"#ifdef USE_COLOR\",\r\n\r\n\t\t\t\"#ifdef GAMMA_INPUT\",\r\n\r\n\t\t\t\t\"vColor = color * color;\",\r\n\r\n\t\t\t\"#else\",\r\n\r\n\t\t\t\t\"vColor = color;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// SKINNING\r\n\r\n\tskinning_pars_vertex: [\r\n\r\n\t\t\"#ifdef USE_SKINNING\",\r\n\r\n\t\t\t\"#ifdef BONE_TEXTURE\",\r\n\r\n\t\t\t\t\"uniform sampler2D boneTexture;\",\r\n\r\n\t\t\t\t\"mat4 getBoneMatrix( const in float i ) {\",\r\n\r\n\t\t\t\t\t\"float j = i * 4.0;\",\r\n\t\t\t\t\t\"float x = mod( j, N_BONE_PIXEL_X );\",\r\n\t\t\t\t\t\"float y = floor( j / N_BONE_PIXEL_X );\",\r\n\r\n\t\t\t\t\t\"const float dx = 1.0 / N_BONE_PIXEL_X;\",\r\n\t\t\t\t\t\"const float dy = 1.0 / N_BONE_PIXEL_Y;\",\r\n\r\n\t\t\t\t\t\"y = dy * ( y + 0.5 );\",\r\n\r\n\t\t\t\t\t\"vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\",\r\n\t\t\t\t\t\"vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\",\r\n\t\t\t\t\t\"vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\",\r\n\t\t\t\t\t\"vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\",\r\n\r\n\t\t\t\t\t\"mat4 bone = mat4( v1, v2, v3, v4 );\",\r\n\r\n\t\t\t\t\t\"return bone;\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\"#else\",\r\n\r\n\t\t\t\t\"uniform mat4 boneGlobalMatrices[ MAX_BONES ];\",\r\n\r\n\t\t\t\t\"mat4 getBoneMatrix( const in float i ) {\",\r\n\r\n\t\t\t\t\t\"mat4 bone = boneGlobalMatrices[ int(i) ];\",\r\n\t\t\t\t\t\"return bone;\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tskinbase_vertex: [\r\n\r\n\t\t\"#ifdef USE_SKINNING\",\r\n\r\n\t\t\t\"mat4 boneMatX = getBoneMatrix( skinIndex.x );\",\r\n\t\t\t\"mat4 boneMatY = getBoneMatrix( skinIndex.y );\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tskinning_vertex: [\r\n\r\n\t\t\"#ifdef USE_SKINNING\",\r\n\r\n\t\t\t\"#ifdef USE_MORPHTARGETS\",\r\n\r\n\t\t\t\"vec4 skinVertex = vec4( morphed, 1.0 );\",\r\n\r\n\t\t\t\"#else\",\r\n\r\n\t\t\t\"vec4 skinVertex = vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;\",\r\n\t\t\t\"skinned \t  += boneMatY * skinVertex * skinWeight.y;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// MORPHING\r\n\r\n\tmorphtarget_pars_vertex: [\r\n\r\n\t\t\"#ifdef USE_MORPHTARGETS\",\r\n\r\n\t\t\t\"#ifndef USE_MORPHNORMALS\",\r\n\r\n\t\t\t\"uniform float morphTargetInfluences[ 8 ];\",\r\n\r\n\t\t\t\"#else\",\r\n\r\n\t\t\t\"uniform float morphTargetInfluences[ 4 ];\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tmorphtarget_vertex: [\r\n\r\n\t\t\"#ifdef USE_MORPHTARGETS\",\r\n\r\n\t\t\t\"vec3 morphed = vec3( 0.0 );\",\r\n\t\t\t\"morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\",\r\n\t\t\t\"morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\",\r\n\t\t\t\"morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\",\r\n\t\t\t\"morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\",\r\n\r\n\t\t\t\"#ifndef USE_MORPHNORMALS\",\r\n\r\n\t\t\t\"morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\",\r\n\t\t\t\"morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\",\r\n\t\t\t\"morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\",\r\n\t\t\t\"morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"morphed += position;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tdefault_vertex : [\r\n\r\n\t\t\"vec4 mvPosition;\",\r\n\r\n\t\t\"#ifdef USE_SKINNING\",\r\n\r\n\t\t\t\"mvPosition = modelViewMatrix * skinned;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )\",\r\n\r\n\t\t\t\"mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )\",\r\n\r\n\t\t\t\"mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"gl_Position = projectionMatrix * mvPosition;\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tmorphnormal_vertex: [\r\n\r\n\t\t\"#ifdef USE_MORPHNORMALS\",\r\n\r\n\t\t\t\"vec3 morphedNormal = vec3( 0.0 );\",\r\n\r\n\t\t\t\"morphedNormal +=  ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\",\r\n\t\t\t\"morphedNormal +=  ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\",\r\n\t\t\t\"morphedNormal +=  ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\",\r\n\t\t\t\"morphedNormal +=  ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\",\r\n\r\n\t\t\t\"morphedNormal += normal;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tskinnormal_vertex: [\r\n\r\n\t\t\"#ifdef USE_SKINNING\",\r\n\r\n\t\t\t\"mat4 skinMatrix = skinWeight.x * boneMatX;\",\r\n\t\t\t\"skinMatrix \t+= skinWeight.y * boneMatY;\",\r\n\r\n\t\t\t\"#ifdef USE_MORPHNORMALS\",\r\n\r\n\t\t\t\"vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\",\r\n\r\n\t\t\t\"#else\",\r\n\r\n\t\t\t\"vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tdefaultnormal_vertex: [\r\n\r\n\t\t\"vec3 objectNormal;\",\r\n\r\n\t\t\"#ifdef USE_SKINNING\",\r\n\r\n\t\t\t\"objectNormal = skinnedNormal.xyz;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )\",\r\n\r\n\t\t\t\"objectNormal = morphedNormal;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )\",\r\n\r\n\t\t\t\"objectNormal = normal;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"#ifdef FLIP_SIDED\",\r\n\r\n\t\t\t\"objectNormal = -objectNormal;\",\r\n\r\n\t\t\"#endif\",\r\n\r\n\t\t\"vec3 transformedNormal = normalMatrix * objectNormal;\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// SHADOW MAP\r\n\r\n\t// based on SpiderGL shadow map and Fabien Sanglard's GLSL shadow mapping examples\r\n\t//  http://spidergl.org/example.php?id=6\r\n\t// \thttp://fabiensanglard.net/shadowmapping\r\n\r\n\tshadowmap_pars_fragment: [\r\n\r\n\t\t\"#ifdef USE_SHADOWMAP\",\r\n\r\n\t\t\t\"uniform sampler2D shadowMap[ MAX_SHADOWS ];\",\r\n\t\t\t\"uniform vec2 shadowMapSize[ MAX_SHADOWS ];\",\r\n\r\n\t\t\t\"uniform float shadowDarkness[ MAX_SHADOWS ];\",\r\n\t\t\t\"uniform float shadowBias[ MAX_SHADOWS ];\",\r\n\r\n\t\t\t\"varying vec4 vShadowCoord[ MAX_SHADOWS ];\",\r\n\r\n\t\t\t\"float unpackDepth( const in vec4 rgba_depth ) {\",\r\n\r\n\t\t\t\t\"const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\",\r\n\t\t\t\t\"float depth = dot( rgba_depth, bit_shift );\",\r\n\t\t\t\t\"return depth;\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tshadowmap_fragment: [\r\n\r\n\t\t\"#ifdef USE_SHADOWMAP\",\r\n\r\n\t\t\t\"#ifdef SHADOWMAP_DEBUG\",\r\n\r\n\t\t\t\t\"vec3 frustumColors[3];\",\r\n\t\t\t\t\"frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\",\r\n\t\t\t\t\"frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\",\r\n\t\t\t\t\"frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#ifdef SHADOWMAP_CASCADE\",\r\n\r\n\t\t\t\t\"int inFrustumCount = 0;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"float fDepth;\",\r\n\t\t\t\"vec3 shadowColor = vec3( 1.0 );\",\r\n\r\n\t\t\t\"for( int i = 0; i < MAX_SHADOWS; i ++ ) {\",\r\n\r\n\t\t\t\t\"vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\",\r\n\r\n\t\t\t\t// \"if ( something && something )\" \t\t breaks ATI OpenGL shader compiler\r\n\t\t\t\t// \"if ( all( something, something ) )\"  using this instead\r\n\r\n\t\t\t\t\"bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\",\r\n\t\t\t\t\"bool inFrustum = all( inFrustumVec );\",\r\n\r\n\t\t\t\t// don't shadow pixels outside of light frustum\r\n\t\t\t\t// use just first frustum (for cascades)\r\n\t\t\t\t// don't shadow pixels behind far plane of light frustum\r\n\r\n\t\t\t\t\"#ifdef SHADOWMAP_CASCADE\",\r\n\r\n\t\t\t\t\t\"inFrustumCount += int( inFrustum );\",\r\n\t\t\t\t\t\"bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\",\r\n\r\n\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\"bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"bool frustumTest = all( frustumTestVec );\",\r\n\r\n\t\t\t\t\"if ( frustumTest ) {\",\r\n\r\n\t\t\t\t\t\"shadowCoord.z += shadowBias[ i ];\",\r\n\r\n\t\t\t\t\t\"#if defined( SHADOWMAP_TYPE_PCF )\",\r\n\r\n\t\t\t\t\t\t// Percentage-close filtering\r\n\t\t\t\t\t\t// (9 pixel kernel)\r\n\t\t\t\t\t\t// http://fabiensanglard.net/shadowmappingPCF/\r\n\r\n\t\t\t\t\t\t\"float shadow = 0.0;\",\r\n\r\n\t\t\t\t\t\t/*\r\n\t\t\t\t\t\t// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\r\n\t\t\t\t\t\t// must enroll loop manually\r\n\r\n\t\t\t\t\t\t\"for ( float y = -1.25; y <= 1.25; y += 1.25 )\",\r\n\t\t\t\t\t\t\t\"for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\",\r\n\r\n\t\t\t\t\t\t\t\t\"vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\",\r\n\r\n\t\t\t\t\t\t\t\t// doesn't seem to produce any noticeable visual difference compared to simple \"texture2D\" lookup\r\n\t\t\t\t\t\t\t\t//\"vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\",\r\n\r\n\t\t\t\t\t\t\t\t\"float fDepth = unpackDepth( rgbaDepth );\",\r\n\r\n\t\t\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z )\",\r\n\t\t\t\t\t\t\t\t\t\"shadow += 1.0;\",\r\n\r\n\t\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\t\t\"shadow /= 9.0;\",\r\n\r\n\t\t\t\t\t\t*/\r\n\r\n\t\t\t\t\t\t\"const float shadowDelta = 1.0 / 9.0;\",\r\n\r\n\t\t\t\t\t\t\"float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\",\r\n\t\t\t\t\t\t\"float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\",\r\n\r\n\t\t\t\t\t\t\"float dx0 = -1.25 * xPixelOffset;\",\r\n\t\t\t\t\t\t\"float dy0 = -1.25 * yPixelOffset;\",\r\n\t\t\t\t\t\t\"float dx1 = 1.25 * xPixelOffset;\",\r\n\t\t\t\t\t\t\"float dy1 = 1.25 * yPixelOffset;\",\r\n\r\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\",\r\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\r\n\r\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\",\r\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\r\n\r\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\",\r\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\r\n\r\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\",\r\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\r\n\r\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\",\r\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\r\n\r\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\",\r\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\r\n\r\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\",\r\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\r\n\r\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\",\r\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\r\n\r\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\",\r\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\r\n\r\n\t\t\t\t\t\t\"shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\",\r\n\r\n\t\t\t\t\t\"#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\",\r\n\r\n\t\t\t\t\t\t// Percentage-close filtering\r\n\t\t\t\t\t\t// (9 pixel kernel)\r\n\t\t\t\t\t\t// http://fabiensanglard.net/shadowmappingPCF/\r\n\r\n\t\t\t\t\t\t\"float shadow = 0.0;\",\r\n\r\n\t\t\t\t\t\t\"float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\",\r\n\t\t\t\t\t\t\"float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\",\r\n\r\n\t\t\t\t\t\t\"float dx0 = -1.0 * xPixelOffset;\",\r\n\t\t\t\t\t\t\"float dy0 = -1.0 * yPixelOffset;\",\r\n\t\t\t\t\t\t\"float dx1 = 1.0 * xPixelOffset;\",\r\n\t\t\t\t\t\t\"float dy1 = 1.0 * yPixelOffset;\",\r\n\r\n\t\t\t\t\t\t\"mat3 shadowKernel;\",\r\n\t\t\t\t\t\t\"mat3 depthKernel;\",\r\n\r\n\t\t\t\t\t\t\"depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\",\r\n\t\t\t\t\t\t\"if ( depthKernel[0][0] < shadowCoord.z ) shadowKernel[0][0] = 0.25;\",\r\n\t\t\t\t\t\t\"else shadowKernel[0][0] = 0.0;\",\r\n\r\n\t\t\t\t\t\t\"depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\",\r\n\t\t\t\t\t\t\"if ( depthKernel[0][1] < shadowCoord.z ) shadowKernel[0][1] = 0.25;\",\r\n\t\t\t\t\t\t\"else shadowKernel[0][1] = 0.0;\",\r\n\r\n\t\t\t\t\t\t\"depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i], shadowCoord.xy + vec2( dx0, dy1 ) ) );\",\r\n\t\t\t\t\t\t\"if ( depthKernel[0][2] < shadowCoord.z ) shadowKernel[0][2] = 0.25;\",\r\n\t\t\t\t\t\t\"else shadowKernel[0][2] = 0.0;\",\r\n\r\n\t\t\t\t\t\t\"depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\",\r\n\t\t\t\t\t\t\"if ( depthKernel[1][0] < shadowCoord.z ) shadowKernel[1][0] = 0.25;\",\r\n\t\t\t\t\t\t\"else shadowKernel[1][0] = 0.0;\",\r\n\r\n\t\t\t\t\t\t\"depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\",\r\n\t\t\t\t\t\t\"if ( depthKernel[1][1] < shadowCoord.z ) shadowKernel[1][1] = 0.25;\",\r\n\t\t\t\t\t\t\"else shadowKernel[1][1] = 0.0;\",\r\n\r\n\t\t\t\t\t\t\"depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\",\r\n\t\t\t\t\t\t\"if ( depthKernel[1][2] < shadowCoord.z ) shadowKernel[1][2] = 0.25;\",\r\n\t\t\t\t\t\t\"else shadowKernel[1][2] = 0.0;\",\r\n\r\n\t\t\t\t\t\t\"depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\",\r\n\t\t\t\t\t\t\"if ( depthKernel[2][0] < shadowCoord.z ) shadowKernel[2][0] = 0.25;\",\r\n\t\t\t\t\t\t\"else shadowKernel[2][0] = 0.0;\",\r\n\r\n\t\t\t\t\t\t\"depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\",\r\n\t\t\t\t\t\t\"if ( depthKernel[2][1] < shadowCoord.z ) shadowKernel[2][1] = 0.25;\",\r\n\t\t\t\t\t\t\"else shadowKernel[2][1] = 0.0;\",\r\n\r\n\t\t\t\t\t\t\"depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\",\r\n\t\t\t\t\t\t\"if ( depthKernel[2][2] < shadowCoord.z ) shadowKernel[2][2] = 0.25;\",\r\n\t\t\t\t\t\t\"else shadowKernel[2][2] = 0.0;\",\r\n\r\n\t\t\t\t\t\t\"vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\",\r\n\r\n\t\t\t\t\t\t\"shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\",\r\n\t\t\t\t\t\t\"shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\",\r\n\r\n\t\t\t\t\t\t\"vec4 shadowValues;\",\r\n\t\t\t\t\t\t\"shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\",\r\n\t\t\t\t\t\t\"shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\",\r\n\t\t\t\t\t\t\"shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\",\r\n\t\t\t\t\t\t\"shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\",\r\n\r\n\t\t\t\t\t\t\"shadow = dot( shadowValues, vec4( 1.0 ) );\",\r\n\r\n\t\t\t\t\t\t\"shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\",\r\n\r\n\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\"vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\",\r\n\t\t\t\t\t\t\"float fDepth = unpackDepth( rgbaDepth );\",\r\n\r\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z )\",\r\n\r\n\t\t\t\t\t\t\t// spot with multiple shadows is darker\r\n\r\n\t\t\t\t\t\t\t\"shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\",\r\n\r\n\t\t\t\t\t\t\t// spot with multiple shadows has the same color as single shadow spot\r\n\r\n\t\t\t\t\t\t\t//\"shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\r\n\t\t\t\t\"#ifdef SHADOWMAP_DEBUG\",\r\n\r\n\t\t\t\t\t\"#ifdef SHADOWMAP_CASCADE\",\r\n\r\n\t\t\t\t\t\t\"if ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];\",\r\n\r\n\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\"if ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"#ifdef GAMMA_OUTPUT\",\r\n\r\n\t\t\t\t\"shadowColor *= shadowColor;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * shadowColor;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tshadowmap_pars_vertex: [\r\n\r\n\t\t\"#ifdef USE_SHADOWMAP\",\r\n\r\n\t\t\t\"varying vec4 vShadowCoord[ MAX_SHADOWS ];\",\r\n\t\t\t\"uniform mat4 shadowMatrix[ MAX_SHADOWS ];\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tshadowmap_vertex: [\r\n\r\n\t\t\"#ifdef USE_SHADOWMAP\",\r\n\r\n\t\t\t\"for( int i = 0; i < MAX_SHADOWS; i ++ ) {\",\r\n\r\n\t\t\t\t\"vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// ALPHATEST\r\n\r\n\talphatest_fragment: [\r\n\r\n\t\t\"#ifdef ALPHATEST\",\r\n\r\n\t\t\t\"if ( gl_FragColor.a < ALPHATEST ) discard;\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\t// LINEAR SPACE\r\n\r\n\tlinear_to_gamma_fragment: [\r\n\r\n\t\t\"#ifdef GAMMA_OUTPUT\",\r\n\r\n\t\t\t\"gl_FragColor.xyz = sqrt( gl_FragColor.xyz );\",\r\n\r\n\t\t\"#endif\"\r\n\r\n\t].join(\"\\n\")\r\n\r\n\r\n};\r\n\r\nTHREE.UniformsUtils = {\r\n\r\n\tmerge: function ( uniforms ) {\r\n\r\n\t\tvar u, p, tmp, merged = {};\r\n\r\n\t\tfor ( u = 0; u < uniforms.length; u ++ ) {\r\n\r\n\t\t\ttmp = this.clone( uniforms[ u ] );\r\n\r\n\t\t\tfor ( p in tmp ) {\r\n\r\n\t\t\t\tmerged[ p ] = tmp[ p ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn merged;\r\n\r\n\t},\r\n\r\n\tclone: function ( uniforms_src ) {\r\n\r\n\t\tvar u, p, parameter, parameter_src, uniforms_dst = {};\r\n\r\n\t\tfor ( u in uniforms_src ) {\r\n\r\n\t\t\tuniforms_dst[ u ] = {};\r\n\r\n\t\t\tfor ( p in uniforms_src[ u ] ) {\r\n\r\n\t\t\t\tparameter_src = uniforms_src[ u ][ p ];\r\n\r\n\t\t\t\tif ( parameter_src instanceof THREE.Color ||\r\n\t\t\t\t\t parameter_src instanceof THREE.Vector2 ||\r\n\t\t\t\t\t parameter_src instanceof THREE.Vector3 ||\r\n\t\t\t\t\t parameter_src instanceof THREE.Vector4 ||\r\n\t\t\t\t\t parameter_src instanceof THREE.Matrix4 ||\r\n\t\t\t\t\t parameter_src instanceof THREE.Texture ) {\r\n\r\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.clone();\r\n\r\n\t\t\t\t} else if ( parameter_src instanceof Array ) {\r\n\r\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.slice();\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn uniforms_dst;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.UniformsLib = {\r\n\r\n\tcommon: {\r\n\r\n\t\t\"diffuse\" : { type: \"c\", value: new THREE.Color( 0xeeeeee ) },\r\n\t\t\"opacity\" : { type: \"f\", value: 1.0 },\r\n\r\n\t\t\"map\" : { type: \"t\", value: null },\r\n\t\t\"offsetRepeat\" : { type: \"v4\", value: new THREE.Vector4( 0, 0, 1, 1 ) },\r\n\r\n\t\t\"lightMap\" : { type: \"t\", value: null },\r\n\t\t\"specularMap\" : { type: \"t\", value: null },\r\n\r\n\t\t\"envMap\" : { type: \"t\", value: null },\r\n\t\t\"flipEnvMap\" : { type: \"f\", value: -1 },\r\n\t\t\"useRefract\" : { type: \"i\", value: 0 },\r\n\t\t\"reflectivity\" : { type: \"f\", value: 1.0 },\r\n\t\t\"refractionRatio\" : { type: \"f\", value: 0.98 },\r\n\t\t\"combine\" : { type: \"i\", value: 0 },\r\n\r\n\t\t\"morphTargetInfluences\" : { type: \"f\", value: 0 }\r\n\r\n\t},\r\n\r\n\tbump: {\r\n\r\n\t\t\"bumpMap\" : { type: \"t\", value: null },\r\n\t\t\"bumpScale\" : { type: \"f\", value: 1 }\r\n\r\n\t},\r\n\r\n\tnormalmap: {\r\n\r\n\t\t\"normalMap\" : { type: \"t\", value: null },\r\n\t\t\"normalScale\" : { type: \"v2\", value: new THREE.Vector2( 1, 1 ) }\r\n\t},\r\n\r\n\tfog : {\r\n\r\n\t\t\"fogDensity\" : { type: \"f\", value: 0.00025 },\r\n\t\t\"fogNear\" : { type: \"f\", value: 1 },\r\n\t\t\"fogFar\" : { type: \"f\", value: 2000 },\r\n\t\t\"fogColor\" : { type: \"c\", value: new THREE.Color( 0xffffff ) }\r\n\r\n\t},\r\n\r\n\tlights: {\r\n\r\n\t\t\"ambientLightColor\" : { type: \"fv\", value: [] },\r\n\r\n\t\t\"directionalLightDirection\" : { type: \"fv\", value: [] },\r\n\t\t\"directionalLightColor\" : { type: \"fv\", value: [] },\r\n\r\n\t\t\"hemisphereLightDirection\" : { type: \"fv\", value: [] },\r\n\t\t\"hemisphereLightSkyColor\" : { type: \"fv\", value: [] },\r\n\t\t\"hemisphereLightGroundColor\" : { type: \"fv\", value: [] },\r\n\r\n\t\t\"pointLightColor\" : { type: \"fv\", value: [] },\r\n\t\t\"pointLightPosition\" : { type: \"fv\", value: [] },\r\n\t\t\"pointLightDistance\" : { type: \"fv1\", value: [] },\r\n\r\n\t\t\"spotLightColor\" : { type: \"fv\", value: [] },\r\n\t\t\"spotLightPosition\" : { type: \"fv\", value: [] },\r\n\t\t\"spotLightDirection\" : { type: \"fv\", value: [] },\r\n\t\t\"spotLightDistance\" : { type: \"fv1\", value: [] },\r\n\t\t\"spotLightAngleCos\" : { type: \"fv1\", value: [] },\r\n\t\t\"spotLightExponent\" : { type: \"fv1\", value: [] }\r\n\r\n\t},\r\n\r\n\tparticle: {\r\n\r\n\t\t\"psColor\" : { type: \"c\", value: new THREE.Color( 0xeeeeee ) },\r\n\t\t\"opacity\" : { type: \"f\", value: 1.0 },\r\n\t\t\"size\" : { type: \"f\", value: 1.0 },\r\n\t\t\"scale\" : { type: \"f\", value: 1.0 },\r\n\t\t\"map\" : { type: \"t\", value: null },\r\n\r\n\t\t\"fogDensity\" : { type: \"f\", value: 0.00025 },\r\n\t\t\"fogNear\" : { type: \"f\", value: 1 },\r\n\t\t\"fogFar\" : { type: \"f\", value: 2000 },\r\n\t\t\"fogColor\" : { type: \"c\", value: new THREE.Color( 0xffffff ) }\r\n\r\n\t},\r\n\r\n\tshadowmap: {\r\n\r\n\t\t\"shadowMap\": { type: \"tv\", value: [] },\r\n\t\t\"shadowMapSize\": { type: \"v2v\", value: [] },\r\n\r\n\t\t\"shadowBias\" : { type: \"fv1\", value: [] },\r\n\t\t\"shadowDarkness\": { type: \"fv1\", value: [] },\r\n\r\n\t\t\"shadowMatrix\" : { type: \"m4v\", value: [] }\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.ShaderLib = {\r\n\r\n\t'basic': {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ \"common\" ],\r\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\r\n\t\t\tTHREE.UniformsLib[ \"shadowmap\" ]\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"map_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n\r\n\t\t\t\t\"#ifdef USE_ENVMAP\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphnormal_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"defaultnormal_vertex\" ],\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform vec3 diffuse;\",\r\n\t\t\t\"uniform float opacity;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"map_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"gl_FragColor = vec4( diffuse, opacity );\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"specularmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t'lambert': {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ \"common\" ],\r\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\r\n\t\t\tTHREE.UniformsLib[ \"lights\" ],\r\n\t\t\tTHREE.UniformsLib[ \"shadowmap\" ],\r\n\r\n\t\t\t{\r\n\t\t\t\t\"ambient\"  : { type: \"c\", value: new THREE.Color( 0xffffff ) },\r\n\t\t\t\t\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\r\n\t\t\t\t\"wrapRGB\"  : { type: \"v3\", value: new THREE.Vector3( 1, 1, 1 ) }\r\n\t\t\t}\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"#define LAMBERT\",\r\n\r\n\t\t\t\"varying vec3 vLightFront;\",\r\n\r\n\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\"varying vec3 vLightBack;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"map_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lights_lambert_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphnormal_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"defaultnormal_vertex\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lights_lambert_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform float opacity;\",\r\n\r\n\t\t\t\"varying vec3 vLightFront;\",\r\n\r\n\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\"varying vec3 vLightBack;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"map_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"gl_FragColor = vec4( vec3 ( 1.0 ), opacity );\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"specularmap_fragment\" ],\r\n\r\n\t\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\t//\"float isFront = float( gl_FrontFacing );\",\r\n\t\t\t\t\t//\"gl_FragColor.xyz *= isFront * vLightFront + ( 1.0 - isFront ) * vLightBack;\",\r\n\r\n\t\t\t\t\t\"if ( gl_FrontFacing )\",\r\n\t\t\t\t\t\t\"gl_FragColor.xyz *= vLightFront;\",\r\n\t\t\t\t\t\"else\",\r\n\t\t\t\t\t\t\"gl_FragColor.xyz *= vLightBack;\",\r\n\r\n\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\"gl_FragColor.xyz *= vLightFront;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t'phong': {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ \"common\" ],\r\n\t\t\tTHREE.UniformsLib[ \"bump\" ],\r\n\t\t\tTHREE.UniformsLib[ \"normalmap\" ],\r\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\r\n\t\t\tTHREE.UniformsLib[ \"lights\" ],\r\n\t\t\tTHREE.UniformsLib[ \"shadowmap\" ],\r\n\r\n\t\t\t{\r\n\t\t\t\t\"ambient\"  : { type: \"c\", value: new THREE.Color( 0xffffff ) },\r\n\t\t\t\t\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\r\n\t\t\t\t\"specular\" : { type: \"c\", value: new THREE.Color( 0x111111 ) },\r\n\t\t\t\t\"shininess\": { type: \"f\", value: 30 },\r\n\t\t\t\t\"wrapRGB\"  : { type: \"v3\", value: new THREE.Vector3( 1, 1, 1 ) }\r\n\t\t\t}\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"#define PHONG\",\r\n\r\n\t\t\t\"varying vec3 vViewPosition;\",\r\n\t\t\t\"varying vec3 vNormal;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"map_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lights_phong_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphnormal_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"defaultnormal_vertex\" ],\r\n\r\n\t\t\t\t\"vNormal = normalize( transformedNormal );\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\r\n\r\n\t\t\t\t\"vViewPosition = -mvPosition.xyz;\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lights_phong_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform vec3 diffuse;\",\r\n\t\t\t\"uniform float opacity;\",\r\n\r\n\t\t\t\"uniform vec3 ambient;\",\r\n\t\t\t\"uniform vec3 emissive;\",\r\n\t\t\t\"uniform vec3 specular;\",\r\n\t\t\t\"uniform float shininess;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"map_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lights_phong_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"bumpmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"normalmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"gl_FragColor = vec4( vec3 ( 1.0 ), opacity );\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"specularmap_fragment\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"lights_phong_fragment\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t'particle_basic': {\r\n\r\n\t\tuniforms:  THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ \"particle\" ],\r\n\t\t\tTHREE.UniformsLib[ \"shadowmap\" ]\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"uniform float size;\",\r\n\t\t\t\"uniform float scale;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\r\n\r\n\t\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\t\"#ifdef USE_SIZEATTENUATION\",\r\n\t\t\t\t\t\"gl_PointSize = size * ( scale / length( mvPosition.xyz ) );\",\r\n\t\t\t\t\"#else\",\r\n\t\t\t\t\t\"gl_PointSize = size;\",\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"gl_Position = projectionMatrix * mvPosition;\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform vec3 psColor;\",\r\n\t\t\t\"uniform float opacity;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"map_particle_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"gl_FragColor = vec4( psColor, opacity );\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_particle_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t'dashed': {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ \"common\" ],\r\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\r\n\r\n\t\t\t{\r\n\t\t\t\t\"scale\":     { type: \"f\", value: 1 },\r\n\t\t\t\t\"dashSize\":  { type: \"f\", value: 1 },\r\n\t\t\t\t\"totalSize\": { type: \"f\", value: 2 }\r\n\t\t\t}\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"uniform float scale;\",\r\n\t\t\t\"attribute float lineDistance;\",\r\n\r\n\t\t\t\"varying float vLineDistance;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\r\n\r\n\t\t\t\t\"vLineDistance = scale * lineDistance;\",\r\n\r\n\t\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\r\n\t\t\t\t\"gl_Position = projectionMatrix * mvPosition;\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform vec3 diffuse;\",\r\n\t\t\t\"uniform float opacity;\",\r\n\r\n\t\t\t\"uniform float dashSize;\",\r\n\t\t\t\"uniform float totalSize;\",\r\n\r\n\t\t\t\"varying float vLineDistance;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"if ( mod( vLineDistance, totalSize ) > dashSize ) {\",\r\n\r\n\t\t\t\t\t\"discard;\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"gl_FragColor = vec4( diffuse, opacity );\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t'depth': {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\t\"mNear\": { type: \"f\", value: 1.0 },\r\n\t\t\t\"mFar\" : { type: \"f\", value: 2000.0 },\r\n\t\t\t\"opacity\" : { type: \"f\", value: 1.0 }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform float mNear;\",\r\n\t\t\t\"uniform float mFar;\",\r\n\t\t\t\"uniform float opacity;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"float depth = gl_FragCoord.z / gl_FragCoord.w;\",\r\n\t\t\t\t\"float color = 1.0 - smoothstep( mNear, mFar, depth );\",\r\n\t\t\t\t\"gl_FragColor = vec4( vec3( color ), opacity );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t'normal': {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\t\"opacity\" : { type: \"f\", value: 1.0 }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec3 vNormal;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\r\n\t\t\t\t\"vNormal = normalize( normalMatrix * normal );\",\r\n\r\n\t\t\t\t\"gl_Position = projectionMatrix * mvPosition;\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform float opacity;\",\r\n\t\t\t\"varying vec3 vNormal;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t/* -------------------------------------------------------------------------\r\n\t//\tNormal map shader\r\n\t//\t\t- Blinn-Phong\r\n\t//\t\t- normal + diffuse + specular + AO + displacement + reflection + shadow maps\r\n\t//\t\t- point and directional lights (use with \"lights: true\" material option)\r\n\t ------------------------------------------------------------------------- */\r\n\r\n\t'normalmap' : {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\r\n\t\t\tTHREE.UniformsLib[ \"lights\" ],\r\n\t\t\tTHREE.UniformsLib[ \"shadowmap\" ],\r\n\r\n\t\t\t{\r\n\r\n\t\t\t\"enableAO\"\t\t  : { type: \"i\", value: 0 },\r\n\t\t\t\"enableDiffuse\"\t  : { type: \"i\", value: 0 },\r\n\t\t\t\"enableSpecular\"  : { type: \"i\", value: 0 },\r\n\t\t\t\"enableReflection\": { type: \"i\", value: 0 },\r\n\t\t\t\"enableDisplacement\": { type: \"i\", value: 0 },\r\n\r\n\t\t\t\"tDisplacement\": { type: \"t\", value: null }, // must go first as this is vertex texture\r\n\t\t\t\"tDiffuse\"\t   : { type: \"t\", value: null },\r\n\t\t\t\"tCube\"\t\t   : { type: \"t\", value: null },\r\n\t\t\t\"tNormal\"\t   : { type: \"t\", value: null },\r\n\t\t\t\"tSpecular\"\t   : { type: \"t\", value: null },\r\n\t\t\t\"tAO\"\t\t   : { type: \"t\", value: null },\r\n\r\n\t\t\t\"uNormalScale\": { type: \"v2\", value: new THREE.Vector2( 1, 1 ) },\r\n\r\n\t\t\t\"uDisplacementBias\": { type: \"f\", value: 0.0 },\r\n\t\t\t\"uDisplacementScale\": { type: \"f\", value: 1.0 },\r\n\r\n\t\t\t\"uDiffuseColor\": { type: \"c\", value: new THREE.Color( 0xffffff ) },\r\n\t\t\t\"uSpecularColor\": { type: \"c\", value: new THREE.Color( 0x111111 ) },\r\n\t\t\t\"uAmbientColor\": { type: \"c\", value: new THREE.Color( 0xffffff ) },\r\n\t\t\t\"uShininess\": { type: \"f\", value: 30 },\r\n\t\t\t\"uOpacity\": { type: \"f\", value: 1 },\r\n\r\n\t\t\t\"useRefract\": { type: \"i\", value: 0 },\r\n\t\t\t\"uRefractionRatio\": { type: \"f\", value: 0.98 },\r\n\t\t\t\"uReflectivity\": { type: \"f\", value: 0.5 },\r\n\r\n\t\t\t\"uOffset\" : { type: \"v2\", value: new THREE.Vector2( 0, 0 ) },\r\n\t\t\t\"uRepeat\" : { type: \"v2\", value: new THREE.Vector2( 1, 1 ) },\r\n\r\n\t\t\t\"wrapRGB\"  : { type: \"v3\", value: new THREE.Vector3( 1, 1, 1 ) }\r\n\r\n\t\t\t}\r\n\r\n\t\t] ),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform vec3 uAmbientColor;\",\r\n\t\t\t\"uniform vec3 uDiffuseColor;\",\r\n\t\t\t\"uniform vec3 uSpecularColor;\",\r\n\t\t\t\"uniform float uShininess;\",\r\n\t\t\t\"uniform float uOpacity;\",\r\n\r\n\t\t\t\"uniform bool enableDiffuse;\",\r\n\t\t\t\"uniform bool enableSpecular;\",\r\n\t\t\t\"uniform bool enableAO;\",\r\n\t\t\t\"uniform bool enableReflection;\",\r\n\r\n\t\t\t\"uniform sampler2D tDiffuse;\",\r\n\t\t\t\"uniform sampler2D tNormal;\",\r\n\t\t\t\"uniform sampler2D tSpecular;\",\r\n\t\t\t\"uniform sampler2D tAO;\",\r\n\r\n\t\t\t\"uniform samplerCube tCube;\",\r\n\r\n\t\t\t\"uniform vec2 uNormalScale;\",\r\n\r\n\t\t\t\"uniform bool useRefract;\",\r\n\t\t\t\"uniform float uRefractionRatio;\",\r\n\t\t\t\"uniform float uReflectivity;\",\r\n\r\n\t\t\t\"varying vec3 vTangent;\",\r\n\t\t\t\"varying vec3 vBinormal;\",\r\n\t\t\t\"varying vec3 vNormal;\",\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"uniform vec3 ambientLightColor;\",\r\n\r\n\t\t\t\"#if MAX_DIR_LIGHTS > 0\",\r\n\r\n\t\t\t\t\"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\",\r\n\t\t\t\t\"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#if MAX_HEMI_LIGHTS > 0\",\r\n\r\n\t\t\t\t\"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\",\r\n\t\t\t\t\"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\",\r\n\t\t\t\t\"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#if MAX_POINT_LIGHTS > 0\",\r\n\r\n\t\t\t\t\"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\",\r\n\t\t\t\t\"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\",\r\n\t\t\t\t\"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#if MAX_SPOT_LIGHTS > 0\",\r\n\r\n\t\t\t\t\"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\t\"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\t\"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\t\"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\t\"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\",\r\n\t\t\t\t\"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\t\"uniform vec3 wrapRGB;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"varying vec3 vWorldPosition;\",\r\n\t\t\t\"varying vec3 vViewPosition;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"gl_FragColor = vec4( vec3( 1.0 ), uOpacity );\",\r\n\r\n\t\t\t\t\"vec3 specularTex = vec3( 1.0 );\",\r\n\r\n\t\t\t\t\"vec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;\",\r\n\t\t\t\t\"normalTex.xy *= uNormalScale;\",\r\n\t\t\t\t\"normalTex = normalize( normalTex );\",\r\n\r\n\t\t\t\t\"if( enableDiffuse ) {\",\r\n\r\n\t\t\t\t\t\"#ifdef GAMMA_INPUT\",\r\n\r\n\t\t\t\t\t\t\"vec4 texelColor = texture2D( tDiffuse, vUv );\",\r\n\t\t\t\t\t\t\"texelColor.xyz *= texelColor.xyz;\",\r\n\r\n\t\t\t\t\t\t\"gl_FragColor = gl_FragColor * texelColor;\",\r\n\r\n\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\"gl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"if( enableAO ) {\",\r\n\r\n\t\t\t\t\t\"#ifdef GAMMA_INPUT\",\r\n\r\n\t\t\t\t\t\t\"vec4 aoColor = texture2D( tAO, vUv );\",\r\n\t\t\t\t\t\t\"aoColor.xyz *= aoColor.xyz;\",\r\n\r\n\t\t\t\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;\",\r\n\r\n\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"if( enableSpecular )\",\r\n\t\t\t\t\t\"specularTex = texture2D( tSpecular, vUv ).xyz;\",\r\n\r\n\t\t\t\t\"mat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );\",\r\n\t\t\t\t\"vec3 finalNormal = tsb * normalTex;\",\r\n\r\n\t\t\t\t\"#ifdef FLIP_SIDED\",\r\n\r\n\t\t\t\t\t\"finalNormal = -finalNormal;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"vec3 normal = normalize( finalNormal );\",\r\n\t\t\t\t\"vec3 viewPosition = normalize( vViewPosition );\",\r\n\r\n\t\t\t\t// point lights\r\n\r\n\t\t\t\t\"#if MAX_POINT_LIGHTS > 0\",\r\n\r\n\t\t\t\t\t\"vec3 pointDiffuse = vec3( 0.0 );\",\r\n\t\t\t\t\t\"vec3 pointSpecular = vec3( 0.0 );\",\r\n\r\n\t\t\t\t\t\"for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\",\r\n\t\t\t\t\t\t\"vec3 pointVector = lPosition.xyz + vViewPosition.xyz;\",\r\n\r\n\t\t\t\t\t\t\"float pointDistance = 1.0;\",\r\n\t\t\t\t\t\t\"if ( pointLightDistance[ i ] > 0.0 )\",\r\n\t\t\t\t\t\t\t\"pointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );\",\r\n\r\n\t\t\t\t\t\t\"pointVector = normalize( pointVector );\",\r\n\r\n\t\t\t\t\t\t// diffuse\r\n\r\n\t\t\t\t\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\t\t\t\t\"float pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );\",\r\n\t\t\t\t\t\t\t\"float pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );\",\r\n\r\n\t\t\t\t\t\t\t\"vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\",\r\n\r\n\t\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\t\"float pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );\",\r\n\r\n\t\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\t\t\"pointDiffuse += pointDistance * pointLightColor[ i ] * uDiffuseColor * pointDiffuseWeight;\",\r\n\r\n\t\t\t\t\t\t// specular\r\n\r\n\t\t\t\t\t\t\"vec3 pointHalfVector = normalize( pointVector + viewPosition );\",\r\n\t\t\t\t\t\t\"float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\",\r\n\t\t\t\t\t\t\"float pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, uShininess ), 0.0 );\",\r\n\r\n\t\t\t\t\t\t\"#ifdef PHYSICALLY_BASED_SHADING\",\r\n\r\n\t\t\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\r\n\r\n\t\t\t\t\t\t\t\"float specularNormalization = ( uShininess + 2.0001 ) / 8.0;\",\r\n\r\n\t\t\t\t\t\t\t\"vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( pointVector, pointHalfVector ), 5.0 );\",\r\n\t\t\t\t\t\t\t\"pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;\",\r\n\r\n\t\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\t\"pointSpecular += pointDistance * pointLightColor[ i ] * uSpecularColor * pointSpecularWeight * pointDiffuseWeight;\",\r\n\r\n\t\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t// spot lights\r\n\r\n\t\t\t\t\"#if MAX_SPOT_LIGHTS > 0\",\r\n\r\n\t\t\t\t\t\"vec3 spotDiffuse = vec3( 0.0 );\",\r\n\t\t\t\t\t\"vec3 spotSpecular = vec3( 0.0 );\",\r\n\r\n\t\t\t\t\t\"for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\",\r\n\t\t\t\t\t\t\"vec3 spotVector = lPosition.xyz + vViewPosition.xyz;\",\r\n\r\n\t\t\t\t\t\t\"float spotDistance = 1.0;\",\r\n\t\t\t\t\t\t\"if ( spotLightDistance[ i ] > 0.0 )\",\r\n\t\t\t\t\t\t\t\"spotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );\",\r\n\r\n\t\t\t\t\t\t\"spotVector = normalize( spotVector );\",\r\n\r\n\t\t\t\t\t\t\"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\",\r\n\r\n\t\t\t\t\t\t\"if ( spotEffect > spotLightAngleCos[ i ] ) {\",\r\n\r\n\t\t\t\t\t\t\t\"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\",\r\n\r\n\t\t\t\t\t\t\t// diffuse\r\n\r\n\t\t\t\t\t\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\t\t\t\t\t\"float spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );\",\r\n\t\t\t\t\t\t\t\t\"float spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );\",\r\n\r\n\t\t\t\t\t\t\t\t\"vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\",\r\n\r\n\t\t\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\t\t\"float spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );\",\r\n\r\n\t\t\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\t\t\t\"spotDiffuse += spotDistance * spotLightColor[ i ] * uDiffuseColor * spotDiffuseWeight * spotEffect;\",\r\n\r\n\t\t\t\t\t\t\t// specular\r\n\r\n\t\t\t\t\t\t\t\"vec3 spotHalfVector = normalize( spotVector + viewPosition );\",\r\n\t\t\t\t\t\t\t\"float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\",\r\n\t\t\t\t\t\t\t\"float spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, uShininess ), 0.0 );\",\r\n\r\n\t\t\t\t\t\t\t\"#ifdef PHYSICALLY_BASED_SHADING\",\r\n\r\n\t\t\t\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\r\n\r\n\t\t\t\t\t\t\t\t\"float specularNormalization = ( uShininess + 2.0001 ) / 8.0;\",\r\n\r\n\t\t\t\t\t\t\t\t\"vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( spotVector, spotHalfVector ), 5.0 );\",\r\n\t\t\t\t\t\t\t\t\"spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;\",\r\n\r\n\t\t\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\t\t\"spotSpecular += spotDistance * spotLightColor[ i ] * uSpecularColor * spotSpecularWeight * spotDiffuseWeight * spotEffect;\",\r\n\r\n\t\t\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t// directional lights\r\n\r\n\t\t\t\t\"#if MAX_DIR_LIGHTS > 0\",\r\n\r\n\t\t\t\t\t\"vec3 dirDiffuse = vec3( 0.0 );\",\r\n\t\t\t\t\t\"vec3 dirSpecular = vec3( 0.0 );\",\r\n\r\n\t\t\t\t\t\"for( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {\",\r\n\r\n\t\t\t\t\t\t\"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\",\r\n\t\t\t\t\t\t\"vec3 dirVector = normalize( lDirection.xyz );\",\r\n\r\n\t\t\t\t\t\t// diffuse\r\n\r\n\t\t\t\t\t\t\"#ifdef WRAP_AROUND\",\r\n\r\n\t\t\t\t\t\t\t\"float directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );\",\r\n\t\t\t\t\t\t\t\"float directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );\",\r\n\r\n\t\t\t\t\t\t\t\"vec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );\",\r\n\r\n\t\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\t\"float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );\",\r\n\r\n\t\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\t\t\"dirDiffuse += directionalLightColor[ i ] * uDiffuseColor * dirDiffuseWeight;\",\r\n\r\n\t\t\t\t\t\t// specular\r\n\r\n\t\t\t\t\t\t\"vec3 dirHalfVector = normalize( dirVector + viewPosition );\",\r\n\t\t\t\t\t\t\"float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\",\r\n\t\t\t\t\t\t\"float dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, uShininess ), 0.0 );\",\r\n\r\n\t\t\t\t\t\t\"#ifdef PHYSICALLY_BASED_SHADING\",\r\n\r\n\t\t\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\r\n\r\n\t\t\t\t\t\t\t\"float specularNormalization = ( uShininess + 2.0001 ) / 8.0;\",\r\n\r\n\t\t\t\t\t\t\t\"vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );\",\r\n\t\t\t\t\t\t\t\"dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\",\r\n\r\n\t\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\t\"dirSpecular += directionalLightColor[ i ] * uSpecularColor * dirSpecularWeight * dirDiffuseWeight;\",\r\n\r\n\t\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t// hemisphere lights\r\n\r\n\t\t\t\t\"#if MAX_HEMI_LIGHTS > 0\",\r\n\r\n\t\t\t\t\t\"vec3 hemiDiffuse  = vec3( 0.0 );\",\r\n\t\t\t\t\t\"vec3 hemiSpecular = vec3( 0.0 );\" ,\r\n\r\n\t\t\t\t\t\"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\",\r\n\r\n\t\t\t\t\t\t\"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\",\r\n\t\t\t\t\t\t\"vec3 lVector = normalize( lDirection.xyz );\",\r\n\r\n\t\t\t\t\t\t// diffuse\r\n\r\n\t\t\t\t\t\t\"float dotProduct = dot( normal, lVector );\",\r\n\t\t\t\t\t\t\"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\",\r\n\r\n\t\t\t\t\t\t\"vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\",\r\n\r\n\t\t\t\t\t\t\"hemiDiffuse += uDiffuseColor * hemiColor;\",\r\n\r\n\t\t\t\t\t\t// specular (sky light)\r\n\r\n\r\n\t\t\t\t\t\t\"vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\",\r\n\t\t\t\t\t\t\"float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\",\r\n\t\t\t\t\t\t\"float hemiSpecularWeightSky = specularTex.r * max( pow( hemiDotNormalHalfSky, uShininess ), 0.0 );\",\r\n\r\n\t\t\t\t\t\t// specular (ground light)\r\n\r\n\t\t\t\t\t\t\"vec3 lVectorGround = -lVector;\",\r\n\r\n\t\t\t\t\t\t\"vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\",\r\n\t\t\t\t\t\t\"float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\",\r\n\t\t\t\t\t\t\"float hemiSpecularWeightGround = specularTex.r * max( pow( hemiDotNormalHalfGround, uShininess ), 0.0 );\",\r\n\r\n\t\t\t\t\t\t\"#ifdef PHYSICALLY_BASED_SHADING\",\r\n\r\n\t\t\t\t\t\t\t\"float dotProductGround = dot( normal, lVectorGround );\",\r\n\r\n\t\t\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\r\n\r\n\t\t\t\t\t\t\t\"float specularNormalization = ( uShininess + 2.0001 ) / 8.0;\",\r\n\r\n\t\t\t\t\t\t\t\"vec3 schlickSky = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );\",\r\n\t\t\t\t\t\t\t\"vec3 schlickGround = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );\",\r\n\t\t\t\t\t\t\t\"hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\",\r\n\r\n\t\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\t\"hemiSpecular += uSpecularColor * hemiColor * ( hemiSpecularWeightSky + hemiSpecularWeightGround ) * hemiDiffuseWeight;\",\r\n\r\n\t\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t// all lights contribution summation\r\n\r\n\t\t\t\t\"vec3 totalDiffuse = vec3( 0.0 );\",\r\n\t\t\t\t\"vec3 totalSpecular = vec3( 0.0 );\",\r\n\r\n\t\t\t\t\"#if MAX_DIR_LIGHTS > 0\",\r\n\r\n\t\t\t\t\t\"totalDiffuse += dirDiffuse;\",\r\n\t\t\t\t\t\"totalSpecular += dirSpecular;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"#if MAX_HEMI_LIGHTS > 0\",\r\n\r\n\t\t\t\t\t\"totalDiffuse += hemiDiffuse;\",\r\n\t\t\t\t\t\"totalSpecular += hemiSpecular;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"#if MAX_POINT_LIGHTS > 0\",\r\n\r\n\t\t\t\t\t\"totalDiffuse += pointDiffuse;\",\r\n\t\t\t\t\t\"totalSpecular += pointSpecular;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"#if MAX_SPOT_LIGHTS > 0\",\r\n\r\n\t\t\t\t\t\"totalDiffuse += spotDiffuse;\",\r\n\t\t\t\t\t\"totalSpecular += spotSpecular;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"#ifdef METAL\",\r\n\r\n\t\t\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * uAmbientColor + totalSpecular );\",\r\n\r\n\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * uAmbientColor ) + totalSpecular;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"if ( enableReflection ) {\",\r\n\r\n\t\t\t\t\t\"vec3 vReflect;\",\r\n\t\t\t\t\t\"vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\",\r\n\r\n\t\t\t\t\t\"if ( useRefract ) {\",\r\n\r\n\t\t\t\t\t\t\"vReflect = refract( cameraToVertex, normal, uRefractionRatio );\",\r\n\r\n\t\t\t\t\t\"} else {\",\r\n\r\n\t\t\t\t\t\t\"vReflect = reflect( cameraToVertex, normal );\",\r\n\r\n\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\t\"vec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\",\r\n\r\n\t\t\t\t\t\"#ifdef GAMMA_INPUT\",\r\n\r\n\t\t\t\t\t\t\"cubeColor.xyz *= cubeColor.xyz;\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\t\"gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * uReflectivity );\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"attribute vec4 tangent;\",\r\n\r\n\t\t\t\"uniform vec2 uOffset;\",\r\n\t\t\t\"uniform vec2 uRepeat;\",\r\n\r\n\t\t\t\"uniform bool enableDisplacement;\",\r\n\r\n\t\t\t\"#ifdef VERTEX_TEXTURES\",\r\n\r\n\t\t\t\t\"uniform sampler2D tDisplacement;\",\r\n\t\t\t\t\"uniform float uDisplacementScale;\",\r\n\t\t\t\t\"uniform float uDisplacementBias;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"varying vec3 vTangent;\",\r\n\t\t\t\"varying vec3 vBinormal;\",\r\n\t\t\t\"varying vec3 vNormal;\",\r\n\t\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\t\"varying vec3 vWorldPosition;\",\r\n\t\t\t\"varying vec3 vViewPosition;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\r\n\r\n\t\t\t\t// normal, tangent and binormal vectors\r\n\r\n\t\t\t\t\"#ifdef USE_SKINNING\",\r\n\r\n\t\t\t\t\t\"vNormal = normalize( normalMatrix * skinnedNormal.xyz );\",\r\n\r\n\t\t\t\t\t\"vec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );\",\r\n\t\t\t\t\t\"vTangent = normalize( normalMatrix * skinnedTangent.xyz );\",\r\n\r\n\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\"vNormal = normalize( normalMatrix * normal );\",\r\n\t\t\t\t\t\"vTangent = normalize( normalMatrix * tangent.xyz );\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"vBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );\",\r\n\r\n\t\t\t\t\"vUv = uv * uRepeat + uOffset;\",\r\n\r\n\t\t\t\t// displacement mapping\r\n\r\n\t\t\t\t\"vec3 displacedPosition;\",\r\n\r\n\t\t\t\t\"#ifdef VERTEX_TEXTURES\",\r\n\r\n\t\t\t\t\t\"if ( enableDisplacement ) {\",\r\n\r\n\t\t\t\t\t\t\"vec3 dv = texture2D( tDisplacement, uv ).xyz;\",\r\n\t\t\t\t\t\t\"float df = uDisplacementScale * dv.x + uDisplacementBias;\",\r\n\t\t\t\t\t\t\"displacedPosition = position + normalize( normal ) * df;\",\r\n\r\n\t\t\t\t\t\"} else {\",\r\n\r\n\t\t\t\t\t\t\"#ifdef USE_SKINNING\",\r\n\r\n\t\t\t\t\t\t\t\"vec4 skinVertex = vec4( position, 1.0 );\",\r\n\r\n\t\t\t\t\t\t\t\"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;\",\r\n\t\t\t\t\t\t\t\"skinned \t  += boneMatY * skinVertex * skinWeight.y;\",\r\n\r\n\t\t\t\t\t\t\t\"displacedPosition  = skinned.xyz;\",\r\n\r\n\t\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\t\"displacedPosition = position;\",\r\n\r\n\t\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\"#ifdef USE_SKINNING\",\r\n\r\n\t\t\t\t\t\t\"vec4 skinVertex = vec4( position, 1.0 );\",\r\n\r\n\t\t\t\t\t\t\"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;\",\r\n\t\t\t\t\t\t\"skinned \t  += boneMatY * skinVertex * skinWeight.y;\",\r\n\r\n\t\t\t\t\t\t\"displacedPosition  = skinned.xyz;\",\r\n\r\n\t\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\t\"displacedPosition = position;\",\r\n\r\n\t\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\t//\r\n\r\n\t\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );\",\r\n\t\t\t\t\"vec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );\",\r\n\r\n\t\t\t\t\"gl_Position = projectionMatrix * mvPosition;\",\r\n\r\n\t\t\t\t//\r\n\r\n\t\t\t\t\"vWorldPosition = worldPosition.xyz;\",\r\n\t\t\t\t\"vViewPosition = -mvPosition.xyz;\",\r\n\r\n\t\t\t\t// shadows\r\n\r\n\t\t\t\t\"#ifdef USE_SHADOWMAP\",\r\n\r\n\t\t\t\t\t\"for( int i = 0; i < MAX_SHADOWS; i ++ ) {\",\r\n\r\n\t\t\t\t\t\t\"vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\",\r\n\r\n\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t/* -------------------------------------------------------------------------\r\n\t//\tCube map shader\r\n\t ------------------------------------------------------------------------- */\r\n\r\n\t'cube': {\r\n\r\n\t\tuniforms: { \"tCube\": { type: \"t\", value: null },\r\n\t\t\t\t\t\"tFlip\": { type: \"f\", value: -1 } },\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec3 vWorldPosition;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\",\r\n\t\t\t\t\"vWorldPosition = worldPosition.xyz;\",\r\n\r\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform samplerCube tCube;\",\r\n\t\t\t\"uniform float tFlip;\",\r\n\r\n\t\t\t\"varying vec3 vWorldPosition;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t// Depth encoding into RGBA texture\r\n\t// \tbased on SpiderGL shadow map example\r\n\t// \t\thttp://spidergl.org/example.php?id=6\r\n\t// \toriginally from\r\n\t//\t\thttp://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD\r\n\t// \tsee also here:\r\n\t//\t\thttp://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\r\n\r\n\t'depthRGBA': {\r\n\r\n\t\tuniforms: {},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"vec4 pack_depth( const in float depth ) {\",\r\n\r\n\t\t\t\t\"const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\",\r\n\t\t\t\t\"const vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\",\r\n\t\t\t\t\"vec4 res = fract( depth * bit_shift );\",\r\n\t\t\t\t\"res -= res.xxyz * bit_mask;\",\r\n\t\t\t\t\"return res;\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\",\r\n\r\n\t\t\t\t//\"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );\",\r\n\t\t\t\t//\"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );\",\r\n\t\t\t\t//\"gl_FragData[ 0 ] = pack_depth( z );\",\r\n\t\t\t\t//\"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t}\r\n\r\n};\r\n/**\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author szimek / https://github.com/szimek/\r\n */\r\n\r\nTHREE.WebGLRenderer = function ( parameters ) {\r\n\r\n\tconsole.log( 'THREE.WebGLRenderer', THREE.REVISION );\r\n\r\n\tparameters = parameters || {};\r\n\r\n\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),\r\n\r\n\t_precision = parameters.precision !== undefined ? parameters.precision : 'highp',\r\n\r\n\t_alpha = parameters.alpha !== undefined ? parameters.alpha : true,\r\n\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\r\n\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\r\n\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\r\n\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,\r\n\r\n\t_clearColor = parameters.clearColor !== undefined ? new THREE.Color( parameters.clearColor ) : new THREE.Color( 0x000000 ),\r\n\t_clearAlpha = parameters.clearAlpha !== undefined ? parameters.clearAlpha : 0;\r\n\r\n\t// public properties\r\n\r\n\tthis.domElement = _canvas;\r\n\tthis.context = null;\r\n\tthis.devicePixelRatio = parameters.devicePixelRatio !== undefined\r\n\t\t\t\t? parameters.devicePixelRatio\r\n\t\t\t\t: window.devicePixelRatio !== undefined\r\n\t\t\t\t\t? window.devicePixelRatio\r\n\t\t\t\t\t: 1;\r\n\r\n\t// clearing\r\n\r\n\tthis.autoClear = true;\r\n\tthis.autoClearColor = true;\r\n\tthis.autoClearDepth = true;\r\n\tthis.autoClearStencil = true;\r\n\r\n\t// scene graph\r\n\r\n\tthis.sortObjects = true;\r\n\r\n\tthis.autoUpdateObjects = true;\r\n\tthis.autoUpdateScene = true;\r\n\r\n\t// physically based shading\r\n\r\n\tthis.gammaInput = false;\r\n\tthis.gammaOutput = false;\r\n\tthis.physicallyBasedShading = false;\r\n\r\n\t// shadow map\r\n\r\n\tthis.shadowMapEnabled = false;\r\n\tthis.shadowMapAutoUpdate = true;\r\n\tthis.shadowMapType = THREE.PCFShadowMap;\r\n\tthis.shadowMapCullFace = THREE.CullFaceFront;\r\n\tthis.shadowMapDebug = false;\r\n\tthis.shadowMapCascade = false;\r\n\r\n\t// morphs\r\n\r\n\tthis.maxMorphTargets = 8;\r\n\tthis.maxMorphNormals = 4;\r\n\r\n\t// flags\r\n\r\n\tthis.autoScaleCubemaps = true;\r\n\r\n\t// custom render plugins\r\n\r\n\tthis.renderPluginsPre = [];\r\n\tthis.renderPluginsPost = [];\r\n\r\n\t// info\r\n\r\n\tthis.info = {\r\n\r\n\t\tmemory: {\r\n\r\n\t\t\tprograms: 0,\r\n\t\t\tgeometries: 0,\r\n\t\t\ttextures: 0\r\n\r\n\t\t},\r\n\r\n\t\trender: {\r\n\r\n\t\t\tcalls: 0,\r\n\t\t\tvertices: 0,\r\n\t\t\tfaces: 0,\r\n\t\t\tpoints: 0\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// internal properties\r\n\r\n\tvar _this = this,\r\n\r\n\t_programs = [],\r\n\t_programs_counter = 0,\r\n\r\n\t// internal state cache\r\n\r\n\t_currentProgram = null,\r\n\t_currentFramebuffer = null,\r\n\t_currentMaterialId = -1,\r\n\t_currentGeometryGroupHash = null,\r\n\t_currentCamera = null,\r\n\t_geometryGroupCounter = 0,\r\n\r\n\t_usedTextureUnits = 0,\r\n\r\n\t// GL state cache\r\n\r\n\t_oldDoubleSided = -1,\r\n\t_oldFlipSided = -1,\r\n\r\n\t_oldBlending = -1,\r\n\r\n\t_oldBlendEquation = -1,\r\n\t_oldBlendSrc = -1,\r\n\t_oldBlendDst = -1,\r\n\r\n\t_oldDepthTest = -1,\r\n\t_oldDepthWrite = -1,\r\n\r\n\t_oldPolygonOffset = null,\r\n\t_oldPolygonOffsetFactor = null,\r\n\t_oldPolygonOffsetUnits = null,\r\n\r\n\t_oldLineWidth = null,\r\n\r\n\t_viewportX = 0,\r\n\t_viewportY = 0,\r\n\t_viewportWidth = 0,\r\n\t_viewportHeight = 0,\r\n\t_currentWidth = 0,\r\n\t_currentHeight = 0,\r\n\r\n\t_enabledAttributes = {},\r\n\r\n\t// frustum\r\n\r\n\t_frustum = new THREE.Frustum(),\r\n\r\n\t // camera matrices cache\r\n\r\n\t_projScreenMatrix = new THREE.Matrix4(),\r\n\t_projScreenMatrixPS = new THREE.Matrix4(),\r\n\r\n\t_vector3 = new THREE.Vector3(),\r\n\r\n\t// light arrays cache\r\n\r\n\t_direction = new THREE.Vector3(),\r\n\r\n\t_lightsNeedUpdate = true,\r\n\r\n\t_lights = {\r\n\r\n\t\tambient: [ 0, 0, 0 ],\r\n\t\tdirectional: { length: 0, colors: new Array(), positions: new Array() },\r\n\t\tpoint: { length: 0, colors: new Array(), positions: new Array(), distances: new Array() },\r\n\t\tspot: { length: 0, colors: new Array(), positions: new Array(), distances: new Array(), directions: new Array(), anglesCos: new Array(), exponents: new Array() },\r\n\t\themi: { length: 0, skyColors: new Array(), groundColors: new Array(), positions: new Array() }\r\n\r\n\t};\r\n\r\n\t// initialize\r\n\r\n\tvar _gl;\r\n\r\n\tvar _glExtensionTextureFloat;\r\n\tvar _glExtensionStandardDerivatives;\r\n\tvar _glExtensionTextureFilterAnisotropic;\r\n\tvar _glExtensionCompressedTextureS3TC;\r\n\r\n\tinitGL();\r\n\r\n\tsetDefaultGLState();\r\n\r\n\tthis.context = _gl;\r\n\r\n\t// GPU capabilities\r\n\r\n\tvar _maxTextures = _gl.getParameter( _gl.MAX_TEXTURE_IMAGE_UNITS );\r\n\tvar _maxVertexTextures = _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\r\n\tvar _maxTextureSize = _gl.getParameter( _gl.MAX_TEXTURE_SIZE );\r\n\tvar _maxCubemapSize = _gl.getParameter( _gl.MAX_CUBE_MAP_TEXTURE_SIZE );\r\n\r\n\tvar _maxAnisotropy = _glExtensionTextureFilterAnisotropic ? _gl.getParameter( _glExtensionTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT ) : 0;\r\n\r\n\tvar _supportsVertexTextures = ( _maxVertexTextures > 0 );\r\n\tvar _supportsBoneTextures = _supportsVertexTextures && _glExtensionTextureFloat;\r\n\r\n\tvar _compressedTextureFormats = _glExtensionCompressedTextureS3TC ? _gl.getParameter( _gl.COMPRESSED_TEXTURE_FORMATS ) : [];\r\n\r\n\t//\r\n\r\n\tvar _vertexShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_FLOAT );\r\n\tvar _vertexShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_FLOAT );\r\n\tvar _vertexShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.LOW_FLOAT );\r\n\r\n\tvar _fragmentShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_FLOAT );\r\n\tvar _fragmentShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_FLOAT );\r\n\tvar _fragmentShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.LOW_FLOAT );\r\n\r\n\tvar _vertexShaderPrecisionHighpInt = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_INT );\r\n\tvar _vertexShaderPrecisionMediumpInt = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_INT );\r\n\tvar _vertexShaderPrecisionLowpInt = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.LOW_INT );\r\n\r\n\tvar _fragmentShaderPrecisionHighpInt = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_INT );\r\n\tvar _fragmentShaderPrecisionMediumpInt = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_INT );\r\n\tvar _fragmentShaderPrecisionLowpInt = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.LOW_INT );\r\n\r\n\t// clamp precision to maximum available\r\n\r\n\tvar highpAvailable = _vertexShaderPrecisionHighpFloat.precision > 0 && _fragmentShaderPrecisionHighpFloat.precision > 0;\r\n\tvar mediumpAvailable = _vertexShaderPrecisionMediumpFloat.precision > 0 && _fragmentShaderPrecisionMediumpFloat.precision > 0;\r\n\r\n\tif ( _precision === \"highp\" && ! highpAvailable ) {\r\n\r\n\t\tif ( mediumpAvailable ) {\r\n\r\n\t\t\t_precision = \"mediump\";\r\n\t\t\tconsole.warn( \"WebGLRenderer: highp not supported, using mediump\" );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_precision = \"lowp\";\r\n\t\t\tconsole.warn( \"WebGLRenderer: highp and mediump not supported, using lowp\" );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tif ( _precision === \"mediump\" && ! mediumpAvailable ) {\r\n\r\n\t\t_precision = \"lowp\";\r\n\t\tconsole.warn( \"WebGLRenderer: mediump not supported, using lowp\" );\r\n\r\n\t}\r\n\r\n\t// API\r\n\r\n\tthis.getContext = function () {\r\n\r\n\t\treturn _gl;\r\n\r\n\t};\r\n\r\n\tthis.supportsVertexTextures = function () {\r\n\r\n\t\treturn _supportsVertexTextures;\r\n\r\n\t};\r\n\r\n\tthis.supportsFloatTextures = function () {\r\n\r\n\t\treturn _glExtensionTextureFloat;\r\n\r\n\t};\r\n\t\r\n\tthis.supportsStandardDerivatives = function () {\r\n\r\n\t\treturn _glExtensionStandardDerivatives;\r\n\r\n\t};\r\n\t\r\n\tthis.supportsCompressedTextureS3TC = function () {\r\n\r\n\t\treturn _glExtensionCompressedTextureS3TC;\r\n\r\n\t};\r\n\t\r\n\tthis.getMaxAnisotropy  = function () {\r\n\r\n\t\treturn _maxAnisotropy;\r\n\r\n\t};\r\n\r\n\tthis.getPrecision = function () {\r\n\r\n\t\treturn _precision;\r\n\r\n\t};\r\n\r\n\tthis.setSize = function ( width, height ) {\r\n\r\n\t\t_canvas.width = width * this.devicePixelRatio;\r\n\t\t_canvas.height = height * this.devicePixelRatio;\r\n\r\n\t\t_canvas.style.width = width + 'px';\r\n\t\t_canvas.style.height = height + 'px';\r\n\r\n\t\tthis.setViewport( 0, 0, _canvas.width, _canvas.height );\r\n\r\n\t};\r\n\r\n\tthis.setViewport = function ( x, y, width, height ) {\r\n\r\n\t\t_viewportX = x !== undefined ? x : 0;\r\n\t\t_viewportY = y !== undefined ? y : 0;\r\n\r\n\t\t_viewportWidth = width !== undefined ? width : _canvas.width;\r\n\t\t_viewportHeight = height !== undefined ? height : _canvas.height;\r\n\r\n\t\t_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );\r\n\r\n\t};\r\n\r\n\tthis.setScissor = function ( x, y, width, height ) {\r\n\r\n\t\t_gl.scissor( x, y, width, height );\r\n\r\n\t};\r\n\r\n\tthis.enableScissorTest = function ( enable ) {\r\n\r\n\t\tenable ? _gl.enable( _gl.SCISSOR_TEST ) : _gl.disable( _gl.SCISSOR_TEST );\r\n\r\n\t};\r\n\r\n\t// Clearing\r\n\r\n\tthis.setClearColorHex = function ( hex, alpha ) {\r\n\r\n\t\t_clearColor.setHex( hex );\r\n\t\t_clearAlpha = alpha;\r\n\r\n\t\t_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\r\n\t};\r\n\r\n\tthis.setClearColor = function ( color, alpha ) {\r\n\r\n\t\t_clearColor.copy( color );\r\n\t\t_clearAlpha = alpha;\r\n\r\n\t\t_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\r\n\t};\r\n\r\n\tthis.getClearColor = function () {\r\n\r\n\t\treturn _clearColor;\r\n\r\n\t};\r\n\r\n\tthis.getClearAlpha = function () {\r\n\r\n\t\treturn _clearAlpha;\r\n\r\n\t};\r\n\r\n\tthis.clear = function ( color, depth, stencil ) {\r\n\r\n\t\tvar bits = 0;\r\n\r\n\t\tif ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\r\n\t\tif ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\r\n\t\tif ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\r\n\r\n\t\t_gl.clear( bits );\r\n\r\n\t};\r\n\r\n\tthis.clearTarget = function ( renderTarget, color, depth, stencil ) {\r\n\r\n\t\tthis.setRenderTarget( renderTarget );\r\n\t\tthis.clear( color, depth, stencil );\r\n\r\n\t};\r\n\r\n\t// Plugins\r\n\r\n\tthis.addPostPlugin = function ( plugin ) {\r\n\r\n\t\tplugin.init( this );\r\n\t\tthis.renderPluginsPost.push( plugin );\r\n\r\n\t};\r\n\r\n\tthis.addPrePlugin = function ( plugin ) {\r\n\r\n\t\tplugin.init( this );\r\n\t\tthis.renderPluginsPre.push( plugin );\r\n\r\n\t};\r\n\r\n\t// Rendering\r\n\r\n\tthis.updateShadowMap = function ( scene, camera ) {\r\n\r\n\t\t_currentProgram = null;\r\n\t\t_oldBlending = -1;\r\n\t\t_oldDepthTest = -1;\r\n\t\t_oldDepthWrite = -1;\r\n\t\t_currentGeometryGroupHash = -1;\r\n\t\t_currentMaterialId = -1;\r\n\t\t_lightsNeedUpdate = true;\r\n\t\t_oldDoubleSided = -1;\r\n\t\t_oldFlipSided = -1;\r\n\r\n\t\tthis.shadowMapPlugin.update( scene, camera );\r\n\r\n\t};\r\n\r\n\t// Internal functions\r\n\r\n\t// Buffer allocation\r\n\r\n\tfunction createParticleBuffers ( geometry ) {\r\n\r\n\t\tgeometry.__webglVertexBuffer = _gl.createBuffer();\r\n\t\tgeometry.__webglColorBuffer = _gl.createBuffer();\r\n\r\n\t\t_this.info.memory.geometries ++;\r\n\r\n\t};\r\n\r\n\tfunction createLineBuffers ( geometry ) {\r\n\r\n\t\tgeometry.__webglVertexBuffer = _gl.createBuffer();\r\n\t\tgeometry.__webglColorBuffer = _gl.createBuffer();\r\n\t\tgeometry.__webglLineDistanceBuffer = _gl.createBuffer();\r\n\r\n\t\t_this.info.memory.geometries ++;\r\n\r\n\t};\r\n\r\n\tfunction createRibbonBuffers ( geometry ) {\r\n\r\n\t\tgeometry.__webglVertexBuffer = _gl.createBuffer();\r\n\t\tgeometry.__webglColorBuffer = _gl.createBuffer();\r\n\t\tgeometry.__webglNormalBuffer = _gl.createBuffer();\r\n\r\n\t\t_this.info.memory.geometries ++;\r\n\r\n\t};\r\n\r\n\tfunction createMeshBuffers ( geometryGroup ) {\r\n\r\n\t\tgeometryGroup.__webglVertexBuffer = _gl.createBuffer();\r\n\t\tgeometryGroup.__webglNormalBuffer = _gl.createBuffer();\r\n\t\tgeometryGroup.__webglTangentBuffer = _gl.createBuffer();\r\n\t\tgeometryGroup.__webglColorBuffer = _gl.createBuffer();\r\n\t\tgeometryGroup.__webglUVBuffer = _gl.createBuffer();\r\n\t\tgeometryGroup.__webglUV2Buffer = _gl.createBuffer();\r\n\r\n\t\tgeometryGroup.__webglSkinIndicesBuffer = _gl.createBuffer();\r\n\t\tgeometryGroup.__webglSkinWeightsBuffer = _gl.createBuffer();\r\n\r\n\t\tgeometryGroup.__webglFaceBuffer = _gl.createBuffer();\r\n\t\tgeometryGroup.__webglLineBuffer = _gl.createBuffer();\r\n\r\n\t\tvar m, ml;\r\n\r\n\t\tif ( geometryGroup.numMorphTargets ) {\r\n\r\n\t\t\tgeometryGroup.__webglMorphTargetsBuffers = [];\r\n\r\n\t\t\tfor ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {\r\n\r\n\t\t\t\tgeometryGroup.__webglMorphTargetsBuffers.push( _gl.createBuffer() );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometryGroup.numMorphNormals ) {\r\n\r\n\t\t\tgeometryGroup.__webglMorphNormalsBuffers = [];\r\n\r\n\t\t\tfor ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {\r\n\r\n\t\t\t\tgeometryGroup.__webglMorphNormalsBuffers.push( _gl.createBuffer() );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t_this.info.memory.geometries ++;\r\n\r\n\t};\r\n\r\n\t// Events\r\n\r\n\tvar onGeometryDispose = function ( event ) {\r\n\r\n\t\tvar geometry = event.target;\r\n\r\n\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\r\n\r\n\t\tdeallocateGeometry( geometry );\r\n\r\n\t\t_this.info.memory.geometries --;\r\n\r\n\t};\r\n\r\n\tvar onTextureDispose = function ( event ) {\r\n\r\n\t\tvar texture = event.target;\r\n\r\n\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\r\n\r\n\t\tdeallocateTexture( texture );\r\n\r\n\t\t_this.info.memory.textures --;\r\n\r\n\r\n\t};\r\n\r\n\tvar onRenderTargetDispose = function ( event ) {\r\n\r\n\t\tvar renderTarget = event.target;\r\n\r\n\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\r\n\r\n\t\tdeallocateRenderTarget( renderTarget );\r\n\r\n\t\t_this.info.memory.textures --;\r\n\r\n\t};\r\n\r\n\tvar onMaterialDispose = function ( event ) {\r\n\r\n\t\tvar material = event.target;\r\n\r\n\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\r\n\r\n\t\tdeallocateMaterial( material );\r\n\r\n\t};\r\n\r\n\t// Buffer deallocation\r\n\r\n\tvar deallocateGeometry = function ( geometry ) {\r\n\r\n\t\tgeometry.__webglInit = undefined;\r\n\r\n\t\tif ( geometry.__webglVertexBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglVertexBuffer );\r\n\t\tif ( geometry.__webglNormalBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglNormalBuffer );\r\n\t\tif ( geometry.__webglTangentBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglTangentBuffer );\r\n\t\tif ( geometry.__webglColorBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglColorBuffer );\r\n\t\tif ( geometry.__webglUVBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglUVBuffer );\r\n\t\tif ( geometry.__webglUV2Buffer !== undefined ) _gl.deleteBuffer( geometry.__webglUV2Buffer );\r\n\r\n\t\tif ( geometry.__webglSkinIndicesBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglSkinIndicesBuffer );\r\n\t\tif ( geometry.__webglSkinWeightsBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglSkinWeightsBuffer );\r\n\r\n\t\tif ( geometry.__webglFaceBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglFaceBuffer );\r\n\t\tif ( geometry.__webglLineBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglLineBuffer );\r\n\r\n\t\tif ( geometry.__webglLineDistanceBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglLineDistanceBuffer );\r\n\r\n\t\t// geometry groups\r\n\r\n\t\tif ( geometry.geometryGroups !== undefined ) {\r\n\r\n\t\t\tfor ( var g in geometry.geometryGroups ) {\r\n\r\n\t\t\t\tvar geometryGroup = geometry.geometryGroups[ g ];\r\n\r\n\t\t\t\tif ( geometryGroup.numMorphTargets !== undefined ) {\r\n\r\n\t\t\t\t\tfor ( var m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {\r\n\r\n\t\t\t\t\t\t_gl.deleteBuffer( geometryGroup.__webglMorphTargetsBuffers[ m ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( geometryGroup.numMorphNormals !== undefined ) {\r\n\r\n\t\t\t\t\tfor ( var m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {\r\n\r\n\t\t\t\t\t\t_gl.deleteBuffer( geometryGroup.__webglMorphNormalsBuffers[ m ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdeleteCustomAttributesBuffers( geometryGroup );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tdeleteCustomAttributesBuffers( geometry );\r\n\r\n\t};\r\n\r\n\tvar deallocateTexture = function ( texture ) {\r\n\r\n\t\tif ( texture.image && texture.image.__webglTextureCube ) {\r\n\r\n\t\t\t// cube texture\r\n\r\n\t\t\t_gl.deleteTexture( texture.image.__webglTextureCube );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// 2D texture\r\n\r\n\t\t\tif ( ! texture.__webglInit ) return;\r\n\r\n\t\t\ttexture.__webglInit = false;\r\n\t\t\t_gl.deleteTexture( texture.__webglTexture );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar deallocateRenderTarget = function ( renderTarget ) {\r\n\r\n\t\tif ( !renderTarget || ! renderTarget.__webglTexture ) return;\r\n\r\n\t\t_gl.deleteTexture( renderTarget.__webglTexture );\r\n\r\n\t\tif ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {\r\n\r\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\t_gl.deleteFramebuffer( renderTarget.__webglFramebuffer[ i ] );\r\n\t\t\t\t_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_gl.deleteFramebuffer( renderTarget.__webglFramebuffer );\r\n\t\t\t_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar deallocateMaterial = function ( material ) {\r\n\r\n\t\tvar program = material.program;\r\n\r\n\t\tif ( program === undefined ) return;\r\n\r\n\t\tmaterial.program = undefined;\r\n\r\n\t\t// only deallocate GL program if this was the last use of shared program\r\n\t\t// assumed there is only single copy of any program in the _programs list\r\n\t\t// (that's how it's constructed)\r\n\r\n\t\tvar i, il, programInfo;\r\n\t\tvar deleteProgram = false;\r\n\r\n\t\tfor ( i = 0, il = _programs.length; i < il; i ++ ) {\r\n\r\n\t\t\tprogramInfo = _programs[ i ];\r\n\r\n\t\t\tif ( programInfo.program === program ) {\r\n\r\n\t\t\t\tprogramInfo.usedTimes --;\r\n\r\n\t\t\t\tif ( programInfo.usedTimes === 0 ) {\r\n\r\n\t\t\t\t\tdeleteProgram = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( deleteProgram === true ) {\r\n\r\n\t\t\t// avoid using array.splice, this is costlier than creating new array from scratch\r\n\r\n\t\t\tvar newPrograms = [];\r\n\r\n\t\t\tfor ( i = 0, il = _programs.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tprogramInfo = _programs[ i ];\r\n\r\n\t\t\t\tif ( programInfo.program !== program ) {\r\n\r\n\t\t\t\t\tnewPrograms.push( programInfo );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_programs = newPrograms;\r\n\r\n\t\t\t_gl.deleteProgram( program );\r\n\r\n\t\t\t_this.info.memory.programs --;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t//\r\n\r\n\t/*\r\n\tfunction deleteParticleBuffers ( geometry ) {\r\n\r\n\t\t_gl.deleteBuffer( geometry.__webglVertexBuffer );\r\n\t\t_gl.deleteBuffer( geometry.__webglColorBuffer );\r\n\r\n\t\tdeleteCustomAttributesBuffers( geometry );\r\n\r\n\t\t_this.info.memory.geometries --;\r\n\r\n\t};\r\n\r\n\tfunction deleteLineBuffers ( geometry ) {\r\n\r\n\t\t_gl.deleteBuffer( geometry.__webglVertexBuffer );\r\n\t\t_gl.deleteBuffer( geometry.__webglColorBuffer );\r\n\t\t_gl.deleteBuffer( geometry.__webglLineDistanceBuffer );\r\n\r\n\t\tdeleteCustomAttributesBuffers( geometry );\r\n\r\n\t\t_this.info.memory.geometries --;\r\n\r\n\t};\r\n\r\n\tfunction deleteRibbonBuffers ( geometry ) {\r\n\r\n\t\t_gl.deleteBuffer( geometry.__webglVertexBuffer );\r\n\t\t_gl.deleteBuffer( geometry.__webglColorBuffer );\r\n\t\t_gl.deleteBuffer( geometry.__webglNormalBuffer );\r\n\r\n\t\tdeleteCustomAttributesBuffers( geometry );\r\n\r\n\t\t_this.info.memory.geometries --;\r\n\r\n\t};\r\n\r\n\tfunction deleteMeshBuffers ( geometryGroup ) {\r\n\r\n\t\t_gl.deleteBuffer( geometryGroup.__webglVertexBuffer );\r\n\t\t_gl.deleteBuffer( geometryGroup.__webglNormalBuffer );\r\n\t\t_gl.deleteBuffer( geometryGroup.__webglTangentBuffer );\r\n\t\t_gl.deleteBuffer( geometryGroup.__webglColorBuffer );\r\n\t\t_gl.deleteBuffer( geometryGroup.__webglUVBuffer );\r\n\t\t_gl.deleteBuffer( geometryGroup.__webglUV2Buffer );\r\n\r\n\t\t_gl.deleteBuffer( geometryGroup.__webglSkinIndicesBuffer );\r\n\t\t_gl.deleteBuffer( geometryGroup.__webglSkinWeightsBuffer );\r\n\r\n\t\t_gl.deleteBuffer( geometryGroup.__webglFaceBuffer );\r\n\t\t_gl.deleteBuffer( geometryGroup.__webglLineBuffer );\r\n\r\n\t\tvar m, ml;\r\n\r\n\t\tif ( geometryGroup.numMorphTargets ) {\r\n\r\n\t\t\tfor ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {\r\n\r\n\t\t\t\t_gl.deleteBuffer( geometryGroup.__webglMorphTargetsBuffers[ m ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometryGroup.numMorphNormals ) {\r\n\r\n\t\t\tfor ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {\r\n\r\n\t\t\t\t_gl.deleteBuffer( geometryGroup.__webglMorphNormalsBuffers[ m ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tdeleteCustomAttributesBuffers( geometryGroup );\r\n\r\n\t\t_this.info.memory.geometries --;\r\n\r\n\t};\r\n\t*/\r\n\r\n\tfunction deleteCustomAttributesBuffers( geometry ) {\r\n\r\n\t\tif ( geometry.__webglCustomAttributesList ) {\r\n\r\n\t\t\tfor ( var id in geometry.__webglCustomAttributesList ) {\r\n\r\n\t\t\t\t_gl.deleteBuffer( geometry.__webglCustomAttributesList[ id ].buffer );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Buffer initialization\r\n\r\n\tfunction initCustomAttributes ( geometry, object ) {\r\n\r\n\t\tvar nvertices = geometry.vertices.length;\r\n\r\n\t\tvar material = object.material;\r\n\r\n\t\tif ( material.attributes ) {\r\n\r\n\t\t\tif ( geometry.__webglCustomAttributesList === undefined ) {\r\n\r\n\t\t\t\tgeometry.__webglCustomAttributesList = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var a in material.attributes ) {\r\n\r\n\t\t\t\tvar attribute = material.attributes[ a ];\r\n\r\n\t\t\t\tif ( !attribute.__webglInitialized || attribute.createUniqueBuffers ) {\r\n\r\n\t\t\t\t\tattribute.__webglInitialized = true;\r\n\r\n\t\t\t\t\tvar size = 1;\t\t// \"f\" and \"i\"\r\n\r\n\t\t\t\t\tif ( attribute.type === \"v2\" ) size = 2;\r\n\t\t\t\t\telse if ( attribute.type === \"v3\" ) size = 3;\r\n\t\t\t\t\telse if ( attribute.type === \"v4\" ) size = 4;\r\n\t\t\t\t\telse if ( attribute.type === \"c\"  ) size = 3;\r\n\r\n\t\t\t\t\tattribute.size = size;\r\n\r\n\t\t\t\t\tattribute.array = new Float32Array( nvertices * size );\r\n\r\n\t\t\t\t\tattribute.buffer = _gl.createBuffer();\r\n\t\t\t\t\tattribute.buffer.belongsToAttribute = a;\r\n\r\n\t\t\t\t\tattribute.needsUpdate = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.__webglCustomAttributesList.push( attribute );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction initParticleBuffers ( geometry, object ) {\r\n\r\n\t\tvar nvertices = geometry.vertices.length;\r\n\r\n\t\tgeometry.__vertexArray = new Float32Array( nvertices * 3 );\r\n\t\tgeometry.__colorArray = new Float32Array( nvertices * 3 );\r\n\r\n\t\tgeometry.__sortArray = [];\r\n\r\n\t\tgeometry.__webglParticleCount = nvertices;\r\n\r\n\t\tinitCustomAttributes ( geometry, object );\r\n\r\n\t};\r\n\r\n\tfunction initLineBuffers ( geometry, object ) {\r\n\r\n\t\tvar nvertices = geometry.vertices.length;\r\n\r\n\t\tgeometry.__vertexArray = new Float32Array( nvertices * 3 );\r\n\t\tgeometry.__colorArray = new Float32Array( nvertices * 3 );\r\n\t\tgeometry.__lineDistanceArray = new Float32Array( nvertices * 1 );\r\n\r\n\t\tgeometry.__webglLineCount = nvertices;\r\n\r\n\t\tinitCustomAttributes ( geometry, object );\r\n\r\n\t};\r\n\r\n\tfunction initRibbonBuffers ( geometry, object ) {\r\n\r\n\t\tvar nvertices = geometry.vertices.length;\r\n\r\n\t\tgeometry.__vertexArray = new Float32Array( nvertices * 3 );\r\n\t\tgeometry.__colorArray = new Float32Array( nvertices * 3 );\r\n\t\tgeometry.__normalArray = new Float32Array( nvertices * 3 );\r\n\r\n\t\tgeometry.__webglVertexCount = nvertices;\r\n\r\n\t\tinitCustomAttributes ( geometry, object );\r\n\r\n\t};\r\n\r\n\tfunction initMeshBuffers ( geometryGroup, object ) {\r\n\r\n\t\tvar geometry = object.geometry,\r\n\t\t\tfaces3 = geometryGroup.faces3,\r\n\t\t\tfaces4 = geometryGroup.faces4,\r\n\r\n\t\t\tnvertices = faces3.length * 3 + faces4.length * 4,\r\n\t\t\tntris     = faces3.length * 1 + faces4.length * 2,\r\n\t\t\tnlines    = faces3.length * 3 + faces4.length * 4,\r\n\r\n\t\t\tmaterial = getBufferMaterial( object, geometryGroup ),\r\n\r\n\t\t\tuvType = bufferGuessUVType( material ),\r\n\t\t\tnormalType = bufferGuessNormalType( material ),\r\n\t\t\tvertexColorType = bufferGuessVertexColorType( material );\r\n\r\n\t\t//console.log( \"uvType\", uvType, \"normalType\", normalType, \"vertexColorType\", vertexColorType, object, geometryGroup, material );\r\n\r\n\t\tgeometryGroup.__vertexArray = new Float32Array( nvertices * 3 );\r\n\r\n\t\tif ( normalType ) {\r\n\r\n\t\t\tgeometryGroup.__normalArray = new Float32Array( nvertices * 3 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.hasTangents ) {\r\n\r\n\t\t\tgeometryGroup.__tangentArray = new Float32Array( nvertices * 4 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( vertexColorType ) {\r\n\r\n\t\t\tgeometryGroup.__colorArray = new Float32Array( nvertices * 3 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( uvType ) {\r\n\r\n\t\t\tif ( geometry.faceUvs.length > 0 || geometry.faceVertexUvs.length > 0 ) {\r\n\r\n\t\t\t\tgeometryGroup.__uvArray = new Float32Array( nvertices * 2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( geometry.faceUvs.length > 1 || geometry.faceVertexUvs.length > 1 ) {\r\n\r\n\t\t\t\tgeometryGroup.__uv2Array = new Float32Array( nvertices * 2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.geometry.skinWeights.length && object.geometry.skinIndices.length ) {\r\n\r\n\t\t\tgeometryGroup.__skinIndexArray = new Float32Array( nvertices * 4 );\r\n\t\t\tgeometryGroup.__skinWeightArray = new Float32Array( nvertices * 4 );\r\n\r\n\t\t}\r\n\r\n\t\tgeometryGroup.__faceArray = new Uint16Array( ntris * 3 );\r\n\t\tgeometryGroup.__lineArray = new Uint16Array( nlines * 2 );\r\n\r\n\t\tvar m, ml;\r\n\r\n\t\tif ( geometryGroup.numMorphTargets ) {\r\n\r\n\t\t\tgeometryGroup.__morphTargetsArrays = [];\r\n\r\n\t\t\tfor ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {\r\n\r\n\t\t\t\tgeometryGroup.__morphTargetsArrays.push( new Float32Array( nvertices * 3 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometryGroup.numMorphNormals ) {\r\n\r\n\t\t\tgeometryGroup.__morphNormalsArrays = [];\r\n\r\n\t\t\tfor ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {\r\n\r\n\t\t\t\tgeometryGroup.__morphNormalsArrays.push( new Float32Array( nvertices * 3 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tgeometryGroup.__webglFaceCount = ntris * 3;\r\n\t\tgeometryGroup.__webglLineCount = nlines * 2;\r\n\r\n\r\n\t\t// custom attributes\r\n\r\n\t\tif ( material.attributes ) {\r\n\r\n\t\t\tif ( geometryGroup.__webglCustomAttributesList === undefined ) {\r\n\r\n\t\t\t\tgeometryGroup.__webglCustomAttributesList = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var a in material.attributes ) {\r\n\r\n\t\t\t\t// Do a shallow copy of the attribute object so different geometryGroup chunks use different\r\n\t\t\t\t// attribute buffers which are correctly indexed in the setMeshBuffers function\r\n\r\n\t\t\t\tvar originalAttribute = material.attributes[ a ];\r\n\r\n\t\t\t\tvar attribute = {};\r\n\r\n\t\t\t\tfor ( var property in originalAttribute ) {\r\n\r\n\t\t\t\t\tattribute[ property ] = originalAttribute[ property ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( !attribute.__webglInitialized || attribute.createUniqueBuffers ) {\r\n\r\n\t\t\t\t\tattribute.__webglInitialized = true;\r\n\r\n\t\t\t\t\tvar size = 1;\t\t// \"f\" and \"i\"\r\n\r\n\t\t\t\t\tif( attribute.type === \"v2\" ) size = 2;\r\n\t\t\t\t\telse if( attribute.type === \"v3\" ) size = 3;\r\n\t\t\t\t\telse if( attribute.type === \"v4\" ) size = 4;\r\n\t\t\t\t\telse if( attribute.type === \"c\"  ) size = 3;\r\n\r\n\t\t\t\t\tattribute.size = size;\r\n\r\n\t\t\t\t\tattribute.array = new Float32Array( nvertices * size );\r\n\r\n\t\t\t\t\tattribute.buffer = _gl.createBuffer();\r\n\t\t\t\t\tattribute.buffer.belongsToAttribute = a;\r\n\r\n\t\t\t\t\toriginalAttribute.needsUpdate = true;\r\n\t\t\t\t\tattribute.__original = originalAttribute;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometryGroup.__webglCustomAttributesList.push( attribute );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tgeometryGroup.__inittedArrays = true;\r\n\r\n\t};\r\n\r\n\tfunction getBufferMaterial( object, geometryGroup ) {\r\n\r\n\t\treturn object.material instanceof THREE.MeshFaceMaterial\r\n\t\t\t? object.material.materials[ geometryGroup.materialIndex ]\r\n\t\t\t: object.material;\r\n\r\n\t};\r\n\r\n\tfunction materialNeedsSmoothNormals ( material ) {\r\n\r\n\t\treturn material && material.shading !== undefined && material.shading === THREE.SmoothShading;\r\n\r\n\t};\r\n\r\n\tfunction bufferGuessNormalType ( material ) {\r\n\r\n\t\t// only MeshBasicMaterial and MeshDepthMaterial don't need normals\r\n\r\n\t\tif ( ( material instanceof THREE.MeshBasicMaterial && !material.envMap ) || material instanceof THREE.MeshDepthMaterial ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( materialNeedsSmoothNormals( material ) ) {\r\n\r\n\t\t\treturn THREE.SmoothShading;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn THREE.FlatShading;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction bufferGuessVertexColorType ( material ) {\r\n\r\n\t\tif ( material.vertexColors ) {\r\n\r\n\t\t\treturn material.vertexColors;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t};\r\n\r\n\tfunction bufferGuessUVType ( material ) {\r\n\r\n\t\t// material must use some texture to require uvs\r\n\r\n\t\tif ( material.map || material.lightMap || material.bumpMap || material.normalMap || material.specularMap || material instanceof THREE.ShaderMaterial ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t};\r\n\r\n\t//\r\n\r\n\tfunction initDirectBuffers( geometry ) {\r\n\r\n\t\tvar a, attribute, type;\r\n\r\n\t\tfor ( a in geometry.attributes ) {\r\n\r\n\t\t\tif ( a === \"index\" ) {\r\n\r\n\t\t\t\ttype = _gl.ELEMENT_ARRAY_BUFFER;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ttype = _gl.ARRAY_BUFFER;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tattribute = geometry.attributes[ a ];\r\n\r\n\t\t\tattribute.buffer = _gl.createBuffer();\r\n\r\n\t\t\t_gl.bindBuffer( type, attribute.buffer );\r\n\t\t\t_gl.bufferData( type, attribute.array, _gl.STATIC_DRAW );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Buffer setting\r\n\r\n\tfunction setParticleBuffers ( geometry, hint, object ) {\r\n\r\n\t\tvar v, c, vertex, offset, index, color,\r\n\r\n\t\tvertices = geometry.vertices,\r\n\t\tvl = vertices.length,\r\n\r\n\t\tcolors = geometry.colors,\r\n\t\tcl = colors.length,\r\n\r\n\t\tvertexArray = geometry.__vertexArray,\r\n\t\tcolorArray = geometry.__colorArray,\r\n\r\n\t\tsortArray = geometry.__sortArray,\r\n\r\n\t\tdirtyVertices = geometry.verticesNeedUpdate,\r\n\t\tdirtyElements = geometry.elementsNeedUpdate,\r\n\t\tdirtyColors = geometry.colorsNeedUpdate,\r\n\r\n\t\tcustomAttributes = geometry.__webglCustomAttributesList,\r\n\t\ti, il,\r\n\t\ta, ca, cal, value,\r\n\t\tcustomAttribute;\r\n\r\n\t\tif ( object.sortParticles ) {\r\n\r\n\t\t\t_projScreenMatrixPS.copy( _projScreenMatrix );\r\n\t\t\t_projScreenMatrixPS.multiply( object.matrixWorld );\r\n\r\n\t\t\tfor ( v = 0; v < vl; v ++ ) {\r\n\r\n\t\t\t\tvertex = vertices[ v ];\r\n\r\n\t\t\t\t_vector3.copy( vertex );\r\n\t\t\t\t_vector3.applyProjection( _projScreenMatrixPS );\r\n\r\n\t\t\t\tsortArray[ v ] = [ _vector3.z, v ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tsortArray.sort( numericalSort );\r\n\r\n\t\t\tfor ( v = 0; v < vl; v ++ ) {\r\n\r\n\t\t\t\tvertex = vertices[ sortArray[v][1] ];\r\n\r\n\t\t\t\toffset = v * 3;\r\n\r\n\t\t\t\tvertexArray[ offset ]     = vertex.x;\r\n\t\t\t\tvertexArray[ offset + 1 ] = vertex.y;\r\n\t\t\t\tvertexArray[ offset + 2 ] = vertex.z;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( c = 0; c < cl; c ++ ) {\r\n\r\n\t\t\t\toffset = c * 3;\r\n\r\n\t\t\t\tcolor = colors[ sortArray[c][1] ];\r\n\r\n\t\t\t\tcolorArray[ offset ]     = color.r;\r\n\t\t\t\tcolorArray[ offset + 1 ] = color.g;\r\n\t\t\t\tcolorArray[ offset + 2 ] = color.b;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( customAttributes ) {\r\n\r\n\t\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tcustomAttribute = customAttributes[ i ];\r\n\r\n\t\t\t\t\tif ( ! ( customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\" ) ) continue;\r\n\r\n\t\t\t\t\toffset = 0;\r\n\r\n\t\t\t\t\tcal = customAttribute.value.length;\r\n\r\n\t\t\t\t\tif ( customAttribute.size === 1 ) {\r\n\r\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\tindex = sortArray[ ca ][ 1 ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ ca ] = customAttribute.value[ index ];\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.size === 2 ) {\r\n\r\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\tindex = sortArray[ ca ][ 1 ];\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ index ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\r\n\r\n\t\t\t\t\t\t\toffset += 2;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.size === 3 ) {\r\n\r\n\t\t\t\t\t\tif ( customAttribute.type === \"c\" ) {\r\n\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tindex = sortArray[ ca ][ 1 ];\r\n\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ index ];\r\n\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ]     = value.r;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.g;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.b;\r\n\r\n\t\t\t\t\t\t\t\toffset += 3;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tindex = sortArray[ ca ][ 1 ];\r\n\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ index ];\r\n\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.z;\r\n\r\n\t\t\t\t\t\t\t\toffset += 3;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.size === 4 ) {\r\n\r\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\tindex = sortArray[ ca ][ 1 ];\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ index ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset ]      = value.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1  ] = value.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2  ] = value.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 3  ] = value.w;\r\n\r\n\t\t\t\t\t\t\toffset += 4;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( dirtyVertices ) {\r\n\r\n\t\t\t\tfor ( v = 0; v < vl; v ++ ) {\r\n\r\n\t\t\t\t\tvertex = vertices[ v ];\r\n\r\n\t\t\t\t\toffset = v * 3;\r\n\r\n\t\t\t\t\tvertexArray[ offset ]     = vertex.x;\r\n\t\t\t\t\tvertexArray[ offset + 1 ] = vertex.y;\r\n\t\t\t\t\tvertexArray[ offset + 2 ] = vertex.z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( dirtyColors ) {\r\n\r\n\t\t\t\tfor ( c = 0; c < cl; c ++ ) {\r\n\r\n\t\t\t\t\tcolor = colors[ c ];\r\n\r\n\t\t\t\t\toffset = c * 3;\r\n\r\n\t\t\t\t\tcolorArray[ offset ]     = color.r;\r\n\t\t\t\t\tcolorArray[ offset + 1 ] = color.g;\r\n\t\t\t\t\tcolorArray[ offset + 2 ] = color.b;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( customAttributes ) {\r\n\r\n\t\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tcustomAttribute = customAttributes[ i ];\r\n\r\n\t\t\t\t\tif ( customAttribute.needsUpdate &&\r\n\t\t\t\t\t\t ( customAttribute.boundTo === undefined ||\r\n\t\t\t\t\t\t   customAttribute.boundTo === \"vertices\") ) {\r\n\r\n\t\t\t\t\t\tcal = customAttribute.value.length;\r\n\r\n\t\t\t\t\t\toffset = 0;\r\n\r\n\t\t\t\t\t\tif ( customAttribute.size === 1 ) {\r\n\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ ca ] = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else if ( customAttribute.size === 2 ) {\r\n\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\r\n\r\n\t\t\t\t\t\t\t\toffset += 2;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else if ( customAttribute.size === 3 ) {\r\n\r\n\t\t\t\t\t\t\tif ( customAttribute.type === \"c\" ) {\r\n\r\n\t\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.r;\r\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.g;\r\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.b;\r\n\r\n\t\t\t\t\t\t\t\t\toffset += 3;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\r\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\r\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.z;\r\n\r\n\t\t\t\t\t\t\t\t\toffset += 3;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else if ( customAttribute.size === 4 ) {\r\n\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ]      = value.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1  ] = value.y;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2  ] = value.z;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 3  ] = value.w;\r\n\r\n\t\t\t\t\t\t\t\toffset += 4;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyVertices || object.sortParticles ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyColors || object.sortParticles ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( customAttributes ) {\r\n\r\n\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tcustomAttribute = customAttributes[ i ];\r\n\r\n\t\t\t\tif ( customAttribute.needsUpdate || object.sortParticles ) {\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );\r\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\t};\r\n\r\n\tfunction setLineBuffers ( geometry, hint ) {\r\n\r\n\t\tvar v, c, d, vertex, offset, color,\r\n\r\n\t\tvertices = geometry.vertices,\r\n\t\tcolors = geometry.colors,\r\n\t\tlineDistances = geometry.lineDistances,\r\n\r\n\t\tvl = vertices.length,\r\n\t\tcl = colors.length,\r\n\t\tdl = lineDistances.length,\r\n\r\n\t\tvertexArray = geometry.__vertexArray,\r\n\t\tcolorArray = geometry.__colorArray,\r\n\t\tlineDistanceArray = geometry.__lineDistanceArray,\r\n\r\n\t\tdirtyVertices = geometry.verticesNeedUpdate,\r\n\t\tdirtyColors = geometry.colorsNeedUpdate,\r\n\t\tdirtyLineDistances = geometry.lineDistancesNeedUpdate,\r\n\r\n\t\tcustomAttributes = geometry.__webglCustomAttributesList,\r\n\r\n\t\ti, il,\r\n\t\ta, ca, cal, value,\r\n\t\tcustomAttribute;\r\n\r\n\t\tif ( dirtyVertices ) {\r\n\r\n\t\t\tfor ( v = 0; v < vl; v ++ ) {\r\n\r\n\t\t\t\tvertex = vertices[ v ];\r\n\r\n\t\t\t\toffset = v * 3;\r\n\r\n\t\t\t\tvertexArray[ offset ]     = vertex.x;\r\n\t\t\t\tvertexArray[ offset + 1 ] = vertex.y;\r\n\t\t\t\tvertexArray[ offset + 2 ] = vertex.z;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyColors ) {\r\n\r\n\t\t\tfor ( c = 0; c < cl; c ++ ) {\r\n\r\n\t\t\t\tcolor = colors[ c ];\r\n\r\n\t\t\t\toffset = c * 3;\r\n\r\n\t\t\t\tcolorArray[ offset ]     = color.r;\r\n\t\t\t\tcolorArray[ offset + 1 ] = color.g;\r\n\t\t\t\tcolorArray[ offset + 2 ] = color.b;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyLineDistances ) {\r\n\r\n\t\t\tfor ( d = 0; d < dl; d ++ ) {\r\n\r\n\t\t\t\tlineDistanceArray[ d ] = lineDistances[ d ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglLineDistanceBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, lineDistanceArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( customAttributes ) {\r\n\r\n\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tcustomAttribute = customAttributes[ i ];\r\n\r\n\t\t\t\tif ( customAttribute.needsUpdate &&\r\n\t\t\t\t\t ( customAttribute.boundTo === undefined ||\r\n\t\t\t\t\t   customAttribute.boundTo === \"vertices\" ) ) {\r\n\r\n\t\t\t\t\toffset = 0;\r\n\r\n\t\t\t\t\tcal = customAttribute.value.length;\r\n\r\n\t\t\t\t\tif ( customAttribute.size === 1 ) {\r\n\r\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ ca ] = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.size === 2 ) {\r\n\r\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\r\n\r\n\t\t\t\t\t\t\toffset += 2;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.size === 3 ) {\r\n\r\n\t\t\t\t\t\tif ( customAttribute.type === \"c\" ) {\r\n\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.r;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.g;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.b;\r\n\r\n\t\t\t\t\t\t\t\toffset += 3;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.z;\r\n\r\n\t\t\t\t\t\t\t\toffset += 3;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.size === 4 ) {\r\n\r\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t = value.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1  ] = value.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2  ] = value.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 3  ] = value.w;\r\n\r\n\t\t\t\t\t\t\toffset += 4;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );\r\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction setRibbonBuffers ( geometry, hint ) {\r\n\r\n\t\tvar v, c, n, vertex, offset, color, normal,\r\n\r\n\t\ti, il, ca, cal, customAttribute, value,\r\n\r\n\t\tvertices = geometry.vertices,\r\n\t\tcolors = geometry.colors,\r\n\t\tnormals = geometry.normals,\r\n\r\n\t\tvl = vertices.length,\r\n\t\tcl = colors.length,\r\n\t\tnl = normals.length,\r\n\r\n\t\tvertexArray = geometry.__vertexArray,\r\n\t\tcolorArray = geometry.__colorArray,\r\n\t\tnormalArray = geometry.__normalArray,\r\n\r\n\t\tdirtyVertices = geometry.verticesNeedUpdate,\r\n\t\tdirtyColors = geometry.colorsNeedUpdate,\r\n\t\tdirtyNormals = geometry.normalsNeedUpdate,\r\n\r\n\t\tcustomAttributes = geometry.__webglCustomAttributesList;\r\n\r\n\t\tif ( dirtyVertices ) {\r\n\r\n\t\t\tfor ( v = 0; v < vl; v ++ ) {\r\n\r\n\t\t\t\tvertex = vertices[ v ];\r\n\r\n\t\t\t\toffset = v * 3;\r\n\r\n\t\t\t\tvertexArray[ offset ]     = vertex.x;\r\n\t\t\t\tvertexArray[ offset + 1 ] = vertex.y;\r\n\t\t\t\tvertexArray[ offset + 2 ] = vertex.z;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyColors ) {\r\n\r\n\t\t\tfor ( c = 0; c < cl; c ++ ) {\r\n\r\n\t\t\t\tcolor = colors[ c ];\r\n\r\n\t\t\t\toffset = c * 3;\r\n\r\n\t\t\t\tcolorArray[ offset ]     = color.r;\r\n\t\t\t\tcolorArray[ offset + 1 ] = color.g;\r\n\t\t\t\tcolorArray[ offset + 2 ] = color.b;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyNormals ) {\r\n\r\n\t\t\tfor ( n = 0; n < nl; n ++ ) {\r\n\r\n\t\t\t\tnormal = normals[ n ];\r\n\r\n\t\t\t\toffset = n * 3;\r\n\r\n\t\t\t\tnormalArray[ offset ]     = normal.x;\r\n\t\t\t\tnormalArray[ offset + 1 ] = normal.y;\r\n\t\t\t\tnormalArray[ offset + 2 ] = normal.z;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglNormalBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, normalArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( customAttributes ) {\r\n\r\n\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tcustomAttribute = customAttributes[ i ];\r\n\r\n\t\t\t\tif ( customAttribute.needsUpdate &&\r\n\t\t\t\t\t ( customAttribute.boundTo === undefined ||\r\n\t\t\t\t\t   customAttribute.boundTo === \"vertices\" ) ) {\r\n\r\n\t\t\t\t\toffset = 0;\r\n\r\n\t\t\t\t\tcal = customAttribute.value.length;\r\n\r\n\t\t\t\t\tif ( customAttribute.size === 1 ) {\r\n\r\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ ca ] = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.size === 2 ) {\r\n\r\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\r\n\r\n\t\t\t\t\t\t\toffset += 2;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.size === 3 ) {\r\n\r\n\t\t\t\t\t\tif ( customAttribute.type === \"c\" ) {\r\n\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.r;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.g;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.b;\r\n\r\n\t\t\t\t\t\t\t\toffset += 3;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.z;\r\n\r\n\t\t\t\t\t\t\t\toffset += 3;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.size === 4 ) {\r\n\r\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t = value.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1  ] = value.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2  ] = value.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 3  ] = value.w;\r\n\r\n\t\t\t\t\t\t\toffset += 4;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );\r\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction setMeshBuffers( geometryGroup, object, hint, dispose, material ) {\r\n\r\n\t\tif ( ! geometryGroup.__inittedArrays ) {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar normalType = bufferGuessNormalType( material ),\r\n\t\tvertexColorType = bufferGuessVertexColorType( material ),\r\n\t\tuvType = bufferGuessUVType( material ),\r\n\r\n\t\tneedsSmoothNormals = ( normalType === THREE.SmoothShading );\r\n\r\n\t\tvar f, fl, fi, face,\r\n\t\tvertexNormals, faceNormal, normal,\r\n\t\tvertexColors, faceColor,\r\n\t\tvertexTangents,\r\n\t\tuv, uv2, v1, v2, v3, v4, t1, t2, t3, t4, n1, n2, n3, n4,\r\n\t\tc1, c2, c3, c4,\r\n\t\tsw1, sw2, sw3, sw4,\r\n\t\tsi1, si2, si3, si4,\r\n\t\tsa1, sa2, sa3, sa4,\r\n\t\tsb1, sb2, sb3, sb4,\r\n\t\tm, ml, i, il,\r\n\t\tvn, uvi, uv2i,\r\n\t\tvk, vkl, vka,\r\n\t\tnka, chf, faceVertexNormals,\r\n\t\ta,\r\n\r\n\t\tvertexIndex = 0,\r\n\r\n\t\toffset = 0,\r\n\t\toffset_uv = 0,\r\n\t\toffset_uv2 = 0,\r\n\t\toffset_face = 0,\r\n\t\toffset_normal = 0,\r\n\t\toffset_tangent = 0,\r\n\t\toffset_line = 0,\r\n\t\toffset_color = 0,\r\n\t\toffset_skin = 0,\r\n\t\toffset_morphTarget = 0,\r\n\t\toffset_custom = 0,\r\n\t\toffset_customSrc = 0,\r\n\r\n\t\tvalue,\r\n\r\n\t\tvertexArray = geometryGroup.__vertexArray,\r\n\t\tuvArray = geometryGroup.__uvArray,\r\n\t\tuv2Array = geometryGroup.__uv2Array,\r\n\t\tnormalArray = geometryGroup.__normalArray,\r\n\t\ttangentArray = geometryGroup.__tangentArray,\r\n\t\tcolorArray = geometryGroup.__colorArray,\r\n\r\n\t\tskinIndexArray = geometryGroup.__skinIndexArray,\r\n\t\tskinWeightArray = geometryGroup.__skinWeightArray,\r\n\r\n\t\tmorphTargetsArrays = geometryGroup.__morphTargetsArrays,\r\n\t\tmorphNormalsArrays = geometryGroup.__morphNormalsArrays,\r\n\r\n\t\tcustomAttributes = geometryGroup.__webglCustomAttributesList,\r\n\t\tcustomAttribute,\r\n\r\n\t\tfaceArray = geometryGroup.__faceArray,\r\n\t\tlineArray = geometryGroup.__lineArray,\r\n\r\n\t\tgeometry = object.geometry, // this is shared for all chunks\r\n\r\n\t\tdirtyVertices = geometry.verticesNeedUpdate,\r\n\t\tdirtyElements = geometry.elementsNeedUpdate,\r\n\t\tdirtyUvs = geometry.uvsNeedUpdate,\r\n\t\tdirtyNormals = geometry.normalsNeedUpdate,\r\n\t\tdirtyTangents = geometry.tangentsNeedUpdate,\r\n\t\tdirtyColors = geometry.colorsNeedUpdate,\r\n\t\tdirtyMorphTargets = geometry.morphTargetsNeedUpdate,\r\n\r\n\t\tvertices = geometry.vertices,\r\n\t\tchunk_faces3 = geometryGroup.faces3,\r\n\t\tchunk_faces4 = geometryGroup.faces4,\r\n\t\tobj_faces = geometry.faces,\r\n\r\n\t\tobj_uvs  = geometry.faceVertexUvs[ 0 ],\r\n\t\tobj_uvs2 = geometry.faceVertexUvs[ 1 ],\r\n\r\n\t\tobj_colors = geometry.colors,\r\n\r\n\t\tobj_skinIndices = geometry.skinIndices,\r\n\t\tobj_skinWeights = geometry.skinWeights,\r\n\r\n\t\tmorphTargets = geometry.morphTargets,\r\n\t\tmorphNormals = geometry.morphNormals;\r\n\r\n\t\tif ( dirtyVertices ) {\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\tv1 = vertices[ face.a ];\r\n\t\t\t\tv2 = vertices[ face.b ];\r\n\t\t\t\tv3 = vertices[ face.c ];\r\n\r\n\t\t\t\tvertexArray[ offset ]     = v1.x;\r\n\t\t\t\tvertexArray[ offset + 1 ] = v1.y;\r\n\t\t\t\tvertexArray[ offset + 2 ] = v1.z;\r\n\r\n\t\t\t\tvertexArray[ offset + 3 ] = v2.x;\r\n\t\t\t\tvertexArray[ offset + 4 ] = v2.y;\r\n\t\t\t\tvertexArray[ offset + 5 ] = v2.z;\r\n\r\n\t\t\t\tvertexArray[ offset + 6 ] = v3.x;\r\n\t\t\t\tvertexArray[ offset + 7 ] = v3.y;\r\n\t\t\t\tvertexArray[ offset + 8 ] = v3.z;\r\n\r\n\t\t\t\toffset += 9;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = obj_faces[ chunk_faces4[ f ] ];\r\n\r\n\t\t\t\tv1 = vertices[ face.a ];\r\n\t\t\t\tv2 = vertices[ face.b ];\r\n\t\t\t\tv3 = vertices[ face.c ];\r\n\t\t\t\tv4 = vertices[ face.d ];\r\n\r\n\t\t\t\tvertexArray[ offset ]     = v1.x;\r\n\t\t\t\tvertexArray[ offset + 1 ] = v1.y;\r\n\t\t\t\tvertexArray[ offset + 2 ] = v1.z;\r\n\r\n\t\t\t\tvertexArray[ offset + 3 ] = v2.x;\r\n\t\t\t\tvertexArray[ offset + 4 ] = v2.y;\r\n\t\t\t\tvertexArray[ offset + 5 ] = v2.z;\r\n\r\n\t\t\t\tvertexArray[ offset + 6 ] = v3.x;\r\n\t\t\t\tvertexArray[ offset + 7 ] = v3.y;\r\n\t\t\t\tvertexArray[ offset + 8 ] = v3.z;\r\n\r\n\t\t\t\tvertexArray[ offset + 9 ]  = v4.x;\r\n\t\t\t\tvertexArray[ offset + 10 ] = v4.y;\r\n\t\t\t\tvertexArray[ offset + 11 ] = v4.z;\r\n\r\n\t\t\t\toffset += 12;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyMorphTargets ) {\r\n\r\n\t\t\tfor ( vk = 0, vkl = morphTargets.length; vk < vkl; vk ++ ) {\r\n\r\n\t\t\t\toffset_morphTarget = 0;\r\n\r\n\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\tchf = chunk_faces3[ f ];\r\n\t\t\t\t\tface = obj_faces[ chf ];\r\n\r\n\t\t\t\t\t// morph positions\r\n\r\n\t\t\t\t\tv1 = morphTargets[ vk ].vertices[ face.a ];\r\n\t\t\t\t\tv2 = morphTargets[ vk ].vertices[ face.b ];\r\n\t\t\t\t\tv3 = morphTargets[ vk ].vertices[ face.c ];\r\n\r\n\t\t\t\t\tvka = morphTargetsArrays[ vk ];\r\n\r\n\t\t\t\t\tvka[ offset_morphTarget ] \t  = v1.x;\r\n\t\t\t\t\tvka[ offset_morphTarget + 1 ] = v1.y;\r\n\t\t\t\t\tvka[ offset_morphTarget + 2 ] = v1.z;\r\n\r\n\t\t\t\t\tvka[ offset_morphTarget + 3 ] = v2.x;\r\n\t\t\t\t\tvka[ offset_morphTarget + 4 ] = v2.y;\r\n\t\t\t\t\tvka[ offset_morphTarget + 5 ] = v2.z;\r\n\r\n\t\t\t\t\tvka[ offset_morphTarget + 6 ] = v3.x;\r\n\t\t\t\t\tvka[ offset_morphTarget + 7 ] = v3.y;\r\n\t\t\t\t\tvka[ offset_morphTarget + 8 ] = v3.z;\r\n\r\n\t\t\t\t\t// morph normals\r\n\r\n\t\t\t\t\tif ( material.morphNormals ) {\r\n\r\n\t\t\t\t\t\tif ( needsSmoothNormals ) {\r\n\r\n\t\t\t\t\t\t\tfaceVertexNormals = morphNormals[ vk ].vertexNormals[ chf ];\r\n\r\n\t\t\t\t\t\t\tn1 = faceVertexNormals.a;\r\n\t\t\t\t\t\t\tn2 = faceVertexNormals.b;\r\n\t\t\t\t\t\t\tn3 = faceVertexNormals.c;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tn1 = morphNormals[ vk ].faceNormals[ chf ];\r\n\t\t\t\t\t\t\tn2 = n1;\r\n\t\t\t\t\t\t\tn3 = n1;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tnka = morphNormalsArrays[ vk ];\r\n\r\n\t\t\t\t\t\tnka[ offset_morphTarget ] \t  = n1.x;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 1 ] = n1.y;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 2 ] = n1.z;\r\n\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 3 ] = n2.x;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 4 ] = n2.y;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 5 ] = n2.z;\r\n\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 6 ] = n3.x;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 7 ] = n3.y;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 8 ] = n3.z;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t//\r\n\r\n\t\t\t\t\toffset_morphTarget += 9;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\tchf = chunk_faces4[ f ];\r\n\t\t\t\t\tface = obj_faces[ chf ];\r\n\r\n\t\t\t\t\t// morph positions\r\n\r\n\t\t\t\t\tv1 = morphTargets[ vk ].vertices[ face.a ];\r\n\t\t\t\t\tv2 = morphTargets[ vk ].vertices[ face.b ];\r\n\t\t\t\t\tv3 = morphTargets[ vk ].vertices[ face.c ];\r\n\t\t\t\t\tv4 = morphTargets[ vk ].vertices[ face.d ];\r\n\r\n\t\t\t\t\tvka = morphTargetsArrays[ vk ];\r\n\r\n\t\t\t\t\tvka[ offset_morphTarget ] \t  = v1.x;\r\n\t\t\t\t\tvka[ offset_morphTarget + 1 ] = v1.y;\r\n\t\t\t\t\tvka[ offset_morphTarget + 2 ] = v1.z;\r\n\r\n\t\t\t\t\tvka[ offset_morphTarget + 3 ] = v2.x;\r\n\t\t\t\t\tvka[ offset_morphTarget + 4 ] = v2.y;\r\n\t\t\t\t\tvka[ offset_morphTarget + 5 ] = v2.z;\r\n\r\n\t\t\t\t\tvka[ offset_morphTarget + 6 ] = v3.x;\r\n\t\t\t\t\tvka[ offset_morphTarget + 7 ] = v3.y;\r\n\t\t\t\t\tvka[ offset_morphTarget + 8 ] = v3.z;\r\n\r\n\t\t\t\t\tvka[ offset_morphTarget + 9 ]  = v4.x;\r\n\t\t\t\t\tvka[ offset_morphTarget + 10 ] = v4.y;\r\n\t\t\t\t\tvka[ offset_morphTarget + 11 ] = v4.z;\r\n\r\n\t\t\t\t\t// morph normals\r\n\r\n\t\t\t\t\tif ( material.morphNormals ) {\r\n\r\n\t\t\t\t\t\tif ( needsSmoothNormals ) {\r\n\r\n\t\t\t\t\t\t\tfaceVertexNormals = morphNormals[ vk ].vertexNormals[ chf ];\r\n\r\n\t\t\t\t\t\t\tn1 = faceVertexNormals.a;\r\n\t\t\t\t\t\t\tn2 = faceVertexNormals.b;\r\n\t\t\t\t\t\t\tn3 = faceVertexNormals.c;\r\n\t\t\t\t\t\t\tn4 = faceVertexNormals.d;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tn1 = morphNormals[ vk ].faceNormals[ chf ];\r\n\t\t\t\t\t\t\tn2 = n1;\r\n\t\t\t\t\t\t\tn3 = n1;\r\n\t\t\t\t\t\t\tn4 = n1;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tnka = morphNormalsArrays[ vk ];\r\n\r\n\t\t\t\t\t\tnka[ offset_morphTarget ] \t  = n1.x;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 1 ] = n1.y;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 2 ] = n1.z;\r\n\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 3 ] = n2.x;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 4 ] = n2.y;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 5 ] = n2.z;\r\n\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 6 ] = n3.x;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 7 ] = n3.y;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 8 ] = n3.z;\r\n\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 9 ]  = n4.x;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 10 ] = n4.y;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 11 ] = n4.z;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t//\r\n\r\n\t\t\t\t\toffset_morphTarget += 12;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ vk ] );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, morphTargetsArrays[ vk ], hint );\r\n\r\n\t\t\t\tif ( material.morphNormals ) {\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ vk ] );\r\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, morphNormalsArrays[ vk ], hint );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( obj_skinWeights.length ) {\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\r\n\r\n\t\t\t\t// weights\r\n\r\n\t\t\t\tsw1 = obj_skinWeights[ face.a ];\r\n\t\t\t\tsw2 = obj_skinWeights[ face.b ];\r\n\t\t\t\tsw3 = obj_skinWeights[ face.c ];\r\n\r\n\t\t\t\tskinWeightArray[ offset_skin ]     = sw1.x;\r\n\t\t\t\tskinWeightArray[ offset_skin + 1 ] = sw1.y;\r\n\t\t\t\tskinWeightArray[ offset_skin + 2 ] = sw1.z;\r\n\t\t\t\tskinWeightArray[ offset_skin + 3 ] = sw1.w;\r\n\r\n\t\t\t\tskinWeightArray[ offset_skin + 4 ] = sw2.x;\r\n\t\t\t\tskinWeightArray[ offset_skin + 5 ] = sw2.y;\r\n\t\t\t\tskinWeightArray[ offset_skin + 6 ] = sw2.z;\r\n\t\t\t\tskinWeightArray[ offset_skin + 7 ] = sw2.w;\r\n\r\n\t\t\t\tskinWeightArray[ offset_skin + 8 ]  = sw3.x;\r\n\t\t\t\tskinWeightArray[ offset_skin + 9 ]  = sw3.y;\r\n\t\t\t\tskinWeightArray[ offset_skin + 10 ] = sw3.z;\r\n\t\t\t\tskinWeightArray[ offset_skin + 11 ] = sw3.w;\r\n\r\n\t\t\t\t// indices\r\n\r\n\t\t\t\tsi1 = obj_skinIndices[ face.a ];\r\n\t\t\t\tsi2 = obj_skinIndices[ face.b ];\r\n\t\t\t\tsi3 = obj_skinIndices[ face.c ];\r\n\r\n\t\t\t\tskinIndexArray[ offset_skin ]     = si1.x;\r\n\t\t\t\tskinIndexArray[ offset_skin + 1 ] = si1.y;\r\n\t\t\t\tskinIndexArray[ offset_skin + 2 ] = si1.z;\r\n\t\t\t\tskinIndexArray[ offset_skin + 3 ] = si1.w;\r\n\r\n\t\t\t\tskinIndexArray[ offset_skin + 4 ] = si2.x;\r\n\t\t\t\tskinIndexArray[ offset_skin + 5 ] = si2.y;\r\n\t\t\t\tskinIndexArray[ offset_skin + 6 ] = si2.z;\r\n\t\t\t\tskinIndexArray[ offset_skin + 7 ] = si2.w;\r\n\r\n\t\t\t\tskinIndexArray[ offset_skin + 8 ]  = si3.x;\r\n\t\t\t\tskinIndexArray[ offset_skin + 9 ]  = si3.y;\r\n\t\t\t\tskinIndexArray[ offset_skin + 10 ] = si3.z;\r\n\t\t\t\tskinIndexArray[ offset_skin + 11 ] = si3.w;\r\n\r\n\t\t\t\toffset_skin += 12;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = obj_faces[ chunk_faces4[ f ] ];\r\n\r\n\t\t\t\t// weights\r\n\r\n\t\t\t\tsw1 = obj_skinWeights[ face.a ];\r\n\t\t\t\tsw2 = obj_skinWeights[ face.b ];\r\n\t\t\t\tsw3 = obj_skinWeights[ face.c ];\r\n\t\t\t\tsw4 = obj_skinWeights[ face.d ];\r\n\r\n\t\t\t\tskinWeightArray[ offset_skin ]     = sw1.x;\r\n\t\t\t\tskinWeightArray[ offset_skin + 1 ] = sw1.y;\r\n\t\t\t\tskinWeightArray[ offset_skin + 2 ] = sw1.z;\r\n\t\t\t\tskinWeightArray[ offset_skin + 3 ] = sw1.w;\r\n\r\n\t\t\t\tskinWeightArray[ offset_skin + 4 ] = sw2.x;\r\n\t\t\t\tskinWeightArray[ offset_skin + 5 ] = sw2.y;\r\n\t\t\t\tskinWeightArray[ offset_skin + 6 ] = sw2.z;\r\n\t\t\t\tskinWeightArray[ offset_skin + 7 ] = sw2.w;\r\n\r\n\t\t\t\tskinWeightArray[ offset_skin + 8 ]  = sw3.x;\r\n\t\t\t\tskinWeightArray[ offset_skin + 9 ]  = sw3.y;\r\n\t\t\t\tskinWeightArray[ offset_skin + 10 ] = sw3.z;\r\n\t\t\t\tskinWeightArray[ offset_skin + 11 ] = sw3.w;\r\n\r\n\t\t\t\tskinWeightArray[ offset_skin + 12 ] = sw4.x;\r\n\t\t\t\tskinWeightArray[ offset_skin + 13 ] = sw4.y;\r\n\t\t\t\tskinWeightArray[ offset_skin + 14 ] = sw4.z;\r\n\t\t\t\tskinWeightArray[ offset_skin + 15 ] = sw4.w;\r\n\r\n\t\t\t\t// indices\r\n\r\n\t\t\t\tsi1 = obj_skinIndices[ face.a ];\r\n\t\t\t\tsi2 = obj_skinIndices[ face.b ];\r\n\t\t\t\tsi3 = obj_skinIndices[ face.c ];\r\n\t\t\t\tsi4 = obj_skinIndices[ face.d ];\r\n\r\n\t\t\t\tskinIndexArray[ offset_skin ]     = si1.x;\r\n\t\t\t\tskinIndexArray[ offset_skin + 1 ] = si1.y;\r\n\t\t\t\tskinIndexArray[ offset_skin + 2 ] = si1.z;\r\n\t\t\t\tskinIndexArray[ offset_skin + 3 ] = si1.w;\r\n\r\n\t\t\t\tskinIndexArray[ offset_skin + 4 ] = si2.x;\r\n\t\t\t\tskinIndexArray[ offset_skin + 5 ] = si2.y;\r\n\t\t\t\tskinIndexArray[ offset_skin + 6 ] = si2.z;\r\n\t\t\t\tskinIndexArray[ offset_skin + 7 ] = si2.w;\r\n\r\n\t\t\t\tskinIndexArray[ offset_skin + 8 ]  = si3.x;\r\n\t\t\t\tskinIndexArray[ offset_skin + 9 ]  = si3.y;\r\n\t\t\t\tskinIndexArray[ offset_skin + 10 ] = si3.z;\r\n\t\t\t\tskinIndexArray[ offset_skin + 11 ] = si3.w;\r\n\r\n\t\t\t\tskinIndexArray[ offset_skin + 12 ] = si4.x;\r\n\t\t\t\tskinIndexArray[ offset_skin + 13 ] = si4.y;\r\n\t\t\t\tskinIndexArray[ offset_skin + 14 ] = si4.z;\r\n\t\t\t\tskinIndexArray[ offset_skin + 15 ] = si4.w;\r\n\r\n\t\t\t\toffset_skin += 16;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( offset_skin > 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, skinIndexArray, hint );\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, skinWeightArray, hint );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyColors && vertexColorType ) {\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\r\n\r\n\t\t\t\tvertexColors = face.vertexColors;\r\n\t\t\t\tfaceColor = face.color;\r\n\r\n\t\t\t\tif ( vertexColors.length === 3 && vertexColorType === THREE.VertexColors ) {\r\n\r\n\t\t\t\t\tc1 = vertexColors[ 0 ];\r\n\t\t\t\t\tc2 = vertexColors[ 1 ];\r\n\t\t\t\t\tc3 = vertexColors[ 2 ];\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tc1 = faceColor;\r\n\t\t\t\t\tc2 = faceColor;\r\n\t\t\t\t\tc3 = faceColor;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcolorArray[ offset_color ]     = c1.r;\r\n\t\t\t\tcolorArray[ offset_color + 1 ] = c1.g;\r\n\t\t\t\tcolorArray[ offset_color + 2 ] = c1.b;\r\n\r\n\t\t\t\tcolorArray[ offset_color + 3 ] = c2.r;\r\n\t\t\t\tcolorArray[ offset_color + 4 ] = c2.g;\r\n\t\t\t\tcolorArray[ offset_color + 5 ] = c2.b;\r\n\r\n\t\t\t\tcolorArray[ offset_color + 6 ] = c3.r;\r\n\t\t\t\tcolorArray[ offset_color + 7 ] = c3.g;\r\n\t\t\t\tcolorArray[ offset_color + 8 ] = c3.b;\r\n\r\n\t\t\t\toffset_color += 9;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = obj_faces[ chunk_faces4[ f ] ];\r\n\r\n\t\t\t\tvertexColors = face.vertexColors;\r\n\t\t\t\tfaceColor = face.color;\r\n\r\n\t\t\t\tif ( vertexColors.length === 4 && vertexColorType === THREE.VertexColors ) {\r\n\r\n\t\t\t\t\tc1 = vertexColors[ 0 ];\r\n\t\t\t\t\tc2 = vertexColors[ 1 ];\r\n\t\t\t\t\tc3 = vertexColors[ 2 ];\r\n\t\t\t\t\tc4 = vertexColors[ 3 ];\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tc1 = faceColor;\r\n\t\t\t\t\tc2 = faceColor;\r\n\t\t\t\t\tc3 = faceColor;\r\n\t\t\t\t\tc4 = faceColor;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcolorArray[ offset_color ]     = c1.r;\r\n\t\t\t\tcolorArray[ offset_color + 1 ] = c1.g;\r\n\t\t\t\tcolorArray[ offset_color + 2 ] = c1.b;\r\n\r\n\t\t\t\tcolorArray[ offset_color + 3 ] = c2.r;\r\n\t\t\t\tcolorArray[ offset_color + 4 ] = c2.g;\r\n\t\t\t\tcolorArray[ offset_color + 5 ] = c2.b;\r\n\r\n\t\t\t\tcolorArray[ offset_color + 6 ] = c3.r;\r\n\t\t\t\tcolorArray[ offset_color + 7 ] = c3.g;\r\n\t\t\t\tcolorArray[ offset_color + 8 ] = c3.b;\r\n\r\n\t\t\t\tcolorArray[ offset_color + 9 ]  = c4.r;\r\n\t\t\t\tcolorArray[ offset_color + 10 ] = c4.g;\r\n\t\t\t\tcolorArray[ offset_color + 11 ] = c4.b;\r\n\r\n\t\t\t\toffset_color += 12;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( offset_color > 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyTangents && geometry.hasTangents ) {\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\r\n\r\n\t\t\t\tvertexTangents = face.vertexTangents;\r\n\r\n\t\t\t\tt1 = vertexTangents[ 0 ];\r\n\t\t\t\tt2 = vertexTangents[ 1 ];\r\n\t\t\t\tt3 = vertexTangents[ 2 ];\r\n\r\n\t\t\t\ttangentArray[ offset_tangent ]     = t1.x;\r\n\t\t\t\ttangentArray[ offset_tangent + 1 ] = t1.y;\r\n\t\t\t\ttangentArray[ offset_tangent + 2 ] = t1.z;\r\n\t\t\t\ttangentArray[ offset_tangent + 3 ] = t1.w;\r\n\r\n\t\t\t\ttangentArray[ offset_tangent + 4 ] = t2.x;\r\n\t\t\t\ttangentArray[ offset_tangent + 5 ] = t2.y;\r\n\t\t\t\ttangentArray[ offset_tangent + 6 ] = t2.z;\r\n\t\t\t\ttangentArray[ offset_tangent + 7 ] = t2.w;\r\n\r\n\t\t\t\ttangentArray[ offset_tangent + 8 ]  = t3.x;\r\n\t\t\t\ttangentArray[ offset_tangent + 9 ]  = t3.y;\r\n\t\t\t\ttangentArray[ offset_tangent + 10 ] = t3.z;\r\n\t\t\t\ttangentArray[ offset_tangent + 11 ] = t3.w;\r\n\r\n\t\t\t\toffset_tangent += 12;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = obj_faces[ chunk_faces4[ f ] ];\r\n\r\n\t\t\t\tvertexTangents = face.vertexTangents;\r\n\r\n\t\t\t\tt1 = vertexTangents[ 0 ];\r\n\t\t\t\tt2 = vertexTangents[ 1 ];\r\n\t\t\t\tt3 = vertexTangents[ 2 ];\r\n\t\t\t\tt4 = vertexTangents[ 3 ];\r\n\r\n\t\t\t\ttangentArray[ offset_tangent ]     = t1.x;\r\n\t\t\t\ttangentArray[ offset_tangent + 1 ] = t1.y;\r\n\t\t\t\ttangentArray[ offset_tangent + 2 ] = t1.z;\r\n\t\t\t\ttangentArray[ offset_tangent + 3 ] = t1.w;\r\n\r\n\t\t\t\ttangentArray[ offset_tangent + 4 ] = t2.x;\r\n\t\t\t\ttangentArray[ offset_tangent + 5 ] = t2.y;\r\n\t\t\t\ttangentArray[ offset_tangent + 6 ] = t2.z;\r\n\t\t\t\ttangentArray[ offset_tangent + 7 ] = t2.w;\r\n\r\n\t\t\t\ttangentArray[ offset_tangent + 8 ]  = t3.x;\r\n\t\t\t\ttangentArray[ offset_tangent + 9 ]  = t3.y;\r\n\t\t\t\ttangentArray[ offset_tangent + 10 ] = t3.z;\r\n\t\t\t\ttangentArray[ offset_tangent + 11 ] = t3.w;\r\n\r\n\t\t\t\ttangentArray[ offset_tangent + 12 ] = t4.x;\r\n\t\t\t\ttangentArray[ offset_tangent + 13 ] = t4.y;\r\n\t\t\t\ttangentArray[ offset_tangent + 14 ] = t4.z;\r\n\t\t\t\ttangentArray[ offset_tangent + 15 ] = t4.w;\r\n\r\n\t\t\t\toffset_tangent += 16;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, tangentArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyNormals && normalType ) {\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\r\n\r\n\t\t\t\tvertexNormals = face.vertexNormals;\r\n\t\t\t\tfaceNormal = face.normal;\r\n\r\n\t\t\t\tif ( vertexNormals.length === 3 && needsSmoothNormals ) {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\t\tvn = vertexNormals[ i ];\r\n\r\n\t\t\t\t\t\tnormalArray[ offset_normal ]     = vn.x;\r\n\t\t\t\t\t\tnormalArray[ offset_normal + 1 ] = vn.y;\r\n\t\t\t\t\t\tnormalArray[ offset_normal + 2 ] = vn.z;\r\n\r\n\t\t\t\t\t\toffset_normal += 3;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\t\tnormalArray[ offset_normal ]     = faceNormal.x;\r\n\t\t\t\t\t\tnormalArray[ offset_normal + 1 ] = faceNormal.y;\r\n\t\t\t\t\t\tnormalArray[ offset_normal + 2 ] = faceNormal.z;\r\n\r\n\t\t\t\t\t\toffset_normal += 3;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = obj_faces[ chunk_faces4[ f ] ];\r\n\r\n\t\t\t\tvertexNormals = face.vertexNormals;\r\n\t\t\t\tfaceNormal = face.normal;\r\n\r\n\t\t\t\tif ( vertexNormals.length === 4 && needsSmoothNormals ) {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\t\t\t\tvn = vertexNormals[ i ];\r\n\r\n\t\t\t\t\t\tnormalArray[ offset_normal ]     = vn.x;\r\n\t\t\t\t\t\tnormalArray[ offset_normal + 1 ] = vn.y;\r\n\t\t\t\t\t\tnormalArray[ offset_normal + 2 ] = vn.z;\r\n\r\n\t\t\t\t\t\toffset_normal += 3;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\t\t\t\tnormalArray[ offset_normal ]     = faceNormal.x;\r\n\t\t\t\t\t\tnormalArray[ offset_normal + 1 ] = faceNormal.y;\r\n\t\t\t\t\t\tnormalArray[ offset_normal + 2 ] = faceNormal.z;\r\n\r\n\t\t\t\t\t\toffset_normal += 3;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, normalArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyUvs && obj_uvs && uvType ) {\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tfi = chunk_faces3[ f ];\r\n\r\n\t\t\t\tuv = obj_uvs[ fi ];\r\n\r\n\t\t\t\tif ( uv === undefined ) continue;\r\n\r\n\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\tuvi = uv[ i ];\r\n\r\n\t\t\t\t\tuvArray[ offset_uv ]     = uvi.x;\r\n\t\t\t\t\tuvArray[ offset_uv + 1 ] = uvi.y;\r\n\r\n\t\t\t\t\toffset_uv += 2;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tfi = chunk_faces4[ f ];\r\n\r\n\t\t\t\tuv = obj_uvs[ fi ];\r\n\r\n\t\t\t\tif ( uv === undefined ) continue;\r\n\r\n\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\t\t\tuvi = uv[ i ];\r\n\r\n\t\t\t\t\tuvArray[ offset_uv ]     = uvi.x;\r\n\t\t\t\t\tuvArray[ offset_uv + 1 ] = uvi.y;\r\n\r\n\t\t\t\t\toffset_uv += 2;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( offset_uv > 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, uvArray, hint );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyUvs && obj_uvs2 && uvType ) {\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tfi = chunk_faces3[ f ];\r\n\r\n\t\t\t\tuv2 = obj_uvs2[ fi ];\r\n\r\n\t\t\t\tif ( uv2 === undefined ) continue;\r\n\r\n\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\tuv2i = uv2[ i ];\r\n\r\n\t\t\t\t\tuv2Array[ offset_uv2 ]     = uv2i.x;\r\n\t\t\t\t\tuv2Array[ offset_uv2 + 1 ] = uv2i.y;\r\n\r\n\t\t\t\t\toffset_uv2 += 2;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tfi = chunk_faces4[ f ];\r\n\r\n\t\t\t\tuv2 = obj_uvs2[ fi ];\r\n\r\n\t\t\t\tif ( uv2 === undefined ) continue;\r\n\r\n\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\t\t\tuv2i = uv2[ i ];\r\n\r\n\t\t\t\t\tuv2Array[ offset_uv2 ]     = uv2i.x;\r\n\t\t\t\t\tuv2Array[ offset_uv2 + 1 ] = uv2i.y;\r\n\r\n\t\t\t\t\toffset_uv2 += 2;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( offset_uv2 > 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, uv2Array, hint );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyElements ) {\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tfaceArray[ offset_face ] \t = vertexIndex;\r\n\t\t\t\tfaceArray[ offset_face + 1 ] = vertexIndex + 1;\r\n\t\t\t\tfaceArray[ offset_face + 2 ] = vertexIndex + 2;\r\n\r\n\t\t\t\toffset_face += 3;\r\n\r\n\t\t\t\tlineArray[ offset_line ]     = vertexIndex;\r\n\t\t\t\tlineArray[ offset_line + 1 ] = vertexIndex + 1;\r\n\r\n\t\t\t\tlineArray[ offset_line + 2 ] = vertexIndex;\r\n\t\t\t\tlineArray[ offset_line + 3 ] = vertexIndex + 2;\r\n\r\n\t\t\t\tlineArray[ offset_line + 4 ] = vertexIndex + 1;\r\n\t\t\t\tlineArray[ offset_line + 5 ] = vertexIndex + 2;\r\n\r\n\t\t\t\toffset_line += 6;\r\n\r\n\t\t\t\tvertexIndex += 3;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tfaceArray[ offset_face ]     = vertexIndex;\r\n\t\t\t\tfaceArray[ offset_face + 1 ] = vertexIndex + 1;\r\n\t\t\t\tfaceArray[ offset_face + 2 ] = vertexIndex + 3;\r\n\r\n\t\t\t\tfaceArray[ offset_face + 3 ] = vertexIndex + 1;\r\n\t\t\t\tfaceArray[ offset_face + 4 ] = vertexIndex + 2;\r\n\t\t\t\tfaceArray[ offset_face + 5 ] = vertexIndex + 3;\r\n\r\n\t\t\t\toffset_face += 6;\r\n\r\n\t\t\t\tlineArray[ offset_line ]     = vertexIndex;\r\n\t\t\t\tlineArray[ offset_line + 1 ] = vertexIndex + 1;\r\n\r\n\t\t\t\tlineArray[ offset_line + 2 ] = vertexIndex;\r\n\t\t\t\tlineArray[ offset_line + 3 ] = vertexIndex + 3;\r\n\r\n\t\t\t\tlineArray[ offset_line + 4 ] = vertexIndex + 1;\r\n\t\t\t\tlineArray[ offset_line + 5 ] = vertexIndex + 2;\r\n\r\n\t\t\t\tlineArray[ offset_line + 6 ] = vertexIndex + 2;\r\n\t\t\t\tlineArray[ offset_line + 7 ] = vertexIndex + 3;\r\n\r\n\t\t\t\toffset_line += 8;\r\n\r\n\t\t\t\tvertexIndex += 4;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );\r\n\t\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, faceArray, hint );\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );\r\n\t\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, lineArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( customAttributes ) {\r\n\r\n\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tcustomAttribute = customAttributes[ i ];\r\n\r\n\t\t\t\tif ( ! customAttribute.__original.needsUpdate ) continue;\r\n\r\n\t\t\t\toffset_custom = 0;\r\n\t\t\t\toffset_customSrc = 0;\r\n\r\n\t\t\t\tif ( customAttribute.size === 1 ) {\r\n\r\n\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\" ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = customAttribute.value[ face.a ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];\r\n\r\n\t\t\t\t\t\t\toffset_custom += 3;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces4[ f ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = customAttribute.value[ face.a ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = customAttribute.value[ face.d ];\r\n\r\n\t\t\t\t\t\t\toffset_custom += 4;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.boundTo === \"faces\" ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = value;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = value;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = value;\r\n\r\n\t\t\t\t\t\t\toffset_custom += 3;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces4[ f ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = value;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = value;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = value;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = value;\r\n\r\n\t\t\t\t\t\t\toffset_custom += 4;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( customAttribute.size === 2 ) {\r\n\r\n\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\" ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\r\n\r\n\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\r\n\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\r\n\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1.y;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v2.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2.y;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v3.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v3.y;\r\n\r\n\t\t\t\t\t\t\toffset_custom += 6;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces4[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\r\n\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\r\n\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\r\n\t\t\t\t\t\t\tv4 = customAttribute.value[ face.d ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1.y;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v2.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2.y;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v3.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v3.y;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v4.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v4.y;\r\n\r\n\t\t\t\t\t\t\toffset_custom += 8;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.boundTo === \"faces\" ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = value;\r\n\t\t\t\t\t\t\tv2 = value;\r\n\t\t\t\t\t\t\tv3 = value;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1.y;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v2.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2.y;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v3.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v3.y;\r\n\r\n\t\t\t\t\t\t\toffset_custom += 6;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces4[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = value;\r\n\t\t\t\t\t\t\tv2 = value;\r\n\t\t\t\t\t\t\tv3 = value;\r\n\t\t\t\t\t\t\tv4 = value;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1.y;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v2.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2.y;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v3.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v3.y;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v4.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v4.y;\r\n\r\n\t\t\t\t\t\t\toffset_custom += 8;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( customAttribute.size === 3 ) {\r\n\r\n\t\t\t\t\tvar pp;\r\n\r\n\t\t\t\t\tif ( customAttribute.type === \"c\" ) {\r\n\r\n\t\t\t\t\t\tpp = [ \"r\", \"g\", \"b\" ];\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tpp = [ \"x\", \"y\", \"z\" ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\" ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\r\n\r\n\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\r\n\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\r\n\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\toffset_custom += 9;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces4[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\r\n\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\r\n\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\r\n\t\t\t\t\t\t\tv4 = customAttribute.value[ face.d ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v2[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v3[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v3[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v4[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v4[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v4[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\toffset_custom += 12;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.boundTo === \"faces\" ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = value;\r\n\t\t\t\t\t\t\tv2 = value;\r\n\t\t\t\t\t\t\tv3 = value;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\toffset_custom += 9;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces4[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = value;\r\n\t\t\t\t\t\t\tv2 = value;\r\n\t\t\t\t\t\t\tv3 = value;\r\n\t\t\t\t\t\t\tv4 = value;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v2[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v3[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v3[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v4[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v4[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v4[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\toffset_custom += 12;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.boundTo === \"faceVertices\" ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = value[ 0 ];\r\n\t\t\t\t\t\t\tv2 = value[ 1 ];\r\n\t\t\t\t\t\t\tv3 = value[ 2 ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\toffset_custom += 9;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces4[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = value[ 0 ];\r\n\t\t\t\t\t\t\tv2 = value[ 1 ];\r\n\t\t\t\t\t\t\tv3 = value[ 2 ];\r\n\t\t\t\t\t\t\tv4 = value[ 3 ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v2[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v3[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v3[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v4[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v4[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v4[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\toffset_custom += 12;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( customAttribute.size === 4 ) {\r\n\r\n\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\" ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\r\n\r\n\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\r\n\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\r\n\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\r\n\r\n\t\t\t\t\t\t\toffset_custom += 12;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces4[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\r\n\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\r\n\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\r\n\t\t\t\t\t\t\tv4 = customAttribute.value[ face.d ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 12 ] = v4.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 13 ] = v4.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 14 ] = v4.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 15 ] = v4.w;\r\n\r\n\t\t\t\t\t\t\toffset_custom += 16;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.boundTo === \"faces\" ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = value;\r\n\t\t\t\t\t\t\tv2 = value;\r\n\t\t\t\t\t\t\tv3 = value;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\r\n\r\n\t\t\t\t\t\t\toffset_custom += 12;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces4[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = value;\r\n\t\t\t\t\t\t\tv2 = value;\r\n\t\t\t\t\t\t\tv3 = value;\r\n\t\t\t\t\t\t\tv4 = value;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 12 ] = v4.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 13 ] = v4.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 14 ] = v4.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 15 ] = v4.w;\r\n\r\n\t\t\t\t\t\t\toffset_custom += 16;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.boundTo === \"faceVertices\" ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = value[ 0 ];\r\n\t\t\t\t\t\t\tv2 = value[ 1 ];\r\n\t\t\t\t\t\t\tv3 = value[ 2 ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\r\n\r\n\t\t\t\t\t\t\toffset_custom += 12;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces4[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = value[ 0 ];\r\n\t\t\t\t\t\t\tv2 = value[ 1 ];\r\n\t\t\t\t\t\t\tv3 = value[ 2 ];\r\n\t\t\t\t\t\t\tv4 = value[ 3 ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 12 ] = v4.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 13 ] = v4.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 14 ] = v4.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 15 ] = v4.w;\r\n\r\n\t\t\t\t\t\t\toffset_custom += 16;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( dispose ) {\r\n\r\n\t\t\tdelete geometryGroup.__inittedArrays;\r\n\t\t\tdelete geometryGroup.__colorArray;\r\n\t\t\tdelete geometryGroup.__normalArray;\r\n\t\t\tdelete geometryGroup.__tangentArray;\r\n\t\t\tdelete geometryGroup.__uvArray;\r\n\t\t\tdelete geometryGroup.__uv2Array;\r\n\t\t\tdelete geometryGroup.__faceArray;\r\n\t\t\tdelete geometryGroup.__vertexArray;\r\n\t\t\tdelete geometryGroup.__lineArray;\r\n\t\t\tdelete geometryGroup.__skinIndexArray;\r\n\t\t\tdelete geometryGroup.__skinWeightArray;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction setDirectBuffers ( geometry, hint, dispose ) {\r\n\r\n\t\tvar attributes = geometry.attributes;\r\n\r\n\t\tvar index = attributes[ \"index\" ];\r\n\t\tvar position = attributes[ \"position\" ];\r\n\t\tvar normal = attributes[ \"normal\" ];\r\n\t\tvar uv = attributes[ \"uv\" ];\r\n\t\tvar color = attributes[ \"color\" ];\r\n\t\tvar tangent = attributes[ \"tangent\" ];\r\n\r\n\t\tif ( geometry.elementsNeedUpdate && index !== undefined ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );\r\n\t\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, index.array, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.verticesNeedUpdate && position !== undefined ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, position.buffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, position.array, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.normalsNeedUpdate && normal !== undefined ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, normal.buffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, normal.array, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.uvsNeedUpdate && uv !== undefined ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, uv.buffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, uv.array, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.colorsNeedUpdate && color !== undefined ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, color.buffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, color.array, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.tangentsNeedUpdate && tangent !== undefined ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, tangent.buffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, tangent.array, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( dispose ) {\r\n\r\n\t\t\tfor ( var i in geometry.attributes ) {\r\n\r\n\t\t\t\tdelete geometry.attributes[ i ].array;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Buffer rendering\r\n\r\n\tthis.renderBufferImmediate = function ( object, program, material ) {\r\n\r\n\t\tif ( object.hasPositions && ! object.__webglVertexBuffer ) object.__webglVertexBuffer = _gl.createBuffer();\r\n\t\tif ( object.hasNormals && ! object.__webglNormalBuffer ) object.__webglNormalBuffer = _gl.createBuffer();\r\n\t\tif ( object.hasUvs && ! object.__webglUvBuffer ) object.__webglUvBuffer = _gl.createBuffer();\r\n\t\tif ( object.hasColors && ! object.__webglColorBuffer ) object.__webglColorBuffer = _gl.createBuffer();\r\n\r\n\t\tif ( object.hasPositions ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglVertexBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\r\n\t\t\t_gl.enableVertexAttribArray( program.attributes.position );\r\n\t\t\t_gl.vertexAttribPointer( program.attributes.position, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.hasNormals ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglNormalBuffer );\r\n\r\n\t\t\tif ( material.shading === THREE.FlatShading ) {\r\n\r\n\t\t\t\tvar nx, ny, nz,\r\n\t\t\t\t\tnax, nbx, ncx, nay, nby, ncy, naz, nbz, ncz,\r\n\t\t\t\t\tnormalArray,\r\n\t\t\t\t\ti, il = object.count * 3;\r\n\r\n\t\t\t\tfor( i = 0; i < il; i += 9 ) {\r\n\r\n\t\t\t\t\tnormalArray = object.normalArray;\r\n\r\n\t\t\t\t\tnax  = normalArray[ i ];\r\n\t\t\t\t\tnay  = normalArray[ i + 1 ];\r\n\t\t\t\t\tnaz  = normalArray[ i + 2 ];\r\n\r\n\t\t\t\t\tnbx  = normalArray[ i + 3 ];\r\n\t\t\t\t\tnby  = normalArray[ i + 4 ];\r\n\t\t\t\t\tnbz  = normalArray[ i + 5 ];\r\n\r\n\t\t\t\t\tncx  = normalArray[ i + 6 ];\r\n\t\t\t\t\tncy  = normalArray[ i + 7 ];\r\n\t\t\t\t\tncz  = normalArray[ i + 8 ];\r\n\r\n\t\t\t\t\tnx = ( nax + nbx + ncx ) / 3;\r\n\t\t\t\t\tny = ( nay + nby + ncy ) / 3;\r\n\t\t\t\t\tnz = ( naz + nbz + ncz ) / 3;\r\n\r\n\t\t\t\t\tnormalArray[ i ] \t = nx;\r\n\t\t\t\t\tnormalArray[ i + 1 ] = ny;\r\n\t\t\t\t\tnormalArray[ i + 2 ] = nz;\r\n\r\n\t\t\t\t\tnormalArray[ i + 3 ] = nx;\r\n\t\t\t\t\tnormalArray[ i + 4 ] = ny;\r\n\t\t\t\t\tnormalArray[ i + 5 ] = nz;\r\n\r\n\t\t\t\t\tnormalArray[ i + 6 ] = nx;\r\n\t\t\t\t\tnormalArray[ i + 7 ] = ny;\r\n\t\t\t\t\tnormalArray[ i + 8 ] = nz;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\r\n\t\t\t_gl.enableVertexAttribArray( program.attributes.normal );\r\n\t\t\t_gl.vertexAttribPointer( program.attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.hasUvs && material.map ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglUvBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\r\n\t\t\t_gl.enableVertexAttribArray( program.attributes.uv );\r\n\t\t\t_gl.vertexAttribPointer( program.attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.hasColors && material.vertexColors !== THREE.NoColors ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglColorBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\r\n\t\t\t_gl.enableVertexAttribArray( program.attributes.color );\r\n\t\t\t_gl.vertexAttribPointer( program.attributes.color, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\t_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\r\n\r\n\t\tobject.count = 0;\r\n\r\n\t};\r\n\r\n\tthis.renderBufferDirect = function ( camera, lights, fog, material, geometry, object ) {\r\n\r\n\t\tif ( material.visible === false ) return;\r\n\r\n\t\tvar program, attributes, linewidth, primitives, a, attribute;\r\n\r\n\t\tprogram = setProgram( camera, lights, fog, material, object );\r\n\r\n\t\tattributes = program.attributes;\r\n\r\n\t\tvar updateBuffers = false,\r\n\t\t\twireframeBit = material.wireframe ? 1 : 0,\r\n\t\t\tgeometryHash = ( geometry.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;\r\n\r\n\t\tif ( geometryHash !== _currentGeometryGroupHash ) {\r\n\r\n\t\t\t_currentGeometryGroupHash = geometryHash;\r\n\t\t\tupdateBuffers = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( updateBuffers ) {\r\n\r\n\t\t\tdisableAttributes();\r\n\r\n\t\t}\r\n\r\n\t\t// render mesh\r\n\r\n\t\tif ( object instanceof THREE.Mesh ) {\r\n\r\n\t\t\tvar index = geometry.attributes[ \"index\" ];\r\n\r\n\t\t\t// indexed triangles\r\n\r\n\t\t\tif ( index ) {\r\n\r\n\t\t\t\tvar offsets = geometry.offsets;\r\n\r\n\t\t\t\t// if there is more than 1 chunk\r\n\t\t\t\t// must set attribute pointers to use new offsets for each chunk\r\n\t\t\t\t// even if geometry and materials didn't change\r\n\r\n\t\t\t\tif ( offsets.length > 1 ) updateBuffers = true;\r\n\r\n\t\t\t\tfor ( var i = 0, il = offsets.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tvar startIndex = offsets[ i ].index;\r\n\r\n\t\t\t\t\tif ( updateBuffers ) {\r\n\r\n\t\t\t\t\t\t// vertices\r\n\r\n\t\t\t\t\t\tvar position = geometry.attributes[ \"position\" ];\r\n\t\t\t\t\t\tvar positionSize = position.itemSize;\r\n\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, position.buffer );\r\n\t\t\t\t\t\tenableAttribute( attributes.position );\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes.position, positionSize, _gl.FLOAT, false, 0, startIndex * positionSize * 4 ); // 4 bytes per Float32\r\n\r\n\t\t\t\t\t\t// normals\r\n\r\n\t\t\t\t\t\tvar normal = geometry.attributes[ \"normal\" ];\r\n\r\n\t\t\t\t\t\tif ( attributes.normal >= 0 && normal ) {\r\n\r\n\t\t\t\t\t\t\tvar normalSize = normal.itemSize;\r\n\r\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, normal.buffer );\r\n\t\t\t\t\t\t\tenableAttribute( attributes.normal );\r\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( attributes.normal, normalSize, _gl.FLOAT, false, 0, startIndex * normalSize * 4 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// uvs\r\n\r\n\t\t\t\t\t\tvar uv = geometry.attributes[ \"uv\" ];\r\n\r\n\t\t\t\t\t\tif ( attributes.uv >= 0 && uv ) {\r\n\r\n\t\t\t\t\t\t\tvar uvSize = uv.itemSize;\r\n\r\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, uv.buffer );\r\n\t\t\t\t\t\t\tenableAttribute( attributes.uv );\r\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( attributes.uv, uvSize, _gl.FLOAT, false, 0, startIndex * uvSize * 4 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// colors\r\n\r\n\t\t\t\t\t\tvar color = geometry.attributes[ \"color\" ];\r\n\r\n\t\t\t\t\t\tif ( attributes.color >= 0 && color ) {\r\n\r\n\t\t\t\t\t\t\tvar colorSize = color.itemSize;\r\n\r\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, color.buffer );\r\n\t\t\t\t\t\t\tenableAttribute( attributes.color );\r\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( attributes.color, colorSize, _gl.FLOAT, false, 0, startIndex * colorSize * 4 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// tangents\r\n\r\n\t\t\t\t\t\tvar tangent = geometry.attributes[ \"tangent\" ];\r\n\r\n\t\t\t\t\t\tif ( attributes.tangent >= 0 && tangent ) {\r\n\r\n\t\t\t\t\t\t\tvar tangentSize = tangent.itemSize;\r\n\r\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, tangent.buffer );\r\n\t\t\t\t\t\t\tenableAttribute( attributes.tangent );\r\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( attributes.tangent, tangentSize, _gl.FLOAT, false, 0, startIndex * tangentSize * 4 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// indices\r\n\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// render indexed triangles\r\n\r\n\t\t\t\t\t_gl.drawElements( _gl.TRIANGLES, offsets[ i ].count, _gl.UNSIGNED_SHORT, offsets[ i ].start * 2 ); // 2 bytes per Uint16\r\n\r\n\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t_this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared\r\n\t\t\t\t\t_this.info.render.faces += offsets[ i ].count / 3;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t// non-indexed triangles\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( updateBuffers ) {\r\n\r\n\t\t\t\t\t// vertices\r\n\r\n\t\t\t\t\tvar position = geometry.attributes[ \"position\" ];\r\n\t\t\t\t\tvar positionSize = position.itemSize;\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, position.buffer );\r\n\t\t\t\t\tenableAttribute( attributes.position );\r\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.position, positionSize, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t\t// normals\r\n\r\n\t\t\t\t\tvar normal = geometry.attributes[ \"normal\" ];\r\n\r\n\t\t\t\t\tif ( attributes.normal >= 0 && normal ) {\r\n\r\n\t\t\t\t\t\tvar normalSize = normal.itemSize;\r\n\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, normal.buffer );\r\n\t\t\t\t\t\tenableAttribute( attributes.normal );\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes.normal, normalSize, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// uvs\r\n\r\n\t\t\t\t\tvar uv = geometry.attributes[ \"uv\" ];\r\n\r\n\t\t\t\t\tif ( attributes.uv >= 0 && uv ) {\r\n\r\n\t\t\t\t\t\tvar uvSize = uv.itemSize;\r\n\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, uv.buffer );\r\n\t\t\t\t\t\tenableAttribute( attributes.uv );\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes.uv, uvSize, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// colors\r\n\r\n\t\t\t\t\tvar color = geometry.attributes[ \"color\" ];\r\n\r\n\t\t\t\t\tif ( attributes.color >= 0 && color ) {\r\n\r\n\t\t\t\t\t\tvar colorSize = color.itemSize;\r\n\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, color.buffer );\r\n\t\t\t\t\t\tenableAttribute( attributes.color );\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes.color, colorSize, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// tangents\r\n\r\n\t\t\t\t\tvar tangent = geometry.attributes[ \"tangent\" ];\r\n\r\n\t\t\t\t\tif ( attributes.tangent >= 0 && tangent ) {\r\n\r\n\t\t\t\t\t\tvar tangentSize = tangent.itemSize;\r\n\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, tangent.buffer );\r\n\t\t\t\t\t\tenableAttribute( attributes.tangent );\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes.tangent, tangentSize, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// render non-indexed triangles\r\n\r\n\t\t\t\t_gl.drawArrays( _gl.TRIANGLES, 0, position.numItems / 3 );\r\n\r\n\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t_this.info.render.vertices += position.numItems / 3;\r\n\t\t\t\t_this.info.render.faces += position.numItems / 3 / 3;\r\n\r\n\t\t\t}\r\n\r\n\t\t// render particles\r\n\r\n\t\t} else if ( object instanceof THREE.ParticleSystem ) {\r\n\r\n\t\t\tif ( updateBuffers ) {\r\n\r\n\t\t\t\t// vertices\r\n\r\n\t\t\t\tvar position = geometry.attributes[ \"position\" ];\r\n\t\t\t\tvar positionSize = position.itemSize;\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, position.buffer );\r\n\t\t\t\tenableAttribute( attributes.position );\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.position, positionSize, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t// colors\r\n\r\n\t\t\t\tvar color = geometry.attributes[ \"color\" ];\r\n\r\n\t\t\t\tif ( attributes.color >= 0 && color ) {\r\n\r\n\t\t\t\t\tvar colorSize = color.itemSize;\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, color.buffer );\r\n\t\t\t\t\tenableAttribute( attributes.color );\r\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.color, colorSize, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// render particles\r\n\r\n\t\t\t\t_gl.drawArrays( _gl.POINTS, 0, position.numItems / 3 );\r\n\r\n\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t_this.info.render.points += position.numItems / 3;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( object instanceof THREE.Line ) {\r\n\r\n\t\t\tif ( updateBuffers ) {\r\n\r\n\t\t\t\t// vertices\r\n\r\n\t\t\t\tvar position = geometry.attributes[ \"position\" ];\r\n\t\t\t\tvar positionSize = position.itemSize;\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, position.buffer );\r\n\t\t\t\tenableAttribute( attributes.position );\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.position, positionSize, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t// colors\r\n\r\n\t\t\t\tvar color = geometry.attributes[ \"color\" ];\r\n\r\n\t\t\t\tif ( attributes.color >= 0 && color ) {\r\n\r\n\t\t\t\t\tvar colorSize = color.itemSize;\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, color.buffer );\r\n\t\t\t\t\tenableAttribute( attributes.color );\r\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.color, colorSize, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// render lines\r\n\r\n\t\t\t\tsetLineWidth( material.linewidth );\r\n\r\n\t\t\t\t_gl.drawArrays( _gl.LINE_STRIP, 0, position.numItems / 3 );\r\n\r\n\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t_this.info.render.points += position.numItems;\r\n\r\n\t\t\t}\r\n\r\n    }\r\n\r\n\t};\r\n\r\n\tthis.renderBuffer = function ( camera, lights, fog, material, geometryGroup, object ) {\r\n\r\n\t\tif ( material.visible === false ) return;\r\n\r\n\t\tvar program, attributes, linewidth, primitives, a, attribute, i, il;\r\n\r\n\t\tprogram = setProgram( camera, lights, fog, material, object );\r\n\r\n\t\tattributes = program.attributes;\r\n\r\n\t\tvar updateBuffers = false,\r\n\t\t\twireframeBit = material.wireframe ? 1 : 0,\r\n\t\t\tgeometryGroupHash = ( geometryGroup.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;\r\n\r\n\t\tif ( geometryGroupHash !== _currentGeometryGroupHash ) {\r\n\r\n\t\t\t_currentGeometryGroupHash = geometryGroupHash;\r\n\t\t\tupdateBuffers = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( updateBuffers ) {\r\n\r\n\t\t\tdisableAttributes();\r\n\r\n\t\t}\r\n\r\n\t\t// vertices\r\n\r\n\t\tif ( !material.morphTargets && attributes.position >= 0 ) {\r\n\r\n\t\t\tif ( updateBuffers ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );\r\n\t\t\t\tenableAttribute( attributes.position );\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( object.morphTargetBase ) {\r\n\r\n\t\t\t\tsetupMorphTargets( material, geometryGroup, object );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\t\tif ( updateBuffers ) {\r\n\r\n\t\t\t// custom attributes\r\n\r\n\t\t\t// Use the per-geometryGroup custom attribute arrays which are setup in initMeshBuffers\r\n\r\n\t\t\tif ( geometryGroup.__webglCustomAttributesList ) {\r\n\r\n\t\t\t\tfor ( i = 0, il = geometryGroup.__webglCustomAttributesList.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tattribute = geometryGroup.__webglCustomAttributesList[ i ];\r\n\r\n\t\t\t\t\tif ( attributes[ attribute.buffer.belongsToAttribute ] >= 0 ) {\r\n\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, attribute.buffer );\r\n\t\t\t\t\t\tenableAttribute( attributes[ attribute.buffer.belongsToAttribute ] );\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes[ attribute.buffer.belongsToAttribute ], attribute.size, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\t// colors\r\n\r\n\t\t\tif ( attributes.color >= 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );\r\n\t\t\t\tenableAttribute( attributes.color );\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// normals\r\n\r\n\t\t\tif ( attributes.normal >= 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );\r\n\t\t\t\tenableAttribute( attributes.normal );\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// tangents\r\n\r\n\t\t\tif ( attributes.tangent >= 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );\r\n\t\t\t\tenableAttribute( attributes.tangent );\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.tangent, 4, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// uvs\r\n\r\n\t\t\tif ( attributes.uv >= 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );\r\n\t\t\t\tenableAttribute( attributes.uv );\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( attributes.uv2 >= 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );\r\n\t\t\t\tenableAttribute( attributes.uv2 );\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.uv2, 2, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( material.skinning &&\r\n\t\t\t\t attributes.skinIndex >= 0 && attributes.skinWeight >= 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );\r\n\t\t\t\tenableAttribute( attributes.skinIndex );\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.skinIndex, 4, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );\r\n\t\t\t\tenableAttribute( attributes.skinWeight );\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.skinWeight, 4, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// line distances\r\n\r\n\t\t\tif ( attributes.lineDistance >= 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglLineDistanceBuffer );\r\n\t\t\t\tenableAttribute( attributes.lineDistance );\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.lineDistance, 1, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// render mesh\r\n\r\n\t\tif ( object instanceof THREE.Mesh ) {\r\n\r\n\t\t\t// wireframe\r\n\r\n\t\t\tif ( material.wireframe ) {\r\n\r\n\t\t\t\tsetLineWidth( material.wireframeLinewidth );\r\n\r\n\t\t\t\tif ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );\r\n\t\t\t\t_gl.drawElements( _gl.LINES, geometryGroup.__webglLineCount, _gl.UNSIGNED_SHORT, 0 );\r\n\r\n\t\t\t// triangles\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );\r\n\t\t\t\t_gl.drawElements( _gl.TRIANGLES, geometryGroup.__webglFaceCount, _gl.UNSIGNED_SHORT, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_this.info.render.calls ++;\r\n\t\t\t_this.info.render.vertices += geometryGroup.__webglFaceCount;\r\n\t\t\t_this.info.render.faces += geometryGroup.__webglFaceCount / 3;\r\n\r\n\t\t// render lines\r\n\r\n\t\t} else if ( object instanceof THREE.Line ) {\r\n\r\n\t\t\tprimitives = ( object.type === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;\r\n\r\n\t\t\tsetLineWidth( material.linewidth );\r\n\r\n\t\t\t_gl.drawArrays( primitives, 0, geometryGroup.__webglLineCount );\r\n\r\n\t\t\t_this.info.render.calls ++;\r\n\r\n\t\t// render particles\r\n\r\n\t\t} else if ( object instanceof THREE.ParticleSystem ) {\r\n\r\n\t\t\t_gl.drawArrays( _gl.POINTS, 0, geometryGroup.__webglParticleCount );\r\n\r\n\t\t\t_this.info.render.calls ++;\r\n\t\t\t_this.info.render.points += geometryGroup.__webglParticleCount;\r\n\r\n\t\t// render ribbon\r\n\r\n\t\t} else if ( object instanceof THREE.Ribbon ) {\r\n\r\n\t\t\t_gl.drawArrays( _gl.TRIANGLE_STRIP, 0, geometryGroup.__webglVertexCount );\r\n\r\n\t\t\t_this.info.render.calls ++;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction enableAttribute( attribute ) {\r\n\r\n\t\tif ( ! _enabledAttributes[ attribute ] ) {\r\n\r\n\t\t\t_gl.enableVertexAttribArray( attribute );\r\n\t\t\t_enabledAttributes[ attribute ] = true;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction disableAttributes() {\r\n\r\n\t\tfor ( var attribute in _enabledAttributes ) {\r\n\r\n\t\t\tif ( _enabledAttributes[ attribute ] ) {\r\n\r\n\t\t\t\t_gl.disableVertexAttribArray( attribute );\r\n\t\t\t\t_enabledAttributes[ attribute ] = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction setupMorphTargets ( material, geometryGroup, object ) {\r\n\r\n\t\t// set base\r\n\r\n\t\tvar attributes = material.program.attributes;\r\n\r\n\t\tif ( object.morphTargetBase !== -1 && attributes.position >= 0 ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ object.morphTargetBase ] );\r\n\t\t\tenableAttribute( attributes.position );\r\n\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t} else if ( attributes.position >= 0 ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );\r\n\t\t\tenableAttribute( attributes.position );\r\n\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.morphTargetForcedOrder.length ) {\r\n\r\n\t\t\t// set forced order\r\n\r\n\t\t\tvar m = 0;\r\n\t\t\tvar order = object.morphTargetForcedOrder;\r\n\t\t\tvar influences = object.morphTargetInfluences;\r\n\r\n\t\t\twhile ( m < material.numSupportedMorphTargets && m < order.length ) {\r\n\r\n\t\t\t\tif ( attributes[ \"morphTarget\" + m ] >= 0 ) {\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ order[ m ] ] );\r\n\t\t\t\t\tenableAttribute( attributes[ \"morphTarget\" + m ] );\r\n\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphTarget\" + m ], 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( attributes[ \"morphNormal\" + m ] >= 0 && material.morphNormals ) {\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ order[ m ] ] );\r\n\t\t\t\t\tenableAttribute( attributes[ \"morphNormal\" + m ] );\r\n\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphNormal\" + m ], 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tobject.__webglMorphTargetInfluences[ m ] = influences[ order[ m ] ];\r\n\r\n\t\t\t\tm ++;\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// find the most influencing\r\n\r\n\t\t\tvar influence, activeInfluenceIndices = [];\r\n\t\t\tvar influences = object.morphTargetInfluences;\r\n\t\t\tvar i, il = influences.length;\r\n\r\n\t\t\tfor ( i = 0; i < il; i ++ ) {\r\n\r\n\t\t\t\tinfluence = influences[ i ];\r\n\r\n\t\t\t\tif ( influence > 0 ) {\r\n\r\n\t\t\t\t\tactiveInfluenceIndices.push( [ influence, i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( activeInfluenceIndices.length > material.numSupportedMorphTargets ) {\r\n\r\n\t\t\t\tactiveInfluenceIndices.sort( numericalSort );\r\n\t\t\t\tactiveInfluenceIndices.length = material.numSupportedMorphTargets;\r\n\r\n\t\t\t} else if ( activeInfluenceIndices.length > material.numSupportedMorphNormals ) {\r\n\r\n\t\t\t\tactiveInfluenceIndices.sort( numericalSort );\r\n\r\n\t\t\t} else if ( activeInfluenceIndices.length === 0 ) {\r\n\r\n\t\t\t\tactiveInfluenceIndices.push( [ 0, 0 ] );\r\n\r\n\t\t\t};\r\n\r\n\t\t\tvar influenceIndex, m = 0;\r\n\r\n\t\t\twhile ( m < material.numSupportedMorphTargets ) {\r\n\r\n\t\t\t\tif ( activeInfluenceIndices[ m ] ) {\r\n\r\n\t\t\t\t\tinfluenceIndex = activeInfluenceIndices[ m ][ 1 ];\r\n\r\n\t\t\t\t\tif ( attributes[ \"morphTarget\" + m ] >= 0 ) {\r\n\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ influenceIndex ] );\r\n\t\t\t\t\t\tenableAttribute( attributes[ \"morphTarget\" + m ] );\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphTarget\" + m ], 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( attributes[ \"morphNormal\" + m ] >= 0 && material.morphNormals ) {\r\n\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ influenceIndex ] );\r\n\t\t\t\t\t\tenableAttribute( attributes[ \"morphNormal\" + m ] );\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphNormal\" + m ], 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tobject.__webglMorphTargetInfluences[ m ] = influences[ influenceIndex ];\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphTarget\" + m ], 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t\tif ( material.morphNormals ) {\r\n\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphNormal\" + m ], 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\t*/\r\n\r\n\t\t\t\t\tobject.__webglMorphTargetInfluences[ m ] = 0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tm ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// load updated influences uniform\r\n\r\n\t\tif ( material.program.uniforms.morphTargetInfluences !== null ) {\r\n\r\n\t\t\t_gl.uniform1fv( material.program.uniforms.morphTargetInfluences, object.__webglMorphTargetInfluences );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Sorting\r\n\r\n\tfunction painterSortStable ( a, b ) {\r\n\r\n\t\tif ( a.z !== b.z ) {\r\n\r\n\t\t\treturn b.z - a.z;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn b.id - a.id;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction numericalSort ( a, b ) {\r\n\r\n\t\treturn b[ 0 ] - a[ 0 ];\r\n\r\n\t};\r\n\r\n\r\n\t// Rendering\r\n\r\n\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\r\n\r\n\t\tif ( camera instanceof THREE.Camera === false ) {\r\n\r\n\t\t\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar i, il,\r\n\r\n\t\twebglObject, object,\r\n\t\trenderList,\r\n\r\n\t\tlights = scene.__lights,\r\n\t\tfog = scene.fog;\r\n\r\n\t\t// reset caching for this frame\r\n\r\n\t\t_currentMaterialId = -1;\r\n\t\t_lightsNeedUpdate = true;\r\n\r\n\t\t// update scene graph\r\n\r\n\t\tif ( this.autoUpdateScene ) scene.updateMatrixWorld();\r\n\r\n\t\t// update camera matrices and frustum\r\n\r\n\t\tif ( camera.parent === undefined ) camera.updateMatrixWorld();\r\n\r\n\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\r\n\r\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\r\n\t\t_frustum.setFromMatrix( _projScreenMatrix );\r\n\r\n\t\t// update WebGL objects\r\n\r\n\t\tif ( this.autoUpdateObjects ) this.initWebGLObjects( scene );\r\n\r\n\t\t// custom render plugins (pre pass)\r\n\r\n\t\trenderPlugins( this.renderPluginsPre, scene, camera );\r\n\r\n\t\t//\r\n\r\n\t\t_this.info.render.calls = 0;\r\n\t\t_this.info.render.vertices = 0;\r\n\t\t_this.info.render.faces = 0;\r\n\t\t_this.info.render.points = 0;\r\n\r\n\t\tthis.setRenderTarget( renderTarget );\r\n\r\n\t\tif ( this.autoClear || forceClear ) {\r\n\r\n\t\t\tthis.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );\r\n\r\n\t\t}\r\n\r\n\t\t// set matrices for regular objects (frustum culled)\r\n\r\n\t\trenderList = scene.__webglObjects;\r\n\r\n\t\tfor ( i = 0, il = renderList.length; i < il; i ++ ) {\r\n\r\n\t\t\twebglObject = renderList[ i ];\r\n\t\t\tobject = webglObject.object;\r\n\r\n\t\t\twebglObject.render = false;\r\n\r\n\t\t\tif ( object.visible ) {\r\n\r\n\t\t\t\tif ( ! ( object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.intersectsObject( object ) ) {\r\n\r\n\t\t\t\t\tsetupMatrices( object, camera );\r\n\r\n\t\t\t\t\tunrollBufferMaterial( webglObject );\r\n\r\n\t\t\t\t\twebglObject.render = true;\r\n\r\n\t\t\t\t\tif ( this.sortObjects === true ) {\r\n\r\n\t\t\t\t\t\tif ( object.renderDepth !== null ) {\r\n\r\n\t\t\t\t\t\t\twebglObject.z = object.renderDepth;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t_vector3.getPositionFromMatrix( object.matrixWorld );\r\n\t\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\r\n\r\n\t\t\t\t\t\t\twebglObject.z = _vector3.z;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\twebglObject.id = object.id;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.sortObjects ) {\r\n\r\n\t\t\trenderList.sort( painterSortStable );\r\n\r\n\t\t}\r\n\r\n\t\t// set matrices for immediate objects\r\n\r\n\t\trenderList = scene.__webglObjectsImmediate;\r\n\r\n\t\tfor ( i = 0, il = renderList.length; i < il; i ++ ) {\r\n\r\n\t\t\twebglObject = renderList[ i ];\r\n\t\t\tobject = webglObject.object;\r\n\r\n\t\t\tif ( object.visible ) {\r\n\r\n\t\t\t\tsetupMatrices( object, camera );\r\n\r\n\t\t\t\tunrollImmediateBufferMaterial( webglObject );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( scene.overrideMaterial ) {\r\n\r\n\t\t\tvar material = scene.overrideMaterial;\r\n\r\n\t\t\tthis.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\r\n\t\t\tthis.setDepthTest( material.depthTest );\r\n\t\t\tthis.setDepthWrite( material.depthWrite );\r\n\t\t\tsetPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\r\n\r\n\t\t\trenderObjects( scene.__webglObjects, false, \"\", camera, lights, fog, true, material );\r\n\t\t\trenderObjectsImmediate( scene.__webglObjectsImmediate, \"\", camera, lights, fog, false, material );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar material = null;\r\n\r\n\t\t\t// opaque pass (front-to-back order)\r\n\r\n\t\t\tthis.setBlending( THREE.NoBlending );\r\n\r\n\t\t\trenderObjects( scene.__webglObjects, true, \"opaque\", camera, lights, fog, false, material );\r\n\t\t\trenderObjectsImmediate( scene.__webglObjectsImmediate, \"opaque\", camera, lights, fog, false, material );\r\n\r\n\t\t\t// transparent pass (back-to-front order)\r\n\r\n\t\t\trenderObjects( scene.__webglObjects, false, \"transparent\", camera, lights, fog, true, material );\r\n\t\t\trenderObjectsImmediate( scene.__webglObjectsImmediate, \"transparent\", camera, lights, fog, true, material );\r\n\r\n\t\t}\r\n\r\n\t\t// custom render plugins (post pass)\r\n\r\n\t\trenderPlugins( this.renderPluginsPost, scene, camera );\r\n\r\n\r\n\t\t// Generate mipmap if we're using any kind of mipmap filtering\r\n\r\n\t\tif ( renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter ) {\r\n\r\n\t\t\tupdateRenderTargetMipmap( renderTarget );\r\n\r\n\t\t}\r\n\r\n\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\r\n\r\n\t\tthis.setDepthTest( true );\r\n\t\tthis.setDepthWrite( true );\r\n\r\n\t\t// _gl.finish();\r\n\r\n\t};\r\n\r\n\tfunction renderPlugins( plugins, scene, camera ) {\r\n\r\n\t\tif ( ! plugins.length ) return;\r\n\r\n\t\tfor ( var i = 0, il = plugins.length; i < il; i ++ ) {\r\n\r\n\t\t\t// reset state for plugin (to start from clean slate)\r\n\r\n\t\t\t_currentProgram = null;\r\n\t\t\t_currentCamera = null;\r\n\r\n\t\t\t_oldBlending = -1;\r\n\t\t\t_oldDepthTest = -1;\r\n\t\t\t_oldDepthWrite = -1;\r\n\t\t\t_oldDoubleSided = -1;\r\n\t\t\t_oldFlipSided = -1;\r\n\t\t\t_currentGeometryGroupHash = -1;\r\n\t\t\t_currentMaterialId = -1;\r\n\r\n\t\t\t_lightsNeedUpdate = true;\r\n\r\n\t\t\tplugins[ i ].render( scene, camera, _currentWidth, _currentHeight );\r\n\r\n\t\t\t// reset state after plugin (anything could have changed)\r\n\r\n\t\t\t_currentProgram = null;\r\n\t\t\t_currentCamera = null;\r\n\r\n\t\t\t_oldBlending = -1;\r\n\t\t\t_oldDepthTest = -1;\r\n\t\t\t_oldDepthWrite = -1;\r\n\t\t\t_oldDoubleSided = -1;\r\n\t\t\t_oldFlipSided = -1;\r\n\t\t\t_currentGeometryGroupHash = -1;\r\n\t\t\t_currentMaterialId = -1;\r\n\r\n\t\t\t_lightsNeedUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction renderObjects ( renderList, reverse, materialType, camera, lights, fog, useBlending, overrideMaterial ) {\r\n\r\n\t\tvar webglObject, object, buffer, material, start, end, delta;\r\n\r\n\t\tif ( reverse ) {\r\n\r\n\t\t\tstart = renderList.length - 1;\r\n\t\t\tend = -1;\r\n\t\t\tdelta = -1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tstart = 0;\r\n\t\t\tend = renderList.length;\r\n\t\t\tdelta = 1;\r\n\t\t}\r\n\r\n\t\tfor ( var i = start; i !== end; i += delta ) {\r\n\r\n\t\t\twebglObject = renderList[ i ];\r\n\r\n\t\t\tif ( webglObject.render ) {\r\n\r\n\t\t\t\tobject = webglObject.object;\r\n\t\t\t\tbuffer = webglObject.buffer;\r\n\r\n\t\t\t\tif ( overrideMaterial ) {\r\n\r\n\t\t\t\t\tmaterial = overrideMaterial;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tmaterial = webglObject[ materialType ];\r\n\r\n\t\t\t\t\tif ( ! material ) continue;\r\n\r\n\t\t\t\t\tif ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\r\n\r\n\t\t\t\t\t_this.setDepthTest( material.depthTest );\r\n\t\t\t\t\t_this.setDepthWrite( material.depthWrite );\r\n\t\t\t\t\tsetPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_this.setMaterialFaces( material );\r\n\r\n\t\t\t\tif ( buffer instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\t\t\t_this.renderBufferDirect( camera, lights, fog, material, buffer, object );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t_this.renderBuffer( camera, lights, fog, material, buffer, object );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction renderObjectsImmediate ( renderList, materialType, camera, lights, fog, useBlending, overrideMaterial ) {\r\n\r\n\t\tvar webglObject, object, material, program;\r\n\r\n\t\tfor ( var i = 0, il = renderList.length; i < il; i ++ ) {\r\n\r\n\t\t\twebglObject = renderList[ i ];\r\n\t\t\tobject = webglObject.object;\r\n\r\n\t\t\tif ( object.visible ) {\r\n\r\n\t\t\t\tif ( overrideMaterial ) {\r\n\r\n\t\t\t\t\tmaterial = overrideMaterial;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tmaterial = webglObject[ materialType ];\r\n\r\n\t\t\t\t\tif ( ! material ) continue;\r\n\r\n\t\t\t\t\tif ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\r\n\r\n\t\t\t\t\t_this.setDepthTest( material.depthTest );\r\n\t\t\t\t\t_this.setDepthWrite( material.depthWrite );\r\n\t\t\t\t\tsetPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_this.renderImmediateObject( camera, lights, fog, material, object );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.renderImmediateObject = function ( camera, lights, fog, material, object ) {\r\n\r\n\t\tvar program = setProgram( camera, lights, fog, material, object );\r\n\r\n\t\t_currentGeometryGroupHash = -1;\r\n\r\n\t\t_this.setMaterialFaces( material );\r\n\r\n\t\tif ( object.immediateRenderCallback ) {\r\n\r\n\t\t\tobject.immediateRenderCallback( program, _gl, _frustum );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tobject.render( function( object ) { _this.renderBufferImmediate( object, program, material ); } );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction unrollImmediateBufferMaterial ( globject ) {\r\n\r\n\t\tvar object = globject.object,\r\n\t\t\tmaterial = object.material;\r\n\r\n\t\tif ( material.transparent ) {\r\n\r\n\t\t\tglobject.transparent = material;\r\n\t\t\tglobject.opaque = null;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tglobject.opaque = material;\r\n\t\t\tglobject.transparent = null;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction unrollBufferMaterial ( globject ) {\r\n\r\n\t\tvar object = globject.object,\r\n\t\t\tbuffer = globject.buffer,\r\n\t\t\tmaterial, materialIndex, meshMaterial;\r\n\r\n\t\tmeshMaterial = object.material;\r\n\r\n\t\tif ( meshMaterial instanceof THREE.MeshFaceMaterial ) {\r\n\r\n\t\t\tmaterialIndex = buffer.materialIndex;\r\n\r\n\t\t\tmaterial = meshMaterial.materials[ materialIndex ];\r\n\r\n\t\t\tif ( material.transparent ) {\r\n\r\n\t\t\t\tglobject.transparent = material;\r\n\t\t\t\tglobject.opaque = null;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tglobject.opaque = material;\r\n\t\t\t\tglobject.transparent = null;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmaterial = meshMaterial;\r\n\r\n\t\t\tif ( material ) {\r\n\r\n\t\t\t\tif ( material.transparent ) {\r\n\r\n\t\t\t\t\tglobject.transparent = material;\r\n\t\t\t\t\tglobject.opaque = null;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tglobject.opaque = material;\r\n\t\t\t\t\tglobject.transparent = null;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Geometry splitting\r\n\r\n\tfunction sortFacesByMaterial ( geometry, material ) {\r\n\r\n\t\tvar f, fl, face, materialIndex, vertices,\r\n\t\t\tgroupHash, hash_map = {};\r\n\r\n\t\tvar numMorphTargets = geometry.morphTargets.length;\r\n\t\tvar numMorphNormals = geometry.morphNormals.length;\r\n\r\n\t\tvar usesFaceMaterial = material instanceof THREE.MeshFaceMaterial;\r\n\r\n\t\tgeometry.geometryGroups = {};\r\n\r\n\t\tfor ( f = 0, fl = geometry.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = geometry.faces[ f ];\r\n\t\t\tmaterialIndex = usesFaceMaterial ? face.materialIndex : 0;\r\n\r\n\t\t\tif ( hash_map[ materialIndex ] === undefined ) {\r\n\r\n\t\t\t\thash_map[ materialIndex ] = { 'hash': materialIndex, 'counter': 0 };\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgroupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;\r\n\r\n\t\t\tif ( geometry.geometryGroups[ groupHash ] === undefined ) {\r\n\r\n\t\t\t\tgeometry.geometryGroups[ groupHash ] = { 'faces3': [], 'faces4': [], 'materialIndex': materialIndex, 'vertices': 0, 'numMorphTargets': numMorphTargets, 'numMorphNormals': numMorphNormals };\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvertices = face instanceof THREE.Face3 ? 3 : 4;\r\n\r\n\t\t\tif ( geometry.geometryGroups[ groupHash ].vertices + vertices > 65535 ) {\r\n\r\n\t\t\t\thash_map[ materialIndex ].counter += 1;\r\n\t\t\t\tgroupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;\r\n\r\n\t\t\t\tif ( geometry.geometryGroups[ groupHash ] === undefined ) {\r\n\r\n\t\t\t\t\tgeometry.geometryGroups[ groupHash ] = { 'faces3': [], 'faces4': [], 'materialIndex': materialIndex, 'vertices': 0, 'numMorphTargets': numMorphTargets, 'numMorphNormals': numMorphNormals };\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( face instanceof THREE.Face3 ) {\r\n\r\n\t\t\t\tgeometry.geometryGroups[ groupHash ].faces3.push( f );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tgeometry.geometryGroups[ groupHash ].faces4.push( f );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.geometryGroups[ groupHash ].vertices += vertices;\r\n\r\n\t\t}\r\n\r\n\t\tgeometry.geometryGroupsList = [];\r\n\r\n\t\tfor ( var g in geometry.geometryGroups ) {\r\n\r\n\t\t\tgeometry.geometryGroups[ g ].id = _geometryGroupCounter ++;\r\n\r\n\t\t\tgeometry.geometryGroupsList.push( geometry.geometryGroups[ g ] );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Objects refresh\r\n\r\n\tthis.initWebGLObjects = function ( scene ) {\r\n\r\n\t\tif ( !scene.__webglObjects ) {\r\n\r\n\t\t\tscene.__webglObjects = [];\r\n\t\t\tscene.__webglObjectsImmediate = [];\r\n\t\t\tscene.__webglSprites = [];\r\n\t\t\tscene.__webglFlares = [];\r\n\r\n\t\t}\r\n\r\n\t\twhile ( scene.__objectsAdded.length ) {\r\n\r\n\t\t\taddObject( scene.__objectsAdded[ 0 ], scene );\r\n\t\t\tscene.__objectsAdded.splice( 0, 1 );\r\n\r\n\t\t}\r\n\r\n\t\twhile ( scene.__objectsRemoved.length ) {\r\n\r\n\t\t\tremoveObject( scene.__objectsRemoved[ 0 ], scene );\r\n\t\t\tscene.__objectsRemoved.splice( 0, 1 );\r\n\r\n\t\t}\r\n\r\n\t\t// update must be called after objects adding / removal\r\n\r\n\t\tfor ( var o = 0, ol = scene.__webglObjects.length; o < ol; o ++ ) {\r\n\r\n\t\t\tupdateObject( scene.__webglObjects[ o ].object );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Objects adding\r\n\r\n\tfunction addObject ( object, scene ) {\r\n\r\n\t\tvar g, geometry, material, geometryGroup;\r\n\r\n\t\tif ( ! object.__webglInit ) {\r\n\r\n\t\t\tobject.__webglInit = true;\r\n\r\n\t\t\tobject._modelViewMatrix = new THREE.Matrix4();\r\n\t\t\tobject._normalMatrix = new THREE.Matrix3();\r\n\r\n\t\t\tif ( object.geometry !== undefined && object.geometry.__webglInit === undefined ) {\r\n\r\n\t\t\t\tobject.geometry.__webglInit = true;\r\n\t\t\t\tobject.geometry.addEventListener( 'dispose', onGeometryDispose );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( object instanceof THREE.Mesh ) {\r\n\r\n\t\t\t\tgeometry = object.geometry;\r\n\t\t\t\tmaterial = object.material;\r\n\r\n\t\t\t\tif ( geometry instanceof THREE.Geometry ) {\r\n\r\n\t\t\t\t\tif ( geometry.geometryGroups === undefined ) {\r\n\r\n\t\t\t\t\t\tsortFacesByMaterial( geometry, material );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// create separate VBOs per geometry chunk\r\n\r\n\t\t\t\t\tfor ( g in geometry.geometryGroups ) {\r\n\r\n\t\t\t\t\t\tgeometryGroup = geometry.geometryGroups[ g ];\r\n\r\n\t\t\t\t\t\t// initialise VBO on the first access\r\n\r\n\t\t\t\t\t\tif ( ! geometryGroup.__webglVertexBuffer ) {\r\n\r\n\t\t\t\t\t\t\tcreateMeshBuffers( geometryGroup );\r\n\t\t\t\t\t\t\tinitMeshBuffers( geometryGroup, object );\r\n\r\n\t\t\t\t\t\t\tgeometry.verticesNeedUpdate = true;\r\n\t\t\t\t\t\t\tgeometry.morphTargetsNeedUpdate = true;\r\n\t\t\t\t\t\t\tgeometry.elementsNeedUpdate = true;\r\n\t\t\t\t\t\t\tgeometry.uvsNeedUpdate = true;\r\n\t\t\t\t\t\t\tgeometry.normalsNeedUpdate = true;\r\n\t\t\t\t\t\t\tgeometry.tangentsNeedUpdate = true;\r\n\t\t\t\t\t\t\tgeometry.colorsNeedUpdate = true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\t\t\tinitDirectBuffers( geometry );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( object instanceof THREE.Ribbon ) {\r\n\r\n\t\t\t\tgeometry = object.geometry;\r\n\r\n\t\t\t\tif ( ! geometry.__webglVertexBuffer ) {\r\n\r\n\t\t\t\t\tcreateRibbonBuffers( geometry );\r\n\t\t\t\t\tinitRibbonBuffers( geometry, object );\r\n\r\n\t\t\t\t\tgeometry.verticesNeedUpdate = true;\r\n\t\t\t\t\tgeometry.colorsNeedUpdate = true;\r\n\t\t\t\t\tgeometry.normalsNeedUpdate = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( object instanceof THREE.Line ) {\r\n\r\n\t\t\t\tgeometry = object.geometry;\r\n\r\n\t\t\t\tif ( ! geometry.__webglVertexBuffer ) {\r\n\r\n\t\t\t\t\tif ( geometry instanceof THREE.Geometry ) {\r\n\r\n            createLineBuffers( geometry );\r\n            initLineBuffers( geometry, object );\r\n\r\n            geometry.verticesNeedUpdate = true;\r\n            geometry.colorsNeedUpdate = true;\r\n            geometry.lineDistancesNeedUpdate = true;\r\n\r\n          } else if ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\t\t\t\tinitDirectBuffers( geometry );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( object instanceof THREE.ParticleSystem ) {\r\n\r\n\t\t\t\tgeometry = object.geometry;\r\n\r\n\t\t\t\tif ( ! geometry.__webglVertexBuffer ) {\r\n\r\n\t\t\t\t\tif ( geometry instanceof THREE.Geometry ) {\r\n\r\n\t\t\t\t\t\tcreateParticleBuffers( geometry );\r\n\t\t\t\t\t\tinitParticleBuffers( geometry, object );\r\n\r\n\t\t\t\t\t\tgeometry.verticesNeedUpdate = true;\r\n\t\t\t\t\t\tgeometry.colorsNeedUpdate = true;\r\n\r\n\t\t\t\t\t} else if ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\t\t\t\tinitDirectBuffers( geometry );\r\n\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! object.__webglActive ) {\r\n\r\n\t\t\tif ( object instanceof THREE.Mesh ) {\r\n\r\n\t\t\t\tgeometry = object.geometry;\r\n\r\n\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\t\t\taddBuffer( scene.__webglObjects, geometry, object );\r\n\r\n\t\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\r\n\r\n\t\t\t\t\tfor ( g in geometry.geometryGroups ) {\r\n\r\n\t\t\t\t\t\tgeometryGroup = geometry.geometryGroups[ g ];\r\n\r\n\t\t\t\t\t\taddBuffer( scene.__webglObjects, geometryGroup, object );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( object instanceof THREE.Ribbon ||\r\n\t\t\t\t\t\tobject instanceof THREE.Line ||\r\n\t\t\t\t\t\tobject instanceof THREE.ParticleSystem ) {\r\n\r\n\t\t\t\tgeometry = object.geometry;\r\n\t\t\t\taddBuffer( scene.__webglObjects, geometry, object );\r\n\r\n\t\t\t} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {\r\n\r\n\t\t\t\taddBufferImmediate( scene.__webglObjectsImmediate, object );\r\n\r\n\t\t\t} else if ( object instanceof THREE.Sprite ) {\r\n\r\n\t\t\t\tscene.__webglSprites.push( object );\r\n\r\n\t\t\t} else if ( object instanceof THREE.LensFlare ) {\r\n\r\n\t\t\t\tscene.__webglFlares.push( object );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobject.__webglActive = true;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction addBuffer ( objlist, buffer, object ) {\r\n\r\n\t\tobjlist.push(\r\n\t\t\t{\r\n\t\t\t\tbuffer: buffer,\r\n\t\t\t\tobject: object,\r\n\t\t\t\topaque: null,\r\n\t\t\t\ttransparent: null\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t};\r\n\r\n\tfunction addBufferImmediate ( objlist, object ) {\r\n\r\n\t\tobjlist.push(\r\n\t\t\t{\r\n\t\t\t\tobject: object,\r\n\t\t\t\topaque: null,\r\n\t\t\t\ttransparent: null\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t};\r\n\r\n\t// Objects updates\r\n\r\n\tfunction updateObject ( object ) {\r\n\r\n\t\tvar geometry = object.geometry,\r\n\t\t\tgeometryGroup, customAttributesDirty, material;\r\n\r\n\t\tif ( object instanceof THREE.Mesh ) {\r\n\r\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\t\tif ( geometry.verticesNeedUpdate || geometry.elementsNeedUpdate ||\r\n\t\t\t\t\t geometry.uvsNeedUpdate || geometry.normalsNeedUpdate ||\r\n\t\t\t\t\t geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate ) {\r\n\r\n\t\t\t\t\tsetDirectBuffers( geometry, _gl.DYNAMIC_DRAW, !geometry.dynamic );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.verticesNeedUpdate = false;\r\n\t\t\t\tgeometry.elementsNeedUpdate = false;\r\n\t\t\t\tgeometry.uvsNeedUpdate = false;\r\n\t\t\t\tgeometry.normalsNeedUpdate = false;\r\n\t\t\t\tgeometry.colorsNeedUpdate = false;\r\n\t\t\t\tgeometry.tangentsNeedUpdate = false;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// check all geometry groups\r\n\r\n\t\t\t\tfor( var i = 0, il = geometry.geometryGroupsList.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tgeometryGroup = geometry.geometryGroupsList[ i ];\r\n\r\n\t\t\t\t\tmaterial = getBufferMaterial( object, geometryGroup );\r\n\r\n\t\t\t\t\tif ( geometry.buffersNeedUpdate ) {\r\n\r\n\t\t\t\t\t\tinitMeshBuffers( geometryGroup, object );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcustomAttributesDirty = material.attributes && areCustomAttributesDirty( material );\r\n\r\n\t\t\t\t\tif ( geometry.verticesNeedUpdate || geometry.morphTargetsNeedUpdate || geometry.elementsNeedUpdate ||\r\n\t\t\t\t\t\t geometry.uvsNeedUpdate || geometry.normalsNeedUpdate ||\r\n\t\t\t\t\t\t geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate || customAttributesDirty ) {\r\n\r\n\t\t\t\t\t\tsetMeshBuffers( geometryGroup, object, _gl.DYNAMIC_DRAW, !geometry.dynamic, material );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.verticesNeedUpdate = false;\r\n\t\t\t\tgeometry.morphTargetsNeedUpdate = false;\r\n\t\t\t\tgeometry.elementsNeedUpdate = false;\r\n\t\t\t\tgeometry.uvsNeedUpdate = false;\r\n\t\t\t\tgeometry.normalsNeedUpdate = false;\r\n\t\t\t\tgeometry.colorsNeedUpdate = false;\r\n\t\t\t\tgeometry.tangentsNeedUpdate = false;\r\n\r\n\t\t\t\tgeometry.buffersNeedUpdate = false;\r\n\r\n\t\t\t\tmaterial.attributes && clearCustomAttributes( material );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( object instanceof THREE.Ribbon ) {\r\n\r\n\t\t\tmaterial = getBufferMaterial( object, geometry );\r\n\r\n\t\t\tcustomAttributesDirty = material.attributes && areCustomAttributesDirty( material );\r\n\r\n\t\t\tif ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.normalsNeedUpdate || customAttributesDirty ) {\r\n\r\n\t\t\t\tsetRibbonBuffers( geometry, _gl.DYNAMIC_DRAW );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.verticesNeedUpdate = false;\r\n\t\t\tgeometry.colorsNeedUpdate = false;\r\n\t\t\tgeometry.normalsNeedUpdate = false;\r\n\r\n\t\t\tmaterial.attributes && clearCustomAttributes( material );\r\n\r\n\t\t} else if ( object instanceof THREE.Line ) {\r\n\r\n      if ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\t\tif ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate ) {\r\n\r\n\t\t\t\t\tsetDirectBuffers( geometry, _gl.DYNAMIC_DRAW, !geometry.dynamic );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.verticesNeedUpdate = false;\r\n\t\t\t\tgeometry.colorsNeedUpdate = false;\r\n\r\n\t\t\t} else {\r\n\r\n        material = getBufferMaterial( object, geometry );\r\n\r\n        customAttributesDirty = material.attributes && areCustomAttributesDirty( material );\r\n\r\n        if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.lineDistancesNeedUpdate || customAttributesDirty ) {\r\n\r\n          setLineBuffers( geometry, _gl.DYNAMIC_DRAW );\r\n\r\n        }\r\n\r\n        geometry.verticesNeedUpdate = false;\r\n        geometry.colorsNeedUpdate = false;\r\n        geometry.lineDistancesNeedUpdate = false;\r\n\r\n        material.attributes && clearCustomAttributes( material );\r\n\r\n      }\r\n\r\n\t\t} else if ( object instanceof THREE.ParticleSystem ) {\r\n\r\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\t\tif ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate ) {\r\n\r\n\t\t\t\t\tsetDirectBuffers( geometry, _gl.DYNAMIC_DRAW, !geometry.dynamic );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.verticesNeedUpdate = false;\r\n\t\t\t\tgeometry.colorsNeedUpdate = false;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tmaterial = getBufferMaterial( object, geometry );\r\n\r\n\t\t\t\tcustomAttributesDirty = material.attributes && areCustomAttributesDirty( material );\r\n\r\n\t\t\t\tif ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || object.sortParticles || customAttributesDirty ) {\r\n\r\n\t\t\t\t\tsetParticleBuffers( geometry, _gl.DYNAMIC_DRAW, object );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.verticesNeedUpdate = false;\r\n\t\t\t\tgeometry.colorsNeedUpdate = false;\r\n\r\n\t\t\t\tmaterial.attributes && clearCustomAttributes( material );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Objects updates - custom attributes check\r\n\r\n\tfunction areCustomAttributesDirty ( material ) {\r\n\r\n\t\tfor ( var a in material.attributes ) {\r\n\r\n\t\t\tif ( material.attributes[ a ].needsUpdate ) return true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t};\r\n\r\n\tfunction clearCustomAttributes ( material ) {\r\n\r\n\t\tfor ( var a in material.attributes ) {\r\n\r\n\t\t\tmaterial.attributes[ a ].needsUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Objects removal\r\n\r\n\tfunction removeObject ( object, scene ) {\r\n\r\n\t\tif ( object instanceof THREE.Mesh  ||\r\n\t\t\t object instanceof THREE.ParticleSystem ||\r\n\t\t\t object instanceof THREE.Ribbon ||\r\n\t\t\t object instanceof THREE.Line ) {\r\n\r\n\t\t\tremoveInstances( scene.__webglObjects, object );\r\n\r\n\t\t} else if ( object instanceof THREE.Sprite ) {\r\n\r\n\t\t\tremoveInstancesDirect( scene.__webglSprites, object );\r\n\r\n\t\t} else if ( object instanceof THREE.LensFlare ) {\r\n\r\n\t\t\tremoveInstancesDirect( scene.__webglFlares, object );\r\n\r\n\t\t} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {\r\n\r\n\t\t\tremoveInstances( scene.__webglObjectsImmediate, object );\r\n\r\n\t\t}\r\n\r\n\t\tobject.__webglActive = false;\r\n\r\n\t};\r\n\r\n\tfunction removeInstances ( objlist, object ) {\r\n\r\n\t\tfor ( var o = objlist.length - 1; o >= 0; o -- ) {\r\n\r\n\t\t\tif ( objlist[ o ].object === object ) {\r\n\r\n\t\t\t\tobjlist.splice( o, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction removeInstancesDirect ( objlist, object ) {\r\n\r\n\t\tfor ( var o = objlist.length - 1; o >= 0; o -- ) {\r\n\r\n\t\t\tif ( objlist[ o ] === object ) {\r\n\r\n\t\t\t\tobjlist.splice( o, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Materials\r\n\r\n\tthis.initMaterial = function ( material, lights, fog, object ) {\r\n\r\n\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\r\n\r\n\t\tvar u, a, identifiers, i, parameters, maxLightCount, maxBones, maxShadows, shaderID;\r\n\r\n\t\tif ( material instanceof THREE.MeshDepthMaterial ) {\r\n\r\n\t\t\tshaderID = 'depth';\r\n\r\n\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\r\n\r\n\t\t\tshaderID = 'normal';\r\n\r\n\t\t} else if ( material instanceof THREE.MeshBasicMaterial ) {\r\n\r\n\t\t\tshaderID = 'basic';\r\n\r\n\t\t} else if ( material instanceof THREE.MeshLambertMaterial ) {\r\n\r\n\t\t\tshaderID = 'lambert';\r\n\r\n\t\t} else if ( material instanceof THREE.MeshPhongMaterial ) {\r\n\r\n\t\t\tshaderID = 'phong';\r\n\r\n\t\t} else if ( material instanceof THREE.LineBasicMaterial ) {\r\n\r\n\t\t\tshaderID = 'basic';\r\n\r\n\t\t} else if ( material instanceof THREE.LineDashedMaterial ) {\r\n\r\n\t\t\tshaderID = 'dashed';\r\n\r\n\t\t} else if ( material instanceof THREE.ParticleBasicMaterial ) {\r\n\r\n\t\t\tshaderID = 'particle_basic';\r\n\r\n\t\t}\r\n\r\n\t\tif ( shaderID ) {\r\n\r\n\t\t\tsetMaterialShaders( material, THREE.ShaderLib[ shaderID ] );\r\n\r\n\t\t}\r\n\r\n\t\t// heuristics to create shader parameters according to lights in the scene\r\n\t\t// (not to blow over maxLights budget)\r\n\r\n\t\tmaxLightCount = allocateLights( lights );\r\n\r\n\t\tmaxShadows = allocateShadows( lights );\r\n\r\n\t\tmaxBones = allocateBones( object );\r\n\r\n\t\tparameters = {\r\n\r\n\t\t\tmap: !!material.map,\r\n\t\t\tenvMap: !!material.envMap,\r\n\t\t\tlightMap: !!material.lightMap,\r\n\t\t\tbumpMap: !!material.bumpMap,\r\n\t\t\tnormalMap: !!material.normalMap,\r\n\t\t\tspecularMap: !!material.specularMap,\r\n\r\n\t\t\tvertexColors: material.vertexColors,\r\n\r\n\t\t\tfog: fog,\r\n\t\t\tuseFog: material.fog,\r\n\t\t\tfogExp: fog instanceof THREE.FogExp2,\r\n\r\n\t\t\tsizeAttenuation: material.sizeAttenuation,\r\n\r\n\t\t\tskinning: material.skinning,\r\n\t\t\tmaxBones: maxBones,\r\n\t\t\tuseVertexTexture: _supportsBoneTextures && object && object.useVertexTexture,\r\n\t\t\tboneTextureWidth: object && object.boneTextureWidth,\r\n\t\t\tboneTextureHeight: object && object.boneTextureHeight,\r\n\r\n\t\t\tmorphTargets: material.morphTargets,\r\n\t\t\tmorphNormals: material.morphNormals,\r\n\t\t\tmaxMorphTargets: this.maxMorphTargets,\r\n\t\t\tmaxMorphNormals: this.maxMorphNormals,\r\n\r\n\t\t\tmaxDirLights: maxLightCount.directional,\r\n\t\t\tmaxPointLights: maxLightCount.point,\r\n\t\t\tmaxSpotLights: maxLightCount.spot,\r\n\t\t\tmaxHemiLights: maxLightCount.hemi,\r\n\r\n\t\t\tmaxShadows: maxShadows,\r\n\t\t\tshadowMapEnabled: this.shadowMapEnabled && object.receiveShadow,\r\n\t\t\tshadowMapType: this.shadowMapType,\r\n\t\t\tshadowMapDebug: this.shadowMapDebug,\r\n\t\t\tshadowMapCascade: this.shadowMapCascade,\r\n\r\n\t\t\talphaTest: material.alphaTest,\r\n\t\t\tmetal: material.metal,\r\n\t\t\tperPixel: material.perPixel,\r\n\t\t\twrapAround: material.wrapAround,\r\n\t\t\tdoubleSided: material.side === THREE.DoubleSide,\r\n\t\t\tflipSided: material.side === THREE.BackSide\r\n\r\n\t\t};\r\n\r\n\t\tmaterial.program = buildProgram( shaderID, material.fragmentShader, material.vertexShader, material.uniforms, material.attributes, material.defines, parameters );\r\n\r\n\t\tvar attributes = material.program.attributes;\r\n\r\n\t\tif ( material.morphTargets ) {\r\n\r\n\t\t\tmaterial.numSupportedMorphTargets = 0;\r\n\r\n\t\t\tvar id, base = \"morphTarget\";\r\n\r\n\t\t\tfor ( i = 0; i < this.maxMorphTargets; i ++ ) {\r\n\r\n\t\t\t\tid = base + i;\r\n\r\n\t\t\t\tif ( attributes[ id ] >= 0 ) {\r\n\r\n\t\t\t\t\tmaterial.numSupportedMorphTargets ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.morphNormals ) {\r\n\r\n\t\t\tmaterial.numSupportedMorphNormals = 0;\r\n\r\n\t\t\tvar id, base = \"morphNormal\";\r\n\r\n\t\t\tfor ( i = 0; i < this.maxMorphNormals; i ++ ) {\r\n\r\n\t\t\t\tid = base + i;\r\n\r\n\t\t\t\tif ( attributes[ id ] >= 0 ) {\r\n\r\n\t\t\t\t\tmaterial.numSupportedMorphNormals ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tmaterial.uniformsList = [];\r\n\r\n\t\tfor ( u in material.uniforms ) {\r\n\r\n\t\t\tmaterial.uniformsList.push( [ material.uniforms[ u ], u ] );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction setMaterialShaders( material, shaders ) {\r\n\r\n\t\tmaterial.uniforms = THREE.UniformsUtils.clone( shaders.uniforms );\r\n\t\tmaterial.vertexShader = shaders.vertexShader;\r\n\t\tmaterial.fragmentShader = shaders.fragmentShader;\r\n\r\n\t};\r\n\r\n\tfunction setProgram( camera, lights, fog, material, object ) {\r\n\r\n\t\t_usedTextureUnits = 0;\r\n\r\n\t\tif ( material.needsUpdate ) {\r\n\r\n\t\t\tif ( material.program ) deallocateMaterial( material );\r\n\r\n\t\t\t_this.initMaterial( material, lights, fog, object );\r\n\t\t\tmaterial.needsUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.morphTargets ) {\r\n\r\n\t\t\tif ( ! object.__webglMorphTargetInfluences ) {\r\n\r\n\t\t\t\tobject.__webglMorphTargetInfluences = new Float32Array( _this.maxMorphTargets );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar refreshMaterial = false;\r\n\r\n\t\tvar program = material.program,\r\n\t\t\tp_uniforms = program.uniforms,\r\n\t\t\tm_uniforms = material.uniforms;\r\n\r\n\t\tif ( program !== _currentProgram ) {\r\n\r\n\t\t\t_gl.useProgram( program );\r\n\t\t\t_currentProgram = program;\r\n\r\n\t\t\trefreshMaterial = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.id !== _currentMaterialId ) {\r\n\r\n\t\t\t_currentMaterialId = material.id;\r\n\t\t\trefreshMaterial = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( refreshMaterial || camera !== _currentCamera ) {\r\n\r\n\t\t\t_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\r\n\r\n\t\t\tif ( camera !== _currentCamera ) _currentCamera = camera;\r\n\r\n\t\t}\r\n\r\n\t\t// skinning uniforms must be set even if material didn't change\r\n\t\t// auto-setting of texture unit for bone texture must go before other textures\r\n\t\t// not sure why, but otherwise weird things happen\r\n\r\n\t\tif ( material.skinning ) {\r\n\r\n\t\t\tif ( _supportsBoneTextures && object.useVertexTexture ) {\r\n\r\n\t\t\t\tif ( p_uniforms.boneTexture !== null ) {\r\n\r\n\t\t\t\t\tvar textureUnit = getTextureUnit();\r\n\r\n\t\t\t\t\t_gl.uniform1i( p_uniforms.boneTexture, textureUnit );\r\n\t\t\t\t\t_this.setTexture( object.boneTexture, textureUnit );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( p_uniforms.boneGlobalMatrices !== null ) {\r\n\r\n\t\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.boneMatrices );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( refreshMaterial ) {\r\n\r\n\t\t\t// refresh uniforms common to several materials\r\n\r\n\t\t\tif ( fog && material.fog ) {\r\n\r\n\t\t\t\trefreshUniformsFog( m_uniforms, fog );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\r\n\t\t\t\t material.lights ) {\r\n\r\n\t\t\t\tif ( _lightsNeedUpdate ) {\r\n\r\n\t\t\t\t\tsetupLights( program, lights );\r\n\t\t\t\t\t_lightsNeedUpdate = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\trefreshUniformsLights( m_uniforms, _lights );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( material instanceof THREE.MeshBasicMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshPhongMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsCommon( m_uniforms, material );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// refresh single material specific uniforms\r\n\r\n\t\t\tif ( material instanceof THREE.LineBasicMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsLine( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.LineDashedMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsLine( m_uniforms, material );\r\n\t\t\t\trefreshUniformsDash( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.ParticleBasicMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsParticle( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshPhongMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsPhong( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshLambertMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsLambert( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshDepthMaterial ) {\r\n\r\n\t\t\t\tm_uniforms.mNear.value = camera.near;\r\n\t\t\t\tm_uniforms.mFar.value = camera.far;\r\n\t\t\t\tm_uniforms.opacity.value = material.opacity;\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\r\n\r\n\t\t\t\tm_uniforms.opacity.value = material.opacity;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( object.receiveShadow && ! material._shadowPass ) {\r\n\r\n\t\t\t\trefreshUniformsShadow( m_uniforms, lights );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// load common uniforms\r\n\r\n\t\t\tloadUniformsGeneric( program, material.uniformsList );\r\n\r\n\t\t\t// load material specific uniforms\r\n\t\t\t// (shader material also gets them for the sake of genericity)\r\n\r\n\t\t\tif ( material instanceof THREE.ShaderMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t material.envMap ) {\r\n\r\n\t\t\t\tif ( p_uniforms.cameraPosition !== null ) {\r\n\r\n\t\t\t\t\t_vector3.getPositionFromMatrix( camera.matrixWorld );\r\n\t\t\t\t\t_gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\r\n\t\t\t\t material instanceof THREE.ShaderMaterial ||\r\n\t\t\t\t material.skinning ) {\r\n\r\n\t\t\t\tif ( p_uniforms.viewMatrix !== null ) {\r\n\r\n\t\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tloadUniformsMatrices( p_uniforms, object );\r\n\r\n\t\tif ( p_uniforms.modelMatrix !== null ) {\r\n\r\n\t\t\t_gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );\r\n\r\n\t\t}\r\n\r\n\t\treturn program;\r\n\r\n\t};\r\n\r\n\t// Uniforms (refresh uniforms objects)\r\n\r\n\tfunction refreshUniformsCommon ( uniforms, material ) {\r\n\r\n\t\tuniforms.opacity.value = material.opacity;\r\n\r\n\t\tif ( _this.gammaInput ) {\r\n\r\n\t\t\tuniforms.diffuse.value.copyGammaToLinear( material.color );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tuniforms.diffuse.value = material.color;\r\n\r\n\t\t}\r\n\r\n\t\tuniforms.map.value = material.map;\r\n\t\tuniforms.lightMap.value = material.lightMap;\r\n\t\tuniforms.specularMap.value = material.specularMap;\r\n\r\n\t\tif ( material.bumpMap ) {\r\n\r\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\r\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.normalMap ) {\r\n\r\n\t\t\tuniforms.normalMap.value = material.normalMap;\r\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\r\n\r\n\t\t}\r\n\r\n\t\t// uv repeat and offset setting priorities\r\n\t\t//\t1. color map\r\n\t\t//\t2. specular map\r\n\t\t//\t3. normal map\r\n\t\t//\t4. bump map\r\n\r\n\t\tvar uvScaleMap;\r\n\r\n\t\tif ( material.map ) {\r\n\r\n\t\t\tuvScaleMap = material.map;\r\n\r\n\t\t} else if ( material.specularMap ) {\r\n\r\n\t\t\tuvScaleMap = material.specularMap;\r\n\r\n\t\t} else if ( material.normalMap ) {\r\n\r\n\t\t\tuvScaleMap = material.normalMap;\r\n\r\n\t\t} else if ( material.bumpMap ) {\r\n\r\n\t\t\tuvScaleMap = material.bumpMap;\r\n\r\n\t\t}\r\n\r\n\t\tif ( uvScaleMap !== undefined ) {\r\n\r\n\t\t\tvar offset = uvScaleMap.offset;\r\n\t\t\tvar repeat = uvScaleMap.repeat;\r\n\r\n\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\r\n\r\n\t\t}\r\n\r\n\t\tuniforms.envMap.value = material.envMap;\r\n\t\tuniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : -1;\r\n\r\n\t\tif ( _this.gammaInput ) {\r\n\r\n\t\t\t//uniforms.reflectivity.value = material.reflectivity * material.reflectivity;\r\n\t\t\tuniforms.reflectivity.value = material.reflectivity;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tuniforms.reflectivity.value = material.reflectivity;\r\n\r\n\t\t}\r\n\r\n\t\tuniforms.refractionRatio.value = material.refractionRatio;\r\n\t\tuniforms.combine.value = material.combine;\r\n\t\tuniforms.useRefract.value = material.envMap && material.envMap.mapping instanceof THREE.CubeRefractionMapping;\r\n\r\n\t};\r\n\r\n\tfunction refreshUniformsLine ( uniforms, material ) {\r\n\r\n\t\tuniforms.diffuse.value = material.color;\r\n\t\tuniforms.opacity.value = material.opacity;\r\n\r\n\t};\r\n\r\n\tfunction refreshUniformsDash ( uniforms, material ) {\r\n\r\n\t\tuniforms.dashSize.value = material.dashSize;\r\n\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\r\n\t\tuniforms.scale.value = material.scale;\r\n\r\n\t};\r\n\r\n\tfunction refreshUniformsParticle ( uniforms, material ) {\r\n\r\n\t\tuniforms.psColor.value = material.color;\r\n\t\tuniforms.opacity.value = material.opacity;\r\n\t\tuniforms.size.value = material.size;\r\n\t\tuniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.\r\n\r\n\t\tuniforms.map.value = material.map;\r\n\r\n\t};\r\n\r\n\tfunction refreshUniformsFog ( uniforms, fog ) {\r\n\r\n\t\tuniforms.fogColor.value = fog.color;\r\n\r\n\t\tif ( fog instanceof THREE.Fog ) {\r\n\r\n\t\t\tuniforms.fogNear.value = fog.near;\r\n\t\t\tuniforms.fogFar.value = fog.far;\r\n\r\n\t\t} else if ( fog instanceof THREE.FogExp2 ) {\r\n\r\n\t\t\tuniforms.fogDensity.value = fog.density;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction refreshUniformsPhong ( uniforms, material ) {\r\n\r\n\t\tuniforms.shininess.value = material.shininess;\r\n\r\n\t\tif ( _this.gammaInput ) {\r\n\r\n\t\t\tuniforms.ambient.value.copyGammaToLinear( material.ambient );\r\n\t\t\tuniforms.emissive.value.copyGammaToLinear( material.emissive );\r\n\t\t\tuniforms.specular.value.copyGammaToLinear( material.specular );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tuniforms.ambient.value = material.ambient;\r\n\t\t\tuniforms.emissive.value = material.emissive;\r\n\t\t\tuniforms.specular.value = material.specular;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.wrapAround ) {\r\n\r\n\t\t\tuniforms.wrapRGB.value.copy( material.wrapRGB );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction refreshUniformsLambert ( uniforms, material ) {\r\n\r\n\t\tif ( _this.gammaInput ) {\r\n\r\n\t\t\tuniforms.ambient.value.copyGammaToLinear( material.ambient );\r\n\t\t\tuniforms.emissive.value.copyGammaToLinear( material.emissive );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tuniforms.ambient.value = material.ambient;\r\n\t\t\tuniforms.emissive.value = material.emissive;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.wrapAround ) {\r\n\r\n\t\t\tuniforms.wrapRGB.value.copy( material.wrapRGB );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction refreshUniformsLights ( uniforms, lights ) {\r\n\r\n\t\tuniforms.ambientLightColor.value = lights.ambient;\r\n\r\n\t\tuniforms.directionalLightColor.value = lights.directional.colors;\r\n\t\tuniforms.directionalLightDirection.value = lights.directional.positions;\r\n\r\n\t\tuniforms.pointLightColor.value = lights.point.colors;\r\n\t\tuniforms.pointLightPosition.value = lights.point.positions;\r\n\t\tuniforms.pointLightDistance.value = lights.point.distances;\r\n\r\n\t\tuniforms.spotLightColor.value = lights.spot.colors;\r\n\t\tuniforms.spotLightPosition.value = lights.spot.positions;\r\n\t\tuniforms.spotLightDistance.value = lights.spot.distances;\r\n\t\tuniforms.spotLightDirection.value = lights.spot.directions;\r\n\t\tuniforms.spotLightAngleCos.value = lights.spot.anglesCos;\r\n\t\tuniforms.spotLightExponent.value = lights.spot.exponents;\r\n\r\n\t\tuniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;\r\n\t\tuniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;\r\n\t\tuniforms.hemisphereLightDirection.value = lights.hemi.positions;\r\n\r\n\t};\r\n\r\n\tfunction refreshUniformsShadow ( uniforms, lights ) {\r\n\r\n\t\tif ( uniforms.shadowMatrix ) {\r\n\r\n\t\t\tvar j = 0;\r\n\r\n\t\t\tfor ( var i = 0, il = lights.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvar light = lights[ i ];\r\n\r\n\t\t\t\tif ( ! light.castShadow ) continue;\r\n\r\n\t\t\t\tif ( light instanceof THREE.SpotLight || ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) ) {\r\n\r\n\t\t\t\t\tuniforms.shadowMap.value[ j ] = light.shadowMap;\r\n\t\t\t\t\tuniforms.shadowMapSize.value[ j ] = light.shadowMapSize;\r\n\r\n\t\t\t\t\tuniforms.shadowMatrix.value[ j ] = light.shadowMatrix;\r\n\r\n\t\t\t\t\tuniforms.shadowDarkness.value[ j ] = light.shadowDarkness;\r\n\t\t\t\t\tuniforms.shadowBias.value[ j ] = light.shadowBias;\r\n\r\n\t\t\t\t\tj ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Uniforms (load to GPU)\r\n\r\n\tfunction loadUniformsMatrices ( uniforms, object ) {\r\n\r\n\t\t_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object._modelViewMatrix.elements );\r\n\r\n\t\tif ( uniforms.normalMatrix ) {\r\n\r\n\t\t\t_gl.uniformMatrix3fv( uniforms.normalMatrix, false, object._normalMatrix.elements );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction getTextureUnit() {\r\n\r\n\t\tvar textureUnit = _usedTextureUnits;\r\n\r\n\t\tif ( textureUnit >= _maxTextures ) {\r\n\r\n\t\t\tconsole.warn( \"WebGLRenderer: trying to use \" + textureUnit + \" texture units while this GPU supports only \" + _maxTextures );\r\n\r\n\t\t}\r\n\r\n\t\t_usedTextureUnits += 1;\r\n\r\n\t\treturn textureUnit;\r\n\r\n\t};\r\n\r\n\tfunction loadUniformsGeneric ( program, uniforms ) {\r\n\r\n\t\tvar uniform, value, type, location, texture, textureUnit, i, il, j, jl, offset;\r\n\r\n\t\tfor ( j = 0, jl = uniforms.length; j < jl; j ++ ) {\r\n\r\n\t\t\tlocation = program.uniforms[ uniforms[ j ][ 1 ] ];\r\n\t\t\tif ( !location ) continue;\r\n\r\n\t\t\tuniform = uniforms[ j ][ 0 ];\r\n\r\n\t\t\ttype = uniform.type;\r\n\t\t\tvalue = uniform.value;\r\n\r\n\t\t\tif ( type === \"i\" ) { // single integer\r\n\r\n\t\t\t\t_gl.uniform1i( location, value );\r\n\r\n\t\t\t} else if ( type === \"f\" ) { // single float\r\n\r\n\t\t\t\t_gl.uniform1f( location, value );\r\n\r\n\t\t\t} else if ( type === \"v2\" ) { // single THREE.Vector2\r\n\r\n\t\t\t\t_gl.uniform2f( location, value.x, value.y );\r\n\r\n\t\t\t} else if ( type === \"v3\" ) { // single THREE.Vector3\r\n\r\n\t\t\t\t_gl.uniform3f( location, value.x, value.y, value.z );\r\n\r\n\t\t\t} else if ( type === \"v4\" ) { // single THREE.Vector4\r\n\r\n\t\t\t\t_gl.uniform4f( location, value.x, value.y, value.z, value.w );\r\n\r\n\t\t\t} else if ( type === \"c\" ) { // single THREE.Color\r\n\r\n\t\t\t\t_gl.uniform3f( location, value.r, value.g, value.b );\r\n\r\n\t\t\t} else if ( type === \"iv1\" ) { // flat array of integers (JS or typed array)\r\n\r\n\t\t\t\t_gl.uniform1iv( location, value );\r\n\r\n\t\t\t} else if ( type === \"iv\" ) { // flat array of integers with 3 x N size (JS or typed array)\r\n\r\n\t\t\t\t_gl.uniform3iv( location, value );\r\n\r\n\t\t\t} else if ( type === \"fv1\" ) { // flat array of floats (JS or typed array)\r\n\r\n\t\t\t\t_gl.uniform1fv( location, value );\r\n\r\n\t\t\t} else if ( type === \"fv\" ) { // flat array of floats with 3 x N size (JS or typed array)\r\n\r\n\t\t\t\t_gl.uniform3fv( location, value );\r\n\r\n\t\t\t} else if ( type === \"v2v\" ) { // array of THREE.Vector2\r\n\r\n\t\t\t\tif ( uniform._array === undefined ) {\r\n\r\n\t\t\t\t\tuniform._array = new Float32Array( 2 * value.length );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( i = 0, il = value.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\toffset = i * 2;\r\n\r\n\t\t\t\t\tuniform._array[ offset ] \t = value[ i ].x;\r\n\t\t\t\t\tuniform._array[ offset + 1 ] = value[ i ].y;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_gl.uniform2fv( location, uniform._array );\r\n\r\n\t\t\t} else if ( type === \"v3v\" ) { // array of THREE.Vector3\r\n\r\n\t\t\t\tif ( uniform._array === undefined ) {\r\n\r\n\t\t\t\t\tuniform._array = new Float32Array( 3 * value.length );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( i = 0, il = value.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\toffset = i * 3;\r\n\r\n\t\t\t\t\tuniform._array[ offset ] \t = value[ i ].x;\r\n\t\t\t\t\tuniform._array[ offset + 1 ] = value[ i ].y;\r\n\t\t\t\t\tuniform._array[ offset + 2 ] = value[ i ].z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_gl.uniform3fv( location, uniform._array );\r\n\r\n\t\t\t} else if ( type === \"v4v\" ) { // array of THREE.Vector4\r\n\r\n\t\t\t\tif ( uniform._array === undefined ) {\r\n\r\n\t\t\t\t\tuniform._array = new Float32Array( 4 * value.length );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( i = 0, il = value.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\toffset = i * 4;\r\n\r\n\t\t\t\t\tuniform._array[ offset ] \t = value[ i ].x;\r\n\t\t\t\t\tuniform._array[ offset + 1 ] = value[ i ].y;\r\n\t\t\t\t\tuniform._array[ offset + 2 ] = value[ i ].z;\r\n\t\t\t\t\tuniform._array[ offset + 3 ] = value[ i ].w;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_gl.uniform4fv( location, uniform._array );\r\n\r\n\t\t\t} else if ( type === \"m4\") { // single THREE.Matrix4\r\n\r\n\t\t\t\tif ( uniform._array === undefined ) {\r\n\r\n\t\t\t\t\tuniform._array = new Float32Array( 16 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvalue.flattenToArray( uniform._array );\r\n\t\t\t\t_gl.uniformMatrix4fv( location, false, uniform._array );\r\n\r\n\t\t\t} else if ( type === \"m4v\" ) { // array of THREE.Matrix4\r\n\r\n\t\t\t\tif ( uniform._array === undefined ) {\r\n\r\n\t\t\t\t\tuniform._array = new Float32Array( 16 * value.length );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( i = 0, il = value.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tvalue[ i ].flattenToArrayOffset( uniform._array, i * 16 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_gl.uniformMatrix4fv( location, false, uniform._array );\r\n\r\n\t\t\t} else if ( type === \"t\" ) { // single THREE.Texture (2d or cube)\r\n\r\n\t\t\t\ttexture = value;\r\n\t\t\t\ttextureUnit = getTextureUnit();\r\n\r\n\t\t\t\t_gl.uniform1i( location, textureUnit );\r\n\r\n\t\t\t\tif ( !texture ) continue;\r\n\r\n\t\t\t\tif ( texture.image instanceof Array && texture.image.length === 6 ) {\r\n\r\n\t\t\t\t\tsetCubeTexture( texture, textureUnit );\r\n\r\n\t\t\t\t} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {\r\n\r\n\t\t\t\t\tsetCubeTextureDynamic( texture, textureUnit );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t_this.setTexture( texture, textureUnit );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( type === \"tv\" ) { // array of THREE.Texture (2d)\r\n\r\n\t\t\t\tif ( uniform._array === undefined ) {\r\n\r\n\t\t\t\t\tuniform._array = [];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor( i = 0, il = uniform.value.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tuniform._array[ i ] = getTextureUnit();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_gl.uniform1iv( location, uniform._array );\r\n\r\n\t\t\t\tfor( i = 0, il = uniform.value.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\ttexture = uniform.value[ i ];\r\n\t\t\t\t\ttextureUnit = uniform._array[ i ];\r\n\r\n\t\t\t\t\tif ( !texture ) continue;\r\n\r\n\t\t\t\t\t_this.setTexture( texture, textureUnit );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction setupMatrices ( object, camera ) {\r\n\r\n\t\tobject._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\r\n\r\n\t\tobject._normalMatrix.getInverse( object._modelViewMatrix );\r\n\t\tobject._normalMatrix.transpose();\r\n\r\n\t};\r\n\r\n\t//\r\n\r\n\tfunction setColorGamma( array, offset, color, intensitySq ) {\r\n\r\n\t\tarray[ offset ]     = color.r * color.r * intensitySq;\r\n\t\tarray[ offset + 1 ] = color.g * color.g * intensitySq;\r\n\t\tarray[ offset + 2 ] = color.b * color.b * intensitySq;\r\n\r\n\t};\r\n\r\n\tfunction setColorLinear( array, offset, color, intensity ) {\r\n\r\n\t\tarray[ offset ]     = color.r * intensity;\r\n\t\tarray[ offset + 1 ] = color.g * intensity;\r\n\t\tarray[ offset + 2 ] = color.b * intensity;\r\n\r\n\t};\r\n\r\n\tfunction setupLights ( program, lights ) {\r\n\r\n\t\tvar l, ll, light, n,\r\n\t\tr = 0, g = 0, b = 0,\r\n\t\tcolor, skyColor, groundColor,\r\n\t\tintensity,  intensitySq,\r\n\t\tposition,\r\n\t\tdistance,\r\n\r\n\t\tzlights = _lights,\r\n\r\n\t\tdirColors = zlights.directional.colors,\r\n\t\tdirPositions = zlights.directional.positions,\r\n\r\n\t\tpointColors = zlights.point.colors,\r\n\t\tpointPositions = zlights.point.positions,\r\n\t\tpointDistances = zlights.point.distances,\r\n\r\n\t\tspotColors = zlights.spot.colors,\r\n\t\tspotPositions = zlights.spot.positions,\r\n\t\tspotDistances = zlights.spot.distances,\r\n\t\tspotDirections = zlights.spot.directions,\r\n\t\tspotAnglesCos = zlights.spot.anglesCos,\r\n\t\tspotExponents = zlights.spot.exponents,\r\n\r\n\t\themiSkyColors = zlights.hemi.skyColors,\r\n\t\themiGroundColors = zlights.hemi.groundColors,\r\n\t\themiPositions = zlights.hemi.positions,\r\n\r\n\t\tdirLength = 0,\r\n\t\tpointLength = 0,\r\n\t\tspotLength = 0,\r\n\t\themiLength = 0,\r\n\r\n\t\tdirCount = 0,\r\n\t\tpointCount = 0,\r\n\t\tspotCount = 0,\r\n\t\themiCount = 0,\r\n\r\n\t\tdirOffset = 0,\r\n\t\tpointOffset = 0,\r\n\t\tspotOffset = 0,\r\n\t\themiOffset = 0;\r\n\r\n\t\tfor ( l = 0, ll = lights.length; l < ll; l ++ ) {\r\n\r\n\t\t\tlight = lights[ l ];\r\n\r\n\t\t\tif ( light.onlyShadow ) continue;\r\n\r\n\t\t\tcolor = light.color;\r\n\t\t\tintensity = light.intensity;\r\n\t\t\tdistance = light.distance;\r\n\r\n\t\t\tif ( light instanceof THREE.AmbientLight ) {\r\n\r\n\t\t\t\tif ( ! light.visible ) continue;\r\n\r\n\t\t\t\tif ( _this.gammaInput ) {\r\n\r\n\t\t\t\t\tr += color.r * color.r;\r\n\t\t\t\t\tg += color.g * color.g;\r\n\t\t\t\t\tb += color.b * color.b;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tr += color.r;\r\n\t\t\t\t\tg += color.g;\r\n\t\t\t\t\tb += color.b;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\r\n\r\n\t\t\t\tdirCount += 1;\r\n\r\n\t\t\t\tif ( ! light.visible ) continue;\r\n\r\n\t\t\t\t_direction.getPositionFromMatrix( light.matrixWorld );\r\n\t\t\t\t_vector3.getPositionFromMatrix( light.target.matrixWorld );\r\n\t\t\t\t_direction.sub( _vector3 );\r\n\t\t\t\t_direction.normalize();\r\n\r\n\t\t\t\t// skip lights with undefined direction\r\n\t\t\t\t// these create troubles in OpenGL (making pixel black)\r\n\r\n\t\t\t\tif ( _direction.x === 0 && _direction.y === 0 && _direction.z === 0 ) continue;\r\n\r\n\t\t\t\tdirOffset = dirLength * 3;\r\n\r\n\t\t\t\tdirPositions[ dirOffset ]     = _direction.x;\r\n\t\t\t\tdirPositions[ dirOffset + 1 ] = _direction.y;\r\n\t\t\t\tdirPositions[ dirOffset + 2 ] = _direction.z;\r\n\r\n\t\t\t\tif ( _this.gammaInput ) {\r\n\r\n\t\t\t\t\tsetColorGamma( dirColors, dirOffset, color, intensity * intensity );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tsetColorLinear( dirColors, dirOffset, color, intensity );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdirLength += 1;\r\n\r\n\t\t\t} else if ( light instanceof THREE.PointLight ) {\r\n\r\n\t\t\t\tpointCount += 1;\r\n\r\n\t\t\t\tif ( ! light.visible ) continue;\r\n\r\n\t\t\t\tpointOffset = pointLength * 3;\r\n\r\n\t\t\t\tif ( _this.gammaInput ) {\r\n\r\n\t\t\t\t\tsetColorGamma( pointColors, pointOffset, color, intensity * intensity );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tsetColorLinear( pointColors, pointOffset, color, intensity );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_vector3.getPositionFromMatrix( light.matrixWorld );\r\n\r\n\t\t\t\tpointPositions[ pointOffset ]     = _vector3.x;\r\n\t\t\t\tpointPositions[ pointOffset + 1 ] = _vector3.y;\r\n\t\t\t\tpointPositions[ pointOffset + 2 ] = _vector3.z;\r\n\r\n\t\t\t\tpointDistances[ pointLength ] = distance;\r\n\r\n\t\t\t\tpointLength += 1;\r\n\r\n\t\t\t} else if ( light instanceof THREE.SpotLight ) {\r\n\r\n\t\t\t\tspotCount += 1;\r\n\r\n\t\t\t\tif ( ! light.visible ) continue;\r\n\r\n\t\t\t\tspotOffset = spotLength * 3;\r\n\r\n\t\t\t\tif ( _this.gammaInput ) {\r\n\r\n\t\t\t\t\tsetColorGamma( spotColors, spotOffset, color, intensity * intensity );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tsetColorLinear( spotColors, spotOffset, color, intensity );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_vector3.getPositionFromMatrix( light.matrixWorld );\r\n\r\n\t\t\t\tspotPositions[ spotOffset ]     = _vector3.x;\r\n\t\t\t\tspotPositions[ spotOffset + 1 ] = _vector3.y;\r\n\t\t\t\tspotPositions[ spotOffset + 2 ] = _vector3.z;\r\n\r\n\t\t\t\tspotDistances[ spotLength ] = distance;\r\n\r\n\t\t\t\t_direction.copy( _vector3 );\r\n\t\t\t\t_vector3.getPositionFromMatrix( light.target.matrixWorld );\r\n\t\t\t\t_direction.sub( _vector3 );\r\n\t\t\t\t_direction.normalize();\r\n\r\n\t\t\t\tspotDirections[ spotOffset ]     = _direction.x;\r\n\t\t\t\tspotDirections[ spotOffset + 1 ] = _direction.y;\r\n\t\t\t\tspotDirections[ spotOffset + 2 ] = _direction.z;\r\n\r\n\t\t\t\tspotAnglesCos[ spotLength ] = Math.cos( light.angle );\r\n\t\t\t\tspotExponents[ spotLength ] = light.exponent;\r\n\r\n\t\t\t\tspotLength += 1;\r\n\r\n\t\t\t} else if ( light instanceof THREE.HemisphereLight ) {\r\n\r\n\t\t\t\themiCount += 1;\r\n\r\n\t\t\t\tif ( ! light.visible ) continue;\r\n\r\n\t\t\t\t_direction.getPositionFromMatrix( light.matrixWorld );\r\n\t\t\t\t_direction.normalize();\r\n\r\n\t\t\t\t// skip lights with undefined direction\r\n\t\t\t\t// these create troubles in OpenGL (making pixel black)\r\n\r\n\t\t\t\tif ( _direction.x === 0 && _direction.y === 0 && _direction.z === 0 ) continue;\r\n\r\n\t\t\t\themiOffset = hemiLength * 3;\r\n\r\n\t\t\t\themiPositions[ hemiOffset ]     = _direction.x;\r\n\t\t\t\themiPositions[ hemiOffset + 1 ] = _direction.y;\r\n\t\t\t\themiPositions[ hemiOffset + 2 ] = _direction.z;\r\n\r\n\t\t\t\tskyColor = light.color;\r\n\t\t\t\tgroundColor = light.groundColor;\r\n\r\n\t\t\t\tif ( _this.gammaInput ) {\r\n\r\n\t\t\t\t\tintensitySq = intensity * intensity;\r\n\r\n\t\t\t\t\tsetColorGamma( hemiSkyColors, hemiOffset, skyColor, intensitySq );\r\n\t\t\t\t\tsetColorGamma( hemiGroundColors, hemiOffset, groundColor, intensitySq );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tsetColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );\r\n\t\t\t\t\tsetColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\themiLength += 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// null eventual remains from removed lights\r\n\t\t// (this is to avoid if in shader)\r\n\r\n\t\tfor ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l ++ ) dirColors[ l ] = 0.0;\r\n\t\tfor ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l ++ ) pointColors[ l ] = 0.0;\r\n\t\tfor ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l ++ ) spotColors[ l ] = 0.0;\r\n\t\tfor ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;\r\n\t\tfor ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;\r\n\r\n\t\tzlights.directional.length = dirLength;\r\n\t\tzlights.point.length = pointLength;\r\n\t\tzlights.spot.length = spotLength;\r\n\t\tzlights.hemi.length = hemiLength;\r\n\r\n\t\tzlights.ambient[ 0 ] = r;\r\n\t\tzlights.ambient[ 1 ] = g;\r\n\t\tzlights.ambient[ 2 ] = b;\r\n\r\n\t};\r\n\r\n\t// GL state setting\r\n\r\n\tthis.setFaceCulling = function ( cullFace, frontFaceDirection ) {\r\n\r\n\t\tif ( cullFace === THREE.CullFaceNone ) {\r\n\r\n\t\t\t_gl.disable( _gl.CULL_FACE );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {\r\n\r\n\t\t\t\t_gl.frontFace( _gl.CW );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.frontFace( _gl.CCW );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( cullFace === THREE.CullFaceBack ) {\r\n\r\n\t\t\t\t_gl.cullFace( _gl.BACK );\r\n\r\n\t\t\t} else if ( cullFace === THREE.CullFaceFront ) {\r\n\r\n\t\t\t\t_gl.cullFace( _gl.FRONT );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.cullFace( _gl.FRONT_AND_BACK );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.enable( _gl.CULL_FACE );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setMaterialFaces = function ( material ) {\r\n\r\n\t\tvar doubleSided = material.side === THREE.DoubleSide;\r\n\t\tvar flipSided = material.side === THREE.BackSide;\r\n\r\n\t\tif ( _oldDoubleSided !== doubleSided ) {\r\n\r\n\t\t\tif ( doubleSided ) {\r\n\r\n\t\t\t\t_gl.disable( _gl.CULL_FACE );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.enable( _gl.CULL_FACE );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_oldDoubleSided = doubleSided;\r\n\r\n\t\t}\r\n\r\n\t\tif ( _oldFlipSided !== flipSided ) {\r\n\r\n\t\t\tif ( flipSided ) {\r\n\r\n\t\t\t\t_gl.frontFace( _gl.CW );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.frontFace( _gl.CCW );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_oldFlipSided = flipSided;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setDepthTest = function ( depthTest ) {\r\n\r\n\t\tif ( _oldDepthTest !== depthTest ) {\r\n\r\n\t\t\tif ( depthTest ) {\r\n\r\n\t\t\t\t_gl.enable( _gl.DEPTH_TEST );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.disable( _gl.DEPTH_TEST );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_oldDepthTest = depthTest;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setDepthWrite = function ( depthWrite ) {\r\n\r\n\t\tif ( _oldDepthWrite !== depthWrite ) {\r\n\r\n\t\t\t_gl.depthMask( depthWrite );\r\n\t\t\t_oldDepthWrite = depthWrite;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction setLineWidth ( width ) {\r\n\r\n\t\tif ( width !== _oldLineWidth ) {\r\n\r\n\t\t\t_gl.lineWidth( width );\r\n\r\n\t\t\t_oldLineWidth = width;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction setPolygonOffset ( polygonoffset, factor, units ) {\r\n\r\n\t\tif ( _oldPolygonOffset !== polygonoffset ) {\r\n\r\n\t\t\tif ( polygonoffset ) {\r\n\r\n\t\t\t\t_gl.enable( _gl.POLYGON_OFFSET_FILL );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.disable( _gl.POLYGON_OFFSET_FILL );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_oldPolygonOffset = polygonoffset;\r\n\r\n\t\t}\r\n\r\n\t\tif ( polygonoffset && ( _oldPolygonOffsetFactor !== factor || _oldPolygonOffsetUnits !== units ) ) {\r\n\r\n\t\t\t_gl.polygonOffset( factor, units );\r\n\r\n\t\t\t_oldPolygonOffsetFactor = factor;\r\n\t\t\t_oldPolygonOffsetUnits = units;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setBlending = function ( blending, blendEquation, blendSrc, blendDst ) {\r\n\r\n\t\tif ( blending !== _oldBlending ) {\r\n\r\n\t\t\tif ( blending === THREE.NoBlending ) {\r\n\r\n\t\t\t\t_gl.disable( _gl.BLEND );\r\n\r\n\t\t\t} else if ( blending === THREE.AdditiveBlending ) {\r\n\r\n\t\t\t\t_gl.enable( _gl.BLEND );\r\n\t\t\t\t_gl.blendEquation( _gl.FUNC_ADD );\r\n\t\t\t\t_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE );\r\n\r\n\t\t\t} else if ( blending === THREE.SubtractiveBlending ) {\r\n\r\n\t\t\t\t// TODO: Find blendFuncSeparate() combination\r\n\t\t\t\t_gl.enable( _gl.BLEND );\r\n\t\t\t\t_gl.blendEquation( _gl.FUNC_ADD );\r\n\t\t\t\t_gl.blendFunc( _gl.ZERO, _gl.ONE_MINUS_SRC_COLOR );\r\n\r\n\t\t\t} else if ( blending === THREE.MultiplyBlending ) {\r\n\r\n\t\t\t\t// TODO: Find blendFuncSeparate() combination\r\n\t\t\t\t_gl.enable( _gl.BLEND );\r\n\t\t\t\t_gl.blendEquation( _gl.FUNC_ADD );\r\n\t\t\t\t_gl.blendFunc( _gl.ZERO, _gl.SRC_COLOR );\r\n\r\n\t\t\t} else if ( blending === THREE.CustomBlending ) {\r\n\r\n\t\t\t\t_gl.enable( _gl.BLEND );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.enable( _gl.BLEND );\r\n\t\t\t\t_gl.blendEquationSeparate( _gl.FUNC_ADD, _gl.FUNC_ADD );\r\n\t\t\t\t_gl.blendFuncSeparate( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA, _gl.ONE, _gl.ONE_MINUS_SRC_ALPHA );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_oldBlending = blending;\r\n\r\n\t\t}\r\n\r\n\t\tif ( blending === THREE.CustomBlending ) {\r\n\r\n\t\t\tif ( blendEquation !== _oldBlendEquation ) {\r\n\r\n\t\t\t\t_gl.blendEquation( paramThreeToGL( blendEquation ) );\r\n\r\n\t\t\t\t_oldBlendEquation = blendEquation;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( blendSrc !== _oldBlendSrc || blendDst !== _oldBlendDst ) {\r\n\r\n\t\t\t\t_gl.blendFunc( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ) );\r\n\r\n\t\t\t\t_oldBlendSrc = blendSrc;\r\n\t\t\t\t_oldBlendDst = blendDst;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_oldBlendEquation = null;\r\n\t\t\t_oldBlendSrc = null;\r\n\t\t\t_oldBlendDst = null;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Defines\r\n\r\n\tfunction generateDefines ( defines ) {\r\n\r\n\t\tvar value, chunk, chunks = [];\r\n\r\n\t\tfor ( var d in defines ) {\r\n\r\n\t\t\tvalue = defines[ d ];\r\n\t\t\tif ( value === false ) continue;\r\n\r\n\t\t\tchunk = \"#define \" + d + \" \" + value;\r\n\t\t\tchunks.push( chunk );\r\n\r\n\t\t}\r\n\r\n\t\treturn chunks.join( \"\\n\" );\r\n\r\n\t};\r\n\r\n\t// Shaders\r\n\r\n\tfunction buildProgram ( shaderID, fragmentShader, vertexShader, uniforms, attributes, defines, parameters ) {\r\n\r\n\t\tvar p, pl, d, program, code;\r\n\t\tvar chunks = [];\r\n\r\n\t\t// Generate code\r\n\r\n\t\tif ( shaderID ) {\r\n\r\n\t\t\tchunks.push( shaderID );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tchunks.push( fragmentShader );\r\n\t\t\tchunks.push( vertexShader );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( d in defines ) {\r\n\r\n\t\t\tchunks.push( d );\r\n\t\t\tchunks.push( defines[ d ] );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( p in parameters ) {\r\n\r\n\t\t\tchunks.push( p );\r\n\t\t\tchunks.push( parameters[ p ] );\r\n\r\n\t\t}\r\n\r\n\t\tcode = chunks.join();\r\n\r\n\t\t// Check if code has been already compiled\r\n\r\n\t\tfor ( p = 0, pl = _programs.length; p < pl; p ++ ) {\r\n\r\n\t\t\tvar programInfo = _programs[ p ];\r\n\r\n\t\t\tif ( programInfo.code === code ) {\r\n\r\n\t\t\t\t//console.log( \"Code already compiled.\" /*: \\n\\n\" + code*/ );\r\n\r\n\t\t\t\tprogramInfo.usedTimes ++;\r\n\r\n\t\t\t\treturn programInfo.program;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar shadowMapTypeDefine = \"SHADOWMAP_TYPE_BASIC\";\r\n\r\n\t\tif ( parameters.shadowMapType === THREE.PCFShadowMap ) {\r\n\r\n\t\t\tshadowMapTypeDefine = \"SHADOWMAP_TYPE_PCF\";\r\n\r\n\t\t} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {\r\n\r\n\t\t\tshadowMapTypeDefine = \"SHADOWMAP_TYPE_PCF_SOFT\";\r\n\r\n\t\t}\r\n\r\n\t\t//console.log( \"building new program \" );\r\n\r\n\t\t//\r\n\r\n\t\tvar customDefines = generateDefines( defines );\r\n\r\n\t\t//\r\n\r\n\t\tprogram = _gl.createProgram();\r\n\r\n\t\tvar prefix_vertex = [\r\n\r\n\t\t\t\"precision \" + _precision + \" float;\",\r\n\r\n\t\t\tcustomDefines,\r\n\r\n\t\t\t_supportsVertexTextures ? \"#define VERTEX_TEXTURES\" : \"\",\r\n\r\n\t\t\t_this.gammaInput ? \"#define GAMMA_INPUT\" : \"\",\r\n\t\t\t_this.gammaOutput ? \"#define GAMMA_OUTPUT\" : \"\",\r\n\t\t\t_this.physicallyBasedShading ? \"#define PHYSICALLY_BASED_SHADING\" : \"\",\r\n\r\n\t\t\t\"#define MAX_DIR_LIGHTS \" + parameters.maxDirLights,\r\n\t\t\t\"#define MAX_POINT_LIGHTS \" + parameters.maxPointLights,\r\n\t\t\t\"#define MAX_SPOT_LIGHTS \" + parameters.maxSpotLights,\r\n\t\t\t\"#define MAX_HEMI_LIGHTS \" + parameters.maxHemiLights,\r\n\r\n\t\t\t\"#define MAX_SHADOWS \" + parameters.maxShadows,\r\n\r\n\t\t\t\"#define MAX_BONES \" + parameters.maxBones,\r\n\r\n\t\t\tparameters.map ? \"#define USE_MAP\" : \"\",\r\n\t\t\tparameters.envMap ? \"#define USE_ENVMAP\" : \"\",\r\n\t\t\tparameters.lightMap ? \"#define USE_LIGHTMAP\" : \"\",\r\n\t\t\tparameters.bumpMap ? \"#define USE_BUMPMAP\" : \"\",\r\n\t\t\tparameters.normalMap ? \"#define USE_NORMALMAP\" : \"\",\r\n\t\t\tparameters.specularMap ? \"#define USE_SPECULARMAP\" : \"\",\r\n\t\t\tparameters.vertexColors ? \"#define USE_COLOR\" : \"\",\r\n\r\n\t\t\tparameters.skinning ? \"#define USE_SKINNING\" : \"\",\r\n\t\t\tparameters.useVertexTexture ? \"#define BONE_TEXTURE\" : \"\",\r\n\t\t\tparameters.boneTextureWidth ? \"#define N_BONE_PIXEL_X \" + parameters.boneTextureWidth.toFixed( 1 ) : \"\",\r\n\t\t\tparameters.boneTextureHeight ? \"#define N_BONE_PIXEL_Y \" + parameters.boneTextureHeight.toFixed( 1 ) : \"\",\r\n\r\n\t\t\tparameters.morphTargets ? \"#define USE_MORPHTARGETS\" : \"\",\r\n\t\t\tparameters.morphNormals ? \"#define USE_MORPHNORMALS\" : \"\",\r\n\t\t\tparameters.perPixel ? \"#define PHONG_PER_PIXEL\" : \"\",\r\n\t\t\tparameters.wrapAround ? \"#define WRAP_AROUND\" : \"\",\r\n\t\t\tparameters.doubleSided ? \"#define DOUBLE_SIDED\" : \"\",\r\n\t\t\tparameters.flipSided ? \"#define FLIP_SIDED\" : \"\",\r\n\r\n\t\t\tparameters.shadowMapEnabled ? \"#define USE_SHADOWMAP\" : \"\",\r\n\t\t\tparameters.shadowMapEnabled ? \"#define \" + shadowMapTypeDefine : \"\",\r\n\t\t\tparameters.shadowMapDebug ? \"#define SHADOWMAP_DEBUG\" : \"\",\r\n\t\t\tparameters.shadowMapCascade ? \"#define SHADOWMAP_CASCADE\" : \"\",\r\n\r\n\t\t\tparameters.sizeAttenuation ? \"#define USE_SIZEATTENUATION\" : \"\",\r\n\r\n\t\t\t\"uniform mat4 modelMatrix;\",\r\n\t\t\t\"uniform mat4 modelViewMatrix;\",\r\n\t\t\t\"uniform mat4 projectionMatrix;\",\r\n\t\t\t\"uniform mat4 viewMatrix;\",\r\n\t\t\t\"uniform mat3 normalMatrix;\",\r\n\t\t\t\"uniform vec3 cameraPosition;\",\r\n\r\n\t\t\t\"attribute vec3 position;\",\r\n\t\t\t\"attribute vec3 normal;\",\r\n\t\t\t\"attribute vec2 uv;\",\r\n\t\t\t\"attribute vec2 uv2;\",\r\n\r\n\t\t\t\"#ifdef USE_COLOR\",\r\n\r\n\t\t\t\t\"attribute vec3 color;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#ifdef USE_MORPHTARGETS\",\r\n\r\n\t\t\t\t\"attribute vec3 morphTarget0;\",\r\n\t\t\t\t\"attribute vec3 morphTarget1;\",\r\n\t\t\t\t\"attribute vec3 morphTarget2;\",\r\n\t\t\t\t\"attribute vec3 morphTarget3;\",\r\n\r\n\t\t\t\t\"#ifdef USE_MORPHNORMALS\",\r\n\r\n\t\t\t\t\t\"attribute vec3 morphNormal0;\",\r\n\t\t\t\t\t\"attribute vec3 morphNormal1;\",\r\n\t\t\t\t\t\"attribute vec3 morphNormal2;\",\r\n\t\t\t\t\t\"attribute vec3 morphNormal3;\",\r\n\r\n\t\t\t\t\"#else\",\r\n\r\n\t\t\t\t\t\"attribute vec3 morphTarget4;\",\r\n\t\t\t\t\t\"attribute vec3 morphTarget5;\",\r\n\t\t\t\t\t\"attribute vec3 morphTarget6;\",\r\n\t\t\t\t\t\"attribute vec3 morphTarget7;\",\r\n\r\n\t\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"#ifdef USE_SKINNING\",\r\n\r\n\t\t\t\t\"attribute vec4 skinIndex;\",\r\n\t\t\t\t\"attribute vec4 skinWeight;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\"\"\r\n\r\n\t\t].join(\"\\n\");\r\n\r\n\t\tvar prefix_fragment = [\r\n\r\n\t\t\t\"precision \" + _precision + \" float;\",\r\n\r\n\t\t\t( parameters.bumpMap || parameters.normalMap ) ? \"#extension GL_OES_standard_derivatives : enable\" : \"\",\r\n\r\n\t\t\tcustomDefines,\r\n\r\n\t\t\t\"#define MAX_DIR_LIGHTS \" + parameters.maxDirLights,\r\n\t\t\t\"#define MAX_POINT_LIGHTS \" + parameters.maxPointLights,\r\n\t\t\t\"#define MAX_SPOT_LIGHTS \" + parameters.maxSpotLights,\r\n\t\t\t\"#define MAX_HEMI_LIGHTS \" + parameters.maxHemiLights,\r\n\r\n\t\t\t\"#define MAX_SHADOWS \" + parameters.maxShadows,\r\n\r\n\t\t\tparameters.alphaTest ? \"#define ALPHATEST \" + parameters.alphaTest: \"\",\r\n\r\n\t\t\t_this.gammaInput ? \"#define GAMMA_INPUT\" : \"\",\r\n\t\t\t_this.gammaOutput ? \"#define GAMMA_OUTPUT\" : \"\",\r\n\t\t\t_this.physicallyBasedShading ? \"#define PHYSICALLY_BASED_SHADING\" : \"\",\r\n\r\n\t\t\t( parameters.useFog && parameters.fog ) ? \"#define USE_FOG\" : \"\",\r\n\t\t\t( parameters.useFog && parameters.fogExp ) ? \"#define FOG_EXP2\" : \"\",\r\n\r\n\t\t\tparameters.map ? \"#define USE_MAP\" : \"\",\r\n\t\t\tparameters.envMap ? \"#define USE_ENVMAP\" : \"\",\r\n\t\t\tparameters.lightMap ? \"#define USE_LIGHTMAP\" : \"\",\r\n\t\t\tparameters.bumpMap ? \"#define USE_BUMPMAP\" : \"\",\r\n\t\t\tparameters.normalMap ? \"#define USE_NORMALMAP\" : \"\",\r\n\t\t\tparameters.specularMap ? \"#define USE_SPECULARMAP\" : \"\",\r\n\t\t\tparameters.vertexColors ? \"#define USE_COLOR\" : \"\",\r\n\r\n\t\t\tparameters.metal ? \"#define METAL\" : \"\",\r\n\t\t\tparameters.perPixel ? \"#define PHONG_PER_PIXEL\" : \"\",\r\n\t\t\tparameters.wrapAround ? \"#define WRAP_AROUND\" : \"\",\r\n\t\t\tparameters.doubleSided ? \"#define DOUBLE_SIDED\" : \"\",\r\n\t\t\tparameters.flipSided ? \"#define FLIP_SIDED\" : \"\",\r\n\r\n\t\t\tparameters.shadowMapEnabled ? \"#define USE_SHADOWMAP\" : \"\",\r\n\t\t\tparameters.shadowMapEnabled ? \"#define \" + shadowMapTypeDefine : \"\",\r\n\t\t\tparameters.shadowMapDebug ? \"#define SHADOWMAP_DEBUG\" : \"\",\r\n\t\t\tparameters.shadowMapCascade ? \"#define SHADOWMAP_CASCADE\" : \"\",\r\n\r\n\t\t\t\"uniform mat4 viewMatrix;\",\r\n\t\t\t\"uniform vec3 cameraPosition;\",\r\n\t\t\t\"\"\r\n\r\n\t\t].join(\"\\n\");\r\n\r\n\t\tvar glFragmentShader = getShader( \"fragment\", prefix_fragment + fragmentShader );\r\n\t\tvar glVertexShader = getShader( \"vertex\", prefix_vertex + vertexShader );\r\n\r\n\t\t_gl.attachShader( program, glVertexShader );\r\n\t\t_gl.attachShader( program, glFragmentShader );\r\n\r\n\t\t_gl.linkProgram( program );\r\n\r\n\t\tif ( !_gl.getProgramParameter( program, _gl.LINK_STATUS ) ) {\r\n\r\n\t\t\tconsole.error( \"Could not initialise shader\\n\" + \"VALIDATE_STATUS: \" + _gl.getProgramParameter( program, _gl.VALIDATE_STATUS ) + \", gl error [\" + _gl.getError() + \"]\" );\r\n\r\n\t\t}\r\n\r\n\t\t// clean up\r\n\r\n\t\t_gl.deleteShader( glFragmentShader );\r\n\t\t_gl.deleteShader( glVertexShader );\r\n\r\n\t\t//console.log( prefix_fragment + fragmentShader );\r\n\t\t//console.log( prefix_vertex + vertexShader );\r\n\r\n\t\tprogram.uniforms = {};\r\n\t\tprogram.attributes = {};\r\n\r\n\t\tvar identifiers, u, a, i;\r\n\r\n\t\t// cache uniform locations\r\n\r\n\t\tidentifiers = [\r\n\r\n\t\t\t'viewMatrix', 'modelViewMatrix', 'projectionMatrix', 'normalMatrix', 'modelMatrix', 'cameraPosition',\r\n\t\t\t'morphTargetInfluences'\r\n\r\n\t\t];\r\n\r\n\t\tif ( parameters.useVertexTexture ) {\r\n\r\n\t\t\tidentifiers.push( 'boneTexture' );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tidentifiers.push( 'boneGlobalMatrices' );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( u in uniforms ) {\r\n\r\n\t\t\tidentifiers.push( u );\r\n\r\n\t\t}\r\n\r\n\t\tcacheUniformLocations( program, identifiers );\r\n\r\n\t\t// cache attributes locations\r\n\r\n\t\tidentifiers = [\r\n\r\n\t\t\t\"position\", \"normal\", \"uv\", \"uv2\", \"tangent\", \"color\",\r\n\t\t\t\"skinIndex\", \"skinWeight\", \"lineDistance\"\r\n\r\n\t\t];\r\n\r\n\t\tfor ( i = 0; i < parameters.maxMorphTargets; i ++ ) {\r\n\r\n\t\t\tidentifiers.push( \"morphTarget\" + i );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( i = 0; i < parameters.maxMorphNormals; i ++ ) {\r\n\r\n\t\t\tidentifiers.push( \"morphNormal\" + i );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( a in attributes ) {\r\n\r\n\t\t\tidentifiers.push( a );\r\n\r\n\t\t}\r\n\r\n\t\tcacheAttributeLocations( program, identifiers );\r\n\r\n\t\tprogram.id = _programs_counter ++;\r\n\r\n\t\t_programs.push( { program: program, code: code, usedTimes: 1 } );\r\n\r\n\t\t_this.info.memory.programs = _programs.length;\r\n\r\n\t\treturn program;\r\n\r\n\t};\r\n\r\n\t// Shader parameters cache\r\n\r\n\tfunction cacheUniformLocations ( program, identifiers ) {\r\n\r\n\t\tvar i, l, id;\r\n\r\n\t\tfor( i = 0, l = identifiers.length; i < l; i ++ ) {\r\n\r\n\t\t\tid = identifiers[ i ];\r\n\t\t\tprogram.uniforms[ id ] = _gl.getUniformLocation( program, id );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction cacheAttributeLocations ( program, identifiers ) {\r\n\r\n\t\tvar i, l, id;\r\n\r\n\t\tfor( i = 0, l = identifiers.length; i < l; i ++ ) {\r\n\r\n\t\t\tid = identifiers[ i ];\r\n\t\t\tprogram.attributes[ id ] = _gl.getAttribLocation( program, id );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction addLineNumbers ( string ) {\r\n\r\n\t\tvar chunks = string.split( \"\\n\" );\r\n\r\n\t\tfor ( var i = 0, il = chunks.length; i < il; i ++ ) {\r\n\r\n\t\t\t// Chrome reports shader errors on lines\r\n\t\t\t// starting counting from 1\r\n\r\n\t\t\tchunks[ i ] = ( i + 1 ) + \": \" + chunks[ i ];\r\n\r\n\t\t}\r\n\r\n\t\treturn chunks.join( \"\\n\" );\r\n\r\n\t};\r\n\r\n\tfunction getShader ( type, string ) {\r\n\r\n\t\tvar shader;\r\n\r\n\t\tif ( type === \"fragment\" ) {\r\n\r\n\t\t\tshader = _gl.createShader( _gl.FRAGMENT_SHADER );\r\n\r\n\t\t} else if ( type === \"vertex\" ) {\r\n\r\n\t\t\tshader = _gl.createShader( _gl.VERTEX_SHADER );\r\n\r\n\t\t}\r\n\r\n\t\t_gl.shaderSource( shader, string );\r\n\t\t_gl.compileShader( shader );\r\n\r\n\t\tif ( !_gl.getShaderParameter( shader, _gl.COMPILE_STATUS ) ) {\r\n\r\n\t\t\tconsole.error( _gl.getShaderInfoLog( shader ) );\r\n\t\t\tconsole.error( addLineNumbers( string ) );\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\treturn shader;\r\n\r\n\t};\r\n\r\n\t// Textures\r\n\r\n\r\n\tfunction isPowerOfTwo ( value ) {\r\n\r\n\t\treturn ( value & ( value - 1 ) ) === 0;\r\n\r\n\t};\r\n\r\n\tfunction setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {\r\n\r\n\t\tif ( isImagePowerOfTwo ) {\r\n\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );\r\n\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\r\n\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( _glExtensionTextureFilterAnisotropic && texture.type !== THREE.FloatType ) {\r\n\r\n\t\t\tif ( texture.anisotropy > 1 || texture.__oldAnisotropy ) {\r\n\r\n\t\t\t\t_gl.texParameterf( textureType, _glExtensionTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _maxAnisotropy ) );\r\n\t\t\t\ttexture.__oldAnisotropy = texture.anisotropy;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setTexture = function ( texture, slot ) {\r\n\r\n\t\tif ( texture.needsUpdate ) {\r\n\r\n\t\t\tif ( ! texture.__webglInit ) {\r\n\r\n\t\t\t\ttexture.__webglInit = true;\r\n\r\n\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\r\n\r\n\t\t\t\ttexture.__webglTexture = _gl.createTexture();\r\n\r\n\t\t\t\t_this.info.memory.textures ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );\r\n\r\n\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\r\n\t\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\r\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\r\n\r\n\t\t\tvar image = texture.image,\r\n\t\t\tisImagePowerOfTwo = isPowerOfTwo( image.width ) && isPowerOfTwo( image.height ),\r\n\t\t\tglFormat = paramThreeToGL( texture.format ),\r\n\t\t\tglType = paramThreeToGL( texture.type );\r\n\r\n\t\t\tsetTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );\r\n\r\n\t\t\tvar mipmap, mipmaps = texture.mipmaps;\r\n\r\n\t\t\tif ( texture instanceof THREE.DataTexture ) {\r\n\r\n\t\t\t\t// use manually created mipmaps if available\r\n\t\t\t\t// if there are no manual mipmaps\r\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\r\n\r\n\t\t\t\tif ( mipmaps.length > 0 && isImagePowerOfTwo ) {\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\r\n\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttexture.generateMipmaps = false;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( texture instanceof THREE.CompressedTexture ) {\r\n\r\n\t\t\t\t// compressed textures can only use manually created mipmaps\r\n\t\t\t\t// WebGL can't generate mipmaps for DDS textures\r\n\r\n\t\t\t\tfor( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tmipmap = mipmaps[ i ];\r\n\t\t\t\t\t_gl.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else { // regular Texture (image, video, canvas)\r\n\r\n\t\t\t\t// use manually created mipmaps if available\r\n\t\t\t\t// if there are no manual mipmaps\r\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\r\n\r\n\t\t\t\tif ( mipmaps.length > 0 && isImagePowerOfTwo ) {\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\r\n\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttexture.generateMipmaps = false;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\r\n\r\n\t\t\ttexture.needsUpdate = false;\r\n\r\n\t\t\tif ( texture.onUpdate ) texture.onUpdate();\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction clampToMaxSize ( image, maxSize ) {\r\n\r\n\t\tif ( image.width <= maxSize && image.height <= maxSize ) {\r\n\r\n\t\t\treturn image;\r\n\r\n\t\t}\r\n\r\n\t\t// Warning: Scaling through the canvas will only work with images that use\r\n\t\t// premultiplied alpha.\r\n\r\n\t\tvar maxDimension = Math.max( image.width, image.height );\r\n\t\tvar newWidth = Math.floor( image.width * maxSize / maxDimension );\r\n\t\tvar newHeight = Math.floor( image.height * maxSize / maxDimension );\r\n\r\n\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\tcanvas.width = newWidth;\r\n\t\tcanvas.height = newHeight;\r\n\r\n\t\tvar ctx = canvas.getContext( \"2d\" );\r\n\t\tctx.drawImage( image, 0, 0, image.width, image.height, 0, 0, newWidth, newHeight );\r\n\r\n\t\treturn canvas;\r\n\r\n\t}\r\n\r\n\tfunction setCubeTexture ( texture, slot ) {\r\n\r\n\t\tif ( texture.image.length === 6 ) {\r\n\r\n\t\t\tif ( texture.needsUpdate ) {\r\n\r\n\t\t\t\tif ( ! texture.image.__webglTextureCube ) {\r\n\r\n\t\t\t\t\ttexture.image.__webglTextureCube = _gl.createTexture();\r\n\r\n\t\t\t\t\t_this.info.memory.textures ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );\r\n\r\n\t\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\r\n\r\n\t\t\t\tvar isCompressed = texture instanceof THREE.CompressedTexture;\r\n\r\n\t\t\t\tvar cubeImage = [];\r\n\r\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\t\tif ( _this.autoScaleCubemaps && ! isCompressed ) {\r\n\r\n\t\t\t\t\t\tcubeImage[ i ] = clampToMaxSize( texture.image[ i ], _maxCubemapSize );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tcubeImage[ i ] = texture.image[ i ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar image = cubeImage[ 0 ],\r\n\t\t\t\tisImagePowerOfTwo = isPowerOfTwo( image.width ) && isPowerOfTwo( image.height ),\r\n\t\t\t\tglFormat = paramThreeToGL( texture.format ),\r\n\t\t\t\tglType = paramThreeToGL( texture.type );\r\n\r\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );\r\n\r\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\t\tif ( isCompressed ) {\r\n\r\n\t\t\t\t\t\tvar mipmap, mipmaps = cubeImage[ i ].mipmaps;\r\n\r\n\t\t\t\t\t\tfor( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tmipmap = mipmaps[ j ];\r\n\t\t\t\t\t\t\t_gl.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( texture.generateMipmaps && isImagePowerOfTwo ) {\r\n\r\n\t\t\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttexture.needsUpdate = false;\r\n\r\n\t\t\t\tif ( texture.onUpdate ) texture.onUpdate();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction setCubeTextureDynamic ( texture, slot ) {\r\n\r\n\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.__webglTexture );\r\n\r\n\t};\r\n\r\n\t// Render targets\r\n\r\n\tfunction setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {\r\n\r\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, renderTarget.__webglTexture, 0 );\r\n\r\n\t};\r\n\r\n\tfunction setupRenderBuffer ( renderbuffer, renderTarget  ) {\r\n\r\n\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\r\n\r\n\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\r\n\r\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\r\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n\r\n\t\t/* For some reason this is not working. Defaulting to RGBA4.\r\n\t\t} else if( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\r\n\r\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );\r\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n\t\t*/\r\n\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\r\n\r\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\r\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setRenderTarget = function ( renderTarget ) {\r\n\r\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\r\n\r\n\t\tif ( renderTarget && ! renderTarget.__webglFramebuffer ) {\r\n\r\n\t\t\tif ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;\r\n\t\t\tif ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;\r\n\r\n\t\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\r\n\r\n\t\t\trenderTarget.__webglTexture = _gl.createTexture();\r\n\r\n\t\t\t_this.info.memory.textures ++;\r\n\r\n\t\t\t// Setup texture, create render and frame buffers\r\n\r\n\t\t\tvar isTargetPowerOfTwo = isPowerOfTwo( renderTarget.width ) && isPowerOfTwo( renderTarget.height ),\r\n\t\t\t\tglFormat = paramThreeToGL( renderTarget.format ),\r\n\t\t\t\tglType = paramThreeToGL( renderTarget.type );\r\n\r\n\t\t\tif ( isCube ) {\r\n\r\n\t\t\t\trenderTarget.__webglFramebuffer = [];\r\n\t\t\t\trenderTarget.__webglRenderbuffer = [];\r\n\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );\r\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo );\r\n\r\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\t\trenderTarget.__webglFramebuffer[ i ] = _gl.createFramebuffer();\r\n\t\t\t\t\trenderTarget.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();\r\n\r\n\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\r\n\r\n\t\t\t\t\tsetupFrameBuffer( renderTarget.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\r\n\t\t\t\t\tsetupRenderBuffer( renderTarget.__webglRenderbuffer[ i ], renderTarget );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\trenderTarget.__webglFramebuffer = _gl.createFramebuffer();\r\n\r\n\t\t\t\tif ( renderTarget.shareDepthFrom ) {\r\n\r\n\t\t\t\t\trenderTarget.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\trenderTarget.__webglRenderbuffer = _gl.createRenderbuffer();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );\r\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo );\r\n\r\n\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\r\n\r\n\t\t\t\tsetupFrameBuffer( renderTarget.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );\r\n\r\n\t\t\t\tif ( renderTarget.shareDepthFrom ) {\r\n\r\n\t\t\t\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\r\n\r\n\t\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );\r\n\r\n\t\t\t\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\r\n\r\n\t\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tsetupRenderBuffer( renderTarget.__webglRenderbuffer, renderTarget );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Release everything\r\n\r\n\t\t\tif ( isCube ) {\r\n\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, null );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\r\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\r\n\r\n\t\t}\r\n\r\n\t\tvar framebuffer, width, height, vx, vy;\r\n\r\n\t\tif ( renderTarget ) {\r\n\r\n\t\t\tif ( isCube ) {\r\n\r\n\t\t\t\tframebuffer = renderTarget.__webglFramebuffer[ renderTarget.activeCubeFace ];\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tframebuffer = renderTarget.__webglFramebuffer;\r\n\r\n\t\t\t}\r\n\r\n\t\t\twidth = renderTarget.width;\r\n\t\t\theight = renderTarget.height;\r\n\r\n\t\t\tvx = 0;\r\n\t\t\tvy = 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tframebuffer = null;\r\n\r\n\t\t\twidth = _viewportWidth;\r\n\t\t\theight = _viewportHeight;\r\n\r\n\t\t\tvx = _viewportX;\r\n\t\t\tvy = _viewportY;\r\n\r\n\t\t}\r\n\r\n\t\tif ( framebuffer !== _currentFramebuffer ) {\r\n\r\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\t\t\t_gl.viewport( vx, vy, width, height );\r\n\r\n\t\t\t_currentFramebuffer = framebuffer;\r\n\r\n\t\t}\r\n\r\n\t\t_currentWidth = width;\r\n\t\t_currentHeight = height;\r\n\r\n\t};\r\n\r\n\tfunction updateRenderTargetMipmap ( renderTarget ) {\r\n\r\n\t\tif ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {\r\n\r\n\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );\r\n\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\r\n\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );\r\n\t\t\t_gl.generateMipmap( _gl.TEXTURE_2D );\r\n\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, null );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Fallback filters for non-power-of-2 textures\r\n\r\n\tfunction filterFallback ( f ) {\r\n\r\n\t\tif ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {\r\n\r\n\t\t\treturn _gl.NEAREST;\r\n\r\n\t\t}\r\n\r\n\t\treturn _gl.LINEAR;\r\n\r\n\t};\r\n\r\n\t// Map three.js constants to WebGL constants\r\n\r\n\tfunction paramThreeToGL ( p ) {\r\n\r\n\t\tif ( p === THREE.RepeatWrapping ) return _gl.REPEAT;\r\n\t\tif ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;\r\n\t\tif ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;\r\n\r\n\t\tif ( p === THREE.NearestFilter ) return _gl.NEAREST;\r\n\t\tif ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;\r\n\t\tif ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;\r\n\r\n\t\tif ( p === THREE.LinearFilter ) return _gl.LINEAR;\r\n\t\tif ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;\r\n\t\tif ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;\r\n\r\n\t\tif ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;\r\n\t\tif ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;\r\n\t\tif ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;\r\n\t\tif ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;\r\n\r\n\t\tif ( p === THREE.ByteType ) return _gl.BYTE;\r\n\t\tif ( p === THREE.ShortType ) return _gl.SHORT;\r\n\t\tif ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;\r\n\t\tif ( p === THREE.IntType ) return _gl.INT;\r\n\t\tif ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;\r\n\t\tif ( p === THREE.FloatType ) return _gl.FLOAT;\r\n\r\n\t\tif ( p === THREE.AlphaFormat ) return _gl.ALPHA;\r\n\t\tif ( p === THREE.RGBFormat ) return _gl.RGB;\r\n\t\tif ( p === THREE.RGBAFormat ) return _gl.RGBA;\r\n\t\tif ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;\r\n\t\tif ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;\r\n\r\n\t\tif ( p === THREE.AddEquation ) return _gl.FUNC_ADD;\r\n\t\tif ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;\r\n\t\tif ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;\r\n\r\n\t\tif ( p === THREE.ZeroFactor ) return _gl.ZERO;\r\n\t\tif ( p === THREE.OneFactor ) return _gl.ONE;\r\n\t\tif ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;\r\n\t\tif ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;\r\n\t\tif ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;\r\n\t\tif ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;\r\n\t\tif ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;\r\n\t\tif ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;\r\n\r\n\t\tif ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;\r\n\t\tif ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;\r\n\t\tif ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;\r\n\r\n\t\tif ( _glExtensionCompressedTextureS3TC !== undefined ) {\r\n\r\n\t\t\tif ( p === THREE.RGB_S3TC_DXT1_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGB_S3TC_DXT1_EXT;\r\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT1_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT1_EXT;\r\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT3_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT;\r\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT5_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT;\r\n\r\n\t\t}\r\n\r\n\t\treturn 0;\r\n\r\n\t};\r\n\r\n\t// Allocations\r\n\r\n\tfunction allocateBones ( object ) {\r\n\r\n\t\tif ( _supportsBoneTextures && object && object.useVertexTexture ) {\r\n\r\n\t\t\treturn 1024;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// default for when object is not specified\r\n\t\t\t// ( for example when prebuilding shader\r\n\t\t\t//   to be used with multiple objects )\r\n\t\t\t//\r\n\t\t\t// \t- leave some extra space for other uniforms\r\n\t\t\t//  - limit here is ANGLE's 254 max uniform vectors\r\n\t\t\t//    (up to 54 should be safe)\r\n\r\n\t\t\tvar nVertexUniforms = _gl.getParameter( _gl.MAX_VERTEX_UNIFORM_VECTORS );\r\n\t\t\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\r\n\r\n\t\t\tvar maxBones = nVertexMatrices;\r\n\r\n\t\t\tif ( object !== undefined && object instanceof THREE.SkinnedMesh ) {\r\n\r\n\t\t\t\tmaxBones = Math.min( object.bones.length, maxBones );\r\n\r\n\t\t\t\tif ( maxBones < object.bones.length ) {\r\n\r\n\t\t\t\t\tconsole.warn( \"WebGLRenderer: too many bones - \" + object.bones.length + \", this GPU supports just \" + maxBones + \" (try OpenGL instead of ANGLE)\" );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn maxBones;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction allocateLights ( lights ) {\r\n\r\n\t\tvar l, ll, light, dirLights, pointLights, spotLights, hemiLights;\r\n\r\n\t\tdirLights = pointLights = spotLights = hemiLights = 0;\r\n\r\n\t\tfor ( l = 0, ll = lights.length; l < ll; l ++ ) {\r\n\r\n\t\t\tlight = lights[ l ];\r\n\r\n\t\t\tif ( light.onlyShadow ) continue;\r\n\r\n\t\t\tif ( light instanceof THREE.DirectionalLight ) dirLights ++;\r\n\t\t\tif ( light instanceof THREE.PointLight ) pointLights ++;\r\n\t\t\tif ( light instanceof THREE.SpotLight ) spotLights ++;\r\n\t\t\tif ( light instanceof THREE.HemisphereLight ) hemiLights ++;\r\n\r\n\t\t}\r\n\r\n\t\treturn { 'directional' : dirLights, 'point' : pointLights, 'spot': spotLights, 'hemi': hemiLights };\r\n\r\n\t};\r\n\r\n\tfunction allocateShadows ( lights ) {\r\n\r\n\t\tvar l, ll, light, maxShadows = 0;\r\n\r\n\t\tfor ( l = 0, ll = lights.length; l < ll; l++ ) {\r\n\r\n\t\t\tlight = lights[ l ];\r\n\r\n\t\t\tif ( ! light.castShadow ) continue;\r\n\r\n\t\t\tif ( light instanceof THREE.SpotLight ) maxShadows ++;\r\n\t\t\tif ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) maxShadows ++;\r\n\r\n\t\t}\r\n\r\n\t\treturn maxShadows;\r\n\r\n\t};\r\n\r\n\t// Initialization\r\n\r\n\tfunction initGL () {\r\n\r\n\t\ttry {\r\n\r\n\t\t\tif ( ! ( _gl = _canvas.getContext( 'experimental-webgl', { alpha: _alpha, premultipliedAlpha: _premultipliedAlpha, antialias: _antialias, stencil: _stencil, preserveDrawingBuffer: _preserveDrawingBuffer } ) ) ) {\r\n\r\n\t\t\t\tthrow 'Error creating WebGL context.';\r\n\r\n\t\t\t}\r\n\r\n\t\t} catch ( error ) {\r\n\r\n\t\t\tconsole.error( error );\r\n\r\n\t\t}\r\n\r\n\t\t_glExtensionTextureFloat = _gl.getExtension( 'OES_texture_float' );\r\n\t\t_glExtensionStandardDerivatives = _gl.getExtension( 'OES_standard_derivatives' );\r\n\r\n\t\t_glExtensionTextureFilterAnisotropic = _gl.getExtension( 'EXT_texture_filter_anisotropic' ) ||\r\n\t\t\t\t\t\t\t\t\t\t\t   _gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) ||\r\n\t\t\t\t\t\t\t\t\t\t\t   _gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\r\n\r\n\r\n\t\t_glExtensionCompressedTextureS3TC = _gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) ||\r\n\t\t\t\t\t\t\t\t\t\t\t_gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) ||\r\n\t\t\t\t\t\t\t\t\t\t\t_gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\r\n\r\n\t\tif ( ! _glExtensionTextureFloat ) {\r\n\r\n\t\t\tconsole.log( 'THREE.WebGLRenderer: Float textures not supported.' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! _glExtensionStandardDerivatives ) {\r\n\r\n\t\t\tconsole.log( 'THREE.WebGLRenderer: Standard derivatives not supported.' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! _glExtensionTextureFilterAnisotropic ) {\r\n\r\n\t\t\tconsole.log( 'THREE.WebGLRenderer: Anisotropic texture filtering not supported.' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! _glExtensionCompressedTextureS3TC ) {\r\n\r\n\t\t\tconsole.log( 'THREE.WebGLRenderer: S3TC compressed textures not supported.' );\r\n\r\n\t\t}\r\n\t\t\r\n\t\tif ( _gl.getShaderPrecisionFormat === undefined ) {\r\n\t\t\t\r\n\t\t\t_gl.getShaderPrecisionFormat = function() { \r\n\t\t\t\t\r\n\t\t\t\treturn {\r\n\t\t\t\t\t\"rangeMin\"  : 1,\r\n\t\t\t\t\t\"rangeMax\"  : 1,\r\n\t\t\t\t\t\"precision\" : 1\r\n\t\t\t\t};\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction setDefaultGLState () {\r\n\r\n\t\t_gl.clearColor( 0, 0, 0, 1 );\r\n\t\t_gl.clearDepth( 1 );\r\n\t\t_gl.clearStencil( 0 );\r\n\r\n\t\t_gl.enable( _gl.DEPTH_TEST );\r\n\t\t_gl.depthFunc( _gl.LEQUAL );\r\n\r\n\t\t_gl.frontFace( _gl.CCW );\r\n\t\t_gl.cullFace( _gl.BACK );\r\n\t\t_gl.enable( _gl.CULL_FACE );\r\n\r\n\t\t_gl.enable( _gl.BLEND );\r\n\t\t_gl.blendEquation( _gl.FUNC_ADD );\r\n\t\t_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA );\r\n\r\n\t\t_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\r\n\t};\r\n\r\n\t// default plugins (order is important)\r\n\r\n\tthis.shadowMapPlugin = new THREE.ShadowMapPlugin();\r\n\tthis.addPrePlugin( this.shadowMapPlugin );\r\n\r\n\tthis.addPostPlugin( new THREE.SpritePlugin() );\r\n\tthis.addPostPlugin( new THREE.LensFlarePlugin() );\r\n\r\n};\r\n/**\r\n * @author szimek / https://github.com/szimek/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.WebGLRenderTarget = function ( width, height, options ) {\r\n\r\n\tTHREE.EventDispatcher.call( this );\r\n\r\n\tthis.width = width;\r\n\tthis.height = height;\r\n\r\n\toptions = options || {};\r\n\r\n\tthis.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;\r\n\tthis.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;\r\n\r\n\tthis.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;\r\n\tthis.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;\r\n\r\n\tthis.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;\r\n\r\n\tthis.offset = new THREE.Vector2( 0, 0 );\r\n\tthis.repeat = new THREE.Vector2( 1, 1 );\r\n\r\n\tthis.format = options.format !== undefined ? options.format : THREE.RGBAFormat;\r\n\tthis.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;\r\n\r\n\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\r\n\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\r\n\r\n\tthis.generateMipmaps = true;\r\n\r\n\tthis.shareDepthFrom = null;\r\n\r\n};\r\n\r\nTHREE.WebGLRenderTarget.prototype.clone = function() {\r\n\r\n\tvar tmp = new THREE.WebGLRenderTarget( this.width, this.height );\r\n\r\n\ttmp.wrapS = this.wrapS;\r\n\ttmp.wrapT = this.wrapT;\r\n\r\n\ttmp.magFilter = this.magFilter;\r\n\ttmp.minFilter = this.minFilter;\r\n\r\n\ttmp.anisotropy = this.anisotropy;\r\n\r\n\ttmp.offset.copy( this.offset );\r\n\ttmp.repeat.copy( this.repeat );\r\n\r\n\ttmp.format = this.format;\r\n\ttmp.type = this.type;\r\n\r\n\ttmp.depthBuffer = this.depthBuffer;\r\n\ttmp.stencilBuffer = this.stencilBuffer;\r\n\r\n\ttmp.generateMipmaps = this.generateMipmaps;\r\n\r\n\ttmp.shareDepthFrom = this.shareDepthFrom;\r\n\r\n\treturn tmp;\r\n\r\n};\r\n\r\nTHREE.WebGLRenderTarget.prototype.dispose = function () {\r\n\r\n\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n};\r\n/**\r\n * @author alteredq / http://alteredqualia.com\r\n */\r\n\r\nTHREE.WebGLRenderTargetCube = function ( width, height, options ) {\r\n\r\n\tTHREE.WebGLRenderTarget.call( this, width, height, options );\r\n\r\n\tthis.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\r\n\r\n};\r\n\r\nTHREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.RenderableVertex = function () {\r\n\r\n\tthis.positionWorld = new THREE.Vector3();\r\n\tthis.positionScreen = new THREE.Vector4();\r\n\r\n\tthis.visible = true;\r\n\r\n};\r\n\r\nTHREE.RenderableVertex.prototype.copy = function ( vertex ) {\r\n\r\n\tthis.positionWorld.copy( vertex.positionWorld );\r\n\tthis.positionScreen.copy( vertex.positionScreen );\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.RenderableFace3 = function () {\r\n\r\n\tthis.v1 = new THREE.RenderableVertex();\r\n\tthis.v2 = new THREE.RenderableVertex();\r\n\tthis.v3 = new THREE.RenderableVertex();\r\n\r\n\tthis.centroidModel = new THREE.Vector3();\r\n\r\n\tthis.normalModel = new THREE.Vector3();\r\n\tthis.normalModelView = new THREE.Vector3();\r\n\r\n\tthis.vertexNormalsLength = 0;\r\n\tthis.vertexNormalsModel = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];\r\n\tthis.vertexNormalsModelView = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];\r\n\r\n\tthis.color = null;\r\n\tthis.material = null;\r\n\tthis.uvs = [[]];\r\n\r\n\tthis.z = null;\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.RenderableFace4 = function () {\r\n\r\n\tthis.v1 = new THREE.RenderableVertex();\r\n\tthis.v2 = new THREE.RenderableVertex();\r\n\tthis.v3 = new THREE.RenderableVertex();\r\n\tthis.v4 = new THREE.RenderableVertex();\r\n\r\n\tthis.centroidModel = new THREE.Vector3();\r\n\r\n\tthis.normalModel = new THREE.Vector3();\r\n\tthis.normalModelView = new THREE.Vector3();\r\n\r\n\tthis.vertexNormalsLength = 0;\r\n\tthis.vertexNormalsModel = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];\r\n\tthis.vertexNormalsModelView = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];\r\n\r\n\tthis.color = null;\r\n\tthis.material = null;\r\n\tthis.uvs = [[]];\r\n\r\n\tthis.z = null;\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.RenderableObject = function () {\r\n\r\n\tthis.object = null;\r\n\tthis.z = null;\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.RenderableParticle = function () {\r\n\r\n\tthis.object = null;\r\n\r\n\tthis.x = null;\r\n\tthis.y = null;\r\n\tthis.z = null;\r\n\r\n\tthis.rotation = null;\r\n\tthis.scale = new THREE.Vector2();\r\n\r\n\tthis.material = null;\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.RenderableLine = function () {\r\n\r\n\tthis.z = null;\r\n\r\n\tthis.v1 = new THREE.RenderableVertex();\r\n\tthis.v2 = new THREE.RenderableVertex();\r\n\r\n\tthis.material = null;\r\n\r\n};\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.GeometryUtils = {\r\n\r\n\t// Merge two geometries or geometry and geometry from object (using object's transform)\r\n\r\n\tmerge: function ( geometry1, object2 /* mesh | geometry */ ) {\r\n\r\n\t\tvar matrix, normalMatrix,\r\n\t\tvertexOffset = geometry1.vertices.length,\r\n\t\tuvPosition = geometry1.faceVertexUvs[ 0 ].length,\r\n\t\tgeometry2 = object2 instanceof THREE.Mesh ? object2.geometry : object2,\r\n\t\tvertices1 = geometry1.vertices,\r\n\t\tvertices2 = geometry2.vertices,\r\n\t\tfaces1 = geometry1.faces,\r\n\t\tfaces2 = geometry2.faces,\r\n\t\tuvs1 = geometry1.faceVertexUvs[ 0 ],\r\n\t\tuvs2 = geometry2.faceVertexUvs[ 0 ];\r\n\r\n\t\tif ( object2 instanceof THREE.Mesh ) {\r\n\r\n\t\t\tobject2.matrixAutoUpdate && object2.updateMatrix();\r\n\r\n\t\t\tmatrix = object2.matrix;\r\n\r\n\t\t\tnormalMatrix = new THREE.Matrix3();\r\n\t\t\tnormalMatrix.getInverse( matrix );\r\n\t\t\tnormalMatrix.transpose();\r\n\r\n\t\t}\r\n\r\n\t\t// vertices\r\n\r\n\t\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar vertex = vertices2[ i ];\r\n\r\n\t\t\tvar vertexCopy = vertex.clone();\r\n\r\n\t\t\tif ( matrix ) vertexCopy.applyMatrix4( matrix );\r\n\r\n\t\t\tvertices1.push( vertexCopy );\r\n\r\n\t\t}\r\n\r\n\t\t// faces\r\n\r\n\t\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar face = faces2[ i ], faceCopy, normal, color,\r\n\t\t\tfaceVertexNormals = face.vertexNormals,\r\n\t\t\tfaceVertexColors = face.vertexColors;\r\n\r\n\t\t\tif ( face instanceof THREE.Face3 ) {\r\n\r\n\t\t\t\tfaceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\r\n\r\n\t\t\t} else if ( face instanceof THREE.Face4 ) {\r\n\r\n\t\t\t\tfaceCopy = new THREE.Face4( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset, face.d + vertexOffset );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfaceCopy.normal.copy( face.normal );\r\n\r\n\t\t\tif ( normalMatrix ) {\r\n\r\n\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tnormal = faceVertexNormals[ j ].clone();\r\n\r\n\t\t\t\tif ( normalMatrix ) {\r\n\r\n\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfaceCopy.vertexNormals.push( normal );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfaceCopy.color.copy( face.color );\r\n\r\n\t\t\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tcolor = faceVertexColors[ j ];\r\n\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfaceCopy.materialIndex = face.materialIndex;\r\n\r\n\t\t\tfaceCopy.centroid.copy( face.centroid );\r\n\r\n\t\t\tif ( matrix ) {\r\n\r\n\t\t\t\tfaceCopy.centroid.applyMatrix4( matrix );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfaces1.push( faceCopy );\r\n\r\n\t\t}\r\n\r\n\t\t// uvs\r\n\r\n\t\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar uv = uvs2[ i ], uvCopy = [];\r\n\r\n\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tuvCopy.push( new THREE.Vector2( uv[ j ].x, uv[ j ].y ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tuvs1.push( uvCopy );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tremoveMaterials: function ( geometry, materialIndexArray ) {\r\n\r\n\t\tvar materialIndexMap = {};\r\n\r\n\t\tfor ( var i = 0, il = materialIndexArray.length; i < il; i ++ ) {\r\n\r\n\t\t\tmaterialIndexMap[ materialIndexArray[i] ] = true;\r\n\r\n\t\t}\r\n\r\n\t\tvar face, newFaces = [];\r\n\r\n\t\tfor ( var i = 0, il = geometry.faces.length; i < il; i ++ ) {\r\n\r\n\t\t\tface = geometry.faces[ i ];\r\n\t\t\tif ( ! ( face.materialIndex in materialIndexMap ) ) newFaces.push( face );\r\n\r\n\t\t}\r\n\r\n\t\tgeometry.faces = newFaces;\r\n\r\n\t},\r\n\r\n\t// Get random point in triangle (via barycentric coordinates)\r\n\t// \t(uniform distribution)\r\n\t// \thttp://www.cgafaq.info/wiki/Random_Point_In_Triangle\r\n\r\n\trandomPointInTriangle: function ( vectorA, vectorB, vectorC ) {\r\n\r\n\t\tvar a, b, c,\r\n\t\t\tpoint = new THREE.Vector3(),\r\n\t\t\ttmp = THREE.GeometryUtils.__v1;\r\n\r\n\t\ta = THREE.GeometryUtils.random();\r\n\t\tb = THREE.GeometryUtils.random();\r\n\r\n\t\tif ( ( a + b ) > 1 ) {\r\n\r\n\t\t\ta = 1 - a;\r\n\t\t\tb = 1 - b;\r\n\r\n\t\t}\r\n\r\n\t\tc = 1 - a - b;\r\n\r\n\t\tpoint.copy( vectorA );\r\n\t\tpoint.multiplyScalar( a );\r\n\r\n\t\ttmp.copy( vectorB );\r\n\t\ttmp.multiplyScalar( b );\r\n\r\n\t\tpoint.add( tmp );\r\n\r\n\t\ttmp.copy( vectorC );\r\n\t\ttmp.multiplyScalar( c );\r\n\r\n\t\tpoint.add( tmp );\r\n\r\n\t\treturn point;\r\n\r\n\t},\r\n\r\n\t// Get random point in face (triangle / quad)\r\n\t// (uniform distribution)\r\n\r\n\trandomPointInFace: function ( face, geometry, useCachedAreas ) {\r\n\r\n\t\tvar vA, vB, vC, vD;\r\n\r\n\t\tif ( face instanceof THREE.Face3 ) {\r\n\r\n\t\t\tvA = geometry.vertices[ face.a ];\r\n\t\t\tvB = geometry.vertices[ face.b ];\r\n\t\t\tvC = geometry.vertices[ face.c ];\r\n\r\n\t\t\treturn THREE.GeometryUtils.randomPointInTriangle( vA, vB, vC );\r\n\r\n\t\t} else if ( face instanceof THREE.Face4 ) {\r\n\r\n\t\t\tvA = geometry.vertices[ face.a ];\r\n\t\t\tvB = geometry.vertices[ face.b ];\r\n\t\t\tvC = geometry.vertices[ face.c ];\r\n\t\t\tvD = geometry.vertices[ face.d ];\r\n\r\n\t\t\tvar area1, area2;\r\n\r\n\t\t\tif ( useCachedAreas ) {\r\n\r\n\t\t\t\tif ( face._area1 && face._area2 ) {\r\n\r\n\t\t\t\t\tarea1 = face._area1;\r\n\t\t\t\t\tarea2 = face._area2;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tarea1 = THREE.GeometryUtils.triangleArea( vA, vB, vD );\r\n\t\t\t\t\tarea2 = THREE.GeometryUtils.triangleArea( vB, vC, vD );\r\n\r\n\t\t\t\t\tface._area1 = area1;\r\n\t\t\t\t\tface._area2 = area2;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tarea1 = THREE.GeometryUtils.triangleArea( vA, vB, vD ),\r\n\t\t\t\tarea2 = THREE.GeometryUtils.triangleArea( vB, vC, vD );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar r = THREE.GeometryUtils.random() * ( area1 + area2 );\r\n\r\n\t\t\tif ( r < area1 ) {\r\n\r\n\t\t\t\treturn THREE.GeometryUtils.randomPointInTriangle( vA, vB, vD );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn THREE.GeometryUtils.randomPointInTriangle( vB, vC, vD );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t// Get uniformly distributed random points in mesh\r\n\t// \t- create array with cumulative sums of face areas\r\n\t//  - pick random number from 0 to total area\r\n\t//  - find corresponding place in area array by binary search\r\n\t//\t- get random point in face\r\n\r\n\trandomPointsInGeometry: function ( geometry, n ) {\r\n\r\n\t\tvar face, i,\r\n\t\t\tfaces = geometry.faces,\r\n\t\t\tvertices = geometry.vertices,\r\n\t\t\til = faces.length,\r\n\t\t\ttotalArea = 0,\r\n\t\t\tcumulativeAreas = [],\r\n\t\t\tvA, vB, vC, vD;\r\n\r\n\t\t// precompute face areas\r\n\r\n\t\tfor ( i = 0; i < il; i ++ ) {\r\n\r\n\t\t\tface = faces[ i ];\r\n\r\n\t\t\tif ( face instanceof THREE.Face3 ) {\r\n\r\n\t\t\t\tvA = vertices[ face.a ];\r\n\t\t\t\tvB = vertices[ face.b ];\r\n\t\t\t\tvC = vertices[ face.c ];\r\n\r\n\t\t\t\tface._area = THREE.GeometryUtils.triangleArea( vA, vB, vC );\r\n\r\n\t\t\t} else if ( face instanceof THREE.Face4 ) {\r\n\r\n\t\t\t\tvA = vertices[ face.a ];\r\n\t\t\t\tvB = vertices[ face.b ];\r\n\t\t\t\tvC = vertices[ face.c ];\r\n\t\t\t\tvD = vertices[ face.d ];\r\n\r\n\t\t\t\tface._area1 = THREE.GeometryUtils.triangleArea( vA, vB, vD );\r\n\t\t\t\tface._area2 = THREE.GeometryUtils.triangleArea( vB, vC, vD );\r\n\r\n\t\t\t\tface._area = face._area1 + face._area2;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttotalArea += face._area;\r\n\r\n\t\t\tcumulativeAreas[ i ] = totalArea;\r\n\r\n\t\t}\r\n\r\n\t\t// binary search cumulative areas array\r\n\r\n\t\tfunction binarySearchIndices( value ) {\r\n\r\n\t\t\tfunction binarySearch( start, end ) {\r\n\r\n\t\t\t\t// return closest larger index\r\n\t\t\t\t// if exact number is not found\r\n\r\n\t\t\t\tif ( end < start )\r\n\t\t\t\t\treturn start;\r\n\r\n\t\t\t\tvar mid = start + Math.floor( ( end - start ) / 2 );\r\n\r\n\t\t\t\tif ( cumulativeAreas[ mid ] > value ) {\r\n\r\n\t\t\t\t\treturn binarySearch( start, mid - 1 );\r\n\r\n\t\t\t\t} else if ( cumulativeAreas[ mid ] < value ) {\r\n\r\n\t\t\t\t\treturn binarySearch( mid + 1, end );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\treturn mid;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar result = binarySearch( 0, cumulativeAreas.length - 1 )\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t\t// pick random face weighted by face area\r\n\r\n\t\tvar r, index,\r\n\t\t\tresult = [];\r\n\r\n\t\tvar stats = {};\r\n\r\n\t\tfor ( i = 0; i < n; i ++ ) {\r\n\r\n\t\t\tr = THREE.GeometryUtils.random() * totalArea;\r\n\r\n\t\t\tindex = binarySearchIndices( r );\r\n\r\n\t\t\tresult[ i ] = THREE.GeometryUtils.randomPointInFace( faces[ index ], geometry, true );\r\n\r\n\t\t\tif ( ! stats[ index ] ) {\r\n\r\n\t\t\t\tstats[ index ] = 1;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tstats[ index ] += 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t},\r\n\r\n\t// Get triangle area (half of parallelogram)\r\n\t//\thttp://mathworld.wolfram.com/TriangleArea.html\r\n\r\n\ttriangleArea: function ( vectorA, vectorB, vectorC ) {\r\n\r\n\t\tvar tmp1 = THREE.GeometryUtils.__v1,\r\n\t\t\ttmp2 = THREE.GeometryUtils.__v2;\r\n\r\n\t\ttmp1.subVectors( vectorB, vectorA );\r\n\t\ttmp2.subVectors( vectorC, vectorA );\r\n\t\ttmp1.cross( tmp2 );\r\n\r\n\t\treturn 0.5 * tmp1.length();\r\n\r\n\t},\r\n\r\n\t// Center geometry so that 0,0,0 is in center of bounding box\r\n\r\n\tcenter: function ( geometry ) {\r\n\r\n\t\tgeometry.computeBoundingBox();\r\n\r\n\t\tvar bb = geometry.boundingBox;\r\n\r\n\t\tvar offset = new THREE.Vector3();\r\n\r\n\t\toffset.addVectors( bb.min, bb.max );\r\n\t\toffset.multiplyScalar( -0.5 );\r\n\r\n\t\tgeometry.applyMatrix( new THREE.Matrix4().makeTranslation( offset.x, offset.y, offset.z ) );\r\n\t\tgeometry.computeBoundingBox();\r\n\r\n\t\treturn offset;\r\n\r\n\t},\r\n\r\n\t// Normalize UVs to be from <0,1>\r\n\t// (for now just the first set of UVs)\r\n\r\n\tnormalizeUVs: function ( geometry ) {\r\n\r\n\t\tvar uvSet = geometry.faceVertexUvs[ 0 ];\r\n\r\n\t\tfor ( var i = 0, il = uvSet.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar uvs = uvSet[ i ];\r\n\r\n\t\t\tfor ( var j = 0, jl = uvs.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t// texture repeat\r\n\r\n\t\t\t\tif( uvs[ j ].x !== 1.0 ) uvs[ j ].x = uvs[ j ].x - Math.floor( uvs[ j ].x );\r\n\t\t\t\tif( uvs[ j ].y !== 1.0 ) uvs[ j ].y = uvs[ j ].y - Math.floor( uvs[ j ].y );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ttriangulateQuads: function ( geometry ) {\r\n\r\n\t\tvar i, il, j, jl;\r\n\r\n\t\tvar faces = [];\r\n\t\tvar faceUvs = [];\r\n\t\tvar faceVertexUvs = [];\r\n\r\n\t\tfor ( i = 0, il = geometry.faceUvs.length; i < il; i ++ ) {\r\n\r\n\t\t\tfaceUvs[ i ] = [];\r\n\r\n\t\t}\r\n\r\n\t\tfor ( i = 0, il = geometry.faceVertexUvs.length; i < il; i ++ ) {\r\n\r\n\t\t\tfaceVertexUvs[ i ] = [];\r\n\r\n\t\t}\r\n\r\n\t\tfor ( i = 0, il = geometry.faces.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar face = geometry.faces[ i ];\r\n\r\n\t\t\tif ( face instanceof THREE.Face4 ) {\r\n\r\n\t\t\t\tvar a = face.a;\r\n\t\t\t\tvar b = face.b;\r\n\t\t\t\tvar c = face.c;\r\n\t\t\t\tvar d = face.d;\r\n\r\n\t\t\t\tvar triA = new THREE.Face3();\r\n\t\t\t\tvar triB = new THREE.Face3();\r\n\r\n\t\t\t\ttriA.color.copy( face.color );\r\n\t\t\t\ttriB.color.copy( face.color );\r\n\r\n\t\t\t\ttriA.materialIndex = face.materialIndex;\r\n\t\t\t\ttriB.materialIndex = face.materialIndex;\r\n\r\n\t\t\t\ttriA.a = a;\r\n\t\t\t\ttriA.b = b;\r\n\t\t\t\ttriA.c = d;\r\n\r\n\t\t\t\ttriB.a = b;\r\n\t\t\t\ttriB.b = c;\r\n\t\t\t\ttriB.c = d;\r\n\r\n\t\t\t\tif ( face.vertexColors.length === 4 ) {\r\n\r\n\t\t\t\t\ttriA.vertexColors[ 0 ] = face.vertexColors[ 0 ].clone();\r\n\t\t\t\t\ttriA.vertexColors[ 1 ] = face.vertexColors[ 1 ].clone();\r\n\t\t\t\t\ttriA.vertexColors[ 2 ] = face.vertexColors[ 3 ].clone();\r\n\r\n\t\t\t\t\ttriB.vertexColors[ 0 ] = face.vertexColors[ 1 ].clone();\r\n\t\t\t\t\ttriB.vertexColors[ 1 ] = face.vertexColors[ 2 ].clone();\r\n\t\t\t\t\ttriB.vertexColors[ 2 ] = face.vertexColors[ 3 ].clone();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfaces.push( triA, triB );\r\n\r\n\t\t\t\tfor ( j = 0, jl = geometry.faceVertexUvs.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tif ( geometry.faceVertexUvs[ j ].length ) {\r\n\r\n\t\t\t\t\t\tvar uvs = geometry.faceVertexUvs[ j ][ i ];\r\n\r\n\t\t\t\t\t\tvar uvA = uvs[ 0 ];\r\n\t\t\t\t\t\tvar uvB = uvs[ 1 ];\r\n\t\t\t\t\t\tvar uvC = uvs[ 2 ];\r\n\t\t\t\t\t\tvar uvD = uvs[ 3 ];\r\n\r\n\t\t\t\t\t\tvar uvsTriA = [ uvA.clone(), uvB.clone(), uvD.clone() ];\r\n\t\t\t\t\t\tvar uvsTriB = [ uvB.clone(), uvC.clone(), uvD.clone() ];\r\n\r\n\t\t\t\t\t\tfaceVertexUvs[ j ].push( uvsTriA, uvsTriB );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( j = 0, jl = geometry.faceUvs.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tif ( geometry.faceUvs[ j ].length ) {\r\n\r\n\t\t\t\t\t\tvar faceUv = geometry.faceUvs[ j ][ i ];\r\n\r\n\t\t\t\t\t\tfaceUvs[ j ].push( faceUv, faceUv );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfaces.push( face );\r\n\r\n\t\t\t\tfor ( j = 0, jl = geometry.faceUvs.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tfaceUvs[ j ].push( geometry.faceUvs[ j ][ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( j = 0, jl = geometry.faceVertexUvs.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tfaceVertexUvs[ j ].push( geometry.faceVertexUvs[ j ][ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tgeometry.faces = faces;\r\n\t\tgeometry.faceUvs = faceUvs;\r\n\t\tgeometry.faceVertexUvs = faceVertexUvs;\r\n\r\n\t\tgeometry.computeCentroids();\r\n\t\tgeometry.computeFaceNormals();\r\n\t\tgeometry.computeVertexNormals();\r\n\r\n\t\tif ( geometry.hasTangents ) geometry.computeTangents();\r\n\r\n\t},\r\n\r\n\tsetMaterialIndex: function ( geometry, index, startFace, endFace ){\r\n\r\n\t\tvar faces = geometry.faces;\r\n\t\tvar start = startFace || 0;\r\n\t\tvar end = endFace || faces.length - 1;\r\n\r\n\t\tfor ( var i = start; i <= end; i ++ ) {\r\n\r\n\t\t\tfaces[i].materialIndex = index;\r\n\r\n\t\t}\r\n\r\n    }\r\n\r\n};\r\n\r\nTHREE.GeometryUtils.random = THREE.Math.random16;\r\n\r\nTHREE.GeometryUtils.__v1 = new THREE.Vector3();\r\nTHREE.GeometryUtils.__v2 = new THREE.Vector3();\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.ImageUtils = {\r\n\r\n\tcrossOrigin: 'anonymous',\r\n\r\n\tloadTexture: function ( url, mapping, onLoad, onError ) {\r\n\r\n\t\tvar image = new Image();\r\n\t\tvar texture = new THREE.Texture( image, mapping );\r\n\r\n\t\tvar loader = new THREE.ImageLoader();\r\n\r\n\t\tloader.addEventListener( 'load', function ( event ) {\r\n\r\n\t\t\ttexture.image = event.content;\r\n\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\tif ( onLoad ) onLoad( texture );\r\n\r\n\t\t} );\r\n\r\n\t\tloader.addEventListener( 'error', function ( event ) {\r\n\r\n\t\t\tif ( onError ) onError( event.message );\r\n\r\n\t\t} );\r\n\r\n\t\tloader.crossOrigin = this.crossOrigin;\r\n\t\tloader.load( url, image );\r\n\r\n\t\ttexture.sourceFile = url;\r\n\r\n\t\treturn texture;\r\n\r\n\t},\r\n\r\n\tloadCompressedTexture: function ( url, mapping, onLoad, onError ) {\r\n\r\n\t\tvar texture = new THREE.CompressedTexture();\r\n\t\ttexture.mapping = mapping;\r\n\r\n\t\tvar request = new XMLHttpRequest();\r\n\r\n\t\trequest.onload = function () {\r\n\r\n\t\t\tvar buffer = request.response;\r\n\t\t\tvar dds = THREE.ImageUtils.parseDDS( buffer, true );\r\n\r\n\t\t\ttexture.format = dds.format;\r\n\r\n\t\t\ttexture.mipmaps = dds.mipmaps;\r\n\t\t\ttexture.image.width = dds.width;\r\n\t\t\ttexture.image.height = dds.height;\r\n\r\n\t\t\t// gl.generateMipmap fails for compressed textures\r\n\t\t\t// mipmaps must be embedded in the DDS file\r\n\t\t\t// or texture filters must not use mipmapping\r\n\r\n\t\t\ttexture.generateMipmaps = false;\r\n\r\n\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\tif ( onLoad ) onLoad( texture );\r\n\r\n\t\t}\r\n\r\n\t\trequest.onerror = onError;\r\n\r\n\t\trequest.open( 'GET', url, true );\r\n\t\trequest.responseType = \"arraybuffer\";\r\n\t\trequest.send( null );\r\n\r\n\t\treturn texture;\r\n\r\n\t},\r\n\r\n\tloadTextureCube: function ( array, mapping, onLoad, onError ) {\r\n\r\n\t\tvar images = [];\r\n\t\timages.loadCount = 0;\r\n\r\n\t\tvar texture = new THREE.Texture();\r\n\t\ttexture.image = images;\r\n\t\tif ( mapping !== undefined ) texture.mapping = mapping;\r\n\r\n\t\t// no flipping needed for cube textures\r\n\r\n\t\ttexture.flipY = false;\r\n\r\n\t\tfor ( var i = 0, il = array.length; i < il; ++ i ) {\r\n\r\n\t\t\tvar cubeImage = new Image();\r\n\t\t\timages[ i ] = cubeImage;\r\n\r\n\t\t\tcubeImage.onload = function () {\r\n\r\n\t\t\t\timages.loadCount += 1;\r\n\r\n\t\t\t\tif ( images.loadCount === 6 ) {\r\n\r\n\t\t\t\t\ttexture.needsUpdate = true;\r\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t};\r\n\r\n\t\t\tcubeImage.onerror = onError;\r\n\r\n\t\t\tcubeImage.crossOrigin = this.crossOrigin;\r\n\t\t\tcubeImage.src = array[ i ];\r\n\r\n\t\t}\r\n\r\n\t\treturn texture;\r\n\r\n\t},\r\n\r\n\tloadCompressedTextureCube: function ( array, mapping, onLoad, onError ) {\r\n\r\n\t\tvar images = [];\r\n\t\timages.loadCount = 0;\r\n\r\n\t\tvar texture = new THREE.CompressedTexture();\r\n\t\ttexture.image = images;\r\n\t\tif ( mapping !== undefined ) texture.mapping = mapping;\r\n\r\n\t\t// no flipping for cube textures\r\n\t\t// (also flipping doesn't work for compressed textures )\r\n\r\n\t\ttexture.flipY = false;\r\n\r\n\t\t// can't generate mipmaps for compressed textures\r\n\t\t// mips must be embedded in DDS files\r\n\r\n\t\ttexture.generateMipmaps = false;\r\n\r\n\t\tvar generateCubeFaceCallback = function ( rq, img ) {\r\n\r\n\t\t\treturn function () {\r\n\r\n\t\t\t\tvar buffer = rq.response;\r\n\t\t\t\tvar dds = THREE.ImageUtils.parseDDS( buffer, true );\r\n\r\n\t\t\t\timg.format = dds.format;\r\n\r\n\t\t\t\timg.mipmaps = dds.mipmaps;\r\n\t\t\t\timg.width = dds.width;\r\n\t\t\t\timg.height = dds.height;\r\n\r\n\t\t\t\timages.loadCount += 1;\r\n\r\n\t\t\t\tif ( images.loadCount === 6 ) {\r\n\r\n\t\t\t\t\ttexture.format = dds.format;\r\n\t\t\t\t\ttexture.needsUpdate = true;\r\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// compressed cubemap textures as 6 separate DDS files\r\n\r\n\t\tif ( array instanceof Array ) {\r\n\r\n\t\t\tfor ( var i = 0, il = array.length; i < il; ++ i ) {\r\n\r\n\t\t\t\tvar cubeImage = {};\r\n\t\t\t\timages[ i ] = cubeImage;\r\n\r\n\t\t\t\tvar request = new XMLHttpRequest();\r\n\r\n\t\t\t\trequest.onload = generateCubeFaceCallback( request, cubeImage );\r\n\t\t\t\trequest.onerror = onError;\r\n\r\n\t\t\t\tvar url = array[ i ];\r\n\r\n\t\t\t\trequest.open( 'GET', url, true );\r\n\t\t\t\trequest.responseType = \"arraybuffer\";\r\n\t\t\t\trequest.send( null );\r\n\r\n\t\t\t}\r\n\r\n\t\t// compressed cubemap texture stored in a single DDS file\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar url = array;\r\n\t\t\tvar request = new XMLHttpRequest();\r\n\r\n\t\t\trequest.onload = function( ) {\r\n\r\n\t\t\t\tvar buffer = request.response;\r\n\t\t\t\tvar dds = THREE.ImageUtils.parseDDS( buffer, true );\r\n\r\n\t\t\t\tif ( dds.isCubemap ) {\r\n\r\n\t\t\t\t\tvar faces = dds.mipmaps.length / dds.mipmapCount;\r\n\r\n\t\t\t\t\tfor ( var f = 0; f < faces; f ++ ) {\r\n\r\n\t\t\t\t\t\timages[ f ] = { mipmaps : [] };\r\n\r\n\t\t\t\t\t\tfor ( var i = 0; i < dds.mipmapCount; i ++ ) {\r\n\r\n\t\t\t\t\t\t\timages[ f ].mipmaps.push( dds.mipmaps[ f * dds.mipmapCount + i ] );\r\n\t\t\t\t\t\t\timages[ f ].format = dds.format;\r\n\t\t\t\t\t\t\timages[ f ].width = dds.width;\r\n\t\t\t\t\t\t\timages[ f ].height = dds.height;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttexture.format = dds.format;\r\n\t\t\t\t\ttexture.needsUpdate = true;\r\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\trequest.onerror = onError;\r\n\r\n\t\t\trequest.open( 'GET', url, true );\r\n\t\t\trequest.responseType = \"arraybuffer\";\r\n\t\t\trequest.send( null );\r\n\r\n\t\t}\r\n\r\n\t\treturn texture;\r\n\r\n\t},\r\n\r\n\tparseDDS: function ( buffer, loadMipmaps ) {\r\n\r\n\t\tvar dds = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 };\r\n\r\n\t\t// Adapted from @toji's DDS utils\r\n\t\t//\thttps://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js\r\n\r\n\t\t// All values and structures referenced from:\r\n\t\t// http://msdn.microsoft.com/en-us/library/bb943991.aspx/\r\n\r\n\t\tvar DDS_MAGIC = 0x20534444;\r\n\r\n\t\tvar DDSD_CAPS = 0x1,\r\n\t\t\tDDSD_HEIGHT = 0x2,\r\n\t\t\tDDSD_WIDTH = 0x4,\r\n\t\t\tDDSD_PITCH = 0x8,\r\n\t\t\tDDSD_PIXELFORMAT = 0x1000,\r\n\t\t\tDDSD_MIPMAPCOUNT = 0x20000,\r\n\t\t\tDDSD_LINEARSIZE = 0x80000,\r\n\t\t\tDDSD_DEPTH = 0x800000;\r\n\r\n\t\tvar DDSCAPS_COMPLEX = 0x8,\r\n\t\t\tDDSCAPS_MIPMAP = 0x400000,\r\n\t\t\tDDSCAPS_TEXTURE = 0x1000;\r\n\r\n\t\tvar DDSCAPS2_CUBEMAP = 0x200,\r\n\t\t\tDDSCAPS2_CUBEMAP_POSITIVEX = 0x400,\r\n\t\t\tDDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,\r\n\t\t\tDDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,\r\n\t\t\tDDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,\r\n\t\t\tDDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,\r\n\t\t\tDDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,\r\n\t\t\tDDSCAPS2_VOLUME = 0x200000;\r\n\r\n\t\tvar DDPF_ALPHAPIXELS = 0x1,\r\n\t\t\tDDPF_ALPHA = 0x2,\r\n\t\t\tDDPF_FOURCC = 0x4,\r\n\t\t\tDDPF_RGB = 0x40,\r\n\t\t\tDDPF_YUV = 0x200,\r\n\t\t\tDDPF_LUMINANCE = 0x20000;\r\n\r\n\t\tfunction fourCCToInt32( value ) {\r\n\r\n\t\t\treturn value.charCodeAt(0) +\r\n\t\t\t\t(value.charCodeAt(1) << 8) +\r\n\t\t\t\t(value.charCodeAt(2) << 16) +\r\n\t\t\t\t(value.charCodeAt(3) << 24);\r\n\r\n\t\t}\r\n\r\n\t\tfunction int32ToFourCC( value ) {\r\n\r\n\t\t\treturn String.fromCharCode(\r\n\t\t\t\tvalue & 0xff,\r\n\t\t\t\t(value >> 8) & 0xff,\r\n\t\t\t\t(value >> 16) & 0xff,\r\n\t\t\t\t(value >> 24) & 0xff\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tvar FOURCC_DXT1 = fourCCToInt32(\"DXT1\");\r\n\t\tvar FOURCC_DXT3 = fourCCToInt32(\"DXT3\");\r\n\t\tvar FOURCC_DXT5 = fourCCToInt32(\"DXT5\");\r\n\r\n\t\tvar headerLengthInt = 31; // The header length in 32 bit ints\r\n\r\n\t\t// Offsets into the header array\r\n\r\n\t\tvar off_magic = 0;\r\n\r\n\t\tvar off_size = 1;\r\n\t\tvar off_flags = 2;\r\n\t\tvar off_height = 3;\r\n\t\tvar off_width = 4;\r\n\r\n\t\tvar off_mipmapCount = 7;\r\n\r\n\t\tvar off_pfFlags = 20;\r\n\t\tvar off_pfFourCC = 21;\r\n\r\n\t\tvar off_caps = 27;\r\n\t\tvar off_caps2 = 28;\r\n\t\tvar off_caps3 = 29;\r\n\t\tvar off_caps4 = 30;\r\n\r\n\t\t// Parse header\r\n\r\n\t\tvar header = new Int32Array( buffer, 0, headerLengthInt );\r\n\r\n\t\tif ( header[ off_magic ] !== DDS_MAGIC ) {\r\n\r\n\t\t\tconsole.error( \"ImageUtils.parseDDS(): Invalid magic number in DDS header\" );\r\n\t\t\treturn dds;\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! header[ off_pfFlags ] & DDPF_FOURCC ) {\r\n\r\n\t\t\tconsole.error( \"ImageUtils.parseDDS(): Unsupported format, must contain a FourCC code\" );\r\n\t\t\treturn dds;\r\n\r\n\t\t}\r\n\r\n\t\tvar blockBytes;\r\n\r\n\t\tvar fourCC = header[ off_pfFourCC ];\r\n\r\n\t\tswitch ( fourCC ) {\r\n\r\n\t\t\tcase FOURCC_DXT1:\r\n\r\n\t\t\t\tblockBytes = 8;\r\n\t\t\t\tdds.format = THREE.RGB_S3TC_DXT1_Format;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase FOURCC_DXT3:\r\n\r\n\t\t\t\tblockBytes = 16;\r\n\t\t\t\tdds.format = THREE.RGBA_S3TC_DXT3_Format;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase FOURCC_DXT5:\r\n\r\n\t\t\t\tblockBytes = 16;\r\n\t\t\t\tdds.format = THREE.RGBA_S3TC_DXT5_Format;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\r\n\t\t\t\tconsole.error( \"ImageUtils.parseDDS(): Unsupported FourCC code: \", int32ToFourCC( fourCC ) );\r\n\t\t\t\treturn dds;\r\n\r\n\t\t}\r\n\r\n\t\tdds.mipmapCount = 1;\r\n\r\n\t\tif ( header[ off_flags ] & DDSD_MIPMAPCOUNT && loadMipmaps !== false ) {\r\n\r\n\t\t\tdds.mipmapCount = Math.max( 1, header[ off_mipmapCount ] );\r\n\r\n\t\t}\r\n\r\n\t\t//TODO: Verify that all faces of the cubemap are present with DDSCAPS2_CUBEMAP_POSITIVEX, etc.\r\n\r\n\t\tdds.isCubemap = header[ off_caps2 ] & DDSCAPS2_CUBEMAP ? true : false;\r\n\r\n\t\tdds.width = header[ off_width ];\r\n\t\tdds.height = header[ off_height ];\r\n\r\n\t\tvar dataOffset = header[ off_size ] + 4;\r\n\r\n\t\t// Extract mipmaps buffers\r\n\r\n\t\tvar width = dds.width;\r\n\t\tvar height = dds.height;\r\n\r\n\t\tvar faces = dds.isCubemap ? 6 : 1;\r\n\r\n\t\tfor ( var face = 0; face < faces; face ++ ) {\r\n\r\n\t\t\tfor ( var i = 0; i < dds.mipmapCount; i ++ ) {\r\n\r\n\t\t\t\tvar dataLength = Math.max( 4, width ) / 4 * Math.max( 4, height ) / 4 * blockBytes;\r\n\t\t\t\tvar byteArray = new Uint8Array( buffer, dataOffset, dataLength );\r\n\r\n\t\t\t\tvar mipmap = { \"data\": byteArray, \"width\": width, \"height\": height };\r\n\t\t\t\tdds.mipmaps.push( mipmap );\r\n\r\n\t\t\t\tdataOffset += dataLength;\r\n\r\n\t\t\t\twidth = Math.max( width * 0.5, 1 );\r\n\t\t\t\theight = Math.max( height * 0.5, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\twidth = dds.width;\r\n\t\t\theight = dds.height;\r\n\r\n\t\t}\r\n\r\n\t\treturn dds;\r\n\r\n\t},\r\n\r\n\tgetNormalMap: function ( image, depth ) {\r\n\r\n\t\t// Adapted from http://www.paulbrunt.co.uk/lab/heightnormal/\r\n\r\n\t\tvar cross = function ( a, b ) {\r\n\r\n\t\t\treturn [ a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ], a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ], a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ] ];\r\n\r\n\t\t}\r\n\r\n\t\tvar subtract = function ( a, b ) {\r\n\r\n\t\t\treturn [ a[ 0 ] - b[ 0 ], a[ 1 ] - b[ 1 ], a[ 2 ] - b[ 2 ] ];\r\n\r\n\t\t}\r\n\r\n\t\tvar normalize = function ( a ) {\r\n\r\n\t\t\tvar l = Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );\r\n\t\t\treturn [ a[ 0 ] / l, a[ 1 ] / l, a[ 2 ] / l ];\r\n\r\n\t\t}\r\n\r\n\t\tdepth = depth | 1;\r\n\r\n\t\tvar width = image.width;\r\n\t\tvar height = image.height;\r\n\r\n\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\tcanvas.width = width;\r\n\t\tcanvas.height = height;\r\n\r\n\t\tvar context = canvas.getContext( '2d' );\r\n\t\tcontext.drawImage( image, 0, 0 );\r\n\r\n\t\tvar data = context.getImageData( 0, 0, width, height ).data;\r\n\t\tvar imageData = context.createImageData( width, height );\r\n\t\tvar output = imageData.data;\r\n\r\n\t\tfor ( var x = 0; x < width; x ++ ) {\r\n\r\n\t\t\tfor ( var y = 0; y < height; y ++ ) {\r\n\r\n\t\t\t\tvar ly = y - 1 < 0 ? 0 : y - 1;\r\n\t\t\t\tvar uy = y + 1 > height - 1 ? height - 1 : y + 1;\r\n\t\t\t\tvar lx = x - 1 < 0 ? 0 : x - 1;\r\n\t\t\t\tvar ux = x + 1 > width - 1 ? width - 1 : x + 1;\r\n\r\n\t\t\t\tvar points = [];\r\n\t\t\t\tvar origin = [ 0, 0, data[ ( y * width + x ) * 4 ] / 255 * depth ];\r\n\t\t\t\tpoints.push( [ - 1, 0, data[ ( y * width + lx ) * 4 ] / 255 * depth ] );\r\n\t\t\t\tpoints.push( [ - 1, - 1, data[ ( ly * width + lx ) * 4 ] / 255 * depth ] );\r\n\t\t\t\tpoints.push( [ 0, - 1, data[ ( ly * width + x ) * 4 ] / 255 * depth ] );\r\n\t\t\t\tpoints.push( [  1, - 1, data[ ( ly * width + ux ) * 4 ] / 255 * depth ] );\r\n\t\t\t\tpoints.push( [ 1, 0, data[ ( y * width + ux ) * 4 ] / 255 * depth ] );\r\n\t\t\t\tpoints.push( [ 1, 1, data[ ( uy * width + ux ) * 4 ] / 255 * depth ] );\r\n\t\t\t\tpoints.push( [ 0, 1, data[ ( uy * width + x ) * 4 ] / 255 * depth ] );\r\n\t\t\t\tpoints.push( [ - 1, 1, data[ ( uy * width + lx ) * 4 ] / 255 * depth ] );\r\n\r\n\t\t\t\tvar normals = [];\r\n\t\t\t\tvar num_points = points.length;\r\n\r\n\t\t\t\tfor ( var i = 0; i < num_points; i ++ ) {\r\n\r\n\t\t\t\t\tvar v1 = points[ i ];\r\n\t\t\t\t\tvar v2 = points[ ( i + 1 ) % num_points ];\r\n\t\t\t\t\tv1 = subtract( v1, origin );\r\n\t\t\t\t\tv2 = subtract( v2, origin );\r\n\t\t\t\t\tnormals.push( normalize( cross( v1, v2 ) ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar normal = [ 0, 0, 0 ];\r\n\r\n\t\t\t\tfor ( var i = 0; i < normals.length; i ++ ) {\r\n\r\n\t\t\t\t\tnormal[ 0 ] += normals[ i ][ 0 ];\r\n\t\t\t\t\tnormal[ 1 ] += normals[ i ][ 1 ];\r\n\t\t\t\t\tnormal[ 2 ] += normals[ i ][ 2 ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnormal[ 0 ] /= normals.length;\r\n\t\t\t\tnormal[ 1 ] /= normals.length;\r\n\t\t\t\tnormal[ 2 ] /= normals.length;\r\n\r\n\t\t\t\tvar idx = ( y * width + x ) * 4;\r\n\r\n\t\t\t\toutput[ idx ] = ( ( normal[ 0 ] + 1.0 ) / 2.0 * 255 ) | 0;\r\n\t\t\t\toutput[ idx + 1 ] = ( ( normal[ 1 ] + 1.0 ) / 2.0 * 255 ) | 0;\r\n\t\t\t\toutput[ idx + 2 ] = ( normal[ 2 ] * 255 ) | 0;\r\n\t\t\t\toutput[ idx + 3 ] = 255;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tcontext.putImageData( imageData, 0, 0 );\r\n\r\n\t\treturn canvas;\r\n\r\n\t},\r\n\r\n\tgenerateDataTexture: function ( width, height, color ) {\r\n\r\n\t\tvar size = width * height;\r\n\t\tvar data = new Uint8Array( 3 * size );\r\n\r\n\t\tvar r = Math.floor( color.r * 255 );\r\n\t\tvar g = Math.floor( color.g * 255 );\r\n\t\tvar b = Math.floor( color.b * 255 );\r\n\r\n\t\tfor ( var i = 0; i < size; i ++ ) {\r\n\r\n\t\t\tdata[ i * 3 ] \t  = r;\r\n\t\t\tdata[ i * 3 + 1 ] = g;\r\n\t\t\tdata[ i * 3 + 2 ] = b;\r\n\r\n\t\t}\r\n\r\n\t\tvar texture = new THREE.DataTexture( data, width, height, THREE.RGBFormat );\r\n\t\ttexture.needsUpdate = true;\r\n\r\n\t\treturn texture;\r\n\r\n\t}\r\n\r\n};\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.SceneUtils = {\r\n\r\n\tcreateMultiMaterialObject: function ( geometry, materials ) {\r\n\r\n\t\tvar group = new THREE.Object3D();\r\n\r\n\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\r\n\r\n\t\t\tgroup.add( new THREE.Mesh( geometry, materials[ i ] ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn group;\r\n\r\n\t},\r\n\r\n\tdetach : function ( child, parent, scene ) {\r\n\r\n\t\tchild.applyMatrix( parent.matrixWorld );\r\n\t\tparent.remove( child );\r\n\t\tscene.add( child );\r\n\r\n\t},\r\n\r\n\tattach: function ( child, scene, parent ) {\r\n\r\n\t\tvar matrixWorldInverse = new THREE.Matrix4();\r\n\t\tmatrixWorldInverse.getInverse( parent.matrixWorld );\r\n\t\tchild.applyMatrix( matrixWorldInverse );\r\n\r\n\t\tscene.remove( child );\r\n\t\tparent.add( child );\r\n\r\n\t}\r\n\r\n};\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * For Text operations in three.js (See TextGeometry)\r\n *\r\n * It uses techniques used in:\r\n *\r\n * \ttypeface.js and canvastext\r\n * \t\tFor converting fonts and rendering with javascript\r\n *\t\thttp://typeface.neocracy.org\r\n *\r\n *\tTriangulation ported from AS3\r\n *\t\tSimple Polygon Triangulation\r\n *\t\thttp://actionsnippet.com/?p=1462\r\n *\r\n * \tA Method to triangulate shapes with holes\r\n *\t\thttp://www.sakri.net/blog/2009/06/12/an-approach-to-triangulating-polygons-with-holes/\r\n *\r\n */\r\n\r\nTHREE.FontUtils = {\r\n\r\n\tfaces : {},\r\n\r\n\t// Just for now. face[weight][style]\r\n\r\n\tface : \"helvetiker\",\r\n\tweight: \"normal\",\r\n\tstyle : \"normal\",\r\n\tsize : 150,\r\n\tdivisions : 10,\r\n\r\n\tgetFace : function() {\r\n\r\n\t\treturn this.faces[ this.face ][ this.weight ][ this.style ];\r\n\r\n\t},\r\n\r\n\tloadFace : function( data ) {\r\n\r\n\t\tvar family = data.familyName.toLowerCase();\r\n\r\n\t\tvar ThreeFont = this;\r\n\r\n\t\tThreeFont.faces[ family ] = ThreeFont.faces[ family ] || {};\r\n\r\n\t\tThreeFont.faces[ family ][ data.cssFontWeight ] = ThreeFont.faces[ family ][ data.cssFontWeight ] || {};\r\n\t\tThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;\r\n\r\n\t\tvar face = ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;\r\n\r\n\t\treturn data;\r\n\r\n\t},\r\n\r\n\tdrawText : function( text ) {\r\n\r\n\t\tvar characterPts = [], allPts = [];\r\n\r\n\t\t// RenderText\r\n\r\n\t\tvar i, p,\r\n\t\t\tface = this.getFace(),\r\n\t\t\tscale = this.size / face.resolution,\r\n\t\t\toffset = 0,\r\n\t\t\tchars = String( text ).split( '' ),\r\n\t\t\tlength = chars.length;\r\n\r\n\t\tvar fontPaths = [];\r\n\r\n\t\tfor ( i = 0; i < length; i ++ ) {\r\n\r\n\t\t\tvar path = new THREE.Path();\r\n\r\n\t\t\tvar ret = this.extractGlyphPoints( chars[ i ], face, scale, offset, path );\r\n\t\t\toffset += ret.offset;\r\n\r\n\t\t\tfontPaths.push( ret.path );\r\n\r\n\t\t}\r\n\r\n\t\t// get the width\r\n\r\n\t\tvar width = offset / 2;\r\n\t\t//\r\n\t\t// for ( p = 0; p < allPts.length; p++ ) {\r\n\t\t//\r\n\t\t// \tallPts[ p ].x -= width;\r\n\t\t//\r\n\t\t// }\r\n\r\n\t\t//var extract = this.extractPoints( allPts, characterPts );\r\n\t\t//extract.contour = allPts;\r\n\r\n\t\t//extract.paths = fontPaths;\r\n\t\t//extract.offset = width;\r\n\r\n\t\treturn { paths : fontPaths, offset : width };\r\n\r\n\t},\r\n\r\n\r\n\r\n\r\n\textractGlyphPoints : function( c, face, scale, offset, path ) {\r\n\r\n\t\tvar pts = [];\r\n\r\n\t\tvar i, i2, divisions,\r\n\t\t\toutline, action, length,\r\n\t\t\tscaleX, scaleY,\r\n\t\t\tx, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2,\r\n\t\t\tlaste,\r\n\t\t\tglyph = face.glyphs[ c ] || face.glyphs[ '?' ];\r\n\r\n\t\tif ( !glyph ) return;\r\n\r\n\t\tif ( glyph.o ) {\r\n\r\n\t\t\toutline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\r\n\t\t\tlength = outline.length;\r\n\r\n\t\t\tscaleX = scale;\r\n\t\t\tscaleY = scale;\r\n\r\n\t\t\tfor ( i = 0; i < length; ) {\r\n\r\n\t\t\t\taction = outline[ i ++ ];\r\n\r\n\t\t\t\t//console.log( action );\r\n\r\n\t\t\t\tswitch( action ) {\r\n\r\n\t\t\t\tcase 'm':\r\n\r\n\t\t\t\t\t// Move To\r\n\r\n\t\t\t\t\tx = outline[ i++ ] * scaleX + offset;\r\n\t\t\t\t\ty = outline[ i++ ] * scaleY;\r\n\r\n\t\t\t\t\tpath.moveTo( x, y );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'l':\r\n\r\n\t\t\t\t\t// Line To\r\n\r\n\t\t\t\t\tx = outline[ i++ ] * scaleX + offset;\r\n\t\t\t\t\ty = outline[ i++ ] * scaleY;\r\n\t\t\t\t\tpath.lineTo(x,y);\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'q':\r\n\r\n\t\t\t\t\t// QuadraticCurveTo\r\n\r\n\t\t\t\t\tcpx  = outline[ i++ ] * scaleX + offset;\r\n\t\t\t\t\tcpy  = outline[ i++ ] * scaleY;\r\n\t\t\t\t\tcpx1 = outline[ i++ ] * scaleX + offset;\r\n\t\t\t\t\tcpy1 = outline[ i++ ] * scaleY;\r\n\r\n\t\t\t\t\tpath.quadraticCurveTo(cpx1, cpy1, cpx, cpy);\r\n\r\n\t\t\t\t\tlaste = pts[ pts.length - 1 ];\r\n\r\n\t\t\t\t\tif ( laste ) {\r\n\r\n\t\t\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\t\t\tcpy0 = laste.y;\r\n\r\n\t\t\t\t\t\tfor ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {\r\n\r\n\t\t\t\t\t\t\tvar t = i2 / divisions;\r\n\t\t\t\t\t\t\tvar tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );\r\n\t\t\t\t\t\t\tvar ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );\r\n\t\t\t\t\t  }\r\n\r\n\t\t\t\t  }\r\n\r\n\t\t\t\t  break;\r\n\r\n\t\t\t\tcase 'b':\r\n\r\n\t\t\t\t\t// Cubic Bezier Curve\r\n\r\n\t\t\t\t\tcpx  = outline[ i++ ] *  scaleX + offset;\r\n\t\t\t\t\tcpy  = outline[ i++ ] *  scaleY;\r\n\t\t\t\t\tcpx1 = outline[ i++ ] *  scaleX + offset;\r\n\t\t\t\t\tcpy1 = outline[ i++ ] * -scaleY;\r\n\t\t\t\t\tcpx2 = outline[ i++ ] *  scaleX + offset;\r\n\t\t\t\t\tcpy2 = outline[ i++ ] * -scaleY;\r\n\r\n\t\t\t\t\tpath.bezierCurveTo( cpx, cpy, cpx1, cpy1, cpx2, cpy2 );\r\n\r\n\t\t\t\t\tlaste = pts[ pts.length - 1 ];\r\n\r\n\t\t\t\t\tif ( laste ) {\r\n\r\n\t\t\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\t\t\tcpy0 = laste.y;\r\n\r\n\t\t\t\t\t\tfor ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {\r\n\r\n\t\t\t\t\t\t\tvar t = i2 / divisions;\r\n\t\t\t\t\t\t\tvar tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );\r\n\t\t\t\t\t\t\tvar ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\r\n\t\treturn { offset: glyph.ha*scale, path:path};\r\n\t}\r\n\r\n};\r\n\r\n\r\nTHREE.FontUtils.generateShapes = function( text, parameters ) {\r\n\r\n\t// Parameters \r\n\r\n\tparameters = parameters || {};\r\n\r\n\tvar size = parameters.size !== undefined ? parameters.size : 100;\r\n\tvar curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments: 4;\r\n\r\n\tvar font = parameters.font !== undefined ? parameters.font : \"helvetiker\";\r\n\tvar weight = parameters.weight !== undefined ? parameters.weight : \"normal\";\r\n\tvar style = parameters.style !== undefined ? parameters.style : \"normal\";\r\n\r\n\tTHREE.FontUtils.size = size;\r\n\tTHREE.FontUtils.divisions = curveSegments;\r\n\r\n\tTHREE.FontUtils.face = font;\r\n\tTHREE.FontUtils.weight = weight;\r\n\tTHREE.FontUtils.style = style;\r\n\r\n\t// Get a Font data json object\r\n\r\n\tvar data = THREE.FontUtils.drawText( text );\r\n\r\n\tvar paths = data.paths;\r\n\tvar shapes = [];\r\n\r\n\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\r\n\r\n\t\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\r\n\r\n\t}\r\n\r\n\treturn shapes;\r\n\r\n};\r\n\r\n\r\n/**\r\n * This code is a quick port of code written in C++ which was submitted to\r\n * flipcode.com by John W. Ratcliff  // July 22, 2000\r\n * See original code and more information here:\r\n * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml\r\n *\r\n * ported to actionscript by Zevan Rosser\r\n * www.actionsnippet.com\r\n *\r\n * ported to javascript by Joshua Koo\r\n * http://www.lab4games.net/zz85/blog\r\n *\r\n */\r\n\r\n\r\n( function( namespace ) {\r\n\r\n\tvar EPSILON = 0.0000000001;\r\n\r\n\t// takes in an contour array and returns\r\n\r\n\tvar process = function( contour, indices ) {\r\n\r\n\t\tvar n = contour.length;\r\n\r\n\t\tif ( n < 3 ) return null;\r\n\r\n\t\tvar result = [],\r\n\t\t\tverts = [],\r\n\t\t\tvertIndices = [];\r\n\r\n\t\t/* we want a counter-clockwise polygon in verts */\r\n\r\n\t\tvar u, v, w;\r\n\r\n\t\tif ( area( contour ) > 0.0 ) {\r\n\r\n\t\t\tfor ( v = 0; v < n; v++ ) verts[ v ] = v;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tfor ( v = 0; v < n; v++ ) verts[ v ] = ( n - 1 ) - v;\r\n\r\n\t\t}\r\n\r\n\t\tvar nv = n;\r\n\r\n\t\t/*  remove nv - 2 vertices, creating 1 triangle every time */\r\n\r\n\t\tvar count = 2 * nv;   /* error detection */\r\n\r\n\t\tfor( v = nv - 1; nv > 2; ) {\r\n\r\n\t\t\t/* if we loop, it is probably a non-simple polygon */\r\n\r\n\t\t\tif ( ( count-- ) <= 0 ) {\r\n\r\n\t\t\t\t//** Triangulate: ERROR - probable bad polygon!\r\n\r\n\t\t\t\t//throw ( \"Warning, unable to triangulate polygon!\" );\r\n\t\t\t\t//return null;\r\n\t\t\t\t// Sometimes warning is fine, especially polygons are triangulated in reverse.\r\n\t\t\t\tconsole.log( \"Warning, unable to triangulate polygon!\" );\r\n\r\n\t\t\t\tif ( indices ) return vertIndices;\r\n\t\t\t\treturn result;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t/* three consecutive vertices in current polygon, <u,v,w> */\r\n\r\n\t\t\tu = v; \t \tif ( nv <= u ) u = 0;     /* previous */\r\n\t\t\tv = u + 1;  if ( nv <= v ) v = 0;     /* new v    */\r\n\t\t\tw = v + 1;  if ( nv <= w ) w = 0;     /* next     */\r\n\r\n\t\t\tif ( snip( contour, u, v, w, nv, verts ) ) {\r\n\r\n\t\t\t\tvar a, b, c, s, t;\r\n\r\n\t\t\t\t/* true names of the vertices */\r\n\r\n\t\t\t\ta = verts[ u ];\r\n\t\t\t\tb = verts[ v ];\r\n\t\t\t\tc = verts[ w ];\r\n\r\n\t\t\t\t/* output Triangle */\r\n\r\n\t\t\t\tresult.push( [ contour[ a ],\r\n\t\t\t\t\tcontour[ b ],\r\n\t\t\t\t\tcontour[ c ] ] );\r\n\r\n\r\n\t\t\t\tvertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );\r\n\r\n\t\t\t\t/* remove v from the remaining polygon */\r\n\r\n\t\t\t\tfor( s = v, t = v + 1; t < nv; s++, t++ ) {\r\n\r\n\t\t\t\t\tverts[ s ] = verts[ t ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnv--;\r\n\r\n\t\t\t\t/* reset error detection counter */\r\n\r\n\t\t\t\tcount = 2 * nv;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( indices ) return vertIndices;\r\n\t\treturn result;\r\n\r\n\t};\r\n\r\n\t// calculate area of the contour polygon\r\n\r\n\tvar area = function ( contour ) {\r\n\r\n\t\tvar n = contour.length;\r\n\t\tvar a = 0.0;\r\n\r\n\t\tfor( var p = n - 1, q = 0; q < n; p = q++ ) {\r\n\r\n\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\r\n\r\n\t\t}\r\n\r\n\t\treturn a * 0.5;\r\n\r\n\t};\r\n\r\n\tvar snip = function ( contour, u, v, w, n, verts ) {\r\n\r\n\t\tvar p;\r\n\t\tvar ax, ay, bx, by;\r\n\t\tvar cx, cy, px, py;\r\n\r\n\t\tax = contour[ verts[ u ] ].x;\r\n\t\tay = contour[ verts[ u ] ].y;\r\n\r\n\t\tbx = contour[ verts[ v ] ].x;\r\n\t\tby = contour[ verts[ v ] ].y;\r\n\r\n\t\tcx = contour[ verts[ w ] ].x;\r\n\t\tcy = contour[ verts[ w ] ].y;\r\n\r\n\t\tif ( EPSILON > (((bx-ax)*(cy-ay)) - ((by-ay)*(cx-ax))) ) return false;\r\n\r\n\t\tvar aX, aY, bX, bY, cX, cY;\r\n\t\tvar apx, apy, bpx, bpy, cpx, cpy;\r\n\t\tvar cCROSSap, bCROSScp, aCROSSbp;\r\n\r\n\t\taX = cx - bx;  aY = cy - by;\r\n\t\tbX = ax - cx;  bY = ay - cy;\r\n\t\tcX = bx - ax;  cY = by - ay;\r\n\r\n\t\tfor ( p = 0; p < n; p++ ) {\r\n\r\n\t\t\tif( (p === u) || (p === v) || (p === w) ) continue;\r\n\r\n\t\t\tpx = contour[ verts[ p ] ].x\r\n\t\t\tpy = contour[ verts[ p ] ].y\r\n\r\n\t\t\tapx = px - ax;  apy = py - ay;\r\n\t\t\tbpx = px - bx;  bpy = py - by;\r\n\t\t\tcpx = px - cx;  cpy = py - cy;\r\n\r\n\t\t\t// see if p is inside triangle abc\r\n\r\n\t\t\taCROSSbp = aX*bpy - aY*bpx;\r\n\t\t\tcCROSSap = cX*apy - cY*apx;\r\n\t\t\tbCROSScp = bX*cpy - bY*cpx;\r\n\r\n\t\t\tif ( (aCROSSbp >= 0.0) && (bCROSScp >= 0.0) && (cCROSSap >= 0.0) ) return false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t};\r\n\r\n\r\n\tnamespace.Triangulate = process;\r\n\tnamespace.Triangulate.area = area;\r\n\r\n\treturn namespace;\r\n\r\n})(THREE.FontUtils);\r\n\r\n// To use the typeface.js face files, hook up the API\r\nself._typeface_js = { faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace };/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Extensible curve object\r\n *\r\n * Some common of Curve methods\r\n * .getPoint(t), getTangent(t)\r\n * .getPointAt(u), getTagentAt(u)\r\n * .getPoints(), .getSpacedPoints()\r\n * .getLength()\r\n * .updateArcLengths()\r\n *\r\n * This file contains following classes:\r\n *\r\n * -- 2d classes --\r\n * THREE.Curve\r\n * THREE.LineCurve\r\n * THREE.QuadraticBezierCurve\r\n * THREE.CubicBezierCurve\r\n * THREE.SplineCurve\r\n * THREE.ArcCurve\r\n * THREE.EllipseCurve\r\n *\r\n * -- 3d classes --\r\n * THREE.LineCurve3\r\n * THREE.QuadraticBezierCurve3\r\n * THREE.CubicBezierCurve3\r\n * THREE.SplineCurve3\r\n * THREE.ClosedSplineCurve3\r\n *\r\n * A series of curves can be represented as a THREE.CurvePath\r\n *\r\n **/\r\n\r\n/**************************************************************\r\n *\tAbstract Curve base class\r\n **************************************************************/\r\n\r\nTHREE.Curve = function () {\r\n\r\n};\r\n\r\n// Virtual base class method to overwrite and implement in subclasses\r\n//\t- t [0 .. 1]\r\n\r\nTHREE.Curve.prototype.getPoint = function ( t ) {\r\n\r\n\tconsole.log( \"Warning, getPoint() not implemented!\" );\r\n\treturn null;\r\n\r\n};\r\n\r\n// Get point at relative position in curve according to arc length\r\n// - u [0 .. 1]\r\n\r\nTHREE.Curve.prototype.getPointAt = function ( u ) {\r\n\r\n\tvar t = this.getUtoTmapping( u );\r\n\treturn this.getPoint( t );\r\n\r\n};\r\n\r\n// Get sequence of points using getPoint( t )\r\n\r\nTHREE.Curve.prototype.getPoints = function ( divisions ) {\r\n\r\n\tif ( !divisions ) divisions = 5;\r\n\r\n\tvar d, pts = [];\r\n\r\n\tfor ( d = 0; d <= divisions; d ++ ) {\r\n\r\n\t\tpts.push( this.getPoint( d / divisions ) );\r\n\r\n\t}\r\n\r\n\treturn pts;\r\n\r\n};\r\n\r\n// Get sequence of points using getPointAt( u )\r\n\r\nTHREE.Curve.prototype.getSpacedPoints = function ( divisions ) {\r\n\r\n\tif ( !divisions ) divisions = 5;\r\n\r\n\tvar d, pts = [];\r\n\r\n\tfor ( d = 0; d <= divisions; d ++ ) {\r\n\r\n\t\tpts.push( this.getPointAt( d / divisions ) );\r\n\r\n\t}\r\n\r\n\treturn pts;\r\n\r\n};\r\n\r\n// Get total curve arc length\r\n\r\nTHREE.Curve.prototype.getLength = function () {\r\n\r\n\tvar lengths = this.getLengths();\r\n\treturn lengths[ lengths.length - 1 ];\r\n\r\n};\r\n\r\n// Get list of cumulative segment lengths\r\n\r\nTHREE.Curve.prototype.getLengths = function ( divisions ) {\r\n\r\n\tif ( !divisions ) divisions = (this.__arcLengthDivisions) ? (this.__arcLengthDivisions): 200;\r\n\r\n\tif ( this.cacheArcLengths\r\n\t\t&& ( this.cacheArcLengths.length == divisions + 1 )\r\n\t\t&& !this.needsUpdate) {\r\n\r\n\t\t//console.log( \"cached\", this.cacheArcLengths );\r\n\t\treturn this.cacheArcLengths;\r\n\r\n\t}\r\n\r\n\tthis.needsUpdate = false;\r\n\r\n\tvar cache = [];\r\n\tvar current, last = this.getPoint( 0 );\r\n\tvar p, sum = 0;\r\n\r\n\tcache.push( 0 );\r\n\r\n\tfor ( p = 1; p <= divisions; p ++ ) {\r\n\r\n\t\tcurrent = this.getPoint ( p / divisions );\r\n\t\tsum += current.distanceTo( last );\r\n\t\tcache.push( sum );\r\n\t\tlast = current;\r\n\r\n\t}\r\n\r\n\tthis.cacheArcLengths = cache;\r\n\r\n\treturn cache; // { sums: cache, sum:sum }; Sum is in the last element.\r\n\r\n};\r\n\r\n\r\nTHREE.Curve.prototype.updateArcLengths = function() {\r\n\tthis.needsUpdate = true;\r\n\tthis.getLengths();\r\n};\r\n\r\n// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance\r\n\r\nTHREE.Curve.prototype.getUtoTmapping = function ( u, distance ) {\r\n\r\n\tvar arcLengths = this.getLengths();\r\n\r\n\tvar i = 0, il = arcLengths.length;\r\n\r\n\tvar targetArcLength; // The targeted u distance value to get\r\n\r\n\tif ( distance ) {\r\n\r\n\t\ttargetArcLength = distance;\r\n\r\n\t} else {\r\n\r\n\t\ttargetArcLength = u * arcLengths[ il - 1 ];\r\n\r\n\t}\r\n\r\n\t//var time = Date.now();\r\n\r\n\t// binary search for the index with largest value smaller than target u distance\r\n\r\n\tvar low = 0, high = il - 1, comparison;\r\n\r\n\twhile ( low <= high ) {\r\n\r\n\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\r\n\r\n\t\tcomparison = arcLengths[ i ] - targetArcLength;\r\n\r\n\t\tif ( comparison < 0 ) {\r\n\r\n\t\t\tlow = i + 1;\r\n\t\t\tcontinue;\r\n\r\n\t\t} else if ( comparison > 0 ) {\r\n\r\n\t\t\thigh = i - 1;\r\n\t\t\tcontinue;\r\n\r\n\t\t} else {\r\n\r\n\t\t\thigh = i;\r\n\t\t\tbreak;\r\n\r\n\t\t\t// DONE\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\ti = high;\r\n\r\n\t//console.log('b' , i, low, high, Date.now()- time);\r\n\r\n\tif ( arcLengths[ i ] == targetArcLength ) {\r\n\r\n\t\tvar t = i / ( il - 1 );\r\n\t\treturn t;\r\n\r\n\t}\r\n\r\n\t// we could get finer grain at lengths, or use simple interpolatation between two points\r\n\r\n\tvar lengthBefore = arcLengths[ i ];\r\n    var lengthAfter = arcLengths[ i + 1 ];\r\n\r\n    var segmentLength = lengthAfter - lengthBefore;\r\n\r\n    // determine where we are between the 'before' and 'after' points\r\n\r\n    var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\r\n\r\n    // add that fractional amount to t\r\n\r\n    var t = ( i + segmentFraction ) / ( il -1 );\r\n\r\n\treturn t;\r\n\r\n};\r\n\r\n// Returns a unit vector tangent at t\r\n// In case any sub curve does not implement its tangent derivation,\r\n// 2 points a small delta apart will be used to find its gradient\r\n// which seems to give a reasonable approximation\r\n\r\nTHREE.Curve.prototype.getTangent = function( t ) {\r\n\r\n\tvar delta = 0.0001;\r\n\tvar t1 = t - delta;\r\n\tvar t2 = t + delta;\r\n\r\n\t// Capping in case of danger\r\n\r\n\tif ( t1 < 0 ) t1 = 0;\r\n\tif ( t2 > 1 ) t2 = 1;\r\n\r\n\tvar pt1 = this.getPoint( t1 );\r\n\tvar pt2 = this.getPoint( t2 );\r\n\r\n\tvar vec = pt2.clone().sub(pt1);\r\n\treturn vec.normalize();\r\n\r\n};\r\n\r\n\r\nTHREE.Curve.prototype.getTangentAt = function ( u ) {\r\n\r\n\tvar t = this.getUtoTmapping( u );\r\n\treturn this.getTangent( t );\r\n\r\n};\r\n\r\n/**************************************************************\r\n *\tLine\r\n **************************************************************/\r\n\r\nTHREE.LineCurve = function ( v1, v2 ) {\r\n\r\n\tthis.v1 = v1;\r\n\tthis.v2 = v2;\r\n\r\n};\r\n\r\nTHREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );\r\n\r\nTHREE.LineCurve.prototype.getPoint = function ( t ) {\r\n\r\n\tvar point = this.v2.clone().sub(this.v1);\r\n\tpoint.multiplyScalar( t ).add( this.v1 );\r\n\r\n\treturn point;\r\n\r\n};\r\n\r\n// Line curve is linear, so we can overwrite default getPointAt\r\n\r\nTHREE.LineCurve.prototype.getPointAt = function ( u ) {\r\n\r\n\treturn this.getPoint( u );\r\n\r\n};\r\n\r\nTHREE.LineCurve.prototype.getTangent = function( t ) {\r\n\r\n\tvar tangent = this.v2.clone().sub(this.v1);\r\n\r\n\treturn tangent.normalize();\r\n\r\n};\r\n\r\n/**************************************************************\r\n *\tQuadratic Bezier curve\r\n **************************************************************/\r\n\r\n\r\nTHREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {\r\n\r\n\tthis.v0 = v0;\r\n\tthis.v1 = v1;\r\n\tthis.v2 = v2;\r\n\r\n};\r\n\r\nTHREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );\r\n\r\n\r\nTHREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {\r\n\r\n\tvar tx, ty;\r\n\r\n\ttx = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );\r\n\tty = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );\r\n\r\n\treturn new THREE.Vector2( tx, ty );\r\n\r\n};\r\n\r\n\r\nTHREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {\r\n\r\n\tvar tx, ty;\r\n\r\n\ttx = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x );\r\n\tty = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y );\r\n\r\n\t// returns unit vector\r\n\r\n\tvar tangent = new THREE.Vector2( tx, ty );\r\n\ttangent.normalize();\r\n\r\n\treturn tangent;\r\n\r\n};\r\n\r\n\r\n/**************************************************************\r\n *\tCubic Bezier curve\r\n **************************************************************/\r\n\r\nTHREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {\r\n\r\n\tthis.v0 = v0;\r\n\tthis.v1 = v1;\r\n\tthis.v2 = v2;\r\n\tthis.v3 = v3;\r\n\r\n};\r\n\r\nTHREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );\r\n\r\nTHREE.CubicBezierCurve.prototype.getPoint = function ( t ) {\r\n\r\n\tvar tx, ty;\r\n\r\n\ttx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );\r\n\tty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );\r\n\r\n\treturn new THREE.Vector2( tx, ty );\r\n\r\n};\r\n\r\nTHREE.CubicBezierCurve.prototype.getTangent = function( t ) {\r\n\r\n\tvar tx, ty;\r\n\r\n\ttx = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );\r\n\tty = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );\r\n\r\n\tvar tangent = new THREE.Vector2( tx, ty );\r\n\ttangent.normalize();\r\n\r\n\treturn tangent;\r\n\r\n};\r\n\r\n\r\n/**************************************************************\r\n *\tSpline curve\r\n **************************************************************/\r\n\r\nTHREE.SplineCurve = function ( points /* array of Vector2 */ ) {\r\n\r\n\tthis.points = (points == undefined) ? [] : points;\r\n\r\n};\r\n\r\nTHREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );\r\n\r\nTHREE.SplineCurve.prototype.getPoint = function ( t ) {\r\n\r\n\tvar v = new THREE.Vector2();\r\n\tvar c = [];\r\n\tvar points = this.points, point, intPoint, weight;\r\n\tpoint = ( points.length - 1 ) * t;\r\n\r\n\tintPoint = Math.floor( point );\r\n\tweight = point - intPoint;\r\n\r\n\tc[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;\r\n\tc[ 1 ] = intPoint;\r\n\tc[ 2 ] = intPoint  > points.length - 2 ? points.length -1 : intPoint + 1;\r\n\tc[ 3 ] = intPoint  > points.length - 3 ? points.length -1 : intPoint + 2;\r\n\r\n\tv.x = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].x, points[ c[ 1 ] ].x, points[ c[ 2 ] ].x, points[ c[ 3 ] ].x, weight );\r\n\tv.y = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].y, points[ c[ 1 ] ].y, points[ c[ 2 ] ].y, points[ c[ 3 ] ].y, weight );\r\n\r\n\treturn v;\r\n\r\n};\r\n\r\n/**************************************************************\r\n *\tEllipse curve\r\n **************************************************************/\r\n\r\nTHREE.EllipseCurve = function ( aX, aY, xRadius, yRadius,\r\n\t\t\t\t\t\t\taStartAngle, aEndAngle,\r\n\t\t\t\t\t\t\taClockwise ) {\r\n\r\n\tthis.aX = aX;\r\n\tthis.aY = aY;\r\n\r\n\tthis.xRadius = xRadius;\r\n\tthis.yRadius = yRadius;\r\n\r\n\tthis.aStartAngle = aStartAngle;\r\n\tthis.aEndAngle = aEndAngle;\r\n\r\n\tthis.aClockwise = aClockwise;\r\n\r\n};\r\n\r\nTHREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );\r\n\r\nTHREE.EllipseCurve.prototype.getPoint = function ( t ) {\r\n\r\n\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\r\n\r\n\tif ( !this.aClockwise ) {\r\n\r\n\t\tt = 1 - t;\r\n\r\n\t}\r\n\r\n\tvar angle = this.aStartAngle + t * deltaAngle;\r\n\r\n\tvar tx = this.aX + this.xRadius * Math.cos( angle );\r\n\tvar ty = this.aY + this.yRadius * Math.sin( angle );\r\n\r\n\treturn new THREE.Vector2( tx, ty );\r\n\r\n};\r\n\r\n/**************************************************************\r\n *\tArc curve\r\n **************************************************************/\r\n\r\nTHREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n\tTHREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\r\n};\r\n\r\nTHREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );\r\n\r\n\r\n/**************************************************************\r\n *\tUtils\r\n **************************************************************/\r\n\r\nTHREE.Curve.Utils = {\r\n\r\n\ttangentQuadraticBezier: function ( t, p0, p1, p2 ) {\r\n\r\n\t\treturn 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );\r\n\r\n\t},\r\n\r\n\t// Puay Bing, thanks for helping with this derivative!\r\n\r\n\ttangentCubicBezier: function (t, p0, p1, p2, p3 ) {\r\n\r\n\t\treturn -3 * p0 * (1 - t) * (1 - t)  +\r\n\t\t\t3 * p1 * (1 - t) * (1-t) - 6 *t *p1 * (1-t) +\r\n\t\t\t6 * t *  p2 * (1-t) - 3 * t * t * p2 +\r\n\t\t\t3 * t * t * p3;\r\n\t},\r\n\r\n\r\n\ttangentSpline: function ( t, p0, p1, p2, p3 ) {\r\n\r\n\t\t// To check if my formulas are correct\r\n\r\n\t\tvar h00 = 6 * t * t - 6 * t; \t// derived from 2t^3 − 3t^2 + 1\r\n\t\tvar h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t\r\n\t\tvar h01 = -6 * t * t + 6 * t; \t// − 2t3 + 3t2\r\n\t\tvar h11 = 3 * t * t - 2 * t;\t// t3 − t2\r\n\r\n\t\treturn h00 + h10 + h01 + h11;\r\n\r\n\t},\r\n\r\n\t// Catmull-Rom\r\n\r\n\tinterpolate: function( p0, p1, p2, p3, t ) {\r\n\r\n\t\tvar v0 = ( p2 - p0 ) * 0.5;\r\n\t\tvar v1 = ( p3 - p1 ) * 0.5;\r\n\t\tvar t2 = t * t;\r\n\t\tvar t3 = t * t2;\r\n\t\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\r\n\t}\r\n\r\n};\r\n\r\n\r\n// TODO: Transformation for Curves?\r\n\r\n/**************************************************************\r\n *\t3D Curves\r\n **************************************************************/\r\n\r\n// A Factory method for creating new curve subclasses\r\n\r\nTHREE.Curve.create = function ( constructor, getPointFunc ) {\r\n\r\n\tconstructor.prototype = Object.create( THREE.Curve.prototype );\r\n\tconstructor.prototype.getPoint = getPointFunc;\r\n\r\n\treturn constructor;\r\n\r\n};\r\n\r\n\r\n/**************************************************************\r\n *\tLine3D\r\n **************************************************************/\r\n\r\nTHREE.LineCurve3 = THREE.Curve.create(\r\n\r\n\tfunction ( v1, v2 ) {\r\n\r\n\t\tthis.v1 = v1;\r\n\t\tthis.v2 = v2;\r\n\r\n\t},\r\n\r\n\tfunction ( t ) {\r\n\r\n\t\tvar r = new THREE.Vector3();\r\n\r\n\r\n\t\tr.subVectors( this.v2, this.v1 ); // diff\r\n\t\tr.multiplyScalar( t );\r\n\t\tr.add( this.v1 );\r\n\r\n\t\treturn r;\r\n\r\n\t}\r\n\r\n);\r\n\r\n\r\n/**************************************************************\r\n *\tQuadratic Bezier 3D curve\r\n **************************************************************/\r\n\r\nTHREE.QuadraticBezierCurve3 = THREE.Curve.create(\r\n\r\n\tfunction ( v0, v1, v2 ) {\r\n\r\n\t\tthis.v0 = v0;\r\n\t\tthis.v1 = v1;\r\n\t\tthis.v2 = v2;\r\n\r\n\t},\r\n\r\n\tfunction ( t ) {\r\n\r\n\t\tvar tx, ty, tz;\r\n\r\n\t\ttx = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );\r\n\t\tty = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );\r\n\t\ttz = THREE.Shape.Utils.b2( t, this.v0.z, this.v1.z, this.v2.z );\r\n\r\n\t\treturn new THREE.Vector3( tx, ty, tz );\r\n\r\n\t}\r\n\r\n);\r\n\r\n\r\n\r\n/**************************************************************\r\n *\tCubic Bezier 3D curve\r\n **************************************************************/\r\n\r\nTHREE.CubicBezierCurve3 = THREE.Curve.create(\r\n\r\n\tfunction ( v0, v1, v2, v3 ) {\r\n\r\n\t\tthis.v0 = v0;\r\n\t\tthis.v1 = v1;\r\n\t\tthis.v2 = v2;\r\n\t\tthis.v3 = v3;\r\n\r\n\t},\r\n\r\n\tfunction ( t ) {\r\n\r\n\t\tvar tx, ty, tz;\r\n\r\n\t\ttx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );\r\n\t\tty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );\r\n\t\ttz = THREE.Shape.Utils.b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z );\r\n\r\n\t\treturn new THREE.Vector3( tx, ty, tz );\r\n\r\n\t}\r\n\r\n);\r\n\r\n\r\n\r\n/**************************************************************\r\n *\tSpline 3D curve\r\n **************************************************************/\r\n\r\n\r\nTHREE.SplineCurve3 = THREE.Curve.create(\r\n\r\n\tfunction ( points /* array of Vector3 */) {\r\n\r\n\t\tthis.points = (points == undefined) ? [] : points;\r\n\r\n\t},\r\n\r\n\tfunction ( t ) {\r\n\r\n\t\tvar v = new THREE.Vector3();\r\n\t\tvar c = [];\r\n\t\tvar points = this.points, point, intPoint, weight;\r\n\t\tpoint = ( points.length - 1 ) * t;\r\n\r\n\t\tintPoint = Math.floor( point );\r\n\t\tweight = point - intPoint;\r\n\r\n\t\tc[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;\r\n\t\tc[ 1 ] = intPoint;\r\n\t\tc[ 2 ] = intPoint  > points.length - 2 ? points.length - 1 : intPoint + 1;\r\n\t\tc[ 3 ] = intPoint  > points.length - 3 ? points.length - 1 : intPoint + 2;\r\n\r\n\t\tvar pt0 = points[ c[0] ],\r\n\t\t\tpt1 = points[ c[1] ],\r\n\t\t\tpt2 = points[ c[2] ],\r\n\t\t\tpt3 = points[ c[3] ];\r\n\r\n\t\tv.x = THREE.Curve.Utils.interpolate(pt0.x, pt1.x, pt2.x, pt3.x, weight);\r\n\t\tv.y = THREE.Curve.Utils.interpolate(pt0.y, pt1.y, pt2.y, pt3.y, weight);\r\n\t\tv.z = THREE.Curve.Utils.interpolate(pt0.z, pt1.z, pt2.z, pt3.z, weight);\r\n\r\n\t\treturn v;\r\n\r\n\t}\r\n\r\n);\r\n\r\n\r\n// THREE.SplineCurve3.prototype.getTangent = function(t) {\r\n// \t\tvar v = new THREE.Vector3();\r\n// \t\tvar c = [];\r\n// \t\tvar points = this.points, point, intPoint, weight;\r\n// \t\tpoint = ( points.length - 1 ) * t;\r\n\r\n// \t\tintPoint = Math.floor( point );\r\n// \t\tweight = point - intPoint;\r\n\r\n// \t\tc[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;\r\n// \t\tc[ 1 ] = intPoint;\r\n// \t\tc[ 2 ] = intPoint  > points.length - 2 ? points.length - 1 : intPoint + 1;\r\n// \t\tc[ 3 ] = intPoint  > points.length - 3 ? points.length - 1 : intPoint + 2;\r\n\r\n// \t\tvar pt0 = points[ c[0] ],\r\n// \t\t\tpt1 = points[ c[1] ],\r\n// \t\t\tpt2 = points[ c[2] ],\r\n// \t\t\tpt3 = points[ c[3] ];\r\n\r\n// \t// t = weight;\r\n// \tv.x = THREE.Curve.Utils.tangentSpline( t, pt0.x, pt1.x, pt2.x, pt3.x );\r\n// \tv.y = THREE.Curve.Utils.tangentSpline( t, pt0.y, pt1.y, pt2.y, pt3.y );\r\n// \tv.z = THREE.Curve.Utils.tangentSpline( t, pt0.z, pt1.z, pt2.z, pt3.z );\r\n\r\n// \treturn v;\r\n\r\n// }\r\n\r\n/**************************************************************\r\n *\tClosed Spline 3D curve\r\n **************************************************************/\r\n\r\n\r\nTHREE.ClosedSplineCurve3 = THREE.Curve.create(\r\n\r\n\tfunction ( points /* array of Vector3 */) {\r\n\r\n\t\tthis.points = (points == undefined) ? [] : points;\r\n\r\n\t},\r\n\r\n    function ( t ) {\r\n\r\n        var v = new THREE.Vector3();\r\n        var c = [];\r\n        var points = this.points, point, intPoint, weight;\r\n        point = ( points.length - 0 ) * t;\r\n            // This needs to be from 0-length +1\r\n\r\n        intPoint = Math.floor( point );\r\n        weight = point - intPoint;\r\n\r\n        intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\r\n        c[ 0 ] = ( intPoint - 1 ) % points.length;\r\n        c[ 1 ] = ( intPoint ) % points.length;\r\n        c[ 2 ] = ( intPoint + 1 ) % points.length;\r\n        c[ 3 ] = ( intPoint + 2 ) % points.length;\r\n\r\n        v.x = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].x, points[ c[ 1 ] ].x, points[ c[ 2 ] ].x, points[ c[ 3 ] ].x, weight );\r\n        v.y = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].y, points[ c[ 1 ] ].y, points[ c[ 2 ] ].y, points[ c[ 3 ] ].y, weight );\r\n        v.z = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].z, points[ c[ 1 ] ].z, points[ c[ 2 ] ].z, points[ c[ 3 ] ].z, weight );\r\n\r\n        return v;\r\n\r\n    }\r\n\r\n);\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n *\r\n **/\r\n\r\n/**************************************************************\r\n *\tCurved Path - a curve path is simply a array of connected\r\n *  curves, but retains the api of a curve\r\n **************************************************************/\r\n\r\nTHREE.CurvePath = function () {\r\n\r\n\tthis.curves = [];\r\n\tthis.bends = [];\r\n\t\r\n\tthis.autoClose = false; // Automatically closes the path\r\n};\r\n\r\nTHREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );\r\n\r\nTHREE.CurvePath.prototype.add = function ( curve ) {\r\n\r\n\tthis.curves.push( curve );\r\n\r\n};\r\n\r\nTHREE.CurvePath.prototype.checkConnection = function() {\r\n\t// TODO\r\n\t// If the ending of curve is not connected to the starting\r\n\t// or the next curve, then, this is not a real path\r\n};\r\n\r\nTHREE.CurvePath.prototype.closePath = function() {\r\n\t// TODO Test\r\n\t// and verify for vector3 (needs to implement equals)\r\n\t// Add a line curve if start and end of lines are not connected\r\n\tvar startPoint = this.curves[0].getPoint(0);\r\n\tvar endPoint = this.curves[this.curves.length-1].getPoint(1);\r\n\t\r\n\tif (!startPoint.equals(endPoint)) {\r\n\t\tthis.curves.push( new THREE.LineCurve(endPoint, startPoint) );\r\n\t}\r\n\t\r\n};\r\n\r\n// To get accurate point with reference to\r\n// entire path distance at time t,\r\n// following has to be done:\r\n\r\n// 1. Length of each sub path have to be known\r\n// 2. Locate and identify type of curve\r\n// 3. Get t for the curve\r\n// 4. Return curve.getPointAt(t')\r\n\r\nTHREE.CurvePath.prototype.getPoint = function( t ) {\r\n\r\n\tvar d = t * this.getLength();\r\n\tvar curveLengths = this.getCurveLengths();\r\n\tvar i = 0, diff, curve;\r\n\r\n\t// To think about boundaries points.\r\n\r\n\twhile ( i < curveLengths.length ) {\r\n\r\n\t\tif ( curveLengths[ i ] >= d ) {\r\n\r\n\t\t\tdiff = curveLengths[ i ] - d;\r\n\t\t\tcurve = this.curves[ i ];\r\n\r\n\t\t\tvar u = 1 - diff / curve.getLength();\r\n\r\n\t\t\treturn curve.getPointAt( u );\r\n\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\ti ++;\r\n\r\n\t}\r\n\r\n\treturn null;\r\n\r\n\t// loop where sum != 0, sum > d , sum+1 <d\r\n\r\n};\r\n\r\n/*\r\nTHREE.CurvePath.prototype.getTangent = function( t ) {\r\n};*/\r\n\r\n\r\n// We cannot use the default THREE.Curve getPoint() with getLength() because in\r\n// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\r\n// getPoint() depends on getLength\r\n\r\nTHREE.CurvePath.prototype.getLength = function() {\r\n\r\n\tvar lens = this.getCurveLengths();\r\n\treturn lens[ lens.length - 1 ];\r\n\r\n};\r\n\r\n// Compute lengths and cache them\r\n// We cannot overwrite getLengths() because UtoT mapping uses it.\r\n\r\nTHREE.CurvePath.prototype.getCurveLengths = function() {\r\n\r\n\t// We use cache values if curves and cache array are same length\r\n\r\n\tif ( this.cacheLengths && this.cacheLengths.length == this.curves.length ) {\r\n\r\n\t\treturn this.cacheLengths;\r\n\r\n\t};\r\n\r\n\t// Get length of subsurve\r\n\t// Push sums into cached array\r\n\r\n\tvar lengths = [], sums = 0;\r\n\tvar i, il = this.curves.length;\r\n\r\n\tfor ( i = 0; i < il; i ++ ) {\r\n\r\n\t\tsums += this.curves[ i ].getLength();\r\n\t\tlengths.push( sums );\r\n\r\n\t}\r\n\r\n\tthis.cacheLengths = lengths;\r\n\r\n\treturn lengths;\r\n\r\n};\r\n\r\n\r\n\r\n// Returns min and max coordinates, as well as centroid\r\n\r\nTHREE.CurvePath.prototype.getBoundingBox = function () {\r\n\r\n\tvar points = this.getPoints();\r\n\r\n\tvar maxX, maxY, maxZ;\r\n\tvar minX, minY, minZ;\r\n\r\n\tmaxX = maxY = Number.NEGATIVE_INFINITY;\r\n\tminX = minY = Number.POSITIVE_INFINITY;\r\n\r\n\tvar p, i, il, sum;\r\n\r\n\tvar v3 = points[0] instanceof THREE.Vector3;\r\n\r\n\tsum = v3 ? new THREE.Vector3() : new THREE.Vector2();\r\n\r\n\tfor ( i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n\t\tp = points[ i ];\r\n\r\n\t\tif ( p.x > maxX ) maxX = p.x;\r\n\t\telse if ( p.x < minX ) minX = p.x;\r\n\r\n\t\tif ( p.y > maxY ) maxY = p.y;\r\n\t\telse if ( p.y < minY ) minY = p.y;\r\n\r\n\t\tif ( v3 ) {\r\n\r\n\t\t\tif ( p.z > maxZ ) maxZ = p.z;\r\n\t\t\telse if ( p.z < minZ ) minZ = p.z;\r\n\r\n\t\t}\r\n\r\n\t\tsum.add( p );\r\n\r\n\t}\r\n\r\n\tvar ret = {\r\n\r\n\t\tminX: minX,\r\n\t\tminY: minY,\r\n\t\tmaxX: maxX,\r\n\t\tmaxY: maxY,\r\n\t\tcentroid: sum.divideScalar( il )\r\n\r\n\t};\r\n\r\n\tif ( v3 ) {\r\n\r\n\t\tret.maxZ = maxZ;\r\n\t\tret.minZ = minZ;\r\n\r\n\t}\r\n\r\n\treturn ret;\r\n\r\n};\r\n\r\n/**************************************************************\r\n *\tCreate Geometries Helpers\r\n **************************************************************/\r\n\r\n/// Generate geometry from path points (for Line or ParticleSystem objects)\r\n\r\nTHREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {\r\n\r\n\tvar pts = this.getPoints( divisions, true );\r\n\treturn this.createGeometry( pts );\r\n\r\n};\r\n\r\n// Generate geometry from equidistance sampling along the path\r\n\r\nTHREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {\r\n\r\n\tvar pts = this.getSpacedPoints( divisions, true );\r\n\treturn this.createGeometry( pts );\r\n\r\n};\r\n\r\nTHREE.CurvePath.prototype.createGeometry = function( points ) {\r\n\r\n\tvar geometry = new THREE.Geometry();\r\n\r\n\tfor ( var i = 0; i < points.length; i ++ ) {\r\n\r\n\t\tgeometry.vertices.push( new THREE.Vector3( points[ i ].x, points[ i ].y, points[ i ].z || 0) );\r\n\r\n\t}\r\n\r\n\treturn geometry;\r\n\r\n};\r\n\r\n\r\n/**************************************************************\r\n *\tBend / Wrap Helper Methods\r\n **************************************************************/\r\n\r\n// Wrap path / Bend modifiers?\r\n\r\nTHREE.CurvePath.prototype.addWrapPath = function ( bendpath ) {\r\n\r\n\tthis.bends.push( bendpath );\r\n\r\n};\r\n\r\nTHREE.CurvePath.prototype.getTransformedPoints = function( segments, bends ) {\r\n\r\n\tvar oldPts = this.getPoints( segments ); // getPoints getSpacedPoints\r\n\tvar i, il;\r\n\r\n\tif ( !bends ) {\r\n\r\n\t\tbends = this.bends;\r\n\r\n\t}\r\n\r\n\tfor ( i = 0, il = bends.length; i < il; i ++ ) {\r\n\r\n\t\toldPts = this.getWrapPoints( oldPts, bends[ i ] );\r\n\r\n\t}\r\n\r\n\treturn oldPts;\r\n\r\n};\r\n\r\nTHREE.CurvePath.prototype.getTransformedSpacedPoints = function( segments, bends ) {\r\n\r\n\tvar oldPts = this.getSpacedPoints( segments );\r\n\r\n\tvar i, il;\r\n\r\n\tif ( !bends ) {\r\n\r\n\t\tbends = this.bends;\r\n\r\n\t}\r\n\r\n\tfor ( i = 0, il = bends.length; i < il; i ++ ) {\r\n\r\n\t\toldPts = this.getWrapPoints( oldPts, bends[ i ] );\r\n\r\n\t}\r\n\r\n\treturn oldPts;\r\n\r\n};\r\n\r\n// This returns getPoints() bend/wrapped around the contour of a path.\r\n// Read http://www.planetclegg.com/projects/WarpingTextToSplines.html\r\n\r\nTHREE.CurvePath.prototype.getWrapPoints = function ( oldPts, path ) {\r\n\r\n\tvar bounds = this.getBoundingBox();\r\n\r\n\tvar i, il, p, oldX, oldY, xNorm;\r\n\r\n\tfor ( i = 0, il = oldPts.length; i < il; i ++ ) {\r\n\r\n\t\tp = oldPts[ i ];\r\n\r\n\t\toldX = p.x;\r\n\t\toldY = p.y;\r\n\r\n\t\txNorm = oldX / bounds.maxX;\r\n\r\n\t\t// If using actual distance, for length > path, requires line extrusions\r\n\t\t//xNorm = path.getUtoTmapping(xNorm, oldX); // 3 styles. 1) wrap stretched. 2) wrap stretch by arc length 3) warp by actual distance\r\n\r\n\t\txNorm = path.getUtoTmapping( xNorm, oldX );\r\n\r\n\t\t// check for out of bounds?\r\n\r\n\t\tvar pathPt = path.getPoint( xNorm );\r\n\t\tvar normal = path.getNormalVector( xNorm ).multiplyScalar( oldY );\r\n\r\n\t\tp.x = pathPt.x + normal.x;\r\n\t\tp.y = pathPt.y + normal.y;\r\n\r\n\t}\r\n\r\n\treturn oldPts;\r\n\r\n};\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Gyroscope = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n};\r\n\r\nTHREE.Gyroscope.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.Gyroscope.prototype.updateMatrixWorld = function ( force ) {\r\n\r\n\tthis.matrixAutoUpdate && this.updateMatrix();\r\n\r\n\t// update matrixWorld\r\n\r\n\tif ( this.matrixWorldNeedsUpdate || force ) {\r\n\r\n\t\tif ( this.parent ) {\r\n\r\n\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\r\n\r\n\t\t\tthis.matrixWorld.decompose( this.translationWorld, this.rotationWorld, this.scaleWorld );\r\n\t\t\tthis.matrix.decompose( this.translationObject, this.rotationObject, this.scaleObject );\r\n\r\n\t\t\tthis.matrixWorld.compose( this.translationWorld, this.rotationObject, this.scaleWorld );\r\n\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.matrixWorld.copy( this.matrix );\r\n\r\n\t\t}\r\n\r\n\r\n\t\tthis.matrixWorldNeedsUpdate = false;\r\n\r\n\t\tforce = true;\r\n\r\n\t}\r\n\r\n\t// update children\r\n\r\n\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n\t\tthis.children[ i ].updateMatrixWorld( force );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Gyroscope.prototype.translationWorld = new THREE.Vector3();\r\nTHREE.Gyroscope.prototype.translationObject = new THREE.Vector3();\r\nTHREE.Gyroscope.prototype.rotationWorld = new THREE.Quaternion();\r\nTHREE.Gyroscope.prototype.rotationObject = new THREE.Quaternion();\r\nTHREE.Gyroscope.prototype.scaleWorld = new THREE.Vector3();\r\nTHREE.Gyroscope.prototype.scaleObject = new THREE.Vector3();\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Creates free form 2d path using series of points, lines or curves.\r\n *\r\n **/\r\n\r\nTHREE.Path = function ( points ) {\r\n\r\n\tTHREE.CurvePath.call(this);\r\n\r\n\tthis.actions = [];\r\n\r\n\tif ( points ) {\r\n\r\n\t\tthis.fromPoints( points );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Path.prototype = Object.create( THREE.CurvePath.prototype );\r\n\r\nTHREE.PathActions = {\r\n\r\n\tMOVE_TO: 'moveTo',\r\n\tLINE_TO: 'lineTo',\r\n\tQUADRATIC_CURVE_TO: 'quadraticCurveTo', // Bezier quadratic curve\r\n\tBEZIER_CURVE_TO: 'bezierCurveTo', \t\t// Bezier cubic curve\r\n\tCSPLINE_THRU: 'splineThru',\t\t\t\t// Catmull-rom spline\r\n\tARC: 'arc',\t\t\t\t\t\t\t\t// Circle\r\n\tELLIPSE: 'ellipse'\r\n};\r\n\r\n// TODO Clean up PATH API\r\n\r\n// Create path using straight lines to connect all points\r\n// - vectors: array of Vector2\r\n\r\nTHREE.Path.prototype.fromPoints = function ( vectors ) {\r\n\r\n\tthis.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );\r\n\r\n\tfor ( var v = 1, vlen = vectors.length; v < vlen; v ++ ) {\r\n\r\n\t\tthis.lineTo( vectors[ v ].x, vectors[ v ].y );\r\n\r\n\t};\r\n\r\n};\r\n\r\n// startPath() endPath()?\r\n\r\nTHREE.Path.prototype.moveTo = function ( x, y ) {\r\n\r\n\tvar args = Array.prototype.slice.call( arguments );\r\n\tthis.actions.push( { action: THREE.PathActions.MOVE_TO, args: args } );\r\n\r\n};\r\n\r\nTHREE.Path.prototype.lineTo = function ( x, y ) {\r\n\r\n\tvar args = Array.prototype.slice.call( arguments );\r\n\r\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n\tvar curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );\r\n\tthis.curves.push( curve );\r\n\r\n\tthis.actions.push( { action: THREE.PathActions.LINE_TO, args: args } );\r\n\r\n};\r\n\r\nTHREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {\r\n\r\n\tvar args = Array.prototype.slice.call( arguments );\r\n\r\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n\tvar curve = new THREE.QuadraticBezierCurve( new THREE.Vector2( x0, y0 ),\r\n\t\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aCPx, aCPy ),\r\n\t\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aX, aY ) );\r\n\tthis.curves.push( curve );\r\n\r\n\tthis.actions.push( { action: THREE.PathActions.QUADRATIC_CURVE_TO, args: args } );\r\n\r\n};\r\n\r\nTHREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y,\r\n                                               aCP2x, aCP2y,\r\n                                               aX, aY ) {\r\n\r\n\tvar args = Array.prototype.slice.call( arguments );\r\n\r\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n\tvar curve = new THREE.CubicBezierCurve( new THREE.Vector2( x0, y0 ),\r\n\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aCP1x, aCP1y ),\r\n\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aCP2x, aCP2y ),\r\n\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aX, aY ) );\r\n\tthis.curves.push( curve );\r\n\r\n\tthis.actions.push( { action: THREE.PathActions.BEZIER_CURVE_TO, args: args } );\r\n\r\n};\r\n\r\nTHREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {\r\n\r\n\tvar args = Array.prototype.slice.call( arguments );\r\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n//---\r\n\tvar npts = [ new THREE.Vector2( x0, y0 ) ];\r\n\tArray.prototype.push.apply( npts, pts );\r\n\r\n\tvar curve = new THREE.SplineCurve( npts );\r\n\tthis.curves.push( curve );\r\n\r\n\tthis.actions.push( { action: THREE.PathActions.CSPLINE_THRU, args: args } );\r\n\r\n};\r\n\r\n// FUTURE: Change the API or follow canvas API?\r\n\r\nTHREE.Path.prototype.arc = function ( aX, aY, aRadius,\r\n\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n\tvar lastargs = this.actions[ this.actions.length - 1].args;\r\n\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n\tthis.absarc(aX + x0, aY + y0, aRadius,\r\n\t\taStartAngle, aEndAngle, aClockwise );\r\n\t\r\n };\r\n\r\n THREE.Path.prototype.absarc = function ( aX, aY, aRadius,\r\n\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\r\n\tthis.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);\r\n };\r\n \r\nTHREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius,\r\n\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n\tvar lastargs = this.actions[ this.actions.length - 1].args;\r\n\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n\tthis.absellipse(aX + x0, aY + y0, xRadius, yRadius,\r\n\t\taStartAngle, aEndAngle, aClockwise );\r\n\r\n };\r\n \r\n\r\nTHREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius,\r\n\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n\tvar args = Array.prototype.slice.call( arguments );\r\n\tvar curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius,\r\n\t\t\t\t\t\t\t\t\taStartAngle, aEndAngle, aClockwise );\r\n\tthis.curves.push( curve );\r\n\r\n\tvar lastPoint = curve.getPoint(aClockwise ? 1 : 0);\r\n\targs.push(lastPoint.x);\r\n\targs.push(lastPoint.y);\r\n\r\n\tthis.actions.push( { action: THREE.PathActions.ELLIPSE, args: args } );\r\n\r\n };\r\n\r\nTHREE.Path.prototype.getSpacedPoints = function ( divisions, closedPath ) {\r\n\r\n\tif ( ! divisions ) divisions = 40;\r\n\r\n\tvar points = [];\r\n\r\n\tfor ( var i = 0; i < divisions; i ++ ) {\r\n\r\n\t\tpoints.push( this.getPoint( i / divisions ) );\r\n\r\n\t\t//if( !this.getPoint( i / divisions ) ) throw \"DIE\";\r\n\r\n\t}\r\n\r\n\t// if ( closedPath ) {\r\n\t//\r\n\t// \tpoints.push( points[ 0 ] );\r\n\t//\r\n\t// }\r\n\r\n\treturn points;\r\n\r\n};\r\n\r\n/* Return an array of vectors based on contour of the path */\r\n\r\nTHREE.Path.prototype.getPoints = function( divisions, closedPath ) {\r\n\r\n\tif (this.useSpacedPoints) {\r\n\t\tconsole.log('tata');\r\n\t\treturn this.getSpacedPoints( divisions, closedPath );\r\n\t}\r\n\r\n\tdivisions = divisions || 12;\r\n\r\n\tvar points = [];\r\n\r\n\tvar i, il, item, action, args;\r\n\tvar cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,\r\n\t\tlaste, j,\r\n\t\tt, tx, ty;\r\n\r\n\tfor ( i = 0, il = this.actions.length; i < il; i ++ ) {\r\n\r\n\t\titem = this.actions[ i ];\r\n\r\n\t\taction = item.action;\r\n\t\targs = item.args;\r\n\r\n\t\tswitch( action ) {\r\n\r\n\t\tcase THREE.PathActions.MOVE_TO:\r\n\r\n\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase THREE.PathActions.LINE_TO:\r\n\r\n\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase THREE.PathActions.QUADRATIC_CURVE_TO:\r\n\r\n\t\t\tcpx  = args[ 2 ];\r\n\t\t\tcpy  = args[ 3 ];\r\n\r\n\t\t\tcpx1 = args[ 0 ];\r\n\t\t\tcpy1 = args[ 1 ];\r\n\r\n\t\t\tif ( points.length > 0 ) {\r\n\r\n\t\t\t\tlaste = points[ points.length - 1 ];\r\n\r\n\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\tcpy0 = laste.y;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tlaste = this.actions[ i - 1 ].args;\r\n\r\n\t\t\t\tcpx0 = laste[ laste.length - 2 ];\r\n\t\t\t\tcpy0 = laste[ laste.length - 1 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( j = 1; j <= divisions; j ++ ) {\r\n\r\n\t\t\t\tt = j / divisions;\r\n\r\n\t\t\t\ttx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );\r\n\t\t\t\tty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );\r\n\r\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\r\n\t\t  \t}\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase THREE.PathActions.BEZIER_CURVE_TO:\r\n\r\n\t\t\tcpx  = args[ 4 ];\r\n\t\t\tcpy  = args[ 5 ];\r\n\r\n\t\t\tcpx1 = args[ 0 ];\r\n\t\t\tcpy1 = args[ 1 ];\r\n\r\n\t\t\tcpx2 = args[ 2 ];\r\n\t\t\tcpy2 = args[ 3 ];\r\n\r\n\t\t\tif ( points.length > 0 ) {\r\n\r\n\t\t\t\tlaste = points[ points.length - 1 ];\r\n\r\n\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\tcpy0 = laste.y;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tlaste = this.actions[ i - 1 ].args;\r\n\r\n\t\t\t\tcpx0 = laste[ laste.length - 2 ];\r\n\t\t\t\tcpy0 = laste[ laste.length - 1 ];\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tfor ( j = 1; j <= divisions; j ++ ) {\r\n\r\n\t\t\t\tt = j / divisions;\r\n\r\n\t\t\t\ttx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );\r\n\t\t\t\tty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );\r\n\r\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase THREE.PathActions.CSPLINE_THRU:\r\n\r\n\t\t\tlaste = this.actions[ i - 1 ].args;\r\n\r\n\t\t\tvar last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );\r\n\t\t\tvar spts = [ last ];\r\n\r\n\t\t\tvar n = divisions * args[ 0 ].length;\r\n\r\n\t\t\tspts = spts.concat( args[ 0 ] );\r\n\r\n\t\t\tvar spline = new THREE.SplineCurve( spts );\r\n\r\n\t\t\tfor ( j = 1; j <= n; j ++ ) {\r\n\r\n\t\t\t\tpoints.push( spline.getPointAt( j / n ) ) ;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase THREE.PathActions.ARC:\r\n\r\n\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\r\n\t\t\t\taRadius = args[ 2 ],\r\n\t\t\t\taStartAngle = args[ 3 ], aEndAngle = args[ 4 ],\r\n\t\t\t\taClockwise = !!args[ 5 ];\r\n\r\n\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\r\n\t\t\tvar angle;\r\n\t\t\tvar tdivisions = divisions * 2;\r\n\r\n\t\t\tfor ( j = 1; j <= tdivisions; j ++ ) {\r\n\r\n\t\t\t\tt = j / tdivisions;\r\n\r\n\t\t\t\tif ( ! aClockwise ) {\r\n\r\n\t\t\t\t\tt = 1 - t;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tangle = aStartAngle + t * deltaAngle;\r\n\r\n\t\t\t\ttx = aX + aRadius * Math.cos( angle );\r\n\t\t\t\tty = aY + aRadius * Math.sin( angle );\r\n\r\n\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\r\n\r\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t//console.log(points);\r\n\r\n\t\t  break;\r\n\t\t  \r\n\t\tcase THREE.PathActions.ELLIPSE:\r\n\r\n\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\r\n\t\t\t\txRadius = args[ 2 ],\r\n\t\t\t\tyRadius = args[ 3 ],\r\n\t\t\t\taStartAngle = args[ 4 ], aEndAngle = args[ 5 ],\r\n\t\t\t\taClockwise = !!args[ 6 ];\r\n\r\n\r\n\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\r\n\t\t\tvar angle;\r\n\t\t\tvar tdivisions = divisions * 2;\r\n\r\n\t\t\tfor ( j = 1; j <= tdivisions; j ++ ) {\r\n\r\n\t\t\t\tt = j / tdivisions;\r\n\r\n\t\t\t\tif ( ! aClockwise ) {\r\n\r\n\t\t\t\t\tt = 1 - t;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tangle = aStartAngle + t * deltaAngle;\r\n\r\n\t\t\t\ttx = aX + xRadius * Math.cos( angle );\r\n\t\t\t\tty = aY + yRadius * Math.sin( angle );\r\n\r\n\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\r\n\r\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t//console.log(points);\r\n\r\n\t\t  break;\r\n\r\n\t\t} // end switch\r\n\r\n\t}\r\n\r\n\r\n\r\n\t// Normalize to remove the closing point by default.\r\n\tvar lastPoint = points[ points.length - 1];\r\n\tvar EPSILON = 0.0000000001;\r\n\tif ( Math.abs(lastPoint.x - points[ 0 ].x) < EPSILON &&\r\n             Math.abs(lastPoint.y - points[ 0 ].y) < EPSILON)\r\n\t\tpoints.splice( points.length - 1, 1);\r\n\tif ( closedPath ) {\r\n\r\n\t\tpoints.push( points[ 0 ] );\r\n\r\n\t}\r\n\r\n\treturn points;\r\n\r\n};\r\n\r\n// Breaks path into shapes\r\n\r\nTHREE.Path.prototype.toShapes = function() {\r\n\r\n\tvar i, il, item, action, args;\r\n\r\n\tvar subPaths = [], lastPath = new THREE.Path();\r\n\r\n\tfor ( i = 0, il = this.actions.length; i < il; i ++ ) {\r\n\r\n\t\titem = this.actions[ i ];\r\n\r\n\t\targs = item.args;\r\n\t\taction = item.action;\r\n\r\n\t\tif ( action == THREE.PathActions.MOVE_TO ) {\r\n\r\n\t\t\tif ( lastPath.actions.length != 0 ) {\r\n\r\n\t\t\t\tsubPaths.push( lastPath );\r\n\t\t\t\tlastPath = new THREE.Path();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tlastPath[ action ].apply( lastPath, args );\r\n\r\n\t}\r\n\r\n\tif ( lastPath.actions.length != 0 ) {\r\n\r\n\t\tsubPaths.push( lastPath );\r\n\r\n\t}\r\n\r\n\t// console.log(subPaths);\r\n\r\n\tif ( subPaths.length == 0 ) return [];\r\n\r\n\tvar tmpPath, tmpShape, shapes = [];\r\n\r\n\tvar holesFirst = !THREE.Shape.Utils.isClockWise( subPaths[ 0 ].getPoints() );\r\n\t// console.log(\"Holes first\", holesFirst);\r\n\r\n\tif ( subPaths.length == 1) {\r\n\t\ttmpPath = subPaths[0];\r\n\t\ttmpShape = new THREE.Shape();\r\n\t\ttmpShape.actions = tmpPath.actions;\r\n\t\ttmpShape.curves = tmpPath.curves;\r\n\t\tshapes.push( tmpShape );\r\n\t\treturn shapes;\r\n\t};\r\n\r\n\tif ( holesFirst ) {\r\n\r\n\t\ttmpShape = new THREE.Shape();\r\n\r\n\t\tfor ( i = 0, il = subPaths.length; i < il; i ++ ) {\r\n\r\n\t\t\ttmpPath = subPaths[ i ];\r\n\r\n\t\t\tif ( THREE.Shape.Utils.isClockWise( tmpPath.getPoints() ) ) {\r\n\r\n\t\t\t\ttmpShape.actions = tmpPath.actions;\r\n\t\t\t\ttmpShape.curves = tmpPath.curves;\r\n\r\n\t\t\t\tshapes.push( tmpShape );\r\n\t\t\t\ttmpShape = new THREE.Shape();\r\n\r\n\t\t\t\t//console.log('cw', i);\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ttmpShape.holes.push( tmpPath );\r\n\r\n\t\t\t\t//console.log('ccw', i);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\t// Shapes first\r\n\r\n\t\tfor ( i = 0, il = subPaths.length; i < il; i ++ ) {\r\n\r\n\t\t\ttmpPath = subPaths[ i ];\r\n\r\n\t\t\tif ( THREE.Shape.Utils.isClockWise( tmpPath.getPoints() ) ) {\r\n\r\n\r\n\t\t\t\tif ( tmpShape ) shapes.push( tmpShape );\r\n\r\n\t\t\t\ttmpShape = new THREE.Shape();\r\n\t\t\t\ttmpShape.actions = tmpPath.actions;\r\n\t\t\t\ttmpShape.curves = tmpPath.curves;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ttmpShape.holes.push( tmpPath );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tshapes.push( tmpShape );\r\n\r\n\t}\r\n\r\n\t//console.log(\"shape\", shapes);\r\n\r\n\treturn shapes;\r\n\r\n};\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Defines a 2d shape plane using paths.\r\n **/\r\n\r\n// STEP 1 Create a path.\r\n// STEP 2 Turn path into shape.\r\n// STEP 3 ExtrudeGeometry takes in Shape/Shapes\r\n// STEP 3a - Extract points from each shape, turn to vertices\r\n// STEP 3b - Triangulate each shape, add faces.\r\n\r\nTHREE.Shape = function () {\r\n\r\n\tTHREE.Path.apply( this, arguments );\r\n\tthis.holes = [];\r\n\r\n};\r\n\r\nTHREE.Shape.prototype = Object.create( THREE.Path.prototype );\r\n\r\n// Convenience method to return ExtrudeGeometry\r\n\r\nTHREE.Shape.prototype.extrude = function ( options ) {\r\n\r\n\tvar extruded = new THREE.ExtrudeGeometry( this, options );\r\n\treturn extruded;\r\n\r\n};\r\n\r\n// Convenience method to return ShapeGeometry\r\n\r\nTHREE.Shape.prototype.makeGeometry = function ( options ) {\r\n\r\n\tvar geometry = new THREE.ShapeGeometry( this, options );\r\n\treturn geometry;\r\n\r\n};\r\n\r\n// Get points of holes\r\n\r\nTHREE.Shape.prototype.getPointsHoles = function ( divisions ) {\r\n\r\n\tvar i, il = this.holes.length, holesPts = [];\r\n\r\n\tfor ( i = 0; i < il; i ++ ) {\r\n\r\n\t\tholesPts[ i ] = this.holes[ i ].getTransformedPoints( divisions, this.bends );\r\n\r\n\t}\r\n\r\n\treturn holesPts;\r\n\r\n};\r\n\r\n// Get points of holes (spaced by regular distance)\r\n\r\nTHREE.Shape.prototype.getSpacedPointsHoles = function ( divisions ) {\r\n\r\n\tvar i, il = this.holes.length, holesPts = [];\r\n\r\n\tfor ( i = 0; i < il; i ++ ) {\r\n\r\n\t\tholesPts[ i ] = this.holes[ i ].getTransformedSpacedPoints( divisions, this.bends );\r\n\r\n\t}\r\n\r\n\treturn holesPts;\r\n\r\n};\r\n\r\n\r\n// Get points of shape and holes (keypoints based on segments parameter)\r\n\r\nTHREE.Shape.prototype.extractAllPoints = function ( divisions ) {\r\n\r\n\treturn {\r\n\r\n\t\tshape: this.getTransformedPoints( divisions ),\r\n\t\tholes: this.getPointsHoles( divisions )\r\n\r\n\t};\r\n\r\n};\r\n\r\nTHREE.Shape.prototype.extractPoints = function ( divisions ) {\r\n\r\n\tif (this.useSpacedPoints) {\r\n\t\treturn this.extractAllSpacedPoints(divisions);\r\n\t}\r\n\r\n\treturn this.extractAllPoints(divisions);\r\n\r\n};\r\n\r\n//\r\n// THREE.Shape.prototype.extractAllPointsWithBend = function ( divisions, bend ) {\r\n//\r\n// \treturn {\r\n//\r\n// \t\tshape: this.transform( bend, divisions ),\r\n// \t\tholes: this.getPointsHoles( divisions, bend )\r\n//\r\n// \t};\r\n//\r\n// };\r\n\r\n// Get points of shape and holes (spaced by regular distance)\r\n\r\nTHREE.Shape.prototype.extractAllSpacedPoints = function ( divisions ) {\r\n\r\n\treturn {\r\n\r\n\t\tshape: this.getTransformedSpacedPoints( divisions ),\r\n\t\tholes: this.getSpacedPointsHoles( divisions )\r\n\r\n\t};\r\n\r\n};\r\n\r\n/**************************************************************\r\n *\tUtils\r\n **************************************************************/\r\n\r\nTHREE.Shape.Utils = {\r\n\r\n\t/*\r\n\t\tcontour - array of vector2 for contour\r\n\t\tholes   - array of array of vector2\r\n\t*/\r\n\r\n\tremoveHoles: function ( contour, holes ) {\r\n\r\n\t\tvar shape = contour.concat(); // work on this shape\r\n\t\tvar allpoints = shape.concat();\r\n\r\n\t\t/* For each isolated shape, find the closest points and break to the hole to allow triangulation */\r\n\r\n\r\n\t\tvar prevShapeVert, nextShapeVert,\r\n\t\t\tprevHoleVert, nextHoleVert,\r\n\t\t\tholeIndex, shapeIndex,\r\n\t\t\tshapeId, shapeGroup,\r\n\t\t\th, h2,\r\n\t\t\thole, shortest, d,\r\n\t\t\tp, pts1, pts2,\r\n\t\t\ttmpShape1, tmpShape2,\r\n\t\t\ttmpHole1, tmpHole2,\r\n\t\t\tverts = [];\r\n\r\n\t\tfor ( h = 0; h < holes.length; h ++ ) {\r\n\r\n\t\t\thole = holes[ h ];\r\n\r\n\t\t\t/*\r\n\t\t\tshapeholes[ h ].concat(); // preserves original\r\n\t\t\tholes.push( hole );\r\n\t\t\t*/\r\n\r\n\t\t\tArray.prototype.push.apply( allpoints, hole );\r\n\r\n\t\t\tshortest = Number.POSITIVE_INFINITY;\r\n\r\n\r\n\t\t\t// Find the shortest pair of pts between shape and hole\r\n\r\n\t\t\t// Note: Actually, I'm not sure now if we could optimize this to be faster than O(m*n)\r\n\t\t\t// Using distanceToSquared() intead of distanceTo() should speed a little\r\n\t\t\t// since running square roots operations are reduced.\r\n\r\n\t\t\tfor ( h2 = 0; h2 < hole.length; h2 ++ ) {\r\n\r\n\t\t\t\tpts1 = hole[ h2 ];\r\n\t\t\t\tvar dist = [];\r\n\r\n\t\t\t\tfor ( p = 0; p < shape.length; p++ ) {\r\n\r\n\t\t\t\t\tpts2 = shape[ p ];\r\n\t\t\t\t\td = pts1.distanceToSquared( pts2 );\r\n\t\t\t\t\tdist.push( d );\r\n\r\n\t\t\t\t\tif ( d < shortest ) {\r\n\r\n\t\t\t\t\t\tshortest = d;\r\n\t\t\t\t\t\tholeIndex = h2;\r\n\t\t\t\t\t\tshapeIndex = p;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t//console.log(\"shortest\", shortest, dist);\r\n\r\n\t\t\tprevShapeVert = ( shapeIndex - 1 ) >= 0 ? shapeIndex - 1 : shape.length - 1;\r\n\t\t\tprevHoleVert = ( holeIndex - 1 ) >= 0 ? holeIndex - 1 : hole.length - 1;\r\n\r\n\t\t\tvar areaapts = [\r\n\r\n\t\t\t\thole[ holeIndex ],\r\n\t\t\t\tshape[ shapeIndex ],\r\n\t\t\t\tshape[ prevShapeVert ]\r\n\r\n\t\t\t];\r\n\r\n\t\t\tvar areaa = THREE.FontUtils.Triangulate.area( areaapts );\r\n\r\n\t\t\tvar areabpts = [\r\n\r\n\t\t\t\thole[ holeIndex ],\r\n\t\t\t\thole[ prevHoleVert ],\r\n\t\t\t\tshape[ shapeIndex ]\r\n\r\n\t\t\t];\r\n\r\n\t\t\tvar areab = THREE.FontUtils.Triangulate.area( areabpts );\r\n\r\n\t\t\tvar shapeOffset = 1;\r\n\t\t\tvar holeOffset = -1;\r\n\r\n\t\t\tvar oldShapeIndex = shapeIndex, oldHoleIndex = holeIndex;\r\n\t\t\tshapeIndex += shapeOffset;\r\n\t\t\tholeIndex += holeOffset;\r\n\r\n\t\t\tif ( shapeIndex < 0 ) { shapeIndex += shape.length;  }\r\n\t\t\tshapeIndex %= shape.length;\r\n\r\n\t\t\tif ( holeIndex < 0 ) { holeIndex += hole.length;  }\r\n\t\t\tholeIndex %= hole.length;\r\n\r\n\t\t\tprevShapeVert = ( shapeIndex - 1 ) >= 0 ? shapeIndex - 1 : shape.length - 1;\r\n\t\t\tprevHoleVert = ( holeIndex - 1 ) >= 0 ? holeIndex - 1 : hole.length - 1;\r\n\r\n\t\t\tareaapts = [\r\n\r\n\t\t\t\thole[ holeIndex ],\r\n\t\t\t\tshape[ shapeIndex ],\r\n\t\t\t\tshape[ prevShapeVert ]\r\n\r\n\t\t\t];\r\n\r\n\t\t\tvar areaa2 = THREE.FontUtils.Triangulate.area( areaapts );\r\n\r\n\t\t\tareabpts = [\r\n\r\n\t\t\t\thole[ holeIndex ],\r\n\t\t\t\thole[ prevHoleVert ],\r\n\t\t\t\tshape[ shapeIndex ]\r\n\r\n\t\t\t];\r\n\r\n\t\t\tvar areab2 = THREE.FontUtils.Triangulate.area( areabpts );\r\n\t\t\t//console.log(areaa,areab ,areaa2,areab2, ( areaa + areab ),  ( areaa2 + areab2 ));\r\n\r\n\t\t\tif ( ( areaa + areab ) > ( areaa2 + areab2 ) ) {\r\n\r\n\t\t\t\t// In case areas are not correct.\r\n\t\t\t\t//console.log(\"USE THIS\");\r\n\r\n\t\t\t\tshapeIndex = oldShapeIndex;\r\n\t\t\t\tholeIndex = oldHoleIndex ;\r\n\r\n\t\t\t\tif ( shapeIndex < 0 ) { shapeIndex += shape.length;  }\r\n\t\t\t\tshapeIndex %= shape.length;\r\n\r\n\t\t\t\tif ( holeIndex < 0 ) { holeIndex += hole.length;  }\r\n\t\t\t\tholeIndex %= hole.length;\r\n\r\n\t\t\t\tprevShapeVert = ( shapeIndex - 1 ) >= 0 ? shapeIndex - 1 : shape.length - 1;\r\n\t\t\t\tprevHoleVert = ( holeIndex - 1 ) >= 0 ? holeIndex - 1 : hole.length - 1;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t//console.log(\"USE THAT \")\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttmpShape1 = shape.slice( 0, shapeIndex );\r\n\t\t\ttmpShape2 = shape.slice( shapeIndex );\r\n\t\t\ttmpHole1 = hole.slice( holeIndex );\r\n\t\t\ttmpHole2 = hole.slice( 0, holeIndex );\r\n\r\n\t\t\t// Should check orders here again?\r\n\r\n\t\t\tvar trianglea = [\r\n\r\n\t\t\t\thole[ holeIndex ],\r\n\t\t\t\tshape[ shapeIndex ],\r\n\t\t\t\tshape[ prevShapeVert ]\r\n\r\n\t\t\t];\r\n\r\n\t\t\tvar triangleb = [\r\n\r\n\t\t\t\thole[ holeIndex ] ,\r\n\t\t\t\thole[ prevHoleVert ],\r\n\t\t\t\tshape[ shapeIndex ]\r\n\r\n\t\t\t];\r\n\r\n\t\t\tverts.push( trianglea );\r\n\t\t\tverts.push( triangleb );\r\n\r\n\t\t\tshape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );\r\n\r\n\t\t}\r\n\r\n\t\treturn {\r\n\r\n\t\t\tshape:shape, \t\t/* shape with no holes */\r\n\t\t\tisolatedPts: verts, /* isolated faces */\r\n\t\t\tallpoints: allpoints\r\n\r\n\t\t}\r\n\r\n\r\n\t},\r\n\r\n\ttriangulateShape: function ( contour, holes ) {\r\n\r\n\t\tvar shapeWithoutHoles = THREE.Shape.Utils.removeHoles( contour, holes );\r\n\r\n\t\tvar shape = shapeWithoutHoles.shape,\r\n\t\t\tallpoints = shapeWithoutHoles.allpoints,\r\n\t\t\tisolatedPts = shapeWithoutHoles.isolatedPts;\r\n\r\n\t\tvar triangles = THREE.FontUtils.Triangulate( shape, false ); // True returns indices for points of spooled shape\r\n\r\n\t\t// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.\r\n\r\n\t\t//console.log( \"triangles\",triangles, triangles.length );\r\n\t\t//console.log( \"allpoints\",allpoints, allpoints.length );\r\n\r\n\t\tvar i, il, f, face,\r\n\t\t\tkey, index,\r\n\t\t\tallPointsMap = {},\r\n\t\t\tisolatedPointsMap = {};\r\n\r\n\t\t// prepare all points map\r\n\r\n\t\tfor ( i = 0, il = allpoints.length; i < il; i ++ ) {\r\n\r\n\t\t\tkey = allpoints[ i ].x + \":\" + allpoints[ i ].y;\r\n\r\n\t\t\tif ( allPointsMap[ key ] !== undefined ) {\r\n\r\n\t\t\t\tconsole.log( \"Duplicate point\", key );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tallPointsMap[ key ] = i;\r\n\r\n\t\t}\r\n\r\n\t\t// check all face vertices against all points map\r\n\r\n\t\tfor ( i = 0, il = triangles.length; i < il; i ++ ) {\r\n\r\n\t\t\tface = triangles[ i ];\r\n\r\n\t\t\tfor ( f = 0; f < 3; f ++ ) {\r\n\r\n\t\t\t\tkey = face[ f ].x + \":\" + face[ f ].y;\r\n\r\n\t\t\t\tindex = allPointsMap[ key ];\r\n\r\n\t\t\t\tif ( index !== undefined ) {\r\n\r\n\t\t\t\t\tface[ f ] = index;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// check isolated points vertices against all points map\r\n\r\n\t\tfor ( i = 0, il = isolatedPts.length; i < il; i ++ ) {\r\n\r\n\t\t\tface = isolatedPts[ i ];\r\n\r\n\t\t\tfor ( f = 0; f < 3; f ++ ) {\r\n\r\n\t\t\t\tkey = face[ f ].x + \":\" + face[ f ].y;\r\n\r\n\t\t\t\tindex = allPointsMap[ key ];\r\n\r\n\t\t\t\tif ( index !== undefined ) {\r\n\r\n\t\t\t\t\tface[ f ] = index;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn triangles.concat( isolatedPts );\r\n\r\n\t}, // end triangulate shapes\r\n\r\n\t/*\r\n\ttriangulate2 : function( pts, holes ) {\r\n\r\n\t\t// For use with Poly2Tri.js\r\n\r\n\t\tvar allpts = pts.concat();\r\n\t\tvar shape = [];\r\n\t\tfor (var p in pts) {\r\n\t\t\tshape.push(new js.poly2tri.Point(pts[p].x, pts[p].y));\r\n\t\t}\r\n\r\n\t\tvar swctx = new js.poly2tri.SweepContext(shape);\r\n\r\n\t\tfor (var h in holes) {\r\n\t\t\tvar aHole = holes[h];\r\n\t\t\tvar newHole = []\r\n\t\t\tfor (i in aHole) {\r\n\t\t\t\tnewHole.push(new js.poly2tri.Point(aHole[i].x, aHole[i].y));\r\n\t\t\t\tallpts.push(aHole[i]);\r\n\t\t\t}\r\n\t\t\tswctx.AddHole(newHole);\r\n\t\t}\r\n\r\n\t\tvar find;\r\n\t\tvar findIndexForPt = function (pt) {\r\n\t\t\tfind = new THREE.Vector2(pt.x, pt.y);\r\n\t\t\tvar p;\r\n\t\t\tfor (p=0, pl = allpts.length; p<pl; p++) {\r\n\t\t\t\tif (allpts[p].equals(find)) return p;\r\n\t\t\t}\r\n\t\t\treturn -1;\r\n\t\t};\r\n\r\n\t\t// triangulate\r\n\t\tjs.poly2tri.sweep.Triangulate(swctx);\r\n\r\n\t\tvar triangles =  swctx.GetTriangles();\r\n\t\tvar tr ;\r\n\t\tvar facesPts = [];\r\n\t\tfor (var t in triangles) {\r\n\t\t\ttr =  triangles[t];\r\n\t\t\tfacesPts.push([\r\n\t\t\t\tfindIndexForPt(tr.GetPoint(0)),\r\n\t\t\t\tfindIndexForPt(tr.GetPoint(1)),\r\n\t\t\t\tfindIndexForPt(tr.GetPoint(2))\r\n\t\t\t\t\t]);\r\n\t\t}\r\n\r\n\r\n\t//\tconsole.log(facesPts);\r\n\t//\tconsole.log(\"triangles\", triangles.length, triangles);\r\n\r\n\t\t// Returns array of faces with 3 element each\r\n\treturn facesPts;\r\n\t},\r\n*/\r\n\r\n\tisClockWise: function ( pts ) {\r\n\r\n\t\treturn THREE.FontUtils.Triangulate.area( pts ) < 0;\r\n\r\n\t},\r\n\r\n\t// Bezier Curves formulas obtained from\r\n\t// http://en.wikipedia.org/wiki/B%C3%A9zier_curve\r\n\r\n\t// Quad Bezier Functions\r\n\r\n\tb2p0: function ( t, p ) {\r\n\r\n\t\tvar k = 1 - t;\r\n\t\treturn k * k * p;\r\n\r\n\t},\r\n\r\n\tb2p1: function ( t, p ) {\r\n\r\n\t\treturn 2 * ( 1 - t ) * t * p;\r\n\r\n\t},\r\n\r\n\tb2p2: function ( t, p ) {\r\n\r\n\t\treturn t * t * p;\r\n\r\n\t},\r\n\r\n\tb2: function ( t, p0, p1, p2 ) {\r\n\r\n\t\treturn this.b2p0( t, p0 ) + this.b2p1( t, p1 ) + this.b2p2( t, p2 );\r\n\r\n\t},\r\n\r\n\t// Cubic Bezier Functions\r\n\r\n\tb3p0: function ( t, p ) {\r\n\r\n\t\tvar k = 1 - t;\r\n\t\treturn k * k * k * p;\r\n\r\n\t},\r\n\r\n\tb3p1: function ( t, p ) {\r\n\r\n\t\tvar k = 1 - t;\r\n\t\treturn 3 * k * k * t * p;\r\n\r\n\t},\r\n\r\n\tb3p2: function ( t, p ) {\r\n\r\n\t\tvar k = 1 - t;\r\n\t\treturn 3 * k * t * t * p;\r\n\r\n\t},\r\n\r\n\tb3p3: function ( t, p ) {\r\n\r\n\t\treturn t * t * t * p;\r\n\r\n\t},\r\n\r\n\tb3: function ( t, p0, p1, p2, p3 ) {\r\n\r\n\t\treturn this.b3p0( t, p0 ) + this.b3p1( t, p1 ) + this.b3p2( t, p2 ) +  this.b3p3( t, p3 );\r\n\r\n\t}\r\n\r\n};\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n */\r\n\r\nTHREE.AnimationHandler = (function() {\r\n\r\n\tvar playing = [];\r\n\tvar library = {};\r\n\tvar that    = {};\r\n\r\n\r\n\t//--- update ---\r\n\r\n\tthat.update = function( deltaTimeMS ) {\r\n\r\n\t\tfor( var i = 0; i < playing.length; i ++ )\r\n\t\t\tplaying[ i ].update( deltaTimeMS );\r\n\r\n\t};\r\n\r\n\r\n\t//--- add ---\r\n\r\n\tthat.addToUpdate = function( animation ) {\r\n\r\n\t\tif ( playing.indexOf( animation ) === -1 )\r\n\t\t\tplaying.push( animation );\r\n\r\n\t};\r\n\r\n\r\n\t//--- remove ---\r\n\r\n\tthat.removeFromUpdate = function( animation ) {\r\n\r\n\t\tvar index = playing.indexOf( animation );\r\n\r\n\t\tif( index !== -1 )\r\n\t\t\tplaying.splice( index, 1 );\r\n\r\n\t};\r\n\r\n\r\n\t//--- add ---\r\n\r\n\tthat.add = function( data ) {\r\n\r\n\t\tif ( library[ data.name ] !== undefined )\r\n\t\t\tconsole.log( \"THREE.AnimationHandler.add: Warning! \" + data.name + \" already exists in library. Overwriting.\" );\r\n\r\n\t\tlibrary[ data.name ] = data;\r\n\t\tinitData( data );\r\n\r\n\t};\r\n\r\n\r\n\t//--- get ---\r\n\r\n\tthat.get = function( name ) {\r\n\r\n\t\tif ( typeof name === \"string\" ) {\r\n\r\n\t\t\tif ( library[ name ] ) {\r\n\r\n\t\t\t\treturn library[ name ];\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.log( \"THREE.AnimationHandler.get: Couldn't find animation \" + name );\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// todo: add simple tween library\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t//--- parse ---\r\n\r\n\tthat.parse = function( root ) {\r\n\r\n\t\t// setup hierarchy\r\n\r\n\t\tvar hierarchy = [];\r\n\r\n\t\tif ( root instanceof THREE.SkinnedMesh ) {\r\n\r\n\t\t\tfor( var b = 0; b < root.bones.length; b++ ) {\r\n\r\n\t\t\t\thierarchy.push( root.bones[ b ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tparseRecurseHierarchy( root, hierarchy );\r\n\r\n\t\t}\r\n\r\n\t\treturn hierarchy;\r\n\r\n\t};\r\n\r\n\tvar parseRecurseHierarchy = function( root, hierarchy ) {\r\n\r\n\t\thierarchy.push( root );\r\n\r\n\t\tfor( var c = 0; c < root.children.length; c++ )\r\n\t\t\tparseRecurseHierarchy( root.children[ c ], hierarchy );\r\n\r\n\t}\r\n\r\n\r\n\t//--- init data ---\r\n\r\n\tvar initData = function( data ) {\r\n\r\n\t\tif( data.initialized === true )\r\n\t\t\treturn;\r\n\r\n\r\n\t\t// loop through all keys\r\n\r\n\t\tfor( var h = 0; h < data.hierarchy.length; h ++ ) {\r\n\r\n\t\t\tfor( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\r\n\t\t\t\t// remove minus times\r\n\r\n\t\t\t\tif( data.hierarchy[ h ].keys[ k ].time < 0 )\r\n\t\t\t\t\tdata.hierarchy[ h ].keys[ k ].time = 0;\r\n\r\n\r\n\t\t\t\t// create quaternions\r\n\r\n\t\t\t\tif( data.hierarchy[ h ].keys[ k ].rot !== undefined &&\r\n\t\t\t\t !( data.hierarchy[ h ].keys[ k ].rot instanceof THREE.Quaternion ) ) {\r\n\r\n\t\t\t\t\tvar quat = data.hierarchy[ h ].keys[ k ].rot;\r\n\t\t\t\t\tdata.hierarchy[ h ].keys[ k ].rot = new THREE.Quaternion( quat[0], quat[1], quat[2], quat[3] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\t// prepare morph target keys\r\n\r\n\t\t\tif( data.hierarchy[ h ].keys.length && data.hierarchy[ h ].keys[ 0 ].morphTargets !== undefined ) {\r\n\r\n\t\t\t\t// get all used\r\n\r\n\t\t\t\tvar usedMorphTargets = {};\r\n\r\n\t\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\r\n\t\t\t\t\tfor ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {\r\n\r\n\t\t\t\t\t\tvar morphTargetName = data.hierarchy[ h ].keys[ k ].morphTargets[ m ];\r\n\t\t\t\t\t\tusedMorphTargets[ morphTargetName ] = -1;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdata.hierarchy[ h ].usedMorphTargets = usedMorphTargets;\r\n\r\n\r\n\t\t\t\t// set all used on all frames\r\n\r\n\t\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\r\n\t\t\t\t\tvar influences = {};\r\n\r\n\t\t\t\t\tfor ( var morphTargetName in usedMorphTargets ) {\r\n\r\n\t\t\t\t\t\tfor ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {\r\n\r\n\t\t\t\t\t\t\tif ( data.hierarchy[ h ].keys[ k ].morphTargets[ m ] === morphTargetName ) {\r\n\r\n\t\t\t\t\t\t\t\tinfluences[ morphTargetName ] = data.hierarchy[ h ].keys[ k ].morphTargetsInfluences[ m ];\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( m === data.hierarchy[ h ].keys[ k ].morphTargets.length ) {\r\n\r\n\t\t\t\t\t\t\tinfluences[ morphTargetName ] = 0;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tdata.hierarchy[ h ].keys[ k ].morphTargetsInfluences = influences;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\t// remove all keys that are on the same time\r\n\r\n\t\t\tfor ( var k = 1; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\r\n\t\t\t\tif ( data.hierarchy[ h ].keys[ k ].time === data.hierarchy[ h ].keys[ k - 1 ].time ) {\r\n\r\n\t\t\t\t\tdata.hierarchy[ h ].keys.splice( k, 1 );\r\n\t\t\t\t\tk --;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\t// set index\r\n\r\n\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\r\n\t\t\t\tdata.hierarchy[ h ].keys[ k ].index = k;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\t\t// JIT\r\n\r\n\t\tvar lengthInFrames = parseInt( data.length * data.fps, 10 );\r\n\r\n\t\tdata.JIT = {};\r\n\t\tdata.JIT.hierarchy = [];\r\n\r\n\t\tfor( var h = 0; h < data.hierarchy.length; h ++ )\r\n\t\t\tdata.JIT.hierarchy.push( new Array( lengthInFrames ) );\r\n\r\n\r\n\t\t// done\r\n\r\n\t\tdata.initialized = true;\r\n\r\n\t};\r\n\r\n\r\n\t// interpolation types\r\n\r\n\tthat.LINEAR = 0;\r\n\tthat.CATMULLROM = 1;\r\n\tthat.CATMULLROM_FORWARD = 2;\r\n\r\n\treturn that;\r\n\r\n}());\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Animation = function ( root, name, interpolationType ) {\r\n\r\n\tthis.root = root;\r\n\tthis.data = THREE.AnimationHandler.get( name );\r\n\tthis.hierarchy = THREE.AnimationHandler.parse( root );\r\n\r\n\tthis.currentTime = 0;\r\n\tthis.timeScale = 1;\r\n\r\n\tthis.isPlaying = false;\r\n\tthis.isPaused = true;\r\n\tthis.loop = true;\r\n\r\n\tthis.interpolationType = interpolationType !== undefined ? interpolationType : THREE.AnimationHandler.LINEAR;\r\n\r\n\tthis.points = [];\r\n\tthis.target = new THREE.Vector3();\r\n\r\n};\r\n\r\nTHREE.Animation.prototype.play = function ( loop, startTimeMS ) {\r\n\r\n\tif ( this.isPlaying === false ) {\r\n\r\n\t\tthis.isPlaying = true;\r\n\t\tthis.loop = loop !== undefined ? loop : true;\r\n\t\tthis.currentTime = startTimeMS !== undefined ? startTimeMS : 0;\r\n\r\n\t\t// reset key cache\r\n\r\n\t\tvar h, hl = this.hierarchy.length,\r\n\t\t\tobject;\r\n\r\n\t\tfor ( h = 0; h < hl; h ++ ) {\r\n\r\n\t\t\tobject = this.hierarchy[ h ];\r\n\r\n\t\t\tif ( this.interpolationType !== THREE.AnimationHandler.CATMULLROM_FORWARD ) {\r\n\r\n\t\t\t\tobject.useQuaternion = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobject.matrixAutoUpdate = true;\r\n\r\n\t\t\tif ( object.animationCache === undefined ) {\r\n\r\n\t\t\t\tobject.animationCache = {};\r\n\t\t\t\tobject.animationCache.prevKey = { pos: 0, rot: 0, scl: 0 };\r\n\t\t\t\tobject.animationCache.nextKey = { pos: 0, rot: 0, scl: 0 };\r\n\t\t\t\tobject.animationCache.originalMatrix = object instanceof THREE.Bone ? object.skinMatrix : object.matrix;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar prevKey = object.animationCache.prevKey;\r\n\t\t\tvar nextKey = object.animationCache.nextKey;\r\n\r\n\t\t\tprevKey.pos = this.data.hierarchy[ h ].keys[ 0 ];\r\n\t\t\tprevKey.rot = this.data.hierarchy[ h ].keys[ 0 ];\r\n\t\t\tprevKey.scl = this.data.hierarchy[ h ].keys[ 0 ];\r\n\r\n\t\t\tnextKey.pos = this.getNextKeyWith( \"pos\", h, 1 );\r\n\t\t\tnextKey.rot = this.getNextKeyWith( \"rot\", h, 1 );\r\n\t\t\tnextKey.scl = this.getNextKeyWith( \"scl\", h, 1 );\r\n\r\n\t\t}\r\n\r\n\t\tthis.update( 0 );\r\n\r\n\t}\r\n\r\n\tthis.isPaused = false;\r\n\r\n\tTHREE.AnimationHandler.addToUpdate( this );\r\n\r\n};\r\n\r\n\r\nTHREE.Animation.prototype.pause = function() {\r\n\r\n\tif ( this.isPaused === true ) {\r\n\r\n\t\tTHREE.AnimationHandler.addToUpdate( this );\r\n\r\n\t} else {\r\n\r\n\t\tTHREE.AnimationHandler.removeFromUpdate( this );\r\n\r\n\t}\r\n\r\n\tthis.isPaused = !this.isPaused;\r\n\r\n};\r\n\r\n\r\nTHREE.Animation.prototype.stop = function() {\r\n\r\n\tthis.isPlaying = false;\r\n\tthis.isPaused  = false;\r\n\tTHREE.AnimationHandler.removeFromUpdate( this );\r\n\r\n};\r\n\r\n\r\nTHREE.Animation.prototype.update = function ( deltaTimeMS ) {\r\n\r\n\t// early out\r\n\r\n\tif ( this.isPlaying === false ) return;\r\n\r\n\r\n\t// vars\r\n\r\n\tvar types = [ \"pos\", \"rot\", \"scl\" ];\r\n\tvar type;\r\n\tvar scale;\r\n\tvar vector;\r\n\tvar prevXYZ, nextXYZ;\r\n\tvar prevKey, nextKey;\r\n\tvar object;\r\n\tvar animationCache;\r\n\tvar frame;\r\n\tvar JIThierarchy = this.data.JIT.hierarchy;\r\n\tvar currentTime, unloopedCurrentTime;\r\n\tvar currentPoint, forwardPoint, angle;\r\n\r\n\r\n\tthis.currentTime += deltaTimeMS * this.timeScale;\r\n\r\n\tunloopedCurrentTime = this.currentTime;\r\n\tcurrentTime = this.currentTime = this.currentTime % this.data.length;\r\n\tframe = parseInt( Math.min( currentTime * this.data.fps, this.data.length * this.data.fps ), 10 );\r\n\r\n\r\n\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\r\n\r\n\t\tobject = this.hierarchy[ h ];\r\n\t\tanimationCache = object.animationCache;\r\n\r\n\t\t// loop through pos/rot/scl\r\n\r\n\t\tfor ( var t = 0; t < 3; t ++ ) {\r\n\r\n\t\t\t// get keys\r\n\r\n\t\t\ttype    = types[ t ];\r\n\t\t\tprevKey = animationCache.prevKey[ type ];\r\n\t\t\tnextKey = animationCache.nextKey[ type ];\r\n\r\n\t\t\t// switch keys?\r\n\r\n\t\t\tif ( nextKey.time <= unloopedCurrentTime ) {\r\n\r\n\t\t\t\t// did we loop?\r\n\r\n\t\t\t\tif ( currentTime < unloopedCurrentTime ) {\r\n\r\n\t\t\t\t\tif ( this.loop ) {\r\n\r\n\t\t\t\t\t\tprevKey = this.data.hierarchy[ h ].keys[ 0 ];\r\n\t\t\t\t\t\tnextKey = this.getNextKeyWith( type, h, 1 );\r\n\r\n\t\t\t\t\t\twhile( nextKey.time < currentTime ) {\r\n\r\n\t\t\t\t\t\t\tprevKey = nextKey;\r\n\t\t\t\t\t\t\tnextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tthis.stop();\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tdo {\r\n\r\n\t\t\t\t\t\tprevKey = nextKey;\r\n\t\t\t\t\t\tnextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );\r\n\r\n\t\t\t\t\t} while( nextKey.time < currentTime )\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tanimationCache.prevKey[ type ] = prevKey;\r\n\t\t\t\tanimationCache.nextKey[ type ] = nextKey;\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tobject.matrixAutoUpdate = true;\r\n\t\t\tobject.matrixWorldNeedsUpdate = true;\r\n\r\n\t\t\tscale = ( currentTime - prevKey.time ) / ( nextKey.time - prevKey.time );\r\n\t\t\tprevXYZ = prevKey[ type ];\r\n\t\t\tnextXYZ = nextKey[ type ];\r\n\r\n\r\n\t\t\t// check scale error\r\n\r\n\t\t\tif ( scale < 0 || scale > 1 ) {\r\n\r\n\t\t\t\tconsole.log( \"THREE.Animation.update: Warning! Scale out of bounds:\" + scale + \" on bone \" + h );\r\n\t\t\t\tscale = scale < 0 ? 0 : 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// interpolate\r\n\r\n\t\t\tif ( type === \"pos\" ) {\r\n\r\n\t\t\t\tvector = object.position;\r\n\r\n\t\t\t\tif ( this.interpolationType === THREE.AnimationHandler.LINEAR ) {\r\n\r\n\t\t\t\t\tvector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;\r\n\t\t\t\t\tvector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;\r\n\t\t\t\t\tvector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;\r\n\r\n\t\t\t\t} else if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\r\n\t\t\t\t\t\t    this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\r\n\r\n\t\t\t\t\tthis.points[ 0 ] = this.getPrevKeyWith( \"pos\", h, prevKey.index - 1 )[ \"pos\" ];\r\n\t\t\t\t\tthis.points[ 1 ] = prevXYZ;\r\n\t\t\t\t\tthis.points[ 2 ] = nextXYZ;\r\n\t\t\t\t\tthis.points[ 3 ] = this.getNextKeyWith( \"pos\", h, nextKey.index + 1 )[ \"pos\" ];\r\n\r\n\t\t\t\t\tscale = scale * 0.33 + 0.33;\r\n\r\n\t\t\t\t\tcurrentPoint = this.interpolateCatmullRom( this.points, scale );\r\n\r\n\t\t\t\t\tvector.x = currentPoint[ 0 ];\r\n\t\t\t\t\tvector.y = currentPoint[ 1 ];\r\n\t\t\t\t\tvector.z = currentPoint[ 2 ];\r\n\r\n\t\t\t\t\tif ( this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\r\n\r\n\t\t\t\t\t\tforwardPoint = this.interpolateCatmullRom( this.points, scale * 1.01 );\r\n\r\n\t\t\t\t\t\tthis.target.set( forwardPoint[ 0 ], forwardPoint[ 1 ], forwardPoint[ 2 ] );\r\n\t\t\t\t\t\tthis.target.sub( vector );\r\n\t\t\t\t\t\tthis.target.y = 0;\r\n\t\t\t\t\t\tthis.target.normalize();\r\n\r\n\t\t\t\t\t\tangle = Math.atan2( this.target.x, this.target.z );\r\n\t\t\t\t\t\tobject.rotation.set( 0, angle, 0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( type === \"rot\" ) {\r\n\r\n\t\t\t\tTHREE.Quaternion.slerp( prevXYZ, nextXYZ, object.quaternion, scale );\r\n\r\n\t\t\t} else if ( type === \"scl\" ) {\r\n\r\n\t\t\t\tvector = object.scale;\r\n\r\n\t\t\t\tvector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;\r\n\t\t\t\tvector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;\r\n\t\t\t\tvector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\n// Catmull-Rom spline\r\n\r\nTHREE.Animation.prototype.interpolateCatmullRom = function ( points, scale ) {\r\n\r\n\tvar c = [], v3 = [],\r\n\tpoint, intPoint, weight, w2, w3,\r\n\tpa, pb, pc, pd;\r\n\r\n\tpoint = ( points.length - 1 ) * scale;\r\n\tintPoint = Math.floor( point );\r\n\tweight = point - intPoint;\r\n\r\n\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\r\n\tc[ 1 ] = intPoint;\r\n\tc[ 2 ] = intPoint > points.length - 2 ? intPoint : intPoint + 1;\r\n\tc[ 3 ] = intPoint > points.length - 3 ? intPoint : intPoint + 2;\r\n\r\n\tpa = points[ c[ 0 ] ];\r\n\tpb = points[ c[ 1 ] ];\r\n\tpc = points[ c[ 2 ] ];\r\n\tpd = points[ c[ 3 ] ];\r\n\r\n\tw2 = weight * weight;\r\n\tw3 = weight * w2;\r\n\r\n\tv3[ 0 ] = this.interpolate( pa[ 0 ], pb[ 0 ], pc[ 0 ], pd[ 0 ], weight, w2, w3 );\r\n\tv3[ 1 ] = this.interpolate( pa[ 1 ], pb[ 1 ], pc[ 1 ], pd[ 1 ], weight, w2, w3 );\r\n\tv3[ 2 ] = this.interpolate( pa[ 2 ], pb[ 2 ], pc[ 2 ], pd[ 2 ], weight, w2, w3 );\r\n\r\n\treturn v3;\r\n\r\n};\r\n\r\nTHREE.Animation.prototype.interpolate = function ( p0, p1, p2, p3, t, t2, t3 ) {\r\n\r\n\tvar v0 = ( p2 - p0 ) * 0.5,\r\n\t\tv1 = ( p3 - p1 ) * 0.5;\r\n\r\n\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\r\n};\r\n\r\n\r\n\r\n// Get next key with\r\n\r\nTHREE.Animation.prototype.getNextKeyWith = function ( type, h, key ) {\r\n\r\n\tvar keys = this.data.hierarchy[ h ].keys;\r\n\r\n\tif ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\r\n\t\t this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\r\n\r\n\t\tkey = key < keys.length - 1 ? key : keys.length - 1;\r\n\r\n\t} else {\r\n\r\n\t\tkey = key % keys.length;\r\n\r\n\t}\r\n\r\n\tfor ( ; key < keys.length; key++ ) {\r\n\r\n\t\tif ( keys[ key ][ type ] !== undefined ) {\r\n\r\n\t\t\treturn keys[ key ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn this.data.hierarchy[ h ].keys[ 0 ];\r\n\r\n};\r\n\r\n// Get previous key with\r\n\r\nTHREE.Animation.prototype.getPrevKeyWith = function ( type, h, key ) {\r\n\r\n\tvar keys = this.data.hierarchy[ h ].keys;\r\n\r\n\tif ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\r\n\t\t this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\r\n\r\n\t\tkey = key > 0 ? key : 0;\r\n\r\n\t} else {\r\n\r\n\t\tkey = key >= 0 ? key : key + keys.length;\r\n\r\n\t}\r\n\r\n\r\n\tfor ( ; key >= 0; key -- ) {\r\n\r\n\t\tif ( keys[ key ][ type ] !== undefined ) {\r\n\r\n\t\t\treturn keys[ key ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn this.data.hierarchy[ h ].keys[ keys.length - 1 ];\r\n\r\n};\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author khang duong\r\n * @author erik kitson\r\n */\r\n\r\nTHREE.KeyFrameAnimation = function( root, data, JITCompile ) {\r\n\r\n\tthis.root = root;\r\n\tthis.data = THREE.AnimationHandler.get( data );\r\n\tthis.hierarchy = THREE.AnimationHandler.parse( root );\r\n\tthis.currentTime = 0;\r\n\tthis.timeScale = 0.001;\r\n\tthis.isPlaying = false;\r\n\tthis.isPaused = true;\r\n\tthis.loop = true;\r\n\tthis.JITCompile = JITCompile !== undefined ? JITCompile : true;\r\n\r\n\t// initialize to first keyframes\r\n\r\n\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {\r\n\r\n\t\tvar keys = this.data.hierarchy[h].keys,\r\n\t\t\tsids = this.data.hierarchy[h].sids,\r\n\t\t\tobj = this.hierarchy[h];\r\n\r\n\t\tif ( keys.length && sids ) {\r\n\r\n\t\t\tfor ( var s = 0; s < sids.length; s++ ) {\r\n\r\n\t\t\t\tvar sid = sids[ s ],\r\n\t\t\t\t\tnext = this.getNextKeyWith( sid, h, 0 );\r\n\r\n\t\t\t\tif ( next ) {\r\n\r\n\t\t\t\t\tnext.apply( sid );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobj.matrixAutoUpdate = false;\r\n\t\t\tthis.data.hierarchy[h].node.updateMatrix();\r\n\t\t\tobj.matrixWorldNeedsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\n// Play\r\n\r\nTHREE.KeyFrameAnimation.prototype.play = function( loop, startTimeMS ) {\r\n\r\n\tif( !this.isPlaying ) {\r\n\r\n\t\tthis.isPlaying = true;\r\n\t\tthis.loop = loop !== undefined ? loop : true;\r\n\t\tthis.currentTime = startTimeMS !== undefined ? startTimeMS : 0;\r\n\t\tthis.startTimeMs = startTimeMS;\r\n\t\tthis.startTime = 10000000;\r\n\t\tthis.endTime = -this.startTime;\r\n\r\n\r\n\t\t// reset key cache\r\n\r\n\t\tvar h, hl = this.hierarchy.length,\r\n\t\t\tobject,\r\n\t\t\tnode;\r\n\r\n\t\tfor ( h = 0; h < hl; h++ ) {\r\n\r\n\t\t\tobject = this.hierarchy[ h ];\r\n\t\t\tnode = this.data.hierarchy[ h ];\r\n\t\t\tobject.useQuaternion = true;\r\n\r\n\t\t\tif ( node.animationCache === undefined ) {\r\n\r\n\t\t\t\tnode.animationCache = {};\r\n\t\t\t\tnode.animationCache.prevKey = null;\r\n\t\t\t\tnode.animationCache.nextKey = null;\r\n\t\t\t\tnode.animationCache.originalMatrix = object instanceof THREE.Bone ? object.skinMatrix : object.matrix;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar keys = this.data.hierarchy[h].keys;\r\n\r\n\t\t\tif (keys.length) {\r\n\r\n\t\t\t\tnode.animationCache.prevKey = keys[ 0 ];\r\n\t\t\t\tnode.animationCache.nextKey = keys[ 1 ];\r\n\r\n\t\t\t\tthis.startTime = Math.min( keys[0].time, this.startTime );\r\n\t\t\t\tthis.endTime = Math.max( keys[keys.length - 1].time, this.endTime );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.update( 0 );\r\n\r\n\t}\r\n\r\n\tthis.isPaused = false;\r\n\r\n\tTHREE.AnimationHandler.addToUpdate( this );\r\n\r\n};\r\n\r\n\r\n\r\n// Pause\r\n\r\nTHREE.KeyFrameAnimation.prototype.pause = function() {\r\n\r\n\tif( this.isPaused ) {\r\n\r\n\t\tTHREE.AnimationHandler.addToUpdate( this );\r\n\r\n\t} else {\r\n\r\n\t\tTHREE.AnimationHandler.removeFromUpdate( this );\r\n\r\n\t}\r\n\r\n\tthis.isPaused = !this.isPaused;\r\n\r\n};\r\n\r\n\r\n// Stop\r\n\r\nTHREE.KeyFrameAnimation.prototype.stop = function() {\r\n\r\n\tthis.isPlaying = false;\r\n\tthis.isPaused  = false;\r\n\tTHREE.AnimationHandler.removeFromUpdate( this );\r\n\r\n\r\n\t// reset JIT matrix and remove cache\r\n\r\n\tfor ( var h = 0; h < this.data.hierarchy.length; h++ ) {\r\n        \r\n        var obj = this.hierarchy[ h ];\r\n\t\tvar node = this.data.hierarchy[ h ];\r\n\r\n\t\tif ( node.animationCache !== undefined ) {\r\n\r\n\t\t\tvar original = node.animationCache.originalMatrix;\r\n\r\n\t\t\tif( obj instanceof THREE.Bone ) {\r\n\r\n\t\t\t\toriginal.copy( obj.skinMatrix );\r\n\t\t\t\tobj.skinMatrix = original;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\toriginal.copy( obj.matrix );\r\n\t\t\t\tobj.matrix = original;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdelete node.animationCache;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\n\r\n// Update\r\n\r\nTHREE.KeyFrameAnimation.prototype.update = function( deltaTimeMS ) {\r\n\r\n\t// early out\r\n\r\n\tif( !this.isPlaying ) return;\r\n\r\n\r\n\t// vars\r\n\r\n\tvar prevKey, nextKey;\r\n\tvar object;\r\n\tvar node;\r\n\tvar frame;\r\n\tvar JIThierarchy = this.data.JIT.hierarchy;\r\n\tvar currentTime, unloopedCurrentTime;\r\n\tvar looped;\r\n\r\n\r\n\t// update\r\n\r\n\tthis.currentTime += deltaTimeMS * this.timeScale;\r\n\r\n\tunloopedCurrentTime = this.currentTime;\r\n\tcurrentTime         = this.currentTime = this.currentTime % this.data.length;\r\n\r\n\t// if looped around, the current time should be based on the startTime\r\n\tif ( currentTime < this.startTimeMs ) {\r\n\r\n\t\tcurrentTime = this.currentTime = this.startTimeMs + currentTime;\r\n\r\n\t}\r\n\r\n\tframe               = parseInt( Math.min( currentTime * this.data.fps, this.data.length * this.data.fps ), 10 );\r\n\tlooped \t\t\t\t= currentTime < unloopedCurrentTime;\r\n\r\n\tif ( looped && !this.loop ) {\r\n\r\n\t\t// Set the animation to the last keyframes and stop\r\n\t\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {\r\n\r\n\t\t\tvar keys = this.data.hierarchy[h].keys,\r\n\t\t\t\tsids = this.data.hierarchy[h].sids,\r\n\t\t\t\tend = keys.length-1,\r\n\t\t\t\tobj = this.hierarchy[h];\r\n\r\n\t\t\tif ( keys.length ) {\r\n\r\n\t\t\t\tfor ( var s = 0; s < sids.length; s++ ) {\r\n\r\n\t\t\t\t\tvar sid = sids[ s ],\r\n\t\t\t\t\t\tprev = this.getPrevKeyWith( sid, h, end );\r\n\r\n\t\t\t\t\tif ( prev ) {\r\n\t\t\t\t\t\tprev.apply( sid );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.data.hierarchy[h].node.updateMatrix();\r\n\t\t\t\tobj.matrixWorldNeedsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.stop();\r\n\t\treturn;\r\n\r\n\t}\r\n\r\n\t// check pre-infinity\r\n\tif ( currentTime < this.startTime ) {\r\n\r\n\t\treturn;\r\n\r\n\t}\r\n\r\n\t// update\r\n\r\n\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {\r\n\r\n\t\tobject = this.hierarchy[ h ];\r\n\t\tnode = this.data.hierarchy[ h ];\r\n\r\n\t\tvar keys = node.keys,\r\n\t\t\tanimationCache = node.animationCache;\r\n\r\n\t\t// use JIT?\r\n\r\n\t\tif ( this.JITCompile && JIThierarchy[ h ][ frame ] !== undefined ) {\r\n\r\n\t\t\tif( object instanceof THREE.Bone ) {\r\n\r\n\t\t\t\tobject.skinMatrix = JIThierarchy[ h ][ frame ];\r\n\t\t\t\tobject.matrixWorldNeedsUpdate = false;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tobject.matrix = JIThierarchy[ h ][ frame ];\r\n\t\t\t\tobject.matrixWorldNeedsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t// use interpolation\r\n\r\n\t\t} else if ( keys.length ) {\r\n\r\n\t\t\t// make sure so original matrix and not JIT matrix is set\r\n\r\n\t\t\tif ( this.JITCompile && animationCache ) {\r\n\r\n\t\t\t\tif( object instanceof THREE.Bone ) {\r\n\r\n\t\t\t\t\tobject.skinMatrix = animationCache.originalMatrix;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tobject.matrix = animationCache.originalMatrix;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tprevKey = animationCache.prevKey;\r\n\t\t\tnextKey = animationCache.nextKey;\r\n\r\n\t\t\tif ( prevKey && nextKey ) {\r\n\r\n\t\t\t\t// switch keys?\r\n\r\n\t\t\t\tif ( nextKey.time <= unloopedCurrentTime ) {\r\n\r\n\t\t\t\t\t// did we loop?\r\n\r\n\t\t\t\t\tif ( looped && this.loop ) {\r\n\r\n\t\t\t\t\t\tprevKey = keys[ 0 ];\r\n\t\t\t\t\t\tnextKey = keys[ 1 ];\r\n\r\n\t\t\t\t\t\twhile ( nextKey.time < currentTime ) {\r\n\r\n\t\t\t\t\t\t\tprevKey = nextKey;\r\n\t\t\t\t\t\t\tnextKey = keys[ prevKey.index + 1 ];\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( !looped ) {\r\n\r\n\t\t\t\t\t\tvar lastIndex = keys.length - 1;\r\n\r\n\t\t\t\t\t\twhile ( nextKey.time < currentTime && nextKey.index !== lastIndex ) {\r\n\r\n\t\t\t\t\t\t\tprevKey = nextKey;\r\n\t\t\t\t\t\t\tnextKey = keys[ prevKey.index + 1 ];\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tanimationCache.prevKey = prevKey;\r\n\t\t\t\t\tanimationCache.nextKey = nextKey;\r\n\r\n\t\t\t\t}\r\n                if(nextKey.time >= currentTime)\r\n                    prevKey.interpolate( nextKey, currentTime );\r\n                else\r\n                    prevKey.interpolate( nextKey, nextKey.time);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.data.hierarchy[h].node.updateMatrix();\r\n\t\t\tobject.matrixWorldNeedsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// update JIT?\r\n\r\n\tif ( this.JITCompile ) {\r\n\r\n\t\tif ( JIThierarchy[ 0 ][ frame ] === undefined ) {\r\n\r\n\t\t\tthis.hierarchy[ 0 ].updateMatrixWorld( true );\r\n\r\n\t\t\tfor ( var h = 0; h < this.hierarchy.length; h++ ) {\r\n\r\n\t\t\t\tif( this.hierarchy[ h ] instanceof THREE.Bone ) {\r\n\r\n\t\t\t\t\tJIThierarchy[ h ][ frame ] = this.hierarchy[ h ].skinMatrix.clone();\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tJIThierarchy[ h ][ frame ] = this.hierarchy[ h ].matrix.clone();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\n// Get next key with\r\n\r\nTHREE.KeyFrameAnimation.prototype.getNextKeyWith = function( sid, h, key ) {\r\n\r\n\tvar keys = this.data.hierarchy[ h ].keys;\r\n\tkey = key % keys.length;\r\n\r\n\tfor ( ; key < keys.length; key++ ) {\r\n\r\n\t\tif ( keys[ key ].hasTarget( sid ) ) {\r\n\r\n\t\t\treturn keys[ key ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn keys[ 0 ];\r\n\r\n};\r\n\r\n// Get previous key with\r\n\r\nTHREE.KeyFrameAnimation.prototype.getPrevKeyWith = function( sid, h, key ) {\r\n\r\n\tvar keys = this.data.hierarchy[ h ].keys;\r\n\tkey = key >= 0 ? key : key + keys.length;\r\n\r\n\tfor ( ; key >= 0; key-- ) {\r\n\r\n\t\tif ( keys[ key ].hasTarget( sid ) ) {\r\n\r\n\t\t\treturn keys[ key ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn keys[ keys.length - 1 ];\r\n\r\n};\r\n/**\r\n * Camera for rendering cube maps\r\n *\t- renders scene into axis-aligned cube\r\n *\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.CubeCamera = function ( near, far, cubeResolution ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tvar fov = 90, aspect = 1;\r\n\r\n\tvar cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraPX.up.set( 0, -1, 0 );\r\n\tcameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );\r\n\tthis.add( cameraPX );\r\n\r\n\tvar cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraNX.up.set( 0, -1, 0 );\r\n\tcameraNX.lookAt( new THREE.Vector3( -1, 0, 0 ) );\r\n\tthis.add( cameraNX );\r\n\r\n\tvar cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraPY.up.set( 0, 0, 1 );\r\n\tcameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );\r\n\tthis.add( cameraPY );\r\n\r\n\tvar cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraNY.up.set( 0, 0, -1 );\r\n\tcameraNY.lookAt( new THREE.Vector3( 0, -1, 0 ) );\r\n\tthis.add( cameraNY );\r\n\r\n\tvar cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraPZ.up.set( 0, -1, 0 );\r\n\tcameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );\r\n\tthis.add( cameraPZ );\r\n\r\n\tvar cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraNZ.up.set( 0, -1, 0 );\r\n\tcameraNZ.lookAt( new THREE.Vector3( 0, 0, -1 ) );\r\n\tthis.add( cameraNZ );\r\n\r\n\tthis.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter } );\r\n\r\n\tthis.updateCubeMap = function ( renderer, scene ) {\r\n\r\n\t\tvar renderTarget = this.renderTarget;\r\n\t\tvar generateMipmaps = renderTarget.generateMipmaps;\r\n\r\n\t\trenderTarget.generateMipmaps = false;\r\n\r\n\t\trenderTarget.activeCubeFace = 0;\r\n\t\trenderer.render( scene, cameraPX, renderTarget );\r\n\r\n\t\trenderTarget.activeCubeFace = 1;\r\n\t\trenderer.render( scene, cameraNX, renderTarget );\r\n\r\n\t\trenderTarget.activeCubeFace = 2;\r\n\t\trenderer.render( scene, cameraPY, renderTarget );\r\n\r\n\t\trenderTarget.activeCubeFace = 3;\r\n\t\trenderer.render( scene, cameraNY, renderTarget );\r\n\r\n\t\trenderTarget.activeCubeFace = 4;\r\n\t\trenderer.render( scene, cameraPZ, renderTarget );\r\n\r\n\t\trenderTarget.generateMipmaps = generateMipmaps;\r\n\r\n\t\trenderTarget.activeCubeFace = 5;\r\n\t\trenderer.render( scene, cameraNZ, renderTarget );\r\n\r\n\t};\r\n\r\n};\r\n\r\nTHREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );\r\n/*\r\n *\t@author zz85 / http://twitter.com/blurspline / http://www.lab4games.net/zz85/blog\r\n *\r\n *\tA general perpose camera, for setting FOV, Lens Focal Length,\r\n *\t\tand switching between perspective and orthographic views easily.\r\n *\t\tUse this only if you do not wish to manage\r\n *\t\tboth a Orthographic and Perspective Camera\r\n *\r\n */\r\n\r\n\r\nTHREE.CombinedCamera = function ( width, height, fov, near, far, orthoNear, orthoFar ) {\r\n\r\n\tTHREE.Camera.call( this );\r\n\r\n\tthis.fov = fov;\r\n\r\n\tthis.left = -width / 2;\r\n\tthis.right = width / 2\r\n\tthis.top = height / 2;\r\n\tthis.bottom = -height / 2;\r\n\r\n\t// We could also handle the projectionMatrix internally, but just wanted to test nested camera objects\r\n\r\n\tthis.cameraO = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, \torthoNear, orthoFar );\r\n\tthis.cameraP = new THREE.PerspectiveCamera( fov, width / height, near, far );\r\n\r\n\tthis.zoom = 1;\r\n\r\n\tthis.toPerspective();\r\n\r\n\tvar aspect = width/height;\r\n\r\n};\r\n\r\nTHREE.CombinedCamera.prototype = Object.create( THREE.Camera.prototype );\r\n\r\nTHREE.CombinedCamera.prototype.toPerspective = function () {\r\n\r\n\t// Switches to the Perspective Camera\r\n\r\n\tthis.near = this.cameraP.near;\r\n\tthis.far = this.cameraP.far;\r\n\r\n\tthis.cameraP.fov =  this.fov / this.zoom ;\r\n\r\n\tthis.cameraP.updateProjectionMatrix();\r\n\r\n\tthis.projectionMatrix = this.cameraP.projectionMatrix;\r\n\r\n\tthis.inPerspectiveMode = true;\r\n\tthis.inOrthographicMode = false;\r\n\r\n};\r\n\r\nTHREE.CombinedCamera.prototype.toOrthographic = function () {\r\n\r\n\t// Switches to the Orthographic camera estimating viewport from Perspective\r\n\r\n\tvar fov = this.fov;\r\n\tvar aspect = this.cameraP.aspect;\r\n\tvar near = this.cameraP.near;\r\n\tvar far = this.cameraP.far;\r\n\r\n\t// The size that we set is the mid plane of the viewing frustum\r\n\r\n\tvar hyperfocus = ( near + far ) / 2;\r\n\r\n\tvar halfHeight = Math.tan( fov / 2 ) * hyperfocus;\r\n\tvar planeHeight = 2 * halfHeight;\r\n\tvar planeWidth = planeHeight * aspect;\r\n\tvar halfWidth = planeWidth / 2;\r\n\r\n\thalfHeight /= this.zoom;\r\n\thalfWidth /= this.zoom;\r\n\r\n\tthis.cameraO.left = -halfWidth;\r\n\tthis.cameraO.right = halfWidth;\r\n\tthis.cameraO.top = halfHeight;\r\n\tthis.cameraO.bottom = -halfHeight;\r\n\r\n\t// this.cameraO.left = -farHalfWidth;\r\n\t// this.cameraO.right = farHalfWidth;\r\n\t// this.cameraO.top = farHalfHeight;\r\n\t// this.cameraO.bottom = -farHalfHeight;\r\n\r\n\t// this.cameraO.left = this.left / this.zoom;\r\n\t// this.cameraO.right = this.right / this.zoom;\r\n\t// this.cameraO.top = this.top / this.zoom;\r\n\t// this.cameraO.bottom = this.bottom / this.zoom;\r\n\r\n\tthis.cameraO.updateProjectionMatrix();\r\n\r\n\tthis.near = this.cameraO.near;\r\n\tthis.far = this.cameraO.far;\r\n\tthis.projectionMatrix = this.cameraO.projectionMatrix;\r\n\r\n\tthis.inPerspectiveMode = false;\r\n\tthis.inOrthographicMode = true;\r\n\r\n};\r\n\r\n\r\nTHREE.CombinedCamera.prototype.setSize = function( width, height ) {\r\n\r\n\tthis.cameraP.aspect = width / height;\r\n\tthis.left = -width / 2;\r\n\tthis.right = width / 2\r\n\tthis.top = height / 2;\r\n\tthis.bottom = -height / 2;\r\n\r\n};\r\n\r\n\r\nTHREE.CombinedCamera.prototype.setFov = function( fov ) {\r\n\r\n\tthis.fov = fov;\r\n\r\n\tif ( this.inPerspectiveMode ) {\r\n\r\n\t\tthis.toPerspective();\r\n\r\n\t} else {\r\n\r\n\t\tthis.toOrthographic();\r\n\r\n\t}\r\n\r\n};\r\n\r\n// For mantaining similar API with PerspectiveCamera\r\n\r\nTHREE.CombinedCamera.prototype.updateProjectionMatrix = function() {\r\n\r\n\tif ( this.inPerspectiveMode ) {\r\n\r\n\t\tthis.toPerspective();\r\n\r\n\t} else {\r\n\r\n\t\tthis.toPerspective();\r\n\t\tthis.toOrthographic();\r\n\r\n\t}\r\n\r\n};\r\n\r\n/*\r\n* Uses Focal Length (in mm) to estimate and set FOV\r\n* 35mm (fullframe) camera is used if frame size is not specified;\r\n* Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html\r\n*/\r\nTHREE.CombinedCamera.prototype.setLens = function ( focalLength, frameHeight ) {\r\n\r\n\tif ( frameHeight === undefined ) frameHeight = 24;\r\n\r\n\tvar fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );\r\n\r\n\tthis.setFov( fov );\r\n\r\n\treturn fov;\r\n};\r\n\r\n\r\nTHREE.CombinedCamera.prototype.setZoom = function( zoom ) {\r\n\r\n\tthis.zoom = zoom;\r\n\r\n\tif ( this.inPerspectiveMode ) {\r\n\r\n\t\tthis.toPerspective();\r\n\r\n\t} else {\r\n\r\n\t\tthis.toOrthographic();\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.CombinedCamera.prototype.toFrontView = function() {\r\n\r\n\tthis.rotation.x = 0;\r\n\tthis.rotation.y = 0;\r\n\tthis.rotation.z = 0;\r\n\r\n\t// should we be modifing the matrix instead?\r\n\r\n\tthis.rotationAutoUpdate = false;\r\n\r\n};\r\n\r\nTHREE.CombinedCamera.prototype.toBackView = function() {\r\n\r\n\tthis.rotation.x = 0;\r\n\tthis.rotation.y = Math.PI;\r\n\tthis.rotation.z = 0;\r\n\tthis.rotationAutoUpdate = false;\r\n\r\n};\r\n\r\nTHREE.CombinedCamera.prototype.toLeftView = function() {\r\n\r\n\tthis.rotation.x = 0;\r\n\tthis.rotation.y = - Math.PI / 2;\r\n\tthis.rotation.z = 0;\r\n\tthis.rotationAutoUpdate = false;\r\n\r\n};\r\n\r\nTHREE.CombinedCamera.prototype.toRightView = function() {\r\n\r\n\tthis.rotation.x = 0;\r\n\tthis.rotation.y = Math.PI / 2;\r\n\tthis.rotation.z = 0;\r\n\tthis.rotationAutoUpdate = false;\r\n\r\n};\r\n\r\nTHREE.CombinedCamera.prototype.toTopView = function() {\r\n\r\n\tthis.rotation.x = - Math.PI / 2;\r\n\tthis.rotation.y = 0;\r\n\tthis.rotation.z = 0;\r\n\tthis.rotationAutoUpdate = false;\r\n\r\n};\r\n\r\nTHREE.CombinedCamera.prototype.toBottomView = function() {\r\n\r\n\tthis.rotation.x = Math.PI / 2;\r\n\tthis.rotation.y = 0;\r\n\tthis.rotation.z = 0;\r\n\tthis.rotationAutoUpdate = false;\r\n\r\n};\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n *\t- 3d asterisk shape (for line pieces THREE.Line)\r\n */\r\n\r\nTHREE.AsteriskGeometry = function ( innerRadius, outerRadius ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tvar sd = innerRadius;\r\n\tvar ed = outerRadius;\r\n\r\n\tvar sd2 = 0.707 * sd;\r\n\tvar ed2 = 0.707 * ed;\r\n\r\n\tvar rays = [ [ sd, 0, 0 ], [ ed, 0, 0 ], [ -sd, 0, 0 ], [ -ed, 0, 0 ],\r\n\t\t\t\t [ 0, sd, 0 ], [ 0, ed, 0 ], [ 0, -sd, 0 ], [ 0, -ed, 0 ],\r\n\t\t\t\t [ 0, 0, sd ], [ 0, 0, ed ], [ 0, 0, -sd ], [ 0, 0, -ed ],\r\n\t\t\t\t [ sd2, sd2, 0 ], [ ed2, ed2, 0 ], [ -sd2, -sd2, 0 ], [ -ed2, -ed2, 0 ],\r\n\t\t\t\t [ sd2, -sd2, 0 ], [ ed2, -ed2, 0 ], [ -sd2, sd2, 0 ], [ -ed2, ed2, 0 ],\r\n\t\t\t\t [ sd2, 0, sd2 ], [ ed2, 0, ed2 ], [ -sd2, 0, -sd2 ], [ -ed2, 0, -ed2 ],\r\n\t\t\t\t [ sd2, 0, -sd2 ], [ ed2, 0, -ed2 ], [ -sd2, 0, sd2 ], [ -ed2, 0, ed2 ],\r\n\t\t\t\t [ 0, sd2, sd2 ], [ 0, ed2, ed2 ], [ 0, -sd2, -sd2 ], [ 0, -ed2, -ed2 ],\r\n\t\t\t\t [ 0, sd2, -sd2 ], [ 0, ed2, -ed2 ], [ 0, -sd2, sd2 ], [ 0, -ed2, ed2 ]\r\n\t];\r\n\r\n\tfor ( var i = 0, il = rays.length; i < il; i ++ ) {\r\n\r\n\t\tvar x = rays[ i ][ 0 ];\r\n\t\tvar y = rays[ i ][ 1 ];\r\n\t\tvar z = rays[ i ][ 2 ];\r\n\r\n\t\tthis.vertices.push( new THREE.Vector3( x, y, z ) );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.AsteriskGeometry.prototype = Object.create( THREE.Geometry.prototype );/**\r\n * @author hughes\r\n */\r\n\r\nTHREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {\r\n\r\n    THREE.Geometry.call( this );\r\n\r\n    radius = radius || 50;\r\n\r\n    thetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\r\n    segments = segments !== undefined ? Math.max( 3, segments ) : 8;\r\n\r\n    var i, uvs = [],\r\n    center = new THREE.Vector3(), centerUV = new THREE.Vector2( 0.5, 0.5 );\r\n\r\n    this.vertices.push(center);\r\n    uvs.push( centerUV );\r\n\r\n    for ( i = 0; i <= segments; i ++ ) {\r\n\r\n        var vertex = new THREE.Vector3();\r\n\r\n        vertex.x = radius * Math.cos( thetaStart + i / segments * thetaLength );\r\n        vertex.y = radius * Math.sin( thetaStart + i / segments * thetaLength );\r\n\r\n        this.vertices.push( vertex );\r\n        uvs.push( new THREE.Vector2( ( vertex.x / radius + 1 ) / 2, - ( vertex.y / radius + 1 ) / 2 + 1 ) );\r\n\r\n    }\r\n\r\n    var n = new THREE.Vector3( 0, 0, -1 );\r\n\r\n    for ( i = 1; i <= segments; i ++ ) {\r\n\r\n        var v1 = i;\r\n        var v2 = i + 1 ;\r\n        var v3 = 0;\r\n\r\n        this.faces.push( new THREE.Face3( v1, v2, v3, [ n, n, n ] ) );\r\n        this.faceVertexUvs[ 0 ].push( [ uvs[ i ], uvs[ i + 1 ], centerUV ] );\r\n\r\n    }\r\n\r\n    this.computeCentroids();\r\n    this.computeFaceNormals();\r\n\r\n    this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\r\n};\r\n\r\nTHREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as\r\n */\r\n\r\nTHREE.CubeGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tvar scope = this;\r\n\r\n\tthis.width = width;\r\n\tthis.height = height;\r\n\tthis.depth = depth;\r\n\r\n\tthis.widthSegments = widthSegments || 1;\r\n\tthis.heightSegments = heightSegments || 1;\r\n\tthis.depthSegments = depthSegments || 1;\r\n\r\n\tvar width_half = this.width / 2;\r\n\tvar height_half = this.height / 2;\r\n\tvar depth_half = this.depth / 2;\r\n\r\n\tbuildPlane( 'z', 'y', - 1, - 1, this.depth, this.height, width_half, 0 ); // px\r\n\tbuildPlane( 'z', 'y',   1, - 1, this.depth, this.height, - width_half, 1 ); // nx\r\n\tbuildPlane( 'x', 'z',   1,   1, this.width, this.depth, height_half, 2 ); // py\r\n\tbuildPlane( 'x', 'z',   1, - 1, this.width, this.depth, - height_half, 3 ); // ny\r\n\tbuildPlane( 'x', 'y',   1, - 1, this.width, this.height, depth_half, 4 ); // pz\r\n\tbuildPlane( 'x', 'y', - 1, - 1, this.width, this.height, - depth_half, 5 ); // nz\r\n\r\n\tfunction buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {\r\n\r\n\t\tvar w, ix, iy,\r\n\t\tgridX = scope.widthSegments,\r\n\t\tgridY = scope.heightSegments,\r\n\t\twidth_half = width / 2,\r\n\t\theight_half = height / 2,\r\n\t\toffset = scope.vertices.length;\r\n\r\n\t\tif ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {\r\n\r\n\t\t\tw = 'z';\r\n\r\n\t\t} else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {\r\n\r\n\t\t\tw = 'y';\r\n\t\t\tgridY = scope.depthSegments;\r\n\r\n\t\t} else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {\r\n\r\n\t\t\tw = 'x';\r\n\t\t\tgridX = scope.depthSegments;\r\n\r\n\t\t}\r\n\r\n\t\tvar gridX1 = gridX + 1,\r\n\t\tgridY1 = gridY + 1,\r\n\t\tsegment_width = width / gridX,\r\n\t\tsegment_height = height / gridY,\r\n\t\tnormal = new THREE.Vector3();\r\n\r\n\t\tnormal[ w ] = depth > 0 ? 1 : - 1;\r\n\r\n\t\tfor ( iy = 0; iy < gridY1; iy ++ ) {\r\n\r\n\t\t\tfor ( ix = 0; ix < gridX1; ix ++ ) {\r\n\r\n\t\t\t\tvar vector = new THREE.Vector3();\r\n\t\t\t\tvector[ u ] = ( ix * segment_width - width_half ) * udir;\r\n\t\t\t\tvector[ v ] = ( iy * segment_height - height_half ) * vdir;\r\n\t\t\t\tvector[ w ] = depth;\r\n\r\n\t\t\t\tscope.vertices.push( vector );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( iy = 0; iy < gridY; iy++ ) {\r\n\r\n\t\t\tfor ( ix = 0; ix < gridX; ix++ ) {\r\n\r\n\t\t\t\tvar a = ix + gridX1 * iy;\r\n\t\t\t\tvar b = ix + gridX1 * ( iy + 1 );\r\n\t\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\r\n\t\t\t\tvar d = ( ix + 1 ) + gridX1 * iy;\r\n\r\n\t\t\t\tvar face = new THREE.Face4( a + offset, b + offset, c + offset, d + offset );\r\n\t\t\t\tface.normal.copy( normal );\r\n\t\t\t\tface.vertexNormals.push( normal.clone(), normal.clone(), normal.clone(), normal.clone() );\r\n\t\t\t\tface.materialIndex = materialIndex;\r\n\r\n\t\t\t\tscope.faces.push( face );\r\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( [\r\n\t\t\t\t\t\t\tnew THREE.Vector2( ix / gridX, 1 - iy / gridY ),\r\n\t\t\t\t\t\t\tnew THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY ),\r\n\t\t\t\t\t\t\tnew THREE.Vector2( ( ix + 1 ) / gridX, 1- ( iy + 1 ) / gridY ),\r\n\t\t\t\t\t\t\tnew THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY )\r\n\t\t\t\t\t\t] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.computeCentroids();\r\n\tthis.mergeVertices();\r\n\r\n};\r\n\r\nTHREE.CubeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tradiusTop = radiusTop !== undefined ? radiusTop : 20;\r\n\tradiusBottom = radiusBottom !== undefined ? radiusBottom : 20;\r\n\theight = height !== undefined ? height : 100;\r\n\r\n\tvar heightHalf = height / 2;\r\n\tvar segmentsX = radiusSegments || 8;\r\n\tvar segmentsY = heightSegments || 1;\r\n\r\n\tvar x, y, vertices = [], uvs = [];\r\n\r\n\tfor ( y = 0; y <= segmentsY; y ++ ) {\r\n\r\n\t\tvar verticesRow = [];\r\n\t\tvar uvsRow = [];\r\n\r\n\t\tvar v = y / segmentsY;\r\n\t\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\r\n\r\n\t\tfor ( x = 0; x <= segmentsX; x ++ ) {\r\n\r\n\t\t\tvar u = x / segmentsX;\r\n\r\n\t\t\tvar vertex = new THREE.Vector3();\r\n\t\t\tvertex.x = radius * Math.sin( u * Math.PI * 2 );\r\n\t\t\tvertex.y = - v * height + heightHalf;\r\n\t\t\tvertex.z = radius * Math.cos( u * Math.PI * 2 );\r\n\r\n\t\t\tthis.vertices.push( vertex );\r\n\r\n\t\t\tverticesRow.push( this.vertices.length - 1 );\r\n\t\t\tuvsRow.push( new THREE.Vector2( u, 1 - v ) );\r\n\r\n\t\t}\r\n\r\n\t\tvertices.push( verticesRow );\r\n\t\tuvs.push( uvsRow );\r\n\r\n\t}\r\n\r\n\tvar tanTheta = ( radiusBottom - radiusTop ) / height;\r\n\tvar na, nb;\r\n\r\n\tfor ( x = 0; x < segmentsX; x ++ ) {\r\n\r\n\t\tif ( radiusTop !== 0 ) {\r\n\r\n\t\t\tna = this.vertices[ vertices[ 0 ][ x ] ].clone();\r\n\t\t\tnb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();\r\n\r\n\t\t} else {\r\n\r\n\t\t\tna = this.vertices[ vertices[ 1 ][ x ] ].clone();\r\n\t\t\tnb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();\r\n\r\n\t\t}\r\n\r\n\t\tna.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();\r\n\t\tnb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();\r\n\r\n\t\tfor ( y = 0; y < segmentsY; y ++ ) {\r\n\r\n\t\t\tvar v1 = vertices[ y ][ x ];\r\n\t\t\tvar v2 = vertices[ y + 1 ][ x ];\r\n\t\t\tvar v3 = vertices[ y + 1 ][ x + 1 ];\r\n\t\t\tvar v4 = vertices[ y ][ x + 1 ];\r\n\r\n\t\t\tvar n1 = na.clone();\r\n\t\t\tvar n2 = na.clone();\r\n\t\t\tvar n3 = nb.clone();\r\n\t\t\tvar n4 = nb.clone();\r\n\r\n\t\t\tvar uv1 = uvs[ y ][ x ].clone();\r\n\t\t\tvar uv2 = uvs[ y + 1 ][ x ].clone();\r\n\t\t\tvar uv3 = uvs[ y + 1 ][ x + 1 ].clone();\r\n\t\t\tvar uv4 = uvs[ y ][ x + 1 ].clone();\r\n\r\n\t\t\tthis.faces.push( new THREE.Face4( v1, v2, v3, v4, [ n1, n2, n3, n4 ] ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3, uv4 ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// top cap\r\n\r\n\tif ( !openEnded && radiusTop > 0 ) {\r\n\r\n\t\tthis.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );\r\n\r\n\t\tfor ( x = 0; x < segmentsX; x ++ ) {\r\n\r\n\t\t\tvar v1 = vertices[ 0 ][ x ];\r\n\t\t\tvar v2 = vertices[ 0 ][ x + 1 ];\r\n\t\t\tvar v3 = this.vertices.length - 1;\r\n\r\n\t\t\tvar n1 = new THREE.Vector3( 0, 1, 0 );\r\n\t\t\tvar n2 = new THREE.Vector3( 0, 1, 0 );\r\n\t\t\tvar n3 = new THREE.Vector3( 0, 1, 0 );\r\n\r\n\t\t\tvar uv1 = uvs[ 0 ][ x ].clone();\r\n\t\t\tvar uv2 = uvs[ 0 ][ x + 1 ].clone();\r\n\t\t\tvar uv3 = new THREE.Vector2( uv2.u, 0 );\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// bottom cap\r\n\r\n\tif ( !openEnded && radiusBottom > 0 ) {\r\n\r\n\t\tthis.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );\r\n\r\n\t\tfor ( x = 0; x < segmentsX; x ++ ) {\r\n\r\n\t\t\tvar v1 = vertices[ y ][ x + 1 ];\r\n\t\t\tvar v2 = vertices[ y ][ x ];\r\n\t\t\tvar v3 = this.vertices.length - 1;\r\n\r\n\t\t\tvar n1 = new THREE.Vector3( 0, - 1, 0 );\r\n\t\t\tvar n2 = new THREE.Vector3( 0, - 1, 0 );\r\n\t\t\tvar n3 = new THREE.Vector3( 0, - 1, 0 );\r\n\r\n\t\t\tvar uv1 = uvs[ y ][ x + 1 ].clone();\r\n\t\t\tvar uv2 = uvs[ y ][ x ].clone();\r\n\t\t\tvar uv3 = new THREE.Vector2( uv2.u, 1 );\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.computeCentroids();\r\n\tthis.computeFaceNormals();\r\n\r\n}\r\n\r\nTHREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n *\r\n * Creates extruded geometry from a path shape.\r\n *\r\n * parameters = {\r\n *\r\n *  size: <float>, // size of the text\r\n *  height: <float>, // thickness to extrude text\r\n *  curveSegments: <int>, // number of points on the curves\r\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segements of extrude spline too\r\n *  amount: <int>, // Amount\r\n *\r\n *  bevelEnabled: <bool>, // turn on bevel\r\n *  bevelThickness: <float>, // how deep into text bevel goes\r\n *  bevelSize: <float>, // how far from text outline is bevel\r\n *  bevelSegments: <int>, // number of bevel layers\r\n *\r\n *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)\r\n *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals\r\n *\r\n *  material: <int> // material index for front and back faces\r\n *  extrudeMaterial: <int> // material index for extrusion and beveled faces\r\n *  uvGenerator: <Object> // object that provides UV generator functions\r\n *\r\n * }\r\n **/\r\n\r\nTHREE.ExtrudeGeometry = function ( shapes, options ) {\r\n\r\n\tif ( typeof( shapes ) === \"undefined\" ) {\r\n\t\tshapes = [];\r\n\t\treturn;\r\n\t}\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tshapes = shapes instanceof Array ? shapes : [ shapes ];\r\n\r\n\tthis.shapebb = shapes[ shapes.length - 1 ].getBoundingBox();\r\n\r\n\tthis.addShapeList( shapes, options );\r\n\r\n\tthis.computeCentroids();\r\n\tthis.computeFaceNormals();\r\n\r\n\t// can't really use automatic vertex normals\r\n\t// as then front and back sides get smoothed too\r\n\t// should do separate smoothing just for sides\r\n\r\n\t//this.computeVertexNormals();\r\n\r\n\t//console.log( \"took\", ( Date.now() - startTime ) );\r\n\r\n};\r\n\r\nTHREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\r\nTHREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {\r\n\tvar sl = shapes.length;\r\n\r\n\tfor ( var s = 0; s < sl; s ++ ) {\r\n\t\tvar shape = shapes[ s ];\r\n\t\tthis.addShape( shape, options );\r\n\t}\r\n};\r\n\r\nTHREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {\r\n\r\n\tvar amount = options.amount !== undefined ? options.amount : 100;\r\n\r\n\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\r\n\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\r\n\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\r\n\r\n\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\r\n\r\n\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\r\n\r\n\tvar steps = options.steps !== undefined ? options.steps : 1;\r\n\r\n\tvar extrudePath = options.extrudePath;\r\n\tvar extrudePts, extrudeByPath = false;\r\n\r\n\tvar material = options.material;\r\n\tvar extrudeMaterial = options.extrudeMaterial;\r\n\r\n\t// Use default WorldUVGenerator if no UV generators are specified.\r\n\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;\r\n\r\n\tvar shapebb = this.shapebb;\r\n\t//shapebb = shape.getBoundingBox();\r\n\r\n\r\n\r\n\tvar splineTube, binormal, normal, position2;\r\n\tif ( extrudePath ) {\r\n\r\n\t\textrudePts = extrudePath.getSpacedPoints( steps );\r\n\r\n\t\textrudeByPath = true;\r\n\t\tbevelEnabled = false; // bevels not supported for path extrusion\r\n\r\n\t\t// SETUP TNB variables\r\n\r\n\t\t// Reuse TNB from TubeGeomtry for now.\r\n\t\t// TODO1 - have a .isClosed in spline?\r\n\r\n\t\tsplineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath, steps, false);\r\n\r\n\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\r\n\r\n\t\tbinormal = new THREE.Vector3();\r\n\t\tnormal = new THREE.Vector3();\r\n\t\tposition2 = new THREE.Vector3();\r\n\r\n\t}\r\n\r\n\t// Safeguards if bevels are not enabled\r\n\r\n\tif ( ! bevelEnabled ) {\r\n\r\n\t\tbevelSegments = 0;\r\n\t\tbevelThickness = 0;\r\n\t\tbevelSize = 0;\r\n\r\n\t}\r\n\r\n\t// Variables initalization\r\n\r\n\tvar ahole, h, hl; // looping of holes\r\n\tvar scope = this;\r\n\tvar bevelPoints = [];\r\n\r\n\tvar shapesOffset = this.vertices.length;\r\n\r\n\tvar shapePoints = shape.extractPoints( curveSegments );\r\n\r\n\tvar vertices = shapePoints.shape;\r\n\tvar holes = shapePoints.holes;\r\n\r\n\tvar reverse = !THREE.Shape.Utils.isClockWise( vertices ) ;\r\n\r\n\tif ( reverse ) {\r\n\r\n\t\tvertices = vertices.reverse();\r\n\r\n\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\r\n\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\tahole = holes[ h ];\r\n\r\n\t\t\tif ( THREE.Shape.Utils.isClockWise( ahole ) ) {\r\n\r\n\t\t\t\tholes[ h ] = ahole.reverse();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!\r\n\r\n\t}\r\n\r\n\r\n\tvar faces = THREE.Shape.Utils.triangulateShape ( vertices, holes );\r\n\r\n\t/* Vertices */\r\n\r\n\tvar contour = vertices; // vertices has all points but contour has only points of circumference\r\n\r\n\tfor ( h = 0, hl = holes.length;  h < hl; h ++ ) {\r\n\r\n\t\tahole = holes[ h ];\r\n\r\n\t\tvertices = vertices.concat( ahole );\r\n\r\n\t}\r\n\r\n\r\n\tfunction scalePt2 ( pt, vec, size ) {\r\n\r\n\t\tif ( !vec ) console.log( \"die\" );\r\n\r\n\t\treturn vec.clone().multiplyScalar( size ).add( pt );\r\n\r\n\t}\r\n\r\n\tvar b, bs, t, z,\r\n\t\tvert, vlen = vertices.length,\r\n\t\tface, flen = faces.length,\r\n\t\tcont, clen = contour.length;\r\n\r\n\r\n\t// Find directions for point movement\r\n\r\n\tvar RAD_TO_DEGREES = 180 / Math.PI;\r\n\r\n\r\n\tfunction getBevelVec( pt_i, pt_j, pt_k ) {\r\n\r\n\t\t// Algorithm 2\r\n\r\n\t\treturn getBevelVec2( pt_i, pt_j, pt_k );\r\n\r\n\t}\r\n\r\n\tfunction getBevelVec1( pt_i, pt_j, pt_k ) {\r\n\r\n\t\tvar anglea = Math.atan2( pt_j.y - pt_i.y, pt_j.x - pt_i.x );\r\n\t\tvar angleb = Math.atan2( pt_k.y - pt_i.y, pt_k.x - pt_i.x );\r\n\r\n\t\tif ( anglea > angleb ) {\r\n\r\n\t\t\tangleb += Math.PI * 2;\r\n\r\n\t\t}\r\n\r\n\t\tvar anglec = ( anglea + angleb ) / 2;\r\n\r\n\r\n\t\t//console.log('angle1', anglea * RAD_TO_DEGREES,'angle2', angleb * RAD_TO_DEGREES, 'anglec', anglec *RAD_TO_DEGREES);\r\n\r\n\t\tvar x = - Math.cos( anglec );\r\n\t\tvar y = - Math.sin( anglec );\r\n\r\n\t\tvar vec = new THREE.Vector2( x, y ); //.normalize();\r\n\r\n\t\treturn vec;\r\n\r\n\t}\r\n\r\n\tfunction getBevelVec2( pt_i, pt_j, pt_k ) {\r\n\r\n\t\tvar a = THREE.ExtrudeGeometry.__v1,\r\n\t\t\tb = THREE.ExtrudeGeometry.__v2,\r\n\t\t\tv_hat = THREE.ExtrudeGeometry.__v3,\r\n\t\t\tw_hat = THREE.ExtrudeGeometry.__v4,\r\n\t\t\tp = THREE.ExtrudeGeometry.__v5,\r\n\t\t\tq = THREE.ExtrudeGeometry.__v6,\r\n\t\t\tv, w,\r\n\t\t\tv_dot_w_hat, q_sub_p_dot_w_hat,\r\n\t\t\ts, intersection;\r\n\r\n\t\t// good reading for line-line intersection\r\n\t\t// http://sputsoft.com/blog/2010/03/line-line-intersection.html\r\n\r\n\t\t// define a as vector j->i\r\n\t\t// define b as vectot k->i\r\n\r\n\t\ta.set( pt_i.x - pt_j.x, pt_i.y - pt_j.y );\r\n\t\tb.set( pt_i.x - pt_k.x, pt_i.y - pt_k.y );\r\n\r\n\t\t// get unit vectors\r\n\r\n\t\tv = a.normalize();\r\n\t\tw = b.normalize();\r\n\r\n\t\t// normals from pt i\r\n\r\n\t\tv_hat.set( -v.y, v.x );\r\n\t\tw_hat.set( w.y, -w.x );\r\n\r\n\t\t// pts from i\r\n\r\n\t\tp.copy( pt_i ).add( v_hat );\r\n\t\tq.copy( pt_i ).add( w_hat );\r\n\r\n\t\tif ( p.equals( q ) ) {\r\n\r\n\t\t\t//console.log(\"Warning: lines are straight\");\r\n\t\t\treturn w_hat.clone();\r\n\r\n\t\t}\r\n\r\n\t\t// Points from j, k. helps prevents points cross overover most of the time\r\n\r\n\t\tp.copy( pt_j ).add( v_hat );\r\n\t\tq.copy( pt_k ).add( w_hat );\r\n\r\n\t\tv_dot_w_hat = v.dot( w_hat );\r\n\t\tq_sub_p_dot_w_hat = q.sub( p ).dot( w_hat );\r\n\r\n\t\t// We should not reach these conditions\r\n\r\n\t\tif ( v_dot_w_hat === 0 ) {\r\n\r\n\t\t\tconsole.log( \"Either infinite or no solutions!\" );\r\n\r\n\t\t\tif ( q_sub_p_dot_w_hat === 0 ) {\r\n\r\n\t\t\t\tconsole.log( \"Its finite solutions.\" );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.log( \"Too bad, no solutions.\" );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\ts = q_sub_p_dot_w_hat / v_dot_w_hat;\r\n\r\n\t\tif ( s < 0 ) {\r\n\r\n\t\t\t// in case of emergecy, revert to algorithm 1.\r\n\r\n\t\t\treturn getBevelVec1( pt_i, pt_j, pt_k );\r\n\r\n\t\t}\r\n\r\n\t\tintersection = v.multiplyScalar( s ).add( p );\r\n\r\n\t\treturn intersection.sub( pt_i ).clone(); // Don't normalize!, otherwise sharp corners become ugly\r\n\r\n\t}\r\n\r\n\tvar contourMovements = [];\r\n\r\n\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\r\n\r\n\t\tif ( j === il ) j = 0;\r\n\t\tif ( k === il ) k = 0;\r\n\r\n\t\t//  (j)---(i)---(k)\r\n\t\t// console.log('i,j,k', i, j , k)\r\n\r\n\t\tvar pt_i = contour[ i ];\r\n\t\tvar pt_j = contour[ j ];\r\n\t\tvar pt_k = contour[ k ];\r\n\r\n\t\tcontourMovements[ i ]= getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\r\n\r\n\t}\r\n\r\n\tvar holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();\r\n\r\n\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\tahole = holes[ h ];\r\n\r\n\t\toneHoleMovements = [];\r\n\r\n\t\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\r\n\r\n\t\t\tif ( j === il ) j = 0;\r\n\t\t\tif ( k === il ) k = 0;\r\n\r\n\t\t\t//  (j)---(i)---(k)\r\n\t\t\toneHoleMovements[ i ]= getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\r\n\r\n\t\t}\r\n\r\n\t\tholesMovements.push( oneHoleMovements );\r\n\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\r\n\r\n\t}\r\n\r\n\r\n\t// Loop bevelSegments, 1 for the front, 1 for the back\r\n\r\n\tfor ( b = 0; b < bevelSegments; b ++ ) {\r\n\t//for ( b = bevelSegments; b > 0; b -- ) {\r\n\r\n\t\tt = b / bevelSegments;\r\n\t\tz = bevelThickness * ( 1 - t );\r\n\r\n\t\t//z = bevelThickness * t;\r\n\t\tbs = bevelSize * ( Math.sin ( t * Math.PI/2 ) ) ; // curved\r\n\t\t//bs = bevelSize * t ; // linear\r\n\r\n\t\t// contract shape\r\n\r\n\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\r\n\r\n\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\r\n\t\t\t//vert = scalePt( contour[ i ], contourCentroid, bs, false );\r\n\t\t\tv( vert.x, vert.y,  - z );\r\n\r\n\t\t}\r\n\r\n\t\t// expand holes\r\n\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h++ ) {\r\n\r\n\t\t\tahole = holes[ h ];\r\n\t\t\toneHoleMovements = holesMovements[ h ];\r\n\r\n\t\t\tfor ( i = 0, il = ahole.length; i < il; i++ ) {\r\n\r\n\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\r\n\t\t\t\t//vert = scalePt( ahole[ i ], holesCentroids[ h ], bs, true );\r\n\r\n\t\t\t\tv( vert.x, vert.y,  -z );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tbs = bevelSize;\r\n\r\n\t// Back facing vertices\r\n\r\n\tfor ( i = 0; i < vlen; i ++ ) {\r\n\r\n\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\r\n\r\n\t\tif ( !extrudeByPath ) {\r\n\r\n\t\t\tv( vert.x, vert.y, 0 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\r\n\r\n\t\t\tnormal.copy( splineTube.normals[0] ).multiplyScalar(vert.x);\r\n\t\t\tbinormal.copy( splineTube.binormals[0] ).multiplyScalar(vert.y);\r\n\r\n\t\t\tposition2.copy( extrudePts[0] ).add(normal).add(binormal);\r\n\r\n\t\t\tv( position2.x, position2.y, position2.z );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Add stepped vertices...\r\n\t// Including front facing vertices\r\n\r\n\tvar s;\r\n\r\n\tfor ( s = 1; s <= steps; s ++ ) {\r\n\r\n\t\tfor ( i = 0; i < vlen; i ++ ) {\r\n\r\n\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\r\n\r\n\t\t\tif ( !extrudeByPath ) {\r\n\r\n\t\t\t\tv( vert.x, vert.y, amount / steps * s );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\r\n\r\n\t\t\t\tnormal.copy( splineTube.normals[s] ).multiplyScalar( vert.x );\r\n\t\t\t\tbinormal.copy( splineTube.binormals[s] ).multiplyScalar( vert.y );\r\n\r\n\t\t\t\tposition2.copy( extrudePts[s] ).add( normal ).add( binormal );\r\n\r\n\t\t\t\tv( position2.x, position2.y, position2.z );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\t// Add bevel segments planes\r\n\r\n\t//for ( b = 1; b <= bevelSegments; b ++ ) {\r\n\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\r\n\r\n\t\tt = b / bevelSegments;\r\n\t\tz = bevelThickness * ( 1 - t );\r\n\t\t//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );\r\n\t\tbs = bevelSize * Math.sin ( t * Math.PI/2 ) ;\r\n\r\n\t\t// contract shape\r\n\r\n\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\r\n\r\n\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\r\n\t\t\tv( vert.x, vert.y,  amount + z );\r\n\r\n\t\t}\r\n\r\n\t\t// expand holes\r\n\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\tahole = holes[ h ];\r\n\t\t\toneHoleMovements = holesMovements[ h ];\r\n\r\n\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\r\n\r\n\t\t\t\tif ( !extrudeByPath ) {\r\n\r\n\t\t\t\t\tv( vert.x, vert.y,  amount + z );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/* Faces */\r\n\r\n\t// Top and bottom faces\r\n\r\n\tbuildLidFaces();\r\n\r\n\t// Sides faces\r\n\r\n\tbuildSideFaces();\r\n\r\n\r\n\t/////  Internal functions\r\n\r\n\tfunction buildLidFaces() {\r\n\r\n\t\tif ( bevelEnabled ) {\r\n\r\n\t\t\tvar layer = 0 ; // steps + 1\r\n\t\t\tvar offset = vlen * layer;\r\n\r\n\t\t\t// Bottom faces\r\n\r\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\tface = faces[ i ];\r\n\t\t\t\tf3( face[ 2 ]+ offset, face[ 1 ]+ offset, face[ 0 ] + offset, true );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlayer = steps + bevelSegments * 2;\r\n\t\t\toffset = vlen * layer;\r\n\r\n\t\t\t// Top faces\r\n\r\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\tface = faces[ i ];\r\n\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset, false );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// Bottom faces\r\n\r\n\t\t\tfor ( i = 0; i < flen; i++ ) {\r\n\r\n\t\t\t\tface = faces[ i ];\r\n\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ], true );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Top faces\r\n\r\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\tface = faces[ i ];\r\n\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps, false );\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Create faces for the z-sides of the shape\r\n\r\n\tfunction buildSideFaces() {\r\n\r\n\t\tvar layeroffset = 0;\r\n\t\tsidewalls( contour, layeroffset );\r\n\t\tlayeroffset += contour.length;\r\n\r\n\t\tfor ( h = 0, hl = holes.length;  h < hl; h ++ ) {\r\n\r\n\t\t\tahole = holes[ h ];\r\n\t\t\tsidewalls( ahole, layeroffset );\r\n\r\n\t\t\t//, true\r\n\t\t\tlayeroffset += ahole.length;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction sidewalls( contour, layeroffset ) {\r\n\r\n\t\tvar j, k;\r\n\t\ti = contour.length;\r\n\r\n\t\twhile ( --i >= 0 ) {\r\n\r\n\t\t\tj = i;\r\n\t\t\tk = i - 1;\r\n\t\t\tif ( k < 0 ) k = contour.length - 1;\r\n\r\n\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\r\n\r\n\t\t\tvar s = 0, sl = steps  + bevelSegments * 2;\r\n\r\n\t\t\tfor ( s = 0; s < sl; s ++ ) {\r\n\r\n\t\t\t\tvar slen1 = vlen * s;\r\n\t\t\t\tvar slen2 = vlen * ( s + 1 );\r\n\r\n\t\t\t\tvar a = layeroffset + j + slen1,\r\n\t\t\t\t\tb = layeroffset + k + slen1,\r\n\t\t\t\t\tc = layeroffset + k + slen2,\r\n\t\t\t\t\td = layeroffset + j + slen2;\r\n\r\n\t\t\t\tf4( a, b, c, d, contour, s, sl, j, k );\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\tfunction v( x, y, z ) {\r\n\r\n\t\tscope.vertices.push( new THREE.Vector3( x, y, z ) );\r\n\r\n\t}\r\n\r\n\tfunction f3( a, b, c, isBottom ) {\r\n\r\n\t\ta += shapesOffset;\r\n\t\tb += shapesOffset;\r\n\t\tc += shapesOffset;\r\n\r\n\t\t// normal, color, material\r\n\t\tscope.faces.push( new THREE.Face3( a, b, c, null, null, material ) );\r\n\r\n\t\tvar uvs = isBottom ? uvgen.generateBottomUV( scope, shape, options, a, b, c ) : uvgen.generateTopUV( scope, shape, options, a, b, c );\r\n\r\n \t\tscope.faceVertexUvs[ 0 ].push( uvs );\r\n\r\n\t}\r\n\r\n\tfunction f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {\r\n\r\n\t\ta += shapesOffset;\r\n\t\tb += shapesOffset;\r\n\t\tc += shapesOffset;\r\n\t\td += shapesOffset;\r\n\r\n \t\tscope.faces.push( new THREE.Face4( a, b, c, d, null, null, extrudeMaterial ) );\r\n\r\n \t\tvar uvs = uvgen.generateSideWallUV( scope, shape, wallContour, options, a, b, c, d,\r\n \t\t                                    stepIndex, stepsLength, contourIndex1, contourIndex2 );\r\n \t\tscope.faceVertexUvs[ 0 ].push( uvs );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.ExtrudeGeometry.WorldUVGenerator = {\r\n\r\n\tgenerateTopUV: function( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC ) {\r\n\t\tvar ax = geometry.vertices[ indexA ].x,\r\n\t\t\tay = geometry.vertices[ indexA ].y,\r\n\r\n\t\t\tbx = geometry.vertices[ indexB ].x,\r\n\t\t\tby = geometry.vertices[ indexB ].y,\r\n\r\n\t\t\tcx = geometry.vertices[ indexC ].x,\r\n\t\t\tcy = geometry.vertices[ indexC ].y;\r\n\r\n\t\treturn [\r\n\t\t\tnew THREE.Vector2( ax, ay ),\r\n\t\t\tnew THREE.Vector2( bx, by ),\r\n\t\t\tnew THREE.Vector2( cx, cy )\r\n\t\t];\r\n\r\n\t},\r\n\r\n\tgenerateBottomUV: function( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC ) {\r\n\r\n\t\treturn this.generateTopUV( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC );\r\n\r\n\t},\r\n\r\n\tgenerateSideWallUV: function( geometry, extrudedShape, wallContour, extrudeOptions,\r\n\t                              indexA, indexB, indexC, indexD, stepIndex, stepsLength,\r\n\t                              contourIndex1, contourIndex2 ) {\r\n\r\n\t\tvar ax = geometry.vertices[ indexA ].x,\r\n\t\t\tay = geometry.vertices[ indexA ].y,\r\n\t\t\taz = geometry.vertices[ indexA ].z,\r\n\r\n\t\t\tbx = geometry.vertices[ indexB ].x,\r\n\t\t\tby = geometry.vertices[ indexB ].y,\r\n\t\t\tbz = geometry.vertices[ indexB ].z,\r\n\r\n\t\t\tcx = geometry.vertices[ indexC ].x,\r\n\t\t\tcy = geometry.vertices[ indexC ].y,\r\n\t\t\tcz = geometry.vertices[ indexC ].z,\r\n\r\n\t\t\tdx = geometry.vertices[ indexD ].x,\r\n\t\t\tdy = geometry.vertices[ indexD ].y,\r\n\t\t\tdz = geometry.vertices[ indexD ].z;\r\n\r\n\t\tif ( Math.abs( ay - by ) < 0.01 ) {\r\n\t\t\treturn [\r\n\t\t\t\tnew THREE.Vector2( ax, 1 - az ),\r\n\t\t\t\tnew THREE.Vector2( bx, 1 - bz ),\r\n\t\t\t\tnew THREE.Vector2( cx, 1 - cz ),\r\n\t\t\t\tnew THREE.Vector2( dx, 1 - dz )\r\n\t\t\t];\r\n\t\t} else {\r\n\t\t\treturn [\r\n\t\t\t\tnew THREE.Vector2( ay, 1 - az ),\r\n\t\t\t\tnew THREE.Vector2( by, 1 - bz ),\r\n\t\t\t\tnew THREE.Vector2( cy, 1 - cz ),\r\n\t\t\t\tnew THREE.Vector2( dy, 1 - dz )\r\n\t\t\t];\r\n\t\t}\r\n\t}\r\n};\r\n\r\nTHREE.ExtrudeGeometry.__v1 = new THREE.Vector2();\r\nTHREE.ExtrudeGeometry.__v2 = new THREE.Vector2();\r\nTHREE.ExtrudeGeometry.__v3 = new THREE.Vector2();\r\nTHREE.ExtrudeGeometry.__v4 = new THREE.Vector2();\r\nTHREE.ExtrudeGeometry.__v5 = new THREE.Vector2();\r\nTHREE.ExtrudeGeometry.__v6 = new THREE.Vector2();\r\n/**\r\n * @author jonobr1 / http://jonobr1.com\r\n *\r\n * Creates a one-sided polygonal geometry from a path shape. Similar to\r\n * ExtrudeGeometry.\r\n *\r\n * parameters = {\r\n *\r\n *\tcurveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.\r\n *\r\n *\tmaterial: <int> // material index for front and back faces\r\n *\tuvGenerator: <Object> // object that provides UV generator functions\r\n *\r\n * }\r\n **/\r\n\r\nTHREE.ShapeGeometry = function ( shapes, options ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tif ( shapes instanceof Array === false ) shapes = [ shapes ];\r\n\r\n\tthis.shapebb = shapes[ shapes.length - 1 ].getBoundingBox();\r\n\r\n\tthis.addShapeList( shapes, options );\r\n\r\n\tthis.computeCentroids();\r\n\tthis.computeFaceNormals();\r\n\r\n};\r\n\r\nTHREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\r\n/**\r\n * Add an array of shapes to THREE.ShapeGeometry.\r\n */\r\nTHREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {\r\n\r\n\tfor ( var i = 0, l = shapes.length; i < l; i++ ) {\r\n\r\n\t\tthis.addShape( shapes[ i ], options );\r\n\r\n\t}\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n/**\r\n * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.\r\n */\r\nTHREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {\r\n\r\n\tif ( options === undefined ) options = {};\r\n\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\r\n\r\n\tvar material = options.material;\r\n\tvar uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;\r\n\r\n\tvar shapebb = this.shapebb;\r\n\r\n\t//\r\n\r\n\tvar i, l, hole, s;\r\n\r\n\tvar shapesOffset = this.vertices.length;\r\n\tvar shapePoints = shape.extractPoints( curveSegments );\r\n\r\n\tvar vertices = shapePoints.shape;\r\n\tvar holes = shapePoints.holes;\r\n\r\n\tvar reverse = !THREE.Shape.Utils.isClockWise( vertices );\r\n\r\n\tif ( reverse ) {\r\n\r\n\t\tvertices = vertices.reverse();\r\n\r\n\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe...\r\n\r\n\t\tfor ( i = 0, l = holes.length; i < l; i++ ) {\r\n\r\n\t\t\thole = holes[ i ];\r\n\r\n\t\t\tif ( THREE.Shape.Utils.isClockWise( hole ) ) {\r\n\r\n\t\t\t\tholes[ i ] = hole.reverse();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treverse = false;\r\n\r\n\t}\r\n\r\n\tvar faces = THREE.Shape.Utils.triangulateShape( vertices, holes );\r\n\r\n\t// Vertices\r\n\r\n\tvar contour = vertices;\r\n\r\n\tfor ( i = 0, l = holes.length; i < l; i++ ) {\r\n\r\n\t\thole = holes[ i ];\r\n\t\tvertices = vertices.concat( hole );\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tvar vert, vlen = vertices.length;\r\n\tvar face, flen = faces.length;\r\n\tvar cont, clen = contour.length;\r\n\r\n\tfor ( i = 0; i < vlen; i++ ) {\r\n\r\n\t\tvert = vertices[ i ];\r\n\r\n\t\tthis.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );\r\n\r\n\t}\r\n\r\n\tfor ( i = 0; i < flen; i++ ) {\r\n\r\n\t\tface = faces[ i ];\r\n\r\n\t\tvar a = face[ 0 ] + shapesOffset;\r\n\t\tvar b = face[ 1 ] + shapesOffset;\r\n\t\tvar c = face[ 2 ] + shapesOffset;\r\n\r\n\t\tthis.faces.push( new THREE.Face3( a, b, c, null, null, material ) );\r\n\t\tthis.faceVertexUvs[ 0 ].push( uvgen.generateBottomUV( this, shape, options, a, b, c ) );\r\n\r\n\t}\r\n\r\n};\r\n/**\r\n * @author astrodud / http://astrodud.isgreat.org/\r\n * @author zz85 / https://github.com/zz85\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\n// points - to create a closed torus, one must use a set of points \r\n//    like so: [ a, b, c, d, a ], see first is the same as last.\r\n// segments - the number of circumference segments to create\r\n// phiStart - the starting radian\r\n// phiLength - the radian (0 to 2*PI) range of the lathed section\r\n//    2*pi is a closed lathe, less than 2PI is a portion.\r\nTHREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tsegments = segments || 12;\r\n\tphiStart = phiStart || 0;\r\n\tphiLength = phiLength || 2 * Math.PI;\r\n\r\n\tvar inversePointLength = 1.0 / ( points.length - 1 );\r\n\tvar inverseSegments = 1.0 / segments;\r\n\r\n\tfor ( var i = 0, il = segments; i <= il; i ++ ) {\r\n\r\n\t\tvar phi = phiStart + i * inverseSegments * phiLength;\r\n\r\n\t\tvar c = Math.cos( phi ),\r\n\t\t\ts = Math.sin( phi );\r\n\r\n\t\tfor ( var j = 0, jl = points.length; j < jl; j ++ ) {\r\n\r\n\t\t\tvar pt = points[ j ];\r\n\r\n\t\t\tvar vertex = new THREE.Vector3();\r\n\r\n\t\t\tvertex.x = c * pt.x - s * pt.y;\r\n\t\t\tvertex.y = s * pt.x + c * pt.y;\r\n\t\t\tvertex.z = pt.z;\r\n\r\n\t\t\tthis.vertices.push( vertex );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tvar np = points.length;\r\n\r\n\tfor ( var i = 0, il = segments; i < il; i ++ ) {\r\n\r\n\t\tfor ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {\r\n\r\n\t\t\tvar base = j + np * i;\r\n\t\t\tvar a = base;\r\n\t\t\tvar b = base + np;\r\n\t\t\tvar c = base + 1 + np;\r\n\t\t\tvar d = base + 1;\r\n\r\n\t\t\tthis.faces.push( new THREE.Face4( a, b, c, d ) );\r\n\r\n\t\t\tvar u0 = i * inverseSegments;\r\n\t\t\tvar v0 = j * inversePointLength;\r\n\t\t\tvar u1 = u0 + inverseSegments;\r\n\t\t\tvar v1 = v0 + inversePointLength;\r\n\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [\r\n\r\n\t\t\t\tnew THREE.Vector2( u0, v0 ), \r\n\t\t\t\tnew THREE.Vector2( u1, v0 ),\r\n\t\t\t\tnew THREE.Vector2( u1, v1 ),\r\n\t\t\t\tnew THREE.Vector2( u0, v1 )\r\n\r\n\t\t\t] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.mergeVertices();\r\n\tthis.computeCentroids();\r\n\tthis.computeFaceNormals();\r\n\tthis.computeVertexNormals();\r\n\r\n};\r\n\r\nTHREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\r\n */\r\n\r\nTHREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.width = width;\r\n\tthis.height = height;\r\n\r\n\tthis.widthSegments = widthSegments || 1;\r\n\tthis.heightSegments = heightSegments || 1;\r\n\r\n\tvar ix, iz;\r\n\tvar width_half = width / 2;\r\n\tvar height_half = height / 2;\r\n\r\n\tvar gridX = this.widthSegments;\r\n\tvar gridZ = this.heightSegments;\r\n\r\n\tvar gridX1 = gridX + 1;\r\n\tvar gridZ1 = gridZ + 1;\r\n\r\n\tvar segment_width = this.width / gridX;\r\n\tvar segment_height = this.height / gridZ;\r\n\r\n\tvar normal = new THREE.Vector3( 0, 0, 1 );\r\n\r\n\tfor ( iz = 0; iz < gridZ1; iz ++ ) {\r\n\r\n\t\tfor ( ix = 0; ix < gridX1; ix ++ ) {\r\n\r\n\t\t\tvar x = ix * segment_width - width_half;\r\n\t\t\tvar y = iz * segment_height - height_half;\r\n\r\n\t\t\tthis.vertices.push( new THREE.Vector3( x, - y, 0 ) );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfor ( iz = 0; iz < gridZ; iz ++ ) {\r\n\r\n\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\r\n\r\n\t\t\tvar a = ix + gridX1 * iz;\r\n\t\t\tvar b = ix + gridX1 * ( iz + 1 );\r\n\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iz + 1 );\r\n\t\t\tvar d = ( ix + 1 ) + gridX1 * iz;\r\n\r\n\t\t\tvar face = new THREE.Face4( a, b, c, d );\r\n\t\t\tface.normal.copy( normal );\r\n\t\t\tface.vertexNormals.push( normal.clone(), normal.clone(), normal.clone(), normal.clone() );\r\n\r\n\t\t\tthis.faces.push( face );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [\r\n\t\t\t\tnew THREE.Vector2( ix / gridX, 1 - iz / gridZ ),\r\n\t\t\t\tnew THREE.Vector2( ix / gridX, 1 - ( iz + 1 ) / gridZ ),\r\n\t\t\t\tnew THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iz + 1 ) / gridZ ),\r\n\t\t\t\tnew THREE.Vector2( ( ix + 1 ) / gridX, 1 - iz / gridZ )\r\n\t\t\t] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.computeCentroids();\r\n\r\n};\r\n\r\nTHREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.radius = radius || 50;\r\n\r\n\tthis.widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\r\n\tthis.heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\r\n\r\n\tphiStart = phiStart !== undefined ? phiStart : 0;\r\n\tphiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\r\n\r\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\r\n\r\n\tvar x, y, vertices = [], uvs = [];\r\n\r\n\tfor ( y = 0; y <= this.heightSegments; y ++ ) {\r\n\r\n\t\tvar verticesRow = [];\r\n\t\tvar uvsRow = [];\r\n\r\n\t\tfor ( x = 0; x <= this.widthSegments; x ++ ) {\r\n\r\n\t\t\tvar u = x / this.widthSegments;\r\n\t\t\tvar v = y / this.heightSegments;\r\n\r\n\t\t\tvar vertex = new THREE.Vector3();\r\n\t\t\tvertex.x = - this.radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\r\n\t\t\tvertex.y = this.radius * Math.cos( thetaStart + v * thetaLength );\r\n\t\t\tvertex.z = this.radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\r\n\r\n\t\t\tthis.vertices.push( vertex );\r\n\r\n\t\t\tverticesRow.push( this.vertices.length - 1 );\r\n\t\t\tuvsRow.push( new THREE.Vector2( u, 1 - v ) );\r\n\r\n\t\t}\r\n\r\n\t\tvertices.push( verticesRow );\r\n\t\tuvs.push( uvsRow );\r\n\r\n\t}\r\n\r\n\tfor ( y = 0; y < this.heightSegments; y ++ ) {\r\n\r\n\t\tfor ( x = 0; x < this.widthSegments; x ++ ) {\r\n\r\n\t\t\tvar v1 = vertices[ y ][ x + 1 ];\r\n\t\t\tvar v2 = vertices[ y ][ x ];\r\n\t\t\tvar v3 = vertices[ y + 1 ][ x ];\r\n\t\t\tvar v4 = vertices[ y + 1 ][ x + 1 ];\r\n\r\n\t\t\tvar n1 = this.vertices[ v1 ].clone().normalize();\r\n\t\t\tvar n2 = this.vertices[ v2 ].clone().normalize();\r\n\t\t\tvar n3 = this.vertices[ v3 ].clone().normalize();\r\n\t\t\tvar n4 = this.vertices[ v4 ].clone().normalize();\r\n\r\n\t\t\tvar uv1 = uvs[ y ][ x + 1 ].clone();\r\n\t\t\tvar uv2 = uvs[ y ][ x ].clone();\r\n\t\t\tvar uv3 = uvs[ y + 1 ][ x ].clone();\r\n\t\t\tvar uv4 = uvs[ y + 1 ][ x + 1 ].clone();\r\n\r\n\t\t\tif ( Math.abs( this.vertices[ v1 ].y ) === this.radius ) {\r\n\r\n\t\t\t\tthis.faces.push( new THREE.Face3( v1, v3, v4, [ n1, n3, n4 ] ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv3, uv4 ] );\r\n\r\n\t\t\t} else if ( Math.abs( this.vertices[ v3 ].y ) === this.radius ) {\r\n\r\n\t\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.faces.push( new THREE.Face4( v1, v2, v3, v4, [ n1, n2, n3, n4 ] ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3, uv4 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.computeCentroids();\r\n\tthis.computeFaceNormals();\r\n\r\n    this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\r\n};\r\n\r\nTHREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * For creating 3D text geometry in three.js\r\n *\r\n * Text = 3D Text\r\n *\r\n * parameters = {\r\n *  size: \t\t\t<float>, \t// size of the text\r\n *  height: \t\t<float>, \t// thickness to extrude text\r\n *  curveSegments: \t<int>,\t\t// number of points on the curves\r\n *\r\n *  font: \t\t\t<string>,\t\t// font name\r\n *  weight: \t\t<string>,\t\t// font weight (normal, bold)\r\n *  style: \t\t\t<string>,\t\t// font style  (normal, italics)\r\n *\r\n *  bevelEnabled:\t<bool>,\t\t\t// turn on bevel\r\n *  bevelThickness: <float>, \t\t// how deep into text bevel goes\r\n *  bevelSize:\t\t<float>, \t\t// how far from text outline is bevel\r\n *  }\r\n *\r\n */\r\n\r\n/*\tUsage Examples\r\n\r\n\t// TextGeometry wrapper\r\n\r\n\tvar text3d = new TextGeometry( text, options );\r\n\r\n\t// Complete manner\r\n\r\n\tvar textShapes = THREE.FontUtils.generateShapes( text, options );\r\n\tvar text3d = new ExtrudeGeometry( textShapes, options );\r\n\r\n*/\r\n\r\n\r\nTHREE.TextGeometry = function ( text, parameters ) {\r\n\r\n\tvar textShapes = THREE.FontUtils.generateShapes( text, parameters );\r\n\r\n\t// translate parameters to ExtrudeGeometry API\r\n\r\n\tparameters.amount = parameters.height !== undefined ? parameters.height : 50;\r\n\r\n\t// defaults\r\n\r\n\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\r\n\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\r\n\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\r\n\r\n\tTHREE.ExtrudeGeometry.call( this, textShapes, parameters );\r\n\r\n};\r\n\r\nTHREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );\r\n/**\r\n * @author oosmoxiecode\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888\r\n */\r\n\r\nTHREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tvar scope = this;\r\n\r\n\tthis.radius = radius || 100;\r\n\tthis.tube = tube || 40;\r\n\tthis.radialSegments = radialSegments || 8;\r\n\tthis.tubularSegments = tubularSegments || 6;\r\n\tthis.arc = arc || Math.PI * 2;\r\n\r\n\tvar center = new THREE.Vector3(), uvs = [], normals = [];\r\n\r\n\tfor ( var j = 0; j <= this.radialSegments; j ++ ) {\r\n\r\n\t\tfor ( var i = 0; i <= this.tubularSegments; i ++ ) {\r\n\r\n\t\t\tvar u = i / this.tubularSegments * this.arc;\r\n\t\t\tvar v = j / this.radialSegments * Math.PI * 2;\r\n\r\n\t\t\tcenter.x = this.radius * Math.cos( u );\r\n\t\t\tcenter.y = this.radius * Math.sin( u );\r\n\r\n\t\t\tvar vertex = new THREE.Vector3();\r\n\t\t\tvertex.x = ( this.radius + this.tube * Math.cos( v ) ) * Math.cos( u );\r\n\t\t\tvertex.y = ( this.radius + this.tube * Math.cos( v ) ) * Math.sin( u );\r\n\t\t\tvertex.z = this.tube * Math.sin( v );\r\n\r\n\t\t\tthis.vertices.push( vertex );\r\n\r\n\t\t\tuvs.push( new THREE.Vector2( i / this.tubularSegments, j / this.radialSegments ) );\r\n\t\t\tnormals.push( vertex.clone().sub( center ).normalize() );\r\n\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tfor ( var j = 1; j <= this.radialSegments; j ++ ) {\r\n\r\n\t\tfor ( var i = 1; i <= this.tubularSegments; i ++ ) {\r\n\r\n\t\t\tvar a = ( this.tubularSegments + 1 ) * j + i - 1;\r\n\t\t\tvar b = ( this.tubularSegments + 1 ) * ( j - 1 ) + i - 1;\r\n\t\t\tvar c = ( this.tubularSegments + 1 ) * ( j - 1 ) + i;\r\n\t\t\tvar d = ( this.tubularSegments + 1 ) * j + i;\r\n\r\n\t\t\tvar face = new THREE.Face4( a, b, c, d, [ normals[ a ], normals[ b ], normals[ c ], normals[ d ] ] );\r\n\t\t\tface.normal.add( normals[ a ] );\r\n\t\t\tface.normal.add( normals[ b ] );\r\n\t\t\tface.normal.add( normals[ c ] );\r\n\t\t\tface.normal.add( normals[ d ] );\r\n\t\t\tface.normal.normalize();\r\n\r\n\t\t\tthis.faces.push( face );\r\n\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.computeCentroids();\r\n\r\n};\r\n\r\nTHREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n/**\r\n * @author oosmoxiecode\r\n * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\r\n */\r\n\r\nTHREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tvar scope = this;\r\n\r\n\tthis.radius = radius || 100;\r\n\tthis.tube = tube || 40;\r\n\tthis.radialSegments = radialSegments || 64;\r\n\tthis.tubularSegments = tubularSegments || 8;\r\n\tthis.p = p || 2;\r\n\tthis.q = q || 3;\r\n\tthis.heightScale = heightScale || 1;\r\n\tthis.grid = new Array( this.radialSegments );\r\n\r\n\tvar tang = new THREE.Vector3();\r\n\tvar n = new THREE.Vector3();\r\n\tvar bitan = new THREE.Vector3();\r\n\r\n\tfor ( var i = 0; i < this.radialSegments; ++ i ) {\r\n\r\n\t\tthis.grid[ i ] = new Array( this.tubularSegments );\r\n\r\n\t\tfor ( var j = 0; j < this.tubularSegments; ++ j ) {\r\n\r\n\t\t\tvar u = i / this.radialSegments * 2 * this.p * Math.PI;\r\n\t\t\tvar v = j / this.tubularSegments * 2 * Math.PI;\r\n\t\t\tvar p1 = getPos( u, v, this.q, this.p, this.radius, this.heightScale );\r\n\t\t\tvar p2 = getPos( u + 0.01, v, this.q, this.p, this.radius, this.heightScale );\r\n\t\t\tvar cx, cy;\r\n\r\n\t\t\ttang.subVectors( p2, p1 );\r\n\t\t\tn.addVectors( p2, p1 );\r\n\r\n\t\t\tbitan.crossVectors( tang, n );\r\n\t\t\tn.crossVectors( bitan, tang );\r\n\t\t\tbitan.normalize();\r\n\t\t\tn.normalize();\r\n\r\n\t\t\tcx = - this.tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\r\n\t\t\tcy = this.tube * Math.sin( v );\r\n\r\n\t\t\tp1.x += cx * n.x + cy * bitan.x;\r\n\t\t\tp1.y += cx * n.y + cy * bitan.y;\r\n\t\t\tp1.z += cx * n.z + cy * bitan.z;\r\n\r\n\t\t\tthis.grid[ i ][ j ] = vert( p1.x, p1.y, p1.z );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfor ( var i = 0; i < this.radialSegments; ++ i ) {\r\n\r\n\t\tfor ( var j = 0; j < this.tubularSegments; ++ j ) {\r\n\r\n\t\t\tvar ip = ( i + 1 ) % this.radialSegments;\r\n\t\t\tvar jp = ( j + 1 ) % this.tubularSegments;\r\n\r\n\t\t\tvar a = this.grid[ i ][ j ];\r\n\t\t\tvar b = this.grid[ ip ][ j ];\r\n\t\t\tvar c = this.grid[ ip ][ jp ];\r\n\t\t\tvar d = this.grid[ i ][ jp ];\r\n\r\n\t\t\tvar uva = new THREE.Vector2( i / this.radialSegments, j / this.tubularSegments );\r\n\t\t\tvar uvb = new THREE.Vector2( ( i + 1 ) / this.radialSegments, j / this.tubularSegments );\r\n\t\t\tvar uvc = new THREE.Vector2( ( i + 1 ) / this.radialSegments, ( j + 1 ) / this.tubularSegments );\r\n\t\t\tvar uvd = new THREE.Vector2( i / this.radialSegments, ( j + 1 ) / this.tubularSegments );\r\n\r\n\t\t\tthis.faces.push( new THREE.Face4( a, b, c, d ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uva,uvb,uvc, uvd ] );\r\n\r\n\t\t}\r\n\t}\r\n\r\n\tthis.computeCentroids();\r\n\tthis.computeFaceNormals();\r\n\tthis.computeVertexNormals();\r\n\r\n\tfunction vert( x, y, z ) {\r\n\r\n\t\treturn scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;\r\n\r\n\t}\r\n\r\n\tfunction getPos( u, v, in_q, in_p, radius, heightScale ) {\r\n\r\n\t\tvar cu = Math.cos( u );\r\n\t\tvar cv = Math.cos( v );\r\n\t\tvar su = Math.sin( u );\r\n\t\tvar quOverP = in_q / in_p * u;\r\n\t\tvar cs = Math.cos( quOverP );\r\n\r\n\t\tvar tx = radius * ( 2 + cs ) * 0.5 * cu;\r\n\t\tvar ty = radius * ( 2 + cs ) * su * 0.5;\r\n\t\tvar tz = heightScale * radius * Math.sin( quOverP ) * 0.5;\r\n\r\n\t\treturn new THREE.Vector3( tx, ty, tz );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n/**\r\n * @author WestLangley / https://github.com/WestLangley\r\n * @author zz85 / https://github.com/zz85\r\n * @author miningold / https://github.com/miningold\r\n *\r\n * Modified from the TorusKnotGeometry by @oosmoxiecode\r\n *\r\n * Creates a tube which extrudes along a 3d spline\r\n *\r\n * Uses parallel transport frames as described in\r\n * http://www.cs.indiana.edu/pub/techreports/TR425.pdf\r\n */\r\n\r\nTHREE.TubeGeometry = function( path, segments, radius, radiusSegments, closed, debug ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.path = path;\r\n\tthis.segments = segments || 64;\r\n\tthis.radius = radius || 1;\r\n\tthis.radiusSegments = radiusSegments || 8;\r\n\tthis.closed = closed || false;\r\n\r\n\tif ( debug ) this.debug = new THREE.Object3D();\r\n\r\n\tthis.grid = [];\r\n\r\n\tvar scope = this,\r\n\r\n\t\ttangent,\r\n\t\tnormal,\r\n\t\tbinormal,\r\n\r\n\t\tnumpoints = this.segments + 1,\r\n\r\n\t\tx, y, z,\r\n\t\ttx, ty, tz,\r\n\t\tu, v,\r\n\r\n\t\tcx, cy,\r\n\t\tpos, pos2 = new THREE.Vector3(),\r\n\t\ti, j,\r\n\t\tip, jp,\r\n\t\ta, b, c, d,\r\n\t\tuva, uvb, uvc, uvd;\r\n\r\n\tvar frames = new THREE.TubeGeometry.FrenetFrames( this.path, this.segments, this.closed ),\r\n\t\ttangents = frames.tangents,\r\n\t\tnormals = frames.normals,\r\n\t\tbinormals = frames.binormals;\r\n\r\n\t// proxy internals\r\n\tthis.tangents = tangents;\r\n\tthis.normals = normals;\r\n\tthis.binormals = binormals;\r\n\r\n\tfunction vert( x, y, z ) {\r\n\r\n\t\treturn scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;\r\n\r\n\t}\r\n\r\n\r\n\t// consruct the grid\r\n\r\n\tfor ( i = 0; i < numpoints; i++ ) {\r\n\r\n\t\tthis.grid[ i ] = [];\r\n\r\n\t\tu = i / ( numpoints - 1 );\r\n\r\n\t\tpos = path.getPointAt( u );\r\n\r\n\t\ttangent = tangents[ i ];\r\n\t\tnormal = normals[ i ];\r\n\t\tbinormal = binormals[ i ];\r\n\r\n\t\tif ( this.debug ) {\r\n\r\n\t\t\tthis.debug.add( new THREE.ArrowHelper(tangent, pos, radius, 0x0000ff ) );\r\n\t\t\tthis.debug.add( new THREE.ArrowHelper(normal, pos, radius, 0xff0000 ) );\r\n\t\t\tthis.debug.add( new THREE.ArrowHelper(binormal, pos, radius, 0x00ff00 ) );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( j = 0; j < this.radiusSegments; j++ ) {\r\n\r\n\t\t\tv = j / this.radiusSegments * 2 * Math.PI;\r\n\r\n\t\t\tcx = -this.radius * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\r\n\t\t\tcy = this.radius * Math.sin( v );\r\n\r\n\t\t\tpos2.copy( pos );\r\n\t\t\tpos2.x += cx * normal.x + cy * binormal.x;\r\n\t\t\tpos2.y += cx * normal.y + cy * binormal.y;\r\n\t\t\tpos2.z += cx * normal.z + cy * binormal.z;\r\n\r\n\t\t\tthis.grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );\r\n\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t// construct the mesh\r\n\r\n\tfor ( i = 0; i < this.segments; i++ ) {\r\n\r\n\t\tfor ( j = 0; j < this.radiusSegments; j++ ) {\r\n\r\n\t\t\tip = ( this.closed ) ? (i + 1) % this.segments : i + 1;\r\n\t\t\tjp = (j + 1) % this.radiusSegments;\r\n\r\n\t\t\ta = this.grid[ i ][ j ];\t\t// *** NOT NECESSARILY PLANAR ! ***\r\n\t\t\tb = this.grid[ ip ][ j ];\r\n\t\t\tc = this.grid[ ip ][ jp ];\r\n\t\t\td = this.grid[ i ][ jp ];\r\n\r\n\t\t\tuva = new THREE.Vector2( i / this.segments, j / this.radiusSegments );\r\n\t\t\tuvb = new THREE.Vector2( ( i + 1 ) / this.segments, j / this.radiusSegments );\r\n\t\t\tuvc = new THREE.Vector2( ( i + 1 ) / this.segments, ( j + 1 ) / this.radiusSegments );\r\n\t\t\tuvd = new THREE.Vector2( i / this.segments, ( j + 1 ) / this.radiusSegments );\r\n\r\n\t\t\tthis.faces.push( new THREE.Face4( a, b, c, d ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uva, uvb, uvc, uvd ] );\r\n\r\n\t\t}\r\n\t}\r\n\r\n\tthis.computeCentroids();\r\n\tthis.computeFaceNormals();\r\n\tthis.computeVertexNormals();\r\n\r\n};\r\n\r\nTHREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\r\n\r\n// For computing of Frenet frames, exposing the tangents, normals and binormals the spline\r\nTHREE.TubeGeometry.FrenetFrames = function(path, segments, closed) {\r\n\r\n\tvar\ttangent = new THREE.Vector3(),\r\n\t\tnormal = new THREE.Vector3(),\r\n\t\tbinormal = new THREE.Vector3(),\r\n\r\n\t\ttangents = [],\r\n\t\tnormals = [],\r\n\t\tbinormals = [],\r\n\r\n\t\tvec = new THREE.Vector3(),\r\n\t\tmat = new THREE.Matrix4(),\r\n\r\n\t\tnumpoints = segments + 1,\r\n\t\ttheta,\r\n\t\tepsilon = 0.0001,\r\n\t\tsmallest,\r\n\r\n\t\ttx, ty, tz,\r\n\t\ti, u, v;\r\n\r\n\r\n\t// expose internals\r\n\tthis.tangents = tangents;\r\n\tthis.normals = normals;\r\n\tthis.binormals = binormals;\r\n\r\n\t// compute the tangent vectors for each segment on the path\r\n\r\n\tfor ( i = 0; i < numpoints; i++ ) {\r\n\r\n\t\tu = i / ( numpoints - 1 );\r\n\r\n\t\ttangents[ i ] = path.getTangentAt( u );\r\n\t\ttangents[ i ].normalize();\r\n\r\n\t}\r\n\r\n\tinitialNormal3();\r\n\r\n\tfunction initialNormal1(lastBinormal) {\r\n\t\t// fixed start binormal. Has dangers of 0 vectors\r\n\t\tnormals[ 0 ] = new THREE.Vector3();\r\n\t\tbinormals[ 0 ] = new THREE.Vector3();\r\n\t\tif (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );\r\n\t\tnormals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();\r\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\r\n\t}\r\n\r\n\tfunction initialNormal2() {\r\n\r\n\t\t// This uses the Frenet-Serret formula for deriving binormal\r\n\t\tvar t2 = path.getTangentAt( epsilon );\r\n\r\n\t\tnormals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();\r\n\t\tbinormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );\r\n\r\n\t\tnormals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent\r\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\r\n\r\n\t}\r\n\r\n\tfunction initialNormal3() {\r\n\t\t// select an initial normal vector perpenicular to the first tangent vector,\r\n\t\t// and in the direction of the smallest tangent xyz component\r\n\r\n\t\tnormals[ 0 ] = new THREE.Vector3();\r\n\t\tbinormals[ 0 ] = new THREE.Vector3();\r\n\t\tsmallest = Number.MAX_VALUE;\r\n\t\ttx = Math.abs( tangents[ 0 ].x );\r\n\t\tty = Math.abs( tangents[ 0 ].y );\r\n\t\ttz = Math.abs( tangents[ 0 ].z );\r\n\r\n\t\tif ( tx <= smallest ) {\r\n\t\t\tsmallest = tx;\r\n\t\t\tnormal.set( 1, 0, 0 );\r\n\t\t}\r\n\r\n\t\tif ( ty <= smallest ) {\r\n\t\t\tsmallest = ty;\r\n\t\t\tnormal.set( 0, 1, 0 );\r\n\t\t}\r\n\r\n\t\tif ( tz <= smallest ) {\r\n\t\t\tnormal.set( 0, 0, 1 );\r\n\t\t}\r\n\r\n\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\r\n\r\n\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\r\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\r\n\t}\r\n\r\n\r\n\t// compute the slowly-varying normal and binormal vectors for each segment on the path\r\n\r\n\tfor ( i = 1; i < numpoints; i++ ) {\r\n\r\n\t\tnormals[ i ] = normals[ i-1 ].clone();\r\n\r\n\t\tbinormals[ i ] = binormals[ i-1 ].clone();\r\n\r\n\t\tvec.crossVectors( tangents[ i-1 ], tangents[ i ] );\r\n\r\n\t\tif ( vec.length() > epsilon ) {\r\n\r\n\t\t\tvec.normalize();\r\n\r\n\t\t\ttheta = Math.acos( tangents[ i-1 ].dot( tangents[ i ] ) );\r\n\r\n\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\r\n\r\n\t\t}\r\n\r\n\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\r\n\r\n\t}\r\n\r\n\r\n\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\r\n\r\n\tif ( closed ) {\r\n\r\n\t\ttheta = Math.acos( normals[ 0 ].dot( normals[ numpoints-1 ] ) );\r\n\t\ttheta /= ( numpoints - 1 );\r\n\r\n\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints-1 ] ) ) > 0 ) {\r\n\r\n\t\t\ttheta = -theta;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( i = 1; i < numpoints; i++ ) {\r\n\r\n\t\t\t// twist a little...\r\n\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\r\n\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n};\r\n/**\r\n * @author clockworkgeek / https://github.com/clockworkgeek\r\n * @author timothypratley / https://github.com/timothypratley\r\n */\r\n\r\nTHREE.PolyhedronGeometry = function ( vertices, faces, radius, detail ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tradius = radius || 1;\r\n\tdetail = detail || 0;\r\n\r\n\tvar that = this;\r\n\r\n\tfor ( var i = 0, l = vertices.length; i < l; i ++ ) {\r\n\r\n\t\tprepare( new THREE.Vector3( vertices[ i ][ 0 ], vertices[ i ][ 1 ], vertices[ i ][ 2 ] ) );\r\n\r\n\t}\r\n\r\n\tvar midpoints = [], p = this.vertices;\r\n\r\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\tmake( p[ faces[ i ][ 0 ] ], p[ faces[ i ][ 1 ] ], p[ faces[ i ][ 2 ] ], detail );\r\n\r\n\t}\r\n\r\n\tthis.mergeVertices();\r\n\r\n\t// Apply radius\r\n\r\n\tfor ( var i = 0, l = this.vertices.length; i < l; i ++ ) {\r\n\r\n\t\tthis.vertices[ i ].multiplyScalar( radius );\r\n\r\n\t}\r\n\r\n\r\n\t// Project vector onto sphere's surface\r\n\r\n\tfunction prepare( vector ) {\r\n\r\n\t\tvar vertex = vector.normalize().clone();\r\n\t\tvertex.index = that.vertices.push( vertex ) - 1;\r\n\r\n\t\t// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.\r\n\r\n\t\tvar u = azimuth( vector ) / 2 / Math.PI + 0.5;\r\n\t\tvar v = inclination( vector ) / Math.PI + 0.5;\r\n\t\tvertex.uv = new THREE.Vector2( u, 1 - v );\r\n\r\n\t\treturn vertex;\r\n\r\n\t}\r\n\r\n\r\n\t// Approximate a curved face with recursively sub-divided triangles.\r\n\r\n\tfunction make( v1, v2, v3, detail ) {\r\n\r\n\t\tif ( detail < 1 ) {\r\n\r\n\t\t\tvar face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );\r\n\t\t\tface.centroid.add( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );\r\n\t\t\tface.normal = face.centroid.clone().normalize();\r\n\t\t\tthat.faces.push( face );\r\n\r\n\t\t\tvar azi = azimuth( face.centroid );\r\n\t\t\tthat.faceVertexUvs[ 0 ].push( [\r\n\t\t\t\tcorrectUV( v1.uv, v1, azi ),\r\n\t\t\t\tcorrectUV( v2.uv, v2, azi ),\r\n\t\t\t\tcorrectUV( v3.uv, v3, azi )\r\n\t\t\t] );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tdetail -= 1;\r\n\r\n\t\t\t// split triangle into 4 smaller triangles\r\n\r\n\t\t\tmake( v1, midpoint( v1, v2 ), midpoint( v1, v3 ), detail ); // top quadrant\r\n\t\t\tmake( midpoint( v1, v2 ), v2, midpoint( v2, v3 ), detail ); // left quadrant\r\n\t\t\tmake( midpoint( v1, v3 ), midpoint( v2, v3 ), v3, detail ); // right quadrant\r\n\t\t\tmake( midpoint( v1, v2 ), midpoint( v2, v3 ), midpoint( v1, v3 ), detail ); // center quadrant\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction midpoint( v1, v2 ) {\r\n\r\n\t\tif ( !midpoints[ v1.index ] ) midpoints[ v1.index ] = [];\r\n\t\tif ( !midpoints[ v2.index ] ) midpoints[ v2.index ] = [];\r\n\r\n\t\tvar mid = midpoints[ v1.index ][ v2.index ];\r\n\r\n\t\tif ( mid === undefined ) {\r\n\r\n\t\t\t// generate mean point and project to surface with prepare()\r\n\r\n\t\t\tmidpoints[ v1.index ][ v2.index ] = midpoints[ v2.index ][ v1.index ] = mid = prepare(\r\n\t\t\t\tnew THREE.Vector3().addVectors( v1, v2 ).divideScalar( 2 )\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\treturn mid;\r\n\r\n\t}\r\n\r\n\r\n\t// Angle around the Y axis, counter-clockwise when looking from above.\r\n\r\n\tfunction azimuth( vector ) {\r\n\r\n\t\treturn Math.atan2( vector.z, -vector.x );\r\n\r\n\t}\r\n\r\n\r\n\t// Angle above the XZ plane.\r\n\r\n\tfunction inclination( vector ) {\r\n\r\n\t\treturn Math.atan2( -vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\r\n\r\n\t}\r\n\r\n\r\n\t// Texture fixing helper. Spheres have some odd behaviours.\r\n\r\n\tfunction correctUV( uv, vector, azimuth ) {\r\n\r\n\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );\r\n\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );\r\n\t\treturn uv;\r\n\r\n\t}\r\n\r\n\tthis.computeCentroids();\r\n\r\n    this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\r\n};\r\n\r\nTHREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n/**\r\n * @author timothypratley / https://github.com/timothypratley\r\n */\r\n\r\nTHREE.IcosahedronGeometry = function ( radius, detail ) {\r\n\r\n\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\r\n\r\n\tvar vertices = [\r\n\t\t[ -1,  t,  0 ], [  1, t, 0 ], [ -1, -t,  0 ], [  1, -t,  0 ],\r\n\t\t[  0, -1,  t ], [  0, 1, t ], [  0, -1, -t ], [  0,  1, -t ],\r\n\t\t[  t,  0, -1 ], [  t, 0, 1 ], [ -t,  0, -1 ], [ -t,  0,  1 ]\r\n\t];\r\n\r\n\tvar faces = [\r\n\t\t[ 0, 11,  5 ], [ 0,  5,  1 ], [  0,  1,  7 ], [  0,  7, 10 ], [  0, 10, 11 ],\r\n\t\t[ 1,  5,  9 ], [ 5, 11,  4 ], [ 11, 10,  2 ], [ 10,  7,  6 ], [  7,  1,  8 ],\r\n\t\t[ 3,  9,  4 ], [ 3,  4,  2 ], [  3,  2,  6 ], [  3,  6,  8 ], [  3,  8,  9 ],\r\n\t\t[ 4,  9,  5 ], [ 2,  4, 11 ], [  6,  2, 10 ], [  8,  6,  7 ], [  9,  8,  1 ]\r\n\t];\r\n\r\n\tTHREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );\r\n\r\n};\r\n\r\nTHREE.IcosahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n/**\r\n * @author timothypratley / https://github.com/timothypratley\r\n */\r\n\r\nTHREE.OctahedronGeometry = function ( radius, detail ) {\r\n\r\n\tvar vertices = [\r\n\t\t[ 1, 0, 0 ], [ -1, 0, 0 ], [ 0, 1, 0 ], [ 0, -1, 0 ], [ 0, 0, 1 ], [ 0, 0, -1 ]\r\n\t];\r\n\r\n\tvar faces = [\r\n\t\t[ 0, 2, 4 ], [ 0, 4, 3 ], [ 0, 3, 5 ], [ 0, 5, 2 ], [ 1, 2, 5 ], [ 1, 5, 3 ], [ 1, 3, 4 ], [ 1, 4, 2 ]\r\n\t];\r\n\r\n\tTHREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );\r\n};\r\n\r\nTHREE.OctahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n/**\r\n * @author timothypratley / https://github.com/timothypratley\r\n */\r\n\r\nTHREE.TetrahedronGeometry = function ( radius, detail ) {\r\n\r\n\tvar vertices = [\r\n\t\t[ 1,  1,  1 ], [ -1, -1, 1 ], [ -1, 1, -1 ], [ 1, -1, -1 ]\r\n\t];\r\n\r\n\tvar faces = [\r\n\t\t[ 2, 1, 0 ], [ 0, 3, 2 ], [ 1, 3, 0 ], [ 2, 3, 1 ]\r\n\t];\r\n\r\n\tTHREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );\r\n\r\n};\r\n\r\nTHREE.TetrahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n/**\r\n * @author zz85 / https://github.com/zz85\r\n * Parametric Surfaces Geometry\r\n * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\r\n *\r\n * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements, useTris );\r\n *\r\n */\r\n\r\nTHREE.ParametricGeometry = function ( func, slices, stacks, useTris ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tvar verts = this.vertices;\r\n\tvar faces = this.faces;\r\n\tvar uvs = this.faceVertexUvs[ 0 ];\r\n\r\n\tuseTris = (useTris === undefined) ? false : useTris;\r\n\r\n\tvar i, il, j, p;\r\n\tvar u, v;\r\n\r\n\tvar stackCount = stacks + 1;\r\n\tvar sliceCount = slices + 1;\r\n\r\n\tfor ( i = 0; i <= stacks; i ++ ) {\r\n\r\n\t\tv = i / stacks;\r\n\r\n\t\tfor ( j = 0; j <= slices; j ++ ) {\r\n\r\n\t\t\tu = j / slices;\r\n\r\n\t\t\tp = func( u, v );\r\n\t\t\tverts.push( p );\r\n\r\n\t\t}\r\n\t}\r\n\r\n\tvar a, b, c, d;\r\n\tvar uva, uvb, uvc, uvd;\r\n\r\n\tfor ( i = 0; i < stacks; i ++ ) {\r\n\r\n\t\tfor ( j = 0; j < slices; j ++ ) {\r\n\r\n\t\t\ta = i * sliceCount + j;\r\n\t\t\tb = i * sliceCount + j + 1;\r\n\t\t\tc = (i + 1) * sliceCount + j;\r\n\t\t\td = (i + 1) * sliceCount + j + 1;\r\n\r\n\t\t\tuva = new THREE.Vector2( j / slices, i / stacks );\r\n\t\t\tuvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );\r\n\t\t\tuvc = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );\r\n\t\t\tuvd = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );\r\n\r\n\t\t\tif ( useTris ) {\r\n\r\n\t\t\t\tfaces.push( new THREE.Face3( a, b, c ) );\r\n\t\t\t\tfaces.push( new THREE.Face3( b, d, c ) );\r\n\r\n\t\t\t\tuvs.push( [ uva, uvb, uvc ] );\r\n\t\t\t\tuvs.push( [ uvb, uvd, uvc ] );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfaces.push( new THREE.Face4( a, b, d, c ) );\r\n\t\t\t\tuvs.push( [ uva, uvb, uvd, uvc ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// console.log(this);\r\n\r\n\t// magic bullet\r\n\t// var diff = this.mergeVertices();\r\n\t// console.log('removed ', diff, ' vertices by merging');\r\n\r\n\tthis.computeCentroids();\r\n\tthis.computeFaceNormals();\r\n\tthis.computeVertexNormals();\r\n\r\n};\r\n\r\nTHREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n/**\r\n * @author qiao / https://github.com/qiao\r\n * @fileoverview This is a convex hull generator using the incremental method. \r\n * The complexity is O(n^2) where n is the number of vertices.\r\n * O(nlogn) algorithms do exist, but they are much more complicated.\r\n *\r\n * Benchmark: \r\n *\r\n *  Platform: CPU: P7350 @2.00GHz Engine: V8\r\n *\r\n *  Num Vertices\tTime(ms)\r\n *\r\n *     10           1\r\n *     20           3\r\n *     30           19\r\n *     40           48\r\n *     50           107\r\n */\r\n\r\nTHREE.ConvexGeometry = function( vertices ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tvar faces = [ [ 0, 1, 2 ], [ 0, 2, 1 ] ]; \r\n\r\n\tfor ( var i = 3; i < vertices.length; i++ ) {\r\n\r\n\t\taddPoint( i );\r\n\r\n\t}\r\n\r\n\r\n\tfunction addPoint( vertexId ) {\r\n\r\n\t\tvar vertex = vertices[ vertexId ].clone();\r\n\r\n\t\tvar mag = vertex.length();\r\n\t\tvertex.x += mag * randomOffset();\r\n\t\tvertex.y += mag * randomOffset();\r\n\t\tvertex.z += mag * randomOffset();\r\n\r\n\t\tvar hole = [];\r\n\r\n\t\tfor ( var f = 0; f < faces.length; ) {\r\n\r\n\t\t\tvar face = faces[ f ];\r\n\r\n\t\t\t// for each face, if the vertex can see it,\r\n\t\t\t// then we try to add the face's edges into the hole.\r\n\t\t\tif ( visible( face, vertex ) ) {\r\n\r\n\t\t\t\tfor ( var e = 0; e < 3; e++ ) {\r\n\r\n\t\t\t\t\tvar edge = [ face[ e ], face[ ( e + 1 ) % 3 ] ];\r\n\t\t\t\t\tvar boundary = true;\r\n\r\n\t\t\t\t\t// remove duplicated edges.\r\n\t\t\t\t\tfor ( var h = 0; h < hole.length; h++ ) {\r\n\r\n\t\t\t\t\t\tif ( equalEdge( hole[ h ], edge ) ) {\r\n\r\n\t\t\t\t\t\t\thole[ h ] = hole[ hole.length - 1 ];\r\n\t\t\t\t\t\t\thole.pop();\r\n\t\t\t\t\t\t\tboundary = false;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( boundary ) {\r\n\r\n\t\t\t\t\t\thole.push( edge );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// remove faces[ f ]\r\n\t\t\t\tfaces[ f ] = faces[ faces.length - 1 ];\r\n\t\t\t\tfaces.pop();\r\n\r\n\t\t\t} else { // not visible\r\n\r\n\t\t\t\tf++;\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// construct the new faces formed by the edges of the hole and the vertex\r\n\t\tfor ( var h = 0; h < hole.length; h++ ) {\r\n\r\n\t\t\tfaces.push( [ \r\n\t\t\t\thole[ h ][ 0 ],\r\n\t\t\t\thole[ h ][ 1 ],\r\n\t\t\t\tvertexId\r\n\t\t\t] );\r\n\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Whether the face is visible from the vertex\r\n\t */\r\n\tfunction visible( face, vertex ) {\r\n\r\n\t\tvar va = vertices[ face[ 0 ] ];\r\n\t\tvar vb = vertices[ face[ 1 ] ];\r\n\t\tvar vc = vertices[ face[ 2 ] ];\r\n\r\n\t\tvar n = normal( va, vb, vc );\r\n\r\n\t\t// distance from face to origin\r\n\t\tvar dist = n.dot( va );\r\n\r\n\t\treturn n.dot( vertex ) >= dist; \r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Face normal\r\n\t */\r\n\tfunction normal( va, vb, vc ) {\r\n\r\n\t\tvar cb = new THREE.Vector3();\r\n\t\tvar ab = new THREE.Vector3();\r\n\r\n\t\tcb.subVectors( vc, vb );\r\n\t\tab.subVectors( va, vb );\r\n\t\tcb.cross( ab );\r\n\r\n\t\tcb.normalize();\r\n\r\n\t\treturn cb;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Detect whether two edges are equal.\r\n\t * Note that when constructing the convex hull, two same edges can only\r\n\t * be of the negative direction.\r\n\t */\r\n\tfunction equalEdge( ea, eb ) {\r\n\r\n\t\treturn ea[ 0 ] === eb[ 1 ] && ea[ 1 ] === eb[ 0 ]; \r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Create a random offset between -1e-6 and 1e-6.\r\n\t */\r\n\tfunction randomOffset() {\r\n\r\n\t\treturn ( Math.random() - 0.5 ) * 2 * 1e-6;\r\n\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * XXX: Not sure if this is the correct approach. Need someone to review.\r\n\t */\r\n\tfunction vertexUv( vertex ) {\r\n\r\n\t\tvar mag = vertex.length();\r\n\t\treturn new THREE.Vector2( vertex.x / mag, vertex.y / mag );\r\n\r\n\t}\r\n\r\n\t// Push vertices into `this.vertices`, skipping those inside the hull\r\n\tvar id = 0;\r\n\tvar newId = new Array( vertices.length ); // map from old vertex id to new id\r\n\r\n\tfor ( var i = 0; i < faces.length; i++ ) {\r\n\r\n\t\t var face = faces[ i ];\r\n\r\n\t\t for ( var j = 0; j < 3; j++ ) {\r\n\r\n\t\t\t\tif ( newId[ face[ j ] ] === undefined ) {\r\n\r\n\t\t\t\t\t\tnewId[ face[ j ] ] = id++;\r\n\t\t\t\t\t\tthis.vertices.push( vertices[ face[ j ] ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tface[ j ] = newId[ face[ j ] ];\r\n\r\n\t\t }\r\n\r\n\t}\r\n\r\n\t// Convert faces into instances of THREE.Face3\r\n\tfor ( var i = 0; i < faces.length; i++ ) {\r\n\r\n\t\tthis.faces.push( new THREE.Face3( \r\n\t\t\t\tfaces[ i ][ 0 ],\r\n\t\t\t\tfaces[ i ][ 1 ],\r\n\t\t\t\tfaces[ i ][ 2 ]\r\n\t\t) );\r\n\r\n\t}\r\n\r\n\t// Compute UVs\r\n\tfor ( var i = 0; i < this.faces.length; i++ ) {\r\n\r\n\t\tvar face = this.faces[ i ];\r\n\r\n\t\tthis.faceVertexUvs[ 0 ].push( [\r\n\t\t\tvertexUv( this.vertices[ face.a ] ),\r\n\t\t\tvertexUv( this.vertices[ face.b ] ),\r\n\t\t\tvertexUv( this.vertices[ face.c ])\r\n\t\t] );\r\n\r\n\t}\r\n\r\n\r\n\tthis.computeCentroids();\r\n\tthis.computeFaceNormals();\r\n\tthis.computeVertexNormals();\r\n\r\n};\r\n\r\nTHREE.ConvexGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n/**\r\n * @author sroucheray / http://sroucheray.org/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.AxisHelper = function ( size ) {\r\n\r\n\tvar geometry = new THREE.Geometry();\r\n\r\n\tgeometry.vertices.push(\r\n\t\tnew THREE.Vector3(), new THREE.Vector3( size || 1, 0, 0 ),\r\n\t\tnew THREE.Vector3(), new THREE.Vector3( 0, size || 1, 0 ),\r\n\t\tnew THREE.Vector3(), new THREE.Vector3( 0, 0, size || 1 )\r\n\t);\r\n\r\n\tgeometry.colors.push(\r\n\t\tnew THREE.Color( 0xff0000 ), new THREE.Color( 0xffaa00 ),\r\n\t\tnew THREE.Color( 0x00ff00 ), new THREE.Color( 0xaaff00 ),\r\n\t\tnew THREE.Color( 0x0000ff ), new THREE.Color( 0x00aaff )\r\n\t);\r\n\r\n\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\r\n\r\n\tTHREE.Line.call( this, geometry, material, THREE.LinePieces );\r\n\r\n};\r\n\r\nTHREE.AxisHelper.prototype = Object.create( THREE.Line.prototype );\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author zz85 / https://github.com/zz85\r\n * @author bhouston / https://exocortex.com\r\n *\r\n * Creates an arrow for visualizing directions\r\n *\r\n * Parameters:\r\n *  dir - Vector3\r\n *  origin - Vector3\r\n *  length - Number\r\n *  hex - color in hex value\r\n */\r\n\r\nTHREE.ArrowHelper = function ( dir, origin, length, hex ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tif ( length === undefined ) length = 20;\r\n\tif ( hex === undefined ) hex = 0xffff00;\r\n\r\n\tvar lineGeometry = new THREE.Geometry();\r\n\tlineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ) );\r\n\tlineGeometry.vertices.push( new THREE.Vector3( 0, 1, 0 ) );\r\n\r\n\tthis.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: hex } ) );\r\n\tthis.add( this.line );\r\n\r\n\tvar coneGeometry = new THREE.CylinderGeometry( 0, 0.05, 0.25, 5, 1 );\r\n\r\n\tthis.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: hex } ) );\r\n\tthis.cone.position.set( 0, 1, 0 );\r\n\tthis.add( this.cone );\r\n\r\n\tif ( origin instanceof THREE.Vector3 ) this.position = origin;\r\n\r\n\tthis.setDirection( dir );\r\n\tthis.setLength( length );\r\n\r\n};\r\n\r\nTHREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.ArrowHelper.prototype.setDirection = function ( dir ) {\r\n\r\n    var d = THREE.ArrowHelper.__v1.copy( dir ).normalize();\r\n\r\n    if ( d.y > 0.999 ) {\r\n\r\n        this.rotation.set( 0, 0, 0 );\r\n \r\n    } else if ( d.y < - 0.999 ) {\r\n\r\n        this.rotation.set( Math.PI, 0, 0 );\r\n\r\n    } else {\r\n\r\n\t    var axis = THREE.ArrowHelper.__v2.set( d.z, 0, - d.x ).normalize();\r\n\t    var radians = Math.acos( d.y );\r\n\t    var quaternion = THREE.ArrowHelper.__q1.setFromAxisAngle( axis, radians );\r\n\r\n\t    this.rotation.setEulerFromQuaternion( quaternion, this.eulerOrder );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.ArrowHelper.prototype.setLength = function ( length ) {\r\n\r\n\tthis.scale.set( length, length, length );\r\n\r\n};\r\n\r\nTHREE.ArrowHelper.prototype.setColor = function ( hex ) {\r\n\r\n\tthis.line.material.color.setHex( hex );\r\n\tthis.cone.material.color.setHex( hex );\r\n\r\n};\r\n\r\nTHREE.ArrowHelper.__v1 = new THREE.Vector3();\r\nTHREE.ArrowHelper.__v2 = new THREE.Vector3();\r\nTHREE.ArrowHelper.__q1 = new THREE.Quaternion();\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n *\t- shows frustum, line of sight and up of the camera\r\n *\t- suitable for fast updates\r\n * \t- based on frustum visualization in lightgl.js shadowmap example\r\n *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\r\n */\r\n\r\nTHREE.CameraHelper = function ( camera ) {\r\n\r\n\tTHREE.Line.call( this );\r\n\r\n\tvar scope = this;\r\n\r\n\tthis.geometry = new THREE.Geometry();\r\n\tthis.material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );\r\n\tthis.type = THREE.LinePieces;\r\n\r\n\tthis.matrixWorld = camera.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tthis.pointMap = {};\r\n\r\n\t// colors\r\n\r\n\tvar hexFrustum = 0xffaa00;\r\n\tvar hexCone = 0xff0000;\r\n\tvar hexUp = 0x00aaff;\r\n\tvar hexTarget = 0xffffff;\r\n\tvar hexCross = 0x333333;\r\n\r\n\t// near\r\n\r\n\taddLine( \"n1\", \"n2\", hexFrustum );\r\n\taddLine( \"n2\", \"n4\", hexFrustum );\r\n\taddLine( \"n4\", \"n3\", hexFrustum );\r\n\taddLine( \"n3\", \"n1\", hexFrustum );\r\n\r\n\t// far\r\n\r\n\taddLine( \"f1\", \"f2\", hexFrustum );\r\n\taddLine( \"f2\", \"f4\", hexFrustum );\r\n\taddLine( \"f4\", \"f3\", hexFrustum );\r\n\taddLine( \"f3\", \"f1\", hexFrustum );\r\n\r\n\t// sides\r\n\r\n\taddLine( \"n1\", \"f1\", hexFrustum );\r\n\taddLine( \"n2\", \"f2\", hexFrustum );\r\n\taddLine( \"n3\", \"f3\", hexFrustum );\r\n\taddLine( \"n4\", \"f4\", hexFrustum );\r\n\r\n\t// cone\r\n\r\n\taddLine( \"p\", \"n1\", hexCone );\r\n\taddLine( \"p\", \"n2\", hexCone );\r\n\taddLine( \"p\", \"n3\", hexCone );\r\n\taddLine( \"p\", \"n4\", hexCone );\r\n\r\n\t// up\r\n\r\n\taddLine( \"u1\", \"u2\", hexUp );\r\n\taddLine( \"u2\", \"u3\", hexUp );\r\n\taddLine( \"u3\", \"u1\", hexUp );\r\n\r\n\t// target\r\n\r\n\taddLine( \"c\", \"t\", hexTarget );\r\n\taddLine( \"p\", \"c\", hexCross );\r\n\r\n\t// cross\r\n\r\n\taddLine( \"cn1\", \"cn2\", hexCross );\r\n\taddLine( \"cn3\", \"cn4\", hexCross );\r\n\r\n\taddLine( \"cf1\", \"cf2\", hexCross );\r\n\taddLine( \"cf3\", \"cf4\", hexCross );\r\n\r\n\tthis.camera = camera;\r\n\r\n\tfunction addLine( a, b, hex ) {\r\n\r\n\t\taddPoint( a, hex );\r\n\t\taddPoint( b, hex );\r\n\r\n\t}\r\n\r\n\tfunction addPoint( id, hex ) {\r\n\r\n\t\tscope.geometry.vertices.push( new THREE.Vector3() );\r\n\t\tscope.geometry.colors.push( new THREE.Color( hex ) );\r\n\r\n\t\tif ( scope.pointMap[ id ] === undefined ) scope.pointMap[ id ] = [];\r\n\r\n\t\tscope.pointMap[ id ].push( scope.geometry.vertices.length - 1 );\r\n\r\n\t}\r\n\r\n\tthis.update( camera );\r\n\r\n};\r\n\r\nTHREE.CameraHelper.prototype = Object.create( THREE.Line.prototype );\r\n\r\nTHREE.CameraHelper.prototype.update = function () {\r\n\r\n\tvar scope = this;\r\n\r\n\tvar w = 1, h = 1;\r\n\r\n\t// we need just camera projection matrix\r\n\t// world matrix must be identity\r\n\r\n\tTHREE.CameraHelper.__c.projectionMatrix.copy( this.camera.projectionMatrix );\r\n\r\n\t// center / target\r\n\r\n\tsetPoint( \"c\", 0, 0, -1 );\r\n\tsetPoint( \"t\", 0, 0,  1 );\r\n\r\n\t// near\r\n\r\n\tsetPoint( \"n1\", -w, -h, -1 );\r\n\tsetPoint( \"n2\",  w, -h, -1 );\r\n\tsetPoint( \"n3\", -w,  h, -1 );\r\n\tsetPoint( \"n4\",  w,  h, -1 );\r\n\r\n\t// far\r\n\r\n\tsetPoint( \"f1\", -w, -h, 1 );\r\n\tsetPoint( \"f2\",  w, -h, 1 );\r\n\tsetPoint( \"f3\", -w,  h, 1 );\r\n\tsetPoint( \"f4\",  w,  h, 1 );\r\n\r\n\t// up\r\n\r\n\tsetPoint( \"u1\",  w * 0.7, h * 1.1, -1 );\r\n\tsetPoint( \"u2\", -w * 0.7, h * 1.1, -1 );\r\n\tsetPoint( \"u3\",        0, h * 2,   -1 );\r\n\r\n\t// cross\r\n\r\n\tsetPoint( \"cf1\", -w,  0, 1 );\r\n\tsetPoint( \"cf2\",  w,  0, 1 );\r\n\tsetPoint( \"cf3\",  0, -h, 1 );\r\n\tsetPoint( \"cf4\",  0,  h, 1 );\r\n\r\n\tsetPoint( \"cn1\", -w,  0, -1 );\r\n\tsetPoint( \"cn2\",  w,  0, -1 );\r\n\tsetPoint( \"cn3\",  0, -h, -1 );\r\n\tsetPoint( \"cn4\",  0,  h, -1 );\r\n\r\n\tfunction setPoint( point, x, y, z ) {\r\n\r\n\t\tTHREE.CameraHelper.__v.set( x, y, z );\r\n\t\tTHREE.CameraHelper.__projector.unprojectVector( THREE.CameraHelper.__v, THREE.CameraHelper.__c );\r\n\r\n\t\tvar points = scope.pointMap[ point ];\r\n\r\n\t\tif ( points !== undefined ) {\r\n\r\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tscope.geometry.vertices[ points[ i ] ].copy( THREE.CameraHelper.__v );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.geometry.verticesNeedUpdate = true;\r\n\r\n};\r\n\r\nTHREE.CameraHelper.__projector = new THREE.Projector();\r\nTHREE.CameraHelper.__v = new THREE.Vector3();\r\nTHREE.CameraHelper.__c = new THREE.Camera();\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n *\t- shows directional light color, intensity, position, orientation and target\r\n */\r\n\r\nTHREE.DirectionalLightHelper = function ( light, sphereSize ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.light = light;\r\n\r\n\t// position\r\n\r\n\tthis.position = light.position;\r\n\r\n\t// direction\r\n\r\n\tthis.direction = new THREE.Vector3();\r\n\tthis.direction.subVectors( light.target.position, light.position );\r\n\r\n\t// color\r\n\r\n\tvar intensity = THREE.Math.clamp( light.intensity, 0, 1 );\r\n\r\n\tthis.color = light.color.clone();\r\n\tthis.color.multiplyScalar( intensity );\r\n\r\n\tvar hexColor = this.color.getHex();\r\n\r\n\t// light helper\r\n\r\n\tvar bulbGeometry = new THREE.SphereGeometry( sphereSize, 16, 8 );\r\n\tvar raysGeometry = new THREE.AsteriskGeometry( sphereSize * 1.25, sphereSize * 2.25 );\r\n\r\n\tvar bulbMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false } );\r\n\tvar raysMaterial = new THREE.LineBasicMaterial( { color: hexColor, fog: false } );\r\n\r\n\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\r\n\r\n\tthis.lightRays = new THREE.Line( raysGeometry, raysMaterial, THREE.LinePieces );\r\n\r\n\tthis.add( this.lightSphere );\r\n\tthis.add( this.lightRays );\r\n\r\n\tthis.lightSphere.properties.isGizmo = true;\r\n\tthis.lightSphere.properties.gizmoSubject = light;\r\n\tthis.lightSphere.properties.gizmoRoot = this;\r\n\r\n\t// light target helper\r\n\r\n\tthis.targetSphere = null;\r\n\r\n\tif ( light.target.properties.targetInverse !== undefined ) {\r\n\r\n\t\tvar targetGeo = new THREE.SphereGeometry( sphereSize, 8, 4 );\r\n\t\tvar targetMaterial = new THREE.MeshBasicMaterial( { color: hexColor, wireframe: true, fog: false } );\r\n\r\n\t\tthis.targetSphere = new THREE.Mesh( targetGeo, targetMaterial );\r\n\t\tthis.targetSphere.position = light.target.position;\r\n\r\n\t\tthis.targetSphere.properties.isGizmo = true;\r\n\t\tthis.targetSphere.properties.gizmoSubject = light.target;\r\n\t\tthis.targetSphere.properties.gizmoRoot = this.targetSphere;\r\n\r\n\t\tvar lineMaterial = new THREE.LineDashedMaterial( { color: hexColor, dashSize: 4, gapSize: 4, opacity: 0.75, transparent: true, fog: false } );\r\n\t\tvar lineGeometry = new THREE.Geometry();\r\n\t\tlineGeometry.vertices.push( this.position.clone() );\r\n\t\tlineGeometry.vertices.push( this.targetSphere.position.clone() );\r\n\t\tlineGeometry.computeLineDistances();\r\n\r\n\t\tthis.targetLine = new THREE.Line( lineGeometry, lineMaterial );\r\n\t\tthis.targetLine.properties.isGizmo = true;\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tthis.properties.isGizmo = true;\r\n\r\n}\r\n\r\nTHREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.DirectionalLightHelper.prototype.update = function () {\r\n\r\n\t// update arrow orientation\r\n\t// pointing from light to target\r\n\r\n\tthis.direction.subVectors( this.light.target.position, this.light.position );\r\n\r\n\t// update arrow, spheres, rays and line colors to light color * light intensity\r\n\r\n\tvar intensity = THREE.Math.clamp( this.light.intensity, 0, 1 );\r\n\r\n\tthis.color.copy( this.light.color );\r\n\tthis.color.multiplyScalar( intensity );\r\n\r\n\tthis.lightSphere.material.color.copy( this.color );\r\n\tthis.lightRays.material.color.copy( this.color );\r\n\r\n\t// Only update targetSphere and targetLine if available\r\n\tif ( this.targetSphere !== null ) {\r\n\r\n\t\tthis.targetSphere.material.color.copy( this.color );\r\n\t\tthis.targetLine.material.color.copy( this.color );\r\n\r\n\t\t// update target line vertices\r\n\r\n\t\tthis.targetLine.geometry.vertices[ 0 ].copy( this.light.position );\r\n\t\tthis.targetLine.geometry.vertices[ 1 ].copy( this.light.target.position );\r\n\r\n\t\tthis.targetLine.geometry.computeLineDistances();\r\n\t\tthis.targetLine.geometry.verticesNeedUpdate = true;\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n *\t- shows hemisphere light intensity, sky and ground colors and directions\r\n */\r\n\r\nTHREE.HemisphereLightHelper = function ( light, sphereSize, arrowLength, domeSize ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.light = light;\r\n\r\n\t// position\r\n\r\n\tthis.position = light.position;\r\n\r\n\t//\r\n\r\n\tvar intensity = THREE.Math.clamp( light.intensity, 0, 1 );\r\n\r\n\t// sky color\r\n\r\n\tthis.color = light.color.clone();\r\n\tthis.color.multiplyScalar( intensity );\r\n\r\n\tvar hexColor = this.color.getHex();\r\n\r\n\t// ground color\r\n\r\n\tthis.groundColor = light.groundColor.clone();\r\n\tthis.groundColor.multiplyScalar( intensity );\r\n\r\n\tvar hexColorGround = this.groundColor.getHex();\r\n\r\n\t// double colored light bulb\r\n\r\n\tvar bulbGeometry = new THREE.SphereGeometry( sphereSize, 16, 8, 0, Math.PI * 2, 0, Math.PI * 0.5 );\r\n\tvar bulbGroundGeometry = new THREE.SphereGeometry( sphereSize, 16, 8, 0, Math.PI * 2, Math.PI * 0.5, Math.PI );\r\n\r\n\tvar bulbSkyMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false } );\r\n\tvar bulbGroundMaterial = new THREE.MeshBasicMaterial( { color: hexColorGround, fog: false } );\r\n\r\n\tfor ( var i = 0, il = bulbGeometry.faces.length; i < il; i ++ ) {\r\n\r\n\t\tbulbGeometry.faces[ i ].materialIndex = 0;\r\n\r\n\t}\r\n\r\n\tfor ( var i = 0, il = bulbGroundGeometry.faces.length; i < il; i ++ ) {\r\n\r\n\t\tbulbGroundGeometry.faces[ i ].materialIndex = 1;\r\n\r\n\t}\r\n\r\n\tTHREE.GeometryUtils.merge( bulbGeometry, bulbGroundGeometry );\r\n\r\n\tthis.lightSphere = new THREE.Mesh( bulbGeometry, new THREE.MeshFaceMaterial( [ bulbSkyMaterial, bulbGroundMaterial ] ) );\r\n\r\n\t// arrows for sky and ground light directions\r\n\r\n\tthis.lightArrow = new THREE.ArrowHelper( new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, ( sphereSize + arrowLength ) * 1.1, 0 ), arrowLength, hexColor );\r\n\tthis.lightArrow.rotation.x = Math.PI;\r\n\r\n\tthis.lightArrowGround = new THREE.ArrowHelper( new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, ( sphereSize + arrowLength ) * -1.1, 0 ), arrowLength, hexColorGround );\r\n\r\n\tvar joint = new THREE.Object3D();\r\n\tjoint.rotation.x = -Math.PI * 0.5;\r\n\r\n\tjoint.add( this.lightSphere );\r\n\tjoint.add( this.lightArrow );\r\n\tjoint.add( this.lightArrowGround );\r\n\r\n\tthis.add( joint );\r\n\r\n\t//\r\n\r\n\tthis.lightSphere.properties.isGizmo = true;\r\n\tthis.lightSphere.properties.gizmoSubject = light;\r\n\tthis.lightSphere.properties.gizmoRoot = this;\r\n\r\n\t//\r\n\r\n\tthis.properties.isGizmo = true;\r\n\r\n\t//\r\n\r\n\tthis.target = new THREE.Vector3();\r\n\tthis.lookAt( this.target );\r\n\r\n}\r\n\r\nTHREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.HemisphereLightHelper.prototype.update = function () {\r\n\r\n\t// update sphere sky and ground colors to light color * light intensity\r\n\r\n\tvar intensity = THREE.Math.clamp( this.light.intensity, 0, 1 );\r\n\r\n\tthis.color.copy( this.light.color );\r\n\tthis.color.multiplyScalar( intensity );\r\n\r\n\tthis.groundColor.copy( this.light.groundColor );\r\n\tthis.groundColor.multiplyScalar( intensity );\r\n\r\n\tthis.lightSphere.material.materials[ 0 ].color.copy( this.color );\r\n\tthis.lightSphere.material.materials[ 1 ].color.copy( this.groundColor );\r\n\r\n\tthis.lightArrow.setColor( this.color.getHex() );\r\n\tthis.lightArrowGround.setColor( this.groundColor.getHex() );\r\n\r\n\tthis.lookAt( this.target );\r\n\r\n}\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n *\t- shows point light color, intensity, position and distance\r\n */\r\n\r\nTHREE.PointLightHelper = function ( light, sphereSize ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.light = light;\r\n\r\n\t// position\r\n\r\n\tthis.position = light.position;\r\n\r\n\t// color\r\n\r\n\tvar intensity = THREE.Math.clamp( light.intensity, 0, 1 );\r\n\r\n\tthis.color = light.color.clone();\r\n\tthis.color.multiplyScalar( intensity );\r\n\r\n\tvar hexColor = this.color.getHex();\r\n\r\n\t// light helper\r\n\r\n\tvar bulbGeometry = new THREE.SphereGeometry( sphereSize, 16, 8 );\r\n\tvar raysGeometry = new THREE.AsteriskGeometry( sphereSize * 1.25, sphereSize * 2.25 );\r\n\tvar distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\r\n\r\n\tvar bulbMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false } );\r\n\tvar raysMaterial = new THREE.LineBasicMaterial( { color: hexColor, fog: false } );\r\n\tvar distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\r\n\r\n\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\r\n\tthis.lightRays = new THREE.Line( raysGeometry, raysMaterial, THREE.LinePieces );\r\n\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\r\n\r\n\tvar d = light.distance;\r\n\r\n\tif ( d === 0.0 ) {\r\n\r\n\t\tthis.lightDistance.visible = false;\r\n\r\n\t} else {\r\n\r\n\t\tthis.lightDistance.scale.set( d, d, d );\r\n\r\n\t}\r\n\r\n\tthis.add( this.lightSphere );\r\n\tthis.add( this.lightRays );\r\n\tthis.add( this.lightDistance );\r\n\r\n\t//\r\n\r\n\tthis.lightSphere.properties.isGizmo = true;\r\n\tthis.lightSphere.properties.gizmoSubject = light;\r\n\tthis.lightSphere.properties.gizmoRoot = this;\r\n\r\n\t//\r\n\r\n\tthis.properties.isGizmo = true;\r\n\r\n}\r\n\r\nTHREE.PointLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.PointLightHelper.prototype.update = function () {\r\n\r\n\t// update sphere and rays colors to light color * light intensity\r\n\r\n\tvar intensity = THREE.Math.clamp( this.light.intensity, 0, 1 );\r\n\r\n\tthis.color.copy( this.light.color );\r\n\tthis.color.multiplyScalar( intensity );\r\n\r\n\tthis.lightSphere.material.color.copy( this.color );\r\n\tthis.lightRays.material.color.copy( this.color );\r\n\tthis.lightDistance.material.color.copy( this.color );\r\n\r\n\t//\r\n\r\n\tvar d = this.light.distance;\r\n\r\n\tif ( d === 0.0 ) {\r\n\r\n\t\tthis.lightDistance.visible = false;\r\n\r\n\t} else {\r\n\r\n\t\tthis.lightDistance.visible = true;\r\n\t\tthis.lightDistance.scale.set( d, d, d );\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n *\t- shows spot light color, intensity, position, orientation, light cone and target\r\n */\r\n\r\nTHREE.SpotLightHelper = function ( light, sphereSize ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.light = light;\r\n\r\n\t// position\r\n\r\n\tthis.position = light.position;\r\n\r\n\t// direction\r\n\r\n\tthis.direction = new THREE.Vector3();\r\n\tthis.direction.subVectors( light.target.position, light.position );\r\n\r\n\t// color\r\n\r\n\tvar intensity = THREE.Math.clamp( light.intensity, 0, 1 );\r\n\r\n\tthis.color = light.color.clone();\r\n\tthis.color.multiplyScalar( intensity );\r\n\r\n\tvar hexColor = this.color.getHex();\r\n\r\n\t// light helper\r\n\r\n\tvar bulbGeometry = new THREE.SphereGeometry( sphereSize, 16, 8 );\r\n\tvar raysGeometry = new THREE.AsteriskGeometry( sphereSize * 1.25, sphereSize * 2.25 );\r\n\tvar coneGeometry = new THREE.CylinderGeometry( 0.0001, 1, 1, 8, 1, true );\r\n\r\n\tvar coneMatrix = new THREE.Matrix4();\r\n\tconeMatrix.rotateX( -Math.PI/2 );\r\n\tconeMatrix.translate( new THREE.Vector3( 0, -0.5, 0 ) );\r\n\tconeGeometry.applyMatrix( coneMatrix );\r\n\r\n\tvar bulbMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false } );\r\n\tvar raysMaterial = new THREE.LineBasicMaterial( { color: hexColor, fog: false } );\r\n\tvar coneMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.3, transparent: true } );\r\n\r\n\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\r\n\tthis.lightCone = new THREE.Mesh( coneGeometry, coneMaterial );\r\n\r\n\tvar coneLength = light.distance ? light.distance : 10000;\r\n\tvar coneWidth = coneLength * Math.tan( light.angle * 0.5 ) * 2;\r\n\tthis.lightCone.scale.set( coneWidth, coneWidth, coneLength );\r\n\r\n\tthis.lightRays = new THREE.Line( raysGeometry, raysMaterial, THREE.LinePieces );\r\n\r\n\tthis.gyroscope = new THREE.Gyroscope();\r\n\r\n\tthis.gyroscope.add( this.lightSphere );\r\n\tthis.gyroscope.add( this.lightRays );\r\n\r\n\tthis.add( this.gyroscope );\r\n\tthis.add( this.lightCone );\r\n\r\n\tthis.lookAt( light.target.position );\r\n\r\n\tthis.lightSphere.properties.isGizmo = true;\r\n\tthis.lightSphere.properties.gizmoSubject = light;\r\n\tthis.lightSphere.properties.gizmoRoot = this;\r\n\r\n\t// light target helper\r\n\r\n\tthis.targetSphere = null;\r\n\r\n\tif ( light.target.properties.targetInverse !== undefined ) {\r\n\r\n\t\tvar targetGeo = new THREE.SphereGeometry( sphereSize, 8, 4 );\r\n\t\tvar targetMaterial = new THREE.MeshBasicMaterial( { color: hexColor, wireframe: true, fog: false } );\r\n\r\n\t\tthis.targetSphere = new THREE.Mesh( targetGeo, targetMaterial );\r\n\t\tthis.targetSphere.position = light.target.position;\r\n\r\n\t\tthis.targetSphere.properties.isGizmo = true;\r\n\t\tthis.targetSphere.properties.gizmoSubject = light.target;\r\n\t\tthis.targetSphere.properties.gizmoRoot = this.targetSphere;\r\n\r\n\t\tvar lineMaterial = new THREE.LineDashedMaterial( { color: hexColor, dashSize: 4, gapSize: 4, opacity: 0.75, transparent: true, fog: false } );\r\n\t\tvar lineGeometry = new THREE.Geometry();\r\n\t\tlineGeometry.vertices.push( this.position.clone() );\r\n\t\tlineGeometry.vertices.push( this.targetSphere.position.clone() );\r\n\t\tlineGeometry.computeLineDistances();\r\n\r\n\t\tthis.targetLine = new THREE.Line( lineGeometry, lineMaterial );\r\n\t\tthis.targetLine.properties.isGizmo = true;\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tthis.properties.isGizmo = true;\r\n\r\n}\r\n\r\nTHREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.SpotLightHelper.prototype.update = function () {\r\n\r\n\t// update arrow orientation\r\n\t// pointing from light to target\r\n\r\n\tthis.direction.subVectors( this.light.target.position, this.light.position );\r\n\r\n\t// update light cone orientation and size\r\n\r\n\tthis.lookAt( this.light.target.position );\r\n\r\n\tvar coneLength = this.light.distance ? this.light.distance : 10000;\r\n\tvar coneWidth = coneLength * Math.tan( this.light.angle * 0.5 ) * 2;\r\n\tthis.lightCone.scale.set( coneWidth, coneWidth, coneLength );\r\n\r\n\t// update arrow, spheres, rays and line colors to light color * light intensity\r\n\r\n\tvar intensity = THREE.Math.clamp( this.light.intensity, 0, 1 );\r\n\r\n\tthis.color.copy( this.light.color );\r\n\tthis.color.multiplyScalar( intensity );\r\n\r\n\tthis.lightSphere.material.color.copy( this.color );\r\n\tthis.lightRays.material.color.copy( this.color );\r\n\tthis.lightCone.material.color.copy( this.color );\r\n\r\n\t// Only update targetSphere and targetLine if available\r\n\tif ( this.targetSphere !== null ) {\r\n\r\n\t\tthis.targetSphere.material.color.copy( this.color );\r\n\t\tthis.targetLine.material.color.copy( this.color );\r\n\r\n\t\t// update target line vertices\r\n\r\n\t\tthis.targetLine.geometry.vertices[ 0 ].copy( this.light.position );\r\n\t\tthis.targetLine.geometry.vertices[ 1 ].copy( this.light.target.position );\r\n\r\n\t\tthis.targetLine.geometry.computeLineDistances();\r\n\t\tthis.targetLine.geometry.verticesNeedUpdate = true;\r\n\r\n\t}\r\n\r\n};\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.ImmediateRenderObject = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.render = function ( renderCallback ) { };\r\n\r\n};\r\n\r\nTHREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.LensFlare = function ( texture, size, distance, blending, color ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.lensFlares = [];\r\n\r\n\tthis.positionScreen = new THREE.Vector3();\r\n\tthis.customUpdateCallback = undefined;\r\n\r\n\tif( texture !== undefined ) {\r\n\r\n\t\tthis.add( texture, size, distance, blending, color );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\n\r\n/*\r\n * Add: adds another flare\r\n */\r\n\r\nTHREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {\r\n\r\n\tif( size === undefined ) size = -1;\r\n\tif( distance === undefined ) distance = 0;\r\n\tif( opacity === undefined ) opacity = 1;\r\n\tif( color === undefined ) color = new THREE.Color( 0xffffff );\r\n\tif( blending === undefined ) blending = THREE.NormalBlending;\r\n\r\n\tdistance = Math.min( distance, Math.max( 0, distance ) );\r\n\r\n\tthis.lensFlares.push( { texture: texture, \t\t\t// THREE.Texture\r\n\t\t                    size: size, \t\t\t\t// size in pixels (-1 = use texture.width)\r\n\t\t                    distance: distance, \t\t// distance (0-1) from light source (0=at light source)\r\n\t\t                    x: 0, y: 0, z: 0,\t\t\t// screen position (-1 => 1) z = 0 is ontop z = 1 is back\r\n\t\t                    scale: 1, \t\t\t\t\t// scale\r\n\t\t                    rotation: 1, \t\t\t\t// rotation\r\n\t\t                    opacity: opacity,\t\t\t// opacity\r\n\t\t\t\t\t\t\tcolor: color,\t\t\t\t// color\r\n\t\t                    blending: blending } );\t\t// blending\r\n\r\n};\r\n\r\n\r\n/*\r\n * Update lens flares update positions on all flares based on the screen position\r\n * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\r\n */\r\n\r\nTHREE.LensFlare.prototype.updateLensFlares = function () {\r\n\r\n\tvar f, fl = this.lensFlares.length;\r\n\tvar flare;\r\n\tvar vecX = -this.positionScreen.x * 2;\r\n\tvar vecY = -this.positionScreen.y * 2;\r\n\r\n\tfor( f = 0; f < fl; f ++ ) {\r\n\r\n\t\tflare = this.lensFlares[ f ];\r\n\r\n\t\tflare.x = this.positionScreen.x + vecX * flare.distance;\r\n\t\tflare.y = this.positionScreen.y + vecY * flare.distance;\r\n\r\n\t\tflare.wantedRotation = flare.x * Math.PI * 0.25;\r\n\t\tflare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;\r\n\r\n\t}\r\n\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.MorphBlendMesh = function( geometry, material ) {\r\n\r\n\tTHREE.Mesh.call( this, geometry, material );\r\n\r\n\tthis.animationsMap = {};\r\n\tthis.animationsList = [];\r\n\r\n\t// prepare default animation\r\n\t// (all frames played together in 1 second)\r\n\r\n\tvar numFrames = this.geometry.morphTargets.length;\r\n\r\n\tvar name = \"__default\";\r\n\r\n\tvar startFrame = 0;\r\n\tvar endFrame = numFrames - 1;\r\n\r\n\tvar fps = numFrames / 1;\r\n\r\n\tthis.createAnimation( name, startFrame, endFrame, fps );\r\n\tthis.setAnimationWeight( name, 1 );\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );\r\n\r\nTHREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {\r\n\r\n\tvar animation = {\r\n\r\n\t\tstartFrame: start,\r\n\t\tendFrame: end,\r\n\r\n\t\tlength: end - start + 1,\r\n\r\n\t\tfps: fps,\r\n\t\tduration: ( end - start ) / fps,\r\n\r\n\t\tlastFrame: 0,\r\n\t\tcurrentFrame: 0,\r\n\r\n\t\tactive: false,\r\n\r\n\t\ttime: 0,\r\n\t\tdirection: 1,\r\n\t\tweight: 1,\r\n\r\n\t\tdirectionBackwards: false,\r\n\t\tmirroredLoop: false\r\n\r\n\t};\r\n\r\n\tthis.animationsMap[ name ] = animation;\r\n\tthis.animationsList.push( animation );\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {\r\n\r\n\tvar pattern = /([a-z]+)(\\d+)/;\r\n\r\n\tvar firstAnimation, frameRanges = {};\r\n\r\n\tvar geometry = this.geometry;\r\n\r\n\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\r\n\r\n\t\tvar morph = geometry.morphTargets[ i ];\r\n\t\tvar chunks = morph.name.match( pattern );\r\n\r\n\t\tif ( chunks && chunks.length > 1 ) {\r\n\r\n\t\t\tvar name = chunks[ 1 ];\r\n\t\t\tvar num = chunks[ 2 ];\r\n\r\n\t\t\tif ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: -Infinity };\r\n\r\n\t\t\tvar range = frameRanges[ name ];\r\n\r\n\t\t\tif ( i < range.start ) range.start = i;\r\n\t\t\tif ( i > range.end ) range.end = i;\r\n\r\n\t\t\tif ( ! firstAnimation ) firstAnimation = name;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfor ( var name in frameRanges ) {\r\n\r\n\t\tvar range = frameRanges[ name ];\r\n\t\tthis.createAnimation( name, range.start, range.end, fps );\r\n\r\n\t}\r\n\r\n\tthis.firstAnimation = firstAnimation;\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.direction = 1;\r\n\t\tanimation.directionBackwards = false;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.direction = -1;\r\n\t\tanimation.directionBackwards = true;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.fps = fps;\r\n\t\tanimation.duration = ( animation.end - animation.start ) / animation.fps;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.duration = duration;\r\n\t\tanimation.fps = ( animation.end - animation.start ) / animation.duration;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.weight = weight;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.time = time;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {\r\n\r\n\tvar time = 0;\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\ttime = animation.time;\r\n\r\n\t}\r\n\r\n\treturn time;\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {\r\n\r\n\tvar duration = -1;\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tduration = animation.duration;\r\n\r\n\t}\r\n\r\n\treturn duration;\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.time = 0;\r\n\t\tanimation.active = true;\r\n\r\n\t} else {\r\n\r\n\t\tconsole.warn( \"animation[\" + name + \"] undefined\" );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.active = false;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.update = function ( delta ) {\r\n\r\n\tfor ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {\r\n\r\n\t\tvar animation = this.animationsList[ i ];\r\n\r\n\t\tif ( ! animation.active ) continue;\r\n\r\n\t\tvar frameTime = animation.duration / animation.length;\r\n\r\n\t\tanimation.time += animation.direction * delta;\r\n\r\n\t\tif ( animation.mirroredLoop ) {\r\n\r\n\t\t\tif ( animation.time > animation.duration || animation.time < 0 ) {\r\n\r\n\t\t\t\tanimation.direction *= -1;\r\n\r\n\t\t\t\tif ( animation.time > animation.duration ) {\r\n\r\n\t\t\t\t\tanimation.time = animation.duration;\r\n\t\t\t\t\tanimation.directionBackwards = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( animation.time < 0 ) {\r\n\r\n\t\t\t\t\tanimation.time = 0;\r\n\t\t\t\t\tanimation.directionBackwards = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tanimation.time = animation.time % animation.duration;\r\n\r\n\t\t\tif ( animation.time < 0 ) animation.time += animation.duration;\r\n\r\n\t\t}\r\n\r\n\t\tvar keyframe = animation.startFrame + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );\r\n\t\tvar weight = animation.weight;\r\n\r\n\t\tif ( keyframe !== animation.currentFrame ) {\r\n\r\n\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = 0;\r\n\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;\r\n\r\n\t\t\tthis.morphTargetInfluences[ keyframe ] = 0;\r\n\r\n\t\t\tanimation.lastFrame = animation.currentFrame;\r\n\t\t\tanimation.currentFrame = keyframe;\r\n\r\n\t\t}\r\n\r\n\t\tvar mix = ( animation.time % frameTime ) / frameTime;\r\n\r\n\t\tif ( animation.directionBackwards ) mix = 1 - mix;\r\n\r\n\t\tthis.morphTargetInfluences[ animation.currentFrame ] = mix * weight;\r\n\t\tthis.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;\r\n\r\n\t}\r\n\r\n};\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.LensFlarePlugin = function () {\r\n\r\n\tvar _gl, _renderer, _precision, _lensFlare = {};\r\n\r\n\tthis.init = function ( renderer ) {\r\n\r\n\t\t_gl = renderer.context;\r\n\t\t_renderer = renderer;\r\n\r\n\t\t_precision = renderer.getPrecision();\r\n\r\n\t\t_lensFlare.vertices = new Float32Array( 8 + 8 );\r\n\t\t_lensFlare.faces = new Uint16Array( 6 );\r\n\r\n\t\tvar i = 0;\r\n\t\t_lensFlare.vertices[ i++ ] = -1; _lensFlare.vertices[ i++ ] = -1;\t// vertex\r\n\t\t_lensFlare.vertices[ i++ ] = 0;  _lensFlare.vertices[ i++ ] = 0;\t// uv... etc.\r\n\r\n\t\t_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = -1;\r\n\t\t_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 0;\r\n\r\n\t\t_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 1;\r\n\t\t_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 1;\r\n\r\n\t\t_lensFlare.vertices[ i++ ] = -1; _lensFlare.vertices[ i++ ] = 1;\r\n\t\t_lensFlare.vertices[ i++ ] = 0;  _lensFlare.vertices[ i++ ] = 1;\r\n\r\n\t\ti = 0;\r\n\t\t_lensFlare.faces[ i++ ] = 0; _lensFlare.faces[ i++ ] = 1; _lensFlare.faces[ i++ ] = 2;\r\n\t\t_lensFlare.faces[ i++ ] = 0; _lensFlare.faces[ i++ ] = 2; _lensFlare.faces[ i++ ] = 3;\r\n\r\n\t\t// buffers\r\n\r\n\t\t_lensFlare.vertexBuffer     = _gl.createBuffer();\r\n\t\t_lensFlare.elementBuffer    = _gl.createBuffer();\r\n\r\n\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, _lensFlare.vertexBuffer );\r\n\t\t_gl.bufferData( _gl.ARRAY_BUFFER, _lensFlare.vertices, _gl.STATIC_DRAW );\r\n\r\n\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.elementBuffer );\r\n\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.faces, _gl.STATIC_DRAW );\r\n\r\n\t\t// textures\r\n\r\n\t\t_lensFlare.tempTexture      = _gl.createTexture();\r\n\t\t_lensFlare.occlusionTexture = _gl.createTexture();\r\n\r\n\t\t_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );\r\n\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, _gl.RGB, 16, 16, 0, _gl.RGB, _gl.UNSIGNED_BYTE, null );\r\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\r\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\r\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, _gl.NEAREST );\r\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, _gl.NEAREST );\r\n\r\n\t\t_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.occlusionTexture );\r\n\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, _gl.RGBA, 16, 16, 0, _gl.RGBA, _gl.UNSIGNED_BYTE, null );\r\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\r\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\r\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, _gl.NEAREST );\r\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, _gl.NEAREST );\r\n\r\n\t\tif ( _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) <= 0 ) {\r\n\r\n\t\t\t_lensFlare.hasVertexTexture = false;\r\n\t\t\t_lensFlare.program = createProgram( THREE.ShaderFlares[ \"lensFlare\" ], _precision );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_lensFlare.hasVertexTexture = true;\r\n\t\t\t_lensFlare.program = createProgram( THREE.ShaderFlares[ \"lensFlareVertexTexture\" ], _precision );\r\n\r\n\t\t}\r\n\r\n\t\t_lensFlare.attributes = {};\r\n\t\t_lensFlare.uniforms = {};\r\n\r\n\t\t_lensFlare.attributes.vertex       = _gl.getAttribLocation ( _lensFlare.program, \"position\" );\r\n\t\t_lensFlare.attributes.uv           = _gl.getAttribLocation ( _lensFlare.program, \"uv\" );\r\n\r\n\t\t_lensFlare.uniforms.renderType     = _gl.getUniformLocation( _lensFlare.program, \"renderType\" );\r\n\t\t_lensFlare.uniforms.map            = _gl.getUniformLocation( _lensFlare.program, \"map\" );\r\n\t\t_lensFlare.uniforms.occlusionMap   = _gl.getUniformLocation( _lensFlare.program, \"occlusionMap\" );\r\n\t\t_lensFlare.uniforms.opacity        = _gl.getUniformLocation( _lensFlare.program, \"opacity\" );\r\n\t\t_lensFlare.uniforms.color          = _gl.getUniformLocation( _lensFlare.program, \"color\" );\r\n\t\t_lensFlare.uniforms.scale          = _gl.getUniformLocation( _lensFlare.program, \"scale\" );\r\n\t\t_lensFlare.uniforms.rotation       = _gl.getUniformLocation( _lensFlare.program, \"rotation\" );\r\n\t\t_lensFlare.uniforms.screenPosition = _gl.getUniformLocation( _lensFlare.program, \"screenPosition\" );\r\n\r\n\t};\r\n\r\n\r\n\t/*\r\n\t * Render lens flares\r\n\t * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\r\n\t *         reads these back and calculates occlusion.\r\n\t *         Then _lensFlare.update_lensFlares() is called to re-position and\r\n\t *         update transparency of flares. Then they are rendered.\r\n\t *\r\n\t */\r\n\r\n\tthis.render = function ( scene, camera, viewportWidth, viewportHeight ) {\r\n\r\n\t\tvar flares = scene.__webglFlares,\r\n\t\t\tnFlares = flares.length;\r\n\r\n\t\tif ( ! nFlares ) return;\r\n\r\n\t\tvar tempPosition = new THREE.Vector3();\r\n\r\n\t\tvar invAspect = viewportHeight / viewportWidth,\r\n\t\t\thalfViewportWidth = viewportWidth * 0.5,\r\n\t\t\thalfViewportHeight = viewportHeight * 0.5;\r\n\r\n\t\tvar size = 16 / viewportHeight,\r\n\t\t\tscale = new THREE.Vector2( size * invAspect, size );\r\n\r\n\t\tvar screenPosition = new THREE.Vector3( 1, 1, 0 ),\r\n\t\t\tscreenPositionPixels = new THREE.Vector2( 1, 1 );\r\n\r\n\t\tvar uniforms = _lensFlare.uniforms,\r\n\t\t\tattributes = _lensFlare.attributes;\r\n\r\n\t\t// set _lensFlare program and reset blending\r\n\r\n\t\t_gl.useProgram( _lensFlare.program );\r\n\r\n\t\t_gl.enableVertexAttribArray( _lensFlare.attributes.vertex );\r\n\t\t_gl.enableVertexAttribArray( _lensFlare.attributes.uv );\r\n\r\n\t\t// loop through all lens flares to update their occlusion and positions\r\n\t\t// setup gl and common used attribs/unforms\r\n\r\n\t\t_gl.uniform1i( uniforms.occlusionMap, 0 );\r\n\t\t_gl.uniform1i( uniforms.map, 1 );\r\n\r\n\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, _lensFlare.vertexBuffer );\r\n\t\t_gl.vertexAttribPointer( attributes.vertex, 2, _gl.FLOAT, false, 2 * 8, 0 );\r\n\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 2 * 8, 8 );\r\n\r\n\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.elementBuffer );\r\n\r\n\t\t_gl.disable( _gl.CULL_FACE );\r\n\t\t_gl.depthMask( false );\r\n\r\n\t\tvar i, j, jl, flare, sprite;\r\n\r\n\t\tfor ( i = 0; i < nFlares; i ++ ) {\r\n\r\n\t\t\tsize = 16 / viewportHeight;\r\n\t\t\tscale.set( size * invAspect, size );\r\n\r\n\t\t\t// calc object screen position\r\n\r\n\t\t\tflare = flares[ i ];\r\n\r\n\t\t\ttempPosition.set( flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14] );\r\n\r\n\t\t\ttempPosition.applyMatrix4( camera.matrixWorldInverse );\r\n\t\t\ttempPosition.applyProjection( camera.projectionMatrix );\r\n\r\n\t\t\t// setup arrays for gl programs\r\n\r\n\t\t\tscreenPosition.copy( tempPosition )\r\n\r\n\t\t\tscreenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;\r\n\t\t\tscreenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;\r\n\r\n\t\t\t// screen cull\r\n\r\n\t\t\tif ( _lensFlare.hasVertexTexture || (\r\n\t\t\t\tscreenPositionPixels.x > 0 &&\r\n\t\t\t\tscreenPositionPixels.x < viewportWidth &&\r\n\t\t\t\tscreenPositionPixels.y > 0 &&\r\n\t\t\t\tscreenPositionPixels.y < viewportHeight ) ) {\r\n\r\n\t\t\t\t// save current RGB to temp texture\r\n\r\n\t\t\t\t_gl.activeTexture( _gl.TEXTURE1 );\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );\r\n\t\t\t\t_gl.copyTexImage2D( _gl.TEXTURE_2D, 0, _gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );\r\n\r\n\r\n\t\t\t\t// render pink quad\r\n\r\n\t\t\t\t_gl.uniform1i( uniforms.renderType, 0 );\r\n\t\t\t\t_gl.uniform2f( uniforms.scale, scale.x, scale.y );\r\n\t\t\t\t_gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\r\n\r\n\t\t\t\t_gl.disable( _gl.BLEND );\r\n\t\t\t\t_gl.enable( _gl.DEPTH_TEST );\r\n\r\n\t\t\t\t_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );\r\n\r\n\r\n\t\t\t\t// copy result to occlusionMap\r\n\r\n\t\t\t\t_gl.activeTexture( _gl.TEXTURE0 );\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.occlusionTexture );\r\n\t\t\t\t_gl.copyTexImage2D( _gl.TEXTURE_2D, 0, _gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );\r\n\r\n\r\n\t\t\t\t// restore graphics\r\n\r\n\t\t\t\t_gl.uniform1i( uniforms.renderType, 1 );\r\n\t\t\t\t_gl.disable( _gl.DEPTH_TEST );\r\n\r\n\t\t\t\t_gl.activeTexture( _gl.TEXTURE1 );\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );\r\n\t\t\t\t_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );\r\n\r\n\r\n\t\t\t\t// update object positions\r\n\r\n\t\t\t\tflare.positionScreen.copy( screenPosition )\r\n\r\n\t\t\t\tif ( flare.customUpdateCallback ) {\r\n\r\n\t\t\t\t\tflare.customUpdateCallback( flare );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tflare.updateLensFlares();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// render flares\r\n\r\n\t\t\t\t_gl.uniform1i( uniforms.renderType, 2 );\r\n\t\t\t\t_gl.enable( _gl.BLEND );\r\n\r\n\t\t\t\tfor ( j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tsprite = flare.lensFlares[ j ];\r\n\r\n\t\t\t\t\tif ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {\r\n\r\n\t\t\t\t\t\tscreenPosition.x = sprite.x;\r\n\t\t\t\t\t\tscreenPosition.y = sprite.y;\r\n\t\t\t\t\t\tscreenPosition.z = sprite.z;\r\n\r\n\t\t\t\t\t\tsize = sprite.size * sprite.scale / viewportHeight;\r\n\r\n\t\t\t\t\t\tscale.x = size * invAspect;\r\n\t\t\t\t\t\tscale.y = size;\r\n\r\n\t\t\t\t\t\t_gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\r\n\t\t\t\t\t\t_gl.uniform2f( uniforms.scale, scale.x, scale.y );\r\n\t\t\t\t\t\t_gl.uniform1f( uniforms.rotation, sprite.rotation );\r\n\r\n\t\t\t\t\t\t_gl.uniform1f( uniforms.opacity, sprite.opacity );\r\n\t\t\t\t\t\t_gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );\r\n\r\n\t\t\t\t\t\t_renderer.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );\r\n\t\t\t\t\t\t_renderer.setTexture( sprite.texture, 1 );\r\n\r\n\t\t\t\t\t\t_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// restore gl\r\n\r\n\t\t_gl.enable( _gl.CULL_FACE );\r\n\t\t_gl.enable( _gl.DEPTH_TEST );\r\n\t\t_gl.depthMask( true );\r\n\r\n\t};\r\n\r\n\tfunction createProgram ( shader, precision ) {\r\n\r\n\t\tvar program = _gl.createProgram();\r\n\r\n\t\tvar fragmentShader = _gl.createShader( _gl.FRAGMENT_SHADER );\r\n\t\tvar vertexShader = _gl.createShader( _gl.VERTEX_SHADER );\r\n\r\n\t\tvar prefix = \"precision \" + precision + \" float;\\n\";\r\n\r\n\t\t_gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\r\n\t\t_gl.shaderSource( vertexShader, prefix + shader.vertexShader );\r\n\r\n\t\t_gl.compileShader( fragmentShader );\r\n\t\t_gl.compileShader( vertexShader );\r\n\r\n\t\t_gl.attachShader( program, fragmentShader );\r\n\t\t_gl.attachShader( program, vertexShader );\r\n\r\n\t\t_gl.linkProgram( program );\r\n\r\n\t\treturn program;\r\n\r\n\t};\r\n\r\n};\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.ShadowMapPlugin = function () {\r\n\r\n\tvar _gl,\r\n\t_renderer,\r\n\t_depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin,\r\n\r\n\t_frustum = new THREE.Frustum(),\r\n\t_projScreenMatrix = new THREE.Matrix4(),\r\n\r\n\t_min = new THREE.Vector3(),\r\n\t_max = new THREE.Vector3(),\r\n\r\n\t_matrixPosition = new THREE.Vector3();\r\n\r\n\tthis.init = function ( renderer ) {\r\n\r\n\t\t_gl = renderer.context;\r\n\t\t_renderer = renderer;\r\n\r\n\t\tvar depthShader = THREE.ShaderLib[ \"depthRGBA\" ];\r\n\t\tvar depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );\r\n\r\n\t\t_depthMaterial = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms } );\r\n\t\t_depthMaterialMorph = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true } );\r\n\t\t_depthMaterialSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, skinning: true } );\r\n\t\t_depthMaterialMorphSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true, skinning: true } );\r\n\r\n\t\t_depthMaterial._shadowPass = true;\r\n\t\t_depthMaterialMorph._shadowPass = true;\r\n\t\t_depthMaterialSkin._shadowPass = true;\r\n\t\t_depthMaterialMorphSkin._shadowPass = true;\r\n\r\n\t};\r\n\r\n\tthis.render = function ( scene, camera ) {\r\n\r\n\t\tif ( ! ( _renderer.shadowMapEnabled && _renderer.shadowMapAutoUpdate ) ) return;\r\n\r\n\t\tthis.update( scene, camera );\r\n\r\n\t};\r\n\r\n\tthis.update = function ( scene, camera ) {\r\n\r\n\t\tvar i, il, j, jl, n,\r\n\r\n\t\tshadowMap, shadowMatrix, shadowCamera,\r\n\t\tprogram, buffer, material,\r\n\t\twebglObject, object, light,\r\n\t\trenderList,\r\n\r\n\t\tlights = [],\r\n\t\tk = 0,\r\n\r\n\t\tfog = null;\r\n\r\n\t\t// set GL state for depth map\r\n\r\n\t\t_gl.clearColor( 1, 1, 1, 1 );\r\n\t\t_gl.disable( _gl.BLEND );\r\n\r\n\t\t_gl.enable( _gl.CULL_FACE );\r\n\t\t_gl.frontFace( _gl.CCW );\r\n\r\n\t\tif ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {\r\n\r\n\t\t\t_gl.cullFace( _gl.FRONT );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_gl.cullFace( _gl.BACK );\r\n\r\n\t\t}\r\n\r\n\t\t_renderer.setDepthTest( true );\r\n\r\n\t\t// preprocess lights\r\n\t\t// \t- skip lights that are not casting shadows\r\n\t\t//\t- create virtual lights for cascaded shadow maps\r\n\r\n\t\tfor ( i = 0, il = scene.__lights.length; i < il; i ++ ) {\r\n\r\n\t\t\tlight = scene.__lights[ i ];\r\n\r\n\t\t\tif ( ! light.castShadow ) continue;\r\n\r\n\t\t\tif ( ( light instanceof THREE.DirectionalLight ) && light.shadowCascade ) {\r\n\r\n\t\t\t\tfor ( n = 0; n < light.shadowCascadeCount; n ++ ) {\r\n\r\n\t\t\t\t\tvar virtualLight;\r\n\r\n\t\t\t\t\tif ( ! light.shadowCascadeArray[ n ] ) {\r\n\r\n\t\t\t\t\t\tvirtualLight = createVirtualLight( light, n );\r\n\t\t\t\t\t\tvirtualLight.originalCamera = camera;\r\n\r\n\t\t\t\t\t\tvar gyro = new THREE.Gyroscope();\r\n\t\t\t\t\t\tgyro.position = light.shadowCascadeOffset;\r\n\r\n\t\t\t\t\t\tgyro.add( virtualLight );\r\n\t\t\t\t\t\tgyro.add( virtualLight.target );\r\n\r\n\t\t\t\t\t\tcamera.add( gyro );\r\n\r\n\t\t\t\t\t\tlight.shadowCascadeArray[ n ] = virtualLight;\r\n\r\n\t\t\t\t\t\tconsole.log( \"Created virtualLight\", virtualLight );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tvirtualLight = light.shadowCascadeArray[ n ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tupdateVirtualLight( light, n );\r\n\r\n\t\t\t\t\tlights[ k ] = virtualLight;\r\n\t\t\t\t\tk ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tlights[ k ] = light;\r\n\t\t\t\tk ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// render depth map\r\n\r\n\t\tfor ( i = 0, il = lights.length; i < il; i ++ ) {\r\n\r\n\t\t\tlight = lights[ i ];\r\n\r\n\t\t\tif ( ! light.shadowMap ) {\r\n\r\n\t\t\t\tvar shadowFilter = THREE.LinearFilter;\r\n\r\n\t\t\t\tif ( _renderer.shadowMapType === THREE.PCFSoftShadowMap ) {\r\n\r\n\t\t\t\t\tshadowFilter = THREE.NearestFilter;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar pars = { minFilter: shadowFilter, magFilter: shadowFilter, format: THREE.RGBAFormat };\r\n\r\n\t\t\t\tlight.shadowMap = new THREE.WebGLRenderTarget( light.shadowMapWidth, light.shadowMapHeight, pars );\r\n\t\t\t\tlight.shadowMapSize = new THREE.Vector2( light.shadowMapWidth, light.shadowMapHeight );\r\n\r\n\t\t\t\tlight.shadowMatrix = new THREE.Matrix4();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! light.shadowCamera ) {\r\n\r\n\t\t\t\tif ( light instanceof THREE.SpotLight ) {\r\n\r\n\t\t\t\t\tlight.shadowCamera = new THREE.PerspectiveCamera( light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar );\r\n\r\n\t\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\r\n\r\n\t\t\t\t\tlight.shadowCamera = new THREE.OrthographicCamera( light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.error( \"Unsupported light type for shadow\" );\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tscene.add( light.shadowCamera );\r\n\r\n\t\t\t\tif ( _renderer.autoUpdateScene ) scene.updateMatrixWorld();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( light.shadowCameraVisible && ! light.cameraHelper ) {\r\n\r\n\t\t\t\tlight.cameraHelper = new THREE.CameraHelper( light.shadowCamera );\r\n\t\t\t\tlight.shadowCamera.add( light.cameraHelper );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( light.isVirtual && virtualLight.originalCamera == camera ) {\r\n\r\n\t\t\t\tupdateShadowCamera( camera, light );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tshadowMap = light.shadowMap;\r\n\t\t\tshadowMatrix = light.shadowMatrix;\r\n\t\t\tshadowCamera = light.shadowCamera;\r\n\r\n\t\t\tshadowCamera.position.getPositionFromMatrix( light.matrixWorld );\r\n\t\t\t_matrixPosition.getPositionFromMatrix( light.target.matrixWorld );\r\n\t\t\tshadowCamera.lookAt( _matrixPosition );\r\n\t\t\tshadowCamera.updateMatrixWorld();\r\n\r\n\t\t\tshadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );\r\n\r\n\t\t\tif ( light.cameraHelper ) light.cameraHelper.visible = light.shadowCameraVisible;\r\n\t\t\tif ( light.shadowCameraVisible ) light.cameraHelper.update();\r\n\r\n\t\t\t// compute shadow matrix\r\n\r\n\t\t\tshadowMatrix.set( 0.5, 0.0, 0.0, 0.5,\r\n\t\t\t\t\t\t\t  0.0, 0.5, 0.0, 0.5,\r\n\t\t\t\t\t\t\t  0.0, 0.0, 0.5, 0.5,\r\n\t\t\t\t\t\t\t  0.0, 0.0, 0.0, 1.0 );\r\n\r\n\t\t\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\r\n\t\t\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\r\n\r\n\t\t\t// update camera matrices and frustum\r\n\r\n\t\t\t_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\r\n\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\r\n\r\n\t\t\t// render shadow map\r\n\r\n\t\t\t_renderer.setRenderTarget( shadowMap );\r\n\t\t\t_renderer.clear();\r\n\r\n\t\t\t// set object matrices & frustum culling\r\n\r\n\t\t\trenderList = scene.__webglObjects;\r\n\r\n\t\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\twebglObject = renderList[ j ];\r\n\t\t\t\tobject = webglObject.object;\r\n\r\n\t\t\t\twebglObject.render = false;\r\n\r\n\t\t\t\tif ( object.visible && object.castShadow ) {\r\n\r\n\t\t\t\t\tif ( ! ( object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.intersectsObject( object ) ) {\r\n\r\n\t\t\t\t\t\tobject._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\r\n\r\n\t\t\t\t\t\twebglObject.render = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// render regular objects\r\n\r\n\t\t\tvar objectMaterial, useMorphing, useSkinning;\r\n\r\n\t\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\twebglObject = renderList[ j ];\r\n\r\n\t\t\t\tif ( webglObject.render ) {\r\n\r\n\t\t\t\t\tobject = webglObject.object;\r\n\t\t\t\t\tbuffer = webglObject.buffer;\r\n\r\n\t\t\t\t\t// culling is overriden globally for all objects\r\n\t\t\t\t\t// while rendering depth map\r\n\r\n\t\t\t\t\t// need to deal with MeshFaceMaterial somehow\r\n\t\t\t\t\t// in that case just use the first of material.materials for now\r\n\t\t\t\t\t// (proper solution would require to break objects by materials\r\n\t\t\t\t\t//  similarly to regular rendering and then set corresponding\r\n\t\t\t\t\t//  depth materials per each chunk instead of just once per object)\r\n\r\n\t\t\t\t\tobjectMaterial = getObjectMaterial( object );\r\n\r\n\t\t\t\t\tuseMorphing = object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;\r\n\t\t\t\t\tuseSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;\r\n\r\n\t\t\t\t\tif ( object.customDepthMaterial ) {\r\n\r\n\t\t\t\t\t\tmaterial = object.customDepthMaterial;\r\n\r\n\t\t\t\t\t} else if ( useSkinning ) {\r\n\r\n\t\t\t\t\t\tmaterial = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;\r\n\r\n\t\t\t\t\t} else if ( useMorphing ) {\r\n\r\n\t\t\t\t\t\tmaterial = _depthMaterialMorph;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tmaterial = _depthMaterial;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( buffer instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, scene.__lights, fog, material, buffer, object );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t_renderer.renderBuffer( shadowCamera, scene.__lights, fog, material, buffer, object );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// set matrices and render immediate objects\r\n\r\n\t\t\trenderList = scene.__webglObjectsImmediate;\r\n\r\n\t\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\twebglObject = renderList[ j ];\r\n\t\t\t\tobject = webglObject.object;\r\n\r\n\t\t\t\tif ( object.visible && object.castShadow ) {\r\n\r\n\t\t\t\t\tobject._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\r\n\r\n\t\t\t\t\t_renderer.renderImmediateObject( shadowCamera, scene.__lights, fog, _depthMaterial, object );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// restore GL state\r\n\r\n\t\tvar clearColor = _renderer.getClearColor(),\r\n\t\tclearAlpha = _renderer.getClearAlpha();\r\n\r\n\t\t_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );\r\n\t\t_gl.enable( _gl.BLEND );\r\n\r\n\t\tif ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {\r\n\r\n\t\t\t_gl.cullFace( _gl.BACK );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction createVirtualLight( light, cascade ) {\r\n\r\n\t\tvar virtualLight = new THREE.DirectionalLight();\r\n\r\n\t\tvirtualLight.isVirtual = true;\r\n\r\n\t\tvirtualLight.onlyShadow = true;\r\n\t\tvirtualLight.castShadow = true;\r\n\r\n\t\tvirtualLight.shadowCameraNear = light.shadowCameraNear;\r\n\t\tvirtualLight.shadowCameraFar = light.shadowCameraFar;\r\n\r\n\t\tvirtualLight.shadowCameraLeft = light.shadowCameraLeft;\r\n\t\tvirtualLight.shadowCameraRight = light.shadowCameraRight;\r\n\t\tvirtualLight.shadowCameraBottom = light.shadowCameraBottom;\r\n\t\tvirtualLight.shadowCameraTop = light.shadowCameraTop;\r\n\r\n\t\tvirtualLight.shadowCameraVisible = light.shadowCameraVisible;\r\n\r\n\t\tvirtualLight.shadowDarkness = light.shadowDarkness;\r\n\r\n\t\tvirtualLight.shadowBias = light.shadowCascadeBias[ cascade ];\r\n\t\tvirtualLight.shadowMapWidth = light.shadowCascadeWidth[ cascade ];\r\n\t\tvirtualLight.shadowMapHeight = light.shadowCascadeHeight[ cascade ];\r\n\r\n\t\tvirtualLight.pointsWorld = [];\r\n\t\tvirtualLight.pointsFrustum = [];\r\n\r\n\t\tvar pointsWorld = virtualLight.pointsWorld,\r\n\t\t\tpointsFrustum = virtualLight.pointsFrustum;\r\n\r\n\t\tfor ( var i = 0; i < 8; i ++ ) {\r\n\r\n\t\t\tpointsWorld[ i ] = new THREE.Vector3();\r\n\t\t\tpointsFrustum[ i ] = new THREE.Vector3();\r\n\r\n\t\t}\r\n\r\n\t\tvar nearZ = light.shadowCascadeNearZ[ cascade ];\r\n\t\tvar farZ = light.shadowCascadeFarZ[ cascade ];\r\n\r\n\t\tpointsFrustum[ 0 ].set( -1, -1, nearZ );\r\n\t\tpointsFrustum[ 1 ].set(  1, -1, nearZ );\r\n\t\tpointsFrustum[ 2 ].set( -1,  1, nearZ );\r\n\t\tpointsFrustum[ 3 ].set(  1,  1, nearZ );\r\n\r\n\t\tpointsFrustum[ 4 ].set( -1, -1, farZ );\r\n\t\tpointsFrustum[ 5 ].set(  1, -1, farZ );\r\n\t\tpointsFrustum[ 6 ].set( -1,  1, farZ );\r\n\t\tpointsFrustum[ 7 ].set(  1,  1, farZ );\r\n\r\n\t\treturn virtualLight;\r\n\r\n\t}\r\n\r\n\t// Synchronize virtual light with the original light\r\n\r\n\tfunction updateVirtualLight( light, cascade ) {\r\n\r\n\t\tvar virtualLight = light.shadowCascadeArray[ cascade ];\r\n\r\n\t\tvirtualLight.position.copy( light.position );\r\n\t\tvirtualLight.target.position.copy( light.target.position );\r\n\t\tvirtualLight.lookAt( virtualLight.target );\r\n\r\n\t\tvirtualLight.shadowCameraVisible = light.shadowCameraVisible;\r\n\t\tvirtualLight.shadowDarkness = light.shadowDarkness;\r\n\r\n\t\tvirtualLight.shadowBias = light.shadowCascadeBias[ cascade ];\r\n\r\n\t\tvar nearZ = light.shadowCascadeNearZ[ cascade ];\r\n\t\tvar farZ = light.shadowCascadeFarZ[ cascade ];\r\n\r\n\t\tvar pointsFrustum = virtualLight.pointsFrustum;\r\n\r\n\t\tpointsFrustum[ 0 ].z = nearZ;\r\n\t\tpointsFrustum[ 1 ].z = nearZ;\r\n\t\tpointsFrustum[ 2 ].z = nearZ;\r\n\t\tpointsFrustum[ 3 ].z = nearZ;\r\n\r\n\t\tpointsFrustum[ 4 ].z = farZ;\r\n\t\tpointsFrustum[ 5 ].z = farZ;\r\n\t\tpointsFrustum[ 6 ].z = farZ;\r\n\t\tpointsFrustum[ 7 ].z = farZ;\r\n\r\n\t}\r\n\r\n\t// Fit shadow camera's ortho frustum to camera frustum\r\n\r\n\tfunction updateShadowCamera( camera, light ) {\r\n\r\n\t\tvar shadowCamera = light.shadowCamera,\r\n\t\t\tpointsFrustum = light.pointsFrustum,\r\n\t\t\tpointsWorld = light.pointsWorld;\r\n\r\n\t\t_min.set( Infinity, Infinity, Infinity );\r\n\t\t_max.set( -Infinity, -Infinity, -Infinity );\r\n\r\n\t\tfor ( var i = 0; i < 8; i ++ ) {\r\n\r\n\t\t\tvar p = pointsWorld[ i ];\r\n\r\n\t\t\tp.copy( pointsFrustum[ i ] );\r\n\t\t\tTHREE.ShadowMapPlugin.__projector.unprojectVector( p, camera );\r\n\r\n\t\t\tp.applyMatrix4( shadowCamera.matrixWorldInverse );\r\n\r\n\t\t\tif ( p.x < _min.x ) _min.x = p.x;\r\n\t\t\tif ( p.x > _max.x ) _max.x = p.x;\r\n\r\n\t\t\tif ( p.y < _min.y ) _min.y = p.y;\r\n\t\t\tif ( p.y > _max.y ) _max.y = p.y;\r\n\r\n\t\t\tif ( p.z < _min.z ) _min.z = p.z;\r\n\t\t\tif ( p.z > _max.z ) _max.z = p.z;\r\n\r\n\t\t}\r\n\r\n\t\tshadowCamera.left = _min.x;\r\n\t\tshadowCamera.right = _max.x;\r\n\t\tshadowCamera.top = _max.y;\r\n\t\tshadowCamera.bottom = _min.y;\r\n\r\n\t\t// can't really fit near/far\r\n\t\t//shadowCamera.near = _min.z;\r\n\t\t//shadowCamera.far = _max.z;\r\n\r\n\t\tshadowCamera.updateProjectionMatrix();\r\n\r\n\t}\r\n\r\n\t// For the moment just ignore objects that have multiple materials with different animation methods\r\n\t// Only the first material will be taken into account for deciding which depth material to use for shadow maps\r\n\r\n\tfunction getObjectMaterial( object ) {\r\n\r\n\t\treturn object.material instanceof THREE.MeshFaceMaterial\r\n\t\t\t? object.material.materials[ 0 ]\r\n\t\t\t: object.material;\r\n\r\n\t};\r\n\r\n};\r\n\r\nTHREE.ShadowMapPlugin.__projector = new THREE.Projector();\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.SpritePlugin = function () {\r\n\r\n\tvar _gl, _renderer, _precision, _sprite = {};\r\n\r\n\tthis.init = function ( renderer ) {\r\n\r\n\t\t_gl = renderer.context;\r\n\t\t_renderer = renderer;\r\n\r\n\t\t_precision = renderer.getPrecision();\r\n\r\n\t\t_sprite.vertices = new Float32Array( 8 + 8 );\r\n\t\t_sprite.faces    = new Uint16Array( 6 );\r\n\r\n\t\tvar i = 0;\r\n\r\n\t\t_sprite.vertices[ i++ ] = -1; _sprite.vertices[ i++ ] = -1;\t// vertex 0\r\n\t\t_sprite.vertices[ i++ ] = 0;  _sprite.vertices[ i++ ] = 0;\t// uv 0\r\n\r\n\t\t_sprite.vertices[ i++ ] = 1;  _sprite.vertices[ i++ ] = -1;\t// vertex 1\r\n\t\t_sprite.vertices[ i++ ] = 1;  _sprite.vertices[ i++ ] = 0;\t// uv 1\r\n\r\n\t\t_sprite.vertices[ i++ ] = 1;  _sprite.vertices[ i++ ] = 1;\t// vertex 2\r\n\t\t_sprite.vertices[ i++ ] = 1;  _sprite.vertices[ i++ ] = 1;\t// uv 2\r\n\r\n\t\t_sprite.vertices[ i++ ] = -1; _sprite.vertices[ i++ ] = 1;\t// vertex 3\r\n\t\t_sprite.vertices[ i++ ] = 0;  _sprite.vertices[ i++ ] = 1;\t// uv 3\r\n\r\n\t\ti = 0;\r\n\r\n\t\t_sprite.faces[ i++ ] = 0; _sprite.faces[ i++ ] = 1; _sprite.faces[ i++ ] = 2;\r\n\t\t_sprite.faces[ i++ ] = 0; _sprite.faces[ i++ ] = 2; _sprite.faces[ i++ ] = 3;\r\n\r\n\t\t_sprite.vertexBuffer  = _gl.createBuffer();\r\n\t\t_sprite.elementBuffer = _gl.createBuffer();\r\n\r\n\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, _sprite.vertexBuffer );\r\n\t\t_gl.bufferData( _gl.ARRAY_BUFFER, _sprite.vertices, _gl.STATIC_DRAW );\r\n\r\n\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _sprite.elementBuffer );\r\n\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, _sprite.faces, _gl.STATIC_DRAW );\r\n\r\n\t\t_sprite.program = createProgram( THREE.ShaderSprite[ \"sprite\" ], _precision );\r\n\r\n\t\t_sprite.attributes = {};\r\n\t\t_sprite.uniforms = {};\r\n\r\n\t\t_sprite.attributes.position           = _gl.getAttribLocation ( _sprite.program, \"position\" );\r\n\t\t_sprite.attributes.uv                 = _gl.getAttribLocation ( _sprite.program, \"uv\" );\r\n\r\n\t\t_sprite.uniforms.uvOffset             = _gl.getUniformLocation( _sprite.program, \"uvOffset\" );\r\n\t\t_sprite.uniforms.uvScale              = _gl.getUniformLocation( _sprite.program, \"uvScale\" );\r\n\r\n\t\t_sprite.uniforms.rotation             = _gl.getUniformLocation( _sprite.program, \"rotation\" );\r\n\t\t_sprite.uniforms.scale                = _gl.getUniformLocation( _sprite.program, \"scale\" );\r\n\t\t_sprite.uniforms.alignment            = _gl.getUniformLocation( _sprite.program, \"alignment\" );\r\n\r\n\t\t_sprite.uniforms.color                = _gl.getUniformLocation( _sprite.program, \"color\" );\r\n\t\t_sprite.uniforms.map                  = _gl.getUniformLocation( _sprite.program, \"map\" );\r\n\t\t_sprite.uniforms.opacity              = _gl.getUniformLocation( _sprite.program, \"opacity\" );\r\n\r\n\t\t_sprite.uniforms.useScreenCoordinates = _gl.getUniformLocation( _sprite.program, \"useScreenCoordinates\" );\r\n\t\t_sprite.uniforms.sizeAttenuation   \t  = _gl.getUniformLocation( _sprite.program, \"sizeAttenuation\" );\r\n\t\t_sprite.uniforms.screenPosition    \t  = _gl.getUniformLocation( _sprite.program, \"screenPosition\" );\r\n\t\t_sprite.uniforms.modelViewMatrix      = _gl.getUniformLocation( _sprite.program, \"modelViewMatrix\" );\r\n\t\t_sprite.uniforms.projectionMatrix     = _gl.getUniformLocation( _sprite.program, \"projectionMatrix\" );\r\n\r\n\t\t_sprite.uniforms.fogType \t\t  \t  = _gl.getUniformLocation( _sprite.program, \"fogType\" );\r\n\t\t_sprite.uniforms.fogDensity \t\t  = _gl.getUniformLocation( _sprite.program, \"fogDensity\" );\r\n\t\t_sprite.uniforms.fogNear \t\t  \t  = _gl.getUniformLocation( _sprite.program, \"fogNear\" );\r\n\t\t_sprite.uniforms.fogFar \t\t  \t  = _gl.getUniformLocation( _sprite.program, \"fogFar\" );\r\n\t\t_sprite.uniforms.fogColor \t\t  \t  = _gl.getUniformLocation( _sprite.program, \"fogColor\" );\r\n\r\n\t\t_sprite.uniforms.alphaTest \t\t  \t  = _gl.getUniformLocation( _sprite.program, \"alphaTest\" );\r\n\r\n\t};\r\n\r\n\tthis.render = function ( scene, camera, viewportWidth, viewportHeight ) {\r\n\r\n\t\tvar sprites = scene.__webglSprites,\r\n\t\t\tnSprites = sprites.length;\r\n\r\n\t\tif ( ! nSprites ) return;\r\n\r\n\t\tvar attributes = _sprite.attributes,\r\n\t\t\tuniforms = _sprite.uniforms;\r\n\r\n\t\tvar invAspect = viewportHeight / viewportWidth;\r\n\r\n\t\tvar halfViewportWidth = viewportWidth * 0.5,\r\n\t\t\thalfViewportHeight = viewportHeight * 0.5;\r\n\r\n\t\t// setup gl\r\n\r\n\t\t_gl.useProgram( _sprite.program );\r\n\r\n\t\t_gl.enableVertexAttribArray( attributes.position );\r\n\t\t_gl.enableVertexAttribArray( attributes.uv );\r\n\r\n\t\t_gl.disable( _gl.CULL_FACE );\r\n\t\t_gl.enable( _gl.BLEND );\r\n\r\n\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, _sprite.vertexBuffer );\r\n\t\t_gl.vertexAttribPointer( attributes.position, 2, _gl.FLOAT, false, 2 * 8, 0 );\r\n\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 2 * 8, 8 );\r\n\r\n\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _sprite.elementBuffer );\r\n\r\n\t\t_gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\r\n\r\n\t\t_gl.activeTexture( _gl.TEXTURE0 );\r\n\t\t_gl.uniform1i( uniforms.map, 0 );\r\n\r\n\t\tvar oldFogType = 0;\r\n\t\tvar sceneFogType = 0;\r\n\t\tvar fog = scene.fog;\r\n\r\n\t\tif ( fog ) {\r\n\r\n\t\t\t_gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );\r\n\r\n\t\t\tif ( fog instanceof THREE.Fog ) {\r\n\r\n\t\t\t\t_gl.uniform1f( uniforms.fogNear, fog.near );\r\n\t\t\t\t_gl.uniform1f( uniforms.fogFar, fog.far );\r\n\r\n\t\t\t\t_gl.uniform1i( uniforms.fogType, 1 );\r\n\t\t\t\toldFogType = 1;\r\n\t\t\t\tsceneFogType = 1;\r\n\r\n\t\t\t} else if ( fog instanceof THREE.FogExp2 ) {\r\n\r\n\t\t\t\t_gl.uniform1f( uniforms.fogDensity, fog.density );\r\n\r\n\t\t\t\t_gl.uniform1i( uniforms.fogType, 2 );\r\n\t\t\t\toldFogType = 2;\r\n\t\t\t\tsceneFogType = 2;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_gl.uniform1i( uniforms.fogType, 0 );\r\n\t\t\toldFogType = 0;\r\n\t\t\tsceneFogType = 0;\r\n\r\n\t\t}\r\n\r\n\r\n\t\t// update positions and sort\r\n\r\n\t\tvar i, sprite, material, screenPosition, size, fogType, scale = [];\r\n\r\n\t\tfor( i = 0; i < nSprites; i ++ ) {\r\n\r\n\t\t\tsprite = sprites[ i ];\r\n\t\t\tmaterial = sprite.material;\r\n\r\n\t\t\tif ( ! sprite.visible || material.opacity === 0 ) continue;\r\n\r\n\t\t\tif ( ! material.useScreenCoordinates ) {\r\n\r\n\t\t\t\tsprite._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );\r\n\t\t\t\tsprite.z = - sprite._modelViewMatrix.elements[ 14 ];\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tsprite.z = - sprite.position.z;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tsprites.sort( painterSortStable );\r\n\r\n\t\t// render all sprites\r\n\r\n\t\tfor( i = 0; i < nSprites; i ++ ) {\r\n\r\n\t\t\tsprite = sprites[ i ];\r\n\t\t\tmaterial = sprite.material;\r\n\r\n\t\t\tif ( ! sprite.visible || material.opacity === 0 ) continue;\r\n\r\n\t\t\tif ( material.map && material.map.image && material.map.image.width ) {\r\n\r\n\t\t\t\t_gl.uniform1f( uniforms.alphaTest, material.alphaTest );\r\n\r\n\t\t\t\tif ( material.useScreenCoordinates === true ) {\r\n\r\n\t\t\t\t\t_gl.uniform1i( uniforms.useScreenCoordinates, 1 );\r\n\t\t\t\t\t_gl.uniform3f(\r\n\t\t\t\t\t\tuniforms.screenPosition,\r\n\t\t\t\t\t\t( ( sprite.position.x * _renderer.devicePixelRatio ) - halfViewportWidth  ) / halfViewportWidth,\r\n\t\t\t\t\t\t( halfViewportHeight - ( sprite.position.y * _renderer.devicePixelRatio ) ) / halfViewportHeight,\r\n\t\t\t\t\t\tMath.max( 0, Math.min( 1, sprite.position.z ) )\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\tscale[ 0 ] = _renderer.devicePixelRatio;\r\n\t\t\t\t\tscale[ 1 ] = _renderer.devicePixelRatio;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t_gl.uniform1i( uniforms.useScreenCoordinates, 0 );\r\n\t\t\t\t\t_gl.uniform1i( uniforms.sizeAttenuation, material.sizeAttenuation ? 1 : 0 );\r\n\t\t\t\t\t_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite._modelViewMatrix.elements );\r\n\r\n\t\t\t\t\tscale[ 0 ] = 1;\r\n\t\t\t\t\tscale[ 1 ] = 1;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( scene.fog && material.fog ) {\r\n\r\n\t\t\t\t\tfogType = sceneFogType;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tfogType = 0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( oldFogType !== fogType ) {\r\n\r\n\t\t\t\t\t_gl.uniform1i( uniforms.fogType, fogType );\r\n\t\t\t\t\toldFogType = fogType;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tsize = 1 / ( material.scaleByViewport ? viewportHeight : 1 );\r\n\r\n\t\t\t\tscale[ 0 ] *= size * invAspect * sprite.scale.x\r\n\t\t\t\tscale[ 1 ] *= size * sprite.scale.y;\r\n\r\n\t\t\t\t_gl.uniform2f( uniforms.uvScale, material.uvScale.x, material.uvScale.y );\r\n\t\t\t\t_gl.uniform2f( uniforms.uvOffset, material.uvOffset.x, material.uvOffset.y );\r\n\t\t\t\t_gl.uniform2f( uniforms.alignment, material.alignment.x, material.alignment.y );\r\n\r\n\t\t\t\t_gl.uniform1f( uniforms.opacity, material.opacity );\r\n\t\t\t\t_gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );\r\n\r\n\t\t\t\t_gl.uniform1f( uniforms.rotation, sprite.rotation );\r\n\t\t\t\t_gl.uniform2fv( uniforms.scale, scale );\r\n\r\n\t\t\t\t_renderer.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\r\n\t\t\t\t_renderer.setDepthTest( material.depthTest );\r\n\t\t\t\t_renderer.setDepthWrite( material.depthWrite );\r\n\t\t\t\t_renderer.setTexture( material.map, 0 );\r\n\r\n\t\t\t\t_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// restore gl\r\n\r\n\t\t_gl.enable( _gl.CULL_FACE );\r\n\r\n\t};\r\n\r\n\tfunction createProgram ( shader, precision ) {\r\n\r\n\t\tvar program = _gl.createProgram();\r\n\r\n\t\tvar fragmentShader = _gl.createShader( _gl.FRAGMENT_SHADER );\r\n\t\tvar vertexShader = _gl.createShader( _gl.VERTEX_SHADER );\r\n\r\n\t\tvar prefix = \"precision \" + precision + \" float;\\n\";\r\n\r\n\t\t_gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\r\n\t\t_gl.shaderSource( vertexShader, prefix + shader.vertexShader );\r\n\r\n\t\t_gl.compileShader( fragmentShader );\r\n\t\t_gl.compileShader( vertexShader );\r\n\r\n\t\t_gl.attachShader( program, fragmentShader );\r\n\t\t_gl.attachShader( program, vertexShader );\r\n\r\n\t\t_gl.linkProgram( program );\r\n\r\n\t\treturn program;\r\n\r\n\t};\r\n\r\n\tfunction painterSortStable ( a, b ) {\r\n\r\n\t\tif ( a.z !== b.z ) {\r\n\r\n\t\t\treturn b.z - a.z;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn b.id - a.id;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n};\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.DepthPassPlugin = function () {\r\n\r\n\tthis.enabled = false;\r\n\tthis.renderTarget = null;\r\n\r\n\tvar _gl,\r\n\t_renderer,\r\n\t_depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin,\r\n\r\n\t_frustum = new THREE.Frustum(),\r\n\t_projScreenMatrix = new THREE.Matrix4();\r\n\r\n\tthis.init = function ( renderer ) {\r\n\r\n\t\t_gl = renderer.context;\r\n\t\t_renderer = renderer;\r\n\r\n\t\tvar depthShader = THREE.ShaderLib[ \"depthRGBA\" ];\r\n\t\tvar depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );\r\n\r\n\t\t_depthMaterial = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms } );\r\n\t\t_depthMaterialMorph = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true } );\r\n\t\t_depthMaterialSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, skinning: true } );\r\n\t\t_depthMaterialMorphSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true, skinning: true } );\r\n\r\n\t\t_depthMaterial._shadowPass = true;\r\n\t\t_depthMaterialMorph._shadowPass = true;\r\n\t\t_depthMaterialSkin._shadowPass = true;\r\n\t\t_depthMaterialMorphSkin._shadowPass = true;\r\n\r\n\t};\r\n\r\n\tthis.render = function ( scene, camera ) {\r\n\r\n\t\tif ( ! this.enabled ) return;\r\n\r\n\t\tthis.update( scene, camera );\r\n\r\n\t};\r\n\r\n\tthis.update = function ( scene, camera ) {\r\n\r\n\t\tvar i, il, j, jl, n,\r\n\r\n\t\tprogram, buffer, material,\r\n\t\twebglObject, object, light,\r\n\t\trenderList,\r\n\r\n\t\tfog = null;\r\n\r\n\t\t// set GL state for depth map\r\n\r\n\t\t_gl.clearColor( 1, 1, 1, 1 );\r\n\t\t_gl.disable( _gl.BLEND );\r\n\r\n\t\t_renderer.setDepthTest( true );\r\n\r\n\t\t// update scene\r\n\r\n\t\tif ( _renderer.autoUpdateScene ) scene.updateMatrixWorld();\r\n\r\n\t\t// update camera matrices and frustum\r\n\r\n\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\r\n\r\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\r\n\t\t_frustum.setFromMatrix( _projScreenMatrix );\r\n\r\n\t\t// render depth map\r\n\r\n\t\t_renderer.setRenderTarget( this.renderTarget );\r\n\t\t_renderer.clear();\r\n\r\n\t\t// set object matrices & frustum culling\r\n\r\n\t\trenderList = scene.__webglObjects;\r\n\r\n\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\r\n\r\n\t\t\twebglObject = renderList[ j ];\r\n\t\t\tobject = webglObject.object;\r\n\r\n\t\t\twebglObject.render = false;\r\n\r\n\t\t\tif ( object.visible ) {\r\n\r\n\t\t\t\tif ( ! ( object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.intersectsObject( object ) ) {\r\n\r\n\t\t\t\t\tobject._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\r\n\r\n\t\t\t\t\twebglObject.render = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// render regular objects\r\n\r\n\t\tvar objectMaterial, useMorphing, useSkinning;\r\n\r\n\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\r\n\r\n\t\t\twebglObject = renderList[ j ];\r\n\r\n\t\t\tif ( webglObject.render ) {\r\n\r\n\t\t\t\tobject = webglObject.object;\r\n\t\t\t\tbuffer = webglObject.buffer;\r\n\r\n\t\t\t\t// todo: create proper depth material for particles\r\n\r\n\t\t\t\tif ( object instanceof THREE.ParticleSystem && !object.customDepthMaterial ) continue;\r\n\r\n\t\t\t\tobjectMaterial = getObjectMaterial( object );\r\n\r\n\t\t\t\tif ( objectMaterial ) _renderer.setMaterialFaces( object.material );\r\n\r\n\t\t\t\tuseMorphing = object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;\r\n\t\t\t\tuseSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;\r\n\r\n\t\t\t\tif ( object.customDepthMaterial ) {\r\n\r\n\t\t\t\t\tmaterial = object.customDepthMaterial;\r\n\r\n\t\t\t\t} else if ( useSkinning ) {\r\n\r\n\t\t\t\t\tmaterial = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;\r\n\r\n\t\t\t\t} else if ( useMorphing ) {\r\n\r\n\t\t\t\t\tmaterial = _depthMaterialMorph;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tmaterial = _depthMaterial;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( buffer instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\t\t\t_renderer.renderBufferDirect( camera, scene.__lights, fog, material, buffer, object );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t_renderer.renderBuffer( camera, scene.__lights, fog, material, buffer, object );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// set matrices and render immediate objects\r\n\r\n\t\trenderList = scene.__webglObjectsImmediate;\r\n\r\n\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\r\n\r\n\t\t\twebglObject = renderList[ j ];\r\n\t\t\tobject = webglObject.object;\r\n\r\n\t\t\tif ( object.visible ) {\r\n\r\n\t\t\t\tobject._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\r\n\r\n\t\t\t\t_renderer.renderImmediateObject( camera, scene.__lights, fog, _depthMaterial, object );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// restore GL state\r\n\r\n\t\tvar clearColor = _renderer.getClearColor(),\r\n\t\tclearAlpha = _renderer.getClearAlpha();\r\n\r\n\t\t_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );\r\n\t\t_gl.enable( _gl.BLEND );\r\n\r\n\t};\r\n\r\n\t// For the moment just ignore objects that have multiple materials with different animation methods\r\n\t// Only the first material will be taken into account for deciding which depth material to use\r\n\r\n\tfunction getObjectMaterial( object ) {\r\n\r\n\t\treturn object.material instanceof THREE.MeshFaceMaterial\r\n\t\t\t? object.material.materials[ 0 ]\r\n\t\t\t: object.material;\r\n\r\n\t};\r\n\r\n};\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n *\r\n */\r\n\r\nTHREE.ShaderFlares = {\r\n\r\n\t'lensFlareVertexTexture': {\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"uniform lowp int renderType;\",\r\n\r\n\t\t\t\"uniform vec3 screenPosition;\",\r\n\t\t\t\"uniform vec2 scale;\",\r\n\t\t\t\"uniform float rotation;\",\r\n\r\n\t\t\t\"uniform sampler2D occlusionMap;\",\r\n\r\n\t\t\t\"attribute vec2 position;\",\r\n\t\t\t\"attribute vec2 uv;\",\r\n\r\n\t\t\t\"varying vec2 vUV;\",\r\n\t\t\t\"varying float vVisibility;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vUV = uv;\",\r\n\r\n\t\t\t\t\"vec2 pos = position;\",\r\n\r\n\t\t\t\t\"if( renderType == 2 ) {\",\r\n\r\n\t\t\t\t\t\"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) ) +\",\r\n\t\t\t\t\t\t\t\t\t  \"texture2D( occlusionMap, vec2( 0.5, 0.1 ) ) +\",\r\n\t\t\t\t\t\t\t\t\t  \"texture2D( occlusionMap, vec2( 0.9, 0.1 ) ) +\",\r\n\t\t\t\t\t\t\t\t\t  \"texture2D( occlusionMap, vec2( 0.9, 0.5 ) ) +\",\r\n\t\t\t\t\t\t\t\t\t  \"texture2D( occlusionMap, vec2( 0.9, 0.9 ) ) +\",\r\n\t\t\t\t\t\t\t\t\t  \"texture2D( occlusionMap, vec2( 0.5, 0.9 ) ) +\",\r\n\t\t\t\t\t\t\t\t\t  \"texture2D( occlusionMap, vec2( 0.1, 0.9 ) ) +\",\r\n\t\t\t\t\t\t\t\t\t  \"texture2D( occlusionMap, vec2( 0.1, 0.5 ) ) +\",\r\n\t\t\t\t\t\t\t\t\t  \"texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\",\r\n\r\n\t\t\t\t\t\"vVisibility = (       visibility.r / 9.0 ) *\",\r\n\t\t\t\t\t\t\t\t  \"( 1.0 - visibility.g / 9.0 ) *\",\r\n\t\t\t\t\t\t\t\t  \"(       visibility.b / 9.0 ) *\",\r\n\t\t\t\t\t\t\t\t  \"( 1.0 - visibility.a / 9.0 );\",\r\n\r\n\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\r\n\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" ),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform lowp int renderType;\",\r\n\r\n\t\t\t\"uniform sampler2D map;\",\r\n\t\t\t\"uniform float opacity;\",\r\n\t\t\t\"uniform vec3 color;\",\r\n\r\n\t\t\t\"varying vec2 vUV;\",\r\n\t\t\t\"varying float vVisibility;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t// pink square\r\n\r\n\t\t\t\t\"if( renderType == 0 ) {\",\r\n\r\n\t\t\t\t\t\"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\",\r\n\r\n\t\t\t\t// restore\r\n\r\n\t\t\t\t\"} else if( renderType == 1 ) {\",\r\n\r\n\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\r\n\r\n\t\t\t\t// flare\r\n\r\n\t\t\t\t\"} else {\",\r\n\r\n\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\r\n\t\t\t\t\t\"texture.a *= opacity * vVisibility;\",\r\n\t\t\t\t\t\"gl_FragColor = texture;\",\r\n\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\"}\"\r\n\t\t].join( \"\\n\" )\r\n\r\n\t},\r\n\r\n\r\n\t'lensFlare': {\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"uniform lowp int renderType;\",\r\n\r\n\t\t\t\"uniform vec3 screenPosition;\",\r\n\t\t\t\"uniform vec2 scale;\",\r\n\t\t\t\"uniform float rotation;\",\r\n\r\n\t\t\t\"attribute vec2 position;\",\r\n\t\t\t\"attribute vec2 uv;\",\r\n\r\n\t\t\t\"varying vec2 vUV;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vUV = uv;\",\r\n\r\n\t\t\t\t\"vec2 pos = position;\",\r\n\r\n\t\t\t\t\"if( renderType == 2 ) {\",\r\n\r\n\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\r\n\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" ),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"precision mediump float;\",\r\n\r\n\t\t\t\"uniform lowp int renderType;\",\r\n\r\n\t\t\t\"uniform sampler2D map;\",\r\n\t\t\t\"uniform sampler2D occlusionMap;\",\r\n\t\t\t\"uniform float opacity;\",\r\n\t\t\t\"uniform vec3 color;\",\r\n\r\n\t\t\t\"varying vec2 vUV;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t// pink square\r\n\r\n\t\t\t\t\"if( renderType == 0 ) {\",\r\n\r\n\t\t\t\t\t\"gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\",\r\n\r\n\t\t\t\t// restore\r\n\r\n\t\t\t\t\"} else if( renderType == 1 ) {\",\r\n\r\n\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\r\n\r\n\t\t\t\t// flare\r\n\r\n\t\t\t\t\"} else {\",\r\n\r\n\t\t\t\t\t\"float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a +\",\r\n\t\t\t\t\t\t\t\t\t   \"texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a +\",\r\n\t\t\t\t\t\t\t\t\t   \"texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a +\",\r\n\t\t\t\t\t\t\t\t\t   \"texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\",\r\n\r\n\t\t\t\t\t\"visibility = ( 1.0 - visibility / 4.0 );\",\r\n\r\n\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\r\n\t\t\t\t\t\"texture.a *= opacity * visibility;\",\r\n\t\t\t\t\t\"gl_FragColor = texture;\",\r\n\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" )\r\n\r\n\t}\r\n\r\n};\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n */\r\n\r\nTHREE.ShaderSprite = {\r\n\r\n\t'sprite': {\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"uniform int useScreenCoordinates;\",\r\n\t\t\t\"uniform int sizeAttenuation;\",\r\n\t\t\t\"uniform vec3 screenPosition;\",\r\n\t\t\t\"uniform mat4 modelViewMatrix;\",\r\n\t\t\t\"uniform mat4 projectionMatrix;\",\r\n\t\t\t\"uniform float rotation;\",\r\n\t\t\t\"uniform vec2 scale;\",\r\n\t\t\t\"uniform vec2 alignment;\",\r\n\t\t\t\"uniform vec2 uvOffset;\",\r\n\t\t\t\"uniform vec2 uvScale;\",\r\n\r\n\t\t\t\"attribute vec2 position;\",\r\n\t\t\t\"attribute vec2 uv;\",\r\n\r\n\t\t\t\"varying vec2 vUV;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vUV = uvOffset + uv * uvScale;\",\r\n\r\n\t\t\t\t\"vec2 alignedPosition = position + alignment;\",\r\n\r\n\t\t\t\t\"vec2 rotatedPosition;\",\r\n\t\t\t\t\"rotatedPosition.x = ( cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y ) * scale.x;\",\r\n\t\t\t\t\"rotatedPosition.y = ( sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y ) * scale.y;\",\r\n\r\n\t\t\t\t\"vec4 finalPosition;\",\r\n\r\n\t\t\t\t\"if( useScreenCoordinates != 0 ) {\",\r\n\r\n\t\t\t\t\t\"finalPosition = vec4( screenPosition.xy + rotatedPosition, screenPosition.z, 1.0 );\",\r\n\r\n\t\t\t\t\"} else {\",\r\n\r\n\t\t\t\t\t\"finalPosition = projectionMatrix * modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\",\r\n\t\t\t\t\t\"finalPosition.xy += rotatedPosition * ( sizeAttenuation == 1 ? 1.0 : finalPosition.z );\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"gl_Position = finalPosition;\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" ),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform vec3 color;\",\r\n\t\t\t\"uniform sampler2D map;\",\r\n\t\t\t\"uniform float opacity;\",\r\n\r\n\t\t\t\"uniform int fogType;\",\r\n\t\t\t\"uniform vec3 fogColor;\",\r\n\t\t\t\"uniform float fogDensity;\",\r\n\t\t\t\"uniform float fogNear;\",\r\n\t\t\t\"uniform float fogFar;\",\r\n\t\t\t\"uniform float alphaTest;\",\r\n\r\n\t\t\t\"varying vec2 vUV;\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\r\n\r\n\t\t\t\t\"if ( texture.a < alphaTest ) discard;\",\r\n\r\n\t\t\t\t\"gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\",\r\n\r\n\t\t\t\t\"if ( fogType > 0 ) {\",\r\n\r\n\t\t\t\t\t\"float depth = gl_FragCoord.z / gl_FragCoord.w;\",\r\n\t\t\t\t\t\"float fogFactor = 0.0;\",\r\n\r\n\t\t\t\t\t\"if ( fogType == 1 ) {\",\r\n\r\n\t\t\t\t\t\t\"fogFactor = smoothstep( fogNear, fogFar, depth );\",\r\n\r\n\t\t\t\t\t\"} else {\",\r\n\r\n\t\t\t\t\t\t\"const float LOG2 = 1.442695;\",\r\n\t\t\t\t\t\t\"float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\",\r\n\t\t\t\t\t\t\"fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\",\r\n\r\n\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\t\"gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\",\r\n\r\n\t\t\t\t\"}\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join( \"\\n\" )\r\n\r\n\t}\r\n\r\n};\r\n\r\n// Export the THREE object for **Node.js**, with\r\n// backwards-compatibility for the old `require()` API. If we're in\r\n// the browser, add `_` as a global object via a string identifier,\r\n// for Closure Compiler \"advanced\" mode.\r\nif (true) {\r\n  if (typeof module !== 'undefined' && module.exports) {\r\n    exports = module.exports = THREE;\r\n  }\r\n  exports.THREE = THREE;\r\n} else {\r\n  this['THREE'] = THREE;\r\n}\r\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(33)))//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2RtaWxsZXQvUHJvamVjdHMvZnB0L2ZwdC1vbGQvfi90aHJlZS90aHJlZS5qcz83NTVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUJBQXVCOztBQUV2Qjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCOztBQUV0Qjs7QUFFQSxxQkFBcUI7QUFDckIsb0JBQW9CO0FBQ3BCLHNCQUFzQjtBQUN0QixxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsbUNBQW1DLFFBQVE7O0FBRTNDO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRiw2QkFBNkI7O0FBRTdCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixxREFBcUQ7O0FBRXRFO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSwyQ0FBMkMsbUNBQW1DLEVBQUU7QUFDaEY7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSwrRUFBK0U7O0FBRS9FLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBLHNEQUFzRDs7QUFFdEQsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEscUJBQXFCLEVBQUU7O0FBRXZCLDZCQUE2QixFQUFFOztBQUUvQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUEsYUFBYTs7QUFFYjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBLHlEQUF5RDtBQUN6RCx5Q0FBeUM7QUFDekMseUNBQXlDOztBQUV6Qzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLGFBQWEsWUFBWTs7QUFFekI7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVELHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7O0FBR0Y7O0FBRUE7O0FBRUEsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUI7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLDBEQUEwRDs7QUFFMUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxnQkFBZ0I7O0FBRWhCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7O0FBRXRDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxJQUFJLHNCQUFzQjs7QUFFMUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBLElBQUksT0FBTzs7QUFFWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsZUFBZTs7QUFFZjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDOztBQUV6Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHVDQUF1QyxRQUFROztBQUUvQzs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHVDQUF1QyxRQUFROztBQUUvQzs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw4RUFBOEU7QUFDOUUsOEVBQThFO0FBQzlFLDhFQUE4RTtBQUM5RSw4RUFBOEU7QUFDOUUsOEVBQThFO0FBQzlFLDhFQUE4RTtBQUM5RSw4RUFBOEU7QUFDOUUsOEVBQThFOztBQUU5RTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsY0FBYyxhQUFhO0FBQzNCLGNBQWMsYUFBYTtBQUMzQixjQUFjLGFBQWE7O0FBRTNCOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLGtDQUFrQyxRQUFROztBQUUxQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsWUFBWTtBQUN6QixhQUFhLFlBQVk7O0FBRXpCOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwyQjs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsYUFBYSxhQUFhO0FBQzFCLGFBQWEsYUFBYTtBQUMxQixhQUFhLGFBQWE7O0FBRTFCOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FB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OztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwyQjs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxhQUFhLFlBQVk7QUFDekIsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsWUFBWTtBQUN6QixhQUFhLFlBQVk7O0FBRXpCOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxXQUFXLFdBQVc7QUFDbEMsWUFBWSxXQUFXLFdBQVc7QUFDbEMsWUFBWSxXQUFXLFlBQVk7QUFDbkMsWUFBWSxXQUFXLGNBQWM7O0FBRXJDOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFdBQVcsV0FBVztBQUN0QyxZQUFZLGVBQWUsV0FBVztBQUN0QyxZQUFZLFdBQVcsZUFBZTtBQUN0QyxZQUFZLFdBQVcsWUFBWTs7QUFFbkM7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxzQ0FBc0MsUUFBUTs7QUFFOUM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLGlCQUFpQixPQUFPOztBQUV4Qjs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLE9BQU87O0FBRTFCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixPQUFPOztBQUV6Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLGtCQUFrQixPQUFPOztBQUV6Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0EsNkNBQTZDOztBQUU3Qzs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7O0FBR0Y7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOzs7QUFHRjs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsa0JBQWtCLGNBQWM7O0FBRWhDLHVCQUF1Qjs7QUFFdkI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsY0FBYyxPQUFPOztBQUVyQjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxjQUFjLGNBQWM7O0FBRTVCOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFVBQVU7O0FBRVY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsY0FBYyx3QkFBd0I7O0FBRXRDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxlQUFlLGtCQUFrQjs7QUFFakM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsNkNBQTZDLE9BQU87O0FBRXBEOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwrQ0FBK0MsUUFBUTs7QUFFdkQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGtFQUFrRTs7QUFFbEU7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMENBQTBDLE9BQU87O0FBRWpEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FBc0MsT0FBTzs7QUFFN0M7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLDRDQUE0QyxPQUFPOztBQUVuRDs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBLDRDQUE0QyxPQUFPOztBQUVuRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLDRDQUE0QyxPQUFPOztBQUVuRDs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDRDQUE0QyxPQUFPOztBQUVuRDs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esd0ZBQXdGO0FBQ3hGO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQiwwQkFBMEI7O0FBRTVDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixxREFBcUQ7O0FBRXJFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnREFBZ0QsUUFBUTs7QUFFeEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLCtDQUErQyxRQUFROztBQUV2RDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNDQUFzQyxRQUFROztBQUU5Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUNBQW1DLFFBQVE7O0FBRTNDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUTs7QUFFUjs7QUFFQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUTs7QUFFUjs7QUFFQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGdEQUFnRCxRQUFROztBQUV4RDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsNENBQTRDLFFBQVE7O0FBRXBEOztBQUVBOztBQUVBLG1DQUFtQyxRQUFROztBQUUzQzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNDQUFzQyxRQUFROztBQUU5QztBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwrQ0FBK0MsUUFBUTs7QUFFdkQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RCw2Q0FBNkMsUUFBUTtBQUNyRCwrQ0FBK0MsUUFBUTs7QUFFdkQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQsNkNBQTZDLFFBQVE7QUFDckQsK0NBQStDLFFBQVE7O0FBRXZEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQixtQkFBbUI7O0FBRW5COztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUI7O0FBRXJCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDZDQUE2QyxRQUFROztBQUVyRDtBQUNBOztBQUVBOztBQUVBLDBDQUEwQyxRQUFROztBQUVsRDtBQUNBOztBQUVBLG1EQUFtRCxRQUFROztBQUUzRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLHNDQUFzQyxRQUFROztBQUU5QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLDBDQUEwQyxRQUFROztBQUVsRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDBDQUEwQyxRQUFROztBQUVsRDs7QUFFQTs7QUFFQSx1Q0FBdUMsUUFBUTs7QUFFL0M7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBLDBDQUEwQyxRQUFROztBQUVsRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsUUFBUTs7QUFFL0M7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSCx1Q0FBdUMsUUFBUTs7QUFFL0M7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEseUNBQXlDLFFBQVE7O0FBRWpEOztBQUVBOztBQUVBLHNDQUFzQyxRQUFROztBQUU5Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7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Q0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUNBQW1DLFFBQVE7O0FBRTNDO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsUUFBUTs7QUFFL0M7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUNBQW1DLFFBQVE7O0FBRTNDO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsUUFBUTs7QUFFL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUEsdUJBQXVCLGtCQUFrQjs7QUFFekM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxrQkFBa0Isc0JBQXNCOztBQUV4Qzs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBLHdDQUF3QyxRQUFROztBQUVoRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGVBQWU7O0FBRWY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7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Tzs7QUFFUDs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1QkFBdUIsK0JBQStCOztBQUV0RDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLFFBQVE7O0FBRVI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDJCQUEyQixpREFBaUQ7O0FBRTVFO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNCQUFzQiwyQkFBMkI7O0FBRWpEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7OztBQUdBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQix5QkFBeUI7O0FBRTNDOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQiw0QkFBNEI7O0FBRTlDOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsV0FBVzs7QUFFN0I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEscUJBQXFCOztBQUVyQjs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLHlDQUF5Qzs7QUFFNUQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHlCQUF5QixpQ0FBaUM7O0FBRTFELEdBQUc7O0FBRUg7O0FBRUEseUJBQXlCLDZEQUE2RDs7QUFFdEYsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVCQUF1Qjs7QUFFdkI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBLElBQUk7O0FBRUo7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxzQkFBc0Isa0JBQWtCOztBQUV4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDBDQUEwQzs7QUFFMUM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSwwQ0FBMEM7QUFDMUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHdCQUF3QixpQkFBaUIsc0JBQXNCLEVBQUU7QUFDaEc7QUFDQSxjQUFjLG9CQUFvQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQztBQUN0QyxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCOztBQUVsQixxQkFBcUI7O0FBRXJCLG9DQUFvQzs7QUFFcEMsdUJBQXVCOztBQUV2QiwyQkFBMkI7QUFDM0IsMkJBQTJCOztBQUUzQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBLHVCQUF1QixrQkFBa0I7O0FBRXpDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGVBQWU7QUFDZjs7QUFFQSw4QkFBOEI7O0FBRTlCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9EQUFvRCxRQUFROztBQUU1RDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsdURBQXVEOztBQUV2RDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQzs7QUFFdEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsaUJBQWlCLHNCQUFzQjs7QUFFdkM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMEJBQTBCLDJEQUEyRDtBQUNyRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixzQkFBc0I7O0FBRXhDOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQSxRQUFRLHNCQUFzQjs7QUFFOUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsaUJBQWlCLDRCQUE0Qjs7QUFFN0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGlCQUFpQiw0QkFBNEI7O0FBRTdDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGVBQWUsa0JBQWtCOztBQUVqQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCOztBQUV4Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx5Q0FBeUMsUUFBUTs7QUFFakQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSw4QkFBOEI7O0FBRTlCOztBQUVBLElBQUk7O0FBRUoscUJBQXFCOztBQUVyQiw2Q0FBNkM7QUFDN0MsNkNBQTZDOztBQUU3Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKLHFCQUFxQixrQkFBa0I7O0FBRXZDO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkM7QUFDN0MsNkNBQTZDO0FBQzdDLDZDQUE2Qzs7QUFFN0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUoscUJBQXFCLGtCQUFrQixrQkFBa0I7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2QztBQUM3Qyw2Q0FBNkM7QUFDN0MsNkNBQTZDO0FBQzdDLDZDQUE2Qzs7QUFFN0M7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdDQUF3QyxRQUFROztBQUVoRDtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3Q0FBd0MsUUFBUTs7QUFFaEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCOztBQUU5Qjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLE1BQU07Ozs7QUFJTixNQUFNOzs7QUFHTixLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4Qjs7QUFFOUI7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7O0FBSUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFlBQVk7QUFDWixZQUFZOztBQUVaLFlBQVk7QUFDWixZQUFZOztBQUVaOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7O0FBRWYsWUFBWTtBQUNaLFlBQVk7O0FBRVosWUFBWTtBQUNaLFlBQVk7O0FBRVo7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtREFBbUQsUUFBUTs7QUFFM0Q7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbURBQW1ELFFBQVE7O0FBRTNEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHlEQUF5RCxRQUFROztBQUVqRTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx5REFBeUQsUUFBUTs7QUFFakU7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixPQUFPOztBQUUxQjtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQ0FBcUMsUUFBUTs7QUFFN0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLFFBQVE7O0FBRTlDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsbURBQW1ELFFBQVE7O0FBRTNEOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1EQUFtRCxRQUFROztBQUUzRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1EQUFtRCxRQUFROztBQUUzRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtREFBbUQsUUFBUTs7QUFFM0Q7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsZUFBZSxRQUFROztBQUV2Qjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGVBQWUsUUFBUTs7QUFFdkI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGVBQWUsUUFBUTs7QUFFdkI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDhDQUE4QyxRQUFROztBQUV0RDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsVUFBVTs7QUFFN0I7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTixtQkFBbUIsVUFBVTs7QUFFN0I7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBLG9CQUFvQixVQUFVOztBQUU5Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUCxvQkFBb0IsVUFBVTs7QUFFOUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU4sbUJBQW1CLFVBQVU7O0FBRTdCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUEsZ0JBQWdCLFFBQVE7O0FBRXhCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxnQkFBZ0IsUUFBUTs7QUFFeEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDhDQUE4QyxRQUFROztBQUV0RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLFVBQVU7O0FBRTlCOztBQUVBOztBQUVBLE9BQU87O0FBRVAsb0JBQW9CLFVBQVU7O0FBRTlCOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQSxxQkFBcUIsVUFBVTs7QUFFL0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLFFBQVE7O0FBRVIscUJBQXFCLFVBQVU7O0FBRS9COztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQLG9CQUFvQixVQUFVOztBQUU5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsNkNBQTZDLFFBQVE7O0FBRXJEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZUFBZSxRQUFROztBQUV2Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxlQUFlLFFBQVE7O0FBRXZCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGVBQWUsUUFBUTs7QUFFdkI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSw2Q0FBNkMsUUFBUTs7QUFFckQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixVQUFVOztBQUU3Qjs7QUFFQTs7QUFFQSxNQUFNOztBQUVOLG1CQUFtQixVQUFVOztBQUU3Qjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUEsb0JBQW9CLFVBQVU7O0FBRTlCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQLG9CQUFvQixVQUFVOztBQUU5Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTixtQkFBbUIsVUFBVTs7QUFFN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsZUFBZSxRQUFROztBQUV2Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxlQUFlLFFBQVE7O0FBRXZCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGVBQWUsUUFBUTs7QUFFdkI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsNkNBQTZDLFFBQVE7O0FBRXJEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsVUFBVTs7QUFFN0I7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTixtQkFBbUIsVUFBVTs7QUFFN0I7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBLG9CQUFvQixVQUFVOztBQUU5Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUCxvQkFBb0IsVUFBVTs7QUFFOUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU4sbUJBQW1CLFVBQVU7O0FBRTdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEseUNBQXlDLFFBQVE7O0FBRWpEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx5Q0FBeUMsUUFBUTs7QUFFakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsMkNBQTJDLFVBQVU7O0FBRXJEOztBQUVBLDBDQUEwQyxRQUFROztBQUVsRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMENBQTBDLFFBQVE7O0FBRWxEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx5Q0FBeUMsUUFBUTs7QUFFakQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx5Q0FBeUMsUUFBUTs7QUFFakQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHlDQUF5QyxRQUFROztBQUVqRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx5Q0FBeUMsUUFBUTs7QUFFakQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHlDQUF5QyxRQUFROztBQUVqRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEseUNBQXlDLFFBQVE7O0FBRWpEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEseUNBQXlDLFFBQVE7O0FBRWpEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsaUJBQWlCLE9BQU87O0FBRXhCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMLGlCQUFpQixPQUFPOztBQUV4QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEseUNBQXlDLFFBQVE7O0FBRWpEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsaUJBQWlCLE9BQU87O0FBRXhCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMLGlCQUFpQixPQUFPOztBQUV4QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx5Q0FBeUMsUUFBUTs7QUFFakQ7O0FBRUE7O0FBRUE7O0FBRUEsZ0JBQWdCLE9BQU87O0FBRXZCOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEseUNBQXlDLFFBQVE7O0FBRWpEOztBQUVBOztBQUVBOztBQUVBLGdCQUFnQixPQUFPOztBQUV2Qjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEseUNBQXlDLFFBQVE7O0FBRWpEOztBQUVBOztBQUVBOztBQUVBLGdCQUFnQixPQUFPOztBQUV2Qjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHlDQUF5QyxRQUFROztBQUVqRDs7QUFFQTs7QUFFQTs7QUFFQSxnQkFBZ0IsT0FBTzs7QUFFdkI7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHlDQUF5QyxRQUFROztBQUVqRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEseUNBQXlDLFFBQVE7O0FBRWpEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsNkNBQTZDLFFBQVE7O0FBRXJEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsNENBQTRDLFFBQVE7O0FBRXBEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSw0Q0FBNEMsUUFBUTs7QUFFcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTiw0Q0FBNEMsUUFBUTs7QUFFcEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDRDQUE0QyxRQUFROztBQUVwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBLDRDQUE0QyxRQUFROztBQUVwRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsNENBQTRDLFFBQVE7O0FBRXBEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTiw0Q0FBNEMsUUFBUTs7QUFFcEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDRDQUE0QyxRQUFROztBQUVwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQSw0Q0FBNEMsUUFBUTs7QUFFcEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDRDQUE0QyxRQUFROztBQUVwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTiw0Q0FBNEMsUUFBUTs7QUFFcEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDRDQUE0QyxRQUFROztBQUVwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTiw0Q0FBNEMsUUFBUTs7QUFFcEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDRDQUE0QyxRQUFROztBQUVwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQSw0Q0FBNEMsUUFBUTs7QUFFcEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDRDQUE0QyxRQUFROztBQUVwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOLDRDQUE0QyxRQUFROztBQUVwRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsNENBQTRDLFFBQVE7O0FBRXBEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU4sNENBQTRDLFFBQVE7O0FBRXBEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSw0Q0FBNEMsUUFBUTs7QUFFcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLFFBQVE7O0FBRXZCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHlDQUF5QyxRQUFROztBQUVqRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1SEFBdUg7O0FBRXZIOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1R0FBdUc7O0FBRXZHO0FBQ0Esc0RBQXNEO0FBQ3REOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVFQUF1RSxRQUFROztBQUUvRTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxRQUFROztBQUV2Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLFFBQVE7O0FBRTlDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyxRQUFROztBQUU5QztBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLFFBQVE7O0FBRS9DOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsV0FBVzs7QUFFakM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDBDQUEwQyxRQUFROztBQUVsRDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUgsc0NBQXNDLDBEQUEwRCxFQUFFOztBQUVsRzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSwwQ0FBMEMsUUFBUTs7QUFFbEQ7QUFDQTs7QUFFQTs7QUFFQSxpQ0FBaUM7O0FBRWpDOztBQUVBOztBQUVBOztBQUVBLDRDQUE0Qzs7QUFFNUM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSw2Q0FBNkM7O0FBRTdDOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG9EQUFvRCxRQUFROztBQUU1RDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFdBQVc7O0FBRVg7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUEsNERBQTRELFFBQVE7O0FBRXBFOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBLEdBQUc7O0FBRUg7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQ0FBbUMsUUFBUTs7QUFFM0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUNBQW1DLFFBQVE7O0FBRTNDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQSxHQUFHOztBQUVIOztBQUVBLEdBQUc7O0FBRUg7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQSxHQUFHOztBQUVIOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsZUFBZSwwQkFBMEI7O0FBRXpDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGVBQWUsMEJBQTBCOztBQUV6Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBLElBQUk7O0FBRUo7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQSxHQUFHOztBQUVIOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDOztBQUU5Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLFFBQVE7O0FBRS9DOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQ0FBb0MsUUFBUTs7QUFFNUM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHdCQUF3Qjs7QUFFeEI7O0FBRUEsSUFBSSwyQkFBMkI7O0FBRS9COztBQUVBLElBQUksNEJBQTRCOztBQUVoQzs7QUFFQSxJQUFJLDRCQUE0Qjs7QUFFaEM7O0FBRUEsSUFBSSw0QkFBNEI7O0FBRWhDOztBQUVBLElBQUksMkJBQTJCOztBQUUvQjs7QUFFQSxJQUFJLDZCQUE2Qjs7QUFFakM7O0FBRUEsSUFBSSw0QkFBNEI7O0FBRWhDOztBQUVBLElBQUksNkJBQTZCOztBQUVqQzs7QUFFQSxJQUFJLDRCQUE0Qjs7QUFFaEM7O0FBRUEsSUFBSSw2QkFBNkI7O0FBRWpDOztBQUVBOztBQUVBOztBQUVBLG1DQUFtQyxRQUFROztBQUUzQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLElBQUksNkJBQTZCOztBQUVqQzs7QUFFQTs7QUFFQTs7QUFFQSxtQ0FBbUMsUUFBUTs7QUFFM0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLElBQUksNkJBQTZCOztBQUVqQzs7QUFFQTs7QUFFQTs7QUFFQSxtQ0FBbUMsUUFBUTs7QUFFM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSSwyQkFBMkI7O0FBRS9COztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSSw2QkFBNkI7O0FBRWpDOztBQUVBOztBQUVBOztBQUVBLG1DQUFtQyxRQUFROztBQUUzQzs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJLDJCQUEyQjs7QUFFL0I7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUEsSUFBSSw0QkFBNEI7O0FBRWhDOztBQUVBOztBQUVBOztBQUVBLDBDQUEwQyxRQUFROztBQUVsRDs7QUFFQTs7QUFFQTs7QUFFQSwwQ0FBMEMsUUFBUTs7QUFFbEQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLFFBQVE7O0FBRTFDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDJFQUEyRSxRQUFRO0FBQ25GLGlGQUFpRixRQUFRO0FBQ3pGLDhFQUE4RSxRQUFRO0FBQ3RGLGlGQUFpRixRQUFRO0FBQ3pGLG9GQUFvRixRQUFROztBQUU1RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxxQ0FBcUMsUUFBUTs7QUFFN0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUM7O0FBRXZDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNkJBQTZCO0FBQzdCLGlDQUFpQztBQUNqQyxrQ0FBa0M7QUFDbEMsNEJBQTRCO0FBQzVCLDhCQUE4QjtBQUM5QixnQ0FBZ0M7O0FBRWhDLDRCQUE0QjtBQUM1QiwwQkFBMEI7QUFDMUIsc0JBQXNCO0FBQ3RCLHVCQUF1Qjs7QUFFdkI7O0FBRUEsMEJBQTBCOztBQUUxQjs7QUFFQTs7QUFFQSxpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDLGlDQUFpQztBQUNqQyxpQ0FBaUM7O0FBRWpDOztBQUVBLGtDQUFrQztBQUNsQyxrQ0FBa0M7QUFDbEMsa0NBQWtDO0FBQ2xDLGtDQUFrQzs7QUFFbEM7O0FBRUEsa0NBQWtDO0FBQ2xDLGtDQUFrQztBQUNsQyxrQ0FBa0M7QUFDbEMsa0NBQWtDOztBQUVsQzs7QUFFQTs7QUFFQTs7QUFFQSw4QkFBOEI7QUFDOUIsK0JBQStCOztBQUUvQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUM7O0FBRXZDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCLGdDQUFnQztBQUNoQzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsY0FBYyxnQ0FBZ0M7O0FBRTlDOztBQUVBOztBQUVBLGNBQWMsZ0NBQWdDOztBQUU5Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsNkNBQTZDOztBQUVoRTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxxQ0FBcUMsT0FBTzs7QUFFNUM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxxQ0FBcUMsT0FBTzs7QUFFNUM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FBc0MsUUFBUTs7QUFFOUM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMENBQTBDLFFBQVE7O0FBRWxEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUEsd0NBQXdDLFFBQVE7O0FBRWhEO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSSxPQUFPOztBQUVYO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQ0FBMEMsUUFBUTs7QUFFbEQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQixPQUFPOztBQUUzQjs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQixPQUFPOztBQUUzQjs7QUFFQTs7QUFFQSwwQ0FBMEMsUUFBUTs7QUFFbEQ7QUFDQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixPQUFPOztBQUUzQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0NBQWtDLFFBQVE7O0FBRTFDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFVBQVU7O0FBRVY7O0FBRUE7O0FBRUE7O0FBRUEsa0NBQWtDLFFBQVE7O0FBRTFDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsNkRBQTZELGtKQUFrSjs7QUFFL007O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDhDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxzQkFBc0Isa0JBQWtCOztBQUV4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx5QkFBeUI7O0FBRXpCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEseUNBQXlDLFFBQVE7O0FBRWpEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtDQUFrQyxRQUFROztBQUUxQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxrREFBa0QsUUFBUTs7QUFFMUQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsaURBQWlELFFBQVE7O0FBRXpEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsZ0NBQWdDLFFBQVE7O0FBRXhDOztBQUVBLG1DQUFtQyxRQUFROztBQUUzQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLGtEQUFrRCxRQUFROztBQUUxRDs7QUFFQTs7QUFFQTs7QUFFQSw4Q0FBOEMsUUFBUTs7QUFFdEQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxjQUFjLFFBQVE7O0FBRXRCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsY0FBYyxPQUFPOztBQUVyQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEscUNBQXFDLFFBQVE7O0FBRTdDOztBQUVBLG9DQUFvQyxRQUFROztBQUU1Qzs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRDQUE0QyxRQUFROztBQUVwRDs7QUFFQTs7QUFFQSxrREFBa0QsUUFBUTs7QUFFMUQ7O0FBRUE7O0FBRUEsMENBQTBDLFFBQVE7O0FBRWxEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxvREFBb0QsUUFBUTs7QUFFNUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw4Q0FBOEMsUUFBUTs7QUFFdEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQSw4Q0FBOEMsUUFBUTs7QUFFdEQ7O0FBRUE7O0FBRUEsb0RBQW9ELFFBQVE7O0FBRTVEOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFVBQVU7O0FBRWhDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxxQ0FBcUMsUUFBUTs7QUFFN0M7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyxRQUFROztBQUU5QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHFCQUFxQixXQUFXOztBQUVoQyxxQkFBcUI7O0FBRXJCLHNCQUFzQixxQkFBcUI7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxhQUFhLGdCQUFnQjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsY0FBYyxLQUFLLHdCQUF3Qjs7QUFFM0M7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHFCQUFxQjs7QUFFckI7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw2Q0FBNkM7O0FBRTdDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjs7QUFFQTs7QUFFQSw4QkFBOEI7QUFDOUIsa0NBQWtDO0FBQ2xDLCtCQUErQjtBQUMvQiw4QkFBOEI7O0FBRTlCOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7OztBQUdBLG1DQUFtQztBQUNuQztBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEs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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLFFBQVE7O0FBRS9DOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGVBQWUsZ0JBQWdCOztBQUUvQjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQSxlQUFlLGdCQUFnQjs7QUFFL0I7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGVBQWUsUUFBUTs7QUFFdkI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGVBQWUsaUJBQWlCOztBQUVoQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLGlCQUFpQjs7QUFFaEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLFFBQVE7O0FBRS9DOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsb0NBQW9DLFFBQVE7O0FBRTVDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUEsb0NBQW9DLFFBQVE7O0FBRTVDOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsYUFBYSxRQUFROztBQUVyQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxhQUFhLFFBQVE7O0FBRXJCOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLCtCQUErQjtBQUMvQjs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxrQkFBa0I7O0FBRWhDOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0Isa0JBQWtCOztBQUVsQztBQUNBOztBQUVBLGdCQUFnQixrQkFBa0I7O0FBRWxDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBCQUEwQiw0QkFBNEI7QUFDdEQ7O0FBRUEseUJBQXlCLDBCQUEwQjtBQUNuRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkJBQTJCLDRCQUE0QjtBQUN2RDs7QUFFQSwwQkFBMEIsMEJBQTBCO0FBQ3BEOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4REFBOEQ7O0FBRTlEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTs7QUFFQSxxQ0FBcUMsUUFBUTs7QUFFN0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEscUNBQXFDLFFBQVE7O0FBRTdDOztBQUVBLGVBQWUsT0FBTzs7QUFFdEI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLFFBQVE7O0FBRS9DOztBQUVBLGVBQWUsT0FBTzs7QUFFdEI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE1BQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBLGlCQUFpQixvQkFBb0I7QUFDckM7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0JBQWtCLHVCQUF1Qjs7QUFFekM7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxpQkFBaUIsMEJBQTBCO0FBQzNDOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQSxpQkFBaUIsMkJBQTJCOztBQUU1QyxrQkFBa0IscUNBQXFDOztBQUV2RDs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQixxQ0FBcUM7O0FBRXpELHFCQUFxQix1REFBdUQ7O0FBRTVFO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBLG9CQUFvQixxQ0FBcUM7O0FBRXpEOztBQUVBOztBQUVBLHNCQUFzQix1REFBdUQ7O0FBRTdFOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBLG1CQUFtQixxQ0FBcUM7O0FBRXhEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBLG1CQUFtQixxQ0FBcUM7O0FBRXhEOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQiwyQkFBMkI7QUFDNUM7OztBQUdBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsY0FBYyxRQUFROztBQUV0Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLHFDQUFxQztBQUNyQyxxQ0FBcUM7QUFDckM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0EsNkNBQTZDLFFBQVE7O0FBRXJEO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLE9BQU87O0FBRXpCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsUUFBUSxtQkFBbUI7O0FBRTNCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7O0FBR0EsUUFBUSxVQUFVOztBQUVsQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw2Q0FBNkMsUUFBUTs7QUFFckQ7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQixpQkFBaUI7O0FBRXBDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWMsUUFBUTs7QUFFdEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7OztBQUlBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUEsaUJBQWlCLGdDQUFnQzs7QUFFakQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDhDQUE4QyxRQUFROztBQUV0RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0IsaUJBQWlCOztBQUVyQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsNkNBQTZDLFFBQVE7O0FBRXJEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQiwyQkFBMkI7O0FBRTlDOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxRQUFRLG1CQUFtQjs7QUFFM0I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxRQUFRLFVBQVU7O0FBRWxCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVGQUF1Rix3RkFBd0Y7O0FBRS9LOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsUUFBUTs7QUFFM0M7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDZFQUE2RTtBQUM3RTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0JBQWdCLGVBQWU7O0FBRS9COztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxnQkFBZ0IsZUFBZTs7QUFFL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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RUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DLE9BQU87O0FBRTNDOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsZ0NBQWdDLE9BQU87O0FBRXZDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLCtCQUErQixPQUFPOztBQUV0QztBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLFVBQVU7O0FBRXZCOztBQUVBOztBQUVBOztBQUVBLGFBQWEsVUFBVTs7QUFFdkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdDQUFnQyxTQUFTOztBQUV6Qzs7QUFFQTtBQUNBOztBQUVBLHNDQUFzQyxRQUFROztBQUU5Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsZ0NBQWdDLFFBQVE7O0FBRXhDLDBDQUEwQyxRQUFROztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxjQUFjLGFBQWE7O0FBRTNCLGVBQWUsYUFBYTs7QUFFNUI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxjQUFjLFlBQVk7O0FBRTFCLGVBQWUsWUFBWTs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGFBQWEsMEJBQTBCOztBQUV2QztBQUNBOztBQUVBLGNBQWMseUJBQXlCOztBQUV2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxhQUFhLHlCQUF5Qjs7QUFFdEMsY0FBYyx3QkFBd0I7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUJBQWlCLDBCQUEwQjs7QUFFM0Msa0JBQWtCLDJCQUEyQjs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0EsaUJBQWlCLDBCQUEwQjs7QUFFM0Msa0JBQWtCLDJCQUEyQjs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIseUJBQXlCOztBQUUxQzs7QUFFQSxrQkFBa0IsMEJBQTBCOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxpQkFBaUIseUJBQXlCOztBQUUxQyxrQkFBa0IsMEJBQTBCOztBQUU1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUEsYUFBYSxlQUFlOztBQUU1Qjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGNBQWMseUJBQXlCOztBQUV2Qzs7QUFFQSxxQ0FBcUM7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUEsYUFBYSxtQkFBbUI7O0FBRWhDLGNBQWMseUJBQXlCOztBQUV2QztBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsYUFBYSxlQUFlOztBQUU1Qjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlFQUF5RTtBQUN6RTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBLGFBQWEsZUFBZTs7QUFFNUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsY0FBYyxlQUFlOztBQUU3QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsc0NBQXNDLE9BQU87O0FBRTdDOztBQUVBOztBQUVBOztBQUVBLG1DQUFtQyxPQUFPOztBQUUxQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwyQ0FBMkMsT0FBTzs7QUFFbEQ7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSw4REFBOEQ7QUFDOUQsOERBQThEO0FBQzlELDhEQUE4RDtBQUM5RCw4RUFBOEU7O0FBRTlFOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGFBQWEsYUFBYTs7QUFFMUI7O0FBRUEsY0FBYyxhQUFhOztBQUUzQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxhQUFhLFlBQVk7O0FBRXpCLGNBQWMsWUFBWTs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDBDOztBQUVBLGlCQUFpQixxQkFBcUI7O0FBRXRDOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0Isa0JBQWtCOztBQUVwQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLE9BQU87O0FBRTNCO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsaUJBQWlCOztBQUV0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxPQUFPOztBQUVYOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsaUJBQWlCOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsaUM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9EOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDLGlCQUFpQixrQkFBa0I7O0FBRW5DOztBQUVBLG1CQUFtQixPQUFPOztBQUUxQjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsaUJBQWlCLGtCQUFrQjs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQix1QkFBdUI7O0FBRXhDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsbUNBQW1DOztBQUVqRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHlFQUF5RSxhQUFhO0FBQ3RGOztBQUVBOztBQUVBLHlFQUF5RSxhQUFhO0FBQ3RGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLCtDQUErQyxrREFBa0Q7QUFDakc7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7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QTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLHFEQUFxRCwrQ0FBK0M7O0FBRXBHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9EQUFvRCx5RkFBeUY7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDRDQUE0Qzs7QUFFNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsR0FBRzs7QUFFN0M7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksUUFBUTs7QUFFcEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FBYUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvREFBb0QsUUFBUTs7QUFFNUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHVEQUF1RDs7QUFFdkQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtEQUFrRCxRQUFROztBQUUxRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNB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QjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLFFBQVE7O0FBRS9DO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLFFBQVE7O0FBRS9DOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQSxNQUFNOztBQUVOOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsUUFBUTs7QUFFL0M7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLE9BQU87O0FBRXpCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixPQUFPOztBQUV6Qjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSwrQkFBK0IsOEJBQThCO0FBQzdELDhCQUE4Qiw4QkFBOEI7O0FBRTVELDhCQUE4QiwrQkFBK0I7QUFDN0QsOEJBQThCLDhCQUE4Qjs7QUFFNUQsOEJBQThCLDhCQUE4QjtBQUM1RCw4QkFBOEIsOEJBQThCOztBQUU1RCwrQkFBK0IsNkJBQTZCO0FBQzVELDhCQUE4Qiw4QkFBOEI7O0FBRTVEOztBQUVBLDJCQUEyQiwwQkFBMEI7QUFDckQsMkJBQTJCLDBCQUEwQjs7QUFFckQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVB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QUNBIiwiZmlsZSI6IjMyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXHJcbnZhciB3aW5kb3cgPSB3aW5kb3cgfHwge307XHJcbnZhciBzZWxmID0gc2VsZiB8fCB7fTtcclxuXHJcbi8vIEhpZ2gtcmVzdWx1dGlvbiBjb3VudGVyOiBlbXVsYXRlIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSBmb3IgVEhSRUUuQ0xPQ0tcclxuaWYoIHdpbmRvdy5wZXJmb3JtYW5jZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHR3aW5kb3cucGVyZm9ybWFuY2UgPSB7IH07XHJcblxyXG59XHJcblxyXG5pZiggd2luZG93LnBlcmZvcm1hbmNlLm5vdyA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHR3aW5kb3cucGVyZm9ybWFuY2Uubm93ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB0aW1lID0gcHJvY2Vzcy5ocnRpbWUoKTtcclxuXHRcdHJldHVybiAoIHRpbWVbMF0gKyB0aW1lWzFdIC8gMWU5ICkgKiAxMDAwO1xyXG5cclxuXHR9O1xyXG5cclxufVxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBMYXJyeSBCYXR0bGUgLyBodHRwOi8vYmF0ZXJ1LmNvbS9uZXdzXHJcbiAqL1xyXG5cclxudmFyIFRIUkVFID0gVEhSRUUgfHwgeyBSRVZJU0lPTjogJzU2JyB9O1xyXG5cclxuc2VsZi5jb25zb2xlID0gc2VsZi5jb25zb2xlIHx8IHtcclxuXHJcblx0aW5mbzogZnVuY3Rpb24gKCkge30sXHJcblx0bG9nOiBmdW5jdGlvbiAoKSB7fSxcclxuXHRkZWJ1ZzogZnVuY3Rpb24gKCkge30sXHJcblx0d2FybjogZnVuY3Rpb24gKCkge30sXHJcblx0ZXJyb3I6IGZ1bmN0aW9uICgpIHt9XHJcblxyXG59O1xyXG5cclxuc2VsZi5JbnQzMkFycmF5ID0gc2VsZi5JbnQzMkFycmF5IHx8IEFycmF5O1xyXG5zZWxmLkZsb2F0MzJBcnJheSA9IHNlbGYuRmxvYXQzMkFycmF5IHx8IEFycmF5O1xyXG5cclxuU3RyaW5nLnByb3RvdHlwZS50cmltID0gU3RyaW5nLnByb3RvdHlwZS50cmltIHx8IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0cmV0dXJuIHRoaXMucmVwbGFjZSggL15cXHMrfFxccyskL2csICcnICk7XHJcblxyXG59O1xyXG5cclxuLy8gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2RvY3VtZW50Y2xvdWQvdW5kZXJzY29yZS9ibG9iL2JmNjU3YmUyNDNhMDc1YjVlNzJhY2M4YTgzZTZmMTJhNTY0ZDhmNTUvdW5kZXJzY29yZS5qcyNMNzY3XHJcblRIUkVFLmV4dGVuZCA9IGZ1bmN0aW9uICggb2JqLCBzb3VyY2UgKSB7XHJcblxyXG5cdC8vIEVDTUFTY3JpcHQ1IGNvbXBhdGliaWxpdHkgYmFzZWQgb246IGh0dHA6Ly93d3cubmN6b25saW5lLm5ldC9ibG9nLzIwMTIvMTIvMTEvYXJlLXlvdXItbWl4aW5zLWVjbWFzY3JpcHQtNS1jb21wYXRpYmxlL1xyXG5cdGlmICggT2JqZWN0LmtleXMgKSB7XHJcblxyXG5cdFx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyggc291cmNlICk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGlsID0ga2V5cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XHJcblxyXG5cdFx0XHR2YXIgcHJvcCA9IGtleXNbaV07XHJcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb2JqLCBwcm9wLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKCBzb3VyY2UsIHByb3AgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHR2YXIgc2FmZUhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XHJcblxyXG5cdFx0Zm9yICggdmFyIHByb3AgaW4gc291cmNlICkge1xyXG5cclxuXHRcdFx0aWYgKCBzYWZlSGFzT3duUHJvcGVydHkuY2FsbCggc291cmNlLCBwcm9wICkgKSB7XHJcblxyXG5cdFx0XHRcdG9ialtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIG9iajtcclxuXHJcbn07XHJcblxyXG4vLyBodHRwOi8vcGF1bGlyaXNoLmNvbS8yMDExL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtYW5pbWF0aW5nL1xyXG4vLyBodHRwOi8vbXkub3BlcmEuY29tL2Vtb2xsZXIvYmxvZy8yMDExLzEyLzIwL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtZXItYW5pbWF0aW5nXHJcblxyXG4vLyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgcG9seWZpbGwgYnkgRXJpayBNw7ZsbGVyXHJcbi8vIGZpeGVzIGZyb20gUGF1bCBJcmlzaCBhbmQgVGlubyBaaWpkZWxcclxuXHJcbiggZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgbGFzdFRpbWUgPSAwO1xyXG5cdHZhciB2ZW5kb3JzID0gWyAnbXMnLCAnbW96JywgJ3dlYmtpdCcsICdvJyBdO1xyXG5cclxuXHRmb3IgKCB2YXIgeCA9IDA7IHggPCB2ZW5kb3JzLmxlbmd0aCAmJiAhd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTsgKysgeCApIHtcclxuXHJcblx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93WyB2ZW5kb3JzWyB4IF0gKyAnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJyBdO1xyXG5cdFx0d2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gd2luZG93WyB2ZW5kb3JzWyB4IF0gKyAnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnIF0gfHwgd2luZG93WyB2ZW5kb3JzWyB4IF0gKyAnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJyBdO1xyXG5cclxuXHR9XHJcblxyXG5cdGlmICggd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xyXG5cclxuXHRcdFx0dmFyIGN1cnJUaW1lID0gRGF0ZS5ub3coKSwgdGltZVRvQ2FsbCA9IE1hdGgubWF4KCAwLCAxNiAtICggY3VyclRpbWUgLSBsYXN0VGltZSApICk7XHJcblx0XHRcdHZhciBpZCA9IHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHsgY2FsbGJhY2soIGN1cnJUaW1lICsgdGltZVRvQ2FsbCApOyB9LCB0aW1lVG9DYWxsICk7XHJcblx0XHRcdGxhc3RUaW1lID0gY3VyclRpbWUgKyB0aW1lVG9DYWxsO1xyXG5cdFx0XHRyZXR1cm4gaWQ7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fVxyXG5cclxuXHR3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgZnVuY3Rpb24gKCBpZCApIHsgd2luZG93LmNsZWFyVGltZW91dCggaWQgKSB9O1xyXG5cclxufSgpICk7XHJcblxyXG4vLyBHTCBTVEFURSBDT05TVEFOVFNcclxuXHJcblRIUkVFLkN1bGxGYWNlTm9uZSA9IDA7XHJcblRIUkVFLkN1bGxGYWNlQmFjayA9IDE7XHJcblRIUkVFLkN1bGxGYWNlRnJvbnQgPSAyO1xyXG5USFJFRS5DdWxsRmFjZUZyb250QmFjayA9IDM7XHJcblxyXG5USFJFRS5Gcm9udEZhY2VEaXJlY3Rpb25DVyA9IDA7XHJcblRIUkVFLkZyb250RmFjZURpcmVjdGlvbkNDVyA9IDE7XHJcblxyXG4vLyBTSEFET1dJTkcgVFlQRVNcclxuXHJcblRIUkVFLkJhc2ljU2hhZG93TWFwID0gMDtcclxuVEhSRUUuUENGU2hhZG93TWFwID0gMTtcclxuVEhSRUUuUENGU29mdFNoYWRvd01hcCA9IDI7XHJcblxyXG4vLyBNQVRFUklBTCBDT05TVEFOVFNcclxuXHJcbi8vIHNpZGVcclxuXHJcblRIUkVFLkZyb250U2lkZSA9IDA7XHJcblRIUkVFLkJhY2tTaWRlID0gMTtcclxuVEhSRUUuRG91YmxlU2lkZSA9IDI7XHJcblxyXG4vLyBzaGFkaW5nXHJcblxyXG5USFJFRS5Ob1NoYWRpbmcgPSAwO1xyXG5USFJFRS5GbGF0U2hhZGluZyA9IDE7XHJcblRIUkVFLlNtb290aFNoYWRpbmcgPSAyO1xyXG5cclxuLy8gY29sb3JzXHJcblxyXG5USFJFRS5Ob0NvbG9ycyA9IDA7XHJcblRIUkVFLkZhY2VDb2xvcnMgPSAxO1xyXG5USFJFRS5WZXJ0ZXhDb2xvcnMgPSAyO1xyXG5cclxuLy8gYmxlbmRpbmcgbW9kZXNcclxuXHJcblRIUkVFLk5vQmxlbmRpbmcgPSAwO1xyXG5USFJFRS5Ob3JtYWxCbGVuZGluZyA9IDE7XHJcblRIUkVFLkFkZGl0aXZlQmxlbmRpbmcgPSAyO1xyXG5USFJFRS5TdWJ0cmFjdGl2ZUJsZW5kaW5nID0gMztcclxuVEhSRUUuTXVsdGlwbHlCbGVuZGluZyA9IDQ7XHJcblRIUkVFLkN1c3RvbUJsZW5kaW5nID0gNTtcclxuXHJcbi8vIGN1c3RvbSBibGVuZGluZyBlcXVhdGlvbnNcclxuLy8gKG51bWJlcnMgc3RhcnQgZnJvbSAxMDAgbm90IHRvIGNsYXNoIHdpdGggb3RoZXJcclxuLy8gIG1hcHBpbmdzIHRvIE9wZW5HTCBjb25zdGFudHMgZGVmaW5lZCBpbiBUZXh0dXJlLmpzKVxyXG5cclxuVEhSRUUuQWRkRXF1YXRpb24gPSAxMDA7XHJcblRIUkVFLlN1YnRyYWN0RXF1YXRpb24gPSAxMDE7XHJcblRIUkVFLlJldmVyc2VTdWJ0cmFjdEVxdWF0aW9uID0gMTAyO1xyXG5cclxuLy8gY3VzdG9tIGJsZW5kaW5nIGRlc3RpbmF0aW9uIGZhY3RvcnNcclxuXHJcblRIUkVFLlplcm9GYWN0b3IgPSAyMDA7XHJcblRIUkVFLk9uZUZhY3RvciA9IDIwMTtcclxuVEhSRUUuU3JjQ29sb3JGYWN0b3IgPSAyMDI7XHJcblRIUkVFLk9uZU1pbnVzU3JjQ29sb3JGYWN0b3IgPSAyMDM7XHJcblRIUkVFLlNyY0FscGhhRmFjdG9yID0gMjA0O1xyXG5USFJFRS5PbmVNaW51c1NyY0FscGhhRmFjdG9yID0gMjA1O1xyXG5USFJFRS5Ec3RBbHBoYUZhY3RvciA9IDIwNjtcclxuVEhSRUUuT25lTWludXNEc3RBbHBoYUZhY3RvciA9IDIwNztcclxuXHJcbi8vIGN1c3RvbSBibGVuZGluZyBzb3VyY2UgZmFjdG9yc1xyXG5cclxuLy9USFJFRS5aZXJvRmFjdG9yID0gMjAwO1xyXG4vL1RIUkVFLk9uZUZhY3RvciA9IDIwMTtcclxuLy9USFJFRS5TcmNBbHBoYUZhY3RvciA9IDIwNDtcclxuLy9USFJFRS5PbmVNaW51c1NyY0FscGhhRmFjdG9yID0gMjA1O1xyXG4vL1RIUkVFLkRzdEFscGhhRmFjdG9yID0gMjA2O1xyXG4vL1RIUkVFLk9uZU1pbnVzRHN0QWxwaGFGYWN0b3IgPSAyMDc7XHJcblRIUkVFLkRzdENvbG9yRmFjdG9yID0gMjA4O1xyXG5USFJFRS5PbmVNaW51c0RzdENvbG9yRmFjdG9yID0gMjA5O1xyXG5USFJFRS5TcmNBbHBoYVNhdHVyYXRlRmFjdG9yID0gMjEwO1xyXG5cclxuXHJcbi8vIFRFWFRVUkUgQ09OU1RBTlRTXHJcblxyXG5USFJFRS5NdWx0aXBseU9wZXJhdGlvbiA9IDA7XHJcblRIUkVFLk1peE9wZXJhdGlvbiA9IDE7XHJcblRIUkVFLkFkZE9wZXJhdGlvbiA9IDI7XHJcblxyXG4vLyBNYXBwaW5nIG1vZGVzXHJcblxyXG5USFJFRS5VVk1hcHBpbmcgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHJcblRIUkVFLkN1YmVSZWZsZWN0aW9uTWFwcGluZyA9IGZ1bmN0aW9uICgpIHt9O1xyXG5USFJFRS5DdWJlUmVmcmFjdGlvbk1hcHBpbmcgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHJcblRIUkVFLlNwaGVyaWNhbFJlZmxlY3Rpb25NYXBwaW5nID0gZnVuY3Rpb24gKCkge307XHJcblRIUkVFLlNwaGVyaWNhbFJlZnJhY3Rpb25NYXBwaW5nID0gZnVuY3Rpb24gKCkge307XHJcblxyXG4vLyBXcmFwcGluZyBtb2Rlc1xyXG5cclxuVEhSRUUuUmVwZWF0V3JhcHBpbmcgPSAxMDAwO1xyXG5USFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nID0gMTAwMTtcclxuVEhSRUUuTWlycm9yZWRSZXBlYXRXcmFwcGluZyA9IDEwMDI7XHJcblxyXG4vLyBGaWx0ZXJzXHJcblxyXG5USFJFRS5OZWFyZXN0RmlsdGVyID0gMTAwMztcclxuVEhSRUUuTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXIgPSAxMDA0O1xyXG5USFJFRS5OZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyID0gMTAwNTtcclxuVEhSRUUuTGluZWFyRmlsdGVyID0gMTAwNjtcclxuVEhSRUUuTGluZWFyTWlwTWFwTmVhcmVzdEZpbHRlciA9IDEwMDc7XHJcblRIUkVFLkxpbmVhck1pcE1hcExpbmVhckZpbHRlciA9IDEwMDg7XHJcblxyXG4vLyBEYXRhIHR5cGVzXHJcblxyXG5USFJFRS5VbnNpZ25lZEJ5dGVUeXBlID0gMTAwOTtcclxuVEhSRUUuQnl0ZVR5cGUgPSAxMDEwO1xyXG5USFJFRS5TaG9ydFR5cGUgPSAxMDExO1xyXG5USFJFRS5VbnNpZ25lZFNob3J0VHlwZSA9IDEwMTI7XHJcblRIUkVFLkludFR5cGUgPSAxMDEzO1xyXG5USFJFRS5VbnNpZ25lZEludFR5cGUgPSAxMDE0O1xyXG5USFJFRS5GbG9hdFR5cGUgPSAxMDE1O1xyXG5cclxuLy8gUGl4ZWwgdHlwZXNcclxuXHJcbi8vVEhSRUUuVW5zaWduZWRCeXRlVHlwZSA9IDEwMDk7XHJcblRIUkVFLlVuc2lnbmVkU2hvcnQ0NDQ0VHlwZSA9IDEwMTY7XHJcblRIUkVFLlVuc2lnbmVkU2hvcnQ1NTUxVHlwZSA9IDEwMTc7XHJcblRIUkVFLlVuc2lnbmVkU2hvcnQ1NjVUeXBlID0gMTAxODtcclxuXHJcbi8vIFBpeGVsIGZvcm1hdHNcclxuXHJcblRIUkVFLkFscGhhRm9ybWF0ID0gMTAxOTtcclxuVEhSRUUuUkdCRm9ybWF0ID0gMTAyMDtcclxuVEhSRUUuUkdCQUZvcm1hdCA9IDEwMjE7XHJcblRIUkVFLkx1bWluYW5jZUZvcm1hdCA9IDEwMjI7XHJcblRIUkVFLkx1bWluYW5jZUFscGhhRm9ybWF0ID0gMTAyMztcclxuXHJcbi8vIENvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXRzXHJcblxyXG5USFJFRS5SR0JfUzNUQ19EWFQxX0Zvcm1hdCA9IDIwMDE7XHJcblRIUkVFLlJHQkFfUzNUQ19EWFQxX0Zvcm1hdCA9IDIwMDI7XHJcblRIUkVFLlJHQkFfUzNUQ19EWFQzX0Zvcm1hdCA9IDIwMDM7XHJcblRIUkVFLlJHQkFfUzNUQ19EWFQ1X0Zvcm1hdCA9IDIwMDQ7XHJcblxyXG4vKlxyXG4vLyBQb3RlbnRpYWwgZnV0dXJlIFBWUlRDIGNvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXRzXHJcblRIUkVFLlJHQl9QVlJUQ180QlBQVjFfRm9ybWF0ID0gMjEwMDtcclxuVEhSRUUuUkdCX1BWUlRDXzJCUFBWMV9Gb3JtYXQgPSAyMTAxO1xyXG5USFJFRS5SR0JBX1BWUlRDXzRCUFBWMV9Gb3JtYXQgPSAyMTAyO1xyXG5USFJFRS5SR0JBX1BWUlRDXzJCUFBWMV9Gb3JtYXQgPSAyMTAzO1xyXG4qL1xyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5Db2xvciA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHRoaXMuc2V0KCB2YWx1ZSApO1xyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG5USFJFRS5leHRlbmQoIFRIUkVFLkNvbG9yLnByb3RvdHlwZSwge1xyXG5cclxuXHRyOiAxLCBnOiAxLCBiOiAxLFxyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0c3dpdGNoICggdHlwZW9mIHZhbHVlICkge1xyXG5cclxuXHRcdFx0Y2FzZSBcIm51bWJlclwiOlxyXG5cdFx0XHRcdHRoaXMuc2V0SGV4KCB2YWx1ZSApO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSBcInN0cmluZ1wiOlxyXG5cdFx0XHRcdHRoaXMuc2V0U3R5bGUoIHZhbHVlICk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRIZXg6IGZ1bmN0aW9uICggaGV4ICkge1xyXG5cclxuXHRcdGhleCA9IE1hdGguZmxvb3IoIGhleCApO1xyXG5cclxuXHRcdHRoaXMuciA9ICggaGV4ID4+IDE2ICYgMjU1ICkgLyAyNTU7XHJcblx0XHR0aGlzLmcgPSAoIGhleCA+PiA4ICYgMjU1ICkgLyAyNTU7XHJcblx0XHR0aGlzLmIgPSAoIGhleCAmIDI1NSApIC8gMjU1O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRSR0I6IGZ1bmN0aW9uICggciwgZywgYiApIHtcclxuXHJcblx0XHR0aGlzLnIgPSByO1xyXG5cdFx0dGhpcy5nID0gZztcclxuXHRcdHRoaXMuYiA9IGI7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEhTVjogZnVuY3Rpb24gKCBoLCBzLCB2ICkge1xyXG5cclxuXHRcdGNvbnNvbGUubG9nKCAnREVQUkVDQVRFRDogQ29sb3JcXCdzIC5zZXRIU1YoKSB3aWxsIGJlIHJlbW92ZWQuIFVzZSAuc2V0SFNMKCBoLCBzLCBsICkgaW5zdGVhZC4nICk7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRIU0woaCxzKnYvKChoPSgyLXMpKnYpPDE/aDoyLWgpLGgvMik7IC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3hwYW5zaXZlLzEzMzc4OTBcclxuXHJcblx0fSxcclxuXHJcblx0c2V0SFNMOiBmdW5jdGlvbiAoIGgsIHMsIGwgKSB7XHJcblxyXG5cdFx0Ly8gaCxzLGwgcmFuZ2VzIGFyZSBpbiAwLjAgLSAxLjBcclxuXHJcblx0XHRpZiAoIHMgPT09IDAgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnIgPSB0aGlzLmcgPSB0aGlzLmIgPSBsO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR2YXIgaHVlMnJnYiA9IGZ1bmN0aW9uICggcCwgcSwgdCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCB0IDwgMCApIHQgKz0gMTtcclxuXHRcdFx0XHRpZiAoIHQgPiAxICkgdCAtPSAxO1xyXG5cdFx0XHRcdGlmICggdCA8IDEgLyA2ICkgcmV0dXJuIHAgKyAoIHEgLSBwICkgKiA2ICogdDtcclxuXHRcdFx0XHRpZiAoIHQgPCAxIC8gMiApIHJldHVybiBxO1xyXG5cdFx0XHRcdGlmICggdCA8IDIgLyAzICkgcmV0dXJuIHAgKyAoIHEgLSBwICkgKiA2ICogKCAyIC8gMyAtIHQgKTtcclxuXHRcdFx0XHRyZXR1cm4gcDtcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHR2YXIgcCA9IGwgPD0gMC41ID8gbCAqICggMSArIHMgKSA6IGwgKyBzIC0gKCBsICogcyApO1xyXG5cdFx0XHR2YXIgcSA9ICggMiAqIGwgKSAtIHA7XHJcblxyXG5cdFx0XHR0aGlzLnIgPSBodWUycmdiKCBxLCBwLCBoICsgMSAvIDMgKTtcclxuXHRcdFx0dGhpcy5nID0gaHVlMnJnYiggcSwgcCwgaCApO1xyXG5cdFx0XHR0aGlzLmIgPSBodWUycmdiKCBxLCBwLCBoIC0gMSAvIDMgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFN0eWxlOiBmdW5jdGlvbiAoIHN0eWxlICkge1xyXG5cclxuXHRcdC8vIHJnYigyNTUsMCwwKVxyXG5cclxuXHRcdGlmICggL15yZ2JcXCgoXFxkKyksKFxcZCspLChcXGQrKVxcKSQvaS50ZXN0KCBzdHlsZSApICkge1xyXG5cclxuXHRcdFx0dmFyIGNvbG9yID0gL15yZ2JcXCgoXFxkKyksKFxcZCspLChcXGQrKVxcKSQvaS5leGVjKCBzdHlsZSApO1xyXG5cclxuXHRcdFx0dGhpcy5yID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAxIF0sIDEwICkgKSAvIDI1NTtcclxuXHRcdFx0dGhpcy5nID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAyIF0sIDEwICkgKSAvIDI1NTtcclxuXHRcdFx0dGhpcy5iID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgKSAvIDI1NTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyByZ2IoMTAwJSwwJSwwJSlcclxuXHJcblx0XHRpZiAoIC9ecmdiXFwoKFxcZCspXFwlLChcXGQrKVxcJSwoXFxkKylcXCVcXCkkL2kudGVzdCggc3R5bGUgKSApIHtcclxuXHJcblx0XHRcdHZhciBjb2xvciA9IC9ecmdiXFwoKFxcZCspXFwlLChcXGQrKVxcJSwoXFxkKylcXCVcXCkkL2kuZXhlYyggc3R5bGUgKTtcclxuXHJcblx0XHRcdHRoaXMuciA9IE1hdGgubWluKCAxMDAsIHBhcnNlSW50KCBjb2xvclsgMSBdLCAxMCApICkgLyAxMDA7XHJcblx0XHRcdHRoaXMuZyA9IE1hdGgubWluKCAxMDAsIHBhcnNlSW50KCBjb2xvclsgMiBdLCAxMCApICkgLyAxMDA7XHJcblx0XHRcdHRoaXMuYiA9IE1hdGgubWluKCAxMDAsIHBhcnNlSW50KCBjb2xvclsgMyBdLCAxMCApICkgLyAxMDA7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gI2ZmMDAwMFxyXG5cclxuXHRcdGlmICggL15cXCMoWzAtOWEtZl17Nn0pJC9pLnRlc3QoIHN0eWxlICkgKSB7XHJcblxyXG5cdFx0XHR2YXIgY29sb3IgPSAvXlxcIyhbMC05YS1mXXs2fSkkL2kuZXhlYyggc3R5bGUgKTtcclxuXHJcblx0XHRcdHRoaXMuc2V0SGV4KCBwYXJzZUludCggY29sb3JbIDEgXSwgMTYgKSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vICNmMDBcclxuXHJcblx0XHRpZiAoIC9eXFwjKFswLTlhLWZdKShbMC05YS1mXSkoWzAtOWEtZl0pJC9pLnRlc3QoIHN0eWxlICkgKSB7XHJcblxyXG5cdFx0XHR2YXIgY29sb3IgPSAvXlxcIyhbMC05YS1mXSkoWzAtOWEtZl0pKFswLTlhLWZdKSQvaS5leGVjKCBzdHlsZSApO1xyXG5cclxuXHRcdFx0dGhpcy5zZXRIZXgoIHBhcnNlSW50KCBjb2xvclsgMSBdICsgY29sb3JbIDEgXSArIGNvbG9yWyAyIF0gKyBjb2xvclsgMiBdICsgY29sb3JbIDMgXSArIGNvbG9yWyAzIF0sIDE2ICkgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyByZWRcclxuXHJcblx0XHRpZiAoIC9eKFxcdyspJC9pLnRlc3QoIHN0eWxlICkgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnNldEhleCggVEhSRUUuQ29sb3JLZXl3b3Jkc1sgc3R5bGUgXSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBjb2xvciApIHtcclxuXHJcblx0XHR0aGlzLnIgPSBjb2xvci5yO1xyXG5cdFx0dGhpcy5nID0gY29sb3IuZztcclxuXHRcdHRoaXMuYiA9IGNvbG9yLmI7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHlHYW1tYVRvTGluZWFyOiBmdW5jdGlvbiAoIGNvbG9yICkge1xyXG5cclxuXHRcdHRoaXMuciA9IGNvbG9yLnIgKiBjb2xvci5yO1xyXG5cdFx0dGhpcy5nID0gY29sb3IuZyAqIGNvbG9yLmc7XHJcblx0XHR0aGlzLmIgPSBjb2xvci5iICogY29sb3IuYjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29weUxpbmVhclRvR2FtbWE6IGZ1bmN0aW9uICggY29sb3IgKSB7XHJcblxyXG5cdFx0dGhpcy5yID0gTWF0aC5zcXJ0KCBjb2xvci5yICk7XHJcblx0XHR0aGlzLmcgPSBNYXRoLnNxcnQoIGNvbG9yLmcgKTtcclxuXHRcdHRoaXMuYiA9IE1hdGguc3FydCggY29sb3IuYiApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb252ZXJ0R2FtbWFUb0xpbmVhcjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciByID0gdGhpcy5yLCBnID0gdGhpcy5nLCBiID0gdGhpcy5iO1xyXG5cclxuXHRcdHRoaXMuciA9IHIgKiByO1xyXG5cdFx0dGhpcy5nID0gZyAqIGc7XHJcblx0XHR0aGlzLmIgPSBiICogYjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29udmVydExpbmVhclRvR2FtbWE6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLnIgPSBNYXRoLnNxcnQoIHRoaXMuciApO1xyXG5cdFx0dGhpcy5nID0gTWF0aC5zcXJ0KCB0aGlzLmcgKTtcclxuXHRcdHRoaXMuYiA9IE1hdGguc3FydCggdGhpcy5iICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldEhleDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiAoIHRoaXMuciAqIDI1NSApIDw8IDE2IF4gKCB0aGlzLmcgKiAyNTUgKSA8PCA4IF4gKCB0aGlzLmIgKiAyNTUgKSA8PCAwO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRIZXhTdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gKCAnMDAwMDAwJyArIHRoaXMuZ2V0SGV4KCkudG9TdHJpbmcoIDE2ICkgKS5zbGljZSggLSA2ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldEhTTDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBoc2wgPSB7IGg6IDAsIHM6IDAsIGw6IDAgfTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0Ly8gaCxzLGwgcmFuZ2VzIGFyZSBpbiAwLjAgLSAxLjBcclxuXHJcblx0XHRcdHZhciByID0gdGhpcy5yLCBnID0gdGhpcy5nLCBiID0gdGhpcy5iO1xyXG5cclxuXHRcdFx0dmFyIG1heCA9IE1hdGgubWF4KCByLCBnLCBiICk7XHJcblx0XHRcdHZhciBtaW4gPSBNYXRoLm1pbiggciwgZywgYiApO1xyXG5cclxuXHRcdFx0dmFyIGh1ZSwgc2F0dXJhdGlvbjtcclxuXHRcdFx0dmFyIGxpZ2h0bmVzcyA9ICggbWluICsgbWF4ICkgLyAyLjA7XHJcblxyXG5cdFx0XHRpZiAoIG1pbiA9PT0gbWF4ICkge1xyXG5cclxuXHRcdFx0XHRodWUgPSAwO1xyXG5cdFx0XHRcdHNhdHVyYXRpb24gPSAwO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dmFyIGRlbHRhID0gbWF4IC0gbWluO1xyXG5cclxuXHRcdFx0XHRzYXR1cmF0aW9uID0gbGlnaHRuZXNzIDw9IDAuNSA/IGRlbHRhIC8gKCBtYXggKyBtaW4gKSA6IGRlbHRhIC8gKCAyIC0gbWF4IC0gbWluICk7XHJcblxyXG5cdFx0XHRcdHN3aXRjaCAoIG1heCApIHtcclxuXHJcblx0XHRcdFx0XHRjYXNlIHI6IGh1ZSA9ICggZyAtIGIgKSAvIGRlbHRhICsgKCBnIDwgYiA/IDYgOiAwICk7IGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSBnOiBodWUgPSAoIGIgLSByICkgLyBkZWx0YSArIDI7IGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSBiOiBodWUgPSAoIHIgLSBnICkgLyBkZWx0YSArIDQ7IGJyZWFrO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGh1ZSAvPSA2O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aHNsLmggPSBodWU7XHJcblx0XHRcdGhzbC5zID0gc2F0dXJhdGlvbjtcclxuXHRcdFx0aHNsLmwgPSBsaWdodG5lc3M7XHJcblxyXG5cdFx0XHRyZXR1cm4gaHNsO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0Z2V0U3R5bGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gJ3JnYignICsgKCAoIHRoaXMuciAqIDI1NSApIHwgMCApICsgJywnICsgKCAoIHRoaXMuZyAqIDI1NSApIHwgMCApICsgJywnICsgKCAoIHRoaXMuYiAqIDI1NSApIHwgMCApICsgJyknO1xyXG5cclxuXHR9LFxyXG5cclxuXHRvZmZzZXRIU0w6IGZ1bmN0aW9uICggaCwgcywgbCApIHtcclxuXHJcblx0XHR2YXIgaHNsID0gdGhpcy5nZXRIU0woKTtcclxuXHJcblx0XHRoc2wuaCArPSBoOyBoc2wucyArPSBzOyBoc2wubCArPSBsO1xyXG5cclxuXHRcdHRoaXMuc2V0SFNMKCBoc2wuaCwgaHNsLnMsIGhzbC5sICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZDogZnVuY3Rpb24gKCBjb2xvciApIHtcclxuXHJcblx0XHR0aGlzLnIgKz0gY29sb3IucjtcclxuXHRcdHRoaXMuZyArPSBjb2xvci5nO1xyXG5cdFx0dGhpcy5iICs9IGNvbG9yLmI7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZENvbG9yczogZnVuY3Rpb24gKCBjb2xvcjEsIGNvbG9yMiApIHtcclxuXHJcblx0XHR0aGlzLnIgPSBjb2xvcjEuciArIGNvbG9yMi5yO1xyXG5cdFx0dGhpcy5nID0gY29sb3IxLmcgKyBjb2xvcjIuZztcclxuXHRcdHRoaXMuYiA9IGNvbG9yMS5iICsgY29sb3IyLmI7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZFNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuXHRcdHRoaXMuciArPSBzO1xyXG5cdFx0dGhpcy5nICs9IHM7XHJcblx0XHR0aGlzLmIgKz0gcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHk6IGZ1bmN0aW9uICggY29sb3IgKSB7XHJcblxyXG5cdFx0dGhpcy5yICo9IGNvbG9yLnI7XHJcblx0XHR0aGlzLmcgKj0gY29sb3IuZztcclxuXHRcdHRoaXMuYiAqPSBjb2xvci5iO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuXHRcdHRoaXMuciAqPSBzO1xyXG5cdFx0dGhpcy5nICo9IHM7XHJcblx0XHR0aGlzLmIgKj0gcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bGVycDogZnVuY3Rpb24gKCBjb2xvciwgYWxwaGEgKSB7XHJcblxyXG5cdFx0dGhpcy5yICs9ICggY29sb3IuciAtIHRoaXMuciApICogYWxwaGE7XHJcblx0XHR0aGlzLmcgKz0gKCBjb2xvci5nIC0gdGhpcy5nICkgKiBhbHBoYTtcclxuXHRcdHRoaXMuYiArPSAoIGNvbG9yLmIgLSB0aGlzLmIgKSAqIGFscGhhO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgVEhSRUUuQ29sb3IoKS5zZXRSR0IoIHRoaXMuciwgdGhpcy5nLCB0aGlzLmIgKTtcclxuXHJcblx0fVxyXG5cclxufSApO1xyXG5cclxuVEhSRUUuQ29sb3JLZXl3b3JkcyA9IHsgXCJhbGljZWJsdWVcIjogMHhGMEY4RkYsIFwiYW50aXF1ZXdoaXRlXCI6IDB4RkFFQkQ3LCBcImFxdWFcIjogMHgwMEZGRkYsIFwiYXF1YW1hcmluZVwiOiAweDdGRkZENCwgXCJhenVyZVwiOiAweEYwRkZGRixcclxuXCJiZWlnZVwiOiAweEY1RjVEQywgXCJiaXNxdWVcIjogMHhGRkU0QzQsIFwiYmxhY2tcIjogMHgwMDAwMDAsIFwiYmxhbmNoZWRhbG1vbmRcIjogMHhGRkVCQ0QsIFwiYmx1ZVwiOiAweDAwMDBGRiwgXCJibHVldmlvbGV0XCI6IDB4OEEyQkUyLFxyXG5cImJyb3duXCI6IDB4QTUyQTJBLCBcImJ1cmx5d29vZFwiOiAweERFQjg4NywgXCJjYWRldGJsdWVcIjogMHg1RjlFQTAsIFwiY2hhcnRyZXVzZVwiOiAweDdGRkYwMCwgXCJjaG9jb2xhdGVcIjogMHhEMjY5MUUsIFwiY29yYWxcIjogMHhGRjdGNTAsXHJcblwiY29ybmZsb3dlcmJsdWVcIjogMHg2NDk1RUQsIFwiY29ybnNpbGtcIjogMHhGRkY4REMsIFwiY3JpbXNvblwiOiAweERDMTQzQywgXCJjeWFuXCI6IDB4MDBGRkZGLCBcImRhcmtibHVlXCI6IDB4MDAwMDhCLCBcImRhcmtjeWFuXCI6IDB4MDA4QjhCLFxyXG5cImRhcmtnb2xkZW5yb2RcIjogMHhCODg2MEIsIFwiZGFya2dyYXlcIjogMHhBOUE5QTksIFwiZGFya2dyZWVuXCI6IDB4MDA2NDAwLCBcImRhcmtncmV5XCI6IDB4QTlBOUE5LCBcImRhcmtraGFraVwiOiAweEJEQjc2QiwgXCJkYXJrbWFnZW50YVwiOiAweDhCMDA4QixcclxuXCJkYXJrb2xpdmVncmVlblwiOiAweDU1NkIyRiwgXCJkYXJrb3JhbmdlXCI6IDB4RkY4QzAwLCBcImRhcmtvcmNoaWRcIjogMHg5OTMyQ0MsIFwiZGFya3JlZFwiOiAweDhCMDAwMCwgXCJkYXJrc2FsbW9uXCI6IDB4RTk5NjdBLCBcImRhcmtzZWFncmVlblwiOiAweDhGQkM4RixcclxuXCJkYXJrc2xhdGVibHVlXCI6IDB4NDgzRDhCLCBcImRhcmtzbGF0ZWdyYXlcIjogMHgyRjRGNEYsIFwiZGFya3NsYXRlZ3JleVwiOiAweDJGNEY0RiwgXCJkYXJrdHVycXVvaXNlXCI6IDB4MDBDRUQxLCBcImRhcmt2aW9sZXRcIjogMHg5NDAwRDMsXHJcblwiZGVlcHBpbmtcIjogMHhGRjE0OTMsIFwiZGVlcHNreWJsdWVcIjogMHgwMEJGRkYsIFwiZGltZ3JheVwiOiAweDY5Njk2OSwgXCJkaW1ncmV5XCI6IDB4Njk2OTY5LCBcImRvZGdlcmJsdWVcIjogMHgxRTkwRkYsIFwiZmlyZWJyaWNrXCI6IDB4QjIyMjIyLFxyXG5cImZsb3JhbHdoaXRlXCI6IDB4RkZGQUYwLCBcImZvcmVzdGdyZWVuXCI6IDB4MjI4QjIyLCBcImZ1Y2hzaWFcIjogMHhGRjAwRkYsIFwiZ2FpbnNib3JvXCI6IDB4RENEQ0RDLCBcImdob3N0d2hpdGVcIjogMHhGOEY4RkYsIFwiZ29sZFwiOiAweEZGRDcwMCxcclxuXCJnb2xkZW5yb2RcIjogMHhEQUE1MjAsIFwiZ3JheVwiOiAweDgwODA4MCwgXCJncmVlblwiOiAweDAwODAwMCwgXCJncmVlbnllbGxvd1wiOiAweEFERkYyRiwgXCJncmV5XCI6IDB4ODA4MDgwLCBcImhvbmV5ZGV3XCI6IDB4RjBGRkYwLCBcImhvdHBpbmtcIjogMHhGRjY5QjQsXHJcblwiaW5kaWFucmVkXCI6IDB4Q0Q1QzVDLCBcImluZGlnb1wiOiAweDRCMDA4MiwgXCJpdm9yeVwiOiAweEZGRkZGMCwgXCJraGFraVwiOiAweEYwRTY4QywgXCJsYXZlbmRlclwiOiAweEU2RTZGQSwgXCJsYXZlbmRlcmJsdXNoXCI6IDB4RkZGMEY1LCBcImxhd25ncmVlblwiOiAweDdDRkMwMCxcclxuXCJsZW1vbmNoaWZmb25cIjogMHhGRkZBQ0QsIFwibGlnaHRibHVlXCI6IDB4QUREOEU2LCBcImxpZ2h0Y29yYWxcIjogMHhGMDgwODAsIFwibGlnaHRjeWFuXCI6IDB4RTBGRkZGLCBcImxpZ2h0Z29sZGVucm9keWVsbG93XCI6IDB4RkFGQUQyLCBcImxpZ2h0Z3JheVwiOiAweEQzRDNEMyxcclxuXCJsaWdodGdyZWVuXCI6IDB4OTBFRTkwLCBcImxpZ2h0Z3JleVwiOiAweEQzRDNEMywgXCJsaWdodHBpbmtcIjogMHhGRkI2QzEsIFwibGlnaHRzYWxtb25cIjogMHhGRkEwN0EsIFwibGlnaHRzZWFncmVlblwiOiAweDIwQjJBQSwgXCJsaWdodHNreWJsdWVcIjogMHg4N0NFRkEsXHJcblwibGlnaHRzbGF0ZWdyYXlcIjogMHg3Nzg4OTksIFwibGlnaHRzbGF0ZWdyZXlcIjogMHg3Nzg4OTksIFwibGlnaHRzdGVlbGJsdWVcIjogMHhCMEM0REUsIFwibGlnaHR5ZWxsb3dcIjogMHhGRkZGRTAsIFwibGltZVwiOiAweDAwRkYwMCwgXCJsaW1lZ3JlZW5cIjogMHgzMkNEMzIsXHJcblwibGluZW5cIjogMHhGQUYwRTYsIFwibWFnZW50YVwiOiAweEZGMDBGRiwgXCJtYXJvb25cIjogMHg4MDAwMDAsIFwibWVkaXVtYXF1YW1hcmluZVwiOiAweDY2Q0RBQSwgXCJtZWRpdW1ibHVlXCI6IDB4MDAwMENELCBcIm1lZGl1bW9yY2hpZFwiOiAweEJBNTVEMyxcclxuXCJtZWRpdW1wdXJwbGVcIjogMHg5MzcwREIsIFwibWVkaXVtc2VhZ3JlZW5cIjogMHgzQ0IzNzEsIFwibWVkaXVtc2xhdGVibHVlXCI6IDB4N0I2OEVFLCBcIm1lZGl1bXNwcmluZ2dyZWVuXCI6IDB4MDBGQTlBLCBcIm1lZGl1bXR1cnF1b2lzZVwiOiAweDQ4RDFDQyxcclxuXCJtZWRpdW12aW9sZXRyZWRcIjogMHhDNzE1ODUsIFwibWlkbmlnaHRibHVlXCI6IDB4MTkxOTcwLCBcIm1pbnRjcmVhbVwiOiAweEY1RkZGQSwgXCJtaXN0eXJvc2VcIjogMHhGRkU0RTEsIFwibW9jY2FzaW5cIjogMHhGRkU0QjUsIFwibmF2YWpvd2hpdGVcIjogMHhGRkRFQUQsXHJcblwibmF2eVwiOiAweDAwMDA4MCwgXCJvbGRsYWNlXCI6IDB4RkRGNUU2LCBcIm9saXZlXCI6IDB4ODA4MDAwLCBcIm9saXZlZHJhYlwiOiAweDZCOEUyMywgXCJvcmFuZ2VcIjogMHhGRkE1MDAsIFwib3JhbmdlcmVkXCI6IDB4RkY0NTAwLCBcIm9yY2hpZFwiOiAweERBNzBENixcclxuXCJwYWxlZ29sZGVucm9kXCI6IDB4RUVFOEFBLCBcInBhbGVncmVlblwiOiAweDk4RkI5OCwgXCJwYWxldHVycXVvaXNlXCI6IDB4QUZFRUVFLCBcInBhbGV2aW9sZXRyZWRcIjogMHhEQjcwOTMsIFwicGFwYXlhd2hpcFwiOiAweEZGRUZENSwgXCJwZWFjaHB1ZmZcIjogMHhGRkRBQjksXHJcblwicGVydVwiOiAweENEODUzRiwgXCJwaW5rXCI6IDB4RkZDMENCLCBcInBsdW1cIjogMHhEREEwREQsIFwicG93ZGVyYmx1ZVwiOiAweEIwRTBFNiwgXCJwdXJwbGVcIjogMHg4MDAwODAsIFwicmVkXCI6IDB4RkYwMDAwLCBcInJvc3licm93blwiOiAweEJDOEY4RixcclxuXCJyb3lhbGJsdWVcIjogMHg0MTY5RTEsIFwic2FkZGxlYnJvd25cIjogMHg4QjQ1MTMsIFwic2FsbW9uXCI6IDB4RkE4MDcyLCBcInNhbmR5YnJvd25cIjogMHhGNEE0NjAsIFwic2VhZ3JlZW5cIjogMHgyRThCNTcsIFwic2Vhc2hlbGxcIjogMHhGRkY1RUUsXHJcblwic2llbm5hXCI6IDB4QTA1MjJELCBcInNpbHZlclwiOiAweEMwQzBDMCwgXCJza3libHVlXCI6IDB4ODdDRUVCLCBcInNsYXRlYmx1ZVwiOiAweDZBNUFDRCwgXCJzbGF0ZWdyYXlcIjogMHg3MDgwOTAsIFwic2xhdGVncmV5XCI6IDB4NzA4MDkwLCBcInNub3dcIjogMHhGRkZBRkEsXHJcblwic3ByaW5nZ3JlZW5cIjogMHgwMEZGN0YsIFwic3RlZWxibHVlXCI6IDB4NDY4MkI0LCBcInRhblwiOiAweEQyQjQ4QywgXCJ0ZWFsXCI6IDB4MDA4MDgwLCBcInRoaXN0bGVcIjogMHhEOEJGRDgsIFwidG9tYXRvXCI6IDB4RkY2MzQ3LCBcInR1cnF1b2lzZVwiOiAweDQwRTBEMCxcclxuXCJ2aW9sZXRcIjogMHhFRTgyRUUsIFwid2hlYXRcIjogMHhGNURFQjMsIFwid2hpdGVcIjogMHhGRkZGRkYsIFwid2hpdGVzbW9rZVwiOiAweEY1RjVGNSwgXCJ5ZWxsb3dcIjogMHhGRkZGMDAsIFwieWVsbG93Z3JlZW5cIjogMHg5QUNEMzIgfTtcclxuLyoqXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb21cclxuICovXHJcblxyXG5USFJFRS5RdWF0ZXJuaW9uID0gZnVuY3Rpb24oIHgsIHksIHosIHcgKSB7XHJcblxyXG5cdHRoaXMueCA9IHggfHwgMDtcclxuXHR0aGlzLnkgPSB5IHx8IDA7XHJcblx0dGhpcy56ID0geiB8fCAwO1xyXG5cdHRoaXMudyA9ICggdyAhPT0gdW5kZWZpbmVkICkgPyB3IDogMTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5leHRlbmQoIFRIUkVFLlF1YXRlcm5pb24ucHJvdG90eXBlLCB7XHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHg7XHJcblx0XHR0aGlzLnkgPSB5O1xyXG5cdFx0dGhpcy56ID0gejtcclxuXHRcdHRoaXMudyA9IHc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggcSApIHtcclxuXHJcblx0XHR0aGlzLnggPSBxLng7XHJcblx0XHR0aGlzLnkgPSBxLnk7XHJcblx0XHR0aGlzLnogPSBxLno7XHJcblx0XHR0aGlzLncgPSBxLnc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21FdWxlcjogZnVuY3Rpb24gKCB2LCBvcmRlciApIHtcclxuXHJcblx0XHQvLyBodHRwOi8vd3d3Lm1hdGh3b3Jrcy5jb20vbWF0bGFiY2VudHJhbC9maWxlZXhjaGFuZ2UvXHJcblx0XHQvLyBcdDIwNjk2LWZ1bmN0aW9uLXRvLWNvbnZlcnQtYmV0d2Vlbi1kY20tZXVsZXItYW5nbGVzLXF1YXRlcm5pb25zLWFuZC1ldWxlci12ZWN0b3JzL1xyXG5cdFx0Ly9cdGNvbnRlbnQvU3BpbkNhbGMubVxyXG5cclxuXHRcdHZhciBjMSA9IE1hdGguY29zKCB2LnggLyAyICk7XHJcblx0XHR2YXIgYzIgPSBNYXRoLmNvcyggdi55IC8gMiApO1xyXG5cdFx0dmFyIGMzID0gTWF0aC5jb3MoIHYueiAvIDIgKTtcclxuXHRcdHZhciBzMSA9IE1hdGguc2luKCB2LnggLyAyICk7XHJcblx0XHR2YXIgczIgPSBNYXRoLnNpbiggdi55IC8gMiApO1xyXG5cdFx0dmFyIHMzID0gTWF0aC5zaW4oIHYueiAvIDIgKTtcclxuXHJcblx0XHRpZiAoIG9yZGVyID09PSB1bmRlZmluZWQgfHwgb3JkZXIgPT09ICdYWVonICkge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xyXG5cdFx0XHR0aGlzLnkgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XHJcblx0XHRcdHRoaXMueiA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMztcclxuXHRcdFx0dGhpcy53ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWVhaJyApIHtcclxuXHJcblx0XHRcdHRoaXMueCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcclxuXHRcdFx0dGhpcy55ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xyXG5cdFx0XHR0aGlzLnogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XHJcblx0XHRcdHRoaXMudyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pYWScgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XHJcblx0XHRcdHRoaXMueSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcclxuXHRcdFx0dGhpcy56ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xyXG5cdFx0XHR0aGlzLncgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdaWVgnICkge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xyXG5cdFx0XHR0aGlzLnkgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XHJcblx0XHRcdHRoaXMueiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcclxuXHRcdFx0dGhpcy53ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWVpYJyApIHtcclxuXHJcblx0XHRcdHRoaXMueCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcclxuXHRcdFx0dGhpcy55ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xyXG5cdFx0XHR0aGlzLnogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XHJcblx0XHRcdHRoaXMudyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1haWScgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XHJcblx0XHRcdHRoaXMueSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcclxuXHRcdFx0dGhpcy56ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xyXG5cdFx0XHR0aGlzLncgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tQXhpc0FuZ2xlOiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xyXG5cclxuXHRcdC8vIGZyb20gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL2FuZ2xlVG9RdWF0ZXJuaW9uL2luZGV4Lmh0bVxyXG5cdFx0Ly8gYXhpcyBoYXZlIHRvIGJlIG5vcm1hbGl6ZWRcclxuXHJcblx0XHR2YXIgaGFsZkFuZ2xlID0gYW5nbGUgLyAyLFxyXG5cdFx0XHRzID0gTWF0aC5zaW4oIGhhbGZBbmdsZSApO1xyXG5cclxuXHRcdHRoaXMueCA9IGF4aXMueCAqIHM7XHJcblx0XHR0aGlzLnkgPSBheGlzLnkgKiBzO1xyXG5cdFx0dGhpcy56ID0gYXhpcy56ICogcztcclxuXHRcdHRoaXMudyA9IE1hdGguY29zKCBoYWxmQW5nbGUgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbVJvdGF0aW9uTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL21hdHJpeFRvUXVhdGVybmlvbi9pbmRleC5odG1cclxuXHJcblx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxyXG5cclxuXHRcdHZhciB0ZSA9IG0uZWxlbWVudHMsXHJcblxyXG5cdFx0XHRtMTEgPSB0ZVswXSwgbTEyID0gdGVbNF0sIG0xMyA9IHRlWzhdLFxyXG5cdFx0XHRtMjEgPSB0ZVsxXSwgbTIyID0gdGVbNV0sIG0yMyA9IHRlWzldLFxyXG5cdFx0XHRtMzEgPSB0ZVsyXSwgbTMyID0gdGVbNl0sIG0zMyA9IHRlWzEwXSxcclxuXHJcblx0XHRcdHRyYWNlID0gbTExICsgbTIyICsgbTMzLFxyXG5cdFx0XHRzO1xyXG5cclxuXHRcdGlmICggdHJhY2UgPiAwICkge1xyXG5cclxuXHRcdFx0cyA9IDAuNSAvIE1hdGguc3FydCggdHJhY2UgKyAxLjAgKTtcclxuXHJcblx0XHRcdHRoaXMudyA9IDAuMjUgLyBzO1xyXG5cdFx0XHR0aGlzLnggPSAoIG0zMiAtIG0yMyApICogcztcclxuXHRcdFx0dGhpcy55ID0gKCBtMTMgLSBtMzEgKSAqIHM7XHJcblx0XHRcdHRoaXMueiA9ICggbTIxIC0gbTEyICkgKiBzO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG0xMSA+IG0yMiAmJiBtMTEgPiBtMzMgKSB7XHJcblxyXG5cdFx0XHRzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMTEgLSBtMjIgLSBtMzMgKTtcclxuXHJcblx0XHRcdHRoaXMudyA9IChtMzIgLSBtMjMgKSAvIHM7XHJcblx0XHRcdHRoaXMueCA9IDAuMjUgKiBzO1xyXG5cdFx0XHR0aGlzLnkgPSAobTEyICsgbTIxICkgLyBzO1xyXG5cdFx0XHR0aGlzLnogPSAobTEzICsgbTMxICkgLyBzO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG0yMiA+IG0zMyApIHtcclxuXHJcblx0XHRcdHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0yMiAtIG0xMSAtIG0zMyApO1xyXG5cclxuXHRcdFx0dGhpcy53ID0gKG0xMyAtIG0zMSApIC8gcztcclxuXHRcdFx0dGhpcy54ID0gKG0xMiArIG0yMSApIC8gcztcclxuXHRcdFx0dGhpcy55ID0gMC4yNSAqIHM7XHJcblx0XHRcdHRoaXMueiA9IChtMjMgKyBtMzIgKSAvIHM7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0zMyAtIG0xMSAtIG0yMiApO1xyXG5cclxuXHRcdFx0dGhpcy53ID0gKCBtMjEgLSBtMTIgKSAvIHM7XHJcblx0XHRcdHRoaXMueCA9ICggbTEzICsgbTMxICkgLyBzO1xyXG5cdFx0XHR0aGlzLnkgPSAoIG0yMyArIG0zMiApIC8gcztcclxuXHRcdFx0dGhpcy56ID0gMC4yNSAqIHM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpbnZlcnNlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5jb25qdWdhdGUoKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29uanVnYXRlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy54ICo9IC0xO1xyXG5cdFx0dGhpcy55ICo9IC0xO1xyXG5cdFx0dGhpcy56ICo9IC0xO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKyB0aGlzLncgKiB0aGlzLnc7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlbmd0aDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiArIHRoaXMudyAqIHRoaXMudyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgbCA9IHRoaXMubGVuZ3RoKCk7XHJcblxyXG5cdFx0aWYgKCBsID09PSAwICkge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gMDtcclxuXHRcdFx0dGhpcy55ID0gMDtcclxuXHRcdFx0dGhpcy56ID0gMDtcclxuXHRcdFx0dGhpcy53ID0gMTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0bCA9IDEgLyBsO1xyXG5cclxuXHRcdFx0dGhpcy54ID0gdGhpcy54ICogbDtcclxuXHRcdFx0dGhpcy55ID0gdGhpcy55ICogbDtcclxuXHRcdFx0dGhpcy56ID0gdGhpcy56ICogbDtcclxuXHRcdFx0dGhpcy53ID0gdGhpcy53ICogbDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5OiBmdW5jdGlvbiAoIHEsIHAgKSB7XHJcblxyXG5cdFx0aWYgKCBwICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdERVBSRUNBVEVEOiBRdWF0ZXJuaW9uXFwncyAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseVF1YXRlcm5pb25zKCBhLCBiICkgaW5zdGVhZC4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnMoIHEsIHAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggdGhpcywgcSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtdWx0aXBseVF1YXRlcm5pb25zOiBmdW5jdGlvbiAoIGEsIGIgKSB7XHJcblxyXG5cdFx0Ly8gZnJvbSBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL3JlYWxOb3JtZWRBbGdlYnJhL3F1YXRlcm5pb25zL2NvZGUvaW5kZXguaHRtXHJcblxyXG5cdFx0dmFyIHFheCA9IGEueCwgcWF5ID0gYS55LCBxYXogPSBhLnosIHFhdyA9IGEudztcclxuXHRcdHZhciBxYnggPSBiLngsIHFieSA9IGIueSwgcWJ6ID0gYi56LCBxYncgPSBiLnc7XHJcblxyXG5cdFx0dGhpcy54ID0gcWF4ICogcWJ3ICsgcWF3ICogcWJ4ICsgcWF5ICogcWJ6IC0gcWF6ICogcWJ5O1xyXG5cdFx0dGhpcy55ID0gcWF5ICogcWJ3ICsgcWF3ICogcWJ5ICsgcWF6ICogcWJ4IC0gcWF4ICogcWJ6O1xyXG5cdFx0dGhpcy56ID0gcWF6ICogcWJ3ICsgcWF3ICogcWJ6ICsgcWF4ICogcWJ5IC0gcWF5ICogcWJ4O1xyXG5cdFx0dGhpcy53ID0gcWF3ICogcWJ3IC0gcWF4ICogcWJ4IC0gcWF5ICogcWJ5IC0gcWF6ICogcWJ6O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtdWx0aXBseVZlY3RvcjM6IGZ1bmN0aW9uICggdmVjdG9yICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ0RFUFJFQ0FURUQ6IFF1YXRlcm5pb25cXCdzIC5tdWx0aXBseVZlY3RvcjMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgaXMgbm93IHZlY3Rvci5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKSBpbnN0ZWFkLicgKTtcclxuXHRcdHJldHVybiB2ZWN0b3IuYXBwbHlRdWF0ZXJuaW9uKCB0aGlzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNsZXJwOiBmdW5jdGlvbiAoIHFiLCB0ICkge1xyXG5cclxuXHRcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56LCB3ID0gdGhpcy53O1xyXG5cclxuXHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvc2xlcnAvXHJcblxyXG5cdFx0dmFyIGNvc0hhbGZUaGV0YSA9IHcgKiBxYi53ICsgeCAqIHFiLnggKyB5ICogcWIueSArIHogKiBxYi56O1xyXG5cclxuXHRcdGlmICggY29zSGFsZlRoZXRhIDwgMCApIHtcclxuXHJcblx0XHRcdHRoaXMudyA9IC1xYi53O1xyXG5cdFx0XHR0aGlzLnggPSAtcWIueDtcclxuXHRcdFx0dGhpcy55ID0gLXFiLnk7XHJcblx0XHRcdHRoaXMueiA9IC1xYi56O1xyXG5cclxuXHRcdFx0Y29zSGFsZlRoZXRhID0gLWNvc0hhbGZUaGV0YTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhpcy5jb3B5KCBxYiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGNvc0hhbGZUaGV0YSA+PSAxLjAgKSB7XHJcblxyXG5cdFx0XHR0aGlzLncgPSB3O1xyXG5cdFx0XHR0aGlzLnggPSB4O1xyXG5cdFx0XHR0aGlzLnkgPSB5O1xyXG5cdFx0XHR0aGlzLnogPSB6O1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBoYWxmVGhldGEgPSBNYXRoLmFjb3MoIGNvc0hhbGZUaGV0YSApO1xyXG5cdFx0dmFyIHNpbkhhbGZUaGV0YSA9IE1hdGguc3FydCggMS4wIC0gY29zSGFsZlRoZXRhICogY29zSGFsZlRoZXRhICk7XHJcblxyXG5cdFx0aWYgKCBNYXRoLmFicyggc2luSGFsZlRoZXRhICkgPCAwLjAwMSApIHtcclxuXHJcblx0XHRcdHRoaXMudyA9IDAuNSAqICggdyArIHRoaXMudyApO1xyXG5cdFx0XHR0aGlzLnggPSAwLjUgKiAoIHggKyB0aGlzLnggKTtcclxuXHRcdFx0dGhpcy55ID0gMC41ICogKCB5ICsgdGhpcy55ICk7XHJcblx0XHRcdHRoaXMueiA9IDAuNSAqICggeiArIHRoaXMueiApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciByYXRpb0EgPSBNYXRoLnNpbiggKCAxIC0gdCApICogaGFsZlRoZXRhICkgLyBzaW5IYWxmVGhldGEsXHJcblx0XHRyYXRpb0IgPSBNYXRoLnNpbiggdCAqIGhhbGZUaGV0YSApIC8gc2luSGFsZlRoZXRhO1xyXG5cclxuXHRcdHRoaXMudyA9ICggdyAqIHJhdGlvQSArIHRoaXMudyAqIHJhdGlvQiApO1xyXG5cdFx0dGhpcy54ID0gKCB4ICogcmF0aW9BICsgdGhpcy54ICogcmF0aW9CICk7XHJcblx0XHR0aGlzLnkgPSAoIHkgKiByYXRpb0EgKyB0aGlzLnkgKiByYXRpb0IgKTtcclxuXHRcdHRoaXMueiA9ICggeiAqIHJhdGlvQSArIHRoaXMueiAqIHJhdGlvQiApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHRyZXR1cm4gKCAoIHYueCA9PT0gdGhpcy54ICkgJiYgKCB2LnkgPT09IHRoaXMueSApICYmICggdi56ID09PSB0aGlzLnogKSAmJiAoIHYudyA9PT0gdGhpcy53ICkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFRIUkVFLlF1YXRlcm5pb24oIHRoaXMueCwgdGhpcy55LCB0aGlzLnosIHRoaXMudyApO1xyXG5cclxuXHR9XHJcblxyXG59ICk7XHJcblxyXG5USFJFRS5RdWF0ZXJuaW9uLnNsZXJwID0gZnVuY3Rpb24gKCBxYSwgcWIsIHFtLCB0ICkge1xyXG5cclxuXHRyZXR1cm4gcW0uY29weSggcWEgKS5zbGVycCggcWIsIHQgKTtcclxuXHJcbn1cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXHJcbiAqIEBhdXRob3IgZWdyYWV0aGVyIC8gaHR0cDovL2VncmFldGhlci5jb20vXHJcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcclxuICovXHJcblxyXG5USFJFRS5WZWN0b3IyID0gZnVuY3Rpb24gKCB4LCB5ICkge1xyXG5cclxuXHR0aGlzLnggPSB4IHx8IDA7XHJcblx0dGhpcy55ID0geSB8fCAwO1xyXG5cclxufTtcclxuXHJcblRIUkVFLmV4dGVuZCggVEhSRUUuVmVjdG9yMi5wcm90b3R5cGUsIHtcclxuXHJcblx0c2V0OiBmdW5jdGlvbiAoIHgsIHkgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0geDtcclxuXHRcdHRoaXMueSA9IHk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFg6IGZ1bmN0aW9uICggeCApIHtcclxuXHJcblx0XHR0aGlzLnggPSB4O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRZOiBmdW5jdGlvbiAoIHkgKSB7XHJcblxyXG5cdFx0dGhpcy55ID0geTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblxyXG5cdHNldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCwgdmFsdWUgKSB7XHJcblxyXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XHJcblxyXG5cdFx0XHRjYXNlIDA6IHRoaXMueCA9IHZhbHVlOyBicmVhaztcclxuXHRcdFx0Y2FzZSAxOiB0aGlzLnkgPSB2YWx1ZTsgYnJlYWs7XHJcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggXCJpbmRleCBpcyBvdXQgb2YgcmFuZ2U6IFwiICsgaW5kZXggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCApIHtcclxuXHJcblx0XHRzd2l0Y2ggKCBpbmRleCApIHtcclxuXHJcblx0XHRcdGNhc2UgMDogcmV0dXJuIHRoaXMueDtcclxuXHRcdFx0Y2FzZSAxOiByZXR1cm4gdGhpcy55O1xyXG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoIFwiaW5kZXggaXMgb3V0IG9mIHJhbmdlOiBcIiArIGluZGV4ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gdi54O1xyXG5cdFx0dGhpcy55ID0gdi55O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhZGQ6IGZ1bmN0aW9uICggdiwgdyApIHtcclxuXHJcblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ0RFUFJFQ0FURUQ6IFZlY3RvcjJcXCdzIC5hZGQoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5hZGRWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmFkZFZlY3RvcnMoIHYsIHcgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy54ICs9IHYueDtcclxuXHRcdHRoaXMueSArPSB2Lnk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZFZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcblx0XHR0aGlzLnggPSBhLnggKyBiLng7XHJcblx0XHR0aGlzLnkgPSBhLnkgKyBiLnk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZFNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuXHRcdHRoaXMueCArPSBzO1xyXG5cdFx0dGhpcy55ICs9IHM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHN1YjogZnVuY3Rpb24gKCB2LCB3ICkge1xyXG5cclxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnREVQUkVDQVRFRDogVmVjdG9yMlxcJ3MgLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuc3ViVmVjdG9ycyggdiwgdyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnggLT0gdi54O1xyXG5cdFx0dGhpcy55IC09IHYueTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c3ViVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuXHRcdHRoaXMueCA9IGEueCAtIGIueDtcclxuXHRcdHRoaXMueSA9IGEueSAtIGIueTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcclxuXHJcblx0XHR0aGlzLnggKj0gcztcclxuXHRcdHRoaXMueSAqPSBzO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXZpZGVTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcclxuXHJcblx0XHRpZiAoIHMgIT09IDAgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggLz0gcztcclxuXHRcdFx0dGhpcy55IC89IHM7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMuc2V0KCAwLCAwICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtaW46IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMueCA+IHYueCApIHtcclxuXHJcblx0XHRcdHRoaXMueCA9IHYueDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLnkgPiB2LnkgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnkgPSB2Lnk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYXg6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMueCA8IHYueCApIHtcclxuXHJcblx0XHRcdHRoaXMueCA9IHYueDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLnkgPCB2LnkgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnkgPSB2Lnk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbGFtcDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcclxuXHJcblx0XHQvLyBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgbWluIDwgbWF4LCBpZiB0aGlzIGFzc3VtcHRpb24gaXNuJ3QgdHJ1ZSBpdCB3aWxsIG5vdCBvcGVyYXRlIGNvcnJlY3RseVxyXG5cclxuXHRcdGlmICggdGhpcy54IDwgbWluLnggKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSBtaW4ueDtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCB0aGlzLnggPiBtYXgueCApIHtcclxuXHJcblx0XHRcdHRoaXMueCA9IG1heC54O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMueSA8IG1pbi55ICkge1xyXG5cclxuXHRcdFx0dGhpcy55ID0gbWluLnk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggdGhpcy55ID4gbWF4LnkgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnkgPSBtYXgueTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG5lZ2F0ZTogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIC0gMSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkb3Q6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55O1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlbmd0aDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIHRoaXMubGVuZ3RoKCkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzdGFuY2VUbzogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQoIHYgKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXN0YW5jZVRvU3F1YXJlZDogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHZhciBkeCA9IHRoaXMueCAtIHYueCwgZHkgPSB0aGlzLnkgLSB2Lnk7XHJcblx0XHRyZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldExlbmd0aDogZnVuY3Rpb24gKCBsICkge1xyXG5cclxuXHRcdHZhciBvbGRMZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xyXG5cclxuXHRcdGlmICggb2xkTGVuZ3RoICE9PSAwICYmIGwgIT09IG9sZExlbmd0aCApIHtcclxuXHJcblx0XHRcdHRoaXMubXVsdGlwbHlTY2FsYXIoIGwgLyBvbGRMZW5ndGggKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bGVycDogZnVuY3Rpb24gKCB2LCBhbHBoYSApIHtcclxuXHJcblx0XHR0aGlzLnggKz0gKCB2LnggLSB0aGlzLnggKSAqIGFscGhhO1xyXG5cdFx0dGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiggdiApIHtcclxuXHJcblx0XHRyZXR1cm4gKCAoIHYueCA9PT0gdGhpcy54ICkgJiYgKCB2LnkgPT09IHRoaXMueSApICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRvQXJyYXk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gWyB0aGlzLngsIHRoaXMueSBdO1xyXG5cdFx0XHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIoIHRoaXMueCwgdGhpcy55ICk7XHJcblxyXG5cdH1cclxuXHJcbn0gKTtcclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgKmtpbGUgLyBodHRwOi8va2lsZS5zdHJhdmFnYW56YS5vcmcvXHJcbiAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgZWdyYWV0aGVyIC8gaHR0cDovL2VncmFldGhlci5jb20vXHJcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG4gKi9cclxuXHJcblRIUkVFLlZlY3RvcjMgPSBmdW5jdGlvbiAoIHgsIHksIHogKSB7XHJcblxyXG5cdHRoaXMueCA9IHggfHwgMDtcclxuXHR0aGlzLnkgPSB5IHx8IDA7XHJcblx0dGhpcy56ID0geiB8fCAwO1xyXG5cclxufTtcclxuXHJcblRIUkVFLmV4dGVuZCggVEhSRUUuVmVjdG9yMy5wcm90b3R5cGUsIHtcclxuXHJcblx0c2V0OiBmdW5jdGlvbiAoIHgsIHksIHogKSB7XHJcblxyXG5cdFx0dGhpcy54ID0geDtcclxuXHRcdHRoaXMueSA9IHk7XHJcblx0XHR0aGlzLnogPSB6O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRYOiBmdW5jdGlvbiAoIHggKSB7XHJcblxyXG5cdFx0dGhpcy54ID0geDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0WTogZnVuY3Rpb24gKCB5ICkge1xyXG5cclxuXHRcdHRoaXMueSA9IHk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFo6IGZ1bmN0aW9uICggeiApIHtcclxuXHJcblx0XHR0aGlzLnogPSB6O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXgsIHZhbHVlICkge1xyXG5cclxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xyXG5cclxuXHRcdFx0Y2FzZSAwOiB0aGlzLnggPSB2YWx1ZTsgYnJlYWs7XHJcblx0XHRcdGNhc2UgMTogdGhpcy55ID0gdmFsdWU7IGJyZWFrO1xyXG5cdFx0XHRjYXNlIDI6IHRoaXMueiA9IHZhbHVlOyBicmVhaztcclxuXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCBcImluZGV4IGlzIG91dCBvZiByYW5nZTogXCIgKyBpbmRleCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0Z2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4ICkge1xyXG5cclxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xyXG5cclxuXHRcdFx0Y2FzZSAwOiByZXR1cm4gdGhpcy54O1xyXG5cdFx0XHRjYXNlIDE6IHJldHVybiB0aGlzLnk7XHJcblx0XHRcdGNhc2UgMjogcmV0dXJuIHRoaXMuejtcclxuXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCBcImluZGV4IGlzIG91dCBvZiByYW5nZTogXCIgKyBpbmRleCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHYueDtcclxuXHRcdHRoaXMueSA9IHYueTtcclxuXHRcdHRoaXMueiA9IHYuejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YWRkOiBmdW5jdGlvbiAoIHYsIHcgKSB7XHJcblxyXG5cdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdERVBSRUNBVEVEOiBWZWN0b3IzXFwncyAuYWRkKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuYWRkVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5hZGRWZWN0b3JzKCB2LCB3ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMueCArPSB2Lng7XHJcblx0XHR0aGlzLnkgKz0gdi55O1xyXG5cdFx0dGhpcy56ICs9IHYuejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YWRkU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG5cdFx0dGhpcy54ICs9IHM7XHJcblx0XHR0aGlzLnkgKz0gcztcclxuXHRcdHRoaXMueiArPSBzO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhZGRWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gYS54ICsgYi54O1xyXG5cdFx0dGhpcy55ID0gYS55ICsgYi55O1xyXG5cdFx0dGhpcy56ID0gYS56ICsgYi56O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzdWI6IGZ1bmN0aW9uICggdiwgdyApIHtcclxuXHJcblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ0RFUFJFQ0FURUQ6IFZlY3RvcjNcXCdzIC5zdWIoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5zdWJWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYsIHcgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy54IC09IHYueDtcclxuXHRcdHRoaXMueSAtPSB2Lnk7XHJcblx0XHR0aGlzLnogLT0gdi56O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzdWJWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gYS54IC0gYi54O1xyXG5cdFx0dGhpcy55ID0gYS55IC0gYi55O1xyXG5cdFx0dGhpcy56ID0gYS56IC0gYi56O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtdWx0aXBseTogZnVuY3Rpb24gKCB2LCB3ICkge1xyXG5cclxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnREVQUkVDQVRFRDogVmVjdG9yM1xcJ3MgLm11bHRpcGx5KCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAubXVsdGlwbHlWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLm11bHRpcGx5VmVjdG9ycyggdiwgdyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnggKj0gdi54O1xyXG5cdFx0dGhpcy55ICo9IHYueTtcclxuXHRcdHRoaXMueiAqPSB2Lno7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG5cdFx0dGhpcy54ICo9IHM7XHJcblx0XHR0aGlzLnkgKj0gcztcclxuXHRcdHRoaXMueiAqPSBzO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtdWx0aXBseVZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcblx0XHR0aGlzLnggPSBhLnggKiBiLng7XHJcblx0XHR0aGlzLnkgPSBhLnkgKiBiLnk7XHJcblx0XHR0aGlzLnogPSBhLnogKiBiLno7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFwcGx5TWF0cml4MzogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdHZhciB4ID0gdGhpcy54O1xyXG5cdFx0dmFyIHkgPSB0aGlzLnk7XHJcblx0XHR2YXIgeiA9IHRoaXMuejtcclxuXHJcblx0XHR2YXIgZSA9IG0uZWxlbWVudHM7XHJcblxyXG5cdFx0dGhpcy54ID0gZVswXSAqIHggKyBlWzNdICogeSArIGVbNl0gKiB6O1xyXG5cdFx0dGhpcy55ID0gZVsxXSAqIHggKyBlWzRdICogeSArIGVbN10gKiB6O1xyXG5cdFx0dGhpcy56ID0gZVsyXSAqIHggKyBlWzVdICogeSArIGVbOF0gKiB6O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHQvLyBpbnB1dDogVEhSRUUuTWF0cml4NCBhZmZpbmUgbWF0cml4XHJcblxyXG5cdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XHJcblxyXG5cdFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRoaXMueCA9IGVbMF0gKiB4ICsgZVs0XSAqIHkgKyBlWzhdICAqIHogKyBlWzEyXTtcclxuXHRcdHRoaXMueSA9IGVbMV0gKiB4ICsgZVs1XSAqIHkgKyBlWzldICAqIHogKyBlWzEzXTtcclxuXHRcdHRoaXMueiA9IGVbMl0gKiB4ICsgZVs2XSAqIHkgKyBlWzEwXSAqIHogKyBlWzE0XTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YXBwbHlQcm9qZWN0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0Ly8gaW5wdXQ6IFRIUkVFLk1hdHJpeDQgcHJvamVjdGlvbiBtYXRyaXhcclxuXHJcblx0XHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcclxuXHJcblx0XHR2YXIgZSA9IG0uZWxlbWVudHM7XHJcblx0XHR2YXIgZCA9IDEgLyAoIGVbM10gKiB4ICsgZVs3XSAqIHkgKyBlWzExXSAqIHogKyBlWzE1XSApOyAvLyBwZXJzcGVjdGl2ZSBkaXZpZGVcclxuXHJcblx0XHR0aGlzLnggPSAoIGVbMF0gKiB4ICsgZVs0XSAqIHkgKyBlWzhdICAqIHogKyBlWzEyXSApICogZDtcclxuXHRcdHRoaXMueSA9ICggZVsxXSAqIHggKyBlWzVdICogeSArIGVbOV0gICogeiArIGVbMTNdICkgKiBkO1xyXG5cdFx0dGhpcy56ID0gKCBlWzJdICogeCArIGVbNl0gKiB5ICsgZVsxMF0gKiB6ICsgZVsxNF0gKSAqIGQ7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFwcGx5UXVhdGVybmlvbjogZnVuY3Rpb24gKCBxICkge1xyXG5cclxuXHRcdHZhciB4ID0gdGhpcy54O1xyXG5cdFx0dmFyIHkgPSB0aGlzLnk7XHJcblx0XHR2YXIgeiA9IHRoaXMuejtcclxuXHJcblx0XHR2YXIgcXggPSBxLng7XHJcblx0XHR2YXIgcXkgPSBxLnk7XHJcblx0XHR2YXIgcXogPSBxLno7XHJcblx0XHR2YXIgcXcgPSBxLnc7XHJcblxyXG5cdFx0Ly8gY2FsY3VsYXRlIHF1YXQgKiB2ZWN0b3JcclxuXHJcblx0XHR2YXIgaXggPSAgcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5O1xyXG5cdFx0dmFyIGl5ID0gIHF3ICogeSArIHF6ICogeCAtIHF4ICogejtcclxuXHRcdHZhciBpeiA9ICBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHg7XHJcblx0XHR2YXIgaXcgPSAtcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6O1xyXG5cclxuXHRcdC8vIGNhbGN1bGF0ZSByZXN1bHQgKiBpbnZlcnNlIHF1YXRcclxuXHJcblx0XHR0aGlzLnggPSBpeCAqIHF3ICsgaXcgKiAtcXggKyBpeSAqIC1xeiAtIGl6ICogLXF5O1xyXG5cdFx0dGhpcy55ID0gaXkgKiBxdyArIGl3ICogLXF5ICsgaXogKiAtcXggLSBpeCAqIC1xejtcclxuXHRcdHRoaXMueiA9IGl6ICogcXcgKyBpdyAqIC1xeiArIGl4ICogLXF5IC0gaXkgKiAtcXg7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFwcGx5RXVsZXI6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgcTEgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHYsIGV1bGVyT3JkZXIgKSB7XHJcblxyXG5cdFx0XHR2YXIgcXVhdGVybmlvbiA9IHExLnNldEZyb21FdWxlciggdiwgZXVsZXJPcmRlciApO1xyXG5cclxuXHRcdFx0dGhpcy5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0YXBwbHlBeGlzQW5nbGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgcTEgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xyXG5cclxuXHRcdFx0dmFyIHF1YXRlcm5pb24gPSBxMS5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApO1xyXG5cclxuXHRcdFx0dGhpcy5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0dHJhbnNmb3JtRGlyZWN0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0Ly8gaW5wdXQ6IFRIUkVFLk1hdHJpeDQgYWZmaW5lIG1hdHJpeFxyXG5cdFx0Ly8gdmVjdG9yIGludGVycHJldGVkIGFzIGEgZGlyZWN0aW9uXHJcblxyXG5cdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XHJcblxyXG5cdFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRoaXMueCA9IGVbMF0gKiB4ICsgZVs0XSAqIHkgKyBlWzhdICAqIHo7XHJcblx0XHR0aGlzLnkgPSBlWzFdICogeCArIGVbNV0gKiB5ICsgZVs5XSAgKiB6O1xyXG5cdFx0dGhpcy56ID0gZVsyXSAqIHggKyBlWzZdICogeSArIGVbMTBdICogejtcclxuXHJcblx0XHR0aGlzLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXZpZGU6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHR0aGlzLnggLz0gdi54O1xyXG5cdFx0dGhpcy55IC89IHYueTtcclxuXHRcdHRoaXMueiAvPSB2Lno7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpdmlkZVNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuXHRcdGlmICggcyAhPT0gMCApIHtcclxuXHJcblx0XHRcdHRoaXMueCAvPSBzO1xyXG5cdFx0XHR0aGlzLnkgLz0gcztcclxuXHRcdFx0dGhpcy56IC89IHM7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMueCA9IDA7XHJcblx0XHRcdHRoaXMueSA9IDA7XHJcblx0XHRcdHRoaXMueiA9IDA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtaW46IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMueCA+IHYueCApIHtcclxuXHJcblx0XHRcdHRoaXMueCA9IHYueDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLnkgPiB2LnkgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnkgPSB2Lnk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy56ID4gdi56ICkge1xyXG5cclxuXHRcdFx0dGhpcy56ID0gdi56O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bWF4OiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnggPCB2LnggKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSB2Lng7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy55IDwgdi55ICkge1xyXG5cclxuXHRcdFx0dGhpcy55ID0gdi55O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMueiA8IHYueiApIHtcclxuXHJcblx0XHRcdHRoaXMueiA9IHYuejtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsYW1wOiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xyXG5cclxuXHRcdC8vIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyBtaW4gPCBtYXgsIGlmIHRoaXMgYXNzdW1wdGlvbiBpc24ndCB0cnVlIGl0IHdpbGwgbm90IG9wZXJhdGUgY29ycmVjdGx5XHJcblxyXG5cdFx0aWYgKCB0aGlzLnggPCBtaW4ueCApIHtcclxuXHJcblx0XHRcdHRoaXMueCA9IG1pbi54O1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHRoaXMueCA+IG1heC54ICkge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gbWF4Lng7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy55IDwgbWluLnkgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnkgPSBtaW4ueTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCB0aGlzLnkgPiBtYXgueSApIHtcclxuXHJcblx0XHRcdHRoaXMueSA9IG1heC55O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMueiA8IG1pbi56ICkge1xyXG5cclxuXHRcdFx0dGhpcy56ID0gbWluLno7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggdGhpcy56ID4gbWF4LnogKSB7XHJcblxyXG5cdFx0XHR0aGlzLnogPSBtYXguejtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKCAtIDEgKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZG90OiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueSArIHRoaXMueiAqIHYuejtcclxuXHJcblx0fSxcclxuXHJcblx0bGVuZ3RoU3E6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56O1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZW5ndGg6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKTtcclxuXHJcblx0fSxcclxuXHJcblx0bGVuZ3RoTWFuaGF0dGFuOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguYWJzKCB0aGlzLnggKSArIE1hdGguYWJzKCB0aGlzLnkgKSArIE1hdGguYWJzKCB0aGlzLnogKTtcclxuXHJcblx0fSxcclxuXHJcblx0bm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCB0aGlzLmxlbmd0aCgpICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldExlbmd0aDogZnVuY3Rpb24gKCBsICkge1xyXG5cclxuXHRcdHZhciBvbGRMZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xyXG5cclxuXHRcdGlmICggb2xkTGVuZ3RoICE9PSAwICYmIGwgIT09IG9sZExlbmd0aCAgKSB7XHJcblxyXG5cdFx0XHR0aGlzLm11bHRpcGx5U2NhbGFyKCBsIC8gb2xkTGVuZ3RoICk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlcnA6IGZ1bmN0aW9uICggdiwgYWxwaGEgKSB7XHJcblxyXG5cdFx0dGhpcy54ICs9ICggdi54IC0gdGhpcy54ICkgKiBhbHBoYTtcclxuXHRcdHRoaXMueSArPSAoIHYueSAtIHRoaXMueSApICogYWxwaGE7XHJcblx0XHR0aGlzLnogKz0gKCB2LnogLSB0aGlzLnogKSAqIGFscGhhO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjcm9zczogZnVuY3Rpb24gKCB2LCB3ICkge1xyXG5cclxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnREVQUkVDQVRFRDogVmVjdG9yM1xcJ3MgLmNyb3NzKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuY3Jvc3NWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmNyb3NzVmVjdG9ycyggdiwgdyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcclxuXHJcblx0XHR0aGlzLnggPSB5ICogdi56IC0geiAqIHYueTtcclxuXHRcdHRoaXMueSA9IHogKiB2LnggLSB4ICogdi56O1xyXG5cdFx0dGhpcy56ID0geCAqIHYueSAtIHkgKiB2Lng7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNyb3NzVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuXHRcdHRoaXMueCA9IGEueSAqIGIueiAtIGEueiAqIGIueTtcclxuXHRcdHRoaXMueSA9IGEueiAqIGIueCAtIGEueCAqIGIuejtcclxuXHRcdHRoaXMueiA9IGEueCAqIGIueSAtIGEueSAqIGIueDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0cHJvamVjdE9uVmVjdG9yOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24oIHZlY3RvciApIHtcclxuXHJcblx0XHRcdHYxLmNvcHkoIHZlY3RvciApLm5vcm1hbGl6ZSgpO1xyXG5cdFx0XHR2YXIgZCA9IHRoaXMuZG90KCB2MSApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5jb3B5KCB2MSApLm11bHRpcGx5U2NhbGFyKCBkICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRwcm9qZWN0T25QbGFuZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwbGFuZU5vcm1hbCApIHtcclxuXHJcblx0XHRcdHYxLmNvcHkoIHRoaXMgKS5wcm9qZWN0T25WZWN0b3IoIHBsYW5lTm9ybWFsICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5zdWIoIHYxICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9KCksXHJcblxyXG5cdHJlZmxlY3Q6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHZlY3RvciApIHtcclxuXHJcblx0XHQgICAgdjEuY29weSggdGhpcyApLnByb2plY3RPblZlY3RvciggdmVjdG9yICkubXVsdGlwbHlTY2FsYXIoIDIgKTtcclxuXHJcblx0XHQgICAgcmV0dXJuIHRoaXMuc3ViVmVjdG9ycyggdjEsIHRoaXMgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0oKSxcclxuXHJcblx0YW5nbGVUbzogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHZhciB0aGV0YSA9IHRoaXMuZG90KCB2ICkgLyAoIHRoaXMubGVuZ3RoKCkgKiB2Lmxlbmd0aCgpICk7XHJcblxyXG5cdFx0Ly8gY2xhbXAsIHRvIGhhbmRsZSBudW1lcmljYWwgcHJvYmxlbXNcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5hY29zKCBUSFJFRS5NYXRoLmNsYW1wKCB0aGV0YSwgLTEsIDEgKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXN0YW5jZVRvOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy5kaXN0YW5jZVRvU3F1YXJlZCggdiApICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc3RhbmNlVG9TcXVhcmVkOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0dmFyIGR4ID0gdGhpcy54IC0gdi54O1xyXG5cdFx0dmFyIGR5ID0gdGhpcy55IC0gdi55O1xyXG5cdFx0dmFyIGR6ID0gdGhpcy56IC0gdi56O1xyXG5cclxuXHRcdHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeSArIGR6ICogZHo7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldFBvc2l0aW9uRnJvbU1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdHRoaXMueCA9IG0uZWxlbWVudHNbMTJdO1xyXG5cdFx0dGhpcy55ID0gbS5lbGVtZW50c1sxM107XHJcblx0XHR0aGlzLnogPSBtLmVsZW1lbnRzWzE0XTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RXVsZXJGcm9tUm90YXRpb25NYXRyaXg6IGZ1bmN0aW9uICggbSwgb3JkZXIgKSB7XHJcblxyXG5cdFx0Ly8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcclxuXHJcblx0XHQvLyBjbGFtcCwgdG8gaGFuZGxlIG51bWVyaWNhbCBwcm9ibGVtc1xyXG5cclxuXHRcdGZ1bmN0aW9uIGNsYW1wKCB4ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIE1hdGgubWluKCBNYXRoLm1heCggeCwgLTEgKSwgMSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgdGUgPSBtLmVsZW1lbnRzO1xyXG5cdFx0dmFyIG0xMSA9IHRlWzBdLCBtMTIgPSB0ZVs0XSwgbTEzID0gdGVbOF07XHJcblx0XHR2YXIgbTIxID0gdGVbMV0sIG0yMiA9IHRlWzVdLCBtMjMgPSB0ZVs5XTtcclxuXHRcdHZhciBtMzEgPSB0ZVsyXSwgbTMyID0gdGVbNl0sIG0zMyA9IHRlWzEwXTtcclxuXHJcblx0XHRpZiAoIG9yZGVyID09PSB1bmRlZmluZWQgfHwgb3JkZXIgPT09ICdYWVonICkge1xyXG5cclxuXHRcdFx0dGhpcy55ID0gTWF0aC5hc2luKCBjbGFtcCggbTEzICkgKTtcclxuXHJcblx0XHRcdGlmICggTWF0aC5hYnMoIG0xMyApIDwgMC45OTk5OSApIHtcclxuXHJcblx0XHRcdFx0dGhpcy54ID0gTWF0aC5hdGFuMiggLSBtMjMsIG0zMyApO1xyXG5cdFx0XHRcdHRoaXMueiA9IE1hdGguYXRhbjIoIC0gbTEyLCBtMTEgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHRoaXMueCA9IE1hdGguYXRhbjIoIG0zMiwgbTIyICk7XHJcblx0XHRcdFx0dGhpcy56ID0gMDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1lYWicgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSBNYXRoLmFzaW4oIC0gY2xhbXAoIG0yMyApICk7XHJcblxyXG5cdFx0XHRpZiAoIE1hdGguYWJzKCBtMjMgKSA8IDAuOTk5OTkgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMueSA9IE1hdGguYXRhbjIoIG0xMywgbTMzICk7XHJcblx0XHRcdFx0dGhpcy56ID0gTWF0aC5hdGFuMiggbTIxLCBtMjIgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHRoaXMueSA9IE1hdGguYXRhbjIoIC0gbTMxLCBtMTEgKTtcclxuXHRcdFx0XHR0aGlzLnogPSAwO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWlhZJyApIHtcclxuXHJcblx0XHRcdHRoaXMueCA9IE1hdGguYXNpbiggY2xhbXAoIG0zMiApICk7XHJcblxyXG5cdFx0XHRpZiAoIE1hdGguYWJzKCBtMzIgKSA8IDAuOTk5OTkgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMueSA9IE1hdGguYXRhbjIoIC0gbTMxLCBtMzMgKTtcclxuXHRcdFx0XHR0aGlzLnogPSBNYXRoLmF0YW4yKCAtIG0xMiwgbTIyICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0aGlzLnkgPSAwO1xyXG5cdFx0XHRcdHRoaXMueiA9IE1hdGguYXRhbjIoIG0yMSwgbTExICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdaWVgnICkge1xyXG5cclxuXHRcdFx0dGhpcy55ID0gTWF0aC5hc2luKCAtIGNsYW1wKCBtMzEgKSApO1xyXG5cclxuXHRcdFx0aWYgKCBNYXRoLmFicyggbTMxICkgPCAwLjk5OTk5ICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLnggPSBNYXRoLmF0YW4yKCBtMzIsIG0zMyApO1xyXG5cdFx0XHRcdHRoaXMueiA9IE1hdGguYXRhbjIoIG0yMSwgbTExICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0aGlzLnggPSAwO1xyXG5cdFx0XHRcdHRoaXMueiA9IE1hdGguYXRhbjIoIC0gbTEyLCBtMjIgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1laWCcgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnogPSBNYXRoLmFzaW4oIGNsYW1wKCBtMjEgKSApO1xyXG5cclxuXHRcdFx0aWYgKCBNYXRoLmFicyggbTIxICkgPCAwLjk5OTk5ICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLnggPSBNYXRoLmF0YW4yKCAtIG0yMywgbTIyICk7XHJcblx0XHRcdFx0dGhpcy55ID0gTWF0aC5hdGFuMiggLSBtMzEsIG0xMSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dGhpcy54ID0gMDtcclxuXHRcdFx0XHR0aGlzLnkgPSBNYXRoLmF0YW4yKCBtMTMsIG0zMyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWFpZJyApIHtcclxuXHJcblx0XHRcdHRoaXMueiA9IE1hdGguYXNpbiggLSBjbGFtcCggbTEyICkgKTtcclxuXHJcblx0XHRcdGlmICggTWF0aC5hYnMoIG0xMiApIDwgMC45OTk5OSApIHtcclxuXHJcblx0XHRcdFx0dGhpcy54ID0gTWF0aC5hdGFuMiggbTMyLCBtMjIgKTtcclxuXHRcdFx0XHR0aGlzLnkgPSBNYXRoLmF0YW4yKCBtMTMsIG0xMSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dGhpcy54ID0gTWF0aC5hdGFuMiggLSBtMjMsIG0zMyApO1xyXG5cdFx0XHRcdHRoaXMueSA9IDA7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRFdWxlckZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEsIG9yZGVyICkge1xyXG5cclxuXHRcdC8vIHEgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXHJcblxyXG5cdFx0Ly8gY2xhbXAsIHRvIGhhbmRsZSBudW1lcmljYWwgcHJvYmxlbXNcclxuXHJcblx0XHRmdW5jdGlvbiBjbGFtcCggeCApIHtcclxuXHJcblx0XHRcdHJldHVybiBNYXRoLm1pbiggTWF0aC5tYXgoIHgsIC0xICksIDEgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gaHR0cDovL3d3dy5tYXRod29ya3MuY29tL21hdGxhYmNlbnRyYWwvZmlsZWV4Y2hhbmdlLzIwNjk2LWZ1bmN0aW9uLXRvLWNvbnZlcnQtYmV0d2Vlbi1kY20tZXVsZXItYW5nbGVzLXF1YXRlcm5pb25zLWFuZC1ldWxlci12ZWN0b3JzL2NvbnRlbnQvU3BpbkNhbGMubVxyXG5cclxuXHRcdHZhciBzcXggPSBxLnggKiBxLng7XHJcblx0XHR2YXIgc3F5ID0gcS55ICogcS55O1xyXG5cdFx0dmFyIHNxeiA9IHEueiAqIHEuejtcclxuXHRcdHZhciBzcXcgPSBxLncgKiBxLnc7XHJcblxyXG5cdFx0aWYgKCBvcmRlciA9PT0gdW5kZWZpbmVkIHx8IG9yZGVyID09PSAnWFlaJyApIHtcclxuXHJcblx0XHRcdHRoaXMueCA9IE1hdGguYXRhbjIoIDIgKiAoIHEueCAqIHEudyAtIHEueSAqIHEueiApLCAoIHNxdyAtIHNxeCAtIHNxeSArIHNxeiApICk7XHJcblx0XHRcdHRoaXMueSA9IE1hdGguYXNpbiggIGNsYW1wKCAyICogKCBxLnggKiBxLnogKyBxLnkgKiBxLncgKSApICk7XHJcblx0XHRcdHRoaXMueiA9IE1hdGguYXRhbjIoIDIgKiAoIHEueiAqIHEudyAtIHEueCAqIHEueSApLCAoIHNxdyArIHNxeCAtIHNxeSAtIHNxeiApICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICAnWVhaJyApIHtcclxuXHJcblx0XHRcdHRoaXMueCA9IE1hdGguYXNpbiggIGNsYW1wKCAyICogKCBxLnggKiBxLncgLSBxLnkgKiBxLnogKSApICk7XHJcblx0XHRcdHRoaXMueSA9IE1hdGguYXRhbjIoIDIgKiAoIHEueCAqIHEueiArIHEueSAqIHEudyApLCAoIHNxdyAtIHNxeCAtIHNxeSArIHNxeiApICk7XHJcblx0XHRcdHRoaXMueiA9IE1hdGguYXRhbjIoIDIgKiAoIHEueCAqIHEueSArIHEueiAqIHEudyApLCAoIHNxdyAtIHNxeCArIHNxeSAtIHNxeiApICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdaWFknICkge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gTWF0aC5hc2luKCAgY2xhbXAoIDIgKiAoIHEueCAqIHEudyArIHEueSAqIHEueiApICkgKTtcclxuXHRcdFx0dGhpcy55ID0gTWF0aC5hdGFuMiggMiAqICggcS55ICogcS53IC0gcS56ICogcS54ICksICggc3F3IC0gc3F4IC0gc3F5ICsgc3F6ICkgKTtcclxuXHRcdFx0dGhpcy56ID0gTWF0aC5hdGFuMiggMiAqICggcS56ICogcS53IC0gcS54ICogcS55ICksICggc3F3IC0gc3F4ICsgc3F5IC0gc3F6ICkgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pZWCcgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSBNYXRoLmF0YW4yKCAyICogKCBxLnggKiBxLncgKyBxLnogKiBxLnkgKSwgKCBzcXcgLSBzcXggLSBzcXkgKyBzcXogKSApO1xyXG5cdFx0XHR0aGlzLnkgPSBNYXRoLmFzaW4oICBjbGFtcCggMiAqICggcS55ICogcS53IC0gcS54ICogcS56ICkgKSApO1xyXG5cdFx0XHR0aGlzLnogPSBNYXRoLmF0YW4yKCAyICogKCBxLnggKiBxLnkgKyBxLnogKiBxLncgKSwgKCBzcXcgKyBzcXggLSBzcXkgLSBzcXogKSApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWVpYJyApIHtcclxuXHJcblx0XHRcdHRoaXMueCA9IE1hdGguYXRhbjIoIDIgKiAoIHEueCAqIHEudyAtIHEueiAqIHEueSApLCAoIHNxdyAtIHNxeCArIHNxeSAtIHNxeiApICk7XHJcblx0XHRcdHRoaXMueSA9IE1hdGguYXRhbjIoIDIgKiAoIHEueSAqIHEudyAtIHEueCAqIHEueiApLCAoIHNxdyArIHNxeCAtIHNxeSAtIHNxeiApICk7XHJcblx0XHRcdHRoaXMueiA9IE1hdGguYXNpbiggIGNsYW1wKCAyICogKCBxLnggKiBxLnkgKyBxLnogKiBxLncgKSApICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdYWlknICkge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gTWF0aC5hdGFuMiggMiAqICggcS54ICogcS53ICsgcS55ICogcS56ICksICggc3F3IC0gc3F4ICsgc3F5IC0gc3F6ICkgKTtcclxuXHRcdFx0dGhpcy55ID0gTWF0aC5hdGFuMiggMiAqICggcS54ICogcS56ICsgcS55ICogcS53ICksICggc3F3ICsgc3F4IC0gc3F5IC0gc3F6ICkgKTtcclxuXHRcdFx0dGhpcy56ID0gTWF0aC5hc2luKCAgY2xhbXAoIDIgKiAoIHEueiAqIHEudyAtIHEueCAqIHEueSApICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldFNjYWxlRnJvbU1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdHZhciBzeCA9IHRoaXMuc2V0KCBtLmVsZW1lbnRzWzBdLCBtLmVsZW1lbnRzWzFdLCBtLmVsZW1lbnRzWzJdICkubGVuZ3RoKCk7XHJcblx0XHR2YXIgc3kgPSB0aGlzLnNldCggbS5lbGVtZW50c1s0XSwgbS5lbGVtZW50c1s1XSwgbS5lbGVtZW50c1s2XSApLmxlbmd0aCgpO1xyXG5cdFx0dmFyIHN6ID0gdGhpcy5zZXQoIG0uZWxlbWVudHNbOF0sIG0uZWxlbWVudHNbOV0sIG0uZWxlbWVudHNbMTBdICkubGVuZ3RoKCk7XHJcblxyXG5cdFx0dGhpcy54ID0gc3g7XHJcblx0XHR0aGlzLnkgPSBzeTtcclxuXHRcdHRoaXMueiA9IHN6O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGVxdWFsczogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHJldHVybiAoICggdi54ID09PSB0aGlzLnggKSAmJiAoIHYueSA9PT0gdGhpcy55ICkgJiYgKCB2LnogPT09IHRoaXMueiApICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRvQXJyYXk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gWyB0aGlzLngsIHRoaXMueSwgdGhpcy56IF07XHJcblx0XHRcclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMyggdGhpcy54LCB0aGlzLnksIHRoaXMueiApO1xyXG5cclxuXHR9XHJcblxyXG59ICk7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIHN1cGVyZWdnYmVydCAvIGh0dHA6Ly93d3cucGF1bGJydW50LmNvLnVrL1xyXG4gKiBAYXV0aG9yIHBoaWxvZ2IgLyBodHRwOi8vYmxvZy50aGVqaXQub3JnL1xyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIGVncmFldGhlciAvIGh0dHA6Ly9lZ3JhZXRoZXIuY29tL1xyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICovXHJcblxyXG5USFJFRS5WZWN0b3I0ID0gZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xyXG5cclxuXHR0aGlzLnggPSB4IHx8IDA7XHJcblx0dGhpcy55ID0geSB8fCAwO1xyXG5cdHRoaXMueiA9IHogfHwgMDtcclxuXHR0aGlzLncgPSAoIHcgIT09IHVuZGVmaW5lZCApID8gdyA6IDE7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuZXh0ZW5kKCBUSFJFRS5WZWN0b3I0LnByb3RvdHlwZSwge1xyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggeCwgeSwgeiwgdyApIHtcclxuXHJcblx0XHR0aGlzLnggPSB4O1xyXG5cdFx0dGhpcy55ID0geTtcclxuXHRcdHRoaXMueiA9IHo7XHJcblx0XHR0aGlzLncgPSB3O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRYOiBmdW5jdGlvbiAoIHggKSB7XHJcblxyXG5cdFx0dGhpcy54ID0geDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0WTogZnVuY3Rpb24gKCB5ICkge1xyXG5cclxuXHRcdHRoaXMueSA9IHk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFo6IGZ1bmN0aW9uICggeiApIHtcclxuXHJcblx0XHR0aGlzLnogPSB6O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRXOiBmdW5jdGlvbiAoIHcgKSB7XHJcblxyXG5cdFx0dGhpcy53ID0gdztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4LCB2YWx1ZSApIHtcclxuXHJcblx0XHRzd2l0Y2ggKCBpbmRleCApIHtcclxuXHJcblx0XHRcdGNhc2UgMDogdGhpcy54ID0gdmFsdWU7IGJyZWFrO1xyXG5cdFx0XHRjYXNlIDE6IHRoaXMueSA9IHZhbHVlOyBicmVhaztcclxuXHRcdFx0Y2FzZSAyOiB0aGlzLnogPSB2YWx1ZTsgYnJlYWs7XHJcblx0XHRcdGNhc2UgMzogdGhpcy53ID0gdmFsdWU7IGJyZWFrO1xyXG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoIFwiaW5kZXggaXMgb3V0IG9mIHJhbmdlOiBcIiArIGluZGV4ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXggKSB7XHJcblxyXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XHJcblxyXG5cdFx0XHRjYXNlIDA6IHJldHVybiB0aGlzLng7XHJcblx0XHRcdGNhc2UgMTogcmV0dXJuIHRoaXMueTtcclxuXHRcdFx0Y2FzZSAyOiByZXR1cm4gdGhpcy56O1xyXG5cdFx0XHRjYXNlIDM6IHJldHVybiB0aGlzLnc7XHJcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggXCJpbmRleCBpcyBvdXQgb2YgcmFuZ2U6IFwiICsgaW5kZXggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHR0aGlzLnggPSB2Lng7XHJcblx0XHR0aGlzLnkgPSB2Lnk7XHJcblx0XHR0aGlzLnogPSB2Lno7XHJcblx0XHR0aGlzLncgPSAoIHYudyAhPT0gdW5kZWZpbmVkICkgPyB2LncgOiAxO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhZGQ6IGZ1bmN0aW9uICggdiwgdyApIHtcclxuXHJcblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ0RFUFJFQ0FURUQ6IFZlY3RvcjRcXCdzIC5hZGQoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5hZGRWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmFkZFZlY3RvcnMoIHYsIHcgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy54ICs9IHYueDtcclxuXHRcdHRoaXMueSArPSB2Lnk7XHJcblx0XHR0aGlzLnogKz0gdi56O1xyXG5cdFx0dGhpcy53ICs9IHYudztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YWRkU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG5cdFx0dGhpcy54ICs9IHM7XHJcblx0XHR0aGlzLnkgKz0gcztcclxuXHRcdHRoaXMueiArPSBzO1xyXG5cdFx0dGhpcy53ICs9IHM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZFZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcblx0XHR0aGlzLnggPSBhLnggKyBiLng7XHJcblx0XHR0aGlzLnkgPSBhLnkgKyBiLnk7XHJcblx0XHR0aGlzLnogPSBhLnogKyBiLno7XHJcblx0XHR0aGlzLncgPSBhLncgKyBiLnc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHN1YjogZnVuY3Rpb24gKCB2LCB3ICkge1xyXG5cclxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnREVQUkVDQVRFRDogVmVjdG9yNFxcJ3MgLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuc3ViVmVjdG9ycyggdiwgdyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnggLT0gdi54O1xyXG5cdFx0dGhpcy55IC09IHYueTtcclxuXHRcdHRoaXMueiAtPSB2Lno7XHJcblx0XHR0aGlzLncgLT0gdi53O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzdWJWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gYS54IC0gYi54O1xyXG5cdFx0dGhpcy55ID0gYS55IC0gYi55O1xyXG5cdFx0dGhpcy56ID0gYS56IC0gYi56O1xyXG5cdFx0dGhpcy53ID0gYS53IC0gYi53O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuXHRcdHRoaXMueCAqPSBzO1xyXG5cdFx0dGhpcy55ICo9IHM7XHJcblx0XHR0aGlzLnogKj0gcztcclxuXHRcdHRoaXMudyAqPSBzO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHR2YXIgeCA9IHRoaXMueDtcclxuXHRcdHZhciB5ID0gdGhpcy55O1xyXG5cdFx0dmFyIHogPSB0aGlzLno7XHJcblx0XHR2YXIgdyA9IHRoaXMudztcclxuXHJcblx0XHR2YXIgZSA9IG0uZWxlbWVudHM7XHJcblxyXG5cdFx0dGhpcy54ID0gZVswXSAqIHggKyBlWzRdICogeSArIGVbOF0gKiB6ICsgZVsxMl0gKiB3O1xyXG5cdFx0dGhpcy55ID0gZVsxXSAqIHggKyBlWzVdICogeSArIGVbOV0gKiB6ICsgZVsxM10gKiB3O1xyXG5cdFx0dGhpcy56ID0gZVsyXSAqIHggKyBlWzZdICogeSArIGVbMTBdICogeiArIGVbMTRdICogdztcclxuXHRcdHRoaXMudyA9IGVbM10gKiB4ICsgZVs3XSAqIHkgKyBlWzExXSAqIHogKyBlWzE1XSAqIHc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpdmlkZVNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuXHRcdGlmICggcyAhPT0gMCApIHtcclxuXHJcblx0XHRcdHRoaXMueCAvPSBzO1xyXG5cdFx0XHR0aGlzLnkgLz0gcztcclxuXHRcdFx0dGhpcy56IC89IHM7XHJcblx0XHRcdHRoaXMudyAvPSBzO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSAwO1xyXG5cdFx0XHR0aGlzLnkgPSAwO1xyXG5cdFx0XHR0aGlzLnogPSAwO1xyXG5cdFx0XHR0aGlzLncgPSAxO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0QXhpc0FuZ2xlRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcclxuXHJcblx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvcXVhdGVybmlvblRvQW5nbGUvaW5kZXguaHRtXHJcblxyXG5cdFx0Ly8gcSBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcclxuXHJcblx0XHR0aGlzLncgPSAyICogTWF0aC5hY29zKCBxLncgKTtcclxuXHJcblx0XHR2YXIgcyA9IE1hdGguc3FydCggMSAtIHEudyAqIHEudyApO1xyXG5cclxuXHRcdGlmICggcyA8IDAuMDAwMSApIHtcclxuXHJcblx0XHRcdCB0aGlzLnggPSAxO1xyXG5cdFx0XHQgdGhpcy55ID0gMDtcclxuXHRcdFx0IHRoaXMueiA9IDA7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdCB0aGlzLnggPSBxLnggLyBzO1xyXG5cdFx0XHQgdGhpcy55ID0gcS55IC8gcztcclxuXHRcdFx0IHRoaXMueiA9IHEueiAvIHM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRBeGlzQW5nbGVGcm9tUm90YXRpb25NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvbWF0cml4VG9BbmdsZS9pbmRleC5odG1cclxuXHJcblx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxyXG5cclxuXHRcdHZhciBhbmdsZSwgeCwgeSwgeixcdFx0Ly8gdmFyaWFibGVzIGZvciByZXN1bHRcclxuXHRcdFx0ZXBzaWxvbiA9IDAuMDEsXHRcdC8vIG1hcmdpbiB0byBhbGxvdyBmb3Igcm91bmRpbmcgZXJyb3JzXHJcblx0XHRcdGVwc2lsb24yID0gMC4xLFx0XHQvLyBtYXJnaW4gdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiAwIGFuZCAxODAgZGVncmVlc1xyXG5cclxuXHRcdFx0dGUgPSBtLmVsZW1lbnRzLFxyXG5cclxuXHRcdFx0bTExID0gdGVbMF0sIG0xMiA9IHRlWzRdLCBtMTMgPSB0ZVs4XSxcclxuXHRcdFx0bTIxID0gdGVbMV0sIG0yMiA9IHRlWzVdLCBtMjMgPSB0ZVs5XSxcclxuXHRcdFx0bTMxID0gdGVbMl0sIG0zMiA9IHRlWzZdLCBtMzMgPSB0ZVsxMF07XHJcblxyXG5cdFx0aWYgKCAoIE1hdGguYWJzKCBtMTIgLSBtMjEgKSA8IGVwc2lsb24gKVxyXG5cdFx0ICAmJiAoIE1hdGguYWJzKCBtMTMgLSBtMzEgKSA8IGVwc2lsb24gKVxyXG5cdFx0ICAmJiAoIE1hdGguYWJzKCBtMjMgLSBtMzIgKSA8IGVwc2lsb24gKSApIHtcclxuXHJcblx0XHRcdC8vIHNpbmd1bGFyaXR5IGZvdW5kXHJcblx0XHRcdC8vIGZpcnN0IGNoZWNrIGZvciBpZGVudGl0eSBtYXRyaXggd2hpY2ggbXVzdCBoYXZlICsxIGZvciBhbGwgdGVybXNcclxuXHRcdFx0Ly8gaW4gbGVhZGluZyBkaWFnb25hbCBhbmQgemVybyBpbiBvdGhlciB0ZXJtc1xyXG5cclxuXHRcdFx0aWYgKCAoIE1hdGguYWJzKCBtMTIgKyBtMjEgKSA8IGVwc2lsb24yIClcclxuXHRcdFx0ICAmJiAoIE1hdGguYWJzKCBtMTMgKyBtMzEgKSA8IGVwc2lsb24yIClcclxuXHRcdFx0ICAmJiAoIE1hdGguYWJzKCBtMjMgKyBtMzIgKSA8IGVwc2lsb24yIClcclxuXHRcdFx0ICAmJiAoIE1hdGguYWJzKCBtMTEgKyBtMjIgKyBtMzMgLSAzICkgPCBlcHNpbG9uMiApICkge1xyXG5cclxuXHRcdFx0XHQvLyB0aGlzIHNpbmd1bGFyaXR5IGlzIGlkZW50aXR5IG1hdHJpeCBzbyBhbmdsZSA9IDBcclxuXHJcblx0XHRcdFx0dGhpcy5zZXQoIDEsIDAsIDAsIDAgKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHRoaXM7IC8vIHplcm8gYW5nbGUsIGFyYml0cmFyeSBheGlzXHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBvdGhlcndpc2UgdGhpcyBzaW5ndWxhcml0eSBpcyBhbmdsZSA9IDE4MFxyXG5cclxuXHRcdFx0YW5nbGUgPSBNYXRoLlBJO1xyXG5cclxuXHRcdFx0dmFyIHh4ID0gKCBtMTEgKyAxICkgLyAyO1xyXG5cdFx0XHR2YXIgeXkgPSAoIG0yMiArIDEgKSAvIDI7XHJcblx0XHRcdHZhciB6eiA9ICggbTMzICsgMSApIC8gMjtcclxuXHRcdFx0dmFyIHh5ID0gKCBtMTIgKyBtMjEgKSAvIDQ7XHJcblx0XHRcdHZhciB4eiA9ICggbTEzICsgbTMxICkgLyA0O1xyXG5cdFx0XHR2YXIgeXogPSAoIG0yMyArIG0zMiApIC8gNDtcclxuXHJcblx0XHRcdGlmICggKCB4eCA+IHl5ICkgJiYgKCB4eCA+IHp6ICkgKSB7IC8vIG0xMSBpcyB0aGUgbGFyZ2VzdCBkaWFnb25hbCB0ZXJtXHJcblxyXG5cdFx0XHRcdGlmICggeHggPCBlcHNpbG9uICkge1xyXG5cclxuXHRcdFx0XHRcdHggPSAwO1xyXG5cdFx0XHRcdFx0eSA9IDAuNzA3MTA2NzgxO1xyXG5cdFx0XHRcdFx0eiA9IDAuNzA3MTA2NzgxO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHggPSBNYXRoLnNxcnQoIHh4ICk7XHJcblx0XHRcdFx0XHR5ID0geHkgLyB4O1xyXG5cdFx0XHRcdFx0eiA9IHh6IC8geDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggeXkgPiB6eiApIHsgLy8gbTIyIGlzIHRoZSBsYXJnZXN0IGRpYWdvbmFsIHRlcm1cclxuXHJcblx0XHRcdFx0aWYgKCB5eSA8IGVwc2lsb24gKSB7XHJcblxyXG5cdFx0XHRcdFx0eCA9IDAuNzA3MTA2NzgxO1xyXG5cdFx0XHRcdFx0eSA9IDA7XHJcblx0XHRcdFx0XHR6ID0gMC43MDcxMDY3ODE7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0eSA9IE1hdGguc3FydCggeXkgKTtcclxuXHRcdFx0XHRcdHggPSB4eSAvIHk7XHJcblx0XHRcdFx0XHR6ID0geXogLyB5O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2UgeyAvLyBtMzMgaXMgdGhlIGxhcmdlc3QgZGlhZ29uYWwgdGVybSBzbyBiYXNlIHJlc3VsdCBvbiB0aGlzXHJcblxyXG5cdFx0XHRcdGlmICggenogPCBlcHNpbG9uICkge1xyXG5cclxuXHRcdFx0XHRcdHggPSAwLjcwNzEwNjc4MTtcclxuXHRcdFx0XHRcdHkgPSAwLjcwNzEwNjc4MTtcclxuXHRcdFx0XHRcdHogPSAwO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHogPSBNYXRoLnNxcnQoIHp6ICk7XHJcblx0XHRcdFx0XHR4ID0geHogLyB6O1xyXG5cdFx0XHRcdFx0eSA9IHl6IC8gejtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5zZXQoIHgsIHksIHosIGFuZ2xlICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpczsgLy8gcmV0dXJuIDE4MCBkZWcgcm90YXRpb25cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYXMgd2UgaGF2ZSByZWFjaGVkIGhlcmUgdGhlcmUgYXJlIG5vIHNpbmd1bGFyaXRpZXMgc28gd2UgY2FuIGhhbmRsZSBub3JtYWxseVxyXG5cclxuXHRcdHZhciBzID0gTWF0aC5zcXJ0KCAoIG0zMiAtIG0yMyApICogKCBtMzIgLSBtMjMgKVxyXG5cdFx0XHRcdFx0XHQgKyAoIG0xMyAtIG0zMSApICogKCBtMTMgLSBtMzEgKVxyXG5cdFx0XHRcdFx0XHQgKyAoIG0yMSAtIG0xMiApICogKCBtMjEgLSBtMTIgKSApOyAvLyB1c2VkIHRvIG5vcm1hbGl6ZVxyXG5cclxuXHRcdGlmICggTWF0aC5hYnMoIHMgKSA8IDAuMDAxICkgcyA9IDE7XHJcblxyXG5cdFx0Ly8gcHJldmVudCBkaXZpZGUgYnkgemVybywgc2hvdWxkIG5vdCBoYXBwZW4gaWYgbWF0cml4IGlzIG9ydGhvZ29uYWwgYW5kIHNob3VsZCBiZVxyXG5cdFx0Ly8gY2F1Z2h0IGJ5IHNpbmd1bGFyaXR5IHRlc3QgYWJvdmUsIGJ1dCBJJ3ZlIGxlZnQgaXQgaW4ganVzdCBpbiBjYXNlXHJcblxyXG5cdFx0dGhpcy54ID0gKCBtMzIgLSBtMjMgKSAvIHM7XHJcblx0XHR0aGlzLnkgPSAoIG0xMyAtIG0zMSApIC8gcztcclxuXHRcdHRoaXMueiA9ICggbTIxIC0gbTEyICkgLyBzO1xyXG5cdFx0dGhpcy53ID0gTWF0aC5hY29zKCAoIG0xMSArIG0yMiArIG0zMyAtIDEgKSAvIDIgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bWluOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnggPiB2LnggKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSB2Lng7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy55ID4gdi55ICkge1xyXG5cclxuXHRcdFx0dGhpcy55ID0gdi55O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMueiA+IHYueiApIHtcclxuXHJcblx0XHRcdHRoaXMueiA9IHYuejtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLncgPiB2LncgKSB7XHJcblxyXG5cdFx0XHR0aGlzLncgPSB2Lnc7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYXg6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMueCA8IHYueCApIHtcclxuXHJcblx0XHRcdHRoaXMueCA9IHYueDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLnkgPCB2LnkgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnkgPSB2Lnk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy56IDwgdi56ICkge1xyXG5cclxuXHRcdFx0dGhpcy56ID0gdi56O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMudyA8IHYudyApIHtcclxuXHJcblx0XHRcdHRoaXMudyA9IHYudztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsYW1wOiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xyXG5cclxuXHRcdC8vIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyBtaW4gPCBtYXgsIGlmIHRoaXMgYXNzdW1wdGlvbiBpc24ndCB0cnVlIGl0IHdpbGwgbm90IG9wZXJhdGUgY29ycmVjdGx5XHJcblxyXG5cdFx0aWYgKCB0aGlzLnggPCBtaW4ueCApIHtcclxuXHJcblx0XHRcdHRoaXMueCA9IG1pbi54O1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHRoaXMueCA+IG1heC54ICkge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gbWF4Lng7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy55IDwgbWluLnkgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnkgPSBtaW4ueTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCB0aGlzLnkgPiBtYXgueSApIHtcclxuXHJcblx0XHRcdHRoaXMueSA9IG1heC55O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMueiA8IG1pbi56ICkge1xyXG5cclxuXHRcdFx0dGhpcy56ID0gbWluLno7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggdGhpcy56ID4gbWF4LnogKSB7XHJcblxyXG5cdFx0XHR0aGlzLnogPSBtYXguejtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLncgPCBtaW4udyApIHtcclxuXHJcblx0XHRcdHRoaXMudyA9IG1pbi53O1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHRoaXMudyA+IG1heC53ICkge1xyXG5cclxuXHRcdFx0dGhpcy53ID0gbWF4Lnc7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRuZWdhdGU6IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKCAtMSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkb3Q6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55ICsgdGhpcy56ICogdi56ICsgdGhpcy53ICogdi53O1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKyB0aGlzLncgKiB0aGlzLnc7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlbmd0aDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiArIHRoaXMudyAqIHRoaXMudyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZW5ndGhNYW5oYXR0YW46IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5hYnMoIHRoaXMueCApICsgTWF0aC5hYnMoIHRoaXMueSApICsgTWF0aC5hYnMoIHRoaXMueiApICsgTWF0aC5hYnMoIHRoaXMudyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIHRoaXMubGVuZ3RoKCkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0TGVuZ3RoOiBmdW5jdGlvbiAoIGwgKSB7XHJcblxyXG5cdFx0dmFyIG9sZExlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XHJcblxyXG5cdFx0aWYgKCBvbGRMZW5ndGggIT09IDAgJiYgbCAhPT0gb2xkTGVuZ3RoICkge1xyXG5cclxuXHRcdFx0dGhpcy5tdWx0aXBseVNjYWxhciggbCAvIG9sZExlbmd0aCApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZXJwOiBmdW5jdGlvbiAoIHYsIGFscGhhICkge1xyXG5cclxuXHRcdHRoaXMueCArPSAoIHYueCAtIHRoaXMueCApICogYWxwaGE7XHJcblx0XHR0aGlzLnkgKz0gKCB2LnkgLSB0aGlzLnkgKSAqIGFscGhhO1xyXG5cdFx0dGhpcy56ICs9ICggdi56IC0gdGhpcy56ICkgKiBhbHBoYTtcclxuXHRcdHRoaXMudyArPSAoIHYudyAtIHRoaXMudyApICogYWxwaGE7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGVxdWFsczogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHJldHVybiAoICggdi54ID09PSB0aGlzLnggKSAmJiAoIHYueSA9PT0gdGhpcy55ICkgJiYgKCB2LnogPT09IHRoaXMueiApICYmICggdi53ID09PSB0aGlzLncgKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0b0FycmF5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIFsgdGhpcy54LCB0aGlzLnksIHRoaXMueiwgdGhpcy53IF07XHJcblx0XHRcclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yNCggdGhpcy54LCB0aGlzLnksIHRoaXMueiwgdGhpcy53ICk7XHJcblxyXG5cdH1cclxuXHJcbn0gKTtcclxuLyoqXHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxyXG4gKi9cclxuXHJcblRIUkVFLkJveDIgPSBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xyXG5cclxuXHR0aGlzLm1pbiA9ICggbWluICE9PSB1bmRlZmluZWQgKSA/IG1pbiA6IG5ldyBUSFJFRS5WZWN0b3IyKCBJbmZpbml0eSwgSW5maW5pdHkgKTtcclxuXHR0aGlzLm1heCA9ICggbWF4ICE9PSB1bmRlZmluZWQgKSA/IG1heCA6IG5ldyBUSFJFRS5WZWN0b3IyKCAtSW5maW5pdHksIC1JbmZpbml0eSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLmV4dGVuZCggVEhSRUUuQm94Mi5wcm90b3R5cGUsIHtcclxuXHJcblx0c2V0OiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xyXG5cclxuXHRcdHRoaXMubWluLmNvcHkoIG1pbiApO1xyXG5cdFx0dGhpcy5tYXguY29weSggbWF4ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21Qb2ludHM6IGZ1bmN0aW9uICggcG9pbnRzICkge1xyXG5cclxuXHRcdGlmICggcG9pbnRzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHR2YXIgcG9pbnQgPSBwb2ludHNbIDAgXTtcclxuXHJcblx0XHRcdHRoaXMubWluLmNvcHkoIHBvaW50ICk7XHJcblx0XHRcdHRoaXMubWF4LmNvcHkoIHBvaW50ICk7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDEsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRwb2ludCA9IHBvaW50c1sgaSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIHBvaW50LnggPCB0aGlzLm1pbi54ICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMubWluLnggPSBwb2ludC54O1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBwb2ludC54ID4gdGhpcy5tYXgueCApIHtcclxuXHJcblx0XHRcdFx0XHR0aGlzLm1heC54ID0gcG9pbnQueDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIHBvaW50LnkgPCB0aGlzLm1pbi55ICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMubWluLnkgPSBwb2ludC55O1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBwb2ludC55ID4gdGhpcy5tYXgueSApIHtcclxuXHJcblx0XHRcdFx0XHR0aGlzLm1heC55ID0gcG9pbnQueTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLm1ha2VFbXB0eSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbUNlbnRlckFuZFNpemU6IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggY2VudGVyLCBzaXplICkge1xyXG5cclxuXHRcdFx0dmFyIGhhbGZTaXplID0gdjEuY29weSggc2l6ZSApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcclxuXHRcdFx0dGhpcy5taW4uY29weSggY2VudGVyICkuc3ViKCBoYWxmU2l6ZSApO1xyXG5cdFx0XHR0aGlzLm1heC5jb3B5KCBjZW50ZXIgKS5hZGQoIGhhbGZTaXplICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuXHRcdHRoaXMubWluLmNvcHkoIGJveC5taW4gKTtcclxuXHRcdHRoaXMubWF4LmNvcHkoIGJveC5tYXggKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bWFrZUVtcHR5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5taW4ueCA9IHRoaXMubWluLnkgPSBJbmZpbml0eTtcclxuXHRcdHRoaXMubWF4LnggPSB0aGlzLm1heC55ID0gLUluZmluaXR5O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRlbXB0eTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIHRoaXMgaXMgYSBtb3JlIHJvYnVzdCBjaGVjayBmb3IgZW1wdHkgdGhhbiAoIHZvbHVtZSA8PSAwICkgYmVjYXVzZSB2b2x1bWUgY2FuIGdldCBwb3NpdGl2ZSB3aXRoIHR3byBuZWdhdGl2ZSBheGVzXHJcblxyXG5cdFx0cmV0dXJuICggdGhpcy5tYXgueCA8IHRoaXMubWluLnggKSB8fCAoIHRoaXMubWF4LnkgPCB0aGlzLm1pbi55ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNlbnRlcjogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHRcdHJldHVybiByZXN1bHQuYWRkVmVjdG9ycyggdGhpcy5taW4sIHRoaXMubWF4ICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzaXplOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG5cdFx0cmV0dXJuIHJlc3VsdC5zdWJWZWN0b3JzKCB0aGlzLm1heCwgdGhpcy5taW4gKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZXhwYW5kQnlQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5taW4oIHBvaW50ICk7XHJcblx0XHR0aGlzLm1heC5tYXgoIHBvaW50ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0ZXhwYW5kQnlWZWN0b3I6IGZ1bmN0aW9uICggdmVjdG9yICkge1xyXG5cclxuXHRcdHRoaXMubWluLnN1YiggdmVjdG9yICk7XHJcblx0XHR0aGlzLm1heC5hZGQoIHZlY3RvciApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGV4cGFuZEJ5U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5hZGRTY2FsYXIoIC1zY2FsYXIgKTtcclxuXHRcdHRoaXMubWF4LmFkZFNjYWxhciggc2NhbGFyICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Y29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcblx0XHRpZiAoIHBvaW50LnggPCB0aGlzLm1pbi54IHx8IHBvaW50LnggPiB0aGlzLm1heC54IHx8XHJcblx0XHQgICAgIHBvaW50LnkgPCB0aGlzLm1pbi55IHx8IHBvaW50LnkgPiB0aGlzLm1heC55ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29udGFpbnNCb3g6IGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuXHRcdGlmICggKCB0aGlzLm1pbi54IDw9IGJveC5taW4ueCApICYmICggYm94Lm1heC54IDw9IHRoaXMubWF4LnggKSAmJlxyXG5cdFx0ICAgICAoIHRoaXMubWluLnkgPD0gYm94Lm1pbi55ICkgJiYgKCBib3gubWF4LnkgPD0gdGhpcy5tYXgueSApICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0UGFyYW1ldGVyOiBmdW5jdGlvbiAoIHBvaW50ICkge1xyXG5cclxuXHRcdC8vIFRoaXMgY2FuIHBvdGVudGlhbGx5IGhhdmUgYSBkaXZpZGUgYnkgemVybyBpZiB0aGUgYm94XHJcblx0XHQvLyBoYXMgYSBzaXplIGRpbWVuc2lvbiBvZiAwLlxyXG5cclxuXHRcdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMihcclxuXHRcdFx0KCBwb2ludC54IC0gdGhpcy5taW4ueCApIC8gKCB0aGlzLm1heC54IC0gdGhpcy5taW4ueCApLFxyXG5cdFx0XHQoIHBvaW50LnkgLSB0aGlzLm1pbi55ICkgLyAoIHRoaXMubWF4LnkgLSB0aGlzLm1pbi55IClcclxuXHRcdCk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGlzSW50ZXJzZWN0aW9uQm94OiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHQvLyB1c2luZyA2IHNwbGl0dGluZyBwbGFuZXMgdG8gcnVsZSBvdXQgaW50ZXJzZWN0aW9ucy5cclxuXHJcblx0XHRpZiAoIGJveC5tYXgueCA8IHRoaXMubWluLnggfHwgYm94Lm1pbi54ID4gdGhpcy5tYXgueCB8fFxyXG5cdFx0ICAgICBib3gubWF4LnkgPCB0aGlzLm1pbi55IHx8IGJveC5taW4ueSA+IHRoaXMubWF4LnkgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbGFtcFBvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHRcdHJldHVybiByZXN1bHQuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcblx0XHRcdHZhciBjbGFtcGVkUG9pbnQgPSB2MS5jb3B5KCBwb2ludCApLmNsYW1wKCB0aGlzLm1pbiwgdGhpcy5tYXggKTtcclxuXHRcdFx0cmV0dXJuIGNsYW1wZWRQb2ludC5zdWIoIHBvaW50ICkubGVuZ3RoKCk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRpbnRlcnNlY3Q6IGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuXHRcdHRoaXMubWluLm1heCggYm94Lm1pbiApO1xyXG5cdFx0dGhpcy5tYXgubWluKCBib3gubWF4ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHVuaW9uOiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5taW4oIGJveC5taW4gKTtcclxuXHRcdHRoaXMubWF4Lm1heCggYm94Lm1heCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0cmFuc2xhdGU6IGZ1bmN0aW9uICggb2Zmc2V0ICkge1xyXG5cclxuXHRcdHRoaXMubWluLmFkZCggb2Zmc2V0ICk7XHJcblx0XHR0aGlzLm1heC5hZGQoIG9mZnNldCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuXHRcdHJldHVybiBib3gubWluLmVxdWFscyggdGhpcy5taW4gKSAmJiBib3gubWF4LmVxdWFscyggdGhpcy5tYXggKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFRIUkVFLkJveDIoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdH1cclxuXHJcbn0gKTtcclxuLyoqXHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxyXG4gKi9cclxuXHJcblRIUkVFLkJveDMgPSBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xyXG5cclxuXHR0aGlzLm1pbiA9ICggbWluICE9PSB1bmRlZmluZWQgKSA/IG1pbiA6IG5ldyBUSFJFRS5WZWN0b3IzKCBJbmZpbml0eSwgSW5maW5pdHksIEluZmluaXR5ICk7XHJcblx0dGhpcy5tYXggPSAoIG1heCAhPT0gdW5kZWZpbmVkICkgPyBtYXggOiBuZXcgVEhSRUUuVmVjdG9yMyggLUluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLmV4dGVuZCggVEhSRUUuQm94My5wcm90b3R5cGUsIHtcclxuXHJcblx0c2V0OiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xyXG5cclxuXHRcdHRoaXMubWluLmNvcHkoIG1pbiApO1xyXG5cdFx0dGhpcy5tYXguY29weSggbWF4ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21Qb2ludHM6IGZ1bmN0aW9uICggcG9pbnRzICkge1xyXG5cclxuXHRcdGlmICggcG9pbnRzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHR2YXIgcG9pbnQgPSBwb2ludHNbIDAgXTtcclxuXHJcblx0XHRcdHRoaXMubWluLmNvcHkoIHBvaW50ICk7XHJcblx0XHRcdHRoaXMubWF4LmNvcHkoIHBvaW50ICk7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDEsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRwb2ludCA9IHBvaW50c1sgaSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIHBvaW50LnggPCB0aGlzLm1pbi54ICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMubWluLnggPSBwb2ludC54O1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBwb2ludC54ID4gdGhpcy5tYXgueCApIHtcclxuXHJcblx0XHRcdFx0XHR0aGlzLm1heC54ID0gcG9pbnQueDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIHBvaW50LnkgPCB0aGlzLm1pbi55ICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMubWluLnkgPSBwb2ludC55O1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBwb2ludC55ID4gdGhpcy5tYXgueSApIHtcclxuXHJcblx0XHRcdFx0XHR0aGlzLm1heC55ID0gcG9pbnQueTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIHBvaW50LnogPCB0aGlzLm1pbi56ICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMubWluLnogPSBwb2ludC56O1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBwb2ludC56ID4gdGhpcy5tYXgueiApIHtcclxuXHJcblx0XHRcdFx0XHR0aGlzLm1heC56ID0gcG9pbnQuejtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLm1ha2VFbXB0eSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbUNlbnRlckFuZFNpemU6IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggY2VudGVyLCBzaXplICkge1xyXG5cclxuXHRcdFx0dmFyIGhhbGZTaXplID0gdjEuY29weSggc2l6ZSApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcclxuXHJcblx0XHRcdHRoaXMubWluLmNvcHkoIGNlbnRlciApLnN1YiggaGFsZlNpemUgKTtcclxuXHRcdFx0dGhpcy5tYXguY29weSggY2VudGVyICkuYWRkKCBoYWxmU2l6ZSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5jb3B5KCBib3gubWluICk7XHJcblx0XHR0aGlzLm1heC5jb3B5KCBib3gubWF4ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1ha2VFbXB0eTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMubWluLnggPSB0aGlzLm1pbi55ID0gdGhpcy5taW4ueiA9IEluZmluaXR5O1xyXG5cdFx0dGhpcy5tYXgueCA9IHRoaXMubWF4LnkgPSB0aGlzLm1heC56ID0gLUluZmluaXR5O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRlbXB0eTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIHRoaXMgaXMgYSBtb3JlIHJvYnVzdCBjaGVjayBmb3IgZW1wdHkgdGhhbiAoIHZvbHVtZSA8PSAwICkgYmVjYXVzZSB2b2x1bWUgY2FuIGdldCBwb3NpdGl2ZSB3aXRoIHR3byBuZWdhdGl2ZSBheGVzXHJcblxyXG5cdFx0cmV0dXJuICggdGhpcy5tYXgueCA8IHRoaXMubWluLnggKSB8fCAoIHRoaXMubWF4LnkgPCB0aGlzLm1pbi55ICkgfHwgKCB0aGlzLm1heC56IDwgdGhpcy5taW4ueiApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjZW50ZXI6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRyZXR1cm4gcmVzdWx0LmFkZFZlY3RvcnMoIHRoaXMubWluLCB0aGlzLm1heCApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcclxuXHJcblx0fSxcclxuXHJcblx0c2l6ZTogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHJldHVybiByZXN1bHQuc3ViVmVjdG9ycyggdGhpcy5tYXgsIHRoaXMubWluICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGV4cGFuZEJ5UG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG5cdFx0dGhpcy5taW4ubWluKCBwb2ludCApO1xyXG5cdFx0dGhpcy5tYXgubWF4KCBwb2ludCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRleHBhbmRCeVZlY3RvcjogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0dGhpcy5taW4uc3ViKCB2ZWN0b3IgKTtcclxuXHRcdHRoaXMubWF4LmFkZCggdmVjdG9yICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGV4cGFuZEJ5U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5hZGRTY2FsYXIoIC1zY2FsYXIgKTtcclxuXHRcdHRoaXMubWF4LmFkZFNjYWxhciggc2NhbGFyICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG5cdFx0aWYgKCBwb2ludC54IDwgdGhpcy5taW4ueCB8fCBwb2ludC54ID4gdGhpcy5tYXgueCB8fFxyXG5cdFx0ICAgICBwb2ludC55IDwgdGhpcy5taW4ueSB8fCBwb2ludC55ID4gdGhpcy5tYXgueSB8fFxyXG5cdFx0ICAgICBwb2ludC56IDwgdGhpcy5taW4ueiB8fCBwb2ludC56ID4gdGhpcy5tYXgueiApIHtcclxuXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbnRhaW5zQm94OiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHRpZiAoICggdGhpcy5taW4ueCA8PSBib3gubWluLnggKSAmJiAoIGJveC5tYXgueCA8PSB0aGlzLm1heC54ICkgJiZcclxuXHRcdFx0ICggdGhpcy5taW4ueSA8PSBib3gubWluLnkgKSAmJiAoIGJveC5tYXgueSA8PSB0aGlzLm1heC55ICkgJiZcclxuXHRcdFx0ICggdGhpcy5taW4ueiA8PSBib3gubWluLnogKSAmJiAoIGJveC5tYXgueiA8PSB0aGlzLm1heC56ICkgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRQYXJhbWV0ZXI6IGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG5cdFx0Ly8gVGhpcyBjYW4gcG90ZW50aWFsbHkgaGF2ZSBhIGRpdmlkZSBieSB6ZXJvIGlmIHRoZSBib3hcclxuXHRcdC8vIGhhcyBhIHNpemUgZGltZW5zaW9uIG9mIDAuXHJcblxyXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKFxyXG5cdFx0XHQoIHBvaW50LnggLSB0aGlzLm1pbi54ICkgLyAoIHRoaXMubWF4LnggLSB0aGlzLm1pbi54ICksXHJcblx0XHRcdCggcG9pbnQueSAtIHRoaXMubWluLnkgKSAvICggdGhpcy5tYXgueSAtIHRoaXMubWluLnkgKSxcclxuXHRcdFx0KCBwb2ludC56IC0gdGhpcy5taW4ueiApIC8gKCB0aGlzLm1heC56IC0gdGhpcy5taW4ueiApXHJcblx0XHQpO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpc0ludGVyc2VjdGlvbkJveDogZnVuY3Rpb24gKCBib3ggKSB7XHJcblxyXG5cdFx0Ly8gdXNpbmcgNiBzcGxpdHRpbmcgcGxhbmVzIHRvIHJ1bGUgb3V0IGludGVyc2VjdGlvbnMuXHJcblxyXG5cdFx0aWYgKCBib3gubWF4LnggPCB0aGlzLm1pbi54IHx8IGJveC5taW4ueCA+IHRoaXMubWF4LnggfHxcclxuXHRcdCAgICAgYm94Lm1heC55IDwgdGhpcy5taW4ueSB8fCBib3gubWluLnkgPiB0aGlzLm1heC55IHx8XHJcblx0XHQgICAgIGJveC5tYXgueiA8IHRoaXMubWluLnogfHwgYm94Lm1pbi56ID4gdGhpcy5tYXgueiApIHtcclxuXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsYW1wUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCBwb2ludCApLmNsYW1wKCB0aGlzLm1pbiwgdGhpcy5tYXggKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHBvaW50ICkge1xyXG5cclxuXHRcdFx0dmFyIGNsYW1wZWRQb2ludCA9IHYxLmNvcHkoIHBvaW50ICkuY2xhbXAoIHRoaXMubWluLCB0aGlzLm1heCApO1xyXG5cdFx0XHRyZXR1cm4gY2xhbXBlZFBvaW50LnN1YiggcG9pbnQgKS5sZW5ndGgoKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGdldEJvdW5kaW5nU3BoZXJlOiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5TcGhlcmUoKTtcclxuXHJcblx0XHRcdHJlc3VsdC5jZW50ZXIgPSB0aGlzLmNlbnRlcigpO1xyXG5cdFx0XHRyZXN1bHQucmFkaXVzID0gdGhpcy5zaXplKCB2MSApLmxlbmd0aCgpICogMC41O1xyXG5cclxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGludGVyc2VjdDogZnVuY3Rpb24gKCBib3ggKSB7XHJcblxyXG5cdFx0dGhpcy5taW4ubWF4KCBib3gubWluICk7XHJcblx0XHR0aGlzLm1heC5taW4oIGJveC5tYXggKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0dW5pb246IGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuXHRcdHRoaXMubWluLm1pbiggYm94Lm1pbiApO1xyXG5cdFx0dGhpcy5tYXgubWF4KCBib3gubWF4ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0dmFyIHBvaW50cyA9IFtcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKVxyXG5cdFx0XHRdO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcclxuXHJcblx0XHRcdC8vIE5PVEU6IEkgYW0gdXNpbmcgYSBiaW5hcnkgcGF0dGVybiB0byBzcGVjaWZ5IGFsbCAyXjMgY29tYmluYXRpb25zIGJlbG93XHJcblx0XHRcdHBvaW50c1swXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWluLnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMDBcclxuXHRcdFx0cG9pbnRzWzFdLnNldCggdGhpcy5taW4ueCwgdGhpcy5taW4ueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAwMVxyXG5cdFx0XHRwb2ludHNbMl0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1heC55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDEwXHJcblx0XHRcdHBvaW50c1szXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWF4LnksIHRoaXMubWF4LnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMTFcclxuXHRcdFx0cG9pbnRzWzRdLnNldCggdGhpcy5tYXgueCwgdGhpcy5taW4ueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDEwMFxyXG5cdFx0XHRwb2ludHNbNV0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1pbi55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMTAxXHJcblx0XHRcdHBvaW50c1s2XS5zZXQoIHRoaXMubWF4LngsIHRoaXMubWF4LnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAxMTBcclxuXHRcdFx0cG9pbnRzWzddLnNldCggdGhpcy5tYXgueCwgdGhpcy5tYXgueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7ICAvLyAxMTFcclxuXHJcblx0XHRcdHRoaXMubWFrZUVtcHR5KCk7XHJcblx0XHRcdHRoaXMuc2V0RnJvbVBvaW50cyggcG9pbnRzICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0dGhpcy5taW4uYWRkKCBvZmZzZXQgKTtcclxuXHRcdHRoaXMubWF4LmFkZCggb2Zmc2V0ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGVxdWFsczogZnVuY3Rpb24gKCBib3ggKSB7XHJcblxyXG5cdFx0cmV0dXJuIGJveC5taW4uZXF1YWxzKCB0aGlzLm1pbiApICYmIGJveC5tYXguZXF1YWxzKCB0aGlzLm1heCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgVEhSRUUuQm94MygpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0fVxyXG5cclxufSApO1xyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxyXG4gKi9cclxuXHJcblRIUkVFLk1hdHJpeDMgPSBmdW5jdGlvbiAoIG4xMSwgbjEyLCBuMTMsIG4yMSwgbjIyLCBuMjMsIG4zMSwgbjMyLCBuMzMgKSB7XHJcblxyXG5cdHRoaXMuZWxlbWVudHMgPSBuZXcgRmxvYXQzMkFycmF5KDkpO1xyXG5cclxuXHR0aGlzLnNldChcclxuXHJcblx0XHQoIG4xMSAhPT0gdW5kZWZpbmVkICkgPyBuMTEgOiAxLCBuMTIgfHwgMCwgbjEzIHx8IDAsXHJcblx0XHRuMjEgfHwgMCwgKCBuMjIgIT09IHVuZGVmaW5lZCApID8gbjIyIDogMSwgbjIzIHx8IDAsXHJcblx0XHRuMzEgfHwgMCwgbjMyIHx8IDAsICggbjMzICE9PSB1bmRlZmluZWQgKSA/IG4zMyA6IDFcclxuXHJcblx0KTtcclxufTtcclxuXHJcblRIUkVFLmV4dGVuZCggVEhSRUUuTWF0cml4My5wcm90b3R5cGUsIHtcclxuXHJcblx0c2V0OiBmdW5jdGlvbiAoIG4xMSwgbjEyLCBuMTMsIG4yMSwgbjIyLCBuMjMsIG4zMSwgbjMyLCBuMzMgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR0ZVswXSA9IG4xMTsgdGVbM10gPSBuMTI7IHRlWzZdID0gbjEzO1xyXG5cdFx0dGVbMV0gPSBuMjE7IHRlWzRdID0gbjIyOyB0ZVs3XSA9IG4yMztcclxuXHRcdHRlWzJdID0gbjMxOyB0ZVs1XSA9IG4zMjsgdGVbOF0gPSBuMzM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGlkZW50aXR5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5zZXQoXHJcblxyXG5cdFx0XHQxLCAwLCAwLFxyXG5cdFx0XHQwLCAxLCAwLFxyXG5cdFx0XHQwLCAwLCAxXHJcblxyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdHZhciBtZSA9IG0uZWxlbWVudHM7XHJcblxyXG5cdFx0dGhpcy5zZXQoXHJcblxyXG5cdFx0XHRtZVswXSwgbWVbM10sIG1lWzZdLFxyXG5cdFx0XHRtZVsxXSwgbWVbNF0sIG1lWzddLFxyXG5cdFx0XHRtZVsyXSwgbWVbNV0sIG1lWzhdXHJcblxyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHlWZWN0b3IzOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdERVBSRUNBVEVEOiBNYXRyaXgzXFwncyAubXVsdGlwbHlWZWN0b3IzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDMoIG1hdHJpeCApIGluc3RlYWQuJyApO1xyXG5cdFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDMoIHRoaXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHlWZWN0b3IzQXJyYXk6IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYSApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBhLmxlbmd0aDsgaSA8IGlsOyBpICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdHYxLnggPSBhWyBpIF07XHJcblx0XHRcdFx0djEueSA9IGFbIGkgKyAxIF07XHJcblx0XHRcdFx0djEueiA9IGFbIGkgKyAyIF07XHJcblxyXG5cdFx0XHRcdHYxLmFwcGx5TWF0cml4Myh0aGlzKTtcclxuXHJcblx0XHRcdFx0YVsgaSBdICAgICA9IHYxLng7XHJcblx0XHRcdFx0YVsgaSArIDEgXSA9IHYxLnk7XHJcblx0XHRcdFx0YVsgaSArIDIgXSA9IHYxLno7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gYTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR0ZVswXSAqPSBzOyB0ZVszXSAqPSBzOyB0ZVs2XSAqPSBzO1xyXG5cdFx0dGVbMV0gKj0gczsgdGVbNF0gKj0gczsgdGVbN10gKj0gcztcclxuXHRcdHRlWzJdICo9IHM7IHRlWzVdICo9IHM7IHRlWzhdICo9IHM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRldGVybWluYW50OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR2YXIgYSA9IHRlWzBdLCBiID0gdGVbMV0sIGMgPSB0ZVsyXSxcclxuXHRcdFx0ZCA9IHRlWzNdLCBlID0gdGVbNF0sIGYgPSB0ZVs1XSxcclxuXHRcdFx0ZyA9IHRlWzZdLCBoID0gdGVbN10sIGkgPSB0ZVs4XTtcclxuXHJcblx0XHRyZXR1cm4gYSplKmkgLSBhKmYqaCAtIGIqZCppICsgYipmKmcgKyBjKmQqaCAtIGMqZSpnO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRJbnZlcnNlOiBmdW5jdGlvbiAoIG1hdHJpeCwgdGhyb3dPbkludmVydGlibGUgKSB7XHJcblxyXG5cdFx0Ly8gaW5wdXQ6IFRIUkVFLk1hdHJpeDRcclxuXHRcdC8vICggYmFzZWQgb24gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3dlYmdsLW1qcy8gKVxyXG5cclxuXHRcdHZhciBtZSA9IG1hdHJpeC5lbGVtZW50cztcclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0dGVbIDAgXSA9ICAgbWVbMTBdICogbWVbNV0gLSBtZVs2XSAqIG1lWzldO1xyXG5cdFx0dGVbIDEgXSA9IC0gbWVbMTBdICogbWVbMV0gKyBtZVsyXSAqIG1lWzldO1xyXG5cdFx0dGVbIDIgXSA9ICAgbWVbNl0gKiBtZVsxXSAtIG1lWzJdICogbWVbNV07XHJcblx0XHR0ZVsgMyBdID0gLSBtZVsxMF0gKiBtZVs0XSArIG1lWzZdICogbWVbOF07XHJcblx0XHR0ZVsgNCBdID0gICBtZVsxMF0gKiBtZVswXSAtIG1lWzJdICogbWVbOF07XHJcblx0XHR0ZVsgNSBdID0gLSBtZVs2XSAqIG1lWzBdICsgbWVbMl0gKiBtZVs0XTtcclxuXHRcdHRlWyA2IF0gPSAgIG1lWzldICogbWVbNF0gLSBtZVs1XSAqIG1lWzhdO1xyXG5cdFx0dGVbIDcgXSA9IC0gbWVbOV0gKiBtZVswXSArIG1lWzFdICogbWVbOF07XHJcblx0XHR0ZVsgOCBdID0gICBtZVs1XSAqIG1lWzBdIC0gbWVbMV0gKiBtZVs0XTtcclxuXHJcblx0XHR2YXIgZGV0ID0gbWVbIDAgXSAqIHRlWyAwIF0gKyBtZVsgMSBdICogdGVbIDMgXSArIG1lWyAyIF0gKiB0ZVsgNiBdO1xyXG5cclxuXHRcdC8vIG5vIGludmVyc2VcclxuXHJcblx0XHRpZiAoIGRldCA9PT0gMCApIHtcclxuXHJcblx0XHRcdHZhciBtc2cgPSBcIk1hdHJpeDMuZ2V0SW52ZXJzZSgpOiBjYW4ndCBpbnZlcnQgbWF0cml4LCBkZXRlcm1pbmFudCBpcyAwXCI7XHJcblxyXG5cdFx0XHRpZiAoIHRocm93T25JbnZlcnRpYmxlIHx8IGZhbHNlICkge1xyXG5cclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApOyBcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggbXNnICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmlkZW50aXR5KCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5tdWx0aXBseVNjYWxhciggMS4wIC8gZGV0ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRyYW5zcG9zZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB0bXAsIG0gPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRtcCA9IG1bMV07IG1bMV0gPSBtWzNdOyBtWzNdID0gdG1wO1xyXG5cdFx0dG1wID0gbVsyXTsgbVsyXSA9IG1bNl07IG1bNl0gPSB0bXA7XHJcblx0XHR0bXAgPSBtWzVdOyBtWzVdID0gbVs3XTsgbVs3XSA9IHRtcDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0Tm9ybWFsTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0Ly8gaW5wdXQ6IFRIUkVFLk1hdHJpeDRcclxuXHJcblx0XHR0aGlzLmdldEludmVyc2UoIG0gKS50cmFuc3Bvc2UoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0dHJhbnNwb3NlSW50b0FycmF5OiBmdW5jdGlvbiAoIHIgKSB7XHJcblxyXG5cdFx0dmFyIG0gPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHJbIDAgXSA9IG1bIDAgXTtcclxuXHRcdHJbIDEgXSA9IG1bIDMgXTtcclxuXHRcdHJbIDIgXSA9IG1bIDYgXTtcclxuXHRcdHJbIDMgXSA9IG1bIDEgXTtcclxuXHRcdHJbIDQgXSA9IG1bIDQgXTtcclxuXHRcdHJbIDUgXSA9IG1bIDcgXTtcclxuXHRcdHJbIDYgXSA9IG1bIDIgXTtcclxuXHRcdHJbIDcgXSA9IG1bIDUgXTtcclxuXHRcdHJbIDggXSA9IG1bIDggXTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHJldHVybiBuZXcgVEhSRUUuTWF0cml4MyhcclxuXHJcblx0XHRcdHRlWzBdLCB0ZVszXSwgdGVbNl0sXHJcblx0XHRcdHRlWzFdLCB0ZVs0XSwgdGVbN10sXHJcblx0XHRcdHRlWzJdLCB0ZVs1XSwgdGVbOF1cclxuXHJcblx0XHQpO1xyXG5cclxuXHR9XHJcblxyXG59ICk7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIHN1cGVyZWdnYmVydCAvIGh0dHA6Ly93d3cucGF1bGJydW50LmNvLnVrL1xyXG4gKiBAYXV0aG9yIHBoaWxvZ2IgLyBodHRwOi8vYmxvZy50aGVqaXQub3JnL1xyXG4gKiBAYXV0aG9yIGpvcmRpX3JvcyAvIGh0dHA6Ly9wbGF0dHNvZnQuY29tXHJcbiAqIEBhdXRob3IgRDFwbG8xZCAvIGh0dHA6Ly9naXRodWIuY29tL0QxcGxvMWRcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICogQGF1dGhvciB0aW1rbmlwIC8gaHR0cDovL3d3dy5mbG9vcnBsYW5uZXIuY29tL1xyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb21cclxuICovXHJcblxyXG5cclxuVEhSRUUuTWF0cml4NCA9IGZ1bmN0aW9uICggbjExLCBuMTIsIG4xMywgbjE0LCBuMjEsIG4yMiwgbjIzLCBuMjQsIG4zMSwgbjMyLCBuMzMsIG4zNCwgbjQxLCBuNDIsIG40MywgbjQ0ICkge1xyXG5cclxuXHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzID0gbmV3IEZsb2F0MzJBcnJheSggMTYgKTtcclxuXHJcblx0Ly8gVE9ETzogaWYgbjExIGlzIHVuZGVmaW5lZCwgdGhlbiBqdXN0IHNldCB0byBpZGVudGl0eSwgb3RoZXJ3aXNlIGNvcHkgYWxsIG90aGVyIHZhbHVlcyBpbnRvIG1hdHJpeFxyXG5cdC8vICAgd2Ugc2hvdWxkIG5vdCBzdXBwb3J0IHNlbWkgc3BlY2lmaWNhdGlvbiBvZiBNYXRyaXg0LCBpdCBpcyBqdXN0IHdlaXJkLlxyXG5cclxuXHR0ZVswXSA9ICggbjExICE9PSB1bmRlZmluZWQgKSA/IG4xMSA6IDE7IHRlWzRdID0gbjEyIHx8IDA7IHRlWzhdID0gbjEzIHx8IDA7IHRlWzEyXSA9IG4xNCB8fCAwO1xyXG5cdHRlWzFdID0gbjIxIHx8IDA7IHRlWzVdID0gKCBuMjIgIT09IHVuZGVmaW5lZCApID8gbjIyIDogMTsgdGVbOV0gPSBuMjMgfHwgMDsgdGVbMTNdID0gbjI0IHx8IDA7XHJcblx0dGVbMl0gPSBuMzEgfHwgMDsgdGVbNl0gPSBuMzIgfHwgMDsgdGVbMTBdID0gKCBuMzMgIT09IHVuZGVmaW5lZCApID8gbjMzIDogMTsgdGVbMTRdID0gbjM0IHx8IDA7XHJcblx0dGVbM10gPSBuNDEgfHwgMDsgdGVbN10gPSBuNDIgfHwgMDsgdGVbMTFdID0gbjQzIHx8IDA7IHRlWzE1XSA9ICggbjQ0ICE9PSB1bmRlZmluZWQgKSA/IG40NCA6IDE7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuZXh0ZW5kKCBUSFJFRS5NYXRyaXg0LnByb3RvdHlwZSwge1xyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggbjExLCBuMTIsIG4xMywgbjE0LCBuMjEsIG4yMiwgbjIzLCBuMjQsIG4zMSwgbjMyLCBuMzMsIG4zNCwgbjQxLCBuNDIsIG40MywgbjQ0ICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0dGVbMF0gPSBuMTE7IHRlWzRdID0gbjEyOyB0ZVs4XSA9IG4xMzsgdGVbMTJdID0gbjE0O1xyXG5cdFx0dGVbMV0gPSBuMjE7IHRlWzVdID0gbjIyOyB0ZVs5XSA9IG4yMzsgdGVbMTNdID0gbjI0O1xyXG5cdFx0dGVbMl0gPSBuMzE7IHRlWzZdID0gbjMyOyB0ZVsxMF0gPSBuMzM7IHRlWzE0XSA9IG4zNDtcclxuXHRcdHRlWzNdID0gbjQxOyB0ZVs3XSA9IG40MjsgdGVbMTFdID0gbjQzOyB0ZVsxNV0gPSBuNDQ7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGlkZW50aXR5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5zZXQoXHJcblxyXG5cdFx0XHQxLCAwLCAwLCAwLFxyXG5cdFx0XHQwLCAxLCAwLCAwLFxyXG5cdFx0XHQwLCAwLCAxLCAwLFxyXG5cdFx0XHQwLCAwLCAwLCAxXHJcblxyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdHZhciBtZSA9IG0uZWxlbWVudHM7XHJcblxyXG5cdFx0dGhpcy5zZXQoXHJcblxyXG5cdFx0XHRtZVswXSwgbWVbNF0sIG1lWzhdLCBtZVsxMl0sXHJcblx0XHRcdG1lWzFdLCBtZVs1XSwgbWVbOV0sIG1lWzEzXSxcclxuXHRcdFx0bWVbMl0sIG1lWzZdLCBtZVsxMF0sIG1lWzE0XSxcclxuXHRcdFx0bWVbM10sIG1lWzddLCBtZVsxMV0sIG1lWzE1XVxyXG5cclxuXHRcdCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFJvdGF0aW9uRnJvbUV1bGVyOiBmdW5jdGlvbiAoIHYsIG9yZGVyICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0dmFyIHggPSB2LngsIHkgPSB2LnksIHogPSB2Lno7XHJcblx0XHR2YXIgYSA9IE1hdGguY29zKCB4ICksIGIgPSBNYXRoLnNpbiggeCApO1xyXG5cdFx0dmFyIGMgPSBNYXRoLmNvcyggeSApLCBkID0gTWF0aC5zaW4oIHkgKTtcclxuXHRcdHZhciBlID0gTWF0aC5jb3MoIHogKSwgZiA9IE1hdGguc2luKCB6ICk7XHJcblxyXG5cdFx0aWYgKCBvcmRlciA9PT0gdW5kZWZpbmVkIHx8IG9yZGVyID09PSAnWFlaJyApIHtcclxuXHJcblx0XHRcdHZhciBhZSA9IGEgKiBlLCBhZiA9IGEgKiBmLCBiZSA9IGIgKiBlLCBiZiA9IGIgKiBmO1xyXG5cclxuXHRcdFx0dGVbMF0gPSBjICogZTtcclxuXHRcdFx0dGVbNF0gPSAtIGMgKiBmO1xyXG5cdFx0XHR0ZVs4XSA9IGQ7XHJcblxyXG5cdFx0XHR0ZVsxXSA9IGFmICsgYmUgKiBkO1xyXG5cdFx0XHR0ZVs1XSA9IGFlIC0gYmYgKiBkO1xyXG5cdFx0XHR0ZVs5XSA9IC0gYiAqIGM7XHJcblxyXG5cdFx0XHR0ZVsyXSA9IGJmIC0gYWUgKiBkO1xyXG5cdFx0XHR0ZVs2XSA9IGJlICsgYWYgKiBkO1xyXG5cdFx0XHR0ZVsxMF0gPSBhICogYztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1lYWicgKSB7XHJcblxyXG5cdFx0XHR2YXIgY2UgPSBjICogZSwgY2YgPSBjICogZiwgZGUgPSBkICogZSwgZGYgPSBkICogZjtcclxuXHJcblx0XHRcdHRlWzBdID0gY2UgKyBkZiAqIGI7XHJcblx0XHRcdHRlWzRdID0gZGUgKiBiIC0gY2Y7XHJcblx0XHRcdHRlWzhdID0gYSAqIGQ7XHJcblxyXG5cdFx0XHR0ZVsxXSA9IGEgKiBmO1xyXG5cdFx0XHR0ZVs1XSA9IGEgKiBlO1xyXG5cdFx0XHR0ZVs5XSA9IC0gYjtcclxuXHJcblx0XHRcdHRlWzJdID0gY2YgKiBiIC0gZGU7XHJcblx0XHRcdHRlWzZdID0gZGYgKyBjZSAqIGI7XHJcblx0XHRcdHRlWzEwXSA9IGEgKiBjO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWlhZJyApIHtcclxuXHJcblx0XHRcdHZhciBjZSA9IGMgKiBlLCBjZiA9IGMgKiBmLCBkZSA9IGQgKiBlLCBkZiA9IGQgKiBmO1xyXG5cclxuXHRcdFx0dGVbMF0gPSBjZSAtIGRmICogYjtcclxuXHRcdFx0dGVbNF0gPSAtIGEgKiBmO1xyXG5cdFx0XHR0ZVs4XSA9IGRlICsgY2YgKiBiO1xyXG5cclxuXHRcdFx0dGVbMV0gPSBjZiArIGRlICogYjtcclxuXHRcdFx0dGVbNV0gPSBhICogZTtcclxuXHRcdFx0dGVbOV0gPSBkZiAtIGNlICogYjtcclxuXHJcblx0XHRcdHRlWzJdID0gLSBhICogZDtcclxuXHRcdFx0dGVbNl0gPSBiO1xyXG5cdFx0XHR0ZVsxMF0gPSBhICogYztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pZWCcgKSB7XHJcblxyXG5cdFx0XHR2YXIgYWUgPSBhICogZSwgYWYgPSBhICogZiwgYmUgPSBiICogZSwgYmYgPSBiICogZjtcclxuXHJcblx0XHRcdHRlWzBdID0gYyAqIGU7XHJcblx0XHRcdHRlWzRdID0gYmUgKiBkIC0gYWY7XHJcblx0XHRcdHRlWzhdID0gYWUgKiBkICsgYmY7XHJcblxyXG5cdFx0XHR0ZVsxXSA9IGMgKiBmO1xyXG5cdFx0XHR0ZVs1XSA9IGJmICogZCArIGFlO1xyXG5cdFx0XHR0ZVs5XSA9IGFmICogZCAtIGJlO1xyXG5cclxuXHRcdFx0dGVbMl0gPSAtIGQ7XHJcblx0XHRcdHRlWzZdID0gYiAqIGM7XHJcblx0XHRcdHRlWzEwXSA9IGEgKiBjO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWVpYJyApIHtcclxuXHJcblx0XHRcdHZhciBhYyA9IGEgKiBjLCBhZCA9IGEgKiBkLCBiYyA9IGIgKiBjLCBiZCA9IGIgKiBkO1xyXG5cclxuXHRcdFx0dGVbMF0gPSBjICogZTtcclxuXHRcdFx0dGVbNF0gPSBiZCAtIGFjICogZjtcclxuXHRcdFx0dGVbOF0gPSBiYyAqIGYgKyBhZDtcclxuXHJcblx0XHRcdHRlWzFdID0gZjtcclxuXHRcdFx0dGVbNV0gPSBhICogZTtcclxuXHRcdFx0dGVbOV0gPSAtIGIgKiBlO1xyXG5cclxuXHRcdFx0dGVbMl0gPSAtIGQgKiBlO1xyXG5cdFx0XHR0ZVs2XSA9IGFkICogZiArIGJjO1xyXG5cdFx0XHR0ZVsxMF0gPSBhYyAtIGJkICogZjtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1haWScgKSB7XHJcblxyXG5cdFx0XHR2YXIgYWMgPSBhICogYywgYWQgPSBhICogZCwgYmMgPSBiICogYywgYmQgPSBiICogZDtcclxuXHJcblx0XHRcdHRlWzBdID0gYyAqIGU7XHJcblx0XHRcdHRlWzRdID0gLSBmO1xyXG5cdFx0XHR0ZVs4XSA9IGQgKiBlO1xyXG5cclxuXHRcdFx0dGVbMV0gPSBhYyAqIGYgKyBiZDtcclxuXHRcdFx0dGVbNV0gPSBhICogZTtcclxuXHRcdFx0dGVbOV0gPSBhZCAqIGYgLSBiYztcclxuXHJcblx0XHRcdHRlWzJdID0gYmMgKiBmIC0gYWQ7XHJcblx0XHRcdHRlWzZdID0gYiAqIGU7XHJcblx0XHRcdHRlWzEwXSA9IGJkICogZiArIGFjO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCBxICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0dmFyIHggPSBxLngsIHkgPSBxLnksIHogPSBxLnosIHcgPSBxLnc7XHJcblx0XHR2YXIgeDIgPSB4ICsgeCwgeTIgPSB5ICsgeSwgejIgPSB6ICsgejtcclxuXHRcdHZhciB4eCA9IHggKiB4MiwgeHkgPSB4ICogeTIsIHh6ID0geCAqIHoyO1xyXG5cdFx0dmFyIHl5ID0geSAqIHkyLCB5eiA9IHkgKiB6MiwgenogPSB6ICogejI7XHJcblx0XHR2YXIgd3ggPSB3ICogeDIsIHd5ID0gdyAqIHkyLCB3eiA9IHcgKiB6MjtcclxuXHJcblx0XHR0ZVswXSA9IDEgLSAoIHl5ICsgenogKTtcclxuXHRcdHRlWzRdID0geHkgLSB3ejtcclxuXHRcdHRlWzhdID0geHogKyB3eTtcclxuXHJcblx0XHR0ZVsxXSA9IHh5ICsgd3o7XHJcblx0XHR0ZVs1XSA9IDEgLSAoIHh4ICsgenogKTtcclxuXHRcdHRlWzldID0geXogLSB3eDtcclxuXHJcblx0XHR0ZVsyXSA9IHh6IC0gd3k7XHJcblx0XHR0ZVs2XSA9IHl6ICsgd3g7XHJcblx0XHR0ZVsxMF0gPSAxIC0gKCB4eCArIHl5ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxvb2tBdDogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0dmFyIHggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0dmFyIHkgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0dmFyIHogPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGV5ZSwgdGFyZ2V0LCB1cCApIHtcclxuXHJcblx0XHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0XHR6LnN1YlZlY3RvcnMoIGV5ZSwgdGFyZ2V0ICkubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHRpZiAoIHoubGVuZ3RoKCkgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdHoueiA9IDE7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR4LmNyb3NzVmVjdG9ycyggdXAsIHogKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdGlmICggeC5sZW5ndGgoKSA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0ei54ICs9IDAuMDAwMTtcclxuXHRcdFx0XHR4LmNyb3NzVmVjdG9ycyggdXAsIHogKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHkuY3Jvc3NWZWN0b3JzKCB6LCB4ICk7XHJcblxyXG5cclxuXHRcdFx0dGVbMF0gPSB4Lng7IHRlWzRdID0geS54OyB0ZVs4XSA9IHoueDtcclxuXHRcdFx0dGVbMV0gPSB4Lnk7IHRlWzVdID0geS55OyB0ZVs5XSA9IHoueTtcclxuXHRcdFx0dGVbMl0gPSB4Lno7IHRlWzZdID0geS56OyB0ZVsxMF0gPSB6Lno7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdG11bHRpcGx5OiBmdW5jdGlvbiAoIG0sIG4gKSB7XHJcblxyXG5cdFx0aWYgKCBuICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdERVBSRUNBVEVEOiBNYXRyaXg0XFwncyAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseU1hdHJpY2VzKCBhLCBiICkgaW5zdGVhZC4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoIG0sIG4gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggdGhpcywgbSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtdWx0aXBseU1hdHJpY2VzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XHJcblxyXG5cdFx0dmFyIGFlID0gYS5lbGVtZW50cztcclxuXHRcdHZhciBiZSA9IGIuZWxlbWVudHM7XHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHZhciBhMTEgPSBhZVswXSwgYTEyID0gYWVbNF0sIGExMyA9IGFlWzhdLCBhMTQgPSBhZVsxMl07XHJcblx0XHR2YXIgYTIxID0gYWVbMV0sIGEyMiA9IGFlWzVdLCBhMjMgPSBhZVs5XSwgYTI0ID0gYWVbMTNdO1xyXG5cdFx0dmFyIGEzMSA9IGFlWzJdLCBhMzIgPSBhZVs2XSwgYTMzID0gYWVbMTBdLCBhMzQgPSBhZVsxNF07XHJcblx0XHR2YXIgYTQxID0gYWVbM10sIGE0MiA9IGFlWzddLCBhNDMgPSBhZVsxMV0sIGE0NCA9IGFlWzE1XTtcclxuXHJcblx0XHR2YXIgYjExID0gYmVbMF0sIGIxMiA9IGJlWzRdLCBiMTMgPSBiZVs4XSwgYjE0ID0gYmVbMTJdO1xyXG5cdFx0dmFyIGIyMSA9IGJlWzFdLCBiMjIgPSBiZVs1XSwgYjIzID0gYmVbOV0sIGIyNCA9IGJlWzEzXTtcclxuXHRcdHZhciBiMzEgPSBiZVsyXSwgYjMyID0gYmVbNl0sIGIzMyA9IGJlWzEwXSwgYjM0ID0gYmVbMTRdO1xyXG5cdFx0dmFyIGI0MSA9IGJlWzNdLCBiNDIgPSBiZVs3XSwgYjQzID0gYmVbMTFdLCBiNDQgPSBiZVsxNV07XHJcblxyXG5cdFx0dGVbMF0gPSBhMTEgKiBiMTEgKyBhMTIgKiBiMjEgKyBhMTMgKiBiMzEgKyBhMTQgKiBiNDE7XHJcblx0XHR0ZVs0XSA9IGExMSAqIGIxMiArIGExMiAqIGIyMiArIGExMyAqIGIzMiArIGExNCAqIGI0MjtcclxuXHRcdHRlWzhdID0gYTExICogYjEzICsgYTEyICogYjIzICsgYTEzICogYjMzICsgYTE0ICogYjQzO1xyXG5cdFx0dGVbMTJdID0gYTExICogYjE0ICsgYTEyICogYjI0ICsgYTEzICogYjM0ICsgYTE0ICogYjQ0O1xyXG5cclxuXHRcdHRlWzFdID0gYTIxICogYjExICsgYTIyICogYjIxICsgYTIzICogYjMxICsgYTI0ICogYjQxO1xyXG5cdFx0dGVbNV0gPSBhMjEgKiBiMTIgKyBhMjIgKiBiMjIgKyBhMjMgKiBiMzIgKyBhMjQgKiBiNDI7XHJcblx0XHR0ZVs5XSA9IGEyMSAqIGIxMyArIGEyMiAqIGIyMyArIGEyMyAqIGIzMyArIGEyNCAqIGI0MztcclxuXHRcdHRlWzEzXSA9IGEyMSAqIGIxNCArIGEyMiAqIGIyNCArIGEyMyAqIGIzNCArIGEyNCAqIGI0NDtcclxuXHJcblx0XHR0ZVsyXSA9IGEzMSAqIGIxMSArIGEzMiAqIGIyMSArIGEzMyAqIGIzMSArIGEzNCAqIGI0MTtcclxuXHRcdHRlWzZdID0gYTMxICogYjEyICsgYTMyICogYjIyICsgYTMzICogYjMyICsgYTM0ICogYjQyO1xyXG5cdFx0dGVbMTBdID0gYTMxICogYjEzICsgYTMyICogYjIzICsgYTMzICogYjMzICsgYTM0ICogYjQzO1xyXG5cdFx0dGVbMTRdID0gYTMxICogYjE0ICsgYTMyICogYjI0ICsgYTMzICogYjM0ICsgYTM0ICogYjQ0O1xyXG5cclxuXHRcdHRlWzNdID0gYTQxICogYjExICsgYTQyICogYjIxICsgYTQzICogYjMxICsgYTQ0ICogYjQxO1xyXG5cdFx0dGVbN10gPSBhNDEgKiBiMTIgKyBhNDIgKiBiMjIgKyBhNDMgKiBiMzIgKyBhNDQgKiBiNDI7XHJcblx0XHR0ZVsxMV0gPSBhNDEgKiBiMTMgKyBhNDIgKiBiMjMgKyBhNDMgKiBiMzMgKyBhNDQgKiBiNDM7XHJcblx0XHR0ZVsxNV0gPSBhNDEgKiBiMTQgKyBhNDIgKiBiMjQgKyBhNDMgKiBiMzQgKyBhNDQgKiBiNDQ7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5VG9BcnJheTogZnVuY3Rpb24gKCBhLCBiLCByICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0dGhpcy5tdWx0aXBseU1hdHJpY2VzKCBhLCBiICk7XHJcblxyXG5cdFx0clsgMCBdID0gdGVbMF07IHJbIDEgXSA9IHRlWzFdOyByWyAyIF0gPSB0ZVsyXTsgclsgMyBdID0gdGVbM107XHJcblx0XHRyWyA0IF0gPSB0ZVs0XTsgclsgNSBdID0gdGVbNV07IHJbIDYgXSA9IHRlWzZdOyByWyA3IF0gPSB0ZVs3XTtcclxuXHRcdHJbIDggXSAgPSB0ZVs4XTsgclsgOSBdICA9IHRlWzldOyByWyAxMCBdID0gdGVbMTBdOyByWyAxMSBdID0gdGVbMTFdO1xyXG5cdFx0clsgMTIgXSA9IHRlWzEyXTsgclsgMTMgXSA9IHRlWzEzXTsgclsgMTQgXSA9IHRlWzE0XTsgclsgMTUgXSA9IHRlWzE1XTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRlWzBdICo9IHM7IHRlWzRdICo9IHM7IHRlWzhdICo9IHM7IHRlWzEyXSAqPSBzO1xyXG5cdFx0dGVbMV0gKj0gczsgdGVbNV0gKj0gczsgdGVbOV0gKj0gczsgdGVbMTNdICo9IHM7XHJcblx0XHR0ZVsyXSAqPSBzOyB0ZVs2XSAqPSBzOyB0ZVsxMF0gKj0gczsgdGVbMTRdICo9IHM7XHJcblx0XHR0ZVszXSAqPSBzOyB0ZVs3XSAqPSBzOyB0ZVsxMV0gKj0gczsgdGVbMTVdICo9IHM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5VmVjdG9yMzogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnREVQUkVDQVRFRDogTWF0cml4NFxcJ3MgLm11bHRpcGx5VmVjdG9yMygpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2ZWN0b3IuYXBwbHlNYXRyaXg0KCBtYXRyaXggKSBvciB2ZWN0b3IuYXBwbHlQcm9qZWN0aW9uKCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcclxuXHRcdHJldHVybiB2ZWN0b3IuYXBwbHlQcm9qZWN0aW9uKCB0aGlzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5VmVjdG9yNDogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnREVQUkVDQVRFRDogTWF0cml4NFxcJ3MgLm11bHRpcGx5VmVjdG9yNCgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2ZWN0b3IuYXBwbHlNYXRyaXg0KCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcclxuXHRcdHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KCB0aGlzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5VmVjdG9yM0FycmF5OiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGEgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gYS5sZW5ndGg7IGkgPCBpbDsgaSArPSAzICkge1xyXG5cclxuXHRcdFx0XHR2MS54ID0gYVsgaSBdO1xyXG5cdFx0XHRcdHYxLnkgPSBhWyBpICsgMSBdO1xyXG5cdFx0XHRcdHYxLnogPSBhWyBpICsgMiBdO1xyXG5cclxuXHRcdFx0XHR2MS5hcHBseVByb2plY3Rpb24oIHRoaXMgKTtcclxuXHJcblx0XHRcdFx0YVsgaSBdICAgICA9IHYxLng7XHJcblx0XHRcdFx0YVsgaSArIDEgXSA9IHYxLnk7XHJcblx0XHRcdFx0YVsgaSArIDIgXSA9IHYxLno7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gYTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHJvdGF0ZUF4aXM6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cdFx0dmFyIHZ4ID0gdi54LCB2eSA9IHYueSwgdnogPSB2Lno7XHJcblxyXG5cdFx0di54ID0gdnggKiB0ZVswXSArIHZ5ICogdGVbNF0gKyB2eiAqIHRlWzhdO1xyXG5cdFx0di55ID0gdnggKiB0ZVsxXSArIHZ5ICogdGVbNV0gKyB2eiAqIHRlWzldO1xyXG5cdFx0di56ID0gdnggKiB0ZVsyXSArIHZ5ICogdGVbNl0gKyB2eiAqIHRlWzEwXTtcclxuXHJcblx0XHR2Lm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdHJldHVybiB2O1xyXG5cclxuXHR9LFxyXG5cclxuXHRjcm9zc1ZlY3RvcjogZnVuY3Rpb24gKCBhICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblx0XHR2YXIgdiA9IG5ldyBUSFJFRS5WZWN0b3I0KCk7XHJcblxyXG5cdFx0di54ID0gdGVbMF0gKiBhLnggKyB0ZVs0XSAqIGEueSArIHRlWzhdICogYS56ICsgdGVbMTJdICogYS53O1xyXG5cdFx0di55ID0gdGVbMV0gKiBhLnggKyB0ZVs1XSAqIGEueSArIHRlWzldICogYS56ICsgdGVbMTNdICogYS53O1xyXG5cdFx0di56ID0gdGVbMl0gKiBhLnggKyB0ZVs2XSAqIGEueSArIHRlWzEwXSAqIGEueiArIHRlWzE0XSAqIGEudztcclxuXHJcblx0XHR2LncgPSAoIGEudyApID8gdGVbM10gKiBhLnggKyB0ZVs3XSAqIGEueSArIHRlWzExXSAqIGEueiArIHRlWzE1XSAqIGEudyA6IDE7XHJcblxyXG5cdFx0cmV0dXJuIHY7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRldGVybWluYW50OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR2YXIgbjExID0gdGVbMF0sIG4xMiA9IHRlWzRdLCBuMTMgPSB0ZVs4XSwgbjE0ID0gdGVbMTJdO1xyXG5cdFx0dmFyIG4yMSA9IHRlWzFdLCBuMjIgPSB0ZVs1XSwgbjIzID0gdGVbOV0sIG4yNCA9IHRlWzEzXTtcclxuXHRcdHZhciBuMzEgPSB0ZVsyXSwgbjMyID0gdGVbNl0sIG4zMyA9IHRlWzEwXSwgbjM0ID0gdGVbMTRdO1xyXG5cdFx0dmFyIG40MSA9IHRlWzNdLCBuNDIgPSB0ZVs3XSwgbjQzID0gdGVbMTFdLCBuNDQgPSB0ZVsxNV07XHJcblxyXG5cdFx0Ly9UT0RPOiBtYWtlIHRoaXMgbW9yZSBlZmZpY2llbnRcclxuXHRcdC8vKCBiYXNlZCBvbiBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL21hdHJpeC9mdW5jdGlvbnMvaW52ZXJzZS9mb3VyRC9pbmRleC5odG0gKVxyXG5cclxuXHRcdHJldHVybiAoXHJcblx0XHRcdG40MSAqIChcclxuXHRcdFx0XHQrbjE0ICogbjIzICogbjMyXHJcblx0XHRcdFx0LW4xMyAqIG4yNCAqIG4zMlxyXG5cdFx0XHRcdC1uMTQgKiBuMjIgKiBuMzNcclxuXHRcdFx0XHQrbjEyICogbjI0ICogbjMzXHJcblx0XHRcdFx0K24xMyAqIG4yMiAqIG4zNFxyXG5cdFx0XHRcdC1uMTIgKiBuMjMgKiBuMzRcclxuXHRcdFx0KSArXHJcblx0XHRcdG40MiAqIChcclxuXHRcdFx0XHQrbjExICogbjIzICogbjM0XHJcblx0XHRcdFx0LW4xMSAqIG4yNCAqIG4zM1xyXG5cdFx0XHRcdCtuMTQgKiBuMjEgKiBuMzNcclxuXHRcdFx0XHQtbjEzICogbjIxICogbjM0XHJcblx0XHRcdFx0K24xMyAqIG4yNCAqIG4zMVxyXG5cdFx0XHRcdC1uMTQgKiBuMjMgKiBuMzFcclxuXHRcdFx0KSArXHJcblx0XHRcdG40MyAqIChcclxuXHRcdFx0XHQrbjExICogbjI0ICogbjMyXHJcblx0XHRcdFx0LW4xMSAqIG4yMiAqIG4zNFxyXG5cdFx0XHRcdC1uMTQgKiBuMjEgKiBuMzJcclxuXHRcdFx0XHQrbjEyICogbjIxICogbjM0XHJcblx0XHRcdFx0K24xNCAqIG4yMiAqIG4zMVxyXG5cdFx0XHRcdC1uMTIgKiBuMjQgKiBuMzFcclxuXHRcdFx0KSArXHJcblx0XHRcdG40NCAqIChcclxuXHRcdFx0XHQtbjEzICogbjIyICogbjMxXHJcblx0XHRcdFx0LW4xMSAqIG4yMyAqIG4zMlxyXG5cdFx0XHRcdCtuMTEgKiBuMjIgKiBuMzNcclxuXHRcdFx0XHQrbjEzICogbjIxICogbjMyXHJcblx0XHRcdFx0LW4xMiAqIG4yMSAqIG4zM1xyXG5cdFx0XHRcdCtuMTIgKiBuMjMgKiBuMzFcclxuXHRcdFx0KVxyXG5cclxuXHRcdCk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRyYW5zcG9zZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblx0XHR2YXIgdG1wO1xyXG5cclxuXHRcdHRtcCA9IHRlWzFdOyB0ZVsxXSA9IHRlWzRdOyB0ZVs0XSA9IHRtcDtcclxuXHRcdHRtcCA9IHRlWzJdOyB0ZVsyXSA9IHRlWzhdOyB0ZVs4XSA9IHRtcDtcclxuXHRcdHRtcCA9IHRlWzZdOyB0ZVs2XSA9IHRlWzldOyB0ZVs5XSA9IHRtcDtcclxuXHJcblx0XHR0bXAgPSB0ZVszXTsgdGVbM10gPSB0ZVsxMl07IHRlWzEyXSA9IHRtcDtcclxuXHRcdHRtcCA9IHRlWzddOyB0ZVs3XSA9IHRlWzEzXTsgdGVbMTNdID0gdG1wO1xyXG5cdFx0dG1wID0gdGVbMTFdOyB0ZVsxMV0gPSB0ZVsxNF07IHRlWzE0XSA9IHRtcDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZmxhdHRlblRvQXJyYXk6IGZ1bmN0aW9uICggZmxhdCApIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cdFx0ZmxhdFsgMCBdID0gdGVbMF07IGZsYXRbIDEgXSA9IHRlWzFdOyBmbGF0WyAyIF0gPSB0ZVsyXTsgZmxhdFsgMyBdID0gdGVbM107XHJcblx0XHRmbGF0WyA0IF0gPSB0ZVs0XTsgZmxhdFsgNSBdID0gdGVbNV07IGZsYXRbIDYgXSA9IHRlWzZdOyBmbGF0WyA3IF0gPSB0ZVs3XTtcclxuXHRcdGZsYXRbIDggXSA9IHRlWzhdOyBmbGF0WyA5IF0gPSB0ZVs5XTsgZmxhdFsgMTAgXSA9IHRlWzEwXTsgZmxhdFsgMTEgXSA9IHRlWzExXTtcclxuXHRcdGZsYXRbIDEyIF0gPSB0ZVsxMl07IGZsYXRbIDEzIF0gPSB0ZVsxM107IGZsYXRbIDE0IF0gPSB0ZVsxNF07IGZsYXRbIDE1IF0gPSB0ZVsxNV07XHJcblxyXG5cdFx0cmV0dXJuIGZsYXQ7XHJcblxyXG5cdH0sXHJcblxyXG5cdGZsYXR0ZW5Ub0FycmF5T2Zmc2V0OiBmdW5jdGlvbiggZmxhdCwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblx0XHRmbGF0WyBvZmZzZXQgXSA9IHRlWzBdO1xyXG5cdFx0ZmxhdFsgb2Zmc2V0ICsgMSBdID0gdGVbMV07XHJcblx0XHRmbGF0WyBvZmZzZXQgKyAyIF0gPSB0ZVsyXTtcclxuXHRcdGZsYXRbIG9mZnNldCArIDMgXSA9IHRlWzNdO1xyXG5cclxuXHRcdGZsYXRbIG9mZnNldCArIDQgXSA9IHRlWzRdO1xyXG5cdFx0ZmxhdFsgb2Zmc2V0ICsgNSBdID0gdGVbNV07XHJcblx0XHRmbGF0WyBvZmZzZXQgKyA2IF0gPSB0ZVs2XTtcclxuXHRcdGZsYXRbIG9mZnNldCArIDcgXSA9IHRlWzddO1xyXG5cclxuXHRcdGZsYXRbIG9mZnNldCArIDggXSAgPSB0ZVs4XTtcclxuXHRcdGZsYXRbIG9mZnNldCArIDkgXSAgPSB0ZVs5XTtcclxuXHRcdGZsYXRbIG9mZnNldCArIDEwIF0gPSB0ZVsxMF07XHJcblx0XHRmbGF0WyBvZmZzZXQgKyAxMSBdID0gdGVbMTFdO1xyXG5cclxuXHRcdGZsYXRbIG9mZnNldCArIDEyIF0gPSB0ZVsxMl07XHJcblx0XHRmbGF0WyBvZmZzZXQgKyAxMyBdID0gdGVbMTNdO1xyXG5cdFx0ZmxhdFsgb2Zmc2V0ICsgMTQgXSA9IHRlWzE0XTtcclxuXHRcdGZsYXRbIG9mZnNldCArIDE1IF0gPSB0ZVsxNV07XHJcblxyXG5cdFx0cmV0dXJuIGZsYXQ7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdERVBSRUNBVEVEOiBNYXRyaXg0XFwncyAuZ2V0UG9zaXRpb24oKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVmVjdG9yMy5nZXRQb3NpdGlvbkZyb21NYXRyaXgoIG1hdHJpeCApIGluc3RlYWQuJyApO1xyXG5cclxuXHRcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHRcdFx0cmV0dXJuIHYxLnNldCggdGVbMTJdLCB0ZVsxM10sIHRlWzE0XSApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0c2V0UG9zaXRpb246IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRlWzEyXSA9IHYueDtcclxuXHRcdHRlWzEzXSA9IHYueTtcclxuXHRcdHRlWzE0XSA9IHYuejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0SW52ZXJzZTogZnVuY3Rpb24gKCBtLCB0aHJvd09uSW52ZXJ0aWJsZSApIHtcclxuXHJcblx0XHQvLyBiYXNlZCBvbiBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL21hdHJpeC9mdW5jdGlvbnMvaW52ZXJzZS9mb3VyRC9pbmRleC5odG1cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblx0XHR2YXIgbWUgPSBtLmVsZW1lbnRzO1xyXG5cclxuXHRcdHZhciBuMTEgPSBtZVswXSwgbjEyID0gbWVbNF0sIG4xMyA9IG1lWzhdLCBuMTQgPSBtZVsxMl07XHJcblx0XHR2YXIgbjIxID0gbWVbMV0sIG4yMiA9IG1lWzVdLCBuMjMgPSBtZVs5XSwgbjI0ID0gbWVbMTNdO1xyXG5cdFx0dmFyIG4zMSA9IG1lWzJdLCBuMzIgPSBtZVs2XSwgbjMzID0gbWVbMTBdLCBuMzQgPSBtZVsxNF07XHJcblx0XHR2YXIgbjQxID0gbWVbM10sIG40MiA9IG1lWzddLCBuNDMgPSBtZVsxMV0sIG40NCA9IG1lWzE1XTtcclxuXHJcblx0XHR0ZVswXSA9IG4yMypuMzQqbjQyIC0gbjI0Km4zMypuNDIgKyBuMjQqbjMyKm40MyAtIG4yMipuMzQqbjQzIC0gbjIzKm4zMipuNDQgKyBuMjIqbjMzKm40NDtcclxuXHRcdHRlWzRdID0gbjE0Km4zMypuNDIgLSBuMTMqbjM0Km40MiAtIG4xNCpuMzIqbjQzICsgbjEyKm4zNCpuNDMgKyBuMTMqbjMyKm40NCAtIG4xMipuMzMqbjQ0O1xyXG5cdFx0dGVbOF0gPSBuMTMqbjI0Km40MiAtIG4xNCpuMjMqbjQyICsgbjE0Km4yMipuNDMgLSBuMTIqbjI0Km40MyAtIG4xMypuMjIqbjQ0ICsgbjEyKm4yMypuNDQ7XHJcblx0XHR0ZVsxMl0gPSBuMTQqbjIzKm4zMiAtIG4xMypuMjQqbjMyIC0gbjE0Km4yMipuMzMgKyBuMTIqbjI0Km4zMyArIG4xMypuMjIqbjM0IC0gbjEyKm4yMypuMzQ7XHJcblx0XHR0ZVsxXSA9IG4yNCpuMzMqbjQxIC0gbjIzKm4zNCpuNDEgLSBuMjQqbjMxKm40MyArIG4yMSpuMzQqbjQzICsgbjIzKm4zMSpuNDQgLSBuMjEqbjMzKm40NDtcclxuXHRcdHRlWzVdID0gbjEzKm4zNCpuNDEgLSBuMTQqbjMzKm40MSArIG4xNCpuMzEqbjQzIC0gbjExKm4zNCpuNDMgLSBuMTMqbjMxKm40NCArIG4xMSpuMzMqbjQ0O1xyXG5cdFx0dGVbOV0gPSBuMTQqbjIzKm40MSAtIG4xMypuMjQqbjQxIC0gbjE0Km4yMSpuNDMgKyBuMTEqbjI0Km40MyArIG4xMypuMjEqbjQ0IC0gbjExKm4yMypuNDQ7XHJcblx0XHR0ZVsxM10gPSBuMTMqbjI0Km4zMSAtIG4xNCpuMjMqbjMxICsgbjE0Km4yMSpuMzMgLSBuMTEqbjI0Km4zMyAtIG4xMypuMjEqbjM0ICsgbjExKm4yMypuMzQ7XHJcblx0XHR0ZVsyXSA9IG4yMipuMzQqbjQxIC0gbjI0Km4zMipuNDEgKyBuMjQqbjMxKm40MiAtIG4yMSpuMzQqbjQyIC0gbjIyKm4zMSpuNDQgKyBuMjEqbjMyKm40NDtcclxuXHRcdHRlWzZdID0gbjE0Km4zMipuNDEgLSBuMTIqbjM0Km40MSAtIG4xNCpuMzEqbjQyICsgbjExKm4zNCpuNDIgKyBuMTIqbjMxKm40NCAtIG4xMSpuMzIqbjQ0O1xyXG5cdFx0dGVbMTBdID0gbjEyKm4yNCpuNDEgLSBuMTQqbjIyKm40MSArIG4xNCpuMjEqbjQyIC0gbjExKm4yNCpuNDIgLSBuMTIqbjIxKm40NCArIG4xMSpuMjIqbjQ0O1xyXG5cdFx0dGVbMTRdID0gbjE0Km4yMipuMzEgLSBuMTIqbjI0Km4zMSAtIG4xNCpuMjEqbjMyICsgbjExKm4yNCpuMzIgKyBuMTIqbjIxKm4zNCAtIG4xMSpuMjIqbjM0O1xyXG5cdFx0dGVbM10gPSBuMjMqbjMyKm40MSAtIG4yMipuMzMqbjQxIC0gbjIzKm4zMSpuNDIgKyBuMjEqbjMzKm40MiArIG4yMipuMzEqbjQzIC0gbjIxKm4zMipuNDM7XHJcblx0XHR0ZVs3XSA9IG4xMipuMzMqbjQxIC0gbjEzKm4zMipuNDEgKyBuMTMqbjMxKm40MiAtIG4xMSpuMzMqbjQyIC0gbjEyKm4zMSpuNDMgKyBuMTEqbjMyKm40MztcclxuXHRcdHRlWzExXSA9IG4xMypuMjIqbjQxIC0gbjEyKm4yMypuNDEgLSBuMTMqbjIxKm40MiArIG4xMSpuMjMqbjQyICsgbjEyKm4yMSpuNDMgLSBuMTEqbjIyKm40MztcclxuXHRcdHRlWzE1XSA9IG4xMipuMjMqbjMxIC0gbjEzKm4yMipuMzEgKyBuMTMqbjIxKm4zMiAtIG4xMSpuMjMqbjMyIC0gbjEyKm4yMSpuMzMgKyBuMTEqbjIyKm4zMztcclxuXHJcblx0XHR2YXIgZGV0ID0gbWVbIDAgXSAqIHRlWyAwIF0gKyBtZVsgMSBdICogdGVbIDQgXSArIG1lWyAyIF0gKiB0ZVsgOCBdICsgbWVbIDMgXSAqIHRlWyAxMiBdO1xyXG5cclxuXHRcdGlmICggZGV0ID09IDAgKSB7XHJcblxyXG5cdFx0XHR2YXIgbXNnID0gXCJNYXRyaXg0LmdldEludmVyc2UoKTogY2FuJ3QgaW52ZXJ0IG1hdHJpeCwgZGV0ZXJtaW5hbnQgaXMgMFwiO1xyXG5cclxuXHRcdFx0aWYgKCB0aHJvd09uSW52ZXJ0aWJsZSB8fCBmYWxzZSApIHtcclxuXHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTsgXHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oIG1zZyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5pZGVudGl0eSgpO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5tdWx0aXBseVNjYWxhciggMSAvIGRldCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb21wb3NlOiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR2YXIgbVJvdGF0aW9uID0gbmV3IFRIUkVFLk1hdHJpeDQoKSxcclxuXHRcdFx0bVNjYWxlID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHRcdFxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggdHJhbnNsYXRpb24sIHJvdGF0aW9uLCBzY2FsZSApIHtcclxuXHJcblx0XHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0XHRtUm90YXRpb24uaWRlbnRpdHkoKTtcclxuXHRcdFx0bVJvdGF0aW9uLnNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHJvdGF0aW9uICk7XHJcblxyXG5cdFx0XHRtU2NhbGUubWFrZVNjYWxlKCBzY2FsZS54LCBzY2FsZS55LCBzY2FsZS56ICk7XHJcblxyXG5cdFx0XHR0aGlzLm11bHRpcGx5TWF0cmljZXMoIG1Sb3RhdGlvbiwgbVNjYWxlICk7XHJcblxyXG5cdFx0XHR0ZVsxMl0gPSB0cmFuc2xhdGlvbi54O1xyXG5cdFx0XHR0ZVsxM10gPSB0cmFuc2xhdGlvbi55O1xyXG5cdFx0XHR0ZVsxNF0gPSB0cmFuc2xhdGlvbi56O1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRkZWNvbXBvc2U6IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdHZhciB4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0eSA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblx0XHRcdHogPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0XHRtYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHRyYW5zbGF0aW9uLCByb3RhdGlvbiwgc2NhbGUgKSB7XHJcblxyXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdFx0Ly8gZ3JhYiB0aGUgYXhpcyB2ZWN0b3JzXHJcblx0XHRcdHguc2V0KCB0ZVswXSwgdGVbMV0sIHRlWzJdICk7XHJcblx0XHRcdHkuc2V0KCB0ZVs0XSwgdGVbNV0sIHRlWzZdICk7XHJcblx0XHRcdHouc2V0KCB0ZVs4XSwgdGVbOV0sIHRlWzEwXSApO1xyXG5cclxuXHRcdFx0dHJhbnNsYXRpb24gPSAoIHRyYW5zbGF0aW9uIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMyApID8gdHJhbnNsYXRpb24gOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0XHRyb3RhdGlvbiA9ICggcm90YXRpb24gaW5zdGFuY2VvZiBUSFJFRS5RdWF0ZXJuaW9uICkgPyByb3RhdGlvbiA6IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XHJcblx0XHRcdHNjYWxlID0gKCBzY2FsZSBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjMgKSA/IHNjYWxlIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRcdHNjYWxlLnggPSB4Lmxlbmd0aCgpO1xyXG5cdFx0XHRzY2FsZS55ID0geS5sZW5ndGgoKTtcclxuXHRcdFx0c2NhbGUueiA9IHoubGVuZ3RoKCk7XHJcblxyXG5cdFx0XHR0cmFuc2xhdGlvbi54ID0gdGVbMTJdO1xyXG5cdFx0XHR0cmFuc2xhdGlvbi55ID0gdGVbMTNdO1xyXG5cdFx0XHR0cmFuc2xhdGlvbi56ID0gdGVbMTRdO1xyXG5cclxuXHRcdFx0Ly8gc2NhbGUgdGhlIHJvdGF0aW9uIHBhcnRcclxuXHJcblx0XHRcdG1hdHJpeC5jb3B5KCB0aGlzICk7XHJcblxyXG5cdFx0XHRtYXRyaXguZWxlbWVudHNbMF0gLz0gc2NhbGUueDtcclxuXHRcdFx0bWF0cml4LmVsZW1lbnRzWzFdIC89IHNjYWxlLng7XHJcblx0XHRcdG1hdHJpeC5lbGVtZW50c1syXSAvPSBzY2FsZS54O1xyXG5cclxuXHRcdFx0bWF0cml4LmVsZW1lbnRzWzRdIC89IHNjYWxlLnk7XHJcblx0XHRcdG1hdHJpeC5lbGVtZW50c1s1XSAvPSBzY2FsZS55O1xyXG5cdFx0XHRtYXRyaXguZWxlbWVudHNbNl0gLz0gc2NhbGUueTtcclxuXHJcblx0XHRcdG1hdHJpeC5lbGVtZW50c1s4XSAvPSBzY2FsZS56O1xyXG5cdFx0XHRtYXRyaXguZWxlbWVudHNbOV0gLz0gc2NhbGUuejtcclxuXHRcdFx0bWF0cml4LmVsZW1lbnRzWzEwXSAvPSBzY2FsZS56O1xyXG5cclxuXHRcdFx0cm90YXRpb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtYXRyaXggKTtcclxuXHJcblx0XHRcdHJldHVybiBbIHRyYW5zbGF0aW9uLCByb3RhdGlvbiwgc2NhbGUgXTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGV4dHJhY3RQb3NpdGlvbjogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblx0XHR2YXIgbWUgPSBtLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRlWzEyXSA9IG1lWzEyXTtcclxuXHRcdHRlWzEzXSA9IG1lWzEzXTtcclxuXHRcdHRlWzE0XSA9IG1lWzE0XTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXh0cmFjdFJvdGF0aW9uOiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cdFx0XHR2YXIgbWUgPSBtLmVsZW1lbnRzO1xyXG5cclxuXHRcdFx0dmFyIHNjYWxlWCA9IDEgLyB2MS5zZXQoIG1lWzBdLCBtZVsxXSwgbWVbMl0gKS5sZW5ndGgoKTtcclxuXHRcdFx0dmFyIHNjYWxlWSA9IDEgLyB2MS5zZXQoIG1lWzRdLCBtZVs1XSwgbWVbNl0gKS5sZW5ndGgoKTtcclxuXHRcdFx0dmFyIHNjYWxlWiA9IDEgLyB2MS5zZXQoIG1lWzhdLCBtZVs5XSwgbWVbMTBdICkubGVuZ3RoKCk7XHJcblxyXG5cdFx0XHR0ZVswXSA9IG1lWzBdICogc2NhbGVYO1xyXG5cdFx0XHR0ZVsxXSA9IG1lWzFdICogc2NhbGVYO1xyXG5cdFx0XHR0ZVsyXSA9IG1lWzJdICogc2NhbGVYO1xyXG5cclxuXHRcdFx0dGVbNF0gPSBtZVs0XSAqIHNjYWxlWTtcclxuXHRcdFx0dGVbNV0gPSBtZVs1XSAqIHNjYWxlWTtcclxuXHRcdFx0dGVbNl0gPSBtZVs2XSAqIHNjYWxlWTtcclxuXHJcblx0XHRcdHRlWzhdID0gbWVbOF0gKiBzY2FsZVo7XHJcblx0XHRcdHRlWzldID0gbWVbOV0gKiBzY2FsZVo7XHJcblx0XHRcdHRlWzEwXSA9IG1lWzEwXSAqIHNjYWxlWjtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHRcdHZhciB4ID0gdi54LCB5ID0gdi55LCB6ID0gdi56O1xyXG5cclxuXHRcdHRlWzEyXSA9IHRlWzBdICogeCArIHRlWzRdICogeSArIHRlWzhdICogeiArIHRlWzEyXTtcclxuXHRcdHRlWzEzXSA9IHRlWzFdICogeCArIHRlWzVdICogeSArIHRlWzldICogeiArIHRlWzEzXTtcclxuXHRcdHRlWzE0XSA9IHRlWzJdICogeCArIHRlWzZdICogeSArIHRlWzEwXSAqIHogKyB0ZVsxNF07XHJcblx0XHR0ZVsxNV0gPSB0ZVszXSAqIHggKyB0ZVs3XSAqIHkgKyB0ZVsxMV0gKiB6ICsgdGVbMTVdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRyb3RhdGVYOiBmdW5jdGlvbiAoIGFuZ2xlICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblx0XHR2YXIgbTEyID0gdGVbNF07XHJcblx0XHR2YXIgbTIyID0gdGVbNV07XHJcblx0XHR2YXIgbTMyID0gdGVbNl07XHJcblx0XHR2YXIgbTQyID0gdGVbN107XHJcblx0XHR2YXIgbTEzID0gdGVbOF07XHJcblx0XHR2YXIgbTIzID0gdGVbOV07XHJcblx0XHR2YXIgbTMzID0gdGVbMTBdO1xyXG5cdFx0dmFyIG00MyA9IHRlWzExXTtcclxuXHRcdHZhciBjID0gTWF0aC5jb3MoIGFuZ2xlICk7XHJcblx0XHR2YXIgcyA9IE1hdGguc2luKCBhbmdsZSApO1xyXG5cclxuXHRcdHRlWzRdID0gYyAqIG0xMiArIHMgKiBtMTM7XHJcblx0XHR0ZVs1XSA9IGMgKiBtMjIgKyBzICogbTIzO1xyXG5cdFx0dGVbNl0gPSBjICogbTMyICsgcyAqIG0zMztcclxuXHRcdHRlWzddID0gYyAqIG00MiArIHMgKiBtNDM7XHJcblxyXG5cdFx0dGVbOF0gPSBjICogbTEzIC0gcyAqIG0xMjtcclxuXHRcdHRlWzldID0gYyAqIG0yMyAtIHMgKiBtMjI7XHJcblx0XHR0ZVsxMF0gPSBjICogbTMzIC0gcyAqIG0zMjtcclxuXHRcdHRlWzExXSA9IGMgKiBtNDMgLSBzICogbTQyO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRyb3RhdGVZOiBmdW5jdGlvbiAoIGFuZ2xlICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblx0XHR2YXIgbTExID0gdGVbMF07XHJcblx0XHR2YXIgbTIxID0gdGVbMV07XHJcblx0XHR2YXIgbTMxID0gdGVbMl07XHJcblx0XHR2YXIgbTQxID0gdGVbM107XHJcblx0XHR2YXIgbTEzID0gdGVbOF07XHJcblx0XHR2YXIgbTIzID0gdGVbOV07XHJcblx0XHR2YXIgbTMzID0gdGVbMTBdO1xyXG5cdFx0dmFyIG00MyA9IHRlWzExXTtcclxuXHRcdHZhciBjID0gTWF0aC5jb3MoIGFuZ2xlICk7XHJcblx0XHR2YXIgcyA9IE1hdGguc2luKCBhbmdsZSApO1xyXG5cclxuXHRcdHRlWzBdID0gYyAqIG0xMSAtIHMgKiBtMTM7XHJcblx0XHR0ZVsxXSA9IGMgKiBtMjEgLSBzICogbTIzO1xyXG5cdFx0dGVbMl0gPSBjICogbTMxIC0gcyAqIG0zMztcclxuXHRcdHRlWzNdID0gYyAqIG00MSAtIHMgKiBtNDM7XHJcblxyXG5cdFx0dGVbOF0gPSBjICogbTEzICsgcyAqIG0xMTtcclxuXHRcdHRlWzldID0gYyAqIG0yMyArIHMgKiBtMjE7XHJcblx0XHR0ZVsxMF0gPSBjICogbTMzICsgcyAqIG0zMTtcclxuXHRcdHRlWzExXSA9IGMgKiBtNDMgKyBzICogbTQxO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRyb3RhdGVaOiBmdW5jdGlvbiAoIGFuZ2xlICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblx0XHR2YXIgbTExID0gdGVbMF07XHJcblx0XHR2YXIgbTIxID0gdGVbMV07XHJcblx0XHR2YXIgbTMxID0gdGVbMl07XHJcblx0XHR2YXIgbTQxID0gdGVbM107XHJcblx0XHR2YXIgbTEyID0gdGVbNF07XHJcblx0XHR2YXIgbTIyID0gdGVbNV07XHJcblx0XHR2YXIgbTMyID0gdGVbNl07XHJcblx0XHR2YXIgbTQyID0gdGVbN107XHJcblx0XHR2YXIgYyA9IE1hdGguY29zKCBhbmdsZSApO1xyXG5cdFx0dmFyIHMgPSBNYXRoLnNpbiggYW5nbGUgKTtcclxuXHJcblx0XHR0ZVswXSA9IGMgKiBtMTEgKyBzICogbTEyO1xyXG5cdFx0dGVbMV0gPSBjICogbTIxICsgcyAqIG0yMjtcclxuXHRcdHRlWzJdID0gYyAqIG0zMSArIHMgKiBtMzI7XHJcblx0XHR0ZVszXSA9IGMgKiBtNDEgKyBzICogbTQyO1xyXG5cclxuXHRcdHRlWzRdID0gYyAqIG0xMiAtIHMgKiBtMTE7XHJcblx0XHR0ZVs1XSA9IGMgKiBtMjIgLSBzICogbTIxO1xyXG5cdFx0dGVbNl0gPSBjICogbTMyIC0gcyAqIG0zMTtcclxuXHRcdHRlWzddID0gYyAqIG00MiAtIHMgKiBtNDE7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJvdGF0ZUJ5QXhpczogZnVuY3Rpb24gKCBheGlzLCBhbmdsZSApIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdC8vIG9wdGltaXplIGJ5IGNoZWNraW5nIGF4aXNcclxuXHJcblx0XHRpZiAoIGF4aXMueCA9PT0gMSAmJiBheGlzLnkgPT09IDAgJiYgYXhpcy56ID09PSAwICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMucm90YXRlWCggYW5nbGUgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBheGlzLnggPT09IDAgJiYgYXhpcy55ID09PSAxICYmIGF4aXMueiA9PT0gMCApIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLnJvdGF0ZVkoIGFuZ2xlICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggYXhpcy54ID09PSAwICYmIGF4aXMueSA9PT0gMCAmJiBheGlzLnogPT09IDEgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5yb3RhdGVaKCBhbmdsZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgeCA9IGF4aXMueCwgeSA9IGF4aXMueSwgeiA9IGF4aXMuejtcclxuXHRcdHZhciBuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeik7XHJcblxyXG5cdFx0eCAvPSBuO1xyXG5cdFx0eSAvPSBuO1xyXG5cdFx0eiAvPSBuO1xyXG5cclxuXHRcdHZhciB4eCA9IHggKiB4LCB5eSA9IHkgKiB5LCB6eiA9IHogKiB6O1xyXG5cdFx0dmFyIGMgPSBNYXRoLmNvcyggYW5nbGUgKTtcclxuXHRcdHZhciBzID0gTWF0aC5zaW4oIGFuZ2xlICk7XHJcblx0XHR2YXIgb25lTWludXNDb3NpbmUgPSAxIC0gYztcclxuXHRcdHZhciB4eSA9IHggKiB5ICogb25lTWludXNDb3NpbmU7XHJcblx0XHR2YXIgeHogPSB4ICogeiAqIG9uZU1pbnVzQ29zaW5lO1xyXG5cdFx0dmFyIHl6ID0geSAqIHogKiBvbmVNaW51c0Nvc2luZTtcclxuXHRcdHZhciB4cyA9IHggKiBzO1xyXG5cdFx0dmFyIHlzID0geSAqIHM7XHJcblx0XHR2YXIgenMgPSB6ICogcztcclxuXHJcblx0XHR2YXIgcjExID0geHggKyAoMSAtIHh4KSAqIGM7XHJcblx0XHR2YXIgcjIxID0geHkgKyB6cztcclxuXHRcdHZhciByMzEgPSB4eiAtIHlzO1xyXG5cdFx0dmFyIHIxMiA9IHh5IC0genM7XHJcblx0XHR2YXIgcjIyID0geXkgKyAoMSAtIHl5KSAqIGM7XHJcblx0XHR2YXIgcjMyID0geXogKyB4cztcclxuXHRcdHZhciByMTMgPSB4eiArIHlzO1xyXG5cdFx0dmFyIHIyMyA9IHl6IC0geHM7XHJcblx0XHR2YXIgcjMzID0genogKyAoMSAtIHp6KSAqIGM7XHJcblxyXG5cdFx0dmFyIG0xMSA9IHRlWzBdLCBtMjEgPSB0ZVsxXSwgbTMxID0gdGVbMl0sIG00MSA9IHRlWzNdO1xyXG5cdFx0dmFyIG0xMiA9IHRlWzRdLCBtMjIgPSB0ZVs1XSwgbTMyID0gdGVbNl0sIG00MiA9IHRlWzddO1xyXG5cdFx0dmFyIG0xMyA9IHRlWzhdLCBtMjMgPSB0ZVs5XSwgbTMzID0gdGVbMTBdLCBtNDMgPSB0ZVsxMV07XHJcblxyXG5cdFx0dGVbMF0gPSByMTEgKiBtMTEgKyByMjEgKiBtMTIgKyByMzEgKiBtMTM7XHJcblx0XHR0ZVsxXSA9IHIxMSAqIG0yMSArIHIyMSAqIG0yMiArIHIzMSAqIG0yMztcclxuXHRcdHRlWzJdID0gcjExICogbTMxICsgcjIxICogbTMyICsgcjMxICogbTMzO1xyXG5cdFx0dGVbM10gPSByMTEgKiBtNDEgKyByMjEgKiBtNDIgKyByMzEgKiBtNDM7XHJcblxyXG5cdFx0dGVbNF0gPSByMTIgKiBtMTEgKyByMjIgKiBtMTIgKyByMzIgKiBtMTM7XHJcblx0XHR0ZVs1XSA9IHIxMiAqIG0yMSArIHIyMiAqIG0yMiArIHIzMiAqIG0yMztcclxuXHRcdHRlWzZdID0gcjEyICogbTMxICsgcjIyICogbTMyICsgcjMyICogbTMzO1xyXG5cdFx0dGVbN10gPSByMTIgKiBtNDEgKyByMjIgKiBtNDIgKyByMzIgKiBtNDM7XHJcblxyXG5cdFx0dGVbOF0gPSByMTMgKiBtMTEgKyByMjMgKiBtMTIgKyByMzMgKiBtMTM7XHJcblx0XHR0ZVs5XSA9IHIxMyAqIG0yMSArIHIyMyAqIG0yMiArIHIzMyAqIG0yMztcclxuXHRcdHRlWzEwXSA9IHIxMyAqIG0zMSArIHIyMyAqIG0zMiArIHIzMyAqIG0zMztcclxuXHRcdHRlWzExXSA9IHIxMyAqIG00MSArIHIyMyAqIG00MiArIHIzMyAqIG00MztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2NhbGU6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cdFx0dmFyIHggPSB2LngsIHkgPSB2LnksIHogPSB2Lno7XHJcblxyXG5cdFx0dGVbMF0gKj0geDsgdGVbNF0gKj0geTsgdGVbOF0gKj0gejtcclxuXHRcdHRlWzFdICo9IHg7IHRlWzVdICo9IHk7IHRlWzldICo9IHo7XHJcblx0XHR0ZVsyXSAqPSB4OyB0ZVs2XSAqPSB5OyB0ZVsxMF0gKj0gejtcclxuXHRcdHRlWzNdICo9IHg7IHRlWzddICo9IHk7IHRlWzExXSAqPSB6O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRNYXhTY2FsZU9uQXhpczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0dmFyIHNjYWxlWFNxID0gdGVbMF0gKiB0ZVswXSArIHRlWzFdICogdGVbMV0gKyB0ZVsyXSAqIHRlWzJdO1xyXG5cdFx0dmFyIHNjYWxlWVNxID0gdGVbNF0gKiB0ZVs0XSArIHRlWzVdICogdGVbNV0gKyB0ZVs2XSAqIHRlWzZdO1xyXG5cdFx0dmFyIHNjYWxlWlNxID0gdGVbOF0gKiB0ZVs4XSArIHRlWzldICogdGVbOV0gKyB0ZVsxMF0gKiB0ZVsxMF07XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguc3FydCggTWF0aC5tYXgoIHNjYWxlWFNxLCBNYXRoLm1heCggc2NhbGVZU3EsIHNjYWxlWlNxICkgKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYWtlVHJhbnNsYXRpb246IGZ1bmN0aW9uICggeCwgeSwgeiApIHtcclxuXHJcblx0XHR0aGlzLnNldChcclxuXHJcblx0XHRcdDEsIDAsIDAsIHgsXHJcblx0XHRcdDAsIDEsIDAsIHksXHJcblx0XHRcdDAsIDAsIDEsIHosXHJcblx0XHRcdDAsIDAsIDAsIDFcclxuXHJcblx0XHQpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYWtlUm90YXRpb25YOiBmdW5jdGlvbiAoIHRoZXRhICkge1xyXG5cclxuXHRcdHZhciBjID0gTWF0aC5jb3MoIHRoZXRhICksIHMgPSBNYXRoLnNpbiggdGhldGEgKTtcclxuXHJcblx0XHR0aGlzLnNldChcclxuXHJcblx0XHRcdDEsIDAsICAwLCAwLFxyXG5cdFx0XHQwLCBjLCAtcywgMCxcclxuXHRcdFx0MCwgcywgIGMsIDAsXHJcblx0XHRcdDAsIDAsICAwLCAxXHJcblxyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bWFrZVJvdGF0aW9uWTogZnVuY3Rpb24gKCB0aGV0YSApIHtcclxuXHJcblx0XHR2YXIgYyA9IE1hdGguY29zKCB0aGV0YSApLCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XHJcblxyXG5cdFx0dGhpcy5zZXQoXHJcblxyXG5cdFx0XHQgYywgMCwgcywgMCxcclxuXHRcdFx0IDAsIDEsIDAsIDAsXHJcblx0XHRcdC1zLCAwLCBjLCAwLFxyXG5cdFx0XHQgMCwgMCwgMCwgMVxyXG5cclxuXHRcdCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1ha2VSb3RhdGlvblo6IGZ1bmN0aW9uICggdGhldGEgKSB7XHJcblxyXG5cdFx0dmFyIGMgPSBNYXRoLmNvcyggdGhldGEgKSwgcyA9IE1hdGguc2luKCB0aGV0YSApO1xyXG5cclxuXHRcdHRoaXMuc2V0KFxyXG5cclxuXHRcdFx0YywgLXMsIDAsIDAsXHJcblx0XHRcdHMsICBjLCAwLCAwLFxyXG5cdFx0XHQwLCAgMCwgMSwgMCxcclxuXHRcdFx0MCwgIDAsIDAsIDFcclxuXHJcblx0XHQpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYWtlUm90YXRpb25BeGlzOiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xyXG5cclxuXHRcdC8vIEJhc2VkIG9uIGh0dHA6Ly93d3cuZ2FtZWRldi5uZXQvcmVmZXJlbmNlL2FydGljbGVzL2FydGljbGUxMTk5LmFzcFxyXG5cclxuXHRcdHZhciBjID0gTWF0aC5jb3MoIGFuZ2xlICk7XHJcblx0XHR2YXIgcyA9IE1hdGguc2luKCBhbmdsZSApO1xyXG5cdFx0dmFyIHQgPSAxIC0gYztcclxuXHRcdHZhciB4ID0gYXhpcy54LCB5ID0gYXhpcy55LCB6ID0gYXhpcy56O1xyXG5cdFx0dmFyIHR4ID0gdCAqIHgsIHR5ID0gdCAqIHk7XHJcblxyXG5cdFx0dGhpcy5zZXQoXHJcblxyXG5cdFx0XHR0eCAqIHggKyBjLCB0eCAqIHkgLSBzICogeiwgdHggKiB6ICsgcyAqIHksIDAsXHJcblx0XHRcdHR4ICogeSArIHMgKiB6LCB0eSAqIHkgKyBjLCB0eSAqIHogLSBzICogeCwgMCxcclxuXHRcdFx0dHggKiB6IC0gcyAqIHksIHR5ICogeiArIHMgKiB4LCB0ICogeiAqIHogKyBjLCAwLFxyXG5cdFx0XHQwLCAwLCAwLCAxXHJcblxyXG5cdFx0KTtcclxuXHJcblx0XHQgcmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1ha2VTY2FsZTogZnVuY3Rpb24gKCB4LCB5LCB6ICkge1xyXG5cclxuXHRcdHRoaXMuc2V0KFxyXG5cclxuXHRcdFx0eCwgMCwgMCwgMCxcclxuXHRcdFx0MCwgeSwgMCwgMCxcclxuXHRcdFx0MCwgMCwgeiwgMCxcclxuXHRcdFx0MCwgMCwgMCwgMVxyXG5cclxuXHRcdCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1ha2VGcnVzdHVtOiBmdW5jdGlvbiAoIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblx0XHR2YXIgeCA9IDIgKiBuZWFyIC8gKCByaWdodCAtIGxlZnQgKTtcclxuXHRcdHZhciB5ID0gMiAqIG5lYXIgLyAoIHRvcCAtIGJvdHRvbSApO1xyXG5cclxuXHRcdHZhciBhID0gKCByaWdodCArIGxlZnQgKSAvICggcmlnaHQgLSBsZWZ0ICk7XHJcblx0XHR2YXIgYiA9ICggdG9wICsgYm90dG9tICkgLyAoIHRvcCAtIGJvdHRvbSApO1xyXG5cdFx0dmFyIGMgPSAtICggZmFyICsgbmVhciApIC8gKCBmYXIgLSBuZWFyICk7XHJcblx0XHR2YXIgZCA9IC0gMiAqIGZhciAqIG5lYXIgLyAoIGZhciAtIG5lYXIgKTtcclxuXHJcblx0XHR0ZVswXSA9IHg7XHR0ZVs0XSA9IDA7XHR0ZVs4XSA9IGE7XHR0ZVsxMl0gPSAwO1xyXG5cdFx0dGVbMV0gPSAwO1x0dGVbNV0gPSB5O1x0dGVbOV0gPSBiO1x0dGVbMTNdID0gMDtcclxuXHRcdHRlWzJdID0gMDtcdHRlWzZdID0gMDtcdHRlWzEwXSA9IGM7XHR0ZVsxNF0gPSBkO1xyXG5cdFx0dGVbM10gPSAwO1x0dGVbN10gPSAwO1x0dGVbMTFdID0gLSAxO1x0dGVbMTVdID0gMDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bWFrZVBlcnNwZWN0aXZlOiBmdW5jdGlvbiAoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKSB7XHJcblxyXG5cdFx0dmFyIHltYXggPSBuZWFyICogTWF0aC50YW4oIFRIUkVFLk1hdGguZGVnVG9SYWQoIGZvdiAqIDAuNSApICk7XHJcblx0XHR2YXIgeW1pbiA9IC0geW1heDtcclxuXHRcdHZhciB4bWluID0geW1pbiAqIGFzcGVjdDtcclxuXHRcdHZhciB4bWF4ID0geW1heCAqIGFzcGVjdDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5tYWtlRnJ1c3R1bSggeG1pbiwgeG1heCwgeW1pbiwgeW1heCwgbmVhciwgZmFyICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1ha2VPcnRob2dyYXBoaWM6IGZ1bmN0aW9uICggbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBuZWFyLCBmYXIgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHRcdHZhciB3ID0gcmlnaHQgLSBsZWZ0O1xyXG5cdFx0dmFyIGggPSB0b3AgLSBib3R0b207XHJcblx0XHR2YXIgcCA9IGZhciAtIG5lYXI7XHJcblxyXG5cdFx0dmFyIHggPSAoIHJpZ2h0ICsgbGVmdCApIC8gdztcclxuXHRcdHZhciB5ID0gKCB0b3AgKyBib3R0b20gKSAvIGg7XHJcblx0XHR2YXIgeiA9ICggZmFyICsgbmVhciApIC8gcDtcclxuXHJcblx0XHR0ZVswXSA9IDIgLyB3O1x0dGVbNF0gPSAwO1x0dGVbOF0gPSAwO1x0dGVbMTJdID0gLXg7XHJcblx0XHR0ZVsxXSA9IDA7XHR0ZVs1XSA9IDIgLyBoO1x0dGVbOV0gPSAwO1x0dGVbMTNdID0gLXk7XHJcblx0XHR0ZVsyXSA9IDA7XHR0ZVs2XSA9IDA7XHR0ZVsxMF0gPSAtMi9wO1x0dGVbMTRdID0gLXo7XHJcblx0XHR0ZVszXSA9IDA7XHR0ZVs3XSA9IDA7XHR0ZVsxMV0gPSAwO1x0dGVbMTVdID0gMTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHJldHVybiBuZXcgVEhSRUUuTWF0cml4NChcclxuXHJcblx0XHRcdHRlWzBdLCB0ZVs0XSwgdGVbOF0sIHRlWzEyXSxcclxuXHRcdFx0dGVbMV0sIHRlWzVdLCB0ZVs5XSwgdGVbMTNdLFxyXG5cdFx0XHR0ZVsyXSwgdGVbNl0sIHRlWzEwXSwgdGVbMTRdLFxyXG5cdFx0XHR0ZVszXSwgdGVbN10sIHRlWzExXSwgdGVbMTVdXHJcblxyXG5cdFx0KTtcclxuXHJcblx0fVxyXG5cclxufSApO1xyXG4vKipcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXHJcbiAqL1xyXG5cclxuVEhSRUUuUmF5ID0gZnVuY3Rpb24gKCBvcmlnaW4sIGRpcmVjdGlvbiApIHtcclxuXHJcblx0dGhpcy5vcmlnaW4gPSAoIG9yaWdpbiAhPT0gdW5kZWZpbmVkICkgPyBvcmlnaW4gOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHRoaXMuZGlyZWN0aW9uID0gKCBkaXJlY3Rpb24gIT09IHVuZGVmaW5lZCApID8gZGlyZWN0aW9uIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5leHRlbmQoIFRIUkVFLlJheS5wcm90b3R5cGUsIHtcclxuXHJcblx0c2V0OiBmdW5jdGlvbiAoIG9yaWdpbiwgZGlyZWN0aW9uICkge1xyXG5cclxuXHRcdHRoaXMub3JpZ2luLmNvcHkoIG9yaWdpbiApO1xyXG5cdFx0dGhpcy5kaXJlY3Rpb24uY29weSggZGlyZWN0aW9uICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggcmF5ICkge1xyXG5cclxuXHRcdHRoaXMub3JpZ2luLmNvcHkoIHJheS5vcmlnaW4gKTtcclxuXHRcdHRoaXMuZGlyZWN0aW9uLmNvcHkoIHJheS5kaXJlY3Rpb24gKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YXQ6IGZ1bmN0aW9uKCB0LCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMuZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMub3JpZ2luICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJlY2FzdDogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuXHRcdFx0dGhpcy5vcmlnaW4uY29weSggdGhpcy5hdCggdCwgdjEgKSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRjbG9zZXN0UG9pbnRUb1BvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHJlc3VsdC5zdWJWZWN0b3JzKCBwb2ludCwgdGhpcy5vcmlnaW4gKTtcclxuXHRcdHZhciBkaXJlY3Rpb25EaXN0YW5jZSA9IHJlc3VsdC5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCB0aGlzLmRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCBkaXJlY3Rpb25EaXN0YW5jZSApLmFkZCggdGhpcy5vcmlnaW4gKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHBvaW50ICkge1xyXG5cclxuXHRcdFx0dmFyIGRpcmVjdGlvbkRpc3RhbmNlID0gdjEuc3ViVmVjdG9ycyggcG9pbnQsIHRoaXMub3JpZ2luICkuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xyXG5cdFx0XHR2MS5jb3B5KCB0aGlzLmRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCBkaXJlY3Rpb25EaXN0YW5jZSApLmFkZCggdGhpcy5vcmlnaW4gKTtcclxuXHJcblx0XHRcdHJldHVybiB2MS5kaXN0YW5jZVRvKCBwb2ludCApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0aXNJbnRlcnNlY3Rpb25TcGhlcmU6IGZ1bmN0aW9uKCBzcGhlcmUgKSB7XHJcblxyXG5cdFx0cmV0dXJuICggdGhpcy5kaXN0YW5jZVRvUG9pbnQoIHNwaGVyZS5jZW50ZXIgKSA8PSBzcGhlcmUucmFkaXVzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGlzSW50ZXJzZWN0aW9uUGxhbmU6IGZ1bmN0aW9uICggcGxhbmUgKSB7XHJcblxyXG5cdFx0Ly8gY2hlY2sgaWYgdGhlIGxpbmUgYW5kIHBsYW5lIGFyZSBub24tcGVycGVuZGljdWxhciwgaWYgdGhleVxyXG5cdFx0Ly8gZXZlbnR1YWxseSB0aGV5IHdpbGwgaW50ZXJzZWN0LlxyXG5cdFx0dmFyIGRlbm9taW5hdG9yID0gcGxhbmUubm9ybWFsLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcclxuXHRcdGlmICggZGVub21pbmF0b3IgIT0gMCApIHtcclxuXHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBsaW5lIGlzIGNvcGxhbmFyLCByZXR1cm4gb3JpZ2luXHJcblx0XHRpZiggcGxhbmUuZGlzdGFuY2VUb1BvaW50KCB0aGlzLm9yaWdpbiApID09IDAgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXN0YW5jZVRvUGxhbmU6IGZ1bmN0aW9uICggcGxhbmUgKSB7XHJcblxyXG5cdFx0dmFyIGRlbm9taW5hdG9yID0gcGxhbmUubm9ybWFsLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcclxuXHRcdGlmICggZGVub21pbmF0b3IgPT0gMCApIHtcclxuXHJcblx0XHRcdC8vIGxpbmUgaXMgY29wbGFuYXIsIHJldHVybiBvcmlnaW5cclxuXHRcdFx0aWYoIHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggdGhpcy5vcmlnaW4gKSA9PSAwICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gMDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIFVuc3VyZSBpZiB0aGlzIGlzIHRoZSBjb3JyZWN0IG1ldGhvZCB0byBoYW5kbGUgdGhpcyBjYXNlLlxyXG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgdCA9IC0gKCB0aGlzLm9yaWdpbi5kb3QoIHBsYW5lLm5vcm1hbCApICsgcGxhbmUuY29uc3RhbnQgKSAvIGRlbm9taW5hdG9yO1xyXG5cclxuXHRcdHJldHVybiB0O1xyXG5cclxuXHR9LFxyXG5cclxuXHRpbnRlcnNlY3RQbGFuZTogZnVuY3Rpb24gKCBwbGFuZSwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIHQgPSB0aGlzLmRpc3RhbmNlVG9QbGFuZSggcGxhbmUgKTtcclxuXHJcblx0XHRpZiAoIHQgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYXQoIHQsIG9wdGlvbmFsVGFyZ2V0ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtYXRyaXg0ICkge1xyXG5cclxuXHRcdHRoaXMuZGlyZWN0aW9uLmFkZCggdGhpcy5vcmlnaW4gKS5hcHBseU1hdHJpeDQoIG1hdHJpeDQgKTtcclxuXHRcdHRoaXMub3JpZ2luLmFwcGx5TWF0cml4NCggbWF0cml4NCApO1xyXG5cdFx0dGhpcy5kaXJlY3Rpb24uc3ViKCB0aGlzLm9yaWdpbiApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGVxdWFsczogZnVuY3Rpb24gKCByYXkgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHJheS5vcmlnaW4uZXF1YWxzKCB0aGlzLm9yaWdpbiApICYmIHJheS5kaXJlY3Rpb24uZXF1YWxzKCB0aGlzLmRpcmVjdGlvbiApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgVEhSRUUuUmF5KCkuY29weSggdGhpcyApO1xyXG5cclxuXHR9XHJcblxyXG59ICk7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb21cclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5TcGhlcmUgPSBmdW5jdGlvbiAoIGNlbnRlciwgcmFkaXVzICkge1xyXG5cclxuXHR0aGlzLmNlbnRlciA9ICggY2VudGVyICE9PSB1bmRlZmluZWQgKSA/IGNlbnRlciA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dGhpcy5yYWRpdXMgPSAoIHJhZGl1cyAhPT0gdW5kZWZpbmVkICkgPyByYWRpdXMgOiAwO1xyXG5cclxufTtcclxuXHJcblRIUkVFLmV4dGVuZCggVEhSRUUuU3BoZXJlLnByb3RvdHlwZSwge1xyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggY2VudGVyLCByYWRpdXMgKSB7XHJcblxyXG5cdFx0dGhpcy5jZW50ZXIuY29weSggY2VudGVyICk7XHJcblx0XHR0aGlzLnJhZGl1cyA9IHJhZGl1cztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tQ2VudGVyQW5kUG9pbnRzOiBmdW5jdGlvbiAoIGNlbnRlciwgcG9pbnRzICkge1xyXG5cclxuXHRcdHZhciBtYXhSYWRpdXNTcSA9IDA7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciByYWRpdXNTcSA9IGNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnRzWyBpIF0gKTtcclxuXHRcdFx0bWF4UmFkaXVzU3EgPSBNYXRoLm1heCggbWF4UmFkaXVzU3EsIHJhZGl1c1NxICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuY2VudGVyID0gY2VudGVyO1xyXG5cdFx0dGhpcy5yYWRpdXMgPSBNYXRoLnNxcnQoIG1heFJhZGl1c1NxICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggc3BoZXJlICkge1xyXG5cclxuXHRcdHRoaXMuY2VudGVyLmNvcHkoIHNwaGVyZS5jZW50ZXIgKTtcclxuXHRcdHRoaXMucmFkaXVzID0gc3BoZXJlLnJhZGl1cztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZW1wdHk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gKCB0aGlzLnJhZGl1cyA8PSAwICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG5cdFx0cmV0dXJuICggcG9pbnQuZGlzdGFuY2VUb1NxdWFyZWQoIHRoaXMuY2VudGVyICkgPD0gKCB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzICkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xyXG5cclxuXHRcdHJldHVybiAoIHBvaW50LmRpc3RhbmNlVG8oIHRoaXMuY2VudGVyICkgLSB0aGlzLnJhZGl1cyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpbnRlcnNlY3RzU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcclxuXHJcblx0XHR2YXIgcmFkaXVzU3VtID0gdGhpcy5yYWRpdXMgKyBzcGhlcmUucmFkaXVzO1xyXG5cclxuXHRcdHJldHVybiBzcGhlcmUuY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCB0aGlzLmNlbnRlciApIDw9ICggcmFkaXVzU3VtICogcmFkaXVzU3VtICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsYW1wUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciBkZWx0YUxlbmd0aFNxID0gdGhpcy5jZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50ICk7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRyZXN1bHQuY29weSggcG9pbnQgKTtcclxuXHJcblx0XHRpZiAoIGRlbHRhTGVuZ3RoU3EgPiAoIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMgKSApIHtcclxuXHJcblx0XHRcdHJlc3VsdC5zdWIoIHRoaXMuY2VudGVyICkubm9ybWFsaXplKCk7XHJcblx0XHRcdHJlc3VsdC5tdWx0aXBseVNjYWxhciggdGhpcy5yYWRpdXMgKS5hZGQoIHRoaXMuY2VudGVyICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldEJvdW5kaW5nQm94OiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciBib3ggPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuQm94MygpO1xyXG5cclxuXHRcdGJveC5zZXQoIHRoaXMuY2VudGVyLCB0aGlzLmNlbnRlciApO1xyXG5cdFx0Ym94LmV4cGFuZEJ5U2NhbGFyKCB0aGlzLnJhZGl1cyApO1xyXG5cclxuXHRcdHJldHVybiBib3g7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XHJcblxyXG5cdFx0dGhpcy5jZW50ZXIuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcclxuXHRcdHRoaXMucmFkaXVzID0gdGhpcy5yYWRpdXMgKiBtYXRyaXguZ2V0TWF4U2NhbGVPbkF4aXMoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoIG9mZnNldCApIHtcclxuXHJcblx0XHR0aGlzLmNlbnRlci5hZGQoIG9mZnNldCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uICggc3BoZXJlICkge1xyXG5cclxuXHRcdHJldHVybiBzcGhlcmUuY2VudGVyLmVxdWFscyggdGhpcy5jZW50ZXIgKSAmJiAoIHNwaGVyZS5yYWRpdXMgPT09IHRoaXMucmFkaXVzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5TcGhlcmUoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdH1cclxuXHJcbn0gKTtcclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxyXG4gKi9cclxuXHJcblRIUkVFLkZydXN0dW0gPSBmdW5jdGlvbiAoIHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUgKSB7XHJcblxyXG5cdHRoaXMucGxhbmVzID0gW1xyXG5cclxuXHRcdCggcDAgIT09IHVuZGVmaW5lZCApID8gcDAgOiBuZXcgVEhSRUUuUGxhbmUoKSxcclxuXHRcdCggcDEgIT09IHVuZGVmaW5lZCApID8gcDEgOiBuZXcgVEhSRUUuUGxhbmUoKSxcclxuXHRcdCggcDIgIT09IHVuZGVmaW5lZCApID8gcDIgOiBuZXcgVEhSRUUuUGxhbmUoKSxcclxuXHRcdCggcDMgIT09IHVuZGVmaW5lZCApID8gcDMgOiBuZXcgVEhSRUUuUGxhbmUoKSxcclxuXHRcdCggcDQgIT09IHVuZGVmaW5lZCApID8gcDQgOiBuZXcgVEhSRUUuUGxhbmUoKSxcclxuXHRcdCggcDUgIT09IHVuZGVmaW5lZCApID8gcDUgOiBuZXcgVEhSRUUuUGxhbmUoKVxyXG5cclxuXHRdO1xyXG5cclxufTtcclxuXHJcblRIUkVFLmV4dGVuZCggVEhSRUUuRnJ1c3R1bS5wcm90b3R5cGUsIHtcclxuXHJcblx0c2V0OiBmdW5jdGlvbiAoIHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUgKSB7XHJcblxyXG5cdFx0dmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xyXG5cclxuXHRcdHBsYW5lc1swXS5jb3B5KCBwMCApO1xyXG5cdFx0cGxhbmVzWzFdLmNvcHkoIHAxICk7XHJcblx0XHRwbGFuZXNbMl0uY29weSggcDIgKTtcclxuXHRcdHBsYW5lc1szXS5jb3B5KCBwMyApO1xyXG5cdFx0cGxhbmVzWzRdLmNvcHkoIHA0ICk7XHJcblx0XHRwbGFuZXNbNV0uY29weSggcDUgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBmcnVzdHVtICkge1xyXG5cclxuXHRcdHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcclxuXHJcblx0XHRmb3IoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRwbGFuZXNbaV0uY29weSggZnJ1c3R1bS5wbGFuZXNbaV0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHR2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XHJcblx0XHR2YXIgbWUgPSBtLmVsZW1lbnRzO1xyXG5cdFx0dmFyIG1lMCA9IG1lWzBdLCBtZTEgPSBtZVsxXSwgbWUyID0gbWVbMl0sIG1lMyA9IG1lWzNdO1xyXG5cdFx0dmFyIG1lNCA9IG1lWzRdLCBtZTUgPSBtZVs1XSwgbWU2ID0gbWVbNl0sIG1lNyA9IG1lWzddO1xyXG5cdFx0dmFyIG1lOCA9IG1lWzhdLCBtZTkgPSBtZVs5XSwgbWUxMCA9IG1lWzEwXSwgbWUxMSA9IG1lWzExXTtcclxuXHRcdHZhciBtZTEyID0gbWVbMTJdLCBtZTEzID0gbWVbMTNdLCBtZTE0ID0gbWVbMTRdLCBtZTE1ID0gbWVbMTVdO1xyXG5cclxuXHRcdHBsYW5lc1sgMCBdLnNldENvbXBvbmVudHMoIG1lMyAtIG1lMCwgbWU3IC0gbWU0LCBtZTExIC0gbWU4LCBtZTE1IC0gbWUxMiApLm5vcm1hbGl6ZSgpO1xyXG5cdFx0cGxhbmVzWyAxIF0uc2V0Q29tcG9uZW50cyggbWUzICsgbWUwLCBtZTcgKyBtZTQsIG1lMTEgKyBtZTgsIG1lMTUgKyBtZTEyICkubm9ybWFsaXplKCk7XHJcblx0XHRwbGFuZXNbIDIgXS5zZXRDb21wb25lbnRzKCBtZTMgKyBtZTEsIG1lNyArIG1lNSwgbWUxMSArIG1lOSwgbWUxNSArIG1lMTMgKS5ub3JtYWxpemUoKTtcclxuXHRcdHBsYW5lc1sgMyBdLnNldENvbXBvbmVudHMoIG1lMyAtIG1lMSwgbWU3IC0gbWU1LCBtZTExIC0gbWU5LCBtZTE1IC0gbWUxMyApLm5vcm1hbGl6ZSgpO1xyXG5cdFx0cGxhbmVzWyA0IF0uc2V0Q29tcG9uZW50cyggbWUzIC0gbWUyLCBtZTcgLSBtZTYsIG1lMTEgLSBtZTEwLCBtZTE1IC0gbWUxNCApLm5vcm1hbGl6ZSgpO1xyXG5cdFx0cGxhbmVzWyA1IF0uc2V0Q29tcG9uZW50cyggbWUzICsgbWUyLCBtZTcgKyBtZTYsIG1lMTEgKyBtZTEwLCBtZTE1ICsgbWUxNCApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRpbnRlcnNlY3RzT2JqZWN0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGNlbnRlciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuXHRcdFx0Ly8gdGhpcyBtZXRob2QgaXMgZXhwYW5kZWQgaW5saW5lZCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy5cclxuXHJcblx0XHRcdHZhciBtYXRyaXggPSBvYmplY3QubWF0cml4V29ybGQ7XHJcblx0XHRcdHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcclxuXHRcdFx0dmFyIG5lZ1JhZGl1cyA9IC0gb2JqZWN0Lmdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlLnJhZGl1cyAqIG1hdHJpeC5nZXRNYXhTY2FsZU9uQXhpcygpO1xyXG5cclxuXHRcdFx0Y2VudGVyLmdldFBvc2l0aW9uRnJvbU1hdHJpeCggbWF0cml4ICk7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgZGlzdGFuY2UgPSBwbGFuZXNbIGkgXS5kaXN0YW5jZVRvUG9pbnQoIGNlbnRlciApO1xyXG5cclxuXHRcdFx0XHRpZiAoIGRpc3RhbmNlIDwgbmVnUmFkaXVzICkge1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRpbnRlcnNlY3RzU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcclxuXHJcblx0XHR2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XHJcblx0XHR2YXIgY2VudGVyID0gc3BoZXJlLmNlbnRlcjtcclxuXHRcdHZhciBuZWdSYWRpdXMgPSAtc3BoZXJlLnJhZGl1cztcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGRpc3RhbmNlID0gcGxhbmVzWyBpIF0uZGlzdGFuY2VUb1BvaW50KCBjZW50ZXIgKTtcclxuXHJcblx0XHRcdGlmICggZGlzdGFuY2UgPCBuZWdSYWRpdXMgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG5cdFx0dmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHBsYW5lc1sgaSBdLmRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKSA8IDAgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5GcnVzdHVtKCkuY29weSggdGhpcyApO1xyXG5cclxuXHR9XHJcblxyXG59ICk7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb21cclxuICovXHJcblxyXG5USFJFRS5QbGFuZSA9IGZ1bmN0aW9uICggbm9ybWFsLCBjb25zdGFudCApIHtcclxuXHJcblx0dGhpcy5ub3JtYWwgPSAoIG5vcm1hbCAhPT0gdW5kZWZpbmVkICkgPyBub3JtYWwgOiBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMCwgMCApO1xyXG5cdHRoaXMuY29uc3RhbnQgPSAoIGNvbnN0YW50ICE9PSB1bmRlZmluZWQgKSA/IGNvbnN0YW50IDogMDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5leHRlbmQoIFRIUkVFLlBsYW5lLnByb3RvdHlwZSwge1xyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggbm9ybWFsLCBjb25zdGFudCApIHtcclxuXHJcblx0XHR0aGlzLm5vcm1hbC5jb3B5KCBub3JtYWwgKTtcclxuXHRcdHRoaXMuY29uc3RhbnQgPSBjb25zdGFudDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0Q29tcG9uZW50czogZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xyXG5cclxuXHRcdHRoaXMubm9ybWFsLnNldCggeCwgeSwgeiApO1xyXG5cdFx0dGhpcy5jb25zdGFudCA9IHc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50OiBmdW5jdGlvbiAoIG5vcm1hbCwgcG9pbnQgKSB7XHJcblxyXG5cdFx0dGhpcy5ub3JtYWwuY29weSggbm9ybWFsICk7XHJcblx0XHR0aGlzLmNvbnN0YW50ID0gLSBwb2ludC5kb3QoIHRoaXMubm9ybWFsICk7XHQvLyBtdXN0IGJlIHRoaXMubm9ybWFsLCBub3Qgbm9ybWFsLCBhcyB0aGlzLm5vcm1hbCBpcyBub3JtYWxpemVkXHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21Db3BsYW5hclBvaW50czogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHZhciB2MiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYSwgYiwgYyApIHtcclxuXHJcblx0XHRcdHZhciBub3JtYWwgPSB2MS5zdWJWZWN0b3JzKCBjLCBiICkuY3Jvc3MoIHYyLnN1YlZlY3RvcnMoIGEsIGIgKSApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0Ly8gUTogc2hvdWxkIGFuIGVycm9yIGJlIHRocm93biBpZiBub3JtYWwgaXMgemVybyAoZS5nLiBkZWdlbmVyYXRlIHBsYW5lKT9cclxuXHJcblx0XHRcdHRoaXMuc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQoIG5vcm1hbCwgYSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBwbGFuZSApIHtcclxuXHJcblx0XHR0aGlzLm5vcm1hbC5jb3B5KCBwbGFuZS5ub3JtYWwgKTtcclxuXHRcdHRoaXMuY29uc3RhbnQgPSBwbGFuZS5jb25zdGFudDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gTm90ZTogd2lsbCBsZWFkIHRvIGEgZGl2aWRlIGJ5IHplcm8gaWYgdGhlIHBsYW5lIGlzIGludmFsaWQuXHJcblxyXG5cdFx0dmFyIGludmVyc2VOb3JtYWxMZW5ndGggPSAxLjAgLyB0aGlzLm5vcm1hbC5sZW5ndGgoKTtcclxuXHRcdHRoaXMubm9ybWFsLm11bHRpcGx5U2NhbGFyKCBpbnZlcnNlTm9ybWFsTGVuZ3RoICk7XHJcblx0XHR0aGlzLmNvbnN0YW50ICo9IGludmVyc2VOb3JtYWxMZW5ndGg7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuY29uc3RhbnQgKj0gLTE7XHJcblx0XHR0aGlzLm5vcm1hbC5uZWdhdGUoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm5vcm1hbC5kb3QoIHBvaW50ICkgKyB0aGlzLmNvbnN0YW50O1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXN0YW5jZVRvU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIHNwaGVyZS5jZW50ZXIgKSAtIHNwaGVyZS5yYWRpdXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHByb2plY3RQb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMub3J0aG9Qb2ludCggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkuc3ViKCBwb2ludCApLm5lZ2F0ZSgpO1xyXG5cclxuXHR9LFxyXG5cclxuXHRvcnRob1BvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgcGVycGVuZGljdWxhck1hZ25pdHVkZSA9IHRoaXMuZGlzdGFuY2VUb1BvaW50KCBwb2ludCApO1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCB0aGlzLm5vcm1hbCApLm11bHRpcGx5U2NhbGFyKCBwZXJwZW5kaWN1bGFyTWFnbml0dWRlICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGlzSW50ZXJzZWN0aW9uTGluZTogZnVuY3Rpb24gKCBsaW5lICkge1xyXG5cclxuXHRcdC8vIE5vdGU6IHRoaXMgdGVzdHMgaWYgYSBsaW5lIGludGVyc2VjdHMgdGhlIHBsYW5lLCBub3Qgd2hldGhlciBpdCAob3IgaXRzIGVuZC1wb2ludHMpIGFyZSBjb3BsYW5hciB3aXRoIGl0LlxyXG5cclxuXHRcdHZhciBzdGFydFNpZ24gPSB0aGlzLmRpc3RhbmNlVG9Qb2ludCggbGluZS5zdGFydCApO1xyXG5cdFx0dmFyIGVuZFNpZ24gPSB0aGlzLmRpc3RhbmNlVG9Qb2ludCggbGluZS5lbmQgKTtcclxuXHJcblx0XHRyZXR1cm4gKCBzdGFydFNpZ24gPCAwICYmIGVuZFNpZ24gPiAwICkgfHwgKCBlbmRTaWduIDwgMCAmJiBzdGFydFNpZ24gPiAwICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGludGVyc2VjdExpbmU6IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggbGluZSwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRcdHZhciBkaXJlY3Rpb24gPSBsaW5lLmRlbHRhKCB2MSApO1xyXG5cclxuXHRcdFx0dmFyIGRlbm9taW5hdG9yID0gdGhpcy5ub3JtYWwuZG90KCBkaXJlY3Rpb24gKTtcclxuXHJcblx0XHRcdGlmICggZGVub21pbmF0b3IgPT0gMCApIHtcclxuXHJcblx0XHRcdFx0Ly8gbGluZSBpcyBjb3BsYW5hciwgcmV0dXJuIG9yaWdpblxyXG5cdFx0XHRcdGlmKCB0aGlzLmRpc3RhbmNlVG9Qb2ludCggbGluZS5zdGFydCApID09IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCBsaW5lLnN0YXJ0ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gVW5zdXJlIGlmIHRoaXMgaXMgdGhlIGNvcnJlY3QgbWV0aG9kIHRvIGhhbmRsZSB0aGlzIGNhc2UuXHJcblx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciB0ID0gLSAoIGxpbmUuc3RhcnQuZG90KCB0aGlzLm5vcm1hbCApICsgdGhpcy5jb25zdGFudCApIC8gZGVub21pbmF0b3I7XHJcblxyXG5cdFx0XHRpZiggdCA8IDAgfHwgdCA+IDEgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIGRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCBsaW5lLnN0YXJ0ICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHJcblx0Y29wbGFuYXJQb2ludDogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHJldHVybiByZXN1bHQuY29weSggdGhpcy5ub3JtYWwgKS5tdWx0aXBseVNjYWxhciggLSB0aGlzLmNvbnN0YW50ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHZhciB2MiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggbWF0cml4LCBvcHRpb25hbE5vcm1hbE1hdHJpeCApIHtcclxuXHJcblx0XHRcdC8vIGNvbXB1dGUgbmV3IG5vcm1hbCBiYXNlZCBvbiB0aGVvcnkgaGVyZTpcclxuXHRcdFx0Ly8gaHR0cDovL3d3dy5zb25naG8uY2Evb3BlbmdsL2dsX25vcm1hbHRyYW5zZm9ybS5odG1sXHJcblx0XHRcdG9wdGlvbmFsTm9ybWFsTWF0cml4ID0gb3B0aW9uYWxOb3JtYWxNYXRyaXggfHwgbmV3IFRIUkVFLk1hdHJpeDMoKS5nZXRJbnZlcnNlKCBtYXRyaXggKS50cmFuc3Bvc2UoKTtcclxuXHRcdFx0dmFyIG5ld05vcm1hbCA9IHYxLmNvcHkoIHRoaXMubm9ybWFsICkuYXBwbHlNYXRyaXgzKCBvcHRpb25hbE5vcm1hbE1hdHJpeCApO1xyXG5cclxuXHRcdFx0dmFyIG5ld0NvcGxhbmFyUG9pbnQgPSB0aGlzLmNvcGxhbmFyUG9pbnQoIHYyICk7XHJcblx0XHRcdG5ld0NvcGxhbmFyUG9pbnQuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcclxuXHJcblx0XHRcdHRoaXMuc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQoIG5ld05vcm1hbCwgbmV3Q29wbGFuYXJQb2ludCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHR0cmFuc2xhdGU6IGZ1bmN0aW9uICggb2Zmc2V0ICkge1xyXG5cclxuXHRcdHRoaXMuY29uc3RhbnQgPSB0aGlzLmNvbnN0YW50IC0gb2Zmc2V0LmRvdCggdGhpcy5ub3JtYWwgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAoIHBsYW5lICkge1xyXG5cclxuXHRcdHJldHVybiBwbGFuZS5ub3JtYWwuZXF1YWxzKCB0aGlzLm5vcm1hbCApICYmICggcGxhbmUuY29uc3RhbnQgPT0gdGhpcy5jb25zdGFudCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgVEhSRUUuUGxhbmUoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdH1cclxuXHJcbn0gKTtcclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTWF0aCA9IHtcclxuXHJcblx0Ly8gQ2xhbXAgdmFsdWUgdG8gcmFuZ2UgPGEsIGI+XHJcblxyXG5cdGNsYW1wOiBmdW5jdGlvbiAoIHgsIGEsIGIgKSB7XHJcblxyXG5cdFx0cmV0dXJuICggeCA8IGEgKSA/IGEgOiAoICggeCA+IGIgKSA/IGIgOiB4ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIENsYW1wIHZhbHVlIHRvIHJhbmdlIDxhLCBpbmYpXHJcblxyXG5cdGNsYW1wQm90dG9tOiBmdW5jdGlvbiAoIHgsIGEgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHggPCBhID8gYSA6IHg7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIExpbmVhciBtYXBwaW5nIGZyb20gcmFuZ2UgPGExLCBhMj4gdG8gcmFuZ2UgPGIxLCBiMj5cclxuXHJcblx0bWFwTGluZWFyOiBmdW5jdGlvbiAoIHgsIGExLCBhMiwgYjEsIGIyICkge1xyXG5cclxuXHRcdHJldHVybiBiMSArICggeCAtIGExICkgKiAoIGIyIC0gYjEgKSAvICggYTIgLSBhMSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Ntb290aHN0ZXBcclxuXHJcblx0c21vb3Roc3RlcDogZnVuY3Rpb24gKCB4LCBtaW4sIG1heCApIHtcclxuXHJcblx0XHRpZiAoIHggPD0gbWluICkgcmV0dXJuIDA7XHJcblx0XHRpZiAoIHggPj0gbWF4ICkgcmV0dXJuIDE7XHJcblxyXG5cdFx0eCA9ICggeCAtIG1pbiApLyggbWF4IC0gbWluICk7XHJcblxyXG5cdFx0cmV0dXJuIHgqeCooMyAtIDIqeCk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNtb290aGVyc3RlcDogZnVuY3Rpb24gKCB4LCBtaW4sIG1heCApIHtcclxuXHJcblx0XHRpZiAoIHggPD0gbWluICkgcmV0dXJuIDA7XHJcblx0XHRpZiAoIHggPj0gbWF4ICkgcmV0dXJuIDE7XHJcblxyXG5cdFx0eCA9ICggeCAtIG1pbiApLyggbWF4IC0gbWluICk7XHJcblxyXG5cdFx0cmV0dXJuIHgqeCp4Kih4Kih4KjYgLSAxNSkgKyAxMCk7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIFJhbmRvbSBmbG9hdCBmcm9tIDwwLCAxPiB3aXRoIDE2IGJpdHMgb2YgcmFuZG9tbmVzc1xyXG5cdC8vIChzdGFuZGFyZCBNYXRoLnJhbmRvbSgpIGNyZWF0ZXMgcmVwZXRpdGl2ZSBwYXR0ZXJucyB3aGVuIGFwcGxpZWQgb3ZlciBsYXJnZXIgc3BhY2UpXHJcblxyXG5cdHJhbmRvbTE2OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuICggNjUyODAgKiBNYXRoLnJhbmRvbSgpICsgMjU1ICogTWF0aC5yYW5kb20oKSApIC8gNjU1MzU7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIFJhbmRvbSBpbnRlZ2VyIGZyb20gPGxvdywgaGlnaD4gaW50ZXJ2YWxcclxuXHJcblx0cmFuZEludDogZnVuY3Rpb24gKCBsb3csIGhpZ2ggKSB7XHJcblxyXG5cdFx0cmV0dXJuIGxvdyArIE1hdGguZmxvb3IoIE1hdGgucmFuZG9tKCkgKiAoIGhpZ2ggLSBsb3cgKyAxICkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gUmFuZG9tIGZsb2F0IGZyb20gPGxvdywgaGlnaD4gaW50ZXJ2YWxcclxuXHJcblx0cmFuZEZsb2F0OiBmdW5jdGlvbiAoIGxvdywgaGlnaCApIHtcclxuXHJcblx0XHRyZXR1cm4gbG93ICsgTWF0aC5yYW5kb20oKSAqICggaGlnaCAtIGxvdyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBSYW5kb20gZmxvYXQgZnJvbSA8LXJhbmdlLzIsIHJhbmdlLzI+IGludGVydmFsXHJcblxyXG5cdHJhbmRGbG9hdFNwcmVhZDogZnVuY3Rpb24gKCByYW5nZSApIHtcclxuXHJcblx0XHRyZXR1cm4gcmFuZ2UgKiAoIDAuNSAtIE1hdGgucmFuZG9tKCkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0c2lnbjogZnVuY3Rpb24gKCB4ICkge1xyXG5cclxuXHRcdHJldHVybiAoIHggPCAwICkgPyAtMSA6ICggKCB4ID4gMCApID8gMSA6IDAgKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZGVnVG9SYWQ6IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdHZhciBkZWdyZWVUb1JhZGlhbnNGYWN0b3IgPSBNYXRoLlBJIC8gMTgwO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGRlZ3JlZXMgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gZGVncmVlcyAqIGRlZ3JlZVRvUmFkaWFuc0ZhY3RvcjtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHJhZFRvRGVnOiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR2YXIgcmFkaWFuVG9EZWdyZWVzRmFjdG9yID0gMTgwIC8gTWF0aC5QSTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCByYWRpYW5zICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHJhZGlhbnMgKiByYWRpYW5Ub0RlZ3JlZXNGYWN0b3I7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpXHJcblxyXG59O1xyXG4vKipcclxuICogU3BsaW5lIGZyb20gVHdlZW4uanMsIHNsaWdodGx5IG9wdGltaXplZCAoYW5kIHRyYXNoZWQpXHJcbiAqIGh0dHA6Ly9zb2xlLmdpdGh1Yi5jb20vdHdlZW4uanMvZXhhbXBsZXMvMDVfc3BsaW5lLmh0bWxcclxuICpcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5TcGxpbmUgPSBmdW5jdGlvbiAoIHBvaW50cyApIHtcclxuXHJcblx0dGhpcy5wb2ludHMgPSBwb2ludHM7XHJcblxyXG5cdHZhciBjID0gW10sIHYzID0geyB4OiAwLCB5OiAwLCB6OiAwIH0sXHJcblx0cG9pbnQsIGludFBvaW50LCB3ZWlnaHQsIHcyLCB3MyxcclxuXHRwYSwgcGIsIHBjLCBwZDtcclxuXHJcblx0dGhpcy5pbml0RnJvbUFycmF5ID0gZnVuY3Rpb24oIGEgKSB7XHJcblxyXG5cdFx0dGhpcy5wb2ludHMgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrICkge1xyXG5cclxuXHRcdFx0dGhpcy5wb2ludHNbIGkgXSA9IHsgeDogYVsgaSBdWyAwIF0sIHk6IGFbIGkgXVsgMSBdLCB6OiBhWyBpIF1bIDIgXSB9O1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5nZXRQb2ludCA9IGZ1bmN0aW9uICggayApIHtcclxuXHJcblx0XHRwb2ludCA9ICggdGhpcy5wb2ludHMubGVuZ3RoIC0gMSApICogaztcclxuXHRcdGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcclxuXHRcdHdlaWdodCA9IHBvaW50IC0gaW50UG9pbnQ7XHJcblxyXG5cdFx0Y1sgMCBdID0gaW50UG9pbnQgPT09IDAgPyBpbnRQb2ludCA6IGludFBvaW50IC0gMTtcclxuXHRcdGNbIDEgXSA9IGludFBvaW50O1xyXG5cdFx0Y1sgMiBdID0gaW50UG9pbnQgID4gdGhpcy5wb2ludHMubGVuZ3RoIC0gMiA/IHRoaXMucG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDE7XHJcblx0XHRjWyAzIF0gPSBpbnRQb2ludCAgPiB0aGlzLnBvaW50cy5sZW5ndGggLSAzID8gdGhpcy5wb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMjtcclxuXHJcblx0XHRwYSA9IHRoaXMucG9pbnRzWyBjWyAwIF0gXTtcclxuXHRcdHBiID0gdGhpcy5wb2ludHNbIGNbIDEgXSBdO1xyXG5cdFx0cGMgPSB0aGlzLnBvaW50c1sgY1sgMiBdIF07XHJcblx0XHRwZCA9IHRoaXMucG9pbnRzWyBjWyAzIF0gXTtcclxuXHJcblx0XHR3MiA9IHdlaWdodCAqIHdlaWdodDtcclxuXHRcdHczID0gd2VpZ2h0ICogdzI7XHJcblxyXG5cdFx0djMueCA9IGludGVycG9sYXRlKCBwYS54LCBwYi54LCBwYy54LCBwZC54LCB3ZWlnaHQsIHcyLCB3MyApO1xyXG5cdFx0djMueSA9IGludGVycG9sYXRlKCBwYS55LCBwYi55LCBwYy55LCBwZC55LCB3ZWlnaHQsIHcyLCB3MyApO1xyXG5cdFx0djMueiA9IGludGVycG9sYXRlKCBwYS56LCBwYi56LCBwYy56LCBwZC56LCB3ZWlnaHQsIHcyLCB3MyApO1xyXG5cclxuXHRcdHJldHVybiB2MztcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5nZXRDb250cm9sUG9pbnRzQXJyYXkgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGksIHAsIGwgPSB0aGlzLnBvaW50cy5sZW5ndGgsXHJcblx0XHRcdGNvb3JkcyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIGkgPSAwOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHAgPSB0aGlzLnBvaW50c1sgaSBdO1xyXG5cdFx0XHRjb29yZHNbIGkgXSA9IFsgcC54LCBwLnksIHAueiBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gY29vcmRzO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBhcHByb3hpbWF0ZSBsZW5ndGggYnkgc3VtbWluZyBsaW5lYXIgc2VnbWVudHNcclxuXHJcblx0dGhpcy5nZXRMZW5ndGggPSBmdW5jdGlvbiAoIG5TdWJEaXZpc2lvbnMgKSB7XHJcblxyXG5cdFx0dmFyIGksIGluZGV4LCBuU2FtcGxlcywgcG9zaXRpb24sXHJcblx0XHRcdHBvaW50ID0gMCwgaW50UG9pbnQgPSAwLCBvbGRJbnRQb2ludCA9IDAsXHJcblx0XHRcdG9sZFBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0dG1wVmVjID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0Y2h1bmtMZW5ndGhzID0gW10sXHJcblx0XHRcdHRvdGFsTGVuZ3RoID0gMDtcclxuXHJcblx0XHQvLyBmaXJzdCBwb2ludCBoYXMgMCBsZW5ndGhcclxuXHJcblx0XHRjaHVua0xlbmd0aHNbIDAgXSA9IDA7XHJcblxyXG5cdFx0aWYgKCAhblN1YkRpdmlzaW9ucyApIG5TdWJEaXZpc2lvbnMgPSAxMDA7XHJcblxyXG5cdFx0blNhbXBsZXMgPSB0aGlzLnBvaW50cy5sZW5ndGggKiBuU3ViRGl2aXNpb25zO1xyXG5cclxuXHRcdG9sZFBvc2l0aW9uLmNvcHkoIHRoaXMucG9pbnRzWyAwIF0gKTtcclxuXHJcblx0XHRmb3IgKCBpID0gMTsgaSA8IG5TYW1wbGVzOyBpICsrICkge1xyXG5cclxuXHRcdFx0aW5kZXggPSBpIC8gblNhbXBsZXM7XHJcblxyXG5cdFx0XHRwb3NpdGlvbiA9IHRoaXMuZ2V0UG9pbnQoIGluZGV4ICk7XHJcblx0XHRcdHRtcFZlYy5jb3B5KCBwb3NpdGlvbiApO1xyXG5cclxuXHRcdFx0dG90YWxMZW5ndGggKz0gdG1wVmVjLmRpc3RhbmNlVG8oIG9sZFBvc2l0aW9uICk7XHJcblxyXG5cdFx0XHRvbGRQb3NpdGlvbi5jb3B5KCBwb3NpdGlvbiApO1xyXG5cclxuXHRcdFx0cG9pbnQgPSAoIHRoaXMucG9pbnRzLmxlbmd0aCAtIDEgKSAqIGluZGV4O1xyXG5cdFx0XHRpbnRQb2ludCA9IE1hdGguZmxvb3IoIHBvaW50ICk7XHJcblxyXG5cdFx0XHRpZiAoIGludFBvaW50ICE9IG9sZEludFBvaW50ICkge1xyXG5cclxuXHRcdFx0XHRjaHVua0xlbmd0aHNbIGludFBvaW50IF0gPSB0b3RhbExlbmd0aDtcclxuXHRcdFx0XHRvbGRJbnRQb2ludCA9IGludFBvaW50O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBsYXN0IHBvaW50IGVuZHMgd2l0aCB0b3RhbCBsZW5ndGhcclxuXHJcblx0XHRjaHVua0xlbmd0aHNbIGNodW5rTGVuZ3Rocy5sZW5ndGggXSA9IHRvdGFsTGVuZ3RoO1xyXG5cclxuXHRcdHJldHVybiB7IGNodW5rczogY2h1bmtMZW5ndGhzLCB0b3RhbDogdG90YWxMZW5ndGggfTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5yZXBhcmFtZXRyaXplQnlBcmNMZW5ndGggPSBmdW5jdGlvbiAoIHNhbXBsaW5nQ29lZiApIHtcclxuXHJcblx0XHR2YXIgaSwgaixcclxuXHRcdFx0aW5kZXgsIGluZGV4Q3VycmVudCwgaW5kZXhOZXh0LFxyXG5cdFx0XHRsaW5lYXJEaXN0YW5jZSwgcmVhbERpc3RhbmNlLFxyXG5cdFx0XHRzYW1wbGluZywgcG9zaXRpb24sXHJcblx0XHRcdG5ld3BvaW50cyA9IFtdLFxyXG5cdFx0XHR0bXBWZWMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0XHRzbCA9IHRoaXMuZ2V0TGVuZ3RoKCk7XHJcblxyXG5cdFx0bmV3cG9pbnRzLnB1c2goIHRtcFZlYy5jb3B5KCB0aGlzLnBvaW50c1sgMCBdICkuY2xvbmUoKSApO1xyXG5cclxuXHRcdGZvciAoIGkgPSAxOyBpIDwgdGhpcy5wb2ludHMubGVuZ3RoOyBpKysgKSB7XHJcblxyXG5cdFx0XHQvL3RtcFZlYy5jb3B5KCB0aGlzLnBvaW50c1sgaSAtIDEgXSApO1xyXG5cdFx0XHQvL2xpbmVhckRpc3RhbmNlID0gdG1wVmVjLmRpc3RhbmNlVG8oIHRoaXMucG9pbnRzWyBpIF0gKTtcclxuXHJcblx0XHRcdHJlYWxEaXN0YW5jZSA9IHNsLmNodW5rc1sgaSBdIC0gc2wuY2h1bmtzWyBpIC0gMSBdO1xyXG5cclxuXHRcdFx0c2FtcGxpbmcgPSBNYXRoLmNlaWwoIHNhbXBsaW5nQ29lZiAqIHJlYWxEaXN0YW5jZSAvIHNsLnRvdGFsICk7XHJcblxyXG5cdFx0XHRpbmRleEN1cnJlbnQgPSAoIGkgLSAxICkgLyAoIHRoaXMucG9pbnRzLmxlbmd0aCAtIDEgKTtcclxuXHRcdFx0aW5kZXhOZXh0ID0gaSAvICggdGhpcy5wb2ludHMubGVuZ3RoIC0gMSApO1xyXG5cclxuXHRcdFx0Zm9yICggaiA9IDE7IGogPCBzYW1wbGluZyAtIDE7IGorKyApIHtcclxuXHJcblx0XHRcdFx0aW5kZXggPSBpbmRleEN1cnJlbnQgKyBqICogKCAxIC8gc2FtcGxpbmcgKSAqICggaW5kZXhOZXh0IC0gaW5kZXhDdXJyZW50ICk7XHJcblxyXG5cdFx0XHRcdHBvc2l0aW9uID0gdGhpcy5nZXRQb2ludCggaW5kZXggKTtcclxuXHRcdFx0XHRuZXdwb2ludHMucHVzaCggdG1wVmVjLmNvcHkoIHBvc2l0aW9uICkuY2xvbmUoKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bmV3cG9pbnRzLnB1c2goIHRtcFZlYy5jb3B5KCB0aGlzLnBvaW50c1sgaSBdICkuY2xvbmUoKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnBvaW50cyA9IG5ld3BvaW50cztcclxuXHJcblx0fTtcclxuXHJcblx0Ly8gQ2F0bXVsbC1Sb21cclxuXHJcblx0ZnVuY3Rpb24gaW50ZXJwb2xhdGUoIHAwLCBwMSwgcDIsIHAzLCB0LCB0MiwgdDMgKSB7XHJcblxyXG5cdFx0dmFyIHYwID0gKCBwMiAtIHAwICkgKiAwLjUsXHJcblx0XHRcdHYxID0gKCBwMyAtIHAxICkgKiAwLjU7XHJcblxyXG5cdFx0cmV0dXJuICggMiAqICggcDEgLSBwMiApICsgdjAgKyB2MSApICogdDMgKyAoIC0gMyAqICggcDEgLSBwMiApIC0gMiAqIHYwIC0gdjEgKSAqIHQyICsgdjAgKiB0ICsgcDE7XHJcblxyXG5cdH07XHJcblxyXG59O1xyXG4vKipcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuVHJpYW5nbGUgPSBmdW5jdGlvbiAoIGEsIGIsIGMgKSB7XHJcblxyXG5cdHRoaXMuYSA9ICggYSAhPT0gdW5kZWZpbmVkICkgPyBhIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR0aGlzLmIgPSAoIGIgIT09IHVuZGVmaW5lZCApID8gYiA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dGhpcy5jID0gKCBjICE9PSB1bmRlZmluZWQgKSA/IGMgOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlRyaWFuZ2xlLm5vcm1hbCA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHR2YXIgdjAgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24oIGEsIGIsIGMsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJlc3VsdC5zdWJWZWN0b3JzKCBjLCBiICk7XHJcblx0XHR2MC5zdWJWZWN0b3JzKCBhLCBiICk7XHJcblx0XHRyZXN1bHQuY3Jvc3MoIHYwICk7XHJcblxyXG5cdFx0dmFyIHJlc3VsdExlbmd0aFNxID0gcmVzdWx0Lmxlbmd0aFNxKCk7XHJcblx0XHRpZiggcmVzdWx0TGVuZ3RoU3EgPiAwICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHJlc3VsdC5tdWx0aXBseVNjYWxhciggMSAvIE1hdGguc3FydCggcmVzdWx0TGVuZ3RoU3EgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0LnNldCggMCwgMCwgMCApO1xyXG5cclxuXHR9O1xyXG5cclxufSgpO1xyXG5cclxuLy8gc3RhdGljL2luc3RhbmNlIG1ldGhvZCB0byBjYWxjdWxhdGUgYmFyeWNvb3JkaW5hdGVzXHJcbi8vIGJhc2VkIG9uOiBodHRwOi8vd3d3LmJsYWNrcGF3bi5jb20vdGV4dHMvcG9pbnRpbnBvbHkvZGVmYXVsdC5odG1sXHJcblRIUkVFLlRyaWFuZ2xlLmJhcnljb29yZEZyb21Qb2ludCA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHR2YXIgdjAgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0djEgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0djIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gKCBwb2ludCwgYSwgYiwgYywgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0djAuc3ViVmVjdG9ycyggYywgYSApO1xyXG5cdFx0djEuc3ViVmVjdG9ycyggYiwgYSApO1xyXG5cdFx0djIuc3ViVmVjdG9ycyggcG9pbnQsIGEgKTtcclxuXHJcblx0XHR2YXIgZG90MDAgPSB2MC5kb3QoIHYwICk7XHJcblx0XHR2YXIgZG90MDEgPSB2MC5kb3QoIHYxICk7XHJcblx0XHR2YXIgZG90MDIgPSB2MC5kb3QoIHYyICk7XHJcblx0XHR2YXIgZG90MTEgPSB2MS5kb3QoIHYxICk7XHJcblx0XHR2YXIgZG90MTIgPSB2MS5kb3QoIHYyICk7XHJcblxyXG5cdFx0dmFyIGRlbm9tID0gKCBkb3QwMCAqIGRvdDExIC0gZG90MDEgKiBkb3QwMSApO1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdC8vIGNvbGluZWFyIG9yIHNpbmd1bGFyIHRyaWFuZ2xlXHJcblx0XHRpZiggZGVub20gPT0gMCApIHtcclxuXHRcdFx0Ly8gYXJiaXRyYXJ5IGxvY2F0aW9uIG91dHNpZGUgb2YgdHJpYW5nbGU/XHJcblx0XHRcdC8vIG5vdCBzdXJlIGlmIHRoaXMgaXMgdGhlIGJlc3QgaWRlYSwgbWF5YmUgc2hvdWxkIGJlIHJldHVybmluZyB1bmRlZmluZWRcclxuXHRcdFx0cmV0dXJuIHJlc3VsdC5zZXQoIC0yLCAtMSwgLTEgKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaW52RGVub20gPSAxIC8gZGVub207XHJcblx0XHR2YXIgdSA9ICggZG90MTEgKiBkb3QwMiAtIGRvdDAxICogZG90MTIgKSAqIGludkRlbm9tO1xyXG5cdFx0dmFyIHYgPSAoIGRvdDAwICogZG90MTIgLSBkb3QwMSAqIGRvdDAyICkgKiBpbnZEZW5vbTtcclxuXHJcblx0XHQvLyBiYXJ5Y29vcmRpbmF0ZXMgbXVzdCBhbHdheXMgc3VtIHRvIDFcclxuXHRcdHJldHVybiByZXN1bHQuc2V0KCAxIC0gdSAtIHYsIHYsIHUgKTtcclxuXHJcblx0fTtcclxuXHJcbn0oKTtcclxuXHJcblRIUkVFLlRyaWFuZ2xlLmNvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uICggcG9pbnQsIGEsIGIsIGMgKSB7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IFRIUkVFLlRyaWFuZ2xlLmJhcnljb29yZEZyb21Qb2ludCggcG9pbnQsIGEsIGIsIGMsIHYxICk7XHJcblxyXG5cdFx0cmV0dXJuICggcmVzdWx0LnggPj0gMCApICYmICggcmVzdWx0LnkgPj0gMCApICYmICggKCByZXN1bHQueCArIHJlc3VsdC55ICkgPD0gMSApO1xyXG5cclxuXHR9O1xyXG5cclxufSgpO1xyXG5cclxuVEhSRUUuZXh0ZW5kKCBUSFJFRS5UcmlhbmdsZS5wcm90b3R5cGUsIHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLlRyaWFuZ2xlLFxyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggYSwgYiwgYyApIHtcclxuXHJcblx0XHR0aGlzLmEuY29weSggYSApO1xyXG5cdFx0dGhpcy5iLmNvcHkoIGIgKTtcclxuXHRcdHRoaXMuYy5jb3B5KCBjICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21Qb2ludHNBbmRJbmRpY2VzOiBmdW5jdGlvbiAoIHBvaW50cywgaTAsIGkxLCBpMiApIHtcclxuXHJcblx0XHR0aGlzLmEuY29weSggcG9pbnRzW2kwXSApO1xyXG5cdFx0dGhpcy5iLmNvcHkoIHBvaW50c1tpMV0gKTtcclxuXHRcdHRoaXMuYy5jb3B5KCBwb2ludHNbaTJdICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggdHJpYW5nbGUgKSB7XHJcblxyXG5cdFx0dGhpcy5hLmNvcHkoIHRyaWFuZ2xlLmEgKTtcclxuXHRcdHRoaXMuYi5jb3B5KCB0cmlhbmdsZS5iICk7XHJcblx0XHR0aGlzLmMuY29weSggdHJpYW5nbGUuYyApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhcmVhOiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR2YXIgdjAgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0djAuc3ViVmVjdG9ycyggdGhpcy5jLCB0aGlzLmIgKTtcclxuXHRcdFx0djEuc3ViVmVjdG9ycyggdGhpcy5hLCB0aGlzLmIgKTtcclxuXHJcblx0XHRcdHJldHVybiB2MC5jcm9zcyggdjEgKS5sZW5ndGgoKSAqIDAuNTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdG1pZHBvaW50OiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0cmV0dXJuIHJlc3VsdC5hZGRWZWN0b3JzKCB0aGlzLmEsIHRoaXMuYiApLmFkZCggdGhpcy5jICkubXVsdGlwbHlTY2FsYXIoIDEgLyAzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG5vcm1hbDogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHRyZXR1cm4gVEhSRUUuVHJpYW5nbGUubm9ybWFsKCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCBvcHRpb25hbFRhcmdldCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRwbGFuZTogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlBsYW5lKCk7XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdC5zZXRGcm9tQ29wbGFuYXJQb2ludHMoIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0YmFyeWNvb3JkRnJvbVBvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHRyZXR1cm4gVEhSRUUuVHJpYW5nbGUuYmFyeWNvb3JkRnJvbVBvaW50KCBwb2ludCwgdGhpcy5hLCB0aGlzLmIsIHRoaXMuYywgb3B0aW9uYWxUYXJnZXQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcblx0XHRyZXR1cm4gVEhSRUUuVHJpYW5nbGUuY29udGFpbnNQb2ludCggcG9pbnQsIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAoIHRyaWFuZ2xlICkge1xyXG5cclxuXHRcdHJldHVybiB0cmlhbmdsZS5hLmVxdWFscyggdGhpcy5hICkgJiYgdHJpYW5nbGUuYi5lcXVhbHMoIHRoaXMuYiApICYmIHRyaWFuZ2xlLmMuZXF1YWxzKCB0aGlzLmMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFRIUkVFLlRyaWFuZ2xlKCkuY29weSggdGhpcyApO1xyXG5cclxuXHR9XHJcblxyXG59ICk7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlZlcnRleCA9IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVydGV4IGhhcyBiZWVuIERFUFJFQ0FURUQuIFVzZSBUSFJFRS5WZWN0b3IzIGluc3RlYWQuJylcclxuXHRyZXR1cm4gdjtcclxuXHJcbn07XHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlVWID0gZnVuY3Rpb24gKCB1LCB2ICkge1xyXG5cclxuXHRjb25zb2xlLndhcm4oICdUSFJFRS5VViBoYXMgYmVlbiBERVBSRUNBVEVELiBVc2UgVEhSRUUuVmVjdG9yMiBpbnN0ZWFkLicpXHJcblx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IyKCB1LCB2ICk7XHJcblxyXG59O1xyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5DbG9jayA9IGZ1bmN0aW9uICggYXV0b1N0YXJ0ICkge1xyXG5cclxuXHR0aGlzLmF1dG9TdGFydCA9ICggYXV0b1N0YXJ0ICE9PSB1bmRlZmluZWQgKSA/IGF1dG9TdGFydCA6IHRydWU7XHJcblxyXG5cdHRoaXMuc3RhcnRUaW1lID0gMDtcclxuXHR0aGlzLm9sZFRpbWUgPSAwO1xyXG5cdHRoaXMuZWxhcHNlZFRpbWUgPSAwO1xyXG5cclxuXHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5leHRlbmQoIFRIUkVFLkNsb2NrLnByb3RvdHlwZSwge1xyXG5cclxuXHRzdGFydDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuc3RhcnRUaW1lID0gd2luZG93LnBlcmZvcm1hbmNlICE9PSB1bmRlZmluZWQgJiYgd2luZG93LnBlcmZvcm1hbmNlLm5vdyAhPT0gdW5kZWZpbmVkXHJcblx0XHRcdFx0XHQ/IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKVxyXG5cdFx0XHRcdFx0OiBEYXRlLm5vdygpO1xyXG5cclxuXHRcdHRoaXMub2xkVGltZSA9IHRoaXMuc3RhcnRUaW1lO1xyXG5cdFx0dGhpcy5ydW5uaW5nID0gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHRzdG9wOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5nZXRFbGFwc2VkVGltZSgpO1xyXG5cdFx0dGhpcy5ydW5uaW5nID0gZmFsc2U7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldEVsYXBzZWRUaW1lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5nZXREZWx0YSgpO1xyXG5cdFx0cmV0dXJuIHRoaXMuZWxhcHNlZFRpbWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldERlbHRhOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGRpZmYgPSAwO1xyXG5cclxuXHRcdGlmICggdGhpcy5hdXRvU3RhcnQgJiYgISB0aGlzLnJ1bm5pbmcgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnN0YXJ0KCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5ydW5uaW5nICkge1xyXG5cclxuXHRcdFx0dmFyIG5ld1RpbWUgPSB3aW5kb3cucGVyZm9ybWFuY2UgIT09IHVuZGVmaW5lZCAmJiB3aW5kb3cucGVyZm9ybWFuY2Uubm93ICE9PSB1bmRlZmluZWRcclxuXHRcdFx0XHRcdD8gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpXHJcblx0XHRcdFx0XHQ6IERhdGUubm93KCk7XHJcblxyXG5cdFx0XHRkaWZmID0gMC4wMDEgKiAoIG5ld1RpbWUgLSB0aGlzLm9sZFRpbWUgKTtcclxuXHRcdFx0dGhpcy5vbGRUaW1lID0gbmV3VGltZTtcclxuXHJcblx0XHRcdHRoaXMuZWxhcHNlZFRpbWUgKz0gZGlmZjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGRpZmY7XHJcblxyXG5cdH1cclxuXHJcbn0gKTtcclxuLyoqXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvZXZlbnRkaXNwYXRjaGVyLmpzL1xyXG4gKi9cclxuXHJcblRIUkVFLkV2ZW50RGlzcGF0Y2hlciA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIGxpc3RlbmVycyA9IHt9O1xyXG5cclxuXHR0aGlzLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyICkge1xyXG5cclxuXHRcdGlmICggbGlzdGVuZXJzWyB0eXBlIF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGxpc3RlbmVyc1sgdHlwZSBdID0gW107XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKSA9PT0gLSAxICkge1xyXG5cclxuXHRcdFx0bGlzdGVuZXJzWyB0eXBlIF0ucHVzaCggbGlzdGVuZXIgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIgKSB7XHJcblxyXG5cdFx0dmFyIGluZGV4ID0gbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKTtcclxuXHJcblx0XHRpZiAoIGluZGV4ICE9PSAtIDEgKSB7XHJcblxyXG5cdFx0XHRsaXN0ZW5lcnNbIHR5cGUgXS5zcGxpY2UoIGluZGV4LCAxICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbiAoIGV2ZW50ICkge1xyXG5cclxuXHRcdHZhciBsaXN0ZW5lckFycmF5ID0gbGlzdGVuZXJzWyBldmVudC50eXBlIF07XHJcblxyXG5cdFx0aWYgKCBsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRldmVudC50YXJnZXQgPSB0aGlzO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbGlzdGVuZXJBcnJheS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRsaXN0ZW5lckFycmF5WyBpIF0uY2FsbCggdGhpcywgZXZlbnQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG59O1xyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tL1xyXG4gKi9cclxuXHJcbiggZnVuY3Rpb24gKCBUSFJFRSApIHtcclxuXHJcblx0VEhSRUUuUmF5Y2FzdGVyID0gZnVuY3Rpb24gKCBvcmlnaW4sIGRpcmVjdGlvbiwgbmVhciwgZmFyICkge1xyXG5cclxuXHRcdHRoaXMucmF5ID0gbmV3IFRIUkVFLlJheSggb3JpZ2luLCBkaXJlY3Rpb24gKTtcclxuXHJcblx0XHQvLyBub3JtYWxpemVkIHJheS5kaXJlY3Rpb24gcmVxdWlyZWQgZm9yIGFjY3VyYXRlIGRpc3RhbmNlIGNhbGN1bGF0aW9uc1xyXG5cdFx0aWYoIHRoaXMucmF5LmRpcmVjdGlvbi5sZW5ndGhTcSgpID4gMCApIHtcclxuXHJcblx0XHRcdHRoaXMucmF5LmRpcmVjdGlvbi5ub3JtYWxpemUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5uZWFyID0gbmVhciB8fCAwO1xyXG5cdFx0dGhpcy5mYXIgPSBmYXIgfHwgSW5maW5pdHk7XHJcblxyXG5cdH07XHJcblxyXG5cdHZhciBzcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCk7XHJcblx0dmFyIGxvY2FsUmF5ID0gbmV3IFRIUkVFLlJheSgpO1xyXG5cdHZhciBmYWNlUGxhbmUgPSBuZXcgVEhSRUUuUGxhbmUoKTtcclxuXHR2YXIgaW50ZXJzZWN0UG9pbnQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHZhciBtYXRyaXhQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdHZhciBpbnZlcnNlTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcblx0dmFyIGRlc2NTb3J0ID0gZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuXHRcdHJldHVybiBhLmRpc3RhbmNlIC0gYi5kaXN0YW5jZTtcclxuXHJcblx0fTtcclxuXHJcblx0dmFyIGludGVyc2VjdE9iamVjdCA9IGZ1bmN0aW9uICggb2JqZWN0LCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XHJcblxyXG5cdFx0aWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5QYXJ0aWNsZSApIHtcclxuXHJcblx0XHRcdG1hdHJpeFBvc2l0aW9uLmdldFBvc2l0aW9uRnJvbU1hdHJpeCggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkuZGlzdGFuY2VUb1BvaW50KCBtYXRyaXhQb3NpdGlvbiApO1xyXG5cclxuXHRcdFx0aWYgKCBkaXN0YW5jZSA+IG9iamVjdC5zY2FsZS54ICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gaW50ZXJzZWN0cztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGludGVyc2VjdHMucHVzaCgge1xyXG5cclxuXHRcdFx0XHRkaXN0YW5jZTogZGlzdGFuY2UsXHJcblx0XHRcdFx0cG9pbnQ6IG9iamVjdC5wb3NpdGlvbixcclxuXHRcdFx0XHRmYWNlOiBudWxsLFxyXG5cdFx0XHRcdG9iamVjdDogb2JqZWN0XHJcblxyXG5cdFx0XHR9ICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTWVzaCApIHtcclxuXHJcblx0XHRcdC8vIENoZWNraW5nIGJvdW5kaW5nU3BoZXJlIGRpc3RhbmNlIHRvIHJheVxyXG5cdFx0XHRtYXRyaXhQb3NpdGlvbi5nZXRQb3NpdGlvbkZyb21NYXRyaXgoIG9iamVjdC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRzcGhlcmUuc2V0KFxyXG5cdFx0XHRcdG1hdHJpeFBvc2l0aW9uLFxyXG5cdFx0XHRcdG9iamVjdC5nZW9tZXRyeS5ib3VuZGluZ1NwaGVyZS5yYWRpdXMgKiBvYmplY3QubWF0cml4V29ybGQuZ2V0TWF4U2NhbGVPbkF4aXMoKSApO1xyXG5cclxuXHRcdFx0aWYgKCAhIHJheWNhc3Rlci5yYXkuaXNJbnRlcnNlY3Rpb25TcGhlcmUoIHNwaGVyZSApICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gaW50ZXJzZWN0cztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIENoZWNraW5nIGZhY2VzXHJcblxyXG5cdFx0XHR2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XHJcblx0XHRcdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xyXG5cclxuXHRcdFx0dmFyIGlzRmFjZU1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaEZhY2VNYXRlcmlhbDtcclxuXHRcdFx0dmFyIG9iamVjdE1hdGVyaWFscyA9IGlzRmFjZU1hdGVyaWFsID09PSB0cnVlID8gb2JqZWN0Lm1hdGVyaWFsLm1hdGVyaWFscyA6IG51bGw7XHJcblxyXG5cdFx0XHR2YXIgc2lkZSA9IG9iamVjdC5tYXRlcmlhbC5zaWRlO1xyXG5cclxuXHRcdFx0dmFyIGEsIGIsIGMsIGQ7XHJcblx0XHRcdHZhciBwcmVjaXNpb24gPSByYXljYXN0ZXIucHJlY2lzaW9uO1xyXG5cclxuXHRcdFx0b2JqZWN0Lm1hdHJpeFJvdGF0aW9uV29ybGQuZXh0cmFjdFJvdGF0aW9uKCBvYmplY3QubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdGludmVyc2VNYXRyaXguZ2V0SW52ZXJzZSggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0XHRsb2NhbFJheS5jb3B5KCByYXljYXN0ZXIucmF5ICkuYXBwbHlNYXRyaXg0KCBpbnZlcnNlTWF0cml4ICk7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgZiA9IDAsIGZsID0gZ2VvbWV0cnkuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBmYWNlID0gZ2VvbWV0cnkuZmFjZXNbIGYgXTtcclxuXHJcblx0XHRcdFx0dmFyIG1hdGVyaWFsID0gaXNGYWNlTWF0ZXJpYWwgPT09IHRydWUgPyBvYmplY3RNYXRlcmlhbHNbIGZhY2UubWF0ZXJpYWxJbmRleCBdIDogb2JqZWN0Lm1hdGVyaWFsO1xyXG5cclxuXHRcdFx0XHRpZiAoIG1hdGVyaWFsID09PSB1bmRlZmluZWQgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0ZmFjZVBsYW5lLnNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50KCBmYWNlLm5vcm1hbCwgdmVydGljZXNbZmFjZS5hXSApO1xyXG5cclxuXHRcdFx0XHR2YXIgcGxhbmVEaXN0YW5jZSA9IGxvY2FsUmF5LmRpc3RhbmNlVG9QbGFuZSggZmFjZVBsYW5lICk7XHJcblxyXG5cdFx0XHRcdC8vIGJhaWwgaWYgcmF5Y2FzdGVyIGFuZCBwbGFuZSBhcmUgcGFyYWxsZWxcclxuXHRcdFx0XHRpZiAoIE1hdGguYWJzKCBwbGFuZURpc3RhbmNlICkgPCBwcmVjaXNpb24gKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0Ly8gaWYgbmVnYXRpdmUgZGlzdGFuY2UsIHRoZW4gcGxhbmUgaXMgYmVoaW5kIHJheWNhc3RlclxyXG5cdFx0XHRcdGlmICggcGxhbmVEaXN0YW5jZSA8IDAgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0Ly8gY2hlY2sgaWYgd2UgaGl0IHRoZSB3cm9uZyBzaWRlIG9mIGEgc2luZ2xlIHNpZGVkIGZhY2VcclxuXHRcdFx0XHRzaWRlID0gbWF0ZXJpYWwuc2lkZTtcclxuXHRcdFx0XHRpZiggc2lkZSAhPT0gVEhSRUUuRG91YmxlU2lkZSApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgcGxhbmVTaWduID0gbG9jYWxSYXkuZGlyZWN0aW9uLmRvdCggZmFjZVBsYW5lLm5vcm1hbCApO1xyXG5cclxuXHRcdFx0XHRcdGlmKCAhICggc2lkZSA9PT0gVEhSRUUuRnJvbnRTaWRlID8gcGxhbmVTaWduIDwgMCA6IHBsYW5lU2lnbiA+IDAgKSApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIHRoaXMgY2FuIGJlIGRvbmUgdXNpbmcgdGhlIHBsYW5lRGlzdGFuY2UgZnJvbSBsb2NhbFJheSBiZWNhdXNlIGxvY2FsUmF5IHdhc24ndCBub3JtYWxpemVkLCBidXQgcmF5IHdhc1xyXG5cdFx0XHRcdGlmICggcGxhbmVEaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IHBsYW5lRGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdGludGVyc2VjdFBvaW50ID0gbG9jYWxSYXkuYXQoIHBsYW5lRGlzdGFuY2UsIGludGVyc2VjdFBvaW50ICk7IC8vIHBhc3NpbmcgaW4gaW50ZXJzZWN0UG9pbnQgYXZvaWRzIGEgY29weVxyXG5cclxuXHRcdFx0XHRpZiAoIGZhY2UgaW5zdGFuY2VvZiBUSFJFRS5GYWNlMyApIHtcclxuXHJcblx0XHRcdFx0XHRhID0gdmVydGljZXNbIGZhY2UuYSBdO1xyXG5cdFx0XHRcdFx0YiA9IHZlcnRpY2VzWyBmYWNlLmIgXTtcclxuXHRcdFx0XHRcdGMgPSB2ZXJ0aWNlc1sgZmFjZS5jIF07XHJcblxyXG5cdFx0XHRcdFx0aWYgKCAhIFRIUkVFLlRyaWFuZ2xlLmNvbnRhaW5zUG9pbnQoIGludGVyc2VjdFBvaW50LCBhLCBiLCBjICkgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggZmFjZSBpbnN0YW5jZW9mIFRIUkVFLkZhY2U0ICkge1xyXG5cclxuXHRcdFx0XHRcdGEgPSB2ZXJ0aWNlc1sgZmFjZS5hIF07XHJcblx0XHRcdFx0XHRiID0gdmVydGljZXNbIGZhY2UuYiBdO1xyXG5cdFx0XHRcdFx0YyA9IHZlcnRpY2VzWyBmYWNlLmMgXTtcclxuXHRcdFx0XHRcdGQgPSB2ZXJ0aWNlc1sgZmFjZS5kIF07XHJcblxyXG5cdFx0XHRcdFx0aWYgKCAoICEgVEhSRUUuVHJpYW5nbGUuY29udGFpbnNQb2ludCggaW50ZXJzZWN0UG9pbnQsIGEsIGIsIGQgKSApICYmXHJcblx0XHRcdFx0XHRcdCAoICEgVEhSRUUuVHJpYW5nbGUuY29udGFpbnNQb2ludCggaW50ZXJzZWN0UG9pbnQsIGIsIGMsIGQgKSApICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gVGhpcyBpcyBhZGRlZCBiZWNhdXNlIGlmIHdlIGNhbGwgb3V0IG9mIHRoaXMgaWYvZWxzZSBncm91cCB3aGVuIG5vbmUgb2YgdGhlIGNhc2VzXHJcblx0XHRcdFx0XHQvLyAgICBtYXRjaCBpdCB3aWxsIGFkZCBhIHBvaW50IHRvIHRoZSBpbnRlcnNlY3Rpb24gbGlzdCBlcnJvbmVvdXNseS5cclxuXHRcdFx0XHRcdHRocm93IEVycm9yKCBcImZhY2UgdHlwZSBub3Qgc3VwcG9ydGVkXCIgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIHtcclxuXHJcblx0XHRcdFx0XHRkaXN0YW5jZTogcGxhbmVEaXN0YW5jZSxcdC8vIHRoaXMgd29ya3MgYmVjYXVzZSB0aGUgb3JpZ2luYWwgcmF5IHdhcyBub3JtYWxpemVkLCBhbmQgdGhlIHRyYW5zZm9ybWVkIGxvY2FsUmF5IHdhc24ndFxyXG5cdFx0XHRcdFx0cG9pbnQ6IHJheWNhc3Rlci5yYXkuYXQoIHBsYW5lRGlzdGFuY2UgKSxcclxuXHRcdFx0XHRcdGZhY2U6IGZhY2UsXHJcblx0XHRcdFx0XHRmYWNlSW5kZXg6IGYsXHJcblx0XHRcdFx0XHRvYmplY3Q6IG9iamVjdFxyXG5cclxuXHRcdFx0XHR9ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR2YXIgaW50ZXJzZWN0RGVzY2VuZGFudHMgPSBmdW5jdGlvbiAoIG9iamVjdCwgcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xyXG5cclxuXHRcdHZhciBkZXNjZW5kYW50cyA9IG9iamVjdC5nZXREZXNjZW5kYW50cygpO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGRlc2NlbmRhbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRpbnRlcnNlY3RPYmplY3QoIGRlc2NlbmRhbnRzWyBpIF0sIHJheWNhc3RlciwgaW50ZXJzZWN0cyApO1xyXG5cclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvL1xyXG5cclxuXHRUSFJFRS5SYXljYXN0ZXIucHJvdG90eXBlLnByZWNpc2lvbiA9IDAuMDAwMTtcclxuXHJcblx0VEhSRUUuUmF5Y2FzdGVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoIG9yaWdpbiwgZGlyZWN0aW9uICkge1xyXG5cclxuXHRcdHRoaXMucmF5LnNldCggb3JpZ2luLCBkaXJlY3Rpb24gKTtcclxuXHJcblx0XHQvLyBub3JtYWxpemVkIHJheS5kaXJlY3Rpb24gcmVxdWlyZWQgZm9yIGFjY3VyYXRlIGRpc3RhbmNlIGNhbGN1bGF0aW9uc1xyXG5cdFx0aWYoIHRoaXMucmF5LmRpcmVjdGlvbi5sZW5ndGgoKSA+IDAgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnJheS5kaXJlY3Rpb24ubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRUSFJFRS5SYXljYXN0ZXIucHJvdG90eXBlLmludGVyc2VjdE9iamVjdCA9IGZ1bmN0aW9uICggb2JqZWN0LCByZWN1cnNpdmUgKSB7XHJcblxyXG5cdFx0dmFyIGludGVyc2VjdHMgPSBbXTtcclxuXHJcblx0XHRpZiAoIHJlY3Vyc2l2ZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdGludGVyc2VjdERlc2NlbmRhbnRzKCBvYmplY3QsIHRoaXMsIGludGVyc2VjdHMgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aW50ZXJzZWN0T2JqZWN0KCBvYmplY3QsIHRoaXMsIGludGVyc2VjdHMgKTtcclxuXHJcblx0XHRpbnRlcnNlY3RzLnNvcnQoIGRlc2NTb3J0ICk7XHJcblxyXG5cdFx0cmV0dXJuIGludGVyc2VjdHM7XHJcblxyXG5cdH07XHJcblxyXG5cdFRIUkVFLlJheWNhc3Rlci5wcm90b3R5cGUuaW50ZXJzZWN0T2JqZWN0cyA9IGZ1bmN0aW9uICggb2JqZWN0cywgcmVjdXJzaXZlICkge1xyXG5cclxuXHRcdHZhciBpbnRlcnNlY3RzID0gW107XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0aW50ZXJzZWN0T2JqZWN0KCBvYmplY3RzWyBpIF0sIHRoaXMsIGludGVyc2VjdHMgKTtcclxuXHJcblx0XHRcdGlmICggcmVjdXJzaXZlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRpbnRlcnNlY3REZXNjZW5kYW50cyggb2JqZWN0c1sgaSBdLCB0aGlzLCBpbnRlcnNlY3RzICk7XHJcblxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aW50ZXJzZWN0cy5zb3J0KCBkZXNjU29ydCApO1xyXG5cclxuXHRcdHJldHVybiBpbnRlcnNlY3RzO1xyXG5cclxuXHR9O1xyXG5cclxufSggVEhSRUUgKSApO1xyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5PYmplY3QzRCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dGhpcy5pZCA9IFRIUkVFLk9iamVjdDNESWRDb3VudCArKztcclxuXHJcblx0dGhpcy5uYW1lID0gJyc7XHJcblx0dGhpcy5wcm9wZXJ0aWVzID0ge307XHJcblxyXG5cdHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xyXG5cdHRoaXMuY2hpbGRyZW4gPSBbXTtcclxuXHJcblx0dGhpcy51cCA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICk7XHJcblxyXG5cdHRoaXMucG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHRoaXMucm90YXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHRoaXMuZXVsZXJPcmRlciA9IFRIUkVFLk9iamVjdDNELmRlZmF1bHRFdWxlck9yZGVyO1xyXG5cdHRoaXMuc2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMSwgMSApO1xyXG5cclxuXHR0aGlzLnJlbmRlckRlcHRoID0gbnVsbDtcclxuXHJcblx0dGhpcy5yb3RhdGlvbkF1dG9VcGRhdGUgPSB0cnVlO1xyXG5cclxuXHR0aGlzLm1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblx0dGhpcy5tYXRyaXhXb3JsZCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblx0dGhpcy5tYXRyaXhSb3RhdGlvbldvcmxkID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcblx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gdHJ1ZTtcclxuXHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHR0aGlzLnF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xyXG5cdHRoaXMudXNlUXVhdGVybmlvbiA9IGZhbHNlO1xyXG5cclxuXHR0aGlzLnZpc2libGUgPSB0cnVlO1xyXG5cclxuXHR0aGlzLmNhc3RTaGFkb3cgPSBmYWxzZTtcclxuXHR0aGlzLnJlY2VpdmVTaGFkb3cgPSBmYWxzZTtcclxuXHJcblx0dGhpcy5mcnVzdHVtQ3VsbGVkID0gdHJ1ZTtcclxuXHJcblx0dGhpcy5fdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbn07XHJcblxyXG5cclxuVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuT2JqZWN0M0QsXHJcblxyXG5cdGFwcGx5TWF0cml4OiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcclxuXHJcblx0XHR0aGlzLm1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBtYXRyaXgsIHRoaXMubWF0cml4ICk7XHJcblxyXG5cdFx0dGhpcy5zY2FsZS5nZXRTY2FsZUZyb21NYXRyaXgoIHRoaXMubWF0cml4ICk7XHJcblxyXG5cdFx0dmFyIG1hdCA9IG5ldyBUSFJFRS5NYXRyaXg0KCkuZXh0cmFjdFJvdGF0aW9uKCB0aGlzLm1hdHJpeCApO1xyXG5cdFx0dGhpcy5yb3RhdGlvbi5zZXRFdWxlckZyb21Sb3RhdGlvbk1hdHJpeCggbWF0LCB0aGlzLmV1bGVyT3JkZXIgKTtcclxuXHJcblx0XHR0aGlzLnBvc2l0aW9uLmdldFBvc2l0aW9uRnJvbU1hdHJpeCggdGhpcy5tYXRyaXggKTtcclxuXHJcblx0fSxcclxuXHJcblx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoIGRpc3RhbmNlLCBheGlzICkge1xyXG5cclxuXHRcdHRoaXMubWF0cml4LnJvdGF0ZUF4aXMoIGF4aXMgKTtcclxuXHRcdHRoaXMucG9zaXRpb24uYWRkKCBheGlzLm11bHRpcGx5U2NhbGFyKCBkaXN0YW5jZSApICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRyYW5zbGF0ZVg6IGZ1bmN0aW9uICggZGlzdGFuY2UgKSB7XHJcblxyXG5cdFx0dGhpcy50cmFuc2xhdGUoIGRpc3RhbmNlLCB0aGlzLl92ZWN0b3Iuc2V0KCAxLCAwLCAwICkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0dHJhbnNsYXRlWTogZnVuY3Rpb24gKCBkaXN0YW5jZSApIHtcclxuXHJcblx0XHR0aGlzLnRyYW5zbGF0ZSggZGlzdGFuY2UsIHRoaXMuX3ZlY3Rvci5zZXQoIDAsIDEsIDAgKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0cmFuc2xhdGVaOiBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xyXG5cclxuXHRcdHRoaXMudHJhbnNsYXRlKCBkaXN0YW5jZSwgdGhpcy5fdmVjdG9yLnNldCggMCwgMCwgMSApICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxvY2FsVG9Xb3JsZDogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0d29ybGRUb0xvY2FsOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcclxuXHJcblx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggVEhSRUUuT2JqZWN0M0QuX19tMS5nZXRJbnZlcnNlKCB0aGlzLm1hdHJpeFdvcmxkICkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0bG9va0F0OiBmdW5jdGlvbiAoIHZlY3RvciApIHtcclxuXHJcblx0XHQvLyBUT0RPOiBBZGQgaGllcmFyY2h5IHN1cHBvcnQuXHJcblxyXG5cdFx0dGhpcy5tYXRyaXgubG9va0F0KCB2ZWN0b3IsIHRoaXMucG9zaXRpb24sIHRoaXMudXAgKTtcclxuXHJcblx0XHRpZiAoIHRoaXMucm90YXRpb25BdXRvVXBkYXRlICkge1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLnVzZVF1YXRlcm5pb24gPT09IGZhbHNlICkgIHtcclxuXHJcblx0XHRcdFx0dGhpcy5yb3RhdGlvbi5zZXRFdWxlckZyb21Sb3RhdGlvbk1hdHJpeCggdGhpcy5tYXRyaXgsIHRoaXMuZXVsZXJPcmRlciApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dGhpcy5xdWF0ZXJuaW9uLmNvcHkoIHRoaXMubWF0cml4LmRlY29tcG9zZSgpWyAxIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZDogZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0aWYgKCBvYmplY3QgPT09IHRoaXMgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRC5hZGQ6IEFuIG9iamVjdCBjYW5cXCd0IGJlIGFkZGVkIGFzIGEgY2hpbGQgb2YgaXRzZWxmLicgKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk9iamVjdDNEICkge1xyXG5cclxuXHRcdFx0aWYgKCBvYmplY3QucGFyZW50ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdG9iamVjdC5wYXJlbnQucmVtb3ZlKCBvYmplY3QgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG9iamVjdC5wYXJlbnQgPSB0aGlzO1xyXG5cdFx0XHR0aGlzLmNoaWxkcmVuLnB1c2goIG9iamVjdCApO1xyXG5cclxuXHRcdFx0Ly8gYWRkIHRvIHNjZW5lXHJcblxyXG5cdFx0XHR2YXIgc2NlbmUgPSB0aGlzO1xyXG5cclxuXHRcdFx0d2hpbGUgKCBzY2VuZS5wYXJlbnQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0c2NlbmUgPSBzY2VuZS5wYXJlbnQ7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIHNjZW5lICE9PSB1bmRlZmluZWQgJiYgc2NlbmUgaW5zdGFuY2VvZiBUSFJFRS5TY2VuZSApICB7XHJcblxyXG5cdFx0XHRcdHNjZW5lLl9fYWRkT2JqZWN0KCBvYmplY3QgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdHJlbW92ZTogZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0dmFyIGluZGV4ID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKCBvYmplY3QgKTtcclxuXHJcblx0XHRpZiAoIGluZGV4ICE9PSAtIDEgKSB7XHJcblxyXG5cdFx0XHRvYmplY3QucGFyZW50ID0gdW5kZWZpbmVkO1xyXG5cdFx0XHR0aGlzLmNoaWxkcmVuLnNwbGljZSggaW5kZXgsIDEgKTtcclxuXHJcblx0XHRcdC8vIHJlbW92ZSBmcm9tIHNjZW5lXHJcblxyXG5cdFx0XHR2YXIgc2NlbmUgPSB0aGlzO1xyXG5cclxuXHRcdFx0d2hpbGUgKCBzY2VuZS5wYXJlbnQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0c2NlbmUgPSBzY2VuZS5wYXJlbnQ7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIHNjZW5lICE9PSB1bmRlZmluZWQgJiYgc2NlbmUgaW5zdGFuY2VvZiBUSFJFRS5TY2VuZSApIHtcclxuXHJcblx0XHRcdFx0c2NlbmUuX19yZW1vdmVPYmplY3QoIG9iamVjdCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0dHJhdmVyc2U6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XHJcblxyXG5cdFx0Y2FsbGJhY2soIHRoaXMgKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmNoaWxkcmVuWyBpIF0udHJhdmVyc2UoIGNhbGxiYWNrICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRDaGlsZEJ5TmFtZTogZnVuY3Rpb24gKCBuYW1lLCByZWN1cnNpdmUgKSB7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlblsgaSBdO1xyXG5cclxuXHRcdFx0aWYgKCBjaGlsZC5uYW1lID09PSBuYW1lICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gY2hpbGQ7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIHJlY3Vyc2l2ZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0Y2hpbGQgPSBjaGlsZC5nZXRDaGlsZEJ5TmFtZSggbmFtZSwgcmVjdXJzaXZlICk7XHJcblxyXG5cdFx0XHRcdGlmICggY2hpbGQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gY2hpbGQ7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0RGVzY2VuZGFudHM6IGZ1bmN0aW9uICggYXJyYXkgKSB7XHJcblxyXG5cdFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcclxuXHJcblx0XHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSggYXJyYXksIHRoaXMuY2hpbGRyZW4gKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmNoaWxkcmVuWyBpIF0uZ2V0RGVzY2VuZGFudHMoIGFycmF5ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBhcnJheTtcclxuXHJcblx0fSxcclxuXHJcblx0dXBkYXRlTWF0cml4OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5tYXRyaXguc2V0UG9zaXRpb24oIHRoaXMucG9zaXRpb24gKTtcclxuXHJcblx0XHRpZiAoIHRoaXMudXNlUXVhdGVybmlvbiA9PT0gZmFsc2UgKSAge1xyXG5cclxuXHRcdFx0dGhpcy5tYXRyaXguc2V0Um90YXRpb25Gcm9tRXVsZXIoIHRoaXMucm90YXRpb24sIHRoaXMuZXVsZXJPcmRlciApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLm1hdHJpeC5zZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCB0aGlzLnF1YXRlcm5pb24gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLnNjYWxlLnggIT09IDEgfHwgdGhpcy5zY2FsZS55ICE9PSAxIHx8IHRoaXMuc2NhbGUueiAhPT0gMSApIHtcclxuXHJcblx0XHRcdHRoaXMubWF0cml4LnNjYWxlKCB0aGlzLnNjYWxlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZU1hdHJpeFdvcmxkOiBmdW5jdGlvbiAoIGZvcmNlICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5tYXRyaXhBdXRvVXBkYXRlID09PSB0cnVlICkgdGhpcy51cGRhdGVNYXRyaXgoKTtcclxuXHJcblx0XHRpZiAoIHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9PT0gdHJ1ZSB8fCBmb3JjZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdGlmICggdGhpcy5wYXJlbnQgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5jb3B5KCB0aGlzLm1hdHJpeCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLnBhcmVudC5tYXRyaXhXb3JsZCwgdGhpcy5tYXRyaXggKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0Zm9yY2UgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyB1cGRhdGUgY2hpbGRyZW5cclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmNoaWxkcmVuWyBpIF0udXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0aWYgKCBvYmplY3QgPT09IHVuZGVmaW5lZCApIG9iamVjdCA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xyXG5cclxuXHRcdG9iamVjdC5uYW1lID0gdGhpcy5uYW1lO1xyXG5cclxuXHRcdG9iamVjdC51cC5jb3B5KCB0aGlzLnVwICk7XHJcblxyXG5cdFx0b2JqZWN0LnBvc2l0aW9uLmNvcHkoIHRoaXMucG9zaXRpb24gKTtcclxuXHRcdGlmICggb2JqZWN0LnJvdGF0aW9uIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMyApIG9iamVjdC5yb3RhdGlvbi5jb3B5KCB0aGlzLnJvdGF0aW9uICk7IC8vIGJlY2F1c2Ugb2YgU3ByaXRlIG1hZG5lc3NcclxuXHRcdG9iamVjdC5ldWxlck9yZGVyID0gdGhpcy5ldWxlck9yZGVyO1xyXG5cdFx0b2JqZWN0LnNjYWxlLmNvcHkoIHRoaXMuc2NhbGUgKTtcclxuXHJcblx0XHRvYmplY3QucmVuZGVyRGVwdGggPSB0aGlzLnJlbmRlckRlcHRoO1xyXG5cclxuXHRcdG9iamVjdC5yb3RhdGlvbkF1dG9VcGRhdGUgPSB0aGlzLnJvdGF0aW9uQXV0b1VwZGF0ZTtcclxuXHJcblx0XHRvYmplY3QubWF0cml4LmNvcHkoIHRoaXMubWF0cml4ICk7XHJcblx0XHRvYmplY3QubWF0cml4V29ybGQuY29weSggdGhpcy5tYXRyaXhXb3JsZCApO1xyXG5cdFx0b2JqZWN0Lm1hdHJpeFJvdGF0aW9uV29ybGQuY29weSggdGhpcy5tYXRyaXhSb3RhdGlvbldvcmxkICk7XHJcblxyXG5cdFx0b2JqZWN0Lm1hdHJpeEF1dG9VcGRhdGUgPSB0aGlzLm1hdHJpeEF1dG9VcGRhdGU7XHJcblx0XHRvYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZTtcclxuXHJcblx0XHRvYmplY3QucXVhdGVybmlvbi5jb3B5KCB0aGlzLnF1YXRlcm5pb24gKTtcclxuXHRcdG9iamVjdC51c2VRdWF0ZXJuaW9uID0gdGhpcy51c2VRdWF0ZXJuaW9uO1xyXG5cclxuXHRcdG9iamVjdC52aXNpYmxlID0gdGhpcy52aXNpYmxlO1xyXG5cclxuXHRcdG9iamVjdC5jYXN0U2hhZG93ID0gdGhpcy5jYXN0U2hhZG93O1xyXG5cdFx0b2JqZWN0LnJlY2VpdmVTaGFkb3cgPSB0aGlzLnJlY2VpdmVTaGFkb3c7XHJcblxyXG5cdFx0b2JqZWN0LmZydXN0dW1DdWxsZWQgPSB0aGlzLmZydXN0dW1DdWxsZWQ7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuWyBpIF07XHJcblx0XHRcdG9iamVjdC5hZGQoIGNoaWxkLmNsb25lKCkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG9iamVjdDtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLk9iamVjdDNELl9fbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5USFJFRS5PYmplY3QzRC5kZWZhdWx0RXVsZXJPcmRlciA9ICdYWVonLFxyXG5cclxuVEhSRUUuT2JqZWN0M0RJZENvdW50ID0gMDtcclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3Igc3VwZXJlZ2diZXJ0IC8gaHR0cDovL3d3dy5wYXVsYnJ1bnQuY28udWsvXHJcbiAqIEBhdXRob3IganVsaWFud2EgLyBodHRwczovL2dpdGh1Yi5jb20vanVsaWFud2FcclxuICovXHJcblxyXG5USFJFRS5Qcm9qZWN0b3IgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBfb2JqZWN0LCBfb2JqZWN0Q291bnQsIF9vYmplY3RQb29sID0gW10sIF9vYmplY3RQb29sTGVuZ3RoID0gMCxcclxuXHRfdmVydGV4LCBfdmVydGV4Q291bnQsIF92ZXJ0ZXhQb29sID0gW10sIF92ZXJ0ZXhQb29sTGVuZ3RoID0gMCxcclxuXHRfZmFjZSwgX2ZhY2UzQ291bnQsIF9mYWNlM1Bvb2wgPSBbXSwgX2ZhY2UzUG9vbExlbmd0aCA9IDAsXHJcblx0X2ZhY2U0Q291bnQsIF9mYWNlNFBvb2wgPSBbXSwgX2ZhY2U0UG9vbExlbmd0aCA9IDAsXHJcblx0X2xpbmUsIF9saW5lQ291bnQsIF9saW5lUG9vbCA9IFtdLCBfbGluZVBvb2xMZW5ndGggPSAwLFxyXG5cdF9wYXJ0aWNsZSwgX3BhcnRpY2xlQ291bnQsIF9wYXJ0aWNsZVBvb2wgPSBbXSwgX3BhcnRpY2xlUG9vbExlbmd0aCA9IDAsXHJcblxyXG5cdF9yZW5kZXJEYXRhID0geyBvYmplY3RzOiBbXSwgc3ByaXRlczogW10sIGxpZ2h0czogW10sIGVsZW1lbnRzOiBbXSB9LFxyXG5cclxuXHRfdmVjdG9yMyA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblx0X3ZlY3RvcjQgPSBuZXcgVEhSRUUuVmVjdG9yNCgpLFxyXG5cclxuXHRfY2xpcEJveCA9IG5ldyBUSFJFRS5Cb3gzKCBuZXcgVEhSRUUuVmVjdG9yMyggLTEsIC0xLCAtMSApLCBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMSwgMSApICksXHJcblx0X2JvdW5kaW5nQm94ID0gbmV3IFRIUkVFLkJveDMoKSxcclxuXHRfcG9pbnRzMyA9IG5ldyBBcnJheSggMyApLFxyXG5cdF9wb2ludHM0ID0gbmV3IEFycmF5KCA0ICksXHJcblxyXG5cdF92aWV3TWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKSxcclxuXHRfdmlld1Byb2plY3Rpb25NYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpLFxyXG5cclxuXHRfbW9kZWxNYXRyaXgsXHJcblx0X21vZGVsVmlld1Byb2plY3Rpb25NYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpLFxyXG5cclxuXHRfbm9ybWFsTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDMoKSxcclxuXHRfbm9ybWFsVmlld01hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXgzKCksXHJcblxyXG5cdF9jZW50cm9pZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblxyXG5cdF9mcnVzdHVtID0gbmV3IFRIUkVFLkZydXN0dW0oKSxcclxuXHJcblx0X2NsaXBwZWRWZXJ0ZXgxUG9zaXRpb25TY3JlZW4gPSBuZXcgVEhSRUUuVmVjdG9yNCgpLFxyXG5cdF9jbGlwcGVkVmVydGV4MlBvc2l0aW9uU2NyZWVuID0gbmV3IFRIUkVFLlZlY3RvcjQoKTtcclxuXHJcblx0dGhpcy5wcm9qZWN0VmVjdG9yID0gZnVuY3Rpb24gKCB2ZWN0b3IsIGNhbWVyYSApIHtcclxuXHJcblx0XHRjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLmdldEludmVyc2UoIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdF92aWV3UHJvamVjdGlvbk1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCwgY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xyXG5cclxuXHRcdHJldHVybiB2ZWN0b3IuYXBwbHlQcm9qZWN0aW9uKCBfdmlld1Byb2plY3Rpb25NYXRyaXggKTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy51bnByb2plY3RWZWN0b3IgPSBmdW5jdGlvbiAoIHZlY3RvciwgY2FtZXJhICkge1xyXG5cclxuXHRcdGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZS5nZXRJbnZlcnNlKCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xyXG5cclxuXHRcdF92aWV3UHJvamVjdGlvbk1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEubWF0cml4V29ybGQsIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZSApO1xyXG5cclxuXHRcdHJldHVybiB2ZWN0b3IuYXBwbHlQcm9qZWN0aW9uKCBfdmlld1Byb2plY3Rpb25NYXRyaXggKTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5waWNraW5nUmF5ID0gZnVuY3Rpb24gKCB2ZWN0b3IsIGNhbWVyYSApIHtcclxuXHJcblx0XHQvLyBzZXQgdHdvIHZlY3RvcnMgd2l0aCBvcHBvc2luZyB6IHZhbHVlc1xyXG5cdFx0dmVjdG9yLnogPSAtMS4wO1xyXG5cdFx0dmFyIGVuZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCB2ZWN0b3IueCwgdmVjdG9yLnksIDEuMCApO1xyXG5cclxuXHRcdHRoaXMudW5wcm9qZWN0VmVjdG9yKCB2ZWN0b3IsIGNhbWVyYSApO1xyXG5cdFx0dGhpcy51bnByb2plY3RWZWN0b3IoIGVuZCwgY2FtZXJhICk7XHJcblxyXG5cdFx0Ly8gZmluZCBkaXJlY3Rpb24gZnJvbSB2ZWN0b3IgdG8gZW5kXHJcblx0XHRlbmQuc3ViKCB2ZWN0b3IgKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFRIUkVFLlJheWNhc3RlciggdmVjdG9yLCBlbmQgKTtcclxuXHJcblx0fTtcclxuXHJcblx0dmFyIHByb2plY3RHcmFwaCA9IGZ1bmN0aW9uICggcm9vdCwgc29ydE9iamVjdHMgKSB7XHJcblxyXG5cdFx0X29iamVjdENvdW50ID0gMDtcclxuXHJcblx0XHRfcmVuZGVyRGF0YS5vYmplY3RzLmxlbmd0aCA9IDA7XHJcblx0XHRfcmVuZGVyRGF0YS5zcHJpdGVzLmxlbmd0aCA9IDA7XHJcblx0XHRfcmVuZGVyRGF0YS5saWdodHMubGVuZ3RoID0gMDtcclxuXHJcblx0XHR2YXIgcHJvamVjdE9iamVjdCA9IGZ1bmN0aW9uICggcGFyZW50ICkge1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGMgPSAwLCBjbCA9IHBhcmVudC5jaGlsZHJlbi5sZW5ndGg7IGMgPCBjbDsgYyArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIG9iamVjdCA9IHBhcmVudC5jaGlsZHJlblsgYyBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIG9iamVjdC52aXNpYmxlID09PSBmYWxzZSApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpZ2h0ICkge1xyXG5cclxuXHRcdFx0XHRcdF9yZW5kZXJEYXRhLmxpZ2h0cy5wdXNoKCBvYmplY3QgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTWVzaCB8fCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaW5lICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggb2JqZWN0LmZydXN0dW1DdWxsZWQgPT09IGZhbHNlIHx8IF9mcnVzdHVtLmludGVyc2VjdHNPYmplY3QoIG9iamVjdCApID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0X29iamVjdCA9IGdldE5leHRPYmplY3RJblBvb2woKTtcclxuXHRcdFx0XHRcdFx0X29iamVjdC5vYmplY3QgPSBvYmplY3Q7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIG9iamVjdC5yZW5kZXJEZXB0aCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0X29iamVjdC56ID0gb2JqZWN0LnJlbmRlckRlcHRoO1xyXG5cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0X3ZlY3RvcjMuZ2V0UG9zaXRpb25Gcm9tTWF0cml4KCBvYmplY3QubWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHRcdFx0XHRfdmVjdG9yMy5hcHBseVByb2plY3Rpb24oIF92aWV3UHJvamVjdGlvbk1hdHJpeCApO1xyXG5cdFx0XHRcdFx0XHRcdF9vYmplY3QueiA9IF92ZWN0b3IzLno7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRfcmVuZGVyRGF0YS5vYmplY3RzLnB1c2goIF9vYmplY3QgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlNwcml0ZSB8fCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5QYXJ0aWNsZSApIHtcclxuXHJcblx0XHRcdFx0XHRfb2JqZWN0ID0gZ2V0TmV4dE9iamVjdEluUG9vbCgpO1xyXG5cdFx0XHRcdFx0X29iamVjdC5vYmplY3QgPSBvYmplY3Q7XHJcblxyXG5cdFx0XHRcdFx0Ly8gVE9ETzogRmluZCBhbiBlbGVnYW50IGFuZCBwZXJmb3JtYW50IHNvbHV0aW9uIGFuZCByZW1vdmUgdGhpcyBkdXBlIGNvZGUuXHJcblxyXG5cdFx0XHRcdFx0aWYgKCBvYmplY3QucmVuZGVyRGVwdGggIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRfb2JqZWN0LnogPSBvYmplY3QucmVuZGVyRGVwdGg7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdF92ZWN0b3IzLmdldFBvc2l0aW9uRnJvbU1hdHJpeCggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdFx0XHRcdF92ZWN0b3IzLmFwcGx5UHJvamVjdGlvbiggX3ZpZXdQcm9qZWN0aW9uTWF0cml4ICk7XHJcblx0XHRcdFx0XHRcdF9vYmplY3QueiA9IF92ZWN0b3IzLno7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdF9yZW5kZXJEYXRhLnNwcml0ZXMucHVzaCggX29iamVjdCApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdF9vYmplY3QgPSBnZXROZXh0T2JqZWN0SW5Qb29sKCk7XHJcblx0XHRcdFx0XHRfb2JqZWN0Lm9iamVjdCA9IG9iamVjdDtcclxuXHJcblx0XHRcdFx0XHRpZiAoIG9iamVjdC5yZW5kZXJEZXB0aCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0XHRcdF9vYmplY3QueiA9IG9iamVjdC5yZW5kZXJEZXB0aDtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0X3ZlY3RvcjMuZ2V0UG9zaXRpb25Gcm9tTWF0cml4KCBvYmplY3QubWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHRcdFx0X3ZlY3RvcjMuYXBwbHlQcm9qZWN0aW9uKCBfdmlld1Byb2plY3Rpb25NYXRyaXggKTtcclxuXHRcdFx0XHRcdFx0X29iamVjdC56ID0gX3ZlY3RvcjMuejtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0X3JlbmRlckRhdGEub2JqZWN0cy5wdXNoKCBfb2JqZWN0ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cHJvamVjdE9iamVjdCggb2JqZWN0ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHRwcm9qZWN0T2JqZWN0KCByb290ICk7XHJcblxyXG5cdFx0aWYgKCBzb3J0T2JqZWN0cyA9PT0gdHJ1ZSApIF9yZW5kZXJEYXRhLm9iamVjdHMuc29ydCggcGFpbnRlclNvcnQgKTtcclxuXHJcblx0XHRyZXR1cm4gX3JlbmRlckRhdGE7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMucHJvamVjdFNjZW5lID0gZnVuY3Rpb24gKCBzY2VuZSwgY2FtZXJhLCBzb3J0T2JqZWN0cywgc29ydEVsZW1lbnRzICkge1xyXG5cclxuXHRcdHZhciB2aXNpYmxlID0gZmFsc2UsXHJcblx0XHRvLCBvbCwgdiwgdmwsIGYsIGZsLCBuLCBubCwgYywgY2wsIHUsIHVsLCBvYmplY3QsXHJcblx0XHRnZW9tZXRyeSwgdmVydGljZXMsIGZhY2VzLCBmYWNlLCBmYWNlVmVydGV4Tm9ybWFscywgZmFjZVZlcnRleFV2cywgdXZzLFxyXG5cdFx0djEsIHYyLCB2MywgdjQsIGlzRmFjZU1hdGVyaWFsLCBvYmplY3RNYXRlcmlhbHM7XHJcblxyXG5cdFx0X2ZhY2UzQ291bnQgPSAwO1xyXG5cdFx0X2ZhY2U0Q291bnQgPSAwO1xyXG5cdFx0X2xpbmVDb3VudCA9IDA7XHJcblx0XHRfcGFydGljbGVDb3VudCA9IDA7XHJcblxyXG5cdFx0X3JlbmRlckRhdGEuZWxlbWVudHMubGVuZ3RoID0gMDtcclxuXHJcblx0XHRzY2VuZS51cGRhdGVNYXRyaXhXb3JsZCgpO1xyXG5cclxuXHRcdGlmICggY2FtZXJhLnBhcmVudCA9PT0gdW5kZWZpbmVkICkgY2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XHJcblxyXG5cdFx0X3ZpZXdNYXRyaXguY29weSggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZS5nZXRJbnZlcnNlKCBjYW1lcmEubWF0cml4V29ybGQgKSApO1xyXG5cdFx0X3ZpZXdQcm9qZWN0aW9uTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBfdmlld01hdHJpeCApO1xyXG5cclxuXHRcdF9ub3JtYWxWaWV3TWF0cml4LmdldEludmVyc2UoIF92aWV3TWF0cml4ICk7XHJcblx0XHRfbm9ybWFsVmlld01hdHJpeC50cmFuc3Bvc2UoKTtcclxuXHJcblx0XHRfZnJ1c3R1bS5zZXRGcm9tTWF0cml4KCBfdmlld1Byb2plY3Rpb25NYXRyaXggKTtcclxuXHJcblx0XHRfcmVuZGVyRGF0YSA9IHByb2plY3RHcmFwaCggc2NlbmUsIHNvcnRPYmplY3RzICk7XHJcblxyXG5cdFx0Zm9yICggbyA9IDAsIG9sID0gX3JlbmRlckRhdGEub2JqZWN0cy5sZW5ndGg7IG8gPCBvbDsgbyArKyApIHtcclxuXHJcblx0XHRcdG9iamVjdCA9IF9yZW5kZXJEYXRhLm9iamVjdHNbIG8gXS5vYmplY3Q7XHJcblxyXG5cdFx0XHRfbW9kZWxNYXRyaXggPSBvYmplY3QubWF0cml4V29ybGQ7XHJcblxyXG5cdFx0XHRfdmVydGV4Q291bnQgPSAwO1xyXG5cclxuXHRcdFx0aWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5NZXNoICkge1xyXG5cclxuXHRcdFx0XHRnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcclxuXHJcblx0XHRcdFx0dmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcclxuXHRcdFx0XHRmYWNlcyA9IGdlb21ldHJ5LmZhY2VzO1xyXG5cdFx0XHRcdGZhY2VWZXJ0ZXhVdnMgPSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzO1xyXG5cclxuXHRcdFx0XHRfbm9ybWFsTWF0cml4LmdldEludmVyc2UoIF9tb2RlbE1hdHJpeCApO1xyXG5cdFx0XHRcdF9ub3JtYWxNYXRyaXgudHJhbnNwb3NlKCk7XHJcblxyXG5cdFx0XHRcdGlzRmFjZU1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaEZhY2VNYXRlcmlhbDtcclxuXHRcdFx0XHRvYmplY3RNYXRlcmlhbHMgPSBpc0ZhY2VNYXRlcmlhbCA9PT0gdHJ1ZSA/IG9iamVjdC5tYXRlcmlhbCA6IG51bGw7XHJcblxyXG5cdFx0XHRcdGZvciAoIHYgPSAwLCB2bCA9IHZlcnRpY2VzLmxlbmd0aDsgdiA8IHZsOyB2ICsrICkge1xyXG5cclxuXHRcdFx0XHRcdF92ZXJ0ZXggPSBnZXROZXh0VmVydGV4SW5Qb29sKCk7XHJcblxyXG5cdFx0XHRcdFx0X3ZlcnRleC5wb3NpdGlvbldvcmxkLmNvcHkoIHZlcnRpY2VzWyB2IF0gKS5hcHBseU1hdHJpeDQoIF9tb2RlbE1hdHJpeCApO1xyXG5cdFx0XHRcdFx0X3ZlcnRleC5wb3NpdGlvblNjcmVlbi5jb3B5KCBfdmVydGV4LnBvc2l0aW9uV29ybGQgKS5hcHBseU1hdHJpeDQoIF92aWV3UHJvamVjdGlvbk1hdHJpeCApO1xyXG5cclxuXHRcdFx0XHRcdF92ZXJ0ZXgucG9zaXRpb25TY3JlZW4ueCAvPSBfdmVydGV4LnBvc2l0aW9uU2NyZWVuLnc7XHJcblx0XHRcdFx0XHRfdmVydGV4LnBvc2l0aW9uU2NyZWVuLnkgLz0gX3ZlcnRleC5wb3NpdGlvblNjcmVlbi53O1xyXG5cdFx0XHRcdFx0X3ZlcnRleC5wb3NpdGlvblNjcmVlbi56IC89IF92ZXJ0ZXgucG9zaXRpb25TY3JlZW4udztcclxuXHJcblx0XHRcdFx0XHRfdmVydGV4LnZpc2libGUgPSAhICggX3ZlcnRleC5wb3NpdGlvblNjcmVlbi54IDwgLTEgfHwgX3ZlcnRleC5wb3NpdGlvblNjcmVlbi54ID4gMSB8fFxyXG5cdFx0XHRcdFx0XHRcdCAgICAgIF92ZXJ0ZXgucG9zaXRpb25TY3JlZW4ueSA8IC0xIHx8IF92ZXJ0ZXgucG9zaXRpb25TY3JlZW4ueSA+IDEgfHxcclxuXHRcdFx0XHRcdFx0XHQgICAgICBfdmVydGV4LnBvc2l0aW9uU2NyZWVuLnogPCAtMSB8fCBfdmVydGV4LnBvc2l0aW9uU2NyZWVuLnogPiAxICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Zm9yICggZiA9IDAsIGZsID0gZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0ZmFjZSA9IGZhY2VzWyBmIF07XHJcblxyXG5cdFx0XHRcdFx0dmFyIG1hdGVyaWFsID0gaXNGYWNlTWF0ZXJpYWwgPT09IHRydWVcclxuXHRcdFx0XHRcdFx0PyBvYmplY3RNYXRlcmlhbHMubWF0ZXJpYWxzWyBmYWNlLm1hdGVyaWFsSW5kZXggXVxyXG5cdFx0XHRcdFx0XHQ6IG9iamVjdC5tYXRlcmlhbDtcclxuXHJcblx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsID09PSB1bmRlZmluZWQgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0XHR2YXIgc2lkZSA9IG1hdGVyaWFsLnNpZGU7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBmYWNlIGluc3RhbmNlb2YgVEhSRUUuRmFjZTMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2MSA9IF92ZXJ0ZXhQb29sWyBmYWNlLmEgXTtcclxuXHRcdFx0XHRcdFx0djIgPSBfdmVydGV4UG9vbFsgZmFjZS5iIF07XHJcblx0XHRcdFx0XHRcdHYzID0gX3ZlcnRleFBvb2xbIGZhY2UuYyBdO1xyXG5cclxuXHRcdFx0XHRcdFx0X3BvaW50czNbIDAgXSA9IHYxLnBvc2l0aW9uU2NyZWVuO1xyXG5cdFx0XHRcdFx0XHRfcG9pbnRzM1sgMSBdID0gdjIucG9zaXRpb25TY3JlZW47XHJcblx0XHRcdFx0XHRcdF9wb2ludHMzWyAyIF0gPSB2My5wb3NpdGlvblNjcmVlbjtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggdjEudmlzaWJsZSA9PT0gdHJ1ZSB8fCB2Mi52aXNpYmxlID09PSB0cnVlIHx8IHYzLnZpc2libGUgPT09IHRydWUgfHxcclxuXHRcdFx0XHRcdFx0XHRfY2xpcEJveC5pc0ludGVyc2VjdGlvbkJveCggX2JvdW5kaW5nQm94LnNldEZyb21Qb2ludHMoIF9wb2ludHMzICkgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dmlzaWJsZSA9ICggKCB2My5wb3NpdGlvblNjcmVlbi54IC0gdjEucG9zaXRpb25TY3JlZW4ueCApICogKCB2Mi5wb3NpdGlvblNjcmVlbi55IC0gdjEucG9zaXRpb25TY3JlZW4ueSApIC1cclxuXHRcdFx0XHRcdFx0XHRcdCggdjMucG9zaXRpb25TY3JlZW4ueSAtIHYxLnBvc2l0aW9uU2NyZWVuLnkgKSAqICggdjIucG9zaXRpb25TY3JlZW4ueCAtIHYxLnBvc2l0aW9uU2NyZWVuLnggKSApIDwgMDtcclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCBzaWRlID09PSBUSFJFRS5Eb3VibGVTaWRlIHx8IHZpc2libGUgPT09ICggc2lkZSA9PT0gVEhSRUUuRnJvbnRTaWRlICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0X2ZhY2UgPSBnZXROZXh0RmFjZTNJblBvb2woKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRfZmFjZS52MS5jb3B5KCB2MSApO1xyXG5cdFx0XHRcdFx0XHRcdFx0X2ZhY2UudjIuY29weSggdjIgKTtcclxuXHRcdFx0XHRcdFx0XHRcdF9mYWNlLnYzLmNvcHkoIHYzICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Y29udGludWU7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGZhY2UgaW5zdGFuY2VvZiBUSFJFRS5GYWNlNCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHYxID0gX3ZlcnRleFBvb2xbIGZhY2UuYSBdO1xyXG5cdFx0XHRcdFx0XHR2MiA9IF92ZXJ0ZXhQb29sWyBmYWNlLmIgXTtcclxuXHRcdFx0XHRcdFx0djMgPSBfdmVydGV4UG9vbFsgZmFjZS5jIF07XHJcblx0XHRcdFx0XHRcdHY0ID0gX3ZlcnRleFBvb2xbIGZhY2UuZCBdO1xyXG5cclxuXHRcdFx0XHRcdFx0X3BvaW50czRbIDAgXSA9IHYxLnBvc2l0aW9uU2NyZWVuO1xyXG5cdFx0XHRcdFx0XHRfcG9pbnRzNFsgMSBdID0gdjIucG9zaXRpb25TY3JlZW47XHJcblx0XHRcdFx0XHRcdF9wb2ludHM0WyAyIF0gPSB2My5wb3NpdGlvblNjcmVlbjtcclxuXHRcdFx0XHRcdFx0X3BvaW50czRbIDMgXSA9IHY0LnBvc2l0aW9uU2NyZWVuO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCB2MS52aXNpYmxlID09PSB0cnVlIHx8IHYyLnZpc2libGUgPT09IHRydWUgfHwgdjMudmlzaWJsZSA9PT0gdHJ1ZSB8fCB2NC52aXNpYmxlID09PSB0cnVlIHx8XHJcblx0XHRcdFx0XHRcdFx0X2NsaXBCb3guaXNJbnRlcnNlY3Rpb25Cb3goIF9ib3VuZGluZ0JveC5zZXRGcm9tUG9pbnRzKCBfcG9pbnRzNCApICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZpc2libGUgPSAoIHY0LnBvc2l0aW9uU2NyZWVuLnggLSB2MS5wb3NpdGlvblNjcmVlbi54ICkgKiAoIHYyLnBvc2l0aW9uU2NyZWVuLnkgLSB2MS5wb3NpdGlvblNjcmVlbi55ICkgLVxyXG5cdFx0XHRcdFx0XHRcdFx0KCB2NC5wb3NpdGlvblNjcmVlbi55IC0gdjEucG9zaXRpb25TY3JlZW4ueSApICogKCB2Mi5wb3NpdGlvblNjcmVlbi54IC0gdjEucG9zaXRpb25TY3JlZW4ueCApIDwgMCB8fFxyXG5cdFx0XHRcdFx0XHRcdFx0KCB2Mi5wb3NpdGlvblNjcmVlbi54IC0gdjMucG9zaXRpb25TY3JlZW4ueCApICogKCB2NC5wb3NpdGlvblNjcmVlbi55IC0gdjMucG9zaXRpb25TY3JlZW4ueSApIC1cclxuXHRcdFx0XHRcdFx0XHRcdCggdjIucG9zaXRpb25TY3JlZW4ueSAtIHYzLnBvc2l0aW9uU2NyZWVuLnkgKSAqICggdjQucG9zaXRpb25TY3JlZW4ueCAtIHYzLnBvc2l0aW9uU2NyZWVuLnggKSA8IDA7XHJcblxyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIHNpZGUgPT09IFRIUkVFLkRvdWJsZVNpZGUgfHwgdmlzaWJsZSA9PT0gKCBzaWRlID09PSBUSFJFRS5Gcm9udFNpZGUgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRfZmFjZSA9IGdldE5leHRGYWNlNEluUG9vbCgpO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdF9mYWNlLnYxLmNvcHkoIHYxICk7XHJcblx0XHRcdFx0XHRcdFx0XHRfZmFjZS52Mi5jb3B5KCB2MiApO1xyXG5cdFx0XHRcdFx0XHRcdFx0X2ZhY2UudjMuY29weSggdjMgKTtcclxuXHRcdFx0XHRcdFx0XHRcdF9mYWNlLnY0LmNvcHkoIHY0ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Y29udGludWU7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRfZmFjZS5ub3JtYWxNb2RlbC5jb3B5KCBmYWNlLm5vcm1hbCApO1xyXG5cclxuXHRcdFx0XHRcdGlmICggdmlzaWJsZSA9PT0gZmFsc2UgJiYgKCBzaWRlID09PSBUSFJFRS5CYWNrU2lkZSB8fCBzaWRlID09PSBUSFJFRS5Eb3VibGVTaWRlICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRfZmFjZS5ub3JtYWxNb2RlbC5uZWdhdGUoKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0X2ZhY2Uubm9ybWFsTW9kZWwuYXBwbHlNYXRyaXgzKCBfbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHRcdFx0X2ZhY2Uubm9ybWFsTW9kZWxWaWV3LmNvcHkoIF9mYWNlLm5vcm1hbE1vZGVsICkuYXBwbHlNYXRyaXgzKCBfbm9ybWFsVmlld01hdHJpeCApO1xyXG5cclxuXHRcdFx0XHRcdF9mYWNlLmNlbnRyb2lkTW9kZWwuY29weSggZmFjZS5jZW50cm9pZCApLmFwcGx5TWF0cml4NCggX21vZGVsTWF0cml4ICk7XHJcblxyXG5cdFx0XHRcdFx0ZmFjZVZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHM7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggbiA9IDAsIG5sID0gZmFjZVZlcnRleE5vcm1hbHMubGVuZ3RoOyBuIDwgbmw7IG4gKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgbm9ybWFsTW9kZWwgPSBfZmFjZS52ZXJ0ZXhOb3JtYWxzTW9kZWxbIG4gXTtcclxuXHRcdFx0XHRcdFx0bm9ybWFsTW9kZWwuY29weSggZmFjZVZlcnRleE5vcm1hbHNbIG4gXSApO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCB2aXNpYmxlID09PSBmYWxzZSAmJiAoIHNpZGUgPT09IFRIUkVFLkJhY2tTaWRlIHx8IHNpZGUgPT09IFRIUkVFLkRvdWJsZVNpZGUgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0bm9ybWFsTW9kZWwubmVnYXRlKCk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRub3JtYWxNb2RlbC5hcHBseU1hdHJpeDMoIF9ub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdFx0XHRcdHZhciBub3JtYWxNb2RlbFZpZXcgPSBfZmFjZS52ZXJ0ZXhOb3JtYWxzTW9kZWxWaWV3WyBuIF07XHJcblx0XHRcdFx0XHRcdG5vcm1hbE1vZGVsVmlldy5jb3B5KCBub3JtYWxNb2RlbCApLmFwcGx5TWF0cml4MyggX25vcm1hbFZpZXdNYXRyaXggKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0X2ZhY2UudmVydGV4Tm9ybWFsc0xlbmd0aCA9IGZhY2VWZXJ0ZXhOb3JtYWxzLmxlbmd0aDtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCBjID0gMCwgY2wgPSBmYWNlVmVydGV4VXZzLmxlbmd0aDsgYyA8IGNsOyBjICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dXZzID0gZmFjZVZlcnRleFV2c1sgYyBdWyBmIF07XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIHV2cyA9PT0gdW5kZWZpbmVkICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCB1ID0gMCwgdWwgPSB1dnMubGVuZ3RoOyB1IDwgdWw7IHUgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdF9mYWNlLnV2c1sgYyBdWyB1IF0gPSB1dnNbIHUgXTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0X2ZhY2UuY29sb3IgPSBmYWNlLmNvbG9yO1xyXG5cdFx0XHRcdFx0X2ZhY2UubWF0ZXJpYWwgPSBtYXRlcmlhbDtcclxuXHJcblx0XHRcdFx0XHRfY2VudHJvaWQuY29weSggX2ZhY2UuY2VudHJvaWRNb2RlbCApLmFwcGx5UHJvamVjdGlvbiggX3ZpZXdQcm9qZWN0aW9uTWF0cml4ICk7XHJcblxyXG5cdFx0XHRcdFx0X2ZhY2UueiA9IF9jZW50cm9pZC56O1xyXG5cclxuXHRcdFx0XHRcdF9yZW5kZXJEYXRhLmVsZW1lbnRzLnB1c2goIF9mYWNlICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpbmUgKSB7XHJcblxyXG5cdFx0XHRcdF9tb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIF92aWV3UHJvamVjdGlvbk1hdHJpeCwgX21vZGVsTWF0cml4ICk7XHJcblxyXG5cdFx0XHRcdHZlcnRpY2VzID0gb2JqZWN0Lmdlb21ldHJ5LnZlcnRpY2VzO1xyXG5cclxuXHRcdFx0XHR2MSA9IGdldE5leHRWZXJ0ZXhJblBvb2woKTtcclxuXHRcdFx0XHR2MS5wb3NpdGlvblNjcmVlbi5jb3B5KCB2ZXJ0aWNlc1sgMCBdICkuYXBwbHlNYXRyaXg0KCBfbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCApO1xyXG5cclxuXHRcdFx0XHQvLyBIYW5kbGUgTGluZVN0cmlwIGFuZCBMaW5lUGllY2VzXHJcblx0XHRcdFx0dmFyIHN0ZXAgPSBvYmplY3QudHlwZSA9PT0gVEhSRUUuTGluZVBpZWNlcyA/IDIgOiAxO1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2ID0gMSwgdmwgPSB2ZXJ0aWNlcy5sZW5ndGg7IHYgPCB2bDsgdiArKyApIHtcclxuXHJcblx0XHRcdFx0XHR2MSA9IGdldE5leHRWZXJ0ZXhJblBvb2woKTtcclxuXHRcdFx0XHRcdHYxLnBvc2l0aW9uU2NyZWVuLmNvcHkoIHZlcnRpY2VzWyB2IF0gKS5hcHBseU1hdHJpeDQoIF9tb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4ICk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCAoIHYgKyAxICkgJSBzdGVwID4gMCApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRcdHYyID0gX3ZlcnRleFBvb2xbIF92ZXJ0ZXhDb3VudCAtIDIgXTtcclxuXHJcblx0XHRcdFx0XHRfY2xpcHBlZFZlcnRleDFQb3NpdGlvblNjcmVlbi5jb3B5KCB2MS5wb3NpdGlvblNjcmVlbiApO1xyXG5cdFx0XHRcdFx0X2NsaXBwZWRWZXJ0ZXgyUG9zaXRpb25TY3JlZW4uY29weSggdjIucG9zaXRpb25TY3JlZW4gKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGNsaXBMaW5lKCBfY2xpcHBlZFZlcnRleDFQb3NpdGlvblNjcmVlbiwgX2NsaXBwZWRWZXJ0ZXgyUG9zaXRpb25TY3JlZW4gKSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdC8vIFBlcmZvcm0gdGhlIHBlcnNwZWN0aXZlIGRpdmlkZVxyXG5cdFx0XHRcdFx0XHRfY2xpcHBlZFZlcnRleDFQb3NpdGlvblNjcmVlbi5tdWx0aXBseVNjYWxhciggMSAvIF9jbGlwcGVkVmVydGV4MVBvc2l0aW9uU2NyZWVuLncgKTtcclxuXHRcdFx0XHRcdFx0X2NsaXBwZWRWZXJ0ZXgyUG9zaXRpb25TY3JlZW4ubXVsdGlwbHlTY2FsYXIoIDEgLyBfY2xpcHBlZFZlcnRleDJQb3NpdGlvblNjcmVlbi53ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRfbGluZSA9IGdldE5leHRMaW5lSW5Qb29sKCk7XHJcblx0XHRcdFx0XHRcdF9saW5lLnYxLnBvc2l0aW9uU2NyZWVuLmNvcHkoIF9jbGlwcGVkVmVydGV4MVBvc2l0aW9uU2NyZWVuICk7XHJcblx0XHRcdFx0XHRcdF9saW5lLnYyLnBvc2l0aW9uU2NyZWVuLmNvcHkoIF9jbGlwcGVkVmVydGV4MlBvc2l0aW9uU2NyZWVuICk7XHJcblxyXG5cdFx0XHRcdFx0XHRfbGluZS56ID0gTWF0aC5tYXgoIF9jbGlwcGVkVmVydGV4MVBvc2l0aW9uU2NyZWVuLnosIF9jbGlwcGVkVmVydGV4MlBvc2l0aW9uU2NyZWVuLnogKTtcclxuXHJcblx0XHRcdFx0XHRcdF9saW5lLm1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xyXG5cclxuXHRcdFx0XHRcdFx0X3JlbmRlckRhdGEuZWxlbWVudHMucHVzaCggX2xpbmUgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggbyA9IDAsIG9sID0gX3JlbmRlckRhdGEuc3ByaXRlcy5sZW5ndGg7IG8gPCBvbDsgbysrICkge1xyXG5cclxuXHRcdFx0b2JqZWN0ID0gX3JlbmRlckRhdGEuc3ByaXRlc1sgbyBdLm9iamVjdDtcclxuXHJcblx0XHRcdF9tb2RlbE1hdHJpeCA9IG9iamVjdC5tYXRyaXhXb3JsZDtcclxuXHJcblx0XHRcdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUGFydGljbGUgKSB7XHJcblxyXG5cdFx0XHRcdF92ZWN0b3I0LnNldCggX21vZGVsTWF0cml4LmVsZW1lbnRzWzEyXSwgX21vZGVsTWF0cml4LmVsZW1lbnRzWzEzXSwgX21vZGVsTWF0cml4LmVsZW1lbnRzWzE0XSwgMSApO1xyXG5cdFx0XHRcdF92ZWN0b3I0LmFwcGx5TWF0cml4NCggX3ZpZXdQcm9qZWN0aW9uTWF0cml4ICk7XHJcblxyXG5cdFx0XHRcdF92ZWN0b3I0LnogLz0gX3ZlY3RvcjQudztcclxuXHJcblx0XHRcdFx0aWYgKCBfdmVjdG9yNC56ID4gMCAmJiBfdmVjdG9yNC56IDwgMSApIHtcclxuXHJcblx0XHRcdFx0XHRfcGFydGljbGUgPSBnZXROZXh0UGFydGljbGVJblBvb2woKTtcclxuXHRcdFx0XHRcdF9wYXJ0aWNsZS5vYmplY3QgPSBvYmplY3Q7XHJcblx0XHRcdFx0XHRfcGFydGljbGUueCA9IF92ZWN0b3I0LnggLyBfdmVjdG9yNC53O1xyXG5cdFx0XHRcdFx0X3BhcnRpY2xlLnkgPSBfdmVjdG9yNC55IC8gX3ZlY3RvcjQudztcclxuXHRcdFx0XHRcdF9wYXJ0aWNsZS56ID0gX3ZlY3RvcjQuejtcclxuXHJcblx0XHRcdFx0XHRfcGFydGljbGUucm90YXRpb24gPSBvYmplY3Qucm90YXRpb24uejtcclxuXHJcblx0XHRcdFx0XHRfcGFydGljbGUuc2NhbGUueCA9IG9iamVjdC5zY2FsZS54ICogTWF0aC5hYnMoIF9wYXJ0aWNsZS54IC0gKCBfdmVjdG9yNC54ICsgY2FtZXJhLnByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbMF0gKSAvICggX3ZlY3RvcjQudyArIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzWzEyXSApICk7XHJcblx0XHRcdFx0XHRfcGFydGljbGUuc2NhbGUueSA9IG9iamVjdC5zY2FsZS55ICogTWF0aC5hYnMoIF9wYXJ0aWNsZS55IC0gKCBfdmVjdG9yNC55ICsgY2FtZXJhLnByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbNV0gKSAvICggX3ZlY3RvcjQudyArIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzWzEzXSApICk7XHJcblxyXG5cdFx0XHRcdFx0X3BhcnRpY2xlLm1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xyXG5cclxuXHRcdFx0XHRcdF9yZW5kZXJEYXRhLmVsZW1lbnRzLnB1c2goIF9wYXJ0aWNsZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggc29ydEVsZW1lbnRzID09PSB0cnVlICkgX3JlbmRlckRhdGEuZWxlbWVudHMuc29ydCggcGFpbnRlclNvcnQgKTtcclxuXHJcblx0XHRyZXR1cm4gX3JlbmRlckRhdGE7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIFBvb2xzXHJcblxyXG5cdGZ1bmN0aW9uIGdldE5leHRPYmplY3RJblBvb2woKSB7XHJcblxyXG5cdFx0aWYgKCBfb2JqZWN0Q291bnQgPT09IF9vYmplY3RQb29sTGVuZ3RoICkge1xyXG5cclxuXHRcdFx0dmFyIG9iamVjdCA9IG5ldyBUSFJFRS5SZW5kZXJhYmxlT2JqZWN0KCk7XHJcblx0XHRcdF9vYmplY3RQb29sLnB1c2goIG9iamVjdCApO1xyXG5cdFx0XHRfb2JqZWN0UG9vbExlbmd0aCArKztcclxuXHRcdFx0X29iamVjdENvdW50ICsrO1xyXG5cdFx0XHRyZXR1cm4gb2JqZWN0O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gX29iamVjdFBvb2xbIF9vYmplY3RDb3VudCArKyBdO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdldE5leHRWZXJ0ZXhJblBvb2woKSB7XHJcblxyXG5cdFx0aWYgKCBfdmVydGV4Q291bnQgPT09IF92ZXJ0ZXhQb29sTGVuZ3RoICkge1xyXG5cclxuXHRcdFx0dmFyIHZlcnRleCA9IG5ldyBUSFJFRS5SZW5kZXJhYmxlVmVydGV4KCk7XHJcblx0XHRcdF92ZXJ0ZXhQb29sLnB1c2goIHZlcnRleCApO1xyXG5cdFx0XHRfdmVydGV4UG9vbExlbmd0aCArKztcclxuXHRcdFx0X3ZlcnRleENvdW50ICsrO1xyXG5cdFx0XHRyZXR1cm4gdmVydGV4O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gX3ZlcnRleFBvb2xbIF92ZXJ0ZXhDb3VudCArKyBdO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdldE5leHRGYWNlM0luUG9vbCgpIHtcclxuXHJcblx0XHRpZiAoIF9mYWNlM0NvdW50ID09PSBfZmFjZTNQb29sTGVuZ3RoICkge1xyXG5cclxuXHRcdFx0dmFyIGZhY2UgPSBuZXcgVEhSRUUuUmVuZGVyYWJsZUZhY2UzKCk7XHJcblx0XHRcdF9mYWNlM1Bvb2wucHVzaCggZmFjZSApO1xyXG5cdFx0XHRfZmFjZTNQb29sTGVuZ3RoICsrO1xyXG5cdFx0XHRfZmFjZTNDb3VudCArKztcclxuXHRcdFx0cmV0dXJuIGZhY2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBfZmFjZTNQb29sWyBfZmFjZTNDb3VudCArKyBdO1xyXG5cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZXROZXh0RmFjZTRJblBvb2woKSB7XHJcblxyXG5cdFx0aWYgKCBfZmFjZTRDb3VudCA9PT0gX2ZhY2U0UG9vbExlbmd0aCApIHtcclxuXHJcblx0XHRcdHZhciBmYWNlID0gbmV3IFRIUkVFLlJlbmRlcmFibGVGYWNlNCgpO1xyXG5cdFx0XHRfZmFjZTRQb29sLnB1c2goIGZhY2UgKTtcclxuXHRcdFx0X2ZhY2U0UG9vbExlbmd0aCArKztcclxuXHRcdFx0X2ZhY2U0Q291bnQgKys7XHJcblx0XHRcdHJldHVybiBmYWNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gX2ZhY2U0UG9vbFsgX2ZhY2U0Q291bnQgKysgXTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZXROZXh0TGluZUluUG9vbCgpIHtcclxuXHJcblx0XHRpZiAoIF9saW5lQ291bnQgPT09IF9saW5lUG9vbExlbmd0aCApIHtcclxuXHJcblx0XHRcdHZhciBsaW5lID0gbmV3IFRIUkVFLlJlbmRlcmFibGVMaW5lKCk7XHJcblx0XHRcdF9saW5lUG9vbC5wdXNoKCBsaW5lICk7XHJcblx0XHRcdF9saW5lUG9vbExlbmd0aCArKztcclxuXHRcdFx0X2xpbmVDb3VudCArK1xyXG5cdFx0XHRyZXR1cm4gbGluZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIF9saW5lUG9vbFsgX2xpbmVDb3VudCArKyBdO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdldE5leHRQYXJ0aWNsZUluUG9vbCgpIHtcclxuXHJcblx0XHRpZiAoIF9wYXJ0aWNsZUNvdW50ID09PSBfcGFydGljbGVQb29sTGVuZ3RoICkge1xyXG5cclxuXHRcdFx0dmFyIHBhcnRpY2xlID0gbmV3IFRIUkVFLlJlbmRlcmFibGVQYXJ0aWNsZSgpO1xyXG5cdFx0XHRfcGFydGljbGVQb29sLnB1c2goIHBhcnRpY2xlICk7XHJcblx0XHRcdF9wYXJ0aWNsZVBvb2xMZW5ndGggKys7XHJcblx0XHRcdF9wYXJ0aWNsZUNvdW50ICsrXHJcblx0XHRcdHJldHVybiBwYXJ0aWNsZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIF9wYXJ0aWNsZVBvb2xbIF9wYXJ0aWNsZUNvdW50ICsrIF07XHJcblxyXG5cdH1cclxuXHJcblx0Ly9cclxuXHJcblx0ZnVuY3Rpb24gcGFpbnRlclNvcnQoIGEsIGIgKSB7XHJcblxyXG5cdFx0cmV0dXJuIGIueiAtIGEuejtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBjbGlwTGluZSggczEsIHMyICkge1xyXG5cclxuXHRcdHZhciBhbHBoYTEgPSAwLCBhbHBoYTIgPSAxLFxyXG5cclxuXHRcdC8vIENhbGN1bGF0ZSB0aGUgYm91bmRhcnkgY29vcmRpbmF0ZSBvZiBlYWNoIHZlcnRleCBmb3IgdGhlIG5lYXIgYW5kIGZhciBjbGlwIHBsYW5lcyxcclxuXHRcdC8vIFogPSAtMSBhbmQgWiA9ICsxLCByZXNwZWN0aXZlbHkuXHJcblx0XHRiYzFuZWFyID0gIHMxLnogKyBzMS53LFxyXG5cdFx0YmMybmVhciA9ICBzMi56ICsgczIudyxcclxuXHRcdGJjMWZhciA9ICAtIHMxLnogKyBzMS53LFxyXG5cdFx0YmMyZmFyID0gIC0gczIueiArIHMyLnc7XHJcblxyXG5cdFx0aWYgKCBiYzFuZWFyID49IDAgJiYgYmMybmVhciA+PSAwICYmIGJjMWZhciA+PSAwICYmIGJjMmZhciA+PSAwICkge1xyXG5cclxuXHRcdFx0Ly8gQm90aCB2ZXJ0aWNlcyBsaWUgZW50aXJlbHkgd2l0aGluIGFsbCBjbGlwIHBsYW5lcy5cclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggKCBiYzFuZWFyIDwgMCAmJiBiYzJuZWFyIDwgMCkgfHwgKGJjMWZhciA8IDAgJiYgYmMyZmFyIDwgMCApICkge1xyXG5cclxuXHRcdFx0Ly8gQm90aCB2ZXJ0aWNlcyBsaWUgZW50aXJlbHkgb3V0c2lkZSBvbmUgb2YgdGhlIGNsaXAgcGxhbmVzLlxyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdC8vIFRoZSBsaW5lIHNlZ21lbnQgc3BhbnMgYXQgbGVhc3Qgb25lIGNsaXAgcGxhbmUuXHJcblxyXG5cdFx0XHRpZiAoIGJjMW5lYXIgPCAwICkge1xyXG5cclxuXHRcdFx0XHQvLyB2MSBsaWVzIG91dHNpZGUgdGhlIG5lYXIgcGxhbmUsIHYyIGluc2lkZVxyXG5cdFx0XHRcdGFscGhhMSA9IE1hdGgubWF4KCBhbHBoYTEsIGJjMW5lYXIgLyAoIGJjMW5lYXIgLSBiYzJuZWFyICkgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGJjMm5lYXIgPCAwICkge1xyXG5cclxuXHRcdFx0XHQvLyB2MiBsaWVzIG91dHNpZGUgdGhlIG5lYXIgcGxhbmUsIHYxIGluc2lkZVxyXG5cdFx0XHRcdGFscGhhMiA9IE1hdGgubWluKCBhbHBoYTIsIGJjMW5lYXIgLyAoIGJjMW5lYXIgLSBiYzJuZWFyICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggYmMxZmFyIDwgMCApIHtcclxuXHJcblx0XHRcdFx0Ly8gdjEgbGllcyBvdXRzaWRlIHRoZSBmYXIgcGxhbmUsIHYyIGluc2lkZVxyXG5cdFx0XHRcdGFscGhhMSA9IE1hdGgubWF4KCBhbHBoYTEsIGJjMWZhciAvICggYmMxZmFyIC0gYmMyZmFyICkgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGJjMmZhciA8IDAgKSB7XHJcblxyXG5cdFx0XHRcdC8vIHYyIGxpZXMgb3V0c2lkZSB0aGUgZmFyIHBsYW5lLCB2MiBpbnNpZGVcclxuXHRcdFx0XHRhbHBoYTIgPSBNYXRoLm1pbiggYWxwaGEyLCBiYzFmYXIgLyAoIGJjMWZhciAtIGJjMmZhciApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGFscGhhMiA8IGFscGhhMSApIHtcclxuXHJcblx0XHRcdFx0Ly8gVGhlIGxpbmUgc2VnbWVudCBzcGFucyB0d28gYm91bmRhcmllcywgYnV0IGlzIG91dHNpZGUgYm90aCBvZiB0aGVtLlxyXG5cdFx0XHRcdC8vIChUaGlzIGNhbid0IGhhcHBlbiB3aGVuIHdlJ3JlIG9ubHkgY2xpcHBpbmcgYWdhaW5zdCBqdXN0IG5lYXIvZmFyIGJ1dCBnb29kXHJcblx0XHRcdFx0Ly8gIHRvIGxlYXZlIHRoZSBjaGVjayBoZXJlIGZvciBmdXR1cmUgdXNhZ2UgaWYgb3RoZXIgY2xpcCBwbGFuZXMgYXJlIGFkZGVkLilcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHQvLyBVcGRhdGUgdGhlIHMxIGFuZCBzMiB2ZXJ0aWNlcyB0byBtYXRjaCB0aGUgY2xpcHBlZCBsaW5lIHNlZ21lbnQuXHJcblx0XHRcdFx0czEubGVycCggczIsIGFscGhhMSApO1xyXG5cdFx0XHRcdHMyLmxlcnAoIHMxLCAxIC0gYWxwaGEyICk7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufTtcclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuRmFjZTMgPSBmdW5jdGlvbiAoIGEsIGIsIGMsIG5vcm1hbCwgY29sb3IsIG1hdGVyaWFsSW5kZXggKSB7XHJcblxyXG5cdHRoaXMuYSA9IGE7XHJcblx0dGhpcy5iID0gYjtcclxuXHR0aGlzLmMgPSBjO1xyXG5cclxuXHR0aGlzLm5vcm1hbCA9IG5vcm1hbCBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjMgPyBub3JtYWwgOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHRoaXMudmVydGV4Tm9ybWFscyA9IG5vcm1hbCBpbnN0YW5jZW9mIEFycmF5ID8gbm9ybWFsIDogWyBdO1xyXG5cclxuXHR0aGlzLmNvbG9yID0gY29sb3IgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciA/IGNvbG9yIDogbmV3IFRIUkVFLkNvbG9yKCk7XHJcblx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBjb2xvciBpbnN0YW5jZW9mIEFycmF5ID8gY29sb3IgOiBbXTtcclxuXHJcblx0dGhpcy52ZXJ0ZXhUYW5nZW50cyA9IFtdO1xyXG5cclxuXHR0aGlzLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4ICE9PSB1bmRlZmluZWQgPyBtYXRlcmlhbEluZGV4IDogMDtcclxuXHJcblx0dGhpcy5jZW50cm9pZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRmFjZTMucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuRmFjZTMsXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMgKTtcclxuXHJcblx0XHRmYWNlLm5vcm1hbC5jb3B5KCB0aGlzLm5vcm1hbCApO1xyXG5cdFx0ZmFjZS5jb2xvci5jb3B5KCB0aGlzLmNvbG9yICk7XHJcblx0XHRmYWNlLmNlbnRyb2lkLmNvcHkoIHRoaXMuY2VudHJvaWQgKTtcclxuXHJcblx0XHRmYWNlLm1hdGVyaWFsSW5kZXggPSB0aGlzLm1hdGVyaWFsSW5kZXg7XHJcblxyXG5cdFx0dmFyIGksIGlsO1xyXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gdGhpcy52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkgZmFjZS52ZXJ0ZXhOb3JtYWxzWyBpIF0gPSB0aGlzLnZlcnRleE5vcm1hbHNbIGkgXS5jbG9uZSgpO1xyXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gdGhpcy52ZXJ0ZXhDb2xvcnMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSBmYWNlLnZlcnRleENvbG9yc1sgaSBdID0gdGhpcy52ZXJ0ZXhDb2xvcnNbIGkgXS5jbG9uZSgpO1xyXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gdGhpcy52ZXJ0ZXhUYW5nZW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIGZhY2UudmVydGV4VGFuZ2VudHNbIGkgXSA9IHRoaXMudmVydGV4VGFuZ2VudHNbIGkgXS5jbG9uZSgpO1xyXG5cclxuXHRcdHJldHVybiBmYWNlO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5GYWNlNCA9IGZ1bmN0aW9uICggYSwgYiwgYywgZCwgbm9ybWFsLCBjb2xvciwgbWF0ZXJpYWxJbmRleCApIHtcclxuXHJcblx0dGhpcy5hID0gYTtcclxuXHR0aGlzLmIgPSBiO1xyXG5cdHRoaXMuYyA9IGM7XHJcblx0dGhpcy5kID0gZDtcclxuXHJcblx0dGhpcy5ub3JtYWwgPSBub3JtYWwgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IzID8gbm9ybWFsIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR0aGlzLnZlcnRleE5vcm1hbHMgPSBub3JtYWwgaW5zdGFuY2VvZiBBcnJheSA/IG5vcm1hbCA6IFsgXTtcclxuXHJcblx0dGhpcy5jb2xvciA9IGNvbG9yIGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgPyBjb2xvciA6IG5ldyBUSFJFRS5Db2xvcigpO1xyXG5cdHRoaXMudmVydGV4Q29sb3JzID0gY29sb3IgaW5zdGFuY2VvZiBBcnJheSA/IGNvbG9yIDogW107XHJcblxyXG5cdHRoaXMudmVydGV4VGFuZ2VudHMgPSBbXTtcclxuXHJcblx0dGhpcy5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWxJbmRleCA6IDA7XHJcblxyXG5cdHRoaXMuY2VudHJvaWQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkZhY2U0LnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkZhY2U0LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBmYWNlID0gbmV3IFRIUkVFLkZhY2U0KCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCB0aGlzLmQgKTtcclxuXHJcblx0XHRmYWNlLm5vcm1hbC5jb3B5KCB0aGlzLm5vcm1hbCApO1xyXG5cdFx0ZmFjZS5jb2xvci5jb3B5KCB0aGlzLmNvbG9yICk7XHJcblx0XHRmYWNlLmNlbnRyb2lkLmNvcHkoIHRoaXMuY2VudHJvaWQgKTtcclxuXHJcblx0XHRmYWNlLm1hdGVyaWFsSW5kZXggPSB0aGlzLm1hdGVyaWFsSW5kZXg7XHJcblxyXG5cdFx0dmFyIGksIGlsO1xyXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gdGhpcy52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkgZmFjZS52ZXJ0ZXhOb3JtYWxzWyBpIF0gPSB0aGlzLnZlcnRleE5vcm1hbHNbIGkgXS5jbG9uZSgpO1xyXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gdGhpcy52ZXJ0ZXhDb2xvcnMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSBmYWNlLnZlcnRleENvbG9yc1sgaSBdID0gdGhpcy52ZXJ0ZXhDb2xvcnNbIGkgXS5jbG9uZSgpO1xyXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gdGhpcy52ZXJ0ZXhUYW5nZW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIGZhY2UudmVydGV4VGFuZ2VudHNbIGkgXSA9IHRoaXMudmVydGV4VGFuZ2VudHNbIGkgXS5jbG9uZSgpO1xyXG5cclxuXHRcdHJldHVybiBmYWNlO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBraWxlIC8gaHR0cDovL2tpbGUuc3RyYXZhZ2FuemEub3JnL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxyXG4gKi9cclxuXHJcblRIUkVFLkdlb21ldHJ5ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRUSFJFRS5FdmVudERpc3BhdGNoZXIuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLmlkID0gVEhSRUUuR2VvbWV0cnlJZENvdW50ICsrO1xyXG5cclxuXHR0aGlzLm5hbWUgPSAnJztcclxuXHJcblx0dGhpcy52ZXJ0aWNlcyA9IFtdO1xyXG5cdHRoaXMuY29sb3JzID0gW107ICAvLyBvbmUtdG8tb25lIHZlcnRleCBjb2xvcnMsIHVzZWQgaW4gUGFydGljbGVTeXN0ZW0sIExpbmUgYW5kIFJpYmJvblxyXG5cdHRoaXMubm9ybWFscyA9IFtdOyAvLyBvbmUtdG8tb25lIHZlcnRleCBub3JtYWxzLCB1c2VkIGluIFJpYmJvblxyXG5cclxuXHR0aGlzLmZhY2VzID0gW107XHJcblxyXG5cdHRoaXMuZmFjZVV2cyA9IFtbXV07XHJcblx0dGhpcy5mYWNlVmVydGV4VXZzID0gW1tdXTtcclxuXHJcblx0dGhpcy5tb3JwaFRhcmdldHMgPSBbXTtcclxuXHR0aGlzLm1vcnBoQ29sb3JzID0gW107XHJcblx0dGhpcy5tb3JwaE5vcm1hbHMgPSBbXTtcclxuXHJcblx0dGhpcy5za2luV2VpZ2h0cyA9IFtdO1xyXG5cdHRoaXMuc2tpbkluZGljZXMgPSBbXTtcclxuXHJcblx0dGhpcy5saW5lRGlzdGFuY2VzID0gW107XHJcblxyXG5cdHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xyXG5cdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBudWxsO1xyXG5cclxuXHR0aGlzLmhhc1RhbmdlbnRzID0gZmFsc2U7XHJcblxyXG5cdHRoaXMuZHluYW1pYyA9IHRydWU7IC8vIHRoZSBpbnRlcm1lZGlhdGUgdHlwZWQgYXJyYXlzIHdpbGwgYmUgZGVsZXRlZCB3aGVuIHNldCB0byBmYWxzZVxyXG5cclxuXHQvLyB1cGRhdGUgZmxhZ3NcclxuXHJcblx0dGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHR0aGlzLmVsZW1lbnRzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdHRoaXMudXZzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHR0aGlzLnRhbmdlbnRzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdHRoaXMuY29sb3JzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdHRoaXMubGluZURpc3RhbmNlc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0dGhpcy5idWZmZXJzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkdlb21ldHJ5LFxyXG5cclxuXHRhcHBseU1hdHJpeDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XHJcblxyXG5cdFx0dmFyIG5vcm1hbE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXgzKCkuZ2V0SW52ZXJzZSggbWF0cml4ICkudHJhbnNwb3NlKCk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgdmVydGV4ID0gdGhpcy52ZXJ0aWNlc1sgaSBdO1xyXG5cdFx0XHR2ZXJ0ZXguYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgZmFjZSA9IHRoaXMuZmFjZXNbIGkgXTtcclxuXHRcdFx0ZmFjZS5ub3JtYWwuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBmYWNlLnZlcnRleE5vcm1hbHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2UudmVydGV4Tm9ybWFsc1sgaiBdLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmYWNlLmNlbnRyb2lkLmFwcGx5TWF0cml4NCggbWF0cml4ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRjb21wdXRlQ2VudHJvaWRzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGYsIGZsLCBmYWNlO1xyXG5cclxuXHRcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xyXG5cdFx0XHRmYWNlLmNlbnRyb2lkLnNldCggMCwgMCwgMCApO1xyXG5cclxuXHRcdFx0aWYgKCBmYWNlIGluc3RhbmNlb2YgVEhSRUUuRmFjZTMgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2UuY2VudHJvaWQuYWRkKCB0aGlzLnZlcnRpY2VzWyBmYWNlLmEgXSApO1xyXG5cdFx0XHRcdGZhY2UuY2VudHJvaWQuYWRkKCB0aGlzLnZlcnRpY2VzWyBmYWNlLmIgXSApO1xyXG5cdFx0XHRcdGZhY2UuY2VudHJvaWQuYWRkKCB0aGlzLnZlcnRpY2VzWyBmYWNlLmMgXSApO1xyXG5cdFx0XHRcdGZhY2UuY2VudHJvaWQuZGl2aWRlU2NhbGFyKCAzICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBmYWNlIGluc3RhbmNlb2YgVEhSRUUuRmFjZTQgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2UuY2VudHJvaWQuYWRkKCB0aGlzLnZlcnRpY2VzWyBmYWNlLmEgXSApO1xyXG5cdFx0XHRcdGZhY2UuY2VudHJvaWQuYWRkKCB0aGlzLnZlcnRpY2VzWyBmYWNlLmIgXSApO1xyXG5cdFx0XHRcdGZhY2UuY2VudHJvaWQuYWRkKCB0aGlzLnZlcnRpY2VzWyBmYWNlLmMgXSApO1xyXG5cdFx0XHRcdGZhY2UuY2VudHJvaWQuYWRkKCB0aGlzLnZlcnRpY2VzWyBmYWNlLmQgXSApO1xyXG5cdFx0XHRcdGZhY2UuY2VudHJvaWQuZGl2aWRlU2NhbGFyKCA0ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRjb21wdXRlRmFjZU5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgY2IgPSBuZXcgVEhSRUUuVmVjdG9yMygpLCBhYiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcclxuXHJcblx0XHRcdHZhciB2QSA9IHRoaXMudmVydGljZXNbIGZhY2UuYSBdO1xyXG5cdFx0XHR2YXIgdkIgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmIgXTtcclxuXHRcdFx0dmFyIHZDID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5jIF07XHJcblxyXG5cdFx0XHRjYi5zdWJWZWN0b3JzKCB2QywgdkIgKTtcclxuXHRcdFx0YWIuc3ViVmVjdG9ycyggdkEsIHZCICk7XHJcblx0XHRcdGNiLmNyb3NzKCBhYiApO1xyXG5cclxuXHRcdFx0Y2Iubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHRmYWNlLm5vcm1hbC5jb3B5KCBjYiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0Y29tcHV0ZVZlcnRleE5vcm1hbHM6IGZ1bmN0aW9uICggYXJlYVdlaWdodGVkICkge1xyXG5cclxuXHRcdHZhciB2LCB2bCwgZiwgZmwsIGZhY2UsIHZlcnRpY2VzO1xyXG5cclxuXHRcdC8vIGNyZWF0ZSBpbnRlcm5hbCBidWZmZXJzIGZvciByZXVzZSB3aGVuIGNhbGxpbmcgdGhpcyBtZXRob2QgcmVwZWF0ZWRseVxyXG5cdFx0Ly8gKG90aGVyd2lzZSBtZW1vcnkgYWxsb2NhdGlvbiAvIGRlYWxsb2NhdGlvbiBldmVyeSBmcmFtZSBpcyBiaWcgcmVzb3VyY2UgaG9nKVxyXG5cclxuXHRcdGlmICggdGhpcy5fX3RtcFZlcnRpY2VzID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl9fdG1wVmVydGljZXMgPSBuZXcgQXJyYXkoIHRoaXMudmVydGljZXMubGVuZ3RoICk7XHJcblx0XHRcdHZlcnRpY2VzID0gdGhpcy5fX3RtcFZlcnRpY2VzO1xyXG5cclxuXHRcdFx0Zm9yICggdiA9IDAsIHZsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IHYgPCB2bDsgdiArKyApIHtcclxuXHJcblx0XHRcdFx0dmVydGljZXNbIHYgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGZhY2UgaW5zdGFuY2VvZiBUSFJFRS5GYWNlMyApIHtcclxuXHJcblx0XHRcdFx0XHRmYWNlLnZlcnRleE5vcm1hbHMgPSBbIG5ldyBUSFJFRS5WZWN0b3IzKCksIG5ldyBUSFJFRS5WZWN0b3IzKCksIG5ldyBUSFJFRS5WZWN0b3IzKCkgXTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggZmFjZSBpbnN0YW5jZW9mIFRIUkVFLkZhY2U0ICkge1xyXG5cclxuXHRcdFx0XHRcdGZhY2UudmVydGV4Tm9ybWFscyA9IFsgbmV3IFRIUkVFLlZlY3RvcjMoKSwgbmV3IFRIUkVFLlZlY3RvcjMoKSwgbmV3IFRIUkVFLlZlY3RvcjMoKSwgbmV3IFRIUkVFLlZlY3RvcjMoKSBdO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHZlcnRpY2VzID0gdGhpcy5fX3RtcFZlcnRpY2VzO1xyXG5cclxuXHRcdFx0Zm9yICggdiA9IDAsIHZsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IHYgPCB2bDsgdiArKyApIHtcclxuXHJcblx0XHRcdFx0dmVydGljZXNbIHYgXS5zZXQoIDAsIDAsIDAgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBhcmVhV2VpZ2h0ZWQgKSB7XHJcblxyXG5cdFx0XHQvLyB2ZXJ0ZXggbm9ybWFscyB3ZWlnaHRlZCBieSB0cmlhbmdsZSBhcmVhc1xyXG5cdFx0XHQvLyBodHRwOi8vd3d3LmlxdWlsZXpsZXMub3JnL3d3dy9hcnRpY2xlcy9ub3JtYWxzL25vcm1hbHMuaHRtXHJcblxyXG5cdFx0XHR2YXIgdkEsIHZCLCB2QywgdkQ7XHJcblx0XHRcdHZhciBjYiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIGFiID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0XHRkYiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIGRjID0gbmV3IFRIUkVFLlZlY3RvcjMoKSwgYmMgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcclxuXHJcblx0XHRcdFx0aWYgKCBmYWNlIGluc3RhbmNlb2YgVEhSRUUuRmFjZTMgKSB7XHJcblxyXG5cdFx0XHRcdFx0dkEgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmEgXTtcclxuXHRcdFx0XHRcdHZCID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5iIF07XHJcblx0XHRcdFx0XHR2QyA9IHRoaXMudmVydGljZXNbIGZhY2UuYyBdO1xyXG5cclxuXHRcdFx0XHRcdGNiLnN1YlZlY3RvcnMoIHZDLCB2QiApO1xyXG5cdFx0XHRcdFx0YWIuc3ViVmVjdG9ycyggdkEsIHZCICk7XHJcblx0XHRcdFx0XHRjYi5jcm9zcyggYWIgKTtcclxuXHJcblx0XHRcdFx0XHR2ZXJ0aWNlc1sgZmFjZS5hIF0uYWRkKCBjYiApO1xyXG5cdFx0XHRcdFx0dmVydGljZXNbIGZhY2UuYiBdLmFkZCggY2IgKTtcclxuXHRcdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmMgXS5hZGQoIGNiICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGZhY2UgaW5zdGFuY2VvZiBUSFJFRS5GYWNlNCApIHtcclxuXHJcblx0XHRcdFx0XHR2QSA9IHRoaXMudmVydGljZXNbIGZhY2UuYSBdO1xyXG5cdFx0XHRcdFx0dkIgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmIgXTtcclxuXHRcdFx0XHRcdHZDID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5jIF07XHJcblx0XHRcdFx0XHR2RCA9IHRoaXMudmVydGljZXNbIGZhY2UuZCBdO1xyXG5cclxuXHRcdFx0XHRcdC8vIGFiZFxyXG5cclxuXHRcdFx0XHRcdGRiLnN1YlZlY3RvcnMoIHZELCB2QiApO1xyXG5cdFx0XHRcdFx0YWIuc3ViVmVjdG9ycyggdkEsIHZCICk7XHJcblx0XHRcdFx0XHRkYi5jcm9zcyggYWIgKTtcclxuXHJcblx0XHRcdFx0XHR2ZXJ0aWNlc1sgZmFjZS5hIF0uYWRkKCBkYiApO1xyXG5cdFx0XHRcdFx0dmVydGljZXNbIGZhY2UuYiBdLmFkZCggZGIgKTtcclxuXHRcdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmQgXS5hZGQoIGRiICk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gYmNkXHJcblxyXG5cdFx0XHRcdFx0ZGMuc3ViVmVjdG9ycyggdkQsIHZDICk7XHJcblx0XHRcdFx0XHRiYy5zdWJWZWN0b3JzKCB2QiwgdkMgKTtcclxuXHRcdFx0XHRcdGRjLmNyb3NzKCBiYyApO1xyXG5cclxuXHRcdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmIgXS5hZGQoIGRjICk7XHJcblx0XHRcdFx0XHR2ZXJ0aWNlc1sgZmFjZS5jIF0uYWRkKCBkYyApO1xyXG5cdFx0XHRcdFx0dmVydGljZXNbIGZhY2UuZCBdLmFkZCggZGMgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGZhY2UgaW5zdGFuY2VvZiBUSFJFRS5GYWNlMyApIHtcclxuXHJcblx0XHRcdFx0XHR2ZXJ0aWNlc1sgZmFjZS5hIF0uYWRkKCBmYWNlLm5vcm1hbCApO1xyXG5cdFx0XHRcdFx0dmVydGljZXNbIGZhY2UuYiBdLmFkZCggZmFjZS5ub3JtYWwgKTtcclxuXHRcdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmMgXS5hZGQoIGZhY2Uubm9ybWFsICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGZhY2UgaW5zdGFuY2VvZiBUSFJFRS5GYWNlNCApIHtcclxuXHJcblx0XHRcdFx0XHR2ZXJ0aWNlc1sgZmFjZS5hIF0uYWRkKCBmYWNlLm5vcm1hbCApO1xyXG5cdFx0XHRcdFx0dmVydGljZXNbIGZhY2UuYiBdLmFkZCggZmFjZS5ub3JtYWwgKTtcclxuXHRcdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmMgXS5hZGQoIGZhY2Uubm9ybWFsICk7XHJcblx0XHRcdFx0XHR2ZXJ0aWNlc1sgZmFjZS5kIF0uYWRkKCBmYWNlLm5vcm1hbCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIHYgPSAwLCB2bCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyB2IDwgdmw7IHYgKysgKSB7XHJcblxyXG5cdFx0XHR2ZXJ0aWNlc1sgdiBdLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcclxuXHJcblx0XHRcdGlmICggZmFjZSBpbnN0YW5jZW9mIFRIUkVFLkZhY2UzICkge1xyXG5cclxuXHRcdFx0XHRmYWNlLnZlcnRleE5vcm1hbHNbIDAgXS5jb3B5KCB2ZXJ0aWNlc1sgZmFjZS5hIF0gKTtcclxuXHRcdFx0XHRmYWNlLnZlcnRleE5vcm1hbHNbIDEgXS5jb3B5KCB2ZXJ0aWNlc1sgZmFjZS5iIF0gKTtcclxuXHRcdFx0XHRmYWNlLnZlcnRleE5vcm1hbHNbIDIgXS5jb3B5KCB2ZXJ0aWNlc1sgZmFjZS5jIF0gKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGZhY2UgaW5zdGFuY2VvZiBUSFJFRS5GYWNlNCApIHtcclxuXHJcblx0XHRcdFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzWyAwIF0uY29weSggdmVydGljZXNbIGZhY2UuYSBdICk7XHJcblx0XHRcdFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzWyAxIF0uY29weSggdmVydGljZXNbIGZhY2UuYiBdICk7XHJcblx0XHRcdFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzWyAyIF0uY29weSggdmVydGljZXNbIGZhY2UuYyBdICk7XHJcblx0XHRcdFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzWyAzIF0uY29weSggdmVydGljZXNbIGZhY2UuZCBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRjb21wdXRlTW9ycGhOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGksIGlsLCBmLCBmbCwgZmFjZTtcclxuXHJcblx0XHQvLyBzYXZlIG9yaWdpbmFsIG5vcm1hbHNcclxuXHRcdC8vIC0gY3JlYXRlIHRlbXAgdmFyaWFibGVzIG9uIGZpcnN0IGFjY2Vzc1xyXG5cdFx0Ly8gICBvdGhlcndpc2UganVzdCBjb3B5IChmb3IgZmFzdGVyIHJlcGVhdGVkIGNhbGxzKVxyXG5cclxuXHRcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xyXG5cclxuXHRcdFx0aWYgKCAhIGZhY2UuX19vcmlnaW5hbEZhY2VOb3JtYWwgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2UuX19vcmlnaW5hbEZhY2VOb3JtYWwgPSBmYWNlLm5vcm1hbC5jbG9uZSgpO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0ZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbC5jb3B5KCBmYWNlLm5vcm1hbCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCAhIGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHMgKSBmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzID0gW107XHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMCwgaWwgPSBmYWNlLnZlcnRleE5vcm1hbHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggISBmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzWyBpIF0gKSB7XHJcblxyXG5cdFx0XHRcdFx0ZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFsc1sgaSBdID0gZmFjZS52ZXJ0ZXhOb3JtYWxzWyBpIF0uY2xvbmUoKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzWyBpIF0uY29weSggZmFjZS52ZXJ0ZXhOb3JtYWxzWyBpIF0gKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyB1c2UgdGVtcCBnZW9tZXRyeSB0byBjb21wdXRlIGZhY2UgYW5kIHZlcnRleCBub3JtYWxzIGZvciBlYWNoIG1vcnBoXHJcblxyXG5cdFx0dmFyIHRtcEdlbyA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xyXG5cdFx0dG1wR2VvLmZhY2VzID0gdGhpcy5mYWNlcztcclxuXHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSB0aGlzLm1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdC8vIGNyZWF0ZSBvbiBmaXJzdCBhY2Nlc3NcclxuXHJcblx0XHRcdGlmICggISB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLm1vcnBoTm9ybWFsc1sgaSBdID0ge307XHJcblx0XHRcdFx0dGhpcy5tb3JwaE5vcm1hbHNbIGkgXS5mYWNlTm9ybWFscyA9IFtdO1xyXG5cdFx0XHRcdHRoaXMubW9ycGhOb3JtYWxzWyBpIF0udmVydGV4Tm9ybWFscyA9IFtdO1xyXG5cclxuXHRcdFx0XHR2YXIgZHN0Tm9ybWFsc0ZhY2UgPSB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdLmZhY2VOb3JtYWxzO1xyXG5cdFx0XHRcdHZhciBkc3ROb3JtYWxzVmVydGV4ID0gdGhpcy5tb3JwaE5vcm1hbHNbIGkgXS52ZXJ0ZXhOb3JtYWxzO1xyXG5cclxuXHRcdFx0XHR2YXIgZmFjZU5vcm1hbCwgdmVydGV4Tm9ybWFscztcclxuXHJcblx0XHRcdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xyXG5cclxuXHRcdFx0XHRcdGZhY2VOb3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0XHRcdGlmICggZmFjZSBpbnN0YW5jZW9mIFRIUkVFLkZhY2UzICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmVydGV4Tm9ybWFscyA9IHsgYTogbmV3IFRIUkVFLlZlY3RvcjMoKSwgYjogbmV3IFRIUkVFLlZlY3RvcjMoKSwgYzogbmV3IFRIUkVFLlZlY3RvcjMoKSB9O1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzID0geyBhOiBuZXcgVEhSRUUuVmVjdG9yMygpLCBiOiBuZXcgVEhSRUUuVmVjdG9yMygpLCBjOiBuZXcgVEhSRUUuVmVjdG9yMygpLCBkOiBuZXcgVEhSRUUuVmVjdG9yMygpIH07XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGRzdE5vcm1hbHNGYWNlLnB1c2goIGZhY2VOb3JtYWwgKTtcclxuXHRcdFx0XHRcdGRzdE5vcm1hbHNWZXJ0ZXgucHVzaCggdmVydGV4Tm9ybWFscyApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgbW9ycGhOb3JtYWxzID0gdGhpcy5tb3JwaE5vcm1hbHNbIGkgXTtcclxuXHJcblx0XHRcdC8vIHNldCB2ZXJ0aWNlcyB0byBtb3JwaCB0YXJnZXRcclxuXHJcblx0XHRcdHRtcEdlby52ZXJ0aWNlcyA9IHRoaXMubW9ycGhUYXJnZXRzWyBpIF0udmVydGljZXM7XHJcblxyXG5cdFx0XHQvLyBjb21wdXRlIG1vcnBoIG5vcm1hbHNcclxuXHJcblx0XHRcdHRtcEdlby5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHRcdFx0dG1wR2VvLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XHJcblxyXG5cdFx0XHQvLyBzdG9yZSBtb3JwaCBub3JtYWxzXHJcblxyXG5cdFx0XHR2YXIgZmFjZU5vcm1hbCwgdmVydGV4Tm9ybWFscztcclxuXHJcblx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XHJcblxyXG5cdFx0XHRcdGZhY2VOb3JtYWwgPSBtb3JwaE5vcm1hbHMuZmFjZU5vcm1hbHNbIGYgXTtcclxuXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzID0gbW9ycGhOb3JtYWxzLnZlcnRleE5vcm1hbHNbIGYgXTtcclxuXHJcblx0XHRcdFx0ZmFjZU5vcm1hbC5jb3B5KCBmYWNlLm5vcm1hbCApO1xyXG5cclxuXHRcdFx0XHRpZiAoIGZhY2UgaW5zdGFuY2VvZiBUSFJFRS5GYWNlMyApIHtcclxuXHJcblx0XHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzLmEuY29weSggZmFjZS52ZXJ0ZXhOb3JtYWxzWyAwIF0gKTtcclxuXHRcdFx0XHRcdHZlcnRleE5vcm1hbHMuYi5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIDEgXSApO1xyXG5cdFx0XHRcdFx0dmVydGV4Tm9ybWFscy5jLmNvcHkoIGZhY2UudmVydGV4Tm9ybWFsc1sgMiBdICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0dmVydGV4Tm9ybWFscy5hLmNvcHkoIGZhY2UudmVydGV4Tm9ybWFsc1sgMCBdICk7XHJcblx0XHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzLmIuY29weSggZmFjZS52ZXJ0ZXhOb3JtYWxzWyAxIF0gKTtcclxuXHRcdFx0XHRcdHZlcnRleE5vcm1hbHMuYy5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIDIgXSApO1xyXG5cdFx0XHRcdFx0dmVydGV4Tm9ybWFscy5kLmNvcHkoIGZhY2UudmVydGV4Tm9ybWFsc1sgMyBdICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gcmVzdG9yZSBvcmlnaW5hbCBub3JtYWxzXHJcblxyXG5cdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XHJcblxyXG5cdFx0XHRmYWNlLm5vcm1hbCA9IGZhY2UuX19vcmlnaW5hbEZhY2VOb3JtYWw7XHJcblx0XHRcdGZhY2UudmVydGV4Tm9ybWFscyA9IGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRjb21wdXRlVGFuZ2VudHM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyBiYXNlZCBvbiBodHRwOi8vd3d3LnRlcmF0aG9uLmNvbS9jb2RlL3RhbmdlbnQuaHRtbFxyXG5cdFx0Ly8gdGFuZ2VudHMgZ28gdG8gdmVydGljZXNcclxuXHJcblx0XHR2YXIgZiwgZmwsIHYsIHZsLCBpLCBpbCwgdmVydGV4SW5kZXgsXHJcblx0XHRcdGZhY2UsIHV2LCB2QSwgdkIsIHZDLCB1dkEsIHV2QiwgdXZDLFxyXG5cdFx0XHR4MSwgeDIsIHkxLCB5MiwgejEsIHoyLFxyXG5cdFx0XHRzMSwgczIsIHQxLCB0MiwgciwgdCwgdGVzdCxcclxuXHRcdFx0dGFuMSA9IFtdLCB0YW4yID0gW10sXHJcblx0XHRcdHNkaXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpLCB0ZGlyID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0dG1wID0gbmV3IFRIUkVFLlZlY3RvcjMoKSwgdG1wMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblx0XHRcdG4gPSBuZXcgVEhSRUUuVmVjdG9yMygpLCB3O1xyXG5cclxuXHRcdGZvciAoIHYgPSAwLCB2bCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyB2IDwgdmw7IHYgKysgKSB7XHJcblxyXG5cdFx0XHR0YW4xWyB2IF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0XHR0YW4yWyB2IF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBoYW5kbGVUcmlhbmdsZSggY29udGV4dCwgYSwgYiwgYywgdWEsIHViLCB1YyApIHtcclxuXHJcblx0XHRcdHZBID0gY29udGV4dC52ZXJ0aWNlc1sgYSBdO1xyXG5cdFx0XHR2QiA9IGNvbnRleHQudmVydGljZXNbIGIgXTtcclxuXHRcdFx0dkMgPSBjb250ZXh0LnZlcnRpY2VzWyBjIF07XHJcblxyXG5cdFx0XHR1dkEgPSB1dlsgdWEgXTtcclxuXHRcdFx0dXZCID0gdXZbIHViIF07XHJcblx0XHRcdHV2QyA9IHV2WyB1YyBdO1xyXG5cclxuXHRcdFx0eDEgPSB2Qi54IC0gdkEueDtcclxuXHRcdFx0eDIgPSB2Qy54IC0gdkEueDtcclxuXHRcdFx0eTEgPSB2Qi55IC0gdkEueTtcclxuXHRcdFx0eTIgPSB2Qy55IC0gdkEueTtcclxuXHRcdFx0ejEgPSB2Qi56IC0gdkEuejtcclxuXHRcdFx0ejIgPSB2Qy56IC0gdkEuejtcclxuXHJcblx0XHRcdHMxID0gdXZCLnggLSB1dkEueDtcclxuXHRcdFx0czIgPSB1dkMueCAtIHV2QS54O1xyXG5cdFx0XHR0MSA9IHV2Qi55IC0gdXZBLnk7XHJcblx0XHRcdHQyID0gdXZDLnkgLSB1dkEueTtcclxuXHJcblx0XHRcdHIgPSAxLjAgLyAoIHMxICogdDIgLSBzMiAqIHQxICk7XHJcblx0XHRcdHNkaXIuc2V0KCAoIHQyICogeDEgLSB0MSAqIHgyICkgKiByLFxyXG5cdFx0XHRcdFx0ICAoIHQyICogeTEgLSB0MSAqIHkyICkgKiByLFxyXG5cdFx0XHRcdFx0ICAoIHQyICogejEgLSB0MSAqIHoyICkgKiByICk7XHJcblx0XHRcdHRkaXIuc2V0KCAoIHMxICogeDIgLSBzMiAqIHgxICkgKiByLFxyXG5cdFx0XHRcdFx0ICAoIHMxICogeTIgLSBzMiAqIHkxICkgKiByLFxyXG5cdFx0XHRcdFx0ICAoIHMxICogejIgLSBzMiAqIHoxICkgKiByICk7XHJcblxyXG5cdFx0XHR0YW4xWyBhIF0uYWRkKCBzZGlyICk7XHJcblx0XHRcdHRhbjFbIGIgXS5hZGQoIHNkaXIgKTtcclxuXHRcdFx0dGFuMVsgYyBdLmFkZCggc2RpciApO1xyXG5cclxuXHRcdFx0dGFuMlsgYSBdLmFkZCggdGRpciApO1xyXG5cdFx0XHR0YW4yWyBiIF0uYWRkKCB0ZGlyICk7XHJcblx0XHRcdHRhbjJbIGMgXS5hZGQoIHRkaXIgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XHJcblx0XHRcdHV2ID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF1bIGYgXTsgLy8gdXNlIFVWIGxheWVyIDAgZm9yIHRhbmdlbnRzXHJcblxyXG5cdFx0XHRpZiAoIGZhY2UgaW5zdGFuY2VvZiBUSFJFRS5GYWNlMyApIHtcclxuXHJcblx0XHRcdFx0aGFuZGxlVHJpYW5nbGUoIHRoaXMsIGZhY2UuYSwgZmFjZS5iLCBmYWNlLmMsIDAsIDEsIDIgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGZhY2UgaW5zdGFuY2VvZiBUSFJFRS5GYWNlNCApIHtcclxuXHJcblx0XHRcdFx0aGFuZGxlVHJpYW5nbGUoIHRoaXMsIGZhY2UuYSwgZmFjZS5iLCBmYWNlLmQsIDAsIDEsIDMgKTtcclxuXHRcdFx0XHRoYW5kbGVUcmlhbmdsZSggdGhpcywgZmFjZS5iLCBmYWNlLmMsIGZhY2UuZCwgMSwgMiwgMyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZmFjZUluZGV4ID0gWyAnYScsICdiJywgJ2MnLCAnZCcgXTtcclxuXHJcblx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZmFjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaSsrICkge1xyXG5cclxuXHRcdFx0XHRuLmNvcHkoIGZhY2UudmVydGV4Tm9ybWFsc1sgaSBdICk7XHJcblxyXG5cdFx0XHRcdHZlcnRleEluZGV4ID0gZmFjZVsgZmFjZUluZGV4WyBpIF0gXTtcclxuXHJcblx0XHRcdFx0dCA9IHRhbjFbIHZlcnRleEluZGV4IF07XHJcblxyXG5cdFx0XHRcdC8vIEdyYW0tU2NobWlkdCBvcnRob2dvbmFsaXplXHJcblxyXG5cdFx0XHRcdHRtcC5jb3B5KCB0ICk7XHJcblx0XHRcdFx0dG1wLnN1Yiggbi5tdWx0aXBseVNjYWxhciggbi5kb3QoIHQgKSApICkubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHRcdC8vIENhbGN1bGF0ZSBoYW5kZWRuZXNzXHJcblxyXG5cdFx0XHRcdHRtcDIuY3Jvc3NWZWN0b3JzKCBmYWNlLnZlcnRleE5vcm1hbHNbIGkgXSwgdCApO1xyXG5cdFx0XHRcdHRlc3QgPSB0bXAyLmRvdCggdGFuMlsgdmVydGV4SW5kZXggXSApO1xyXG5cdFx0XHRcdHcgPSAodGVzdCA8IDAuMCkgPyAtMS4wIDogMS4wO1xyXG5cclxuXHRcdFx0XHRmYWNlLnZlcnRleFRhbmdlbnRzWyBpIF0gPSBuZXcgVEhSRUUuVmVjdG9yNCggdG1wLngsIHRtcC55LCB0bXAueiwgdyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmhhc1RhbmdlbnRzID0gdHJ1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29tcHV0ZUxpbmVEaXN0YW5jZXM6IGZ1bmN0aW9uICggKSB7XHJcblxyXG5cdFx0dmFyIGQgPSAwO1xyXG5cdFx0dmFyIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcztcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGkgPiAwICkge1xyXG5cclxuXHRcdFx0XHRkICs9IHZlcnRpY2VzWyBpIF0uZGlzdGFuY2VUbyggdmVydGljZXNbIGkgLSAxIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMubGluZURpc3RhbmNlc1sgaSBdID0gZDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbXB1dGVCb3VuZGluZ0JveDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGlmICggdGhpcy5ib3VuZGluZ0JveCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBuZXcgVEhSRUUuQm94MygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmJvdW5kaW5nQm94LnNldEZyb21Qb2ludHMoIHRoaXMudmVydGljZXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29tcHV0ZUJvdW5kaW5nU3BoZXJlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5ib3VuZGluZ1NwaGVyZS5zZXRGcm9tQ2VudGVyQW5kUG9pbnRzKCB0aGlzLmJvdW5kaW5nU3BoZXJlLmNlbnRlciwgdGhpcy52ZXJ0aWNlcyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvKlxyXG5cdCAqIENoZWNrcyBmb3IgZHVwbGljYXRlIHZlcnRpY2VzIHdpdGggaGFzaG1hcC5cclxuXHQgKiBEdXBsaWNhdGVkIHZlcnRpY2VzIGFyZSByZW1vdmVkXHJcblx0ICogYW5kIGZhY2VzJyB2ZXJ0aWNlcyBhcmUgdXBkYXRlZC5cclxuXHQgKi9cclxuXHJcblx0bWVyZ2VWZXJ0aWNlczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2ZXJ0aWNlc01hcCA9IHt9OyAvLyBIYXNobWFwIGZvciBsb29raW5nIHVwIHZlcnRpY2UgYnkgcG9zaXRpb24gY29vcmRpbmF0ZXMgKGFuZCBtYWtpbmcgc3VyZSB0aGV5IGFyZSB1bmlxdWUpXHJcblx0XHR2YXIgdW5pcXVlID0gW10sIGNoYW5nZXMgPSBbXTtcclxuXHJcblx0XHR2YXIgdiwga2V5O1xyXG5cdFx0dmFyIHByZWNpc2lvblBvaW50cyA9IDQ7IC8vIG51bWJlciBvZiBkZWNpbWFsIHBvaW50cywgZWcuIDQgZm9yIGVwc2lsb24gb2YgMC4wMDAxXHJcblx0XHR2YXIgcHJlY2lzaW9uID0gTWF0aC5wb3coIDEwLCBwcmVjaXNpb25Qb2ludHMgKTtcclxuXHRcdHZhciBpLGlsLCBmYWNlO1xyXG5cdFx0dmFyIGluZGljZXMsIGssIGosIGpsLCB1O1xyXG5cclxuXHRcdC8vIHJlc2V0IGNhY2hlIG9mIHZlcnRpY2VzIGFzIGl0IG5vdyB3aWxsIGJlIGNoYW5naW5nLlxyXG5cdFx0dGhpcy5fX3RtcFZlcnRpY2VzID0gdW5kZWZpbmVkO1xyXG5cclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2ID0gdGhpcy52ZXJ0aWNlc1sgaSBdO1xyXG5cdFx0XHRrZXkgPSBbIE1hdGgucm91bmQoIHYueCAqIHByZWNpc2lvbiApLCBNYXRoLnJvdW5kKCB2LnkgKiBwcmVjaXNpb24gKSwgTWF0aC5yb3VuZCggdi56ICogcHJlY2lzaW9uICkgXS5qb2luKCAnXycgKTtcclxuXHJcblx0XHRcdGlmICggdmVydGljZXNNYXBbIGtleSBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHZlcnRpY2VzTWFwWyBrZXkgXSA9IGk7XHJcblx0XHRcdFx0dW5pcXVlLnB1c2goIHRoaXMudmVydGljZXNbIGkgXSApO1xyXG5cdFx0XHRcdGNoYW5nZXNbIGkgXSA9IHVuaXF1ZS5sZW5ndGggLSAxO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ly9jb25zb2xlLmxvZygnRHVwbGljYXRlIHZlcnRleCBmb3VuZC4gJywgaSwgJyBjb3VsZCBiZSB1c2luZyAnLCB2ZXJ0aWNlc01hcFtrZXldKTtcclxuXHRcdFx0XHRjaGFuZ2VzWyBpIF0gPSBjaGFuZ2VzWyB2ZXJ0aWNlc01hcFsga2V5IF0gXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9O1xyXG5cclxuXHJcblx0XHQvLyBpZiBmYWNlcyBhcmUgY29tcGxldGVseSBkZWdlbmVyYXRlIGFmdGVyIG1lcmdpbmcgdmVydGljZXMsIHdlXHJcblx0XHQvLyBoYXZlIHRvIHJlbW92ZSB0aGVtIGZyb20gdGhlIGdlb21ldHJ5LlxyXG5cdFx0dmFyIGZhY2VJbmRpY2VzVG9SZW1vdmUgPSBbXTtcclxuXHJcblx0XHRmb3IoIGkgPSAwLCBpbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgaSBdO1xyXG5cclxuXHRcdFx0aWYgKCBmYWNlIGluc3RhbmNlb2YgVEhSRUUuRmFjZTMgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2UuYSA9IGNoYW5nZXNbIGZhY2UuYSBdO1xyXG5cdFx0XHRcdGZhY2UuYiA9IGNoYW5nZXNbIGZhY2UuYiBdO1xyXG5cdFx0XHRcdGZhY2UuYyA9IGNoYW5nZXNbIGZhY2UuYyBdO1xyXG5cclxuXHRcdFx0XHRpbmRpY2VzID0gWyBmYWNlLmEsIGZhY2UuYiwgZmFjZS5jIF07XHJcblxyXG5cdFx0XHRcdHZhciBkdXBJbmRleCA9IC0xO1xyXG5cclxuXHRcdFx0XHQvLyBpZiBhbnkgZHVwbGljYXRlIHZlcnRpY2VzIGFyZSBmb3VuZCBpbiBhIEZhY2UzXHJcblx0XHRcdFx0Ly8gd2UgaGF2ZSB0byByZW1vdmUgdGhlIGZhY2UgYXMgbm90aGluZyBjYW4gYmUgc2F2ZWRcclxuXHRcdFx0XHRmb3IgKCB2YXIgbiA9IDA7IG4gPCAzOyBuICsrICkge1xyXG5cdFx0XHRcdFx0aWYgKCBpbmRpY2VzWyBuIF0gPT0gaW5kaWNlc1sgKCBuICsgMSApICUgMyBdICkge1xyXG5cclxuXHRcdFx0XHRcdFx0ZHVwSW5kZXggPSBuO1xyXG5cdFx0XHRcdFx0XHRmYWNlSW5kaWNlc1RvUmVtb3ZlLnB1c2goIGkgKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGZhY2UgaW5zdGFuY2VvZiBUSFJFRS5GYWNlNCApIHtcclxuXHJcblx0XHRcdFx0ZmFjZS5hID0gY2hhbmdlc1sgZmFjZS5hIF07XHJcblx0XHRcdFx0ZmFjZS5iID0gY2hhbmdlc1sgZmFjZS5iIF07XHJcblx0XHRcdFx0ZmFjZS5jID0gY2hhbmdlc1sgZmFjZS5jIF07XHJcblx0XHRcdFx0ZmFjZS5kID0gY2hhbmdlc1sgZmFjZS5kIF07XHJcblxyXG5cdFx0XHRcdC8vIGNoZWNrIGR1cHMgaW4gKGEsIGIsIGMsIGQpIGFuZCBjb252ZXJ0IHRvIC0+IGZhY2UzXHJcblxyXG5cdFx0XHRcdGluZGljZXMgPSBbIGZhY2UuYSwgZmFjZS5iLCBmYWNlLmMsIGZhY2UuZCBdO1xyXG5cclxuXHRcdFx0XHR2YXIgZHVwSW5kZXggPSAtMTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIG4gPSAwOyBuIDwgNDsgbiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGluZGljZXNbIG4gXSA9PSBpbmRpY2VzWyAoIG4gKyAxICkgJSA0IF0gKSB7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBpZiBtb3JlIHRoYW4gb25lIGR1cGxpY2F0ZWQgdmVydGV4IGlzIGZvdW5kXHJcblx0XHRcdFx0XHRcdC8vIHdlIGNhbid0IGdlbmVyYXRlIGFueSB2YWxpZCBGYWNlMydzLCB0aHVzXHJcblx0XHRcdFx0XHRcdC8vIHdlIG5lZWQgdG8gcmVtb3ZlIHRoaXMgZmFjZSBjb21wbGV0ZS5cclxuXHRcdFx0XHRcdFx0aWYgKCBkdXBJbmRleCA+PSAwICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRmYWNlSW5kaWNlc1RvUmVtb3ZlLnB1c2goIGkgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGR1cEluZGV4ID0gbjtcclxuXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIGR1cEluZGV4ID49IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0aW5kaWNlcy5zcGxpY2UoIGR1cEluZGV4LCAxICk7XHJcblxyXG5cdFx0XHRcdFx0dmFyIG5ld0ZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoIGluZGljZXNbMF0sIGluZGljZXNbMV0sIGluZGljZXNbMl0sIGZhY2Uubm9ybWFsLCBmYWNlLmNvbG9yLCBmYWNlLm1hdGVyaWFsSW5kZXggKTtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCBqID0gMCwgamwgPSB0aGlzLmZhY2VWZXJ0ZXhVdnMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR1ID0gdGhpcy5mYWNlVmVydGV4VXZzWyBqIF1bIGkgXTtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggdSApIHtcclxuXHRcdFx0XHRcdFx0XHR1LnNwbGljZSggZHVwSW5kZXgsIDEgKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiggZmFjZS52ZXJ0ZXhOb3JtYWxzICYmIGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGggPiAwKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRuZXdGYWNlLnZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHM7XHJcblx0XHRcdFx0XHRcdG5ld0ZhY2UudmVydGV4Tm9ybWFscy5zcGxpY2UoIGR1cEluZGV4LCAxICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmKCBmYWNlLnZlcnRleENvbG9ycyAmJiBmYWNlLnZlcnRleENvbG9ycy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0XHRcdFx0bmV3RmFjZS52ZXJ0ZXhDb2xvcnMgPSBmYWNlLnZlcnRleENvbG9ycztcclxuXHRcdFx0XHRcdFx0bmV3RmFjZS52ZXJ0ZXhDb2xvcnMuc3BsaWNlKCBkdXBJbmRleCwgMSApO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHRoaXMuZmFjZXNbIGkgXSA9IG5ld0ZhY2U7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCBpID0gZmFjZUluZGljZXNUb1JlbW92ZS5sZW5ndGggLSAxOyBpID49IDA7IGkgLS0gKSB7XHJcblxyXG5cdFx0XHR0aGlzLmZhY2VzLnNwbGljZSggaSwgMSApO1xyXG5cclxuXHRcdFx0Zm9yICggaiA9IDAsIGpsID0gdGhpcy5mYWNlVmVydGV4VXZzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIGogXS5zcGxpY2UoIGksIDEgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVXNlIHVuaXF1ZSBzZXQgb2YgdmVydGljZXNcclxuXHJcblx0XHR2YXIgZGlmZiA9IHRoaXMudmVydGljZXMubGVuZ3RoIC0gdW5pcXVlLmxlbmd0aDtcclxuXHRcdHRoaXMudmVydGljZXMgPSB1bmlxdWU7XHJcblx0XHRyZXR1cm4gZGlmZjtcclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuXHJcblx0XHR2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIHZlcnRpY2VzWyBpIF0uY2xvbmUoKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZmFjZXMgPSB0aGlzLmZhY2VzO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBmYWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGdlb21ldHJ5LmZhY2VzLnB1c2goIGZhY2VzWyBpIF0uY2xvbmUoKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgdXZzID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF07XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHV2cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciB1diA9IHV2c1sgaSBdLCB1dkNvcHkgPSBbXTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSB1di5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0dXZDb3B5LnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB1dlsgaiBdLngsIHV2WyBqIF0ueSApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggdXZDb3B5ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBnZW9tZXRyeTtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzcG9zZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuR2VvbWV0cnlJZENvdW50ID0gMDtcclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQnVmZmVyR2VvbWV0cnkgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFRIUkVFLkV2ZW50RGlzcGF0Y2hlci5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMuaWQgPSBUSFJFRS5HZW9tZXRyeUlkQ291bnQgKys7XHJcblxyXG5cdC8vIGF0dHJpYnV0ZXNcclxuXHJcblx0dGhpcy5hdHRyaWJ1dGVzID0ge307XHJcblxyXG5cdC8vIGF0dHJpYnV0ZXMgdHlwZWQgYXJyYXlzIGFyZSBrZXB0IG9ubHkgaWYgZHluYW1pYyBmbGFnIGlzIHNldFxyXG5cclxuXHR0aGlzLmR5bmFtaWMgPSBmYWxzZTtcclxuXHJcblx0Ly8gb2Zmc2V0cyBmb3IgY2h1bmtzIHdoZW4gdXNpbmcgaW5kZXhlZCBlbGVtZW50c1xyXG5cclxuXHR0aGlzLm9mZnNldHMgPSBbXTtcclxuXHJcblx0Ly8gYm91bmRpbmdzXHJcblxyXG5cdHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xyXG5cdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBudWxsO1xyXG5cclxuXHR0aGlzLmhhc1RhbmdlbnRzID0gZmFsc2U7XHJcblxyXG5cdC8vIGZvciBjb21wYXRpYmlsaXR5XHJcblxyXG5cdHRoaXMubW9ycGhUYXJnZXRzID0gW107XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvciA6IFRIUkVFLkJ1ZmZlckdlb21ldHJ5LFxyXG5cclxuXHRhcHBseU1hdHJpeDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XHJcblxyXG5cdFx0dmFyIHBvc2l0aW9uQXJyYXk7XHJcblx0XHR2YXIgbm9ybWFsQXJyYXk7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmF0dHJpYnV0ZXNbIFwicG9zaXRpb25cIiBdICkgcG9zaXRpb25BcnJheSA9IHRoaXMuYXR0cmlidXRlc1sgXCJwb3NpdGlvblwiIF0uYXJyYXk7XHJcblx0XHRpZiAoIHRoaXMuYXR0cmlidXRlc1sgXCJub3JtYWxcIiBdICkgbm9ybWFsQXJyYXkgPSB0aGlzLmF0dHJpYnV0ZXNbIFwibm9ybWFsXCIgXS5hcnJheTtcclxuXHJcblx0XHRpZiAoIHBvc2l0aW9uQXJyYXkgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdG1hdHJpeC5tdWx0aXBseVZlY3RvcjNBcnJheSggcG9zaXRpb25BcnJheSApO1xyXG5cdFx0XHR0aGlzLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbm9ybWFsQXJyYXkgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHZhciBub3JtYWxNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4MygpO1xyXG5cdFx0XHRub3JtYWxNYXRyaXguZ2V0SW52ZXJzZSggbWF0cml4ICkudHJhbnNwb3NlKCk7XHJcblxyXG5cdFx0XHRub3JtYWxNYXRyaXgubXVsdGlwbHlWZWN0b3IzQXJyYXkoIG5vcm1hbEFycmF5ICk7XHJcblxyXG5cdFx0XHR0aGlzLm5vcm1hbGl6ZU5vcm1hbHMoKTtcclxuXHJcblx0XHRcdHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0Y29tcHV0ZUJvdW5kaW5nQm94OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmJvdW5kaW5nQm94ID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5ib3VuZGluZ0JveCA9IG5ldyBUSFJFRS5Cb3gzKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBwb3NpdGlvbnMgPSB0aGlzLmF0dHJpYnV0ZXNbIFwicG9zaXRpb25cIiBdLmFycmF5O1xyXG5cclxuXHRcdGlmICggcG9zaXRpb25zICkge1xyXG5cclxuXHRcdFx0dmFyIGJiID0gdGhpcy5ib3VuZGluZ0JveDtcclxuXHRcdFx0dmFyIHgsIHksIHo7XHJcblxyXG5cdFx0XHRpZiggcG9zaXRpb25zLmxlbmd0aCA+PSAzICkge1xyXG5cdFx0XHRcdGJiLm1pbi54ID0gYmIubWF4LnggPSBwb3NpdGlvbnNbIDAgXTtcclxuXHRcdFx0XHRiYi5taW4ueSA9IGJiLm1heC55ID0gcG9zaXRpb25zWyAxIF07XHJcblx0XHRcdFx0YmIubWluLnogPSBiYi5tYXgueiA9IHBvc2l0aW9uc1sgMiBdO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDMsIGlsID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlsOyBpICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdHggPSBwb3NpdGlvbnNbIGkgXTtcclxuXHRcdFx0XHR5ID0gcG9zaXRpb25zWyBpICsgMSBdO1xyXG5cdFx0XHRcdHogPSBwb3NpdGlvbnNbIGkgKyAyIF07XHJcblxyXG5cdFx0XHRcdC8vIGJvdW5kaW5nIGJveFxyXG5cclxuXHRcdFx0XHRpZiAoIHggPCBiYi5taW4ueCApIHtcclxuXHJcblx0XHRcdFx0XHRiYi5taW4ueCA9IHg7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHggPiBiYi5tYXgueCApIHtcclxuXHJcblx0XHRcdFx0XHRiYi5tYXgueCA9IHg7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCB5IDwgYmIubWluLnkgKSB7XHJcblxyXG5cdFx0XHRcdFx0YmIubWluLnkgPSB5O1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCB5ID4gYmIubWF4LnkgKSB7XHJcblxyXG5cdFx0XHRcdFx0YmIubWF4LnkgPSB5O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggeiA8IGJiLm1pbi56ICkge1xyXG5cclxuXHRcdFx0XHRcdGJiLm1pbi56ID0gejtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggeiA+IGJiLm1heC56ICkge1xyXG5cclxuXHRcdFx0XHRcdGJiLm1heC56ID0gejtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHBvc2l0aW9ucyA9PT0gdW5kZWZpbmVkIHx8IHBvc2l0aW9ucy5sZW5ndGggPT09IDAgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmJvdW5kaW5nQm94Lm1pbi5zZXQoIDAsIDAsIDAgKTtcclxuXHRcdFx0dGhpcy5ib3VuZGluZ0JveC5tYXguc2V0KCAwLCAwLCAwICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRjb21wdXRlQm91bmRpbmdTcGhlcmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcG9zaXRpb25zID0gdGhpcy5hdHRyaWJ1dGVzWyBcInBvc2l0aW9uXCIgXS5hcnJheTtcclxuXHJcblx0XHRpZiAoIHBvc2l0aW9ucyApIHtcclxuXHJcblx0XHRcdHZhciByYWRpdXNTcSwgbWF4UmFkaXVzU3EgPSAwO1xyXG5cdFx0XHR2YXIgeCwgeSwgejtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgaWw7IGkgKz0gMyApIHtcclxuXHJcblx0XHRcdFx0eCA9IHBvc2l0aW9uc1sgaSBdO1xyXG5cdFx0XHRcdHkgPSBwb3NpdGlvbnNbIGkgKyAxIF07XHJcblx0XHRcdFx0eiA9IHBvc2l0aW9uc1sgaSArIDIgXTtcclxuXHJcblx0XHRcdFx0cmFkaXVzU3EgPSAgeCAqIHggKyB5ICogeSArIHogKiB6O1xyXG5cdFx0XHRcdGlmICggcmFkaXVzU3EgPiBtYXhSYWRpdXNTcSApIG1heFJhZGl1c1NxID0gcmFkaXVzU3E7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cyA9IE1hdGguc3FydCggbWF4UmFkaXVzU3EgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbXB1dGVWZXJ0ZXhOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmF0dHJpYnV0ZXNbIFwicG9zaXRpb25cIiBdICkge1xyXG5cclxuXHRcdFx0dmFyIGksIGlsO1xyXG5cdFx0XHR2YXIgaiwgamw7XHJcblxyXG5cdFx0XHR2YXIgblZlcnRleEVsZW1lbnRzID0gdGhpcy5hdHRyaWJ1dGVzWyBcInBvc2l0aW9uXCIgXS5hcnJheS5sZW5ndGg7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuYXR0cmlidXRlc1sgXCJub3JtYWxcIiBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuYXR0cmlidXRlc1sgXCJub3JtYWxcIiBdID0ge1xyXG5cclxuXHRcdFx0XHRcdGl0ZW1TaXplOiAzLFxyXG5cdFx0XHRcdFx0YXJyYXk6IG5ldyBGbG9hdDMyQXJyYXkoIG5WZXJ0ZXhFbGVtZW50cyApLFxyXG5cdFx0XHRcdFx0bnVtSXRlbXM6IG5WZXJ0ZXhFbGVtZW50c1xyXG5cclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ly8gcmVzZXQgZXhpc3Rpbmcgbm9ybWFscyB0byB6ZXJvXHJcblxyXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IHRoaXMuYXR0cmlidXRlc1sgXCJub3JtYWxcIiBdLmFycmF5Lmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuYXR0cmlidXRlc1sgXCJub3JtYWxcIiBdLmFycmF5WyBpIF0gPSAwO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgcG9zaXRpb25zID0gdGhpcy5hdHRyaWJ1dGVzWyBcInBvc2l0aW9uXCIgXS5hcnJheTtcclxuXHRcdFx0dmFyIG5vcm1hbHMgPSB0aGlzLmF0dHJpYnV0ZXNbIFwibm9ybWFsXCIgXS5hcnJheTtcclxuXHJcblx0XHRcdHZhciB2QSwgdkIsIHZDLCB4LCB5LCB6LFxyXG5cclxuXHRcdFx0cEEgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0XHRwQiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblx0XHRcdHBDID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHJcblx0XHRcdGNiID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0YWIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0Ly8gaW5kZXhlZCBlbGVtZW50c1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLmF0dHJpYnV0ZXNbIFwiaW5kZXhcIiBdICkge1xyXG5cclxuXHRcdFx0XHR2YXIgaW5kaWNlcyA9IHRoaXMuYXR0cmlidXRlc1sgXCJpbmRleFwiIF0uYXJyYXk7XHJcblxyXG5cdFx0XHRcdHZhciBvZmZzZXRzID0gdGhpcy5vZmZzZXRzO1xyXG5cclxuXHRcdFx0XHRmb3IgKCBqID0gMCwgamwgPSBvZmZzZXRzLmxlbmd0aDsgaiA8IGpsOyArKyBqICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBzdGFydCA9IG9mZnNldHNbIGogXS5zdGFydDtcclxuXHRcdFx0XHRcdHZhciBjb3VudCA9IG9mZnNldHNbIGogXS5jb3VudDtcclxuXHRcdFx0XHRcdHZhciBpbmRleCA9IG9mZnNldHNbIGogXS5pbmRleDtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCBpID0gc3RhcnQsIGlsID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsOyBpICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2QSA9IGluZGV4ICsgaW5kaWNlc1sgaSBdO1xyXG5cdFx0XHRcdFx0XHR2QiA9IGluZGV4ICsgaW5kaWNlc1sgaSArIDEgXTtcclxuXHRcdFx0XHRcdFx0dkMgPSBpbmRleCArIGluZGljZXNbIGkgKyAyIF07XHJcblxyXG5cdFx0XHRcdFx0XHR4ID0gcG9zaXRpb25zWyB2QSAqIDMgXTtcclxuXHRcdFx0XHRcdFx0eSA9IHBvc2l0aW9uc1sgdkEgKiAzICsgMSBdO1xyXG5cdFx0XHRcdFx0XHR6ID0gcG9zaXRpb25zWyB2QSAqIDMgKyAyIF07XHJcblx0XHRcdFx0XHRcdHBBLnNldCggeCwgeSwgeiApO1xyXG5cclxuXHRcdFx0XHRcdFx0eCA9IHBvc2l0aW9uc1sgdkIgKiAzIF07XHJcblx0XHRcdFx0XHRcdHkgPSBwb3NpdGlvbnNbIHZCICogMyArIDEgXTtcclxuXHRcdFx0XHRcdFx0eiA9IHBvc2l0aW9uc1sgdkIgKiAzICsgMiBdO1xyXG5cdFx0XHRcdFx0XHRwQi5zZXQoIHgsIHksIHogKTtcclxuXHJcblx0XHRcdFx0XHRcdHggPSBwb3NpdGlvbnNbIHZDICogMyBdO1xyXG5cdFx0XHRcdFx0XHR5ID0gcG9zaXRpb25zWyB2QyAqIDMgKyAxIF07XHJcblx0XHRcdFx0XHRcdHogPSBwb3NpdGlvbnNbIHZDICogMyArIDIgXTtcclxuXHRcdFx0XHRcdFx0cEMuc2V0KCB4LCB5LCB6ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRjYi5zdWJWZWN0b3JzKCBwQywgcEIgKTtcclxuXHRcdFx0XHRcdFx0YWIuc3ViVmVjdG9ycyggcEEsIHBCICk7XHJcblx0XHRcdFx0XHRcdGNiLmNyb3NzKCBhYiApO1xyXG5cclxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkEgKiAzIF0gICAgICs9IGNiLng7XHJcblx0XHRcdFx0XHRcdG5vcm1hbHNbIHZBICogMyArIDEgXSArPSBjYi55O1xyXG5cdFx0XHRcdFx0XHRub3JtYWxzWyB2QSAqIDMgKyAyIF0gKz0gY2IuejtcclxuXHJcblx0XHRcdFx0XHRcdG5vcm1hbHNbIHZCICogMyBdICAgICArPSBjYi54O1xyXG5cdFx0XHRcdFx0XHRub3JtYWxzWyB2QiAqIDMgKyAxIF0gKz0gY2IueTtcclxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkIgKiAzICsgMiBdICs9IGNiLno7XHJcblxyXG5cdFx0XHRcdFx0XHRub3JtYWxzWyB2QyAqIDMgXSAgICAgKz0gY2IueDtcclxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkMgKiAzICsgMSBdICs9IGNiLnk7XHJcblx0XHRcdFx0XHRcdG5vcm1hbHNbIHZDICogMyArIDIgXSArPSBjYi56O1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gbm9uLWluZGV4ZWQgZWxlbWVudHMgKHVuY29ubmVjdGVkIHRyaWFuZ2xlIHNvdXApXHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRmb3IgKCBpID0gMCwgaWwgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgaWw7IGkgKz0gOSApIHtcclxuXHJcblx0XHRcdFx0XHR4ID0gcG9zaXRpb25zWyBpIF07XHJcblx0XHRcdFx0XHR5ID0gcG9zaXRpb25zWyBpICsgMSBdO1xyXG5cdFx0XHRcdFx0eiA9IHBvc2l0aW9uc1sgaSArIDIgXTtcclxuXHRcdFx0XHRcdHBBLnNldCggeCwgeSwgeiApO1xyXG5cclxuXHRcdFx0XHRcdHggPSBwb3NpdGlvbnNbIGkgKyAzIF07XHJcblx0XHRcdFx0XHR5ID0gcG9zaXRpb25zWyBpICsgNCBdO1xyXG5cdFx0XHRcdFx0eiA9IHBvc2l0aW9uc1sgaSArIDUgXTtcclxuXHRcdFx0XHRcdHBCLnNldCggeCwgeSwgeiApO1xyXG5cclxuXHRcdFx0XHRcdHggPSBwb3NpdGlvbnNbIGkgKyA2IF07XHJcblx0XHRcdFx0XHR5ID0gcG9zaXRpb25zWyBpICsgNyBdO1xyXG5cdFx0XHRcdFx0eiA9IHBvc2l0aW9uc1sgaSArIDggXTtcclxuXHRcdFx0XHRcdHBDLnNldCggeCwgeSwgeiApO1xyXG5cclxuXHRcdFx0XHRcdGNiLnN1YlZlY3RvcnMoIHBDLCBwQiApO1xyXG5cdFx0XHRcdFx0YWIuc3ViVmVjdG9ycyggcEEsIHBCICk7XHJcblx0XHRcdFx0XHRjYi5jcm9zcyggYWIgKTtcclxuXHJcblx0XHRcdFx0XHRub3JtYWxzWyBpIF0gXHQgPSBjYi54O1xyXG5cdFx0XHRcdFx0bm9ybWFsc1sgaSArIDEgXSA9IGNiLnk7XHJcblx0XHRcdFx0XHRub3JtYWxzWyBpICsgMiBdID0gY2IuejtcclxuXHJcblx0XHRcdFx0XHRub3JtYWxzWyBpICsgMyBdID0gY2IueDtcclxuXHRcdFx0XHRcdG5vcm1hbHNbIGkgKyA0IF0gPSBjYi55O1xyXG5cdFx0XHRcdFx0bm9ybWFsc1sgaSArIDUgXSA9IGNiLno7XHJcblxyXG5cdFx0XHRcdFx0bm9ybWFsc1sgaSArIDYgXSA9IGNiLng7XHJcblx0XHRcdFx0XHRub3JtYWxzWyBpICsgNyBdID0gY2IueTtcclxuXHRcdFx0XHRcdG5vcm1hbHNbIGkgKyA4IF0gPSBjYi56O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLm5vcm1hbGl6ZU5vcm1hbHMoKTtcclxuXHJcblx0XHRcdHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0bm9ybWFsaXplTm9ybWFsczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBub3JtYWxzID0gdGhpcy5hdHRyaWJ1dGVzWyBcIm5vcm1hbFwiIF0uYXJyYXk7XHJcblxyXG5cdFx0dmFyIHgsIHksIHosIG47XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG5vcm1hbHMubGVuZ3RoOyBpIDwgaWw7IGkgKz0gMyApIHtcclxuXHJcblx0XHRcdHggPSBub3JtYWxzWyBpIF07XHJcblx0XHRcdHkgPSBub3JtYWxzWyBpICsgMSBdO1xyXG5cdFx0XHR6ID0gbm9ybWFsc1sgaSArIDIgXTtcclxuXHJcblx0XHRcdG4gPSAxLjAgLyBNYXRoLnNxcnQoIHggKiB4ICsgeSAqIHkgKyB6ICogeiApO1xyXG5cclxuXHRcdFx0bm9ybWFsc1sgaSBdIFx0ICo9IG47XHJcblx0XHRcdG5vcm1hbHNbIGkgKyAxIF0gKj0gbjtcclxuXHRcdFx0bm9ybWFsc1sgaSArIDIgXSAqPSBuO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0Y29tcHV0ZVRhbmdlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gYmFzZWQgb24gaHR0cDovL3d3dy50ZXJhdGhvbi5jb20vY29kZS90YW5nZW50Lmh0bWxcclxuXHRcdC8vIChwZXIgdmVydGV4IHRhbmdlbnRzKVxyXG5cclxuXHRcdGlmICggdGhpcy5hdHRyaWJ1dGVzWyBcImluZGV4XCIgXSA9PT0gdW5kZWZpbmVkIHx8XHJcblx0XHRcdCB0aGlzLmF0dHJpYnV0ZXNbIFwicG9zaXRpb25cIiBdID09PSB1bmRlZmluZWQgfHxcclxuXHRcdFx0IHRoaXMuYXR0cmlidXRlc1sgXCJub3JtYWxcIiBdID09PSB1bmRlZmluZWQgfHxcclxuXHRcdFx0IHRoaXMuYXR0cmlidXRlc1sgXCJ1dlwiIF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggXCJNaXNzaW5nIHJlcXVpcmVkIGF0dHJpYnV0ZXMgKGluZGV4LCBwb3NpdGlvbiwgbm9ybWFsIG9yIHV2KSBpbiBCdWZmZXJHZW9tZXRyeS5jb21wdXRlVGFuZ2VudHMoKVwiICk7XHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGluZGljZXMgPSB0aGlzLmF0dHJpYnV0ZXNbIFwiaW5kZXhcIiBdLmFycmF5O1xyXG5cdFx0dmFyIHBvc2l0aW9ucyA9IHRoaXMuYXR0cmlidXRlc1sgXCJwb3NpdGlvblwiIF0uYXJyYXk7XHJcblx0XHR2YXIgbm9ybWFscyA9IHRoaXMuYXR0cmlidXRlc1sgXCJub3JtYWxcIiBdLmFycmF5O1xyXG5cdFx0dmFyIHV2cyA9IHRoaXMuYXR0cmlidXRlc1sgXCJ1dlwiIF0uYXJyYXk7XHJcblxyXG5cdFx0dmFyIG5WZXJ0aWNlcyA9IHBvc2l0aW9ucy5sZW5ndGggLyAzO1xyXG5cclxuXHRcdGlmICggdGhpcy5hdHRyaWJ1dGVzWyBcInRhbmdlbnRcIiBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR2YXIgblRhbmdlbnRFbGVtZW50cyA9IDQgKiBuVmVydGljZXM7XHJcblxyXG5cdFx0XHR0aGlzLmF0dHJpYnV0ZXNbIFwidGFuZ2VudFwiIF0gPSB7XHJcblxyXG5cdFx0XHRcdGl0ZW1TaXplOiA0LFxyXG5cdFx0XHRcdGFycmF5OiBuZXcgRmxvYXQzMkFycmF5KCBuVGFuZ2VudEVsZW1lbnRzICksXHJcblx0XHRcdFx0bnVtSXRlbXM6IG5UYW5nZW50RWxlbWVudHNcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0YW5nZW50cyA9IHRoaXMuYXR0cmlidXRlc1sgXCJ0YW5nZW50XCIgXS5hcnJheTtcclxuXHJcblx0XHR2YXIgdGFuMSA9IFtdLCB0YW4yID0gW107XHJcblxyXG5cdFx0Zm9yICggdmFyIGsgPSAwOyBrIDwgblZlcnRpY2VzOyBrICsrICkge1xyXG5cclxuXHRcdFx0dGFuMVsgayBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdFx0dGFuMlsgayBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHhBLCB5QSwgekEsXHJcblx0XHRcdHhCLCB5QiwgekIsXHJcblx0XHRcdHhDLCB5QywgekMsXHJcblxyXG5cdFx0XHR1QSwgdkEsXHJcblx0XHRcdHVCLCB2QixcclxuXHRcdFx0dUMsIHZDLFxyXG5cclxuXHRcdFx0eDEsIHgyLCB5MSwgeTIsIHoxLCB6MixcclxuXHRcdFx0czEsIHMyLCB0MSwgdDIsIHI7XHJcblxyXG5cdFx0dmFyIHNkaXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpLCB0ZGlyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRmdW5jdGlvbiBoYW5kbGVUcmlhbmdsZSggYSwgYiwgYyApIHtcclxuXHJcblx0XHRcdHhBID0gcG9zaXRpb25zWyBhICogMyBdO1xyXG5cdFx0XHR5QSA9IHBvc2l0aW9uc1sgYSAqIDMgKyAxIF07XHJcblx0XHRcdHpBID0gcG9zaXRpb25zWyBhICogMyArIDIgXTtcclxuXHJcblx0XHRcdHhCID0gcG9zaXRpb25zWyBiICogMyBdO1xyXG5cdFx0XHR5QiA9IHBvc2l0aW9uc1sgYiAqIDMgKyAxIF07XHJcblx0XHRcdHpCID0gcG9zaXRpb25zWyBiICogMyArIDIgXTtcclxuXHJcblx0XHRcdHhDID0gcG9zaXRpb25zWyBjICogMyBdO1xyXG5cdFx0XHR5QyA9IHBvc2l0aW9uc1sgYyAqIDMgKyAxIF07XHJcblx0XHRcdHpDID0gcG9zaXRpb25zWyBjICogMyArIDIgXTtcclxuXHJcblx0XHRcdHVBID0gdXZzWyBhICogMiBdO1xyXG5cdFx0XHR2QSA9IHV2c1sgYSAqIDIgKyAxIF07XHJcblxyXG5cdFx0XHR1QiA9IHV2c1sgYiAqIDIgXTtcclxuXHRcdFx0dkIgPSB1dnNbIGIgKiAyICsgMSBdO1xyXG5cclxuXHRcdFx0dUMgPSB1dnNbIGMgKiAyIF07XHJcblx0XHRcdHZDID0gdXZzWyBjICogMiArIDEgXTtcclxuXHJcblx0XHRcdHgxID0geEIgLSB4QTtcclxuXHRcdFx0eDIgPSB4QyAtIHhBO1xyXG5cclxuXHRcdFx0eTEgPSB5QiAtIHlBO1xyXG5cdFx0XHR5MiA9IHlDIC0geUE7XHJcblxyXG5cdFx0XHR6MSA9IHpCIC0gekE7XHJcblx0XHRcdHoyID0gekMgLSB6QTtcclxuXHJcblx0XHRcdHMxID0gdUIgLSB1QTtcclxuXHRcdFx0czIgPSB1QyAtIHVBO1xyXG5cclxuXHRcdFx0dDEgPSB2QiAtIHZBO1xyXG5cdFx0XHR0MiA9IHZDIC0gdkE7XHJcblxyXG5cdFx0XHRyID0gMS4wIC8gKCBzMSAqIHQyIC0gczIgKiB0MSApO1xyXG5cclxuXHRcdFx0c2Rpci5zZXQoXHJcblx0XHRcdFx0KCB0MiAqIHgxIC0gdDEgKiB4MiApICogcixcclxuXHRcdFx0XHQoIHQyICogeTEgLSB0MSAqIHkyICkgKiByLFxyXG5cdFx0XHRcdCggdDIgKiB6MSAtIHQxICogejIgKSAqIHJcclxuXHRcdFx0KTtcclxuXHJcblx0XHRcdHRkaXIuc2V0KFxyXG5cdFx0XHRcdCggczEgKiB4MiAtIHMyICogeDEgKSAqIHIsXHJcblx0XHRcdFx0KCBzMSAqIHkyIC0gczIgKiB5MSApICogcixcclxuXHRcdFx0XHQoIHMxICogejIgLSBzMiAqIHoxICkgKiByXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0XHR0YW4xWyBhIF0uYWRkKCBzZGlyICk7XHJcblx0XHRcdHRhbjFbIGIgXS5hZGQoIHNkaXIgKTtcclxuXHRcdFx0dGFuMVsgYyBdLmFkZCggc2RpciApO1xyXG5cclxuXHRcdFx0dGFuMlsgYSBdLmFkZCggdGRpciApO1xyXG5cdFx0XHR0YW4yWyBiIF0uYWRkKCB0ZGlyICk7XHJcblx0XHRcdHRhbjJbIGMgXS5hZGQoIHRkaXIgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGksIGlsO1xyXG5cdFx0dmFyIGosIGpsO1xyXG5cdFx0dmFyIGlBLCBpQiwgaUM7XHJcblxyXG5cdFx0dmFyIG9mZnNldHMgPSB0aGlzLm9mZnNldHM7XHJcblxyXG5cdFx0Zm9yICggaiA9IDAsIGpsID0gb2Zmc2V0cy5sZW5ndGg7IGogPCBqbDsgKysgaiApIHtcclxuXHJcblx0XHRcdHZhciBzdGFydCA9IG9mZnNldHNbIGogXS5zdGFydDtcclxuXHRcdFx0dmFyIGNvdW50ID0gb2Zmc2V0c1sgaiBdLmNvdW50O1xyXG5cdFx0XHR2YXIgaW5kZXggPSBvZmZzZXRzWyBqIF0uaW5kZXg7XHJcblxyXG5cdFx0XHRmb3IgKCBpID0gc3RhcnQsIGlsID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsOyBpICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdGlBID0gaW5kZXggKyBpbmRpY2VzWyBpIF07XHJcblx0XHRcdFx0aUIgPSBpbmRleCArIGluZGljZXNbIGkgKyAxIF07XHJcblx0XHRcdFx0aUMgPSBpbmRleCArIGluZGljZXNbIGkgKyAyIF07XHJcblxyXG5cdFx0XHRcdGhhbmRsZVRyaWFuZ2xlKCBpQSwgaUIsIGlDICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0bXAgPSBuZXcgVEhSRUUuVmVjdG9yMygpLCB0bXAyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHZhciBuID0gbmV3IFRIUkVFLlZlY3RvcjMoKSwgbjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0dmFyIHcsIHQsIHRlc3Q7XHJcblxyXG5cdFx0ZnVuY3Rpb24gaGFuZGxlVmVydGV4KCB2ICkge1xyXG5cclxuXHRcdFx0bi54ID0gbm9ybWFsc1sgdiAqIDMgXTtcclxuXHRcdFx0bi55ID0gbm9ybWFsc1sgdiAqIDMgKyAxIF07XHJcblx0XHRcdG4ueiA9IG5vcm1hbHNbIHYgKiAzICsgMiBdO1xyXG5cclxuXHRcdFx0bjIuY29weSggbiApO1xyXG5cclxuXHRcdFx0dCA9IHRhbjFbIHYgXTtcclxuXHJcblx0XHRcdC8vIEdyYW0tU2NobWlkdCBvcnRob2dvbmFsaXplXHJcblxyXG5cdFx0XHR0bXAuY29weSggdCApO1xyXG5cdFx0XHR0bXAuc3ViKCBuLm11bHRpcGx5U2NhbGFyKCBuLmRvdCggdCApICkgKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdC8vIENhbGN1bGF0ZSBoYW5kZWRuZXNzXHJcblxyXG5cdFx0XHR0bXAyLmNyb3NzVmVjdG9ycyggbjIsIHQgKTtcclxuXHRcdFx0dGVzdCA9IHRtcDIuZG90KCB0YW4yWyB2IF0gKTtcclxuXHRcdFx0dyA9ICggdGVzdCA8IDAuMCApID8gLTEuMCA6IDEuMDtcclxuXHJcblx0XHRcdHRhbmdlbnRzWyB2ICogNCBdIFx0ICA9IHRtcC54O1xyXG5cdFx0XHR0YW5nZW50c1sgdiAqIDQgKyAxIF0gPSB0bXAueTtcclxuXHRcdFx0dGFuZ2VudHNbIHYgKiA0ICsgMiBdID0gdG1wLno7XHJcblx0XHRcdHRhbmdlbnRzWyB2ICogNCArIDMgXSA9IHc7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIGogPSAwLCBqbCA9IG9mZnNldHMubGVuZ3RoOyBqIDwgamw7ICsrIGogKSB7XHJcblxyXG5cdFx0XHR2YXIgc3RhcnQgPSBvZmZzZXRzWyBqIF0uc3RhcnQ7XHJcblx0XHRcdHZhciBjb3VudCA9IG9mZnNldHNbIGogXS5jb3VudDtcclxuXHRcdFx0dmFyIGluZGV4ID0gb2Zmc2V0c1sgaiBdLmluZGV4O1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IHN0YXJ0LCBpbCA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbDsgaSArPSAzICkge1xyXG5cclxuXHRcdFx0XHRpQSA9IGluZGV4ICsgaW5kaWNlc1sgaSBdO1xyXG5cdFx0XHRcdGlCID0gaW5kZXggKyBpbmRpY2VzWyBpICsgMSBdO1xyXG5cdFx0XHRcdGlDID0gaW5kZXggKyBpbmRpY2VzWyBpICsgMiBdO1xyXG5cclxuXHRcdFx0XHRoYW5kbGVWZXJ0ZXgoIGlBICk7XHJcblx0XHRcdFx0aGFuZGxlVmVydGV4KCBpQiApO1xyXG5cdFx0XHRcdGhhbmRsZVZlcnRleCggaUMgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5oYXNUYW5nZW50cyA9IHRydWU7XHJcblx0XHR0aGlzLnRhbmdlbnRzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKi9cclxuXHJcblRIUkVFLkNhbWVyYSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLm1hdHJpeFdvcmxkSW52ZXJzZSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG5cdHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblx0dGhpcy5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ2FtZXJhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuQ2FtZXJhLnByb3RvdHlwZS5sb29rQXQgPSBmdW5jdGlvbiAoIHZlY3RvciApIHtcclxuXHJcblx0Ly8gVE9ETzogQWRkIGhpZXJhcmNoeSBzdXBwb3J0LlxyXG5cclxuXHR0aGlzLm1hdHJpeC5sb29rQXQoIHRoaXMucG9zaXRpb24sIHZlY3RvciwgdGhpcy51cCApO1xyXG5cclxuXHRpZiAoIHRoaXMucm90YXRpb25BdXRvVXBkYXRlID09PSB0cnVlICkge1xyXG5cclxuXHRcdGlmICggdGhpcy51c2VRdWF0ZXJuaW9uID09PSBmYWxzZSApICB7XHJcblxyXG5cdFx0XHR0aGlzLnJvdGF0aW9uLnNldEV1bGVyRnJvbVJvdGF0aW9uTWF0cml4KCB0aGlzLm1hdHJpeCwgdGhpcy5ldWxlck9yZGVyICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMucXVhdGVybmlvbi5jb3B5KCB0aGlzLm1hdHJpeC5kZWNvbXBvc2UoKVsgMSBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59O1xyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5PcnRob2dyYXBoaWNDYW1lcmEgPSBmdW5jdGlvbiAoIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyICkge1xyXG5cclxuXHRUSFJFRS5DYW1lcmEuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLmxlZnQgPSBsZWZ0O1xyXG5cdHRoaXMucmlnaHQgPSByaWdodDtcclxuXHR0aGlzLnRvcCA9IHRvcDtcclxuXHR0aGlzLmJvdHRvbSA9IGJvdHRvbTtcclxuXHJcblx0dGhpcy5uZWFyID0gKCBuZWFyICE9PSB1bmRlZmluZWQgKSA/IG5lYXIgOiAwLjE7XHJcblx0dGhpcy5mYXIgPSAoIGZhciAhPT0gdW5kZWZpbmVkICkgPyBmYXIgOiAyMDAwO1xyXG5cclxuXHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5PcnRob2dyYXBoaWNDYW1lcmEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ2FtZXJhLnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhLnByb3RvdHlwZS51cGRhdGVQcm9qZWN0aW9uTWF0cml4ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR0aGlzLnByb2plY3Rpb25NYXRyaXgubWFrZU9ydGhvZ3JhcGhpYyggdGhpcy5sZWZ0LCB0aGlzLnJpZ2h0LCB0aGlzLnRvcCwgdGhpcy5ib3R0b20sIHRoaXMubmVhciwgdGhpcy5mYXIgKTtcclxuXHJcbn07XHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGdyZWdnbWFuIC8gaHR0cDovL2dhbWVzLmdyZWdnbWFuLmNvbS9cclxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG4gKi9cclxuXHJcblRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhID0gZnVuY3Rpb24gKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICkge1xyXG5cclxuXHRUSFJFRS5DYW1lcmEuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLmZvdiA9IGZvdiAhPT0gdW5kZWZpbmVkID8gZm92IDogNTA7XHJcblx0dGhpcy5hc3BlY3QgPSBhc3BlY3QgIT09IHVuZGVmaW5lZCA/IGFzcGVjdCA6IDE7XHJcblx0dGhpcy5uZWFyID0gbmVhciAhPT0gdW5kZWZpbmVkID8gbmVhciA6IDAuMTtcclxuXHR0aGlzLmZhciA9IGZhciAhPT0gdW5kZWZpbmVkID8gZmFyIDogMjAwMDtcclxuXHJcblx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ2FtZXJhLnByb3RvdHlwZSApO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBVc2VzIEZvY2FsIExlbmd0aCAoaW4gbW0pIHRvIGVzdGltYXRlIGFuZCBzZXQgRk9WXHJcbiAqIDM1bW0gKGZ1bGxmcmFtZSkgY2FtZXJhIGlzIHVzZWQgaWYgZnJhbWUgc2l6ZSBpcyBub3Qgc3BlY2lmaWVkO1xyXG4gKiBGb3JtdWxhIGJhc2VkIG9uIGh0dHA6Ly93d3cuYm9iYXRraW5zLmNvbS9waG90b2dyYXBoeS90ZWNobmljYWwvZmllbGRfb2Zfdmlldy5odG1sXHJcbiAqL1xyXG5cclxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlLnNldExlbnMgPSBmdW5jdGlvbiAoIGZvY2FsTGVuZ3RoLCBmcmFtZUhlaWdodCApIHtcclxuXHJcblx0aWYgKCBmcmFtZUhlaWdodCA9PT0gdW5kZWZpbmVkICkgZnJhbWVIZWlnaHQgPSAyNDtcclxuXHJcblx0dGhpcy5mb3YgPSAyICogVEhSRUUuTWF0aC5yYWRUb0RlZyggTWF0aC5hdGFuKCBmcmFtZUhlaWdodCAvICggZm9jYWxMZW5ndGggKiAyICkgKSApO1xyXG5cdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xyXG5cclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBTZXRzIGFuIG9mZnNldCBpbiBhIGxhcmdlciBmcnVzdHVtLiBUaGlzIGlzIHVzZWZ1bCBmb3IgbXVsdGktd2luZG93IG9yXHJcbiAqIG11bHRpLW1vbml0b3IvbXVsdGktbWFjaGluZSBzZXR1cHMuXHJcbiAqXHJcbiAqIEZvciBleGFtcGxlLCBpZiB5b3UgaGF2ZSAzeDIgbW9uaXRvcnMgYW5kIGVhY2ggbW9uaXRvciBpcyAxOTIweDEwODAgYW5kXHJcbiAqIHRoZSBtb25pdG9ycyBhcmUgaW4gZ3JpZCBsaWtlIHRoaXNcclxuICpcclxuICogICArLS0tKy0tLSstLS0rXHJcbiAqICAgfCBBIHwgQiB8IEMgfFxyXG4gKiAgICstLS0rLS0tKy0tLStcclxuICogICB8IEQgfCBFIHwgRiB8XHJcbiAqICAgKy0tLSstLS0rLS0tK1xyXG4gKlxyXG4gKiB0aGVuIGZvciBlYWNoIG1vbml0b3IgeW91IHdvdWxkIGNhbGwgaXQgbGlrZSB0aGlzXHJcbiAqXHJcbiAqICAgdmFyIHcgPSAxOTIwO1xyXG4gKiAgIHZhciBoID0gMTA4MDtcclxuICogICB2YXIgZnVsbFdpZHRoID0gdyAqIDM7XHJcbiAqICAgdmFyIGZ1bGxIZWlnaHQgPSBoICogMjtcclxuICpcclxuICogICAtLUEtLVxyXG4gKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDAsIGggKiAwLCB3LCBoICk7XHJcbiAqICAgLS1CLS1cclxuICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAxLCBoICogMCwgdywgaCApO1xyXG4gKiAgIC0tQy0tXHJcbiAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMiwgaCAqIDAsIHcsIGggKTtcclxuICogICAtLUQtLVxyXG4gKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDAsIGggKiAxLCB3LCBoICk7XHJcbiAqICAgLS1FLS1cclxuICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAxLCBoICogMSwgdywgaCApO1xyXG4gKiAgIC0tRi0tXHJcbiAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMiwgaCAqIDEsIHcsIGggKTtcclxuICpcclxuICogICBOb3RlIHRoZXJlIGlzIG5vIHJlYXNvbiBtb25pdG9ycyBoYXZlIHRvIGJlIHRoZSBzYW1lIHNpemUgb3IgaW4gYSBncmlkLlxyXG4gKi9cclxuXHJcblRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZS5zZXRWaWV3T2Zmc2V0ID0gZnVuY3Rpb24gKCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHgsIHksIHdpZHRoLCBoZWlnaHQgKSB7XHJcblxyXG5cdHRoaXMuZnVsbFdpZHRoID0gZnVsbFdpZHRoO1xyXG5cdHRoaXMuZnVsbEhlaWdodCA9IGZ1bGxIZWlnaHQ7XHJcblx0dGhpcy54ID0geDtcclxuXHR0aGlzLnkgPSB5O1xyXG5cdHRoaXMud2lkdGggPSB3aWR0aDtcclxuXHR0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuXHJcblx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XHJcblxyXG59O1xyXG5cclxuXHJcblRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZS51cGRhdGVQcm9qZWN0aW9uTWF0cml4ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRpZiAoIHRoaXMuZnVsbFdpZHRoICkge1xyXG5cclxuXHRcdHZhciBhc3BlY3QgPSB0aGlzLmZ1bGxXaWR0aCAvIHRoaXMuZnVsbEhlaWdodDtcclxuXHRcdHZhciB0b3AgPSBNYXRoLnRhbiggVEhSRUUuTWF0aC5kZWdUb1JhZCggdGhpcy5mb3YgKiAwLjUgKSApICogdGhpcy5uZWFyO1xyXG5cdFx0dmFyIGJvdHRvbSA9IC10b3A7XHJcblx0XHR2YXIgbGVmdCA9IGFzcGVjdCAqIGJvdHRvbTtcclxuXHRcdHZhciByaWdodCA9IGFzcGVjdCAqIHRvcDtcclxuXHRcdHZhciB3aWR0aCA9IE1hdGguYWJzKCByaWdodCAtIGxlZnQgKTtcclxuXHRcdHZhciBoZWlnaHQgPSBNYXRoLmFicyggdG9wIC0gYm90dG9tICk7XHJcblxyXG5cdFx0dGhpcy5wcm9qZWN0aW9uTWF0cml4Lm1ha2VGcnVzdHVtKFxyXG5cdFx0XHRsZWZ0ICsgdGhpcy54ICogd2lkdGggLyB0aGlzLmZ1bGxXaWR0aCxcclxuXHRcdFx0bGVmdCArICggdGhpcy54ICsgdGhpcy53aWR0aCApICogd2lkdGggLyB0aGlzLmZ1bGxXaWR0aCxcclxuXHRcdFx0dG9wIC0gKCB0aGlzLnkgKyB0aGlzLmhlaWdodCApICogaGVpZ2h0IC8gdGhpcy5mdWxsSGVpZ2h0LFxyXG5cdFx0XHR0b3AgLSB0aGlzLnkgKiBoZWlnaHQgLyB0aGlzLmZ1bGxIZWlnaHQsXHJcblx0XHRcdHRoaXMubmVhcixcclxuXHRcdFx0dGhpcy5mYXJcclxuXHRcdCk7XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0dGhpcy5wcm9qZWN0aW9uTWF0cml4Lm1ha2VQZXJzcGVjdGl2ZSggdGhpcy5mb3YsIHRoaXMuYXNwZWN0LCB0aGlzLm5lYXIsIHRoaXMuZmFyICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuIFxyXG5USFJFRS5MaWdodCA9IGZ1bmN0aW9uICggaGV4ICkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIGhleCApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkxpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5BbWJpZW50TGlnaHQgPSBmdW5jdGlvbiAoIGhleCApIHtcclxuXHJcblx0VEhSRUUuTGlnaHQuY2FsbCggdGhpcywgaGV4ICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQW1iaWVudExpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpZ2h0LnByb3RvdHlwZSApO1xyXG4vKipcclxuICogQGF1dGhvciBNUGFua25pbiAvIGh0dHA6Ly93d3cucmVkcGxhbnQuZGUvXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQXJlYUxpZ2h0ID0gZnVuY3Rpb24gKCBoZXgsIGludGVuc2l0eSApIHtcclxuXHJcblx0VEhSRUUuTGlnaHQuY2FsbCggdGhpcywgaGV4ICk7XHJcblxyXG5cdHRoaXMubm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIC0xLCAwICk7XHJcblx0dGhpcy5yaWdodCA9IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAwLCAwICk7XHJcblxyXG5cdHRoaXMuaW50ZW5zaXR5ID0gKCBpbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApID8gaW50ZW5zaXR5IDogMTtcclxuXHJcblx0dGhpcy53aWR0aCA9IDEuMDtcclxuXHR0aGlzLmhlaWdodCA9IDEuMDtcclxuXHJcblx0dGhpcy5jb25zdGFudEF0dGVudWF0aW9uID0gMS41O1xyXG5cdHRoaXMubGluZWFyQXR0ZW51YXRpb24gPSAwLjU7XHJcblx0dGhpcy5xdWFkcmF0aWNBdHRlbnVhdGlvbiA9IDAuMTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BcmVhTGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGlnaHQucHJvdG90eXBlICk7XHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5EaXJlY3Rpb25hbExpZ2h0ID0gZnVuY3Rpb24gKCBoZXgsIGludGVuc2l0eSApIHtcclxuXHJcblx0VEhSRUUuTGlnaHQuY2FsbCggdGhpcywgaGV4ICk7XHJcblxyXG5cdHRoaXMucG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApO1xyXG5cdHRoaXMudGFyZ2V0ID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XHJcblxyXG5cdHRoaXMuaW50ZW5zaXR5ID0gKCBpbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApID8gaW50ZW5zaXR5IDogMTtcclxuXHJcblx0dGhpcy5jYXN0U2hhZG93ID0gZmFsc2U7XHJcblx0dGhpcy5vbmx5U2hhZG93ID0gZmFsc2U7XHJcblxyXG5cdC8vXHJcblxyXG5cdHRoaXMuc2hhZG93Q2FtZXJhTmVhciA9IDUwO1xyXG5cdHRoaXMuc2hhZG93Q2FtZXJhRmFyID0gNTAwMDtcclxuXHJcblx0dGhpcy5zaGFkb3dDYW1lcmFMZWZ0ID0gLTUwMDtcclxuXHR0aGlzLnNoYWRvd0NhbWVyYVJpZ2h0ID0gNTAwO1xyXG5cdHRoaXMuc2hhZG93Q2FtZXJhVG9wID0gNTAwO1xyXG5cdHRoaXMuc2hhZG93Q2FtZXJhQm90dG9tID0gLTUwMDtcclxuXHJcblx0dGhpcy5zaGFkb3dDYW1lcmFWaXNpYmxlID0gZmFsc2U7XHJcblxyXG5cdHRoaXMuc2hhZG93QmlhcyA9IDA7XHJcblx0dGhpcy5zaGFkb3dEYXJrbmVzcyA9IDAuNTtcclxuXHJcblx0dGhpcy5zaGFkb3dNYXBXaWR0aCA9IDUxMjtcclxuXHR0aGlzLnNoYWRvd01hcEhlaWdodCA9IDUxMjtcclxuXHJcblx0Ly9cclxuXHJcblx0dGhpcy5zaGFkb3dDYXNjYWRlID0gZmFsc2U7XHJcblxyXG5cdHRoaXMuc2hhZG93Q2FzY2FkZU9mZnNldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAtMTAwMCApO1xyXG5cdHRoaXMuc2hhZG93Q2FzY2FkZUNvdW50ID0gMjtcclxuXHJcblx0dGhpcy5zaGFkb3dDYXNjYWRlQmlhcyA9IFsgMCwgMCwgMCBdO1xyXG5cdHRoaXMuc2hhZG93Q2FzY2FkZVdpZHRoID0gWyA1MTIsIDUxMiwgNTEyIF07XHJcblx0dGhpcy5zaGFkb3dDYXNjYWRlSGVpZ2h0ID0gWyA1MTIsIDUxMiwgNTEyIF07XHJcblxyXG5cdHRoaXMuc2hhZG93Q2FzY2FkZU5lYXJaID0gWyAtMS4wMDAsIDAuOTkwLCAwLjk5OCBdO1xyXG5cdHRoaXMuc2hhZG93Q2FzY2FkZUZhclogID0gWyAgMC45OTAsIDAuOTk4LCAxLjAwMCBdO1xyXG5cclxuXHR0aGlzLnNoYWRvd0Nhc2NhZGVBcnJheSA9IFtdO1xyXG5cclxuXHQvL1xyXG5cclxuXHR0aGlzLnNoYWRvd01hcCA9IG51bGw7XHJcblx0dGhpcy5zaGFkb3dNYXBTaXplID0gbnVsbDtcclxuXHR0aGlzLnNoYWRvd0NhbWVyYSA9IG51bGw7XHJcblx0dGhpcy5zaGFkb3dNYXRyaXggPSBudWxsO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkRpcmVjdGlvbmFsTGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGlnaHQucHJvdG90eXBlICk7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkhlbWlzcGhlcmVMaWdodCA9IGZ1bmN0aW9uICggc2t5Q29sb3JIZXgsIGdyb3VuZENvbG9ySGV4LCBpbnRlbnNpdHkgKSB7XHJcblxyXG5cdFRIUkVFLkxpZ2h0LmNhbGwoIHRoaXMsIHNreUNvbG9ySGV4ICk7XHJcblxyXG5cdHRoaXMuZ3JvdW5kQ29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIGdyb3VuZENvbG9ySGV4ICk7XHJcblxyXG5cdHRoaXMucG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMTAwLCAwICk7XHJcblxyXG5cdHRoaXMuaW50ZW5zaXR5ID0gKCBpbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApID8gaW50ZW5zaXR5IDogMTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5IZW1pc3BoZXJlTGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGlnaHQucHJvdG90eXBlICk7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlBvaW50TGlnaHQgPSBmdW5jdGlvbiAoIGhleCwgaW50ZW5zaXR5LCBkaXN0YW5jZSApIHtcclxuXHJcblx0VEhSRUUuTGlnaHQuY2FsbCggdGhpcywgaGV4ICk7XHJcblxyXG5cdHRoaXMucG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMCApO1xyXG5cdHRoaXMuaW50ZW5zaXR5ID0gKCBpbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApID8gaW50ZW5zaXR5IDogMTtcclxuXHR0aGlzLmRpc3RhbmNlID0gKCBkaXN0YW5jZSAhPT0gdW5kZWZpbmVkICkgPyBkaXN0YW5jZSA6IDA7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUG9pbnRMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaWdodC5wcm90b3R5cGUgKTtcclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuU3BvdExpZ2h0ID0gZnVuY3Rpb24gKCBoZXgsIGludGVuc2l0eSwgZGlzdGFuY2UsIGFuZ2xlLCBleHBvbmVudCApIHtcclxuXHJcblx0VEhSRUUuTGlnaHQuY2FsbCggdGhpcywgaGV4ICk7XHJcblxyXG5cdHRoaXMucG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApO1xyXG5cdHRoaXMudGFyZ2V0ID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XHJcblxyXG5cdHRoaXMuaW50ZW5zaXR5ID0gKCBpbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApID8gaW50ZW5zaXR5IDogMTtcclxuXHR0aGlzLmRpc3RhbmNlID0gKCBkaXN0YW5jZSAhPT0gdW5kZWZpbmVkICkgPyBkaXN0YW5jZSA6IDA7XHJcblx0dGhpcy5hbmdsZSA9ICggYW5nbGUgIT09IHVuZGVmaW5lZCApID8gYW5nbGUgOiBNYXRoLlBJIC8gMjtcclxuXHR0aGlzLmV4cG9uZW50ID0gKCBleHBvbmVudCAhPT0gdW5kZWZpbmVkICkgPyBleHBvbmVudCA6IDEwO1xyXG5cclxuXHR0aGlzLmNhc3RTaGFkb3cgPSBmYWxzZTtcclxuXHR0aGlzLm9ubHlTaGFkb3cgPSBmYWxzZTtcclxuXHJcblx0Ly9cclxuXHJcblx0dGhpcy5zaGFkb3dDYW1lcmFOZWFyID0gNTA7XHJcblx0dGhpcy5zaGFkb3dDYW1lcmFGYXIgPSA1MDAwO1xyXG5cdHRoaXMuc2hhZG93Q2FtZXJhRm92ID0gNTA7XHJcblxyXG5cdHRoaXMuc2hhZG93Q2FtZXJhVmlzaWJsZSA9IGZhbHNlO1xyXG5cclxuXHR0aGlzLnNoYWRvd0JpYXMgPSAwO1xyXG5cdHRoaXMuc2hhZG93RGFya25lc3MgPSAwLjU7XHJcblxyXG5cdHRoaXMuc2hhZG93TWFwV2lkdGggPSA1MTI7XHJcblx0dGhpcy5zaGFkb3dNYXBIZWlnaHQgPSA1MTI7XHJcblxyXG5cdC8vXHJcblxyXG5cdHRoaXMuc2hhZG93TWFwID0gbnVsbDtcclxuXHR0aGlzLnNoYWRvd01hcFNpemUgPSBudWxsO1xyXG5cdHRoaXMuc2hhZG93Q2FtZXJhID0gbnVsbDtcclxuXHR0aGlzLnNoYWRvd01hdHJpeCA9IG51bGw7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU3BvdExpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpZ2h0LnByb3RvdHlwZSApO1xyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5Mb2FkZXIgPSBmdW5jdGlvbiAoIHNob3dTdGF0dXMgKSB7XHJcblxyXG5cdHRoaXMuc2hvd1N0YXR1cyA9IHNob3dTdGF0dXM7XHJcblx0dGhpcy5zdGF0dXNEb21FbGVtZW50ID0gc2hvd1N0YXR1cyA/IFRIUkVFLkxvYWRlci5wcm90b3R5cGUuYWRkU3RhdHVzRWxlbWVudCgpIDogbnVsbDtcclxuXHJcblx0dGhpcy5vbkxvYWRTdGFydCA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cdHRoaXMub25Mb2FkUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHR0aGlzLm9uTG9hZENvbXBsZXRlID0gZnVuY3Rpb24gKCkge307XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTG9hZGVyLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkxvYWRlcixcclxuXHJcblx0Y3Jvc3NPcmlnaW46ICdhbm9ueW1vdXMnLFxyXG5cclxuXHRhZGRTdGF0dXNFbGVtZW50OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XHJcblxyXG5cdFx0ZS5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcclxuXHRcdGUuc3R5bGUucmlnaHQgPSBcIjBweFwiO1xyXG5cdFx0ZS5zdHlsZS50b3AgPSBcIjBweFwiO1xyXG5cdFx0ZS5zdHlsZS5mb250U2l6ZSA9IFwiMC44ZW1cIjtcclxuXHRcdGUuc3R5bGUudGV4dEFsaWduID0gXCJsZWZ0XCI7XHJcblx0XHRlLnN0eWxlLmJhY2tncm91bmQgPSBcInJnYmEoMCwwLDAsMC4yNSlcIjtcclxuXHRcdGUuc3R5bGUuY29sb3IgPSBcIiNmZmZcIjtcclxuXHRcdGUuc3R5bGUud2lkdGggPSBcIjEyMHB4XCI7XHJcblx0XHRlLnN0eWxlLnBhZGRpbmcgPSBcIjAuNWVtIDAuNWVtIDAuNWVtIDAuNWVtXCI7XHJcblx0XHRlLnN0eWxlLnpJbmRleCA9IDEwMDA7XHJcblxyXG5cdFx0ZS5pbm5lckhUTUwgPSBcIkxvYWRpbmcgLi4uXCI7XHJcblxyXG5cdFx0cmV0dXJuIGU7XHJcblxyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZVByb2dyZXNzOiBmdW5jdGlvbiAoIHByb2dyZXNzICkge1xyXG5cclxuXHRcdHZhciBtZXNzYWdlID0gXCJMb2FkZWQgXCI7XHJcblxyXG5cdFx0aWYgKCBwcm9ncmVzcy50b3RhbCApIHtcclxuXHJcblx0XHRcdG1lc3NhZ2UgKz0gKCAxMDAgKiBwcm9ncmVzcy5sb2FkZWQgLyBwcm9ncmVzcy50b3RhbCApLnRvRml4ZWQoMCkgKyBcIiVcIjtcclxuXHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdG1lc3NhZ2UgKz0gKCBwcm9ncmVzcy5sb2FkZWQgLyAxMDAwICkudG9GaXhlZCgyKSArIFwiIEtCXCI7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuc3RhdHVzRG9tRWxlbWVudC5pbm5lckhUTUwgPSBtZXNzYWdlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRleHRyYWN0VXJsQmFzZTogZnVuY3Rpb24gKCB1cmwgKSB7XHJcblxyXG5cdFx0dmFyIHBhcnRzID0gdXJsLnNwbGl0KCAnLycgKTtcclxuXHRcdHBhcnRzLnBvcCgpO1xyXG5cdFx0cmV0dXJuICggcGFydHMubGVuZ3RoIDwgMSA/ICcuJyA6IHBhcnRzLmpvaW4oICcvJyApICkgKyAnLyc7XHJcblxyXG5cdH0sXHJcblxyXG5cdGluaXRNYXRlcmlhbHM6IGZ1bmN0aW9uICggbWF0ZXJpYWxzLCB0ZXh0dXJlUGF0aCApIHtcclxuXHJcblx0XHR2YXIgYXJyYXkgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBtYXRlcmlhbHMubGVuZ3RoOyArKyBpICkge1xyXG5cclxuXHRcdFx0YXJyYXlbIGkgXSA9IFRIUkVFLkxvYWRlci5wcm90b3R5cGUuY3JlYXRlTWF0ZXJpYWwoIG1hdGVyaWFsc1sgaSBdLCB0ZXh0dXJlUGF0aCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gYXJyYXk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG5lZWRzVGFuZ2VudHM6IGZ1bmN0aW9uICggbWF0ZXJpYWxzICkge1xyXG5cclxuXHRcdGZvciggdmFyIGkgPSAwLCBpbCA9IG1hdGVyaWFscy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBtID0gbWF0ZXJpYWxzWyBpIF07XHJcblxyXG5cdFx0XHRpZiAoIG0gaW5zdGFuY2VvZiBUSFJFRS5TaGFkZXJNYXRlcmlhbCApIHJldHVybiB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNyZWF0ZU1hdGVyaWFsOiBmdW5jdGlvbiAoIG0sIHRleHR1cmVQYXRoICkge1xyXG5cclxuXHRcdHZhciBfdGhpcyA9IHRoaXM7XHJcblxyXG5cdFx0ZnVuY3Rpb24gaXNfcG93MiggbiApIHtcclxuXHJcblx0XHRcdHZhciBsID0gTWF0aC5sb2coIG4gKSAvIE1hdGguTE4yO1xyXG5cdFx0XHRyZXR1cm4gTWF0aC5mbG9vciggbCApID09IGw7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIG5lYXJlc3RfcG93MiggbiApIHtcclxuXHJcblx0XHRcdHZhciBsID0gTWF0aC5sb2coIG4gKSAvIE1hdGguTE4yO1xyXG5cdFx0XHRyZXR1cm4gTWF0aC5wb3coIDIsIE1hdGgucm91bmQoICBsICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gbG9hZF9pbWFnZSggd2hlcmUsIHVybCApIHtcclxuXHJcblx0XHRcdHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpO1xyXG5cclxuXHRcdFx0aW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0XHRpZiAoICFpc19wb3cyKCB0aGlzLndpZHRoICkgfHwgIWlzX3BvdzIoIHRoaXMuaGVpZ2h0ICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHdpZHRoID0gbmVhcmVzdF9wb3cyKCB0aGlzLndpZHRoICk7XHJcblx0XHRcdFx0XHR2YXIgaGVpZ2h0ID0gbmVhcmVzdF9wb3cyKCB0aGlzLmhlaWdodCApO1xyXG5cclxuXHRcdFx0XHRcdHdoZXJlLmltYWdlLndpZHRoID0gd2lkdGg7XHJcblx0XHRcdFx0XHR3aGVyZS5pbWFnZS5oZWlnaHQgPSBoZWlnaHQ7XHJcblx0XHRcdFx0XHR3aGVyZS5pbWFnZS5nZXRDb250ZXh0KCAnMmQnICkuZHJhd0ltYWdlKCB0aGlzLCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0d2hlcmUuaW1hZ2UgPSB0aGlzO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHdoZXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRpbWFnZS5jcm9zc09yaWdpbiA9IF90aGlzLmNyb3NzT3JpZ2luO1xyXG5cdFx0XHRpbWFnZS5zcmMgPSB1cmw7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGNyZWF0ZV90ZXh0dXJlKCB3aGVyZSwgbmFtZSwgc291cmNlRmlsZSwgcmVwZWF0LCBvZmZzZXQsIHdyYXAsIGFuaXNvdHJvcHkgKSB7XHJcblxyXG5cdFx0XHR2YXIgaXNDb21wcmVzc2VkID0gL1xcLmRkcyQvaS50ZXN0KCBzb3VyY2VGaWxlICk7XHJcblx0XHRcdHZhciBmdWxsUGF0aCA9IHRleHR1cmVQYXRoICsgXCIvXCIgKyBzb3VyY2VGaWxlO1xyXG5cclxuXHRcdFx0aWYgKCBpc0NvbXByZXNzZWQgKSB7XHJcblxyXG5cdFx0XHRcdHZhciB0ZXh0dXJlID0gVEhSRUUuSW1hZ2VVdGlscy5sb2FkQ29tcHJlc3NlZFRleHR1cmUoIGZ1bGxQYXRoICk7XHJcblxyXG5cdFx0XHRcdHdoZXJlWyBuYW1lIF0gPSB0ZXh0dXJlO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dmFyIHRleHR1cmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApO1xyXG5cclxuXHRcdFx0XHR3aGVyZVsgbmFtZSBdID0gbmV3IFRIUkVFLlRleHR1cmUoIHRleHR1cmUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHdoZXJlWyBuYW1lIF0uc291cmNlRmlsZSA9IHNvdXJjZUZpbGU7XHJcblxyXG5cdFx0XHRpZiggcmVwZWF0ICkge1xyXG5cclxuXHRcdFx0XHR3aGVyZVsgbmFtZSBdLnJlcGVhdC5zZXQoIHJlcGVhdFsgMCBdLCByZXBlYXRbIDEgXSApO1xyXG5cclxuXHRcdFx0XHRpZiAoIHJlcGVhdFsgMCBdICE9PSAxICkgd2hlcmVbIG5hbWUgXS53cmFwUyA9IFRIUkVFLlJlcGVhdFdyYXBwaW5nO1xyXG5cdFx0XHRcdGlmICggcmVwZWF0WyAxIF0gIT09IDEgKSB3aGVyZVsgbmFtZSBdLndyYXBUID0gVEhSRUUuUmVwZWF0V3JhcHBpbmc7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG9mZnNldCApIHtcclxuXHJcblx0XHRcdFx0d2hlcmVbIG5hbWUgXS5vZmZzZXQuc2V0KCBvZmZzZXRbIDAgXSwgb2Zmc2V0WyAxIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggd3JhcCApIHtcclxuXHJcblx0XHRcdFx0dmFyIHdyYXBNYXAgPSB7XHJcblx0XHRcdFx0XHRcInJlcGVhdFwiOiBUSFJFRS5SZXBlYXRXcmFwcGluZyxcclxuXHRcdFx0XHRcdFwibWlycm9yXCI6IFRIUkVFLk1pcnJvcmVkUmVwZWF0V3JhcHBpbmdcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggd3JhcE1hcFsgd3JhcFsgMCBdIF0gIT09IHVuZGVmaW5lZCApIHdoZXJlWyBuYW1lIF0ud3JhcFMgPSB3cmFwTWFwWyB3cmFwWyAwIF0gXTtcclxuXHRcdFx0XHRpZiAoIHdyYXBNYXBbIHdyYXBbIDEgXSBdICE9PSB1bmRlZmluZWQgKSB3aGVyZVsgbmFtZSBdLndyYXBUID0gd3JhcE1hcFsgd3JhcFsgMSBdIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGFuaXNvdHJvcHkgKSB7XHJcblxyXG5cdFx0XHRcdHdoZXJlWyBuYW1lIF0uYW5pc290cm9weSA9IGFuaXNvdHJvcHk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoICEgaXNDb21wcmVzc2VkICkge1xyXG5cclxuXHRcdFx0XHRsb2FkX2ltYWdlKCB3aGVyZVsgbmFtZSBdLCBmdWxsUGF0aCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiByZ2IyaGV4KCByZ2IgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gKCByZ2JbIDAgXSAqIDI1NSA8PCAxNiApICsgKCByZ2JbIDEgXSAqIDI1NSA8PCA4ICkgKyByZ2JbIDIgXSAqIDI1NTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZGVmYXVsdHNcclxuXHJcblx0XHR2YXIgbXR5cGUgPSBcIk1lc2hMYW1iZXJ0TWF0ZXJpYWxcIjtcclxuXHRcdHZhciBtcGFycyA9IHsgY29sb3I6IDB4ZWVlZWVlLCBvcGFjaXR5OiAxLjAsIG1hcDogbnVsbCwgbGlnaHRNYXA6IG51bGwsIG5vcm1hbE1hcDogbnVsbCwgYnVtcE1hcDogbnVsbCwgd2lyZWZyYW1lOiBmYWxzZSB9O1xyXG5cclxuXHRcdC8vIHBhcmFtZXRlcnMgZnJvbSBtb2RlbCBmaWxlXHJcblxyXG5cdFx0aWYgKCBtLnNoYWRpbmcgKSB7XHJcblxyXG5cdFx0XHR2YXIgc2hhZGluZyA9IG0uc2hhZGluZy50b0xvd2VyQ2FzZSgpO1xyXG5cclxuXHRcdFx0aWYgKCBzaGFkaW5nID09PSBcInBob25nXCIgKSBtdHlwZSA9IFwiTWVzaFBob25nTWF0ZXJpYWxcIjtcclxuXHRcdFx0ZWxzZSBpZiAoIHNoYWRpbmcgPT09IFwiYmFzaWNcIiApIG10eXBlID0gXCJNZXNoQmFzaWNNYXRlcmlhbFwiO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG0uYmxlbmRpbmcgIT09IHVuZGVmaW5lZCAmJiBUSFJFRVsgbS5ibGVuZGluZyBdICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRtcGFycy5ibGVuZGluZyA9IFRIUkVFWyBtLmJsZW5kaW5nIF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbS50cmFuc3BhcmVudCAhPT0gdW5kZWZpbmVkIHx8IG0ub3BhY2l0eSA8IDEuMCApIHtcclxuXHJcblx0XHRcdG1wYXJzLnRyYW5zcGFyZW50ID0gbS50cmFuc3BhcmVudDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtLmRlcHRoVGVzdCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0bXBhcnMuZGVwdGhUZXN0ID0gbS5kZXB0aFRlc3Q7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbS5kZXB0aFdyaXRlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRtcGFycy5kZXB0aFdyaXRlID0gbS5kZXB0aFdyaXRlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG0udmlzaWJsZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0bXBhcnMudmlzaWJsZSA9IG0udmlzaWJsZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtLmZsaXBTaWRlZCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0bXBhcnMuc2lkZSA9IFRIUkVFLkJhY2tTaWRlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG0uZG91YmxlU2lkZWQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdG1wYXJzLnNpZGUgPSBUSFJFRS5Eb3VibGVTaWRlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG0ud2lyZWZyYW1lICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRtcGFycy53aXJlZnJhbWUgPSBtLndpcmVmcmFtZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtLnZlcnRleENvbG9ycyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0aWYgKCBtLnZlcnRleENvbG9ycyA9PT0gXCJmYWNlXCIgKSB7XHJcblxyXG5cdFx0XHRcdG1wYXJzLnZlcnRleENvbG9ycyA9IFRIUkVFLkZhY2VDb2xvcnM7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBtLnZlcnRleENvbG9ycyApIHtcclxuXHJcblx0XHRcdFx0bXBhcnMudmVydGV4Q29sb3JzID0gVEhSRUUuVmVydGV4Q29sb3JzO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBjb2xvcnNcclxuXHJcblx0XHRpZiAoIG0uY29sb3JEaWZmdXNlICkge1xyXG5cclxuXHRcdFx0bXBhcnMuY29sb3IgPSByZ2IyaGV4KCBtLmNvbG9yRGlmZnVzZSApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG0uRGJnQ29sb3IgKSB7XHJcblxyXG5cdFx0XHRtcGFycy5jb2xvciA9IG0uRGJnQ29sb3I7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbS5jb2xvclNwZWN1bGFyICkge1xyXG5cclxuXHRcdFx0bXBhcnMuc3BlY3VsYXIgPSByZ2IyaGV4KCBtLmNvbG9yU3BlY3VsYXIgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtLmNvbG9yQW1iaWVudCApIHtcclxuXHJcblx0XHRcdG1wYXJzLmFtYmllbnQgPSByZ2IyaGV4KCBtLmNvbG9yQW1iaWVudCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBtb2RpZmllcnNcclxuXHJcblx0XHRpZiAoIG0udHJhbnNwYXJlbmN5ICkge1xyXG5cclxuXHRcdFx0bXBhcnMub3BhY2l0eSA9IG0udHJhbnNwYXJlbmN5O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG0uc3BlY3VsYXJDb2VmICkge1xyXG5cclxuXHRcdFx0bXBhcnMuc2hpbmluZXNzID0gbS5zcGVjdWxhckNvZWY7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHRleHR1cmVzXHJcblxyXG5cdFx0aWYgKCBtLm1hcERpZmZ1c2UgJiYgdGV4dHVyZVBhdGggKSB7XHJcblxyXG5cdFx0XHRjcmVhdGVfdGV4dHVyZSggbXBhcnMsIFwibWFwXCIsIG0ubWFwRGlmZnVzZSwgbS5tYXBEaWZmdXNlUmVwZWF0LCBtLm1hcERpZmZ1c2VPZmZzZXQsIG0ubWFwRGlmZnVzZVdyYXAsIG0ubWFwRGlmZnVzZUFuaXNvdHJvcHkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtLm1hcExpZ2h0ICYmIHRleHR1cmVQYXRoICkge1xyXG5cclxuXHRcdFx0Y3JlYXRlX3RleHR1cmUoIG1wYXJzLCBcImxpZ2h0TWFwXCIsIG0ubWFwTGlnaHQsIG0ubWFwTGlnaHRSZXBlYXQsIG0ubWFwTGlnaHRPZmZzZXQsIG0ubWFwTGlnaHRXcmFwLCBtLm1hcExpZ2h0QW5pc290cm9weSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG0ubWFwQnVtcCAmJiB0ZXh0dXJlUGF0aCApIHtcclxuXHJcblx0XHRcdGNyZWF0ZV90ZXh0dXJlKCBtcGFycywgXCJidW1wTWFwXCIsIG0ubWFwQnVtcCwgbS5tYXBCdW1wUmVwZWF0LCBtLm1hcEJ1bXBPZmZzZXQsIG0ubWFwQnVtcFdyYXAsIG0ubWFwQnVtcEFuaXNvdHJvcHkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtLm1hcE5vcm1hbCAmJiB0ZXh0dXJlUGF0aCApIHtcclxuXHJcblx0XHRcdGNyZWF0ZV90ZXh0dXJlKCBtcGFycywgXCJub3JtYWxNYXBcIiwgbS5tYXBOb3JtYWwsIG0ubWFwTm9ybWFsUmVwZWF0LCBtLm1hcE5vcm1hbE9mZnNldCwgbS5tYXBOb3JtYWxXcmFwLCBtLm1hcE5vcm1hbEFuaXNvdHJvcHkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtLm1hcFNwZWN1bGFyICYmIHRleHR1cmVQYXRoICkge1xyXG5cclxuXHRcdFx0Y3JlYXRlX3RleHR1cmUoIG1wYXJzLCBcInNwZWN1bGFyTWFwXCIsIG0ubWFwU3BlY3VsYXIsIG0ubWFwU3BlY3VsYXJSZXBlYXQsIG0ubWFwU3BlY3VsYXJPZmZzZXQsIG0ubWFwU3BlY3VsYXJXcmFwLCBtLm1hcFNwZWN1bGFyQW5pc290cm9weSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGlmICggbS5tYXBCdW1wU2NhbGUgKSB7XHJcblxyXG5cdFx0XHRtcGFycy5idW1wU2NhbGUgPSBtLm1hcEJ1bXBTY2FsZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc3BlY2lhbCBjYXNlIGZvciBub3JtYWwgbWFwcGVkIG1hdGVyaWFsXHJcblxyXG5cdFx0aWYgKCBtLm1hcE5vcm1hbCApIHtcclxuXHJcblx0XHRcdHZhciBzaGFkZXIgPSBUSFJFRS5TaGFkZXJMaWJbIFwibm9ybWFsbWFwXCIgXTtcclxuXHRcdFx0dmFyIHVuaWZvcm1zID0gVEhSRUUuVW5pZm9ybXNVdGlscy5jbG9uZSggc2hhZGVyLnVuaWZvcm1zICk7XHJcblxyXG5cdFx0XHR1bmlmb3Jtc1sgXCJ0Tm9ybWFsXCIgXS52YWx1ZSA9IG1wYXJzLm5vcm1hbE1hcDtcclxuXHJcblx0XHRcdGlmICggbS5tYXBOb3JtYWxGYWN0b3IgKSB7XHJcblxyXG5cdFx0XHRcdHVuaWZvcm1zWyBcInVOb3JtYWxTY2FsZVwiIF0udmFsdWUuc2V0KCBtLm1hcE5vcm1hbEZhY3RvciwgbS5tYXBOb3JtYWxGYWN0b3IgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggbXBhcnMubWFwICkge1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtc1sgXCJ0RGlmZnVzZVwiIF0udmFsdWUgPSBtcGFycy5tYXA7XHJcblx0XHRcdFx0dW5pZm9ybXNbIFwiZW5hYmxlRGlmZnVzZVwiIF0udmFsdWUgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBtcGFycy5zcGVjdWxhck1hcCApIHtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXNbIFwidFNwZWN1bGFyXCIgXS52YWx1ZSA9IG1wYXJzLnNwZWN1bGFyTWFwO1xyXG5cdFx0XHRcdHVuaWZvcm1zWyBcImVuYWJsZVNwZWN1bGFyXCIgXS52YWx1ZSA9IHRydWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG1wYXJzLmxpZ2h0TWFwICkge1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtc1sgXCJ0QU9cIiBdLnZhbHVlID0gbXBhcnMubGlnaHRNYXA7XHJcblx0XHRcdFx0dW5pZm9ybXNbIFwiZW5hYmxlQU9cIiBdLnZhbHVlID0gdHJ1ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGZvciB0aGUgbW9tZW50IGRvbid0IGhhbmRsZSBkaXNwbGFjZW1lbnQgdGV4dHVyZVxyXG5cclxuXHRcdFx0dW5pZm9ybXNbIFwidURpZmZ1c2VDb2xvclwiIF0udmFsdWUuc2V0SGV4KCBtcGFycy5jb2xvciApO1xyXG5cdFx0XHR1bmlmb3Jtc1sgXCJ1U3BlY3VsYXJDb2xvclwiIF0udmFsdWUuc2V0SGV4KCBtcGFycy5zcGVjdWxhciApO1xyXG5cdFx0XHR1bmlmb3Jtc1sgXCJ1QW1iaWVudENvbG9yXCIgXS52YWx1ZS5zZXRIZXgoIG1wYXJzLmFtYmllbnQgKTtcclxuXHJcblx0XHRcdHVuaWZvcm1zWyBcInVTaGluaW5lc3NcIiBdLnZhbHVlID0gbXBhcnMuc2hpbmluZXNzO1xyXG5cclxuXHRcdFx0aWYgKCBtcGFycy5vcGFjaXR5ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHVuaWZvcm1zWyBcInVPcGFjaXR5XCIgXS52YWx1ZSA9IG1wYXJzLm9wYWNpdHk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgcGFyYW1ldGVycyA9IHsgZnJhZ21lbnRTaGFkZXI6IHNoYWRlci5mcmFnbWVudFNoYWRlciwgdmVydGV4U2hhZGVyOiBzaGFkZXIudmVydGV4U2hhZGVyLCB1bmlmb3JtczogdW5pZm9ybXMsIGxpZ2h0czogdHJ1ZSwgZm9nOiB0cnVlIH07XHJcblx0XHRcdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCggcGFyYW1ldGVycyApO1xyXG5cclxuXHRcdFx0aWYgKCBtcGFycy50cmFuc3BhcmVudCApIHtcclxuXHJcblx0XHRcdFx0bWF0ZXJpYWwudHJhbnNwYXJlbnQgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUVbIG10eXBlIF0oIG1wYXJzICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbS5EYmdOYW1lICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5uYW1lID0gbS5EYmdOYW1lO1xyXG5cclxuXHRcdHJldHVybiBtYXRlcmlhbDtcclxuXHJcblx0fVxyXG5cclxufTtcclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuSW1hZ2VMb2FkZXIgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFRIUkVFLkV2ZW50RGlzcGF0Y2hlci5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMuY3Jvc3NPcmlnaW4gPSBudWxsO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkltYWdlTG9hZGVyLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkltYWdlTG9hZGVyLFxyXG5cclxuXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgaW1hZ2UgKSB7XHJcblxyXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcclxuXHJcblx0XHRpZiAoIGltYWdlID09PSB1bmRlZmluZWQgKSBpbWFnZSA9IG5ldyBJbWFnZSgpO1xyXG5cclxuXHRcdGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoICdsb2FkJywgZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnbG9hZCcsIGNvbnRlbnQ6IGltYWdlIH0gKTtcclxuXHJcblx0XHR9LCBmYWxzZSApO1xyXG5cclxuXHRcdGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoICdlcnJvcicsIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Vycm9yJywgbWVzc2FnZTogJ0NvdWxkblxcJ3QgbG9hZCBVUkwgWycgKyB1cmwgKyAnXScgfSApO1xyXG5cclxuXHRcdH0sIGZhbHNlICk7XHJcblxyXG5cdFx0aWYgKCBzY29wZS5jcm9zc09yaWdpbiApIGltYWdlLmNyb3NzT3JpZ2luID0gc2NvcGUuY3Jvc3NPcmlnaW47XHJcblxyXG5cdFx0aW1hZ2Uuc3JjID0gdXJsO1xyXG5cclxuXHR9XHJcblxyXG59XHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkpTT05Mb2FkZXIgPSBmdW5jdGlvbiAoIHNob3dTdGF0dXMgKSB7XHJcblxyXG5cdFRIUkVFLkxvYWRlci5jYWxsKCB0aGlzLCBzaG93U3RhdHVzICk7XHJcblxyXG5cdHRoaXMud2l0aENyZWRlbnRpYWxzID0gZmFsc2U7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuSlNPTkxvYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5Mb2FkZXIucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5KU09OTG9hZGVyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCB1cmwsIGNhbGxiYWNrLCB0ZXh0dXJlUGF0aCApIHtcclxuXHJcblx0dmFyIHNjb3BlID0gdGhpcztcclxuXHJcblx0Ly8gdG9kbzogdW5pZnkgbG9hZCBBUEkgdG8gZm9yIGVhc2llciBTY2VuZUxvYWRlciB1c2VcclxuXHJcblx0dGV4dHVyZVBhdGggPSB0ZXh0dXJlUGF0aCAmJiAoIHR5cGVvZiB0ZXh0dXJlUGF0aCA9PT0gXCJzdHJpbmdcIiApID8gdGV4dHVyZVBhdGggOiB0aGlzLmV4dHJhY3RVcmxCYXNlKCB1cmwgKTtcclxuXHJcblx0dGhpcy5vbkxvYWRTdGFydCgpO1xyXG5cdHRoaXMubG9hZEFqYXhKU09OKCB0aGlzLCB1cmwsIGNhbGxiYWNrLCB0ZXh0dXJlUGF0aCApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkpTT05Mb2FkZXIucHJvdG90eXBlLmxvYWRBamF4SlNPTiA9IGZ1bmN0aW9uICggY29udGV4dCwgdXJsLCBjYWxsYmFjaywgdGV4dHVyZVBhdGgsIGNhbGxiYWNrUHJvZ3Jlc3MgKSB7XHJcblxyXG5cdHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuXHJcblx0dmFyIGxlbmd0aCA9IDA7XHJcblxyXG5cdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0geGhyLkRPTkUgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHhoci5zdGF0dXMgPT09IDIwMCB8fCB4aHIuc3RhdHVzID09PSAwICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHhoci5yZXNwb25zZVRleHQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGpzb24gPSBKU09OLnBhcnNlKCB4aHIucmVzcG9uc2VUZXh0ICk7XHJcblx0XHRcdFx0XHRjb250ZXh0LmNyZWF0ZU1vZGVsKCBqc29uLCBjYWxsYmFjaywgdGV4dHVyZVBhdGggKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oIFwiVEhSRUUuSlNPTkxvYWRlcjogW1wiICsgdXJsICsgXCJdIHNlZW1zIHRvIGJlIHVucmVhY2hhYmxlIG9yIGZpbGUgdGhlcmUgaXMgZW1wdHlcIiApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIGluIGNvbnRleHQgb2YgbW9yZSBjb21wbGV4IGFzc2V0IGluaXRpYWxpemF0aW9uXHJcblx0XHRcdFx0Ly8gZG8gbm90IGJsb2NrIG9uIHNpbmdsZSBmYWlsZWQgZmlsZVxyXG5cdFx0XHRcdC8vIG1heWJlIHNob3VsZCBnbyBldmVuIG9uZSBtb3JlIGxldmVsIHVwXHJcblxyXG5cdFx0XHRcdGNvbnRleHQub25Mb2FkQ29tcGxldGUoKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoIFwiVEhSRUUuSlNPTkxvYWRlcjogQ291bGRuJ3QgbG9hZCBbXCIgKyB1cmwgKyBcIl0gW1wiICsgeGhyLnN0YXR1cyArIFwiXVwiICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggeGhyLnJlYWR5U3RhdGUgPT09IHhoci5MT0FESU5HICkge1xyXG5cclxuXHRcdFx0aWYgKCBjYWxsYmFja1Byb2dyZXNzICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGxlbmd0aCA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0XHRsZW5ndGggPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiQ29udGVudC1MZW5ndGhcIiApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGNhbGxiYWNrUHJvZ3Jlc3MoIHsgdG90YWw6IGxlbmd0aCwgbG9hZGVkOiB4aHIucmVzcG9uc2VUZXh0Lmxlbmd0aCB9ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggeGhyLnJlYWR5U3RhdGUgPT09IHhoci5IRUFERVJTX1JFQ0VJVkVEICkge1xyXG5cclxuXHRcdFx0bGVuZ3RoID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCBcIkNvbnRlbnQtTGVuZ3RoXCIgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHhoci5vcGVuKCBcIkdFVFwiLCB1cmwsIHRydWUgKTtcclxuXHR4aHIud2l0aENyZWRlbnRpYWxzID0gdGhpcy53aXRoQ3JlZGVudGlhbHM7XHJcblx0eGhyLnNlbmQoIG51bGwgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5KU09OTG9hZGVyLnByb3RvdHlwZS5jcmVhdGVNb2RlbCA9IGZ1bmN0aW9uICgganNvbiwgY2FsbGJhY2ssIHRleHR1cmVQYXRoICkge1xyXG5cclxuXHR2YXIgc2NvcGUgPSB0aGlzLFxyXG5cdGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCksXHJcblx0c2NhbGUgPSAoIGpzb24uc2NhbGUgIT09IHVuZGVmaW5lZCApID8gMS4wIC8ganNvbi5zY2FsZSA6IDEuMDtcclxuXHJcblx0cGFyc2VNb2RlbCggc2NhbGUgKTtcclxuXHJcblx0cGFyc2VTa2luKCk7XHJcblx0cGFyc2VNb3JwaGluZyggc2NhbGUgKTtcclxuXHJcblx0Z2VvbWV0cnkuY29tcHV0ZUNlbnRyb2lkcygpO1xyXG5cdGdlb21ldHJ5LmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG5cclxuXHRmdW5jdGlvbiBwYXJzZU1vZGVsKCBzY2FsZSApIHtcclxuXHJcblx0XHRmdW5jdGlvbiBpc0JpdFNldCggdmFsdWUsIHBvc2l0aW9uICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHZhbHVlICYgKCAxIDw8IHBvc2l0aW9uICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBpLCBqLCBmaSxcclxuXHJcblx0XHRvZmZzZXQsIHpMZW5ndGgsIG5WZXJ0aWNlcyxcclxuXHJcblx0XHRjb2xvckluZGV4LCBub3JtYWxJbmRleCwgdXZJbmRleCwgbWF0ZXJpYWxJbmRleCxcclxuXHJcblx0XHR0eXBlLFxyXG5cdFx0aXNRdWFkLFxyXG5cdFx0aGFzTWF0ZXJpYWwsXHJcblx0XHRoYXNGYWNlVXYsIGhhc0ZhY2VWZXJ0ZXhVdixcclxuXHRcdGhhc0ZhY2VOb3JtYWwsIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwsXHJcblx0XHRoYXNGYWNlQ29sb3IsIGhhc0ZhY2VWZXJ0ZXhDb2xvcixcclxuXHJcblx0XHR2ZXJ0ZXgsIGZhY2UsIGNvbG9yLCBub3JtYWwsXHJcblxyXG5cdFx0dXZMYXllciwgdXZzLCB1LCB2LFxyXG5cclxuXHRcdGZhY2VzID0ganNvbi5mYWNlcyxcclxuXHRcdHZlcnRpY2VzID0ganNvbi52ZXJ0aWNlcyxcclxuXHRcdG5vcm1hbHMgPSBqc29uLm5vcm1hbHMsXHJcblx0XHRjb2xvcnMgPSBqc29uLmNvbG9ycyxcclxuXHJcblx0XHRuVXZMYXllcnMgPSAwO1xyXG5cclxuXHRcdC8vIGRpc3JlZ2FyZCBlbXB0eSBhcnJheXNcclxuXHJcblx0XHRmb3IgKCBpID0gMDsgaSA8IGpzb24udXZzLmxlbmd0aDsgaSsrICkge1xyXG5cclxuXHRcdFx0aWYgKCBqc29uLnV2c1sgaSBdLmxlbmd0aCApIG5VdkxheWVycyArKztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBuVXZMYXllcnM7IGkrKyApIHtcclxuXHJcblx0XHRcdGdlb21ldHJ5LmZhY2VVdnNbIGkgXSA9IFtdO1xyXG5cdFx0XHRnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF0gPSBbXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0b2Zmc2V0ID0gMDtcclxuXHRcdHpMZW5ndGggPSB2ZXJ0aWNlcy5sZW5ndGg7XHJcblxyXG5cdFx0d2hpbGUgKCBvZmZzZXQgPCB6TGVuZ3RoICkge1xyXG5cclxuXHRcdFx0dmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRcdHZlcnRleC54ID0gdmVydGljZXNbIG9mZnNldCArKyBdICogc2NhbGU7XHJcblx0XHRcdHZlcnRleC55ID0gdmVydGljZXNbIG9mZnNldCArKyBdICogc2NhbGU7XHJcblx0XHRcdHZlcnRleC56ID0gdmVydGljZXNbIG9mZnNldCArKyBdICogc2NhbGU7XHJcblxyXG5cdFx0XHRnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0b2Zmc2V0ID0gMDtcclxuXHRcdHpMZW5ndGggPSBmYWNlcy5sZW5ndGg7XHJcblxyXG5cdFx0d2hpbGUgKCBvZmZzZXQgPCB6TGVuZ3RoICkge1xyXG5cclxuXHRcdFx0dHlwZSA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHJcblxyXG5cdFx0XHRpc1F1YWQgICAgICAgICAgXHQ9IGlzQml0U2V0KCB0eXBlLCAwICk7XHJcblx0XHRcdGhhc01hdGVyaWFsICAgICAgICAgPSBpc0JpdFNldCggdHlwZSwgMSApO1xyXG5cdFx0XHRoYXNGYWNlVXYgICAgICAgICAgID0gaXNCaXRTZXQoIHR5cGUsIDIgKTtcclxuXHRcdFx0aGFzRmFjZVZlcnRleFV2ICAgICA9IGlzQml0U2V0KCB0eXBlLCAzICk7XHJcblx0XHRcdGhhc0ZhY2VOb3JtYWwgICAgICAgPSBpc0JpdFNldCggdHlwZSwgNCApO1xyXG5cdFx0XHRoYXNGYWNlVmVydGV4Tm9ybWFsID0gaXNCaXRTZXQoIHR5cGUsIDUgKTtcclxuXHRcdFx0aGFzRmFjZUNvbG9yXHQgICAgPSBpc0JpdFNldCggdHlwZSwgNiApO1xyXG5cdFx0XHRoYXNGYWNlVmVydGV4Q29sb3IgID0gaXNCaXRTZXQoIHR5cGUsIDcgKTtcclxuXHJcblx0XHRcdC8vY29uc29sZS5sb2coXCJ0eXBlXCIsIHR5cGUsIFwiYml0c1wiLCBpc1F1YWQsIGhhc01hdGVyaWFsLCBoYXNGYWNlVXYsIGhhc0ZhY2VWZXJ0ZXhVdiwgaGFzRmFjZU5vcm1hbCwgaGFzRmFjZVZlcnRleE5vcm1hbCwgaGFzRmFjZUNvbG9yLCBoYXNGYWNlVmVydGV4Q29sb3IpO1xyXG5cclxuXHRcdFx0aWYgKCBpc1F1YWQgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2UgPSBuZXcgVEhSRUUuRmFjZTQoKTtcclxuXHJcblx0XHRcdFx0ZmFjZS5hID0gZmFjZXNbIG9mZnNldCArKyBdO1xyXG5cdFx0XHRcdGZhY2UuYiA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHRcdFx0XHRmYWNlLmMgPSBmYWNlc1sgb2Zmc2V0ICsrIF07XHJcblx0XHRcdFx0ZmFjZS5kID0gZmFjZXNbIG9mZnNldCArKyBdO1xyXG5cclxuXHRcdFx0XHRuVmVydGljZXMgPSA0O1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0ZmFjZSA9IG5ldyBUSFJFRS5GYWNlMygpO1xyXG5cclxuXHRcdFx0XHRmYWNlLmEgPSBmYWNlc1sgb2Zmc2V0ICsrIF07XHJcblx0XHRcdFx0ZmFjZS5iID0gZmFjZXNbIG9mZnNldCArKyBdO1xyXG5cdFx0XHRcdGZhY2UuYyA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHJcblx0XHRcdFx0blZlcnRpY2VzID0gMztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggaGFzTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdG1hdGVyaWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XHJcblx0XHRcdFx0ZmFjZS5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHRvIGdldCBmYWNlIDw9PiB1diBpbmRleCBjb3JyZXNwb25kZW5jZVxyXG5cclxuXHRcdFx0ZmkgPSBnZW9tZXRyeS5mYWNlcy5sZW5ndGg7XHJcblxyXG5cdFx0XHRpZiAoIGhhc0ZhY2VVdiApIHtcclxuXHJcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBuVXZMYXllcnM7IGkrKyApIHtcclxuXHJcblx0XHRcdFx0XHR1dkxheWVyID0ganNvbi51dnNbIGkgXTtcclxuXHJcblx0XHRcdFx0XHR1dkluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xyXG5cclxuXHRcdFx0XHRcdHUgPSB1dkxheWVyWyB1dkluZGV4ICogMiBdO1xyXG5cdFx0XHRcdFx0diA9IHV2TGF5ZXJbIHV2SW5kZXggKiAyICsgMSBdO1xyXG5cclxuXHRcdFx0XHRcdGdlb21ldHJ5LmZhY2VVdnNbIGkgXVsgZmkgXSA9IG5ldyBUSFJFRS5WZWN0b3IyKCB1LCB2ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggaGFzRmFjZVZlcnRleFV2ICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IG5VdkxheWVyczsgaSsrICkge1xyXG5cclxuXHRcdFx0XHRcdHV2TGF5ZXIgPSBqc29uLnV2c1sgaSBdO1xyXG5cclxuXHRcdFx0XHRcdHV2cyA9IFtdO1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIGogPSAwOyBqIDwgblZlcnRpY2VzOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dXZJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHJcblx0XHRcdFx0XHRcdHUgPSB1dkxheWVyWyB1dkluZGV4ICogMiBdO1xyXG5cdFx0XHRcdFx0XHR2ID0gdXZMYXllclsgdXZJbmRleCAqIDIgKyAxIF07XHJcblxyXG5cdFx0XHRcdFx0XHR1dnNbIGogXSA9IG5ldyBUSFJFRS5WZWN0b3IyKCB1LCB2ICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgXSA9IHV2cztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBoYXNGYWNlTm9ybWFsICkge1xyXG5cclxuXHRcdFx0XHRub3JtYWxJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXSAqIDM7XHJcblxyXG5cdFx0XHRcdG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0XHRcdG5vcm1hbC54ID0gbm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXTtcclxuXHRcdFx0XHRub3JtYWwueSA9IG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF07XHJcblx0XHRcdFx0bm9ybWFsLnogPSBub3JtYWxzWyBub3JtYWxJbmRleCBdO1xyXG5cclxuXHRcdFx0XHRmYWNlLm5vcm1hbCA9IG5vcm1hbDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggaGFzRmFjZVZlcnRleE5vcm1hbCApIHtcclxuXHJcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBuVmVydGljZXM7IGkrKyApIHtcclxuXHJcblx0XHRcdFx0XHRub3JtYWxJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXSAqIDM7XHJcblxyXG5cdFx0XHRcdFx0bm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRcdFx0XHRub3JtYWwueCA9IG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF07XHJcblx0XHRcdFx0XHRub3JtYWwueSA9IG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF07XHJcblx0XHRcdFx0XHRub3JtYWwueiA9IG5vcm1hbHNbIG5vcm1hbEluZGV4IF07XHJcblxyXG5cdFx0XHRcdFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cclxuXHRcdFx0aWYgKCBoYXNGYWNlQ29sb3IgKSB7XHJcblxyXG5cdFx0XHRcdGNvbG9ySW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XHJcblxyXG5cdFx0XHRcdGNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCBjb2xvcnNbIGNvbG9ySW5kZXggXSApO1xyXG5cdFx0XHRcdGZhY2UuY29sb3IgPSBjb2xvcjtcclxuXHJcblx0XHRcdH1cclxuXHJcblxyXG5cdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhDb2xvciApIHtcclxuXHJcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBuVmVydGljZXM7IGkrKyApIHtcclxuXHJcblx0XHRcdFx0XHRjb2xvckluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xyXG5cclxuXHRcdFx0XHRcdGNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCBjb2xvcnNbIGNvbG9ySW5kZXggXSApO1xyXG5cdFx0XHRcdFx0ZmFjZS52ZXJ0ZXhDb2xvcnMucHVzaCggY29sb3IgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Z2VvbWV0cnkuZmFjZXMucHVzaCggZmFjZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gcGFyc2VTa2luKCkge1xyXG5cclxuXHRcdHZhciBpLCBsLCB4LCB5LCB6LCB3LCBhLCBiLCBjLCBkO1xyXG5cclxuXHRcdGlmICgganNvbi5za2luV2VpZ2h0cyApIHtcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwLCBsID0ganNvbi5za2luV2VpZ2h0cy5sZW5ndGg7IGkgPCBsOyBpICs9IDIgKSB7XHJcblxyXG5cdFx0XHRcdHggPSBqc29uLnNraW5XZWlnaHRzWyBpICAgICBdO1xyXG5cdFx0XHRcdHkgPSBqc29uLnNraW5XZWlnaHRzWyBpICsgMSBdO1xyXG5cdFx0XHRcdHogPSAwO1xyXG5cdFx0XHRcdHcgPSAwO1xyXG5cclxuXHRcdFx0XHRnZW9tZXRyeS5za2luV2VpZ2h0cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yNCggeCwgeSwgeiwgdyApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICgganNvbi5za2luSW5kaWNlcyApIHtcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwLCBsID0ganNvbi5za2luSW5kaWNlcy5sZW5ndGg7IGkgPCBsOyBpICs9IDIgKSB7XHJcblxyXG5cdFx0XHRcdGEgPSBqc29uLnNraW5JbmRpY2VzWyBpICAgICBdO1xyXG5cdFx0XHRcdGIgPSBqc29uLnNraW5JbmRpY2VzWyBpICsgMSBdO1xyXG5cdFx0XHRcdGMgPSAwO1xyXG5cdFx0XHRcdGQgPSAwO1xyXG5cclxuXHRcdFx0XHRnZW9tZXRyeS5za2luSW5kaWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yNCggYSwgYiwgYywgZCApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGdlb21ldHJ5LmJvbmVzID0ganNvbi5ib25lcztcclxuXHRcdGdlb21ldHJ5LmFuaW1hdGlvbiA9IGpzb24uYW5pbWF0aW9uO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBwYXJzZU1vcnBoaW5nKCBzY2FsZSApIHtcclxuXHJcblx0XHRpZiAoIGpzb24ubW9ycGhUYXJnZXRzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR2YXIgaSwgbCwgdiwgdmwsIGRzdFZlcnRpY2VzLCBzcmNWZXJ0aWNlcztcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwLCBsID0ganNvbi5tb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Z2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF0gPSB7fTtcclxuXHRcdFx0XHRnZW9tZXRyeS5tb3JwaFRhcmdldHNbIGkgXS5uYW1lID0ganNvbi5tb3JwaFRhcmdldHNbIGkgXS5uYW1lO1xyXG5cdFx0XHRcdGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdLnZlcnRpY2VzID0gW107XHJcblxyXG5cdFx0XHRcdGRzdFZlcnRpY2VzID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF0udmVydGljZXM7XHJcblx0XHRcdFx0c3JjVmVydGljZXMgPSBqc29uLm1vcnBoVGFyZ2V0cyBbIGkgXS52ZXJ0aWNlcztcclxuXHJcblx0XHRcdFx0Zm9yKCB2ID0gMCwgdmwgPSBzcmNWZXJ0aWNlcy5sZW5ndGg7IHYgPCB2bDsgdiArPSAzICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciB2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0XHRcdFx0dmVydGV4LnggPSBzcmNWZXJ0aWNlc1sgdiBdICogc2NhbGU7XHJcblx0XHRcdFx0XHR2ZXJ0ZXgueSA9IHNyY1ZlcnRpY2VzWyB2ICsgMSBdICogc2NhbGU7XHJcblx0XHRcdFx0XHR2ZXJ0ZXgueiA9IHNyY1ZlcnRpY2VzWyB2ICsgMiBdICogc2NhbGU7XHJcblxyXG5cdFx0XHRcdFx0ZHN0VmVydGljZXMucHVzaCggdmVydGV4ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBqc29uLm1vcnBoQ29sb3JzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR2YXIgaSwgbCwgYywgY2wsIGRzdENvbG9ycywgc3JjQ29sb3JzLCBjb2xvcjtcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwLCBsID0ganNvbi5tb3JwaENvbG9ycy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5Lm1vcnBoQ29sb3JzWyBpIF0gPSB7fTtcclxuXHRcdFx0XHRnZW9tZXRyeS5tb3JwaENvbG9yc1sgaSBdLm5hbWUgPSBqc29uLm1vcnBoQ29sb3JzWyBpIF0ubmFtZTtcclxuXHRcdFx0XHRnZW9tZXRyeS5tb3JwaENvbG9yc1sgaSBdLmNvbG9ycyA9IFtdO1xyXG5cclxuXHRcdFx0XHRkc3RDb2xvcnMgPSBnZW9tZXRyeS5tb3JwaENvbG9yc1sgaSBdLmNvbG9ycztcclxuXHRcdFx0XHRzcmNDb2xvcnMgPSBqc29uLm1vcnBoQ29sb3JzIFsgaSBdLmNvbG9ycztcclxuXHJcblx0XHRcdFx0Zm9yICggYyA9IDAsIGNsID0gc3JjQ29sb3JzLmxlbmd0aDsgYyA8IGNsOyBjICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZhYTAwICk7XHJcblx0XHRcdFx0XHRjb2xvci5zZXRSR0IoIHNyY0NvbG9yc1sgYyBdLCBzcmNDb2xvcnNbIGMgKyAxIF0sIHNyY0NvbG9yc1sgYyArIDIgXSApO1xyXG5cdFx0XHRcdFx0ZHN0Q29sb3JzLnB1c2goIGNvbG9yICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHZhciBtYXRlcmlhbHMgPSB0aGlzLmluaXRNYXRlcmlhbHMoIGpzb24ubWF0ZXJpYWxzLCB0ZXh0dXJlUGF0aCApO1xyXG5cclxuXHRpZiAoIHRoaXMubmVlZHNUYW5nZW50cyggbWF0ZXJpYWxzICkgKSBnZW9tZXRyeS5jb21wdXRlVGFuZ2VudHMoKTtcclxuXHJcblx0Y2FsbGJhY2soIGdlb21ldHJ5LCBtYXRlcmlhbHMgKTtcclxuXHJcbn07XHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkxvYWRpbmdNb25pdG9yID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRUSFJFRS5FdmVudERpc3BhdGNoZXIuY2FsbCggdGhpcyApO1xyXG5cclxuXHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHR2YXIgbG9hZGVkID0gMDtcclxuXHR2YXIgdG90YWwgPSAwO1xyXG5cclxuXHR2YXIgb25Mb2FkID0gZnVuY3Rpb24gKCBldmVudCApIHtcclxuXHJcblx0XHRsb2FkZWQgKys7XHJcblxyXG5cdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAncHJvZ3Jlc3MnLCBsb2FkZWQ6IGxvYWRlZCwgdG90YWw6IHRvdGFsIH0gKTtcclxuXHJcblx0XHRpZiAoIGxvYWRlZCA9PT0gdG90YWwgKSB7XHJcblxyXG5cdFx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdsb2FkJyB9ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLmFkZCA9IGZ1bmN0aW9uICggbG9hZGVyICkge1xyXG5cclxuXHRcdHRvdGFsICsrO1xyXG5cclxuXHRcdGxvYWRlci5hZGRFdmVudExpc3RlbmVyKCAnbG9hZCcsIG9uTG9hZCwgZmFsc2UgKTtcclxuXHJcblx0fTtcclxuXHJcbn07XHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlNjZW5lTG9hZGVyID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR0aGlzLm9uTG9hZFN0YXJ0ID0gZnVuY3Rpb24gKCkge307XHJcblx0dGhpcy5vbkxvYWRQcm9ncmVzcyA9IGZ1bmN0aW9uKCkge307XHJcblx0dGhpcy5vbkxvYWRDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cclxuXHR0aGlzLmNhbGxiYWNrU3luYyA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cdHRoaXMuY2FsbGJhY2tQcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cclxuXHR0aGlzLmdlb21ldHJ5SGFuZGxlck1hcCA9IHt9O1xyXG5cdHRoaXMuaGllcmFyY2h5SGFuZGxlck1hcCA9IHt9O1xyXG5cclxuXHR0aGlzLmFkZEdlb21ldHJ5SGFuZGxlciggXCJhc2NpaVwiLCBUSFJFRS5KU09OTG9hZGVyICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU2NlbmVMb2FkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU2NlbmVMb2FkZXI7XHJcblxyXG5USFJFRS5TY2VuZUxvYWRlci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICggdXJsLCBjYWxsYmFja0ZpbmlzaGVkICkge1xyXG5cclxuXHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHR2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcblxyXG5cdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApIHtcclxuXHJcblx0XHRcdGlmICggeGhyLnN0YXR1cyA9PT0gMjAwIHx8IHhoci5zdGF0dXMgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBqc29uID0gSlNPTi5wYXJzZSggeGhyLnJlc3BvbnNlVGV4dCApO1xyXG5cdFx0XHRcdHNjb3BlLnBhcnNlKCBqc29uLCBjYWxsYmFja0ZpbmlzaGVkLCB1cmwgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoIFwiVEhSRUUuU2NlbmVMb2FkZXI6IENvdWxkbid0IGxvYWQgW1wiICsgdXJsICsgXCJdIFtcIiArIHhoci5zdGF0dXMgKyBcIl1cIiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0eGhyLm9wZW4oIFwiR0VUXCIsIHVybCwgdHJ1ZSApO1xyXG5cdHhoci5zZW5kKCBudWxsICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU2NlbmVMb2FkZXIucHJvdG90eXBlLmFkZEdlb21ldHJ5SGFuZGxlciA9IGZ1bmN0aW9uICggdHlwZUlELCBsb2FkZXJDbGFzcyApIHtcclxuXHJcblx0dGhpcy5nZW9tZXRyeUhhbmRsZXJNYXBbIHR5cGVJRCBdID0geyBcImxvYWRlckNsYXNzXCI6IGxvYWRlckNsYXNzIH07XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU2NlbmVMb2FkZXIucHJvdG90eXBlLmFkZEhpZXJhcmNoeUhhbmRsZXIgPSBmdW5jdGlvbiAoIHR5cGVJRCwgbG9hZGVyQ2xhc3MgKSB7XHJcblxyXG5cdHRoaXMuaGllcmFyY2h5SGFuZGxlck1hcFsgdHlwZUlEIF0gPSB7IFwibG9hZGVyQ2xhc3NcIjogbG9hZGVyQ2xhc3MgfTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5TY2VuZUxvYWRlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoIGpzb24sIGNhbGxiYWNrRmluaXNoZWQsIHVybCApIHtcclxuXHJcblx0dmFyIHNjb3BlID0gdGhpcztcclxuXHJcblx0dmFyIHVybEJhc2UgPSBUSFJFRS5Mb2FkZXIucHJvdG90eXBlLmV4dHJhY3RVcmxCYXNlKCB1cmwgKTtcclxuXHJcblx0dmFyIGdlb21ldHJ5LCBtYXRlcmlhbCwgY2FtZXJhLCBmb2csXHJcblx0XHR0ZXh0dXJlLCBpbWFnZXMsIGNvbG9yLFxyXG5cdFx0bGlnaHQsIGhleCwgaW50ZW5zaXR5LFxyXG5cdFx0Y291bnRlcl9tb2RlbHMsIGNvdW50ZXJfdGV4dHVyZXMsXHJcblx0XHR0b3RhbF9tb2RlbHMsIHRvdGFsX3RleHR1cmVzLFxyXG5cdFx0cmVzdWx0O1xyXG5cclxuXHR2YXIgdGFyZ2V0X2FycmF5ID0gW107XHJcblxyXG5cdHZhciBkYXRhID0ganNvbjtcclxuXHJcblx0Ly8gYXN5bmMgZ2VvbWV0cnkgbG9hZGVyc1xyXG5cclxuXHRmb3IgKCB2YXIgdHlwZUlEIGluIHRoaXMuZ2VvbWV0cnlIYW5kbGVyTWFwICkge1xyXG5cclxuXHRcdHZhciBsb2FkZXJDbGFzcyA9IHRoaXMuZ2VvbWV0cnlIYW5kbGVyTWFwWyB0eXBlSUQgXVsgXCJsb2FkZXJDbGFzc1wiIF07XHJcblx0XHR0aGlzLmdlb21ldHJ5SGFuZGxlck1hcFsgdHlwZUlEIF1bIFwibG9hZGVyT2JqZWN0XCIgXSA9IG5ldyBsb2FkZXJDbGFzcygpO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIGFzeW5jIGhpZXJhY2h5IGxvYWRlcnNcclxuXHJcblx0Zm9yICggdmFyIHR5cGVJRCBpbiB0aGlzLmhpZXJhcmNoeUhhbmRsZXJNYXAgKSB7XHJcblxyXG5cdFx0dmFyIGxvYWRlckNsYXNzID0gdGhpcy5oaWVyYXJjaHlIYW5kbGVyTWFwWyB0eXBlSUQgXVsgXCJsb2FkZXJDbGFzc1wiIF07XHJcblx0XHR0aGlzLmhpZXJhcmNoeUhhbmRsZXJNYXBbIHR5cGVJRCBdWyBcImxvYWRlck9iamVjdFwiIF0gPSBuZXcgbG9hZGVyQ2xhc3MoKTtcclxuXHJcblx0fVxyXG5cclxuXHRjb3VudGVyX21vZGVscyA9IDA7XHJcblx0Y291bnRlcl90ZXh0dXJlcyA9IDA7XHJcblxyXG5cdHJlc3VsdCA9IHtcclxuXHJcblx0XHRzY2VuZTogbmV3IFRIUkVFLlNjZW5lKCksXHJcblx0XHRnZW9tZXRyaWVzOiB7fSxcclxuXHRcdGZhY2VfbWF0ZXJpYWxzOiB7fSxcclxuXHRcdG1hdGVyaWFsczoge30sXHJcblx0XHR0ZXh0dXJlczoge30sXHJcblx0XHRvYmplY3RzOiB7fSxcclxuXHRcdGNhbWVyYXM6IHt9LFxyXG5cdFx0bGlnaHRzOiB7fSxcclxuXHRcdGZvZ3M6IHt9LFxyXG5cdFx0ZW1wdGllczoge30sXHJcblx0XHRncm91cHM6IHt9XHJcblxyXG5cdH07XHJcblxyXG5cdGlmICggZGF0YS50cmFuc2Zvcm0gKSB7XHJcblxyXG5cdFx0dmFyIHBvc2l0aW9uID0gZGF0YS50cmFuc2Zvcm0ucG9zaXRpb24sXHJcblx0XHRcdHJvdGF0aW9uID0gZGF0YS50cmFuc2Zvcm0ucm90YXRpb24sXHJcblx0XHRcdHNjYWxlID0gZGF0YS50cmFuc2Zvcm0uc2NhbGU7XHJcblxyXG5cdFx0aWYgKCBwb3NpdGlvbiApXHJcblx0XHRcdHJlc3VsdC5zY2VuZS5wb3NpdGlvbi5zZXQoIHBvc2l0aW9uWyAwIF0sIHBvc2l0aW9uWyAxIF0sIHBvc2l0aW9uIFsgMiBdICk7XHJcblxyXG5cdFx0aWYgKCByb3RhdGlvbiApXHJcblx0XHRcdHJlc3VsdC5zY2VuZS5yb3RhdGlvbi5zZXQoIHJvdGF0aW9uWyAwIF0sIHJvdGF0aW9uWyAxIF0sIHJvdGF0aW9uIFsgMiBdICk7XHJcblxyXG5cdFx0aWYgKCBzY2FsZSApXHJcblx0XHRcdHJlc3VsdC5zY2VuZS5zY2FsZS5zZXQoIHNjYWxlWyAwIF0sIHNjYWxlWyAxIF0sIHNjYWxlIFsgMiBdICk7XHJcblxyXG5cdFx0aWYgKCBwb3NpdGlvbiB8fCByb3RhdGlvbiB8fCBzY2FsZSApIHtcclxuXHJcblx0XHRcdHJlc3VsdC5zY2VuZS51cGRhdGVNYXRyaXgoKTtcclxuXHRcdFx0cmVzdWx0LnNjZW5lLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdldF91cmwoIHNvdXJjZV91cmwsIHVybF90eXBlICkge1xyXG5cclxuXHRcdGlmICggdXJsX3R5cGUgPT0gXCJyZWxhdGl2ZVRvSFRNTFwiICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHNvdXJjZV91cmw7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHJldHVybiB1cmxCYXNlICsgXCIvXCIgKyBzb3VyY2VfdXJsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0Ly8gdG9wbGV2ZWwgbG9hZGVyIGZ1bmN0aW9uLCBkZWxlZ2F0ZXMgdG8gaGFuZGxlX2NoaWxkcmVuXHJcblxyXG5cdGZ1bmN0aW9uIGhhbmRsZV9vYmplY3RzKCkge1xyXG5cclxuXHRcdGhhbmRsZV9jaGlsZHJlbiggcmVzdWx0LnNjZW5lLCBkYXRhLm9iamVjdHMgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBoYW5kbGUgYWxsIHRoZSBjaGlsZHJlbiBmcm9tIHRoZSBsb2FkZWQganNvbiBhbmQgYXR0YWNoIHRoZW0gdG8gZ2l2ZW4gcGFyZW50XHJcblxyXG5cdGZ1bmN0aW9uIGhhbmRsZV9jaGlsZHJlbiggcGFyZW50LCBjaGlsZHJlbiApIHtcclxuXHJcblx0XHR2YXIgbWF0LCBkc3QsIHBvcywgcm90LCBzY2wsIHF1YXQ7XHJcblxyXG5cdFx0Zm9yICggdmFyIG9iaklEIGluIGNoaWxkcmVuICkge1xyXG5cclxuXHRcdFx0Ly8gY2hlY2sgYnkgaWQgaWYgY2hpbGQgaGFzIGFscmVhZHkgYmVlbiBoYW5kbGVkLFxyXG5cdFx0XHQvLyBpZiBub3QsIGNyZWF0ZSBuZXcgb2JqZWN0XHJcblxyXG5cdFx0XHRpZiAoIHJlc3VsdC5vYmplY3RzWyBvYmpJRCBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBvYmpKU09OID0gY2hpbGRyZW5bIG9iaklEIF07XHJcblxyXG5cdFx0XHRcdHZhciBvYmplY3QgPSBudWxsO1xyXG5cclxuXHRcdFx0XHQvLyBtZXNoZXNcclxuXHJcblx0XHRcdFx0aWYgKCBvYmpKU09OLnR5cGUgJiYgKCBvYmpKU09OLnR5cGUgaW4gc2NvcGUuaGllcmFyY2h5SGFuZGxlck1hcCApICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggb2JqSlNPTi5sb2FkaW5nID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgcmVzZXJ2ZWRUeXBlcyA9IHsgXCJ0eXBlXCI6IDEsIFwidXJsXCI6IDEsIFwibWF0ZXJpYWxcIjogMSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCAgXCJwb3NpdGlvblwiOiAxLCBcInJvdGF0aW9uXCI6IDEsIFwic2NhbGVcIiA6IDEsXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQgIFwidmlzaWJsZVwiOiAxLCBcImNoaWxkcmVuXCI6IDEsIFwicHJvcGVydGllc1wiOiAxLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ICBcInNraW5cIjogMSwgXCJtb3JwaFwiOiAxLCBcIm1pcnJvcmVkTG9vcFwiOiAxLCBcImR1cmF0aW9uXCI6IDEgfTtcclxuXHJcblx0XHRcdFx0XHRcdHZhciBsb2FkZXJQYXJhbWV0ZXJzID0ge307XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgcGFyVHlwZSBpbiBvYmpKU09OICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoICEgKCBwYXJUeXBlIGluIHJlc2VydmVkVHlwZXMgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRsb2FkZXJQYXJhbWV0ZXJzWyBwYXJUeXBlIF0gPSBvYmpKU09OWyBwYXJUeXBlIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdG1hdGVyaWFsID0gcmVzdWx0Lm1hdGVyaWFsc1sgb2JqSlNPTi5tYXRlcmlhbCBdO1xyXG5cclxuXHRcdFx0XHRcdFx0b2JqSlNPTi5sb2FkaW5nID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0XHRcdHZhciBsb2FkZXIgPSBzY29wZS5oaWVyYXJjaHlIYW5kbGVyTWFwWyBvYmpKU09OLnR5cGUgXVsgXCJsb2FkZXJPYmplY3RcIiBdO1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gQ29sbGFkYUxvYWRlclxyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBsb2FkZXIub3B0aW9ucyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0bG9hZGVyLmxvYWQoIGdldF91cmwoIG9iakpTT04udXJsLCBkYXRhLnVybEJhc2VUeXBlICksIGNyZWF0ZV9jYWxsYmFja19oaWVyYWNoeSggb2JqSUQsIHBhcmVudCwgbWF0ZXJpYWwsIG9iakpTT04gKSApO1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gVVRGOExvYWRlclxyXG5cdFx0XHRcdFx0XHQvLyBPQkpMb2FkZXJcclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGxvYWRlci5sb2FkKCBnZXRfdXJsKCBvYmpKU09OLnVybCwgZGF0YS51cmxCYXNlVHlwZSApLCBjcmVhdGVfY2FsbGJhY2tfaGllcmFjaHkoIG9iaklELCBwYXJlbnQsIG1hdGVyaWFsLCBvYmpKU09OICksIGxvYWRlclBhcmFtZXRlcnMgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG9iakpTT04uZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRnZW9tZXRyeSA9IHJlc3VsdC5nZW9tZXRyaWVzWyBvYmpKU09OLmdlb21ldHJ5IF07XHJcblxyXG5cdFx0XHRcdFx0Ly8gZ2VvbWV0cnkgYWxyZWFkeSBsb2FkZWRcclxuXHJcblx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIG5lZWRzVGFuZ2VudHMgPSBmYWxzZTtcclxuXHJcblx0XHRcdFx0XHRcdG1hdGVyaWFsID0gcmVzdWx0Lm1hdGVyaWFsc1sgb2JqSlNPTi5tYXRlcmlhbCBdO1xyXG5cdFx0XHRcdFx0XHRuZWVkc1RhbmdlbnRzID0gbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5TaGFkZXJNYXRlcmlhbDtcclxuXHJcblx0XHRcdFx0XHRcdHBvcyA9IG9iakpTT04ucG9zaXRpb247XHJcblx0XHRcdFx0XHRcdHJvdCA9IG9iakpTT04ucm90YXRpb247XHJcblx0XHRcdFx0XHRcdHNjbCA9IG9iakpTT04uc2NhbGU7XHJcblx0XHRcdFx0XHRcdG1hdCA9IG9iakpTT04ubWF0cml4O1xyXG5cdFx0XHRcdFx0XHRxdWF0ID0gb2JqSlNPTi5xdWF0ZXJuaW9uO1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gdXNlIG1hdGVyaWFscyBmcm9tIHRoZSBtb2RlbCBmaWxlXHJcblx0XHRcdFx0XHRcdC8vIGlmIHRoZXJlIGlzIG5vIG1hdGVyaWFsIHNwZWNpZmllZCBpbiB0aGUgb2JqZWN0XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoICEgb2JqSlNPTi5tYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0bWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEZhY2VNYXRlcmlhbCggcmVzdWx0LmZhY2VfbWF0ZXJpYWxzWyBvYmpKU09OLmdlb21ldHJ5IF0gKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdC8vIHVzZSBtYXRlcmlhbHMgZnJvbSB0aGUgbW9kZWwgZmlsZVxyXG5cdFx0XHRcdFx0XHQvLyBpZiB0aGVyZSBpcyBqdXN0IGVtcHR5IGZhY2UgbWF0ZXJpYWxcclxuXHRcdFx0XHRcdFx0Ly8gKG11c3QgY3JlYXRlIG5ldyBtYXRlcmlhbCBhcyBlYWNoIG1vZGVsIGhhcyBpdHMgb3duIGZhY2UgbWF0ZXJpYWwpXHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsICkgJiYgbWF0ZXJpYWwubWF0ZXJpYWxzLmxlbmd0aCA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0bWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEZhY2VNYXRlcmlhbCggcmVzdWx0LmZhY2VfbWF0ZXJpYWxzWyBvYmpKU09OLmdlb21ldHJ5IF0gKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBtYXRlcmlhbC5tYXRlcmlhbHMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdG5lZWRzVGFuZ2VudHMgPSBuZWVkc1RhbmdlbnRzIHx8ICggbWF0ZXJpYWwubWF0ZXJpYWxzWyBpIF0gaW5zdGFuY2VvZiBUSFJFRS5TaGFkZXJNYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIG5lZWRzVGFuZ2VudHMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGdlb21ldHJ5LmNvbXB1dGVUYW5nZW50cygpO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBvYmpKU09OLnNraW4gKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdG9iamVjdCA9IG5ldyBUSFJFRS5Ta2lubmVkTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBvYmpKU09OLm1vcnBoICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuTW9ycGhBbmltTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggb2JqSlNPTi5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdG9iamVjdC5kdXJhdGlvbiA9IG9iakpTT04uZHVyYXRpb247XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCBvYmpKU09OLnRpbWUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRvYmplY3QudGltZSA9IG9iakpTT04udGltZTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIG9iakpTT04ubWlycm9yZWRMb29wICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0b2JqZWN0Lm1pcnJvcmVkTG9vcCA9IG9iakpTT04ubWlycm9yZWRMb29wO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggbWF0ZXJpYWwubW9ycGhOb3JtYWxzICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGdlb21ldHJ5LmNvbXB1dGVNb3JwaE5vcm1hbHMoKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLk1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0b2JqZWN0Lm5hbWUgPSBvYmpJRDtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggbWF0ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRvYmplY3QubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0XHRcdG9iamVjdC5tYXRyaXguc2V0KFxyXG5cdFx0XHRcdFx0XHRcdFx0bWF0WzBdLCAgbWF0WzFdLCAgbWF0WzJdLCAgbWF0WzNdLFxyXG5cdFx0XHRcdFx0XHRcdFx0bWF0WzRdLCAgbWF0WzVdLCAgbWF0WzZdLCAgbWF0WzddLFxyXG5cdFx0XHRcdFx0XHRcdFx0bWF0WzhdLCAgbWF0WzldLCAgbWF0WzEwXSwgbWF0WzExXSxcclxuXHRcdFx0XHRcdFx0XHRcdG1hdFsxMl0sIG1hdFsxM10sIG1hdFsxNF0sIG1hdFsxNV1cclxuXHRcdFx0XHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0b2JqZWN0LnBvc2l0aW9uLnNldCggcG9zWzBdLCBwb3NbMV0sIHBvc1syXSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIHF1YXQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0b2JqZWN0LnF1YXRlcm5pb24uc2V0KCBxdWF0WzBdLCBxdWF0WzFdLCBxdWF0WzJdLCBxdWF0WzNdICk7XHJcblx0XHRcdFx0XHRcdFx0XHRvYmplY3QudXNlUXVhdGVybmlvbiA9IHRydWU7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0b2JqZWN0LnJvdGF0aW9uLnNldCggcm90WzBdLCByb3RbMV0sIHJvdFsyXSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdG9iamVjdC5zY2FsZS5zZXQoIHNjbFswXSwgc2NsWzFdLCBzY2xbMl0gKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdG9iamVjdC52aXNpYmxlID0gb2JqSlNPTi52aXNpYmxlO1xyXG5cdFx0XHRcdFx0XHRvYmplY3QuY2FzdFNoYWRvdyA9IG9iakpTT04uY2FzdFNoYWRvdztcclxuXHRcdFx0XHRcdFx0b2JqZWN0LnJlY2VpdmVTaGFkb3cgPSBvYmpKU09OLnJlY2VpdmVTaGFkb3c7XHJcblxyXG5cdFx0XHRcdFx0XHRwYXJlbnQuYWRkKCBvYmplY3QgKTtcclxuXHJcblx0XHRcdFx0XHRcdHJlc3VsdC5vYmplY3RzWyBvYmpJRCBdID0gb2JqZWN0O1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gbGlnaHRzXHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG9iakpTT04udHlwZSA9PT0gXCJEaXJlY3Rpb25hbExpZ2h0XCIgfHwgb2JqSlNPTi50eXBlID09PSBcIlBvaW50TGlnaHRcIiB8fCBvYmpKU09OLnR5cGUgPT09IFwiQW1iaWVudExpZ2h0XCIgKSB7XHJcblxyXG5cdFx0XHRcdFx0aGV4ID0gKCBvYmpKU09OLmNvbG9yICE9PSB1bmRlZmluZWQgKSA/IG9iakpTT04uY29sb3IgOiAweGZmZmZmZjtcclxuXHRcdFx0XHRcdGludGVuc2l0eSA9ICggb2JqSlNPTi5pbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApID8gb2JqSlNPTi5pbnRlbnNpdHkgOiAxO1xyXG5cclxuXHRcdFx0XHRcdGlmICggb2JqSlNPTi50eXBlID09PSBcIkRpcmVjdGlvbmFsTGlnaHRcIiApIHtcclxuXHJcblx0XHRcdFx0XHRcdHBvcyA9IG9iakpTT04uZGlyZWN0aW9uO1xyXG5cclxuXHRcdFx0XHRcdFx0bGlnaHQgPSBuZXcgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCggaGV4LCBpbnRlbnNpdHkgKTtcclxuXHRcdFx0XHRcdFx0bGlnaHQucG9zaXRpb24uc2V0KCBwb3NbMF0sIHBvc1sxXSwgcG9zWzJdICk7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIG9iakpTT04udGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR0YXJnZXRfYXJyYXkucHVzaCggeyBcIm9iamVjdFwiOiBsaWdodCwgXCJ0YXJnZXROYW1lXCIgOiBvYmpKU09OLnRhcmdldCB9ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIGtpbGwgZXhpc3RpbmcgZGVmYXVsdCB0YXJnZXRcclxuXHRcdFx0XHRcdFx0XHQvLyBvdGhlcndpc2UgaXQgZ2V0cyBhZGRlZCB0byBzY2VuZSB3aGVuIHBhcmVudCBnZXRzIGFkZGVkXHJcblxyXG5cdFx0XHRcdFx0XHRcdGxpZ2h0LnRhcmdldCA9IG51bGw7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggb2JqSlNPTi50eXBlID09PSBcIlBvaW50TGlnaHRcIiApIHtcclxuXHJcblx0XHRcdFx0XHRcdHBvcyA9IG9iakpTT04ucG9zaXRpb247XHJcblx0XHRcdFx0XHRcdGRzdCA9IG9iakpTT04uZGlzdGFuY2U7XHJcblxyXG5cdFx0XHRcdFx0XHRsaWdodCA9IG5ldyBUSFJFRS5Qb2ludExpZ2h0KCBoZXgsIGludGVuc2l0eSwgZHN0ICk7XHJcblx0XHRcdFx0XHRcdGxpZ2h0LnBvc2l0aW9uLnNldCggcG9zWzBdLCBwb3NbMV0sIHBvc1syXSApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIG9iakpTT04udHlwZSA9PT0gXCJBbWJpZW50TGlnaHRcIiApIHtcclxuXHJcblx0XHRcdFx0XHRcdGxpZ2h0ID0gbmV3IFRIUkVFLkFtYmllbnRMaWdodCggaGV4ICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHBhcmVudC5hZGQoIGxpZ2h0ICk7XHJcblxyXG5cdFx0XHRcdFx0bGlnaHQubmFtZSA9IG9iaklEO1xyXG5cdFx0XHRcdFx0cmVzdWx0LmxpZ2h0c1sgb2JqSUQgXSA9IGxpZ2h0O1xyXG5cdFx0XHRcdFx0cmVzdWx0Lm9iamVjdHNbIG9iaklEIF0gPSBsaWdodDtcclxuXHJcblx0XHRcdFx0Ly8gY2FtZXJhc1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBvYmpKU09OLnR5cGUgPT09IFwiUGVyc3BlY3RpdmVDYW1lcmFcIiB8fCBvYmpKU09OLnR5cGUgPT09IFwiT3J0aG9ncmFwaGljQ2FtZXJhXCIgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBvYmpKU09OLnR5cGUgPT09IFwiUGVyc3BlY3RpdmVDYW1lcmFcIiApIHtcclxuXHJcblx0XHRcdFx0XHRcdGNhbWVyYSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggb2JqSlNPTi5mb3YsIG9iakpTT04uYXNwZWN0LCBvYmpKU09OLm5lYXIsIG9iakpTT04uZmFyICk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggb2JqSlNPTi50eXBlID09PSBcIk9ydGhvZ3JhcGhpY0NhbWVyYVwiICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y2FtZXJhID0gbmV3IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSggb2JqSlNPTi5sZWZ0LCBvYmpKU09OLnJpZ2h0LCBvYmpKU09OLnRvcCwgb2JqSlNPTi5ib3R0b20sIG9iakpTT04ubmVhciwgb2JqSlNPTi5mYXIgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0cG9zID0gb2JqSlNPTi5wb3NpdGlvbjtcclxuXHRcdFx0XHRcdGNhbWVyYS5wb3NpdGlvbi5zZXQoIHBvc1swXSwgcG9zWzFdLCBwb3NbMl0gKTtcclxuXHRcdFx0XHRcdHBhcmVudC5hZGQoIGNhbWVyYSApO1xyXG5cclxuXHRcdFx0XHRcdGNhbWVyYS5uYW1lID0gb2JqSUQ7XHJcblx0XHRcdFx0XHRyZXN1bHQuY2FtZXJhc1sgb2JqSUQgXSA9IGNhbWVyYTtcclxuXHRcdFx0XHRcdHJlc3VsdC5vYmplY3RzWyBvYmpJRCBdID0gY2FtZXJhO1xyXG5cclxuXHRcdFx0XHQvLyBwdXJlIE9iamVjdDNEXHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0cG9zID0gb2JqSlNPTi5wb3NpdGlvbjtcclxuXHRcdFx0XHRcdHJvdCA9IG9iakpTT04ucm90YXRpb247XHJcblx0XHRcdFx0XHRzY2wgPSBvYmpKU09OLnNjYWxlO1xyXG5cdFx0XHRcdFx0cXVhdCA9IG9iakpTT04ucXVhdGVybmlvbjtcclxuXHJcblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcclxuXHRcdFx0XHRcdG9iamVjdC5uYW1lID0gb2JqSUQ7XHJcblx0XHRcdFx0XHRvYmplY3QucG9zaXRpb24uc2V0KCBwb3NbMF0sIHBvc1sxXSwgcG9zWzJdICk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBxdWF0ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0b2JqZWN0LnF1YXRlcm5pb24uc2V0KCBxdWF0WzBdLCBxdWF0WzFdLCBxdWF0WzJdLCBxdWF0WzNdICk7XHJcblx0XHRcdFx0XHRcdG9iamVjdC51c2VRdWF0ZXJuaW9uID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0b2JqZWN0LnJvdGF0aW9uLnNldCggcm90WzBdLCByb3RbMV0sIHJvdFsyXSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRvYmplY3Quc2NhbGUuc2V0KCBzY2xbMF0sIHNjbFsxXSwgc2NsWzJdICk7XHJcblx0XHRcdFx0XHRvYmplY3QudmlzaWJsZSA9ICggb2JqSlNPTi52aXNpYmxlICE9PSB1bmRlZmluZWQgKSA/IG9iakpTT04udmlzaWJsZSA6IGZhbHNlO1xyXG5cclxuXHRcdFx0XHRcdHBhcmVudC5hZGQoIG9iamVjdCApO1xyXG5cclxuXHRcdFx0XHRcdHJlc3VsdC5vYmplY3RzWyBvYmpJRCBdID0gb2JqZWN0O1xyXG5cdFx0XHRcdFx0cmVzdWx0LmVtcHRpZXNbIG9iaklEIF0gPSBvYmplY3Q7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBvYmpKU09OLnByb3BlcnRpZXMgIT09IHVuZGVmaW5lZCApICB7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIga2V5IGluIG9iakpTT04ucHJvcGVydGllcyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dmFyIHZhbHVlID0gb2JqSlNPTi5wcm9wZXJ0aWVzWyBrZXkgXTtcclxuXHRcdFx0XHRcdFx0XHRvYmplY3QucHJvcGVydGllc1sga2V5IF0gPSB2YWx1ZTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBvYmpKU09OLmdyb3VwcyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgb2JqSlNPTi5ncm91cHMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2YXIgZ3JvdXBJRCA9IG9iakpTT04uZ3JvdXBzWyBpIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggcmVzdWx0Lmdyb3Vwc1sgZ3JvdXBJRCBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0Lmdyb3Vwc1sgZ3JvdXBJRCBdID0gW107XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0cmVzdWx0Lmdyb3Vwc1sgZ3JvdXBJRCBdLnB1c2goIG9iaklEICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmICggb2JqSlNPTi5jaGlsZHJlbiAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aGFuZGxlX2NoaWxkcmVuKCBvYmplY3QsIG9iakpTT04uY2hpbGRyZW4gKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGhhbmRsZV9tZXNoKCBnZW8sIG1hdCwgaWQgKSB7XHJcblxyXG5cdFx0cmVzdWx0Lmdlb21ldHJpZXNbIGlkIF0gPSBnZW87XHJcblx0XHRyZXN1bHQuZmFjZV9tYXRlcmlhbHNbIGlkIF0gPSBtYXQ7XHJcblx0XHRoYW5kbGVfb2JqZWN0cygpO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBoYW5kbGVfaGllcmFyY2h5KCBub2RlLCBpZCwgcGFyZW50LCBtYXRlcmlhbCwgb2JqICkge1xyXG5cclxuXHRcdHZhciBwID0gb2JqLnBvc2l0aW9uO1xyXG5cdFx0dmFyIHIgPSBvYmoucm90YXRpb247XHJcblx0XHR2YXIgcSA9IG9iai5xdWF0ZXJuaW9uO1xyXG5cdFx0dmFyIHMgPSBvYmouc2NhbGU7XHJcblxyXG5cdFx0bm9kZS5wb3NpdGlvbi5zZXQoIHBbMF0sIHBbMV0sIHBbMl0gKTtcclxuXHJcblx0XHRpZiAoIHEgKSB7XHJcblxyXG5cdFx0XHRub2RlLnF1YXRlcm5pb24uc2V0KCBxWzBdLCBxWzFdLCBxWzJdLCBxWzNdICk7XHJcblx0XHRcdG5vZGUudXNlUXVhdGVybmlvbiA9IHRydWU7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdG5vZGUucm90YXRpb24uc2V0KCByWzBdLCByWzFdLCByWzJdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdG5vZGUuc2NhbGUuc2V0KCBzWzBdLCBzWzFdLCBzWzJdICk7XHJcblxyXG5cdFx0Ly8gb3ZlcnJpZGUgY2hpbGRyZW4gbWF0ZXJpYWxzXHJcblx0XHQvLyBpZiBvYmplY3QgbWF0ZXJpYWwgd2FzIHNwZWNpZmllZCBpbiBKU09OIGV4cGxpY2l0bHlcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0bm9kZS50cmF2ZXJzZSggZnVuY3Rpb24gKCBjaGlsZCApICB7XHJcblxyXG5cdFx0XHRcdGNoaWxkLm1hdGVyaWFsID0gbWF0ZXJpYWw7XHJcblxyXG5cdFx0XHR9ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIG92ZXJyaWRlIGNoaWxkcmVuIHZpc2liaWxpdHlcclxuXHRcdC8vIHdpdGggcm9vdCBub2RlIHZpc2liaWxpdHkgYXMgc3BlY2lmaWVkIGluIEpTT05cclxuXHJcblx0XHR2YXIgdmlzaWJsZSA9ICggb2JqLnZpc2libGUgIT09IHVuZGVmaW5lZCApID8gb2JqLnZpc2libGUgOiB0cnVlO1xyXG5cclxuXHRcdG5vZGUudHJhdmVyc2UoIGZ1bmN0aW9uICggY2hpbGQgKSAge1xyXG5cclxuXHRcdFx0Y2hpbGQudmlzaWJsZSA9IHZpc2libGU7XHJcblxyXG5cdFx0fSApO1xyXG5cclxuXHRcdHBhcmVudC5hZGQoIG5vZGUgKTtcclxuXHJcblx0XHRub2RlLm5hbWUgPSBpZDtcclxuXHJcblx0XHRyZXN1bHQub2JqZWN0c1sgaWQgXSA9IG5vZGU7XHJcblx0XHRoYW5kbGVfb2JqZWN0cygpO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBjcmVhdGVfY2FsbGJhY2tfZ2VvbWV0cnkoIGlkICkge1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiggZ2VvLCBtYXQgKSB7XHJcblxyXG5cdFx0XHRoYW5kbGVfbWVzaCggZ2VvLCBtYXQsIGlkICk7XHJcblxyXG5cdFx0XHRjb3VudGVyX21vZGVscyAtPSAxO1xyXG5cclxuXHRcdFx0c2NvcGUub25Mb2FkQ29tcGxldGUoKTtcclxuXHJcblx0XHRcdGFzeW5jX2NhbGxiYWNrX2dhdGUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGNyZWF0ZV9jYWxsYmFja19oaWVyYWNoeSggaWQsIHBhcmVudCwgbWF0ZXJpYWwsIG9iaiApIHtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24oIGV2ZW50ICkge1xyXG5cclxuXHRcdFx0dmFyIHJlc3VsdDtcclxuXHJcblx0XHRcdC8vIGxvYWRlcnMgd2hpY2ggdXNlIEV2ZW50RGlzcGF0Y2hlclxyXG5cclxuXHRcdFx0aWYgKCBldmVudC5jb250ZW50ICkge1xyXG5cclxuXHRcdFx0XHRyZXN1bHQgPSBldmVudC5jb250ZW50O1xyXG5cclxuXHRcdFx0Ly8gQ29sbGFkYUxvYWRlclxyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggZXZlbnQuZGFlICkge1xyXG5cclxuXHRcdFx0XHRyZXN1bHQgPSBldmVudC5zY2VuZTtcclxuXHJcblxyXG5cdFx0XHQvLyBVVEY4TG9hZGVyXHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRyZXN1bHQgPSBldmVudDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGhhbmRsZV9oaWVyYXJjaHkoIHJlc3VsdCwgaWQsIHBhcmVudCwgbWF0ZXJpYWwsIG9iaiApO1xyXG5cclxuXHRcdFx0Y291bnRlcl9tb2RlbHMgLT0gMTtcclxuXHJcblx0XHRcdHNjb3BlLm9uTG9hZENvbXBsZXRlKCk7XHJcblxyXG5cdFx0XHRhc3luY19jYWxsYmFja19nYXRlKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBjcmVhdGVfY2FsbGJhY2tfZW1iZWQoIGlkICkge1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiggZ2VvLCBtYXQgKSB7XHJcblxyXG5cdFx0XHRyZXN1bHQuZ2VvbWV0cmllc1sgaWQgXSA9IGdlbztcclxuXHRcdFx0cmVzdWx0LmZhY2VfbWF0ZXJpYWxzWyBpZCBdID0gbWF0O1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gYXN5bmNfY2FsbGJhY2tfZ2F0ZSgpIHtcclxuXHJcblx0XHR2YXIgcHJvZ3Jlc3MgPSB7XHJcblxyXG5cdFx0XHR0b3RhbE1vZGVscyA6IHRvdGFsX21vZGVscyxcclxuXHRcdFx0dG90YWxUZXh0dXJlcyA6IHRvdGFsX3RleHR1cmVzLFxyXG5cdFx0XHRsb2FkZWRNb2RlbHMgOiB0b3RhbF9tb2RlbHMgLSBjb3VudGVyX21vZGVscyxcclxuXHRcdFx0bG9hZGVkVGV4dHVyZXMgOiB0b3RhbF90ZXh0dXJlcyAtIGNvdW50ZXJfdGV4dHVyZXNcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHNjb3BlLmNhbGxiYWNrUHJvZ3Jlc3MoIHByb2dyZXNzLCByZXN1bHQgKTtcclxuXHJcblx0XHRzY29wZS5vbkxvYWRQcm9ncmVzcygpO1xyXG5cclxuXHRcdGlmICggY291bnRlcl9tb2RlbHMgPT09IDAgJiYgY291bnRlcl90ZXh0dXJlcyA9PT0gMCApIHtcclxuXHJcblx0XHRcdGZpbmFsaXplKCk7XHJcblx0XHRcdGNhbGxiYWNrRmluaXNoZWQoIHJlc3VsdCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gZmluYWxpemUoKSB7XHJcblxyXG5cdFx0Ly8gdGFrZSBjYXJlIG9mIHRhcmdldHMgd2hpY2ggY291bGQgYmUgYXN5bmNocm9ub3VzbHkgbG9hZGVkIG9iamVjdHNcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0YXJnZXRfYXJyYXkubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHRhID0gdGFyZ2V0X2FycmF5WyBpIF07XHJcblxyXG5cdFx0XHR2YXIgdGFyZ2V0ID0gcmVzdWx0Lm9iamVjdHNbIHRhLnRhcmdldE5hbWUgXTtcclxuXHJcblx0XHRcdGlmICggdGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0XHR0YS5vYmplY3QudGFyZ2V0ID0gdGFyZ2V0O1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ly8gaWYgdGhlcmUgd2FzIGVycm9yIGFuZCB0YXJnZXQgb2Ygc3BlY2lmaWVkIG5hbWUgZG9lc24ndCBleGlzdCBpbiB0aGUgc2NlbmUgZmlsZVxyXG5cdFx0XHRcdC8vIGNyZWF0ZSBpbnN0ZWFkIGR1bW15IHRhcmdldFxyXG5cdFx0XHRcdC8vICh0YXJnZXQgbXVzdCBiZSBhZGRlZCB0byBzY2VuZSBleHBsaWNpdGx5IGFzIHBhcmVudCBpcyBhbHJlYWR5IGFkZGVkKVxyXG5cclxuXHRcdFx0XHR0YS5vYmplY3QudGFyZ2V0ID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XHJcblx0XHRcdFx0cmVzdWx0LnNjZW5lLmFkZCggdGEub2JqZWN0LnRhcmdldCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGEub2JqZWN0LnRhcmdldC5wcm9wZXJ0aWVzLnRhcmdldEludmVyc2UgPSB0YS5vYmplY3Q7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR2YXIgY2FsbGJhY2tUZXh0dXJlID0gZnVuY3Rpb24gKCBjb3VudCApIHtcclxuXHJcblx0XHRjb3VudGVyX3RleHR1cmVzIC09IGNvdW50O1xyXG5cdFx0YXN5bmNfY2FsbGJhY2tfZ2F0ZSgpO1xyXG5cclxuXHRcdHNjb3BlLm9uTG9hZENvbXBsZXRlKCk7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIG11c3QgdXNlIHRoaXMgaW5zdGVhZCBvZiBqdXN0IGRpcmVjdGx5IGNhbGxpbmcgY2FsbGJhY2tUZXh0dXJlXHJcblx0Ly8gYmVjYXVzZSBvZiBjbG9zdXJlIGluIHRoZSBjYWxsaW5nIGNvbnRleHQgbG9vcFxyXG5cclxuXHR2YXIgZ2VuZXJhdGVUZXh0dXJlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoIGNvdW50ICkge1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHRcdGNhbGxiYWNrVGV4dHVyZSggY291bnQgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBmaXJzdCBnbyBzeW5jaHJvbm91cyBlbGVtZW50c1xyXG5cclxuXHQvLyBmb2dzXHJcblxyXG5cdHZhciBmb2dJRCwgZm9nSlNPTjtcclxuXHJcblx0Zm9yICggZm9nSUQgaW4gZGF0YS5mb2dzICkge1xyXG5cclxuXHRcdGZvZ0pTT04gPSBkYXRhLmZvZ3NbIGZvZ0lEIF07XHJcblxyXG5cdFx0aWYgKCBmb2dKU09OLnR5cGUgPT09IFwibGluZWFyXCIgKSB7XHJcblxyXG5cdFx0XHRmb2cgPSBuZXcgVEhSRUUuRm9nKCAweDAwMDAwMCwgZm9nSlNPTi5uZWFyLCBmb2dKU09OLmZhciApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGZvZ0pTT04udHlwZSA9PT0gXCJleHAyXCIgKSB7XHJcblxyXG5cdFx0XHRmb2cgPSBuZXcgVEhSRUUuRm9nRXhwMiggMHgwMDAwMDAsIGZvZ0pTT04uZGVuc2l0eSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb2xvciA9IGZvZ0pTT04uY29sb3I7XHJcblx0XHRmb2cuY29sb3Iuc2V0UkdCKCBjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdICk7XHJcblxyXG5cdFx0cmVzdWx0LmZvZ3NbIGZvZ0lEIF0gPSBmb2c7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gbm93IGNvbWUgcG90ZW50aWFsbHkgYXN5bmNocm9ub3VzIGVsZW1lbnRzXHJcblxyXG5cdC8vIGdlb21ldHJpZXNcclxuXHJcblx0Ly8gY291bnQgaG93IG1hbnkgZ2VvbWV0cmllcyB3aWxsIGJlIGxvYWRlZCBhc3luY2hyb25vdXNseVxyXG5cclxuXHR2YXIgZ2VvSUQsIGdlb0pTT047XHJcblxyXG5cdGZvciAoIGdlb0lEIGluIGRhdGEuZ2VvbWV0cmllcyApIHtcclxuXHJcblx0XHRnZW9KU09OID0gZGF0YS5nZW9tZXRyaWVzWyBnZW9JRCBdO1xyXG5cclxuXHRcdGlmICggZ2VvSlNPTi50eXBlIGluIHRoaXMuZ2VvbWV0cnlIYW5kbGVyTWFwICkge1xyXG5cclxuXHRcdFx0Y291bnRlcl9tb2RlbHMgKz0gMTtcclxuXHJcblx0XHRcdHNjb3BlLm9uTG9hZFN0YXJ0KCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8vIGNvdW50IGhvdyBtYW55IGhpZXJhcmNoaWVzIHdpbGwgYmUgbG9hZGVkIGFzeW5jaHJvbm91c2x5XHJcblxyXG5cdHZhciBvYmpJRCwgb2JqSlNPTjtcclxuXHJcblx0Zm9yICggb2JqSUQgaW4gZGF0YS5vYmplY3RzICkge1xyXG5cclxuXHRcdG9iakpTT04gPSBkYXRhLm9iamVjdHNbIG9iaklEIF07XHJcblxyXG5cdFx0aWYgKCBvYmpKU09OLnR5cGUgJiYgKCBvYmpKU09OLnR5cGUgaW4gdGhpcy5oaWVyYXJjaHlIYW5kbGVyTWFwICkgKSB7XHJcblxyXG5cdFx0XHRjb3VudGVyX21vZGVscyArPSAxO1xyXG5cclxuXHRcdFx0c2NvcGUub25Mb2FkU3RhcnQoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dG90YWxfbW9kZWxzID0gY291bnRlcl9tb2RlbHM7XHJcblxyXG5cdGZvciAoIGdlb0lEIGluIGRhdGEuZ2VvbWV0cmllcyApIHtcclxuXHJcblx0XHRnZW9KU09OID0gZGF0YS5nZW9tZXRyaWVzWyBnZW9JRCBdO1xyXG5cclxuXHRcdGlmICggZ2VvSlNPTi50eXBlID09PSBcImN1YmVcIiApIHtcclxuXHJcblx0XHRcdGdlb21ldHJ5ID0gbmV3IFRIUkVFLkN1YmVHZW9tZXRyeSggZ2VvSlNPTi53aWR0aCwgZ2VvSlNPTi5oZWlnaHQsIGdlb0pTT04uZGVwdGgsIGdlb0pTT04ud2lkdGhTZWdtZW50cywgZ2VvSlNPTi5oZWlnaHRTZWdtZW50cywgZ2VvSlNPTi5kZXB0aFNlZ21lbnRzICk7XHJcblx0XHRcdHJlc3VsdC5nZW9tZXRyaWVzWyBnZW9JRCBdID0gZ2VvbWV0cnk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggZ2VvSlNPTi50eXBlID09PSBcInBsYW5lXCIgKSB7XHJcblxyXG5cdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5QbGFuZUdlb21ldHJ5KCBnZW9KU09OLndpZHRoLCBnZW9KU09OLmhlaWdodCwgZ2VvSlNPTi53aWR0aFNlZ21lbnRzLCBnZW9KU09OLmhlaWdodFNlZ21lbnRzICk7XHJcblx0XHRcdHJlc3VsdC5nZW9tZXRyaWVzWyBnZW9JRCBdID0gZ2VvbWV0cnk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggZ2VvSlNPTi50eXBlID09PSBcInNwaGVyZVwiICkge1xyXG5cclxuXHRcdFx0Z2VvbWV0cnkgPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoIGdlb0pTT04ucmFkaXVzLCBnZW9KU09OLndpZHRoU2VnbWVudHMsIGdlb0pTT04uaGVpZ2h0U2VnbWVudHMgKTtcclxuXHRcdFx0cmVzdWx0Lmdlb21ldHJpZXNbIGdlb0lEIF0gPSBnZW9tZXRyeTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBnZW9KU09OLnR5cGUgPT09IFwiY3lsaW5kZXJcIiApIHtcclxuXHJcblx0XHRcdGdlb21ldHJ5ID0gbmV3IFRIUkVFLkN5bGluZGVyR2VvbWV0cnkoIGdlb0pTT04udG9wUmFkLCBnZW9KU09OLmJvdFJhZCwgZ2VvSlNPTi5oZWlnaHQsIGdlb0pTT04ucmFkU2VncywgZ2VvSlNPTi5oZWlnaHRTZWdzICk7XHJcblx0XHRcdHJlc3VsdC5nZW9tZXRyaWVzWyBnZW9JRCBdID0gZ2VvbWV0cnk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggZ2VvSlNPTi50eXBlID09PSBcInRvcnVzXCIgKSB7XHJcblxyXG5cdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5Ub3J1c0dlb21ldHJ5KCBnZW9KU09OLnJhZGl1cywgZ2VvSlNPTi50dWJlLCBnZW9KU09OLnNlZ21lbnRzUiwgZ2VvSlNPTi5zZWdtZW50c1QgKTtcclxuXHRcdFx0cmVzdWx0Lmdlb21ldHJpZXNbIGdlb0lEIF0gPSBnZW9tZXRyeTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBnZW9KU09OLnR5cGUgPT09IFwiaWNvc2FoZWRyb25cIiApIHtcclxuXHJcblx0XHRcdGdlb21ldHJ5ID0gbmV3IFRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkoIGdlb0pTT04ucmFkaXVzLCBnZW9KU09OLnN1YmRpdmlzaW9ucyApO1xyXG5cdFx0XHRyZXN1bHQuZ2VvbWV0cmllc1sgZ2VvSUQgXSA9IGdlb21ldHJ5O1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGdlb0pTT04udHlwZSBpbiB0aGlzLmdlb21ldHJ5SGFuZGxlck1hcCApIHtcclxuXHJcblx0XHRcdHZhciBsb2FkZXJQYXJhbWV0ZXJzID0ge307XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgcGFyVHlwZSBpbiBnZW9KU09OICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHBhclR5cGUgIT09IFwidHlwZVwiICYmIHBhclR5cGUgIT09IFwidXJsXCIgKSB7XHJcblxyXG5cdFx0XHRcdFx0bG9hZGVyUGFyYW1ldGVyc1sgcGFyVHlwZSBdID0gZ2VvSlNPTlsgcGFyVHlwZSBdO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgbG9hZGVyID0gdGhpcy5nZW9tZXRyeUhhbmRsZXJNYXBbIGdlb0pTT04udHlwZSBdWyBcImxvYWRlck9iamVjdFwiIF07XHJcblx0XHRcdGxvYWRlci5sb2FkKCBnZXRfdXJsKCBnZW9KU09OLnVybCwgZGF0YS51cmxCYXNlVHlwZSApLCBjcmVhdGVfY2FsbGJhY2tfZ2VvbWV0cnkoIGdlb0lEICksIGxvYWRlclBhcmFtZXRlcnMgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBnZW9KU09OLnR5cGUgPT09IFwiZW1iZWRkZWRcIiApIHtcclxuXHJcblx0XHRcdHZhciBtb2RlbEpzb24gPSBkYXRhLmVtYmVkc1sgZ2VvSlNPTi5pZCBdLFxyXG5cdFx0XHRcdHRleHR1cmVfcGF0aCA9IFwiXCI7XHJcblxyXG5cdFx0XHQvLyBwYXNzIG1ldGFkYXRhIGFsb25nIHRvIGpzb25Mb2FkZXIgc28gaXQga25vd3MgdGhlIGZvcm1hdCB2ZXJzaW9uXHJcblxyXG5cdFx0XHRtb2RlbEpzb24ubWV0YWRhdGEgPSBkYXRhLm1ldGFkYXRhO1xyXG5cclxuXHRcdFx0aWYgKCBtb2RlbEpzb24gKSB7XHJcblxyXG5cdFx0XHRcdHZhciBqc29uTG9hZGVyID0gdGhpcy5nZW9tZXRyeUhhbmRsZXJNYXBbIFwiYXNjaWlcIiBdWyBcImxvYWRlck9iamVjdFwiIF07XHJcblx0XHRcdFx0anNvbkxvYWRlci5jcmVhdGVNb2RlbCggbW9kZWxKc29uLCBjcmVhdGVfY2FsbGJhY2tfZW1iZWQoIGdlb0lEICksIHRleHR1cmVfcGF0aCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvLyB0ZXh0dXJlc1xyXG5cclxuXHQvLyBjb3VudCBob3cgbWFueSB0ZXh0dXJlcyB3aWxsIGJlIGxvYWRlZCBhc3luY2hyb25vdXNseVxyXG5cclxuXHR2YXIgdGV4dHVyZUlELCB0ZXh0dXJlSlNPTjtcclxuXHJcblx0Zm9yICggdGV4dHVyZUlEIGluIGRhdGEudGV4dHVyZXMgKSB7XHJcblxyXG5cdFx0dGV4dHVyZUpTT04gPSBkYXRhLnRleHR1cmVzWyB0ZXh0dXJlSUQgXTtcclxuXHJcblx0XHRpZiAoIHRleHR1cmVKU09OLnVybCBpbnN0YW5jZW9mIEFycmF5ICkge1xyXG5cclxuXHRcdFx0Y291bnRlcl90ZXh0dXJlcyArPSB0ZXh0dXJlSlNPTi51cmwubGVuZ3RoO1xyXG5cclxuXHRcdFx0Zm9yKCB2YXIgbiA9IDA7IG4gPCB0ZXh0dXJlSlNPTi51cmwubGVuZ3RoOyBuICsrICkge1xyXG5cclxuXHRcdFx0XHRzY29wZS5vbkxvYWRTdGFydCgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRjb3VudGVyX3RleHR1cmVzICs9IDE7XHJcblxyXG5cdFx0XHRzY29wZS5vbkxvYWRTdGFydCgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR0b3RhbF90ZXh0dXJlcyA9IGNvdW50ZXJfdGV4dHVyZXM7XHJcblxyXG5cdGZvciAoIHRleHR1cmVJRCBpbiBkYXRhLnRleHR1cmVzICkge1xyXG5cclxuXHRcdHRleHR1cmVKU09OID0gZGF0YS50ZXh0dXJlc1sgdGV4dHVyZUlEIF07XHJcblxyXG5cdFx0aWYgKCB0ZXh0dXJlSlNPTi5tYXBwaW5nICE9PSB1bmRlZmluZWQgJiYgVEhSRUVbIHRleHR1cmVKU09OLm1hcHBpbmcgXSAhPT0gdW5kZWZpbmVkICApIHtcclxuXHJcblx0XHRcdHRleHR1cmVKU09OLm1hcHBpbmcgPSBuZXcgVEhSRUVbIHRleHR1cmVKU09OLm1hcHBpbmcgXSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRleHR1cmVKU09OLnVybCBpbnN0YW5jZW9mIEFycmF5ICkge1xyXG5cclxuXHRcdFx0dmFyIGNvdW50ID0gdGV4dHVyZUpTT04udXJsLmxlbmd0aDtcclxuXHRcdFx0dmFyIHVybF9hcnJheSA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yKCB2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dXJsX2FycmF5WyBpIF0gPSBnZXRfdXJsKCB0ZXh0dXJlSlNPTi51cmxbIGkgXSwgZGF0YS51cmxCYXNlVHlwZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGlzQ29tcHJlc3NlZCA9IC9cXC5kZHMkL2kudGVzdCggdXJsX2FycmF5WyAwIF0gKTtcclxuXHJcblx0XHRcdGlmICggaXNDb21wcmVzc2VkICkge1xyXG5cclxuXHRcdFx0XHR0ZXh0dXJlID0gVEhSRUUuSW1hZ2VVdGlscy5sb2FkQ29tcHJlc3NlZFRleHR1cmVDdWJlKCB1cmxfYXJyYXksIHRleHR1cmVKU09OLm1hcHBpbmcsIGdlbmVyYXRlVGV4dHVyZUNhbGxiYWNrKCBjb3VudCApICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0ZXh0dXJlID0gVEhSRUUuSW1hZ2VVdGlscy5sb2FkVGV4dHVyZUN1YmUoIHVybF9hcnJheSwgdGV4dHVyZUpTT04ubWFwcGluZywgZ2VuZXJhdGVUZXh0dXJlQ2FsbGJhY2soIGNvdW50ICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dmFyIGlzQ29tcHJlc3NlZCA9IC9cXC5kZHMkL2kudGVzdCggdGV4dHVyZUpTT04udXJsICk7XHJcblx0XHRcdHZhciBmdWxsVXJsID0gZ2V0X3VybCggdGV4dHVyZUpTT04udXJsLCBkYXRhLnVybEJhc2VUeXBlICk7XHJcblx0XHRcdHZhciB0ZXh0dXJlQ2FsbGJhY2sgPSBnZW5lcmF0ZVRleHR1cmVDYWxsYmFjayggMSApO1xyXG5cclxuXHRcdFx0aWYgKCBpc0NvbXByZXNzZWQgKSB7XHJcblxyXG5cdFx0XHRcdHRleHR1cmUgPSBUSFJFRS5JbWFnZVV0aWxzLmxvYWRDb21wcmVzc2VkVGV4dHVyZSggZnVsbFVybCwgdGV4dHVyZUpTT04ubWFwcGluZywgdGV4dHVyZUNhbGxiYWNrICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0ZXh0dXJlID0gVEhSRUUuSW1hZ2VVdGlscy5sb2FkVGV4dHVyZSggZnVsbFVybCwgdGV4dHVyZUpTT04ubWFwcGluZywgdGV4dHVyZUNhbGxiYWNrICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIFRIUkVFWyB0ZXh0dXJlSlNPTi5taW5GaWx0ZXIgXSAhPT0gdW5kZWZpbmVkIClcclxuXHRcdFx0XHR0ZXh0dXJlLm1pbkZpbHRlciA9IFRIUkVFWyB0ZXh0dXJlSlNPTi5taW5GaWx0ZXIgXTtcclxuXHJcblx0XHRcdGlmICggVEhSRUVbIHRleHR1cmVKU09OLm1hZ0ZpbHRlciBdICE9PSB1bmRlZmluZWQgKVxyXG5cdFx0XHRcdHRleHR1cmUubWFnRmlsdGVyID0gVEhSRUVbIHRleHR1cmVKU09OLm1hZ0ZpbHRlciBdO1xyXG5cclxuXHRcdFx0aWYgKCB0ZXh0dXJlSlNPTi5hbmlzb3Ryb3B5ICkgdGV4dHVyZS5hbmlzb3Ryb3B5ID0gdGV4dHVyZUpTT04uYW5pc290cm9weTtcclxuXHJcblx0XHRcdGlmICggdGV4dHVyZUpTT04ucmVwZWF0ICkge1xyXG5cclxuXHRcdFx0XHR0ZXh0dXJlLnJlcGVhdC5zZXQoIHRleHR1cmVKU09OLnJlcGVhdFsgMCBdLCB0ZXh0dXJlSlNPTi5yZXBlYXRbIDEgXSApO1xyXG5cclxuXHRcdFx0XHRpZiAoIHRleHR1cmVKU09OLnJlcGVhdFsgMCBdICE9PSAxICkgdGV4dHVyZS53cmFwUyA9IFRIUkVFLlJlcGVhdFdyYXBwaW5nO1xyXG5cdFx0XHRcdGlmICggdGV4dHVyZUpTT04ucmVwZWF0WyAxIF0gIT09IDEgKSB0ZXh0dXJlLndyYXBUID0gVEhSRUUuUmVwZWF0V3JhcHBpbmc7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIHRleHR1cmVKU09OLm9mZnNldCApIHtcclxuXHJcblx0XHRcdFx0dGV4dHVyZS5vZmZzZXQuc2V0KCB0ZXh0dXJlSlNPTi5vZmZzZXRbIDAgXSwgdGV4dHVyZUpTT04ub2Zmc2V0WyAxIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGhhbmRsZSB3cmFwIGFmdGVyIHJlcGVhdCBzbyB0aGF0IGRlZmF1bHQgcmVwZWF0IGNhbiBiZSBvdmVycmlkZW5cclxuXHJcblx0XHRcdGlmICggdGV4dHVyZUpTT04ud3JhcCApIHtcclxuXHJcblx0XHRcdFx0dmFyIHdyYXBNYXAgPSB7XHJcblx0XHRcdFx0XCJyZXBlYXRcIiBcdDogVEhSRUUuUmVwZWF0V3JhcHBpbmcsXHJcblx0XHRcdFx0XCJtaXJyb3JcIlx0OiBUSFJFRS5NaXJyb3JlZFJlcGVhdFdyYXBwaW5nXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIHdyYXBNYXBbIHRleHR1cmVKU09OLndyYXBbIDAgXSBdICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLndyYXBTID0gd3JhcE1hcFsgdGV4dHVyZUpTT04ud3JhcFsgMCBdIF07XHJcblx0XHRcdFx0aWYgKCB3cmFwTWFwWyB0ZXh0dXJlSlNPTi53cmFwWyAxIF0gXSAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS53cmFwVCA9IHdyYXBNYXBbIHRleHR1cmVKU09OLndyYXBbIDEgXSBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXN1bHQudGV4dHVyZXNbIHRleHR1cmVJRCBdID0gdGV4dHVyZTtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBtYXRlcmlhbHNcclxuXHJcblx0dmFyIG1hdElELCBtYXRKU09OO1xyXG5cdHZhciBwYXJJRDtcclxuXHJcblx0Zm9yICggbWF0SUQgaW4gZGF0YS5tYXRlcmlhbHMgKSB7XHJcblxyXG5cdFx0bWF0SlNPTiA9IGRhdGEubWF0ZXJpYWxzWyBtYXRJRCBdO1xyXG5cclxuXHRcdGZvciAoIHBhcklEIGluIG1hdEpTT04ucGFyYW1ldGVycyApIHtcclxuXHJcblx0XHRcdGlmICggcGFySUQgPT09IFwiZW52TWFwXCIgfHwgcGFySUQgPT09IFwibWFwXCIgfHwgcGFySUQgPT09IFwibGlnaHRNYXBcIiB8fCBwYXJJRCA9PT0gXCJidW1wTWFwXCIgKSB7XHJcblxyXG5cdFx0XHRcdG1hdEpTT04ucGFyYW1ldGVyc1sgcGFySUQgXSA9IHJlc3VsdC50ZXh0dXJlc1sgbWF0SlNPTi5wYXJhbWV0ZXJzWyBwYXJJRCBdIF07XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBwYXJJRCA9PT0gXCJzaGFkaW5nXCIgKSB7XHJcblxyXG5cdFx0XHRcdG1hdEpTT04ucGFyYW1ldGVyc1sgcGFySUQgXSA9ICggbWF0SlNPTi5wYXJhbWV0ZXJzWyBwYXJJRCBdID09PSBcImZsYXRcIiApID8gVEhSRUUuRmxhdFNoYWRpbmcgOiBUSFJFRS5TbW9vdGhTaGFkaW5nO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggcGFySUQgPT09IFwic2lkZVwiICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIG1hdEpTT04ucGFyYW1ldGVyc1sgcGFySUQgXSA9PSBcImRvdWJsZVwiICkge1xyXG5cclxuXHRcdFx0XHRcdG1hdEpTT04ucGFyYW1ldGVyc1sgcGFySUQgXSA9IFRIUkVFLkRvdWJsZVNpZGU7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdEpTT04ucGFyYW1ldGVyc1sgcGFySUQgXSA9PSBcImJhY2tcIiApIHtcclxuXHJcblx0XHRcdFx0XHRtYXRKU09OLnBhcmFtZXRlcnNbIHBhcklEIF0gPSBUSFJFRS5CYWNrU2lkZTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRtYXRKU09OLnBhcmFtZXRlcnNbIHBhcklEIF0gPSBUSFJFRS5Gcm9udFNpZGU7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHBhcklEID09PSBcImJsZW5kaW5nXCIgKSB7XHJcblxyXG5cdFx0XHRcdG1hdEpTT04ucGFyYW1ldGVyc1sgcGFySUQgXSA9IG1hdEpTT04ucGFyYW1ldGVyc1sgcGFySUQgXSBpbiBUSFJFRSA/IFRIUkVFWyBtYXRKU09OLnBhcmFtZXRlcnNbIHBhcklEIF0gXSA6IFRIUkVFLk5vcm1hbEJsZW5kaW5nO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggcGFySUQgPT09IFwiY29tYmluZVwiICkge1xyXG5cclxuXHRcdFx0XHRtYXRKU09OLnBhcmFtZXRlcnNbIHBhcklEIF0gPSBtYXRKU09OLnBhcmFtZXRlcnNbIHBhcklEIF0gaW4gVEhSRUUgPyBUSFJFRVsgbWF0SlNPTi5wYXJhbWV0ZXJzWyBwYXJJRCBdIF0gOiBUSFJFRS5NdWx0aXBseU9wZXJhdGlvbjtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHBhcklEID09PSBcInZlcnRleENvbG9yc1wiICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIG1hdEpTT04ucGFyYW1ldGVyc1sgcGFySUQgXSA9PSBcImZhY2VcIiApIHtcclxuXHJcblx0XHRcdFx0XHRtYXRKU09OLnBhcmFtZXRlcnNbIHBhcklEIF0gPSBUSFJFRS5GYWNlQ29sb3JzO1xyXG5cclxuXHRcdFx0XHQvLyBkZWZhdWx0IHRvIHZlcnRleCBjb2xvcnMgaWYgXCJ2ZXJ0ZXhDb2xvcnNcIiBpcyBhbnl0aGluZyBlbHNlIGZhY2UgY29sb3JzIG9yIDAgLyBudWxsIC8gZmFsc2VcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0SlNPTi5wYXJhbWV0ZXJzWyBwYXJJRCBdICkgICB7XHJcblxyXG5cdFx0XHRcdFx0bWF0SlNPTi5wYXJhbWV0ZXJzWyBwYXJJRCBdID0gVEhSRUUuVmVydGV4Q29sb3JzO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBwYXJJRCA9PT0gXCJ3cmFwUkdCXCIgKSB7XHJcblxyXG5cdFx0XHRcdHZhciB2MyA9IG1hdEpTT04ucGFyYW1ldGVyc1sgcGFySUQgXTtcclxuXHRcdFx0XHRtYXRKU09OLnBhcmFtZXRlcnNbIHBhcklEIF0gPSBuZXcgVEhSRUUuVmVjdG9yMyggdjNbIDAgXSwgdjNbIDEgXSwgdjNbIDIgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG1hdEpTT04ucGFyYW1ldGVycy5vcGFjaXR5ICE9PSB1bmRlZmluZWQgJiYgbWF0SlNPTi5wYXJhbWV0ZXJzLm9wYWNpdHkgPCAxLjAgKSB7XHJcblxyXG5cdFx0XHRtYXRKU09OLnBhcmFtZXRlcnMudHJhbnNwYXJlbnQgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG1hdEpTT04ucGFyYW1ldGVycy5ub3JtYWxNYXAgKSB7XHJcblxyXG5cdFx0XHR2YXIgc2hhZGVyID0gVEhSRUUuU2hhZGVyTGliWyBcIm5vcm1hbG1hcFwiIF07XHJcblx0XHRcdHZhciB1bmlmb3JtcyA9IFRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoIHNoYWRlci51bmlmb3JtcyApO1xyXG5cclxuXHRcdFx0dmFyIGRpZmZ1c2UgPSBtYXRKU09OLnBhcmFtZXRlcnMuY29sb3I7XHJcblx0XHRcdHZhciBzcGVjdWxhciA9IG1hdEpTT04ucGFyYW1ldGVycy5zcGVjdWxhcjtcclxuXHRcdFx0dmFyIGFtYmllbnQgPSBtYXRKU09OLnBhcmFtZXRlcnMuYW1iaWVudDtcclxuXHRcdFx0dmFyIHNoaW5pbmVzcyA9IG1hdEpTT04ucGFyYW1ldGVycy5zaGluaW5lc3M7XHJcblxyXG5cdFx0XHR1bmlmb3Jtc1sgXCJ0Tm9ybWFsXCIgXS52YWx1ZSA9IHJlc3VsdC50ZXh0dXJlc1sgbWF0SlNPTi5wYXJhbWV0ZXJzLm5vcm1hbE1hcCBdO1xyXG5cclxuXHRcdFx0aWYgKCBtYXRKU09OLnBhcmFtZXRlcnMubm9ybWFsU2NhbGUgKSB7XHJcblxyXG5cdFx0XHRcdHVuaWZvcm1zWyBcInVOb3JtYWxTY2FsZVwiIF0udmFsdWUuc2V0KCBtYXRKU09OLnBhcmFtZXRlcnMubm9ybWFsU2NhbGVbIDAgXSwgbWF0SlNPTi5wYXJhbWV0ZXJzLm5vcm1hbFNjYWxlWyAxIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggbWF0SlNPTi5wYXJhbWV0ZXJzLm1hcCApIHtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXNbIFwidERpZmZ1c2VcIiBdLnZhbHVlID0gbWF0SlNPTi5wYXJhbWV0ZXJzLm1hcDtcclxuXHRcdFx0XHR1bmlmb3Jtc1sgXCJlbmFibGVEaWZmdXNlXCIgXS52YWx1ZSA9IHRydWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG1hdEpTT04ucGFyYW1ldGVycy5lbnZNYXAgKSB7XHJcblxyXG5cdFx0XHRcdHVuaWZvcm1zWyBcInRDdWJlXCIgXS52YWx1ZSA9IG1hdEpTT04ucGFyYW1ldGVycy5lbnZNYXA7XHJcblx0XHRcdFx0dW5pZm9ybXNbIFwiZW5hYmxlUmVmbGVjdGlvblwiIF0udmFsdWUgPSB0cnVlO1xyXG5cdFx0XHRcdHVuaWZvcm1zWyBcInVSZWZsZWN0aXZpdHlcIiBdLnZhbHVlID0gbWF0SlNPTi5wYXJhbWV0ZXJzLnJlZmxlY3Rpdml0eTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggbWF0SlNPTi5wYXJhbWV0ZXJzLmxpZ2h0TWFwICkge1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtc1sgXCJ0QU9cIiBdLnZhbHVlID0gbWF0SlNPTi5wYXJhbWV0ZXJzLmxpZ2h0TWFwO1xyXG5cdFx0XHRcdHVuaWZvcm1zWyBcImVuYWJsZUFPXCIgXS52YWx1ZSA9IHRydWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG1hdEpTT04ucGFyYW1ldGVycy5zcGVjdWxhck1hcCApIHtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXNbIFwidFNwZWN1bGFyXCIgXS52YWx1ZSA9IHJlc3VsdC50ZXh0dXJlc1sgbWF0SlNPTi5wYXJhbWV0ZXJzLnNwZWN1bGFyTWFwIF07XHJcblx0XHRcdFx0dW5pZm9ybXNbIFwiZW5hYmxlU3BlY3VsYXJcIiBdLnZhbHVlID0gdHJ1ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggbWF0SlNPTi5wYXJhbWV0ZXJzLmRpc3BsYWNlbWVudE1hcCApIHtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXNbIFwidERpc3BsYWNlbWVudFwiIF0udmFsdWUgPSByZXN1bHQudGV4dHVyZXNbIG1hdEpTT04ucGFyYW1ldGVycy5kaXNwbGFjZW1lbnRNYXAgXTtcclxuXHRcdFx0XHR1bmlmb3Jtc1sgXCJlbmFibGVEaXNwbGFjZW1lbnRcIiBdLnZhbHVlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXNbIFwidURpc3BsYWNlbWVudEJpYXNcIiBdLnZhbHVlID0gbWF0SlNPTi5wYXJhbWV0ZXJzLmRpc3BsYWNlbWVudEJpYXM7XHJcblx0XHRcdFx0dW5pZm9ybXNbIFwidURpc3BsYWNlbWVudFNjYWxlXCIgXS52YWx1ZSA9IG1hdEpTT04ucGFyYW1ldGVycy5kaXNwbGFjZW1lbnRTY2FsZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHVuaWZvcm1zWyBcInVEaWZmdXNlQ29sb3JcIiBdLnZhbHVlLnNldEhleCggZGlmZnVzZSApO1xyXG5cdFx0XHR1bmlmb3Jtc1sgXCJ1U3BlY3VsYXJDb2xvclwiIF0udmFsdWUuc2V0SGV4KCBzcGVjdWxhciApO1xyXG5cdFx0XHR1bmlmb3Jtc1sgXCJ1QW1iaWVudENvbG9yXCIgXS52YWx1ZS5zZXRIZXgoIGFtYmllbnQgKTtcclxuXHJcblx0XHRcdHVuaWZvcm1zWyBcInVTaGluaW5lc3NcIiBdLnZhbHVlID0gc2hpbmluZXNzO1xyXG5cclxuXHRcdFx0aWYgKCBtYXRKU09OLnBhcmFtZXRlcnMub3BhY2l0eSApIHtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXNbIFwidU9wYWNpdHlcIiBdLnZhbHVlID0gbWF0SlNPTi5wYXJhbWV0ZXJzLm9wYWNpdHk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgcGFyYW1ldGVycyA9IHsgZnJhZ21lbnRTaGFkZXI6IHNoYWRlci5mcmFnbWVudFNoYWRlciwgdmVydGV4U2hhZGVyOiBzaGFkZXIudmVydGV4U2hhZGVyLCB1bmlmb3JtczogdW5pZm9ybXMsIGxpZ2h0czogdHJ1ZSwgZm9nOiB0cnVlIH07XHJcblxyXG5cdFx0XHRtYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCggcGFyYW1ldGVycyApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRtYXRlcmlhbCA9IG5ldyBUSFJFRVsgbWF0SlNPTi50eXBlIF0oIG1hdEpTT04ucGFyYW1ldGVycyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXN1bHQubWF0ZXJpYWxzWyBtYXRJRCBdID0gbWF0ZXJpYWw7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gc2Vjb25kIHBhc3MgdGhyb3VnaCBhbGwgbWF0ZXJpYWxzIHRvIGluaXRpYWxpemUgTWVzaEZhY2VNYXRlcmlhbHNcclxuXHQvLyB0aGF0IGNvdWxkIGJlIHJlZmVycmluZyB0byBvdGhlciBtYXRlcmlhbHMgb3V0IG9mIG9yZGVyXHJcblxyXG5cdGZvciAoIG1hdElEIGluIGRhdGEubWF0ZXJpYWxzICkge1xyXG5cclxuXHRcdG1hdEpTT04gPSBkYXRhLm1hdGVyaWFsc1sgbWF0SUQgXTtcclxuXHJcblx0XHRpZiAoIG1hdEpTT04ucGFyYW1ldGVycy5tYXRlcmlhbHMgKSB7XHJcblxyXG5cdFx0XHR2YXIgbWF0ZXJpYWxBcnJheSA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbWF0SlNPTi5wYXJhbWV0ZXJzLm1hdGVyaWFscy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBsYWJlbCA9IG1hdEpTT04ucGFyYW1ldGVycy5tYXRlcmlhbHNbIGkgXTtcclxuXHRcdFx0XHRtYXRlcmlhbEFycmF5LnB1c2goIHJlc3VsdC5tYXRlcmlhbHNbIGxhYmVsIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJlc3VsdC5tYXRlcmlhbHNbIG1hdElEIF0ubWF0ZXJpYWxzID0gbWF0ZXJpYWxBcnJheTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gb2JqZWN0cyAoIHN5bmNocm9ub3VzIGluaXQgb2YgcHJvY2VkdXJhbCBwcmltaXRpdmVzIClcclxuXHJcblx0aGFuZGxlX29iamVjdHMoKTtcclxuXHJcblx0Ly8gZGVmYXVsdHNcclxuXHJcblx0aWYgKCByZXN1bHQuY2FtZXJhcyAmJiBkYXRhLmRlZmF1bHRzLmNhbWVyYSApIHtcclxuXHJcblx0XHRyZXN1bHQuY3VycmVudENhbWVyYSA9IHJlc3VsdC5jYW1lcmFzWyBkYXRhLmRlZmF1bHRzLmNhbWVyYSBdO1xyXG5cclxuXHR9XHJcblxyXG5cdGlmICggcmVzdWx0LmZvZ3MgJiYgZGF0YS5kZWZhdWx0cy5mb2cgKSB7XHJcblxyXG5cdFx0cmVzdWx0LnNjZW5lLmZvZyA9IHJlc3VsdC5mb2dzWyBkYXRhLmRlZmF1bHRzLmZvZyBdO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIHN5bmNocm9ub3VzIGNhbGxiYWNrXHJcblxyXG5cdHNjb3BlLmNhbGxiYWNrU3luYyggcmVzdWx0ICk7XHJcblxyXG5cdC8vIGp1c3QgaW4gY2FzZSB0aGVyZSBhcmUgbm8gYXN5bmMgZWxlbWVudHNcclxuXHJcblx0YXN5bmNfY2FsbGJhY2tfZ2F0ZSgpO1xyXG5cclxufTtcclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuVGV4dHVyZUxvYWRlciA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0VEhSRUUuRXZlbnREaXNwYXRjaGVyLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy5jcm9zc09yaWdpbiA9IG51bGw7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuVGV4dHVyZUxvYWRlci5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5UZXh0dXJlTG9hZGVyLFxyXG5cclxuXHRsb2FkOiBmdW5jdGlvbiAoIHVybCApIHtcclxuXHJcblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHRcdHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpO1xyXG5cclxuXHRcdGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoICdsb2FkJywgZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuVGV4dHVyZSggaW1hZ2UgKTtcclxuXHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdsb2FkJywgY29udGVudDogdGV4dHVyZSB9ICk7XHJcblxyXG5cdFx0fSwgZmFsc2UgKTtcclxuXHJcblx0XHRpbWFnZS5hZGRFdmVudExpc3RlbmVyKCAnZXJyb3InLCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdlcnJvcicsIG1lc3NhZ2U6ICdDb3VsZG5cXCd0IGxvYWQgVVJMIFsnICsgdXJsICsgJ10nIH0gKTtcclxuXHJcblx0XHR9LCBmYWxzZSApO1xyXG5cclxuXHRcdGlmICggc2NvcGUuY3Jvc3NPcmlnaW4gKSBpbWFnZS5jcm9zc09yaWdpbiA9IHNjb3BlLmNyb3NzT3JpZ2luO1xyXG5cclxuXHRcdGltYWdlLnNyYyA9IHVybDtcclxuXHJcblx0fVxyXG5cclxufVxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5NYXRlcmlhbCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0VEhSRUUuRXZlbnREaXNwYXRjaGVyLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy5pZCA9IFRIUkVFLk1hdGVyaWFsSWRDb3VudCArKztcclxuXHJcblx0dGhpcy5uYW1lID0gJyc7XHJcblxyXG5cdHRoaXMuc2lkZSA9IFRIUkVFLkZyb250U2lkZTtcclxuXHJcblx0dGhpcy5vcGFjaXR5ID0gMTtcclxuXHR0aGlzLnRyYW5zcGFyZW50ID0gZmFsc2U7XHJcblxyXG5cdHRoaXMuYmxlbmRpbmcgPSBUSFJFRS5Ob3JtYWxCbGVuZGluZztcclxuXHJcblx0dGhpcy5ibGVuZFNyYyA9IFRIUkVFLlNyY0FscGhhRmFjdG9yO1xyXG5cdHRoaXMuYmxlbmREc3QgPSBUSFJFRS5PbmVNaW51c1NyY0FscGhhRmFjdG9yO1xyXG5cdHRoaXMuYmxlbmRFcXVhdGlvbiA9IFRIUkVFLkFkZEVxdWF0aW9uO1xyXG5cclxuXHR0aGlzLmRlcHRoVGVzdCA9IHRydWU7XHJcblx0dGhpcy5kZXB0aFdyaXRlID0gdHJ1ZTtcclxuXHJcblx0dGhpcy5wb2x5Z29uT2Zmc2V0ID0gZmFsc2U7XHJcblx0dGhpcy5wb2x5Z29uT2Zmc2V0RmFjdG9yID0gMDtcclxuXHR0aGlzLnBvbHlnb25PZmZzZXRVbml0cyA9IDA7XHJcblxyXG5cdHRoaXMuYWxwaGFUZXN0ID0gMDtcclxuXHJcblx0dGhpcy5vdmVyZHJhdyA9IGZhbHNlOyAvLyBCb29sZWFuIGZvciBmaXhpbmcgYW50aWFsaWFzaW5nIGdhcHMgaW4gQ2FudmFzUmVuZGVyZXJcclxuXHJcblx0dGhpcy52aXNpYmxlID0gdHJ1ZTtcclxuXHJcblx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLnNldFZhbHVlcyA9IGZ1bmN0aW9uICggdmFsdWVzICkge1xyXG5cclxuXHRpZiAoIHZhbHVlcyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xyXG5cclxuXHRmb3IgKCB2YXIga2V5IGluIHZhbHVlcyApIHtcclxuXHJcblx0XHR2YXIgbmV3VmFsdWUgPSB2YWx1ZXNbIGtleSBdO1xyXG5cclxuXHRcdGlmICggbmV3VmFsdWUgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdGVyaWFsOiBcXCcnICsga2V5ICsgJ1xcJyBwYXJhbWV0ZXIgaXMgdW5kZWZpbmVkLicgKTtcclxuXHRcdFx0Y29udGludWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICgga2V5IGluIHRoaXMgKSB7XHJcblxyXG5cdFx0XHR2YXIgY3VycmVudFZhbHVlID0gdGhpc1sga2V5IF07XHJcblxyXG5cdFx0XHRpZiAoIGN1cnJlbnRWYWx1ZSBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yICYmIG5ld1ZhbHVlIGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgKSB7XHJcblxyXG5cdFx0XHRcdGN1cnJlbnRWYWx1ZS5jb3B5KCBuZXdWYWx1ZSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggY3VycmVudFZhbHVlIGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgKSB7XHJcblxyXG5cdFx0XHRcdGN1cnJlbnRWYWx1ZS5zZXQoIG5ld1ZhbHVlICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBjdXJyZW50VmFsdWUgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IzICYmIG5ld1ZhbHVlIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMyApIHtcclxuXHJcblx0XHRcdFx0Y3VycmVudFZhbHVlLmNvcHkoIG5ld1ZhbHVlICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0aGlzWyBrZXkgXSA9IG5ld1ZhbHVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICggbWF0ZXJpYWwgKSB7XHJcblxyXG5cdGlmICggbWF0ZXJpYWwgPT09IHVuZGVmaW5lZCApIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1hdGVyaWFsKCk7XHJcblxyXG5cdG1hdGVyaWFsLm5hbWUgPSB0aGlzLm5hbWU7XHJcblxyXG5cdG1hdGVyaWFsLnNpZGUgPSB0aGlzLnNpZGU7XHJcblxyXG5cdG1hdGVyaWFsLm9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XHJcblx0bWF0ZXJpYWwudHJhbnNwYXJlbnQgPSB0aGlzLnRyYW5zcGFyZW50O1xyXG5cclxuXHRtYXRlcmlhbC5ibGVuZGluZyA9IHRoaXMuYmxlbmRpbmc7XHJcblxyXG5cdG1hdGVyaWFsLmJsZW5kU3JjID0gdGhpcy5ibGVuZFNyYztcclxuXHRtYXRlcmlhbC5ibGVuZERzdCA9IHRoaXMuYmxlbmREc3Q7XHJcblx0bWF0ZXJpYWwuYmxlbmRFcXVhdGlvbiA9IHRoaXMuYmxlbmRFcXVhdGlvbjtcclxuXHJcblx0bWF0ZXJpYWwuZGVwdGhUZXN0ID0gdGhpcy5kZXB0aFRlc3Q7XHJcblx0bWF0ZXJpYWwuZGVwdGhXcml0ZSA9IHRoaXMuZGVwdGhXcml0ZTtcclxuXHJcblx0bWF0ZXJpYWwucG9seWdvbk9mZnNldCA9IHRoaXMucG9seWdvbk9mZnNldDtcclxuXHRtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0RmFjdG9yID0gdGhpcy5wb2x5Z29uT2Zmc2V0RmFjdG9yO1xyXG5cdG1hdGVyaWFsLnBvbHlnb25PZmZzZXRVbml0cyA9IHRoaXMucG9seWdvbk9mZnNldFVuaXRzO1xyXG5cclxuXHRtYXRlcmlhbC5hbHBoYVRlc3QgPSB0aGlzLmFscGhhVGVzdDtcclxuXHJcblx0bWF0ZXJpYWwub3ZlcmRyYXcgPSB0aGlzLm92ZXJkcmF3O1xyXG5cclxuXHRtYXRlcmlhbC52aXNpYmxlID0gdGhpcy52aXNpYmxlO1xyXG5cclxuXHRyZXR1cm4gbWF0ZXJpYWw7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1hdGVyaWFsSWRDb3VudCA9IDA7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKlxyXG4gKiBwYXJhbWV0ZXJzID0ge1xyXG4gKiAgY29sb3I6IDxoZXg+LFxyXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcclxuICpcclxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcclxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxyXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxyXG4gKlxyXG4gKiAgbGluZXdpZHRoOiA8ZmxvYXQ+LFxyXG4gKiAgbGluZWNhcDogXCJyb3VuZFwiLFxyXG4gKiAgbGluZWpvaW46IFwicm91bmRcIixcclxuICpcclxuICogIHZlcnRleENvbG9yczogPGJvb2w+XHJcbiAqXHJcbiAqICBmb2c6IDxib29sPlxyXG4gKiB9XHJcbiAqL1xyXG5cclxuVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTtcclxuXHJcblx0dGhpcy5saW5ld2lkdGggPSAxO1xyXG5cdHRoaXMubGluZWNhcCA9ICdyb3VuZCc7XHJcblx0dGhpcy5saW5lam9pbiA9ICdyb3VuZCc7XHJcblxyXG5cdHRoaXMudmVydGV4Q29sb3JzID0gZmFsc2U7XHJcblxyXG5cdHRoaXMuZm9nID0gdHJ1ZTtcclxuXHJcblx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5MaW5lQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLkxpbmVCYXNpY01hdGVyaWFsLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCk7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBtYXRlcmlhbCApO1xyXG5cclxuXHRtYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmNvbG9yICk7XHJcblxyXG5cdG1hdGVyaWFsLmxpbmV3aWR0aCA9IHRoaXMubGluZXdpZHRoO1xyXG5cdG1hdGVyaWFsLmxpbmVjYXAgPSB0aGlzLmxpbmVjYXA7XHJcblx0bWF0ZXJpYWwubGluZWpvaW4gPSB0aGlzLmxpbmVqb2luO1xyXG5cclxuXHRtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSB0aGlzLnZlcnRleENvbG9ycztcclxuXHJcblx0bWF0ZXJpYWwuZm9nID0gdGhpcy5mb2c7XHJcblxyXG5cdHJldHVybiBtYXRlcmlhbDtcclxuXHJcbn07XHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKlxyXG4gKiBwYXJhbWV0ZXJzID0ge1xyXG4gKiAgY29sb3I6IDxoZXg+LFxyXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcclxuICpcclxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcclxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxyXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxyXG4gKlxyXG4gKiAgbGluZXdpZHRoOiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgc2NhbGU6IDxmbG9hdD4sXHJcbiAqICBkYXNoU2l6ZTogPGZsb2F0PixcclxuICogIGdhcFNpemU6IDxmbG9hdD4sXHJcbiAqXHJcbiAqICB2ZXJ0ZXhDb2xvcnM6IDxib29sPlxyXG4gKlxyXG4gKiAgZm9nOiA8Ym9vbD5cclxuICogfVxyXG4gKi9cclxuXHJcblRIUkVFLkxpbmVEYXNoZWRNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcclxuXHJcblx0VEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApO1xyXG5cclxuXHR0aGlzLmxpbmV3aWR0aCA9IDE7XHJcblxyXG5cdHRoaXMuc2NhbGUgPSAxO1xyXG5cdHRoaXMuZGFzaFNpemUgPSAzO1xyXG5cdHRoaXMuZ2FwU2l6ZSA9IDE7XHJcblxyXG5cdHRoaXMudmVydGV4Q29sb3JzID0gZmFsc2U7XHJcblxyXG5cdHRoaXMuZm9nID0gdHJ1ZTtcclxuXHJcblx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZURhc2hlZE1hdGVyaWFsKCk7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBtYXRlcmlhbCApO1xyXG5cclxuXHRtYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmNvbG9yICk7XHJcblxyXG5cdG1hdGVyaWFsLmxpbmV3aWR0aCA9IHRoaXMubGluZXdpZHRoO1xyXG5cclxuXHRtYXRlcmlhbC5zY2FsZSA9IHRoaXMuc2NhbGU7XHJcblx0bWF0ZXJpYWwuZGFzaFNpemUgPSB0aGlzLmRhc2hTaXplO1xyXG5cdG1hdGVyaWFsLmdhcFNpemUgPSB0aGlzLmdhcFNpemU7XHJcblxyXG5cdG1hdGVyaWFsLnZlcnRleENvbG9ycyA9IHRoaXMudmVydGV4Q29sb3JzO1xyXG5cclxuXHRtYXRlcmlhbC5mb2cgPSB0aGlzLmZvZztcclxuXHJcblx0cmV0dXJuIG1hdGVyaWFsO1xyXG5cclxufTtcclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqXHJcbiAqIHBhcmFtZXRlcnMgPSB7XHJcbiAqICBjb2xvcjogPGhleD4sXHJcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxyXG4gKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKlxyXG4gKiAgbGlnaHRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqXHJcbiAqICBzcGVjdWxhck1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICpcclxuICogIGVudk1hcDogbmV3IFRIUkVFLlRleHR1cmVDdWJlKCBbcG9zeCwgbmVneCwgcG9zeSwgbmVneSwgcG9zeiwgbmVnel0gKSxcclxuICogIGNvbWJpbmU6IFRIUkVFLk11bHRpcGx5LFxyXG4gKiAgcmVmbGVjdGl2aXR5OiA8ZmxvYXQ+LFxyXG4gKiAgcmVmcmFjdGlvblJhdGlvOiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgc2hhZGluZzogVEhSRUUuU21vb3RoU2hhZGluZyxcclxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcclxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxyXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxyXG4gKlxyXG4gKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXHJcbiAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD4sXHJcbiAqXHJcbiAqICB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLk5vQ29sb3JzIC8gVEhSRUUuVmVydGV4Q29sb3JzIC8gVEhSRUUuRmFjZUNvbG9ycyxcclxuICpcclxuICogIHNraW5uaW5nOiA8Ym9vbD4sXHJcbiAqICBtb3JwaFRhcmdldHM6IDxib29sPixcclxuICpcclxuICogIGZvZzogPGJvb2w+XHJcbiAqIH1cclxuICovXHJcblxyXG5USFJFRS5NZXNoQmFzaWNNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcclxuXHJcblx0VEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApOyAvLyBlbWlzc2l2ZVxyXG5cclxuXHR0aGlzLm1hcCA9IG51bGw7XHJcblxyXG5cdHRoaXMubGlnaHRNYXAgPSBudWxsO1xyXG5cclxuXHR0aGlzLnNwZWN1bGFyTWFwID0gbnVsbDtcclxuXHJcblx0dGhpcy5lbnZNYXAgPSBudWxsO1xyXG5cdHRoaXMuY29tYmluZSA9IFRIUkVFLk11bHRpcGx5T3BlcmF0aW9uO1xyXG5cdHRoaXMucmVmbGVjdGl2aXR5ID0gMTtcclxuXHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IDAuOTg7XHJcblxyXG5cdHRoaXMuZm9nID0gdHJ1ZTtcclxuXHJcblx0dGhpcy5zaGFkaW5nID0gVEhSRUUuU21vb3RoU2hhZGluZztcclxuXHJcblx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcclxuXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XHJcblx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gJ3JvdW5kJztcclxuXHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gJ3JvdW5kJztcclxuXHJcblx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBUSFJFRS5Ob0NvbG9ycztcclxuXHJcblx0dGhpcy5za2lubmluZyA9IGZhbHNlO1xyXG5cdHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7XHJcblxyXG5cdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5NZXNoQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCgpO1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgbWF0ZXJpYWwgKTtcclxuXHJcblx0bWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5jb2xvciApO1xyXG5cclxuXHRtYXRlcmlhbC5tYXAgPSB0aGlzLm1hcDtcclxuXHJcblx0bWF0ZXJpYWwubGlnaHRNYXAgPSB0aGlzLmxpZ2h0TWFwO1xyXG5cclxuXHRtYXRlcmlhbC5zcGVjdWxhck1hcCA9IHRoaXMuc3BlY3VsYXJNYXA7XHJcblxyXG5cdG1hdGVyaWFsLmVudk1hcCA9IHRoaXMuZW52TWFwO1xyXG5cdG1hdGVyaWFsLmNvbWJpbmUgPSB0aGlzLmNvbWJpbmU7XHJcblx0bWF0ZXJpYWwucmVmbGVjdGl2aXR5ID0gdGhpcy5yZWZsZWN0aXZpdHk7XHJcblx0bWF0ZXJpYWwucmVmcmFjdGlvblJhdGlvID0gdGhpcy5yZWZyYWN0aW9uUmF0aW87XHJcblxyXG5cdG1hdGVyaWFsLmZvZyA9IHRoaXMuZm9nO1xyXG5cclxuXHRtYXRlcmlhbC5zaGFkaW5nID0gdGhpcy5zaGFkaW5nO1xyXG5cclxuXHRtYXRlcmlhbC53aXJlZnJhbWUgPSB0aGlzLndpcmVmcmFtZTtcclxuXHRtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGggPSB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aDtcclxuXHRtYXRlcmlhbC53aXJlZnJhbWVMaW5lY2FwID0gdGhpcy53aXJlZnJhbWVMaW5lY2FwO1xyXG5cdG1hdGVyaWFsLndpcmVmcmFtZUxpbmVqb2luID0gdGhpcy53aXJlZnJhbWVMaW5lam9pbjtcclxuXHJcblx0bWF0ZXJpYWwudmVydGV4Q29sb3JzID0gdGhpcy52ZXJ0ZXhDb2xvcnM7XHJcblxyXG5cdG1hdGVyaWFsLnNraW5uaW5nID0gdGhpcy5za2lubmluZztcclxuXHRtYXRlcmlhbC5tb3JwaFRhcmdldHMgPSB0aGlzLm1vcnBoVGFyZ2V0cztcclxuXHJcblx0cmV0dXJuIG1hdGVyaWFsO1xyXG5cclxufTtcclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqXHJcbiAqIHBhcmFtZXRlcnMgPSB7XHJcbiAqICBjb2xvcjogPGhleD4sXHJcbiAqICBhbWJpZW50OiA8aGV4PixcclxuICogIGVtaXNzaXZlOiA8aGV4PixcclxuICogIG9wYWNpdHk6IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqXHJcbiAqICBsaWdodE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICpcclxuICogIHNwZWN1bGFyTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKlxyXG4gKiAgZW52TWFwOiBuZXcgVEhSRUUuVGV4dHVyZUN1YmUoIFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XSApLFxyXG4gKiAgY29tYmluZTogVEhSRUUuTXVsdGlwbHksXHJcbiAqICByZWZsZWN0aXZpdHk6IDxmbG9hdD4sXHJcbiAqICByZWZyYWN0aW9uUmF0aW86IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBzaGFkaW5nOiBUSFJFRS5TbW9vdGhTaGFkaW5nLFxyXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxyXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXHJcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXHJcbiAqXHJcbiAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcclxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PixcclxuICpcclxuICogIHZlcnRleENvbG9yczogVEhSRUUuTm9Db2xvcnMgLyBUSFJFRS5WZXJ0ZXhDb2xvcnMgLyBUSFJFRS5GYWNlQ29sb3JzLFxyXG4gKlxyXG4gKiAgc2tpbm5pbmc6IDxib29sPixcclxuICogIG1vcnBoVGFyZ2V0czogPGJvb2w+LFxyXG4gKiAgbW9ycGhOb3JtYWxzOiA8Ym9vbD4sXHJcbiAqXHJcbiAqXHRmb2c6IDxib29sPlxyXG4gKiB9XHJcbiAqL1xyXG5cclxuVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcclxuXHJcblx0VEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApOyAvLyBkaWZmdXNlXHJcblx0dGhpcy5hbWJpZW50ID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApO1xyXG5cdHRoaXMuZW1pc3NpdmUgPSBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICk7XHJcblxyXG5cdHRoaXMud3JhcEFyb3VuZCA9IGZhbHNlO1xyXG5cdHRoaXMud3JhcFJHQiA9IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAxLCAxICk7XHJcblxyXG5cdHRoaXMubWFwID0gbnVsbDtcclxuXHJcblx0dGhpcy5saWdodE1hcCA9IG51bGw7XHJcblxyXG5cdHRoaXMuc3BlY3VsYXJNYXAgPSBudWxsO1xyXG5cclxuXHR0aGlzLmVudk1hcCA9IG51bGw7XHJcblx0dGhpcy5jb21iaW5lID0gVEhSRUUuTXVsdGlwbHlPcGVyYXRpb247XHJcblx0dGhpcy5yZWZsZWN0aXZpdHkgPSAxO1xyXG5cdHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45ODtcclxuXHJcblx0dGhpcy5mb2cgPSB0cnVlO1xyXG5cclxuXHR0aGlzLnNoYWRpbmcgPSBUSFJFRS5TbW9vdGhTaGFkaW5nO1xyXG5cclxuXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcclxuXHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xyXG5cclxuXHR0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzO1xyXG5cclxuXHR0aGlzLnNraW5uaW5nID0gZmFsc2U7XHJcblx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcclxuXHR0aGlzLm1vcnBoTm9ybWFscyA9IGZhbHNlO1xyXG5cclxuXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwoKTtcclxuXHJcblx0VEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIG1hdGVyaWFsICk7XHJcblxyXG5cdG1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMuY29sb3IgKTtcclxuXHRtYXRlcmlhbC5hbWJpZW50LmNvcHkoIHRoaXMuYW1iaWVudCApO1xyXG5cdG1hdGVyaWFsLmVtaXNzaXZlLmNvcHkoIHRoaXMuZW1pc3NpdmUgKTtcclxuXHJcblx0bWF0ZXJpYWwud3JhcEFyb3VuZCA9IHRoaXMud3JhcEFyb3VuZDtcclxuXHRtYXRlcmlhbC53cmFwUkdCLmNvcHkoIHRoaXMud3JhcFJHQiApO1xyXG5cclxuXHRtYXRlcmlhbC5tYXAgPSB0aGlzLm1hcDtcclxuXHJcblx0bWF0ZXJpYWwubGlnaHRNYXAgPSB0aGlzLmxpZ2h0TWFwO1xyXG5cclxuXHRtYXRlcmlhbC5zcGVjdWxhck1hcCA9IHRoaXMuc3BlY3VsYXJNYXA7XHJcblxyXG5cdG1hdGVyaWFsLmVudk1hcCA9IHRoaXMuZW52TWFwO1xyXG5cdG1hdGVyaWFsLmNvbWJpbmUgPSB0aGlzLmNvbWJpbmU7XHJcblx0bWF0ZXJpYWwucmVmbGVjdGl2aXR5ID0gdGhpcy5yZWZsZWN0aXZpdHk7XHJcblx0bWF0ZXJpYWwucmVmcmFjdGlvblJhdGlvID0gdGhpcy5yZWZyYWN0aW9uUmF0aW87XHJcblxyXG5cdG1hdGVyaWFsLmZvZyA9IHRoaXMuZm9nO1xyXG5cclxuXHRtYXRlcmlhbC5zaGFkaW5nID0gdGhpcy5zaGFkaW5nO1xyXG5cclxuXHRtYXRlcmlhbC53aXJlZnJhbWUgPSB0aGlzLndpcmVmcmFtZTtcclxuXHRtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGggPSB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aDtcclxuXHRtYXRlcmlhbC53aXJlZnJhbWVMaW5lY2FwID0gdGhpcy53aXJlZnJhbWVMaW5lY2FwO1xyXG5cdG1hdGVyaWFsLndpcmVmcmFtZUxpbmVqb2luID0gdGhpcy53aXJlZnJhbWVMaW5lam9pbjtcclxuXHJcblx0bWF0ZXJpYWwudmVydGV4Q29sb3JzID0gdGhpcy52ZXJ0ZXhDb2xvcnM7XHJcblxyXG5cdG1hdGVyaWFsLnNraW5uaW5nID0gdGhpcy5za2lubmluZztcclxuXHRtYXRlcmlhbC5tb3JwaFRhcmdldHMgPSB0aGlzLm1vcnBoVGFyZ2V0cztcclxuXHRtYXRlcmlhbC5tb3JwaE5vcm1hbHMgPSB0aGlzLm1vcnBoTm9ybWFscztcclxuXHJcblx0cmV0dXJuIG1hdGVyaWFsO1xyXG5cclxufTtcclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqXHJcbiAqIHBhcmFtZXRlcnMgPSB7XHJcbiAqICBjb2xvcjogPGhleD4sXHJcbiAqICBhbWJpZW50OiA8aGV4PixcclxuICogIGVtaXNzaXZlOiA8aGV4PixcclxuICogIHNwZWN1bGFyOiA8aGV4PixcclxuICogIHNoaW5pbmVzczogPGZsb2F0PixcclxuICogIG9wYWNpdHk6IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqXHJcbiAqICBsaWdodE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICpcclxuICogIGJ1bXBNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqICBidW1wU2NhbGU6IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBub3JtYWxNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqICBub3JtYWxTY2FsZTogPFZlY3RvcjI+LFxyXG4gKlxyXG4gKiAgc3BlY3VsYXJNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqXHJcbiAqICBlbnZNYXA6IG5ldyBUSFJFRS5UZXh0dXJlQ3ViZSggW3Bvc3gsIG5lZ3gsIHBvc3ksIG5lZ3ksIHBvc3osIG5lZ3pdICksXHJcbiAqICBjb21iaW5lOiBUSFJFRS5NdWx0aXBseSxcclxuICogIHJlZmxlY3Rpdml0eTogPGZsb2F0PixcclxuICogIHJlZnJhY3Rpb25SYXRpbzogPGZsb2F0PixcclxuICpcclxuICogIHNoYWRpbmc6IFRIUkVFLlNtb290aFNoYWRpbmcsXHJcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXHJcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcclxuICogIGRlcHRoV3JpdGU6IDxib29sPixcclxuICpcclxuICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxyXG4gKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgdmVydGV4Q29sb3JzOiBUSFJFRS5Ob0NvbG9ycyAvIFRIUkVFLlZlcnRleENvbG9ycyAvIFRIUkVFLkZhY2VDb2xvcnMsXHJcbiAqXHJcbiAqICBza2lubmluZzogPGJvb2w+LFxyXG4gKiAgbW9ycGhUYXJnZXRzOiA8Ym9vbD4sXHJcbiAqICBtb3JwaE5vcm1hbHM6IDxib29sPixcclxuICpcclxuICpcdGZvZzogPGJvb2w+XHJcbiAqIH1cclxuICovXHJcblxyXG5USFJFRS5NZXNoUGhvbmdNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcclxuXHJcblx0VEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApOyAvLyBkaWZmdXNlXHJcblx0dGhpcy5hbWJpZW50ID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApO1xyXG5cdHRoaXMuZW1pc3NpdmUgPSBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICk7XHJcblx0dGhpcy5zcGVjdWxhciA9IG5ldyBUSFJFRS5Db2xvciggMHgxMTExMTEgKTtcclxuXHR0aGlzLnNoaW5pbmVzcyA9IDMwO1xyXG5cclxuXHR0aGlzLm1ldGFsID0gZmFsc2U7XHJcblx0dGhpcy5wZXJQaXhlbCA9IHRydWU7XHJcblxyXG5cdHRoaXMud3JhcEFyb3VuZCA9IGZhbHNlO1xyXG5cdHRoaXMud3JhcFJHQiA9IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAxLCAxICk7XHJcblxyXG5cdHRoaXMubWFwID0gbnVsbDtcclxuXHJcblx0dGhpcy5saWdodE1hcCA9IG51bGw7XHJcblxyXG5cdHRoaXMuYnVtcE1hcCA9IG51bGw7XHJcblx0dGhpcy5idW1wU2NhbGUgPSAxO1xyXG5cclxuXHR0aGlzLm5vcm1hbE1hcCA9IG51bGw7XHJcblx0dGhpcy5ub3JtYWxTY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IyKCAxLCAxICk7XHJcblxyXG5cdHRoaXMuc3BlY3VsYXJNYXAgPSBudWxsO1xyXG5cclxuXHR0aGlzLmVudk1hcCA9IG51bGw7XHJcblx0dGhpcy5jb21iaW5lID0gVEhSRUUuTXVsdGlwbHlPcGVyYXRpb247XHJcblx0dGhpcy5yZWZsZWN0aXZpdHkgPSAxO1xyXG5cdHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45ODtcclxuXHJcblx0dGhpcy5mb2cgPSB0cnVlO1xyXG5cclxuXHR0aGlzLnNoYWRpbmcgPSBUSFJFRS5TbW9vdGhTaGFkaW5nO1xyXG5cclxuXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcclxuXHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xyXG5cclxuXHR0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzO1xyXG5cclxuXHR0aGlzLnNraW5uaW5nID0gZmFsc2U7XHJcblx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcclxuXHR0aGlzLm1vcnBoTm9ybWFscyA9IGZhbHNlO1xyXG5cclxuXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwoKTtcclxuXHJcblx0VEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIG1hdGVyaWFsICk7XHJcblxyXG5cdG1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMuY29sb3IgKTtcclxuXHRtYXRlcmlhbC5hbWJpZW50LmNvcHkoIHRoaXMuYW1iaWVudCApO1xyXG5cdG1hdGVyaWFsLmVtaXNzaXZlLmNvcHkoIHRoaXMuZW1pc3NpdmUgKTtcclxuXHRtYXRlcmlhbC5zcGVjdWxhci5jb3B5KCB0aGlzLnNwZWN1bGFyICk7XHJcblx0bWF0ZXJpYWwuc2hpbmluZXNzID0gdGhpcy5zaGluaW5lc3M7XHJcblxyXG5cdG1hdGVyaWFsLm1ldGFsID0gdGhpcy5tZXRhbDtcclxuXHRtYXRlcmlhbC5wZXJQaXhlbCA9IHRoaXMucGVyUGl4ZWw7XHJcblxyXG5cdG1hdGVyaWFsLndyYXBBcm91bmQgPSB0aGlzLndyYXBBcm91bmQ7XHJcblx0bWF0ZXJpYWwud3JhcFJHQi5jb3B5KCB0aGlzLndyYXBSR0IgKTtcclxuXHJcblx0bWF0ZXJpYWwubWFwID0gdGhpcy5tYXA7XHJcblxyXG5cdG1hdGVyaWFsLmxpZ2h0TWFwID0gdGhpcy5saWdodE1hcDtcclxuXHJcblx0bWF0ZXJpYWwuYnVtcE1hcCA9IHRoaXMuYnVtcE1hcDtcclxuXHRtYXRlcmlhbC5idW1wU2NhbGUgPSB0aGlzLmJ1bXBTY2FsZTtcclxuXHJcblx0bWF0ZXJpYWwubm9ybWFsTWFwID0gdGhpcy5ub3JtYWxNYXA7XHJcblx0bWF0ZXJpYWwubm9ybWFsU2NhbGUuY29weSggdGhpcy5ub3JtYWxTY2FsZSApO1xyXG5cclxuXHRtYXRlcmlhbC5zcGVjdWxhck1hcCA9IHRoaXMuc3BlY3VsYXJNYXA7XHJcblxyXG5cdG1hdGVyaWFsLmVudk1hcCA9IHRoaXMuZW52TWFwO1xyXG5cdG1hdGVyaWFsLmNvbWJpbmUgPSB0aGlzLmNvbWJpbmU7XHJcblx0bWF0ZXJpYWwucmVmbGVjdGl2aXR5ID0gdGhpcy5yZWZsZWN0aXZpdHk7XHJcblx0bWF0ZXJpYWwucmVmcmFjdGlvblJhdGlvID0gdGhpcy5yZWZyYWN0aW9uUmF0aW87XHJcblxyXG5cdG1hdGVyaWFsLmZvZyA9IHRoaXMuZm9nO1xyXG5cclxuXHRtYXRlcmlhbC5zaGFkaW5nID0gdGhpcy5zaGFkaW5nO1xyXG5cclxuXHRtYXRlcmlhbC53aXJlZnJhbWUgPSB0aGlzLndpcmVmcmFtZTtcclxuXHRtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGggPSB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aDtcclxuXHRtYXRlcmlhbC53aXJlZnJhbWVMaW5lY2FwID0gdGhpcy53aXJlZnJhbWVMaW5lY2FwO1xyXG5cdG1hdGVyaWFsLndpcmVmcmFtZUxpbmVqb2luID0gdGhpcy53aXJlZnJhbWVMaW5lam9pbjtcclxuXHJcblx0bWF0ZXJpYWwudmVydGV4Q29sb3JzID0gdGhpcy52ZXJ0ZXhDb2xvcnM7XHJcblxyXG5cdG1hdGVyaWFsLnNraW5uaW5nID0gdGhpcy5za2lubmluZztcclxuXHRtYXRlcmlhbC5tb3JwaFRhcmdldHMgPSB0aGlzLm1vcnBoVGFyZ2V0cztcclxuXHRtYXRlcmlhbC5tb3JwaE5vcm1hbHMgPSB0aGlzLm1vcnBoTm9ybWFscztcclxuXHJcblx0cmV0dXJuIG1hdGVyaWFsO1xyXG5cclxufTtcclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqXHJcbiAqIHBhcmFtZXRlcnMgPSB7XHJcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxyXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXHJcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXHJcbiAqXHJcbiAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcclxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PlxyXG4gKiB9XHJcbiAqL1xyXG5cclxuVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcclxuXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XHJcblxyXG5cdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5NZXNoRGVwdGhNYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCgpO1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgbWF0ZXJpYWwgKTtcclxuXHJcblx0bWF0ZXJpYWwud2lyZWZyYW1lID0gdGhpcy53aXJlZnJhbWU7XHJcblx0bWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoID0gdGhpcy53aXJlZnJhbWVMaW5ld2lkdGg7XHJcblxyXG5cdHJldHVybiBtYXRlcmlhbDtcclxuXHJcbn07XHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKlxyXG4gKiBwYXJhbWV0ZXJzID0ge1xyXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcclxuICpcclxuICogIHNoYWRpbmc6IFRIUkVFLkZsYXRTaGFkaW5nLFxyXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxyXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXHJcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXHJcbiAqXHJcbiAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcclxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PlxyXG4gKiB9XHJcbiAqL1xyXG5cclxuVEhSRUUuTWVzaE5vcm1hbE1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzLCBwYXJhbWV0ZXJzICk7XHJcblxyXG5cdHRoaXMuc2hhZGluZyA9IFRIUkVFLkZsYXRTaGFkaW5nO1xyXG5cclxuXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcclxuXHJcblx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaE5vcm1hbE1hdGVyaWFsKCk7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBtYXRlcmlhbCApO1xyXG5cclxuXHRtYXRlcmlhbC5zaGFkaW5nID0gdGhpcy5zaGFkaW5nO1xyXG5cclxuXHRtYXRlcmlhbC53aXJlZnJhbWUgPSB0aGlzLndpcmVmcmFtZTtcclxuXHRtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGggPSB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aDtcclxuXHJcblx0cmV0dXJuIG1hdGVyaWFsO1xyXG5cclxufTtcclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTWVzaEZhY2VNYXRlcmlhbCA9IGZ1bmN0aW9uICggbWF0ZXJpYWxzICkge1xyXG5cclxuXHR0aGlzLm1hdGVyaWFscyA9IG1hdGVyaWFscyBpbnN0YW5jZW9mIEFycmF5ID8gbWF0ZXJpYWxzIDogW107XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTWVzaEZhY2VNYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHJldHVybiBuZXcgVEhSRUUuTWVzaEZhY2VNYXRlcmlhbCggdGhpcy5tYXRlcmlhbHMuc2xpY2UoIDAgKSApO1xyXG5cclxufTtcclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqXHJcbiAqIHBhcmFtZXRlcnMgPSB7XHJcbiAqICBjb2xvcjogPGhleD4sXHJcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxyXG4gKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKlxyXG4gKiAgc2l6ZTogPGZsb2F0PixcclxuICpcclxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcclxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxyXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxyXG4gKlxyXG4gKiAgdmVydGV4Q29sb3JzOiA8Ym9vbD4sXHJcbiAqXHJcbiAqICBmb2c6IDxib29sPlxyXG4gKiB9XHJcbiAqL1xyXG5cclxuVEhSRUUuUGFydGljbGVCYXNpY01hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7XHJcblxyXG5cdHRoaXMubWFwID0gbnVsbDtcclxuXHJcblx0dGhpcy5zaXplID0gMTtcclxuXHR0aGlzLnNpemVBdHRlbnVhdGlvbiA9IHRydWU7XHJcblxyXG5cdHRoaXMudmVydGV4Q29sb3JzID0gZmFsc2U7XHJcblxyXG5cdHRoaXMuZm9nID0gdHJ1ZTtcclxuXHJcblx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5QYXJ0aWNsZUJhc2ljTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5QYXJ0aWNsZUJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuUGFydGljbGVCYXNpY01hdGVyaWFsKCk7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBtYXRlcmlhbCApO1xyXG5cclxuXHRtYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmNvbG9yICk7XHJcblxyXG5cdG1hdGVyaWFsLm1hcCA9IHRoaXMubWFwO1xyXG5cclxuXHRtYXRlcmlhbC5zaXplID0gdGhpcy5zaXplO1xyXG5cdG1hdGVyaWFsLnNpemVBdHRlbnVhdGlvbiA9IHRoaXMuc2l6ZUF0dGVudWF0aW9uO1xyXG5cclxuXHRtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSB0aGlzLnZlcnRleENvbG9ycztcclxuXHJcblx0bWF0ZXJpYWwuZm9nID0gdGhpcy5mb2c7XHJcblxyXG5cdHJldHVybiBtYXRlcmlhbDtcclxuXHJcbn07XHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKlxyXG4gKiBwYXJhbWV0ZXJzID0ge1xyXG4gKiAgY29sb3I6IDxoZXg+LFxyXG4gKiAgcHJvZ3JhbTogPGZ1bmN0aW9uPixcclxuICogIG9wYWNpdHk6IDxmbG9hdD4sXHJcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmdcclxuICogfVxyXG4gKi9cclxuXHJcblRIUkVFLlBhcnRpY2xlQ2FudmFzTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTtcclxuXHR0aGlzLnByb2dyYW0gPSBmdW5jdGlvbiAoIGNvbnRleHQsIGNvbG9yICkge307XHJcblxyXG5cdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUGFydGljbGVDYW52YXNNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLlBhcnRpY2xlQ2FudmFzTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuUGFydGljbGVDYW52YXNNYXRlcmlhbCgpO1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgbWF0ZXJpYWwgKTtcclxuXHJcblx0bWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5jb2xvciApO1xyXG5cdG1hdGVyaWFsLnByb2dyYW0gPSB0aGlzLnByb2dyYW07XHJcblxyXG5cdHJldHVybiBtYXRlcmlhbDtcclxuXHJcbn07XHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKlxyXG4gKiBwYXJhbWV0ZXJzID0ge1xyXG4gKiAgZnJhZ21lbnRTaGFkZXI6IDxzdHJpbmc+LFxyXG4gKiAgdmVydGV4U2hhZGVyOiA8c3RyaW5nPixcclxuICpcclxuICogIHVuaWZvcm1zOiB7IFwicGFyYW1ldGVyMVwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sIFwicGFyYW1ldGVyMlwiOiB7IHR5cGU6IFwiaVwiIHZhbHVlMjogMiB9IH0sXHJcbiAqXHJcbiAqICBkZWZpbmVzOiB7IFwibGFiZWxcIiA6IFwidmFsdWVcIiB9LFxyXG4gKlxyXG4gKiAgc2hhZGluZzogVEhSRUUuU21vb3RoU2hhZGluZyxcclxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcclxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxyXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxyXG4gKlxyXG4gKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXHJcbiAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBsaWdodHM6IDxib29sPixcclxuICpcclxuICogIHZlcnRleENvbG9yczogVEhSRUUuTm9Db2xvcnMgLyBUSFJFRS5WZXJ0ZXhDb2xvcnMgLyBUSFJFRS5GYWNlQ29sb3JzLFxyXG4gKlxyXG4gKiAgc2tpbm5pbmc6IDxib29sPixcclxuICogIG1vcnBoVGFyZ2V0czogPGJvb2w+LFxyXG4gKiAgbW9ycGhOb3JtYWxzOiA8Ym9vbD4sXHJcbiAqXHJcbiAqXHRmb2c6IDxib29sPlxyXG4gKiB9XHJcbiAqL1xyXG5cclxuVEhSRUUuU2hhZGVyTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy5mcmFnbWVudFNoYWRlciA9IFwidm9pZCBtYWluKCkge31cIjtcclxuXHR0aGlzLnZlcnRleFNoYWRlciA9IFwidm9pZCBtYWluKCkge31cIjtcclxuXHR0aGlzLnVuaWZvcm1zID0ge307XHJcblx0dGhpcy5kZWZpbmVzID0ge307XHJcblx0dGhpcy5hdHRyaWJ1dGVzID0gbnVsbDtcclxuXHJcblx0dGhpcy5zaGFkaW5nID0gVEhSRUUuU21vb3RoU2hhZGluZztcclxuXHJcblx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcclxuXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XHJcblxyXG5cdHRoaXMuZm9nID0gZmFsc2U7IC8vIHNldCB0byB1c2Ugc2NlbmUgZm9nXHJcblxyXG5cdHRoaXMubGlnaHRzID0gZmFsc2U7IC8vIHNldCB0byB1c2Ugc2NlbmUgbGlnaHRzXHJcblxyXG5cdHRoaXMudmVydGV4Q29sb3JzID0gVEhSRUUuTm9Db2xvcnM7IC8vIHNldCB0byB1c2UgXCJjb2xvclwiIGF0dHJpYnV0ZSBzdHJlYW1cclxuXHJcblx0dGhpcy5za2lubmluZyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIHNraW5uaW5nIGF0dHJpYnV0ZSBzdHJlYW1zXHJcblxyXG5cdHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7IC8vIHNldCB0byB1c2UgbW9ycGggdGFyZ2V0c1xyXG5cdHRoaXMubW9ycGhOb3JtYWxzID0gZmFsc2U7IC8vIHNldCB0byB1c2UgbW9ycGggbm9ybWFsc1xyXG5cclxuXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlNoYWRlck1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoKTtcclxuXHJcblx0VEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIG1hdGVyaWFsICk7XHJcblxyXG5cdG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyID0gdGhpcy5mcmFnbWVudFNoYWRlcjtcclxuXHRtYXRlcmlhbC52ZXJ0ZXhTaGFkZXIgPSB0aGlzLnZlcnRleFNoYWRlcjtcclxuXHJcblx0bWF0ZXJpYWwudW5pZm9ybXMgPSBUSFJFRS5Vbmlmb3Jtc1V0aWxzLmNsb25lKCB0aGlzLnVuaWZvcm1zICk7XHJcblxyXG5cdG1hdGVyaWFsLmF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XHJcblx0bWF0ZXJpYWwuZGVmaW5lcyA9IHRoaXMuZGVmaW5lcztcclxuXHJcblx0bWF0ZXJpYWwuc2hhZGluZyA9IHRoaXMuc2hhZGluZztcclxuXHJcblx0bWF0ZXJpYWwud2lyZWZyYW1lID0gdGhpcy53aXJlZnJhbWU7XHJcblx0bWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoID0gdGhpcy53aXJlZnJhbWVMaW5ld2lkdGg7XHJcblxyXG5cdG1hdGVyaWFsLmZvZyA9IHRoaXMuZm9nO1xyXG5cclxuXHRtYXRlcmlhbC5saWdodHMgPSB0aGlzLmxpZ2h0cztcclxuXHJcblx0bWF0ZXJpYWwudmVydGV4Q29sb3JzID0gdGhpcy52ZXJ0ZXhDb2xvcnM7XHJcblxyXG5cdG1hdGVyaWFsLnNraW5uaW5nID0gdGhpcy5za2lubmluZztcclxuXHJcblx0bWF0ZXJpYWwubW9ycGhUYXJnZXRzID0gdGhpcy5tb3JwaFRhcmdldHM7XHJcblx0bWF0ZXJpYWwubW9ycGhOb3JtYWxzID0gdGhpcy5tb3JwaE5vcm1hbHM7XHJcblxyXG5cdHJldHVybiBtYXRlcmlhbDtcclxuXHJcbn07XHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKlxyXG4gKiBwYXJhbWV0ZXJzID0ge1xyXG4gKiAgY29sb3I6IDxoZXg+LFxyXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcclxuICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICpcclxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcclxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxyXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxyXG4gKlxyXG4gKiAgdXNlU2NyZWVuQ29vcmRpbmF0ZXM6IDxib29sPixcclxuICogIHNpemVBdHRlbnVhdGlvbjogPGJvb2w+LFxyXG4gKiAgc2NhbGVCeVZpZXdwb3J0OiA8Ym9vbD4sXHJcbiAqICBhbGlnbm1lbnQ6IFRIUkVFLlNwcml0ZUFsaWdubWVudC5jZW50ZXIsXHJcbiAqXHJcbiAqXHR1dk9mZnNldDogbmV3IFRIUkVFLlZlY3RvcjIoKSxcclxuICpcdHV2U2NhbGU6IG5ldyBUSFJFRS5WZWN0b3IyKCksXHJcbiAqXHJcbiAqICBmb2c6IDxib29sPlxyXG4gKiB9XHJcbiAqL1xyXG5cclxuVEhSRUUuU3ByaXRlTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0Ly8gZGVmYXVsdHNcclxuXHJcblx0dGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTtcclxuXHR0aGlzLm1hcCA9IG5ldyBUSFJFRS5UZXh0dXJlKCk7XHJcblxyXG5cdHRoaXMudXNlU2NyZWVuQ29vcmRpbmF0ZXMgPSB0cnVlO1xyXG5cdHRoaXMuZGVwdGhUZXN0ID0gIXRoaXMudXNlU2NyZWVuQ29vcmRpbmF0ZXM7XHJcblx0dGhpcy5zaXplQXR0ZW51YXRpb24gPSAhdGhpcy51c2VTY3JlZW5Db29yZGluYXRlcztcclxuXHR0aGlzLnNjYWxlQnlWaWV3cG9ydCA9ICF0aGlzLnNpemVBdHRlbnVhdGlvbjtcclxuXHR0aGlzLmFsaWdubWVudCA9IFRIUkVFLlNwcml0ZUFsaWdubWVudC5jZW50ZXIuY2xvbmUoKTtcclxuXHJcblx0dGhpcy5mb2cgPSBmYWxzZTtcclxuXHJcblx0dGhpcy51dk9mZnNldCA9IG5ldyBUSFJFRS5WZWN0b3IyKCAwLCAwICk7XHJcblx0dGhpcy51dlNjYWxlICA9IG5ldyBUSFJFRS5WZWN0b3IyKCAxLCAxICk7XHJcblxyXG5cdC8vIHNldCBwYXJhbWV0ZXJzXHJcblxyXG5cdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG5cdC8vIG92ZXJyaWRlIGNvdXBsZWQgZGVmYXVsdHMgaWYgbm90IHNwZWNpZmllZCBleHBsaWNpdGx5IGJ5IHBhcmFtZXRlcnNcclxuXHJcblx0cGFyYW1ldGVycyA9IHBhcmFtZXRlcnMgfHwge307XHJcblxyXG5cdGlmICggcGFyYW1ldGVycy5kZXB0aFRlc3QgPT09IHVuZGVmaW5lZCApIHRoaXMuZGVwdGhUZXN0ID0gIXRoaXMudXNlU2NyZWVuQ29vcmRpbmF0ZXM7XHJcblx0aWYgKCBwYXJhbWV0ZXJzLnNpemVBdHRlbnVhdGlvbiA9PT0gdW5kZWZpbmVkICkgdGhpcy5zaXplQXR0ZW51YXRpb24gPSAhdGhpcy51c2VTY3JlZW5Db29yZGluYXRlcztcclxuXHRpZiAoIHBhcmFtZXRlcnMuc2NhbGVCeVZpZXdwb3J0ID09PSB1bmRlZmluZWQgKSB0aGlzLnNjYWxlQnlWaWV3cG9ydCA9ICF0aGlzLnNpemVBdHRlbnVhdGlvbjtcclxuXHJcbn07XHJcblxyXG5USFJFRS5TcHJpdGVNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLlNwcml0ZU1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLlNwcml0ZU1hdGVyaWFsKCk7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBtYXRlcmlhbCApO1xyXG5cclxuXHRtYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmNvbG9yICk7XHJcblx0bWF0ZXJpYWwubWFwID0gdGhpcy5tYXA7XHJcblxyXG5cdG1hdGVyaWFsLnVzZVNjcmVlbkNvb3JkaW5hdGVzID0gdGhpcy51c2VTY3JlZW5Db29yZGluYXRlcztcclxuXHRtYXRlcmlhbC5zaXplQXR0ZW51YXRpb24gPSB0aGlzLnNpemVBdHRlbnVhdGlvbjtcclxuXHRtYXRlcmlhbC5zY2FsZUJ5Vmlld3BvcnQgPSB0aGlzLnNjYWxlQnlWaWV3cG9ydDtcclxuXHRtYXRlcmlhbC5hbGlnbm1lbnQuY29weSggdGhpcy5hbGlnbm1lbnQgKTtcclxuXHJcblx0bWF0ZXJpYWwudXZPZmZzZXQuY29weSggdGhpcy51dk9mZnNldCApO1xyXG5cdG1hdGVyaWFsLnV2U2NhbGUuY29weSggdGhpcy51dlNjYWxlICk7XHJcblxyXG5cdG1hdGVyaWFsLmZvZyA9IHRoaXMuZm9nO1xyXG5cclxuXHRyZXR1cm4gbWF0ZXJpYWw7XHJcblxyXG59O1xyXG5cclxuLy8gQWxpZ25tZW50IGVudW1zXHJcblxyXG5USFJFRS5TcHJpdGVBbGlnbm1lbnQgPSB7fTtcclxuVEhSRUUuU3ByaXRlQWxpZ25tZW50LnRvcExlZnQgPSBuZXcgVEhSRUUuVmVjdG9yMiggMSwgLTEgKTtcclxuVEhSRUUuU3ByaXRlQWxpZ25tZW50LnRvcENlbnRlciA9IG5ldyBUSFJFRS5WZWN0b3IyKCAwLCAtMSApO1xyXG5USFJFRS5TcHJpdGVBbGlnbm1lbnQudG9wUmlnaHQgPSBuZXcgVEhSRUUuVmVjdG9yMiggLTEsIC0xICk7XHJcblRIUkVFLlNwcml0ZUFsaWdubWVudC5jZW50ZXJMZWZ0ID0gbmV3IFRIUkVFLlZlY3RvcjIoIDEsIDAgKTtcclxuVEhSRUUuU3ByaXRlQWxpZ25tZW50LmNlbnRlciA9IG5ldyBUSFJFRS5WZWN0b3IyKCAwLCAwICk7XHJcblRIUkVFLlNwcml0ZUFsaWdubWVudC5jZW50ZXJSaWdodCA9IG5ldyBUSFJFRS5WZWN0b3IyKCAtMSwgMCApO1xyXG5USFJFRS5TcHJpdGVBbGlnbm1lbnQuYm90dG9tTGVmdCA9IG5ldyBUSFJFRS5WZWN0b3IyKCAxLCAxICk7XHJcblRIUkVFLlNwcml0ZUFsaWdubWVudC5ib3R0b21DZW50ZXIgPSBuZXcgVEhSRUUuVmVjdG9yMiggMCwgMSApO1xyXG5USFJFRS5TcHJpdGVBbGlnbm1lbnQuYm90dG9tUmlnaHQgPSBuZXcgVEhSRUUuVmVjdG9yMiggLTEsIDEgKTtcclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3Igc3ppbWVrIC8gaHR0cHM6Ly9naXRodWIuY29tL3N6aW1lay9cclxuICovXHJcblxyXG5USFJFRS5UZXh0dXJlID0gZnVuY3Rpb24gKCBpbWFnZSwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICkge1xyXG5cclxuXHRUSFJFRS5FdmVudERpc3BhdGNoZXIuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLmlkID0gVEhSRUUuVGV4dHVyZUlkQ291bnQgKys7XHJcblxyXG5cdHRoaXMubmFtZSA9ICcnO1xyXG5cclxuXHR0aGlzLmltYWdlID0gaW1hZ2U7XHJcblx0dGhpcy5taXBtYXBzID0gW107XHJcblxyXG5cdHRoaXMubWFwcGluZyA9IG1hcHBpbmcgIT09IHVuZGVmaW5lZCA/IG1hcHBpbmcgOiBuZXcgVEhSRUUuVVZNYXBwaW5nKCk7XHJcblxyXG5cdHRoaXMud3JhcFMgPSB3cmFwUyAhPT0gdW5kZWZpbmVkID8gd3JhcFMgOiBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nO1xyXG5cdHRoaXMud3JhcFQgPSB3cmFwVCAhPT0gdW5kZWZpbmVkID8gd3JhcFQgOiBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nO1xyXG5cclxuXHR0aGlzLm1hZ0ZpbHRlciA9IG1hZ0ZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWFnRmlsdGVyIDogVEhSRUUuTGluZWFyRmlsdGVyO1xyXG5cdHRoaXMubWluRmlsdGVyID0gbWluRmlsdGVyICE9PSB1bmRlZmluZWQgPyBtaW5GaWx0ZXIgOiBUSFJFRS5MaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXI7XHJcblxyXG5cdHRoaXMuYW5pc290cm9weSA9IGFuaXNvdHJvcHkgIT09IHVuZGVmaW5lZCA/IGFuaXNvdHJvcHkgOiAxO1xyXG5cclxuXHR0aGlzLmZvcm1hdCA9IGZvcm1hdCAhPT0gdW5kZWZpbmVkID8gZm9ybWF0IDogVEhSRUUuUkdCQUZvcm1hdDtcclxuXHR0aGlzLnR5cGUgPSB0eXBlICE9PSB1bmRlZmluZWQgPyB0eXBlIDogVEhSRUUuVW5zaWduZWRCeXRlVHlwZTtcclxuXHJcblx0dGhpcy5vZmZzZXQgPSBuZXcgVEhSRUUuVmVjdG9yMiggMCwgMCApO1xyXG5cdHRoaXMucmVwZWF0ID0gbmV3IFRIUkVFLlZlY3RvcjIoIDEsIDEgKTtcclxuXHJcblx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSB0cnVlO1xyXG5cdHRoaXMucHJlbXVsdGlwbHlBbHBoYSA9IGZhbHNlO1xyXG5cdHRoaXMuZmxpcFkgPSB0cnVlO1xyXG5cdHRoaXMudW5wYWNrQWxpZ25tZW50ID0gNDsgLy8gdmFsaWQgdmFsdWVzOiAxLCAyLCA0LCA4IChzZWUgaHR0cDovL3d3dy5raHJvbm9zLm9yZy9vcGVuZ2xlcy9zZGsvZG9jcy9tYW4veGh0bWwvZ2xQaXhlbFN0b3JlaS54bWwpXHJcblxyXG5cdHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcclxuXHR0aGlzLm9uVXBkYXRlID0gbnVsbDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5UZXh0dXJlLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLlRleHR1cmUsXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoIHRleHR1cmUgKSB7XHJcblxyXG5cdFx0aWYgKCB0ZXh0dXJlID09PSB1bmRlZmluZWQgKSB0ZXh0dXJlID0gbmV3IFRIUkVFLlRleHR1cmUoKTtcclxuXHJcblx0XHR0ZXh0dXJlLmltYWdlID0gdGhpcy5pbWFnZTtcclxuXHRcdHRleHR1cmUubWlwbWFwcyA9IHRoaXMubWlwbWFwcy5zbGljZSgwKTtcclxuXHJcblx0XHR0ZXh0dXJlLm1hcHBpbmcgPSB0aGlzLm1hcHBpbmc7XHJcblxyXG5cdFx0dGV4dHVyZS53cmFwUyA9IHRoaXMud3JhcFM7XHJcblx0XHR0ZXh0dXJlLndyYXBUID0gdGhpcy53cmFwVDtcclxuXHJcblx0XHR0ZXh0dXJlLm1hZ0ZpbHRlciA9IHRoaXMubWFnRmlsdGVyO1xyXG5cdFx0dGV4dHVyZS5taW5GaWx0ZXIgPSB0aGlzLm1pbkZpbHRlcjtcclxuXHJcblx0XHR0ZXh0dXJlLmFuaXNvdHJvcHkgPSB0aGlzLmFuaXNvdHJvcHk7XHJcblxyXG5cdFx0dGV4dHVyZS5mb3JtYXQgPSB0aGlzLmZvcm1hdDtcclxuXHRcdHRleHR1cmUudHlwZSA9IHRoaXMudHlwZTtcclxuXHJcblx0XHR0ZXh0dXJlLm9mZnNldC5jb3B5KCB0aGlzLm9mZnNldCApO1xyXG5cdFx0dGV4dHVyZS5yZXBlYXQuY29weSggdGhpcy5yZXBlYXQgKTtcclxuXHJcblx0XHR0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IHRoaXMuZ2VuZXJhdGVNaXBtYXBzO1xyXG5cdFx0dGV4dHVyZS5wcmVtdWx0aXBseUFscGhhID0gdGhpcy5wcmVtdWx0aXBseUFscGhhO1xyXG5cdFx0dGV4dHVyZS5mbGlwWSA9IHRoaXMuZmxpcFk7XHJcblx0XHR0ZXh0dXJlLnVucGFja0FsaWdubWVudCA9IHRoaXMudW5wYWNrQWxpZ25tZW50O1xyXG5cclxuXHRcdHJldHVybiB0ZXh0dXJlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5UZXh0dXJlSWRDb3VudCA9IDA7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkNvbXByZXNzZWRUZXh0dXJlID0gZnVuY3Rpb24gKCBtaXBtYXBzLCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGFuaXNvdHJvcHkgKSB7XHJcblxyXG5cdFRIUkVFLlRleHR1cmUuY2FsbCggdGhpcywgbnVsbCwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICk7XHJcblxyXG5cdHRoaXMuaW1hZ2UgPSB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcclxuXHR0aGlzLm1pcG1hcHMgPSBtaXBtYXBzO1xyXG5cclxuXHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlOyAvLyBXZWJHTCBjdXJyZW50bHkgY2FuJ3QgZ2VuZXJhdGUgbWlwbWFwcyBmb3IgY29tcHJlc3NlZCB0ZXh0dXJlcywgdGhleSBtdXN0IGJlIGVtYmVkZGVkIGluIEREUyBmaWxlXHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ29tcHJlc3NlZFRleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLkNvbXByZXNzZWRUZXh0dXJlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuQ29tcHJlc3NlZFRleHR1cmUoKTtcclxuXHJcblx0VEhSRUUuVGV4dHVyZS5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgdGV4dHVyZSApO1xyXG5cclxuXHRyZXR1cm4gdGV4dHVyZTtcclxuXHJcbn07XHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkRhdGFUZXh0dXJlID0gZnVuY3Rpb24gKCBkYXRhLCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGFuaXNvdHJvcHkgKSB7XHJcblxyXG5cdFRIUkVFLlRleHR1cmUuY2FsbCggdGhpcywgbnVsbCwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICk7XHJcblxyXG5cdHRoaXMuaW1hZ2UgPSB7IGRhdGE6IGRhdGEsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5EYXRhVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5UZXh0dXJlLnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuRGF0YVRleHR1cmUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgdGV4dHVyZSA9IG5ldyBUSFJFRS5EYXRhVGV4dHVyZSgpO1xyXG5cclxuXHRUSFJFRS5UZXh0dXJlLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCB0ZXh0dXJlICk7XHJcblxyXG5cdHJldHVybiB0ZXh0dXJlO1xyXG5cclxufTtcclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuUGFydGljbGUgPSBmdW5jdGlvbiAoIG1hdGVyaWFsICkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5QYXJ0aWNsZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLlBhcnRpY2xlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuXHRpZiAoIG9iamVjdCA9PT0gdW5kZWZpbmVkICkgb2JqZWN0ID0gbmV3IFRIUkVFLlBhcnRpY2xlKCB0aGlzLm1hdGVyaWFsICk7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBvYmplY3QgKTtcclxuXHJcblx0cmV0dXJuIG9iamVjdDtcclxuXHJcbn07XHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlBhcnRpY2xlU3lzdGVtID0gZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5O1xyXG5cdHRoaXMubWF0ZXJpYWwgPSAoIG1hdGVyaWFsICE9PSB1bmRlZmluZWQgKSA/IG1hdGVyaWFsIDogbmV3IFRIUkVFLlBhcnRpY2xlQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmIH0gKTtcclxuXHJcblx0dGhpcy5zb3J0UGFydGljbGVzID0gZmFsc2U7XHJcblxyXG5cdGlmICggdGhpcy5nZW9tZXRyeSApIHtcclxuXHJcblx0XHQvLyBjYWxjIGJvdW5kIHJhZGl1c1xyXG5cclxuXHRcdGlmKCB0aGlzLmdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5nZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5mcnVzdHVtQ3VsbGVkID0gZmFsc2U7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUGFydGljbGVTeXN0ZW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5QYXJ0aWNsZVN5c3RlbS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcblx0aWYgKCBvYmplY3QgPT09IHVuZGVmaW5lZCApIG9iamVjdCA9IG5ldyBUSFJFRS5QYXJ0aWNsZVN5c3RlbSggdGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCApO1xyXG5cdG9iamVjdC5zb3J0UGFydGljbGVzID0gdGhpcy5zb3J0UGFydGljbGVzO1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgb2JqZWN0ICk7XHJcblxyXG5cdHJldHVybiBvYmplY3Q7XHJcblxyXG59O1xyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5MaW5lID0gZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHR5cGUgKSB7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5O1xyXG5cdHRoaXMubWF0ZXJpYWwgPSAoIG1hdGVyaWFsICE9PSB1bmRlZmluZWQgKSA/IG1hdGVyaWFsIDogbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmYgfSApO1xyXG5cdHRoaXMudHlwZSA9ICggdHlwZSAhPT0gdW5kZWZpbmVkICkgPyB0eXBlIDogVEhSRUUuTGluZVN0cmlwO1xyXG5cclxuXHRpZiAoIHRoaXMuZ2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0aWYgKCAhIHRoaXMuZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLkxpbmVTdHJpcCA9IDA7XHJcblRIUkVFLkxpbmVQaWVjZXMgPSAxO1xyXG5cclxuVEhSRUUuTGluZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLkxpbmUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG5cdGlmICggb2JqZWN0ID09PSB1bmRlZmluZWQgKSBvYmplY3QgPSBuZXcgVEhSRUUuTGluZSggdGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCwgdGhpcy50eXBlICk7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBvYmplY3QgKTtcclxuXHJcblx0cmV0dXJuIG9iamVjdDtcclxuXHJcbn07XHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIGpvbm9icjEgLyBodHRwOi8vam9ub2JyMS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTWVzaCA9IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcclxuXHR0aGlzLm1hdGVyaWFsID0gKCBtYXRlcmlhbCAhPT0gdW5kZWZpbmVkICkgPyBtYXRlcmlhbCA6IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmLCB3aXJlZnJhbWU6IHRydWUgfSApO1xyXG5cclxuXHRpZiAoIHRoaXMuZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnVwZGF0ZU1vcnBoVGFyZ2V0cygpO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTWVzaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLk1lc2gucHJvdG90eXBlLnVwZGF0ZU1vcnBoVGFyZ2V0cyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0aWYgKCB0aGlzLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdHRoaXMubW9ycGhUYXJnZXRCYXNlID0gLTE7XHJcblx0XHR0aGlzLm1vcnBoVGFyZ2V0Rm9yY2VkT3JkZXIgPSBbXTtcclxuXHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzID0gW107XHJcblx0XHR0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSA9IHt9O1xyXG5cclxuXHRcdGZvciAoIHZhciBtID0gMCwgbWwgPSB0aGlzLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGg7IG0gPCBtbDsgbSArKyApIHtcclxuXHJcblx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzLnB1c2goIDAgKTtcclxuXHRcdFx0dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbIHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBtIF0ubmFtZSBdID0gbTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5NZXNoLnByb3RvdHlwZS5nZXRNb3JwaFRhcmdldEluZGV4QnlOYW1lID0gZnVuY3Rpb24gKCBuYW1lICkge1xyXG5cclxuXHRpZiAoIHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5WyBuYW1lIF0gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbIG5hbWUgXTtcclxuXHJcblx0fVxyXG5cclxuXHRjb25zb2xlLmxvZyggXCJUSFJFRS5NZXNoLmdldE1vcnBoVGFyZ2V0SW5kZXhCeU5hbWU6IG1vcnBoIHRhcmdldCBcIiArIG5hbWUgKyBcIiBkb2VzIG5vdCBleGlzdC4gUmV0dXJuaW5nIDAuXCIgKTtcclxuXHJcblx0cmV0dXJuIDA7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTWVzaC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcblx0aWYgKCBvYmplY3QgPT09IHVuZGVmaW5lZCApIG9iamVjdCA9IG5ldyBUSFJFRS5NZXNoKCB0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsICk7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBvYmplY3QgKTtcclxuXHJcblx0cmV0dXJuIG9iamVjdDtcclxuXHJcbn07XHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkJvbmUgPSBmdW5jdGlvbiggYmVsb25nc1RvU2tpbiApIHtcclxuXHJcblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnNraW4gPSBiZWxvbmdzVG9Ta2luO1xyXG5cdHRoaXMuc2tpbk1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQm9uZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLkJvbmUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICggcGFyZW50U2tpbk1hdHJpeCwgZm9yY2VVcGRhdGUgKSB7XHJcblxyXG5cdC8vIHVwZGF0ZSBsb2NhbFxyXG5cclxuXHRpZiAoIHRoaXMubWF0cml4QXV0b1VwZGF0ZSApIHtcclxuXHJcblx0XHRmb3JjZVVwZGF0ZSB8PSB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIHVwZGF0ZSBza2luIG1hdHJpeFxyXG5cclxuXHRpZiAoIGZvcmNlVXBkYXRlIHx8IHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSApIHtcclxuXHJcblx0XHRpZiggcGFyZW50U2tpbk1hdHJpeCApIHtcclxuXHJcblx0XHRcdHRoaXMuc2tpbk1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBwYXJlbnRTa2luTWF0cml4LCB0aGlzLm1hdHJpeCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLnNraW5NYXRyaXguY29weSggdGhpcy5tYXRyaXggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gZmFsc2U7XHJcblx0XHRmb3JjZVVwZGF0ZSA9IHRydWU7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gdXBkYXRlIGNoaWxkcmVuXHJcblxyXG5cdHZhciBjaGlsZCwgaSwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xyXG5cclxuXHRmb3IgKCBpID0gMDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0dGhpcy5jaGlsZHJlblsgaSBdLnVwZGF0ZSggdGhpcy5za2luTWF0cml4LCBmb3JjZVVwZGF0ZSApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuU2tpbm5lZE1lc2ggPSBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbCwgdXNlVmVydGV4VGV4dHVyZSApIHtcclxuXHJcblx0VEhSRUUuTWVzaC5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuXHJcblx0Ly9cclxuXHJcblx0dGhpcy51c2VWZXJ0ZXhUZXh0dXJlID0gdXNlVmVydGV4VGV4dHVyZSAhPT0gdW5kZWZpbmVkID8gdXNlVmVydGV4VGV4dHVyZSA6IHRydWU7XHJcblxyXG5cdC8vIGluaXQgYm9uZXNcclxuXHJcblx0dGhpcy5pZGVudGl0eU1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG5cdHRoaXMuYm9uZXMgPSBbXTtcclxuXHR0aGlzLmJvbmVNYXRyaWNlcyA9IFtdO1xyXG5cclxuXHR2YXIgYiwgYm9uZSwgZ2JvbmUsIHAsIHEsIHM7XHJcblxyXG5cdGlmICggdGhpcy5nZW9tZXRyeSAmJiB0aGlzLmdlb21ldHJ5LmJvbmVzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0Zm9yICggYiA9IDA7IGIgPCB0aGlzLmdlb21ldHJ5LmJvbmVzLmxlbmd0aDsgYiArKyApIHtcclxuXHJcblx0XHRcdGdib25lID0gdGhpcy5nZW9tZXRyeS5ib25lc1sgYiBdO1xyXG5cclxuXHRcdFx0cCA9IGdib25lLnBvcztcclxuXHRcdFx0cSA9IGdib25lLnJvdHE7XHJcblx0XHRcdHMgPSBnYm9uZS5zY2w7XHJcblxyXG5cdFx0XHRib25lID0gdGhpcy5hZGRCb25lKCk7XHJcblxyXG5cdFx0XHRib25lLm5hbWUgPSBnYm9uZS5uYW1lO1xyXG5cdFx0XHRib25lLnBvc2l0aW9uLnNldCggcFswXSwgcFsxXSwgcFsyXSApO1xyXG5cdFx0XHRib25lLnF1YXRlcm5pb24uc2V0KCBxWzBdLCBxWzFdLCBxWzJdLCBxWzNdICk7XHJcblx0XHRcdGJvbmUudXNlUXVhdGVybmlvbiA9IHRydWU7XHJcblxyXG5cdFx0XHRpZiAoIHMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Ym9uZS5zY2FsZS5zZXQoIHNbMF0sIHNbMV0sIHNbMl0gKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGJvbmUuc2NhbGUuc2V0KCAxLCAxLCAxICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIGIgPSAwOyBiIDwgdGhpcy5ib25lcy5sZW5ndGg7IGIgKysgKSB7XHJcblxyXG5cdFx0XHRnYm9uZSA9IHRoaXMuZ2VvbWV0cnkuYm9uZXNbIGIgXTtcclxuXHRcdFx0Ym9uZSA9IHRoaXMuYm9uZXNbIGIgXTtcclxuXHJcblx0XHRcdGlmICggZ2JvbmUucGFyZW50ID09PSAtMSApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5hZGQoIGJvbmUgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuYm9uZXNbIGdib25lLnBhcmVudCBdLmFkZCggYm9uZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdHZhciBuQm9uZXMgPSB0aGlzLmJvbmVzLmxlbmd0aDtcclxuXHJcblx0XHRpZiAoIHRoaXMudXNlVmVydGV4VGV4dHVyZSApIHtcclxuXHJcblx0XHRcdC8vIGxheW91dCAoMSBtYXRyaXggPSA0IHBpeGVscylcclxuXHRcdFx0Ly9cdFJHQkEgUkdCQSBSR0JBIFJHQkEgKD0+IGNvbHVtbjEsIGNvbHVtbjIsIGNvbHVtbjMsIGNvbHVtbjQpXHJcblx0XHRcdC8vICB3aXRoICA4eDggIHBpeGVsIHRleHR1cmUgbWF4ICAgMTYgYm9uZXMgICg4ICogOCAgLyA0KVxyXG5cdFx0XHQvLyAgXHQgMTZ4MTYgcGl4ZWwgdGV4dHVyZSBtYXggICA2NCBib25lcyAoMTYgKiAxNiAvIDQpXHJcblx0XHRcdC8vICBcdCAzMngzMiBwaXhlbCB0ZXh0dXJlIG1heCAgMjU2IGJvbmVzICgzMiAqIDMyIC8gNClcclxuXHRcdFx0Ly8gIFx0IDY0eDY0IHBpeGVsIHRleHR1cmUgbWF4IDEwMjQgYm9uZXMgKDY0ICogNjQgLyA0KVxyXG5cclxuXHRcdFx0dmFyIHNpemU7XHJcblxyXG5cdFx0XHRpZiAoIG5Cb25lcyA+IDI1NiApXHJcblx0XHRcdFx0c2l6ZSA9IDY0O1xyXG5cdFx0XHRlbHNlIGlmICggbkJvbmVzID4gNjQgKVxyXG5cdFx0XHRcdHNpemUgPSAzMjtcclxuXHRcdFx0ZWxzZSBpZiAoIG5Cb25lcyA+IDE2IClcclxuXHRcdFx0XHRzaXplID0gMTY7XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0XHRzaXplID0gODtcclxuXHJcblx0XHRcdHRoaXMuYm9uZVRleHR1cmVXaWR0aCA9IHNpemU7XHJcblx0XHRcdHRoaXMuYm9uZVRleHR1cmVIZWlnaHQgPSBzaXplO1xyXG5cclxuXHRcdFx0dGhpcy5ib25lTWF0cmljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCB0aGlzLmJvbmVUZXh0dXJlV2lkdGggKiB0aGlzLmJvbmVUZXh0dXJlSGVpZ2h0ICogNCApOyAvLyA0IGZsb2F0cyBwZXIgUkdCQSBwaXhlbFxyXG5cdFx0XHR0aGlzLmJvbmVUZXh0dXJlID0gbmV3IFRIUkVFLkRhdGFUZXh0dXJlKCB0aGlzLmJvbmVNYXRyaWNlcywgdGhpcy5ib25lVGV4dHVyZVdpZHRoLCB0aGlzLmJvbmVUZXh0dXJlSGVpZ2h0LCBUSFJFRS5SR0JBRm9ybWF0LCBUSFJFRS5GbG9hdFR5cGUgKTtcclxuXHRcdFx0dGhpcy5ib25lVGV4dHVyZS5taW5GaWx0ZXIgPSBUSFJFRS5OZWFyZXN0RmlsdGVyO1xyXG5cdFx0XHR0aGlzLmJvbmVUZXh0dXJlLm1hZ0ZpbHRlciA9IFRIUkVFLk5lYXJlc3RGaWx0ZXI7XHJcblx0XHRcdHRoaXMuYm9uZVRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XHJcblx0XHRcdHRoaXMuYm9uZVRleHR1cmUuZmxpcFkgPSBmYWxzZTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhpcy5ib25lTWF0cmljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCAxNiAqIG5Cb25lcyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnBvc2UoKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1lc2gucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5Ta2lubmVkTWVzaC5wcm90b3R5cGUuYWRkQm9uZSA9IGZ1bmN0aW9uKCBib25lICkge1xyXG5cclxuXHRpZiAoIGJvbmUgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRib25lID0gbmV3IFRIUkVFLkJvbmUoIHRoaXMgKTtcclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLmJvbmVzLnB1c2goIGJvbmUgKTtcclxuXHJcblx0cmV0dXJuIGJvbmU7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkID0gZnVuY3Rpb24gKCBmb3JjZSApIHtcclxuXHJcblx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlICYmIHRoaXMudXBkYXRlTWF0cml4KCk7XHJcblxyXG5cdC8vIHVwZGF0ZSBtYXRyaXhXb3JsZFxyXG5cclxuXHRpZiAoIHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSB8fCBmb3JjZSApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMucGFyZW50ICkge1xyXG5cclxuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLnBhcmVudC5tYXRyaXhXb3JsZCwgdGhpcy5tYXRyaXggKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5jb3B5KCB0aGlzLm1hdHJpeCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHRmb3JjZSA9IHRydWU7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gdXBkYXRlIGNoaWxkcmVuXHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHR2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuWyBpIF07XHJcblxyXG5cdFx0aWYgKCBjaGlsZCBpbnN0YW5jZW9mIFRIUkVFLkJvbmUgKSB7XHJcblxyXG5cdFx0XHRjaGlsZC51cGRhdGUoIHRoaXMuaWRlbnRpdHlNYXRyaXgsIGZhbHNlICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGNoaWxkLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8vIG1ha2UgYSBzbmFwc2hvdCBvZiB0aGUgYm9uZXMnIHJlc3QgcG9zaXRpb25cclxuXHJcblx0aWYgKCB0aGlzLmJvbmVJbnZlcnNlcyA9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0dGhpcy5ib25lSW52ZXJzZXMgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgYiA9IDAsIGJsID0gdGhpcy5ib25lcy5sZW5ndGg7IGIgPCBibDsgYiArKyApIHtcclxuXHJcblx0XHRcdHZhciBpbnZlcnNlID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcblx0XHRcdGludmVyc2UuZ2V0SW52ZXJzZSggdGhpcy5ib25lc1sgYiBdLnNraW5NYXRyaXggKTtcclxuXHJcblx0XHRcdHRoaXMuYm9uZUludmVyc2VzLnB1c2goIGludmVyc2UgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gZmxhdHRlbiBib25lIG1hdHJpY2VzIHRvIGFycmF5XHJcblxyXG5cdGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgYiA8IGJsOyBiICsrICkge1xyXG5cclxuXHRcdC8vIGNvbXB1dGUgdGhlIG9mZnNldCBiZXR3ZWVuIHRoZSBjdXJyZW50IGFuZCB0aGUgb3JpZ2luYWwgdHJhbnNmb3JtO1xyXG5cclxuXHRcdC8vVE9ETzogd2UgY291bGQgZ2V0IHJpZCBvZiB0aGlzIG11bHRpcGxpY2F0aW9uIHN0ZXAgaWYgdGhlIHNraW5NYXRyaXhcclxuXHRcdC8vIHdhcyBhbHJlYWR5IHJlcHJlc2VudGluZyB0aGUgb2Zmc2V0OyBob3dldmVyLCB0aGlzIHJlcXVpcmVzIHNvbWVcclxuXHRcdC8vIG1ham9yIGNoYW5nZXMgdG8gdGhlIGFuaW1hdGlvbiBzeXN0ZW1cclxuXHJcblx0XHRUSFJFRS5Ta2lubmVkTWVzaC5vZmZzZXRNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggdGhpcy5ib25lc1sgYiBdLnNraW5NYXRyaXgsIHRoaXMuYm9uZUludmVyc2VzWyBiIF0gKTtcclxuXHJcblx0XHRUSFJFRS5Ta2lubmVkTWVzaC5vZmZzZXRNYXRyaXguZmxhdHRlblRvQXJyYXlPZmZzZXQoIHRoaXMuYm9uZU1hdHJpY2VzLCBiICogMTYgKTtcclxuXHJcblx0fVxyXG5cclxuXHRpZiAoIHRoaXMudXNlVmVydGV4VGV4dHVyZSApIHtcclxuXHJcblx0XHR0aGlzLmJvbmVUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZS5wb3NlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XHJcblxyXG5cdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdC8vIG5vcm1hbGl6ZSB3ZWlnaHRzXHJcblxyXG5cdFx0dmFyIHN3ID0gdGhpcy5nZW9tZXRyeS5za2luV2VpZ2h0c1sgaSBdO1xyXG5cclxuXHRcdHZhciBzY2FsZSA9IDEuMCAvIHN3Lmxlbmd0aE1hbmhhdHRhbigpO1xyXG5cclxuXHRcdGlmICggc2NhbGUgIT09IEluZmluaXR5ICkge1xyXG5cclxuXHRcdFx0c3cubXVsdGlwbHlTY2FsYXIoIHNjYWxlICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHN3LnNldCggMSApOyAvLyB0aGlzIHdpbGwgYmUgbm9ybWFsaXplZCBieSB0aGUgc2hhZGVyIGFueXdheVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuXHRpZiAoIG9iamVjdCA9PT0gdW5kZWZpbmVkICkgb2JqZWN0ID0gbmV3IFRIUkVFLlNraW5uZWRNZXNoKCB0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsLCB0aGlzLnVzZVZlcnRleFRleHR1cmUgKTtcclxuXHJcblx0VEhSRUUuTWVzaC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgb2JqZWN0ICk7XHJcblxyXG5cdHJldHVybiBvYmplY3Q7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU2tpbm5lZE1lc2gub2Zmc2V0TWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTW9ycGhBbmltTWVzaCA9IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xyXG5cclxuXHRUSFJFRS5NZXNoLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cclxuXHQvLyBBUElcclxuXHJcblx0dGhpcy5kdXJhdGlvbiA9IDEwMDA7IC8vIG1pbGxpc2Vjb25kc1xyXG5cdHRoaXMubWlycm9yZWRMb29wID0gZmFsc2U7XHJcblx0dGhpcy50aW1lID0gMDtcclxuXHJcblx0Ly8gaW50ZXJuYWxzXHJcblxyXG5cdHRoaXMubGFzdEtleWZyYW1lID0gMDtcclxuXHR0aGlzLmN1cnJlbnRLZXlmcmFtZSA9IDA7XHJcblxyXG5cdHRoaXMuZGlyZWN0aW9uID0gMTtcclxuXHR0aGlzLmRpcmVjdGlvbkJhY2t3YXJkcyA9IGZhbHNlO1xyXG5cclxuXHR0aGlzLnNldEZyYW1lUmFuZ2UoIDAsIHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aCAtIDEgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEFuaW1NZXNoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1lc2gucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5Nb3JwaEFuaW1NZXNoLnByb3RvdHlwZS5zZXRGcmFtZVJhbmdlID0gZnVuY3Rpb24gKCBzdGFydCwgZW5kICkge1xyXG5cclxuXHR0aGlzLnN0YXJ0S2V5ZnJhbWUgPSBzdGFydDtcclxuXHR0aGlzLmVuZEtleWZyYW1lID0gZW5kO1xyXG5cclxuXHR0aGlzLmxlbmd0aCA9IHRoaXMuZW5kS2V5ZnJhbWUgLSB0aGlzLnN0YXJ0S2V5ZnJhbWUgKyAxO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLnNldERpcmVjdGlvbkZvcndhcmQgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHRoaXMuZGlyZWN0aW9uID0gMTtcclxuXHR0aGlzLmRpcmVjdGlvbkJhY2t3YXJkcyA9IGZhbHNlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLnNldERpcmVjdGlvbkJhY2t3YXJkID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR0aGlzLmRpcmVjdGlvbiA9IC0xO1xyXG5cdHRoaXMuZGlyZWN0aW9uQmFja3dhcmRzID0gdHJ1ZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEFuaW1NZXNoLnByb3RvdHlwZS5wYXJzZUFuaW1hdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XHJcblxyXG5cdGlmICggISBnZW9tZXRyeS5hbmltYXRpb25zICkgZ2VvbWV0cnkuYW5pbWF0aW9ucyA9IHt9O1xyXG5cclxuXHR2YXIgZmlyc3RBbmltYXRpb24sIGFuaW1hdGlvbnMgPSBnZW9tZXRyeS5hbmltYXRpb25zO1xyXG5cclxuXHR2YXIgcGF0dGVybiA9IC8oW2Etel0rKShcXGQrKS87XHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgaWwgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0dmFyIG1vcnBoID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF07XHJcblx0XHR2YXIgcGFydHMgPSBtb3JwaC5uYW1lLm1hdGNoKCBwYXR0ZXJuICk7XHJcblxyXG5cdFx0aWYgKCBwYXJ0cyAmJiBwYXJ0cy5sZW5ndGggPiAxICkge1xyXG5cclxuXHRcdFx0dmFyIGxhYmVsID0gcGFydHNbIDEgXTtcclxuXHRcdFx0dmFyIG51bSA9IHBhcnRzWyAyIF07XHJcblxyXG5cdFx0XHRpZiAoICEgYW5pbWF0aW9uc1sgbGFiZWwgXSApIGFuaW1hdGlvbnNbIGxhYmVsIF0gPSB7IHN0YXJ0OiBJbmZpbml0eSwgZW5kOiAtSW5maW5pdHkgfTtcclxuXHJcblx0XHRcdHZhciBhbmltYXRpb24gPSBhbmltYXRpb25zWyBsYWJlbCBdO1xyXG5cclxuXHRcdFx0aWYgKCBpIDwgYW5pbWF0aW9uLnN0YXJ0ICkgYW5pbWF0aW9uLnN0YXJ0ID0gaTtcclxuXHRcdFx0aWYgKCBpID4gYW5pbWF0aW9uLmVuZCApIGFuaW1hdGlvbi5lbmQgPSBpO1xyXG5cclxuXHRcdFx0aWYgKCAhIGZpcnN0QW5pbWF0aW9uICkgZmlyc3RBbmltYXRpb24gPSBsYWJlbDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Z2VvbWV0cnkuZmlyc3RBbmltYXRpb24gPSBmaXJzdEFuaW1hdGlvbjtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEFuaW1NZXNoLnByb3RvdHlwZS5zZXRBbmltYXRpb25MYWJlbCA9IGZ1bmN0aW9uICggbGFiZWwsIHN0YXJ0LCBlbmQgKSB7XHJcblxyXG5cdGlmICggISB0aGlzLmdlb21ldHJ5LmFuaW1hdGlvbnMgKSB0aGlzLmdlb21ldHJ5LmFuaW1hdGlvbnMgPSB7fTtcclxuXHJcblx0dGhpcy5nZW9tZXRyeS5hbmltYXRpb25zWyBsYWJlbCBdID0geyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH07XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUucGxheUFuaW1hdGlvbiA9IGZ1bmN0aW9uICggbGFiZWwsIGZwcyApIHtcclxuXHJcblx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuZ2VvbWV0cnkuYW5pbWF0aW9uc1sgbGFiZWwgXTtcclxuXHJcblx0aWYgKCBhbmltYXRpb24gKSB7XHJcblxyXG5cdFx0dGhpcy5zZXRGcmFtZVJhbmdlKCBhbmltYXRpb24uc3RhcnQsIGFuaW1hdGlvbi5lbmQgKTtcclxuXHRcdHRoaXMuZHVyYXRpb24gPSAxMDAwICogKCAoIGFuaW1hdGlvbi5lbmQgLSBhbmltYXRpb24uc3RhcnQgKSAvIGZwcyApO1xyXG5cdFx0dGhpcy50aW1lID0gMDtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oIFwiYW5pbWF0aW9uW1wiICsgbGFiZWwgKyBcIl0gdW5kZWZpbmVkXCIgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLnVwZGF0ZUFuaW1hdGlvbiA9IGZ1bmN0aW9uICggZGVsdGEgKSB7XHJcblxyXG5cdHZhciBmcmFtZVRpbWUgPSB0aGlzLmR1cmF0aW9uIC8gdGhpcy5sZW5ndGg7XHJcblxyXG5cdHRoaXMudGltZSArPSB0aGlzLmRpcmVjdGlvbiAqIGRlbHRhO1xyXG5cclxuXHRpZiAoIHRoaXMubWlycm9yZWRMb29wICkge1xyXG5cclxuXHRcdGlmICggdGhpcy50aW1lID4gdGhpcy5kdXJhdGlvbiB8fCB0aGlzLnRpbWUgPCAwICkge1xyXG5cclxuXHRcdFx0dGhpcy5kaXJlY3Rpb24gKj0gLTE7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMudGltZSA+IHRoaXMuZHVyYXRpb24gKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMudGltZSA9IHRoaXMuZHVyYXRpb247XHJcblx0XHRcdFx0dGhpcy5kaXJlY3Rpb25CYWNrd2FyZHMgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCB0aGlzLnRpbWUgPCAwICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLnRpbWUgPSAwO1xyXG5cdFx0XHRcdHRoaXMuZGlyZWN0aW9uQmFja3dhcmRzID0gZmFsc2U7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdHRoaXMudGltZSA9IHRoaXMudGltZSAlIHRoaXMuZHVyYXRpb247XHJcblxyXG5cdFx0aWYgKCB0aGlzLnRpbWUgPCAwICkgdGhpcy50aW1lICs9IHRoaXMuZHVyYXRpb247XHJcblxyXG5cdH1cclxuXHJcblx0dmFyIGtleWZyYW1lID0gdGhpcy5zdGFydEtleWZyYW1lICsgVEhSRUUuTWF0aC5jbGFtcCggTWF0aC5mbG9vciggdGhpcy50aW1lIC8gZnJhbWVUaW1lICksIDAsIHRoaXMubGVuZ3RoIC0gMSApO1xyXG5cclxuXHRpZiAoIGtleWZyYW1lICE9PSB0aGlzLmN1cnJlbnRLZXlmcmFtZSApIHtcclxuXHJcblx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgdGhpcy5sYXN0S2V5ZnJhbWUgXSA9IDA7XHJcblx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgdGhpcy5jdXJyZW50S2V5ZnJhbWUgXSA9IDE7XHJcblxyXG5cdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGtleWZyYW1lIF0gPSAwO1xyXG5cclxuXHRcdHRoaXMubGFzdEtleWZyYW1lID0gdGhpcy5jdXJyZW50S2V5ZnJhbWU7XHJcblx0XHR0aGlzLmN1cnJlbnRLZXlmcmFtZSA9IGtleWZyYW1lO1xyXG5cclxuXHR9XHJcblxyXG5cdHZhciBtaXggPSAoIHRoaXMudGltZSAlIGZyYW1lVGltZSApIC8gZnJhbWVUaW1lO1xyXG5cclxuXHRpZiAoIHRoaXMuZGlyZWN0aW9uQmFja3dhcmRzICkge1xyXG5cclxuXHRcdG1peCA9IDEgLSBtaXg7XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIHRoaXMuY3VycmVudEtleWZyYW1lIF0gPSBtaXg7XHJcblx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIHRoaXMubGFzdEtleWZyYW1lIF0gPSAxIC0gbWl4O1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG5cdGlmICggb2JqZWN0ID09PSB1bmRlZmluZWQgKSBvYmplY3QgPSBuZXcgVEhSRUUuTW9ycGhBbmltTWVzaCggdGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCApO1xyXG5cclxuXHRvYmplY3QuZHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uO1xyXG5cdG9iamVjdC5taXJyb3JlZExvb3AgPSB0aGlzLm1pcnJvcmVkTG9vcDtcclxuXHRvYmplY3QudGltZSA9IHRoaXMudGltZTtcclxuXHJcblx0b2JqZWN0Lmxhc3RLZXlmcmFtZSA9IHRoaXMubGFzdEtleWZyYW1lO1xyXG5cdG9iamVjdC5jdXJyZW50S2V5ZnJhbWUgPSB0aGlzLmN1cnJlbnRLZXlmcmFtZTtcclxuXHJcblx0b2JqZWN0LmRpcmVjdGlvbiA9IHRoaXMuZGlyZWN0aW9uO1xyXG5cdG9iamVjdC5kaXJlY3Rpb25CYWNrd2FyZHMgPSB0aGlzLmRpcmVjdGlvbkJhY2t3YXJkcztcclxuXHJcblx0VEhSRUUuTWVzaC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgb2JqZWN0ICk7XHJcblxyXG5cdHJldHVybiBvYmplY3Q7XHJcblxyXG59O1xyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5SaWJib24gPSBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcclxuXHJcblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XHJcblx0dGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlJpYmJvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLlJpYmJvbi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcblx0aWYgKCBvYmplY3QgPT09IHVuZGVmaW5lZCApIG9iamVjdCA9IG5ldyBUSFJFRS5SaWJib24oIHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwgKTtcclxuXHJcblx0VEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIG9iamVjdCApO1xyXG5cclxuXHRyZXR1cm4gb2JqZWN0O1xyXG5cclxufTtcclxuLyoqXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTE9EID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMuTE9EcyA9IFtdO1xyXG5cclxufTtcclxuXHJcblxyXG5USFJFRS5MT0QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5MT0QucHJvdG90eXBlLmFkZExldmVsID0gZnVuY3Rpb24gKCBvYmplY3QzRCwgdmlzaWJsZUF0RGlzdGFuY2UgKSB7XHJcblxyXG5cdGlmICggdmlzaWJsZUF0RGlzdGFuY2UgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHR2aXNpYmxlQXREaXN0YW5jZSA9IDA7XHJcblxyXG5cdH1cclxuXHJcblx0dmlzaWJsZUF0RGlzdGFuY2UgPSBNYXRoLmFicyggdmlzaWJsZUF0RGlzdGFuY2UgKTtcclxuXHJcblx0Zm9yICggdmFyIGwgPSAwOyBsIDwgdGhpcy5MT0RzLmxlbmd0aDsgbCArKyApIHtcclxuXHJcblx0XHRpZiAoIHZpc2libGVBdERpc3RhbmNlIDwgdGhpcy5MT0RzWyBsIF0udmlzaWJsZUF0RGlzdGFuY2UgKSB7XHJcblxyXG5cdFx0XHRicmVhaztcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5MT0RzLnNwbGljZSggbCwgMCwgeyB2aXNpYmxlQXREaXN0YW5jZTogdmlzaWJsZUF0RGlzdGFuY2UsIG9iamVjdDNEOiBvYmplY3QzRCB9ICk7XHJcblx0dGhpcy5hZGQoIG9iamVjdDNEICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTE9ELnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoIGNhbWVyYSApIHtcclxuXHJcblx0aWYgKCB0aGlzLkxPRHMubGVuZ3RoID4gMSApIHtcclxuXHJcblx0XHRjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLmdldEludmVyc2UoIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdHZhciBpbnZlcnNlICA9IGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2U7XHJcblx0XHR2YXIgZGlzdGFuY2UgPSAtKCBpbnZlcnNlLmVsZW1lbnRzWzJdICogdGhpcy5tYXRyaXhXb3JsZC5lbGVtZW50c1sxMl0gKyBpbnZlcnNlLmVsZW1lbnRzWzZdICogdGhpcy5tYXRyaXhXb3JsZC5lbGVtZW50c1sxM10gKyBpbnZlcnNlLmVsZW1lbnRzWzEwXSAqIHRoaXMubWF0cml4V29ybGQuZWxlbWVudHNbMTRdICsgaW52ZXJzZS5lbGVtZW50c1sxNF0gKTtcclxuXHJcblx0XHR0aGlzLkxPRHNbIDAgXS5vYmplY3QzRC52aXNpYmxlID0gdHJ1ZTtcclxuXHJcblx0XHRmb3IgKCB2YXIgbCA9IDE7IGwgPCB0aGlzLkxPRHMubGVuZ3RoOyBsICsrICkge1xyXG5cclxuXHRcdFx0aWYoIGRpc3RhbmNlID49IHRoaXMuTE9Ec1sgbCBdLnZpc2libGVBdERpc3RhbmNlICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLkxPRHNbIGwgLSAxIF0ub2JqZWN0M0QudmlzaWJsZSA9IGZhbHNlO1xyXG5cdFx0XHRcdHRoaXMuTE9Ec1sgbCAgICAgXS5vYmplY3QzRC52aXNpYmxlID0gdHJ1ZTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IoIDsgbCA8IHRoaXMuTE9Ecy5sZW5ndGg7IGwgKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLkxPRHNbIGwgXS5vYmplY3QzRC52aXNpYmxlID0gZmFsc2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTE9ELnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0Ly8gVE9ET1xyXG5cclxufTtcclxuLyoqXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuU3ByaXRlID0gZnVuY3Rpb24gKCBtYXRlcmlhbCApIHtcclxuXHJcblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLm1hdGVyaWFsID0gKCBtYXRlcmlhbCAhPT0gdW5kZWZpbmVkICkgPyBtYXRlcmlhbCA6IG5ldyBUSFJFRS5TcHJpdGVNYXRlcmlhbCgpO1xyXG5cclxuXHR0aGlzLnJvdGF0aW9uM2QgPSB0aGlzLnJvdGF0aW9uO1xyXG5cdHRoaXMucm90YXRpb24gPSAwO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlNwcml0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuXHJcbi8qXHJcbiAqIEN1c3RvbSB1cGRhdGUgbWF0cml4XHJcbiAqL1xyXG5cclxuVEhSRUUuU3ByaXRlLnByb3RvdHlwZS51cGRhdGVNYXRyaXggPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHRoaXMubWF0cml4LnNldFBvc2l0aW9uKCB0aGlzLnBvc2l0aW9uICk7XHJcblxyXG5cdHRoaXMucm90YXRpb24zZC5zZXQoIDAsIDAsIHRoaXMucm90YXRpb24gKTtcclxuXHR0aGlzLm1hdHJpeC5zZXRSb3RhdGlvbkZyb21FdWxlciggdGhpcy5yb3RhdGlvbjNkICk7XHJcblxyXG5cdGlmICggdGhpcy5zY2FsZS54ICE9PSAxIHx8IHRoaXMuc2NhbGUueSAhPT0gMSApIHtcclxuXHJcblx0XHR0aGlzLm1hdHJpeC5zY2FsZSggdGhpcy5zY2FsZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU3ByaXRlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuXHRpZiAoIG9iamVjdCA9PT0gdW5kZWZpbmVkICkgb2JqZWN0ID0gbmV3IFRIUkVFLlNwcml0ZSggdGhpcy5tYXRlcmlhbCApO1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgb2JqZWN0ICk7XHJcblxyXG5cdHJldHVybiBvYmplY3Q7XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuU2NlbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy5mb2cgPSBudWxsO1xyXG5cdHRoaXMub3ZlcnJpZGVNYXRlcmlhbCA9IG51bGw7XHJcblxyXG5cdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHR0aGlzLl9fb2JqZWN0cyA9IFtdO1xyXG5cdHRoaXMuX19saWdodHMgPSBbXTtcclxuXHJcblx0dGhpcy5fX29iamVjdHNBZGRlZCA9IFtdO1xyXG5cdHRoaXMuX19vYmplY3RzUmVtb3ZlZCA9IFtdO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlNjZW5lLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuU2NlbmUucHJvdG90eXBlLl9fYWRkT2JqZWN0ID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG5cdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGlnaHQgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLl9fbGlnaHRzLmluZGV4T2YoIG9iamVjdCApID09PSAtIDEgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl9fbGlnaHRzLnB1c2goIG9iamVjdCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG9iamVjdC50YXJnZXQgJiYgb2JqZWN0LnRhcmdldC5wYXJlbnQgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHRoaXMuYWRkKCBvYmplY3QudGFyZ2V0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9IGVsc2UgaWYgKCAhKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5DYW1lcmEgfHwgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuQm9uZSApICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5fX29iamVjdHMuaW5kZXhPZiggb2JqZWN0ICkgPT09IC0gMSApIHtcclxuXHJcblx0XHRcdHRoaXMuX19vYmplY3RzLnB1c2goIG9iamVjdCApO1xyXG5cdFx0XHR0aGlzLl9fb2JqZWN0c0FkZGVkLnB1c2goIG9iamVjdCApO1xyXG5cclxuXHRcdFx0Ly8gY2hlY2sgaWYgcHJldmlvdXNseSByZW1vdmVkXHJcblxyXG5cdFx0XHR2YXIgaSA9IHRoaXMuX19vYmplY3RzUmVtb3ZlZC5pbmRleE9mKCBvYmplY3QgKTtcclxuXHJcblx0XHRcdGlmICggaSAhPT0gLTEgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX19vYmplY3RzUmVtb3ZlZC5zcGxpY2UoIGksIDEgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Zm9yICggdmFyIGMgPSAwOyBjIDwgb2JqZWN0LmNoaWxkcmVuLmxlbmd0aDsgYyArKyApIHtcclxuXHJcblx0XHR0aGlzLl9fYWRkT2JqZWN0KCBvYmplY3QuY2hpbGRyZW5bIGMgXSApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU2NlbmUucHJvdG90eXBlLl9fcmVtb3ZlT2JqZWN0ID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG5cdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGlnaHQgKSB7XHJcblxyXG5cdFx0dmFyIGkgPSB0aGlzLl9fbGlnaHRzLmluZGV4T2YoIG9iamVjdCApO1xyXG5cclxuXHRcdGlmICggaSAhPT0gLTEgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl9fbGlnaHRzLnNwbGljZSggaSwgMSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSBlbHNlIGlmICggISggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuQ2FtZXJhICkgKSB7XHJcblxyXG5cdFx0dmFyIGkgPSB0aGlzLl9fb2JqZWN0cy5pbmRleE9mKCBvYmplY3QgKTtcclxuXHJcblx0XHRpZiggaSAhPT0gLTEgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl9fb2JqZWN0cy5zcGxpY2UoIGksIDEgKTtcclxuXHRcdFx0dGhpcy5fX29iamVjdHNSZW1vdmVkLnB1c2goIG9iamVjdCApO1xyXG5cclxuXHRcdFx0Ly8gY2hlY2sgaWYgcHJldmlvdXNseSBhZGRlZFxyXG5cclxuXHRcdFx0dmFyIGFpID0gdGhpcy5fX29iamVjdHNBZGRlZC5pbmRleE9mKCBvYmplY3QgKTtcclxuXHJcblx0XHRcdGlmICggYWkgIT09IC0xICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLl9fb2JqZWN0c0FkZGVkLnNwbGljZSggYWksIDEgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Zm9yICggdmFyIGMgPSAwOyBjIDwgb2JqZWN0LmNoaWxkcmVuLmxlbmd0aDsgYyArKyApIHtcclxuXHJcblx0XHR0aGlzLl9fcmVtb3ZlT2JqZWN0KCBvYmplY3QuY2hpbGRyZW5bIGMgXSApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5Gb2cgPSBmdW5jdGlvbiAoIGhleCwgbmVhciwgZmFyICkge1xyXG5cclxuXHR0aGlzLm5hbWUgPSAnJztcclxuXHJcblx0dGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggaGV4ICk7XHJcblxyXG5cdHRoaXMubmVhciA9ICggbmVhciAhPT0gdW5kZWZpbmVkICkgPyBuZWFyIDogMTtcclxuXHR0aGlzLmZhciA9ICggZmFyICE9PSB1bmRlZmluZWQgKSA/IGZhciA6IDEwMDA7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRm9nLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0cmV0dXJuIG5ldyBUSFJFRS5Gb2coIHRoaXMuY29sb3IuZ2V0SGV4KCksIHRoaXMubmVhciwgdGhpcy5mYXIgKTtcclxuXHJcbn07XHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkZvZ0V4cDIgPSBmdW5jdGlvbiAoIGhleCwgZGVuc2l0eSApIHtcclxuXHJcblx0dGhpcy5uYW1lID0gJyc7XHJcblx0dGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggaGV4ICk7XHJcblx0dGhpcy5kZW5zaXR5ID0gKCBkZW5zaXR5ICE9PSB1bmRlZmluZWQgKSA/IGRlbnNpdHkgOiAwLjAwMDI1O1xyXG5cclxufTtcclxuXHJcblRIUkVFLkZvZ0V4cDIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRyZXR1cm4gbmV3IFRIUkVFLkZvZ0V4cDIoIHRoaXMuY29sb3IuZ2V0SGV4KCksIHRoaXMuZGVuc2l0eSApO1xyXG5cclxufTtcclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQ2FudmFzUmVuZGVyZXIgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdGNvbnNvbGUubG9nKCAnVEhSRUUuQ2FudmFzUmVuZGVyZXInLCBUSFJFRS5SRVZJU0lPTiApO1xyXG5cclxuXHR2YXIgc21vb3Roc3RlcCA9IFRIUkVFLk1hdGguc21vb3Roc3RlcDtcclxuXHJcblx0cGFyYW1ldGVycyA9IHBhcmFtZXRlcnMgfHwge307XHJcblxyXG5cdHZhciBfdGhpcyA9IHRoaXMsXHJcblx0X3JlbmRlckRhdGEsIF9lbGVtZW50cywgX2xpZ2h0cyxcclxuXHRfcHJvamVjdG9yID0gbmV3IFRIUkVFLlByb2plY3RvcigpLFxyXG5cclxuXHRfY2FudmFzID0gcGFyYW1ldGVycy5jYW52YXMgIT09IHVuZGVmaW5lZFxyXG5cdFx0XHQ/IHBhcmFtZXRlcnMuY2FudmFzXHJcblx0XHRcdDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKSxcclxuXHJcblx0X2NhbnZhc1dpZHRoLCBfY2FudmFzSGVpZ2h0LCBfY2FudmFzV2lkdGhIYWxmLCBfY2FudmFzSGVpZ2h0SGFsZixcclxuXHRfY29udGV4dCA9IF9jYW52YXMuZ2V0Q29udGV4dCggJzJkJyApLFxyXG5cclxuXHRfY2xlYXJDb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHgwMDAwMDAgKSxcclxuXHRfY2xlYXJPcGFjaXR5ID0gMCxcclxuXHJcblx0X2NvbnRleHRHbG9iYWxBbHBoYSA9IDEsXHJcblx0X2NvbnRleHRHbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAwLFxyXG5cdF9jb250ZXh0U3Ryb2tlU3R5bGUgPSBudWxsLFxyXG5cdF9jb250ZXh0RmlsbFN0eWxlID0gbnVsbCxcclxuXHRfY29udGV4dExpbmVXaWR0aCA9IG51bGwsXHJcblx0X2NvbnRleHRMaW5lQ2FwID0gbnVsbCxcclxuXHRfY29udGV4dExpbmVKb2luID0gbnVsbCxcclxuXHRfY29udGV4dERhc2hTaXplID0gbnVsbCxcclxuXHRfY29udGV4dEdhcFNpemUgPSAwLFxyXG5cclxuXHRfdjEsIF92MiwgX3YzLCBfdjQsXHJcblx0X3Y1ID0gbmV3IFRIUkVFLlJlbmRlcmFibGVWZXJ0ZXgoKSxcclxuXHRfdjYgPSBuZXcgVEhSRUUuUmVuZGVyYWJsZVZlcnRleCgpLFxyXG5cclxuXHRfdjF4LCBfdjF5LCBfdjJ4LCBfdjJ5LCBfdjN4LCBfdjN5LFxyXG5cdF92NHgsIF92NHksIF92NXgsIF92NXksIF92NngsIF92NnksXHJcblxyXG5cdF9jb2xvciA9IG5ldyBUSFJFRS5Db2xvcigpLFxyXG5cdF9jb2xvcjEgPSBuZXcgVEhSRUUuQ29sb3IoKSxcclxuXHRfY29sb3IyID0gbmV3IFRIUkVFLkNvbG9yKCksXHJcblx0X2NvbG9yMyA9IG5ldyBUSFJFRS5Db2xvcigpLFxyXG5cdF9jb2xvcjQgPSBuZXcgVEhSRUUuQ29sb3IoKSxcclxuXHJcblx0X2RpZmZ1c2VDb2xvciA9IG5ldyBUSFJFRS5Db2xvcigpLFxyXG5cdF9lbWlzc2l2ZUNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCksXHJcblxyXG5cdF9saWdodENvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCksXHJcblxyXG5cdF9wYXR0ZXJucyA9IHt9LCBfaW1hZ2VkYXRhcyA9IHt9LFxyXG5cclxuXHRfbmVhciwgX2ZhcixcclxuXHJcblx0X2ltYWdlLCBfdXZzLFxyXG5cdF91djF4LCBfdXYxeSwgX3V2MngsIF91djJ5LCBfdXYzeCwgX3V2M3ksXHJcblxyXG5cdF9jbGlwQm94ID0gbmV3IFRIUkVFLkJveDIoKSxcclxuXHRfY2xlYXJCb3ggPSBuZXcgVEhSRUUuQm94MigpLFxyXG5cdF9lbGVtQm94ID0gbmV3IFRIUkVFLkJveDIoKSxcclxuXHJcblx0X2VuYWJsZUxpZ2h0aW5nID0gZmFsc2UsXHJcblx0X2FtYmllbnRMaWdodCA9IG5ldyBUSFJFRS5Db2xvcigpLFxyXG5cdF9kaXJlY3Rpb25hbExpZ2h0cyA9IG5ldyBUSFJFRS5Db2xvcigpLFxyXG5cdF9wb2ludExpZ2h0cyA9IG5ldyBUSFJFRS5Db2xvcigpLFxyXG5cclxuXHRfdmVjdG9yMyA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIC8vIE5lZWRlZCBmb3IgUG9pbnRMaWdodFxyXG5cclxuXHRfcGl4ZWxNYXAsIF9waXhlbE1hcENvbnRleHQsIF9waXhlbE1hcEltYWdlLCBfcGl4ZWxNYXBEYXRhLFxyXG5cdF9ncmFkaWVudE1hcCwgX2dyYWRpZW50TWFwQ29udGV4dCwgX2dyYWRpZW50TWFwUXVhbGl0eSA9IDE2O1xyXG5cclxuXHRfcGl4ZWxNYXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApO1xyXG5cdF9waXhlbE1hcC53aWR0aCA9IF9waXhlbE1hcC5oZWlnaHQgPSAyO1xyXG5cclxuXHRfcGl4ZWxNYXBDb250ZXh0ID0gX3BpeGVsTWFwLmdldENvbnRleHQoICcyZCcgKTtcclxuXHRfcGl4ZWxNYXBDb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKDAsMCwwLDEpJztcclxuXHRfcGl4ZWxNYXBDb250ZXh0LmZpbGxSZWN0KCAwLCAwLCAyLCAyICk7XHJcblxyXG5cdF9waXhlbE1hcEltYWdlID0gX3BpeGVsTWFwQ29udGV4dC5nZXRJbWFnZURhdGEoIDAsIDAsIDIsIDIgKTtcclxuXHRfcGl4ZWxNYXBEYXRhID0gX3BpeGVsTWFwSW1hZ2UuZGF0YTtcclxuXHJcblx0X2dyYWRpZW50TWFwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKTtcclxuXHRfZ3JhZGllbnRNYXAud2lkdGggPSBfZ3JhZGllbnRNYXAuaGVpZ2h0ID0gX2dyYWRpZW50TWFwUXVhbGl0eTtcclxuXHJcblx0X2dyYWRpZW50TWFwQ29udGV4dCA9IF9ncmFkaWVudE1hcC5nZXRDb250ZXh0KCAnMmQnICk7XHJcblx0X2dyYWRpZW50TWFwQ29udGV4dC50cmFuc2xhdGUoIC0gX2dyYWRpZW50TWFwUXVhbGl0eSAvIDIsIC0gX2dyYWRpZW50TWFwUXVhbGl0eSAvIDIgKTtcclxuXHRfZ3JhZGllbnRNYXBDb250ZXh0LnNjYWxlKCBfZ3JhZGllbnRNYXBRdWFsaXR5LCBfZ3JhZGllbnRNYXBRdWFsaXR5ICk7XHJcblxyXG5cdF9ncmFkaWVudE1hcFF1YWxpdHkgLS07IC8vIEZpeCBVVnNcclxuXHJcblx0Ly8gZGFzaCtnYXAgZmFsbGJhY2tzIGZvciBGaXJlZm94IGFuZCBldmVyeXRoaW5nIGVsc2VcclxuXHJcblx0aWYgKCBfY29udGV4dC5zZXRMaW5lRGFzaCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdGlmICggX2NvbnRleHQubW96RGFzaCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0X2NvbnRleHQuc2V0TGluZURhc2ggPSBmdW5jdGlvbiAoIHZhbHVlcyApIHtcclxuXHJcblx0XHRcdFx0X2NvbnRleHQubW96RGFzaCA9IHZhbHVlc1sgMCBdICE9PSBudWxsID8gdmFsdWVzIDogbnVsbDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0X2NvbnRleHQuc2V0TGluZURhc2ggPSBmdW5jdGlvbiAoKSB7fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLmRvbUVsZW1lbnQgPSBfY2FudmFzO1xyXG5cclxuXHR0aGlzLmRldmljZVBpeGVsUmF0aW8gPSBwYXJhbWV0ZXJzLmRldmljZVBpeGVsUmF0aW8gIT09IHVuZGVmaW5lZFxyXG5cdFx0XHRcdD8gcGFyYW1ldGVycy5kZXZpY2VQaXhlbFJhdGlvXHJcblx0XHRcdFx0OiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyAhPT0gdW5kZWZpbmVkXHJcblx0XHRcdFx0XHQ/IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvXHJcblx0XHRcdFx0XHQ6IDE7XHJcblxyXG5cdHRoaXMuYXV0b0NsZWFyID0gdHJ1ZTtcclxuXHR0aGlzLnNvcnRPYmplY3RzID0gdHJ1ZTtcclxuXHR0aGlzLnNvcnRFbGVtZW50cyA9IHRydWU7XHJcblxyXG5cdHRoaXMuaW5mbyA9IHtcclxuXHJcblx0XHRyZW5kZXI6IHtcclxuXHJcblx0XHRcdHZlcnRpY2VzOiAwLFxyXG5cdFx0XHRmYWNlczogMFxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvLyBXZWJHTFJlbmRlcmVyIGNvbXBhdGliaWxpdHlcclxuXHJcblx0dGhpcy5zdXBwb3J0c1ZlcnRleFRleHR1cmVzID0gZnVuY3Rpb24gKCkge307XHJcblx0dGhpcy5zZXRGYWNlQ3VsbGluZyA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cclxuXHR0aGlzLnNldFNpemUgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQgKSB7XHJcblxyXG5cdFx0X2NhbnZhc1dpZHRoID0gd2lkdGggKiB0aGlzLmRldmljZVBpeGVsUmF0aW87XHJcblx0XHRfY2FudmFzSGVpZ2h0ID0gaGVpZ2h0ICogdGhpcy5kZXZpY2VQaXhlbFJhdGlvO1xyXG5cclxuXHRcdF9jYW52YXNXaWR0aEhhbGYgPSBNYXRoLmZsb29yKCBfY2FudmFzV2lkdGggLyAyICk7XHJcblx0XHRfY2FudmFzSGVpZ2h0SGFsZiA9IE1hdGguZmxvb3IoIF9jYW52YXNIZWlnaHQgLyAyICk7XHJcblxyXG5cdFx0X2NhbnZhcy53aWR0aCA9IF9jYW52YXNXaWR0aDtcclxuXHRcdF9jYW52YXMuaGVpZ2h0ID0gX2NhbnZhc0hlaWdodDtcclxuXHJcblx0XHRfY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xyXG5cdFx0X2NhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xyXG5cclxuXHRcdF9jbGlwQm94LnNldChcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIC0gX2NhbnZhc1dpZHRoSGFsZiwgLSBfY2FudmFzSGVpZ2h0SGFsZiApLFxyXG5cdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggX2NhbnZhc1dpZHRoSGFsZiwgX2NhbnZhc0hlaWdodEhhbGYgKVxyXG5cdFx0KTtcclxuXHJcblx0XHRfY2xlYXJCb3guc2V0KFxyXG5cdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggLSBfY2FudmFzV2lkdGhIYWxmLCAtIF9jYW52YXNIZWlnaHRIYWxmICksXHJcblx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBfY2FudmFzV2lkdGhIYWxmLCBfY2FudmFzSGVpZ2h0SGFsZiApXHJcblx0XHQpO1xyXG5cclxuXHRcdF9jb250ZXh0R2xvYmFsQWxwaGEgPSAxO1xyXG5cdFx0X2NvbnRleHRHbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAwO1xyXG5cdFx0X2NvbnRleHRTdHJva2VTdHlsZSA9IG51bGw7XHJcblx0XHRfY29udGV4dEZpbGxTdHlsZSA9IG51bGw7XHJcblx0XHRfY29udGV4dExpbmVXaWR0aCA9IG51bGw7XHJcblx0XHRfY29udGV4dExpbmVDYXAgPSBudWxsO1xyXG5cdFx0X2NvbnRleHRMaW5lSm9pbiA9IG51bGw7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuc2V0Q2xlYXJDb2xvciA9IGZ1bmN0aW9uICggY29sb3IsIG9wYWNpdHkgKSB7XHJcblxyXG5cdFx0X2NsZWFyQ29sb3IuY29weSggY29sb3IgKTtcclxuXHRcdF9jbGVhck9wYWNpdHkgPSBvcGFjaXR5ICE9PSB1bmRlZmluZWQgPyBvcGFjaXR5IDogMTtcclxuXHJcblx0XHRfY2xlYXJCb3guc2V0KFxyXG5cdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggLSBfY2FudmFzV2lkdGhIYWxmLCAtIF9jYW52YXNIZWlnaHRIYWxmICksXHJcblx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBfY2FudmFzV2lkdGhIYWxmLCBfY2FudmFzSGVpZ2h0SGFsZiApXHJcblx0XHQpO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnNldENsZWFyQ29sb3JIZXggPSBmdW5jdGlvbiAoIGhleCwgb3BhY2l0eSApIHtcclxuXHJcblx0XHRfY2xlYXJDb2xvci5zZXRIZXgoIGhleCApO1xyXG5cdFx0X2NsZWFyT3BhY2l0eSA9IG9wYWNpdHkgIT09IHVuZGVmaW5lZCA/IG9wYWNpdHkgOiAxO1xyXG5cclxuXHRcdF9jbGVhckJveC5zZXQoXHJcblx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCAtIF9jYW52YXNXaWR0aEhhbGYsIC0gX2NhbnZhc0hlaWdodEhhbGYgKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIF9jYW52YXNXaWR0aEhhbGYsIF9jYW52YXNIZWlnaHRIYWxmIClcclxuXHRcdCk7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuZ2V0TWF4QW5pc290cm9weSAgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIDA7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0X2NvbnRleHQuc2V0VHJhbnNmb3JtKCAxLCAwLCAwLCAtIDEsIF9jYW52YXNXaWR0aEhhbGYsIF9jYW52YXNIZWlnaHRIYWxmICk7XHJcblxyXG5cdFx0aWYgKCBfY2xlYXJCb3guZW1wdHkoKSA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRfY2xlYXJCb3guaW50ZXJzZWN0KCBfY2xpcEJveCApO1xyXG5cdFx0XHRfY2xlYXJCb3guZXhwYW5kQnlTY2FsYXIoIDIgKTtcclxuXHJcblx0XHRcdGlmICggX2NsZWFyT3BhY2l0eSA8IDEgKSB7XHJcblxyXG5cdFx0XHRcdF9jb250ZXh0LmNsZWFyUmVjdChcclxuXHRcdFx0XHRcdF9jbGVhckJveC5taW4ueCB8IDAsXHJcblx0XHRcdFx0XHRfY2xlYXJCb3gubWluLnkgfCAwLFxyXG5cdFx0XHRcdFx0KCBfY2xlYXJCb3gubWF4LnggLSBfY2xlYXJCb3gubWluLnggKSB8IDAsXHJcblx0XHRcdFx0XHQoIF9jbGVhckJveC5tYXgueSAtIF9jbGVhckJveC5taW4ueSApIHwgMFxyXG5cdFx0XHRcdCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIF9jbGVhck9wYWNpdHkgPiAwICkge1xyXG5cclxuXHRcdFx0XHRzZXRCbGVuZGluZyggVEhSRUUuTm9ybWFsQmxlbmRpbmcgKTtcclxuXHRcdFx0XHRzZXRPcGFjaXR5KCAxICk7XHJcblxyXG5cdFx0XHRcdHNldEZpbGxTdHlsZSggJ3JnYmEoJyArIE1hdGguZmxvb3IoIF9jbGVhckNvbG9yLnIgKiAyNTUgKSArICcsJyArIE1hdGguZmxvb3IoIF9jbGVhckNvbG9yLmcgKiAyNTUgKSArICcsJyArIE1hdGguZmxvb3IoIF9jbGVhckNvbG9yLmIgKiAyNTUgKSArICcsJyArIF9jbGVhck9wYWNpdHkgKyAnKScgKTtcclxuXHJcblx0XHRcdFx0X2NvbnRleHQuZmlsbFJlY3QoXHJcblx0XHRcdFx0XHRfY2xlYXJCb3gubWluLnggfCAwLFxyXG5cdFx0XHRcdFx0X2NsZWFyQm94Lm1pbi55IHwgMCxcclxuXHRcdFx0XHRcdCggX2NsZWFyQm94Lm1heC54IC0gX2NsZWFyQm94Lm1pbi54ICkgfCAwLFxyXG5cdFx0XHRcdFx0KCBfY2xlYXJCb3gubWF4LnkgLSBfY2xlYXJCb3gubWluLnkgKSB8IDBcclxuXHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0X2NsZWFyQm94Lm1ha2VFbXB0eSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCBzY2VuZSwgY2FtZXJhICkge1xyXG5cclxuXHRcdGlmICggY2FtZXJhIGluc3RhbmNlb2YgVEhSRUUuQ2FtZXJhID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5DYW52YXNSZW5kZXJlci5yZW5kZXI6IGNhbWVyYSBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuQ2FtZXJhLicgKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMuYXV0b0NsZWFyID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0dGhpcy5jbGVhcigpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRfY29udGV4dC5zZXRUcmFuc2Zvcm0oIDEsIDAsIDAsIC0gMSwgX2NhbnZhc1dpZHRoSGFsZiwgX2NhbnZhc0hlaWdodEhhbGYgKTtcclxuXHJcblx0XHRfdGhpcy5pbmZvLnJlbmRlci52ZXJ0aWNlcyA9IDA7XHJcblx0XHRfdGhpcy5pbmZvLnJlbmRlci5mYWNlcyA9IDA7XHJcblxyXG5cdFx0X3JlbmRlckRhdGEgPSBfcHJvamVjdG9yLnByb2plY3RTY2VuZSggc2NlbmUsIGNhbWVyYSwgdGhpcy5zb3J0T2JqZWN0cywgdGhpcy5zb3J0RWxlbWVudHMgKTtcclxuXHRcdF9lbGVtZW50cyA9IF9yZW5kZXJEYXRhLmVsZW1lbnRzO1xyXG5cdFx0X2xpZ2h0cyA9IF9yZW5kZXJEYXRhLmxpZ2h0cztcclxuXHJcblx0XHQvKiBERUJVR1xyXG5cdFx0c2V0RmlsbFN0eWxlKCAncmdiYSggMCwgMjU1LCAyNTUsIDAuNSApJyApO1xyXG5cdFx0X2NvbnRleHQuZmlsbFJlY3QoIF9jbGlwQm94Lm1pbi54LCBfY2xpcEJveC5taW4ueSwgX2NsaXBCb3gubWF4LnggLSBfY2xpcEJveC5taW4ueCwgX2NsaXBCb3gubWF4LnkgLSBfY2xpcEJveC5taW4ueSApO1xyXG5cdFx0Ki9cclxuXHJcblx0XHRfZW5hYmxlTGlnaHRpbmcgPSBfbGlnaHRzLmxlbmd0aCA+IDA7XHJcblxyXG5cdFx0aWYgKCBfZW5hYmxlTGlnaHRpbmcgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHQgY2FsY3VsYXRlTGlnaHRzKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIHZhciBlID0gMCwgZWwgPSBfZWxlbWVudHMubGVuZ3RoOyBlIDwgZWw7IGUrKyApIHtcclxuXHJcblx0XHRcdHZhciBlbGVtZW50ID0gX2VsZW1lbnRzWyBlIF07XHJcblxyXG5cdFx0XHR2YXIgbWF0ZXJpYWwgPSBlbGVtZW50Lm1hdGVyaWFsO1xyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbCA9PT0gdW5kZWZpbmVkIHx8IG1hdGVyaWFsLnZpc2libGUgPT09IGZhbHNlICkgY29udGludWU7XHJcblxyXG5cdFx0XHRfZWxlbUJveC5tYWtlRW1wdHkoKTtcclxuXHJcblx0XHRcdGlmICggZWxlbWVudCBpbnN0YW5jZW9mIFRIUkVFLlJlbmRlcmFibGVQYXJ0aWNsZSApIHtcclxuXHJcblx0XHRcdFx0X3YxID0gZWxlbWVudDtcclxuXHRcdFx0XHRfdjEueCAqPSBfY2FudmFzV2lkdGhIYWxmOyBfdjEueSAqPSBfY2FudmFzSGVpZ2h0SGFsZjtcclxuXHJcblx0XHRcdFx0cmVuZGVyUGFydGljbGUoIF92MSwgZWxlbWVudCwgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGVsZW1lbnQgaW5zdGFuY2VvZiBUSFJFRS5SZW5kZXJhYmxlTGluZSApIHtcclxuXHJcblx0XHRcdFx0X3YxID0gZWxlbWVudC52MTsgX3YyID0gZWxlbWVudC52MjtcclxuXHJcblx0XHRcdFx0X3YxLnBvc2l0aW9uU2NyZWVuLnggKj0gX2NhbnZhc1dpZHRoSGFsZjsgX3YxLnBvc2l0aW9uU2NyZWVuLnkgKj0gX2NhbnZhc0hlaWdodEhhbGY7XHJcblx0XHRcdFx0X3YyLnBvc2l0aW9uU2NyZWVuLnggKj0gX2NhbnZhc1dpZHRoSGFsZjsgX3YyLnBvc2l0aW9uU2NyZWVuLnkgKj0gX2NhbnZhc0hlaWdodEhhbGY7XHJcblxyXG5cdFx0XHRcdF9lbGVtQm94LnNldEZyb21Qb2ludHMoIFsgX3YxLnBvc2l0aW9uU2NyZWVuLCBfdjIucG9zaXRpb25TY3JlZW4gXSApO1xyXG5cclxuXHRcdFx0XHRpZiAoIF9jbGlwQm94LmlzSW50ZXJzZWN0aW9uQm94KCBfZWxlbUJveCApID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRcdHJlbmRlckxpbmUoIF92MSwgX3YyLCBlbGVtZW50LCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBlbGVtZW50IGluc3RhbmNlb2YgVEhSRUUuUmVuZGVyYWJsZUZhY2UzICkge1xyXG5cclxuXHRcdFx0XHRfdjEgPSBlbGVtZW50LnYxOyBfdjIgPSBlbGVtZW50LnYyOyBfdjMgPSBlbGVtZW50LnYzO1xyXG5cclxuXHRcdFx0XHRpZiAoIF92MS5wb3NpdGlvblNjcmVlbi56IDwgLTEgfHwgX3YxLnBvc2l0aW9uU2NyZWVuLnogPiAxICkgY29udGludWU7XHJcblx0XHRcdFx0aWYgKCBfdjIucG9zaXRpb25TY3JlZW4ueiA8IC0xIHx8IF92Mi5wb3NpdGlvblNjcmVlbi56ID4gMSApIGNvbnRpbnVlO1xyXG5cdFx0XHRcdGlmICggX3YzLnBvc2l0aW9uU2NyZWVuLnogPCAtMSB8fCBfdjMucG9zaXRpb25TY3JlZW4ueiA+IDEgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0X3YxLnBvc2l0aW9uU2NyZWVuLnggKj0gX2NhbnZhc1dpZHRoSGFsZjsgX3YxLnBvc2l0aW9uU2NyZWVuLnkgKj0gX2NhbnZhc0hlaWdodEhhbGY7XHJcblx0XHRcdFx0X3YyLnBvc2l0aW9uU2NyZWVuLnggKj0gX2NhbnZhc1dpZHRoSGFsZjsgX3YyLnBvc2l0aW9uU2NyZWVuLnkgKj0gX2NhbnZhc0hlaWdodEhhbGY7XHJcblx0XHRcdFx0X3YzLnBvc2l0aW9uU2NyZWVuLnggKj0gX2NhbnZhc1dpZHRoSGFsZjsgX3YzLnBvc2l0aW9uU2NyZWVuLnkgKj0gX2NhbnZhc0hlaWdodEhhbGY7XHJcblxyXG5cdFx0XHRcdGlmICggbWF0ZXJpYWwub3ZlcmRyYXcgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0ZXhwYW5kKCBfdjEucG9zaXRpb25TY3JlZW4sIF92Mi5wb3NpdGlvblNjcmVlbiApO1xyXG5cdFx0XHRcdFx0ZXhwYW5kKCBfdjIucG9zaXRpb25TY3JlZW4sIF92My5wb3NpdGlvblNjcmVlbiApO1xyXG5cdFx0XHRcdFx0ZXhwYW5kKCBfdjMucG9zaXRpb25TY3JlZW4sIF92MS5wb3NpdGlvblNjcmVlbiApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdF9lbGVtQm94LnNldEZyb21Qb2ludHMoIFsgX3YxLnBvc2l0aW9uU2NyZWVuLCBfdjIucG9zaXRpb25TY3JlZW4sIF92My5wb3NpdGlvblNjcmVlbiBdICk7XHJcblxyXG5cdFx0XHRcdHJlbmRlckZhY2UzKCBfdjEsIF92MiwgX3YzLCAwLCAxLCAyLCBlbGVtZW50LCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggZWxlbWVudCBpbnN0YW5jZW9mIFRIUkVFLlJlbmRlcmFibGVGYWNlNCApIHtcclxuXHJcblx0XHRcdFx0X3YxID0gZWxlbWVudC52MTsgX3YyID0gZWxlbWVudC52MjsgX3YzID0gZWxlbWVudC52MzsgX3Y0ID0gZWxlbWVudC52NDtcclxuXHJcblx0XHRcdFx0aWYgKCBfdjEucG9zaXRpb25TY3JlZW4ueiA8IC0xIHx8IF92MS5wb3NpdGlvblNjcmVlbi56ID4gMSApIGNvbnRpbnVlO1xyXG5cdFx0XHRcdGlmICggX3YyLnBvc2l0aW9uU2NyZWVuLnogPCAtMSB8fCBfdjIucG9zaXRpb25TY3JlZW4ueiA+IDEgKSBjb250aW51ZTtcclxuXHRcdFx0XHRpZiAoIF92My5wb3NpdGlvblNjcmVlbi56IDwgLTEgfHwgX3YzLnBvc2l0aW9uU2NyZWVuLnogPiAxICkgY29udGludWU7XHJcblx0XHRcdFx0aWYgKCBfdjQucG9zaXRpb25TY3JlZW4ueiA8IC0xIHx8IF92NC5wb3NpdGlvblNjcmVlbi56ID4gMSApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRfdjEucG9zaXRpb25TY3JlZW4ueCAqPSBfY2FudmFzV2lkdGhIYWxmOyBfdjEucG9zaXRpb25TY3JlZW4ueSAqPSBfY2FudmFzSGVpZ2h0SGFsZjtcclxuXHRcdFx0XHRfdjIucG9zaXRpb25TY3JlZW4ueCAqPSBfY2FudmFzV2lkdGhIYWxmOyBfdjIucG9zaXRpb25TY3JlZW4ueSAqPSBfY2FudmFzSGVpZ2h0SGFsZjtcclxuXHRcdFx0XHRfdjMucG9zaXRpb25TY3JlZW4ueCAqPSBfY2FudmFzV2lkdGhIYWxmOyBfdjMucG9zaXRpb25TY3JlZW4ueSAqPSBfY2FudmFzSGVpZ2h0SGFsZjtcclxuXHRcdFx0XHRfdjQucG9zaXRpb25TY3JlZW4ueCAqPSBfY2FudmFzV2lkdGhIYWxmOyBfdjQucG9zaXRpb25TY3JlZW4ueSAqPSBfY2FudmFzSGVpZ2h0SGFsZjtcclxuXHJcblx0XHRcdFx0X3Y1LnBvc2l0aW9uU2NyZWVuLmNvcHkoIF92Mi5wb3NpdGlvblNjcmVlbiApO1xyXG5cdFx0XHRcdF92Ni5wb3NpdGlvblNjcmVlbi5jb3B5KCBfdjQucG9zaXRpb25TY3JlZW4gKTtcclxuXHJcblx0XHRcdFx0aWYgKCBtYXRlcmlhbC5vdmVyZHJhdyA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0XHRleHBhbmQoIF92MS5wb3NpdGlvblNjcmVlbiwgX3YyLnBvc2l0aW9uU2NyZWVuICk7XHJcblx0XHRcdFx0XHRleHBhbmQoIF92Mi5wb3NpdGlvblNjcmVlbiwgX3Y0LnBvc2l0aW9uU2NyZWVuICk7XHJcblx0XHRcdFx0XHRleHBhbmQoIF92NC5wb3NpdGlvblNjcmVlbiwgX3YxLnBvc2l0aW9uU2NyZWVuICk7XHJcblxyXG5cdFx0XHRcdFx0ZXhwYW5kKCBfdjMucG9zaXRpb25TY3JlZW4sIF92NS5wb3NpdGlvblNjcmVlbiApO1xyXG5cdFx0XHRcdFx0ZXhwYW5kKCBfdjMucG9zaXRpb25TY3JlZW4sIF92Ni5wb3NpdGlvblNjcmVlbiApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdF9lbGVtQm94LnNldEZyb21Qb2ludHMoIFsgX3YxLnBvc2l0aW9uU2NyZWVuLCBfdjIucG9zaXRpb25TY3JlZW4sIF92My5wb3NpdGlvblNjcmVlbiwgX3Y0LnBvc2l0aW9uU2NyZWVuIF0gKTtcclxuXHJcblx0XHRcdFx0cmVuZGVyRmFjZTQoIF92MSwgX3YyLCBfdjMsIF92NCwgX3Y1LCBfdjYsIGVsZW1lbnQsIG1hdGVyaWFsLCBzY2VuZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0LyogREVCVUdcclxuXHRcdFx0c2V0TGluZVdpZHRoKCAxICk7XHJcblx0XHRcdHNldFN0cm9rZVN0eWxlKCAncmdiYSggMCwgMjU1LCAwLCAwLjUgKScgKTtcclxuXHRcdFx0X2NvbnRleHQuc3Ryb2tlUmVjdCggX2VsZW1Cb3gubWluLngsIF9lbGVtQm94Lm1pbi55LCBfZWxlbUJveC5tYXgueCAtIF9lbGVtQm94Lm1pbi54LCBfZWxlbUJveC5tYXgueSAtIF9lbGVtQm94Lm1pbi55ICk7XHJcblx0XHRcdCovXHJcblxyXG5cdFx0XHRfY2xlYXJCb3gudW5pb24oIF9lbGVtQm94ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8qIERFQlVHXHJcblx0XHRzZXRMaW5lV2lkdGgoIDEgKTtcclxuXHRcdHNldFN0cm9rZVN0eWxlKCAncmdiYSggMjU1LCAwLCAwLCAwLjUgKScgKTtcclxuXHRcdF9jb250ZXh0LnN0cm9rZVJlY3QoIF9jbGVhckJveC5taW4ueCwgX2NsZWFyQm94Lm1pbi55LCBfY2xlYXJCb3gubWF4LnggLSBfY2xlYXJCb3gubWluLngsIF9jbGVhckJveC5tYXgueSAtIF9jbGVhckJveC5taW4ueSApO1xyXG5cdFx0Ki9cclxuXHJcblx0XHRfY29udGV4dC5zZXRUcmFuc2Zvcm0oIDEsIDAsIDAsIDEsIDAsIDAgKTtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGZ1bmN0aW9uIGNhbGN1bGF0ZUxpZ2h0cygpIHtcclxuXHJcblx0XHRcdF9hbWJpZW50TGlnaHQuc2V0UkdCKCAwLCAwLCAwICk7XHJcblx0XHRcdF9kaXJlY3Rpb25hbExpZ2h0cy5zZXRSR0IoIDAsIDAsIDAgKTtcclxuXHRcdFx0X3BvaW50TGlnaHRzLnNldFJHQiggMCwgMCwgMCApO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGwgPSAwLCBsbCA9IF9saWdodHMubGVuZ3RoOyBsIDwgbGw7IGwgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBsaWdodCA9IF9saWdodHNbIGwgXTtcclxuXHRcdFx0XHR2YXIgbGlnaHRDb2xvciA9IGxpZ2h0LmNvbG9yO1xyXG5cclxuXHRcdFx0XHRpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuQW1iaWVudExpZ2h0ICkge1xyXG5cclxuXHRcdFx0XHRcdF9hbWJpZW50TGlnaHQuYWRkKCBsaWdodENvbG9yICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCApIHtcclxuXHJcblx0XHRcdFx0XHQvLyBmb3IgcGFydGljbGVzXHJcblxyXG5cdFx0XHRcdFx0X2RpcmVjdGlvbmFsTGlnaHRzLmFkZCggbGlnaHRDb2xvciApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50TGlnaHQgKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gZm9yIHBhcnRpY2xlc1xyXG5cclxuXHRcdFx0XHRcdF9wb2ludExpZ2h0cy5hZGQoIGxpZ2h0Q29sb3IgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBjYWxjdWxhdGVMaWdodCggcG9zaXRpb24sIG5vcm1hbCwgY29sb3IgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgbCA9IDAsIGxsID0gX2xpZ2h0cy5sZW5ndGg7IGwgPCBsbDsgbCArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGxpZ2h0ID0gX2xpZ2h0c1sgbCBdO1xyXG5cclxuXHRcdFx0XHRfbGlnaHRDb2xvci5jb3B5KCBsaWdodC5jb2xvciApO1xyXG5cclxuXHRcdFx0XHRpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgbGlnaHRQb3NpdGlvbiA9IF92ZWN0b3IzLmdldFBvc2l0aW9uRnJvbU1hdHJpeCggbGlnaHQubWF0cml4V29ybGQgKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdFx0XHR2YXIgYW1vdW50ID0gbm9ybWFsLmRvdCggbGlnaHRQb3NpdGlvbiApO1xyXG5cclxuXHRcdFx0XHRcdGlmICggYW1vdW50IDw9IDAgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0XHRhbW91bnQgKj0gbGlnaHQuaW50ZW5zaXR5O1xyXG5cclxuXHRcdFx0XHRcdGNvbG9yLmFkZCggX2xpZ2h0Q29sb3IubXVsdGlwbHlTY2FsYXIoIGFtb3VudCApICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRMaWdodCApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgbGlnaHRQb3NpdGlvbiA9IF92ZWN0b3IzLmdldFBvc2l0aW9uRnJvbU1hdHJpeCggbGlnaHQubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdFx0XHR2YXIgYW1vdW50ID0gbm9ybWFsLmRvdCggX3ZlY3RvcjMuc3ViVmVjdG9ycyggbGlnaHRQb3NpdGlvbiwgcG9zaXRpb24gKS5ub3JtYWxpemUoKSApO1xyXG5cclxuXHRcdFx0XHRcdGlmICggYW1vdW50IDw9IDAgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0XHRhbW91bnQgKj0gbGlnaHQuZGlzdGFuY2UgPT0gMCA/IDEgOiAxIC0gTWF0aC5taW4oIHBvc2l0aW9uLmRpc3RhbmNlVG8oIGxpZ2h0UG9zaXRpb24gKSAvIGxpZ2h0LmRpc3RhbmNlLCAxICk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBhbW91bnQgPT0gMCApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRcdGFtb3VudCAqPSBsaWdodC5pbnRlbnNpdHk7XHJcblxyXG5cdFx0XHRcdFx0Y29sb3IuYWRkKCBfbGlnaHRDb2xvci5tdWx0aXBseVNjYWxhciggYW1vdW50ICkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiByZW5kZXJQYXJ0aWNsZSggdjEsIGVsZW1lbnQsIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0c2V0T3BhY2l0eSggbWF0ZXJpYWwub3BhY2l0eSApO1xyXG5cdFx0XHRzZXRCbGVuZGluZyggbWF0ZXJpYWwuYmxlbmRpbmcgKTtcclxuXHJcblx0XHRcdHZhciB3aWR0aCwgaGVpZ2h0LCBzY2FsZVgsIHNjYWxlWSxcclxuXHRcdFx0Yml0bWFwLCBiaXRtYXBXaWR0aCwgYml0bWFwSGVpZ2h0O1xyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLlBhcnRpY2xlQmFzaWNNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBtYXRlcmlhbC5tYXAgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0c2NhbGVYID0gZWxlbWVudC5vYmplY3Quc2NhbGUueDtcclxuXHRcdFx0XHRcdHNjYWxlWSA9IGVsZW1lbnQub2JqZWN0LnNjYWxlLnk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gVE9ETzogQmUgYWJsZSB0byBkaXNhYmxlIHRoaXNcclxuXHJcblx0XHRcdFx0XHRzY2FsZVggKj0gZWxlbWVudC5zY2FsZS54ICogX2NhbnZhc1dpZHRoSGFsZjtcclxuXHRcdFx0XHRcdHNjYWxlWSAqPSBlbGVtZW50LnNjYWxlLnkgKiBfY2FudmFzSGVpZ2h0SGFsZjtcclxuXHJcblx0XHRcdFx0XHRfZWxlbUJveC5taW4uc2V0KCB2MS54IC0gc2NhbGVYLCB2MS55IC0gc2NhbGVZICk7XHJcblx0XHRcdFx0XHRfZWxlbUJveC5tYXguc2V0KCB2MS54ICsgc2NhbGVYLCB2MS55ICsgc2NhbGVZICk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBfY2xpcEJveC5pc0ludGVyc2VjdGlvbkJveCggX2VsZW1Cb3ggKSA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHNldEZpbGxTdHlsZSggbWF0ZXJpYWwuY29sb3IuZ2V0U3R5bGUoKSApO1xyXG5cclxuXHRcdFx0XHRcdF9jb250ZXh0LnNhdmUoKTtcclxuXHRcdFx0XHRcdF9jb250ZXh0LnRyYW5zbGF0ZSggdjEueCwgdjEueSApO1xyXG5cdFx0XHRcdFx0X2NvbnRleHQucm90YXRlKCAtIGVsZW1lbnQucm90YXRpb24gKTtcclxuXHRcdFx0XHRcdF9jb250ZXh0LnNjYWxlKCBzY2FsZVgsIHNjYWxlWSApO1xyXG5cdFx0XHRcdFx0X2NvbnRleHQuZmlsbFJlY3QoIC0xLCAtMSwgMiwgMiApO1xyXG5cdFx0XHRcdFx0X2NvbnRleHQucmVzdG9yZSgpO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGJpdG1hcCA9IG1hdGVyaWFsLm1hcC5pbWFnZTtcclxuXHRcdFx0XHRcdGJpdG1hcFdpZHRoID0gYml0bWFwLndpZHRoID4+IDE7XHJcblx0XHRcdFx0XHRiaXRtYXBIZWlnaHQgPSBiaXRtYXAuaGVpZ2h0ID4+IDE7XHJcblxyXG5cdFx0XHRcdFx0c2NhbGVYID0gZWxlbWVudC5zY2FsZS54ICogX2NhbnZhc1dpZHRoSGFsZjtcclxuXHRcdFx0XHRcdHNjYWxlWSA9IGVsZW1lbnQuc2NhbGUueSAqIF9jYW52YXNIZWlnaHRIYWxmO1xyXG5cclxuXHRcdFx0XHRcdHdpZHRoID0gc2NhbGVYICogYml0bWFwV2lkdGg7XHJcblx0XHRcdFx0XHRoZWlnaHQgPSBzY2FsZVkgKiBiaXRtYXBIZWlnaHQ7XHJcblxyXG5cdFx0XHRcdFx0Ly8gVE9ETzogUm90YXRpb25zIGJyZWFrIHRoaXMuLi5cclxuXHJcblx0XHRcdFx0XHRfZWxlbUJveC5taW4uc2V0KCB2MS54IC0gd2lkdGgsIHYxLnkgLSBoZWlnaHQgKTtcclxuXHRcdFx0XHRcdF9lbGVtQm94Lm1heC5zZXQoIHYxLnggKyB3aWR0aCwgdjEueSArIGhlaWdodCApO1xyXG5cclxuXHRcdFx0XHRcdGlmICggX2NsaXBCb3guaXNJbnRlcnNlY3Rpb25Cb3goIF9lbGVtQm94ICkgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRfY29udGV4dC5zYXZlKCk7XHJcblx0XHRcdFx0XHRfY29udGV4dC50cmFuc2xhdGUoIHYxLngsIHYxLnkgKTtcclxuXHRcdFx0XHRcdF9jb250ZXh0LnJvdGF0ZSggLSBlbGVtZW50LnJvdGF0aW9uICk7XHJcblx0XHRcdFx0XHRfY29udGV4dC5zY2FsZSggc2NhbGVYLCAtIHNjYWxlWSApO1xyXG5cclxuXHRcdFx0XHRcdF9jb250ZXh0LnRyYW5zbGF0ZSggLSBiaXRtYXBXaWR0aCwgLSBiaXRtYXBIZWlnaHQgKTtcclxuXHRcdFx0XHRcdF9jb250ZXh0LmRyYXdJbWFnZSggYml0bWFwLCAwLCAwICk7XHJcblx0XHRcdFx0XHRfY29udGV4dC5yZXN0b3JlKCk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0LyogREVCVUdcclxuXHRcdFx0XHRzZXRTdHJva2VTdHlsZSggJ3JnYigyNTUsMjU1LDApJyApO1xyXG5cdFx0XHRcdF9jb250ZXh0LmJlZ2luUGF0aCgpO1xyXG5cdFx0XHRcdF9jb250ZXh0Lm1vdmVUbyggdjEueCAtIDEwLCB2MS55ICk7XHJcblx0XHRcdFx0X2NvbnRleHQubGluZVRvKCB2MS54ICsgMTAsIHYxLnkgKTtcclxuXHRcdFx0XHRfY29udGV4dC5tb3ZlVG8oIHYxLngsIHYxLnkgLSAxMCApO1xyXG5cdFx0XHRcdF9jb250ZXh0LmxpbmVUbyggdjEueCwgdjEueSArIDEwICk7XHJcblx0XHRcdFx0X2NvbnRleHQuc3Ryb2tlKCk7XHJcblx0XHRcdFx0Ki9cclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuUGFydGljbGVDYW52YXNNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdFx0d2lkdGggPSBlbGVtZW50LnNjYWxlLnggKiBfY2FudmFzV2lkdGhIYWxmO1xyXG5cdFx0XHRcdGhlaWdodCA9IGVsZW1lbnQuc2NhbGUueSAqIF9jYW52YXNIZWlnaHRIYWxmO1xyXG5cclxuXHRcdFx0XHRfZWxlbUJveC5taW4uc2V0KCB2MS54IC0gd2lkdGgsIHYxLnkgLSBoZWlnaHQgKTtcclxuXHRcdFx0XHRfZWxlbUJveC5tYXguc2V0KCB2MS54ICsgd2lkdGgsIHYxLnkgKyBoZWlnaHQgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBfY2xpcEJveC5pc0ludGVyc2VjdGlvbkJveCggX2VsZW1Cb3ggKSA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHNldFN0cm9rZVN0eWxlKCBtYXRlcmlhbC5jb2xvci5nZXRTdHlsZSgpICk7XHJcblx0XHRcdFx0c2V0RmlsbFN0eWxlKCBtYXRlcmlhbC5jb2xvci5nZXRTdHlsZSgpICk7XHJcblxyXG5cdFx0XHRcdF9jb250ZXh0LnNhdmUoKTtcclxuXHRcdFx0XHRfY29udGV4dC50cmFuc2xhdGUoIHYxLngsIHYxLnkgKTtcclxuXHRcdFx0XHRfY29udGV4dC5yb3RhdGUoIC0gZWxlbWVudC5yb3RhdGlvbiApO1xyXG5cdFx0XHRcdF9jb250ZXh0LnNjYWxlKCB3aWR0aCwgaGVpZ2h0ICk7XHJcblxyXG5cdFx0XHRcdG1hdGVyaWFsLnByb2dyYW0oIF9jb250ZXh0ICk7XHJcblxyXG5cdFx0XHRcdF9jb250ZXh0LnJlc3RvcmUoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gcmVuZGVyTGluZSggdjEsIHYyLCBlbGVtZW50LCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdHNldE9wYWNpdHkoIG1hdGVyaWFsLm9wYWNpdHkgKTtcclxuXHRcdFx0c2V0QmxlbmRpbmcoIG1hdGVyaWFsLmJsZW5kaW5nICk7XHJcblxyXG5cdFx0XHRfY29udGV4dC5iZWdpblBhdGgoKTtcclxuXHRcdFx0X2NvbnRleHQubW92ZVRvKCB2MS5wb3NpdGlvblNjcmVlbi54LCB2MS5wb3NpdGlvblNjcmVlbi55ICk7XHJcblx0XHRcdF9jb250ZXh0LmxpbmVUbyggdjIucG9zaXRpb25TY3JlZW4ueCwgdjIucG9zaXRpb25TY3JlZW4ueSApO1xyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRzZXRMaW5lV2lkdGgoIG1hdGVyaWFsLmxpbmV3aWR0aCApO1xyXG5cdFx0XHRcdHNldExpbmVDYXAoIG1hdGVyaWFsLmxpbmVjYXAgKTtcclxuXHRcdFx0XHRzZXRMaW5lSm9pbiggbWF0ZXJpYWwubGluZWpvaW4gKTtcclxuXHRcdFx0XHRzZXRTdHJva2VTdHlsZSggbWF0ZXJpYWwuY29sb3IuZ2V0U3R5bGUoKSApO1xyXG5cdFx0XHRcdHNldERhc2hBbmRHYXAoIG51bGwsIG51bGwgKTtcclxuXHJcblx0XHRcdFx0X2NvbnRleHQuc3Ryb2tlKCk7XHJcblx0XHRcdFx0X2VsZW1Cb3guZXhwYW5kQnlTY2FsYXIoIG1hdGVyaWFsLmxpbmV3aWR0aCAqIDIgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTGluZURhc2hlZE1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRzZXRMaW5lV2lkdGgoIG1hdGVyaWFsLmxpbmV3aWR0aCApO1xyXG5cdFx0XHRcdHNldExpbmVDYXAoIG1hdGVyaWFsLmxpbmVjYXAgKTtcclxuXHRcdFx0XHRzZXRMaW5lSm9pbiggbWF0ZXJpYWwubGluZWpvaW4gKTtcclxuXHRcdFx0XHRzZXRTdHJva2VTdHlsZSggbWF0ZXJpYWwuY29sb3IuZ2V0U3R5bGUoKSApO1xyXG5cdFx0XHRcdHNldERhc2hBbmRHYXAoIG1hdGVyaWFsLmRhc2hTaXplLCBtYXRlcmlhbC5nYXBTaXplICk7XHJcblxyXG5cdFx0XHRcdF9jb250ZXh0LnN0cm9rZSgpO1xyXG5cdFx0XHRcdF9lbGVtQm94LmV4cGFuZEJ5U2NhbGFyKCBtYXRlcmlhbC5saW5ld2lkdGggKiAyICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHJlbmRlckZhY2UzKCB2MSwgdjIsIHYzLCB1djEsIHV2MiwgdXYzLCBlbGVtZW50LCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdF90aGlzLmluZm8ucmVuZGVyLnZlcnRpY2VzICs9IDM7XHJcblx0XHRcdF90aGlzLmluZm8ucmVuZGVyLmZhY2VzICsrO1xyXG5cclxuXHRcdFx0c2V0T3BhY2l0eSggbWF0ZXJpYWwub3BhY2l0eSApO1xyXG5cdFx0XHRzZXRCbGVuZGluZyggbWF0ZXJpYWwuYmxlbmRpbmcgKTtcclxuXHJcblx0XHRcdF92MXggPSB2MS5wb3NpdGlvblNjcmVlbi54OyBfdjF5ID0gdjEucG9zaXRpb25TY3JlZW4ueTtcclxuXHRcdFx0X3YyeCA9IHYyLnBvc2l0aW9uU2NyZWVuLng7IF92MnkgPSB2Mi5wb3NpdGlvblNjcmVlbi55O1xyXG5cdFx0XHRfdjN4ID0gdjMucG9zaXRpb25TY3JlZW4ueDsgX3YzeSA9IHYzLnBvc2l0aW9uU2NyZWVuLnk7XHJcblxyXG5cdFx0XHRkcmF3VHJpYW5nbGUoIF92MXgsIF92MXksIF92MngsIF92MnksIF92M3gsIF92M3kgKTtcclxuXHJcblx0XHRcdGlmICggKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgfHwgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCApICYmIG1hdGVyaWFsLm1hcCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0X2RpZmZ1c2VDb2xvci5jb3B5KCBtYXRlcmlhbC5jb2xvciApO1xyXG5cdFx0XHRcdF9lbWlzc2l2ZUNvbG9yLmNvcHkoIG1hdGVyaWFsLmVtaXNzaXZlICk7XHJcblxyXG5cdFx0XHRcdGlmICggbWF0ZXJpYWwudmVydGV4Q29sb3JzID09PSBUSFJFRS5GYWNlQ29sb3JzICkge1xyXG5cclxuXHRcdFx0XHRcdF9kaWZmdXNlQ29sb3IubXVsdGlwbHkoIGVsZW1lbnQuY29sb3IgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIF9lbmFibGVMaWdodGluZyA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsLndpcmVmcmFtZSA9PT0gZmFsc2UgJiYgbWF0ZXJpYWwuc2hhZGluZyA9PSBUSFJFRS5TbW9vdGhTaGFkaW5nICYmIGVsZW1lbnQudmVydGV4Tm9ybWFsc0xlbmd0aCA9PSAzICkge1xyXG5cclxuXHRcdFx0XHRcdFx0X2NvbG9yMS5jb3B5KCBfYW1iaWVudExpZ2h0ICk7XHJcblx0XHRcdFx0XHRcdF9jb2xvcjIuY29weSggX2FtYmllbnRMaWdodCApO1xyXG5cdFx0XHRcdFx0XHRfY29sb3IzLmNvcHkoIF9hbWJpZW50TGlnaHQgKTtcclxuXHJcblx0XHRcdFx0XHRcdGNhbGN1bGF0ZUxpZ2h0KCBlbGVtZW50LnYxLnBvc2l0aW9uV29ybGQsIGVsZW1lbnQudmVydGV4Tm9ybWFsc01vZGVsWyAwIF0sIF9jb2xvcjEgKTtcclxuXHRcdFx0XHRcdFx0Y2FsY3VsYXRlTGlnaHQoIGVsZW1lbnQudjIucG9zaXRpb25Xb3JsZCwgZWxlbWVudC52ZXJ0ZXhOb3JtYWxzTW9kZWxbIDEgXSwgX2NvbG9yMiApO1xyXG5cdFx0XHRcdFx0XHRjYWxjdWxhdGVMaWdodCggZWxlbWVudC52My5wb3NpdGlvbldvcmxkLCBlbGVtZW50LnZlcnRleE5vcm1hbHNNb2RlbFsgMiBdLCBfY29sb3IzICk7XHJcblxyXG5cdFx0XHRcdFx0XHRfY29sb3IxLm11bHRpcGx5KCBfZGlmZnVzZUNvbG9yICkuYWRkKCBfZW1pc3NpdmVDb2xvciApO1xyXG5cdFx0XHRcdFx0XHRfY29sb3IyLm11bHRpcGx5KCBfZGlmZnVzZUNvbG9yICkuYWRkKCBfZW1pc3NpdmVDb2xvciApO1xyXG5cdFx0XHRcdFx0XHRfY29sb3IzLm11bHRpcGx5KCBfZGlmZnVzZUNvbG9yICkuYWRkKCBfZW1pc3NpdmVDb2xvciApO1xyXG5cdFx0XHRcdFx0XHRfY29sb3I0LmFkZENvbG9ycyggX2NvbG9yMiwgX2NvbG9yMyApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcclxuXHJcblx0XHRcdFx0XHRcdF9pbWFnZSA9IGdldEdyYWRpZW50VGV4dHVyZSggX2NvbG9yMSwgX2NvbG9yMiwgX2NvbG9yMywgX2NvbG9yNCApO1xyXG5cclxuXHRcdFx0XHRcdFx0Y2xpcEltYWdlKCBfdjF4LCBfdjF5LCBfdjJ4LCBfdjJ5LCBfdjN4LCBfdjN5LCAwLCAwLCAxLCAwLCAwLCAxLCBfaW1hZ2UgKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0X2NvbG9yLmNvcHkoIF9hbWJpZW50TGlnaHQgKTtcclxuXHJcblx0XHRcdFx0XHRcdGNhbGN1bGF0ZUxpZ2h0KCBlbGVtZW50LmNlbnRyb2lkTW9kZWwsIGVsZW1lbnQubm9ybWFsTW9kZWwsIF9jb2xvciApO1xyXG5cclxuXHRcdFx0XHRcdFx0X2NvbG9yLm11bHRpcGx5KCBfZGlmZnVzZUNvbG9yICkuYWRkKCBfZW1pc3NpdmVDb2xvciApO1xyXG5cclxuXHRcdFx0XHRcdFx0bWF0ZXJpYWwud2lyZWZyYW1lID09PSB0cnVlXHJcblx0XHRcdFx0XHRcdFx0PyBzdHJva2VQYXRoKCBfY29sb3IsIG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCwgbWF0ZXJpYWwud2lyZWZyYW1lTGluZWNhcCwgbWF0ZXJpYWwud2lyZWZyYW1lTGluZWpvaW4gKVxyXG5cdFx0XHRcdFx0XHRcdDogZmlsbFBhdGgoIF9jb2xvciApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRtYXRlcmlhbC53aXJlZnJhbWUgPT09IHRydWVcclxuXHRcdFx0XHRcdFx0PyBzdHJva2VQYXRoKCBtYXRlcmlhbC5jb2xvciwgbWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoLCBtYXRlcmlhbC53aXJlZnJhbWVMaW5lY2FwLCBtYXRlcmlhbC53aXJlZnJhbWVMaW5lam9pbiApXHJcblx0XHRcdFx0XHRcdDogZmlsbFBhdGgoIG1hdGVyaWFsLmNvbG9yICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwgfHwgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsIHx8IG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggbWF0ZXJpYWwubWFwICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggbWF0ZXJpYWwubWFwLm1hcHBpbmcgaW5zdGFuY2VvZiBUSFJFRS5VVk1hcHBpbmcgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRfdXZzID0gZWxlbWVudC51dnNbIDAgXTtcclxuXHRcdFx0XHRcdFx0cGF0dGVyblBhdGgoIF92MXgsIF92MXksIF92MngsIF92MnksIF92M3gsIF92M3ksIF91dnNbIHV2MSBdLngsIF91dnNbIHV2MSBdLnksIF91dnNbIHV2MiBdLngsIF91dnNbIHV2MiBdLnksIF91dnNbIHV2MyBdLngsIF91dnNbIHV2MyBdLnksIG1hdGVyaWFsLm1hcCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmVudk1hcCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsLmVudk1hcC5tYXBwaW5nIGluc3RhbmNlb2YgVEhSRUUuU3BoZXJpY2FsUmVmbGVjdGlvbk1hcHBpbmcgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRfdmVjdG9yMy5jb3B5KCBlbGVtZW50LnZlcnRleE5vcm1hbHNNb2RlbFZpZXdbIHV2MSBdICk7XHJcblx0XHRcdFx0XHRcdF91djF4ID0gMC41ICogX3ZlY3RvcjMueCArIDAuNTtcclxuXHRcdFx0XHRcdFx0X3V2MXkgPSAwLjUgKiBfdmVjdG9yMy55ICsgMC41O1xyXG5cclxuXHRcdFx0XHRcdFx0X3ZlY3RvcjMuY29weSggZWxlbWVudC52ZXJ0ZXhOb3JtYWxzTW9kZWxWaWV3WyB1djIgXSApO1xyXG5cdFx0XHRcdFx0XHRfdXYyeCA9IDAuNSAqIF92ZWN0b3IzLnggKyAwLjU7XHJcblx0XHRcdFx0XHRcdF91djJ5ID0gMC41ICogX3ZlY3RvcjMueSArIDAuNTtcclxuXHJcblx0XHRcdFx0XHRcdF92ZWN0b3IzLmNvcHkoIGVsZW1lbnQudmVydGV4Tm9ybWFsc01vZGVsVmlld1sgdXYzIF0gKTtcclxuXHRcdFx0XHRcdFx0X3V2M3ggPSAwLjUgKiBfdmVjdG9yMy54ICsgMC41O1xyXG5cdFx0XHRcdFx0XHRfdXYzeSA9IDAuNSAqIF92ZWN0b3IzLnkgKyAwLjU7XHJcblxyXG5cdFx0XHRcdFx0XHRwYXR0ZXJuUGF0aCggX3YxeCwgX3YxeSwgX3YyeCwgX3YyeSwgX3YzeCwgX3YzeSwgX3V2MXgsIF91djF5LCBfdXYyeCwgX3V2MnksIF91djN4LCBfdXYzeSwgbWF0ZXJpYWwuZW52TWFwICk7XHJcblxyXG5cdFx0XHRcdFx0fS8qIGVsc2UgaWYgKCBtYXRlcmlhbC5lbnZNYXAubWFwcGluZyA9PSBUSFJFRS5TcGhlcmljYWxSZWZyYWN0aW9uTWFwcGluZyApIHtcclxuXHJcblxyXG5cclxuXHRcdFx0XHRcdH0qL1xyXG5cclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRfY29sb3IuY29weSggbWF0ZXJpYWwuY29sb3IgKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsLnZlcnRleENvbG9ycyA9PT0gVEhSRUUuRmFjZUNvbG9ycyApIHtcclxuXHJcblx0XHRcdFx0XHRcdF9jb2xvci5tdWx0aXBseSggZWxlbWVudC5jb2xvciApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRtYXRlcmlhbC53aXJlZnJhbWUgPT09IHRydWVcclxuXHRcdFx0XHRcdFx0PyBzdHJva2VQYXRoKCBfY29sb3IsIG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCwgbWF0ZXJpYWwud2lyZWZyYW1lTGluZWNhcCwgbWF0ZXJpYWwud2lyZWZyYW1lTGluZWpvaW4gKVxyXG5cdFx0XHRcdFx0XHQ6IGZpbGxQYXRoKCBfY29sb3IgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRGVwdGhNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdFx0X25lYXIgPSBjYW1lcmEubmVhcjtcclxuXHRcdFx0XHRfZmFyID0gY2FtZXJhLmZhcjtcclxuXHJcblx0XHRcdFx0X2NvbG9yMS5yID0gX2NvbG9yMS5nID0gX2NvbG9yMS5iID0gMSAtIHNtb290aHN0ZXAoIHYxLnBvc2l0aW9uU2NyZWVuLnogKiB2MS5wb3NpdGlvblNjcmVlbi53LCBfbmVhciwgX2ZhciApO1xyXG5cdFx0XHRcdF9jb2xvcjIuciA9IF9jb2xvcjIuZyA9IF9jb2xvcjIuYiA9IDEgLSBzbW9vdGhzdGVwKCB2Mi5wb3NpdGlvblNjcmVlbi56ICogdjIucG9zaXRpb25TY3JlZW4udywgX25lYXIsIF9mYXIgKTtcclxuXHRcdFx0XHRfY29sb3IzLnIgPSBfY29sb3IzLmcgPSBfY29sb3IzLmIgPSAxIC0gc21vb3Roc3RlcCggdjMucG9zaXRpb25TY3JlZW4ueiAqIHYzLnBvc2l0aW9uU2NyZWVuLncsIF9uZWFyLCBfZmFyICk7XHJcblx0XHRcdFx0X2NvbG9yNC5hZGRDb2xvcnMoIF9jb2xvcjIsIF9jb2xvcjMgKS5tdWx0aXBseVNjYWxhciggMC41ICk7XHJcblxyXG5cdFx0XHRcdF9pbWFnZSA9IGdldEdyYWRpZW50VGV4dHVyZSggX2NvbG9yMSwgX2NvbG9yMiwgX2NvbG9yMywgX2NvbG9yNCApO1xyXG5cclxuXHRcdFx0XHRjbGlwSW1hZ2UoIF92MXgsIF92MXksIF92MngsIF92MnksIF92M3gsIF92M3ksIDAsIDAsIDEsIDAsIDAsIDEsIF9pbWFnZSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBub3JtYWw7XHJcblxyXG5cdFx0XHRcdGlmICggbWF0ZXJpYWwuc2hhZGluZyA9PSBUSFJFRS5GbGF0U2hhZGluZyApIHtcclxuXHJcblx0XHRcdFx0XHRub3JtYWwgPSBlbGVtZW50Lm5vcm1hbE1vZGVsVmlldztcclxuXHJcblx0XHRcdFx0XHRfY29sb3Iuc2V0UkdCKCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICkubXVsdGlwbHlTY2FsYXIoIDAuNSApLmFkZFNjYWxhciggMC41ICk7XHJcblxyXG5cdFx0XHRcdFx0bWF0ZXJpYWwud2lyZWZyYW1lID09PSB0cnVlXHJcblx0XHRcdFx0XHRcdD8gc3Ryb2tlUGF0aCggX2NvbG9yLCBtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGgsIG1hdGVyaWFsLndpcmVmcmFtZUxpbmVjYXAsIG1hdGVyaWFsLndpcmVmcmFtZUxpbmVqb2luIClcclxuXHRcdFx0XHRcdFx0OiBmaWxsUGF0aCggX2NvbG9yICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLnNoYWRpbmcgPT0gVEhSRUUuU21vb3RoU2hhZGluZyApIHtcclxuXHJcblx0XHRcdFx0XHRub3JtYWwgPSBlbGVtZW50LnZlcnRleE5vcm1hbHNNb2RlbFZpZXdbIHV2MSBdO1xyXG5cdFx0XHRcdFx0X2NvbG9yMS5zZXRSR0IoIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKS5tdWx0aXBseVNjYWxhciggMC41ICkuYWRkU2NhbGFyKCAwLjUgKTtcclxuXHJcblx0XHRcdFx0XHRub3JtYWwgPSBlbGVtZW50LnZlcnRleE5vcm1hbHNNb2RlbFZpZXdbIHV2MiBdO1xyXG5cdFx0XHRcdFx0X2NvbG9yMi5zZXRSR0IoIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKS5tdWx0aXBseVNjYWxhciggMC41ICkuYWRkU2NhbGFyKCAwLjUgKTtcclxuXHJcblx0XHRcdFx0XHRub3JtYWwgPSBlbGVtZW50LnZlcnRleE5vcm1hbHNNb2RlbFZpZXdbIHV2MyBdO1xyXG5cdFx0XHRcdFx0X2NvbG9yMy5zZXRSR0IoIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKS5tdWx0aXBseVNjYWxhciggMC41ICkuYWRkU2NhbGFyKCAwLjUgKTtcclxuXHJcblx0XHRcdFx0XHRfY29sb3I0LmFkZENvbG9ycyggX2NvbG9yMiwgX2NvbG9yMyApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcclxuXHJcblx0XHRcdFx0XHRfaW1hZ2UgPSBnZXRHcmFkaWVudFRleHR1cmUoIF9jb2xvcjEsIF9jb2xvcjIsIF9jb2xvcjMsIF9jb2xvcjQgKTtcclxuXHJcblx0XHRcdFx0XHRjbGlwSW1hZ2UoIF92MXgsIF92MXksIF92MngsIF92MnksIF92M3gsIF92M3ksIDAsIDAsIDEsIDAsIDAsIDEsIF9pbWFnZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHJlbmRlckZhY2U0KCB2MSwgdjIsIHYzLCB2NCwgdjUsIHY2LCBlbGVtZW50LCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdF90aGlzLmluZm8ucmVuZGVyLnZlcnRpY2VzICs9IDQ7XHJcblx0XHRcdF90aGlzLmluZm8ucmVuZGVyLmZhY2VzICsrO1xyXG5cclxuXHRcdFx0c2V0T3BhY2l0eSggbWF0ZXJpYWwub3BhY2l0eSApO1xyXG5cdFx0XHRzZXRCbGVuZGluZyggbWF0ZXJpYWwuYmxlbmRpbmcgKTtcclxuXHJcblx0XHRcdGlmICggKCBtYXRlcmlhbC5tYXAgIT09IHVuZGVmaW5lZCAmJiBtYXRlcmlhbC5tYXAgIT09IG51bGwgKSB8fCAoIG1hdGVyaWFsLmVudk1hcCAhPT0gdW5kZWZpbmVkICYmIG1hdGVyaWFsLmVudk1hcCAhPT0gbnVsbCApICkge1xyXG5cclxuXHRcdFx0XHQvLyBMZXQgcmVuZGVyRmFjZTMoKSBoYW5kbGUgdGhpc1xyXG5cclxuXHRcdFx0XHRyZW5kZXJGYWNlMyggdjEsIHYyLCB2NCwgMCwgMSwgMywgZWxlbWVudCwgbWF0ZXJpYWwgKTtcclxuXHRcdFx0XHRyZW5kZXJGYWNlMyggdjUsIHYzLCB2NiwgMSwgMiwgMywgZWxlbWVudCwgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0X3YxeCA9IHYxLnBvc2l0aW9uU2NyZWVuLng7IF92MXkgPSB2MS5wb3NpdGlvblNjcmVlbi55O1xyXG5cdFx0XHRfdjJ4ID0gdjIucG9zaXRpb25TY3JlZW4ueDsgX3YyeSA9IHYyLnBvc2l0aW9uU2NyZWVuLnk7XHJcblx0XHRcdF92M3ggPSB2My5wb3NpdGlvblNjcmVlbi54OyBfdjN5ID0gdjMucG9zaXRpb25TY3JlZW4ueTtcclxuXHRcdFx0X3Y0eCA9IHY0LnBvc2l0aW9uU2NyZWVuLng7IF92NHkgPSB2NC5wb3NpdGlvblNjcmVlbi55O1xyXG5cdFx0XHRfdjV4ID0gdjUucG9zaXRpb25TY3JlZW4ueDsgX3Y1eSA9IHY1LnBvc2l0aW9uU2NyZWVuLnk7XHJcblx0XHRcdF92NnggPSB2Ni5wb3NpdGlvblNjcmVlbi54OyBfdjZ5ID0gdjYucG9zaXRpb25TY3JlZW4ueTtcclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsIHx8IG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdF9kaWZmdXNlQ29sb3IuY29weSggbWF0ZXJpYWwuY29sb3IgKTtcclxuXHRcdFx0XHRfZW1pc3NpdmVDb2xvci5jb3B5KCBtYXRlcmlhbC5lbWlzc2l2ZSApO1xyXG5cclxuXHRcdFx0XHRpZiAoIG1hdGVyaWFsLnZlcnRleENvbG9ycyA9PT0gVEhSRUUuRmFjZUNvbG9ycyApIHtcclxuXHJcblx0XHRcdFx0XHRfZGlmZnVzZUNvbG9yLm11bHRpcGx5KCBlbGVtZW50LmNvbG9yICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBfZW5hYmxlTGlnaHRpbmcgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBtYXRlcmlhbC53aXJlZnJhbWUgPT09IGZhbHNlICYmIG1hdGVyaWFsLnNoYWRpbmcgPT0gVEhSRUUuU21vb3RoU2hhZGluZyAmJiBlbGVtZW50LnZlcnRleE5vcm1hbHNMZW5ndGggPT0gNCApIHtcclxuXHJcblx0XHRcdFx0XHRcdF9jb2xvcjEuY29weSggX2FtYmllbnRMaWdodCApO1xyXG5cdFx0XHRcdFx0XHRfY29sb3IyLmNvcHkoIF9hbWJpZW50TGlnaHQgKTtcclxuXHRcdFx0XHRcdFx0X2NvbG9yMy5jb3B5KCBfYW1iaWVudExpZ2h0ICk7XHJcblx0XHRcdFx0XHRcdF9jb2xvcjQuY29weSggX2FtYmllbnRMaWdodCApO1xyXG5cclxuXHRcdFx0XHRcdFx0Y2FsY3VsYXRlTGlnaHQoIGVsZW1lbnQudjEucG9zaXRpb25Xb3JsZCwgZWxlbWVudC52ZXJ0ZXhOb3JtYWxzTW9kZWxbIDAgXSwgX2NvbG9yMSApO1xyXG5cdFx0XHRcdFx0XHRjYWxjdWxhdGVMaWdodCggZWxlbWVudC52Mi5wb3NpdGlvbldvcmxkLCBlbGVtZW50LnZlcnRleE5vcm1hbHNNb2RlbFsgMSBdLCBfY29sb3IyICk7XHJcblx0XHRcdFx0XHRcdGNhbGN1bGF0ZUxpZ2h0KCBlbGVtZW50LnY0LnBvc2l0aW9uV29ybGQsIGVsZW1lbnQudmVydGV4Tm9ybWFsc01vZGVsWyAzIF0sIF9jb2xvcjMgKTtcclxuXHRcdFx0XHRcdFx0Y2FsY3VsYXRlTGlnaHQoIGVsZW1lbnQudjMucG9zaXRpb25Xb3JsZCwgZWxlbWVudC52ZXJ0ZXhOb3JtYWxzTW9kZWxbIDIgXSwgX2NvbG9yNCApO1xyXG5cclxuXHRcdFx0XHRcdFx0X2NvbG9yMS5tdWx0aXBseSggX2RpZmZ1c2VDb2xvciApLmFkZCggX2VtaXNzaXZlQ29sb3IgKTtcclxuXHRcdFx0XHRcdFx0X2NvbG9yMi5tdWx0aXBseSggX2RpZmZ1c2VDb2xvciApLmFkZCggX2VtaXNzaXZlQ29sb3IgKTtcclxuXHRcdFx0XHRcdFx0X2NvbG9yMy5tdWx0aXBseSggX2RpZmZ1c2VDb2xvciApLmFkZCggX2VtaXNzaXZlQ29sb3IgKTtcclxuXHRcdFx0XHRcdFx0X2NvbG9yNC5tdWx0aXBseSggX2RpZmZ1c2VDb2xvciApLmFkZCggX2VtaXNzaXZlQ29sb3IgKTtcclxuXHJcblx0XHRcdFx0XHRcdF9pbWFnZSA9IGdldEdyYWRpZW50VGV4dHVyZSggX2NvbG9yMSwgX2NvbG9yMiwgX2NvbG9yMywgX2NvbG9yNCApO1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gVE9ETzogVVZzIGFyZSBpbmNvcnJlY3QsIHY0LT52Mz9cclxuXHJcblx0XHRcdFx0XHRcdGRyYXdUcmlhbmdsZSggX3YxeCwgX3YxeSwgX3YyeCwgX3YyeSwgX3Y0eCwgX3Y0eSApO1xyXG5cdFx0XHRcdFx0XHRjbGlwSW1hZ2UoIF92MXgsIF92MXksIF92MngsIF92MnksIF92NHgsIF92NHksIDAsIDAsIDEsIDAsIDAsIDEsIF9pbWFnZSApO1xyXG5cclxuXHRcdFx0XHRcdFx0ZHJhd1RyaWFuZ2xlKCBfdjV4LCBfdjV5LCBfdjN4LCBfdjN5LCBfdjZ4LCBfdjZ5ICk7XHJcblx0XHRcdFx0XHRcdGNsaXBJbWFnZSggX3Y1eCwgX3Y1eSwgX3YzeCwgX3YzeSwgX3Y2eCwgX3Y2eSwgMSwgMCwgMSwgMSwgMCwgMSwgX2ltYWdlICk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdF9jb2xvci5jb3B5KCBfYW1iaWVudExpZ2h0ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRjYWxjdWxhdGVMaWdodCggZWxlbWVudC5jZW50cm9pZE1vZGVsLCBlbGVtZW50Lm5vcm1hbE1vZGVsLCBfY29sb3IgKTtcclxuXHJcblx0XHRcdFx0XHRcdF9jb2xvci5tdWx0aXBseSggX2RpZmZ1c2VDb2xvciApLmFkZCggX2VtaXNzaXZlQ29sb3IgKTtcclxuXHJcblx0XHRcdFx0XHRcdGRyYXdRdWFkKCBfdjF4LCBfdjF5LCBfdjJ4LCBfdjJ5LCBfdjN4LCBfdjN5LCBfdjR4LCBfdjR5ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRtYXRlcmlhbC53aXJlZnJhbWUgPT09IHRydWVcclxuXHRcdFx0XHRcdFx0XHQ/IHN0cm9rZVBhdGgoIF9jb2xvciwgbWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoLCBtYXRlcmlhbC53aXJlZnJhbWVMaW5lY2FwLCBtYXRlcmlhbC53aXJlZnJhbWVMaW5lam9pbiApXHJcblx0XHRcdFx0XHRcdFx0OiBmaWxsUGF0aCggX2NvbG9yICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdF9jb2xvci5hZGRDb2xvcnMoIF9kaWZmdXNlQ29sb3IsIF9lbWlzc2l2ZUNvbG9yICk7XHJcblxyXG5cdFx0XHRcdFx0ZHJhd1F1YWQoIF92MXgsIF92MXksIF92MngsIF92MnksIF92M3gsIF92M3ksIF92NHgsIF92NHkgKTtcclxuXHJcblx0XHRcdFx0XHRtYXRlcmlhbC53aXJlZnJhbWUgPT09IHRydWVcclxuXHRcdFx0XHRcdFx0PyBzdHJva2VQYXRoKCBfY29sb3IsIG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCwgbWF0ZXJpYWwud2lyZWZyYW1lTGluZWNhcCwgbWF0ZXJpYWwud2lyZWZyYW1lTGluZWpvaW4gKVxyXG5cdFx0XHRcdFx0XHQ6IGZpbGxQYXRoKCBfY29sb3IgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdFx0X2NvbG9yLmNvcHkoIG1hdGVyaWFsLmNvbG9yICk7XHJcblxyXG5cdFx0XHRcdGlmICggbWF0ZXJpYWwudmVydGV4Q29sb3JzID09PSBUSFJFRS5GYWNlQ29sb3JzICkge1xyXG5cclxuXHRcdFx0XHRcdF9jb2xvci5tdWx0aXBseSggZWxlbWVudC5jb2xvciApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGRyYXdRdWFkKCBfdjF4LCBfdjF5LCBfdjJ4LCBfdjJ5LCBfdjN4LCBfdjN5LCBfdjR4LCBfdjR5ICk7XHJcblxyXG5cdFx0XHRcdG1hdGVyaWFsLndpcmVmcmFtZSA9PT0gdHJ1ZVxyXG5cdFx0XHRcdFx0PyBzdHJva2VQYXRoKCBfY29sb3IsIG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCwgbWF0ZXJpYWwud2lyZWZyYW1lTGluZWNhcCwgbWF0ZXJpYWwud2lyZWZyYW1lTGluZWpvaW4gKVxyXG5cdFx0XHRcdFx0OiBmaWxsUGF0aCggX2NvbG9yICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdFx0dmFyIG5vcm1hbDtcclxuXHJcblx0XHRcdFx0aWYgKCBtYXRlcmlhbC5zaGFkaW5nID09IFRIUkVFLkZsYXRTaGFkaW5nICkge1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbCA9IGVsZW1lbnQubm9ybWFsTW9kZWxWaWV3O1xyXG5cdFx0XHRcdFx0X2NvbG9yLnNldFJHQiggbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApLm11bHRpcGx5U2NhbGFyKCAwLjUgKS5hZGRTY2FsYXIoIDAuNSApO1xyXG5cclxuXHRcdFx0XHRcdGRyYXdRdWFkKCBfdjF4LCBfdjF5LCBfdjJ4LCBfdjJ5LCBfdjN4LCBfdjN5LCBfdjR4LCBfdjR5ICk7XHJcblxyXG5cdFx0XHRcdFx0bWF0ZXJpYWwud2lyZWZyYW1lID09PSB0cnVlXHJcblx0XHRcdFx0XHRcdD8gc3Ryb2tlUGF0aCggX2NvbG9yLCBtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGgsIG1hdGVyaWFsLndpcmVmcmFtZUxpbmVjYXAsIG1hdGVyaWFsLndpcmVmcmFtZUxpbmVqb2luIClcclxuXHRcdFx0XHRcdFx0OiBmaWxsUGF0aCggX2NvbG9yICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLnNoYWRpbmcgPT0gVEhSRUUuU21vb3RoU2hhZGluZyApIHtcclxuXHJcblx0XHRcdFx0XHRub3JtYWwgPSBlbGVtZW50LnZlcnRleE5vcm1hbHNNb2RlbFZpZXdbIDAgXTtcclxuXHRcdFx0XHRcdF9jb2xvcjEuc2V0UkdCKCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICkubXVsdGlwbHlTY2FsYXIoIDAuNSApLmFkZFNjYWxhciggMC41ICk7XHJcblxyXG5cdFx0XHRcdFx0bm9ybWFsID0gZWxlbWVudC52ZXJ0ZXhOb3JtYWxzTW9kZWxWaWV3WyAxIF07XHJcblx0XHRcdFx0XHRfY29sb3IyLnNldFJHQiggbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApLm11bHRpcGx5U2NhbGFyKCAwLjUgKS5hZGRTY2FsYXIoIDAuNSApO1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbCA9IGVsZW1lbnQudmVydGV4Tm9ybWFsc01vZGVsVmlld1sgMyBdO1xyXG5cdFx0XHRcdFx0X2NvbG9yMy5zZXRSR0IoIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKS5tdWx0aXBseVNjYWxhciggMC41ICkuYWRkU2NhbGFyKCAwLjUgKTtcclxuXHJcblx0XHRcdFx0XHRub3JtYWwgPSBlbGVtZW50LnZlcnRleE5vcm1hbHNNb2RlbFZpZXdbIDIgXTtcclxuXHRcdFx0XHRcdF9jb2xvcjQuc2V0UkdCKCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICkubXVsdGlwbHlTY2FsYXIoIDAuNSApLmFkZFNjYWxhciggMC41ICk7XHJcblxyXG5cdFx0XHRcdFx0X2ltYWdlID0gZ2V0R3JhZGllbnRUZXh0dXJlKCBfY29sb3IxLCBfY29sb3IyLCBfY29sb3IzLCBfY29sb3I0ICk7XHJcblxyXG5cdFx0XHRcdFx0ZHJhd1RyaWFuZ2xlKCBfdjF4LCBfdjF5LCBfdjJ4LCBfdjJ5LCBfdjR4LCBfdjR5ICk7XHJcblx0XHRcdFx0XHRjbGlwSW1hZ2UoIF92MXgsIF92MXksIF92MngsIF92MnksIF92NHgsIF92NHksIDAsIDAsIDEsIDAsIDAsIDEsIF9pbWFnZSApO1xyXG5cclxuXHRcdFx0XHRcdGRyYXdUcmlhbmdsZSggX3Y1eCwgX3Y1eSwgX3YzeCwgX3YzeSwgX3Y2eCwgX3Y2eSApO1xyXG5cdFx0XHRcdFx0Y2xpcEltYWdlKCBfdjV4LCBfdjV5LCBfdjN4LCBfdjN5LCBfdjZ4LCBfdjZ5LCAxLCAwLCAxLCAxLCAwLCAxLCBfaW1hZ2UgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hEZXB0aE1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRfbmVhciA9IGNhbWVyYS5uZWFyO1xyXG5cdFx0XHRcdF9mYXIgPSBjYW1lcmEuZmFyO1xyXG5cclxuXHRcdFx0XHRfY29sb3IxLnIgPSBfY29sb3IxLmcgPSBfY29sb3IxLmIgPSAxIC0gc21vb3Roc3RlcCggdjEucG9zaXRpb25TY3JlZW4ueiAqIHYxLnBvc2l0aW9uU2NyZWVuLncsIF9uZWFyLCBfZmFyICk7XHJcblx0XHRcdFx0X2NvbG9yMi5yID0gX2NvbG9yMi5nID0gX2NvbG9yMi5iID0gMSAtIHNtb290aHN0ZXAoIHYyLnBvc2l0aW9uU2NyZWVuLnogKiB2Mi5wb3NpdGlvblNjcmVlbi53LCBfbmVhciwgX2ZhciApO1xyXG5cdFx0XHRcdF9jb2xvcjMuciA9IF9jb2xvcjMuZyA9IF9jb2xvcjMuYiA9IDEgLSBzbW9vdGhzdGVwKCB2NC5wb3NpdGlvblNjcmVlbi56ICogdjQucG9zaXRpb25TY3JlZW4udywgX25lYXIsIF9mYXIgKTtcclxuXHRcdFx0XHRfY29sb3I0LnIgPSBfY29sb3I0LmcgPSBfY29sb3I0LmIgPSAxIC0gc21vb3Roc3RlcCggdjMucG9zaXRpb25TY3JlZW4ueiAqIHYzLnBvc2l0aW9uU2NyZWVuLncsIF9uZWFyLCBfZmFyICk7XHJcblxyXG5cdFx0XHRcdF9pbWFnZSA9IGdldEdyYWRpZW50VGV4dHVyZSggX2NvbG9yMSwgX2NvbG9yMiwgX2NvbG9yMywgX2NvbG9yNCApO1xyXG5cclxuXHRcdFx0XHQvLyBUT0RPOiBVVnMgYXJlIGluY29ycmVjdCwgdjQtPnYzP1xyXG5cclxuXHRcdFx0XHRkcmF3VHJpYW5nbGUoIF92MXgsIF92MXksIF92MngsIF92MnksIF92NHgsIF92NHkgKTtcclxuXHRcdFx0XHRjbGlwSW1hZ2UoIF92MXgsIF92MXksIF92MngsIF92MnksIF92NHgsIF92NHksIDAsIDAsIDEsIDAsIDAsIDEsIF9pbWFnZSApO1xyXG5cclxuXHRcdFx0XHRkcmF3VHJpYW5nbGUoIF92NXgsIF92NXksIF92M3gsIF92M3ksIF92NngsIF92NnkgKTtcclxuXHRcdFx0XHRjbGlwSW1hZ2UoIF92NXgsIF92NXksIF92M3gsIF92M3ksIF92NngsIF92NnksIDEsIDAsIDEsIDEsIDAsIDEsIF9pbWFnZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGZ1bmN0aW9uIGRyYXdUcmlhbmdsZSggeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiApIHtcclxuXHJcblx0XHRcdF9jb250ZXh0LmJlZ2luUGF0aCgpO1xyXG5cdFx0XHRfY29udGV4dC5tb3ZlVG8oIHgwLCB5MCApO1xyXG5cdFx0XHRfY29udGV4dC5saW5lVG8oIHgxLCB5MSApO1xyXG5cdFx0XHRfY29udGV4dC5saW5lVG8oIHgyLCB5MiApO1xyXG5cdFx0XHRfY29udGV4dC5jbG9zZVBhdGgoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gZHJhd1F1YWQoIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MyApIHtcclxuXHJcblx0XHRcdF9jb250ZXh0LmJlZ2luUGF0aCgpO1xyXG5cdFx0XHRfY29udGV4dC5tb3ZlVG8oIHgwLCB5MCApO1xyXG5cdFx0XHRfY29udGV4dC5saW5lVG8oIHgxLCB5MSApO1xyXG5cdFx0XHRfY29udGV4dC5saW5lVG8oIHgyLCB5MiApO1xyXG5cdFx0XHRfY29udGV4dC5saW5lVG8oIHgzLCB5MyApO1xyXG5cdFx0XHRfY29udGV4dC5jbG9zZVBhdGgoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gc3Ryb2tlUGF0aCggY29sb3IsIGxpbmV3aWR0aCwgbGluZWNhcCwgbGluZWpvaW4gKSB7XHJcblxyXG5cdFx0XHRzZXRMaW5lV2lkdGgoIGxpbmV3aWR0aCApO1xyXG5cdFx0XHRzZXRMaW5lQ2FwKCBsaW5lY2FwICk7XHJcblx0XHRcdHNldExpbmVKb2luKCBsaW5lam9pbiApO1xyXG5cdFx0XHRzZXRTdHJva2VTdHlsZSggY29sb3IuZ2V0U3R5bGUoKSApO1xyXG5cclxuXHRcdFx0X2NvbnRleHQuc3Ryb2tlKCk7XHJcblxyXG5cdFx0XHRfZWxlbUJveC5leHBhbmRCeVNjYWxhciggbGluZXdpZHRoICogMiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBmaWxsUGF0aCggY29sb3IgKSB7XHJcblxyXG5cdFx0XHRzZXRGaWxsU3R5bGUoIGNvbG9yLmdldFN0eWxlKCkgKTtcclxuXHRcdFx0X2NvbnRleHQuZmlsbCgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBwYXR0ZXJuUGF0aCggeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgdTAsIHYwLCB1MSwgdjEsIHUyLCB2MiwgdGV4dHVyZSApIHtcclxuXHJcblx0XHRcdGlmICggdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLkRhdGFUZXh0dXJlIHx8IHRleHR1cmUuaW1hZ2UgPT09IHVuZGVmaW5lZCB8fCB0ZXh0dXJlLmltYWdlLndpZHRoID09IDAgKSByZXR1cm47XHJcblxyXG5cdFx0XHRpZiAoIHRleHR1cmUubmVlZHNVcGRhdGUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdHZhciByZXBlYXRYID0gdGV4dHVyZS53cmFwUyA9PSBUSFJFRS5SZXBlYXRXcmFwcGluZztcclxuXHRcdFx0XHR2YXIgcmVwZWF0WSA9IHRleHR1cmUud3JhcFQgPT0gVEhSRUUuUmVwZWF0V3JhcHBpbmc7XHJcblxyXG5cdFx0XHRcdF9wYXR0ZXJuc1sgdGV4dHVyZS5pZCBdID0gX2NvbnRleHQuY3JlYXRlUGF0dGVybihcclxuXHRcdFx0XHRcdHRleHR1cmUuaW1hZ2UsIHJlcGVhdFggPT09IHRydWUgJiYgcmVwZWF0WSA9PT0gdHJ1ZVxyXG5cdFx0XHRcdFx0XHQ/ICdyZXBlYXQnXHJcblx0XHRcdFx0XHRcdDogcmVwZWF0WCA9PT0gdHJ1ZSAmJiByZXBlYXRZID09PSBmYWxzZVxyXG5cdFx0XHRcdFx0XHRcdD8gJ3JlcGVhdC14J1xyXG5cdFx0XHRcdFx0XHRcdDogcmVwZWF0WCA9PT0gZmFsc2UgJiYgcmVwZWF0WSA9PT0gdHJ1ZVxyXG5cdFx0XHRcdFx0XHRcdFx0PyAncmVwZWF0LXknXHJcblx0XHRcdFx0XHRcdFx0XHQ6ICduby1yZXBlYXQnXHJcblx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0X3BhdHRlcm5zWyB0ZXh0dXJlLmlkIF0gPT09IHVuZGVmaW5lZFxyXG5cdFx0XHRcdD8gc2V0RmlsbFN0eWxlKCAncmdiYSgwLDAsMCwxKScgKVxyXG5cdFx0XHRcdDogc2V0RmlsbFN0eWxlKCBfcGF0dGVybnNbIHRleHR1cmUuaWQgXSApO1xyXG5cclxuXHRcdFx0Ly8gaHR0cDovL2V4dHJlbWVseXNhdGlzZmFjdG9yeXRvdGFsaXRhcmlhbmlzbS5jb20vYmxvZy8/cD0yMTIwXHJcblxyXG5cdFx0XHR2YXIgYSwgYiwgYywgZCwgZSwgZiwgZGV0LCBpZGV0LFxyXG5cdFx0XHRvZmZzZXRYID0gdGV4dHVyZS5vZmZzZXQueCAvIHRleHR1cmUucmVwZWF0LngsXHJcblx0XHRcdG9mZnNldFkgPSB0ZXh0dXJlLm9mZnNldC55IC8gdGV4dHVyZS5yZXBlYXQueSxcclxuXHRcdFx0d2lkdGggPSB0ZXh0dXJlLmltYWdlLndpZHRoICogdGV4dHVyZS5yZXBlYXQueCxcclxuXHRcdFx0aGVpZ2h0ID0gdGV4dHVyZS5pbWFnZS5oZWlnaHQgKiB0ZXh0dXJlLnJlcGVhdC55O1xyXG5cclxuXHRcdFx0dTAgPSAoIHUwICsgb2Zmc2V0WCApICogd2lkdGg7XHJcblx0XHRcdHYwID0gKCAxLjAgLSB2MCArIG9mZnNldFkgKSAqIGhlaWdodDtcclxuXHJcblx0XHRcdHUxID0gKCB1MSArIG9mZnNldFggKSAqIHdpZHRoO1xyXG5cdFx0XHR2MSA9ICggMS4wIC0gdjEgKyBvZmZzZXRZICkgKiBoZWlnaHQ7XHJcblxyXG5cdFx0XHR1MiA9ICggdTIgKyBvZmZzZXRYICkgKiB3aWR0aDtcclxuXHRcdFx0djIgPSAoIDEuMCAtIHYyICsgb2Zmc2V0WSApICogaGVpZ2h0O1xyXG5cclxuXHRcdFx0eDEgLT0geDA7IHkxIC09IHkwO1xyXG5cdFx0XHR4MiAtPSB4MDsgeTIgLT0geTA7XHJcblxyXG5cdFx0XHR1MSAtPSB1MDsgdjEgLT0gdjA7XHJcblx0XHRcdHUyIC09IHUwOyB2MiAtPSB2MDtcclxuXHJcblx0XHRcdGRldCA9IHUxICogdjIgLSB1MiAqIHYxO1xyXG5cclxuXHRcdFx0aWYgKCBkZXQgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggX2ltYWdlZGF0YXNbIHRleHR1cmUuaWQgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApXHJcblx0XHRcdFx0XHRjYW52YXMud2lkdGggPSB0ZXh0dXJlLmltYWdlLndpZHRoO1xyXG5cdFx0XHRcdFx0Y2FudmFzLmhlaWdodCA9IHRleHR1cmUuaW1hZ2UuaGVpZ2h0O1xyXG5cclxuXHRcdFx0XHRcdHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcclxuXHRcdFx0XHRcdGNvbnRleHQuZHJhd0ltYWdlKCB0ZXh0dXJlLmltYWdlLCAwLCAwICk7XHJcblxyXG5cdFx0XHRcdFx0X2ltYWdlZGF0YXNbIHRleHR1cmUuaWQgXSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKCAwLCAwLCB0ZXh0dXJlLmltYWdlLndpZHRoLCB0ZXh0dXJlLmltYWdlLmhlaWdodCApLmRhdGE7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dmFyIGRhdGEgPSBfaW1hZ2VkYXRhc1sgdGV4dHVyZS5pZCBdO1xyXG5cdFx0XHRcdHZhciBpbmRleCA9ICggTWF0aC5mbG9vciggdTAgKSArIE1hdGguZmxvb3IoIHYwICkgKiB0ZXh0dXJlLmltYWdlLndpZHRoICkgKiA0O1xyXG5cclxuXHRcdFx0XHRfY29sb3Iuc2V0UkdCKCBkYXRhWyBpbmRleCBdIC8gMjU1LCBkYXRhWyBpbmRleCArIDEgXSAvIDI1NSwgZGF0YVsgaW5kZXggKyAyIF0gLyAyNTUgKTtcclxuXHRcdFx0XHRmaWxsUGF0aCggX2NvbG9yICk7XHJcblxyXG5cdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlkZXQgPSAxIC8gZGV0O1xyXG5cclxuXHRcdFx0YSA9ICggdjIgKiB4MSAtIHYxICogeDIgKSAqIGlkZXQ7XHJcblx0XHRcdGIgPSAoIHYyICogeTEgLSB2MSAqIHkyICkgKiBpZGV0O1xyXG5cdFx0XHRjID0gKCB1MSAqIHgyIC0gdTIgKiB4MSApICogaWRldDtcclxuXHRcdFx0ZCA9ICggdTEgKiB5MiAtIHUyICogeTEgKSAqIGlkZXQ7XHJcblxyXG5cdFx0XHRlID0geDAgLSBhICogdTAgLSBjICogdjA7XHJcblx0XHRcdGYgPSB5MCAtIGIgKiB1MCAtIGQgKiB2MDtcclxuXHJcblx0XHRcdF9jb250ZXh0LnNhdmUoKTtcclxuXHRcdFx0X2NvbnRleHQudHJhbnNmb3JtKCBhLCBiLCBjLCBkLCBlLCBmICk7XHJcblx0XHRcdF9jb250ZXh0LmZpbGwoKTtcclxuXHRcdFx0X2NvbnRleHQucmVzdG9yZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBjbGlwSW1hZ2UoIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHUwLCB2MCwgdTEsIHYxLCB1MiwgdjIsIGltYWdlICkge1xyXG5cclxuXHRcdFx0Ly8gaHR0cDovL2V4dHJlbWVseXNhdGlzZmFjdG9yeXRvdGFsaXRhcmlhbmlzbS5jb20vYmxvZy8/cD0yMTIwXHJcblxyXG5cdFx0XHR2YXIgYSwgYiwgYywgZCwgZSwgZiwgZGV0LCBpZGV0LFxyXG5cdFx0XHR3aWR0aCA9IGltYWdlLndpZHRoIC0gMSxcclxuXHRcdFx0aGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0IC0gMTtcclxuXHJcblx0XHRcdHUwICo9IHdpZHRoOyB2MCAqPSBoZWlnaHQ7XHJcblx0XHRcdHUxICo9IHdpZHRoOyB2MSAqPSBoZWlnaHQ7XHJcblx0XHRcdHUyICo9IHdpZHRoOyB2MiAqPSBoZWlnaHQ7XHJcblxyXG5cdFx0XHR4MSAtPSB4MDsgeTEgLT0geTA7XHJcblx0XHRcdHgyIC09IHgwOyB5MiAtPSB5MDtcclxuXHJcblx0XHRcdHUxIC09IHUwOyB2MSAtPSB2MDtcclxuXHRcdFx0dTIgLT0gdTA7IHYyIC09IHYwO1xyXG5cclxuXHRcdFx0ZGV0ID0gdTEgKiB2MiAtIHUyICogdjE7XHJcblxyXG5cdFx0XHRpZGV0ID0gMSAvIGRldDtcclxuXHJcblx0XHRcdGEgPSAoIHYyICogeDEgLSB2MSAqIHgyICkgKiBpZGV0O1xyXG5cdFx0XHRiID0gKCB2MiAqIHkxIC0gdjEgKiB5MiApICogaWRldDtcclxuXHRcdFx0YyA9ICggdTEgKiB4MiAtIHUyICogeDEgKSAqIGlkZXQ7XHJcblx0XHRcdGQgPSAoIHUxICogeTIgLSB1MiAqIHkxICkgKiBpZGV0O1xyXG5cclxuXHRcdFx0ZSA9IHgwIC0gYSAqIHUwIC0gYyAqIHYwO1xyXG5cdFx0XHRmID0geTAgLSBiICogdTAgLSBkICogdjA7XHJcblxyXG5cdFx0XHRfY29udGV4dC5zYXZlKCk7XHJcblx0XHRcdF9jb250ZXh0LnRyYW5zZm9ybSggYSwgYiwgYywgZCwgZSwgZiApO1xyXG5cdFx0XHRfY29udGV4dC5jbGlwKCk7XHJcblx0XHRcdF9jb250ZXh0LmRyYXdJbWFnZSggaW1hZ2UsIDAsIDAgKTtcclxuXHRcdFx0X2NvbnRleHQucmVzdG9yZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBnZXRHcmFkaWVudFRleHR1cmUoIGNvbG9yMSwgY29sb3IyLCBjb2xvcjMsIGNvbG9yNCApIHtcclxuXHJcblx0XHRcdC8vIGh0dHA6Ly9tcmRvb2IuY29tL2Jsb2cvcG9zdC83MTBcclxuXHJcblx0XHRcdF9waXhlbE1hcERhdGFbIDAgXSA9ICggY29sb3IxLnIgKiAyNTUgKSB8IDA7XHJcblx0XHRcdF9waXhlbE1hcERhdGFbIDEgXSA9ICggY29sb3IxLmcgKiAyNTUgKSB8IDA7XHJcblx0XHRcdF9waXhlbE1hcERhdGFbIDIgXSA9ICggY29sb3IxLmIgKiAyNTUgKSB8IDA7XHJcblxyXG5cdFx0XHRfcGl4ZWxNYXBEYXRhWyA0IF0gPSAoIGNvbG9yMi5yICogMjU1ICkgfCAwO1xyXG5cdFx0XHRfcGl4ZWxNYXBEYXRhWyA1IF0gPSAoIGNvbG9yMi5nICogMjU1ICkgfCAwO1xyXG5cdFx0XHRfcGl4ZWxNYXBEYXRhWyA2IF0gPSAoIGNvbG9yMi5iICogMjU1ICkgfCAwO1xyXG5cclxuXHRcdFx0X3BpeGVsTWFwRGF0YVsgOCBdID0gKCBjb2xvcjMuciAqIDI1NSApIHwgMDtcclxuXHRcdFx0X3BpeGVsTWFwRGF0YVsgOSBdID0gKCBjb2xvcjMuZyAqIDI1NSApIHwgMDtcclxuXHRcdFx0X3BpeGVsTWFwRGF0YVsgMTAgXSA9ICggY29sb3IzLmIgKiAyNTUgKSB8IDA7XHJcblxyXG5cdFx0XHRfcGl4ZWxNYXBEYXRhWyAxMiBdID0gKCBjb2xvcjQuciAqIDI1NSApIHwgMDtcclxuXHRcdFx0X3BpeGVsTWFwRGF0YVsgMTMgXSA9ICggY29sb3I0LmcgKiAyNTUgKSB8IDA7XHJcblx0XHRcdF9waXhlbE1hcERhdGFbIDE0IF0gPSAoIGNvbG9yNC5iICogMjU1ICkgfCAwO1xyXG5cclxuXHRcdFx0X3BpeGVsTWFwQ29udGV4dC5wdXRJbWFnZURhdGEoIF9waXhlbE1hcEltYWdlLCAwLCAwICk7XHJcblx0XHRcdF9ncmFkaWVudE1hcENvbnRleHQuZHJhd0ltYWdlKCBfcGl4ZWxNYXAsIDAsIDAgKTtcclxuXHJcblx0XHRcdHJldHVybiBfZ3JhZGllbnRNYXA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEhpZGUgYW50aS1hbGlhcyBnYXBzXHJcblxyXG5cdFx0ZnVuY3Rpb24gZXhwYW5kKCB2MSwgdjIgKSB7XHJcblxyXG5cdFx0XHR2YXIgeCA9IHYyLnggLSB2MS54LCB5ID0gIHYyLnkgLSB2MS55LFxyXG5cdFx0XHRkZXQgPSB4ICogeCArIHkgKiB5LCBpZGV0O1xyXG5cclxuXHRcdFx0aWYgKCBkZXQgPT09IDAgKSByZXR1cm47XHJcblxyXG5cdFx0XHRpZGV0ID0gMSAvIE1hdGguc3FydCggZGV0ICk7XHJcblxyXG5cdFx0XHR4ICo9IGlkZXQ7IHkgKj0gaWRldDtcclxuXHJcblx0XHRcdHYyLnggKz0geDsgdjIueSArPSB5O1xyXG5cdFx0XHR2MS54IC09IHg7IHYxLnkgLT0geTtcclxuXHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0Ly8gQ29udGV4dCBjYWNoZWQgbWV0aG9kcy5cclxuXHJcblx0ZnVuY3Rpb24gc2V0T3BhY2l0eSggdmFsdWUgKSB7XHJcblxyXG5cdFx0aWYgKCBfY29udGV4dEdsb2JhbEFscGhhICE9PSB2YWx1ZSApIHtcclxuXHJcblx0XHRcdF9jb250ZXh0Lmdsb2JhbEFscGhhID0gdmFsdWU7XHJcblx0XHRcdF9jb250ZXh0R2xvYmFsQWxwaGEgPSB2YWx1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gc2V0QmxlbmRpbmcoIHZhbHVlICkge1xyXG5cclxuXHRcdGlmICggX2NvbnRleHRHbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gIT09IHZhbHVlICkge1xyXG5cclxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gVEhSRUUuTm9ybWFsQmxlbmRpbmcgKSB7XHJcblxyXG5cdFx0XHRcdF9jb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdzb3VyY2Utb3Zlcic7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSA9PT0gVEhSRUUuQWRkaXRpdmVCbGVuZGluZyApIHtcclxuXHJcblx0XHRcdFx0X2NvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2xpZ2h0ZXInO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggdmFsdWUgPT09IFRIUkVFLlN1YnRyYWN0aXZlQmxlbmRpbmcgKSB7XHJcblxyXG5cdFx0XHRcdF9jb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkYXJrZXInO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0X2NvbnRleHRHbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSB2YWx1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gc2V0TGluZVdpZHRoKCB2YWx1ZSApIHtcclxuXHJcblx0XHRpZiAoIF9jb250ZXh0TGluZVdpZHRoICE9PSB2YWx1ZSApIHtcclxuXHJcblx0XHRcdF9jb250ZXh0LmxpbmVXaWR0aCA9IHZhbHVlO1xyXG5cdFx0XHRfY29udGV4dExpbmVXaWR0aCA9IHZhbHVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzZXRMaW5lQ2FwKCB2YWx1ZSApIHtcclxuXHJcblx0XHQvLyBcImJ1dHRcIiwgXCJyb3VuZFwiLCBcInNxdWFyZVwiXHJcblxyXG5cdFx0aWYgKCBfY29udGV4dExpbmVDYXAgIT09IHZhbHVlICkge1xyXG5cclxuXHRcdFx0X2NvbnRleHQubGluZUNhcCA9IHZhbHVlO1xyXG5cdFx0XHRfY29udGV4dExpbmVDYXAgPSB2YWx1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gc2V0TGluZUpvaW4oIHZhbHVlICkge1xyXG5cclxuXHRcdC8vIFwicm91bmRcIiwgXCJiZXZlbFwiLCBcIm1pdGVyXCJcclxuXHJcblx0XHRpZiAoIF9jb250ZXh0TGluZUpvaW4gIT09IHZhbHVlICkge1xyXG5cclxuXHRcdFx0X2NvbnRleHQubGluZUpvaW4gPSB2YWx1ZTtcclxuXHRcdFx0X2NvbnRleHRMaW5lSm9pbiA9IHZhbHVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzZXRTdHJva2VTdHlsZSggdmFsdWUgKSB7XHJcblxyXG5cdFx0aWYgKCBfY29udGV4dFN0cm9rZVN0eWxlICE9PSB2YWx1ZSApIHtcclxuXHJcblx0XHRcdF9jb250ZXh0LnN0cm9rZVN0eWxlID0gdmFsdWU7XHJcblx0XHRcdF9jb250ZXh0U3Ryb2tlU3R5bGUgPSB2YWx1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gc2V0RmlsbFN0eWxlKCB2YWx1ZSApIHtcclxuXHJcblx0XHRpZiAoIF9jb250ZXh0RmlsbFN0eWxlICE9PSB2YWx1ZSApIHtcclxuXHJcblx0XHRcdF9jb250ZXh0LmZpbGxTdHlsZSA9IHZhbHVlO1xyXG5cdFx0XHRfY29udGV4dEZpbGxTdHlsZSA9IHZhbHVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzZXREYXNoQW5kR2FwKCBkYXNoU2l6ZVZhbHVlLCBnYXBTaXplVmFsdWUgKSB7XHJcblxyXG5cdFx0aWYgKCBfY29udGV4dERhc2hTaXplICE9PSBkYXNoU2l6ZVZhbHVlIHx8IF9jb250ZXh0R2FwU2l6ZSAhPT0gZ2FwU2l6ZVZhbHVlICkge1xyXG5cclxuXHRcdFx0X2NvbnRleHQuc2V0TGluZURhc2goIFsgZGFzaFNpemVWYWx1ZSwgZ2FwU2l6ZVZhbHVlIF0gKTtcclxuXHRcdFx0X2NvbnRleHREYXNoU2l6ZSA9IGRhc2hTaXplVmFsdWU7XHJcblx0XHRcdF9jb250ZXh0R2FwU2l6ZSA9IGdhcFNpemVWYWx1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn07XHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKi9cclxuXHJcblRIUkVFLlNoYWRlckNodW5rID0ge1xyXG5cclxuXHQvLyBGT0dcclxuXHJcblx0Zm9nX3BhcnNfZnJhZ21lbnQ6IFtcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfRk9HXCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBmb2dDb2xvcjtcIixcclxuXHJcblx0XHRcdFwiI2lmZGVmIEZPR19FWFAyXCIsXHJcblxyXG5cdFx0XHRcdFwidW5pZm9ybSBmbG9hdCBmb2dEZW5zaXR5O1wiLFxyXG5cclxuXHRcdFx0XCIjZWxzZVwiLFxyXG5cclxuXHRcdFx0XHRcInVuaWZvcm0gZmxvYXQgZm9nTmVhcjtcIixcclxuXHRcdFx0XHRcInVuaWZvcm0gZmxvYXQgZm9nRmFyO1wiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0Zm9nX2ZyYWdtZW50OiBbXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX0ZPR1wiLFxyXG5cclxuXHRcdFx0XCJmbG9hdCBkZXB0aCA9IGdsX0ZyYWdDb29yZC56IC8gZ2xfRnJhZ0Nvb3JkLnc7XCIsXHJcblxyXG5cdFx0XHRcIiNpZmRlZiBGT0dfRVhQMlwiLFxyXG5cclxuXHRcdFx0XHRcImNvbnN0IGZsb2F0IExPRzIgPSAxLjQ0MjY5NTtcIixcclxuXHRcdFx0XHRcImZsb2F0IGZvZ0ZhY3RvciA9IGV4cDIoIC0gZm9nRGVuc2l0eSAqIGZvZ0RlbnNpdHkgKiBkZXB0aCAqIGRlcHRoICogTE9HMiApO1wiLFxyXG5cdFx0XHRcdFwiZm9nRmFjdG9yID0gMS4wIC0gY2xhbXAoIGZvZ0ZhY3RvciwgMC4wLCAxLjAgKTtcIixcclxuXHJcblx0XHRcdFwiI2Vsc2VcIixcclxuXHJcblx0XHRcdFx0XCJmbG9hdCBmb2dGYWN0b3IgPSBzbW9vdGhzdGVwKCBmb2dOZWFyLCBmb2dGYXIsIGRlcHRoICk7XCIsXHJcblxyXG5cdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XCJnbF9GcmFnQ29sb3IgPSBtaXgoIGdsX0ZyYWdDb2xvciwgdmVjNCggZm9nQ29sb3IsIGdsX0ZyYWdDb2xvci53ICksIGZvZ0ZhY3RvciApO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHQvLyBFTlZJUk9OTUVOVCBNQVBcclxuXHJcblx0ZW52bWFwX3BhcnNfZnJhZ21lbnQ6IFtcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfRU5WTUFQXCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgcmVmbGVjdGl2aXR5O1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gc2FtcGxlckN1YmUgZW52TWFwO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgZmxpcEVudk1hcDtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGludCBjb21iaW5lO1wiLFxyXG5cclxuXHRcdFx0XCIjaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQIClcIixcclxuXHJcblx0XHRcdFx0XCJ1bmlmb3JtIGJvb2wgdXNlUmVmcmFjdDtcIixcclxuXHRcdFx0XHRcInVuaWZvcm0gZmxvYXQgcmVmcmFjdGlvblJhdGlvO1wiLFxyXG5cclxuXHRcdFx0XCIjZWxzZVwiLFxyXG5cclxuXHRcdFx0XHRcInZhcnlpbmcgdmVjMyB2UmVmbGVjdDtcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdGVudm1hcF9mcmFnbWVudDogW1xyXG5cclxuXHRcdFwiI2lmZGVmIFVTRV9FTlZNQVBcIixcclxuXHJcblx0XHRcdFwidmVjMyByZWZsZWN0VmVjO1wiLFxyXG5cclxuXHRcdFx0XCIjaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQIClcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWMzIGNhbWVyYVRvVmVydGV4ID0gbm9ybWFsaXplKCB2V29ybGRQb3NpdGlvbiAtIGNhbWVyYVBvc2l0aW9uICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiaWYgKCB1c2VSZWZyYWN0ICkge1wiLFxyXG5cclxuXHRcdFx0XHRcdFwicmVmbGVjdFZlYyA9IHJlZnJhY3QoIGNhbWVyYVRvVmVydGV4LCBub3JtYWwsIHJlZnJhY3Rpb25SYXRpbyApO1wiLFxyXG5cclxuXHRcdFx0XHRcIn0gZWxzZSB7IFwiLFxyXG5cclxuXHRcdFx0XHRcdFwicmVmbGVjdFZlYyA9IHJlZmxlY3QoIGNhbWVyYVRvVmVydGV4LCBub3JtYWwgKTtcIixcclxuXHJcblx0XHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcdFwicmVmbGVjdFZlYyA9IHZSZWZsZWN0O1wiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFwiI2lmZGVmIERPVUJMRV9TSURFRFwiLFxyXG5cclxuXHRcdFx0XHRcImZsb2F0IGZsaXBOb3JtYWwgPSAoIC0xLjAgKyAyLjAgKiBmbG9hdCggZ2xfRnJvbnRGYWNpbmcgKSApO1wiLFxyXG5cdFx0XHRcdFwidmVjNCBjdWJlQ29sb3IgPSB0ZXh0dXJlQ3ViZSggZW52TWFwLCBmbGlwTm9ybWFsICogdmVjMyggZmxpcEVudk1hcCAqIHJlZmxlY3RWZWMueCwgcmVmbGVjdFZlYy55eiApICk7XCIsXHJcblxyXG5cdFx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcdFwidmVjNCBjdWJlQ29sb3IgPSB0ZXh0dXJlQ3ViZSggZW52TWFwLCB2ZWMzKCBmbGlwRW52TWFwICogcmVmbGVjdFZlYy54LCByZWZsZWN0VmVjLnl6ICkgKTtcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcIiNpZmRlZiBHQU1NQV9JTlBVVFwiLFxyXG5cclxuXHRcdFx0XHRcImN1YmVDb2xvci54eXogKj0gY3ViZUNvbG9yLnh5ejtcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcImlmICggY29tYmluZSA9PSAxICkge1wiLFxyXG5cclxuXHRcdFx0XHRcImdsX0ZyYWdDb2xvci54eXogPSBtaXgoIGdsX0ZyYWdDb2xvci54eXosIGN1YmVDb2xvci54eXosIHNwZWN1bGFyU3RyZW5ndGggKiByZWZsZWN0aXZpdHkgKTtcIixcclxuXHJcblx0XHRcdFwifSBlbHNlIGlmICggY29tYmluZSA9PSAyICkge1wiLFxyXG5cclxuXHRcdFx0XHRcImdsX0ZyYWdDb2xvci54eXogKz0gY3ViZUNvbG9yLnh5eiAqIHNwZWN1bGFyU3RyZW5ndGggKiByZWZsZWN0aXZpdHk7XCIsXHJcblxyXG5cdFx0XHRcIn0gZWxzZSB7XCIsXHJcblxyXG5cdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yLnh5eiA9IG1peCggZ2xfRnJhZ0NvbG9yLnh5eiwgZ2xfRnJhZ0NvbG9yLnh5eiAqIGN1YmVDb2xvci54eXosIHNwZWN1bGFyU3RyZW5ndGggKiByZWZsZWN0aXZpdHkgKTtcIixcclxuXHJcblx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRlbnZtYXBfcGFyc192ZXJ0ZXg6IFtcclxuXHJcblx0XHRcIiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgJiYgISBkZWZpbmVkKCBVU0VfQlVNUE1BUCApICYmICEgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApXCIsXHJcblxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2UmVmbGVjdDtcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCByZWZyYWN0aW9uUmF0aW87XCIsXHJcblx0XHRcdFwidW5pZm9ybSBib29sIHVzZVJlZnJhY3Q7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdHdvcmxkcG9zX3ZlcnRleCA6IFtcclxuXHJcblx0XHRcIiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgfHwgZGVmaW5lZCggUEhPTkcgKSB8fCBkZWZpbmVkKCBMQU1CRVJUICkgfHwgZGVmaW5lZCAoIFVTRV9TSEFET1dNQVAgKVwiLFxyXG5cclxuXHRcdFx0XCIjaWZkZWYgVVNFX1NLSU5OSU5HXCIsXHJcblxyXG5cdFx0XHRcdFwidmVjNCB3b3JsZFBvc2l0aW9uID0gbW9kZWxNYXRyaXggKiBza2lubmVkO1wiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFwiI2lmIGRlZmluZWQoIFVTRV9NT1JQSFRBUkdFVFMgKSAmJiAhIGRlZmluZWQoIFVTRV9TS0lOTklORyApXCIsXHJcblxyXG5cdFx0XHRcdFwidmVjNCB3b3JsZFBvc2l0aW9uID0gbW9kZWxNYXRyaXggKiB2ZWM0KCBtb3JwaGVkLCAxLjAgKTtcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcIiNpZiAhIGRlZmluZWQoIFVTRV9NT1JQSFRBUkdFVFMgKSAmJiAhIGRlZmluZWQoIFVTRV9TS0lOTklORyApXCIsXHJcblxyXG5cdFx0XHRcdFwidmVjNCB3b3JsZFBvc2l0aW9uID0gbW9kZWxNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXHJcblxyXG5cdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRlbnZtYXBfdmVydGV4IDogW1xyXG5cclxuXHRcdFwiI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSAmJiAhIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgJiYgISBkZWZpbmVkKCBVU0VfTk9STUFMTUFQIClcIixcclxuXHJcblx0XHRcdFwidmVjMyB3b3JsZE5vcm1hbCA9IG1hdDMoIG1vZGVsTWF0cml4WyAwIF0ueHl6LCBtb2RlbE1hdHJpeFsgMSBdLnh5eiwgbW9kZWxNYXRyaXhbIDIgXS54eXogKSAqIG9iamVjdE5vcm1hbDtcIixcclxuXHRcdFx0XCJ3b3JsZE5vcm1hbCA9IG5vcm1hbGl6ZSggd29ybGROb3JtYWwgKTtcIixcclxuXHJcblx0XHRcdFwidmVjMyBjYW1lcmFUb1ZlcnRleCA9IG5vcm1hbGl6ZSggd29ybGRQb3NpdGlvbi54eXogLSBjYW1lcmFQb3NpdGlvbiApO1wiLFxyXG5cclxuXHRcdFx0XCJpZiAoIHVzZVJlZnJhY3QgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFwidlJlZmxlY3QgPSByZWZyYWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwsIHJlZnJhY3Rpb25SYXRpbyApO1wiLFxyXG5cclxuXHRcdFx0XCJ9IGVsc2Uge1wiLFxyXG5cclxuXHRcdFx0XHRcInZSZWZsZWN0ID0gcmVmbGVjdCggY2FtZXJhVG9WZXJ0ZXgsIHdvcmxkTm9ybWFsICk7XCIsXHJcblxyXG5cdFx0XHRcIn1cIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0Ly8gQ09MT1IgTUFQIChwYXJ0aWNsZXMpXHJcblxyXG5cdG1hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50OiBbXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX01BUFwiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCBtYXA7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cclxuXHRtYXBfcGFydGljbGVfZnJhZ21lbnQ6IFtcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfTUFQXCIsXHJcblxyXG5cdFx0XHRcImdsX0ZyYWdDb2xvciA9IGdsX0ZyYWdDb2xvciAqIHRleHR1cmUyRCggbWFwLCB2ZWMyKCBnbF9Qb2ludENvb3JkLngsIDEuMCAtIGdsX1BvaW50Q29vcmQueSApICk7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdC8vIENPTE9SIE1BUCAodHJpYW5nbGVzKVxyXG5cclxuXHRtYXBfcGFyc192ZXJ0ZXg6IFtcclxuXHJcblx0XHRcIiNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX1NQRUNVTEFSTUFQIClcIixcclxuXHJcblx0XHRcdFwidmFyeWluZyB2ZWMyIHZVdjtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzQgb2Zmc2V0UmVwZWF0O1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRtYXBfcGFyc19mcmFnbWVudDogW1xyXG5cclxuXHRcdFwiI2lmIGRlZmluZWQoIFVTRV9NQVAgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBVU0VfU1BFQ1VMQVJNQVAgKVwiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzIgdlV2O1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX01BUFwiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCBtYXA7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdG1hcF92ZXJ0ZXg6IFtcclxuXHJcblx0XHRcIiNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX1NQRUNVTEFSTUFQIClcIixcclxuXHJcblx0XHRcdFwidlV2ID0gdXYgKiBvZmZzZXRSZXBlYXQuencgKyBvZmZzZXRSZXBlYXQueHk7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdG1hcF9mcmFnbWVudDogW1xyXG5cclxuXHRcdFwiI2lmZGVmIFVTRV9NQVBcIixcclxuXHJcblx0XHRcdFwidmVjNCB0ZXhlbENvbG9yID0gdGV4dHVyZTJEKCBtYXAsIHZVdiApO1wiLFxyXG5cclxuXHRcdFx0XCIjaWZkZWYgR0FNTUFfSU5QVVRcIixcclxuXHJcblx0XHRcdFx0XCJ0ZXhlbENvbG9yLnh5eiAqPSB0ZXhlbENvbG9yLnh5ejtcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcImdsX0ZyYWdDb2xvciA9IGdsX0ZyYWdDb2xvciAqIHRleGVsQ29sb3I7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdC8vIExJR0hUIE1BUFxyXG5cclxuXHRsaWdodG1hcF9wYXJzX2ZyYWdtZW50OiBbXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX0xJR0hUTUFQXCIsXHJcblxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMiB2VXYyO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIGxpZ2h0TWFwO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRsaWdodG1hcF9wYXJzX3ZlcnRleDogW1xyXG5cclxuXHRcdFwiI2lmZGVmIFVTRV9MSUdIVE1BUFwiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzIgdlV2MjtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0bGlnaHRtYXBfZnJhZ21lbnQ6IFtcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfTElHSFRNQVBcIixcclxuXHJcblx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gZ2xfRnJhZ0NvbG9yICogdGV4dHVyZTJEKCBsaWdodE1hcCwgdlV2MiApO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRsaWdodG1hcF92ZXJ0ZXg6IFtcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfTElHSFRNQVBcIixcclxuXHJcblx0XHRcdFwidlV2MiA9IHV2MjtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0Ly8gQlVNUCBNQVBcclxuXHJcblx0YnVtcG1hcF9wYXJzX2ZyYWdtZW50OiBbXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX0JVTVBNQVBcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgYnVtcE1hcDtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IGJ1bXBTY2FsZTtcIixcclxuXHJcblx0XHRcdC8vIERlcml2YXRpdmUgbWFwcyAtIGJ1bXAgbWFwcGluZyB1bnBhcmFtZXRyaXplZCBzdXJmYWNlcyBieSBNb3J0ZW4gTWlra2Vsc2VuXHJcblx0XHRcdC8vXHRodHRwOi8vbW1pa2tlbHNlbjNkLmJsb2dzcG90LnNrLzIwMTEvMDcvZGVyaXZhdGl2ZS1tYXBzLmh0bWxcclxuXHJcblx0XHRcdC8vIEV2YWx1YXRlIHRoZSBkZXJpdmF0aXZlIG9mIHRoZSBoZWlnaHQgdy5yLnQuIHNjcmVlbi1zcGFjZSB1c2luZyBmb3J3YXJkIGRpZmZlcmVuY2luZyAobGlzdGluZyAyKVxyXG5cclxuXHRcdFx0XCJ2ZWMyIGRIZHh5X2Z3ZCgpIHtcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWMyIGRTVGR4ID0gZEZkeCggdlV2ICk7XCIsXHJcblx0XHRcdFx0XCJ2ZWMyIGRTVGR5ID0gZEZkeSggdlV2ICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiZmxvYXQgSGxsID0gYnVtcFNjYWxlICogdGV4dHVyZTJEKCBidW1wTWFwLCB2VXYgKS54O1wiLFxyXG5cdFx0XHRcdFwiZmxvYXQgZEJ4ID0gYnVtcFNjYWxlICogdGV4dHVyZTJEKCBidW1wTWFwLCB2VXYgKyBkU1RkeCApLnggLSBIbGw7XCIsXHJcblx0XHRcdFx0XCJmbG9hdCBkQnkgPSBidW1wU2NhbGUgKiB0ZXh0dXJlMkQoIGJ1bXBNYXAsIHZVdiArIGRTVGR5ICkueCAtIEhsbDtcIixcclxuXHJcblx0XHRcdFx0XCJyZXR1cm4gdmVjMiggZEJ4LCBkQnkgKTtcIixcclxuXHJcblx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFx0XCJ2ZWMzIHBlcnR1cmJOb3JtYWxBcmIoIHZlYzMgc3VyZl9wb3MsIHZlYzMgc3VyZl9ub3JtLCB2ZWMyIGRIZHh5ICkge1wiLFxyXG5cclxuXHRcdFx0XHRcInZlYzMgdlNpZ21hWCA9IGRGZHgoIHN1cmZfcG9zICk7XCIsXHJcblx0XHRcdFx0XCJ2ZWMzIHZTaWdtYVkgPSBkRmR5KCBzdXJmX3BvcyApO1wiLFxyXG5cdFx0XHRcdFwidmVjMyB2TiA9IHN1cmZfbm9ybTtcIixcdFx0Ly8gbm9ybWFsaXplZFxyXG5cclxuXHRcdFx0XHRcInZlYzMgUjEgPSBjcm9zcyggdlNpZ21hWSwgdk4gKTtcIixcclxuXHRcdFx0XHRcInZlYzMgUjIgPSBjcm9zcyggdk4sIHZTaWdtYVggKTtcIixcclxuXHJcblx0XHRcdFx0XCJmbG9hdCBmRGV0ID0gZG90KCB2U2lnbWFYLCBSMSApO1wiLFxyXG5cclxuXHRcdFx0XHRcInZlYzMgdkdyYWQgPSBzaWduKCBmRGV0ICkgKiAoIGRIZHh5LnggKiBSMSArIGRIZHh5LnkgKiBSMiApO1wiLFxyXG5cdFx0XHRcdFwicmV0dXJuIG5vcm1hbGl6ZSggYWJzKCBmRGV0ICkgKiBzdXJmX25vcm0gLSB2R3JhZCApO1wiLFxyXG5cclxuXHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdC8vIE5PUk1BTCBNQVBcclxuXHJcblx0bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ6IFtcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfTk9STUFMTUFQXCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIG5vcm1hbE1hcDtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzIgbm9ybWFsU2NhbGU7XCIsXHJcblxyXG5cdFx0XHQvLyBQZXItUGl4ZWwgVGFuZ2VudCBTcGFjZSBOb3JtYWwgTWFwcGluZ1xyXG5cdFx0XHQvLyBodHRwOi8vaGFja3NvZmxpZmUuYmxvZ3Nwb3QuY2gvMjAwOS8xMS9wZXItcGl4ZWwtdGFuZ2VudC1zcGFjZS1ub3JtYWwtbWFwcGluZy5odG1sXHJcblxyXG5cdFx0XHRcInZlYzMgcGVydHVyYk5vcm1hbDJBcmIoIHZlYzMgZXllX3BvcywgdmVjMyBzdXJmX25vcm0gKSB7XCIsXHJcblxyXG5cdFx0XHRcdFwidmVjMyBxMCA9IGRGZHgoIGV5ZV9wb3MueHl6ICk7XCIsXHJcblx0XHRcdFx0XCJ2ZWMzIHExID0gZEZkeSggZXllX3Bvcy54eXogKTtcIixcclxuXHRcdFx0XHRcInZlYzIgc3QwID0gZEZkeCggdlV2LnN0ICk7XCIsXHJcblx0XHRcdFx0XCJ2ZWMyIHN0MSA9IGRGZHkoIHZVdi5zdCApO1wiLFxyXG5cclxuXHRcdFx0XHRcInZlYzMgUyA9IG5vcm1hbGl6ZSggIHEwICogc3QxLnQgLSBxMSAqIHN0MC50ICk7XCIsXHJcblx0XHRcdFx0XCJ2ZWMzIFQgPSBub3JtYWxpemUoIC1xMCAqIHN0MS5zICsgcTEgKiBzdDAucyApO1wiLFxyXG5cdFx0XHRcdFwidmVjMyBOID0gbm9ybWFsaXplKCBzdXJmX25vcm0gKTtcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWMzIG1hcE4gPSB0ZXh0dXJlMkQoIG5vcm1hbE1hcCwgdlV2ICkueHl6ICogMi4wIC0gMS4wO1wiLFxyXG5cdFx0XHRcdFwibWFwTi54eSA9IG5vcm1hbFNjYWxlICogbWFwTi54eTtcIixcclxuXHRcdFx0XHRcIm1hdDMgdHNuID0gbWF0MyggUywgVCwgTiApO1wiLFxyXG5cdFx0XHRcdFwicmV0dXJuIG5vcm1hbGl6ZSggdHNuICogbWFwTiApO1wiLFxyXG5cclxuXHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdC8vIFNQRUNVTEFSIE1BUFxyXG5cclxuXHRzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50OiBbXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX1NQRUNVTEFSTUFQXCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIHNwZWN1bGFyTWFwO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRzcGVjdWxhcm1hcF9mcmFnbWVudDogW1xyXG5cclxuXHRcdFwiZmxvYXQgc3BlY3VsYXJTdHJlbmd0aDtcIixcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfU1BFQ1VMQVJNQVBcIixcclxuXHJcblx0XHRcdFwidmVjNCB0ZXhlbFNwZWN1bGFyID0gdGV4dHVyZTJEKCBzcGVjdWxhck1hcCwgdlV2ICk7XCIsXHJcblx0XHRcdFwic3BlY3VsYXJTdHJlbmd0aCA9IHRleGVsU3BlY3VsYXIucjtcIixcclxuXHJcblx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcInNwZWN1bGFyU3RyZW5ndGggPSAxLjA7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdC8vIExJR0hUUyBMQU1CRVJUXHJcblxyXG5cdGxpZ2h0c19sYW1iZXJ0X3BhcnNfdmVydGV4OiBbXHJcblxyXG5cdFx0XCJ1bmlmb3JtIHZlYzMgYW1iaWVudDtcIixcclxuXHRcdFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XCIsXHJcblx0XHRcInVuaWZvcm0gdmVjMyBlbWlzc2l2ZTtcIixcclxuXHJcblx0XHRcInVuaWZvcm0gdmVjMyBhbWJpZW50TGlnaHRDb2xvcjtcIixcclxuXHJcblx0XHRcIiNpZiBNQVhfRElSX0xJR0hUUyA+IDBcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGRpcmVjdGlvbmFsTGlnaHRDb2xvclsgTUFYX0RJUl9MSUdIVFMgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvblsgTUFYX0RJUl9MSUdIVFMgXTtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiI2lmIE1BWF9IRU1JX0xJR0hUUyA+IDBcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGhlbWlzcGhlcmVMaWdodFNreUNvbG9yWyBNQVhfSEVNSV9MSUdIVFMgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3JbIE1BWF9IRU1JX0xJR0hUUyBdO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHREaXJlY3Rpb25bIE1BWF9IRU1JX0xJR0hUUyBdO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjaWYgTUFYX1BPSU5UX0xJR0hUUyA+IDBcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIHBvaW50TGlnaHRDb2xvclsgTUFYX1BPSU5UX0xJR0hUUyBdO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBwb2ludExpZ2h0UG9zaXRpb25bIE1BWF9QT0lOVF9MSUdIVFMgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHBvaW50TGlnaHREaXN0YW5jZVsgTUFYX1BPSU5UX0xJR0hUUyBdO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjaWYgTUFYX1NQT1RfTElHSFRTID4gMFwiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgc3BvdExpZ2h0Q29sb3JbIE1BWF9TUE9UX0xJR0hUUyBdO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBzcG90TGlnaHRQb3NpdGlvblsgTUFYX1NQT1RfTElHSFRTIF07XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIHNwb3RMaWdodERpcmVjdGlvblsgTUFYX1NQT1RfTElHSFRTIF07XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBzcG90TGlnaHREaXN0YW5jZVsgTUFYX1NQT1RfTElHSFRTIF07XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBzcG90TGlnaHRBbmdsZUNvc1sgTUFYX1NQT1RfTElHSFRTIF07XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBzcG90TGlnaHRFeHBvbmVudFsgTUFYX1NQT1RfTElHSFRTIF07XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNpZmRlZiBXUkFQX0FST1VORFwiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgd3JhcFJHQjtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0bGlnaHRzX2xhbWJlcnRfdmVydGV4OiBbXHJcblxyXG5cdFx0XCJ2TGlnaHRGcm9udCA9IHZlYzMoIDAuMCApO1wiLFxyXG5cclxuXHRcdFwiI2lmZGVmIERPVUJMRV9TSURFRFwiLFxyXG5cclxuXHRcdFx0XCJ2TGlnaHRCYWNrID0gdmVjMyggMC4wICk7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcInRyYW5zZm9ybWVkTm9ybWFsID0gbm9ybWFsaXplKCB0cmFuc2Zvcm1lZE5vcm1hbCApO1wiLFxyXG5cclxuXHRcdFwiI2lmIE1BWF9ESVJfTElHSFRTID4gMFwiLFxyXG5cclxuXHRcdFwiZm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfRElSX0xJR0hUUzsgaSArKyApIHtcIixcclxuXHJcblx0XHRcdFwidmVjNCBsRGlyZWN0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIGRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25bIGkgXSwgMC4wICk7XCIsXHJcblx0XHRcdFwidmVjMyBkaXJWZWN0b3IgPSBub3JtYWxpemUoIGxEaXJlY3Rpb24ueHl6ICk7XCIsXHJcblxyXG5cdFx0XHRcImZsb2F0IGRvdFByb2R1Y3QgPSBkb3QoIHRyYW5zZm9ybWVkTm9ybWFsLCBkaXJWZWN0b3IgKTtcIixcclxuXHRcdFx0XCJ2ZWMzIGRpcmVjdGlvbmFsTGlnaHRXZWlnaHRpbmcgPSB2ZWMzKCBtYXgoIGRvdFByb2R1Y3QsIDAuMCApICk7XCIsXHJcblxyXG5cdFx0XHRcIiNpZmRlZiBET1VCTEVfU0lERURcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWMzIGRpcmVjdGlvbmFsTGlnaHRXZWlnaHRpbmdCYWNrID0gdmVjMyggbWF4KCAtZG90UHJvZHVjdCwgMC4wICkgKTtcIixcclxuXHJcblx0XHRcdFx0XCIjaWZkZWYgV1JBUF9BUk9VTkRcIixcclxuXHJcblx0XHRcdFx0XHRcInZlYzMgZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZ0hhbGZCYWNrID0gdmVjMyggbWF4KCAtMC41ICogZG90UHJvZHVjdCArIDAuNSwgMC4wICkgKTtcIixcclxuXHJcblx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcIiNpZmRlZiBXUkFQX0FST1VORFwiLFxyXG5cclxuXHRcdFx0XHRcInZlYzMgZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZ0hhbGYgPSB2ZWMzKCBtYXgoIDAuNSAqIGRvdFByb2R1Y3QgKyAwLjUsIDAuMCApICk7XCIsXHJcblx0XHRcdFx0XCJkaXJlY3Rpb25hbExpZ2h0V2VpZ2h0aW5nID0gbWl4KCBkaXJlY3Rpb25hbExpZ2h0V2VpZ2h0aW5nLCBkaXJlY3Rpb25hbExpZ2h0V2VpZ2h0aW5nSGFsZiwgd3JhcFJHQiApO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNpZmRlZiBET1VCTEVfU0lERURcIixcclxuXHJcblx0XHRcdFx0XHRcImRpcmVjdGlvbmFsTGlnaHRXZWlnaHRpbmdCYWNrID0gbWl4KCBkaXJlY3Rpb25hbExpZ2h0V2VpZ2h0aW5nQmFjaywgZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZ0hhbGZCYWNrLCB3cmFwUkdCICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XCJ2TGlnaHRGcm9udCArPSBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIGkgXSAqIGRpcmVjdGlvbmFsTGlnaHRXZWlnaHRpbmc7XCIsXHJcblxyXG5cdFx0XHRcIiNpZmRlZiBET1VCTEVfU0lERURcIixcclxuXHJcblx0XHRcdFx0XCJ2TGlnaHRCYWNrICs9IGRpcmVjdGlvbmFsTGlnaHRDb2xvclsgaSBdICogZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZ0JhY2s7XCIsXHJcblxyXG5cdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwifVwiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjaWYgTUFYX1BPSU5UX0xJR0hUUyA+IDBcIixcclxuXHJcblx0XHRcdFwiZm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfUE9JTlRfTElHSFRTOyBpICsrICkge1wiLFxyXG5cclxuXHRcdFx0XHRcInZlYzQgbFBvc2l0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIHBvaW50TGlnaHRQb3NpdGlvblsgaSBdLCAxLjAgKTtcIixcclxuXHRcdFx0XHRcInZlYzMgbFZlY3RvciA9IGxQb3NpdGlvbi54eXogLSBtdlBvc2l0aW9uLnh5ejtcIixcclxuXHJcblx0XHRcdFx0XCJmbG9hdCBsRGlzdGFuY2UgPSAxLjA7XCIsXHJcblx0XHRcdFx0XCJpZiAoIHBvaW50TGlnaHREaXN0YW5jZVsgaSBdID4gMC4wIClcIixcclxuXHRcdFx0XHRcdFwibERpc3RhbmNlID0gMS4wIC0gbWluKCAoIGxlbmd0aCggbFZlY3RvciApIC8gcG9pbnRMaWdodERpc3RhbmNlWyBpIF0gKSwgMS4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFwibFZlY3RvciA9IG5vcm1hbGl6ZSggbFZlY3RvciApO1wiLFxyXG5cdFx0XHRcdFwiZmxvYXQgZG90UHJvZHVjdCA9IGRvdCggdHJhbnNmb3JtZWROb3JtYWwsIGxWZWN0b3IgKTtcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWMzIHBvaW50TGlnaHRXZWlnaHRpbmcgPSB2ZWMzKCBtYXgoIGRvdFByb2R1Y3QsIDAuMCApICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2lmZGVmIERPVUJMRV9TSURFRFwiLFxyXG5cclxuXHRcdFx0XHRcdFwidmVjMyBwb2ludExpZ2h0V2VpZ2h0aW5nQmFjayA9IHZlYzMoIG1heCggLWRvdFByb2R1Y3QsIDAuMCApICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCIjaWZkZWYgV1JBUF9BUk9VTkRcIixcclxuXHJcblx0XHRcdFx0XHRcdFwidmVjMyBwb2ludExpZ2h0V2VpZ2h0aW5nSGFsZkJhY2sgPSB2ZWMzKCBtYXgoIC0wLjUgKiBkb3RQcm9kdWN0ICsgMC41LCAwLjAgKSApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFwiI2lmZGVmIFdSQVBfQVJPVU5EXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ2ZWMzIHBvaW50TGlnaHRXZWlnaHRpbmdIYWxmID0gdmVjMyggbWF4KCAwLjUgKiBkb3RQcm9kdWN0ICsgMC41LCAwLjAgKSApO1wiLFxyXG5cdFx0XHRcdFx0XCJwb2ludExpZ2h0V2VpZ2h0aW5nID0gbWl4KCBwb2ludExpZ2h0V2VpZ2h0aW5nLCBwb2ludExpZ2h0V2VpZ2h0aW5nSGFsZiwgd3JhcFJHQiApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiI2lmZGVmIERPVUJMRV9TSURFRFwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJwb2ludExpZ2h0V2VpZ2h0aW5nQmFjayA9IG1peCggcG9pbnRMaWdodFdlaWdodGluZ0JhY2ssIHBvaW50TGlnaHRXZWlnaHRpbmdIYWxmQmFjaywgd3JhcFJHQiApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFwidkxpZ2h0RnJvbnQgKz0gcG9pbnRMaWdodENvbG9yWyBpIF0gKiBwb2ludExpZ2h0V2VpZ2h0aW5nICogbERpc3RhbmNlO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNpZmRlZiBET1VCTEVfU0lERURcIixcclxuXHJcblx0XHRcdFx0XHRcInZMaWdodEJhY2sgKz0gcG9pbnRMaWdodENvbG9yWyBpIF0gKiBwb2ludExpZ2h0V2VpZ2h0aW5nQmFjayAqIGxEaXN0YW5jZTtcIixcclxuXHJcblx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjaWYgTUFYX1NQT1RfTElHSFRTID4gMFwiLFxyXG5cclxuXHRcdFx0XCJmb3IoIGludCBpID0gMDsgaSA8IE1BWF9TUE9UX0xJR0hUUzsgaSArKyApIHtcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWM0IGxQb3NpdGlvbiA9IHZpZXdNYXRyaXggKiB2ZWM0KCBzcG90TGlnaHRQb3NpdGlvblsgaSBdLCAxLjAgKTtcIixcclxuXHRcdFx0XHRcInZlYzMgbFZlY3RvciA9IGxQb3NpdGlvbi54eXogLSBtdlBvc2l0aW9uLnh5ejtcIixcclxuXHJcblx0XHRcdFx0XCJmbG9hdCBzcG90RWZmZWN0ID0gZG90KCBzcG90TGlnaHREaXJlY3Rpb25bIGkgXSwgbm9ybWFsaXplKCBzcG90TGlnaHRQb3NpdGlvblsgaSBdIC0gd29ybGRQb3NpdGlvbi54eXogKSApO1wiLFxyXG5cclxuXHRcdFx0XHRcImlmICggc3BvdEVmZmVjdCA+IHNwb3RMaWdodEFuZ2xlQ29zWyBpIF0gKSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJzcG90RWZmZWN0ID0gbWF4KCBwb3coIHNwb3RFZmZlY3QsIHNwb3RMaWdodEV4cG9uZW50WyBpIF0gKSwgMC4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJmbG9hdCBsRGlzdGFuY2UgPSAxLjA7XCIsXHJcblx0XHRcdFx0XHRcImlmICggc3BvdExpZ2h0RGlzdGFuY2VbIGkgXSA+IDAuMCApXCIsXHJcblx0XHRcdFx0XHRcdFwibERpc3RhbmNlID0gMS4wIC0gbWluKCAoIGxlbmd0aCggbFZlY3RvciApIC8gc3BvdExpZ2h0RGlzdGFuY2VbIGkgXSApLCAxLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcImxWZWN0b3IgPSBub3JtYWxpemUoIGxWZWN0b3IgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcImZsb2F0IGRvdFByb2R1Y3QgPSBkb3QoIHRyYW5zZm9ybWVkTm9ybWFsLCBsVmVjdG9yICk7XCIsXHJcblx0XHRcdFx0XHRcInZlYzMgc3BvdExpZ2h0V2VpZ2h0aW5nID0gdmVjMyggbWF4KCBkb3RQcm9kdWN0LCAwLjAgKSApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiI2lmZGVmIERPVUJMRV9TSURFRFwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJ2ZWMzIHNwb3RMaWdodFdlaWdodGluZ0JhY2sgPSB2ZWMzKCBtYXgoIC1kb3RQcm9kdWN0LCAwLjAgKSApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCIjaWZkZWYgV1JBUF9BUk9VTkRcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XCJ2ZWMzIHNwb3RMaWdodFdlaWdodGluZ0hhbGZCYWNrID0gdmVjMyggbWF4KCAtMC41ICogZG90UHJvZHVjdCArIDAuNSwgMC4wICkgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0XHRcIiNpZmRlZiBXUkFQX0FST1VORFwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJ2ZWMzIHNwb3RMaWdodFdlaWdodGluZ0hhbGYgPSB2ZWMzKCBtYXgoIDAuNSAqIGRvdFByb2R1Y3QgKyAwLjUsIDAuMCApICk7XCIsXHJcblx0XHRcdFx0XHRcdFwic3BvdExpZ2h0V2VpZ2h0aW5nID0gbWl4KCBzcG90TGlnaHRXZWlnaHRpbmcsIHNwb3RMaWdodFdlaWdodGluZ0hhbGYsIHdyYXBSR0IgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiI2lmZGVmIERPVUJMRV9TSURFRFwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcInNwb3RMaWdodFdlaWdodGluZ0JhY2sgPSBtaXgoIHNwb3RMaWdodFdlaWdodGluZ0JhY2ssIHNwb3RMaWdodFdlaWdodGluZ0hhbGZCYWNrLCB3cmFwUkdCICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ2TGlnaHRGcm9udCArPSBzcG90TGlnaHRDb2xvclsgaSBdICogc3BvdExpZ2h0V2VpZ2h0aW5nICogbERpc3RhbmNlICogc3BvdEVmZmVjdDtcIixcclxuXHJcblx0XHRcdFx0XHRcIiNpZmRlZiBET1VCTEVfU0lERURcIixcclxuXHJcblx0XHRcdFx0XHRcdFwidkxpZ2h0QmFjayArPSBzcG90TGlnaHRDb2xvclsgaSBdICogc3BvdExpZ2h0V2VpZ2h0aW5nQmFjayAqIGxEaXN0YW5jZSAqIHNwb3RFZmZlY3Q7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XHRcIn1cIixcclxuXHJcblx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiI2lmIE1BWF9IRU1JX0xJR0hUUyA+IDBcIixcclxuXHJcblx0XHRcdFwiZm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfSEVNSV9MSUdIVFM7IGkgKysgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFwidmVjNCBsRGlyZWN0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIGhlbWlzcGhlcmVMaWdodERpcmVjdGlvblsgaSBdLCAwLjAgKTtcIixcclxuXHRcdFx0XHRcInZlYzMgbFZlY3RvciA9IG5vcm1hbGl6ZSggbERpcmVjdGlvbi54eXogKTtcIixcclxuXHJcblx0XHRcdFx0XCJmbG9hdCBkb3RQcm9kdWN0ID0gZG90KCB0cmFuc2Zvcm1lZE5vcm1hbCwgbFZlY3RvciApO1wiLFxyXG5cclxuXHRcdFx0XHRcImZsb2F0IGhlbWlEaWZmdXNlV2VpZ2h0ID0gMC41ICogZG90UHJvZHVjdCArIDAuNTtcIixcclxuXHRcdFx0XHRcImZsb2F0IGhlbWlEaWZmdXNlV2VpZ2h0QmFjayA9IC0wLjUgKiBkb3RQcm9kdWN0ICsgMC41O1wiLFxyXG5cclxuXHRcdFx0XHRcInZMaWdodEZyb250ICs9IG1peCggaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3JbIGkgXSwgaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3JbIGkgXSwgaGVtaURpZmZ1c2VXZWlnaHQgKTtcIixcclxuXHJcblx0XHRcdFx0XCIjaWZkZWYgRE9VQkxFX1NJREVEXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ2TGlnaHRCYWNrICs9IG1peCggaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3JbIGkgXSwgaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3JbIGkgXSwgaGVtaURpZmZ1c2VXZWlnaHRCYWNrICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcIn1cIixcclxuXHJcblx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwidkxpZ2h0RnJvbnQgPSB2TGlnaHRGcm9udCAqIGRpZmZ1c2UgKyBhbWJpZW50ICogYW1iaWVudExpZ2h0Q29sb3IgKyBlbWlzc2l2ZTtcIixcclxuXHJcblx0XHRcIiNpZmRlZiBET1VCTEVfU0lERURcIixcclxuXHJcblx0XHRcdFwidkxpZ2h0QmFjayA9IHZMaWdodEJhY2sgKiBkaWZmdXNlICsgYW1iaWVudCAqIGFtYmllbnRMaWdodENvbG9yICsgZW1pc3NpdmU7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdC8vIExJR0hUUyBQSE9OR1xyXG5cclxuXHRsaWdodHNfcGhvbmdfcGFyc192ZXJ0ZXg6IFtcclxuXHJcblx0XHRcIiNpZm5kZWYgUEhPTkdfUEVSX1BJWEVMXCIsXHJcblxyXG5cdFx0XCIjaWYgTUFYX1BPSU5UX0xJR0hUUyA+IDBcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIHBvaW50TGlnaHRQb3NpdGlvblsgTUFYX1BPSU5UX0xJR0hUUyBdO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgcG9pbnRMaWdodERpc3RhbmNlWyBNQVhfUE9JTlRfTElHSFRTIF07XCIsXHJcblxyXG5cdFx0XHRcInZhcnlpbmcgdmVjNCB2UG9pbnRMaWdodFsgTUFYX1BPSU5UX0xJR0hUUyBdO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjaWYgTUFYX1NQT1RfTElHSFRTID4gMFwiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgc3BvdExpZ2h0UG9zaXRpb25bIE1BWF9TUE9UX0xJR0hUUyBdO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0RGlzdGFuY2VbIE1BWF9TUE9UX0xJR0hUUyBdO1wiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzQgdlNwb3RMaWdodFsgTUFYX1NQT1RfTElHSFRTIF07XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDAgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKVwiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cclxuXHRsaWdodHNfcGhvbmdfdmVydGV4OiBbXHJcblxyXG5cdFx0XCIjaWZuZGVmIFBIT05HX1BFUl9QSVhFTFwiLFxyXG5cclxuXHRcdFwiI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcImZvciggaW50IGkgPSAwOyBpIDwgTUFYX1BPSU5UX0xJR0hUUzsgaSArKyApIHtcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWM0IGxQb3NpdGlvbiA9IHZpZXdNYXRyaXggKiB2ZWM0KCBwb2ludExpZ2h0UG9zaXRpb25bIGkgXSwgMS4wICk7XCIsXHJcblx0XHRcdFx0XCJ2ZWMzIGxWZWN0b3IgPSBsUG9zaXRpb24ueHl6IC0gbXZQb3NpdGlvbi54eXo7XCIsXHJcblxyXG5cdFx0XHRcdFwiZmxvYXQgbERpc3RhbmNlID0gMS4wO1wiLFxyXG5cdFx0XHRcdFwiaWYgKCBwb2ludExpZ2h0RGlzdGFuY2VbIGkgXSA+IDAuMCApXCIsXHJcblx0XHRcdFx0XHRcImxEaXN0YW5jZSA9IDEuMCAtIG1pbiggKCBsZW5ndGgoIGxWZWN0b3IgKSAvIHBvaW50TGlnaHREaXN0YW5jZVsgaSBdICksIDEuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcInZQb2ludExpZ2h0WyBpIF0gPSB2ZWM0KCBsVmVjdG9yLCBsRGlzdGFuY2UgKTtcIixcclxuXHJcblx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjaWYgTUFYX1NQT1RfTElHSFRTID4gMFwiLFxyXG5cclxuXHRcdFx0XCJmb3IoIGludCBpID0gMDsgaSA8IE1BWF9TUE9UX0xJR0hUUzsgaSArKyApIHtcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWM0IGxQb3NpdGlvbiA9IHZpZXdNYXRyaXggKiB2ZWM0KCBzcG90TGlnaHRQb3NpdGlvblsgaSBdLCAxLjAgKTtcIixcclxuXHRcdFx0XHRcInZlYzMgbFZlY3RvciA9IGxQb3NpdGlvbi54eXogLSBtdlBvc2l0aW9uLnh5ejtcIixcclxuXHJcblx0XHRcdFx0XCJmbG9hdCBsRGlzdGFuY2UgPSAxLjA7XCIsXHJcblx0XHRcdFx0XCJpZiAoIHNwb3RMaWdodERpc3RhbmNlWyBpIF0gPiAwLjAgKVwiLFxyXG5cdFx0XHRcdFx0XCJsRGlzdGFuY2UgPSAxLjAgLSBtaW4oICggbGVuZ3RoKCBsVmVjdG9yICkgLyBzcG90TGlnaHREaXN0YW5jZVsgaSBdICksIDEuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcInZTcG90TGlnaHRbIGkgXSA9IHZlYzQoIGxWZWN0b3IsIGxEaXN0YW5jZSApO1wiLFxyXG5cclxuXHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDAgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKVwiLFxyXG5cclxuXHRcdFx0XCJ2V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24ueHl6O1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRsaWdodHNfcGhvbmdfcGFyc19mcmFnbWVudDogW1xyXG5cclxuXHRcdFwidW5pZm9ybSB2ZWMzIGFtYmllbnRMaWdodENvbG9yO1wiLFxyXG5cclxuXHRcdFwiI2lmIE1BWF9ESVJfTElHSFRTID4gMFwiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgZGlyZWN0aW9uYWxMaWdodENvbG9yWyBNQVhfRElSX0xJR0hUUyBdO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uWyBNQVhfRElSX0xJR0hUUyBdO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjaWYgTUFYX0hFTUlfTElHSFRTID4gMFwiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3JbIE1BWF9IRU1JX0xJR0hUUyBdO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvclsgTUFYX0hFTUlfTElHSFRTIF07XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGhlbWlzcGhlcmVMaWdodERpcmVjdGlvblsgTUFYX0hFTUlfTElHSFRTIF07XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNpZiBNQVhfUE9JTlRfTElHSFRTID4gMFwiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgcG9pbnRMaWdodENvbG9yWyBNQVhfUE9JTlRfTElHSFRTIF07XCIsXHJcblxyXG5cdFx0XHRcIiNpZmRlZiBQSE9OR19QRVJfUElYRUxcIixcclxuXHJcblx0XHRcdFx0XCJ1bmlmb3JtIHZlYzMgcG9pbnRMaWdodFBvc2l0aW9uWyBNQVhfUE9JTlRfTElHSFRTIF07XCIsXHJcblx0XHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHBvaW50TGlnaHREaXN0YW5jZVsgTUFYX1BPSU5UX0xJR0hUUyBdO1wiLFxyXG5cclxuXHRcdFx0XCIjZWxzZVwiLFxyXG5cclxuXHRcdFx0XHRcInZhcnlpbmcgdmVjNCB2UG9pbnRMaWdodFsgTUFYX1BPSU5UX0xJR0hUUyBdO1wiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDBcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIHNwb3RMaWdodENvbG9yWyBNQVhfU1BPVF9MSUdIVFMgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgc3BvdExpZ2h0UG9zaXRpb25bIE1BWF9TUE9UX0xJR0hUUyBdO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBzcG90TGlnaHREaXJlY3Rpb25bIE1BWF9TUE9UX0xJR0hUUyBdO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0QW5nbGVDb3NbIE1BWF9TUE9UX0xJR0hUUyBdO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0RXhwb25lbnRbIE1BWF9TUE9UX0xJR0hUUyBdO1wiLFxyXG5cclxuXHRcdFx0XCIjaWZkZWYgUEhPTkdfUEVSX1BJWEVMXCIsXHJcblxyXG5cdFx0XHRcdFwidW5pZm9ybSBmbG9hdCBzcG90TGlnaHREaXN0YW5jZVsgTUFYX1NQT1RfTElHSFRTIF07XCIsXHJcblxyXG5cdFx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcdFwidmFyeWluZyB2ZWM0IHZTcG90TGlnaHRbIE1BWF9TUE9UX0xJR0hUUyBdO1wiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDAgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKVwiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNpZmRlZiBXUkFQX0FST1VORFwiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgd3JhcFJHQjtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwidmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XCIsXHJcblx0XHRcInZhcnlpbmcgdmVjMyB2Tm9ybWFsO1wiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0bGlnaHRzX3Bob25nX2ZyYWdtZW50OiBbXHJcblxyXG5cdFx0XCJ2ZWMzIG5vcm1hbCA9IG5vcm1hbGl6ZSggdk5vcm1hbCApO1wiLFxyXG5cdFx0XCJ2ZWMzIHZpZXdQb3NpdGlvbiA9IG5vcm1hbGl6ZSggdlZpZXdQb3NpdGlvbiApO1wiLFxyXG5cclxuXHRcdFwiI2lmZGVmIERPVUJMRV9TSURFRFwiLFxyXG5cclxuXHRcdFx0XCJub3JtYWwgPSBub3JtYWwgKiAoIC0xLjAgKyAyLjAgKiBmbG9hdCggZ2xfRnJvbnRGYWNpbmcgKSApO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX05PUk1BTE1BUFwiLFxyXG5cclxuXHRcdFx0XCJub3JtYWwgPSBwZXJ0dXJiTm9ybWFsMkFyYiggLXZpZXdQb3NpdGlvbiwgbm9ybWFsICk7XCIsXHJcblxyXG5cdFx0XCIjZWxpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApXCIsXHJcblxyXG5cdFx0XHRcIm5vcm1hbCA9IHBlcnR1cmJOb3JtYWxBcmIoIC12Vmlld1Bvc2l0aW9uLCBub3JtYWwsIGRIZHh5X2Z3ZCgpICk7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNpZiBNQVhfUE9JTlRfTElHSFRTID4gMFwiLFxyXG5cclxuXHRcdFx0XCJ2ZWMzIHBvaW50RGlmZnVzZSAgPSB2ZWMzKCAwLjAgKTtcIixcclxuXHRcdFx0XCJ2ZWMzIHBvaW50U3BlY3VsYXIgPSB2ZWMzKCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFwiZm9yICggaW50IGkgPSAwOyBpIDwgTUFYX1BPSU5UX0xJR0hUUzsgaSArKyApIHtcIixcclxuXHJcblx0XHRcdFx0XCIjaWZkZWYgUEhPTkdfUEVSX1BJWEVMXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ2ZWM0IGxQb3NpdGlvbiA9IHZpZXdNYXRyaXggKiB2ZWM0KCBwb2ludExpZ2h0UG9zaXRpb25bIGkgXSwgMS4wICk7XCIsXHJcblx0XHRcdFx0XHRcInZlYzMgbFZlY3RvciA9IGxQb3NpdGlvbi54eXogKyB2Vmlld1Bvc2l0aW9uLnh5ejtcIixcclxuXHJcblx0XHRcdFx0XHRcImZsb2F0IGxEaXN0YW5jZSA9IDEuMDtcIixcclxuXHRcdFx0XHRcdFwiaWYgKCBwb2ludExpZ2h0RGlzdGFuY2VbIGkgXSA+IDAuMCApXCIsXHJcblx0XHRcdFx0XHRcdFwibERpc3RhbmNlID0gMS4wIC0gbWluKCAoIGxlbmd0aCggbFZlY3RvciApIC8gcG9pbnRMaWdodERpc3RhbmNlWyBpIF0gKSwgMS4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJsVmVjdG9yID0gbm9ybWFsaXplKCBsVmVjdG9yICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2Vsc2VcIixcclxuXHJcblx0XHRcdFx0XHRcInZlYzMgbFZlY3RvciA9IG5vcm1hbGl6ZSggdlBvaW50TGlnaHRbIGkgXS54eXogKTtcIixcclxuXHRcdFx0XHRcdFwiZmxvYXQgbERpc3RhbmNlID0gdlBvaW50TGlnaHRbIGkgXS53O1wiLFxyXG5cclxuXHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHQvLyBkaWZmdXNlXHJcblxyXG5cdFx0XHRcdFwiZmxvYXQgZG90UHJvZHVjdCA9IGRvdCggbm9ybWFsLCBsVmVjdG9yICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2lmZGVmIFdSQVBfQVJPVU5EXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJmbG9hdCBwb2ludERpZmZ1c2VXZWlnaHRGdWxsID0gbWF4KCBkb3RQcm9kdWN0LCAwLjAgKTtcIixcclxuXHRcdFx0XHRcdFwiZmxvYXQgcG9pbnREaWZmdXNlV2VpZ2h0SGFsZiA9IG1heCggMC41ICogZG90UHJvZHVjdCArIDAuNSwgMC4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ2ZWMzIHBvaW50RGlmZnVzZVdlaWdodCA9IG1peCggdmVjMyAoIHBvaW50RGlmZnVzZVdlaWdodEZ1bGwgKSwgdmVjMyggcG9pbnREaWZmdXNlV2VpZ2h0SGFsZiApLCB3cmFwUkdCICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2Vsc2VcIixcclxuXHJcblx0XHRcdFx0XHRcImZsb2F0IHBvaW50RGlmZnVzZVdlaWdodCA9IG1heCggZG90UHJvZHVjdCwgMC4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFwicG9pbnREaWZmdXNlICArPSBkaWZmdXNlICogcG9pbnRMaWdodENvbG9yWyBpIF0gKiBwb2ludERpZmZ1c2VXZWlnaHQgKiBsRGlzdGFuY2U7XCIsXHJcblxyXG5cdFx0XHRcdC8vIHNwZWN1bGFyXHJcblxyXG5cdFx0XHRcdFwidmVjMyBwb2ludEhhbGZWZWN0b3IgPSBub3JtYWxpemUoIGxWZWN0b3IgKyB2aWV3UG9zaXRpb24gKTtcIixcclxuXHRcdFx0XHRcImZsb2F0IHBvaW50RG90Tm9ybWFsSGFsZiA9IG1heCggZG90KCBub3JtYWwsIHBvaW50SGFsZlZlY3RvciApLCAwLjAgKTtcIixcclxuXHRcdFx0XHRcImZsb2F0IHBvaW50U3BlY3VsYXJXZWlnaHQgPSBzcGVjdWxhclN0cmVuZ3RoICogbWF4KCBwb3coIHBvaW50RG90Tm9ybWFsSGFsZiwgc2hpbmluZXNzICksIDAuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNpZmRlZiBQSFlTSUNBTExZX0JBU0VEX1NIQURJTkdcIixcclxuXHJcblx0XHRcdFx0XHQvLyAyLjAgPT4gMi4wMDAxIGlzIGhhY2sgdG8gd29yayBhcm91bmQgQU5HTEUgYnVnXHJcblxyXG5cdFx0XHRcdFx0XCJmbG9hdCBzcGVjdWxhck5vcm1hbGl6YXRpb24gPSAoIHNoaW5pbmVzcyArIDIuMDAwMSApIC8gOC4wO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwidmVjMyBzY2hsaWNrID0gc3BlY3VsYXIgKyB2ZWMzKCAxLjAgLSBzcGVjdWxhciApICogcG93KCAxLjAgLSBkb3QoIGxWZWN0b3IsIHBvaW50SGFsZlZlY3RvciApLCA1LjAgKTtcIixcclxuXHRcdFx0XHRcdFwicG9pbnRTcGVjdWxhciArPSBzY2hsaWNrICogcG9pbnRMaWdodENvbG9yWyBpIF0gKiBwb2ludFNwZWN1bGFyV2VpZ2h0ICogcG9pbnREaWZmdXNlV2VpZ2h0ICogbERpc3RhbmNlICogc3BlY3VsYXJOb3JtYWxpemF0aW9uO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJwb2ludFNwZWN1bGFyICs9IHNwZWN1bGFyICogcG9pbnRMaWdodENvbG9yWyBpIF0gKiBwb2ludFNwZWN1bGFyV2VpZ2h0ICogcG9pbnREaWZmdXNlV2VpZ2h0ICogbERpc3RhbmNlO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcInZlYzMgc3BvdERpZmZ1c2UgID0gdmVjMyggMC4wICk7XCIsXHJcblx0XHRcdFwidmVjMyBzcG90U3BlY3VsYXIgPSB2ZWMzKCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFwiZm9yICggaW50IGkgPSAwOyBpIDwgTUFYX1NQT1RfTElHSFRTOyBpICsrICkge1wiLFxyXG5cclxuXHRcdFx0XHRcIiNpZmRlZiBQSE9OR19QRVJfUElYRUxcIixcclxuXHJcblx0XHRcdFx0XHRcInZlYzQgbFBvc2l0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIHNwb3RMaWdodFBvc2l0aW9uWyBpIF0sIDEuMCApO1wiLFxyXG5cdFx0XHRcdFx0XCJ2ZWMzIGxWZWN0b3IgPSBsUG9zaXRpb24ueHl6ICsgdlZpZXdQb3NpdGlvbi54eXo7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJmbG9hdCBsRGlzdGFuY2UgPSAxLjA7XCIsXHJcblx0XHRcdFx0XHRcImlmICggc3BvdExpZ2h0RGlzdGFuY2VbIGkgXSA+IDAuMCApXCIsXHJcblx0XHRcdFx0XHRcdFwibERpc3RhbmNlID0gMS4wIC0gbWluKCAoIGxlbmd0aCggbFZlY3RvciApIC8gc3BvdExpZ2h0RGlzdGFuY2VbIGkgXSApLCAxLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcImxWZWN0b3IgPSBub3JtYWxpemUoIGxWZWN0b3IgKTtcIixcclxuXHJcblx0XHRcdFx0XCIjZWxzZVwiLFxyXG5cclxuXHRcdFx0XHRcdFwidmVjMyBsVmVjdG9yID0gbm9ybWFsaXplKCB2U3BvdExpZ2h0WyBpIF0ueHl6ICk7XCIsXHJcblx0XHRcdFx0XHRcImZsb2F0IGxEaXN0YW5jZSA9IHZTcG90TGlnaHRbIGkgXS53O1wiLFxyXG5cclxuXHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHRcImZsb2F0IHNwb3RFZmZlY3QgPSBkb3QoIHNwb3RMaWdodERpcmVjdGlvblsgaSBdLCBub3JtYWxpemUoIHNwb3RMaWdodFBvc2l0aW9uWyBpIF0gLSB2V29ybGRQb3NpdGlvbiApICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiaWYgKCBzcG90RWZmZWN0ID4gc3BvdExpZ2h0QW5nbGVDb3NbIGkgXSApIHtcIixcclxuXHJcblx0XHRcdFx0XHRcInNwb3RFZmZlY3QgPSBtYXgoIHBvdyggc3BvdEVmZmVjdCwgc3BvdExpZ2h0RXhwb25lbnRbIGkgXSApLCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHQvLyBkaWZmdXNlXHJcblxyXG5cdFx0XHRcdFx0XCJmbG9hdCBkb3RQcm9kdWN0ID0gZG90KCBub3JtYWwsIGxWZWN0b3IgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcIiNpZmRlZiBXUkFQX0FST1VORFwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJmbG9hdCBzcG90RGlmZnVzZVdlaWdodEZ1bGwgPSBtYXgoIGRvdFByb2R1Y3QsIDAuMCApO1wiLFxyXG5cdFx0XHRcdFx0XHRcImZsb2F0IHNwb3REaWZmdXNlV2VpZ2h0SGFsZiA9IG1heCggMC41ICogZG90UHJvZHVjdCArIDAuNSwgMC4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcInZlYzMgc3BvdERpZmZ1c2VXZWlnaHQgPSBtaXgoIHZlYzMgKCBzcG90RGlmZnVzZVdlaWdodEZ1bGwgKSwgdmVjMyggc3BvdERpZmZ1c2VXZWlnaHRIYWxmICksIHdyYXBSR0IgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImZsb2F0IHNwb3REaWZmdXNlV2VpZ2h0ID0gbWF4KCBkb3RQcm9kdWN0LCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHRcdFwic3BvdERpZmZ1c2UgKz0gZGlmZnVzZSAqIHNwb3RMaWdodENvbG9yWyBpIF0gKiBzcG90RGlmZnVzZVdlaWdodCAqIGxEaXN0YW5jZSAqIHNwb3RFZmZlY3Q7XCIsXHJcblxyXG5cdFx0XHRcdFx0Ly8gc3BlY3VsYXJcclxuXHJcblx0XHRcdFx0XHRcInZlYzMgc3BvdEhhbGZWZWN0b3IgPSBub3JtYWxpemUoIGxWZWN0b3IgKyB2aWV3UG9zaXRpb24gKTtcIixcclxuXHRcdFx0XHRcdFwiZmxvYXQgc3BvdERvdE5vcm1hbEhhbGYgPSBtYXgoIGRvdCggbm9ybWFsLCBzcG90SGFsZlZlY3RvciApLCAwLjAgKTtcIixcclxuXHRcdFx0XHRcdFwiZmxvYXQgc3BvdFNwZWN1bGFyV2VpZ2h0ID0gc3BlY3VsYXJTdHJlbmd0aCAqIG1heCggcG93KCBzcG90RG90Tm9ybWFsSGFsZiwgc2hpbmluZXNzICksIDAuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiI2lmZGVmIFBIWVNJQ0FMTFlfQkFTRURfU0hBRElOR1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0Ly8gMi4wID0+IDIuMDAwMSBpcyBoYWNrIHRvIHdvcmsgYXJvdW5kIEFOR0xFIGJ1Z1xyXG5cclxuXHRcdFx0XHRcdFx0XCJmbG9hdCBzcGVjdWxhck5vcm1hbGl6YXRpb24gPSAoIHNoaW5pbmVzcyArIDIuMDAwMSApIC8gOC4wO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJ2ZWMzIHNjaGxpY2sgPSBzcGVjdWxhciArIHZlYzMoIDEuMCAtIHNwZWN1bGFyICkgKiBwb3coIDEuMCAtIGRvdCggbFZlY3Rvciwgc3BvdEhhbGZWZWN0b3IgKSwgNS4wICk7XCIsXHJcblx0XHRcdFx0XHRcdFwic3BvdFNwZWN1bGFyICs9IHNjaGxpY2sgKiBzcG90TGlnaHRDb2xvclsgaSBdICogc3BvdFNwZWN1bGFyV2VpZ2h0ICogc3BvdERpZmZ1c2VXZWlnaHQgKiBsRGlzdGFuY2UgKiBzcGVjdWxhck5vcm1hbGl6YXRpb24gKiBzcG90RWZmZWN0O1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiI2Vsc2VcIixcclxuXHJcblx0XHRcdFx0XHRcdFwic3BvdFNwZWN1bGFyICs9IHNwZWN1bGFyICogc3BvdExpZ2h0Q29sb3JbIGkgXSAqIHNwb3RTcGVjdWxhcldlaWdodCAqIHNwb3REaWZmdXNlV2VpZ2h0ICogbERpc3RhbmNlICogc3BvdEVmZmVjdDtcIixcclxuXHJcblx0XHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHRcIn1cIixcclxuXHJcblx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjaWYgTUFYX0RJUl9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcInZlYzMgZGlyRGlmZnVzZSAgPSB2ZWMzKCAwLjAgKTtcIixcclxuXHRcdFx0XCJ2ZWMzIGRpclNwZWN1bGFyID0gdmVjMyggMC4wICk7XCIgLFxyXG5cclxuXHRcdFx0XCJmb3IoIGludCBpID0gMDsgaSA8IE1BWF9ESVJfTElHSFRTOyBpICsrICkge1wiLFxyXG5cclxuXHRcdFx0XHRcInZlYzQgbERpcmVjdGlvbiA9IHZpZXdNYXRyaXggKiB2ZWM0KCBkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uWyBpIF0sIDAuMCApO1wiLFxyXG5cdFx0XHRcdFwidmVjMyBkaXJWZWN0b3IgPSBub3JtYWxpemUoIGxEaXJlY3Rpb24ueHl6ICk7XCIsXHJcblxyXG5cdFx0XHRcdC8vIGRpZmZ1c2VcclxuXHJcblx0XHRcdFx0XCJmbG9hdCBkb3RQcm9kdWN0ID0gZG90KCBub3JtYWwsIGRpclZlY3RvciApO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNpZmRlZiBXUkFQX0FST1VORFwiLFxyXG5cclxuXHRcdFx0XHRcdFwiZmxvYXQgZGlyRGlmZnVzZVdlaWdodEZ1bGwgPSBtYXgoIGRvdFByb2R1Y3QsIDAuMCApO1wiLFxyXG5cdFx0XHRcdFx0XCJmbG9hdCBkaXJEaWZmdXNlV2VpZ2h0SGFsZiA9IG1heCggMC41ICogZG90UHJvZHVjdCArIDAuNSwgMC4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ2ZWMzIGRpckRpZmZ1c2VXZWlnaHQgPSBtaXgoIHZlYzMoIGRpckRpZmZ1c2VXZWlnaHRGdWxsICksIHZlYzMoIGRpckRpZmZ1c2VXZWlnaHRIYWxmICksIHdyYXBSR0IgKTtcIixcclxuXHJcblx0XHRcdFx0XCIjZWxzZVwiLFxyXG5cclxuXHRcdFx0XHRcdFwiZmxvYXQgZGlyRGlmZnVzZVdlaWdodCA9IG1heCggZG90UHJvZHVjdCwgMC4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFwiZGlyRGlmZnVzZSAgKz0gZGlmZnVzZSAqIGRpcmVjdGlvbmFsTGlnaHRDb2xvclsgaSBdICogZGlyRGlmZnVzZVdlaWdodDtcIixcclxuXHJcblx0XHRcdFx0Ly8gc3BlY3VsYXJcclxuXHJcblx0XHRcdFx0XCJ2ZWMzIGRpckhhbGZWZWN0b3IgPSBub3JtYWxpemUoIGRpclZlY3RvciArIHZpZXdQb3NpdGlvbiApO1wiLFxyXG5cdFx0XHRcdFwiZmxvYXQgZGlyRG90Tm9ybWFsSGFsZiA9IG1heCggZG90KCBub3JtYWwsIGRpckhhbGZWZWN0b3IgKSwgMC4wICk7XCIsXHJcblx0XHRcdFx0XCJmbG9hdCBkaXJTcGVjdWxhcldlaWdodCA9IHNwZWN1bGFyU3RyZW5ndGggKiBtYXgoIHBvdyggZGlyRG90Tm9ybWFsSGFsZiwgc2hpbmluZXNzICksIDAuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNpZmRlZiBQSFlTSUNBTExZX0JBU0VEX1NIQURJTkdcIixcclxuXHJcblx0XHRcdFx0XHQvKlxyXG5cdFx0XHRcdFx0Ly8gZnJlc25lbCB0ZXJtIGZyb20gc2tpbiBzaGFkZXJcclxuXHRcdFx0XHRcdFwiY29uc3QgZmxvYXQgRjAgPSAwLjEyODtcIixcclxuXHJcblx0XHRcdFx0XHRcImZsb2F0IGJhc2UgPSAxLjAgLSBkb3QoIHZpZXdQb3NpdGlvbiwgZGlySGFsZlZlY3RvciApO1wiLFxyXG5cdFx0XHRcdFx0XCJmbG9hdCBleHBvbmVudGlhbCA9IHBvdyggYmFzZSwgNS4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJmbG9hdCBmcmVzbmVsID0gZXhwb25lbnRpYWwgKyBGMCAqICggMS4wIC0gZXhwb25lbnRpYWwgKTtcIixcclxuXHRcdFx0XHRcdCovXHJcblxyXG5cdFx0XHRcdFx0LypcclxuXHRcdFx0XHRcdC8vIGZyZXNuZWwgdGVybSBmcm9tIGZyZXNuZWwgc2hhZGVyXHJcblx0XHRcdFx0XHRcImNvbnN0IGZsb2F0IG1GcmVzbmVsQmlhcyA9IDAuMDg7XCIsXHJcblx0XHRcdFx0XHRcImNvbnN0IGZsb2F0IG1GcmVzbmVsU2NhbGUgPSAwLjM7XCIsXHJcblx0XHRcdFx0XHRcImNvbnN0IGZsb2F0IG1GcmVzbmVsUG93ZXIgPSA1LjA7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJmbG9hdCBmcmVzbmVsID0gbUZyZXNuZWxCaWFzICsgbUZyZXNuZWxTY2FsZSAqIHBvdyggMS4wICsgZG90KCBub3JtYWxpemUoIC12aWV3UG9zaXRpb24gKSwgbm9ybWFsICksIG1GcmVzbmVsUG93ZXIgKTtcIixcclxuXHRcdFx0XHRcdCovXHJcblxyXG5cdFx0XHRcdFx0Ly8gMi4wID0+IDIuMDAwMSBpcyBoYWNrIHRvIHdvcmsgYXJvdW5kIEFOR0xFIGJ1Z1xyXG5cclxuXHRcdFx0XHRcdFwiZmxvYXQgc3BlY3VsYXJOb3JtYWxpemF0aW9uID0gKCBzaGluaW5lc3MgKyAyLjAwMDEgKSAvIDguMDtcIixcclxuXHJcblx0XHRcdFx0XHQvL1wiZGlyU3BlY3VsYXIgKz0gc3BlY3VsYXIgKiBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIGkgXSAqIGRpclNwZWN1bGFyV2VpZ2h0ICogZGlyRGlmZnVzZVdlaWdodCAqIHNwZWN1bGFyTm9ybWFsaXphdGlvbiAqIGZyZXNuZWw7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ2ZWMzIHNjaGxpY2sgPSBzcGVjdWxhciArIHZlYzMoIDEuMCAtIHNwZWN1bGFyICkgKiBwb3coIDEuMCAtIGRvdCggZGlyVmVjdG9yLCBkaXJIYWxmVmVjdG9yICksIDUuMCApO1wiLFxyXG5cdFx0XHRcdFx0XCJkaXJTcGVjdWxhciArPSBzY2hsaWNrICogZGlyZWN0aW9uYWxMaWdodENvbG9yWyBpIF0gKiBkaXJTcGVjdWxhcldlaWdodCAqIGRpckRpZmZ1c2VXZWlnaHQgKiBzcGVjdWxhck5vcm1hbGl6YXRpb247XCIsXHJcblxyXG5cdFx0XHRcdFwiI2Vsc2VcIixcclxuXHJcblx0XHRcdFx0XHRcImRpclNwZWN1bGFyICs9IHNwZWN1bGFyICogZGlyZWN0aW9uYWxMaWdodENvbG9yWyBpIF0gKiBkaXJTcGVjdWxhcldlaWdodCAqIGRpckRpZmZ1c2VXZWlnaHQ7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcIn1cIixcclxuXHJcblx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiI2lmIE1BWF9IRU1JX0xJR0hUUyA+IDBcIixcclxuXHJcblx0XHRcdFwidmVjMyBoZW1pRGlmZnVzZSAgPSB2ZWMzKCAwLjAgKTtcIixcclxuXHRcdFx0XCJ2ZWMzIGhlbWlTcGVjdWxhciA9IHZlYzMoIDAuMCApO1wiICxcclxuXHJcblx0XHRcdFwiZm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfSEVNSV9MSUdIVFM7IGkgKysgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFwidmVjNCBsRGlyZWN0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIGhlbWlzcGhlcmVMaWdodERpcmVjdGlvblsgaSBdLCAwLjAgKTtcIixcclxuXHRcdFx0XHRcInZlYzMgbFZlY3RvciA9IG5vcm1hbGl6ZSggbERpcmVjdGlvbi54eXogKTtcIixcclxuXHJcblx0XHRcdFx0Ly8gZGlmZnVzZVxyXG5cclxuXHRcdFx0XHRcImZsb2F0IGRvdFByb2R1Y3QgPSBkb3QoIG5vcm1hbCwgbFZlY3RvciApO1wiLFxyXG5cdFx0XHRcdFwiZmxvYXQgaGVtaURpZmZ1c2VXZWlnaHQgPSAwLjUgKiBkb3RQcm9kdWN0ICsgMC41O1wiLFxyXG5cclxuXHRcdFx0XHRcInZlYzMgaGVtaUNvbG9yID0gbWl4KCBoZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvclsgaSBdLCBoZW1pc3BoZXJlTGlnaHRTa3lDb2xvclsgaSBdLCBoZW1pRGlmZnVzZVdlaWdodCApO1wiLFxyXG5cclxuXHRcdFx0XHRcImhlbWlEaWZmdXNlICs9IGRpZmZ1c2UgKiBoZW1pQ29sb3I7XCIsXHJcblxyXG5cdFx0XHRcdC8vIHNwZWN1bGFyIChza3kgbGlnaHQpXHJcblxyXG5cdFx0XHRcdFwidmVjMyBoZW1pSGFsZlZlY3RvclNreSA9IG5vcm1hbGl6ZSggbFZlY3RvciArIHZpZXdQb3NpdGlvbiApO1wiLFxyXG5cdFx0XHRcdFwiZmxvYXQgaGVtaURvdE5vcm1hbEhhbGZTa3kgPSAwLjUgKiBkb3QoIG5vcm1hbCwgaGVtaUhhbGZWZWN0b3JTa3kgKSArIDAuNTtcIixcclxuXHRcdFx0XHRcImZsb2F0IGhlbWlTcGVjdWxhcldlaWdodFNreSA9IHNwZWN1bGFyU3RyZW5ndGggKiBtYXgoIHBvdyggaGVtaURvdE5vcm1hbEhhbGZTa3ksIHNoaW5pbmVzcyApLCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFx0Ly8gc3BlY3VsYXIgKGdyb3VuZCBsaWdodClcclxuXHJcblx0XHRcdFx0XCJ2ZWMzIGxWZWN0b3JHcm91bmQgPSAtbFZlY3RvcjtcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWMzIGhlbWlIYWxmVmVjdG9yR3JvdW5kID0gbm9ybWFsaXplKCBsVmVjdG9yR3JvdW5kICsgdmlld1Bvc2l0aW9uICk7XCIsXHJcblx0XHRcdFx0XCJmbG9hdCBoZW1pRG90Tm9ybWFsSGFsZkdyb3VuZCA9IDAuNSAqIGRvdCggbm9ybWFsLCBoZW1pSGFsZlZlY3Rvckdyb3VuZCApICsgMC41O1wiLFxyXG5cdFx0XHRcdFwiZmxvYXQgaGVtaVNwZWN1bGFyV2VpZ2h0R3JvdW5kID0gc3BlY3VsYXJTdHJlbmd0aCAqIG1heCggcG93KCBoZW1pRG90Tm9ybWFsSGFsZkdyb3VuZCwgc2hpbmluZXNzICksIDAuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNpZmRlZiBQSFlTSUNBTExZX0JBU0VEX1NIQURJTkdcIixcclxuXHJcblx0XHRcdFx0XHRcImZsb2F0IGRvdFByb2R1Y3RHcm91bmQgPSBkb3QoIG5vcm1hbCwgbFZlY3Rvckdyb3VuZCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdC8vIDIuMCA9PiAyLjAwMDEgaXMgaGFjayB0byB3b3JrIGFyb3VuZCBBTkdMRSBidWdcclxuXHJcblx0XHRcdFx0XHRcImZsb2F0IHNwZWN1bGFyTm9ybWFsaXphdGlvbiA9ICggc2hpbmluZXNzICsgMi4wMDAxICkgLyA4LjA7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ2ZWMzIHNjaGxpY2tTa3kgPSBzcGVjdWxhciArIHZlYzMoIDEuMCAtIHNwZWN1bGFyICkgKiBwb3coIDEuMCAtIGRvdCggbFZlY3RvciwgaGVtaUhhbGZWZWN0b3JTa3kgKSwgNS4wICk7XCIsXHJcblx0XHRcdFx0XHRcInZlYzMgc2NobGlja0dyb3VuZCA9IHNwZWN1bGFyICsgdmVjMyggMS4wIC0gc3BlY3VsYXIgKSAqIHBvdyggMS4wIC0gZG90KCBsVmVjdG9yR3JvdW5kLCBoZW1pSGFsZlZlY3Rvckdyb3VuZCApLCA1LjAgKTtcIixcclxuXHRcdFx0XHRcdFwiaGVtaVNwZWN1bGFyICs9IGhlbWlDb2xvciAqIHNwZWN1bGFyTm9ybWFsaXphdGlvbiAqICggc2NobGlja1NreSAqIGhlbWlTcGVjdWxhcldlaWdodFNreSAqIG1heCggZG90UHJvZHVjdCwgMC4wICkgKyBzY2hsaWNrR3JvdW5kICogaGVtaVNwZWN1bGFyV2VpZ2h0R3JvdW5kICogbWF4KCBkb3RQcm9kdWN0R3JvdW5kLCAwLjAgKSApO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJoZW1pU3BlY3VsYXIgKz0gc3BlY3VsYXIgKiBoZW1pQ29sb3IgKiAoIGhlbWlTcGVjdWxhcldlaWdodFNreSArIGhlbWlTcGVjdWxhcldlaWdodEdyb3VuZCApICogaGVtaURpZmZ1c2VXZWlnaHQ7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcIn1cIixcclxuXHJcblx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwidmVjMyB0b3RhbERpZmZ1c2UgPSB2ZWMzKCAwLjAgKTtcIixcclxuXHRcdFwidmVjMyB0b3RhbFNwZWN1bGFyID0gdmVjMyggMC4wICk7XCIsXHJcblxyXG5cdFx0XCIjaWYgTUFYX0RJUl9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcInRvdGFsRGlmZnVzZSArPSBkaXJEaWZmdXNlO1wiLFxyXG5cdFx0XHRcInRvdGFsU3BlY3VsYXIgKz0gZGlyU3BlY3VsYXI7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNpZiBNQVhfSEVNSV9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcInRvdGFsRGlmZnVzZSArPSBoZW1pRGlmZnVzZTtcIixcclxuXHRcdFx0XCJ0b3RhbFNwZWN1bGFyICs9IGhlbWlTcGVjdWxhcjtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcInRvdGFsRGlmZnVzZSArPSBwb2ludERpZmZ1c2U7XCIsXHJcblx0XHRcdFwidG90YWxTcGVjdWxhciArPSBwb2ludFNwZWN1bGFyO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjaWYgTUFYX1NQT1RfTElHSFRTID4gMFwiLFxyXG5cclxuXHRcdFx0XCJ0b3RhbERpZmZ1c2UgKz0gc3BvdERpZmZ1c2U7XCIsXHJcblx0XHRcdFwidG90YWxTcGVjdWxhciArPSBzcG90U3BlY3VsYXI7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNpZmRlZiBNRVRBTFwiLFxyXG5cclxuXHRcdFx0XCJnbF9GcmFnQ29sb3IueHl6ID0gZ2xfRnJhZ0NvbG9yLnh5eiAqICggZW1pc3NpdmUgKyB0b3RhbERpZmZ1c2UgKyBhbWJpZW50TGlnaHRDb2xvciAqIGFtYmllbnQgKyB0b3RhbFNwZWN1bGFyICk7XCIsXHJcblxyXG5cdFx0XCIjZWxzZVwiLFxyXG5cclxuXHRcdFx0XCJnbF9GcmFnQ29sb3IueHl6ID0gZ2xfRnJhZ0NvbG9yLnh5eiAqICggZW1pc3NpdmUgKyB0b3RhbERpZmZ1c2UgKyBhbWJpZW50TGlnaHRDb2xvciAqIGFtYmllbnQgKSArIHRvdGFsU3BlY3VsYXI7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdC8vIFZFUlRFWCBDT0xPUlNcclxuXHJcblx0Y29sb3JfcGFyc19mcmFnbWVudDogW1xyXG5cclxuXHRcdFwiI2lmZGVmIFVTRV9DT0xPUlwiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdkNvbG9yO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHJcblx0Y29sb3JfZnJhZ21lbnQ6IFtcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfQ09MT1JcIixcclxuXHJcblx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gZ2xfRnJhZ0NvbG9yICogdmVjNCggdkNvbG9yLCBvcGFjaXR5ICk7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdGNvbG9yX3BhcnNfdmVydGV4OiBbXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX0NPTE9SXCIsXHJcblxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2Q29sb3I7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cclxuXHRjb2xvcl92ZXJ0ZXg6IFtcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfQ09MT1JcIixcclxuXHJcblx0XHRcdFwiI2lmZGVmIEdBTU1BX0lOUFVUXCIsXHJcblxyXG5cdFx0XHRcdFwidkNvbG9yID0gY29sb3IgKiBjb2xvcjtcIixcclxuXHJcblx0XHRcdFwiI2Vsc2VcIixcclxuXHJcblx0XHRcdFx0XCJ2Q29sb3IgPSBjb2xvcjtcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdC8vIFNLSU5OSU5HXHJcblxyXG5cdHNraW5uaW5nX3BhcnNfdmVydGV4OiBbXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX1NLSU5OSU5HXCIsXHJcblxyXG5cdFx0XHRcIiNpZmRlZiBCT05FX1RFWFRVUkVcIixcclxuXHJcblx0XHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCBib25lVGV4dHVyZTtcIixcclxuXHJcblx0XHRcdFx0XCJtYXQ0IGdldEJvbmVNYXRyaXgoIGNvbnN0IGluIGZsb2F0IGkgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJmbG9hdCBqID0gaSAqIDQuMDtcIixcclxuXHRcdFx0XHRcdFwiZmxvYXQgeCA9IG1vZCggaiwgTl9CT05FX1BJWEVMX1ggKTtcIixcclxuXHRcdFx0XHRcdFwiZmxvYXQgeSA9IGZsb29yKCBqIC8gTl9CT05FX1BJWEVMX1ggKTtcIixcclxuXHJcblx0XHRcdFx0XHRcImNvbnN0IGZsb2F0IGR4ID0gMS4wIC8gTl9CT05FX1BJWEVMX1g7XCIsXHJcblx0XHRcdFx0XHRcImNvbnN0IGZsb2F0IGR5ID0gMS4wIC8gTl9CT05FX1BJWEVMX1k7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ5ID0gZHkgKiAoIHkgKyAwLjUgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcInZlYzQgdjEgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDAuNSApLCB5ICkgKTtcIixcclxuXHRcdFx0XHRcdFwidmVjNCB2MiA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMS41ICksIHkgKSApO1wiLFxyXG5cdFx0XHRcdFx0XCJ2ZWM0IHYzID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAyLjUgKSwgeSApICk7XCIsXHJcblx0XHRcdFx0XHRcInZlYzQgdjQgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDMuNSApLCB5ICkgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcIm1hdDQgYm9uZSA9IG1hdDQoIHYxLCB2MiwgdjMsIHY0ICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJyZXR1cm4gYm9uZTtcIixcclxuXHJcblx0XHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcdFwidW5pZm9ybSBtYXQ0IGJvbmVHbG9iYWxNYXRyaWNlc1sgTUFYX0JPTkVTIF07XCIsXHJcblxyXG5cdFx0XHRcdFwibWF0NCBnZXRCb25lTWF0cml4KCBjb25zdCBpbiBmbG9hdCBpICkge1wiLFxyXG5cclxuXHRcdFx0XHRcdFwibWF0NCBib25lID0gYm9uZUdsb2JhbE1hdHJpY2VzWyBpbnQoaSkgXTtcIixcclxuXHRcdFx0XHRcdFwicmV0dXJuIGJvbmU7XCIsXHJcblxyXG5cdFx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0c2tpbmJhc2VfdmVydGV4OiBbXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX1NLSU5OSU5HXCIsXHJcblxyXG5cdFx0XHRcIm1hdDQgYm9uZU1hdFggPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueCApO1wiLFxyXG5cdFx0XHRcIm1hdDQgYm9uZU1hdFkgPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueSApO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRza2lubmluZ192ZXJ0ZXg6IFtcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfU0tJTk5JTkdcIixcclxuXHJcblx0XHRcdFwiI2lmZGVmIFVTRV9NT1JQSFRBUkdFVFNcIixcclxuXHJcblx0XHRcdFwidmVjNCBza2luVmVydGV4ID0gdmVjNCggbW9ycGhlZCwgMS4wICk7XCIsXHJcblxyXG5cdFx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcInZlYzQgc2tpblZlcnRleCA9IHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcInZlYzQgc2tpbm5lZCAgPSBib25lTWF0WCAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lng7XCIsXHJcblx0XHRcdFwic2tpbm5lZCBcdCAgKz0gYm9uZU1hdFkgKiBza2luVmVydGV4ICogc2tpbldlaWdodC55O1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHQvLyBNT1JQSElOR1xyXG5cclxuXHRtb3JwaHRhcmdldF9wYXJzX3ZlcnRleDogW1xyXG5cclxuXHRcdFwiI2lmZGVmIFVTRV9NT1JQSFRBUkdFVFNcIixcclxuXHJcblx0XHRcdFwiI2lmbmRlZiBVU0VfTU9SUEhOT1JNQUxTXCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA4IF07XCIsXHJcblxyXG5cdFx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA0IF07XCIsXHJcblxyXG5cdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRtb3JwaHRhcmdldF92ZXJ0ZXg6IFtcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfTU9SUEhUQVJHRVRTXCIsXHJcblxyXG5cdFx0XHRcInZlYzMgbW9ycGhlZCA9IHZlYzMoIDAuMCApO1wiLFxyXG5cdFx0XHRcIm1vcnBoZWQgKz0gKCBtb3JwaFRhcmdldDAgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAwIF07XCIsXHJcblx0XHRcdFwibW9ycGhlZCArPSAoIG1vcnBoVGFyZ2V0MSAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDEgXTtcIixcclxuXHRcdFx0XCJtb3JwaGVkICs9ICggbW9ycGhUYXJnZXQyIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMiBdO1wiLFxyXG5cdFx0XHRcIm1vcnBoZWQgKz0gKCBtb3JwaFRhcmdldDMgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAzIF07XCIsXHJcblxyXG5cdFx0XHRcIiNpZm5kZWYgVVNFX01PUlBITk9STUFMU1wiLFxyXG5cclxuXHRcdFx0XCJtb3JwaGVkICs9ICggbW9ycGhUYXJnZXQ0IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNCBdO1wiLFxyXG5cdFx0XHRcIm1vcnBoZWQgKz0gKCBtb3JwaFRhcmdldDUgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA1IF07XCIsXHJcblx0XHRcdFwibW9ycGhlZCArPSAoIG1vcnBoVGFyZ2V0NiAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDYgXTtcIixcclxuXHRcdFx0XCJtb3JwaGVkICs9ICggbW9ycGhUYXJnZXQ3IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNyBdO1wiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFwibW9ycGhlZCArPSBwb3NpdGlvbjtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0ZGVmYXVsdF92ZXJ0ZXggOiBbXHJcblxyXG5cdFx0XCJ2ZWM0IG12UG9zaXRpb247XCIsXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX1NLSU5OSU5HXCIsXHJcblxyXG5cdFx0XHRcIm12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiBza2lubmVkO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjaWYgIWRlZmluZWQoIFVTRV9TS0lOTklORyApICYmIGRlZmluZWQoIFVTRV9NT1JQSFRBUkdFVFMgKVwiLFxyXG5cclxuXHRcdFx0XCJtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggbW9ycGhlZCwgMS4wICk7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNpZiAhZGVmaW5lZCggVVNFX1NLSU5OSU5HICkgJiYgISBkZWZpbmVkKCBVU0VfTU9SUEhUQVJHRVRTIClcIixcclxuXHJcblx0XHRcdFwibXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdG1vcnBobm9ybWFsX3ZlcnRleDogW1xyXG5cclxuXHRcdFwiI2lmZGVmIFVTRV9NT1JQSE5PUk1BTFNcIixcclxuXHJcblx0XHRcdFwidmVjMyBtb3JwaGVkTm9ybWFsID0gdmVjMyggMC4wICk7XCIsXHJcblxyXG5cdFx0XHRcIm1vcnBoZWROb3JtYWwgKz0gICggbW9ycGhOb3JtYWwwIC0gbm9ybWFsICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDAgXTtcIixcclxuXHRcdFx0XCJtb3JwaGVkTm9ybWFsICs9ICAoIG1vcnBoTm9ybWFsMSAtIG5vcm1hbCApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAxIF07XCIsXHJcblx0XHRcdFwibW9ycGhlZE5vcm1hbCArPSAgKCBtb3JwaE5vcm1hbDIgLSBub3JtYWwgKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMiBdO1wiLFxyXG5cdFx0XHRcIm1vcnBoZWROb3JtYWwgKz0gICggbW9ycGhOb3JtYWwzIC0gbm9ybWFsICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDMgXTtcIixcclxuXHJcblx0XHRcdFwibW9ycGhlZE5vcm1hbCArPSBub3JtYWw7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdHNraW5ub3JtYWxfdmVydGV4OiBbXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX1NLSU5OSU5HXCIsXHJcblxyXG5cdFx0XHRcIm1hdDQgc2tpbk1hdHJpeCA9IHNraW5XZWlnaHQueCAqIGJvbmVNYXRYO1wiLFxyXG5cdFx0XHRcInNraW5NYXRyaXggXHQrPSBza2luV2VpZ2h0LnkgKiBib25lTWF0WTtcIixcclxuXHJcblx0XHRcdFwiI2lmZGVmIFVTRV9NT1JQSE5PUk1BTFNcIixcclxuXHJcblx0XHRcdFwidmVjNCBza2lubmVkTm9ybWFsID0gc2tpbk1hdHJpeCAqIHZlYzQoIG1vcnBoZWROb3JtYWwsIDAuMCApO1wiLFxyXG5cclxuXHRcdFx0XCIjZWxzZVwiLFxyXG5cclxuXHRcdFx0XCJ2ZWM0IHNraW5uZWROb3JtYWwgPSBza2luTWF0cml4ICogdmVjNCggbm9ybWFsLCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdGRlZmF1bHRub3JtYWxfdmVydGV4OiBbXHJcblxyXG5cdFx0XCJ2ZWMzIG9iamVjdE5vcm1hbDtcIixcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfU0tJTk5JTkdcIixcclxuXHJcblx0XHRcdFwib2JqZWN0Tm9ybWFsID0gc2tpbm5lZE5vcm1hbC54eXo7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNpZiAhZGVmaW5lZCggVVNFX1NLSU5OSU5HICkgJiYgZGVmaW5lZCggVVNFX01PUlBITk9STUFMUyApXCIsXHJcblxyXG5cdFx0XHRcIm9iamVjdE5vcm1hbCA9IG1vcnBoZWROb3JtYWw7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNpZiAhZGVmaW5lZCggVVNFX1NLSU5OSU5HICkgJiYgISBkZWZpbmVkKCBVU0VfTU9SUEhOT1JNQUxTIClcIixcclxuXHJcblx0XHRcdFwib2JqZWN0Tm9ybWFsID0gbm9ybWFsO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjaWZkZWYgRkxJUF9TSURFRFwiLFxyXG5cclxuXHRcdFx0XCJvYmplY3ROb3JtYWwgPSAtb2JqZWN0Tm9ybWFsO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCJ2ZWMzIHRyYW5zZm9ybWVkTm9ybWFsID0gbm9ybWFsTWF0cml4ICogb2JqZWN0Tm9ybWFsO1wiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0Ly8gU0hBRE9XIE1BUFxyXG5cclxuXHQvLyBiYXNlZCBvbiBTcGlkZXJHTCBzaGFkb3cgbWFwIGFuZCBGYWJpZW4gU2FuZ2xhcmQncyBHTFNMIHNoYWRvdyBtYXBwaW5nIGV4YW1wbGVzXHJcblx0Ly8gIGh0dHA6Ly9zcGlkZXJnbC5vcmcvZXhhbXBsZS5waHA/aWQ9NlxyXG5cdC8vIFx0aHR0cDovL2ZhYmllbnNhbmdsYXJkLm5ldC9zaGFkb3dtYXBwaW5nXHJcblxyXG5cdHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50OiBbXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX1NIQURPV01BUFwiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCBzaGFkb3dNYXBbIE1BWF9TSEFET1dTIF07XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMyIHNoYWRvd01hcFNpemVbIE1BWF9TSEFET1dTIF07XCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgc2hhZG93RGFya25lc3NbIE1BWF9TSEFET1dTIF07XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBzaGFkb3dCaWFzWyBNQVhfU0hBRE9XUyBdO1wiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzQgdlNoYWRvd0Nvb3JkWyBNQVhfU0hBRE9XUyBdO1wiLFxyXG5cclxuXHRcdFx0XCJmbG9hdCB1bnBhY2tEZXB0aCggY29uc3QgaW4gdmVjNCByZ2JhX2RlcHRoICkge1wiLFxyXG5cclxuXHRcdFx0XHRcImNvbnN0IHZlYzQgYml0X3NoaWZ0ID0gdmVjNCggMS4wIC8gKCAyNTYuMCAqIDI1Ni4wICogMjU2LjAgKSwgMS4wIC8gKCAyNTYuMCAqIDI1Ni4wICksIDEuMCAvIDI1Ni4wLCAxLjAgKTtcIixcclxuXHRcdFx0XHRcImZsb2F0IGRlcHRoID0gZG90KCByZ2JhX2RlcHRoLCBiaXRfc2hpZnQgKTtcIixcclxuXHRcdFx0XHRcInJldHVybiBkZXB0aDtcIixcclxuXHJcblx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRzaGFkb3dtYXBfZnJhZ21lbnQ6IFtcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXCIsXHJcblxyXG5cdFx0XHRcIiNpZmRlZiBTSEFET1dNQVBfREVCVUdcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWMzIGZydXN0dW1Db2xvcnNbM107XCIsXHJcblx0XHRcdFx0XCJmcnVzdHVtQ29sb3JzWzBdID0gdmVjMyggMS4wLCAwLjUsIDAuMCApO1wiLFxyXG5cdFx0XHRcdFwiZnJ1c3R1bUNvbG9yc1sxXSA9IHZlYzMoIDAuMCwgMS4wLCAwLjggKTtcIixcclxuXHRcdFx0XHRcImZydXN0dW1Db2xvcnNbMl0gPSB2ZWMzKCAwLjAsIDAuNSwgMS4wICk7XCIsXHJcblxyXG5cdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XCIjaWZkZWYgU0hBRE9XTUFQX0NBU0NBREVcIixcclxuXHJcblx0XHRcdFx0XCJpbnQgaW5GcnVzdHVtQ291bnQgPSAwO1wiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFwiZmxvYXQgZkRlcHRoO1wiLFxyXG5cdFx0XHRcInZlYzMgc2hhZG93Q29sb3IgPSB2ZWMzKCAxLjAgKTtcIixcclxuXHJcblx0XHRcdFwiZm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfU0hBRE9XUzsgaSArKyApIHtcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWMzIHNoYWRvd0Nvb3JkID0gdlNoYWRvd0Nvb3JkWyBpIF0ueHl6IC8gdlNoYWRvd0Nvb3JkWyBpIF0udztcIixcclxuXHJcblx0XHRcdFx0Ly8gXCJpZiAoIHNvbWV0aGluZyAmJiBzb21ldGhpbmcgKVwiIFx0XHQgYnJlYWtzIEFUSSBPcGVuR0wgc2hhZGVyIGNvbXBpbGVyXHJcblx0XHRcdFx0Ly8gXCJpZiAoIGFsbCggc29tZXRoaW5nLCBzb21ldGhpbmcgKSApXCIgIHVzaW5nIHRoaXMgaW5zdGVhZFxyXG5cclxuXHRcdFx0XHRcImJ2ZWM0IGluRnJ1c3R1bVZlYyA9IGJ2ZWM0ICggc2hhZG93Q29vcmQueCA+PSAwLjAsIHNoYWRvd0Nvb3JkLnggPD0gMS4wLCBzaGFkb3dDb29yZC55ID49IDAuMCwgc2hhZG93Q29vcmQueSA8PSAxLjAgKTtcIixcclxuXHRcdFx0XHRcImJvb2wgaW5GcnVzdHVtID0gYWxsKCBpbkZydXN0dW1WZWMgKTtcIixcclxuXHJcblx0XHRcdFx0Ly8gZG9uJ3Qgc2hhZG93IHBpeGVscyBvdXRzaWRlIG9mIGxpZ2h0IGZydXN0dW1cclxuXHRcdFx0XHQvLyB1c2UganVzdCBmaXJzdCBmcnVzdHVtIChmb3IgY2FzY2FkZXMpXHJcblx0XHRcdFx0Ly8gZG9uJ3Qgc2hhZG93IHBpeGVscyBiZWhpbmQgZmFyIHBsYW5lIG9mIGxpZ2h0IGZydXN0dW1cclxuXHJcblx0XHRcdFx0XCIjaWZkZWYgU0hBRE9XTUFQX0NBU0NBREVcIixcclxuXHJcblx0XHRcdFx0XHRcImluRnJ1c3R1bUNvdW50ICs9IGludCggaW5GcnVzdHVtICk7XCIsXHJcblx0XHRcdFx0XHRcImJ2ZWMzIGZydXN0dW1UZXN0VmVjID0gYnZlYzMoIGluRnJ1c3R1bSwgaW5GcnVzdHVtQ291bnQgPT0gMSwgc2hhZG93Q29vcmQueiA8PSAxLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XCIjZWxzZVwiLFxyXG5cclxuXHRcdFx0XHRcdFwiYnZlYzIgZnJ1c3R1bVRlc3RWZWMgPSBidmVjMiggaW5GcnVzdHVtLCBzaGFkb3dDb29yZC56IDw9IDEuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHRcImJvb2wgZnJ1c3R1bVRlc3QgPSBhbGwoIGZydXN0dW1UZXN0VmVjICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiaWYgKCBmcnVzdHVtVGVzdCApIHtcIixcclxuXHJcblx0XHRcdFx0XHRcInNoYWRvd0Nvb3JkLnogKz0gc2hhZG93Qmlhc1sgaSBdO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiI2lmIGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRiApXCIsXHJcblxyXG5cdFx0XHRcdFx0XHQvLyBQZXJjZW50YWdlLWNsb3NlIGZpbHRlcmluZ1xyXG5cdFx0XHRcdFx0XHQvLyAoOSBwaXhlbCBrZXJuZWwpXHJcblx0XHRcdFx0XHRcdC8vIGh0dHA6Ly9mYWJpZW5zYW5nbGFyZC5uZXQvc2hhZG93bWFwcGluZ1BDRi9cclxuXHJcblx0XHRcdFx0XHRcdFwiZmxvYXQgc2hhZG93ID0gMC4wO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0LypcclxuXHRcdFx0XHRcdFx0Ly8gbmVzdGVkIGxvb3BzIGJyZWFrcyBzaGFkZXIgY29tcGlsZXIgLyB2YWxpZGF0b3Igb24gc29tZSBBVEkgY2FyZHMgd2hlbiB1c2luZyBPcGVuR0xcclxuXHRcdFx0XHRcdFx0Ly8gbXVzdCBlbnJvbGwgbG9vcCBtYW51YWxseVxyXG5cclxuXHRcdFx0XHRcdFx0XCJmb3IgKCBmbG9hdCB5ID0gLTEuMjU7IHkgPD0gMS4yNTsgeSArPSAxLjI1IClcIixcclxuXHRcdFx0XHRcdFx0XHRcImZvciAoIGZsb2F0IHggPSAtMS4yNTsgeCA8PSAxLjI1OyB4ICs9IDEuMjUgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XCJ2ZWM0IHJnYmFEZXB0aCA9IHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHZlYzIoIHggKiB4UGl4ZWxPZmZzZXQsIHkgKiB5UGl4ZWxPZmZzZXQgKSArIHNoYWRvd0Nvb3JkLnh5ICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZG9lc24ndCBzZWVtIHRvIHByb2R1Y2UgYW55IG5vdGljZWFibGUgdmlzdWFsIGRpZmZlcmVuY2UgY29tcGFyZWQgdG8gc2ltcGxlIFwidGV4dHVyZTJEXCIgbG9va3VwXHJcblx0XHRcdFx0XHRcdFx0XHQvL1widmVjNCByZ2JhRGVwdGggPSB0ZXh0dXJlMkRQcm9qKCBzaGFkb3dNYXBbIGkgXSwgdmVjNCggdlNoYWRvd0Nvb3JkWyBpIF0udyAqICggdmVjMiggeCAqIHhQaXhlbE9mZnNldCwgeSAqIHlQaXhlbE9mZnNldCApICsgc2hhZG93Q29vcmQueHkgKSwgMC4wNSwgdlNoYWRvd0Nvb3JkWyBpIF0udyApICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XCJmbG9hdCBmRGVwdGggPSB1bnBhY2tEZXB0aCggcmdiYURlcHRoICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XCJpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKVwiLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcInNoYWRvdyArPSAxLjA7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcIn1cIixcclxuXHJcblx0XHRcdFx0XHRcdFwic2hhZG93IC89IDkuMDtcIixcclxuXHJcblx0XHRcdFx0XHRcdCovXHJcblxyXG5cdFx0XHRcdFx0XHRcImNvbnN0IGZsb2F0IHNoYWRvd0RlbHRhID0gMS4wIC8gOS4wO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJmbG9hdCB4UGl4ZWxPZmZzZXQgPSAxLjAgLyBzaGFkb3dNYXBTaXplWyBpIF0ueDtcIixcclxuXHRcdFx0XHRcdFx0XCJmbG9hdCB5UGl4ZWxPZmZzZXQgPSAxLjAgLyBzaGFkb3dNYXBTaXplWyBpIF0ueTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiZmxvYXQgZHgwID0gLTEuMjUgKiB4UGl4ZWxPZmZzZXQ7XCIsXHJcblx0XHRcdFx0XHRcdFwiZmxvYXQgZHkwID0gLTEuMjUgKiB5UGl4ZWxPZmZzZXQ7XCIsXHJcblx0XHRcdFx0XHRcdFwiZmxvYXQgZHgxID0gMS4yNSAqIHhQaXhlbE9mZnNldDtcIixcclxuXHRcdFx0XHRcdFx0XCJmbG9hdCBkeTEgPSAxLjI1ICogeVBpeGVsT2Zmc2V0O1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MCApICkgKTtcIixcclxuXHRcdFx0XHRcdFx0XCJpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gc2hhZG93RGVsdGE7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkwICkgKSApO1wiLFxyXG5cdFx0XHRcdFx0XHRcImlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBzaGFkb3dEZWx0YTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTAgKSApICk7XCIsXHJcblx0XHRcdFx0XHRcdFwiaWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IHNoYWRvd0RlbHRhO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIDAuMCApICkgKTtcIixcclxuXHRcdFx0XHRcdFx0XCJpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gc2hhZG93RGVsdGE7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSApICk7XCIsXHJcblx0XHRcdFx0XHRcdFwiaWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IHNoYWRvd0RlbHRhO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIDAuMCApICkgKTtcIixcclxuXHRcdFx0XHRcdFx0XCJpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gc2hhZG93RGVsdGE7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkxICkgKSApO1wiLFxyXG5cdFx0XHRcdFx0XHRcImlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBzaGFkb3dEZWx0YTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTEgKSApICk7XCIsXHJcblx0XHRcdFx0XHRcdFwiaWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IHNoYWRvd0RlbHRhO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIGR5MSApICkgKTtcIixcclxuXHRcdFx0XHRcdFx0XCJpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gc2hhZG93RGVsdGE7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcInNoYWRvd0NvbG9yID0gc2hhZG93Q29sb3IgKiB2ZWMzKCAoIDEuMCAtIHNoYWRvd0RhcmtuZXNzWyBpIF0gKiBzaGFkb3cgKSApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiI2VsaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGX1NPRlQgKVwiLFxyXG5cclxuXHRcdFx0XHRcdFx0Ly8gUGVyY2VudGFnZS1jbG9zZSBmaWx0ZXJpbmdcclxuXHRcdFx0XHRcdFx0Ly8gKDkgcGl4ZWwga2VybmVsKVxyXG5cdFx0XHRcdFx0XHQvLyBodHRwOi8vZmFiaWVuc2FuZ2xhcmQubmV0L3NoYWRvd21hcHBpbmdQQ0YvXHJcblxyXG5cdFx0XHRcdFx0XHRcImZsb2F0IHNoYWRvdyA9IDAuMDtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiZmxvYXQgeFBpeGVsT2Zmc2V0ID0gMS4wIC8gc2hhZG93TWFwU2l6ZVsgaSBdLng7XCIsXHJcblx0XHRcdFx0XHRcdFwiZmxvYXQgeVBpeGVsT2Zmc2V0ID0gMS4wIC8gc2hhZG93TWFwU2l6ZVsgaSBdLnk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImZsb2F0IGR4MCA9IC0xLjAgKiB4UGl4ZWxPZmZzZXQ7XCIsXHJcblx0XHRcdFx0XHRcdFwiZmxvYXQgZHkwID0gLTEuMCAqIHlQaXhlbE9mZnNldDtcIixcclxuXHRcdFx0XHRcdFx0XCJmbG9hdCBkeDEgPSAxLjAgKiB4UGl4ZWxPZmZzZXQ7XCIsXHJcblx0XHRcdFx0XHRcdFwiZmxvYXQgZHkxID0gMS4wICogeVBpeGVsT2Zmc2V0O1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJtYXQzIHNoYWRvd0tlcm5lbDtcIixcclxuXHRcdFx0XHRcdFx0XCJtYXQzIGRlcHRoS2VybmVsO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJkZXB0aEtlcm5lbFswXVswXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkwICkgKSApO1wiLFxyXG5cdFx0XHRcdFx0XHRcImlmICggZGVwdGhLZXJuZWxbMF1bMF0gPCBzaGFkb3dDb29yZC56ICkgc2hhZG93S2VybmVsWzBdWzBdID0gMC4yNTtcIixcclxuXHRcdFx0XHRcdFx0XCJlbHNlIHNoYWRvd0tlcm5lbFswXVswXSA9IDAuMDtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiZGVwdGhLZXJuZWxbMF1bMV0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIDAuMCApICkgKTtcIixcclxuXHRcdFx0XHRcdFx0XCJpZiAoIGRlcHRoS2VybmVsWzBdWzFdIDwgc2hhZG93Q29vcmQueiApIHNoYWRvd0tlcm5lbFswXVsxXSA9IDAuMjU7XCIsXHJcblx0XHRcdFx0XHRcdFwiZWxzZSBzaGFkb3dLZXJuZWxbMF1bMV0gPSAwLjA7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImRlcHRoS2VybmVsWzBdWzJdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MSApICkgKTtcIixcclxuXHRcdFx0XHRcdFx0XCJpZiAoIGRlcHRoS2VybmVsWzBdWzJdIDwgc2hhZG93Q29vcmQueiApIHNoYWRvd0tlcm5lbFswXVsyXSA9IDAuMjU7XCIsXHJcblx0XHRcdFx0XHRcdFwiZWxzZSBzaGFkb3dLZXJuZWxbMF1bMl0gPSAwLjA7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImRlcHRoS2VybmVsWzFdWzBdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTAgKSApICk7XCIsXHJcblx0XHRcdFx0XHRcdFwiaWYgKCBkZXB0aEtlcm5lbFsxXVswXSA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3dLZXJuZWxbMV1bMF0gPSAwLjI1O1wiLFxyXG5cdFx0XHRcdFx0XHRcImVsc2Ugc2hhZG93S2VybmVsWzFdWzBdID0gMC4wO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJkZXB0aEtlcm5lbFsxXVsxXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSApICk7XCIsXHJcblx0XHRcdFx0XHRcdFwiaWYgKCBkZXB0aEtlcm5lbFsxXVsxXSA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3dLZXJuZWxbMV1bMV0gPSAwLjI1O1wiLFxyXG5cdFx0XHRcdFx0XHRcImVsc2Ugc2hhZG93S2VybmVsWzFdWzFdID0gMC4wO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJkZXB0aEtlcm5lbFsxXVsyXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkxICkgKSApO1wiLFxyXG5cdFx0XHRcdFx0XHRcImlmICggZGVwdGhLZXJuZWxbMV1bMl0gPCBzaGFkb3dDb29yZC56ICkgc2hhZG93S2VybmVsWzFdWzJdID0gMC4yNTtcIixcclxuXHRcdFx0XHRcdFx0XCJlbHNlIHNoYWRvd0tlcm5lbFsxXVsyXSA9IDAuMDtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiZGVwdGhLZXJuZWxbMl1bMF0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIGR5MCApICkgKTtcIixcclxuXHRcdFx0XHRcdFx0XCJpZiAoIGRlcHRoS2VybmVsWzJdWzBdIDwgc2hhZG93Q29vcmQueiApIHNoYWRvd0tlcm5lbFsyXVswXSA9IDAuMjU7XCIsXHJcblx0XHRcdFx0XHRcdFwiZWxzZSBzaGFkb3dLZXJuZWxbMl1bMF0gPSAwLjA7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImRlcHRoS2VybmVsWzJdWzFdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCAwLjAgKSApICk7XCIsXHJcblx0XHRcdFx0XHRcdFwiaWYgKCBkZXB0aEtlcm5lbFsyXVsxXSA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3dLZXJuZWxbMl1bMV0gPSAwLjI1O1wiLFxyXG5cdFx0XHRcdFx0XHRcImVsc2Ugc2hhZG93S2VybmVsWzJdWzFdID0gMC4wO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJkZXB0aEtlcm5lbFsyXVsyXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkxICkgKSApO1wiLFxyXG5cdFx0XHRcdFx0XHRcImlmICggZGVwdGhLZXJuZWxbMl1bMl0gPCBzaGFkb3dDb29yZC56ICkgc2hhZG93S2VybmVsWzJdWzJdID0gMC4yNTtcIixcclxuXHRcdFx0XHRcdFx0XCJlbHNlIHNoYWRvd0tlcm5lbFsyXVsyXSA9IDAuMDtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwidmVjMiBmcmFjdGlvbmFsQ29vcmQgPSAxLjAgLSBmcmFjdCggc2hhZG93Q29vcmQueHkgKiBzaGFkb3dNYXBTaXplW2ldLnh5ICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcInNoYWRvd0tlcm5lbFswXSA9IG1peCggc2hhZG93S2VybmVsWzFdLCBzaGFkb3dLZXJuZWxbMF0sIGZyYWN0aW9uYWxDb29yZC54ICk7XCIsXHJcblx0XHRcdFx0XHRcdFwic2hhZG93S2VybmVsWzFdID0gbWl4KCBzaGFkb3dLZXJuZWxbMl0sIHNoYWRvd0tlcm5lbFsxXSwgZnJhY3Rpb25hbENvb3JkLnggKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwidmVjNCBzaGFkb3dWYWx1ZXM7XCIsXHJcblx0XHRcdFx0XHRcdFwic2hhZG93VmFsdWVzLnggPSBtaXgoIHNoYWRvd0tlcm5lbFswXVsxXSwgc2hhZG93S2VybmVsWzBdWzBdLCBmcmFjdGlvbmFsQ29vcmQueSApO1wiLFxyXG5cdFx0XHRcdFx0XHRcInNoYWRvd1ZhbHVlcy55ID0gbWl4KCBzaGFkb3dLZXJuZWxbMF1bMl0sIHNoYWRvd0tlcm5lbFswXVsxXSwgZnJhY3Rpb25hbENvb3JkLnkgKTtcIixcclxuXHRcdFx0XHRcdFx0XCJzaGFkb3dWYWx1ZXMueiA9IG1peCggc2hhZG93S2VybmVsWzFdWzFdLCBzaGFkb3dLZXJuZWxbMV1bMF0sIGZyYWN0aW9uYWxDb29yZC55ICk7XCIsXHJcblx0XHRcdFx0XHRcdFwic2hhZG93VmFsdWVzLncgPSBtaXgoIHNoYWRvd0tlcm5lbFsxXVsyXSwgc2hhZG93S2VybmVsWzFdWzFdLCBmcmFjdGlvbmFsQ29vcmQueSApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJzaGFkb3cgPSBkb3QoIHNoYWRvd1ZhbHVlcywgdmVjNCggMS4wICkgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwic2hhZG93Q29sb3IgPSBzaGFkb3dDb2xvciAqIHZlYzMoICggMS4wIC0gc2hhZG93RGFya25lc3NbIGkgXSAqIHNoYWRvdyApICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCIjZWxzZVwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJ2ZWM0IHJnYmFEZXB0aCA9IHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICk7XCIsXHJcblx0XHRcdFx0XHRcdFwiZmxvYXQgZkRlcHRoID0gdW5wYWNrRGVwdGgoIHJnYmFEZXB0aCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKVwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHQvLyBzcG90IHdpdGggbXVsdGlwbGUgc2hhZG93cyBpcyBkYXJrZXJcclxuXHJcblx0XHRcdFx0XHRcdFx0XCJzaGFkb3dDb2xvciA9IHNoYWRvd0NvbG9yICogdmVjMyggMS4wIC0gc2hhZG93RGFya25lc3NbIGkgXSApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHQvLyBzcG90IHdpdGggbXVsdGlwbGUgc2hhZG93cyBoYXMgdGhlIHNhbWUgY29sb3IgYXMgc2luZ2xlIHNoYWRvdyBzcG90XHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vXCJzaGFkb3dDb2xvciA9IG1pbiggc2hhZG93Q29sb3IsIHZlYzMoIHNoYWRvd0RhcmtuZXNzWyBpIF0gKSApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFwifVwiLFxyXG5cclxuXHJcblx0XHRcdFx0XCIjaWZkZWYgU0hBRE9XTUFQX0RFQlVHXCIsXHJcblxyXG5cdFx0XHRcdFx0XCIjaWZkZWYgU0hBRE9XTUFQX0NBU0NBREVcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiaWYgKCBpbkZydXN0dW0gJiYgaW5GcnVzdHVtQ291bnQgPT0gMSApIGdsX0ZyYWdDb2xvci54eXogKj0gZnJ1c3R1bUNvbG9yc1sgaSBdO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiI2Vsc2VcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiaWYgKCBpbkZydXN0dW0gKSBnbF9GcmFnQ29sb3IueHl6ICo9IGZydXN0dW1Db2xvcnNbIGkgXTtcIixcclxuXHJcblx0XHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XHRcIiNpZmRlZiBHQU1NQV9PVVRQVVRcIixcclxuXHJcblx0XHRcdFx0XCJzaGFkb3dDb2xvciAqPSBzaGFkb3dDb2xvcjtcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcImdsX0ZyYWdDb2xvci54eXogPSBnbF9GcmFnQ29sb3IueHl6ICogc2hhZG93Q29sb3I7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdHNoYWRvd21hcF9wYXJzX3ZlcnRleDogW1xyXG5cclxuXHRcdFwiI2lmZGVmIFVTRV9TSEFET1dNQVBcIixcclxuXHJcblx0XHRcdFwidmFyeWluZyB2ZWM0IHZTaGFkb3dDb29yZFsgTUFYX1NIQURPV1MgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIG1hdDQgc2hhZG93TWF0cml4WyBNQVhfU0hBRE9XUyBdO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRzaGFkb3dtYXBfdmVydGV4OiBbXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX1NIQURPV01BUFwiLFxyXG5cclxuXHRcdFx0XCJmb3IoIGludCBpID0gMDsgaSA8IE1BWF9TSEFET1dTOyBpICsrICkge1wiLFxyXG5cclxuXHRcdFx0XHRcInZTaGFkb3dDb29yZFsgaSBdID0gc2hhZG93TWF0cml4WyBpIF0gKiB3b3JsZFBvc2l0aW9uO1wiLFxyXG5cclxuXHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdC8vIEFMUEhBVEVTVFxyXG5cclxuXHRhbHBoYXRlc3RfZnJhZ21lbnQ6IFtcclxuXHJcblx0XHRcIiNpZmRlZiBBTFBIQVRFU1RcIixcclxuXHJcblx0XHRcdFwiaWYgKCBnbF9GcmFnQ29sb3IuYSA8IEFMUEhBVEVTVCApIGRpc2NhcmQ7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdC8vIExJTkVBUiBTUEFDRVxyXG5cclxuXHRsaW5lYXJfdG9fZ2FtbWFfZnJhZ21lbnQ6IFtcclxuXHJcblx0XHRcIiNpZmRlZiBHQU1NQV9PVVRQVVRcIixcclxuXHJcblx0XHRcdFwiZ2xfRnJhZ0NvbG9yLnh5eiA9IHNxcnQoIGdsX0ZyYWdDb2xvci54eXogKTtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKVxyXG5cclxuXHJcbn07XHJcblxyXG5USFJFRS5Vbmlmb3Jtc1V0aWxzID0ge1xyXG5cclxuXHRtZXJnZTogZnVuY3Rpb24gKCB1bmlmb3JtcyApIHtcclxuXHJcblx0XHR2YXIgdSwgcCwgdG1wLCBtZXJnZWQgPSB7fTtcclxuXHJcblx0XHRmb3IgKCB1ID0gMDsgdSA8IHVuaWZvcm1zLmxlbmd0aDsgdSArKyApIHtcclxuXHJcblx0XHRcdHRtcCA9IHRoaXMuY2xvbmUoIHVuaWZvcm1zWyB1IF0gKTtcclxuXHJcblx0XHRcdGZvciAoIHAgaW4gdG1wICkge1xyXG5cclxuXHRcdFx0XHRtZXJnZWRbIHAgXSA9IHRtcFsgcCBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbWVyZ2VkO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCB1bmlmb3Jtc19zcmMgKSB7XHJcblxyXG5cdFx0dmFyIHUsIHAsIHBhcmFtZXRlciwgcGFyYW1ldGVyX3NyYywgdW5pZm9ybXNfZHN0ID0ge307XHJcblxyXG5cdFx0Zm9yICggdSBpbiB1bmlmb3Jtc19zcmMgKSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtc19kc3RbIHUgXSA9IHt9O1xyXG5cclxuXHRcdFx0Zm9yICggcCBpbiB1bmlmb3Jtc19zcmNbIHUgXSApIHtcclxuXHJcblx0XHRcdFx0cGFyYW1ldGVyX3NyYyA9IHVuaWZvcm1zX3NyY1sgdSBdWyBwIF07XHJcblxyXG5cdFx0XHRcdGlmICggcGFyYW1ldGVyX3NyYyBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yIHx8XHJcblx0XHRcdFx0XHQgcGFyYW1ldGVyX3NyYyBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjIgfHxcclxuXHRcdFx0XHRcdCBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMyB8fFxyXG5cdFx0XHRcdFx0IHBhcmFtZXRlcl9zcmMgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3I0IHx8XHJcblx0XHRcdFx0XHQgcGFyYW1ldGVyX3NyYyBpbnN0YW5jZW9mIFRIUkVFLk1hdHJpeDQgfHxcclxuXHRcdFx0XHRcdCBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdFx0XHR1bmlmb3Jtc19kc3RbIHUgXVsgcCBdID0gcGFyYW1ldGVyX3NyYy5jbG9uZSgpO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgQXJyYXkgKSB7XHJcblxyXG5cdFx0XHRcdFx0dW5pZm9ybXNfZHN0WyB1IF1bIHAgXSA9IHBhcmFtZXRlcl9zcmMuc2xpY2UoKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHR1bmlmb3Jtc19kc3RbIHUgXVsgcCBdID0gcGFyYW1ldGVyX3NyYztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdW5pZm9ybXNfZHN0O1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuVW5pZm9ybXNMaWIgPSB7XHJcblxyXG5cdGNvbW1vbjoge1xyXG5cclxuXHRcdFwiZGlmZnVzZVwiIDogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHhlZWVlZWUgKSB9LFxyXG5cdFx0XCJvcGFjaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXHJcblxyXG5cdFx0XCJtYXBcIiA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXHJcblx0XHRcIm9mZnNldFJlcGVhdFwiIDogeyB0eXBlOiBcInY0XCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yNCggMCwgMCwgMSwgMSApIH0sXHJcblxyXG5cdFx0XCJsaWdodE1hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcclxuXHRcdFwic3BlY3VsYXJNYXBcIiA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXHJcblxyXG5cdFx0XCJlbnZNYXBcIiA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXHJcblx0XHRcImZsaXBFbnZNYXBcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAtMSB9LFxyXG5cdFx0XCJ1c2VSZWZyYWN0XCIgOiB7IHR5cGU6IFwiaVwiLCB2YWx1ZTogMCB9LFxyXG5cdFx0XCJyZWZsZWN0aXZpdHlcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfSxcclxuXHRcdFwicmVmcmFjdGlvblJhdGlvXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMC45OCB9LFxyXG5cdFx0XCJjb21iaW5lXCIgOiB7IHR5cGU6IFwiaVwiLCB2YWx1ZTogMCB9LFxyXG5cclxuXHRcdFwibW9ycGhUYXJnZXRJbmZsdWVuY2VzXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMCB9XHJcblxyXG5cdH0sXHJcblxyXG5cdGJ1bXA6IHtcclxuXHJcblx0XHRcImJ1bXBNYXBcIiA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXHJcblx0XHRcImJ1bXBTY2FsZVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEgfVxyXG5cclxuXHR9LFxyXG5cclxuXHRub3JtYWxtYXA6IHtcclxuXHJcblx0XHRcIm5vcm1hbE1hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcclxuXHRcdFwibm9ybWFsU2NhbGVcIiA6IHsgdHlwZTogXCJ2MlwiLCB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjIoIDEsIDEgKSB9XHJcblx0fSxcclxuXHJcblx0Zm9nIDoge1xyXG5cclxuXHRcdFwiZm9nRGVuc2l0eVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDAuMDAwMjUgfSxcclxuXHRcdFwiZm9nTmVhclwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEgfSxcclxuXHRcdFwiZm9nRmFyXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMjAwMCB9LFxyXG5cdFx0XCJmb2dDb2xvclwiIDogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKSB9XHJcblxyXG5cdH0sXHJcblxyXG5cdGxpZ2h0czoge1xyXG5cclxuXHRcdFwiYW1iaWVudExpZ2h0Q29sb3JcIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcclxuXHJcblx0XHRcImRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25cIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcclxuXHRcdFwiZGlyZWN0aW9uYWxMaWdodENvbG9yXCIgOiB7IHR5cGU6IFwiZnZcIiwgdmFsdWU6IFtdIH0sXHJcblxyXG5cdFx0XCJoZW1pc3BoZXJlTGlnaHREaXJlY3Rpb25cIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcclxuXHRcdFwiaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3JcIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcclxuXHRcdFwiaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3JcIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcclxuXHJcblx0XHRcInBvaW50TGlnaHRDb2xvclwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxyXG5cdFx0XCJwb2ludExpZ2h0UG9zaXRpb25cIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcclxuXHRcdFwicG9pbnRMaWdodERpc3RhbmNlXCIgOiB7IHR5cGU6IFwiZnYxXCIsIHZhbHVlOiBbXSB9LFxyXG5cclxuXHRcdFwic3BvdExpZ2h0Q29sb3JcIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcclxuXHRcdFwic3BvdExpZ2h0UG9zaXRpb25cIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcclxuXHRcdFwic3BvdExpZ2h0RGlyZWN0aW9uXCIgOiB7IHR5cGU6IFwiZnZcIiwgdmFsdWU6IFtdIH0sXHJcblx0XHRcInNwb3RMaWdodERpc3RhbmNlXCIgOiB7IHR5cGU6IFwiZnYxXCIsIHZhbHVlOiBbXSB9LFxyXG5cdFx0XCJzcG90TGlnaHRBbmdsZUNvc1wiIDogeyB0eXBlOiBcImZ2MVwiLCB2YWx1ZTogW10gfSxcclxuXHRcdFwic3BvdExpZ2h0RXhwb25lbnRcIiA6IHsgdHlwZTogXCJmdjFcIiwgdmFsdWU6IFtdIH1cclxuXHJcblx0fSxcclxuXHJcblx0cGFydGljbGU6IHtcclxuXHJcblx0XHRcInBzQ29sb3JcIiA6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4ZWVlZWVlICkgfSxcclxuXHRcdFwib3BhY2l0eVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9LFxyXG5cdFx0XCJzaXplXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXHJcblx0XHRcInNjYWxlXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXHJcblx0XHRcIm1hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcclxuXHJcblx0XHRcImZvZ0RlbnNpdHlcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwLjAwMDI1IH0sXHJcblx0XHRcImZvZ05lYXJcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH0sXHJcblx0XHRcImZvZ0ZhclwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDIwMDAgfSxcclxuXHRcdFwiZm9nQ29sb3JcIiA6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICkgfVxyXG5cclxuXHR9LFxyXG5cclxuXHRzaGFkb3dtYXA6IHtcclxuXHJcblx0XHRcInNoYWRvd01hcFwiOiB7IHR5cGU6IFwidHZcIiwgdmFsdWU6IFtdIH0sXHJcblx0XHRcInNoYWRvd01hcFNpemVcIjogeyB0eXBlOiBcInYydlwiLCB2YWx1ZTogW10gfSxcclxuXHJcblx0XHRcInNoYWRvd0JpYXNcIiA6IHsgdHlwZTogXCJmdjFcIiwgdmFsdWU6IFtdIH0sXHJcblx0XHRcInNoYWRvd0RhcmtuZXNzXCI6IHsgdHlwZTogXCJmdjFcIiwgdmFsdWU6IFtdIH0sXHJcblxyXG5cdFx0XCJzaGFkb3dNYXRyaXhcIiA6IHsgdHlwZTogXCJtNHZcIiwgdmFsdWU6IFtdIH1cclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLlNoYWRlckxpYiA9IHtcclxuXHJcblx0J2Jhc2ljJzoge1xyXG5cclxuXHRcdHVuaWZvcm1zOiBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXHJcblxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJjb21tb25cIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJmb2dcIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJzaGFkb3dtYXBcIiBdXHJcblxyXG5cdFx0XSApLFxyXG5cclxuXHRcdHZlcnRleFNoYWRlcjogW1xyXG5cclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRtYXBfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5pbmdfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0bWFwX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2luYmFzZV92ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XHRcIiNpZmRlZiBVU0VfRU5WTUFQXCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBobm9ybWFsX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5vcm1hbF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImRlZmF1bHRub3JtYWxfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImRlZmF1bHRfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwid29ybGRwb3NfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRcdGZyYWdtZW50U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcclxuXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYXRlc3RfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNwZWN1bGFybWFwX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodG1hcF9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGluZWFyX3RvX2dhbW1hX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKFwiXFxuXCIpXHJcblxyXG5cdH0sXHJcblxyXG5cdCdsYW1iZXJ0Jzoge1xyXG5cclxuXHRcdHVuaWZvcm1zOiBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXHJcblxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJjb21tb25cIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJmb2dcIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJsaWdodHNcIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJzaGFkb3dtYXBcIiBdLFxyXG5cclxuXHRcdFx0e1xyXG5cdFx0XHRcdFwiYW1iaWVudFwiICA6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICkgfSxcclxuXHRcdFx0XHRcImVtaXNzaXZlXCIgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweDAwMDAwMCApIH0sXHJcblx0XHRcdFx0XCJ3cmFwUkdCXCIgIDogeyB0eXBlOiBcInYzXCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMSwgMSApIH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdF0gKSxcclxuXHJcblx0XHR2ZXJ0ZXhTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwiI2RlZmluZSBMQU1CRVJUXCIsXHJcblxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2TGlnaHRGcm9udDtcIixcclxuXHJcblx0XHRcdFwiI2lmZGVmIERPVUJMRV9TSURFRFwiLFxyXG5cclxuXHRcdFx0XHRcInZhcnlpbmcgdmVjMyB2TGlnaHRCYWNrO1wiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0bWFwX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX2xhbWJlcnRfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5pbmdfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0bWFwX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGhub3JtYWxfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2luYmFzZV92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5ub3JtYWxfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJkZWZhdWx0bm9ybWFsX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5pbmdfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJkZWZhdWx0X3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIndvcmxkcG9zX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX2xhbWJlcnRfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRcdGZyYWdtZW50U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcclxuXHJcblx0XHRcdFwidmFyeWluZyB2ZWMzIHZMaWdodEZyb250O1wiLFxyXG5cclxuXHRcdFx0XCIjaWZkZWYgRE9VQkxFX1NJREVEXCIsXHJcblxyXG5cdFx0XHRcdFwidmFyeWluZyB2ZWMzIHZMaWdodEJhY2s7XCIsXHJcblxyXG5cdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdmVjNCggdmVjMyAoIDEuMCApLCBvcGFjaXR5ICk7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGF0ZXN0X2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF9mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcdFwiI2lmZGVmIERPVUJMRV9TSURFRFwiLFxyXG5cclxuXHRcdFx0XHRcdC8vXCJmbG9hdCBpc0Zyb250ID0gZmxvYXQoIGdsX0Zyb250RmFjaW5nICk7XCIsXHJcblx0XHRcdFx0XHQvL1wiZ2xfRnJhZ0NvbG9yLnh5eiAqPSBpc0Zyb250ICogdkxpZ2h0RnJvbnQgKyAoIDEuMCAtIGlzRnJvbnQgKSAqIHZMaWdodEJhY2s7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJpZiAoIGdsX0Zyb250RmFjaW5nIClcIixcclxuXHRcdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IueHl6ICo9IHZMaWdodEZyb250O1wiLFxyXG5cdFx0XHRcdFx0XCJlbHNlXCIsXHJcblx0XHRcdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yLnh5eiAqPSB2TGlnaHRCYWNrO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IueHl6ICo9IHZMaWdodEZyb250O1wiLFxyXG5cclxuXHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodG1hcF9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGluZWFyX3RvX2dhbW1hX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKFwiXFxuXCIpXHJcblxyXG5cdH0sXHJcblxyXG5cdCdwaG9uZyc6IHtcclxuXHJcblx0XHR1bmlmb3JtczogVEhSRUUuVW5pZm9ybXNVdGlscy5tZXJnZSggW1xyXG5cclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiY29tbW9uXCIgXSxcclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiYnVtcFwiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcIm5vcm1hbG1hcFwiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImZvZ1wiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImxpZ2h0c1wiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcInNoYWRvd21hcFwiIF0sXHJcblxyXG5cdFx0XHR7XHJcblx0XHRcdFx0XCJhbWJpZW50XCIgIDogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKSB9LFxyXG5cdFx0XHRcdFwiZW1pc3NpdmVcIiA6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICkgfSxcclxuXHRcdFx0XHRcInNwZWN1bGFyXCIgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweDExMTExMSApIH0sXHJcblx0XHRcdFx0XCJzaGluaW5lc3NcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDMwIH0sXHJcblx0XHRcdFx0XCJ3cmFwUkdCXCIgIDogeyB0eXBlOiBcInYzXCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMSwgMSApIH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdF0gKSxcclxuXHJcblx0XHR2ZXJ0ZXhTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwiI2RlZmluZSBQSE9OR1wiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcIixcclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcIixcclxuXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0bWFwX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX3Bob25nX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodG1hcF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBobm9ybWFsX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbmJhc2VfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubm9ybWFsX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGVmYXVsdG5vcm1hbF92ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XHRcInZOb3JtYWwgPSBub3JtYWxpemUoIHRyYW5zZm9ybWVkTm9ybWFsICk7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5pbmdfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJkZWZhdWx0X3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcdFwidlZpZXdQb3NpdGlvbiA9IC1tdlBvc2l0aW9uLnh5ejtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwid29ybGRwb3NfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfcGhvbmdfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRcdGZyYWdtZW50U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGFtYmllbnQ7XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGVtaXNzaXZlO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBzcGVjdWxhcjtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHNoaW5pbmVzcztcIixcclxuXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImJ1bXBtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFx0XCJnbF9GcmFnQ29sb3IgPSB2ZWM0KCB2ZWMzICggMS4wICksIG9wYWNpdHkgKTtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYXRlc3RfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNwZWN1bGFybWFwX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX3Bob25nX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRtYXBfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpbmVhcl90b19nYW1tYV9mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcIn1cIlxyXG5cclxuXHRcdF0uam9pbihcIlxcblwiKVxyXG5cclxuXHR9LFxyXG5cclxuXHQncGFydGljbGVfYmFzaWMnOiB7XHJcblxyXG5cdFx0dW5pZm9ybXM6ICBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXHJcblxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJwYXJ0aWNsZVwiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcInNoYWRvd21hcFwiIF1cclxuXHJcblx0XHRdICksXHJcblxyXG5cdFx0dmVydGV4U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgc2l6ZTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHNjYWxlO1wiLFxyXG5cclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcdFwidmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNpZmRlZiBVU0VfU0laRUFUVEVOVUFUSU9OXCIsXHJcblx0XHRcdFx0XHRcImdsX1BvaW50U2l6ZSA9IHNpemUgKiAoIHNjYWxlIC8gbGVuZ3RoKCBtdlBvc2l0aW9uLnh5eiApICk7XCIsXHJcblx0XHRcdFx0XCIjZWxzZVwiLFxyXG5cdFx0XHRcdFx0XCJnbF9Qb2ludFNpemUgPSBzaXplO1wiLFxyXG5cdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFwiZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwid29ybGRwb3NfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRcdGZyYWdtZW50U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBwc0NvbG9yO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcclxuXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfcGFydGljbGVfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdmVjNCggcHNDb2xvciwgb3BhY2l0eSApO1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfcGFydGljbGVfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhdGVzdF9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKFwiXFxuXCIpXHJcblxyXG5cdH0sXHJcblxyXG5cdCdkYXNoZWQnOiB7XHJcblxyXG5cdFx0dW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcclxuXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImNvbW1vblwiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImZvZ1wiIF0sXHJcblxyXG5cdFx0XHR7XHJcblx0XHRcdFx0XCJzY2FsZVwiOiAgICAgeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEgfSxcclxuXHRcdFx0XHRcImRhc2hTaXplXCI6ICB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMSB9LFxyXG5cdFx0XHRcdFwidG90YWxTaXplXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAyIH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdF0gKSxcclxuXHJcblx0XHR2ZXJ0ZXhTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBzY2FsZTtcIixcclxuXHRcdFx0XCJhdHRyaWJ1dGUgZmxvYXQgbGluZURpc3RhbmNlO1wiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIGZsb2F0IHZMaW5lRGlzdGFuY2U7XCIsXHJcblxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFx0XCJ2TGluZURpc3RhbmNlID0gc2NhbGUgKiBsaW5lRGlzdGFuY2U7XCIsXHJcblxyXG5cdFx0XHRcdFwidmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxyXG5cdFx0XHRcdFwiZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtcIixcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRcdGZyYWdtZW50U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBkYXNoU2l6ZTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHRvdGFsU2l6ZTtcIixcclxuXHJcblx0XHRcdFwidmFyeWluZyBmbG9hdCB2TGluZURpc3RhbmNlO1wiLFxyXG5cclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XHRcImlmICggbW9kKCB2TGluZURpc3RhbmNlLCB0b3RhbFNpemUgKSA+IGRhc2hTaXplICkge1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiZGlzY2FyZDtcIixcclxuXHJcblx0XHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKFwiXFxuXCIpXHJcblxyXG5cdH0sXHJcblxyXG5cdCdkZXB0aCc6IHtcclxuXHJcblx0XHR1bmlmb3Jtczoge1xyXG5cclxuXHRcdFx0XCJtTmVhclwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXHJcblx0XHRcdFwibUZhclwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDIwMDAuMCB9LFxyXG5cdFx0XHRcIm9wYWNpdHlcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfVxyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0dmVydGV4U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFx0XCJnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXHJcblxyXG5cdFx0XHRcIn1cIlxyXG5cclxuXHRcdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0XHRmcmFnbWVudFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IG1OZWFyO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgbUZhcjtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFx0XCJmbG9hdCBkZXB0aCA9IGdsX0ZyYWdDb29yZC56IC8gZ2xfRnJhZ0Nvb3JkLnc7XCIsXHJcblx0XHRcdFx0XCJmbG9hdCBjb2xvciA9IDEuMCAtIHNtb290aHN0ZXAoIG1OZWFyLCBtRmFyLCBkZXB0aCApO1wiLFxyXG5cdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdmVjNCggdmVjMyggY29sb3IgKSwgb3BhY2l0eSApO1wiLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oXCJcXG5cIilcclxuXHJcblx0fSxcclxuXHJcblx0J25vcm1hbCc6IHtcclxuXHJcblx0XHR1bmlmb3Jtczoge1xyXG5cclxuXHRcdFx0XCJvcGFjaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH1cclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHZlcnRleFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcIixcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XHRcInZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcclxuXHRcdFx0XHRcInZOb3JtYWwgPSBub3JtYWxpemUoIG5vcm1hbE1hdHJpeCAqIG5vcm1hbCApO1wiLFxyXG5cclxuXHRcdFx0XHRcImdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XCIsXHJcblxyXG5cdFx0XHRcIn1cIlxyXG5cclxuXHRcdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0XHRmcmFnbWVudFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXHJcblx0XHRcdFwidmFyeWluZyB2ZWMzIHZOb3JtYWw7XCIsXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFx0XCJnbF9GcmFnQ29sb3IgPSB2ZWM0KCAwLjUgKiBub3JtYWxpemUoIHZOb3JtYWwgKSArIDAuNSwgb3BhY2l0eSApO1wiLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oXCJcXG5cIilcclxuXHJcblx0fSxcclxuXHJcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cdC8vXHROb3JtYWwgbWFwIHNoYWRlclxyXG5cdC8vXHRcdC0gQmxpbm4tUGhvbmdcclxuXHQvL1x0XHQtIG5vcm1hbCArIGRpZmZ1c2UgKyBzcGVjdWxhciArIEFPICsgZGlzcGxhY2VtZW50ICsgcmVmbGVjdGlvbiArIHNoYWRvdyBtYXBzXHJcblx0Ly9cdFx0LSBwb2ludCBhbmQgZGlyZWN0aW9uYWwgbGlnaHRzICh1c2Ugd2l0aCBcImxpZ2h0czogdHJ1ZVwiIG1hdGVyaWFsIG9wdGlvbilcclxuXHQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG5cclxuXHQnbm9ybWFsbWFwJyA6IHtcclxuXHJcblx0XHR1bmlmb3JtczogVEhSRUUuVW5pZm9ybXNVdGlscy5tZXJnZSggW1xyXG5cclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiZm9nXCIgXSxcclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwibGlnaHRzXCIgXSxcclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwic2hhZG93bWFwXCIgXSxcclxuXHJcblx0XHRcdHtcclxuXHJcblx0XHRcdFwiZW5hYmxlQU9cIlx0XHQgIDogeyB0eXBlOiBcImlcIiwgdmFsdWU6IDAgfSxcclxuXHRcdFx0XCJlbmFibGVEaWZmdXNlXCJcdCAgOiB7IHR5cGU6IFwiaVwiLCB2YWx1ZTogMCB9LFxyXG5cdFx0XHRcImVuYWJsZVNwZWN1bGFyXCIgIDogeyB0eXBlOiBcImlcIiwgdmFsdWU6IDAgfSxcclxuXHRcdFx0XCJlbmFibGVSZWZsZWN0aW9uXCI6IHsgdHlwZTogXCJpXCIsIHZhbHVlOiAwIH0sXHJcblx0XHRcdFwiZW5hYmxlRGlzcGxhY2VtZW50XCI6IHsgdHlwZTogXCJpXCIsIHZhbHVlOiAwIH0sXHJcblxyXG5cdFx0XHRcInREaXNwbGFjZW1lbnRcIjogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSwgLy8gbXVzdCBnbyBmaXJzdCBhcyB0aGlzIGlzIHZlcnRleCB0ZXh0dXJlXHJcblx0XHRcdFwidERpZmZ1c2VcIlx0ICAgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxyXG5cdFx0XHRcInRDdWJlXCJcdFx0ICAgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxyXG5cdFx0XHRcInROb3JtYWxcIlx0ICAgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxyXG5cdFx0XHRcInRTcGVjdWxhclwiXHQgICA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXHJcblx0XHRcdFwidEFPXCJcdFx0ICAgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxyXG5cclxuXHRcdFx0XCJ1Tm9ybWFsU2NhbGVcIjogeyB0eXBlOiBcInYyXCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yMiggMSwgMSApIH0sXHJcblxyXG5cdFx0XHRcInVEaXNwbGFjZW1lbnRCaWFzXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwLjAgfSxcclxuXHRcdFx0XCJ1RGlzcGxhY2VtZW50U2NhbGVcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9LFxyXG5cclxuXHRcdFx0XCJ1RGlmZnVzZUNvbG9yXCI6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICkgfSxcclxuXHRcdFx0XCJ1U3BlY3VsYXJDb2xvclwiOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweDExMTExMSApIH0sXHJcblx0XHRcdFwidUFtYmllbnRDb2xvclwiOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApIH0sXHJcblx0XHRcdFwidVNoaW5pbmVzc1wiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMzAgfSxcclxuXHRcdFx0XCJ1T3BhY2l0eVwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMSB9LFxyXG5cclxuXHRcdFx0XCJ1c2VSZWZyYWN0XCI6IHsgdHlwZTogXCJpXCIsIHZhbHVlOiAwIH0sXHJcblx0XHRcdFwidVJlZnJhY3Rpb25SYXRpb1wiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMC45OCB9LFxyXG5cdFx0XHRcInVSZWZsZWN0aXZpdHlcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDAuNSB9LFxyXG5cclxuXHRcdFx0XCJ1T2Zmc2V0XCIgOiB7IHR5cGU6IFwidjJcIiwgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3IyKCAwLCAwICkgfSxcclxuXHRcdFx0XCJ1UmVwZWF0XCIgOiB7IHR5cGU6IFwidjJcIiwgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3IyKCAxLCAxICkgfSxcclxuXHJcblx0XHRcdFwid3JhcFJHQlwiICA6IHsgdHlwZTogXCJ2M1wiLCB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDEsIDEgKSB9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XSApLFxyXG5cclxuXHRcdGZyYWdtZW50U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyB1QW1iaWVudENvbG9yO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyB1RGlmZnVzZUNvbG9yO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyB1U3BlY3VsYXJDb2xvcjtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHVTaGluaW5lc3M7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCB1T3BhY2l0eTtcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSBib29sIGVuYWJsZURpZmZ1c2U7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBib29sIGVuYWJsZVNwZWN1bGFyO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gYm9vbCBlbmFibGVBTztcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGJvb2wgZW5hYmxlUmVmbGVjdGlvbjtcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgdERpZmZ1c2U7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgdE5vcm1hbDtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCB0U3BlY3VsYXI7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgdEFPO1wiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXJDdWJlIHRDdWJlO1wiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzIgdU5vcm1hbFNjYWxlO1wiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIGJvb2wgdXNlUmVmcmFjdDtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHVSZWZyYWN0aW9uUmF0aW87XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCB1UmVmbGVjdGl2aXR5O1wiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdlRhbmdlbnQ7XCIsXHJcblx0XHRcdFwidmFyeWluZyB2ZWMzIHZCaW5vcm1hbDtcIixcclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcIixcclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzIgdlV2O1wiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgYW1iaWVudExpZ2h0Q29sb3I7XCIsXHJcblxyXG5cdFx0XHRcIiNpZiBNQVhfRElSX0xJR0hUUyA+IDBcIixcclxuXHJcblx0XHRcdFx0XCJ1bmlmb3JtIHZlYzMgZGlyZWN0aW9uYWxMaWdodENvbG9yWyBNQVhfRElSX0xJR0hUUyBdO1wiLFxyXG5cdFx0XHRcdFwidW5pZm9ybSB2ZWMzIGRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25bIE1BWF9ESVJfTElHSFRTIF07XCIsXHJcblxyXG5cdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XCIjaWYgTUFYX0hFTUlfTElHSFRTID4gMFwiLFxyXG5cclxuXHRcdFx0XHRcInVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHRTa3lDb2xvclsgTUFYX0hFTUlfTElHSFRTIF07XCIsXHJcblx0XHRcdFx0XCJ1bmlmb3JtIHZlYzMgaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3JbIE1BWF9IRU1JX0xJR0hUUyBdO1wiLFxyXG5cdFx0XHRcdFwidW5pZm9ybSB2ZWMzIGhlbWlzcGhlcmVMaWdodERpcmVjdGlvblsgTUFYX0hFTUlfTElHSFRTIF07XCIsXHJcblxyXG5cdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XCIjaWYgTUFYX1BPSU5UX0xJR0hUUyA+IDBcIixcclxuXHJcblx0XHRcdFx0XCJ1bmlmb3JtIHZlYzMgcG9pbnRMaWdodENvbG9yWyBNQVhfUE9JTlRfTElHSFRTIF07XCIsXHJcblx0XHRcdFx0XCJ1bmlmb3JtIHZlYzMgcG9pbnRMaWdodFBvc2l0aW9uWyBNQVhfUE9JTlRfTElHSFRTIF07XCIsXHJcblx0XHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHBvaW50TGlnaHREaXN0YW5jZVsgTUFYX1BPSU5UX0xJR0hUUyBdO1wiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFwiI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDBcIixcclxuXHJcblx0XHRcdFx0XCJ1bmlmb3JtIHZlYzMgc3BvdExpZ2h0Q29sb3JbIE1BWF9TUE9UX0xJR0hUUyBdO1wiLFxyXG5cdFx0XHRcdFwidW5pZm9ybSB2ZWMzIHNwb3RMaWdodFBvc2l0aW9uWyBNQVhfU1BPVF9MSUdIVFMgXTtcIixcclxuXHRcdFx0XHRcInVuaWZvcm0gdmVjMyBzcG90TGlnaHREaXJlY3Rpb25bIE1BWF9TUE9UX0xJR0hUUyBdO1wiLFxyXG5cdFx0XHRcdFwidW5pZm9ybSBmbG9hdCBzcG90TGlnaHRBbmdsZUNvc1sgTUFYX1NQT1RfTElHSFRTIF07XCIsXHJcblx0XHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHNwb3RMaWdodEV4cG9uZW50WyBNQVhfU1BPVF9MSUdIVFMgXTtcIixcclxuXHRcdFx0XHRcInVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0RGlzdGFuY2VbIE1BWF9TUE9UX0xJR0hUUyBdO1wiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFwiI2lmZGVmIFdSQVBfQVJPVU5EXCIsXHJcblxyXG5cdFx0XHRcdFwidW5pZm9ybSB2ZWMzIHdyYXBSR0I7XCIsXHJcblxyXG5cdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XCIsXHJcblx0XHRcdFwidmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XCIsXHJcblxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IHZlYzQoIHZlYzMoIDEuMCApLCB1T3BhY2l0eSApO1wiLFxyXG5cclxuXHRcdFx0XHRcInZlYzMgc3BlY3VsYXJUZXggPSB2ZWMzKCAxLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWMzIG5vcm1hbFRleCA9IHRleHR1cmUyRCggdE5vcm1hbCwgdlV2ICkueHl6ICogMi4wIC0gMS4wO1wiLFxyXG5cdFx0XHRcdFwibm9ybWFsVGV4Lnh5ICo9IHVOb3JtYWxTY2FsZTtcIixcclxuXHRcdFx0XHRcIm5vcm1hbFRleCA9IG5vcm1hbGl6ZSggbm9ybWFsVGV4ICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiaWYoIGVuYWJsZURpZmZ1c2UgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCIjaWZkZWYgR0FNTUFfSU5QVVRcIixcclxuXHJcblx0XHRcdFx0XHRcdFwidmVjNCB0ZXhlbENvbG9yID0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgdlV2ICk7XCIsXHJcblx0XHRcdFx0XHRcdFwidGV4ZWxDb2xvci54eXogKj0gdGV4ZWxDb2xvci54eXo7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IGdsX0ZyYWdDb2xvciAqIHRleGVsQ29sb3I7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCIjZWxzZVwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IgPSBnbF9GcmFnQ29sb3IgKiB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2VXYgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHRcIn1cIixcclxuXHJcblx0XHRcdFx0XCJpZiggZW5hYmxlQU8gKSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCIjaWZkZWYgR0FNTUFfSU5QVVRcIixcclxuXHJcblx0XHRcdFx0XHRcdFwidmVjNCBhb0NvbG9yID0gdGV4dHVyZTJEKCB0QU8sIHZVdiApO1wiLFxyXG5cdFx0XHRcdFx0XHRcImFvQ29sb3IueHl6ICo9IGFvQ29sb3IueHl6O1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IueHl6ID0gZ2xfRnJhZ0NvbG9yLnh5eiAqIGFvQ29sb3IueHl6O1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiI2Vsc2VcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yLnh5eiA9IGdsX0ZyYWdDb2xvci54eXogKiB0ZXh0dXJlMkQoIHRBTywgdlV2ICkueHl6O1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFx0XHRcImlmKCBlbmFibGVTcGVjdWxhciApXCIsXHJcblx0XHRcdFx0XHRcInNwZWN1bGFyVGV4ID0gdGV4dHVyZTJEKCB0U3BlY3VsYXIsIHZVdiApLnh5ejtcIixcclxuXHJcblx0XHRcdFx0XCJtYXQzIHRzYiA9IG1hdDMoIG5vcm1hbGl6ZSggdlRhbmdlbnQgKSwgbm9ybWFsaXplKCB2Qmlub3JtYWwgKSwgbm9ybWFsaXplKCB2Tm9ybWFsICkgKTtcIixcclxuXHRcdFx0XHRcInZlYzMgZmluYWxOb3JtYWwgPSB0c2IgKiBub3JtYWxUZXg7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2lmZGVmIEZMSVBfU0lERURcIixcclxuXHJcblx0XHRcdFx0XHRcImZpbmFsTm9ybWFsID0gLWZpbmFsTm9ybWFsO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHRcInZlYzMgbm9ybWFsID0gbm9ybWFsaXplKCBmaW5hbE5vcm1hbCApO1wiLFxyXG5cdFx0XHRcdFwidmVjMyB2aWV3UG9zaXRpb24gPSBub3JtYWxpemUoIHZWaWV3UG9zaXRpb24gKTtcIixcclxuXHJcblx0XHRcdFx0Ly8gcG9pbnQgbGlnaHRzXHJcblxyXG5cdFx0XHRcdFwiI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ2ZWMzIHBvaW50RGlmZnVzZSA9IHZlYzMoIDAuMCApO1wiLFxyXG5cdFx0XHRcdFx0XCJ2ZWMzIHBvaW50U3BlY3VsYXIgPSB2ZWMzKCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcImZvciAoIGludCBpID0gMDsgaSA8IE1BWF9QT0lOVF9MSUdIVFM7IGkgKysgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcInZlYzQgbFBvc2l0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIHBvaW50TGlnaHRQb3NpdGlvblsgaSBdLCAxLjAgKTtcIixcclxuXHRcdFx0XHRcdFx0XCJ2ZWMzIHBvaW50VmVjdG9yID0gbFBvc2l0aW9uLnh5eiArIHZWaWV3UG9zaXRpb24ueHl6O1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJmbG9hdCBwb2ludERpc3RhbmNlID0gMS4wO1wiLFxyXG5cdFx0XHRcdFx0XHRcImlmICggcG9pbnRMaWdodERpc3RhbmNlWyBpIF0gPiAwLjAgKVwiLFxyXG5cdFx0XHRcdFx0XHRcdFwicG9pbnREaXN0YW5jZSA9IDEuMCAtIG1pbiggKCBsZW5ndGgoIHBvaW50VmVjdG9yICkgLyBwb2ludExpZ2h0RGlzdGFuY2VbIGkgXSApLCAxLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwicG9pbnRWZWN0b3IgPSBub3JtYWxpemUoIHBvaW50VmVjdG9yICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHQvLyBkaWZmdXNlXHJcblxyXG5cdFx0XHRcdFx0XHRcIiNpZmRlZiBXUkFQX0FST1VORFwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcImZsb2F0IHBvaW50RGlmZnVzZVdlaWdodEZ1bGwgPSBtYXgoIGRvdCggbm9ybWFsLCBwb2ludFZlY3RvciApLCAwLjAgKTtcIixcclxuXHRcdFx0XHRcdFx0XHRcImZsb2F0IHBvaW50RGlmZnVzZVdlaWdodEhhbGYgPSBtYXgoIDAuNSAqIGRvdCggbm9ybWFsLCBwb2ludFZlY3RvciApICsgMC41LCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XCJ2ZWMzIHBvaW50RGlmZnVzZVdlaWdodCA9IG1peCggdmVjMyAoIHBvaW50RGlmZnVzZVdlaWdodEZ1bGwgKSwgdmVjMyggcG9pbnREaWZmdXNlV2VpZ2h0SGFsZiApLCB3cmFwUkdCICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdFwiZmxvYXQgcG9pbnREaWZmdXNlV2VpZ2h0ID0gbWF4KCBkb3QoIG5vcm1hbCwgcG9pbnRWZWN0b3IgKSwgMC4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJwb2ludERpZmZ1c2UgKz0gcG9pbnREaXN0YW5jZSAqIHBvaW50TGlnaHRDb2xvclsgaSBdICogdURpZmZ1c2VDb2xvciAqIHBvaW50RGlmZnVzZVdlaWdodDtcIixcclxuXHJcblx0XHRcdFx0XHRcdC8vIHNwZWN1bGFyXHJcblxyXG5cdFx0XHRcdFx0XHRcInZlYzMgcG9pbnRIYWxmVmVjdG9yID0gbm9ybWFsaXplKCBwb2ludFZlY3RvciArIHZpZXdQb3NpdGlvbiApO1wiLFxyXG5cdFx0XHRcdFx0XHRcImZsb2F0IHBvaW50RG90Tm9ybWFsSGFsZiA9IG1heCggZG90KCBub3JtYWwsIHBvaW50SGFsZlZlY3RvciApLCAwLjAgKTtcIixcclxuXHRcdFx0XHRcdFx0XCJmbG9hdCBwb2ludFNwZWN1bGFyV2VpZ2h0ID0gc3BlY3VsYXJUZXguciAqIG1heCggcG93KCBwb2ludERvdE5vcm1hbEhhbGYsIHVTaGluaW5lc3MgKSwgMC4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcIiNpZmRlZiBQSFlTSUNBTExZX0JBU0VEX1NIQURJTkdcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gMi4wID0+IDIuMDAwMSBpcyBoYWNrIHRvIHdvcmsgYXJvdW5kIEFOR0xFIGJ1Z1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcImZsb2F0IHNwZWN1bGFyTm9ybWFsaXphdGlvbiA9ICggdVNoaW5pbmVzcyArIDIuMDAwMSApIC8gOC4wO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcInZlYzMgc2NobGljayA9IHVTcGVjdWxhckNvbG9yICsgdmVjMyggMS4wIC0gdVNwZWN1bGFyQ29sb3IgKSAqIHBvdyggMS4wIC0gZG90KCBwb2ludFZlY3RvciwgcG9pbnRIYWxmVmVjdG9yICksIDUuMCApO1wiLFxyXG5cdFx0XHRcdFx0XHRcdFwicG9pbnRTcGVjdWxhciArPSBzY2hsaWNrICogcG9pbnRMaWdodENvbG9yWyBpIF0gKiBwb2ludFNwZWN1bGFyV2VpZ2h0ICogcG9pbnREaWZmdXNlV2VpZ2h0ICogcG9pbnREaXN0YW5jZSAqIHNwZWN1bGFyTm9ybWFsaXphdGlvbjtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiI2Vsc2VcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XCJwb2ludFNwZWN1bGFyICs9IHBvaW50RGlzdGFuY2UgKiBwb2ludExpZ2h0Q29sb3JbIGkgXSAqIHVTcGVjdWxhckNvbG9yICogcG9pbnRTcGVjdWxhcldlaWdodCAqIHBvaW50RGlmZnVzZVdlaWdodDtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdC8vIHNwb3QgbGlnaHRzXHJcblxyXG5cdFx0XHRcdFwiI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDBcIixcclxuXHJcblx0XHRcdFx0XHRcInZlYzMgc3BvdERpZmZ1c2UgPSB2ZWMzKCAwLjAgKTtcIixcclxuXHRcdFx0XHRcdFwidmVjMyBzcG90U3BlY3VsYXIgPSB2ZWMzKCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcImZvciAoIGludCBpID0gMDsgaSA8IE1BWF9TUE9UX0xJR0hUUzsgaSArKyApIHtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwidmVjNCBsUG9zaXRpb24gPSB2aWV3TWF0cml4ICogdmVjNCggc3BvdExpZ2h0UG9zaXRpb25bIGkgXSwgMS4wICk7XCIsXHJcblx0XHRcdFx0XHRcdFwidmVjMyBzcG90VmVjdG9yID0gbFBvc2l0aW9uLnh5eiArIHZWaWV3UG9zaXRpb24ueHl6O1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJmbG9hdCBzcG90RGlzdGFuY2UgPSAxLjA7XCIsXHJcblx0XHRcdFx0XHRcdFwiaWYgKCBzcG90TGlnaHREaXN0YW5jZVsgaSBdID4gMC4wIClcIixcclxuXHRcdFx0XHRcdFx0XHRcInNwb3REaXN0YW5jZSA9IDEuMCAtIG1pbiggKCBsZW5ndGgoIHNwb3RWZWN0b3IgKSAvIHNwb3RMaWdodERpc3RhbmNlWyBpIF0gKSwgMS4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcInNwb3RWZWN0b3IgPSBub3JtYWxpemUoIHNwb3RWZWN0b3IgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiZmxvYXQgc3BvdEVmZmVjdCA9IGRvdCggc3BvdExpZ2h0RGlyZWN0aW9uWyBpIF0sIG5vcm1hbGl6ZSggc3BvdExpZ2h0UG9zaXRpb25bIGkgXSAtIHZXb3JsZFBvc2l0aW9uICkgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiaWYgKCBzcG90RWZmZWN0ID4gc3BvdExpZ2h0QW5nbGVDb3NbIGkgXSApIHtcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XCJzcG90RWZmZWN0ID0gbWF4KCBwb3coIHNwb3RFZmZlY3QsIHNwb3RMaWdodEV4cG9uZW50WyBpIF0gKSwgMC4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIGRpZmZ1c2VcclxuXHJcblx0XHRcdFx0XHRcdFx0XCIjaWZkZWYgV1JBUF9BUk9VTkRcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcImZsb2F0IHNwb3REaWZmdXNlV2VpZ2h0RnVsbCA9IG1heCggZG90KCBub3JtYWwsIHNwb3RWZWN0b3IgKSwgMC4wICk7XCIsXHJcblx0XHRcdFx0XHRcdFx0XHRcImZsb2F0IHNwb3REaWZmdXNlV2VpZ2h0SGFsZiA9IG1heCggMC41ICogZG90KCBub3JtYWwsIHNwb3RWZWN0b3IgKSArIDAuNSwgMC4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XCJ2ZWMzIHNwb3REaWZmdXNlV2VpZ2h0ID0gbWl4KCB2ZWMzICggc3BvdERpZmZ1c2VXZWlnaHRGdWxsICksIHZlYzMoIHNwb3REaWZmdXNlV2VpZ2h0SGFsZiApLCB3cmFwUkdCICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdFwiI2Vsc2VcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcImZsb2F0IHNwb3REaWZmdXNlV2VpZ2h0ID0gbWF4KCBkb3QoIG5vcm1hbCwgc3BvdFZlY3RvciApLCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XCJzcG90RGlmZnVzZSArPSBzcG90RGlzdGFuY2UgKiBzcG90TGlnaHRDb2xvclsgaSBdICogdURpZmZ1c2VDb2xvciAqIHNwb3REaWZmdXNlV2VpZ2h0ICogc3BvdEVmZmVjdDtcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gc3BlY3VsYXJcclxuXHJcblx0XHRcdFx0XHRcdFx0XCJ2ZWMzIHNwb3RIYWxmVmVjdG9yID0gbm9ybWFsaXplKCBzcG90VmVjdG9yICsgdmlld1Bvc2l0aW9uICk7XCIsXHJcblx0XHRcdFx0XHRcdFx0XCJmbG9hdCBzcG90RG90Tm9ybWFsSGFsZiA9IG1heCggZG90KCBub3JtYWwsIHNwb3RIYWxmVmVjdG9yICksIDAuMCApO1wiLFxyXG5cdFx0XHRcdFx0XHRcdFwiZmxvYXQgc3BvdFNwZWN1bGFyV2VpZ2h0ID0gc3BlY3VsYXJUZXguciAqIG1heCggcG93KCBzcG90RG90Tm9ybWFsSGFsZiwgdVNoaW5pbmVzcyApLCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XCIjaWZkZWYgUEhZU0lDQUxMWV9CQVNFRF9TSEFESU5HXCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gMi4wID0+IDIuMDAwMSBpcyBoYWNrIHRvIHdvcmsgYXJvdW5kIEFOR0xFIGJ1Z1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFwiZmxvYXQgc3BlY3VsYXJOb3JtYWxpemF0aW9uID0gKCB1U2hpbmluZXNzICsgMi4wMDAxICkgLyA4LjA7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XCJ2ZWMzIHNjaGxpY2sgPSB1U3BlY3VsYXJDb2xvciArIHZlYzMoIDEuMCAtIHVTcGVjdWxhckNvbG9yICkgKiBwb3coIDEuMCAtIGRvdCggc3BvdFZlY3Rvciwgc3BvdEhhbGZWZWN0b3IgKSwgNS4wICk7XCIsXHJcblx0XHRcdFx0XHRcdFx0XHRcInNwb3RTcGVjdWxhciArPSBzY2hsaWNrICogc3BvdExpZ2h0Q29sb3JbIGkgXSAqIHNwb3RTcGVjdWxhcldlaWdodCAqIHNwb3REaWZmdXNlV2VpZ2h0ICogc3BvdERpc3RhbmNlICogc3BlY3VsYXJOb3JtYWxpemF0aW9uICogc3BvdEVmZmVjdDtcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XCIjZWxzZVwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFwic3BvdFNwZWN1bGFyICs9IHNwb3REaXN0YW5jZSAqIHNwb3RMaWdodENvbG9yWyBpIF0gKiB1U3BlY3VsYXJDb2xvciAqIHNwb3RTcGVjdWxhcldlaWdodCAqIHNwb3REaWZmdXNlV2VpZ2h0ICogc3BvdEVmZmVjdDtcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHQvLyBkaXJlY3Rpb25hbCBsaWdodHNcclxuXHJcblx0XHRcdFx0XCIjaWYgTUFYX0RJUl9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ2ZWMzIGRpckRpZmZ1c2UgPSB2ZWMzKCAwLjAgKTtcIixcclxuXHRcdFx0XHRcdFwidmVjMyBkaXJTcGVjdWxhciA9IHZlYzMoIDAuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiZm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfRElSX0xJR0hUUzsgaSsrICkge1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJ2ZWM0IGxEaXJlY3Rpb24gPSB2aWV3TWF0cml4ICogdmVjNCggZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvblsgaSBdLCAwLjAgKTtcIixcclxuXHRcdFx0XHRcdFx0XCJ2ZWMzIGRpclZlY3RvciA9IG5vcm1hbGl6ZSggbERpcmVjdGlvbi54eXogKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdC8vIGRpZmZ1c2VcclxuXHJcblx0XHRcdFx0XHRcdFwiI2lmZGVmIFdSQVBfQVJPVU5EXCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdFwiZmxvYXQgZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZ0Z1bGwgPSBtYXgoIGRvdCggbm9ybWFsLCBkaXJWZWN0b3IgKSwgMC4wICk7XCIsXHJcblx0XHRcdFx0XHRcdFx0XCJmbG9hdCBkaXJlY3Rpb25hbExpZ2h0V2VpZ2h0aW5nSGFsZiA9IG1heCggMC41ICogZG90KCBub3JtYWwsIGRpclZlY3RvciApICsgMC41LCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XCJ2ZWMzIGRpckRpZmZ1c2VXZWlnaHQgPSBtaXgoIHZlYzMoIGRpcmVjdGlvbmFsTGlnaHRXZWlnaHRpbmdGdWxsICksIHZlYzMoIGRpcmVjdGlvbmFsTGlnaHRXZWlnaHRpbmdIYWxmICksIHdyYXBSR0IgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiI2Vsc2VcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XCJmbG9hdCBkaXJEaWZmdXNlV2VpZ2h0ID0gbWF4KCBkb3QoIG5vcm1hbCwgZGlyVmVjdG9yICksIDAuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiZGlyRGlmZnVzZSArPSBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIGkgXSAqIHVEaWZmdXNlQ29sb3IgKiBkaXJEaWZmdXNlV2VpZ2h0O1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0Ly8gc3BlY3VsYXJcclxuXHJcblx0XHRcdFx0XHRcdFwidmVjMyBkaXJIYWxmVmVjdG9yID0gbm9ybWFsaXplKCBkaXJWZWN0b3IgKyB2aWV3UG9zaXRpb24gKTtcIixcclxuXHRcdFx0XHRcdFx0XCJmbG9hdCBkaXJEb3ROb3JtYWxIYWxmID0gbWF4KCBkb3QoIG5vcm1hbCwgZGlySGFsZlZlY3RvciApLCAwLjAgKTtcIixcclxuXHRcdFx0XHRcdFx0XCJmbG9hdCBkaXJTcGVjdWxhcldlaWdodCA9IHNwZWN1bGFyVGV4LnIgKiBtYXgoIHBvdyggZGlyRG90Tm9ybWFsSGFsZiwgdVNoaW5pbmVzcyApLCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiI2lmZGVmIFBIWVNJQ0FMTFlfQkFTRURfU0hBRElOR1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHQvLyAyLjAgPT4gMi4wMDAxIGlzIGhhY2sgdG8gd29yayBhcm91bmQgQU5HTEUgYnVnXHJcblxyXG5cdFx0XHRcdFx0XHRcdFwiZmxvYXQgc3BlY3VsYXJOb3JtYWxpemF0aW9uID0gKCB1U2hpbmluZXNzICsgMi4wMDAxICkgLyA4LjA7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdFwidmVjMyBzY2hsaWNrID0gdVNwZWN1bGFyQ29sb3IgKyB2ZWMzKCAxLjAgLSB1U3BlY3VsYXJDb2xvciApICogcG93KCAxLjAgLSBkb3QoIGRpclZlY3RvciwgZGlySGFsZlZlY3RvciApLCA1LjAgKTtcIixcclxuXHRcdFx0XHRcdFx0XHRcImRpclNwZWN1bGFyICs9IHNjaGxpY2sgKiBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIGkgXSAqIGRpclNwZWN1bGFyV2VpZ2h0ICogZGlyRGlmZnVzZVdlaWdodCAqIHNwZWN1bGFyTm9ybWFsaXphdGlvbjtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiI2Vsc2VcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XCJkaXJTcGVjdWxhciArPSBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIGkgXSAqIHVTcGVjdWxhckNvbG9yICogZGlyU3BlY3VsYXJXZWlnaHQgKiBkaXJEaWZmdXNlV2VpZ2h0O1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0XHRcIn1cIixcclxuXHJcblx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0Ly8gaGVtaXNwaGVyZSBsaWdodHNcclxuXHJcblx0XHRcdFx0XCIjaWYgTUFYX0hFTUlfTElHSFRTID4gMFwiLFxyXG5cclxuXHRcdFx0XHRcdFwidmVjMyBoZW1pRGlmZnVzZSAgPSB2ZWMzKCAwLjAgKTtcIixcclxuXHRcdFx0XHRcdFwidmVjMyBoZW1pU3BlY3VsYXIgPSB2ZWMzKCAwLjAgKTtcIiAsXHJcblxyXG5cdFx0XHRcdFx0XCJmb3IoIGludCBpID0gMDsgaSA8IE1BWF9IRU1JX0xJR0hUUzsgaSArKyApIHtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwidmVjNCBsRGlyZWN0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIGhlbWlzcGhlcmVMaWdodERpcmVjdGlvblsgaSBdLCAwLjAgKTtcIixcclxuXHRcdFx0XHRcdFx0XCJ2ZWMzIGxWZWN0b3IgPSBub3JtYWxpemUoIGxEaXJlY3Rpb24ueHl6ICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHQvLyBkaWZmdXNlXHJcblxyXG5cdFx0XHRcdFx0XHRcImZsb2F0IGRvdFByb2R1Y3QgPSBkb3QoIG5vcm1hbCwgbFZlY3RvciApO1wiLFxyXG5cdFx0XHRcdFx0XHRcImZsb2F0IGhlbWlEaWZmdXNlV2VpZ2h0ID0gMC41ICogZG90UHJvZHVjdCArIDAuNTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwidmVjMyBoZW1pQ29sb3IgPSBtaXgoIGhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yWyBpIF0sIGhlbWlzcGhlcmVMaWdodFNreUNvbG9yWyBpIF0sIGhlbWlEaWZmdXNlV2VpZ2h0ICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImhlbWlEaWZmdXNlICs9IHVEaWZmdXNlQ29sb3IgKiBoZW1pQ29sb3I7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHQvLyBzcGVjdWxhciAoc2t5IGxpZ2h0KVxyXG5cclxuXHJcblx0XHRcdFx0XHRcdFwidmVjMyBoZW1pSGFsZlZlY3RvclNreSA9IG5vcm1hbGl6ZSggbFZlY3RvciArIHZpZXdQb3NpdGlvbiApO1wiLFxyXG5cdFx0XHRcdFx0XHRcImZsb2F0IGhlbWlEb3ROb3JtYWxIYWxmU2t5ID0gMC41ICogZG90KCBub3JtYWwsIGhlbWlIYWxmVmVjdG9yU2t5ICkgKyAwLjU7XCIsXHJcblx0XHRcdFx0XHRcdFwiZmxvYXQgaGVtaVNwZWN1bGFyV2VpZ2h0U2t5ID0gc3BlY3VsYXJUZXguciAqIG1heCggcG93KCBoZW1pRG90Tm9ybWFsSGFsZlNreSwgdVNoaW5pbmVzcyApLCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdC8vIHNwZWN1bGFyIChncm91bmQgbGlnaHQpXHJcblxyXG5cdFx0XHRcdFx0XHRcInZlYzMgbFZlY3Rvckdyb3VuZCA9IC1sVmVjdG9yO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJ2ZWMzIGhlbWlIYWxmVmVjdG9yR3JvdW5kID0gbm9ybWFsaXplKCBsVmVjdG9yR3JvdW5kICsgdmlld1Bvc2l0aW9uICk7XCIsXHJcblx0XHRcdFx0XHRcdFwiZmxvYXQgaGVtaURvdE5vcm1hbEhhbGZHcm91bmQgPSAwLjUgKiBkb3QoIG5vcm1hbCwgaGVtaUhhbGZWZWN0b3JHcm91bmQgKSArIDAuNTtcIixcclxuXHRcdFx0XHRcdFx0XCJmbG9hdCBoZW1pU3BlY3VsYXJXZWlnaHRHcm91bmQgPSBzcGVjdWxhclRleC5yICogbWF4KCBwb3coIGhlbWlEb3ROb3JtYWxIYWxmR3JvdW5kLCB1U2hpbmluZXNzICksIDAuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCIjaWZkZWYgUEhZU0lDQUxMWV9CQVNFRF9TSEFESU5HXCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdFwiZmxvYXQgZG90UHJvZHVjdEdyb3VuZCA9IGRvdCggbm9ybWFsLCBsVmVjdG9yR3JvdW5kICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIDIuMCA9PiAyLjAwMDEgaXMgaGFjayB0byB3b3JrIGFyb3VuZCBBTkdMRSBidWdcclxuXHJcblx0XHRcdFx0XHRcdFx0XCJmbG9hdCBzcGVjdWxhck5vcm1hbGl6YXRpb24gPSAoIHVTaGluaW5lc3MgKyAyLjAwMDEgKSAvIDguMDtcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XCJ2ZWMzIHNjaGxpY2tTa3kgPSB1U3BlY3VsYXJDb2xvciArIHZlYzMoIDEuMCAtIHVTcGVjdWxhckNvbG9yICkgKiBwb3coIDEuMCAtIGRvdCggbFZlY3RvciwgaGVtaUhhbGZWZWN0b3JTa3kgKSwgNS4wICk7XCIsXHJcblx0XHRcdFx0XHRcdFx0XCJ2ZWMzIHNjaGxpY2tHcm91bmQgPSB1U3BlY3VsYXJDb2xvciArIHZlYzMoIDEuMCAtIHVTcGVjdWxhckNvbG9yICkgKiBwb3coIDEuMCAtIGRvdCggbFZlY3Rvckdyb3VuZCwgaGVtaUhhbGZWZWN0b3JHcm91bmQgKSwgNS4wICk7XCIsXHJcblx0XHRcdFx0XHRcdFx0XCJoZW1pU3BlY3VsYXIgKz0gaGVtaUNvbG9yICogc3BlY3VsYXJOb3JtYWxpemF0aW9uICogKCBzY2hsaWNrU2t5ICogaGVtaVNwZWN1bGFyV2VpZ2h0U2t5ICogbWF4KCBkb3RQcm9kdWN0LCAwLjAgKSArIHNjaGxpY2tHcm91bmQgKiBoZW1pU3BlY3VsYXJXZWlnaHRHcm91bmQgKiBtYXgoIGRvdFByb2R1Y3RHcm91bmQsIDAuMCApICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdFwiaGVtaVNwZWN1bGFyICs9IHVTcGVjdWxhckNvbG9yICogaGVtaUNvbG9yICogKCBoZW1pU3BlY3VsYXJXZWlnaHRTa3kgKyBoZW1pU3BlY3VsYXJXZWlnaHRHcm91bmQgKSAqIGhlbWlEaWZmdXNlV2VpZ2h0O1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0XHRcIn1cIixcclxuXHJcblx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0Ly8gYWxsIGxpZ2h0cyBjb250cmlidXRpb24gc3VtbWF0aW9uXHJcblxyXG5cdFx0XHRcdFwidmVjMyB0b3RhbERpZmZ1c2UgPSB2ZWMzKCAwLjAgKTtcIixcclxuXHRcdFx0XHRcInZlYzMgdG90YWxTcGVjdWxhciA9IHZlYzMoIDAuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNpZiBNQVhfRElSX0xJR0hUUyA+IDBcIixcclxuXHJcblx0XHRcdFx0XHRcInRvdGFsRGlmZnVzZSArPSBkaXJEaWZmdXNlO1wiLFxyXG5cdFx0XHRcdFx0XCJ0b3RhbFNwZWN1bGFyICs9IGRpclNwZWN1bGFyO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHRcIiNpZiBNQVhfSEVNSV9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ0b3RhbERpZmZ1c2UgKz0gaGVtaURpZmZ1c2U7XCIsXHJcblx0XHRcdFx0XHRcInRvdGFsU3BlY3VsYXIgKz0gaGVtaVNwZWN1bGFyO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHRcIiNpZiBNQVhfUE9JTlRfTElHSFRTID4gMFwiLFxyXG5cclxuXHRcdFx0XHRcdFwidG90YWxEaWZmdXNlICs9IHBvaW50RGlmZnVzZTtcIixcclxuXHRcdFx0XHRcdFwidG90YWxTcGVjdWxhciArPSBwb2ludFNwZWN1bGFyO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHRcIiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ0b3RhbERpZmZ1c2UgKz0gc3BvdERpZmZ1c2U7XCIsXHJcblx0XHRcdFx0XHRcInRvdGFsU3BlY3VsYXIgKz0gc3BvdFNwZWN1bGFyO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHRcIiNpZmRlZiBNRVRBTFwiLFxyXG5cclxuXHRcdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yLnh5eiA9IGdsX0ZyYWdDb2xvci54eXogKiAoIHRvdGFsRGlmZnVzZSArIGFtYmllbnRMaWdodENvbG9yICogdUFtYmllbnRDb2xvciArIHRvdGFsU3BlY3VsYXIgKTtcIixcclxuXHJcblx0XHRcdFx0XCIjZWxzZVwiLFxyXG5cclxuXHRcdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yLnh5eiA9IGdsX0ZyYWdDb2xvci54eXogKiAoIHRvdGFsRGlmZnVzZSArIGFtYmllbnRMaWdodENvbG9yICogdUFtYmllbnRDb2xvciApICsgdG90YWxTcGVjdWxhcjtcIixcclxuXHJcblx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0XCJpZiAoIGVuYWJsZVJlZmxlY3Rpb24gKSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ2ZWMzIHZSZWZsZWN0O1wiLFxyXG5cdFx0XHRcdFx0XCJ2ZWMzIGNhbWVyYVRvVmVydGV4ID0gbm9ybWFsaXplKCB2V29ybGRQb3NpdGlvbiAtIGNhbWVyYVBvc2l0aW9uICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJpZiAoIHVzZVJlZnJhY3QgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcInZSZWZsZWN0ID0gcmVmcmFjdCggY2FtZXJhVG9WZXJ0ZXgsIG5vcm1hbCwgdVJlZnJhY3Rpb25SYXRpbyApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwifSBlbHNlIHtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwidlJlZmxlY3QgPSByZWZsZWN0KCBjYW1lcmFUb1ZlcnRleCwgbm9ybWFsICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ2ZWM0IGN1YmVDb2xvciA9IHRleHR1cmVDdWJlKCB0Q3ViZSwgdmVjMyggLXZSZWZsZWN0LngsIHZSZWZsZWN0Lnl6ICkgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcIiNpZmRlZiBHQU1NQV9JTlBVVFwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJjdWJlQ29sb3IueHl6ICo9IGN1YmVDb2xvci54eXo7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0XHRcImdsX0ZyYWdDb2xvci54eXogPSBtaXgoIGdsX0ZyYWdDb2xvci54eXosIGN1YmVDb2xvci54eXosIHNwZWN1bGFyVGV4LnIgKiB1UmVmbGVjdGl2aXR5ICk7XCIsXHJcblxyXG5cdFx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpbmVhcl90b19nYW1tYV9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRcdHZlcnRleFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCJhdHRyaWJ1dGUgdmVjNCB0YW5nZW50O1wiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzIgdU9mZnNldDtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzIgdVJlcGVhdDtcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSBib29sIGVuYWJsZURpc3BsYWNlbWVudDtcIixcclxuXHJcblx0XHRcdFwiI2lmZGVmIFZFUlRFWF9URVhUVVJFU1wiLFxyXG5cclxuXHRcdFx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIHREaXNwbGFjZW1lbnQ7XCIsXHJcblx0XHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHVEaXNwbGFjZW1lbnRTY2FsZTtcIixcclxuXHRcdFx0XHRcInVuaWZvcm0gZmxvYXQgdURpc3BsYWNlbWVudEJpYXM7XCIsXHJcblxyXG5cdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdlRhbmdlbnQ7XCIsXHJcblx0XHRcdFwidmFyeWluZyB2ZWMzIHZCaW5vcm1hbDtcIixcclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcIixcclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzIgdlV2O1wiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XCIsXHJcblx0XHRcdFwidmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XCIsXHJcblxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ19wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbmJhc2VfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubm9ybWFsX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcdC8vIG5vcm1hbCwgdGFuZ2VudCBhbmQgYmlub3JtYWwgdmVjdG9yc1xyXG5cclxuXHRcdFx0XHRcIiNpZmRlZiBVU0VfU0tJTk5JTkdcIixcclxuXHJcblx0XHRcdFx0XHRcInZOb3JtYWwgPSBub3JtYWxpemUoIG5vcm1hbE1hdHJpeCAqIHNraW5uZWROb3JtYWwueHl6ICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ2ZWM0IHNraW5uZWRUYW5nZW50ID0gc2tpbk1hdHJpeCAqIHZlYzQoIHRhbmdlbnQueHl6LCAwLjAgKTtcIixcclxuXHRcdFx0XHRcdFwidlRhbmdlbnQgPSBub3JtYWxpemUoIG5vcm1hbE1hdHJpeCAqIHNraW5uZWRUYW5nZW50Lnh5eiApO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ2Tm9ybWFsID0gbm9ybWFsaXplKCBub3JtYWxNYXRyaXggKiBub3JtYWwgKTtcIixcclxuXHRcdFx0XHRcdFwidlRhbmdlbnQgPSBub3JtYWxpemUoIG5vcm1hbE1hdHJpeCAqIHRhbmdlbnQueHl6ICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFwidkJpbm9ybWFsID0gbm9ybWFsaXplKCBjcm9zcyggdk5vcm1hbCwgdlRhbmdlbnQgKSAqIHRhbmdlbnQudyApO1wiLFxyXG5cclxuXHRcdFx0XHRcInZVdiA9IHV2ICogdVJlcGVhdCArIHVPZmZzZXQ7XCIsXHJcblxyXG5cdFx0XHRcdC8vIGRpc3BsYWNlbWVudCBtYXBwaW5nXHJcblxyXG5cdFx0XHRcdFwidmVjMyBkaXNwbGFjZWRQb3NpdGlvbjtcIixcclxuXHJcblx0XHRcdFx0XCIjaWZkZWYgVkVSVEVYX1RFWFRVUkVTXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJpZiAoIGVuYWJsZURpc3BsYWNlbWVudCApIHtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwidmVjMyBkdiA9IHRleHR1cmUyRCggdERpc3BsYWNlbWVudCwgdXYgKS54eXo7XCIsXHJcblx0XHRcdFx0XHRcdFwiZmxvYXQgZGYgPSB1RGlzcGxhY2VtZW50U2NhbGUgKiBkdi54ICsgdURpc3BsYWNlbWVudEJpYXM7XCIsXHJcblx0XHRcdFx0XHRcdFwiZGlzcGxhY2VkUG9zaXRpb24gPSBwb3NpdGlvbiArIG5vcm1hbGl6ZSggbm9ybWFsICkgKiBkZjtcIixcclxuXHJcblx0XHRcdFx0XHRcIn0gZWxzZSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcIiNpZmRlZiBVU0VfU0tJTk5JTkdcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XCJ2ZWM0IHNraW5WZXJ0ZXggPSB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdFwidmVjNCBza2lubmVkICA9IGJvbmVNYXRYICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueDtcIixcclxuXHRcdFx0XHRcdFx0XHRcInNraW5uZWQgXHQgICs9IGJvbmVNYXRZICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XCJkaXNwbGFjZWRQb3NpdGlvbiAgPSBza2lubmVkLnh5ejtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiI2Vsc2VcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XCJkaXNwbGFjZWRQb3NpdGlvbiA9IHBvc2l0aW9uO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0XHRcIn1cIixcclxuXHJcblx0XHRcdFx0XCIjZWxzZVwiLFxyXG5cclxuXHRcdFx0XHRcdFwiI2lmZGVmIFVTRV9TS0lOTklOR1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJ2ZWM0IHNraW5WZXJ0ZXggPSB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcInZlYzQgc2tpbm5lZCAgPSBib25lTWF0WCAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lng7XCIsXHJcblx0XHRcdFx0XHRcdFwic2tpbm5lZCBcdCAgKz0gYm9uZU1hdFkgKiBza2luVmVydGV4ICogc2tpbldlaWdodC55O1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJkaXNwbGFjZWRQb3NpdGlvbiAgPSBza2lubmVkLnh5ejtcIixcclxuXHJcblx0XHRcdFx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImRpc3BsYWNlZFBvc2l0aW9uID0gcG9zaXRpb247XCIsXHJcblxyXG5cdFx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0Ly9cclxuXHJcblx0XHRcdFx0XCJ2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBkaXNwbGFjZWRQb3NpdGlvbiwgMS4wICk7XCIsXHJcblx0XHRcdFx0XCJ2ZWM0IHdvcmxkUG9zaXRpb24gPSBtb2RlbE1hdHJpeCAqIHZlYzQoIGRpc3BsYWNlZFBvc2l0aW9uLCAxLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XCJnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uO1wiLFxyXG5cclxuXHRcdFx0XHQvL1xyXG5cclxuXHRcdFx0XHRcInZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbi54eXo7XCIsXHJcblx0XHRcdFx0XCJ2Vmlld1Bvc2l0aW9uID0gLW12UG9zaXRpb24ueHl6O1wiLFxyXG5cclxuXHRcdFx0XHQvLyBzaGFkb3dzXHJcblxyXG5cdFx0XHRcdFwiI2lmZGVmIFVTRV9TSEFET1dNQVBcIixcclxuXHJcblx0XHRcdFx0XHRcImZvciggaW50IGkgPSAwOyBpIDwgTUFYX1NIQURPV1M7IGkgKysgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcInZTaGFkb3dDb29yZFsgaSBdID0gc2hhZG93TWF0cml4WyBpIF0gKiB3b3JsZFBvc2l0aW9uO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oXCJcXG5cIilcclxuXHJcblx0fSxcclxuXHJcblx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cdC8vXHRDdWJlIG1hcCBzaGFkZXJcclxuXHQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG5cclxuXHQnY3ViZSc6IHtcclxuXHJcblx0XHR1bmlmb3JtczogeyBcInRDdWJlXCI6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXHJcblx0XHRcdFx0XHRcInRGbGlwXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAtMSB9IH0sXHJcblxyXG5cdFx0dmVydGV4U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcIixcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XHRcInZlYzQgd29ybGRQb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxyXG5cdFx0XHRcdFwidldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uLnh5ejtcIixcclxuXHJcblx0XHRcdFx0XCJnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXHJcblxyXG5cdFx0XHRcIn1cIlxyXG5cclxuXHRcdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0XHRmcmFnbWVudFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXJDdWJlIHRDdWJlO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgdEZsaXA7XCIsXHJcblxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcIixcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IHRleHR1cmVDdWJlKCB0Q3ViZSwgdmVjMyggdEZsaXAgKiB2V29ybGRQb3NpdGlvbi54LCB2V29ybGRQb3NpdGlvbi55eiApICk7XCIsXHJcblxyXG5cdFx0XHRcIn1cIlxyXG5cclxuXHRcdF0uam9pbihcIlxcblwiKVxyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBEZXB0aCBlbmNvZGluZyBpbnRvIFJHQkEgdGV4dHVyZVxyXG5cdC8vIFx0YmFzZWQgb24gU3BpZGVyR0wgc2hhZG93IG1hcCBleGFtcGxlXHJcblx0Ly8gXHRcdGh0dHA6Ly9zcGlkZXJnbC5vcmcvZXhhbXBsZS5waHA/aWQ9NlxyXG5cdC8vIFx0b3JpZ2luYWxseSBmcm9tXHJcblx0Ly9cdFx0aHR0cDovL3d3dy5nYW1lZGV2Lm5ldC90b3BpYy80NDIxMzgtcGFja2luZy1hLWZsb2F0LWludG8tYS1hOHI4ZzhiOC10ZXh0dXJlLXNoYWRlci9wYWdlX193aGljaHBhZ2VfXzElMjVFRiUyNUJGJTI1QkRcclxuXHQvLyBcdHNlZSBhbHNvIGhlcmU6XHJcblx0Ly9cdFx0aHR0cDovL2FyYXMtcC5pbmZvL2Jsb2cvMjAwOS8wNy8zMC9lbmNvZGluZy1mbG9hdHMtdG8tcmdiYS10aGUtZmluYWwvXHJcblxyXG5cdCdkZXB0aFJHQkEnOiB7XHJcblxyXG5cdFx0dW5pZm9ybXM6IHt9LFxyXG5cclxuXHRcdHZlcnRleFNoYWRlcjogW1xyXG5cclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ19wYXJzX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbmJhc2VfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGVmYXVsdF92ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwidmVjNCBwYWNrX2RlcHRoKCBjb25zdCBpbiBmbG9hdCBkZXB0aCApIHtcIixcclxuXHJcblx0XHRcdFx0XCJjb25zdCB2ZWM0IGJpdF9zaGlmdCA9IHZlYzQoIDI1Ni4wICogMjU2LjAgKiAyNTYuMCwgMjU2LjAgKiAyNTYuMCwgMjU2LjAsIDEuMCApO1wiLFxyXG5cdFx0XHRcdFwiY29uc3QgdmVjNCBiaXRfbWFzayAgPSB2ZWM0KCAwLjAsIDEuMCAvIDI1Ni4wLCAxLjAgLyAyNTYuMCwgMS4wIC8gMjU2LjAgKTtcIixcclxuXHRcdFx0XHRcInZlYzQgcmVzID0gZnJhY3QoIGRlcHRoICogYml0X3NoaWZ0ICk7XCIsXHJcblx0XHRcdFx0XCJyZXMgLT0gcmVzLnh4eXogKiBiaXRfbWFzaztcIixcclxuXHRcdFx0XHRcInJldHVybiByZXM7XCIsXHJcblxyXG5cdFx0XHRcIn1cIixcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XHRcImdsX0ZyYWdEYXRhWyAwIF0gPSBwYWNrX2RlcHRoKCBnbF9GcmFnQ29vcmQueiApO1wiLFxyXG5cclxuXHRcdFx0XHQvL1wiZ2xfRnJhZ0RhdGFbIDAgXSA9IHBhY2tfZGVwdGgoIGdsX0ZyYWdDb29yZC56IC8gZ2xfRnJhZ0Nvb3JkLncgKTtcIixcclxuXHRcdFx0XHQvL1wiZmxvYXQgeiA9ICggKCBnbF9GcmFnQ29vcmQueiAvIGdsX0ZyYWdDb29yZC53ICkgLSAzLjAgKSAvICggNDAwMC4wIC0gMy4wICk7XCIsXHJcblx0XHRcdFx0Ly9cImdsX0ZyYWdEYXRhWyAwIF0gPSBwYWNrX2RlcHRoKCB6ICk7XCIsXHJcblx0XHRcdFx0Ly9cImdsX0ZyYWdEYXRhWyAwIF0gPSB2ZWM0KCB6LCB6LCB6LCAxLjAgKTtcIixcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKFwiXFxuXCIpXHJcblxyXG5cdH1cclxuXHJcbn07XHJcbi8qKlxyXG4gKiBAYXV0aG9yIHN1cGVyZWdnYmVydCAvIGh0dHA6Ly93d3cucGF1bGJydW50LmNvLnVrL1xyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIHN6aW1layAvIGh0dHBzOi8vZ2l0aHViLmNvbS9zemltZWsvXHJcbiAqL1xyXG5cclxuVEhSRUUuV2ViR0xSZW5kZXJlciA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcclxuXHJcblx0Y29uc29sZS5sb2coICdUSFJFRS5XZWJHTFJlbmRlcmVyJywgVEhSRUUuUkVWSVNJT04gKTtcclxuXHJcblx0cGFyYW1ldGVycyA9IHBhcmFtZXRlcnMgfHwge307XHJcblxyXG5cdHZhciBfY2FudmFzID0gcGFyYW1ldGVycy5jYW52YXMgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuY2FudmFzIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKSxcclxuXHJcblx0X3ByZWNpc2lvbiA9IHBhcmFtZXRlcnMucHJlY2lzaW9uICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnByZWNpc2lvbiA6ICdoaWdocCcsXHJcblxyXG5cdF9hbHBoYSA9IHBhcmFtZXRlcnMuYWxwaGEgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuYWxwaGEgOiB0cnVlLFxyXG5cdF9wcmVtdWx0aXBsaWVkQWxwaGEgPSBwYXJhbWV0ZXJzLnByZW11bHRpcGxpZWRBbHBoYSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wcmVtdWx0aXBsaWVkQWxwaGEgOiB0cnVlLFxyXG5cdF9hbnRpYWxpYXMgPSBwYXJhbWV0ZXJzLmFudGlhbGlhcyAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5hbnRpYWxpYXMgOiBmYWxzZSxcclxuXHRfc3RlbmNpbCA9IHBhcmFtZXRlcnMuc3RlbmNpbCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5zdGVuY2lsIDogdHJ1ZSxcclxuXHRfcHJlc2VydmVEcmF3aW5nQnVmZmVyID0gcGFyYW1ldGVycy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMucHJlc2VydmVEcmF3aW5nQnVmZmVyIDogZmFsc2UsXHJcblxyXG5cdF9jbGVhckNvbG9yID0gcGFyYW1ldGVycy5jbGVhckNvbG9yICE9PSB1bmRlZmluZWQgPyBuZXcgVEhSRUUuQ29sb3IoIHBhcmFtZXRlcnMuY2xlYXJDb2xvciApIDogbmV3IFRIUkVFLkNvbG9yKCAweDAwMDAwMCApLFxyXG5cdF9jbGVhckFscGhhID0gcGFyYW1ldGVycy5jbGVhckFscGhhICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmNsZWFyQWxwaGEgOiAwO1xyXG5cclxuXHQvLyBwdWJsaWMgcHJvcGVydGllc1xyXG5cclxuXHR0aGlzLmRvbUVsZW1lbnQgPSBfY2FudmFzO1xyXG5cdHRoaXMuY29udGV4dCA9IG51bGw7XHJcblx0dGhpcy5kZXZpY2VQaXhlbFJhdGlvID0gcGFyYW1ldGVycy5kZXZpY2VQaXhlbFJhdGlvICE9PSB1bmRlZmluZWRcclxuXHRcdFx0XHQ/IHBhcmFtZXRlcnMuZGV2aWNlUGl4ZWxSYXRpb1xyXG5cdFx0XHRcdDogd2luZG93LmRldmljZVBpeGVsUmF0aW8gIT09IHVuZGVmaW5lZFxyXG5cdFx0XHRcdFx0PyB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpb1xyXG5cdFx0XHRcdFx0OiAxO1xyXG5cclxuXHQvLyBjbGVhcmluZ1xyXG5cclxuXHR0aGlzLmF1dG9DbGVhciA9IHRydWU7XHJcblx0dGhpcy5hdXRvQ2xlYXJDb2xvciA9IHRydWU7XHJcblx0dGhpcy5hdXRvQ2xlYXJEZXB0aCA9IHRydWU7XHJcblx0dGhpcy5hdXRvQ2xlYXJTdGVuY2lsID0gdHJ1ZTtcclxuXHJcblx0Ly8gc2NlbmUgZ3JhcGhcclxuXHJcblx0dGhpcy5zb3J0T2JqZWN0cyA9IHRydWU7XHJcblxyXG5cdHRoaXMuYXV0b1VwZGF0ZU9iamVjdHMgPSB0cnVlO1xyXG5cdHRoaXMuYXV0b1VwZGF0ZVNjZW5lID0gdHJ1ZTtcclxuXHJcblx0Ly8gcGh5c2ljYWxseSBiYXNlZCBzaGFkaW5nXHJcblxyXG5cdHRoaXMuZ2FtbWFJbnB1dCA9IGZhbHNlO1xyXG5cdHRoaXMuZ2FtbWFPdXRwdXQgPSBmYWxzZTtcclxuXHR0aGlzLnBoeXNpY2FsbHlCYXNlZFNoYWRpbmcgPSBmYWxzZTtcclxuXHJcblx0Ly8gc2hhZG93IG1hcFxyXG5cclxuXHR0aGlzLnNoYWRvd01hcEVuYWJsZWQgPSBmYWxzZTtcclxuXHR0aGlzLnNoYWRvd01hcEF1dG9VcGRhdGUgPSB0cnVlO1xyXG5cdHRoaXMuc2hhZG93TWFwVHlwZSA9IFRIUkVFLlBDRlNoYWRvd01hcDtcclxuXHR0aGlzLnNoYWRvd01hcEN1bGxGYWNlID0gVEhSRUUuQ3VsbEZhY2VGcm9udDtcclxuXHR0aGlzLnNoYWRvd01hcERlYnVnID0gZmFsc2U7XHJcblx0dGhpcy5zaGFkb3dNYXBDYXNjYWRlID0gZmFsc2U7XHJcblxyXG5cdC8vIG1vcnBoc1xyXG5cclxuXHR0aGlzLm1heE1vcnBoVGFyZ2V0cyA9IDg7XHJcblx0dGhpcy5tYXhNb3JwaE5vcm1hbHMgPSA0O1xyXG5cclxuXHQvLyBmbGFnc1xyXG5cclxuXHR0aGlzLmF1dG9TY2FsZUN1YmVtYXBzID0gdHJ1ZTtcclxuXHJcblx0Ly8gY3VzdG9tIHJlbmRlciBwbHVnaW5zXHJcblxyXG5cdHRoaXMucmVuZGVyUGx1Z2luc1ByZSA9IFtdO1xyXG5cdHRoaXMucmVuZGVyUGx1Z2luc1Bvc3QgPSBbXTtcclxuXHJcblx0Ly8gaW5mb1xyXG5cclxuXHR0aGlzLmluZm8gPSB7XHJcblxyXG5cdFx0bWVtb3J5OiB7XHJcblxyXG5cdFx0XHRwcm9ncmFtczogMCxcclxuXHRcdFx0Z2VvbWV0cmllczogMCxcclxuXHRcdFx0dGV4dHVyZXM6IDBcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHJlbmRlcjoge1xyXG5cclxuXHRcdFx0Y2FsbHM6IDAsXHJcblx0XHRcdHZlcnRpY2VzOiAwLFxyXG5cdFx0XHRmYWNlczogMCxcclxuXHRcdFx0cG9pbnRzOiAwXHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBpbnRlcm5hbCBwcm9wZXJ0aWVzXHJcblxyXG5cdHZhciBfdGhpcyA9IHRoaXMsXHJcblxyXG5cdF9wcm9ncmFtcyA9IFtdLFxyXG5cdF9wcm9ncmFtc19jb3VudGVyID0gMCxcclxuXHJcblx0Ly8gaW50ZXJuYWwgc3RhdGUgY2FjaGVcclxuXHJcblx0X2N1cnJlbnRQcm9ncmFtID0gbnVsbCxcclxuXHRfY3VycmVudEZyYW1lYnVmZmVyID0gbnVsbCxcclxuXHRfY3VycmVudE1hdGVyaWFsSWQgPSAtMSxcclxuXHRfY3VycmVudEdlb21ldHJ5R3JvdXBIYXNoID0gbnVsbCxcclxuXHRfY3VycmVudENhbWVyYSA9IG51bGwsXHJcblx0X2dlb21ldHJ5R3JvdXBDb3VudGVyID0gMCxcclxuXHJcblx0X3VzZWRUZXh0dXJlVW5pdHMgPSAwLFxyXG5cclxuXHQvLyBHTCBzdGF0ZSBjYWNoZVxyXG5cclxuXHRfb2xkRG91YmxlU2lkZWQgPSAtMSxcclxuXHRfb2xkRmxpcFNpZGVkID0gLTEsXHJcblxyXG5cdF9vbGRCbGVuZGluZyA9IC0xLFxyXG5cclxuXHRfb2xkQmxlbmRFcXVhdGlvbiA9IC0xLFxyXG5cdF9vbGRCbGVuZFNyYyA9IC0xLFxyXG5cdF9vbGRCbGVuZERzdCA9IC0xLFxyXG5cclxuXHRfb2xkRGVwdGhUZXN0ID0gLTEsXHJcblx0X29sZERlcHRoV3JpdGUgPSAtMSxcclxuXHJcblx0X29sZFBvbHlnb25PZmZzZXQgPSBudWxsLFxyXG5cdF9vbGRQb2x5Z29uT2Zmc2V0RmFjdG9yID0gbnVsbCxcclxuXHRfb2xkUG9seWdvbk9mZnNldFVuaXRzID0gbnVsbCxcclxuXHJcblx0X29sZExpbmVXaWR0aCA9IG51bGwsXHJcblxyXG5cdF92aWV3cG9ydFggPSAwLFxyXG5cdF92aWV3cG9ydFkgPSAwLFxyXG5cdF92aWV3cG9ydFdpZHRoID0gMCxcclxuXHRfdmlld3BvcnRIZWlnaHQgPSAwLFxyXG5cdF9jdXJyZW50V2lkdGggPSAwLFxyXG5cdF9jdXJyZW50SGVpZ2h0ID0gMCxcclxuXHJcblx0X2VuYWJsZWRBdHRyaWJ1dGVzID0ge30sXHJcblxyXG5cdC8vIGZydXN0dW1cclxuXHJcblx0X2ZydXN0dW0gPSBuZXcgVEhSRUUuRnJ1c3R1bSgpLFxyXG5cclxuXHQgLy8gY2FtZXJhIG1hdHJpY2VzIGNhY2hlXHJcblxyXG5cdF9wcm9qU2NyZWVuTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKSxcclxuXHRfcHJvalNjcmVlbk1hdHJpeFBTID0gbmV3IFRIUkVFLk1hdHJpeDQoKSxcclxuXHJcblx0X3ZlY3RvcjMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cclxuXHQvLyBsaWdodCBhcnJheXMgY2FjaGVcclxuXHJcblx0X2RpcmVjdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblxyXG5cdF9saWdodHNOZWVkVXBkYXRlID0gdHJ1ZSxcclxuXHJcblx0X2xpZ2h0cyA9IHtcclxuXHJcblx0XHRhbWJpZW50OiBbIDAsIDAsIDAgXSxcclxuXHRcdGRpcmVjdGlvbmFsOiB7IGxlbmd0aDogMCwgY29sb3JzOiBuZXcgQXJyYXkoKSwgcG9zaXRpb25zOiBuZXcgQXJyYXkoKSB9LFxyXG5cdFx0cG9pbnQ6IHsgbGVuZ3RoOiAwLCBjb2xvcnM6IG5ldyBBcnJheSgpLCBwb3NpdGlvbnM6IG5ldyBBcnJheSgpLCBkaXN0YW5jZXM6IG5ldyBBcnJheSgpIH0sXHJcblx0XHRzcG90OiB7IGxlbmd0aDogMCwgY29sb3JzOiBuZXcgQXJyYXkoKSwgcG9zaXRpb25zOiBuZXcgQXJyYXkoKSwgZGlzdGFuY2VzOiBuZXcgQXJyYXkoKSwgZGlyZWN0aW9uczogbmV3IEFycmF5KCksIGFuZ2xlc0NvczogbmV3IEFycmF5KCksIGV4cG9uZW50czogbmV3IEFycmF5KCkgfSxcclxuXHRcdGhlbWk6IHsgbGVuZ3RoOiAwLCBza3lDb2xvcnM6IG5ldyBBcnJheSgpLCBncm91bmRDb2xvcnM6IG5ldyBBcnJheSgpLCBwb3NpdGlvbnM6IG5ldyBBcnJheSgpIH1cclxuXHJcblx0fTtcclxuXHJcblx0Ly8gaW5pdGlhbGl6ZVxyXG5cclxuXHR2YXIgX2dsO1xyXG5cclxuXHR2YXIgX2dsRXh0ZW5zaW9uVGV4dHVyZUZsb2F0O1xyXG5cdHZhciBfZ2xFeHRlbnNpb25TdGFuZGFyZERlcml2YXRpdmVzO1xyXG5cdHZhciBfZ2xFeHRlbnNpb25UZXh0dXJlRmlsdGVyQW5pc290cm9waWM7XHJcblx0dmFyIF9nbEV4dGVuc2lvbkNvbXByZXNzZWRUZXh0dXJlUzNUQztcclxuXHJcblx0aW5pdEdMKCk7XHJcblxyXG5cdHNldERlZmF1bHRHTFN0YXRlKCk7XHJcblxyXG5cdHRoaXMuY29udGV4dCA9IF9nbDtcclxuXHJcblx0Ly8gR1BVIGNhcGFiaWxpdGllc1xyXG5cclxuXHR2YXIgX21heFRleHR1cmVzID0gX2dsLmdldFBhcmFtZXRlciggX2dsLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTICk7XHJcblx0dmFyIF9tYXhWZXJ0ZXhUZXh0dXJlcyA9IF9nbC5nZXRQYXJhbWV0ZXIoIF9nbC5NQVhfVkVSVEVYX1RFWFRVUkVfSU1BR0VfVU5JVFMgKTtcclxuXHR2YXIgX21heFRleHR1cmVTaXplID0gX2dsLmdldFBhcmFtZXRlciggX2dsLk1BWF9URVhUVVJFX1NJWkUgKTtcclxuXHR2YXIgX21heEN1YmVtYXBTaXplID0gX2dsLmdldFBhcmFtZXRlciggX2dsLk1BWF9DVUJFX01BUF9URVhUVVJFX1NJWkUgKTtcclxuXHJcblx0dmFyIF9tYXhBbmlzb3Ryb3B5ID0gX2dsRXh0ZW5zaW9uVGV4dHVyZUZpbHRlckFuaXNvdHJvcGljID8gX2dsLmdldFBhcmFtZXRlciggX2dsRXh0ZW5zaW9uVGV4dHVyZUZpbHRlckFuaXNvdHJvcGljLk1BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCApIDogMDtcclxuXHJcblx0dmFyIF9zdXBwb3J0c1ZlcnRleFRleHR1cmVzID0gKCBfbWF4VmVydGV4VGV4dHVyZXMgPiAwICk7XHJcblx0dmFyIF9zdXBwb3J0c0JvbmVUZXh0dXJlcyA9IF9zdXBwb3J0c1ZlcnRleFRleHR1cmVzICYmIF9nbEV4dGVuc2lvblRleHR1cmVGbG9hdDtcclxuXHJcblx0dmFyIF9jb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMgPSBfZ2xFeHRlbnNpb25Db21wcmVzc2VkVGV4dHVyZVMzVEMgPyBfZ2wuZ2V0UGFyYW1ldGVyKCBfZ2wuQ09NUFJFU1NFRF9URVhUVVJFX0ZPUk1BVFMgKSA6IFtdO1xyXG5cclxuXHQvL1xyXG5cclxuXHR2YXIgX3ZlcnRleFNoYWRlclByZWNpc2lvbkhpZ2hwRmxvYXQgPSBfZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBfZ2wuVkVSVEVYX1NIQURFUiwgX2dsLkhJR0hfRkxPQVQgKTtcclxuXHR2YXIgX3ZlcnRleFNoYWRlclByZWNpc2lvbk1lZGl1bXBGbG9hdCA9IF9nbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIF9nbC5WRVJURVhfU0hBREVSLCBfZ2wuTUVESVVNX0ZMT0FUICk7XHJcblx0dmFyIF92ZXJ0ZXhTaGFkZXJQcmVjaXNpb25Mb3dwRmxvYXQgPSBfZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBfZ2wuVkVSVEVYX1NIQURFUiwgX2dsLkxPV19GTE9BVCApO1xyXG5cclxuXHR2YXIgX2ZyYWdtZW50U2hhZGVyUHJlY2lzaW9uSGlnaHBGbG9hdCA9IF9nbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIF9nbC5GUkFHTUVOVF9TSEFERVIsIF9nbC5ISUdIX0ZMT0FUICk7XHJcblx0dmFyIF9mcmFnbWVudFNoYWRlclByZWNpc2lvbk1lZGl1bXBGbG9hdCA9IF9nbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIF9nbC5GUkFHTUVOVF9TSEFERVIsIF9nbC5NRURJVU1fRkxPQVQgKTtcclxuXHR2YXIgX2ZyYWdtZW50U2hhZGVyUHJlY2lzaW9uTG93cEZsb2F0ID0gX2dsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggX2dsLkZSQUdNRU5UX1NIQURFUiwgX2dsLkxPV19GTE9BVCApO1xyXG5cclxuXHR2YXIgX3ZlcnRleFNoYWRlclByZWNpc2lvbkhpZ2hwSW50ID0gX2dsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggX2dsLlZFUlRFWF9TSEFERVIsIF9nbC5ISUdIX0lOVCApO1xyXG5cdHZhciBfdmVydGV4U2hhZGVyUHJlY2lzaW9uTWVkaXVtcEludCA9IF9nbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIF9nbC5WRVJURVhfU0hBREVSLCBfZ2wuTUVESVVNX0lOVCApO1xyXG5cdHZhciBfdmVydGV4U2hhZGVyUHJlY2lzaW9uTG93cEludCA9IF9nbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIF9nbC5WRVJURVhfU0hBREVSLCBfZ2wuTE9XX0lOVCApO1xyXG5cclxuXHR2YXIgX2ZyYWdtZW50U2hhZGVyUHJlY2lzaW9uSGlnaHBJbnQgPSBfZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBfZ2wuRlJBR01FTlRfU0hBREVSLCBfZ2wuSElHSF9JTlQgKTtcclxuXHR2YXIgX2ZyYWdtZW50U2hhZGVyUHJlY2lzaW9uTWVkaXVtcEludCA9IF9nbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIF9nbC5GUkFHTUVOVF9TSEFERVIsIF9nbC5NRURJVU1fSU5UICk7XHJcblx0dmFyIF9mcmFnbWVudFNoYWRlclByZWNpc2lvbkxvd3BJbnQgPSBfZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBfZ2wuRlJBR01FTlRfU0hBREVSLCBfZ2wuTE9XX0lOVCApO1xyXG5cclxuXHQvLyBjbGFtcCBwcmVjaXNpb24gdG8gbWF4aW11bSBhdmFpbGFibGVcclxuXHJcblx0dmFyIGhpZ2hwQXZhaWxhYmxlID0gX3ZlcnRleFNoYWRlclByZWNpc2lvbkhpZ2hwRmxvYXQucHJlY2lzaW9uID4gMCAmJiBfZnJhZ21lbnRTaGFkZXJQcmVjaXNpb25IaWdocEZsb2F0LnByZWNpc2lvbiA+IDA7XHJcblx0dmFyIG1lZGl1bXBBdmFpbGFibGUgPSBfdmVydGV4U2hhZGVyUHJlY2lzaW9uTWVkaXVtcEZsb2F0LnByZWNpc2lvbiA+IDAgJiYgX2ZyYWdtZW50U2hhZGVyUHJlY2lzaW9uTWVkaXVtcEZsb2F0LnByZWNpc2lvbiA+IDA7XHJcblxyXG5cdGlmICggX3ByZWNpc2lvbiA9PT0gXCJoaWdocFwiICYmICEgaGlnaHBBdmFpbGFibGUgKSB7XHJcblxyXG5cdFx0aWYgKCBtZWRpdW1wQXZhaWxhYmxlICkge1xyXG5cclxuXHRcdFx0X3ByZWNpc2lvbiA9IFwibWVkaXVtcFwiO1xyXG5cdFx0XHRjb25zb2xlLndhcm4oIFwiV2ViR0xSZW5kZXJlcjogaGlnaHAgbm90IHN1cHBvcnRlZCwgdXNpbmcgbWVkaXVtcFwiICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdF9wcmVjaXNpb24gPSBcImxvd3BcIjtcclxuXHRcdFx0Y29uc29sZS53YXJuKCBcIldlYkdMUmVuZGVyZXI6IGhpZ2hwIGFuZCBtZWRpdW1wIG5vdCBzdXBwb3J0ZWQsIHVzaW5nIGxvd3BcIiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRpZiAoIF9wcmVjaXNpb24gPT09IFwibWVkaXVtcFwiICYmICEgbWVkaXVtcEF2YWlsYWJsZSApIHtcclxuXHJcblx0XHRfcHJlY2lzaW9uID0gXCJsb3dwXCI7XHJcblx0XHRjb25zb2xlLndhcm4oIFwiV2ViR0xSZW5kZXJlcjogbWVkaXVtcCBub3Qgc3VwcG9ydGVkLCB1c2luZyBsb3dwXCIgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBBUElcclxuXHJcblx0dGhpcy5nZXRDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBfZ2w7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gX3N1cHBvcnRzVmVydGV4VGV4dHVyZXM7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuc3VwcG9ydHNGbG9hdFRleHR1cmVzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBfZ2xFeHRlbnNpb25UZXh0dXJlRmxvYXQ7XHJcblxyXG5cdH07XHJcblx0XHJcblx0dGhpcy5zdXBwb3J0c1N0YW5kYXJkRGVyaXZhdGl2ZXMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIF9nbEV4dGVuc2lvblN0YW5kYXJkRGVyaXZhdGl2ZXM7XHJcblxyXG5cdH07XHJcblx0XHJcblx0dGhpcy5zdXBwb3J0c0NvbXByZXNzZWRUZXh0dXJlUzNUQyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gX2dsRXh0ZW5zaW9uQ29tcHJlc3NlZFRleHR1cmVTM1RDO1xyXG5cclxuXHR9O1xyXG5cdFxyXG5cdHRoaXMuZ2V0TWF4QW5pc290cm9weSAgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIF9tYXhBbmlzb3Ryb3B5O1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLmdldFByZWNpc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gX3ByZWNpc2lvbjtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5zZXRTaXplID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0ICkge1xyXG5cclxuXHRcdF9jYW52YXMud2lkdGggPSB3aWR0aCAqIHRoaXMuZGV2aWNlUGl4ZWxSYXRpbztcclxuXHRcdF9jYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogdGhpcy5kZXZpY2VQaXhlbFJhdGlvO1xyXG5cclxuXHRcdF9jYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XHJcblx0XHRfY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XHJcblxyXG5cdFx0dGhpcy5zZXRWaWV3cG9ydCggMCwgMCwgX2NhbnZhcy53aWR0aCwgX2NhbnZhcy5oZWlnaHQgKTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5zZXRWaWV3cG9ydCA9IGZ1bmN0aW9uICggeCwgeSwgd2lkdGgsIGhlaWdodCApIHtcclxuXHJcblx0XHRfdmlld3BvcnRYID0geCAhPT0gdW5kZWZpbmVkID8geCA6IDA7XHJcblx0XHRfdmlld3BvcnRZID0geSAhPT0gdW5kZWZpbmVkID8geSA6IDA7XHJcblxyXG5cdFx0X3ZpZXdwb3J0V2lkdGggPSB3aWR0aCAhPT0gdW5kZWZpbmVkID8gd2lkdGggOiBfY2FudmFzLndpZHRoO1xyXG5cdFx0X3ZpZXdwb3J0SGVpZ2h0ID0gaGVpZ2h0ICE9PSB1bmRlZmluZWQgPyBoZWlnaHQgOiBfY2FudmFzLmhlaWdodDtcclxuXHJcblx0XHRfZ2wudmlld3BvcnQoIF92aWV3cG9ydFgsIF92aWV3cG9ydFksIF92aWV3cG9ydFdpZHRoLCBfdmlld3BvcnRIZWlnaHQgKTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5zZXRTY2lzc29yID0gZnVuY3Rpb24gKCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICkge1xyXG5cclxuXHRcdF9nbC5zY2lzc29yKCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICk7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuZW5hYmxlU2Npc3NvclRlc3QgPSBmdW5jdGlvbiAoIGVuYWJsZSApIHtcclxuXHJcblx0XHRlbmFibGUgPyBfZ2wuZW5hYmxlKCBfZ2wuU0NJU1NPUl9URVNUICkgOiBfZ2wuZGlzYWJsZSggX2dsLlNDSVNTT1JfVEVTVCApO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBDbGVhcmluZ1xyXG5cclxuXHR0aGlzLnNldENsZWFyQ29sb3JIZXggPSBmdW5jdGlvbiAoIGhleCwgYWxwaGEgKSB7XHJcblxyXG5cdFx0X2NsZWFyQ29sb3Iuc2V0SGV4KCBoZXggKTtcclxuXHRcdF9jbGVhckFscGhhID0gYWxwaGE7XHJcblxyXG5cdFx0X2dsLmNsZWFyQ29sb3IoIF9jbGVhckNvbG9yLnIsIF9jbGVhckNvbG9yLmcsIF9jbGVhckNvbG9yLmIsIF9jbGVhckFscGhhICk7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuc2V0Q2xlYXJDb2xvciA9IGZ1bmN0aW9uICggY29sb3IsIGFscGhhICkge1xyXG5cclxuXHRcdF9jbGVhckNvbG9yLmNvcHkoIGNvbG9yICk7XHJcblx0XHRfY2xlYXJBbHBoYSA9IGFscGhhO1xyXG5cclxuXHRcdF9nbC5jbGVhckNvbG9yKCBfY2xlYXJDb2xvci5yLCBfY2xlYXJDb2xvci5nLCBfY2xlYXJDb2xvci5iLCBfY2xlYXJBbHBoYSApO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLmdldENsZWFyQ29sb3IgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIF9jbGVhckNvbG9yO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLmdldENsZWFyQWxwaGEgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIF9jbGVhckFscGhhO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLmNsZWFyID0gZnVuY3Rpb24gKCBjb2xvciwgZGVwdGgsIHN0ZW5jaWwgKSB7XHJcblxyXG5cdFx0dmFyIGJpdHMgPSAwO1xyXG5cclxuXHRcdGlmICggY29sb3IgPT09IHVuZGVmaW5lZCB8fCBjb2xvciApIGJpdHMgfD0gX2dsLkNPTE9SX0JVRkZFUl9CSVQ7XHJcblx0XHRpZiAoIGRlcHRoID09PSB1bmRlZmluZWQgfHwgZGVwdGggKSBiaXRzIHw9IF9nbC5ERVBUSF9CVUZGRVJfQklUO1xyXG5cdFx0aWYgKCBzdGVuY2lsID09PSB1bmRlZmluZWQgfHwgc3RlbmNpbCApIGJpdHMgfD0gX2dsLlNURU5DSUxfQlVGRkVSX0JJVDtcclxuXHJcblx0XHRfZ2wuY2xlYXIoIGJpdHMgKTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5jbGVhclRhcmdldCA9IGZ1bmN0aW9uICggcmVuZGVyVGFyZ2V0LCBjb2xvciwgZGVwdGgsIHN0ZW5jaWwgKSB7XHJcblxyXG5cdFx0dGhpcy5zZXRSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApO1xyXG5cdFx0dGhpcy5jbGVhciggY29sb3IsIGRlcHRoLCBzdGVuY2lsICk7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIFBsdWdpbnNcclxuXHJcblx0dGhpcy5hZGRQb3N0UGx1Z2luID0gZnVuY3Rpb24gKCBwbHVnaW4gKSB7XHJcblxyXG5cdFx0cGx1Z2luLmluaXQoIHRoaXMgKTtcclxuXHRcdHRoaXMucmVuZGVyUGx1Z2luc1Bvc3QucHVzaCggcGx1Z2luICk7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuYWRkUHJlUGx1Z2luID0gZnVuY3Rpb24gKCBwbHVnaW4gKSB7XHJcblxyXG5cdFx0cGx1Z2luLmluaXQoIHRoaXMgKTtcclxuXHRcdHRoaXMucmVuZGVyUGx1Z2luc1ByZS5wdXNoKCBwbHVnaW4gKTtcclxuXHJcblx0fTtcclxuXHJcblx0Ly8gUmVuZGVyaW5nXHJcblxyXG5cdHRoaXMudXBkYXRlU2hhZG93TWFwID0gZnVuY3Rpb24gKCBzY2VuZSwgY2FtZXJhICkge1xyXG5cclxuXHRcdF9jdXJyZW50UHJvZ3JhbSA9IG51bGw7XHJcblx0XHRfb2xkQmxlbmRpbmcgPSAtMTtcclxuXHRcdF9vbGREZXB0aFRlc3QgPSAtMTtcclxuXHRcdF9vbGREZXB0aFdyaXRlID0gLTE7XHJcblx0XHRfY3VycmVudEdlb21ldHJ5R3JvdXBIYXNoID0gLTE7XHJcblx0XHRfY3VycmVudE1hdGVyaWFsSWQgPSAtMTtcclxuXHRcdF9saWdodHNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuXHRcdF9vbGREb3VibGVTaWRlZCA9IC0xO1xyXG5cdFx0X29sZEZsaXBTaWRlZCA9IC0xO1xyXG5cclxuXHRcdHRoaXMuc2hhZG93TWFwUGx1Z2luLnVwZGF0ZSggc2NlbmUsIGNhbWVyYSApO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBJbnRlcm5hbCBmdW5jdGlvbnNcclxuXHJcblx0Ly8gQnVmZmVyIGFsbG9jYXRpb25cclxuXHJcblx0ZnVuY3Rpb24gY3JlYXRlUGFydGljbGVCdWZmZXJzICggZ2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0Z2VvbWV0cnkuX193ZWJnbFZlcnRleEJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcclxuXHRcdGdlb21ldHJ5Ll9fd2ViZ2xDb2xvckJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcclxuXHJcblx0XHRfdGhpcy5pbmZvLm1lbW9yeS5nZW9tZXRyaWVzICsrO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBjcmVhdGVMaW5lQnVmZmVycyAoIGdlb21ldHJ5ICkge1xyXG5cclxuXHRcdGdlb21ldHJ5Ll9fd2ViZ2xWZXJ0ZXhCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblx0XHRnZW9tZXRyeS5fX3dlYmdsQ29sb3JCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblx0XHRnZW9tZXRyeS5fX3dlYmdsTGluZURpc3RhbmNlQnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cclxuXHRcdF90aGlzLmluZm8ubWVtb3J5Lmdlb21ldHJpZXMgKys7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGNyZWF0ZVJpYmJvbkJ1ZmZlcnMgKCBnZW9tZXRyeSApIHtcclxuXHJcblx0XHRnZW9tZXRyeS5fX3dlYmdsVmVydGV4QnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cdFx0Z2VvbWV0cnkuX193ZWJnbENvbG9yQnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cdFx0Z2VvbWV0cnkuX193ZWJnbE5vcm1hbEJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcclxuXHJcblx0XHRfdGhpcy5pbmZvLm1lbW9yeS5nZW9tZXRyaWVzICsrO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBjcmVhdGVNZXNoQnVmZmVycyAoIGdlb21ldHJ5R3JvdXAgKSB7XHJcblxyXG5cdFx0Z2VvbWV0cnlHcm91cC5fX3dlYmdsVmVydGV4QnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cdFx0Z2VvbWV0cnlHcm91cC5fX3dlYmdsTm9ybWFsQnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cdFx0Z2VvbWV0cnlHcm91cC5fX3dlYmdsVGFuZ2VudEJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcclxuXHRcdGdlb21ldHJ5R3JvdXAuX193ZWJnbENvbG9yQnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cdFx0Z2VvbWV0cnlHcm91cC5fX3dlYmdsVVZCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblx0XHRnZW9tZXRyeUdyb3VwLl9fd2ViZ2xVVjJCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblxyXG5cdFx0Z2VvbWV0cnlHcm91cC5fX3dlYmdsU2tpbkluZGljZXNCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblx0XHRnZW9tZXRyeUdyb3VwLl9fd2ViZ2xTa2luV2VpZ2h0c0J1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcclxuXHJcblx0XHRnZW9tZXRyeUdyb3VwLl9fd2ViZ2xGYWNlQnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cdFx0Z2VvbWV0cnlHcm91cC5fX3dlYmdsTGluZUJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcclxuXHJcblx0XHR2YXIgbSwgbWw7XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeUdyb3VwLm51bU1vcnBoVGFyZ2V0cyApIHtcclxuXHJcblx0XHRcdGdlb21ldHJ5R3JvdXAuX193ZWJnbE1vcnBoVGFyZ2V0c0J1ZmZlcnMgPSBbXTtcclxuXHJcblx0XHRcdGZvciAoIG0gPSAwLCBtbCA9IGdlb21ldHJ5R3JvdXAubnVtTW9ycGhUYXJnZXRzOyBtIDwgbWw7IG0gKysgKSB7XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5R3JvdXAuX193ZWJnbE1vcnBoVGFyZ2V0c0J1ZmZlcnMucHVzaCggX2dsLmNyZWF0ZUJ1ZmZlcigpICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZ2VvbWV0cnlHcm91cC5udW1Nb3JwaE5vcm1hbHMgKSB7XHJcblxyXG5cdFx0XHRnZW9tZXRyeUdyb3VwLl9fd2ViZ2xNb3JwaE5vcm1hbHNCdWZmZXJzID0gW107XHJcblxyXG5cdFx0XHRmb3IgKCBtID0gMCwgbWwgPSBnZW9tZXRyeUdyb3VwLm51bU1vcnBoTm9ybWFsczsgbSA8IG1sOyBtICsrICkge1xyXG5cclxuXHRcdFx0XHRnZW9tZXRyeUdyb3VwLl9fd2ViZ2xNb3JwaE5vcm1hbHNCdWZmZXJzLnB1c2goIF9nbC5jcmVhdGVCdWZmZXIoKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRfdGhpcy5pbmZvLm1lbW9yeS5nZW9tZXRyaWVzICsrO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBFdmVudHNcclxuXHJcblx0dmFyIG9uR2VvbWV0cnlEaXNwb3NlID0gZnVuY3Rpb24gKCBldmVudCApIHtcclxuXHJcblx0XHR2YXIgZ2VvbWV0cnkgPSBldmVudC50YXJnZXQ7XHJcblxyXG5cdFx0Z2VvbWV0cnkucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbkdlb21ldHJ5RGlzcG9zZSApO1xyXG5cclxuXHRcdGRlYWxsb2NhdGVHZW9tZXRyeSggZ2VvbWV0cnkgKTtcclxuXHJcblx0XHRfdGhpcy5pbmZvLm1lbW9yeS5nZW9tZXRyaWVzIC0tO1xyXG5cclxuXHR9O1xyXG5cclxuXHR2YXIgb25UZXh0dXJlRGlzcG9zZSA9IGZ1bmN0aW9uICggZXZlbnQgKSB7XHJcblxyXG5cdFx0dmFyIHRleHR1cmUgPSBldmVudC50YXJnZXQ7XHJcblxyXG5cdFx0dGV4dHVyZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uVGV4dHVyZURpc3Bvc2UgKTtcclxuXHJcblx0XHRkZWFsbG9jYXRlVGV4dHVyZSggdGV4dHVyZSApO1xyXG5cclxuXHRcdF90aGlzLmluZm8ubWVtb3J5LnRleHR1cmVzIC0tO1xyXG5cclxuXHJcblx0fTtcclxuXHJcblx0dmFyIG9uUmVuZGVyVGFyZ2V0RGlzcG9zZSA9IGZ1bmN0aW9uICggZXZlbnQgKSB7XHJcblxyXG5cdFx0dmFyIHJlbmRlclRhcmdldCA9IGV2ZW50LnRhcmdldDtcclxuXHJcblx0XHRyZW5kZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblJlbmRlclRhcmdldERpc3Bvc2UgKTtcclxuXHJcblx0XHRkZWFsbG9jYXRlUmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRfdGhpcy5pbmZvLm1lbW9yeS50ZXh0dXJlcyAtLTtcclxuXHJcblx0fTtcclxuXHJcblx0dmFyIG9uTWF0ZXJpYWxEaXNwb3NlID0gZnVuY3Rpb24gKCBldmVudCApIHtcclxuXHJcblx0XHR2YXIgbWF0ZXJpYWwgPSBldmVudC50YXJnZXQ7XHJcblxyXG5cdFx0bWF0ZXJpYWwucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbk1hdGVyaWFsRGlzcG9zZSApO1xyXG5cclxuXHRcdGRlYWxsb2NhdGVNYXRlcmlhbCggbWF0ZXJpYWwgKTtcclxuXHJcblx0fTtcclxuXHJcblx0Ly8gQnVmZmVyIGRlYWxsb2NhdGlvblxyXG5cclxuXHR2YXIgZGVhbGxvY2F0ZUdlb21ldHJ5ID0gZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcclxuXHJcblx0XHRnZW9tZXRyeS5fX3dlYmdsSW5pdCA9IHVuZGVmaW5lZDtcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5Ll9fd2ViZ2xWZXJ0ZXhCdWZmZXIgIT09IHVuZGVmaW5lZCApIF9nbC5kZWxldGVCdWZmZXIoIGdlb21ldHJ5Ll9fd2ViZ2xWZXJ0ZXhCdWZmZXIgKTtcclxuXHRcdGlmICggZ2VvbWV0cnkuX193ZWJnbE5vcm1hbEJ1ZmZlciAhPT0gdW5kZWZpbmVkICkgX2dsLmRlbGV0ZUJ1ZmZlciggZ2VvbWV0cnkuX193ZWJnbE5vcm1hbEJ1ZmZlciApO1xyXG5cdFx0aWYgKCBnZW9tZXRyeS5fX3dlYmdsVGFuZ2VudEJ1ZmZlciAhPT0gdW5kZWZpbmVkICkgX2dsLmRlbGV0ZUJ1ZmZlciggZ2VvbWV0cnkuX193ZWJnbFRhbmdlbnRCdWZmZXIgKTtcclxuXHRcdGlmICggZ2VvbWV0cnkuX193ZWJnbENvbG9yQnVmZmVyICE9PSB1bmRlZmluZWQgKSBfZ2wuZGVsZXRlQnVmZmVyKCBnZW9tZXRyeS5fX3dlYmdsQ29sb3JCdWZmZXIgKTtcclxuXHRcdGlmICggZ2VvbWV0cnkuX193ZWJnbFVWQnVmZmVyICE9PSB1bmRlZmluZWQgKSBfZ2wuZGVsZXRlQnVmZmVyKCBnZW9tZXRyeS5fX3dlYmdsVVZCdWZmZXIgKTtcclxuXHRcdGlmICggZ2VvbWV0cnkuX193ZWJnbFVWMkJ1ZmZlciAhPT0gdW5kZWZpbmVkICkgX2dsLmRlbGV0ZUJ1ZmZlciggZ2VvbWV0cnkuX193ZWJnbFVWMkJ1ZmZlciApO1xyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkuX193ZWJnbFNraW5JbmRpY2VzQnVmZmVyICE9PSB1bmRlZmluZWQgKSBfZ2wuZGVsZXRlQnVmZmVyKCBnZW9tZXRyeS5fX3dlYmdsU2tpbkluZGljZXNCdWZmZXIgKTtcclxuXHRcdGlmICggZ2VvbWV0cnkuX193ZWJnbFNraW5XZWlnaHRzQnVmZmVyICE9PSB1bmRlZmluZWQgKSBfZ2wuZGVsZXRlQnVmZmVyKCBnZW9tZXRyeS5fX3dlYmdsU2tpbldlaWdodHNCdWZmZXIgKTtcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5Ll9fd2ViZ2xGYWNlQnVmZmVyICE9PSB1bmRlZmluZWQgKSBfZ2wuZGVsZXRlQnVmZmVyKCBnZW9tZXRyeS5fX3dlYmdsRmFjZUJ1ZmZlciApO1xyXG5cdFx0aWYgKCBnZW9tZXRyeS5fX3dlYmdsTGluZUJ1ZmZlciAhPT0gdW5kZWZpbmVkICkgX2dsLmRlbGV0ZUJ1ZmZlciggZ2VvbWV0cnkuX193ZWJnbExpbmVCdWZmZXIgKTtcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5Ll9fd2ViZ2xMaW5lRGlzdGFuY2VCdWZmZXIgIT09IHVuZGVmaW5lZCApIF9nbC5kZWxldGVCdWZmZXIoIGdlb21ldHJ5Ll9fd2ViZ2xMaW5lRGlzdGFuY2VCdWZmZXIgKTtcclxuXHJcblx0XHQvLyBnZW9tZXRyeSBncm91cHNcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5Lmdlb21ldHJ5R3JvdXBzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgZyBpbiBnZW9tZXRyeS5nZW9tZXRyeUdyb3VwcyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGdlb21ldHJ5R3JvdXAgPSBnZW9tZXRyeS5nZW9tZXRyeUdyb3Vwc1sgZyBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5R3JvdXAubnVtTW9ycGhUYXJnZXRzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIG0gPSAwLCBtbCA9IGdlb21ldHJ5R3JvdXAubnVtTW9ycGhUYXJnZXRzOyBtIDwgbWw7IG0gKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRfZ2wuZGVsZXRlQnVmZmVyKCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xNb3JwaFRhcmdldHNCdWZmZXJzWyBtIF0gKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBnZW9tZXRyeUdyb3VwLm51bU1vcnBoTm9ybWFscyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIHZhciBtID0gMCwgbWwgPSBnZW9tZXRyeUdyb3VwLm51bU1vcnBoTm9ybWFsczsgbSA8IG1sOyBtICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0X2dsLmRlbGV0ZUJ1ZmZlciggZ2VvbWV0cnlHcm91cC5fX3dlYmdsTW9ycGhOb3JtYWxzQnVmZmVyc1sgbSBdICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGRlbGV0ZUN1c3RvbUF0dHJpYnV0ZXNCdWZmZXJzKCBnZW9tZXRyeUdyb3VwICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGRlbGV0ZUN1c3RvbUF0dHJpYnV0ZXNCdWZmZXJzKCBnZW9tZXRyeSApO1xyXG5cclxuXHR9O1xyXG5cclxuXHR2YXIgZGVhbGxvY2F0ZVRleHR1cmUgPSBmdW5jdGlvbiAoIHRleHR1cmUgKSB7XHJcblxyXG5cdFx0aWYgKCB0ZXh0dXJlLmltYWdlICYmIHRleHR1cmUuaW1hZ2UuX193ZWJnbFRleHR1cmVDdWJlICkge1xyXG5cclxuXHRcdFx0Ly8gY3ViZSB0ZXh0dXJlXHJcblxyXG5cdFx0XHRfZ2wuZGVsZXRlVGV4dHVyZSggdGV4dHVyZS5pbWFnZS5fX3dlYmdsVGV4dHVyZUN1YmUgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Ly8gMkQgdGV4dHVyZVxyXG5cclxuXHRcdFx0aWYgKCAhIHRleHR1cmUuX193ZWJnbEluaXQgKSByZXR1cm47XHJcblxyXG5cdFx0XHR0ZXh0dXJlLl9fd2ViZ2xJbml0ID0gZmFsc2U7XHJcblx0XHRcdF9nbC5kZWxldGVUZXh0dXJlKCB0ZXh0dXJlLl9fd2ViZ2xUZXh0dXJlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR2YXIgZGVhbGxvY2F0ZVJlbmRlclRhcmdldCA9IGZ1bmN0aW9uICggcmVuZGVyVGFyZ2V0ICkge1xyXG5cclxuXHRcdGlmICggIXJlbmRlclRhcmdldCB8fCAhIHJlbmRlclRhcmdldC5fX3dlYmdsVGV4dHVyZSApIHJldHVybjtcclxuXHJcblx0XHRfZ2wuZGVsZXRlVGV4dHVyZSggcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xUZXh0dXJlICk7XHJcblxyXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRfZ2wuZGVsZXRlRnJhbWVidWZmZXIoIHJlbmRlclRhcmdldC5fX3dlYmdsRnJhbWVidWZmZXJbIGkgXSApO1xyXG5cdFx0XHRcdF9nbC5kZWxldGVSZW5kZXJidWZmZXIoIHJlbmRlclRhcmdldC5fX3dlYmdsUmVuZGVyYnVmZmVyWyBpIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0X2dsLmRlbGV0ZUZyYW1lYnVmZmVyKCByZW5kZXJUYXJnZXQuX193ZWJnbEZyYW1lYnVmZmVyICk7XHJcblx0XHRcdF9nbC5kZWxldGVSZW5kZXJidWZmZXIoIHJlbmRlclRhcmdldC5fX3dlYmdsUmVuZGVyYnVmZmVyICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR2YXIgZGVhbGxvY2F0ZU1hdGVyaWFsID0gZnVuY3Rpb24gKCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHR2YXIgcHJvZ3JhbSA9IG1hdGVyaWFsLnByb2dyYW07XHJcblxyXG5cdFx0aWYgKCBwcm9ncmFtID09PSB1bmRlZmluZWQgKSByZXR1cm47XHJcblxyXG5cdFx0bWF0ZXJpYWwucHJvZ3JhbSA9IHVuZGVmaW5lZDtcclxuXHJcblx0XHQvLyBvbmx5IGRlYWxsb2NhdGUgR0wgcHJvZ3JhbSBpZiB0aGlzIHdhcyB0aGUgbGFzdCB1c2Ugb2Ygc2hhcmVkIHByb2dyYW1cclxuXHRcdC8vIGFzc3VtZWQgdGhlcmUgaXMgb25seSBzaW5nbGUgY29weSBvZiBhbnkgcHJvZ3JhbSBpbiB0aGUgX3Byb2dyYW1zIGxpc3RcclxuXHRcdC8vICh0aGF0J3MgaG93IGl0J3MgY29uc3RydWN0ZWQpXHJcblxyXG5cdFx0dmFyIGksIGlsLCBwcm9ncmFtSW5mbztcclxuXHRcdHZhciBkZWxldGVQcm9ncmFtID0gZmFsc2U7XHJcblxyXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gX3Byb2dyYW1zLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0cHJvZ3JhbUluZm8gPSBfcHJvZ3JhbXNbIGkgXTtcclxuXHJcblx0XHRcdGlmICggcHJvZ3JhbUluZm8ucHJvZ3JhbSA9PT0gcHJvZ3JhbSApIHtcclxuXHJcblx0XHRcdFx0cHJvZ3JhbUluZm8udXNlZFRpbWVzIC0tO1xyXG5cclxuXHRcdFx0XHRpZiAoIHByb2dyYW1JbmZvLnVzZWRUaW1lcyA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0XHRkZWxldGVQcm9ncmFtID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBkZWxldGVQcm9ncmFtID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0Ly8gYXZvaWQgdXNpbmcgYXJyYXkuc3BsaWNlLCB0aGlzIGlzIGNvc3RsaWVyIHRoYW4gY3JlYXRpbmcgbmV3IGFycmF5IGZyb20gc2NyYXRjaFxyXG5cclxuXHRcdFx0dmFyIG5ld1Byb2dyYW1zID0gW107XHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMCwgaWwgPSBfcHJvZ3JhbXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHByb2dyYW1JbmZvID0gX3Byb2dyYW1zWyBpIF07XHJcblxyXG5cdFx0XHRcdGlmICggcHJvZ3JhbUluZm8ucHJvZ3JhbSAhPT0gcHJvZ3JhbSApIHtcclxuXHJcblx0XHRcdFx0XHRuZXdQcm9ncmFtcy5wdXNoKCBwcm9ncmFtSW5mbyApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRfcHJvZ3JhbXMgPSBuZXdQcm9ncmFtcztcclxuXHJcblx0XHRcdF9nbC5kZWxldGVQcm9ncmFtKCBwcm9ncmFtICk7XHJcblxyXG5cdFx0XHRfdGhpcy5pbmZvLm1lbW9yeS5wcm9ncmFtcyAtLTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdC8vXHJcblxyXG5cdC8qXHJcblx0ZnVuY3Rpb24gZGVsZXRlUGFydGljbGVCdWZmZXJzICggZ2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0X2dsLmRlbGV0ZUJ1ZmZlciggZ2VvbWV0cnkuX193ZWJnbFZlcnRleEJ1ZmZlciApO1xyXG5cdFx0X2dsLmRlbGV0ZUJ1ZmZlciggZ2VvbWV0cnkuX193ZWJnbENvbG9yQnVmZmVyICk7XHJcblxyXG5cdFx0ZGVsZXRlQ3VzdG9tQXR0cmlidXRlc0J1ZmZlcnMoIGdlb21ldHJ5ICk7XHJcblxyXG5cdFx0X3RoaXMuaW5mby5tZW1vcnkuZ2VvbWV0cmllcyAtLTtcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gZGVsZXRlTGluZUJ1ZmZlcnMgKCBnZW9tZXRyeSApIHtcclxuXHJcblx0XHRfZ2wuZGVsZXRlQnVmZmVyKCBnZW9tZXRyeS5fX3dlYmdsVmVydGV4QnVmZmVyICk7XHJcblx0XHRfZ2wuZGVsZXRlQnVmZmVyKCBnZW9tZXRyeS5fX3dlYmdsQ29sb3JCdWZmZXIgKTtcclxuXHRcdF9nbC5kZWxldGVCdWZmZXIoIGdlb21ldHJ5Ll9fd2ViZ2xMaW5lRGlzdGFuY2VCdWZmZXIgKTtcclxuXHJcblx0XHRkZWxldGVDdXN0b21BdHRyaWJ1dGVzQnVmZmVycyggZ2VvbWV0cnkgKTtcclxuXHJcblx0XHRfdGhpcy5pbmZvLm1lbW9yeS5nZW9tZXRyaWVzIC0tO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBkZWxldGVSaWJib25CdWZmZXJzICggZ2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0X2dsLmRlbGV0ZUJ1ZmZlciggZ2VvbWV0cnkuX193ZWJnbFZlcnRleEJ1ZmZlciApO1xyXG5cdFx0X2dsLmRlbGV0ZUJ1ZmZlciggZ2VvbWV0cnkuX193ZWJnbENvbG9yQnVmZmVyICk7XHJcblx0XHRfZ2wuZGVsZXRlQnVmZmVyKCBnZW9tZXRyeS5fX3dlYmdsTm9ybWFsQnVmZmVyICk7XHJcblxyXG5cdFx0ZGVsZXRlQ3VzdG9tQXR0cmlidXRlc0J1ZmZlcnMoIGdlb21ldHJ5ICk7XHJcblxyXG5cdFx0X3RoaXMuaW5mby5tZW1vcnkuZ2VvbWV0cmllcyAtLTtcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gZGVsZXRlTWVzaEJ1ZmZlcnMgKCBnZW9tZXRyeUdyb3VwICkge1xyXG5cclxuXHRcdF9nbC5kZWxldGVCdWZmZXIoIGdlb21ldHJ5R3JvdXAuX193ZWJnbFZlcnRleEJ1ZmZlciApO1xyXG5cdFx0X2dsLmRlbGV0ZUJ1ZmZlciggZ2VvbWV0cnlHcm91cC5fX3dlYmdsTm9ybWFsQnVmZmVyICk7XHJcblx0XHRfZ2wuZGVsZXRlQnVmZmVyKCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xUYW5nZW50QnVmZmVyICk7XHJcblx0XHRfZ2wuZGVsZXRlQnVmZmVyKCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xDb2xvckJ1ZmZlciApO1xyXG5cdFx0X2dsLmRlbGV0ZUJ1ZmZlciggZ2VvbWV0cnlHcm91cC5fX3dlYmdsVVZCdWZmZXIgKTtcclxuXHRcdF9nbC5kZWxldGVCdWZmZXIoIGdlb21ldHJ5R3JvdXAuX193ZWJnbFVWMkJ1ZmZlciApO1xyXG5cclxuXHRcdF9nbC5kZWxldGVCdWZmZXIoIGdlb21ldHJ5R3JvdXAuX193ZWJnbFNraW5JbmRpY2VzQnVmZmVyICk7XHJcblx0XHRfZ2wuZGVsZXRlQnVmZmVyKCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xTa2luV2VpZ2h0c0J1ZmZlciApO1xyXG5cclxuXHRcdF9nbC5kZWxldGVCdWZmZXIoIGdlb21ldHJ5R3JvdXAuX193ZWJnbEZhY2VCdWZmZXIgKTtcclxuXHRcdF9nbC5kZWxldGVCdWZmZXIoIGdlb21ldHJ5R3JvdXAuX193ZWJnbExpbmVCdWZmZXIgKTtcclxuXHJcblx0XHR2YXIgbSwgbWw7XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeUdyb3VwLm51bU1vcnBoVGFyZ2V0cyApIHtcclxuXHJcblx0XHRcdGZvciAoIG0gPSAwLCBtbCA9IGdlb21ldHJ5R3JvdXAubnVtTW9ycGhUYXJnZXRzOyBtIDwgbWw7IG0gKysgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5kZWxldGVCdWZmZXIoIGdlb21ldHJ5R3JvdXAuX193ZWJnbE1vcnBoVGFyZ2V0c0J1ZmZlcnNbIG0gXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5R3JvdXAubnVtTW9ycGhOb3JtYWxzICkge1xyXG5cclxuXHRcdFx0Zm9yICggbSA9IDAsIG1sID0gZ2VvbWV0cnlHcm91cC5udW1Nb3JwaE5vcm1hbHM7IG0gPCBtbDsgbSArKyApIHtcclxuXHJcblx0XHRcdFx0X2dsLmRlbGV0ZUJ1ZmZlciggZ2VvbWV0cnlHcm91cC5fX3dlYmdsTW9ycGhOb3JtYWxzQnVmZmVyc1sgbSBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGRlbGV0ZUN1c3RvbUF0dHJpYnV0ZXNCdWZmZXJzKCBnZW9tZXRyeUdyb3VwICk7XHJcblxyXG5cdFx0X3RoaXMuaW5mby5tZW1vcnkuZ2VvbWV0cmllcyAtLTtcclxuXHJcblx0fTtcclxuXHQqL1xyXG5cclxuXHRmdW5jdGlvbiBkZWxldGVDdXN0b21BdHRyaWJ1dGVzQnVmZmVycyggZ2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3QgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaWQgaW4gZ2VvbWV0cnkuX193ZWJnbEN1c3RvbUF0dHJpYnV0ZXNMaXN0ICkge1xyXG5cclxuXHRcdFx0XHRfZ2wuZGVsZXRlQnVmZmVyKCBnZW9tZXRyeS5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3RbIGlkIF0uYnVmZmVyICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBCdWZmZXIgaW5pdGlhbGl6YXRpb25cclxuXHJcblx0ZnVuY3Rpb24gaW5pdEN1c3RvbUF0dHJpYnV0ZXMgKCBnZW9tZXRyeSwgb2JqZWN0ICkge1xyXG5cclxuXHRcdHZhciBudmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGg7XHJcblxyXG5cdFx0dmFyIG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwuYXR0cmlidXRlcyApIHtcclxuXHJcblx0XHRcdGlmICggZ2VvbWV0cnkuX193ZWJnbEN1c3RvbUF0dHJpYnV0ZXNMaXN0ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5Ll9fd2ViZ2xDdXN0b21BdHRyaWJ1dGVzTGlzdCA9IFtdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Zm9yICggdmFyIGEgaW4gbWF0ZXJpYWwuYXR0cmlidXRlcyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGF0dHJpYnV0ZSA9IG1hdGVyaWFsLmF0dHJpYnV0ZXNbIGEgXTtcclxuXHJcblx0XHRcdFx0aWYgKCAhYXR0cmlidXRlLl9fd2ViZ2xJbml0aWFsaXplZCB8fCBhdHRyaWJ1dGUuY3JlYXRlVW5pcXVlQnVmZmVycyApIHtcclxuXHJcblx0XHRcdFx0XHRhdHRyaWJ1dGUuX193ZWJnbEluaXRpYWxpemVkID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0XHR2YXIgc2l6ZSA9IDE7XHRcdC8vIFwiZlwiIGFuZCBcImlcIlxyXG5cclxuXHRcdFx0XHRcdGlmICggYXR0cmlidXRlLnR5cGUgPT09IFwidjJcIiApIHNpemUgPSAyO1xyXG5cdFx0XHRcdFx0ZWxzZSBpZiAoIGF0dHJpYnV0ZS50eXBlID09PSBcInYzXCIgKSBzaXplID0gMztcclxuXHRcdFx0XHRcdGVsc2UgaWYgKCBhdHRyaWJ1dGUudHlwZSA9PT0gXCJ2NFwiICkgc2l6ZSA9IDQ7XHJcblx0XHRcdFx0XHRlbHNlIGlmICggYXR0cmlidXRlLnR5cGUgPT09IFwiY1wiICApIHNpemUgPSAzO1xyXG5cclxuXHRcdFx0XHRcdGF0dHJpYnV0ZS5zaXplID0gc2l6ZTtcclxuXHJcblx0XHRcdFx0XHRhdHRyaWJ1dGUuYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBudmVydGljZXMgKiBzaXplICk7XHJcblxyXG5cdFx0XHRcdFx0YXR0cmlidXRlLmJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcclxuXHRcdFx0XHRcdGF0dHJpYnV0ZS5idWZmZXIuYmVsb25nc1RvQXR0cmlidXRlID0gYTtcclxuXHJcblx0XHRcdFx0XHRhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5Ll9fd2ViZ2xDdXN0b21BdHRyaWJ1dGVzTGlzdC5wdXNoKCBhdHRyaWJ1dGUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGluaXRQYXJ0aWNsZUJ1ZmZlcnMgKCBnZW9tZXRyeSwgb2JqZWN0ICkge1xyXG5cclxuXHRcdHZhciBudmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGg7XHJcblxyXG5cdFx0Z2VvbWV0cnkuX192ZXJ0ZXhBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIG52ZXJ0aWNlcyAqIDMgKTtcclxuXHRcdGdlb21ldHJ5Ll9fY29sb3JBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIG52ZXJ0aWNlcyAqIDMgKTtcclxuXHJcblx0XHRnZW9tZXRyeS5fX3NvcnRBcnJheSA9IFtdO1xyXG5cclxuXHRcdGdlb21ldHJ5Ll9fd2ViZ2xQYXJ0aWNsZUNvdW50ID0gbnZlcnRpY2VzO1xyXG5cclxuXHRcdGluaXRDdXN0b21BdHRyaWJ1dGVzICggZ2VvbWV0cnksIG9iamVjdCApO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBpbml0TGluZUJ1ZmZlcnMgKCBnZW9tZXRyeSwgb2JqZWN0ICkge1xyXG5cclxuXHRcdHZhciBudmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGg7XHJcblxyXG5cdFx0Z2VvbWV0cnkuX192ZXJ0ZXhBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIG52ZXJ0aWNlcyAqIDMgKTtcclxuXHRcdGdlb21ldHJ5Ll9fY29sb3JBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIG52ZXJ0aWNlcyAqIDMgKTtcclxuXHRcdGdlb21ldHJ5Ll9fbGluZURpc3RhbmNlQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBudmVydGljZXMgKiAxICk7XHJcblxyXG5cdFx0Z2VvbWV0cnkuX193ZWJnbExpbmVDb3VudCA9IG52ZXJ0aWNlcztcclxuXHJcblx0XHRpbml0Q3VzdG9tQXR0cmlidXRlcyAoIGdlb21ldHJ5LCBvYmplY3QgKTtcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gaW5pdFJpYmJvbkJ1ZmZlcnMgKCBnZW9tZXRyeSwgb2JqZWN0ICkge1xyXG5cclxuXHRcdHZhciBudmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGg7XHJcblxyXG5cdFx0Z2VvbWV0cnkuX192ZXJ0ZXhBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIG52ZXJ0aWNlcyAqIDMgKTtcclxuXHRcdGdlb21ldHJ5Ll9fY29sb3JBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIG52ZXJ0aWNlcyAqIDMgKTtcclxuXHRcdGdlb21ldHJ5Ll9fbm9ybWFsQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBudmVydGljZXMgKiAzICk7XHJcblxyXG5cdFx0Z2VvbWV0cnkuX193ZWJnbFZlcnRleENvdW50ID0gbnZlcnRpY2VzO1xyXG5cclxuXHRcdGluaXRDdXN0b21BdHRyaWJ1dGVzICggZ2VvbWV0cnksIG9iamVjdCApO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBpbml0TWVzaEJ1ZmZlcnMgKCBnZW9tZXRyeUdyb3VwLCBvYmplY3QgKSB7XHJcblxyXG5cdFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5LFxyXG5cdFx0XHRmYWNlczMgPSBnZW9tZXRyeUdyb3VwLmZhY2VzMyxcclxuXHRcdFx0ZmFjZXM0ID0gZ2VvbWV0cnlHcm91cC5mYWNlczQsXHJcblxyXG5cdFx0XHRudmVydGljZXMgPSBmYWNlczMubGVuZ3RoICogMyArIGZhY2VzNC5sZW5ndGggKiA0LFxyXG5cdFx0XHRudHJpcyAgICAgPSBmYWNlczMubGVuZ3RoICogMSArIGZhY2VzNC5sZW5ndGggKiAyLFxyXG5cdFx0XHRubGluZXMgICAgPSBmYWNlczMubGVuZ3RoICogMyArIGZhY2VzNC5sZW5ndGggKiA0LFxyXG5cclxuXHRcdFx0bWF0ZXJpYWwgPSBnZXRCdWZmZXJNYXRlcmlhbCggb2JqZWN0LCBnZW9tZXRyeUdyb3VwICksXHJcblxyXG5cdFx0XHR1dlR5cGUgPSBidWZmZXJHdWVzc1VWVHlwZSggbWF0ZXJpYWwgKSxcclxuXHRcdFx0bm9ybWFsVHlwZSA9IGJ1ZmZlckd1ZXNzTm9ybWFsVHlwZSggbWF0ZXJpYWwgKSxcclxuXHRcdFx0dmVydGV4Q29sb3JUeXBlID0gYnVmZmVyR3Vlc3NWZXJ0ZXhDb2xvclR5cGUoIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0Ly9jb25zb2xlLmxvZyggXCJ1dlR5cGVcIiwgdXZUeXBlLCBcIm5vcm1hbFR5cGVcIiwgbm9ybWFsVHlwZSwgXCJ2ZXJ0ZXhDb2xvclR5cGVcIiwgdmVydGV4Q29sb3JUeXBlLCBvYmplY3QsIGdlb21ldHJ5R3JvdXAsIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0Z2VvbWV0cnlHcm91cC5fX3ZlcnRleEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggbnZlcnRpY2VzICogMyApO1xyXG5cclxuXHRcdGlmICggbm9ybWFsVHlwZSApIHtcclxuXHJcblx0XHRcdGdlb21ldHJ5R3JvdXAuX19ub3JtYWxBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIG52ZXJ0aWNlcyAqIDMgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS5oYXNUYW5nZW50cyApIHtcclxuXHJcblx0XHRcdGdlb21ldHJ5R3JvdXAuX190YW5nZW50QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBudmVydGljZXMgKiA0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdmVydGV4Q29sb3JUeXBlICkge1xyXG5cclxuXHRcdFx0Z2VvbWV0cnlHcm91cC5fX2NvbG9yQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBudmVydGljZXMgKiAzICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdXZUeXBlICkge1xyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyeS5mYWNlVXZzLmxlbmd0aCA+IDAgfHwgZ2VvbWV0cnkuZmFjZVZlcnRleFV2cy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0XHRnZW9tZXRyeUdyb3VwLl9fdXZBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIG52ZXJ0aWNlcyAqIDIgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggZ2VvbWV0cnkuZmFjZVV2cy5sZW5ndGggPiAxIHx8IGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnMubGVuZ3RoID4gMSApIHtcclxuXHJcblx0XHRcdFx0Z2VvbWV0cnlHcm91cC5fX3V2MkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggbnZlcnRpY2VzICogMiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG9iamVjdC5nZW9tZXRyeS5za2luV2VpZ2h0cy5sZW5ndGggJiYgb2JqZWN0Lmdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCApIHtcclxuXHJcblx0XHRcdGdlb21ldHJ5R3JvdXAuX19za2luSW5kZXhBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIG52ZXJ0aWNlcyAqIDQgKTtcclxuXHRcdFx0Z2VvbWV0cnlHcm91cC5fX3NraW5XZWlnaHRBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIG52ZXJ0aWNlcyAqIDQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Z2VvbWV0cnlHcm91cC5fX2ZhY2VBcnJheSA9IG5ldyBVaW50MTZBcnJheSggbnRyaXMgKiAzICk7XHJcblx0XHRnZW9tZXRyeUdyb3VwLl9fbGluZUFycmF5ID0gbmV3IFVpbnQxNkFycmF5KCBubGluZXMgKiAyICk7XHJcblxyXG5cdFx0dmFyIG0sIG1sO1xyXG5cclxuXHRcdGlmICggZ2VvbWV0cnlHcm91cC5udW1Nb3JwaFRhcmdldHMgKSB7XHJcblxyXG5cdFx0XHRnZW9tZXRyeUdyb3VwLl9fbW9ycGhUYXJnZXRzQXJyYXlzID0gW107XHJcblxyXG5cdFx0XHRmb3IgKCBtID0gMCwgbWwgPSBnZW9tZXRyeUdyb3VwLm51bU1vcnBoVGFyZ2V0czsgbSA8IG1sOyBtICsrICkge1xyXG5cclxuXHRcdFx0XHRnZW9tZXRyeUdyb3VwLl9fbW9ycGhUYXJnZXRzQXJyYXlzLnB1c2goIG5ldyBGbG9hdDMyQXJyYXkoIG52ZXJ0aWNlcyAqIDMgKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5R3JvdXAubnVtTW9ycGhOb3JtYWxzICkge1xyXG5cclxuXHRcdFx0Z2VvbWV0cnlHcm91cC5fX21vcnBoTm9ybWFsc0FycmF5cyA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yICggbSA9IDAsIG1sID0gZ2VvbWV0cnlHcm91cC5udW1Nb3JwaE5vcm1hbHM7IG0gPCBtbDsgbSArKyApIHtcclxuXHJcblx0XHRcdFx0Z2VvbWV0cnlHcm91cC5fX21vcnBoTm9ybWFsc0FycmF5cy5wdXNoKCBuZXcgRmxvYXQzMkFycmF5KCBudmVydGljZXMgKiAzICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Z2VvbWV0cnlHcm91cC5fX3dlYmdsRmFjZUNvdW50ID0gbnRyaXMgKiAzO1xyXG5cdFx0Z2VvbWV0cnlHcm91cC5fX3dlYmdsTGluZUNvdW50ID0gbmxpbmVzICogMjtcclxuXHJcblxyXG5cdFx0Ly8gY3VzdG9tIGF0dHJpYnV0ZXNcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLmF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGdlb21ldHJ5R3JvdXAuX193ZWJnbEN1c3RvbUF0dHJpYnV0ZXNMaXN0ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5R3JvdXAuX193ZWJnbEN1c3RvbUF0dHJpYnV0ZXNMaXN0ID0gW107XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgYSBpbiBtYXRlcmlhbC5hdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdFx0XHQvLyBEbyBhIHNoYWxsb3cgY29weSBvZiB0aGUgYXR0cmlidXRlIG9iamVjdCBzbyBkaWZmZXJlbnQgZ2VvbWV0cnlHcm91cCBjaHVua3MgdXNlIGRpZmZlcmVudFxyXG5cdFx0XHRcdC8vIGF0dHJpYnV0ZSBidWZmZXJzIHdoaWNoIGFyZSBjb3JyZWN0bHkgaW5kZXhlZCBpbiB0aGUgc2V0TWVzaEJ1ZmZlcnMgZnVuY3Rpb25cclxuXHJcblx0XHRcdFx0dmFyIG9yaWdpbmFsQXR0cmlidXRlID0gbWF0ZXJpYWwuYXR0cmlidXRlc1sgYSBdO1xyXG5cclxuXHRcdFx0XHR2YXIgYXR0cmlidXRlID0ge307XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBwcm9wZXJ0eSBpbiBvcmlnaW5hbEF0dHJpYnV0ZSApIHtcclxuXHJcblx0XHRcdFx0XHRhdHRyaWJ1dGVbIHByb3BlcnR5IF0gPSBvcmlnaW5hbEF0dHJpYnV0ZVsgcHJvcGVydHkgXTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoICFhdHRyaWJ1dGUuX193ZWJnbEluaXRpYWxpemVkIHx8IGF0dHJpYnV0ZS5jcmVhdGVVbmlxdWVCdWZmZXJzICkge1xyXG5cclxuXHRcdFx0XHRcdGF0dHJpYnV0ZS5fX3dlYmdsSW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHRcdHZhciBzaXplID0gMTtcdFx0Ly8gXCJmXCIgYW5kIFwiaVwiXHJcblxyXG5cdFx0XHRcdFx0aWYoIGF0dHJpYnV0ZS50eXBlID09PSBcInYyXCIgKSBzaXplID0gMjtcclxuXHRcdFx0XHRcdGVsc2UgaWYoIGF0dHJpYnV0ZS50eXBlID09PSBcInYzXCIgKSBzaXplID0gMztcclxuXHRcdFx0XHRcdGVsc2UgaWYoIGF0dHJpYnV0ZS50eXBlID09PSBcInY0XCIgKSBzaXplID0gNDtcclxuXHRcdFx0XHRcdGVsc2UgaWYoIGF0dHJpYnV0ZS50eXBlID09PSBcImNcIiAgKSBzaXplID0gMztcclxuXHJcblx0XHRcdFx0XHRhdHRyaWJ1dGUuc2l6ZSA9IHNpemU7XHJcblxyXG5cdFx0XHRcdFx0YXR0cmlidXRlLmFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggbnZlcnRpY2VzICogc2l6ZSApO1xyXG5cclxuXHRcdFx0XHRcdGF0dHJpYnV0ZS5idWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblx0XHRcdFx0XHRhdHRyaWJ1dGUuYnVmZmVyLmJlbG9uZ3NUb0F0dHJpYnV0ZSA9IGE7XHJcblxyXG5cdFx0XHRcdFx0b3JpZ2luYWxBdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cdFx0XHRcdFx0YXR0cmlidXRlLl9fb3JpZ2luYWwgPSBvcmlnaW5hbEF0dHJpYnV0ZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRnZW9tZXRyeUdyb3VwLl9fd2ViZ2xDdXN0b21BdHRyaWJ1dGVzTGlzdC5wdXNoKCBhdHRyaWJ1dGUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Z2VvbWV0cnlHcm91cC5fX2luaXR0ZWRBcnJheXMgPSB0cnVlO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBnZXRCdWZmZXJNYXRlcmlhbCggb2JqZWN0LCBnZW9tZXRyeUdyb3VwICkge1xyXG5cclxuXHRcdHJldHVybiBvYmplY3QubWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsXHJcblx0XHRcdD8gb2JqZWN0Lm1hdGVyaWFsLm1hdGVyaWFsc1sgZ2VvbWV0cnlHcm91cC5tYXRlcmlhbEluZGV4IF1cclxuXHRcdFx0OiBvYmplY3QubWF0ZXJpYWw7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIG1hdGVyaWFsTmVlZHNTbW9vdGhOb3JtYWxzICggbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0cmV0dXJuIG1hdGVyaWFsICYmIG1hdGVyaWFsLnNoYWRpbmcgIT09IHVuZGVmaW5lZCAmJiBtYXRlcmlhbC5zaGFkaW5nID09PSBUSFJFRS5TbW9vdGhTaGFkaW5nO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBidWZmZXJHdWVzc05vcm1hbFR5cGUgKCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHQvLyBvbmx5IE1lc2hCYXNpY01hdGVyaWFsIGFuZCBNZXNoRGVwdGhNYXRlcmlhbCBkb24ndCBuZWVkIG5vcm1hbHNcclxuXHJcblx0XHRpZiAoICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCAmJiAhbWF0ZXJpYWwuZW52TWFwICkgfHwgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRGVwdGhNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbE5lZWRzU21vb3RoTm9ybWFscyggbWF0ZXJpYWwgKSApIHtcclxuXHJcblx0XHRcdHJldHVybiBUSFJFRS5TbW9vdGhTaGFkaW5nO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gVEhSRUUuRmxhdFNoYWRpbmc7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBidWZmZXJHdWVzc1ZlcnRleENvbG9yVHlwZSAoIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwudmVydGV4Q29sb3JzICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIG1hdGVyaWFsLnZlcnRleENvbG9ycztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBidWZmZXJHdWVzc1VWVHlwZSAoIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdC8vIG1hdGVyaWFsIG11c3QgdXNlIHNvbWUgdGV4dHVyZSB0byByZXF1aXJlIHV2c1xyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwubWFwIHx8IG1hdGVyaWFsLmxpZ2h0TWFwIHx8IG1hdGVyaWFsLmJ1bXBNYXAgfHwgbWF0ZXJpYWwubm9ybWFsTWFwIHx8IG1hdGVyaWFsLnNwZWN1bGFyTWFwIHx8IG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuU2hhZGVyTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvL1xyXG5cclxuXHRmdW5jdGlvbiBpbml0RGlyZWN0QnVmZmVycyggZ2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0dmFyIGEsIGF0dHJpYnV0ZSwgdHlwZTtcclxuXHJcblx0XHRmb3IgKCBhIGluIGdlb21ldHJ5LmF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGEgPT09IFwiaW5kZXhcIiApIHtcclxuXHJcblx0XHRcdFx0dHlwZSA9IF9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUjtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHR5cGUgPSBfZ2wuQVJSQVlfQlVGRkVSO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YXR0cmlidXRlID0gZ2VvbWV0cnkuYXR0cmlidXRlc1sgYSBdO1xyXG5cclxuXHRcdFx0YXR0cmlidXRlLmJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcclxuXHJcblx0XHRcdF9nbC5iaW5kQnVmZmVyKCB0eXBlLCBhdHRyaWJ1dGUuYnVmZmVyICk7XHJcblx0XHRcdF9nbC5idWZmZXJEYXRhKCB0eXBlLCBhdHRyaWJ1dGUuYXJyYXksIF9nbC5TVEFUSUNfRFJBVyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0Ly8gQnVmZmVyIHNldHRpbmdcclxuXHJcblx0ZnVuY3Rpb24gc2V0UGFydGljbGVCdWZmZXJzICggZ2VvbWV0cnksIGhpbnQsIG9iamVjdCApIHtcclxuXHJcblx0XHR2YXIgdiwgYywgdmVydGV4LCBvZmZzZXQsIGluZGV4LCBjb2xvcixcclxuXHJcblx0XHR2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzLFxyXG5cdFx0dmwgPSB2ZXJ0aWNlcy5sZW5ndGgsXHJcblxyXG5cdFx0Y29sb3JzID0gZ2VvbWV0cnkuY29sb3JzLFxyXG5cdFx0Y2wgPSBjb2xvcnMubGVuZ3RoLFxyXG5cclxuXHRcdHZlcnRleEFycmF5ID0gZ2VvbWV0cnkuX192ZXJ0ZXhBcnJheSxcclxuXHRcdGNvbG9yQXJyYXkgPSBnZW9tZXRyeS5fX2NvbG9yQXJyYXksXHJcblxyXG5cdFx0c29ydEFycmF5ID0gZ2VvbWV0cnkuX19zb3J0QXJyYXksXHJcblxyXG5cdFx0ZGlydHlWZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSxcclxuXHRcdGRpcnR5RWxlbWVudHMgPSBnZW9tZXRyeS5lbGVtZW50c05lZWRVcGRhdGUsXHJcblx0XHRkaXJ0eUNvbG9ycyA9IGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUsXHJcblxyXG5cdFx0Y3VzdG9tQXR0cmlidXRlcyA9IGdlb21ldHJ5Ll9fd2ViZ2xDdXN0b21BdHRyaWJ1dGVzTGlzdCxcclxuXHRcdGksIGlsLFxyXG5cdFx0YSwgY2EsIGNhbCwgdmFsdWUsXHJcblx0XHRjdXN0b21BdHRyaWJ1dGU7XHJcblxyXG5cdFx0aWYgKCBvYmplY3Quc29ydFBhcnRpY2xlcyApIHtcclxuXHJcblx0XHRcdF9wcm9qU2NyZWVuTWF0cml4UFMuY29weSggX3Byb2pTY3JlZW5NYXRyaXggKTtcclxuXHRcdFx0X3Byb2pTY3JlZW5NYXRyaXhQUy5tdWx0aXBseSggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0XHRmb3IgKCB2ID0gMDsgdiA8IHZsOyB2ICsrICkge1xyXG5cclxuXHRcdFx0XHR2ZXJ0ZXggPSB2ZXJ0aWNlc1sgdiBdO1xyXG5cclxuXHRcdFx0XHRfdmVjdG9yMy5jb3B5KCB2ZXJ0ZXggKTtcclxuXHRcdFx0XHRfdmVjdG9yMy5hcHBseVByb2plY3Rpb24oIF9wcm9qU2NyZWVuTWF0cml4UFMgKTtcclxuXHJcblx0XHRcdFx0c29ydEFycmF5WyB2IF0gPSBbIF92ZWN0b3IzLnosIHYgXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHNvcnRBcnJheS5zb3J0KCBudW1lcmljYWxTb3J0ICk7XHJcblxyXG5cdFx0XHRmb3IgKCB2ID0gMDsgdiA8IHZsOyB2ICsrICkge1xyXG5cclxuXHRcdFx0XHR2ZXJ0ZXggPSB2ZXJ0aWNlc1sgc29ydEFycmF5W3ZdWzFdIF07XHJcblxyXG5cdFx0XHRcdG9mZnNldCA9IHYgKiAzO1xyXG5cclxuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0IF0gICAgID0gdmVydGV4Lng7XHJcblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCArIDEgXSA9IHZlcnRleC55O1xyXG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgKyAyIF0gPSB2ZXJ0ZXguejtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAoIGMgPSAwOyBjIDwgY2w7IGMgKysgKSB7XHJcblxyXG5cdFx0XHRcdG9mZnNldCA9IGMgKiAzO1xyXG5cclxuXHRcdFx0XHRjb2xvciA9IGNvbG9yc1sgc29ydEFycmF5W2NdWzFdIF07XHJcblxyXG5cdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldCBdICAgICA9IGNvbG9yLnI7XHJcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0ICsgMSBdID0gY29sb3IuZztcclxuXHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXQgKyAyIF0gPSBjb2xvci5iO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBjdXN0b21BdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCBpID0gMCwgaWwgPSBjdXN0b21BdHRyaWJ1dGVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZSA9IGN1c3RvbUF0dHJpYnV0ZXNbIGkgXTtcclxuXHJcblx0XHRcdFx0XHRpZiAoICEgKCBjdXN0b21BdHRyaWJ1dGUuYm91bmRUbyA9PT0gdW5kZWZpbmVkIHx8IGN1c3RvbUF0dHJpYnV0ZS5ib3VuZFRvID09PSBcInZlcnRpY2VzXCIgKSApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRcdG9mZnNldCA9IDA7XHJcblxyXG5cdFx0XHRcdFx0Y2FsID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlLmxlbmd0aDtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZS5zaXplID09PSAxICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggY2EgPSAwOyBjYSA8IGNhbDsgY2EgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGluZGV4ID0gc29ydEFycmF5WyBjYSBdWyAxIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgY2EgXSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgaW5kZXggXTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjdXN0b21BdHRyaWJ1dGUuc2l6ZSA9PT0gMiApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGNhID0gMDsgY2EgPCBjYWw7IGNhICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpbmRleCA9IHNvcnRBcnJheVsgY2EgXVsgMSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgaW5kZXggXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgXSBcdD0gdmFsdWUueDtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDEgXSA9IHZhbHVlLnk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdG9mZnNldCArPSAyO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGN1c3RvbUF0dHJpYnV0ZS5zaXplID09PSAzICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBjdXN0b21BdHRyaWJ1dGUudHlwZSA9PT0gXCJjXCIgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGZvciAoIGNhID0gMDsgY2EgPCBjYWw7IGNhICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGluZGV4ID0gc29ydEFycmF5WyBjYSBdWyAxIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0dmFsdWUgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGluZGV4IF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgXSAgICAgPSB2YWx1ZS5yO1xyXG5cdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAxIF0gPSB2YWx1ZS5nO1xyXG5cdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAyIF0gPSB2YWx1ZS5iO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdG9mZnNldCArPSAzO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRmb3IgKCBjYSA9IDA7IGNhIDwgY2FsOyBjYSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRpbmRleCA9IHNvcnRBcnJheVsgY2EgXVsgMSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBpbmRleCBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0IF0gXHQ9IHZhbHVlLng7XHJcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDEgXSA9IHZhbHVlLnk7XHJcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDIgXSA9IHZhbHVlLno7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0b2Zmc2V0ICs9IDM7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjdXN0b21BdHRyaWJ1dGUuc2l6ZSA9PT0gNCApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGNhID0gMDsgY2EgPCBjYWw7IGNhICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpbmRleCA9IHNvcnRBcnJheVsgY2EgXVsgMSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgaW5kZXggXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgXSAgICAgID0gdmFsdWUueDtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDEgIF0gPSB2YWx1ZS55O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMiAgXSA9IHZhbHVlLno7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAzICBdID0gdmFsdWUudztcclxuXHJcblx0XHRcdFx0XHRcdFx0b2Zmc2V0ICs9IDQ7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGlmICggZGlydHlWZXJ0aWNlcyApIHtcclxuXHJcblx0XHRcdFx0Zm9yICggdiA9IDA7IHYgPCB2bDsgdiArKyApIHtcclxuXHJcblx0XHRcdFx0XHR2ZXJ0ZXggPSB2ZXJ0aWNlc1sgdiBdO1xyXG5cclxuXHRcdFx0XHRcdG9mZnNldCA9IHYgKiAzO1xyXG5cclxuXHRcdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgXSAgICAgPSB2ZXJ0ZXgueDtcclxuXHRcdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgKyAxIF0gPSB2ZXJ0ZXgueTtcclxuXHRcdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgKyAyIF0gPSB2ZXJ0ZXguejtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBkaXJ0eUNvbG9ycyApIHtcclxuXHJcblx0XHRcdFx0Zm9yICggYyA9IDA7IGMgPCBjbDsgYyArKyApIHtcclxuXHJcblx0XHRcdFx0XHRjb2xvciA9IGNvbG9yc1sgYyBdO1xyXG5cclxuXHRcdFx0XHRcdG9mZnNldCA9IGMgKiAzO1xyXG5cclxuXHRcdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldCBdICAgICA9IGNvbG9yLnI7XHJcblx0XHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXQgKyAxIF0gPSBjb2xvci5nO1xyXG5cdFx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0ICsgMiBdID0gY29sb3IuYjtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBjdXN0b21BdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCBpID0gMCwgaWwgPSBjdXN0b21BdHRyaWJ1dGVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZSA9IGN1c3RvbUF0dHJpYnV0ZXNbIGkgXTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSAmJlxyXG5cdFx0XHRcdFx0XHQgKCBjdXN0b21BdHRyaWJ1dGUuYm91bmRUbyA9PT0gdW5kZWZpbmVkIHx8XHJcblx0XHRcdFx0XHRcdCAgIGN1c3RvbUF0dHJpYnV0ZS5ib3VuZFRvID09PSBcInZlcnRpY2VzXCIpICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y2FsID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlLmxlbmd0aDtcclxuXHJcblx0XHRcdFx0XHRcdG9mZnNldCA9IDA7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZS5zaXplID09PSAxICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRmb3IgKCBjYSA9IDA7IGNhIDwgY2FsOyBjYSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIGNhIF0gPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGNhIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGN1c3RvbUF0dHJpYnV0ZS5zaXplID09PSAyICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRmb3IgKCBjYSA9IDA7IGNhIDwgY2FsOyBjYSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2EgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCBdIFx0PSB2YWx1ZS54O1xyXG5cdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAxIF0gPSB2YWx1ZS55O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdG9mZnNldCArPSAyO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjdXN0b21BdHRyaWJ1dGUuc2l6ZSA9PT0gMyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCBjdXN0b21BdHRyaWJ1dGUudHlwZSA9PT0gXCJjXCIgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Zm9yICggY2EgPSAwOyBjYSA8IGNhbDsgY2EgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2EgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0IF0gXHQ9IHZhbHVlLnI7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMSBdID0gdmFsdWUuZztcclxuXHRcdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAyIF0gPSB2YWx1ZS5iO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0b2Zmc2V0ICs9IDM7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGZvciAoIGNhID0gMDsgY2EgPCBjYWw7IGNhICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0dmFsdWUgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGNhIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCBdIFx0PSB2YWx1ZS54O1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDEgXSA9IHZhbHVlLnk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMiBdID0gdmFsdWUuejtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdG9mZnNldCArPSAzO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLnNpemUgPT09IDQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGZvciAoIGNhID0gMDsgY2EgPCBjYWw7IGNhICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBjYSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0IF0gICAgICA9IHZhbHVlLng7XHJcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDEgIF0gPSB2YWx1ZS55O1xyXG5cdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAyICBdID0gdmFsdWUuejtcclxuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMyAgXSA9IHZhbHVlLnc7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0b2Zmc2V0ICs9IDQ7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBkaXJ0eVZlcnRpY2VzIHx8IG9iamVjdC5zb3J0UGFydGljbGVzICkge1xyXG5cclxuXHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5Ll9fd2ViZ2xWZXJ0ZXhCdWZmZXIgKTtcclxuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIHZlcnRleEFycmF5LCBoaW50ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZGlydHlDb2xvcnMgfHwgb2JqZWN0LnNvcnRQYXJ0aWNsZXMgKSB7XHJcblxyXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnkuX193ZWJnbENvbG9yQnVmZmVyICk7XHJcblx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBjb2xvckFycmF5LCBoaW50ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggY3VzdG9tQXR0cmlidXRlcyApIHtcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IGN1c3RvbUF0dHJpYnV0ZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZSA9IGN1c3RvbUF0dHJpYnV0ZXNbIGkgXTtcclxuXHJcblx0XHRcdFx0aWYgKCBjdXN0b21BdHRyaWJ1dGUubmVlZHNVcGRhdGUgfHwgb2JqZWN0LnNvcnRQYXJ0aWNsZXMgKSB7XHJcblxyXG5cdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGN1c3RvbUF0dHJpYnV0ZS5idWZmZXIgKTtcclxuXHRcdFx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBjdXN0b21BdHRyaWJ1dGUuYXJyYXksIGhpbnQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIHNldExpbmVCdWZmZXJzICggZ2VvbWV0cnksIGhpbnQgKSB7XHJcblxyXG5cdFx0dmFyIHYsIGMsIGQsIHZlcnRleCwgb2Zmc2V0LCBjb2xvcixcclxuXHJcblx0XHR2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzLFxyXG5cdFx0Y29sb3JzID0gZ2VvbWV0cnkuY29sb3JzLFxyXG5cdFx0bGluZURpc3RhbmNlcyA9IGdlb21ldHJ5LmxpbmVEaXN0YW5jZXMsXHJcblxyXG5cdFx0dmwgPSB2ZXJ0aWNlcy5sZW5ndGgsXHJcblx0XHRjbCA9IGNvbG9ycy5sZW5ndGgsXHJcblx0XHRkbCA9IGxpbmVEaXN0YW5jZXMubGVuZ3RoLFxyXG5cclxuXHRcdHZlcnRleEFycmF5ID0gZ2VvbWV0cnkuX192ZXJ0ZXhBcnJheSxcclxuXHRcdGNvbG9yQXJyYXkgPSBnZW9tZXRyeS5fX2NvbG9yQXJyYXksXHJcblx0XHRsaW5lRGlzdGFuY2VBcnJheSA9IGdlb21ldHJ5Ll9fbGluZURpc3RhbmNlQXJyYXksXHJcblxyXG5cdFx0ZGlydHlWZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSxcclxuXHRcdGRpcnR5Q29sb3JzID0gZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSxcclxuXHRcdGRpcnR5TGluZURpc3RhbmNlcyA9IGdlb21ldHJ5LmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlLFxyXG5cclxuXHRcdGN1c3RvbUF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3QsXHJcblxyXG5cdFx0aSwgaWwsXHJcblx0XHRhLCBjYSwgY2FsLCB2YWx1ZSxcclxuXHRcdGN1c3RvbUF0dHJpYnV0ZTtcclxuXHJcblx0XHRpZiAoIGRpcnR5VmVydGljZXMgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCB2ID0gMDsgdiA8IHZsOyB2ICsrICkge1xyXG5cclxuXHRcdFx0XHR2ZXJ0ZXggPSB2ZXJ0aWNlc1sgdiBdO1xyXG5cclxuXHRcdFx0XHRvZmZzZXQgPSB2ICogMztcclxuXHJcblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCBdICAgICA9IHZlcnRleC54O1xyXG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgKyAxIF0gPSB2ZXJ0ZXgueTtcclxuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0ICsgMiBdID0gdmVydGV4Lno7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnkuX193ZWJnbFZlcnRleEJ1ZmZlciApO1xyXG5cdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgdmVydGV4QXJyYXksIGhpbnQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBkaXJ0eUNvbG9ycyApIHtcclxuXHJcblx0XHRcdGZvciAoIGMgPSAwOyBjIDwgY2w7IGMgKysgKSB7XHJcblxyXG5cdFx0XHRcdGNvbG9yID0gY29sb3JzWyBjIF07XHJcblxyXG5cdFx0XHRcdG9mZnNldCA9IGMgKiAzO1xyXG5cclxuXHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXQgXSAgICAgPSBjb2xvci5yO1xyXG5cdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldCArIDEgXSA9IGNvbG9yLmc7XHJcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0ICsgMiBdID0gY29sb3IuYjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeS5fX3dlYmdsQ29sb3JCdWZmZXIgKTtcclxuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIGNvbG9yQXJyYXksIGhpbnQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBkaXJ0eUxpbmVEaXN0YW5jZXMgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCBkID0gMDsgZCA8IGRsOyBkICsrICkge1xyXG5cclxuXHRcdFx0XHRsaW5lRGlzdGFuY2VBcnJheVsgZCBdID0gbGluZURpc3RhbmNlc1sgZCBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5Ll9fd2ViZ2xMaW5lRGlzdGFuY2VCdWZmZXIgKTtcclxuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIGxpbmVEaXN0YW5jZUFycmF5LCBoaW50ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggY3VzdG9tQXR0cmlidXRlcyApIHtcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IGN1c3RvbUF0dHJpYnV0ZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZSA9IGN1c3RvbUF0dHJpYnV0ZXNbIGkgXTtcclxuXHJcblx0XHRcdFx0aWYgKCBjdXN0b21BdHRyaWJ1dGUubmVlZHNVcGRhdGUgJiZcclxuXHRcdFx0XHRcdCAoIGN1c3RvbUF0dHJpYnV0ZS5ib3VuZFRvID09PSB1bmRlZmluZWQgfHxcclxuXHRcdFx0XHRcdCAgIGN1c3RvbUF0dHJpYnV0ZS5ib3VuZFRvID09PSBcInZlcnRpY2VzXCIgKSApIHtcclxuXHJcblx0XHRcdFx0XHRvZmZzZXQgPSAwO1xyXG5cclxuXHRcdFx0XHRcdGNhbCA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZS5sZW5ndGg7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBjdXN0b21BdHRyaWJ1dGUuc2l6ZSA9PT0gMSApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGNhID0gMDsgY2EgPCBjYWw7IGNhICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIGNhIF0gPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGNhIF07XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLnNpemUgPT09IDIgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCBjYSA9IDA7IGNhIDwgY2FsOyBjYSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dmFsdWUgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGNhIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0IF0gXHQ9IHZhbHVlLng7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAxIF0gPSB2YWx1ZS55O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRvZmZzZXQgKz0gMjtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjdXN0b21BdHRyaWJ1dGUuc2l6ZSA9PT0gMyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggY3VzdG9tQXR0cmlidXRlLnR5cGUgPT09IFwiY1wiICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRmb3IgKCBjYSA9IDA7IGNhIDwgY2FsOyBjYSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2EgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCBdIFx0PSB2YWx1ZS5yO1xyXG5cdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAxIF0gPSB2YWx1ZS5nO1xyXG5cdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAyIF0gPSB2YWx1ZS5iO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdG9mZnNldCArPSAzO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRmb3IgKCBjYSA9IDA7IGNhIDwgY2FsOyBjYSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2EgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCBdIFx0PSB2YWx1ZS54O1xyXG5cdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAxIF0gPSB2YWx1ZS55O1xyXG5cdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAyIF0gPSB2YWx1ZS56O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdG9mZnNldCArPSAzO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLnNpemUgPT09IDQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCBjYSA9IDA7IGNhIDwgY2FsOyBjYSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dmFsdWUgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGNhIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0IF0gXHQgPSB2YWx1ZS54O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMSAgXSA9IHZhbHVlLnk7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAyICBdID0gdmFsdWUuejtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDMgIF0gPSB2YWx1ZS53O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRvZmZzZXQgKz0gNDtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGN1c3RvbUF0dHJpYnV0ZS5idWZmZXIgKTtcclxuXHRcdFx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBjdXN0b21BdHRyaWJ1dGUuYXJyYXksIGhpbnQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gc2V0UmliYm9uQnVmZmVycyAoIGdlb21ldHJ5LCBoaW50ICkge1xyXG5cclxuXHRcdHZhciB2LCBjLCBuLCB2ZXJ0ZXgsIG9mZnNldCwgY29sb3IsIG5vcm1hbCxcclxuXHJcblx0XHRpLCBpbCwgY2EsIGNhbCwgY3VzdG9tQXR0cmlidXRlLCB2YWx1ZSxcclxuXHJcblx0XHR2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzLFxyXG5cdFx0Y29sb3JzID0gZ2VvbWV0cnkuY29sb3JzLFxyXG5cdFx0bm9ybWFscyA9IGdlb21ldHJ5Lm5vcm1hbHMsXHJcblxyXG5cdFx0dmwgPSB2ZXJ0aWNlcy5sZW5ndGgsXHJcblx0XHRjbCA9IGNvbG9ycy5sZW5ndGgsXHJcblx0XHRubCA9IG5vcm1hbHMubGVuZ3RoLFxyXG5cclxuXHRcdHZlcnRleEFycmF5ID0gZ2VvbWV0cnkuX192ZXJ0ZXhBcnJheSxcclxuXHRcdGNvbG9yQXJyYXkgPSBnZW9tZXRyeS5fX2NvbG9yQXJyYXksXHJcblx0XHRub3JtYWxBcnJheSA9IGdlb21ldHJ5Ll9fbm9ybWFsQXJyYXksXHJcblxyXG5cdFx0ZGlydHlWZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSxcclxuXHRcdGRpcnR5Q29sb3JzID0gZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSxcclxuXHRcdGRpcnR5Tm9ybWFscyA9IGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlLFxyXG5cclxuXHRcdGN1c3RvbUF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3Q7XHJcblxyXG5cdFx0aWYgKCBkaXJ0eVZlcnRpY2VzICkge1xyXG5cclxuXHRcdFx0Zm9yICggdiA9IDA7IHYgPCB2bDsgdiArKyApIHtcclxuXHJcblx0XHRcdFx0dmVydGV4ID0gdmVydGljZXNbIHYgXTtcclxuXHJcblx0XHRcdFx0b2Zmc2V0ID0gdiAqIDM7XHJcblxyXG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgXSAgICAgPSB2ZXJ0ZXgueDtcclxuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0ICsgMSBdID0gdmVydGV4Lnk7XHJcblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCArIDIgXSA9IHZlcnRleC56O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5Ll9fd2ViZ2xWZXJ0ZXhCdWZmZXIgKTtcclxuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIHZlcnRleEFycmF5LCBoaW50ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZGlydHlDb2xvcnMgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCBjID0gMDsgYyA8IGNsOyBjICsrICkge1xyXG5cclxuXHRcdFx0XHRjb2xvciA9IGNvbG9yc1sgYyBdO1xyXG5cclxuXHRcdFx0XHRvZmZzZXQgPSBjICogMztcclxuXHJcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0IF0gICAgID0gY29sb3IucjtcclxuXHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXQgKyAxIF0gPSBjb2xvci5nO1xyXG5cdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldCArIDIgXSA9IGNvbG9yLmI7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnkuX193ZWJnbENvbG9yQnVmZmVyICk7XHJcblx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBjb2xvckFycmF5LCBoaW50ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZGlydHlOb3JtYWxzICkge1xyXG5cclxuXHRcdFx0Zm9yICggbiA9IDA7IG4gPCBubDsgbiArKyApIHtcclxuXHJcblx0XHRcdFx0bm9ybWFsID0gbm9ybWFsc1sgbiBdO1xyXG5cclxuXHRcdFx0XHRvZmZzZXQgPSBuICogMztcclxuXHJcblx0XHRcdFx0bm9ybWFsQXJyYXlbIG9mZnNldCBdICAgICA9IG5vcm1hbC54O1xyXG5cdFx0XHRcdG5vcm1hbEFycmF5WyBvZmZzZXQgKyAxIF0gPSBub3JtYWwueTtcclxuXHRcdFx0XHRub3JtYWxBcnJheVsgb2Zmc2V0ICsgMiBdID0gbm9ybWFsLno7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnkuX193ZWJnbE5vcm1hbEJ1ZmZlciApO1xyXG5cdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgbm9ybWFsQXJyYXksIGhpbnQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBjdXN0b21BdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDAsIGlsID0gY3VzdG9tQXR0cmlidXRlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlID0gY3VzdG9tQXR0cmlidXRlc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSAmJlxyXG5cdFx0XHRcdFx0ICggY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09IHVuZGVmaW5lZCB8fFxyXG5cdFx0XHRcdFx0ICAgY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09IFwidmVydGljZXNcIiApICkge1xyXG5cclxuXHRcdFx0XHRcdG9mZnNldCA9IDA7XHJcblxyXG5cdFx0XHRcdFx0Y2FsID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlLmxlbmd0aDtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZS5zaXplID09PSAxICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggY2EgPSAwOyBjYSA8IGNhbDsgY2EgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgY2EgXSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2EgXTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjdXN0b21BdHRyaWJ1dGUuc2l6ZSA9PT0gMiApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGNhID0gMDsgY2EgPCBjYWw7IGNhICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2EgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgXSBcdD0gdmFsdWUueDtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDEgXSA9IHZhbHVlLnk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdG9mZnNldCArPSAyO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGN1c3RvbUF0dHJpYnV0ZS5zaXplID09PSAzICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBjdXN0b21BdHRyaWJ1dGUudHlwZSA9PT0gXCJjXCIgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGZvciAoIGNhID0gMDsgY2EgPCBjYWw7IGNhICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBjYSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0IF0gXHQ9IHZhbHVlLnI7XHJcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDEgXSA9IHZhbHVlLmc7XHJcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDIgXSA9IHZhbHVlLmI7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0b2Zmc2V0ICs9IDM7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGZvciAoIGNhID0gMDsgY2EgPCBjYWw7IGNhICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBjYSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0IF0gXHQ9IHZhbHVlLng7XHJcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDEgXSA9IHZhbHVlLnk7XHJcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDIgXSA9IHZhbHVlLno7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0b2Zmc2V0ICs9IDM7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjdXN0b21BdHRyaWJ1dGUuc2l6ZSA9PT0gNCApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGNhID0gMDsgY2EgPCBjYWw7IGNhICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2EgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgXSBcdCA9IHZhbHVlLng7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAxICBdID0gdmFsdWUueTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDIgIF0gPSB2YWx1ZS56O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMyAgXSA9IHZhbHVlLnc7XHJcblxyXG5cdFx0XHRcdFx0XHRcdG9mZnNldCArPSA0O1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgY3VzdG9tQXR0cmlidXRlLmJ1ZmZlciApO1xyXG5cdFx0XHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIGN1c3RvbUF0dHJpYnV0ZS5hcnJheSwgaGludCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBzZXRNZXNoQnVmZmVycyggZ2VvbWV0cnlHcm91cCwgb2JqZWN0LCBoaW50LCBkaXNwb3NlLCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHRpZiAoICEgZ2VvbWV0cnlHcm91cC5fX2luaXR0ZWRBcnJheXMgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBub3JtYWxUeXBlID0gYnVmZmVyR3Vlc3NOb3JtYWxUeXBlKCBtYXRlcmlhbCApLFxyXG5cdFx0dmVydGV4Q29sb3JUeXBlID0gYnVmZmVyR3Vlc3NWZXJ0ZXhDb2xvclR5cGUoIG1hdGVyaWFsICksXHJcblx0XHR1dlR5cGUgPSBidWZmZXJHdWVzc1VWVHlwZSggbWF0ZXJpYWwgKSxcclxuXHJcblx0XHRuZWVkc1Ntb290aE5vcm1hbHMgPSAoIG5vcm1hbFR5cGUgPT09IFRIUkVFLlNtb290aFNoYWRpbmcgKTtcclxuXHJcblx0XHR2YXIgZiwgZmwsIGZpLCBmYWNlLFxyXG5cdFx0dmVydGV4Tm9ybWFscywgZmFjZU5vcm1hbCwgbm9ybWFsLFxyXG5cdFx0dmVydGV4Q29sb3JzLCBmYWNlQ29sb3IsXHJcblx0XHR2ZXJ0ZXhUYW5nZW50cyxcclxuXHRcdHV2LCB1djIsIHYxLCB2MiwgdjMsIHY0LCB0MSwgdDIsIHQzLCB0NCwgbjEsIG4yLCBuMywgbjQsXHJcblx0XHRjMSwgYzIsIGMzLCBjNCxcclxuXHRcdHN3MSwgc3cyLCBzdzMsIHN3NCxcclxuXHRcdHNpMSwgc2kyLCBzaTMsIHNpNCxcclxuXHRcdHNhMSwgc2EyLCBzYTMsIHNhNCxcclxuXHRcdHNiMSwgc2IyLCBzYjMsIHNiNCxcclxuXHRcdG0sIG1sLCBpLCBpbCxcclxuXHRcdHZuLCB1dmksIHV2MmksXHJcblx0XHR2aywgdmtsLCB2a2EsXHJcblx0XHRua2EsIGNoZiwgZmFjZVZlcnRleE5vcm1hbHMsXHJcblx0XHRhLFxyXG5cclxuXHRcdHZlcnRleEluZGV4ID0gMCxcclxuXHJcblx0XHRvZmZzZXQgPSAwLFxyXG5cdFx0b2Zmc2V0X3V2ID0gMCxcclxuXHRcdG9mZnNldF91djIgPSAwLFxyXG5cdFx0b2Zmc2V0X2ZhY2UgPSAwLFxyXG5cdFx0b2Zmc2V0X25vcm1hbCA9IDAsXHJcblx0XHRvZmZzZXRfdGFuZ2VudCA9IDAsXHJcblx0XHRvZmZzZXRfbGluZSA9IDAsXHJcblx0XHRvZmZzZXRfY29sb3IgPSAwLFxyXG5cdFx0b2Zmc2V0X3NraW4gPSAwLFxyXG5cdFx0b2Zmc2V0X21vcnBoVGFyZ2V0ID0gMCxcclxuXHRcdG9mZnNldF9jdXN0b20gPSAwLFxyXG5cdFx0b2Zmc2V0X2N1c3RvbVNyYyA9IDAsXHJcblxyXG5cdFx0dmFsdWUsXHJcblxyXG5cdFx0dmVydGV4QXJyYXkgPSBnZW9tZXRyeUdyb3VwLl9fdmVydGV4QXJyYXksXHJcblx0XHR1dkFycmF5ID0gZ2VvbWV0cnlHcm91cC5fX3V2QXJyYXksXHJcblx0XHR1djJBcnJheSA9IGdlb21ldHJ5R3JvdXAuX191djJBcnJheSxcclxuXHRcdG5vcm1hbEFycmF5ID0gZ2VvbWV0cnlHcm91cC5fX25vcm1hbEFycmF5LFxyXG5cdFx0dGFuZ2VudEFycmF5ID0gZ2VvbWV0cnlHcm91cC5fX3RhbmdlbnRBcnJheSxcclxuXHRcdGNvbG9yQXJyYXkgPSBnZW9tZXRyeUdyb3VwLl9fY29sb3JBcnJheSxcclxuXHJcblx0XHRza2luSW5kZXhBcnJheSA9IGdlb21ldHJ5R3JvdXAuX19za2luSW5kZXhBcnJheSxcclxuXHRcdHNraW5XZWlnaHRBcnJheSA9IGdlb21ldHJ5R3JvdXAuX19za2luV2VpZ2h0QXJyYXksXHJcblxyXG5cdFx0bW9ycGhUYXJnZXRzQXJyYXlzID0gZ2VvbWV0cnlHcm91cC5fX21vcnBoVGFyZ2V0c0FycmF5cyxcclxuXHRcdG1vcnBoTm9ybWFsc0FycmF5cyA9IGdlb21ldHJ5R3JvdXAuX19tb3JwaE5vcm1hbHNBcnJheXMsXHJcblxyXG5cdFx0Y3VzdG9tQXR0cmlidXRlcyA9IGdlb21ldHJ5R3JvdXAuX193ZWJnbEN1c3RvbUF0dHJpYnV0ZXNMaXN0LFxyXG5cdFx0Y3VzdG9tQXR0cmlidXRlLFxyXG5cclxuXHRcdGZhY2VBcnJheSA9IGdlb21ldHJ5R3JvdXAuX19mYWNlQXJyYXksXHJcblx0XHRsaW5lQXJyYXkgPSBnZW9tZXRyeUdyb3VwLl9fbGluZUFycmF5LFxyXG5cclxuXHRcdGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5LCAvLyB0aGlzIGlzIHNoYXJlZCBmb3IgYWxsIGNodW5rc1xyXG5cclxuXHRcdGRpcnR5VmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUsXHJcblx0XHRkaXJ0eUVsZW1lbnRzID0gZ2VvbWV0cnkuZWxlbWVudHNOZWVkVXBkYXRlLFxyXG5cdFx0ZGlydHlVdnMgPSBnZW9tZXRyeS51dnNOZWVkVXBkYXRlLFxyXG5cdFx0ZGlydHlOb3JtYWxzID0gZ2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGUsXHJcblx0XHRkaXJ0eVRhbmdlbnRzID0gZ2VvbWV0cnkudGFuZ2VudHNOZWVkVXBkYXRlLFxyXG5cdFx0ZGlydHlDb2xvcnMgPSBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlLFxyXG5cdFx0ZGlydHlNb3JwaFRhcmdldHMgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNOZWVkVXBkYXRlLFxyXG5cclxuXHRcdHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXMsXHJcblx0XHRjaHVua19mYWNlczMgPSBnZW9tZXRyeUdyb3VwLmZhY2VzMyxcclxuXHRcdGNodW5rX2ZhY2VzNCA9IGdlb21ldHJ5R3JvdXAuZmFjZXM0LFxyXG5cdFx0b2JqX2ZhY2VzID0gZ2VvbWV0cnkuZmFjZXMsXHJcblxyXG5cdFx0b2JqX3V2cyAgPSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyAwIF0sXHJcblx0XHRvYmpfdXZzMiA9IGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIDEgXSxcclxuXHJcblx0XHRvYmpfY29sb3JzID0gZ2VvbWV0cnkuY29sb3JzLFxyXG5cclxuXHRcdG9ial9za2luSW5kaWNlcyA9IGdlb21ldHJ5LnNraW5JbmRpY2VzLFxyXG5cdFx0b2JqX3NraW5XZWlnaHRzID0gZ2VvbWV0cnkuc2tpbldlaWdodHMsXHJcblxyXG5cdFx0bW9ycGhUYXJnZXRzID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzLFxyXG5cdFx0bW9ycGhOb3JtYWxzID0gZ2VvbWV0cnkubW9ycGhOb3JtYWxzO1xyXG5cclxuXHRcdGlmICggZGlydHlWZXJ0aWNlcyApIHtcclxuXHJcblx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzMy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0ZmFjZSA9IG9ial9mYWNlc1sgY2h1bmtfZmFjZXMzWyBmIF0gXTtcclxuXHJcblx0XHRcdFx0djEgPSB2ZXJ0aWNlc1sgZmFjZS5hIF07XHJcblx0XHRcdFx0djIgPSB2ZXJ0aWNlc1sgZmFjZS5iIF07XHJcblx0XHRcdFx0djMgPSB2ZXJ0aWNlc1sgZmFjZS5jIF07XHJcblxyXG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgXSAgICAgPSB2MS54O1xyXG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgKyAxIF0gPSB2MS55O1xyXG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgKyAyIF0gPSB2MS56O1xyXG5cclxuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0ICsgMyBdID0gdjIueDtcclxuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0ICsgNCBdID0gdjIueTtcclxuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0ICsgNSBdID0gdjIuejtcclxuXHJcblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCArIDYgXSA9IHYzLng7XHJcblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCArIDcgXSA9IHYzLnk7XHJcblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCArIDggXSA9IHYzLno7XHJcblxyXG5cdFx0XHRcdG9mZnNldCArPSA5O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXM0Lmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRmYWNlID0gb2JqX2ZhY2VzWyBjaHVua19mYWNlczRbIGYgXSBdO1xyXG5cclxuXHRcdFx0XHR2MSA9IHZlcnRpY2VzWyBmYWNlLmEgXTtcclxuXHRcdFx0XHR2MiA9IHZlcnRpY2VzWyBmYWNlLmIgXTtcclxuXHRcdFx0XHR2MyA9IHZlcnRpY2VzWyBmYWNlLmMgXTtcclxuXHRcdFx0XHR2NCA9IHZlcnRpY2VzWyBmYWNlLmQgXTtcclxuXHJcblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCBdICAgICA9IHYxLng7XHJcblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCArIDEgXSA9IHYxLnk7XHJcblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCArIDIgXSA9IHYxLno7XHJcblxyXG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgKyAzIF0gPSB2Mi54O1xyXG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgKyA0IF0gPSB2Mi55O1xyXG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgKyA1IF0gPSB2Mi56O1xyXG5cclxuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0ICsgNiBdID0gdjMueDtcclxuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0ICsgNyBdID0gdjMueTtcclxuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0ICsgOCBdID0gdjMuejtcclxuXHJcblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCArIDkgXSAgPSB2NC54O1xyXG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgKyAxMCBdID0gdjQueTtcclxuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0ICsgMTEgXSA9IHY0Lno7XHJcblxyXG5cdFx0XHRcdG9mZnNldCArPSAxMjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xWZXJ0ZXhCdWZmZXIgKTtcclxuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIHZlcnRleEFycmF5LCBoaW50ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZGlydHlNb3JwaFRhcmdldHMgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCB2ayA9IDAsIHZrbCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7IHZrIDwgdmtsOyB2ayArKyApIHtcclxuXHJcblx0XHRcdFx0b2Zmc2V0X21vcnBoVGFyZ2V0ID0gMDtcclxuXHJcblx0XHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXMzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGNoZiA9IGNodW5rX2ZhY2VzM1sgZiBdO1xyXG5cdFx0XHRcdFx0ZmFjZSA9IG9ial9mYWNlc1sgY2hmIF07XHJcblxyXG5cdFx0XHRcdFx0Ly8gbW9ycGggcG9zaXRpb25zXHJcblxyXG5cdFx0XHRcdFx0djEgPSBtb3JwaFRhcmdldHNbIHZrIF0udmVydGljZXNbIGZhY2UuYSBdO1xyXG5cdFx0XHRcdFx0djIgPSBtb3JwaFRhcmdldHNbIHZrIF0udmVydGljZXNbIGZhY2UuYiBdO1xyXG5cdFx0XHRcdFx0djMgPSBtb3JwaFRhcmdldHNbIHZrIF0udmVydGljZXNbIGZhY2UuYyBdO1xyXG5cclxuXHRcdFx0XHRcdHZrYSA9IG1vcnBoVGFyZ2V0c0FycmF5c1sgdmsgXTtcclxuXHJcblx0XHRcdFx0XHR2a2FbIG9mZnNldF9tb3JwaFRhcmdldCBdIFx0ICA9IHYxLng7XHJcblx0XHRcdFx0XHR2a2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDEgXSA9IHYxLnk7XHJcblx0XHRcdFx0XHR2a2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDIgXSA9IHYxLno7XHJcblxyXG5cdFx0XHRcdFx0dmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyAzIF0gPSB2Mi54O1xyXG5cdFx0XHRcdFx0dmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyA0IF0gPSB2Mi55O1xyXG5cdFx0XHRcdFx0dmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyA1IF0gPSB2Mi56O1xyXG5cclxuXHRcdFx0XHRcdHZrYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgNiBdID0gdjMueDtcclxuXHRcdFx0XHRcdHZrYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgNyBdID0gdjMueTtcclxuXHRcdFx0XHRcdHZrYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgOCBdID0gdjMuejtcclxuXHJcblx0XHRcdFx0XHQvLyBtb3JwaCBub3JtYWxzXHJcblxyXG5cdFx0XHRcdFx0aWYgKCBtYXRlcmlhbC5tb3JwaE5vcm1hbHMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIG5lZWRzU21vb3RoTm9ybWFscyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0ZmFjZVZlcnRleE5vcm1hbHMgPSBtb3JwaE5vcm1hbHNbIHZrIF0udmVydGV4Tm9ybWFsc1sgY2hmIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdG4xID0gZmFjZVZlcnRleE5vcm1hbHMuYTtcclxuXHRcdFx0XHRcdFx0XHRuMiA9IGZhY2VWZXJ0ZXhOb3JtYWxzLmI7XHJcblx0XHRcdFx0XHRcdFx0bjMgPSBmYWNlVmVydGV4Tm9ybWFscy5jO1xyXG5cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0bjEgPSBtb3JwaE5vcm1hbHNbIHZrIF0uZmFjZU5vcm1hbHNbIGNoZiBdO1xyXG5cdFx0XHRcdFx0XHRcdG4yID0gbjE7XHJcblx0XHRcdFx0XHRcdFx0bjMgPSBuMTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdG5rYSA9IG1vcnBoTm9ybWFsc0FycmF5c1sgdmsgXTtcclxuXHJcblx0XHRcdFx0XHRcdG5rYVsgb2Zmc2V0X21vcnBoVGFyZ2V0IF0gXHQgID0gbjEueDtcclxuXHRcdFx0XHRcdFx0bmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyAxIF0gPSBuMS55O1xyXG5cdFx0XHRcdFx0XHRua2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDIgXSA9IG4xLno7XHJcblxyXG5cdFx0XHRcdFx0XHRua2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDMgXSA9IG4yLng7XHJcblx0XHRcdFx0XHRcdG5rYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgNCBdID0gbjIueTtcclxuXHRcdFx0XHRcdFx0bmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyA1IF0gPSBuMi56O1xyXG5cclxuXHRcdFx0XHRcdFx0bmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyA2IF0gPSBuMy54O1xyXG5cdFx0XHRcdFx0XHRua2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDcgXSA9IG4zLnk7XHJcblx0XHRcdFx0XHRcdG5rYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgOCBdID0gbjMuejtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Ly9cclxuXHJcblx0XHRcdFx0XHRvZmZzZXRfbW9ycGhUYXJnZXQgKz0gOTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczQubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y2hmID0gY2h1bmtfZmFjZXM0WyBmIF07XHJcblx0XHRcdFx0XHRmYWNlID0gb2JqX2ZhY2VzWyBjaGYgXTtcclxuXHJcblx0XHRcdFx0XHQvLyBtb3JwaCBwb3NpdGlvbnNcclxuXHJcblx0XHRcdFx0XHR2MSA9IG1vcnBoVGFyZ2V0c1sgdmsgXS52ZXJ0aWNlc1sgZmFjZS5hIF07XHJcblx0XHRcdFx0XHR2MiA9IG1vcnBoVGFyZ2V0c1sgdmsgXS52ZXJ0aWNlc1sgZmFjZS5iIF07XHJcblx0XHRcdFx0XHR2MyA9IG1vcnBoVGFyZ2V0c1sgdmsgXS52ZXJ0aWNlc1sgZmFjZS5jIF07XHJcblx0XHRcdFx0XHR2NCA9IG1vcnBoVGFyZ2V0c1sgdmsgXS52ZXJ0aWNlc1sgZmFjZS5kIF07XHJcblxyXG5cdFx0XHRcdFx0dmthID0gbW9ycGhUYXJnZXRzQXJyYXlzWyB2ayBdO1xyXG5cclxuXHRcdFx0XHRcdHZrYVsgb2Zmc2V0X21vcnBoVGFyZ2V0IF0gXHQgID0gdjEueDtcclxuXHRcdFx0XHRcdHZrYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgMSBdID0gdjEueTtcclxuXHRcdFx0XHRcdHZrYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgMiBdID0gdjEuejtcclxuXHJcblx0XHRcdFx0XHR2a2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDMgXSA9IHYyLng7XHJcblx0XHRcdFx0XHR2a2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDQgXSA9IHYyLnk7XHJcblx0XHRcdFx0XHR2a2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDUgXSA9IHYyLno7XHJcblxyXG5cdFx0XHRcdFx0dmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyA2IF0gPSB2My54O1xyXG5cdFx0XHRcdFx0dmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyA3IF0gPSB2My55O1xyXG5cdFx0XHRcdFx0dmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyA4IF0gPSB2My56O1xyXG5cclxuXHRcdFx0XHRcdHZrYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgOSBdICA9IHY0Lng7XHJcblx0XHRcdFx0XHR2a2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDEwIF0gPSB2NC55O1xyXG5cdFx0XHRcdFx0dmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyAxMSBdID0gdjQuejtcclxuXHJcblx0XHRcdFx0XHQvLyBtb3JwaCBub3JtYWxzXHJcblxyXG5cdFx0XHRcdFx0aWYgKCBtYXRlcmlhbC5tb3JwaE5vcm1hbHMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIG5lZWRzU21vb3RoTm9ybWFscyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0ZmFjZVZlcnRleE5vcm1hbHMgPSBtb3JwaE5vcm1hbHNbIHZrIF0udmVydGV4Tm9ybWFsc1sgY2hmIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdG4xID0gZmFjZVZlcnRleE5vcm1hbHMuYTtcclxuXHRcdFx0XHRcdFx0XHRuMiA9IGZhY2VWZXJ0ZXhOb3JtYWxzLmI7XHJcblx0XHRcdFx0XHRcdFx0bjMgPSBmYWNlVmVydGV4Tm9ybWFscy5jO1xyXG5cdFx0XHRcdFx0XHRcdG40ID0gZmFjZVZlcnRleE5vcm1hbHMuZDtcclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdG4xID0gbW9ycGhOb3JtYWxzWyB2ayBdLmZhY2VOb3JtYWxzWyBjaGYgXTtcclxuXHRcdFx0XHRcdFx0XHRuMiA9IG4xO1xyXG5cdFx0XHRcdFx0XHRcdG4zID0gbjE7XHJcblx0XHRcdFx0XHRcdFx0bjQgPSBuMTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdG5rYSA9IG1vcnBoTm9ybWFsc0FycmF5c1sgdmsgXTtcclxuXHJcblx0XHRcdFx0XHRcdG5rYVsgb2Zmc2V0X21vcnBoVGFyZ2V0IF0gXHQgID0gbjEueDtcclxuXHRcdFx0XHRcdFx0bmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyAxIF0gPSBuMS55O1xyXG5cdFx0XHRcdFx0XHRua2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDIgXSA9IG4xLno7XHJcblxyXG5cdFx0XHRcdFx0XHRua2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDMgXSA9IG4yLng7XHJcblx0XHRcdFx0XHRcdG5rYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgNCBdID0gbjIueTtcclxuXHRcdFx0XHRcdFx0bmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyA1IF0gPSBuMi56O1xyXG5cclxuXHRcdFx0XHRcdFx0bmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyA2IF0gPSBuMy54O1xyXG5cdFx0XHRcdFx0XHRua2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDcgXSA9IG4zLnk7XHJcblx0XHRcdFx0XHRcdG5rYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgOCBdID0gbjMuejtcclxuXHJcblx0XHRcdFx0XHRcdG5rYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgOSBdICA9IG40Lng7XHJcblx0XHRcdFx0XHRcdG5rYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgMTAgXSA9IG40Lnk7XHJcblx0XHRcdFx0XHRcdG5rYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgMTEgXSA9IG40Lno7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdC8vXHJcblxyXG5cdFx0XHRcdFx0b2Zmc2V0X21vcnBoVGFyZ2V0ICs9IDEyO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xNb3JwaFRhcmdldHNCdWZmZXJzWyB2ayBdICk7XHJcblx0XHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIG1vcnBoVGFyZ2V0c0FycmF5c1sgdmsgXSwgaGludCApO1xyXG5cclxuXHRcdFx0XHRpZiAoIG1hdGVyaWFsLm1vcnBoTm9ybWFscyApIHtcclxuXHJcblx0XHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsTW9ycGhOb3JtYWxzQnVmZmVyc1sgdmsgXSApO1xyXG5cdFx0XHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIG1vcnBoTm9ybWFsc0FycmF5c1sgdmsgXSwgaGludCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggb2JqX3NraW5XZWlnaHRzLmxlbmd0aCApIHtcclxuXHJcblx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzMy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0ZmFjZSA9IG9ial9mYWNlc1sgY2h1bmtfZmFjZXMzWyBmIF1cdF07XHJcblxyXG5cdFx0XHRcdC8vIHdlaWdodHNcclxuXHJcblx0XHRcdFx0c3cxID0gb2JqX3NraW5XZWlnaHRzWyBmYWNlLmEgXTtcclxuXHRcdFx0XHRzdzIgPSBvYmpfc2tpbldlaWdodHNbIGZhY2UuYiBdO1xyXG5cdFx0XHRcdHN3MyA9IG9ial9za2luV2VpZ2h0c1sgZmFjZS5jIF07XHJcblxyXG5cdFx0XHRcdHNraW5XZWlnaHRBcnJheVsgb2Zmc2V0X3NraW4gXSAgICAgPSBzdzEueDtcclxuXHRcdFx0XHRza2luV2VpZ2h0QXJyYXlbIG9mZnNldF9za2luICsgMSBdID0gc3cxLnk7XHJcblx0XHRcdFx0c2tpbldlaWdodEFycmF5WyBvZmZzZXRfc2tpbiArIDIgXSA9IHN3MS56O1xyXG5cdFx0XHRcdHNraW5XZWlnaHRBcnJheVsgb2Zmc2V0X3NraW4gKyAzIF0gPSBzdzEudztcclxuXHJcblx0XHRcdFx0c2tpbldlaWdodEFycmF5WyBvZmZzZXRfc2tpbiArIDQgXSA9IHN3Mi54O1xyXG5cdFx0XHRcdHNraW5XZWlnaHRBcnJheVsgb2Zmc2V0X3NraW4gKyA1IF0gPSBzdzIueTtcclxuXHRcdFx0XHRza2luV2VpZ2h0QXJyYXlbIG9mZnNldF9za2luICsgNiBdID0gc3cyLno7XHJcblx0XHRcdFx0c2tpbldlaWdodEFycmF5WyBvZmZzZXRfc2tpbiArIDcgXSA9IHN3Mi53O1xyXG5cclxuXHRcdFx0XHRza2luV2VpZ2h0QXJyYXlbIG9mZnNldF9za2luICsgOCBdICA9IHN3My54O1xyXG5cdFx0XHRcdHNraW5XZWlnaHRBcnJheVsgb2Zmc2V0X3NraW4gKyA5IF0gID0gc3czLnk7XHJcblx0XHRcdFx0c2tpbldlaWdodEFycmF5WyBvZmZzZXRfc2tpbiArIDEwIF0gPSBzdzMuejtcclxuXHRcdFx0XHRza2luV2VpZ2h0QXJyYXlbIG9mZnNldF9za2luICsgMTEgXSA9IHN3My53O1xyXG5cclxuXHRcdFx0XHQvLyBpbmRpY2VzXHJcblxyXG5cdFx0XHRcdHNpMSA9IG9ial9za2luSW5kaWNlc1sgZmFjZS5hIF07XHJcblx0XHRcdFx0c2kyID0gb2JqX3NraW5JbmRpY2VzWyBmYWNlLmIgXTtcclxuXHRcdFx0XHRzaTMgPSBvYmpfc2tpbkluZGljZXNbIGZhY2UuYyBdO1xyXG5cclxuXHRcdFx0XHRza2luSW5kZXhBcnJheVsgb2Zmc2V0X3NraW4gXSAgICAgPSBzaTEueDtcclxuXHRcdFx0XHRza2luSW5kZXhBcnJheVsgb2Zmc2V0X3NraW4gKyAxIF0gPSBzaTEueTtcclxuXHRcdFx0XHRza2luSW5kZXhBcnJheVsgb2Zmc2V0X3NraW4gKyAyIF0gPSBzaTEuejtcclxuXHRcdFx0XHRza2luSW5kZXhBcnJheVsgb2Zmc2V0X3NraW4gKyAzIF0gPSBzaTEudztcclxuXHJcblx0XHRcdFx0c2tpbkluZGV4QXJyYXlbIG9mZnNldF9za2luICsgNCBdID0gc2kyLng7XHJcblx0XHRcdFx0c2tpbkluZGV4QXJyYXlbIG9mZnNldF9za2luICsgNSBdID0gc2kyLnk7XHJcblx0XHRcdFx0c2tpbkluZGV4QXJyYXlbIG9mZnNldF9za2luICsgNiBdID0gc2kyLno7XHJcblx0XHRcdFx0c2tpbkluZGV4QXJyYXlbIG9mZnNldF9za2luICsgNyBdID0gc2kyLnc7XHJcblxyXG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiArIDggXSAgPSBzaTMueDtcclxuXHRcdFx0XHRza2luSW5kZXhBcnJheVsgb2Zmc2V0X3NraW4gKyA5IF0gID0gc2kzLnk7XHJcblx0XHRcdFx0c2tpbkluZGV4QXJyYXlbIG9mZnNldF9za2luICsgMTAgXSA9IHNpMy56O1xyXG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiArIDExIF0gPSBzaTMudztcclxuXHJcblx0XHRcdFx0b2Zmc2V0X3NraW4gKz0gMTI7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczQubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2UgPSBvYmpfZmFjZXNbIGNodW5rX2ZhY2VzNFsgZiBdIF07XHJcblxyXG5cdFx0XHRcdC8vIHdlaWdodHNcclxuXHJcblx0XHRcdFx0c3cxID0gb2JqX3NraW5XZWlnaHRzWyBmYWNlLmEgXTtcclxuXHRcdFx0XHRzdzIgPSBvYmpfc2tpbldlaWdodHNbIGZhY2UuYiBdO1xyXG5cdFx0XHRcdHN3MyA9IG9ial9za2luV2VpZ2h0c1sgZmFjZS5jIF07XHJcblx0XHRcdFx0c3c0ID0gb2JqX3NraW5XZWlnaHRzWyBmYWNlLmQgXTtcclxuXHJcblx0XHRcdFx0c2tpbldlaWdodEFycmF5WyBvZmZzZXRfc2tpbiBdICAgICA9IHN3MS54O1xyXG5cdFx0XHRcdHNraW5XZWlnaHRBcnJheVsgb2Zmc2V0X3NraW4gKyAxIF0gPSBzdzEueTtcclxuXHRcdFx0XHRza2luV2VpZ2h0QXJyYXlbIG9mZnNldF9za2luICsgMiBdID0gc3cxLno7XHJcblx0XHRcdFx0c2tpbldlaWdodEFycmF5WyBvZmZzZXRfc2tpbiArIDMgXSA9IHN3MS53O1xyXG5cclxuXHRcdFx0XHRza2luV2VpZ2h0QXJyYXlbIG9mZnNldF9za2luICsgNCBdID0gc3cyLng7XHJcblx0XHRcdFx0c2tpbldlaWdodEFycmF5WyBvZmZzZXRfc2tpbiArIDUgXSA9IHN3Mi55O1xyXG5cdFx0XHRcdHNraW5XZWlnaHRBcnJheVsgb2Zmc2V0X3NraW4gKyA2IF0gPSBzdzIuejtcclxuXHRcdFx0XHRza2luV2VpZ2h0QXJyYXlbIG9mZnNldF9za2luICsgNyBdID0gc3cyLnc7XHJcblxyXG5cdFx0XHRcdHNraW5XZWlnaHRBcnJheVsgb2Zmc2V0X3NraW4gKyA4IF0gID0gc3czLng7XHJcblx0XHRcdFx0c2tpbldlaWdodEFycmF5WyBvZmZzZXRfc2tpbiArIDkgXSAgPSBzdzMueTtcclxuXHRcdFx0XHRza2luV2VpZ2h0QXJyYXlbIG9mZnNldF9za2luICsgMTAgXSA9IHN3My56O1xyXG5cdFx0XHRcdHNraW5XZWlnaHRBcnJheVsgb2Zmc2V0X3NraW4gKyAxMSBdID0gc3czLnc7XHJcblxyXG5cdFx0XHRcdHNraW5XZWlnaHRBcnJheVsgb2Zmc2V0X3NraW4gKyAxMiBdID0gc3c0Lng7XHJcblx0XHRcdFx0c2tpbldlaWdodEFycmF5WyBvZmZzZXRfc2tpbiArIDEzIF0gPSBzdzQueTtcclxuXHRcdFx0XHRza2luV2VpZ2h0QXJyYXlbIG9mZnNldF9za2luICsgMTQgXSA9IHN3NC56O1xyXG5cdFx0XHRcdHNraW5XZWlnaHRBcnJheVsgb2Zmc2V0X3NraW4gKyAxNSBdID0gc3c0Lnc7XHJcblxyXG5cdFx0XHRcdC8vIGluZGljZXNcclxuXHJcblx0XHRcdFx0c2kxID0gb2JqX3NraW5JbmRpY2VzWyBmYWNlLmEgXTtcclxuXHRcdFx0XHRzaTIgPSBvYmpfc2tpbkluZGljZXNbIGZhY2UuYiBdO1xyXG5cdFx0XHRcdHNpMyA9IG9ial9za2luSW5kaWNlc1sgZmFjZS5jIF07XHJcblx0XHRcdFx0c2k0ID0gb2JqX3NraW5JbmRpY2VzWyBmYWNlLmQgXTtcclxuXHJcblx0XHRcdFx0c2tpbkluZGV4QXJyYXlbIG9mZnNldF9za2luIF0gICAgID0gc2kxLng7XHJcblx0XHRcdFx0c2tpbkluZGV4QXJyYXlbIG9mZnNldF9za2luICsgMSBdID0gc2kxLnk7XHJcblx0XHRcdFx0c2tpbkluZGV4QXJyYXlbIG9mZnNldF9za2luICsgMiBdID0gc2kxLno7XHJcblx0XHRcdFx0c2tpbkluZGV4QXJyYXlbIG9mZnNldF9za2luICsgMyBdID0gc2kxLnc7XHJcblxyXG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiArIDQgXSA9IHNpMi54O1xyXG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiArIDUgXSA9IHNpMi55O1xyXG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiArIDYgXSA9IHNpMi56O1xyXG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiArIDcgXSA9IHNpMi53O1xyXG5cclxuXHRcdFx0XHRza2luSW5kZXhBcnJheVsgb2Zmc2V0X3NraW4gKyA4IF0gID0gc2kzLng7XHJcblx0XHRcdFx0c2tpbkluZGV4QXJyYXlbIG9mZnNldF9za2luICsgOSBdICA9IHNpMy55O1xyXG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiArIDEwIF0gPSBzaTMuejtcclxuXHRcdFx0XHRza2luSW5kZXhBcnJheVsgb2Zmc2V0X3NraW4gKyAxMSBdID0gc2kzLnc7XHJcblxyXG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiArIDEyIF0gPSBzaTQueDtcclxuXHRcdFx0XHRza2luSW5kZXhBcnJheVsgb2Zmc2V0X3NraW4gKyAxMyBdID0gc2k0Lnk7XHJcblx0XHRcdFx0c2tpbkluZGV4QXJyYXlbIG9mZnNldF9za2luICsgMTQgXSA9IHNpNC56O1xyXG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiArIDE1IF0gPSBzaTQudztcclxuXHJcblx0XHRcdFx0b2Zmc2V0X3NraW4gKz0gMTY7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG9mZnNldF9za2luID4gMCApIHtcclxuXHJcblx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbFNraW5JbmRpY2VzQnVmZmVyICk7XHJcblx0XHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIHNraW5JbmRleEFycmF5LCBoaW50ICk7XHJcblxyXG5cdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xTa2luV2VpZ2h0c0J1ZmZlciApO1xyXG5cdFx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBza2luV2VpZ2h0QXJyYXksIGhpbnQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBkaXJ0eUNvbG9ycyAmJiB2ZXJ0ZXhDb2xvclR5cGUgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2UgPSBvYmpfZmFjZXNbIGNodW5rX2ZhY2VzM1sgZiBdXHRdO1xyXG5cclxuXHRcdFx0XHR2ZXJ0ZXhDb2xvcnMgPSBmYWNlLnZlcnRleENvbG9ycztcclxuXHRcdFx0XHRmYWNlQ29sb3IgPSBmYWNlLmNvbG9yO1xyXG5cclxuXHRcdFx0XHRpZiAoIHZlcnRleENvbG9ycy5sZW5ndGggPT09IDMgJiYgdmVydGV4Q29sb3JUeXBlID09PSBUSFJFRS5WZXJ0ZXhDb2xvcnMgKSB7XHJcblxyXG5cdFx0XHRcdFx0YzEgPSB2ZXJ0ZXhDb2xvcnNbIDAgXTtcclxuXHRcdFx0XHRcdGMyID0gdmVydGV4Q29sb3JzWyAxIF07XHJcblx0XHRcdFx0XHRjMyA9IHZlcnRleENvbG9yc1sgMiBdO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGMxID0gZmFjZUNvbG9yO1xyXG5cdFx0XHRcdFx0YzIgPSBmYWNlQ29sb3I7XHJcblx0XHRcdFx0XHRjMyA9IGZhY2VDb2xvcjtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXRfY29sb3IgXSAgICAgPSBjMS5yO1xyXG5cdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldF9jb2xvciArIDEgXSA9IGMxLmc7XHJcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0X2NvbG9yICsgMiBdID0gYzEuYjtcclxuXHJcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0X2NvbG9yICsgMyBdID0gYzIucjtcclxuXHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXRfY29sb3IgKyA0IF0gPSBjMi5nO1xyXG5cdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldF9jb2xvciArIDUgXSA9IGMyLmI7XHJcblxyXG5cdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldF9jb2xvciArIDYgXSA9IGMzLnI7XHJcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0X2NvbG9yICsgNyBdID0gYzMuZztcclxuXHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXRfY29sb3IgKyA4IF0gPSBjMy5iO1xyXG5cclxuXHRcdFx0XHRvZmZzZXRfY29sb3IgKz0gOTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzNC5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0ZmFjZSA9IG9ial9mYWNlc1sgY2h1bmtfZmFjZXM0WyBmIF0gXTtcclxuXHJcblx0XHRcdFx0dmVydGV4Q29sb3JzID0gZmFjZS52ZXJ0ZXhDb2xvcnM7XHJcblx0XHRcdFx0ZmFjZUNvbG9yID0gZmFjZS5jb2xvcjtcclxuXHJcblx0XHRcdFx0aWYgKCB2ZXJ0ZXhDb2xvcnMubGVuZ3RoID09PSA0ICYmIHZlcnRleENvbG9yVHlwZSA9PT0gVEhSRUUuVmVydGV4Q29sb3JzICkge1xyXG5cclxuXHRcdFx0XHRcdGMxID0gdmVydGV4Q29sb3JzWyAwIF07XHJcblx0XHRcdFx0XHRjMiA9IHZlcnRleENvbG9yc1sgMSBdO1xyXG5cdFx0XHRcdFx0YzMgPSB2ZXJ0ZXhDb2xvcnNbIDIgXTtcclxuXHRcdFx0XHRcdGM0ID0gdmVydGV4Q29sb3JzWyAzIF07XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0YzEgPSBmYWNlQ29sb3I7XHJcblx0XHRcdFx0XHRjMiA9IGZhY2VDb2xvcjtcclxuXHRcdFx0XHRcdGMzID0gZmFjZUNvbG9yO1xyXG5cdFx0XHRcdFx0YzQgPSBmYWNlQ29sb3I7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0X2NvbG9yIF0gICAgID0gYzEucjtcclxuXHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXRfY29sb3IgKyAxIF0gPSBjMS5nO1xyXG5cdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldF9jb2xvciArIDIgXSA9IGMxLmI7XHJcblxyXG5cdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldF9jb2xvciArIDMgXSA9IGMyLnI7XHJcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0X2NvbG9yICsgNCBdID0gYzIuZztcclxuXHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXRfY29sb3IgKyA1IF0gPSBjMi5iO1xyXG5cclxuXHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXRfY29sb3IgKyA2IF0gPSBjMy5yO1xyXG5cdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldF9jb2xvciArIDcgXSA9IGMzLmc7XHJcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0X2NvbG9yICsgOCBdID0gYzMuYjtcclxuXHJcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0X2NvbG9yICsgOSBdICA9IGM0LnI7XHJcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0X2NvbG9yICsgMTAgXSA9IGM0Lmc7XHJcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0X2NvbG9yICsgMTEgXSA9IGM0LmI7XHJcblxyXG5cdFx0XHRcdG9mZnNldF9jb2xvciArPSAxMjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggb2Zmc2V0X2NvbG9yID4gMCApIHtcclxuXHJcblx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbENvbG9yQnVmZmVyICk7XHJcblx0XHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIGNvbG9yQXJyYXksIGhpbnQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBkaXJ0eVRhbmdlbnRzICYmIGdlb21ldHJ5Lmhhc1RhbmdlbnRzICkge1xyXG5cclxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXMzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRmYWNlID0gb2JqX2ZhY2VzWyBjaHVua19mYWNlczNbIGYgXVx0XTtcclxuXHJcblx0XHRcdFx0dmVydGV4VGFuZ2VudHMgPSBmYWNlLnZlcnRleFRhbmdlbnRzO1xyXG5cclxuXHRcdFx0XHR0MSA9IHZlcnRleFRhbmdlbnRzWyAwIF07XHJcblx0XHRcdFx0dDIgPSB2ZXJ0ZXhUYW5nZW50c1sgMSBdO1xyXG5cdFx0XHRcdHQzID0gdmVydGV4VGFuZ2VudHNbIDIgXTtcclxuXHJcblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCBdICAgICA9IHQxLng7XHJcblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCArIDEgXSA9IHQxLnk7XHJcblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCArIDIgXSA9IHQxLno7XHJcblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCArIDMgXSA9IHQxLnc7XHJcblxyXG5cdFx0XHRcdHRhbmdlbnRBcnJheVsgb2Zmc2V0X3RhbmdlbnQgKyA0IF0gPSB0Mi54O1xyXG5cdFx0XHRcdHRhbmdlbnRBcnJheVsgb2Zmc2V0X3RhbmdlbnQgKyA1IF0gPSB0Mi55O1xyXG5cdFx0XHRcdHRhbmdlbnRBcnJheVsgb2Zmc2V0X3RhbmdlbnQgKyA2IF0gPSB0Mi56O1xyXG5cdFx0XHRcdHRhbmdlbnRBcnJheVsgb2Zmc2V0X3RhbmdlbnQgKyA3IF0gPSB0Mi53O1xyXG5cclxuXHRcdFx0XHR0YW5nZW50QXJyYXlbIG9mZnNldF90YW5nZW50ICsgOCBdICA9IHQzLng7XHJcblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCArIDkgXSAgPSB0My55O1xyXG5cdFx0XHRcdHRhbmdlbnRBcnJheVsgb2Zmc2V0X3RhbmdlbnQgKyAxMCBdID0gdDMuejtcclxuXHRcdFx0XHR0YW5nZW50QXJyYXlbIG9mZnNldF90YW5nZW50ICsgMTEgXSA9IHQzLnc7XHJcblxyXG5cdFx0XHRcdG9mZnNldF90YW5nZW50ICs9IDEyO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXM0Lmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRmYWNlID0gb2JqX2ZhY2VzWyBjaHVua19mYWNlczRbIGYgXSBdO1xyXG5cclxuXHRcdFx0XHR2ZXJ0ZXhUYW5nZW50cyA9IGZhY2UudmVydGV4VGFuZ2VudHM7XHJcblxyXG5cdFx0XHRcdHQxID0gdmVydGV4VGFuZ2VudHNbIDAgXTtcclxuXHRcdFx0XHR0MiA9IHZlcnRleFRhbmdlbnRzWyAxIF07XHJcblx0XHRcdFx0dDMgPSB2ZXJ0ZXhUYW5nZW50c1sgMiBdO1xyXG5cdFx0XHRcdHQ0ID0gdmVydGV4VGFuZ2VudHNbIDMgXTtcclxuXHJcblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCBdICAgICA9IHQxLng7XHJcblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCArIDEgXSA9IHQxLnk7XHJcblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCArIDIgXSA9IHQxLno7XHJcblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCArIDMgXSA9IHQxLnc7XHJcblxyXG5cdFx0XHRcdHRhbmdlbnRBcnJheVsgb2Zmc2V0X3RhbmdlbnQgKyA0IF0gPSB0Mi54O1xyXG5cdFx0XHRcdHRhbmdlbnRBcnJheVsgb2Zmc2V0X3RhbmdlbnQgKyA1IF0gPSB0Mi55O1xyXG5cdFx0XHRcdHRhbmdlbnRBcnJheVsgb2Zmc2V0X3RhbmdlbnQgKyA2IF0gPSB0Mi56O1xyXG5cdFx0XHRcdHRhbmdlbnRBcnJheVsgb2Zmc2V0X3RhbmdlbnQgKyA3IF0gPSB0Mi53O1xyXG5cclxuXHRcdFx0XHR0YW5nZW50QXJyYXlbIG9mZnNldF90YW5nZW50ICsgOCBdICA9IHQzLng7XHJcblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCArIDkgXSAgPSB0My55O1xyXG5cdFx0XHRcdHRhbmdlbnRBcnJheVsgb2Zmc2V0X3RhbmdlbnQgKyAxMCBdID0gdDMuejtcclxuXHRcdFx0XHR0YW5nZW50QXJyYXlbIG9mZnNldF90YW5nZW50ICsgMTEgXSA9IHQzLnc7XHJcblxyXG5cdFx0XHRcdHRhbmdlbnRBcnJheVsgb2Zmc2V0X3RhbmdlbnQgKyAxMiBdID0gdDQueDtcclxuXHRcdFx0XHR0YW5nZW50QXJyYXlbIG9mZnNldF90YW5nZW50ICsgMTMgXSA9IHQ0Lnk7XHJcblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCArIDE0IF0gPSB0NC56O1xyXG5cdFx0XHRcdHRhbmdlbnRBcnJheVsgb2Zmc2V0X3RhbmdlbnQgKyAxNSBdID0gdDQudztcclxuXHJcblx0XHRcdFx0b2Zmc2V0X3RhbmdlbnQgKz0gMTY7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsVGFuZ2VudEJ1ZmZlciApO1xyXG5cdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgdGFuZ2VudEFycmF5LCBoaW50ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZGlydHlOb3JtYWxzICYmIG5vcm1hbFR5cGUgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2UgPSBvYmpfZmFjZXNbIGNodW5rX2ZhY2VzM1sgZiBdXHRdO1xyXG5cclxuXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzID0gZmFjZS52ZXJ0ZXhOb3JtYWxzO1xyXG5cdFx0XHRcdGZhY2VOb3JtYWwgPSBmYWNlLm5vcm1hbDtcclxuXHJcblx0XHRcdFx0aWYgKCB2ZXJ0ZXhOb3JtYWxzLmxlbmd0aCA9PT0gMyAmJiBuZWVkc1Ntb290aE5vcm1hbHMgKSB7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCAzOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dm4gPSB2ZXJ0ZXhOb3JtYWxzWyBpIF07XHJcblxyXG5cdFx0XHRcdFx0XHRub3JtYWxBcnJheVsgb2Zmc2V0X25vcm1hbCBdICAgICA9IHZuLng7XHJcblx0XHRcdFx0XHRcdG5vcm1hbEFycmF5WyBvZmZzZXRfbm9ybWFsICsgMSBdID0gdm4ueTtcclxuXHRcdFx0XHRcdFx0bm9ybWFsQXJyYXlbIG9mZnNldF9ub3JtYWwgKyAyIF0gPSB2bi56O1xyXG5cclxuXHRcdFx0XHRcdFx0b2Zmc2V0X25vcm1hbCArPSAzO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRub3JtYWxBcnJheVsgb2Zmc2V0X25vcm1hbCBdICAgICA9IGZhY2VOb3JtYWwueDtcclxuXHRcdFx0XHRcdFx0bm9ybWFsQXJyYXlbIG9mZnNldF9ub3JtYWwgKyAxIF0gPSBmYWNlTm9ybWFsLnk7XHJcblx0XHRcdFx0XHRcdG5vcm1hbEFycmF5WyBvZmZzZXRfbm9ybWFsICsgMiBdID0gZmFjZU5vcm1hbC56O1xyXG5cclxuXHRcdFx0XHRcdFx0b2Zmc2V0X25vcm1hbCArPSAzO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXM0Lmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRmYWNlID0gb2JqX2ZhY2VzWyBjaHVua19mYWNlczRbIGYgXSBdO1xyXG5cclxuXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzID0gZmFjZS52ZXJ0ZXhOb3JtYWxzO1xyXG5cdFx0XHRcdGZhY2VOb3JtYWwgPSBmYWNlLm5vcm1hbDtcclxuXHJcblx0XHRcdFx0aWYgKCB2ZXJ0ZXhOb3JtYWxzLmxlbmd0aCA9PT0gNCAmJiBuZWVkc1Ntb290aE5vcm1hbHMgKSB7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCA0OyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dm4gPSB2ZXJ0ZXhOb3JtYWxzWyBpIF07XHJcblxyXG5cdFx0XHRcdFx0XHRub3JtYWxBcnJheVsgb2Zmc2V0X25vcm1hbCBdICAgICA9IHZuLng7XHJcblx0XHRcdFx0XHRcdG5vcm1hbEFycmF5WyBvZmZzZXRfbm9ybWFsICsgMSBdID0gdm4ueTtcclxuXHRcdFx0XHRcdFx0bm9ybWFsQXJyYXlbIG9mZnNldF9ub3JtYWwgKyAyIF0gPSB2bi56O1xyXG5cclxuXHRcdFx0XHRcdFx0b2Zmc2V0X25vcm1hbCArPSAzO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IDQ7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRub3JtYWxBcnJheVsgb2Zmc2V0X25vcm1hbCBdICAgICA9IGZhY2VOb3JtYWwueDtcclxuXHRcdFx0XHRcdFx0bm9ybWFsQXJyYXlbIG9mZnNldF9ub3JtYWwgKyAxIF0gPSBmYWNlTm9ybWFsLnk7XHJcblx0XHRcdFx0XHRcdG5vcm1hbEFycmF5WyBvZmZzZXRfbm9ybWFsICsgMiBdID0gZmFjZU5vcm1hbC56O1xyXG5cclxuXHRcdFx0XHRcdFx0b2Zmc2V0X25vcm1hbCArPSAzO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbE5vcm1hbEJ1ZmZlciApO1xyXG5cdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgbm9ybWFsQXJyYXksIGhpbnQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBkaXJ0eVV2cyAmJiBvYmpfdXZzICYmIHV2VHlwZSApIHtcclxuXHJcblx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzMy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0ZmkgPSBjaHVua19mYWNlczNbIGYgXTtcclxuXHJcblx0XHRcdFx0dXYgPSBvYmpfdXZzWyBmaSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIHV2ID09PSB1bmRlZmluZWQgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCAzOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHV2aSA9IHV2WyBpIF07XHJcblxyXG5cdFx0XHRcdFx0dXZBcnJheVsgb2Zmc2V0X3V2IF0gICAgID0gdXZpLng7XHJcblx0XHRcdFx0XHR1dkFycmF5WyBvZmZzZXRfdXYgKyAxIF0gPSB1dmkueTtcclxuXHJcblx0XHRcdFx0XHRvZmZzZXRfdXYgKz0gMjtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXM0Lmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRmaSA9IGNodW5rX2ZhY2VzNFsgZiBdO1xyXG5cclxuXHRcdFx0XHR1diA9IG9ial91dnNbIGZpIF07XHJcblxyXG5cdFx0XHRcdGlmICggdXYgPT09IHVuZGVmaW5lZCApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IDQ7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dXZpID0gdXZbIGkgXTtcclxuXHJcblx0XHRcdFx0XHR1dkFycmF5WyBvZmZzZXRfdXYgXSAgICAgPSB1dmkueDtcclxuXHRcdFx0XHRcdHV2QXJyYXlbIG9mZnNldF91diArIDEgXSA9IHV2aS55O1xyXG5cclxuXHRcdFx0XHRcdG9mZnNldF91diArPSAyO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG9mZnNldF91diA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xVVkJ1ZmZlciApO1xyXG5cdFx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCB1dkFycmF5LCBoaW50ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZGlydHlVdnMgJiYgb2JqX3V2czIgJiYgdXZUeXBlICkge1xyXG5cclxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXMzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRmaSA9IGNodW5rX2ZhY2VzM1sgZiBdO1xyXG5cclxuXHRcdFx0XHR1djIgPSBvYmpfdXZzMlsgZmkgXTtcclxuXHJcblx0XHRcdFx0aWYgKCB1djIgPT09IHVuZGVmaW5lZCApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dXYyaSA9IHV2MlsgaSBdO1xyXG5cclxuXHRcdFx0XHRcdHV2MkFycmF5WyBvZmZzZXRfdXYyIF0gICAgID0gdXYyaS54O1xyXG5cdFx0XHRcdFx0dXYyQXJyYXlbIG9mZnNldF91djIgKyAxIF0gPSB1djJpLnk7XHJcblxyXG5cdFx0XHRcdFx0b2Zmc2V0X3V2MiArPSAyO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczQubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdGZpID0gY2h1bmtfZmFjZXM0WyBmIF07XHJcblxyXG5cdFx0XHRcdHV2MiA9IG9ial91dnMyWyBmaSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIHV2MiA9PT0gdW5kZWZpbmVkICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgNDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHR1djJpID0gdXYyWyBpIF07XHJcblxyXG5cdFx0XHRcdFx0dXYyQXJyYXlbIG9mZnNldF91djIgXSAgICAgPSB1djJpLng7XHJcblx0XHRcdFx0XHR1djJBcnJheVsgb2Zmc2V0X3V2MiArIDEgXSA9IHV2MmkueTtcclxuXHJcblx0XHRcdFx0XHRvZmZzZXRfdXYyICs9IDI7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggb2Zmc2V0X3V2MiA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xVVjJCdWZmZXIgKTtcclxuXHRcdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgdXYyQXJyYXksIGhpbnQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBkaXJ0eUVsZW1lbnRzICkge1xyXG5cclxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXMzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRmYWNlQXJyYXlbIG9mZnNldF9mYWNlIF0gXHQgPSB2ZXJ0ZXhJbmRleDtcclxuXHRcdFx0XHRmYWNlQXJyYXlbIG9mZnNldF9mYWNlICsgMSBdID0gdmVydGV4SW5kZXggKyAxO1xyXG5cdFx0XHRcdGZhY2VBcnJheVsgb2Zmc2V0X2ZhY2UgKyAyIF0gPSB2ZXJ0ZXhJbmRleCArIDI7XHJcblxyXG5cdFx0XHRcdG9mZnNldF9mYWNlICs9IDM7XHJcblxyXG5cdFx0XHRcdGxpbmVBcnJheVsgb2Zmc2V0X2xpbmUgXSAgICAgPSB2ZXJ0ZXhJbmRleDtcclxuXHRcdFx0XHRsaW5lQXJyYXlbIG9mZnNldF9saW5lICsgMSBdID0gdmVydGV4SW5kZXggKyAxO1xyXG5cclxuXHRcdFx0XHRsaW5lQXJyYXlbIG9mZnNldF9saW5lICsgMiBdID0gdmVydGV4SW5kZXg7XHJcblx0XHRcdFx0bGluZUFycmF5WyBvZmZzZXRfbGluZSArIDMgXSA9IHZlcnRleEluZGV4ICsgMjtcclxuXHJcblx0XHRcdFx0bGluZUFycmF5WyBvZmZzZXRfbGluZSArIDQgXSA9IHZlcnRleEluZGV4ICsgMTtcclxuXHRcdFx0XHRsaW5lQXJyYXlbIG9mZnNldF9saW5lICsgNSBdID0gdmVydGV4SW5kZXggKyAyO1xyXG5cclxuXHRcdFx0XHRvZmZzZXRfbGluZSArPSA2O1xyXG5cclxuXHRcdFx0XHR2ZXJ0ZXhJbmRleCArPSAzO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXM0Lmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRmYWNlQXJyYXlbIG9mZnNldF9mYWNlIF0gICAgID0gdmVydGV4SW5kZXg7XHJcblx0XHRcdFx0ZmFjZUFycmF5WyBvZmZzZXRfZmFjZSArIDEgXSA9IHZlcnRleEluZGV4ICsgMTtcclxuXHRcdFx0XHRmYWNlQXJyYXlbIG9mZnNldF9mYWNlICsgMiBdID0gdmVydGV4SW5kZXggKyAzO1xyXG5cclxuXHRcdFx0XHRmYWNlQXJyYXlbIG9mZnNldF9mYWNlICsgMyBdID0gdmVydGV4SW5kZXggKyAxO1xyXG5cdFx0XHRcdGZhY2VBcnJheVsgb2Zmc2V0X2ZhY2UgKyA0IF0gPSB2ZXJ0ZXhJbmRleCArIDI7XHJcblx0XHRcdFx0ZmFjZUFycmF5WyBvZmZzZXRfZmFjZSArIDUgXSA9IHZlcnRleEluZGV4ICsgMztcclxuXHJcblx0XHRcdFx0b2Zmc2V0X2ZhY2UgKz0gNjtcclxuXHJcblx0XHRcdFx0bGluZUFycmF5WyBvZmZzZXRfbGluZSBdICAgICA9IHZlcnRleEluZGV4O1xyXG5cdFx0XHRcdGxpbmVBcnJheVsgb2Zmc2V0X2xpbmUgKyAxIF0gPSB2ZXJ0ZXhJbmRleCArIDE7XHJcblxyXG5cdFx0XHRcdGxpbmVBcnJheVsgb2Zmc2V0X2xpbmUgKyAyIF0gPSB2ZXJ0ZXhJbmRleDtcclxuXHRcdFx0XHRsaW5lQXJyYXlbIG9mZnNldF9saW5lICsgMyBdID0gdmVydGV4SW5kZXggKyAzO1xyXG5cclxuXHRcdFx0XHRsaW5lQXJyYXlbIG9mZnNldF9saW5lICsgNCBdID0gdmVydGV4SW5kZXggKyAxO1xyXG5cdFx0XHRcdGxpbmVBcnJheVsgb2Zmc2V0X2xpbmUgKyA1IF0gPSB2ZXJ0ZXhJbmRleCArIDI7XHJcblxyXG5cdFx0XHRcdGxpbmVBcnJheVsgb2Zmc2V0X2xpbmUgKyA2IF0gPSB2ZXJ0ZXhJbmRleCArIDI7XHJcblx0XHRcdFx0bGluZUFycmF5WyBvZmZzZXRfbGluZSArIDcgXSA9IHZlcnRleEluZGV4ICsgMztcclxuXHJcblx0XHRcdFx0b2Zmc2V0X2xpbmUgKz0gODtcclxuXHJcblx0XHRcdFx0dmVydGV4SW5kZXggKz0gNDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbEZhY2VCdWZmZXIgKTtcclxuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZmFjZUFycmF5LCBoaW50ICk7XHJcblxyXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xMaW5lQnVmZmVyICk7XHJcblx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGxpbmVBcnJheSwgaGludCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMCwgaWwgPSBjdXN0b21BdHRyaWJ1dGVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUgPSBjdXN0b21BdHRyaWJ1dGVzWyBpIF07XHJcblxyXG5cdFx0XHRcdGlmICggISBjdXN0b21BdHRyaWJ1dGUuX19vcmlnaW5hbC5uZWVkc1VwZGF0ZSApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRvZmZzZXRfY3VzdG9tID0gMDtcclxuXHRcdFx0XHRvZmZzZXRfY3VzdG9tU3JjID0gMDtcclxuXHJcblx0XHRcdFx0aWYgKCBjdXN0b21BdHRyaWJ1dGUuc2l6ZSA9PT0gMSApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZS5ib3VuZFRvID09PSB1bmRlZmluZWQgfHwgY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09IFwidmVydGljZXNcIiApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzMy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0ZmFjZSA9IG9ial9mYWNlc1sgY2h1bmtfZmFjZXMzWyBmIF1cdF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSBdIFx0ICAgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGZhY2UuYSBdO1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEgXSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5iIF07XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMiBdID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBmYWNlLmMgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0b2Zmc2V0X2N1c3RvbSArPSAzO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXM0Lmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRmYWNlID0gb2JqX2ZhY2VzWyBjaHVua19mYWNlczRbIGYgXSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gXSBcdCAgID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBmYWNlLmEgXTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxIF0gPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGZhY2UuYiBdO1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDIgXSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5jIF07XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMyBdID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBmYWNlLmQgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0b2Zmc2V0X2N1c3RvbSArPSA0O1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGN1c3RvbUF0dHJpYnV0ZS5ib3VuZFRvID09PSBcImZhY2VzXCIgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBjaHVua19mYWNlczNbIGYgXSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gXSBcdCAgID0gdmFsdWU7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMSBdID0gdmFsdWU7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMiBdID0gdmFsdWU7XHJcblxyXG5cdFx0XHRcdFx0XHRcdG9mZnNldF9jdXN0b20gKz0gMztcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzNC5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dmFsdWUgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGNodW5rX2ZhY2VzNFsgZiBdIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSBdIFx0ICAgPSB2YWx1ZTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxIF0gPSB2YWx1ZTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAyIF0gPSB2YWx1ZTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAzIF0gPSB2YWx1ZTtcclxuXHJcblx0XHRcdFx0XHRcdFx0b2Zmc2V0X2N1c3RvbSArPSA0O1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLnNpemUgPT09IDIgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBjdXN0b21BdHRyaWJ1dGUuYm91bmRUbyA9PT0gdW5kZWZpbmVkIHx8IGN1c3RvbUF0dHJpYnV0ZS5ib3VuZFRvID09PSBcInZlcnRpY2VzXCIgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGZhY2UgPSBvYmpfZmFjZXNbIGNodW5rX2ZhY2VzM1sgZiBdXHRdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2MSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5hIF07XHJcblx0XHRcdFx0XHRcdFx0djIgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGZhY2UuYiBdO1xyXG5cdFx0XHRcdFx0XHRcdHYzID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBmYWNlLmMgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tIF0gXHQgICA9IHYxLng7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMSBdID0gdjEueTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMiBdID0gdjIueDtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAzIF0gPSB2Mi55O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA0IF0gPSB2My54O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDUgXSA9IHYzLnk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdG9mZnNldF9jdXN0b20gKz0gNjtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzNC5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0ZmFjZSA9IG9ial9mYWNlc1sgY2h1bmtfZmFjZXM0WyBmIF0gXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0djEgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGZhY2UuYSBdO1xyXG5cdFx0XHRcdFx0XHRcdHYyID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBmYWNlLmIgXTtcclxuXHRcdFx0XHRcdFx0XHR2MyA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5jIF07XHJcblx0XHRcdFx0XHRcdFx0djQgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGZhY2UuZCBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gXSBcdCAgID0gdjEueDtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxIF0gPSB2MS55O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAyIF0gPSB2Mi54O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDMgXSA9IHYyLnk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDQgXSA9IHYzLng7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNSBdID0gdjMueTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNiBdID0gdjQueDtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA3IF0gPSB2NC55O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRvZmZzZXRfY3VzdG9tICs9IDg7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09IFwiZmFjZXNcIiApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzMy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dmFsdWUgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGNodW5rX2ZhY2VzM1sgZiBdIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdHYxID0gdmFsdWU7XHJcblx0XHRcdFx0XHRcdFx0djIgPSB2YWx1ZTtcclxuXHRcdFx0XHRcdFx0XHR2MyA9IHZhbHVlO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gXSBcdCAgID0gdjEueDtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxIF0gPSB2MS55O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAyIF0gPSB2Mi54O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDMgXSA9IHYyLnk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDQgXSA9IHYzLng7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNSBdID0gdjMueTtcclxuXHJcblx0XHRcdFx0XHRcdFx0b2Zmc2V0X2N1c3RvbSArPSA2O1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXM0Lmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2h1bmtfZmFjZXM0WyBmIF0gXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0djEgPSB2YWx1ZTtcclxuXHRcdFx0XHRcdFx0XHR2MiA9IHZhbHVlO1xyXG5cdFx0XHRcdFx0XHRcdHYzID0gdmFsdWU7XHJcblx0XHRcdFx0XHRcdFx0djQgPSB2YWx1ZTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tIF0gXHQgICA9IHYxLng7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMSBdID0gdjEueTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMiBdID0gdjIueDtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAzIF0gPSB2Mi55O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA0IF0gPSB2My54O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDUgXSA9IHYzLnk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDYgXSA9IHY0Lng7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNyBdID0gdjQueTtcclxuXHJcblx0XHRcdFx0XHRcdFx0b2Zmc2V0X2N1c3RvbSArPSA4O1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLnNpemUgPT09IDMgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHBwO1xyXG5cclxuXHRcdFx0XHRcdGlmICggY3VzdG9tQXR0cmlidXRlLnR5cGUgPT09IFwiY1wiICkge1xyXG5cclxuXHRcdFx0XHRcdFx0cHAgPSBbIFwiclwiLCBcImdcIiwgXCJiXCIgXTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0cHAgPSBbIFwieFwiLCBcInlcIiwgXCJ6XCIgXTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBjdXN0b21BdHRyaWJ1dGUuYm91bmRUbyA9PT0gdW5kZWZpbmVkIHx8IGN1c3RvbUF0dHJpYnV0ZS5ib3VuZFRvID09PSBcInZlcnRpY2VzXCIgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGZhY2UgPSBvYmpfZmFjZXNbIGNodW5rX2ZhY2VzM1sgZiBdXHRdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2MSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5hIF07XHJcblx0XHRcdFx0XHRcdFx0djIgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGZhY2UuYiBdO1xyXG5cdFx0XHRcdFx0XHRcdHYzID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBmYWNlLmMgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tIF0gXHQgICA9IHYxWyBwcFsgMCBdIF07XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMSBdID0gdjFbIHBwWyAxIF0gXTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAyIF0gPSB2MVsgcHBbIDIgXSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAzIF0gPSB2MlsgcHBbIDAgXSBdO1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDQgXSA9IHYyWyBwcFsgMSBdIF07XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNSBdID0gdjJbIHBwWyAyIF0gXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNiBdID0gdjNbIHBwWyAwIF0gXTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA3IF0gPSB2M1sgcHBbIDEgXSBdO1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDggXSA9IHYzWyBwcFsgMiBdIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdG9mZnNldF9jdXN0b20gKz0gOTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzNC5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0ZmFjZSA9IG9ial9mYWNlc1sgY2h1bmtfZmFjZXM0WyBmIF0gXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0djEgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGZhY2UuYSBdO1xyXG5cdFx0XHRcdFx0XHRcdHYyID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBmYWNlLmIgXTtcclxuXHRcdFx0XHRcdFx0XHR2MyA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5jIF07XHJcblx0XHRcdFx0XHRcdFx0djQgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGZhY2UuZCBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gIF0gXHQ9IHYxWyBwcFsgMCBdIF07XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMSAgXSA9IHYxWyBwcFsgMSBdIF07XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMiAgXSA9IHYxWyBwcFsgMiBdIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDMgIF0gPSB2MlsgcHBbIDAgXSBdO1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDQgIF0gPSB2MlsgcHBbIDEgXSBdO1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDUgIF0gPSB2MlsgcHBbIDIgXSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA2ICBdID0gdjNbIHBwWyAwIF0gXTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA3ICBdID0gdjNbIHBwWyAxIF0gXTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA4ICBdID0gdjNbIHBwWyAyIF0gXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgOSAgXSA9IHY0WyBwcFsgMCBdIF07XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMTAgXSA9IHY0WyBwcFsgMSBdIF07XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMTEgXSA9IHY0WyBwcFsgMiBdIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdG9mZnNldF9jdXN0b20gKz0gMTI7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09IFwiZmFjZXNcIiApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzMy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dmFsdWUgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGNodW5rX2ZhY2VzM1sgZiBdIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdHYxID0gdmFsdWU7XHJcblx0XHRcdFx0XHRcdFx0djIgPSB2YWx1ZTtcclxuXHRcdFx0XHRcdFx0XHR2MyA9IHZhbHVlO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gXSBcdCAgID0gdjFbIHBwWyAwIF0gXTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxIF0gPSB2MVsgcHBbIDEgXSBdO1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDIgXSA9IHYxWyBwcFsgMiBdIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDMgXSA9IHYyWyBwcFsgMCBdIF07XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNCBdID0gdjJbIHBwWyAxIF0gXTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA1IF0gPSB2MlsgcHBbIDIgXSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA2IF0gPSB2M1sgcHBbIDAgXSBdO1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDcgXSA9IHYzWyBwcFsgMSBdIF07XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgOCBdID0gdjNbIHBwWyAyIF0gXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0b2Zmc2V0X2N1c3RvbSArPSA5O1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXM0Lmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2h1bmtfZmFjZXM0WyBmIF0gXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0djEgPSB2YWx1ZTtcclxuXHRcdFx0XHRcdFx0XHR2MiA9IHZhbHVlO1xyXG5cdFx0XHRcdFx0XHRcdHYzID0gdmFsdWU7XHJcblx0XHRcdFx0XHRcdFx0djQgPSB2YWx1ZTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICBdIFx0PSB2MVsgcHBbIDAgXSBdO1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEgIF0gPSB2MVsgcHBbIDEgXSBdO1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDIgIF0gPSB2MVsgcHBbIDIgXSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAzICBdID0gdjJbIHBwWyAwIF0gXTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA0ICBdID0gdjJbIHBwWyAxIF0gXTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA1ICBdID0gdjJbIHBwWyAyIF0gXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNiAgXSA9IHYzWyBwcFsgMCBdIF07XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNyAgXSA9IHYzWyBwcFsgMSBdIF07XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgOCAgXSA9IHYzWyBwcFsgMiBdIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDkgIF0gPSB2NFsgcHBbIDAgXSBdO1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEwIF0gPSB2NFsgcHBbIDEgXSBdO1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDExIF0gPSB2NFsgcHBbIDIgXSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRvZmZzZXRfY3VzdG9tICs9IDEyO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGN1c3RvbUF0dHJpYnV0ZS5ib3VuZFRvID09PSBcImZhY2VWZXJ0aWNlc1wiICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXMzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2h1bmtfZmFjZXMzWyBmIF0gXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0djEgPSB2YWx1ZVsgMCBdO1xyXG5cdFx0XHRcdFx0XHRcdHYyID0gdmFsdWVbIDEgXTtcclxuXHRcdFx0XHRcdFx0XHR2MyA9IHZhbHVlWyAyIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSBdIFx0ICAgPSB2MVsgcHBbIDAgXSBdO1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEgXSA9IHYxWyBwcFsgMSBdIF07XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMiBdID0gdjFbIHBwWyAyIF0gXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMyBdID0gdjJbIHBwWyAwIF0gXTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA0IF0gPSB2MlsgcHBbIDEgXSBdO1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDUgXSA9IHYyWyBwcFsgMiBdIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDYgXSA9IHYzWyBwcFsgMCBdIF07XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNyBdID0gdjNbIHBwWyAxIF0gXTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA4IF0gPSB2M1sgcHBbIDIgXSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRvZmZzZXRfY3VzdG9tICs9IDk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczQubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBjaHVua19mYWNlczRbIGYgXSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2MSA9IHZhbHVlWyAwIF07XHJcblx0XHRcdFx0XHRcdFx0djIgPSB2YWx1ZVsgMSBdO1xyXG5cdFx0XHRcdFx0XHRcdHYzID0gdmFsdWVbIDIgXTtcclxuXHRcdFx0XHRcdFx0XHR2NCA9IHZhbHVlWyAzIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSAgXSBcdD0gdjFbIHBwWyAwIF0gXTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxICBdID0gdjFbIHBwWyAxIF0gXTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAyICBdID0gdjFbIHBwWyAyIF0gXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMyAgXSA9IHYyWyBwcFsgMCBdIF07XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNCAgXSA9IHYyWyBwcFsgMSBdIF07XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNSAgXSA9IHYyWyBwcFsgMiBdIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDYgIF0gPSB2M1sgcHBbIDAgXSBdO1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDcgIF0gPSB2M1sgcHBbIDEgXSBdO1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDggIF0gPSB2M1sgcHBbIDIgXSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA5ICBdID0gdjRbIHBwWyAwIF0gXTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxMCBdID0gdjRbIHBwWyAxIF0gXTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxMSBdID0gdjRbIHBwWyAyIF0gXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0b2Zmc2V0X2N1c3RvbSArPSAxMjtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGN1c3RvbUF0dHJpYnV0ZS5zaXplID09PSA0ICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09IHVuZGVmaW5lZCB8fCBjdXN0b21BdHRyaWJ1dGUuYm91bmRUbyA9PT0gXCJ2ZXJ0aWNlc1wiICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXMzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRmYWNlID0gb2JqX2ZhY2VzWyBjaHVua19mYWNlczNbIGYgXVx0XTtcclxuXHJcblx0XHRcdFx0XHRcdFx0djEgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGZhY2UuYSBdO1xyXG5cdFx0XHRcdFx0XHRcdHYyID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBmYWNlLmIgXTtcclxuXHRcdFx0XHRcdFx0XHR2MyA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5jIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSAgXSBcdD0gdjEueDtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxICBdID0gdjEueTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAyICBdID0gdjEuejtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAzICBdID0gdjEudztcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNCAgXSA9IHYyLng7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNSAgXSA9IHYyLnk7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNiAgXSA9IHYyLno7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNyAgXSA9IHYyLnc7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDggIF0gPSB2My54O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDkgIF0gPSB2My55O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEwIF0gPSB2My56O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDExIF0gPSB2My53O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRvZmZzZXRfY3VzdG9tICs9IDEyO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXM0Lmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRmYWNlID0gb2JqX2ZhY2VzWyBjaHVua19mYWNlczRbIGYgXSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2MSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5hIF07XHJcblx0XHRcdFx0XHRcdFx0djIgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGZhY2UuYiBdO1xyXG5cdFx0XHRcdFx0XHRcdHYzID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBmYWNlLmMgXTtcclxuXHRcdFx0XHRcdFx0XHR2NCA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5kIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSAgXSBcdD0gdjEueDtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxICBdID0gdjEueTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAyICBdID0gdjEuejtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAzICBdID0gdjEudztcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNCAgXSA9IHYyLng7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNSAgXSA9IHYyLnk7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNiAgXSA9IHYyLno7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNyAgXSA9IHYyLnc7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDggIF0gPSB2My54O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDkgIF0gPSB2My55O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEwIF0gPSB2My56O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDExIF0gPSB2My53O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxMiBdID0gdjQueDtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxMyBdID0gdjQueTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxNCBdID0gdjQuejtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxNSBdID0gdjQudztcclxuXHJcblx0XHRcdFx0XHRcdFx0b2Zmc2V0X2N1c3RvbSArPSAxNjtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjdXN0b21BdHRyaWJ1dGUuYm91bmRUbyA9PT0gXCJmYWNlc1wiICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXMzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2h1bmtfZmFjZXMzWyBmIF0gXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0djEgPSB2YWx1ZTtcclxuXHRcdFx0XHRcdFx0XHR2MiA9IHZhbHVlO1xyXG5cdFx0XHRcdFx0XHRcdHYzID0gdmFsdWU7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSAgXSBcdD0gdjEueDtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxICBdID0gdjEueTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAyICBdID0gdjEuejtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAzICBdID0gdjEudztcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNCAgXSA9IHYyLng7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNSAgXSA9IHYyLnk7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNiAgXSA9IHYyLno7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNyAgXSA9IHYyLnc7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDggIF0gPSB2My54O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDkgIF0gPSB2My55O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEwIF0gPSB2My56O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDExIF0gPSB2My53O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRvZmZzZXRfY3VzdG9tICs9IDEyO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXM0Lmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2h1bmtfZmFjZXM0WyBmIF0gXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0djEgPSB2YWx1ZTtcclxuXHRcdFx0XHRcdFx0XHR2MiA9IHZhbHVlO1xyXG5cdFx0XHRcdFx0XHRcdHYzID0gdmFsdWU7XHJcblx0XHRcdFx0XHRcdFx0djQgPSB2YWx1ZTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICBdIFx0PSB2MS54O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEgIF0gPSB2MS55O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDIgIF0gPSB2MS56O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDMgIF0gPSB2MS53O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA0ICBdID0gdjIueDtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA1ICBdID0gdjIueTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA2ICBdID0gdjIuejtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA3ICBdID0gdjIudztcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgOCAgXSA9IHYzLng7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgOSAgXSA9IHYzLnk7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMTAgXSA9IHYzLno7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMTEgXSA9IHYzLnc7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEyIF0gPSB2NC54O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEzIF0gPSB2NC55O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDE0IF0gPSB2NC56O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDE1IF0gPSB2NC53O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRvZmZzZXRfY3VzdG9tICs9IDE2O1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGN1c3RvbUF0dHJpYnV0ZS5ib3VuZFRvID09PSBcImZhY2VWZXJ0aWNlc1wiICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXMzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2h1bmtfZmFjZXMzWyBmIF0gXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0djEgPSB2YWx1ZVsgMCBdO1xyXG5cdFx0XHRcdFx0XHRcdHYyID0gdmFsdWVbIDEgXTtcclxuXHRcdFx0XHRcdFx0XHR2MyA9IHZhbHVlWyAyIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSAgXSBcdD0gdjEueDtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxICBdID0gdjEueTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAyICBdID0gdjEuejtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAzICBdID0gdjEudztcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNCAgXSA9IHYyLng7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNSAgXSA9IHYyLnk7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNiAgXSA9IHYyLno7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNyAgXSA9IHYyLnc7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDggIF0gPSB2My54O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDkgIF0gPSB2My55O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEwIF0gPSB2My56O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDExIF0gPSB2My53O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRvZmZzZXRfY3VzdG9tICs9IDEyO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXM0Lmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2h1bmtfZmFjZXM0WyBmIF0gXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0djEgPSB2YWx1ZVsgMCBdO1xyXG5cdFx0XHRcdFx0XHRcdHYyID0gdmFsdWVbIDEgXTtcclxuXHRcdFx0XHRcdFx0XHR2MyA9IHZhbHVlWyAyIF07XHJcblx0XHRcdFx0XHRcdFx0djQgPSB2YWx1ZVsgMyBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gIF0gXHQ9IHYxLng7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMSAgXSA9IHYxLnk7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMiAgXSA9IHYxLno7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMyAgXSA9IHYxLnc7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDQgIF0gPSB2Mi54O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDUgIF0gPSB2Mi55O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDYgIF0gPSB2Mi56O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDcgIF0gPSB2Mi53O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA4ICBdID0gdjMueDtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA5ICBdID0gdjMueTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxMCBdID0gdjMuejtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxMSBdID0gdjMudztcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMTIgXSA9IHY0Lng7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMTMgXSA9IHY0Lnk7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMTQgXSA9IHY0Lno7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMTUgXSA9IHY0Lnc7XHJcblxyXG5cdFx0XHRcdFx0XHRcdG9mZnNldF9jdXN0b20gKz0gMTY7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBjdXN0b21BdHRyaWJ1dGUuYnVmZmVyICk7XHJcblx0XHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIGN1c3RvbUF0dHJpYnV0ZS5hcnJheSwgaGludCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGRpc3Bvc2UgKSB7XHJcblxyXG5cdFx0XHRkZWxldGUgZ2VvbWV0cnlHcm91cC5fX2luaXR0ZWRBcnJheXM7XHJcblx0XHRcdGRlbGV0ZSBnZW9tZXRyeUdyb3VwLl9fY29sb3JBcnJheTtcclxuXHRcdFx0ZGVsZXRlIGdlb21ldHJ5R3JvdXAuX19ub3JtYWxBcnJheTtcclxuXHRcdFx0ZGVsZXRlIGdlb21ldHJ5R3JvdXAuX190YW5nZW50QXJyYXk7XHJcblx0XHRcdGRlbGV0ZSBnZW9tZXRyeUdyb3VwLl9fdXZBcnJheTtcclxuXHRcdFx0ZGVsZXRlIGdlb21ldHJ5R3JvdXAuX191djJBcnJheTtcclxuXHRcdFx0ZGVsZXRlIGdlb21ldHJ5R3JvdXAuX19mYWNlQXJyYXk7XHJcblx0XHRcdGRlbGV0ZSBnZW9tZXRyeUdyb3VwLl9fdmVydGV4QXJyYXk7XHJcblx0XHRcdGRlbGV0ZSBnZW9tZXRyeUdyb3VwLl9fbGluZUFycmF5O1xyXG5cdFx0XHRkZWxldGUgZ2VvbWV0cnlHcm91cC5fX3NraW5JbmRleEFycmF5O1xyXG5cdFx0XHRkZWxldGUgZ2VvbWV0cnlHcm91cC5fX3NraW5XZWlnaHRBcnJheTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIHNldERpcmVjdEJ1ZmZlcnMgKCBnZW9tZXRyeSwgaGludCwgZGlzcG9zZSApIHtcclxuXHJcblx0XHR2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0dmFyIGluZGV4ID0gYXR0cmlidXRlc1sgXCJpbmRleFwiIF07XHJcblx0XHR2YXIgcG9zaXRpb24gPSBhdHRyaWJ1dGVzWyBcInBvc2l0aW9uXCIgXTtcclxuXHRcdHZhciBub3JtYWwgPSBhdHRyaWJ1dGVzWyBcIm5vcm1hbFwiIF07XHJcblx0XHR2YXIgdXYgPSBhdHRyaWJ1dGVzWyBcInV2XCIgXTtcclxuXHRcdHZhciBjb2xvciA9IGF0dHJpYnV0ZXNbIFwiY29sb3JcIiBdO1xyXG5cdFx0dmFyIHRhbmdlbnQgPSBhdHRyaWJ1dGVzWyBcInRhbmdlbnRcIiBdO1xyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkuZWxlbWVudHNOZWVkVXBkYXRlICYmIGluZGV4ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBpbmRleC5idWZmZXIgKTtcclxuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgaW5kZXguYXJyYXksIGhpbnQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgJiYgcG9zaXRpb24gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBwb3NpdGlvbi5idWZmZXIgKTtcclxuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIHBvc2l0aW9uLmFycmF5LCBoaW50ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGUgJiYgbm9ybWFsICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgbm9ybWFsLmJ1ZmZlciApO1xyXG5cdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgbm9ybWFsLmFycmF5LCBoaW50ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkudXZzTmVlZFVwZGF0ZSAmJiB1diAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIHV2LmJ1ZmZlciApO1xyXG5cdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgdXYuYXJyYXksIGhpbnQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlICYmIGNvbG9yICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgY29sb3IuYnVmZmVyICk7XHJcblx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBjb2xvci5hcnJheSwgaGludCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LnRhbmdlbnRzTmVlZFVwZGF0ZSAmJiB0YW5nZW50ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgdGFuZ2VudC5idWZmZXIgKTtcclxuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIHRhbmdlbnQuYXJyYXksIGhpbnQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBkaXNwb3NlICkge1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgaW4gZ2VvbWV0cnkuYXR0cmlidXRlcyApIHtcclxuXHJcblx0XHRcdFx0ZGVsZXRlIGdlb21ldHJ5LmF0dHJpYnV0ZXNbIGkgXS5hcnJheTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIEJ1ZmZlciByZW5kZXJpbmdcclxuXHJcblx0dGhpcy5yZW5kZXJCdWZmZXJJbW1lZGlhdGUgPSBmdW5jdGlvbiAoIG9iamVjdCwgcHJvZ3JhbSwgbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0aWYgKCBvYmplY3QuaGFzUG9zaXRpb25zICYmICEgb2JqZWN0Ll9fd2ViZ2xWZXJ0ZXhCdWZmZXIgKSBvYmplY3QuX193ZWJnbFZlcnRleEJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcclxuXHRcdGlmICggb2JqZWN0Lmhhc05vcm1hbHMgJiYgISBvYmplY3QuX193ZWJnbE5vcm1hbEJ1ZmZlciApIG9iamVjdC5fX3dlYmdsTm9ybWFsQnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cdFx0aWYgKCBvYmplY3QuaGFzVXZzICYmICEgb2JqZWN0Ll9fd2ViZ2xVdkJ1ZmZlciApIG9iamVjdC5fX3dlYmdsVXZCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblx0XHRpZiAoIG9iamVjdC5oYXNDb2xvcnMgJiYgISBvYmplY3QuX193ZWJnbENvbG9yQnVmZmVyICkgb2JqZWN0Ll9fd2ViZ2xDb2xvckJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcclxuXHJcblx0XHRpZiAoIG9iamVjdC5oYXNQb3NpdGlvbnMgKSB7XHJcblxyXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgb2JqZWN0Ll9fd2ViZ2xWZXJ0ZXhCdWZmZXIgKTtcclxuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC5wb3NpdGlvbkFycmF5LCBfZ2wuRFlOQU1JQ19EUkFXICk7XHJcblx0XHRcdF9nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSggcHJvZ3JhbS5hdHRyaWJ1dGVzLnBvc2l0aW9uICk7XHJcblx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBwcm9ncmFtLmF0dHJpYnV0ZXMucG9zaXRpb24sIDMsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBvYmplY3QuaGFzTm9ybWFscyApIHtcclxuXHJcblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3QuX193ZWJnbE5vcm1hbEJ1ZmZlciApO1xyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbC5zaGFkaW5nID09PSBUSFJFRS5GbGF0U2hhZGluZyApIHtcclxuXHJcblx0XHRcdFx0dmFyIG54LCBueSwgbnosXHJcblx0XHRcdFx0XHRuYXgsIG5ieCwgbmN4LCBuYXksIG5ieSwgbmN5LCBuYXosIG5ieiwgbmN6LFxyXG5cdFx0XHRcdFx0bm9ybWFsQXJyYXksXHJcblx0XHRcdFx0XHRpLCBpbCA9IG9iamVjdC5jb3VudCAqIDM7XHJcblxyXG5cdFx0XHRcdGZvciggaSA9IDA7IGkgPCBpbDsgaSArPSA5ICkge1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbEFycmF5ID0gb2JqZWN0Lm5vcm1hbEFycmF5O1xyXG5cclxuXHRcdFx0XHRcdG5heCAgPSBub3JtYWxBcnJheVsgaSBdO1xyXG5cdFx0XHRcdFx0bmF5ICA9IG5vcm1hbEFycmF5WyBpICsgMSBdO1xyXG5cdFx0XHRcdFx0bmF6ICA9IG5vcm1hbEFycmF5WyBpICsgMiBdO1xyXG5cclxuXHRcdFx0XHRcdG5ieCAgPSBub3JtYWxBcnJheVsgaSArIDMgXTtcclxuXHRcdFx0XHRcdG5ieSAgPSBub3JtYWxBcnJheVsgaSArIDQgXTtcclxuXHRcdFx0XHRcdG5ieiAgPSBub3JtYWxBcnJheVsgaSArIDUgXTtcclxuXHJcblx0XHRcdFx0XHRuY3ggID0gbm9ybWFsQXJyYXlbIGkgKyA2IF07XHJcblx0XHRcdFx0XHRuY3kgID0gbm9ybWFsQXJyYXlbIGkgKyA3IF07XHJcblx0XHRcdFx0XHRuY3ogID0gbm9ybWFsQXJyYXlbIGkgKyA4IF07XHJcblxyXG5cdFx0XHRcdFx0bnggPSAoIG5heCArIG5ieCArIG5jeCApIC8gMztcclxuXHRcdFx0XHRcdG55ID0gKCBuYXkgKyBuYnkgKyBuY3kgKSAvIDM7XHJcblx0XHRcdFx0XHRueiA9ICggbmF6ICsgbmJ6ICsgbmN6ICkgLyAzO1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbEFycmF5WyBpIF0gXHQgPSBueDtcclxuXHRcdFx0XHRcdG5vcm1hbEFycmF5WyBpICsgMSBdID0gbnk7XHJcblx0XHRcdFx0XHRub3JtYWxBcnJheVsgaSArIDIgXSA9IG56O1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbEFycmF5WyBpICsgMyBdID0gbng7XHJcblx0XHRcdFx0XHRub3JtYWxBcnJheVsgaSArIDQgXSA9IG55O1xyXG5cdFx0XHRcdFx0bm9ybWFsQXJyYXlbIGkgKyA1IF0gPSBuejtcclxuXHJcblx0XHRcdFx0XHRub3JtYWxBcnJheVsgaSArIDYgXSA9IG54O1xyXG5cdFx0XHRcdFx0bm9ybWFsQXJyYXlbIGkgKyA3IF0gPSBueTtcclxuXHRcdFx0XHRcdG5vcm1hbEFycmF5WyBpICsgOCBdID0gbno7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3Qubm9ybWFsQXJyYXksIF9nbC5EWU5BTUlDX0RSQVcgKTtcclxuXHRcdFx0X2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KCBwcm9ncmFtLmF0dHJpYnV0ZXMubm9ybWFsICk7XHJcblx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBwcm9ncmFtLmF0dHJpYnV0ZXMubm9ybWFsLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggb2JqZWN0Lmhhc1V2cyAmJiBtYXRlcmlhbC5tYXAgKSB7XHJcblxyXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgb2JqZWN0Ll9fd2ViZ2xVdkJ1ZmZlciApO1xyXG5cdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgb2JqZWN0LnV2QXJyYXksIF9nbC5EWU5BTUlDX0RSQVcgKTtcclxuXHRcdFx0X2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KCBwcm9ncmFtLmF0dHJpYnV0ZXMudXYgKTtcclxuXHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIHByb2dyYW0uYXR0cmlidXRlcy51diwgMiwgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG9iamVjdC5oYXNDb2xvcnMgJiYgbWF0ZXJpYWwudmVydGV4Q29sb3JzICE9PSBUSFJFRS5Ob0NvbG9ycyApIHtcclxuXHJcblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3QuX193ZWJnbENvbG9yQnVmZmVyICk7XHJcblx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3QuY29sb3JBcnJheSwgX2dsLkRZTkFNSUNfRFJBVyApO1xyXG5cdFx0XHRfZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoIHByb2dyYW0uYXR0cmlidXRlcy5jb2xvciApO1xyXG5cdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggcHJvZ3JhbS5hdHRyaWJ1dGVzLmNvbG9yLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdF9nbC5kcmF3QXJyYXlzKCBfZ2wuVFJJQU5HTEVTLCAwLCBvYmplY3QuY291bnQgKTtcclxuXHJcblx0XHRvYmplY3QuY291bnQgPSAwO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnJlbmRlckJ1ZmZlckRpcmVjdCA9IGZ1bmN0aW9uICggY2FtZXJhLCBsaWdodHMsIGZvZywgbWF0ZXJpYWwsIGdlb21ldHJ5LCBvYmplY3QgKSB7XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHR2YXIgcHJvZ3JhbSwgYXR0cmlidXRlcywgbGluZXdpZHRoLCBwcmltaXRpdmVzLCBhLCBhdHRyaWJ1dGU7XHJcblxyXG5cdFx0cHJvZ3JhbSA9IHNldFByb2dyYW0oIGNhbWVyYSwgbGlnaHRzLCBmb2csIG1hdGVyaWFsLCBvYmplY3QgKTtcclxuXHJcblx0XHRhdHRyaWJ1dGVzID0gcHJvZ3JhbS5hdHRyaWJ1dGVzO1xyXG5cclxuXHRcdHZhciB1cGRhdGVCdWZmZXJzID0gZmFsc2UsXHJcblx0XHRcdHdpcmVmcmFtZUJpdCA9IG1hdGVyaWFsLndpcmVmcmFtZSA/IDEgOiAwLFxyXG5cdFx0XHRnZW9tZXRyeUhhc2ggPSAoIGdlb21ldHJ5LmlkICogMHhmZmZmZmYgKSArICggcHJvZ3JhbS5pZCAqIDIgKSArIHdpcmVmcmFtZUJpdDtcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5SGFzaCAhPT0gX2N1cnJlbnRHZW9tZXRyeUdyb3VwSGFzaCApIHtcclxuXHJcblx0XHRcdF9jdXJyZW50R2VvbWV0cnlHcm91cEhhc2ggPSBnZW9tZXRyeUhhc2g7XHJcblx0XHRcdHVwZGF0ZUJ1ZmZlcnMgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHVwZGF0ZUJ1ZmZlcnMgKSB7XHJcblxyXG5cdFx0XHRkaXNhYmxlQXR0cmlidXRlcygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyByZW5kZXIgbWVzaFxyXG5cclxuXHRcdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTWVzaCApIHtcclxuXHJcblx0XHRcdHZhciBpbmRleCA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbIFwiaW5kZXhcIiBdO1xyXG5cclxuXHRcdFx0Ly8gaW5kZXhlZCB0cmlhbmdsZXNcclxuXHJcblx0XHRcdGlmICggaW5kZXggKSB7XHJcblxyXG5cdFx0XHRcdHZhciBvZmZzZXRzID0gZ2VvbWV0cnkub2Zmc2V0cztcclxuXHJcblx0XHRcdFx0Ly8gaWYgdGhlcmUgaXMgbW9yZSB0aGFuIDEgY2h1bmtcclxuXHRcdFx0XHQvLyBtdXN0IHNldCBhdHRyaWJ1dGUgcG9pbnRlcnMgdG8gdXNlIG5ldyBvZmZzZXRzIGZvciBlYWNoIGNodW5rXHJcblx0XHRcdFx0Ly8gZXZlbiBpZiBnZW9tZXRyeSBhbmQgbWF0ZXJpYWxzIGRpZG4ndCBjaGFuZ2VcclxuXHJcblx0XHRcdFx0aWYgKCBvZmZzZXRzLmxlbmd0aCA+IDEgKSB1cGRhdGVCdWZmZXJzID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG9mZnNldHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHN0YXJ0SW5kZXggPSBvZmZzZXRzWyBpIF0uaW5kZXg7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB1cGRhdGVCdWZmZXJzICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gdmVydGljZXNcclxuXHJcblx0XHRcdFx0XHRcdHZhciBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbIFwicG9zaXRpb25cIiBdO1xyXG5cdFx0XHRcdFx0XHR2YXIgcG9zaXRpb25TaXplID0gcG9zaXRpb24uaXRlbVNpemU7XHJcblxyXG5cdFx0XHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgcG9zaXRpb24uYnVmZmVyICk7XHJcblx0XHRcdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy5wb3NpdGlvbiApO1xyXG5cdFx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5wb3NpdGlvbiwgcG9zaXRpb25TaXplLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCBzdGFydEluZGV4ICogcG9zaXRpb25TaXplICogNCApOyAvLyA0IGJ5dGVzIHBlciBGbG9hdDMyXHJcblxyXG5cdFx0XHRcdFx0XHQvLyBub3JtYWxzXHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgbm9ybWFsID0gZ2VvbWV0cnkuYXR0cmlidXRlc1sgXCJub3JtYWxcIiBdO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzLm5vcm1hbCA+PSAwICYmIG5vcm1hbCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dmFyIG5vcm1hbFNpemUgPSBub3JtYWwuaXRlbVNpemU7XHJcblxyXG5cdFx0XHRcdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBub3JtYWwuYnVmZmVyICk7XHJcblx0XHRcdFx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLm5vcm1hbCApO1xyXG5cdFx0XHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLm5vcm1hbCwgbm9ybWFsU2l6ZSwgX2dsLkZMT0FULCBmYWxzZSwgMCwgc3RhcnRJbmRleCAqIG5vcm1hbFNpemUgKiA0ICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHQvLyB1dnNcclxuXHJcblx0XHRcdFx0XHRcdHZhciB1diA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbIFwidXZcIiBdO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzLnV2ID49IDAgJiYgdXYgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhciB1dlNpemUgPSB1di5pdGVtU2l6ZTtcclxuXHJcblx0XHRcdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIHV2LmJ1ZmZlciApO1xyXG5cdFx0XHRcdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy51diApO1xyXG5cdFx0XHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnV2LCB1dlNpemUsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIHN0YXJ0SW5kZXggKiB1dlNpemUgKiA0ICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBjb2xvcnNcclxuXHJcblx0XHRcdFx0XHRcdHZhciBjb2xvciA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbIFwiY29sb3JcIiBdO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzLmNvbG9yID49IDAgJiYgY29sb3IgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhciBjb2xvclNpemUgPSBjb2xvci5pdGVtU2l6ZTtcclxuXHJcblx0XHRcdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGNvbG9yLmJ1ZmZlciApO1xyXG5cdFx0XHRcdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy5jb2xvciApO1xyXG5cdFx0XHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLmNvbG9yLCBjb2xvclNpemUsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIHN0YXJ0SW5kZXggKiBjb2xvclNpemUgKiA0ICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHQvLyB0YW5nZW50c1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIHRhbmdlbnQgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzWyBcInRhbmdlbnRcIiBdO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzLnRhbmdlbnQgPj0gMCAmJiB0YW5nZW50ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2YXIgdGFuZ2VudFNpemUgPSB0YW5nZW50Lml0ZW1TaXplO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgdGFuZ2VudC5idWZmZXIgKTtcclxuXHRcdFx0XHRcdFx0XHRlbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMudGFuZ2VudCApO1xyXG5cdFx0XHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnRhbmdlbnQsIHRhbmdlbnRTaXplLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCBzdGFydEluZGV4ICogdGFuZ2VudFNpemUgKiA0ICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBpbmRpY2VzXHJcblxyXG5cdFx0XHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBpbmRleC5idWZmZXIgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Ly8gcmVuZGVyIGluZGV4ZWQgdHJpYW5nbGVzXHJcblxyXG5cdFx0XHRcdFx0X2dsLmRyYXdFbGVtZW50cyggX2dsLlRSSUFOR0xFUywgb2Zmc2V0c1sgaSBdLmNvdW50LCBfZ2wuVU5TSUdORURfU0hPUlQsIG9mZnNldHNbIGkgXS5zdGFydCAqIDIgKTsgLy8gMiBieXRlcyBwZXIgVWludDE2XHJcblxyXG5cdFx0XHRcdFx0X3RoaXMuaW5mby5yZW5kZXIuY2FsbHMgKys7XHJcblx0XHRcdFx0XHRfdGhpcy5pbmZvLnJlbmRlci52ZXJ0aWNlcyArPSBvZmZzZXRzWyBpIF0uY291bnQ7IC8vIG5vdCByZWFsbHkgdHJ1ZSwgaGVyZSB2ZXJ0aWNlcyBjYW4gYmUgc2hhcmVkXHJcblx0XHRcdFx0XHRfdGhpcy5pbmZvLnJlbmRlci5mYWNlcyArPSBvZmZzZXRzWyBpIF0uY291bnQgLyAzO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBub24taW5kZXhlZCB0cmlhbmdsZXNcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGlmICggdXBkYXRlQnVmZmVycyApIHtcclxuXHJcblx0XHRcdFx0XHQvLyB2ZXJ0aWNlc1xyXG5cclxuXHRcdFx0XHRcdHZhciBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbIFwicG9zaXRpb25cIiBdO1xyXG5cdFx0XHRcdFx0dmFyIHBvc2l0aW9uU2l6ZSA9IHBvc2l0aW9uLml0ZW1TaXplO1xyXG5cclxuXHRcdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBwb3NpdGlvbi5idWZmZXIgKTtcclxuXHRcdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy5wb3NpdGlvbiApO1xyXG5cdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMucG9zaXRpb24sIHBvc2l0aW9uU2l6ZSwgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xyXG5cclxuXHRcdFx0XHRcdC8vIG5vcm1hbHNcclxuXHJcblx0XHRcdFx0XHR2YXIgbm9ybWFsID0gZ2VvbWV0cnkuYXR0cmlidXRlc1sgXCJub3JtYWxcIiBdO1xyXG5cclxuXHRcdFx0XHRcdGlmICggYXR0cmlidXRlcy5ub3JtYWwgPj0gMCAmJiBub3JtYWwgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgbm9ybWFsU2l6ZSA9IG5vcm1hbC5pdGVtU2l6ZTtcclxuXHJcblx0XHRcdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBub3JtYWwuYnVmZmVyICk7XHJcblx0XHRcdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy5ub3JtYWwgKTtcclxuXHRcdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMubm9ybWFsLCBub3JtYWxTaXplLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdC8vIHV2c1xyXG5cclxuXHRcdFx0XHRcdHZhciB1diA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbIFwidXZcIiBdO1xyXG5cclxuXHRcdFx0XHRcdGlmICggYXR0cmlidXRlcy51diA+PSAwICYmIHV2ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIHV2U2l6ZSA9IHV2Lml0ZW1TaXplO1xyXG5cclxuXHRcdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIHV2LmJ1ZmZlciApO1xyXG5cdFx0XHRcdFx0XHRlbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMudXYgKTtcclxuXHRcdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMudXYsIHV2U2l6ZSwgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHQvLyBjb2xvcnNcclxuXHJcblx0XHRcdFx0XHR2YXIgY29sb3IgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzWyBcImNvbG9yXCIgXTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGF0dHJpYnV0ZXMuY29sb3IgPj0gMCAmJiBjb2xvciApIHtcclxuXHJcblx0XHRcdFx0XHRcdHZhciBjb2xvclNpemUgPSBjb2xvci5pdGVtU2l6ZTtcclxuXHJcblx0XHRcdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBjb2xvci5idWZmZXIgKTtcclxuXHRcdFx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLmNvbG9yICk7XHJcblx0XHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLmNvbG9yLCBjb2xvclNpemUsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Ly8gdGFuZ2VudHNcclxuXHJcblx0XHRcdFx0XHR2YXIgdGFuZ2VudCA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbIFwidGFuZ2VudFwiIF07XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzLnRhbmdlbnQgPj0gMCAmJiB0YW5nZW50ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIHRhbmdlbnRTaXplID0gdGFuZ2VudC5pdGVtU2l6ZTtcclxuXHJcblx0XHRcdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCB0YW5nZW50LmJ1ZmZlciApO1xyXG5cdFx0XHRcdFx0XHRlbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMudGFuZ2VudCApO1xyXG5cdFx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy50YW5nZW50LCB0YW5nZW50U2l6ZSwgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyByZW5kZXIgbm9uLWluZGV4ZWQgdHJpYW5nbGVzXHJcblxyXG5cdFx0XHRcdF9nbC5kcmF3QXJyYXlzKCBfZ2wuVFJJQU5HTEVTLCAwLCBwb3NpdGlvbi5udW1JdGVtcyAvIDMgKTtcclxuXHJcblx0XHRcdFx0X3RoaXMuaW5mby5yZW5kZXIuY2FsbHMgKys7XHJcblx0XHRcdFx0X3RoaXMuaW5mby5yZW5kZXIudmVydGljZXMgKz0gcG9zaXRpb24ubnVtSXRlbXMgLyAzO1xyXG5cdFx0XHRcdF90aGlzLmluZm8ucmVuZGVyLmZhY2VzICs9IHBvc2l0aW9uLm51bUl0ZW1zIC8gMyAvIDM7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0Ly8gcmVuZGVyIHBhcnRpY2xlc1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlBhcnRpY2xlU3lzdGVtICkge1xyXG5cclxuXHRcdFx0aWYgKCB1cGRhdGVCdWZmZXJzICkge1xyXG5cclxuXHRcdFx0XHQvLyB2ZXJ0aWNlc1xyXG5cclxuXHRcdFx0XHR2YXIgcG9zaXRpb24gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzWyBcInBvc2l0aW9uXCIgXTtcclxuXHRcdFx0XHR2YXIgcG9zaXRpb25TaXplID0gcG9zaXRpb24uaXRlbVNpemU7XHJcblxyXG5cdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBwb3NpdGlvbi5idWZmZXIgKTtcclxuXHRcdFx0XHRlbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMucG9zaXRpb24gKTtcclxuXHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5wb3NpdGlvbiwgcG9zaXRpb25TaXplLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XHJcblxyXG5cdFx0XHRcdC8vIGNvbG9yc1xyXG5cclxuXHRcdFx0XHR2YXIgY29sb3IgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzWyBcImNvbG9yXCIgXTtcclxuXHJcblx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzLmNvbG9yID49IDAgJiYgY29sb3IgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGNvbG9yU2l6ZSA9IGNvbG9yLml0ZW1TaXplO1xyXG5cclxuXHRcdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBjb2xvci5idWZmZXIgKTtcclxuXHRcdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy5jb2xvciApO1xyXG5cdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMuY29sb3IsIGNvbG9yU2l6ZSwgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIHJlbmRlciBwYXJ0aWNsZXNcclxuXHJcblx0XHRcdFx0X2dsLmRyYXdBcnJheXMoIF9nbC5QT0lOVFMsIDAsIHBvc2l0aW9uLm51bUl0ZW1zIC8gMyApO1xyXG5cclxuXHRcdFx0XHRfdGhpcy5pbmZvLnJlbmRlci5jYWxscyArKztcclxuXHRcdFx0XHRfdGhpcy5pbmZvLnJlbmRlci5wb2ludHMgKz0gcG9zaXRpb24ubnVtSXRlbXMgLyAzO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpbmUgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHVwZGF0ZUJ1ZmZlcnMgKSB7XHJcblxyXG5cdFx0XHRcdC8vIHZlcnRpY2VzXHJcblxyXG5cdFx0XHRcdHZhciBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbIFwicG9zaXRpb25cIiBdO1xyXG5cdFx0XHRcdHZhciBwb3NpdGlvblNpemUgPSBwb3NpdGlvbi5pdGVtU2l6ZTtcclxuXHJcblx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIHBvc2l0aW9uLmJ1ZmZlciApO1xyXG5cdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy5wb3NpdGlvbiApO1xyXG5cdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnBvc2l0aW9uLCBwb3NpdGlvblNpemUsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcclxuXHJcblx0XHRcdFx0Ly8gY29sb3JzXHJcblxyXG5cdFx0XHRcdHZhciBjb2xvciA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbIFwiY29sb3JcIiBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGF0dHJpYnV0ZXMuY29sb3IgPj0gMCAmJiBjb2xvciApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgY29sb3JTaXplID0gY29sb3IuaXRlbVNpemU7XHJcblxyXG5cdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGNvbG9yLmJ1ZmZlciApO1xyXG5cdFx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLmNvbG9yICk7XHJcblx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5jb2xvciwgY29sb3JTaXplLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gcmVuZGVyIGxpbmVzXHJcblxyXG5cdFx0XHRcdHNldExpbmVXaWR0aCggbWF0ZXJpYWwubGluZXdpZHRoICk7XHJcblxyXG5cdFx0XHRcdF9nbC5kcmF3QXJyYXlzKCBfZ2wuTElORV9TVFJJUCwgMCwgcG9zaXRpb24ubnVtSXRlbXMgLyAzICk7XHJcblxyXG5cdFx0XHRcdF90aGlzLmluZm8ucmVuZGVyLmNhbGxzICsrO1xyXG5cdFx0XHRcdF90aGlzLmluZm8ucmVuZGVyLnBvaW50cyArPSBwb3NpdGlvbi5udW1JdGVtcztcclxuXHJcblx0XHRcdH1cclxuXHJcbiAgICB9XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMucmVuZGVyQnVmZmVyID0gZnVuY3Rpb24gKCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBtYXRlcmlhbCwgZ2VvbWV0cnlHcm91cCwgb2JqZWN0ICkge1xyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwudmlzaWJsZSA9PT0gZmFsc2UgKSByZXR1cm47XHJcblxyXG5cdFx0dmFyIHByb2dyYW0sIGF0dHJpYnV0ZXMsIGxpbmV3aWR0aCwgcHJpbWl0aXZlcywgYSwgYXR0cmlidXRlLCBpLCBpbDtcclxuXHJcblx0XHRwcm9ncmFtID0gc2V0UHJvZ3JhbSggY2FtZXJhLCBsaWdodHMsIGZvZywgbWF0ZXJpYWwsIG9iamVjdCApO1xyXG5cclxuXHRcdGF0dHJpYnV0ZXMgPSBwcm9ncmFtLmF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0dmFyIHVwZGF0ZUJ1ZmZlcnMgPSBmYWxzZSxcclxuXHRcdFx0d2lyZWZyYW1lQml0ID0gbWF0ZXJpYWwud2lyZWZyYW1lID8gMSA6IDAsXHJcblx0XHRcdGdlb21ldHJ5R3JvdXBIYXNoID0gKCBnZW9tZXRyeUdyb3VwLmlkICogMHhmZmZmZmYgKSArICggcHJvZ3JhbS5pZCAqIDIgKSArIHdpcmVmcmFtZUJpdDtcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5R3JvdXBIYXNoICE9PSBfY3VycmVudEdlb21ldHJ5R3JvdXBIYXNoICkge1xyXG5cclxuXHRcdFx0X2N1cnJlbnRHZW9tZXRyeUdyb3VwSGFzaCA9IGdlb21ldHJ5R3JvdXBIYXNoO1xyXG5cdFx0XHR1cGRhdGVCdWZmZXJzID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB1cGRhdGVCdWZmZXJzICkge1xyXG5cclxuXHRcdFx0ZGlzYWJsZUF0dHJpYnV0ZXMoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdmVydGljZXNcclxuXHJcblx0XHRpZiAoICFtYXRlcmlhbC5tb3JwaFRhcmdldHMgJiYgYXR0cmlidXRlcy5wb3NpdGlvbiA+PSAwICkge1xyXG5cclxuXHRcdFx0aWYgKCB1cGRhdGVCdWZmZXJzICkge1xyXG5cclxuXHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsVmVydGV4QnVmZmVyICk7XHJcblx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnBvc2l0aW9uICk7XHJcblx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMucG9zaXRpb24sIDMsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0aWYgKCBvYmplY3QubW9ycGhUYXJnZXRCYXNlICkge1xyXG5cclxuXHRcdFx0XHRzZXR1cE1vcnBoVGFyZ2V0cyggbWF0ZXJpYWwsIGdlb21ldHJ5R3JvdXAsIG9iamVjdCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblxyXG5cdFx0aWYgKCB1cGRhdGVCdWZmZXJzICkge1xyXG5cclxuXHRcdFx0Ly8gY3VzdG9tIGF0dHJpYnV0ZXNcclxuXHJcblx0XHRcdC8vIFVzZSB0aGUgcGVyLWdlb21ldHJ5R3JvdXAgY3VzdG9tIGF0dHJpYnV0ZSBhcnJheXMgd2hpY2ggYXJlIHNldHVwIGluIGluaXRNZXNoQnVmZmVyc1xyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xDdXN0b21BdHRyaWJ1dGVzTGlzdCApIHtcclxuXHJcblx0XHRcdFx0Zm9yICggaSA9IDAsIGlsID0gZ2VvbWV0cnlHcm91cC5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3QubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0YXR0cmlidXRlID0gZ2VvbWV0cnlHcm91cC5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3RbIGkgXTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGF0dHJpYnV0ZXNbIGF0dHJpYnV0ZS5idWZmZXIuYmVsb25nc1RvQXR0cmlidXRlIF0gPj0gMCApIHtcclxuXHJcblx0XHRcdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBhdHRyaWJ1dGUuYnVmZmVyICk7XHJcblx0XHRcdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlc1sgYXR0cmlidXRlLmJ1ZmZlci5iZWxvbmdzVG9BdHRyaWJ1dGUgXSApO1xyXG5cdFx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlc1sgYXR0cmlidXRlLmJ1ZmZlci5iZWxvbmdzVG9BdHRyaWJ1dGUgXSwgYXR0cmlidXRlLnNpemUsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblxyXG5cdFx0XHQvLyBjb2xvcnNcclxuXHJcblx0XHRcdGlmICggYXR0cmlidXRlcy5jb2xvciA+PSAwICkge1xyXG5cclxuXHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsQ29sb3JCdWZmZXIgKTtcclxuXHRcdFx0XHRlbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMuY29sb3IgKTtcclxuXHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5jb2xvciwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gbm9ybWFsc1xyXG5cclxuXHRcdFx0aWYgKCBhdHRyaWJ1dGVzLm5vcm1hbCA+PSAwICkge1xyXG5cclxuXHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsTm9ybWFsQnVmZmVyICk7XHJcblx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLm5vcm1hbCApO1xyXG5cdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLm5vcm1hbCwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gdGFuZ2VudHNcclxuXHJcblx0XHRcdGlmICggYXR0cmlidXRlcy50YW5nZW50ID49IDAgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xUYW5nZW50QnVmZmVyICk7XHJcblx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnRhbmdlbnQgKTtcclxuXHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy50YW5nZW50LCA0LCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyB1dnNcclxuXHJcblx0XHRcdGlmICggYXR0cmlidXRlcy51diA+PSAwICkge1xyXG5cclxuXHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsVVZCdWZmZXIgKTtcclxuXHRcdFx0XHRlbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMudXYgKTtcclxuXHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy51diwgMiwgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBhdHRyaWJ1dGVzLnV2MiA+PSAwICkge1xyXG5cclxuXHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsVVYyQnVmZmVyICk7XHJcblx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnV2MiApO1xyXG5cdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnV2MiwgMiwgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbC5za2lubmluZyAmJlxyXG5cdFx0XHRcdCBhdHRyaWJ1dGVzLnNraW5JbmRleCA+PSAwICYmIGF0dHJpYnV0ZXMuc2tpbldlaWdodCA+PSAwICkge1xyXG5cclxuXHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsU2tpbkluZGljZXNCdWZmZXIgKTtcclxuXHRcdFx0XHRlbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMuc2tpbkluZGV4ICk7XHJcblx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMuc2tpbkluZGV4LCA0LCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XHJcblxyXG5cdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xTa2luV2VpZ2h0c0J1ZmZlciApO1xyXG5cdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy5za2luV2VpZ2h0ICk7XHJcblx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMuc2tpbldlaWdodCwgNCwgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gbGluZSBkaXN0YW5jZXNcclxuXHJcblx0XHRcdGlmICggYXR0cmlidXRlcy5saW5lRGlzdGFuY2UgPj0gMCApIHtcclxuXHJcblx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbExpbmVEaXN0YW5jZUJ1ZmZlciApO1xyXG5cdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy5saW5lRGlzdGFuY2UgKTtcclxuXHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5saW5lRGlzdGFuY2UsIDEsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gcmVuZGVyIG1lc2hcclxuXHJcblx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggKSB7XHJcblxyXG5cdFx0XHQvLyB3aXJlZnJhbWVcclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwud2lyZWZyYW1lICkge1xyXG5cclxuXHRcdFx0XHRzZXRMaW5lV2lkdGgoIG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCApO1xyXG5cclxuXHRcdFx0XHRpZiAoIHVwZGF0ZUJ1ZmZlcnMgKSBfZ2wuYmluZEJ1ZmZlciggX2dsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xMaW5lQnVmZmVyICk7XHJcblx0XHRcdFx0X2dsLmRyYXdFbGVtZW50cyggX2dsLkxJTkVTLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xMaW5lQ291bnQsIF9nbC5VTlNJR05FRF9TSE9SVCwgMCApO1xyXG5cclxuXHRcdFx0Ly8gdHJpYW5nbGVzXHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRpZiAoIHVwZGF0ZUJ1ZmZlcnMgKSBfZ2wuYmluZEJ1ZmZlciggX2dsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xGYWNlQnVmZmVyICk7XHJcblx0XHRcdFx0X2dsLmRyYXdFbGVtZW50cyggX2dsLlRSSUFOR0xFUywgZ2VvbWV0cnlHcm91cC5fX3dlYmdsRmFjZUNvdW50LCBfZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdF90aGlzLmluZm8ucmVuZGVyLmNhbGxzICsrO1xyXG5cdFx0XHRfdGhpcy5pbmZvLnJlbmRlci52ZXJ0aWNlcyArPSBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xGYWNlQ291bnQ7XHJcblx0XHRcdF90aGlzLmluZm8ucmVuZGVyLmZhY2VzICs9IGdlb21ldHJ5R3JvdXAuX193ZWJnbEZhY2VDb3VudCAvIDM7XHJcblxyXG5cdFx0Ly8gcmVuZGVyIGxpbmVzXHJcblxyXG5cdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGluZSApIHtcclxuXHJcblx0XHRcdHByaW1pdGl2ZXMgPSAoIG9iamVjdC50eXBlID09PSBUSFJFRS5MaW5lU3RyaXAgKSA/IF9nbC5MSU5FX1NUUklQIDogX2dsLkxJTkVTO1xyXG5cclxuXHRcdFx0c2V0TGluZVdpZHRoKCBtYXRlcmlhbC5saW5ld2lkdGggKTtcclxuXHJcblx0XHRcdF9nbC5kcmF3QXJyYXlzKCBwcmltaXRpdmVzLCAwLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xMaW5lQ291bnQgKTtcclxuXHJcblx0XHRcdF90aGlzLmluZm8ucmVuZGVyLmNhbGxzICsrO1xyXG5cclxuXHRcdC8vIHJlbmRlciBwYXJ0aWNsZXNcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5QYXJ0aWNsZVN5c3RlbSApIHtcclxuXHJcblx0XHRcdF9nbC5kcmF3QXJyYXlzKCBfZ2wuUE9JTlRTLCAwLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xQYXJ0aWNsZUNvdW50ICk7XHJcblxyXG5cdFx0XHRfdGhpcy5pbmZvLnJlbmRlci5jYWxscyArKztcclxuXHRcdFx0X3RoaXMuaW5mby5yZW5kZXIucG9pbnRzICs9IGdlb21ldHJ5R3JvdXAuX193ZWJnbFBhcnRpY2xlQ291bnQ7XHJcblxyXG5cdFx0Ly8gcmVuZGVyIHJpYmJvblxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlJpYmJvbiApIHtcclxuXHJcblx0XHRcdF9nbC5kcmF3QXJyYXlzKCBfZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIGdlb21ldHJ5R3JvdXAuX193ZWJnbFZlcnRleENvdW50ICk7XHJcblxyXG5cdFx0XHRfdGhpcy5pbmZvLnJlbmRlci5jYWxscyArKztcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlICkge1xyXG5cclxuXHRcdGlmICggISBfZW5hYmxlZEF0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdICkge1xyXG5cclxuXHRcdFx0X2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KCBhdHRyaWJ1dGUgKTtcclxuXHRcdFx0X2VuYWJsZWRBdHRyaWJ1dGVzWyBhdHRyaWJ1dGUgXSA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBkaXNhYmxlQXR0cmlidXRlcygpIHtcclxuXHJcblx0XHRmb3IgKCB2YXIgYXR0cmlidXRlIGluIF9lbmFibGVkQXR0cmlidXRlcyApIHtcclxuXHJcblx0XHRcdGlmICggX2VuYWJsZWRBdHRyaWJ1dGVzWyBhdHRyaWJ1dGUgXSApIHtcclxuXHJcblx0XHRcdFx0X2dsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheSggYXR0cmlidXRlICk7XHJcblx0XHRcdFx0X2VuYWJsZWRBdHRyaWJ1dGVzWyBhdHRyaWJ1dGUgXSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gc2V0dXBNb3JwaFRhcmdldHMgKCBtYXRlcmlhbCwgZ2VvbWV0cnlHcm91cCwgb2JqZWN0ICkge1xyXG5cclxuXHRcdC8vIHNldCBiYXNlXHJcblxyXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSBtYXRlcmlhbC5wcm9ncmFtLmF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0aWYgKCBvYmplY3QubW9ycGhUYXJnZXRCYXNlICE9PSAtMSAmJiBhdHRyaWJ1dGVzLnBvc2l0aW9uID49IDAgKSB7XHJcblxyXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsTW9ycGhUYXJnZXRzQnVmZmVyc1sgb2JqZWN0Lm1vcnBoVGFyZ2V0QmFzZSBdICk7XHJcblx0XHRcdGVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy5wb3NpdGlvbiApO1xyXG5cdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5wb3NpdGlvbiwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGF0dHJpYnV0ZXMucG9zaXRpb24gPj0gMCApIHtcclxuXHJcblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xWZXJ0ZXhCdWZmZXIgKTtcclxuXHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnBvc2l0aW9uICk7XHJcblx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnBvc2l0aW9uLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggb2JqZWN0Lm1vcnBoVGFyZ2V0Rm9yY2VkT3JkZXIubGVuZ3RoICkge1xyXG5cclxuXHRcdFx0Ly8gc2V0IGZvcmNlZCBvcmRlclxyXG5cclxuXHRcdFx0dmFyIG0gPSAwO1xyXG5cdFx0XHR2YXIgb3JkZXIgPSBvYmplY3QubW9ycGhUYXJnZXRGb3JjZWRPcmRlcjtcclxuXHRcdFx0dmFyIGluZmx1ZW5jZXMgPSBvYmplY3QubW9ycGhUYXJnZXRJbmZsdWVuY2VzO1xyXG5cclxuXHRcdFx0d2hpbGUgKCBtIDwgbWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhUYXJnZXRzICYmIG0gPCBvcmRlci5sZW5ndGggKSB7XHJcblxyXG5cdFx0XHRcdGlmICggYXR0cmlidXRlc1sgXCJtb3JwaFRhcmdldFwiICsgbSBdID49IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbE1vcnBoVGFyZ2V0c0J1ZmZlcnNbIG9yZGVyWyBtIF0gXSApO1xyXG5cdFx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzWyBcIm1vcnBoVGFyZ2V0XCIgKyBtIF0gKTtcclxuXHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzWyBcIm1vcnBoVGFyZ2V0XCIgKyBtIF0sIDMsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIGF0dHJpYnV0ZXNbIFwibW9ycGhOb3JtYWxcIiArIG0gXSA+PSAwICYmIG1hdGVyaWFsLm1vcnBoTm9ybWFscyApIHtcclxuXHJcblx0XHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsTW9ycGhOb3JtYWxzQnVmZmVyc1sgb3JkZXJbIG0gXSBdICk7XHJcblx0XHRcdFx0XHRlbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXNbIFwibW9ycGhOb3JtYWxcIiArIG0gXSApO1xyXG5cdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXNbIFwibW9ycGhOb3JtYWxcIiArIG0gXSwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdG9iamVjdC5fX3dlYmdsTW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBtIF0gPSBpbmZsdWVuY2VzWyBvcmRlclsgbSBdIF07XHJcblxyXG5cdFx0XHRcdG0gKys7XHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Ly8gZmluZCB0aGUgbW9zdCBpbmZsdWVuY2luZ1xyXG5cclxuXHRcdFx0dmFyIGluZmx1ZW5jZSwgYWN0aXZlSW5mbHVlbmNlSW5kaWNlcyA9IFtdO1xyXG5cdFx0XHR2YXIgaW5mbHVlbmNlcyA9IG9iamVjdC5tb3JwaFRhcmdldEluZmx1ZW5jZXM7XHJcblx0XHRcdHZhciBpLCBpbCA9IGluZmx1ZW5jZXMubGVuZ3RoO1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0aW5mbHVlbmNlID0gaW5mbHVlbmNlc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGluZmx1ZW5jZSA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0YWN0aXZlSW5mbHVlbmNlSW5kaWNlcy5wdXNoKCBbIGluZmx1ZW5jZSwgaSBdICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggYWN0aXZlSW5mbHVlbmNlSW5kaWNlcy5sZW5ndGggPiBtYXRlcmlhbC5udW1TdXBwb3J0ZWRNb3JwaFRhcmdldHMgKSB7XHJcblxyXG5cdFx0XHRcdGFjdGl2ZUluZmx1ZW5jZUluZGljZXMuc29ydCggbnVtZXJpY2FsU29ydCApO1xyXG5cdFx0XHRcdGFjdGl2ZUluZmx1ZW5jZUluZGljZXMubGVuZ3RoID0gbWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhUYXJnZXRzO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggYWN0aXZlSW5mbHVlbmNlSW5kaWNlcy5sZW5ndGggPiBtYXRlcmlhbC5udW1TdXBwb3J0ZWRNb3JwaE5vcm1hbHMgKSB7XHJcblxyXG5cdFx0XHRcdGFjdGl2ZUluZmx1ZW5jZUluZGljZXMuc29ydCggbnVtZXJpY2FsU29ydCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggYWN0aXZlSW5mbHVlbmNlSW5kaWNlcy5sZW5ndGggPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdGFjdGl2ZUluZmx1ZW5jZUluZGljZXMucHVzaCggWyAwLCAwIF0gKTtcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHR2YXIgaW5mbHVlbmNlSW5kZXgsIG0gPSAwO1xyXG5cclxuXHRcdFx0d2hpbGUgKCBtIDwgbWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhUYXJnZXRzICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGFjdGl2ZUluZmx1ZW5jZUluZGljZXNbIG0gXSApIHtcclxuXHJcblx0XHRcdFx0XHRpbmZsdWVuY2VJbmRleCA9IGFjdGl2ZUluZmx1ZW5jZUluZGljZXNbIG0gXVsgMSBdO1xyXG5cclxuXHRcdFx0XHRcdGlmICggYXR0cmlidXRlc1sgXCJtb3JwaFRhcmdldFwiICsgbSBdID49IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsTW9ycGhUYXJnZXRzQnVmZmVyc1sgaW5mbHVlbmNlSW5kZXggXSApO1xyXG5cdFx0XHRcdFx0XHRlbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXNbIFwibW9ycGhUYXJnZXRcIiArIG0gXSApO1xyXG5cdFx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlc1sgXCJtb3JwaFRhcmdldFwiICsgbSBdLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmICggYXR0cmlidXRlc1sgXCJtb3JwaE5vcm1hbFwiICsgbSBdID49IDAgJiYgbWF0ZXJpYWwubW9ycGhOb3JtYWxzICkge1xyXG5cclxuXHRcdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbE1vcnBoTm9ybWFsc0J1ZmZlcnNbIGluZmx1ZW5jZUluZGV4IF0gKTtcclxuXHRcdFx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzWyBcIm1vcnBoTm9ybWFsXCIgKyBtIF0gKTtcclxuXHRcdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXNbIFwibW9ycGhOb3JtYWxcIiArIG0gXSwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xyXG5cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0b2JqZWN0Ll9fd2ViZ2xNb3JwaFRhcmdldEluZmx1ZW5jZXNbIG0gXSA9IGluZmx1ZW5jZXNbIGluZmx1ZW5jZUluZGV4IF07XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0LypcclxuXHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzWyBcIm1vcnBoVGFyZ2V0XCIgKyBtIF0sIDMsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsLm1vcnBoTm9ybWFscyApIHtcclxuXHJcblx0XHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzWyBcIm1vcnBoTm9ybWFsXCIgKyBtIF0sIDMsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHQqL1xyXG5cclxuXHRcdFx0XHRcdG9iamVjdC5fX3dlYmdsTW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBtIF0gPSAwO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdG0gKys7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGxvYWQgdXBkYXRlZCBpbmZsdWVuY2VzIHVuaWZvcm1cclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLnByb2dyYW0udW5pZm9ybXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0X2dsLnVuaWZvcm0xZnYoIG1hdGVyaWFsLnByb2dyYW0udW5pZm9ybXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzLCBvYmplY3QuX193ZWJnbE1vcnBoVGFyZ2V0SW5mbHVlbmNlcyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0Ly8gU29ydGluZ1xyXG5cclxuXHRmdW5jdGlvbiBwYWludGVyU29ydFN0YWJsZSAoIGEsIGIgKSB7XHJcblxyXG5cdFx0aWYgKCBhLnogIT09IGIueiApIHtcclxuXHJcblx0XHRcdHJldHVybiBiLnogLSBhLno7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHJldHVybiBiLmlkIC0gYS5pZDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIG51bWVyaWNhbFNvcnQgKCBhLCBiICkge1xyXG5cclxuXHRcdHJldHVybiBiWyAwIF0gLSBhWyAwIF07XHJcblxyXG5cdH07XHJcblxyXG5cclxuXHQvLyBSZW5kZXJpbmdcclxuXHJcblx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEsIHJlbmRlclRhcmdldCwgZm9yY2VDbGVhciApIHtcclxuXHJcblx0XHRpZiAoIGNhbWVyYSBpbnN0YW5jZW9mIFRIUkVFLkNhbWVyYSA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5yZW5kZXI6IGNhbWVyYSBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuQ2FtZXJhLicgKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaSwgaWwsXHJcblxyXG5cdFx0d2ViZ2xPYmplY3QsIG9iamVjdCxcclxuXHRcdHJlbmRlckxpc3QsXHJcblxyXG5cdFx0bGlnaHRzID0gc2NlbmUuX19saWdodHMsXHJcblx0XHRmb2cgPSBzY2VuZS5mb2c7XHJcblxyXG5cdFx0Ly8gcmVzZXQgY2FjaGluZyBmb3IgdGhpcyBmcmFtZVxyXG5cclxuXHRcdF9jdXJyZW50TWF0ZXJpYWxJZCA9IC0xO1xyXG5cdFx0X2xpZ2h0c05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdC8vIHVwZGF0ZSBzY2VuZSBncmFwaFxyXG5cclxuXHRcdGlmICggdGhpcy5hdXRvVXBkYXRlU2NlbmUgKSBzY2VuZS51cGRhdGVNYXRyaXhXb3JsZCgpO1xyXG5cclxuXHRcdC8vIHVwZGF0ZSBjYW1lcmEgbWF0cmljZXMgYW5kIGZydXN0dW1cclxuXHJcblx0XHRpZiAoIGNhbWVyYS5wYXJlbnQgPT09IHVuZGVmaW5lZCApIGNhbWVyYS51cGRhdGVNYXRyaXhXb3JsZCgpO1xyXG5cclxuXHRcdGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UuZ2V0SW52ZXJzZSggY2FtZXJhLm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0X3Byb2pTY3JlZW5NYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcclxuXHRcdF9mcnVzdHVtLnNldEZyb21NYXRyaXgoIF9wcm9qU2NyZWVuTWF0cml4ICk7XHJcblxyXG5cdFx0Ly8gdXBkYXRlIFdlYkdMIG9iamVjdHNcclxuXHJcblx0XHRpZiAoIHRoaXMuYXV0b1VwZGF0ZU9iamVjdHMgKSB0aGlzLmluaXRXZWJHTE9iamVjdHMoIHNjZW5lICk7XHJcblxyXG5cdFx0Ly8gY3VzdG9tIHJlbmRlciBwbHVnaW5zIChwcmUgcGFzcylcclxuXHJcblx0XHRyZW5kZXJQbHVnaW5zKCB0aGlzLnJlbmRlclBsdWdpbnNQcmUsIHNjZW5lLCBjYW1lcmEgKTtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdF90aGlzLmluZm8ucmVuZGVyLmNhbGxzID0gMDtcclxuXHRcdF90aGlzLmluZm8ucmVuZGVyLnZlcnRpY2VzID0gMDtcclxuXHRcdF90aGlzLmluZm8ucmVuZGVyLmZhY2VzID0gMDtcclxuXHRcdF90aGlzLmluZm8ucmVuZGVyLnBvaW50cyA9IDA7XHJcblxyXG5cdFx0dGhpcy5zZXRSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdGlmICggdGhpcy5hdXRvQ2xlYXIgfHwgZm9yY2VDbGVhciApIHtcclxuXHJcblx0XHRcdHRoaXMuY2xlYXIoIHRoaXMuYXV0b0NsZWFyQ29sb3IsIHRoaXMuYXV0b0NsZWFyRGVwdGgsIHRoaXMuYXV0b0NsZWFyU3RlbmNpbCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBzZXQgbWF0cmljZXMgZm9yIHJlZ3VsYXIgb2JqZWN0cyAoZnJ1c3R1bSBjdWxsZWQpXHJcblxyXG5cdFx0cmVuZGVyTGlzdCA9IHNjZW5lLl9fd2ViZ2xPYmplY3RzO1xyXG5cclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IHJlbmRlckxpc3QubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR3ZWJnbE9iamVjdCA9IHJlbmRlckxpc3RbIGkgXTtcclxuXHRcdFx0b2JqZWN0ID0gd2ViZ2xPYmplY3Qub2JqZWN0O1xyXG5cclxuXHRcdFx0d2ViZ2xPYmplY3QucmVuZGVyID0gZmFsc2U7XHJcblxyXG5cdFx0XHRpZiAoIG9iamVjdC52aXNpYmxlICkge1xyXG5cclxuXHRcdFx0XHRpZiAoICEgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5NZXNoIHx8IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlBhcnRpY2xlU3lzdGVtICkgfHwgISAoIG9iamVjdC5mcnVzdHVtQ3VsbGVkICkgfHwgX2ZydXN0dW0uaW50ZXJzZWN0c09iamVjdCggb2JqZWN0ICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0c2V0dXBNYXRyaWNlcyggb2JqZWN0LCBjYW1lcmEgKTtcclxuXHJcblx0XHRcdFx0XHR1bnJvbGxCdWZmZXJNYXRlcmlhbCggd2ViZ2xPYmplY3QgKTtcclxuXHJcblx0XHRcdFx0XHR3ZWJnbE9iamVjdC5yZW5kZXIgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHRcdGlmICggdGhpcy5zb3J0T2JqZWN0cyA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggb2JqZWN0LnJlbmRlckRlcHRoICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR3ZWJnbE9iamVjdC56ID0gb2JqZWN0LnJlbmRlckRlcHRoO1xyXG5cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0X3ZlY3RvcjMuZ2V0UG9zaXRpb25Gcm9tTWF0cml4KCBvYmplY3QubWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHRcdFx0XHRfdmVjdG9yMy5hcHBseVByb2plY3Rpb24oIF9wcm9qU2NyZWVuTWF0cml4ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHdlYmdsT2JqZWN0LnogPSBfdmVjdG9yMy56O1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0d2ViZ2xPYmplY3QuaWQgPSBvYmplY3QuaWQ7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5zb3J0T2JqZWN0cyApIHtcclxuXHJcblx0XHRcdHJlbmRlckxpc3Quc29ydCggcGFpbnRlclNvcnRTdGFibGUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc2V0IG1hdHJpY2VzIGZvciBpbW1lZGlhdGUgb2JqZWN0c1xyXG5cclxuXHRcdHJlbmRlckxpc3QgPSBzY2VuZS5fX3dlYmdsT2JqZWN0c0ltbWVkaWF0ZTtcclxuXHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSByZW5kZXJMaXN0Lmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0d2ViZ2xPYmplY3QgPSByZW5kZXJMaXN0WyBpIF07XHJcblx0XHRcdG9iamVjdCA9IHdlYmdsT2JqZWN0Lm9iamVjdDtcclxuXHJcblx0XHRcdGlmICggb2JqZWN0LnZpc2libGUgKSB7XHJcblxyXG5cdFx0XHRcdHNldHVwTWF0cmljZXMoIG9iamVjdCwgY2FtZXJhICk7XHJcblxyXG5cdFx0XHRcdHVucm9sbEltbWVkaWF0ZUJ1ZmZlck1hdGVyaWFsKCB3ZWJnbE9iamVjdCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHNjZW5lLm92ZXJyaWRlTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHR2YXIgbWF0ZXJpYWwgPSBzY2VuZS5vdmVycmlkZU1hdGVyaWFsO1xyXG5cclxuXHRcdFx0dGhpcy5zZXRCbGVuZGluZyggbWF0ZXJpYWwuYmxlbmRpbmcsIG1hdGVyaWFsLmJsZW5kRXF1YXRpb24sIG1hdGVyaWFsLmJsZW5kU3JjLCBtYXRlcmlhbC5ibGVuZERzdCApO1xyXG5cdFx0XHR0aGlzLnNldERlcHRoVGVzdCggbWF0ZXJpYWwuZGVwdGhUZXN0ICk7XHJcblx0XHRcdHRoaXMuc2V0RGVwdGhXcml0ZSggbWF0ZXJpYWwuZGVwdGhXcml0ZSApO1xyXG5cdFx0XHRzZXRQb2x5Z29uT2Zmc2V0KCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0LCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0RmFjdG9yLCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0VW5pdHMgKTtcclxuXHJcblx0XHRcdHJlbmRlck9iamVjdHMoIHNjZW5lLl9fd2ViZ2xPYmplY3RzLCBmYWxzZSwgXCJcIiwgY2FtZXJhLCBsaWdodHMsIGZvZywgdHJ1ZSwgbWF0ZXJpYWwgKTtcclxuXHRcdFx0cmVuZGVyT2JqZWN0c0ltbWVkaWF0ZSggc2NlbmUuX193ZWJnbE9iamVjdHNJbW1lZGlhdGUsIFwiXCIsIGNhbWVyYSwgbGlnaHRzLCBmb2csIGZhbHNlLCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR2YXIgbWF0ZXJpYWwgPSBudWxsO1xyXG5cclxuXHRcdFx0Ly8gb3BhcXVlIHBhc3MgKGZyb250LXRvLWJhY2sgb3JkZXIpXHJcblxyXG5cdFx0XHR0aGlzLnNldEJsZW5kaW5nKCBUSFJFRS5Ob0JsZW5kaW5nICk7XHJcblxyXG5cdFx0XHRyZW5kZXJPYmplY3RzKCBzY2VuZS5fX3dlYmdsT2JqZWN0cywgdHJ1ZSwgXCJvcGFxdWVcIiwgY2FtZXJhLCBsaWdodHMsIGZvZywgZmFsc2UsIG1hdGVyaWFsICk7XHJcblx0XHRcdHJlbmRlck9iamVjdHNJbW1lZGlhdGUoIHNjZW5lLl9fd2ViZ2xPYmplY3RzSW1tZWRpYXRlLCBcIm9wYXF1ZVwiLCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBmYWxzZSwgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdC8vIHRyYW5zcGFyZW50IHBhc3MgKGJhY2stdG8tZnJvbnQgb3JkZXIpXHJcblxyXG5cdFx0XHRyZW5kZXJPYmplY3RzKCBzY2VuZS5fX3dlYmdsT2JqZWN0cywgZmFsc2UsIFwidHJhbnNwYXJlbnRcIiwgY2FtZXJhLCBsaWdodHMsIGZvZywgdHJ1ZSwgbWF0ZXJpYWwgKTtcclxuXHRcdFx0cmVuZGVyT2JqZWN0c0ltbWVkaWF0ZSggc2NlbmUuX193ZWJnbE9iamVjdHNJbW1lZGlhdGUsIFwidHJhbnNwYXJlbnRcIiwgY2FtZXJhLCBsaWdodHMsIGZvZywgdHJ1ZSwgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY3VzdG9tIHJlbmRlciBwbHVnaW5zIChwb3N0IHBhc3MpXHJcblxyXG5cdFx0cmVuZGVyUGx1Z2lucyggdGhpcy5yZW5kZXJQbHVnaW5zUG9zdCwgc2NlbmUsIGNhbWVyYSApO1xyXG5cclxuXHJcblx0XHQvLyBHZW5lcmF0ZSBtaXBtYXAgaWYgd2UncmUgdXNpbmcgYW55IGtpbmQgb2YgbWlwbWFwIGZpbHRlcmluZ1xyXG5cclxuXHRcdGlmICggcmVuZGVyVGFyZ2V0ICYmIHJlbmRlclRhcmdldC5nZW5lcmF0ZU1pcG1hcHMgJiYgcmVuZGVyVGFyZ2V0Lm1pbkZpbHRlciAhPT0gVEhSRUUuTmVhcmVzdEZpbHRlciAmJiByZW5kZXJUYXJnZXQubWluRmlsdGVyICE9PSBUSFJFRS5MaW5lYXJGaWx0ZXIgKSB7XHJcblxyXG5cdFx0XHR1cGRhdGVSZW5kZXJUYXJnZXRNaXBtYXAoIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBFbnN1cmUgZGVwdGggYnVmZmVyIHdyaXRpbmcgaXMgZW5hYmxlZCBzbyBpdCBjYW4gYmUgY2xlYXJlZCBvbiBuZXh0IHJlbmRlclxyXG5cclxuXHRcdHRoaXMuc2V0RGVwdGhUZXN0KCB0cnVlICk7XHJcblx0XHR0aGlzLnNldERlcHRoV3JpdGUoIHRydWUgKTtcclxuXHJcblx0XHQvLyBfZ2wuZmluaXNoKCk7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIHJlbmRlclBsdWdpbnMoIHBsdWdpbnMsIHNjZW5lLCBjYW1lcmEgKSB7XHJcblxyXG5cdFx0aWYgKCAhIHBsdWdpbnMubGVuZ3RoICkgcmV0dXJuO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwbHVnaW5zLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0Ly8gcmVzZXQgc3RhdGUgZm9yIHBsdWdpbiAodG8gc3RhcnQgZnJvbSBjbGVhbiBzbGF0ZSlcclxuXHJcblx0XHRcdF9jdXJyZW50UHJvZ3JhbSA9IG51bGw7XHJcblx0XHRcdF9jdXJyZW50Q2FtZXJhID0gbnVsbDtcclxuXHJcblx0XHRcdF9vbGRCbGVuZGluZyA9IC0xO1xyXG5cdFx0XHRfb2xkRGVwdGhUZXN0ID0gLTE7XHJcblx0XHRcdF9vbGREZXB0aFdyaXRlID0gLTE7XHJcblx0XHRcdF9vbGREb3VibGVTaWRlZCA9IC0xO1xyXG5cdFx0XHRfb2xkRmxpcFNpZGVkID0gLTE7XHJcblx0XHRcdF9jdXJyZW50R2VvbWV0cnlHcm91cEhhc2ggPSAtMTtcclxuXHRcdFx0X2N1cnJlbnRNYXRlcmlhbElkID0gLTE7XHJcblxyXG5cdFx0XHRfbGlnaHRzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHRwbHVnaW5zWyBpIF0ucmVuZGVyKCBzY2VuZSwgY2FtZXJhLCBfY3VycmVudFdpZHRoLCBfY3VycmVudEhlaWdodCApO1xyXG5cclxuXHRcdFx0Ly8gcmVzZXQgc3RhdGUgYWZ0ZXIgcGx1Z2luIChhbnl0aGluZyBjb3VsZCBoYXZlIGNoYW5nZWQpXHJcblxyXG5cdFx0XHRfY3VycmVudFByb2dyYW0gPSBudWxsO1xyXG5cdFx0XHRfY3VycmVudENhbWVyYSA9IG51bGw7XHJcblxyXG5cdFx0XHRfb2xkQmxlbmRpbmcgPSAtMTtcclxuXHRcdFx0X29sZERlcHRoVGVzdCA9IC0xO1xyXG5cdFx0XHRfb2xkRGVwdGhXcml0ZSA9IC0xO1xyXG5cdFx0XHRfb2xkRG91YmxlU2lkZWQgPSAtMTtcclxuXHRcdFx0X29sZEZsaXBTaWRlZCA9IC0xO1xyXG5cdFx0XHRfY3VycmVudEdlb21ldHJ5R3JvdXBIYXNoID0gLTE7XHJcblx0XHRcdF9jdXJyZW50TWF0ZXJpYWxJZCA9IC0xO1xyXG5cclxuXHRcdFx0X2xpZ2h0c05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gcmVuZGVyT2JqZWN0cyAoIHJlbmRlckxpc3QsIHJldmVyc2UsIG1hdGVyaWFsVHlwZSwgY2FtZXJhLCBsaWdodHMsIGZvZywgdXNlQmxlbmRpbmcsIG92ZXJyaWRlTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0dmFyIHdlYmdsT2JqZWN0LCBvYmplY3QsIGJ1ZmZlciwgbWF0ZXJpYWwsIHN0YXJ0LCBlbmQsIGRlbHRhO1xyXG5cclxuXHRcdGlmICggcmV2ZXJzZSApIHtcclxuXHJcblx0XHRcdHN0YXJ0ID0gcmVuZGVyTGlzdC5sZW5ndGggLSAxO1xyXG5cdFx0XHRlbmQgPSAtMTtcclxuXHRcdFx0ZGVsdGEgPSAtMTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0c3RhcnQgPSAwO1xyXG5cdFx0XHRlbmQgPSByZW5kZXJMaXN0Lmxlbmd0aDtcclxuXHRcdFx0ZGVsdGEgPSAxO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIHZhciBpID0gc3RhcnQ7IGkgIT09IGVuZDsgaSArPSBkZWx0YSApIHtcclxuXHJcblx0XHRcdHdlYmdsT2JqZWN0ID0gcmVuZGVyTGlzdFsgaSBdO1xyXG5cclxuXHRcdFx0aWYgKCB3ZWJnbE9iamVjdC5yZW5kZXIgKSB7XHJcblxyXG5cdFx0XHRcdG9iamVjdCA9IHdlYmdsT2JqZWN0Lm9iamVjdDtcclxuXHRcdFx0XHRidWZmZXIgPSB3ZWJnbE9iamVjdC5idWZmZXI7XHJcblxyXG5cdFx0XHRcdGlmICggb3ZlcnJpZGVNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdFx0XHRtYXRlcmlhbCA9IG92ZXJyaWRlTWF0ZXJpYWw7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0bWF0ZXJpYWwgPSB3ZWJnbE9iamVjdFsgbWF0ZXJpYWxUeXBlIF07XHJcblxyXG5cdFx0XHRcdFx0aWYgKCAhIG1hdGVyaWFsICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB1c2VCbGVuZGluZyApIF90aGlzLnNldEJsZW5kaW5nKCBtYXRlcmlhbC5ibGVuZGluZywgbWF0ZXJpYWwuYmxlbmRFcXVhdGlvbiwgbWF0ZXJpYWwuYmxlbmRTcmMsIG1hdGVyaWFsLmJsZW5kRHN0ICk7XHJcblxyXG5cdFx0XHRcdFx0X3RoaXMuc2V0RGVwdGhUZXN0KCBtYXRlcmlhbC5kZXB0aFRlc3QgKTtcclxuXHRcdFx0XHRcdF90aGlzLnNldERlcHRoV3JpdGUoIG1hdGVyaWFsLmRlcHRoV3JpdGUgKTtcclxuXHRcdFx0XHRcdHNldFBvbHlnb25PZmZzZXQoIG1hdGVyaWFsLnBvbHlnb25PZmZzZXQsIG1hdGVyaWFsLnBvbHlnb25PZmZzZXRGYWN0b3IsIG1hdGVyaWFsLnBvbHlnb25PZmZzZXRVbml0cyApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdF90aGlzLnNldE1hdGVyaWFsRmFjZXMoIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHRcdGlmICggYnVmZmVyIGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHRcdFx0X3RoaXMucmVuZGVyQnVmZmVyRGlyZWN0KCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBtYXRlcmlhbCwgYnVmZmVyLCBvYmplY3QgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRfdGhpcy5yZW5kZXJCdWZmZXIoIGNhbWVyYSwgbGlnaHRzLCBmb2csIG1hdGVyaWFsLCBidWZmZXIsIG9iamVjdCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiByZW5kZXJPYmplY3RzSW1tZWRpYXRlICggcmVuZGVyTGlzdCwgbWF0ZXJpYWxUeXBlLCBjYW1lcmEsIGxpZ2h0cywgZm9nLCB1c2VCbGVuZGluZywgb3ZlcnJpZGVNYXRlcmlhbCApIHtcclxuXHJcblx0XHR2YXIgd2ViZ2xPYmplY3QsIG9iamVjdCwgbWF0ZXJpYWwsIHByb2dyYW07XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHJlbmRlckxpc3QubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR3ZWJnbE9iamVjdCA9IHJlbmRlckxpc3RbIGkgXTtcclxuXHRcdFx0b2JqZWN0ID0gd2ViZ2xPYmplY3Qub2JqZWN0O1xyXG5cclxuXHRcdFx0aWYgKCBvYmplY3QudmlzaWJsZSApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBvdmVycmlkZU1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRcdG1hdGVyaWFsID0gb3ZlcnJpZGVNYXRlcmlhbDtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRtYXRlcmlhbCA9IHdlYmdsT2JqZWN0WyBtYXRlcmlhbFR5cGUgXTtcclxuXHJcblx0XHRcdFx0XHRpZiAoICEgbWF0ZXJpYWwgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHVzZUJsZW5kaW5nICkgX3RoaXMuc2V0QmxlbmRpbmcoIG1hdGVyaWFsLmJsZW5kaW5nLCBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uLCBtYXRlcmlhbC5ibGVuZFNyYywgbWF0ZXJpYWwuYmxlbmREc3QgKTtcclxuXHJcblx0XHRcdFx0XHRfdGhpcy5zZXREZXB0aFRlc3QoIG1hdGVyaWFsLmRlcHRoVGVzdCApO1xyXG5cdFx0XHRcdFx0X3RoaXMuc2V0RGVwdGhXcml0ZSggbWF0ZXJpYWwuZGVwdGhXcml0ZSApO1xyXG5cdFx0XHRcdFx0c2V0UG9seWdvbk9mZnNldCggbWF0ZXJpYWwucG9seWdvbk9mZnNldCwgbWF0ZXJpYWwucG9seWdvbk9mZnNldEZhY3RvciwgbWF0ZXJpYWwucG9seWdvbk9mZnNldFVuaXRzICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0X3RoaXMucmVuZGVySW1tZWRpYXRlT2JqZWN0KCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBtYXRlcmlhbCwgb2JqZWN0ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnJlbmRlckltbWVkaWF0ZU9iamVjdCA9IGZ1bmN0aW9uICggY2FtZXJhLCBsaWdodHMsIGZvZywgbWF0ZXJpYWwsIG9iamVjdCApIHtcclxuXHJcblx0XHR2YXIgcHJvZ3JhbSA9IHNldFByb2dyYW0oIGNhbWVyYSwgbGlnaHRzLCBmb2csIG1hdGVyaWFsLCBvYmplY3QgKTtcclxuXHJcblx0XHRfY3VycmVudEdlb21ldHJ5R3JvdXBIYXNoID0gLTE7XHJcblxyXG5cdFx0X3RoaXMuc2V0TWF0ZXJpYWxGYWNlcyggbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRpZiAoIG9iamVjdC5pbW1lZGlhdGVSZW5kZXJDYWxsYmFjayApIHtcclxuXHJcblx0XHRcdG9iamVjdC5pbW1lZGlhdGVSZW5kZXJDYWxsYmFjayggcHJvZ3JhbSwgX2dsLCBfZnJ1c3R1bSApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRvYmplY3QucmVuZGVyKCBmdW5jdGlvbiggb2JqZWN0ICkgeyBfdGhpcy5yZW5kZXJCdWZmZXJJbW1lZGlhdGUoIG9iamVjdCwgcHJvZ3JhbSwgbWF0ZXJpYWwgKTsgfSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gdW5yb2xsSW1tZWRpYXRlQnVmZmVyTWF0ZXJpYWwgKCBnbG9iamVjdCApIHtcclxuXHJcblx0XHR2YXIgb2JqZWN0ID0gZ2xvYmplY3Qub2JqZWN0LFxyXG5cdFx0XHRtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLnRyYW5zcGFyZW50ICkge1xyXG5cclxuXHRcdFx0Z2xvYmplY3QudHJhbnNwYXJlbnQgPSBtYXRlcmlhbDtcclxuXHRcdFx0Z2xvYmplY3Qub3BhcXVlID0gbnVsbDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Z2xvYmplY3Qub3BhcXVlID0gbWF0ZXJpYWw7XHJcblx0XHRcdGdsb2JqZWN0LnRyYW5zcGFyZW50ID0gbnVsbDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIHVucm9sbEJ1ZmZlck1hdGVyaWFsICggZ2xvYmplY3QgKSB7XHJcblxyXG5cdFx0dmFyIG9iamVjdCA9IGdsb2JqZWN0Lm9iamVjdCxcclxuXHRcdFx0YnVmZmVyID0gZ2xvYmplY3QuYnVmZmVyLFxyXG5cdFx0XHRtYXRlcmlhbCwgbWF0ZXJpYWxJbmRleCwgbWVzaE1hdGVyaWFsO1xyXG5cclxuXHRcdG1lc2hNYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcclxuXHJcblx0XHRpZiAoIG1lc2hNYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hGYWNlTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRtYXRlcmlhbEluZGV4ID0gYnVmZmVyLm1hdGVyaWFsSW5kZXg7XHJcblxyXG5cdFx0XHRtYXRlcmlhbCA9IG1lc2hNYXRlcmlhbC5tYXRlcmlhbHNbIG1hdGVyaWFsSW5kZXggXTtcclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwudHJhbnNwYXJlbnQgKSB7XHJcblxyXG5cdFx0XHRcdGdsb2JqZWN0LnRyYW5zcGFyZW50ID0gbWF0ZXJpYWw7XHJcblx0XHRcdFx0Z2xvYmplY3Qub3BhcXVlID0gbnVsbDtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGdsb2JqZWN0Lm9wYXF1ZSA9IG1hdGVyaWFsO1xyXG5cdFx0XHRcdGdsb2JqZWN0LnRyYW5zcGFyZW50ID0gbnVsbDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0bWF0ZXJpYWwgPSBtZXNoTWF0ZXJpYWw7XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIG1hdGVyaWFsLnRyYW5zcGFyZW50ICkge1xyXG5cclxuXHRcdFx0XHRcdGdsb2JqZWN0LnRyYW5zcGFyZW50ID0gbWF0ZXJpYWw7XHJcblx0XHRcdFx0XHRnbG9iamVjdC5vcGFxdWUgPSBudWxsO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGdsb2JqZWN0Lm9wYXF1ZSA9IG1hdGVyaWFsO1xyXG5cdFx0XHRcdFx0Z2xvYmplY3QudHJhbnNwYXJlbnQgPSBudWxsO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBHZW9tZXRyeSBzcGxpdHRpbmdcclxuXHJcblx0ZnVuY3Rpb24gc29ydEZhY2VzQnlNYXRlcmlhbCAoIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHR2YXIgZiwgZmwsIGZhY2UsIG1hdGVyaWFsSW5kZXgsIHZlcnRpY2VzLFxyXG5cdFx0XHRncm91cEhhc2gsIGhhc2hfbWFwID0ge307XHJcblxyXG5cdFx0dmFyIG51bU1vcnBoVGFyZ2V0cyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGg7XHJcblx0XHR2YXIgbnVtTW9ycGhOb3JtYWxzID0gZ2VvbWV0cnkubW9ycGhOb3JtYWxzLmxlbmd0aDtcclxuXHJcblx0XHR2YXIgdXNlc0ZhY2VNYXRlcmlhbCA9IG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaEZhY2VNYXRlcmlhbDtcclxuXHJcblx0XHRnZW9tZXRyeS5nZW9tZXRyeUdyb3VwcyA9IHt9O1xyXG5cclxuXHRcdGZvciAoIGYgPSAwLCBmbCA9IGdlb21ldHJ5LmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0ZmFjZSA9IGdlb21ldHJ5LmZhY2VzWyBmIF07XHJcblx0XHRcdG1hdGVyaWFsSW5kZXggPSB1c2VzRmFjZU1hdGVyaWFsID8gZmFjZS5tYXRlcmlhbEluZGV4IDogMDtcclxuXHJcblx0XHRcdGlmICggaGFzaF9tYXBbIG1hdGVyaWFsSW5kZXggXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRoYXNoX21hcFsgbWF0ZXJpYWxJbmRleCBdID0geyAnaGFzaCc6IG1hdGVyaWFsSW5kZXgsICdjb3VudGVyJzogMCB9O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Z3JvdXBIYXNoID0gaGFzaF9tYXBbIG1hdGVyaWFsSW5kZXggXS5oYXNoICsgJ18nICsgaGFzaF9tYXBbIG1hdGVyaWFsSW5kZXggXS5jb3VudGVyO1xyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyeS5nZW9tZXRyeUdyb3Vwc1sgZ3JvdXBIYXNoIF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Z2VvbWV0cnkuZ2VvbWV0cnlHcm91cHNbIGdyb3VwSGFzaCBdID0geyAnZmFjZXMzJzogW10sICdmYWNlczQnOiBbXSwgJ21hdGVyaWFsSW5kZXgnOiBtYXRlcmlhbEluZGV4LCAndmVydGljZXMnOiAwLCAnbnVtTW9ycGhUYXJnZXRzJzogbnVtTW9ycGhUYXJnZXRzLCAnbnVtTW9ycGhOb3JtYWxzJzogbnVtTW9ycGhOb3JtYWxzIH07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2ZXJ0aWNlcyA9IGZhY2UgaW5zdGFuY2VvZiBUSFJFRS5GYWNlMyA/IDMgOiA0O1xyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyeS5nZW9tZXRyeUdyb3Vwc1sgZ3JvdXBIYXNoIF0udmVydGljZXMgKyB2ZXJ0aWNlcyA+IDY1NTM1ICkge1xyXG5cclxuXHRcdFx0XHRoYXNoX21hcFsgbWF0ZXJpYWxJbmRleCBdLmNvdW50ZXIgKz0gMTtcclxuXHRcdFx0XHRncm91cEhhc2ggPSBoYXNoX21hcFsgbWF0ZXJpYWxJbmRleCBdLmhhc2ggKyAnXycgKyBoYXNoX21hcFsgbWF0ZXJpYWxJbmRleCBdLmNvdW50ZXI7XHJcblxyXG5cdFx0XHRcdGlmICggZ2VvbWV0cnkuZ2VvbWV0cnlHcm91cHNbIGdyb3VwSGFzaCBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0Z2VvbWV0cnkuZ2VvbWV0cnlHcm91cHNbIGdyb3VwSGFzaCBdID0geyAnZmFjZXMzJzogW10sICdmYWNlczQnOiBbXSwgJ21hdGVyaWFsSW5kZXgnOiBtYXRlcmlhbEluZGV4LCAndmVydGljZXMnOiAwLCAnbnVtTW9ycGhUYXJnZXRzJzogbnVtTW9ycGhUYXJnZXRzLCAnbnVtTW9ycGhOb3JtYWxzJzogbnVtTW9ycGhOb3JtYWxzIH07XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggZmFjZSBpbnN0YW5jZW9mIFRIUkVFLkZhY2UzICkge1xyXG5cclxuXHRcdFx0XHRnZW9tZXRyeS5nZW9tZXRyeUdyb3Vwc1sgZ3JvdXBIYXNoIF0uZmFjZXMzLnB1c2goIGYgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5Lmdlb21ldHJ5R3JvdXBzWyBncm91cEhhc2ggXS5mYWNlczQucHVzaCggZiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Z2VvbWV0cnkuZ2VvbWV0cnlHcm91cHNbIGdyb3VwSGFzaCBdLnZlcnRpY2VzICs9IHZlcnRpY2VzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRnZW9tZXRyeS5nZW9tZXRyeUdyb3Vwc0xpc3QgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgZyBpbiBnZW9tZXRyeS5nZW9tZXRyeUdyb3VwcyApIHtcclxuXHJcblx0XHRcdGdlb21ldHJ5Lmdlb21ldHJ5R3JvdXBzWyBnIF0uaWQgPSBfZ2VvbWV0cnlHcm91cENvdW50ZXIgKys7XHJcblxyXG5cdFx0XHRnZW9tZXRyeS5nZW9tZXRyeUdyb3Vwc0xpc3QucHVzaCggZ2VvbWV0cnkuZ2VvbWV0cnlHcm91cHNbIGcgXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0Ly8gT2JqZWN0cyByZWZyZXNoXHJcblxyXG5cdHRoaXMuaW5pdFdlYkdMT2JqZWN0cyA9IGZ1bmN0aW9uICggc2NlbmUgKSB7XHJcblxyXG5cdFx0aWYgKCAhc2NlbmUuX193ZWJnbE9iamVjdHMgKSB7XHJcblxyXG5cdFx0XHRzY2VuZS5fX3dlYmdsT2JqZWN0cyA9IFtdO1xyXG5cdFx0XHRzY2VuZS5fX3dlYmdsT2JqZWN0c0ltbWVkaWF0ZSA9IFtdO1xyXG5cdFx0XHRzY2VuZS5fX3dlYmdsU3ByaXRlcyA9IFtdO1xyXG5cdFx0XHRzY2VuZS5fX3dlYmdsRmxhcmVzID0gW107XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHdoaWxlICggc2NlbmUuX19vYmplY3RzQWRkZWQubGVuZ3RoICkge1xyXG5cclxuXHRcdFx0YWRkT2JqZWN0KCBzY2VuZS5fX29iamVjdHNBZGRlZFsgMCBdLCBzY2VuZSApO1xyXG5cdFx0XHRzY2VuZS5fX29iamVjdHNBZGRlZC5zcGxpY2UoIDAsIDEgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0d2hpbGUgKCBzY2VuZS5fX29iamVjdHNSZW1vdmVkLmxlbmd0aCApIHtcclxuXHJcblx0XHRcdHJlbW92ZU9iamVjdCggc2NlbmUuX19vYmplY3RzUmVtb3ZlZFsgMCBdLCBzY2VuZSApO1xyXG5cdFx0XHRzY2VuZS5fX29iamVjdHNSZW1vdmVkLnNwbGljZSggMCwgMSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyB1cGRhdGUgbXVzdCBiZSBjYWxsZWQgYWZ0ZXIgb2JqZWN0cyBhZGRpbmcgLyByZW1vdmFsXHJcblxyXG5cdFx0Zm9yICggdmFyIG8gPSAwLCBvbCA9IHNjZW5lLl9fd2ViZ2xPYmplY3RzLmxlbmd0aDsgbyA8IG9sOyBvICsrICkge1xyXG5cclxuXHRcdFx0dXBkYXRlT2JqZWN0KCBzY2VuZS5fX3dlYmdsT2JqZWN0c1sgbyBdLm9iamVjdCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0Ly8gT2JqZWN0cyBhZGRpbmdcclxuXHJcblx0ZnVuY3Rpb24gYWRkT2JqZWN0ICggb2JqZWN0LCBzY2VuZSApIHtcclxuXHJcblx0XHR2YXIgZywgZ2VvbWV0cnksIG1hdGVyaWFsLCBnZW9tZXRyeUdyb3VwO1xyXG5cclxuXHRcdGlmICggISBvYmplY3QuX193ZWJnbEluaXQgKSB7XHJcblxyXG5cdFx0XHRvYmplY3QuX193ZWJnbEluaXQgPSB0cnVlO1xyXG5cclxuXHRcdFx0b2JqZWN0Ll9tb2RlbFZpZXdNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cdFx0XHRvYmplY3QuX25vcm1hbE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXgzKCk7XHJcblxyXG5cdFx0XHRpZiAoIG9iamVjdC5nZW9tZXRyeSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5nZW9tZXRyeS5fX3dlYmdsSW5pdCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRvYmplY3QuZ2VvbWV0cnkuX193ZWJnbEluaXQgPSB0cnVlO1xyXG5cdFx0XHRcdG9iamVjdC5nZW9tZXRyeS5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uR2VvbWV0cnlEaXNwb3NlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggKSB7XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xyXG5cdFx0XHRcdG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xyXG5cclxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBnZW9tZXRyeS5nZW9tZXRyeUdyb3VwcyA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0c29ydEZhY2VzQnlNYXRlcmlhbCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdC8vIGNyZWF0ZSBzZXBhcmF0ZSBWQk9zIHBlciBnZW9tZXRyeSBjaHVua1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIGcgaW4gZ2VvbWV0cnkuZ2VvbWV0cnlHcm91cHMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeUdyb3VwID0gZ2VvbWV0cnkuZ2VvbWV0cnlHcm91cHNbIGcgXTtcclxuXHJcblx0XHRcdFx0XHRcdC8vIGluaXRpYWxpc2UgVkJPIG9uIHRoZSBmaXJzdCBhY2Nlc3NcclxuXHJcblx0XHRcdFx0XHRcdGlmICggISBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xWZXJ0ZXhCdWZmZXIgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGNyZWF0ZU1lc2hCdWZmZXJzKCBnZW9tZXRyeUdyb3VwICk7XHJcblx0XHRcdFx0XHRcdFx0aW5pdE1lc2hCdWZmZXJzKCBnZW9tZXRyeUdyb3VwLCBvYmplY3QgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHRnZW9tZXRyeS5tb3JwaFRhcmdldHNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHRnZW9tZXRyeS5lbGVtZW50c05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRcdGdlb21ldHJ5LnV2c05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRcdGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHRnZW9tZXRyeS50YW5nZW50c05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRcdGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcclxuXHJcblx0XHRcdFx0XHRpbml0RGlyZWN0QnVmZmVycyggZ2VvbWV0cnkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUmliYm9uICkge1xyXG5cclxuXHRcdFx0XHRnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcclxuXHJcblx0XHRcdFx0aWYgKCAhIGdlb21ldHJ5Ll9fd2ViZ2xWZXJ0ZXhCdWZmZXIgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y3JlYXRlUmliYm9uQnVmZmVycyggZ2VvbWV0cnkgKTtcclxuXHRcdFx0XHRcdGluaXRSaWJib25CdWZmZXJzKCBnZW9tZXRyeSwgb2JqZWN0ICk7XHJcblxyXG5cdFx0XHRcdFx0Z2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuXHRcdFx0XHRcdGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cdFx0XHRcdFx0Z2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaW5lICkge1xyXG5cclxuXHRcdFx0XHRnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcclxuXHJcblx0XHRcdFx0aWYgKCAhIGdlb21ldHJ5Ll9fd2ViZ2xWZXJ0ZXhCdWZmZXIgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xyXG5cclxuICAgICAgICAgICAgY3JlYXRlTGluZUJ1ZmZlcnMoIGdlb21ldHJ5ICk7XHJcbiAgICAgICAgICAgIGluaXRMaW5lQnVmZmVycyggZ2VvbWV0cnksIG9iamVjdCApO1xyXG5cclxuICAgICAgICAgICAgZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICB9IGVsc2UgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aW5pdERpcmVjdEJ1ZmZlcnMoIGdlb21ldHJ5ICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5QYXJ0aWNsZVN5c3RlbSApIHtcclxuXHJcblx0XHRcdFx0Z2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XHJcblxyXG5cdFx0XHRcdGlmICggISBnZW9tZXRyeS5fX3dlYmdsVmVydGV4QnVmZmVyICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSApIHtcclxuXHJcblx0XHRcdFx0XHRcdGNyZWF0ZVBhcnRpY2xlQnVmZmVycyggZ2VvbWV0cnkgKTtcclxuXHRcdFx0XHRcdFx0aW5pdFBhcnRpY2xlQnVmZmVycyggZ2VvbWV0cnksIG9iamVjdCApO1xyXG5cclxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcclxuXHJcblx0XHRcdFx0XHRcdGluaXREaXJlY3RCdWZmZXJzKCBnZW9tZXRyeSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCAhIG9iamVjdC5fX3dlYmdsQWN0aXZlICkge1xyXG5cclxuXHRcdFx0aWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5NZXNoICkge1xyXG5cclxuXHRcdFx0XHRnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcclxuXHJcblx0XHRcdFx0aWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xyXG5cclxuXHRcdFx0XHRcdGFkZEJ1ZmZlciggc2NlbmUuX193ZWJnbE9iamVjdHMsIGdlb21ldHJ5LCBvYmplY3QgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSApIHtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCBnIGluIGdlb21ldHJ5Lmdlb21ldHJ5R3JvdXBzICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Z2VvbWV0cnlHcm91cCA9IGdlb21ldHJ5Lmdlb21ldHJ5R3JvdXBzWyBnIF07XHJcblxyXG5cdFx0XHRcdFx0XHRhZGRCdWZmZXIoIHNjZW5lLl9fd2ViZ2xPYmplY3RzLCBnZW9tZXRyeUdyb3VwLCBvYmplY3QgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlJpYmJvbiB8fFxyXG5cdFx0XHRcdFx0XHRvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaW5lIHx8XHJcblx0XHRcdFx0XHRcdG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlBhcnRpY2xlU3lzdGVtICkge1xyXG5cclxuXHRcdFx0XHRnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcclxuXHRcdFx0XHRhZGRCdWZmZXIoIHNjZW5lLl9fd2ViZ2xPYmplY3RzLCBnZW9tZXRyeSwgb2JqZWN0ICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5JbW1lZGlhdGVSZW5kZXJPYmplY3QgfHwgb2JqZWN0LmltbWVkaWF0ZVJlbmRlckNhbGxiYWNrICkge1xyXG5cclxuXHRcdFx0XHRhZGRCdWZmZXJJbW1lZGlhdGUoIHNjZW5lLl9fd2ViZ2xPYmplY3RzSW1tZWRpYXRlLCBvYmplY3QgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlNwcml0ZSApIHtcclxuXHJcblx0XHRcdFx0c2NlbmUuX193ZWJnbFNwcml0ZXMucHVzaCggb2JqZWN0ICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MZW5zRmxhcmUgKSB7XHJcblxyXG5cdFx0XHRcdHNjZW5lLl9fd2ViZ2xGbGFyZXMucHVzaCggb2JqZWN0ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRvYmplY3QuX193ZWJnbEFjdGl2ZSA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBhZGRCdWZmZXIgKCBvYmpsaXN0LCBidWZmZXIsIG9iamVjdCApIHtcclxuXHJcblx0XHRvYmpsaXN0LnB1c2goXHJcblx0XHRcdHtcclxuXHRcdFx0XHRidWZmZXI6IGJ1ZmZlcixcclxuXHRcdFx0XHRvYmplY3Q6IG9iamVjdCxcclxuXHRcdFx0XHRvcGFxdWU6IG51bGwsXHJcblx0XHRcdFx0dHJhbnNwYXJlbnQ6IG51bGxcclxuXHRcdFx0fVxyXG5cdFx0KTtcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gYWRkQnVmZmVySW1tZWRpYXRlICggb2JqbGlzdCwgb2JqZWN0ICkge1xyXG5cclxuXHRcdG9iamxpc3QucHVzaChcclxuXHRcdFx0e1xyXG5cdFx0XHRcdG9iamVjdDogb2JqZWN0LFxyXG5cdFx0XHRcdG9wYXF1ZTogbnVsbCxcclxuXHRcdFx0XHR0cmFuc3BhcmVudDogbnVsbFxyXG5cdFx0XHR9XHJcblx0XHQpO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBPYmplY3RzIHVwZGF0ZXNcclxuXHJcblx0ZnVuY3Rpb24gdXBkYXRlT2JqZWN0ICggb2JqZWN0ICkge1xyXG5cclxuXHRcdHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeSxcclxuXHRcdFx0Z2VvbWV0cnlHcm91cCwgY3VzdG9tQXR0cmlidXRlc0RpcnR5LCBtYXRlcmlhbDtcclxuXHJcblx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggKSB7XHJcblxyXG5cdFx0XHRpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlIHx8IGdlb21ldHJ5LmVsZW1lbnRzTmVlZFVwZGF0ZSB8fFxyXG5cdFx0XHRcdFx0IGdlb21ldHJ5LnV2c05lZWRVcGRhdGUgfHwgZ2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGUgfHxcclxuXHRcdFx0XHRcdCBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlIHx8IGdlb21ldHJ5LnRhbmdlbnRzTmVlZFVwZGF0ZSApIHtcclxuXHJcblx0XHRcdFx0XHRzZXREaXJlY3RCdWZmZXJzKCBnZW9tZXRyeSwgX2dsLkRZTkFNSUNfRFJBVywgIWdlb21ldHJ5LmR5bmFtaWMgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHRcdFx0XHRnZW9tZXRyeS5lbGVtZW50c05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHRcdFx0XHRnZW9tZXRyeS51dnNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0XHRcdFx0Z2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHRcdFx0XHRnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0XHRcdFx0Z2VvbWV0cnkudGFuZ2VudHNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHQvLyBjaGVjayBhbGwgZ2VvbWV0cnkgZ3JvdXBzXHJcblxyXG5cdFx0XHRcdGZvciggdmFyIGkgPSAwLCBpbCA9IGdlb21ldHJ5Lmdlb21ldHJ5R3JvdXBzTGlzdC5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRnZW9tZXRyeUdyb3VwID0gZ2VvbWV0cnkuZ2VvbWV0cnlHcm91cHNMaXN0WyBpIF07XHJcblxyXG5cdFx0XHRcdFx0bWF0ZXJpYWwgPSBnZXRCdWZmZXJNYXRlcmlhbCggb2JqZWN0LCBnZW9tZXRyeUdyb3VwICk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBnZW9tZXRyeS5idWZmZXJzTmVlZFVwZGF0ZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdGluaXRNZXNoQnVmZmVycyggZ2VvbWV0cnlHcm91cCwgb2JqZWN0ICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZXNEaXJ0eSA9IG1hdGVyaWFsLmF0dHJpYnV0ZXMgJiYgYXJlQ3VzdG9tQXR0cmlidXRlc0RpcnR5KCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0XHRcdGlmICggZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlIHx8IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c05lZWRVcGRhdGUgfHwgZ2VvbWV0cnkuZWxlbWVudHNOZWVkVXBkYXRlIHx8XHJcblx0XHRcdFx0XHRcdCBnZW9tZXRyeS51dnNOZWVkVXBkYXRlIHx8IGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlIHx8XHJcblx0XHRcdFx0XHRcdCBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlIHx8IGdlb21ldHJ5LnRhbmdlbnRzTmVlZFVwZGF0ZSB8fCBjdXN0b21BdHRyaWJ1dGVzRGlydHkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRzZXRNZXNoQnVmZmVycyggZ2VvbWV0cnlHcm91cCwgb2JqZWN0LCBfZ2wuRFlOQU1JQ19EUkFXLCAhZ2VvbWV0cnkuZHluYW1pYywgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Z2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0XHRcdFx0Z2VvbWV0cnkubW9ycGhUYXJnZXRzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0XHRcdGdlb21ldHJ5LmVsZW1lbnRzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0XHRcdGdlb21ldHJ5LnV2c05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHRcdFx0XHRnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0XHRcdGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHRcdFx0XHRnZW9tZXRyeS50YW5nZW50c05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHRcdFx0Z2VvbWV0cnkuYnVmZmVyc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHRcdFx0bWF0ZXJpYWwuYXR0cmlidXRlcyAmJiBjbGVhckN1c3RvbUF0dHJpYnV0ZXMoIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUmliYm9uICkge1xyXG5cclxuXHRcdFx0bWF0ZXJpYWwgPSBnZXRCdWZmZXJNYXRlcmlhbCggb2JqZWN0LCBnZW9tZXRyeSApO1xyXG5cclxuXHRcdFx0Y3VzdG9tQXR0cmlidXRlc0RpcnR5ID0gbWF0ZXJpYWwuYXR0cmlidXRlcyAmJiBhcmVDdXN0b21BdHRyaWJ1dGVzRGlydHkoIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHRpZiAoIGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSB8fCBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlIHx8IGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlIHx8IGN1c3RvbUF0dHJpYnV0ZXNEaXJ0eSApIHtcclxuXHJcblx0XHRcdFx0c2V0UmliYm9uQnVmZmVycyggZ2VvbWV0cnksIF9nbC5EWU5BTUlDX0RSQVcgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0XHRnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0XHRcdGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0XHRtYXRlcmlhbC5hdHRyaWJ1dGVzICYmIGNsZWFyQ3VzdG9tQXR0cmlidXRlcyggbWF0ZXJpYWwgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaW5lICkge1xyXG5cclxuICAgICAgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSB8fCBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlICkge1xyXG5cclxuXHRcdFx0XHRcdHNldERpcmVjdEJ1ZmZlcnMoIGdlb21ldHJ5LCBfZ2wuRFlOQU1JQ19EUkFXLCAhZ2VvbWV0cnkuZHluYW1pYyApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0XHRcdGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG4gICAgICAgIG1hdGVyaWFsID0gZ2V0QnVmZmVyTWF0ZXJpYWwoIG9iamVjdCwgZ2VvbWV0cnkgKTtcclxuXHJcbiAgICAgICAgY3VzdG9tQXR0cmlidXRlc0RpcnR5ID0gbWF0ZXJpYWwuYXR0cmlidXRlcyAmJiBhcmVDdXN0b21BdHRyaWJ1dGVzRGlydHkoIG1hdGVyaWFsICk7XHJcblxyXG4gICAgICAgIGlmICggZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlIHx8IGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgfHwgZ2VvbWV0cnkubGluZURpc3RhbmNlc05lZWRVcGRhdGUgfHwgY3VzdG9tQXR0cmlidXRlc0RpcnR5ICkge1xyXG5cclxuICAgICAgICAgIHNldExpbmVCdWZmZXJzKCBnZW9tZXRyeSwgX2dsLkRZTkFNSUNfRFJBVyApO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG4gICAgICAgIGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuICAgICAgICBnZW9tZXRyeS5saW5lRGlzdGFuY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICBtYXRlcmlhbC5hdHRyaWJ1dGVzICYmIGNsZWFyQ3VzdG9tQXR0cmlidXRlcyggbWF0ZXJpYWwgKTtcclxuXHJcbiAgICAgIH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5QYXJ0aWNsZVN5c3RlbSApIHtcclxuXHJcblx0XHRcdGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgfHwgZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSApIHtcclxuXHJcblx0XHRcdFx0XHRzZXREaXJlY3RCdWZmZXJzKCBnZW9tZXRyeSwgX2dsLkRZTkFNSUNfRFJBVywgIWdlb21ldHJ5LmR5bmFtaWMgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHRcdFx0XHRnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRtYXRlcmlhbCA9IGdldEJ1ZmZlck1hdGVyaWFsKCBvYmplY3QsIGdlb21ldHJ5ICk7XHJcblxyXG5cdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZXNEaXJ0eSA9IG1hdGVyaWFsLmF0dHJpYnV0ZXMgJiYgYXJlQ3VzdG9tQXR0cmlidXRlc0RpcnR5KCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSB8fCBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlIHx8IG9iamVjdC5zb3J0UGFydGljbGVzIHx8IGN1c3RvbUF0dHJpYnV0ZXNEaXJ0eSApIHtcclxuXHJcblx0XHRcdFx0XHRzZXRQYXJ0aWNsZUJ1ZmZlcnMoIGdlb21ldHJ5LCBfZ2wuRFlOQU1JQ19EUkFXLCBvYmplY3QgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHRcdFx0XHRnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0XHRcdG1hdGVyaWFsLmF0dHJpYnV0ZXMgJiYgY2xlYXJDdXN0b21BdHRyaWJ1dGVzKCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0Ly8gT2JqZWN0cyB1cGRhdGVzIC0gY3VzdG9tIGF0dHJpYnV0ZXMgY2hlY2tcclxuXHJcblx0ZnVuY3Rpb24gYXJlQ3VzdG9tQXR0cmlidXRlc0RpcnR5ICggbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0Zm9yICggdmFyIGEgaW4gbWF0ZXJpYWwuYXR0cmlidXRlcyApIHtcclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwuYXR0cmlidXRlc1sgYSBdLm5lZWRzVXBkYXRlICkgcmV0dXJuIHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gY2xlYXJDdXN0b21BdHRyaWJ1dGVzICggbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0Zm9yICggdmFyIGEgaW4gbWF0ZXJpYWwuYXR0cmlidXRlcyApIHtcclxuXHJcblx0XHRcdG1hdGVyaWFsLmF0dHJpYnV0ZXNbIGEgXS5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0Ly8gT2JqZWN0cyByZW1vdmFsXHJcblxyXG5cdGZ1bmN0aW9uIHJlbW92ZU9iamVjdCAoIG9iamVjdCwgc2NlbmUgKSB7XHJcblxyXG5cdFx0aWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5NZXNoICB8fFxyXG5cdFx0XHQgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUGFydGljbGVTeXN0ZW0gfHxcclxuXHRcdFx0IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlJpYmJvbiB8fFxyXG5cdFx0XHQgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGluZSApIHtcclxuXHJcblx0XHRcdHJlbW92ZUluc3RhbmNlcyggc2NlbmUuX193ZWJnbE9iamVjdHMsIG9iamVjdCApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlNwcml0ZSApIHtcclxuXHJcblx0XHRcdHJlbW92ZUluc3RhbmNlc0RpcmVjdCggc2NlbmUuX193ZWJnbFNwcml0ZXMsIG9iamVjdCApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxlbnNGbGFyZSApIHtcclxuXHJcblx0XHRcdHJlbW92ZUluc3RhbmNlc0RpcmVjdCggc2NlbmUuX193ZWJnbEZsYXJlcywgb2JqZWN0ICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuSW1tZWRpYXRlUmVuZGVyT2JqZWN0IHx8IG9iamVjdC5pbW1lZGlhdGVSZW5kZXJDYWxsYmFjayApIHtcclxuXHJcblx0XHRcdHJlbW92ZUluc3RhbmNlcyggc2NlbmUuX193ZWJnbE9iamVjdHNJbW1lZGlhdGUsIG9iamVjdCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRvYmplY3QuX193ZWJnbEFjdGl2ZSA9IGZhbHNlO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiByZW1vdmVJbnN0YW5jZXMgKCBvYmpsaXN0LCBvYmplY3QgKSB7XHJcblxyXG5cdFx0Zm9yICggdmFyIG8gPSBvYmpsaXN0Lmxlbmd0aCAtIDE7IG8gPj0gMDsgbyAtLSApIHtcclxuXHJcblx0XHRcdGlmICggb2JqbGlzdFsgbyBdLm9iamVjdCA9PT0gb2JqZWN0ICkge1xyXG5cclxuXHRcdFx0XHRvYmpsaXN0LnNwbGljZSggbywgMSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gcmVtb3ZlSW5zdGFuY2VzRGlyZWN0ICggb2JqbGlzdCwgb2JqZWN0ICkge1xyXG5cclxuXHRcdGZvciAoIHZhciBvID0gb2JqbGlzdC5sZW5ndGggLSAxOyBvID49IDA7IG8gLS0gKSB7XHJcblxyXG5cdFx0XHRpZiAoIG9iamxpc3RbIG8gXSA9PT0gb2JqZWN0ICkge1xyXG5cclxuXHRcdFx0XHRvYmpsaXN0LnNwbGljZSggbywgMSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0Ly8gTWF0ZXJpYWxzXHJcblxyXG5cdHRoaXMuaW5pdE1hdGVyaWFsID0gZnVuY3Rpb24gKCBtYXRlcmlhbCwgbGlnaHRzLCBmb2csIG9iamVjdCApIHtcclxuXHJcblx0XHRtYXRlcmlhbC5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uTWF0ZXJpYWxEaXNwb3NlICk7XHJcblxyXG5cdFx0dmFyIHUsIGEsIGlkZW50aWZpZXJzLCBpLCBwYXJhbWV0ZXJzLCBtYXhMaWdodENvdW50LCBtYXhCb25lcywgbWF4U2hhZG93cywgc2hhZGVySUQ7XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hEZXB0aE1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0c2hhZGVySUQgPSAnZGVwdGgnO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaE5vcm1hbE1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0c2hhZGVySUQgPSAnbm9ybWFsJztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0c2hhZGVySUQgPSAnYmFzaWMnO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdHNoYWRlcklEID0gJ2xhbWJlcnQnO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRzaGFkZXJJRCA9ICdwaG9uZyc7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdHNoYWRlcklEID0gJ2Jhc2ljJztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLkxpbmVEYXNoZWRNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdHNoYWRlcklEID0gJ2Rhc2hlZCc7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5QYXJ0aWNsZUJhc2ljTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRzaGFkZXJJRCA9ICdwYXJ0aWNsZV9iYXNpYyc7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggc2hhZGVySUQgKSB7XHJcblxyXG5cdFx0XHRzZXRNYXRlcmlhbFNoYWRlcnMoIG1hdGVyaWFsLCBUSFJFRS5TaGFkZXJMaWJbIHNoYWRlcklEIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gaGV1cmlzdGljcyB0byBjcmVhdGUgc2hhZGVyIHBhcmFtZXRlcnMgYWNjb3JkaW5nIHRvIGxpZ2h0cyBpbiB0aGUgc2NlbmVcclxuXHRcdC8vIChub3QgdG8gYmxvdyBvdmVyIG1heExpZ2h0cyBidWRnZXQpXHJcblxyXG5cdFx0bWF4TGlnaHRDb3VudCA9IGFsbG9jYXRlTGlnaHRzKCBsaWdodHMgKTtcclxuXHJcblx0XHRtYXhTaGFkb3dzID0gYWxsb2NhdGVTaGFkb3dzKCBsaWdodHMgKTtcclxuXHJcblx0XHRtYXhCb25lcyA9IGFsbG9jYXRlQm9uZXMoIG9iamVjdCApO1xyXG5cclxuXHRcdHBhcmFtZXRlcnMgPSB7XHJcblxyXG5cdFx0XHRtYXA6ICEhbWF0ZXJpYWwubWFwLFxyXG5cdFx0XHRlbnZNYXA6ICEhbWF0ZXJpYWwuZW52TWFwLFxyXG5cdFx0XHRsaWdodE1hcDogISFtYXRlcmlhbC5saWdodE1hcCxcclxuXHRcdFx0YnVtcE1hcDogISFtYXRlcmlhbC5idW1wTWFwLFxyXG5cdFx0XHRub3JtYWxNYXA6ICEhbWF0ZXJpYWwubm9ybWFsTWFwLFxyXG5cdFx0XHRzcGVjdWxhck1hcDogISFtYXRlcmlhbC5zcGVjdWxhck1hcCxcclxuXHJcblx0XHRcdHZlcnRleENvbG9yczogbWF0ZXJpYWwudmVydGV4Q29sb3JzLFxyXG5cclxuXHRcdFx0Zm9nOiBmb2csXHJcblx0XHRcdHVzZUZvZzogbWF0ZXJpYWwuZm9nLFxyXG5cdFx0XHRmb2dFeHA6IGZvZyBpbnN0YW5jZW9mIFRIUkVFLkZvZ0V4cDIsXHJcblxyXG5cdFx0XHRzaXplQXR0ZW51YXRpb246IG1hdGVyaWFsLnNpemVBdHRlbnVhdGlvbixcclxuXHJcblx0XHRcdHNraW5uaW5nOiBtYXRlcmlhbC5za2lubmluZyxcclxuXHRcdFx0bWF4Qm9uZXM6IG1heEJvbmVzLFxyXG5cdFx0XHR1c2VWZXJ0ZXhUZXh0dXJlOiBfc3VwcG9ydHNCb25lVGV4dHVyZXMgJiYgb2JqZWN0ICYmIG9iamVjdC51c2VWZXJ0ZXhUZXh0dXJlLFxyXG5cdFx0XHRib25lVGV4dHVyZVdpZHRoOiBvYmplY3QgJiYgb2JqZWN0LmJvbmVUZXh0dXJlV2lkdGgsXHJcblx0XHRcdGJvbmVUZXh0dXJlSGVpZ2h0OiBvYmplY3QgJiYgb2JqZWN0LmJvbmVUZXh0dXJlSGVpZ2h0LFxyXG5cclxuXHRcdFx0bW9ycGhUYXJnZXRzOiBtYXRlcmlhbC5tb3JwaFRhcmdldHMsXHJcblx0XHRcdG1vcnBoTm9ybWFsczogbWF0ZXJpYWwubW9ycGhOb3JtYWxzLFxyXG5cdFx0XHRtYXhNb3JwaFRhcmdldHM6IHRoaXMubWF4TW9ycGhUYXJnZXRzLFxyXG5cdFx0XHRtYXhNb3JwaE5vcm1hbHM6IHRoaXMubWF4TW9ycGhOb3JtYWxzLFxyXG5cclxuXHRcdFx0bWF4RGlyTGlnaHRzOiBtYXhMaWdodENvdW50LmRpcmVjdGlvbmFsLFxyXG5cdFx0XHRtYXhQb2ludExpZ2h0czogbWF4TGlnaHRDb3VudC5wb2ludCxcclxuXHRcdFx0bWF4U3BvdExpZ2h0czogbWF4TGlnaHRDb3VudC5zcG90LFxyXG5cdFx0XHRtYXhIZW1pTGlnaHRzOiBtYXhMaWdodENvdW50LmhlbWksXHJcblxyXG5cdFx0XHRtYXhTaGFkb3dzOiBtYXhTaGFkb3dzLFxyXG5cdFx0XHRzaGFkb3dNYXBFbmFibGVkOiB0aGlzLnNoYWRvd01hcEVuYWJsZWQgJiYgb2JqZWN0LnJlY2VpdmVTaGFkb3csXHJcblx0XHRcdHNoYWRvd01hcFR5cGU6IHRoaXMuc2hhZG93TWFwVHlwZSxcclxuXHRcdFx0c2hhZG93TWFwRGVidWc6IHRoaXMuc2hhZG93TWFwRGVidWcsXHJcblx0XHRcdHNoYWRvd01hcENhc2NhZGU6IHRoaXMuc2hhZG93TWFwQ2FzY2FkZSxcclxuXHJcblx0XHRcdGFscGhhVGVzdDogbWF0ZXJpYWwuYWxwaGFUZXN0LFxyXG5cdFx0XHRtZXRhbDogbWF0ZXJpYWwubWV0YWwsXHJcblx0XHRcdHBlclBpeGVsOiBtYXRlcmlhbC5wZXJQaXhlbCxcclxuXHRcdFx0d3JhcEFyb3VuZDogbWF0ZXJpYWwud3JhcEFyb3VuZCxcclxuXHRcdFx0ZG91YmxlU2lkZWQ6IG1hdGVyaWFsLnNpZGUgPT09IFRIUkVFLkRvdWJsZVNpZGUsXHJcblx0XHRcdGZsaXBTaWRlZDogbWF0ZXJpYWwuc2lkZSA9PT0gVEhSRUUuQmFja1NpZGVcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdG1hdGVyaWFsLnByb2dyYW0gPSBidWlsZFByb2dyYW0oIHNoYWRlcklELCBtYXRlcmlhbC5mcmFnbWVudFNoYWRlciwgbWF0ZXJpYWwudmVydGV4U2hhZGVyLCBtYXRlcmlhbC51bmlmb3JtcywgbWF0ZXJpYWwuYXR0cmlidXRlcywgbWF0ZXJpYWwuZGVmaW5lcywgcGFyYW1ldGVycyApO1xyXG5cclxuXHRcdHZhciBhdHRyaWJ1dGVzID0gbWF0ZXJpYWwucHJvZ3JhbS5hdHRyaWJ1dGVzO1xyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwubW9ycGhUYXJnZXRzICkge1xyXG5cclxuXHRcdFx0bWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhUYXJnZXRzID0gMDtcclxuXHJcblx0XHRcdHZhciBpZCwgYmFzZSA9IFwibW9ycGhUYXJnZXRcIjtcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgdGhpcy5tYXhNb3JwaFRhcmdldHM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGlkID0gYmFzZSArIGk7XHJcblxyXG5cdFx0XHRcdGlmICggYXR0cmlidXRlc1sgaWQgXSA+PSAwICkge1xyXG5cclxuXHRcdFx0XHRcdG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoVGFyZ2V0cyArKztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLm1vcnBoTm9ybWFscyApIHtcclxuXHJcblx0XHRcdG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoTm9ybWFscyA9IDA7XHJcblxyXG5cdFx0XHR2YXIgaWQsIGJhc2UgPSBcIm1vcnBoTm9ybWFsXCI7XHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IHRoaXMubWF4TW9ycGhOb3JtYWxzOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRpZCA9IGJhc2UgKyBpO1xyXG5cclxuXHRcdFx0XHRpZiAoIGF0dHJpYnV0ZXNbIGlkIF0gPj0gMCApIHtcclxuXHJcblx0XHRcdFx0XHRtYXRlcmlhbC5udW1TdXBwb3J0ZWRNb3JwaE5vcm1hbHMgKys7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0bWF0ZXJpYWwudW5pZm9ybXNMaXN0ID0gW107XHJcblxyXG5cdFx0Zm9yICggdSBpbiBtYXRlcmlhbC51bmlmb3JtcyApIHtcclxuXHJcblx0XHRcdG1hdGVyaWFsLnVuaWZvcm1zTGlzdC5wdXNoKCBbIG1hdGVyaWFsLnVuaWZvcm1zWyB1IF0sIHUgXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gc2V0TWF0ZXJpYWxTaGFkZXJzKCBtYXRlcmlhbCwgc2hhZGVycyApIHtcclxuXHJcblx0XHRtYXRlcmlhbC51bmlmb3JtcyA9IFRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoIHNoYWRlcnMudW5pZm9ybXMgKTtcclxuXHRcdG1hdGVyaWFsLnZlcnRleFNoYWRlciA9IHNoYWRlcnMudmVydGV4U2hhZGVyO1xyXG5cdFx0bWF0ZXJpYWwuZnJhZ21lbnRTaGFkZXIgPSBzaGFkZXJzLmZyYWdtZW50U2hhZGVyO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBzZXRQcm9ncmFtKCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBtYXRlcmlhbCwgb2JqZWN0ICkge1xyXG5cclxuXHRcdF91c2VkVGV4dHVyZVVuaXRzID0gMDtcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLm5lZWRzVXBkYXRlICkge1xyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbC5wcm9ncmFtICkgZGVhbGxvY2F0ZU1hdGVyaWFsKCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0X3RoaXMuaW5pdE1hdGVyaWFsKCBtYXRlcmlhbCwgbGlnaHRzLCBmb2csIG9iamVjdCApO1xyXG5cdFx0XHRtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyApIHtcclxuXHJcblx0XHRcdGlmICggISBvYmplY3QuX193ZWJnbE1vcnBoVGFyZ2V0SW5mbHVlbmNlcyApIHtcclxuXHJcblx0XHRcdFx0b2JqZWN0Ll9fd2ViZ2xNb3JwaFRhcmdldEluZmx1ZW5jZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBfdGhpcy5tYXhNb3JwaFRhcmdldHMgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHJlZnJlc2hNYXRlcmlhbCA9IGZhbHNlO1xyXG5cclxuXHRcdHZhciBwcm9ncmFtID0gbWF0ZXJpYWwucHJvZ3JhbSxcclxuXHRcdFx0cF91bmlmb3JtcyA9IHByb2dyYW0udW5pZm9ybXMsXHJcblx0XHRcdG1fdW5pZm9ybXMgPSBtYXRlcmlhbC51bmlmb3JtcztcclxuXHJcblx0XHRpZiAoIHByb2dyYW0gIT09IF9jdXJyZW50UHJvZ3JhbSApIHtcclxuXHJcblx0XHRcdF9nbC51c2VQcm9ncmFtKCBwcm9ncmFtICk7XHJcblx0XHRcdF9jdXJyZW50UHJvZ3JhbSA9IHByb2dyYW07XHJcblxyXG5cdFx0XHRyZWZyZXNoTWF0ZXJpYWwgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLmlkICE9PSBfY3VycmVudE1hdGVyaWFsSWQgKSB7XHJcblxyXG5cdFx0XHRfY3VycmVudE1hdGVyaWFsSWQgPSBtYXRlcmlhbC5pZDtcclxuXHRcdFx0cmVmcmVzaE1hdGVyaWFsID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCByZWZyZXNoTWF0ZXJpYWwgfHwgY2FtZXJhICE9PSBfY3VycmVudENhbWVyYSApIHtcclxuXHJcblx0XHRcdF9nbC51bmlmb3JtTWF0cml4NGZ2KCBwX3VuaWZvcm1zLnByb2plY3Rpb25NYXRyaXgsIGZhbHNlLCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeC5lbGVtZW50cyApO1xyXG5cclxuXHRcdFx0aWYgKCBjYW1lcmEgIT09IF9jdXJyZW50Q2FtZXJhICkgX2N1cnJlbnRDYW1lcmEgPSBjYW1lcmE7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHNraW5uaW5nIHVuaWZvcm1zIG11c3QgYmUgc2V0IGV2ZW4gaWYgbWF0ZXJpYWwgZGlkbid0IGNoYW5nZVxyXG5cdFx0Ly8gYXV0by1zZXR0aW5nIG9mIHRleHR1cmUgdW5pdCBmb3IgYm9uZSB0ZXh0dXJlIG11c3QgZ28gYmVmb3JlIG90aGVyIHRleHR1cmVzXHJcblx0XHQvLyBub3Qgc3VyZSB3aHksIGJ1dCBvdGhlcndpc2Ugd2VpcmQgdGhpbmdzIGhhcHBlblxyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwuc2tpbm5pbmcgKSB7XHJcblxyXG5cdFx0XHRpZiAoIF9zdXBwb3J0c0JvbmVUZXh0dXJlcyAmJiBvYmplY3QudXNlVmVydGV4VGV4dHVyZSApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBwX3VuaWZvcm1zLmJvbmVUZXh0dXJlICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciB0ZXh0dXJlVW5pdCA9IGdldFRleHR1cmVVbml0KCk7XHJcblxyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0xaSggcF91bmlmb3Jtcy5ib25lVGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcclxuXHRcdFx0XHRcdF90aGlzLnNldFRleHR1cmUoIG9iamVjdC5ib25lVGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0aWYgKCBwX3VuaWZvcm1zLmJvbmVHbG9iYWxNYXRyaWNlcyAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDRmdiggcF91bmlmb3Jtcy5ib25lR2xvYmFsTWF0cmljZXMsIGZhbHNlLCBvYmplY3QuYm9uZU1hdHJpY2VzICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCByZWZyZXNoTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHQvLyByZWZyZXNoIHVuaWZvcm1zIGNvbW1vbiB0byBzZXZlcmFsIG1hdGVyaWFsc1xyXG5cclxuXHRcdFx0aWYgKCBmb2cgJiYgbWF0ZXJpYWwuZm9nICkge1xyXG5cclxuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNGb2coIG1fdW5pZm9ybXMsIGZvZyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsIHx8XHJcblx0XHRcdFx0IG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCB8fFxyXG5cdFx0XHRcdCBtYXRlcmlhbC5saWdodHMgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggX2xpZ2h0c05lZWRVcGRhdGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0c2V0dXBMaWdodHMoIHByb2dyYW0sIGxpZ2h0cyApO1xyXG5cdFx0XHRcdFx0X2xpZ2h0c05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNMaWdodHMoIG1fdW5pZm9ybXMsIF9saWdodHMgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCB8fFxyXG5cdFx0XHRcdCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgfHxcclxuXHRcdFx0XHQgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zQ29tbW9uKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gcmVmcmVzaCBzaW5nbGUgbWF0ZXJpYWwgc3BlY2lmaWMgdW5pZm9ybXNcclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zTGluZSggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTGluZURhc2hlZE1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNMaW5lKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xyXG5cdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc0Rhc2goIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLlBhcnRpY2xlQmFzaWNNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zUGFydGljbGUoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNQaG9uZyggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zTGFtYmVydCggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdG1fdW5pZm9ybXMubU5lYXIudmFsdWUgPSBjYW1lcmEubmVhcjtcclxuXHRcdFx0XHRtX3VuaWZvcm1zLm1GYXIudmFsdWUgPSBjYW1lcmEuZmFyO1xyXG5cdFx0XHRcdG1fdW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdFx0bV91bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggb2JqZWN0LnJlY2VpdmVTaGFkb3cgJiYgISBtYXRlcmlhbC5fc2hhZG93UGFzcyApIHtcclxuXHJcblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zU2hhZG93KCBtX3VuaWZvcm1zLCBsaWdodHMgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGxvYWQgY29tbW9uIHVuaWZvcm1zXHJcblxyXG5cdFx0XHRsb2FkVW5pZm9ybXNHZW5lcmljKCBwcm9ncmFtLCBtYXRlcmlhbC51bmlmb3Jtc0xpc3QgKTtcclxuXHJcblx0XHRcdC8vIGxvYWQgbWF0ZXJpYWwgc3BlY2lmaWMgdW5pZm9ybXNcclxuXHRcdFx0Ly8gKHNoYWRlciBtYXRlcmlhbCBhbHNvIGdldHMgdGhlbSBmb3IgdGhlIHNha2Ugb2YgZ2VuZXJpY2l0eSlcclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5TaGFkZXJNYXRlcmlhbCB8fFxyXG5cdFx0XHRcdCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsIHx8XHJcblx0XHRcdFx0IG1hdGVyaWFsLmVudk1hcCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBwX3VuaWZvcm1zLmNhbWVyYVBvc2l0aW9uICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRcdF92ZWN0b3IzLmdldFBvc2l0aW9uRnJvbU1hdHJpeCggY2FtZXJhLm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTNmKCBwX3VuaWZvcm1zLmNhbWVyYVBvc2l0aW9uLCBfdmVjdG9yMy54LCBfdmVjdG9yMy55LCBfdmVjdG9yMy56ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCB8fFxyXG5cdFx0XHRcdCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgfHxcclxuXHRcdFx0XHQgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5TaGFkZXJNYXRlcmlhbCB8fFxyXG5cdFx0XHRcdCBtYXRlcmlhbC5za2lubmluZyApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBwX3VuaWZvcm1zLnZpZXdNYXRyaXggIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm1NYXRyaXg0ZnYoIHBfdW5pZm9ybXMudmlld01hdHJpeCwgZmFsc2UsIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UuZWxlbWVudHMgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRsb2FkVW5pZm9ybXNNYXRyaWNlcyggcF91bmlmb3Jtcywgb2JqZWN0ICk7XHJcblxyXG5cdFx0aWYgKCBwX3VuaWZvcm1zLm1vZGVsTWF0cml4ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0X2dsLnVuaWZvcm1NYXRyaXg0ZnYoIHBfdW5pZm9ybXMubW9kZWxNYXRyaXgsIGZhbHNlLCBvYmplY3QubWF0cml4V29ybGQuZWxlbWVudHMgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHByb2dyYW07XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIFVuaWZvcm1zIChyZWZyZXNoIHVuaWZvcm1zIG9iamVjdHMpXHJcblxyXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0NvbW1vbiAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHR1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcclxuXHJcblx0XHRpZiAoIF90aGlzLmdhbW1hSW5wdXQgKSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5kaWZmdXNlLnZhbHVlLmNvcHlHYW1tYVRvTGluZWFyKCBtYXRlcmlhbC5jb2xvciApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5kaWZmdXNlLnZhbHVlID0gbWF0ZXJpYWwuY29sb3I7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHVuaWZvcm1zLm1hcC52YWx1ZSA9IG1hdGVyaWFsLm1hcDtcclxuXHRcdHVuaWZvcm1zLmxpZ2h0TWFwLnZhbHVlID0gbWF0ZXJpYWwubGlnaHRNYXA7XHJcblx0XHR1bmlmb3Jtcy5zcGVjdWxhck1hcC52YWx1ZSA9IG1hdGVyaWFsLnNwZWN1bGFyTWFwO1xyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwuYnVtcE1hcCApIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLmJ1bXBNYXAudmFsdWUgPSBtYXRlcmlhbC5idW1wTWFwO1xyXG5cdFx0XHR1bmlmb3Jtcy5idW1wU2NhbGUudmFsdWUgPSBtYXRlcmlhbC5idW1wU2NhbGU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwubm9ybWFsTWFwICkge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMubm9ybWFsTWFwLnZhbHVlID0gbWF0ZXJpYWwubm9ybWFsTWFwO1xyXG5cdFx0XHR1bmlmb3Jtcy5ub3JtYWxTY2FsZS52YWx1ZS5jb3B5KCBtYXRlcmlhbC5ub3JtYWxTY2FsZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyB1diByZXBlYXQgYW5kIG9mZnNldCBzZXR0aW5nIHByaW9yaXRpZXNcclxuXHRcdC8vXHQxLiBjb2xvciBtYXBcclxuXHRcdC8vXHQyLiBzcGVjdWxhciBtYXBcclxuXHRcdC8vXHQzLiBub3JtYWwgbWFwXHJcblx0XHQvL1x0NC4gYnVtcCBtYXBcclxuXHJcblx0XHR2YXIgdXZTY2FsZU1hcDtcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLm1hcCApIHtcclxuXHJcblx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5tYXA7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuc3BlY3VsYXJNYXAgKSB7XHJcblxyXG5cdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwuc3BlY3VsYXJNYXA7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwubm9ybWFsTWFwICkge1xyXG5cclxuXHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLm5vcm1hbE1hcDtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5idW1wTWFwICkge1xyXG5cclxuXHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLmJ1bXBNYXA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdXZTY2FsZU1hcCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0dmFyIG9mZnNldCA9IHV2U2NhbGVNYXAub2Zmc2V0O1xyXG5cdFx0XHR2YXIgcmVwZWF0ID0gdXZTY2FsZU1hcC5yZXBlYXQ7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5vZmZzZXRSZXBlYXQudmFsdWUuc2V0KCBvZmZzZXQueCwgb2Zmc2V0LnksIHJlcGVhdC54LCByZXBlYXQueSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR1bmlmb3Jtcy5lbnZNYXAudmFsdWUgPSBtYXRlcmlhbC5lbnZNYXA7XHJcblx0XHR1bmlmb3Jtcy5mbGlwRW52TWFwLnZhbHVlID0gKCBtYXRlcmlhbC5lbnZNYXAgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUgKSA/IDEgOiAtMTtcclxuXHJcblx0XHRpZiAoIF90aGlzLmdhbW1hSW5wdXQgKSB7XHJcblxyXG5cdFx0XHQvL3VuaWZvcm1zLnJlZmxlY3Rpdml0eS52YWx1ZSA9IG1hdGVyaWFsLnJlZmxlY3Rpdml0eSAqIG1hdGVyaWFsLnJlZmxlY3Rpdml0eTtcclxuXHRcdFx0dW5pZm9ybXMucmVmbGVjdGl2aXR5LnZhbHVlID0gbWF0ZXJpYWwucmVmbGVjdGl2aXR5O1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5yZWZsZWN0aXZpdHkudmFsdWUgPSBtYXRlcmlhbC5yZWZsZWN0aXZpdHk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHVuaWZvcm1zLnJlZnJhY3Rpb25SYXRpby52YWx1ZSA9IG1hdGVyaWFsLnJlZnJhY3Rpb25SYXRpbztcclxuXHRcdHVuaWZvcm1zLmNvbWJpbmUudmFsdWUgPSBtYXRlcmlhbC5jb21iaW5lO1xyXG5cdFx0dW5pZm9ybXMudXNlUmVmcmFjdC52YWx1ZSA9IG1hdGVyaWFsLmVudk1hcCAmJiBtYXRlcmlhbC5lbnZNYXAubWFwcGluZyBpbnN0YW5jZW9mIFRIUkVFLkN1YmVSZWZyYWN0aW9uTWFwcGluZztcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zTGluZSAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHR1bmlmb3Jtcy5kaWZmdXNlLnZhbHVlID0gbWF0ZXJpYWwuY29sb3I7XHJcblx0XHR1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zRGFzaCAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHR1bmlmb3Jtcy5kYXNoU2l6ZS52YWx1ZSA9IG1hdGVyaWFsLmRhc2hTaXplO1xyXG5cdFx0dW5pZm9ybXMudG90YWxTaXplLnZhbHVlID0gbWF0ZXJpYWwuZGFzaFNpemUgKyBtYXRlcmlhbC5nYXBTaXplO1xyXG5cdFx0dW5pZm9ybXMuc2NhbGUudmFsdWUgPSBtYXRlcmlhbC5zY2FsZTtcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zUGFydGljbGUgKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0dW5pZm9ybXMucHNDb2xvci52YWx1ZSA9IG1hdGVyaWFsLmNvbG9yO1xyXG5cdFx0dW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XHJcblx0XHR1bmlmb3Jtcy5zaXplLnZhbHVlID0gbWF0ZXJpYWwuc2l6ZTtcclxuXHRcdHVuaWZvcm1zLnNjYWxlLnZhbHVlID0gX2NhbnZhcy5oZWlnaHQgLyAyLjA7IC8vIFRPRE86IENhY2hlIHRoaXMuXHJcblxyXG5cdFx0dW5pZm9ybXMubWFwLnZhbHVlID0gbWF0ZXJpYWwubWFwO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNGb2cgKCB1bmlmb3JtcywgZm9nICkge1xyXG5cclxuXHRcdHVuaWZvcm1zLmZvZ0NvbG9yLnZhbHVlID0gZm9nLmNvbG9yO1xyXG5cclxuXHRcdGlmICggZm9nIGluc3RhbmNlb2YgVEhSRUUuRm9nICkge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMuZm9nTmVhci52YWx1ZSA9IGZvZy5uZWFyO1xyXG5cdFx0XHR1bmlmb3Jtcy5mb2dGYXIudmFsdWUgPSBmb2cuZmFyO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGZvZyBpbnN0YW5jZW9mIFRIUkVFLkZvZ0V4cDIgKSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5mb2dEZW5zaXR5LnZhbHVlID0gZm9nLmRlbnNpdHk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNQaG9uZyAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHR1bmlmb3Jtcy5zaGluaW5lc3MudmFsdWUgPSBtYXRlcmlhbC5zaGluaW5lc3M7XHJcblxyXG5cdFx0aWYgKCBfdGhpcy5nYW1tYUlucHV0ICkge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMuYW1iaWVudC52YWx1ZS5jb3B5R2FtbWFUb0xpbmVhciggbWF0ZXJpYWwuYW1iaWVudCApO1xyXG5cdFx0XHR1bmlmb3Jtcy5lbWlzc2l2ZS52YWx1ZS5jb3B5R2FtbWFUb0xpbmVhciggbWF0ZXJpYWwuZW1pc3NpdmUgKTtcclxuXHRcdFx0dW5pZm9ybXMuc3BlY3VsYXIudmFsdWUuY29weUdhbW1hVG9MaW5lYXIoIG1hdGVyaWFsLnNwZWN1bGFyICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLmFtYmllbnQudmFsdWUgPSBtYXRlcmlhbC5hbWJpZW50O1xyXG5cdFx0XHR1bmlmb3Jtcy5lbWlzc2l2ZS52YWx1ZSA9IG1hdGVyaWFsLmVtaXNzaXZlO1xyXG5cdFx0XHR1bmlmb3Jtcy5zcGVjdWxhci52YWx1ZSA9IG1hdGVyaWFsLnNwZWN1bGFyO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLndyYXBBcm91bmQgKSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy53cmFwUkdCLnZhbHVlLmNvcHkoIG1hdGVyaWFsLndyYXBSR0IgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0xhbWJlcnQgKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0aWYgKCBfdGhpcy5nYW1tYUlucHV0ICkge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMuYW1iaWVudC52YWx1ZS5jb3B5R2FtbWFUb0xpbmVhciggbWF0ZXJpYWwuYW1iaWVudCApO1xyXG5cdFx0XHR1bmlmb3Jtcy5lbWlzc2l2ZS52YWx1ZS5jb3B5R2FtbWFUb0xpbmVhciggbWF0ZXJpYWwuZW1pc3NpdmUgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMuYW1iaWVudC52YWx1ZSA9IG1hdGVyaWFsLmFtYmllbnQ7XHJcblx0XHRcdHVuaWZvcm1zLmVtaXNzaXZlLnZhbHVlID0gbWF0ZXJpYWwuZW1pc3NpdmU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwud3JhcEFyb3VuZCApIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLndyYXBSR0IudmFsdWUuY29weSggbWF0ZXJpYWwud3JhcFJHQiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zTGlnaHRzICggdW5pZm9ybXMsIGxpZ2h0cyApIHtcclxuXHJcblx0XHR1bmlmb3Jtcy5hbWJpZW50TGlnaHRDb2xvci52YWx1ZSA9IGxpZ2h0cy5hbWJpZW50O1xyXG5cclxuXHRcdHVuaWZvcm1zLmRpcmVjdGlvbmFsTGlnaHRDb2xvci52YWx1ZSA9IGxpZ2h0cy5kaXJlY3Rpb25hbC5jb2xvcnM7XHJcblx0XHR1bmlmb3Jtcy5kaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uLnZhbHVlID0gbGlnaHRzLmRpcmVjdGlvbmFsLnBvc2l0aW9ucztcclxuXHJcblx0XHR1bmlmb3Jtcy5wb2ludExpZ2h0Q29sb3IudmFsdWUgPSBsaWdodHMucG9pbnQuY29sb3JzO1xyXG5cdFx0dW5pZm9ybXMucG9pbnRMaWdodFBvc2l0aW9uLnZhbHVlID0gbGlnaHRzLnBvaW50LnBvc2l0aW9ucztcclxuXHRcdHVuaWZvcm1zLnBvaW50TGlnaHREaXN0YW5jZS52YWx1ZSA9IGxpZ2h0cy5wb2ludC5kaXN0YW5jZXM7XHJcblxyXG5cdFx0dW5pZm9ybXMuc3BvdExpZ2h0Q29sb3IudmFsdWUgPSBsaWdodHMuc3BvdC5jb2xvcnM7XHJcblx0XHR1bmlmb3Jtcy5zcG90TGlnaHRQb3NpdGlvbi52YWx1ZSA9IGxpZ2h0cy5zcG90LnBvc2l0aW9ucztcclxuXHRcdHVuaWZvcm1zLnNwb3RMaWdodERpc3RhbmNlLnZhbHVlID0gbGlnaHRzLnNwb3QuZGlzdGFuY2VzO1xyXG5cdFx0dW5pZm9ybXMuc3BvdExpZ2h0RGlyZWN0aW9uLnZhbHVlID0gbGlnaHRzLnNwb3QuZGlyZWN0aW9ucztcclxuXHRcdHVuaWZvcm1zLnNwb3RMaWdodEFuZ2xlQ29zLnZhbHVlID0gbGlnaHRzLnNwb3QuYW5nbGVzQ29zO1xyXG5cdFx0dW5pZm9ybXMuc3BvdExpZ2h0RXhwb25lbnQudmFsdWUgPSBsaWdodHMuc3BvdC5leHBvbmVudHM7XHJcblxyXG5cdFx0dW5pZm9ybXMuaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3IudmFsdWUgPSBsaWdodHMuaGVtaS5za3lDb2xvcnM7XHJcblx0XHR1bmlmb3Jtcy5oZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvci52YWx1ZSA9IGxpZ2h0cy5oZW1pLmdyb3VuZENvbG9ycztcclxuXHRcdHVuaWZvcm1zLmhlbWlzcGhlcmVMaWdodERpcmVjdGlvbi52YWx1ZSA9IGxpZ2h0cy5oZW1pLnBvc2l0aW9ucztcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zU2hhZG93ICggdW5pZm9ybXMsIGxpZ2h0cyApIHtcclxuXHJcblx0XHRpZiAoIHVuaWZvcm1zLnNoYWRvd01hdHJpeCApIHtcclxuXHJcblx0XHRcdHZhciBqID0gMDtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBsaWdodHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBsaWdodCA9IGxpZ2h0c1sgaSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoICEgbGlnaHQuY2FzdFNoYWRvdyApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuU3BvdExpZ2h0IHx8ICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0ICYmICEgbGlnaHQuc2hhZG93Q2FzY2FkZSApICkge1xyXG5cclxuXHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvd01hcC52YWx1ZVsgaiBdID0gbGlnaHQuc2hhZG93TWFwO1xyXG5cdFx0XHRcdFx0dW5pZm9ybXMuc2hhZG93TWFwU2l6ZS52YWx1ZVsgaiBdID0gbGlnaHQuc2hhZG93TWFwU2l6ZTtcclxuXHJcblx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3dNYXRyaXgudmFsdWVbIGogXSA9IGxpZ2h0LnNoYWRvd01hdHJpeDtcclxuXHJcblx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3dEYXJrbmVzcy52YWx1ZVsgaiBdID0gbGlnaHQuc2hhZG93RGFya25lc3M7XHJcblx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3dCaWFzLnZhbHVlWyBqIF0gPSBsaWdodC5zaGFkb3dCaWFzO1xyXG5cclxuXHRcdFx0XHRcdGogKys7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIFVuaWZvcm1zIChsb2FkIHRvIEdQVSlcclxuXHJcblx0ZnVuY3Rpb24gbG9hZFVuaWZvcm1zTWF0cmljZXMgKCB1bmlmb3Jtcywgb2JqZWN0ICkge1xyXG5cclxuXHRcdF9nbC51bmlmb3JtTWF0cml4NGZ2KCB1bmlmb3Jtcy5tb2RlbFZpZXdNYXRyaXgsIGZhbHNlLCBvYmplY3QuX21vZGVsVmlld01hdHJpeC5lbGVtZW50cyApO1xyXG5cclxuXHRcdGlmICggdW5pZm9ybXMubm9ybWFsTWF0cml4ICkge1xyXG5cclxuXHRcdFx0X2dsLnVuaWZvcm1NYXRyaXgzZnYoIHVuaWZvcm1zLm5vcm1hbE1hdHJpeCwgZmFsc2UsIG9iamVjdC5fbm9ybWFsTWF0cml4LmVsZW1lbnRzICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBnZXRUZXh0dXJlVW5pdCgpIHtcclxuXHJcblx0XHR2YXIgdGV4dHVyZVVuaXQgPSBfdXNlZFRleHR1cmVVbml0cztcclxuXHJcblx0XHRpZiAoIHRleHR1cmVVbml0ID49IF9tYXhUZXh0dXJlcyApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggXCJXZWJHTFJlbmRlcmVyOiB0cnlpbmcgdG8gdXNlIFwiICsgdGV4dHVyZVVuaXQgKyBcIiB0ZXh0dXJlIHVuaXRzIHdoaWxlIHRoaXMgR1BVIHN1cHBvcnRzIG9ubHkgXCIgKyBfbWF4VGV4dHVyZXMgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0X3VzZWRUZXh0dXJlVW5pdHMgKz0gMTtcclxuXHJcblx0XHRyZXR1cm4gdGV4dHVyZVVuaXQ7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGxvYWRVbmlmb3Jtc0dlbmVyaWMgKCBwcm9ncmFtLCB1bmlmb3JtcyApIHtcclxuXHJcblx0XHR2YXIgdW5pZm9ybSwgdmFsdWUsIHR5cGUsIGxvY2F0aW9uLCB0ZXh0dXJlLCB0ZXh0dXJlVW5pdCwgaSwgaWwsIGosIGpsLCBvZmZzZXQ7XHJcblxyXG5cdFx0Zm9yICggaiA9IDAsIGpsID0gdW5pZm9ybXMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRsb2NhdGlvbiA9IHByb2dyYW0udW5pZm9ybXNbIHVuaWZvcm1zWyBqIF1bIDEgXSBdO1xyXG5cdFx0XHRpZiAoICFsb2NhdGlvbiApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0dW5pZm9ybSA9IHVuaWZvcm1zWyBqIF1bIDAgXTtcclxuXHJcblx0XHRcdHR5cGUgPSB1bmlmb3JtLnR5cGU7XHJcblx0XHRcdHZhbHVlID0gdW5pZm9ybS52YWx1ZTtcclxuXHJcblx0XHRcdGlmICggdHlwZSA9PT0gXCJpXCIgKSB7IC8vIHNpbmdsZSBpbnRlZ2VyXHJcblxyXG5cdFx0XHRcdF9nbC51bmlmb3JtMWkoIGxvY2F0aW9uLCB2YWx1ZSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJmXCIgKSB7IC8vIHNpbmdsZSBmbG9hdFxyXG5cclxuXHRcdFx0XHRfZ2wudW5pZm9ybTFmKCBsb2NhdGlvbiwgdmFsdWUgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwidjJcIiApIHsgLy8gc2luZ2xlIFRIUkVFLlZlY3RvcjJcclxuXHJcblx0XHRcdFx0X2dsLnVuaWZvcm0yZiggbG9jYXRpb24sIHZhbHVlLngsIHZhbHVlLnkgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwidjNcIiApIHsgLy8gc2luZ2xlIFRIUkVFLlZlY3RvcjNcclxuXHJcblx0XHRcdFx0X2dsLnVuaWZvcm0zZiggbG9jYXRpb24sIHZhbHVlLngsIHZhbHVlLnksIHZhbHVlLnogKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwidjRcIiApIHsgLy8gc2luZ2xlIFRIUkVFLlZlY3RvcjRcclxuXHJcblx0XHRcdFx0X2dsLnVuaWZvcm00ZiggbG9jYXRpb24sIHZhbHVlLngsIHZhbHVlLnksIHZhbHVlLnosIHZhbHVlLncgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwiY1wiICkgeyAvLyBzaW5nbGUgVEhSRUUuQ29sb3JcclxuXHJcblx0XHRcdFx0X2dsLnVuaWZvcm0zZiggbG9jYXRpb24sIHZhbHVlLnIsIHZhbHVlLmcsIHZhbHVlLmIgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwiaXYxXCIgKSB7IC8vIGZsYXQgYXJyYXkgb2YgaW50ZWdlcnMgKEpTIG9yIHR5cGVkIGFycmF5KVxyXG5cclxuXHRcdFx0XHRfZ2wudW5pZm9ybTFpdiggbG9jYXRpb24sIHZhbHVlICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcIml2XCIgKSB7IC8vIGZsYXQgYXJyYXkgb2YgaW50ZWdlcnMgd2l0aCAzIHggTiBzaXplIChKUyBvciB0eXBlZCBhcnJheSlcclxuXHJcblx0XHRcdFx0X2dsLnVuaWZvcm0zaXYoIGxvY2F0aW9uLCB2YWx1ZSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJmdjFcIiApIHsgLy8gZmxhdCBhcnJheSBvZiBmbG9hdHMgKEpTIG9yIHR5cGVkIGFycmF5KVxyXG5cclxuXHRcdFx0XHRfZ2wudW5pZm9ybTFmdiggbG9jYXRpb24sIHZhbHVlICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcImZ2XCIgKSB7IC8vIGZsYXQgYXJyYXkgb2YgZmxvYXRzIHdpdGggMyB4IE4gc2l6ZSAoSlMgb3IgdHlwZWQgYXJyYXkpXHJcblxyXG5cdFx0XHRcdF9nbC51bmlmb3JtM2Z2KCBsb2NhdGlvbiwgdmFsdWUgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwidjJ2XCIgKSB7IC8vIGFycmF5IG9mIFRIUkVFLlZlY3RvcjJcclxuXHJcblx0XHRcdFx0aWYgKCB1bmlmb3JtLl9hcnJheSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggMiAqIHZhbHVlLmxlbmd0aCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdG9mZnNldCA9IGkgKiAyO1xyXG5cclxuXHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5WyBvZmZzZXQgXSBcdCA9IHZhbHVlWyBpIF0ueDtcclxuXHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5WyBvZmZzZXQgKyAxIF0gPSB2YWx1ZVsgaSBdLnk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0X2dsLnVuaWZvcm0yZnYoIGxvY2F0aW9uLCB1bmlmb3JtLl9hcnJheSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJ2M3ZcIiApIHsgLy8gYXJyYXkgb2YgVEhSRUUuVmVjdG9yM1xyXG5cclxuXHRcdFx0XHRpZiAoIHVuaWZvcm0uX2FycmF5ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCAzICogdmFsdWUubGVuZ3RoICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Zm9yICggaSA9IDAsIGlsID0gdmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0b2Zmc2V0ID0gaSAqIDM7XHJcblxyXG5cdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXlbIG9mZnNldCBdIFx0ID0gdmFsdWVbIGkgXS54O1xyXG5cdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXlbIG9mZnNldCArIDEgXSA9IHZhbHVlWyBpIF0ueTtcclxuXHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5WyBvZmZzZXQgKyAyIF0gPSB2YWx1ZVsgaSBdLno7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0X2dsLnVuaWZvcm0zZnYoIGxvY2F0aW9uLCB1bmlmb3JtLl9hcnJheSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJ2NHZcIiApIHsgLy8gYXJyYXkgb2YgVEhSRUUuVmVjdG9yNFxyXG5cclxuXHRcdFx0XHRpZiAoIHVuaWZvcm0uX2FycmF5ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCA0ICogdmFsdWUubGVuZ3RoICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Zm9yICggaSA9IDAsIGlsID0gdmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0b2Zmc2V0ID0gaSAqIDQ7XHJcblxyXG5cdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXlbIG9mZnNldCBdIFx0ID0gdmFsdWVbIGkgXS54O1xyXG5cdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXlbIG9mZnNldCArIDEgXSA9IHZhbHVlWyBpIF0ueTtcclxuXHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5WyBvZmZzZXQgKyAyIF0gPSB2YWx1ZVsgaSBdLno7XHJcblx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheVsgb2Zmc2V0ICsgMyBdID0gdmFsdWVbIGkgXS53O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdF9nbC51bmlmb3JtNGZ2KCBsb2NhdGlvbiwgdW5pZm9ybS5fYXJyYXkgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwibTRcIikgeyAvLyBzaW5nbGUgVEhSRUUuTWF0cml4NFxyXG5cclxuXHRcdFx0XHRpZiAoIHVuaWZvcm0uX2FycmF5ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCAxNiApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHZhbHVlLmZsYXR0ZW5Ub0FycmF5KCB1bmlmb3JtLl9hcnJheSApO1xyXG5cdFx0XHRcdF9nbC51bmlmb3JtTWF0cml4NGZ2KCBsb2NhdGlvbiwgZmFsc2UsIHVuaWZvcm0uX2FycmF5ICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcIm00dlwiICkgeyAvLyBhcnJheSBvZiBUSFJFRS5NYXRyaXg0XHJcblxyXG5cdFx0XHRcdGlmICggdW5pZm9ybS5fYXJyYXkgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIDE2ICogdmFsdWUubGVuZ3RoICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Zm9yICggaSA9IDAsIGlsID0gdmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFsdWVbIGkgXS5mbGF0dGVuVG9BcnJheU9mZnNldCggdW5pZm9ybS5fYXJyYXksIGkgKiAxNiApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdF9nbC51bmlmb3JtTWF0cml4NGZ2KCBsb2NhdGlvbiwgZmFsc2UsIHVuaWZvcm0uX2FycmF5ICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcInRcIiApIHsgLy8gc2luZ2xlIFRIUkVFLlRleHR1cmUgKDJkIG9yIGN1YmUpXHJcblxyXG5cdFx0XHRcdHRleHR1cmUgPSB2YWx1ZTtcclxuXHRcdFx0XHR0ZXh0dXJlVW5pdCA9IGdldFRleHR1cmVVbml0KCk7XHJcblxyXG5cdFx0XHRcdF9nbC51bmlmb3JtMWkoIGxvY2F0aW9uLCB0ZXh0dXJlVW5pdCApO1xyXG5cclxuXHRcdFx0XHRpZiAoICF0ZXh0dXJlICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdGlmICggdGV4dHVyZS5pbWFnZSBpbnN0YW5jZW9mIEFycmF5ICYmIHRleHR1cmUuaW1hZ2UubGVuZ3RoID09PSA2ICkge1xyXG5cclxuXHRcdFx0XHRcdHNldEN1YmVUZXh0dXJlKCB0ZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlICkge1xyXG5cclxuXHRcdFx0XHRcdHNldEN1YmVUZXh0dXJlRHluYW1pYyggdGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRfdGhpcy5zZXRUZXh0dXJlKCB0ZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcInR2XCIgKSB7IC8vIGFycmF5IG9mIFRIUkVFLlRleHR1cmUgKDJkKVxyXG5cclxuXHRcdFx0XHRpZiAoIHVuaWZvcm0uX2FycmF5ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXkgPSBbXTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmb3IoIGkgPSAwLCBpbCA9IHVuaWZvcm0udmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXlbIGkgXSA9IGdldFRleHR1cmVVbml0KCk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0X2dsLnVuaWZvcm0xaXYoIGxvY2F0aW9uLCB1bmlmb3JtLl9hcnJheSApO1xyXG5cclxuXHRcdFx0XHRmb3IoIGkgPSAwLCBpbCA9IHVuaWZvcm0udmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGV4dHVyZSA9IHVuaWZvcm0udmFsdWVbIGkgXTtcclxuXHRcdFx0XHRcdHRleHR1cmVVbml0ID0gdW5pZm9ybS5fYXJyYXlbIGkgXTtcclxuXHJcblx0XHRcdFx0XHRpZiAoICF0ZXh0dXJlICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdFx0X3RoaXMuc2V0VGV4dHVyZSggdGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gc2V0dXBNYXRyaWNlcyAoIG9iamVjdCwgY2FtZXJhICkge1xyXG5cclxuXHRcdG9iamVjdC5fbW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsIG9iamVjdC5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdG9iamVjdC5fbm9ybWFsTWF0cml4LmdldEludmVyc2UoIG9iamVjdC5fbW9kZWxWaWV3TWF0cml4ICk7XHJcblx0XHRvYmplY3QuX25vcm1hbE1hdHJpeC50cmFuc3Bvc2UoKTtcclxuXHJcblx0fTtcclxuXHJcblx0Ly9cclxuXHJcblx0ZnVuY3Rpb24gc2V0Q29sb3JHYW1tYSggYXJyYXksIG9mZnNldCwgY29sb3IsIGludGVuc2l0eVNxICkge1xyXG5cclxuXHRcdGFycmF5WyBvZmZzZXQgXSAgICAgPSBjb2xvci5yICogY29sb3IuciAqIGludGVuc2l0eVNxO1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IGNvbG9yLmcgKiBjb2xvci5nICogaW50ZW5zaXR5U3E7XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gY29sb3IuYiAqIGNvbG9yLmIgKiBpbnRlbnNpdHlTcTtcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gc2V0Q29sb3JMaW5lYXIoIGFycmF5LCBvZmZzZXQsIGNvbG9yLCBpbnRlbnNpdHkgKSB7XHJcblxyXG5cdFx0YXJyYXlbIG9mZnNldCBdICAgICA9IGNvbG9yLnIgKiBpbnRlbnNpdHk7XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gY29sb3IuZyAqIGludGVuc2l0eTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSBjb2xvci5iICogaW50ZW5zaXR5O1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBzZXR1cExpZ2h0cyAoIHByb2dyYW0sIGxpZ2h0cyApIHtcclxuXHJcblx0XHR2YXIgbCwgbGwsIGxpZ2h0LCBuLFxyXG5cdFx0ciA9IDAsIGcgPSAwLCBiID0gMCxcclxuXHRcdGNvbG9yLCBza3lDb2xvciwgZ3JvdW5kQ29sb3IsXHJcblx0XHRpbnRlbnNpdHksICBpbnRlbnNpdHlTcSxcclxuXHRcdHBvc2l0aW9uLFxyXG5cdFx0ZGlzdGFuY2UsXHJcblxyXG5cdFx0emxpZ2h0cyA9IF9saWdodHMsXHJcblxyXG5cdFx0ZGlyQ29sb3JzID0gemxpZ2h0cy5kaXJlY3Rpb25hbC5jb2xvcnMsXHJcblx0XHRkaXJQb3NpdGlvbnMgPSB6bGlnaHRzLmRpcmVjdGlvbmFsLnBvc2l0aW9ucyxcclxuXHJcblx0XHRwb2ludENvbG9ycyA9IHpsaWdodHMucG9pbnQuY29sb3JzLFxyXG5cdFx0cG9pbnRQb3NpdGlvbnMgPSB6bGlnaHRzLnBvaW50LnBvc2l0aW9ucyxcclxuXHRcdHBvaW50RGlzdGFuY2VzID0gemxpZ2h0cy5wb2ludC5kaXN0YW5jZXMsXHJcblxyXG5cdFx0c3BvdENvbG9ycyA9IHpsaWdodHMuc3BvdC5jb2xvcnMsXHJcblx0XHRzcG90UG9zaXRpb25zID0gemxpZ2h0cy5zcG90LnBvc2l0aW9ucyxcclxuXHRcdHNwb3REaXN0YW5jZXMgPSB6bGlnaHRzLnNwb3QuZGlzdGFuY2VzLFxyXG5cdFx0c3BvdERpcmVjdGlvbnMgPSB6bGlnaHRzLnNwb3QuZGlyZWN0aW9ucyxcclxuXHRcdHNwb3RBbmdsZXNDb3MgPSB6bGlnaHRzLnNwb3QuYW5nbGVzQ29zLFxyXG5cdFx0c3BvdEV4cG9uZW50cyA9IHpsaWdodHMuc3BvdC5leHBvbmVudHMsXHJcblxyXG5cdFx0aGVtaVNreUNvbG9ycyA9IHpsaWdodHMuaGVtaS5za3lDb2xvcnMsXHJcblx0XHRoZW1pR3JvdW5kQ29sb3JzID0gemxpZ2h0cy5oZW1pLmdyb3VuZENvbG9ycyxcclxuXHRcdGhlbWlQb3NpdGlvbnMgPSB6bGlnaHRzLmhlbWkucG9zaXRpb25zLFxyXG5cclxuXHRcdGRpckxlbmd0aCA9IDAsXHJcblx0XHRwb2ludExlbmd0aCA9IDAsXHJcblx0XHRzcG90TGVuZ3RoID0gMCxcclxuXHRcdGhlbWlMZW5ndGggPSAwLFxyXG5cclxuXHRcdGRpckNvdW50ID0gMCxcclxuXHRcdHBvaW50Q291bnQgPSAwLFxyXG5cdFx0c3BvdENvdW50ID0gMCxcclxuXHRcdGhlbWlDb3VudCA9IDAsXHJcblxyXG5cdFx0ZGlyT2Zmc2V0ID0gMCxcclxuXHRcdHBvaW50T2Zmc2V0ID0gMCxcclxuXHRcdHNwb3RPZmZzZXQgPSAwLFxyXG5cdFx0aGVtaU9mZnNldCA9IDA7XHJcblxyXG5cdFx0Zm9yICggbCA9IDAsIGxsID0gbGlnaHRzLmxlbmd0aDsgbCA8IGxsOyBsICsrICkge1xyXG5cclxuXHRcdFx0bGlnaHQgPSBsaWdodHNbIGwgXTtcclxuXHJcblx0XHRcdGlmICggbGlnaHQub25seVNoYWRvdyApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0Y29sb3IgPSBsaWdodC5jb2xvcjtcclxuXHRcdFx0aW50ZW5zaXR5ID0gbGlnaHQuaW50ZW5zaXR5O1xyXG5cdFx0XHRkaXN0YW5jZSA9IGxpZ2h0LmRpc3RhbmNlO1xyXG5cclxuXHRcdFx0aWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkFtYmllbnRMaWdodCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCAhIGxpZ2h0LnZpc2libGUgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0aWYgKCBfdGhpcy5nYW1tYUlucHV0ICkge1xyXG5cclxuXHRcdFx0XHRcdHIgKz0gY29sb3IuciAqIGNvbG9yLnI7XHJcblx0XHRcdFx0XHRnICs9IGNvbG9yLmcgKiBjb2xvci5nO1xyXG5cdFx0XHRcdFx0YiArPSBjb2xvci5iICogY29sb3IuYjtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRyICs9IGNvbG9yLnI7XHJcblx0XHRcdFx0XHRnICs9IGNvbG9yLmc7XHJcblx0XHRcdFx0XHRiICs9IGNvbG9yLmI7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCApIHtcclxuXHJcblx0XHRcdFx0ZGlyQ291bnQgKz0gMTtcclxuXHJcblx0XHRcdFx0aWYgKCAhIGxpZ2h0LnZpc2libGUgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0X2RpcmVjdGlvbi5nZXRQb3NpdGlvbkZyb21NYXRyaXgoIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdFx0X3ZlY3RvcjMuZ2V0UG9zaXRpb25Gcm9tTWF0cml4KCBsaWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHRfZGlyZWN0aW9uLnN1YiggX3ZlY3RvcjMgKTtcclxuXHRcdFx0XHRfZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0XHQvLyBza2lwIGxpZ2h0cyB3aXRoIHVuZGVmaW5lZCBkaXJlY3Rpb25cclxuXHRcdFx0XHQvLyB0aGVzZSBjcmVhdGUgdHJvdWJsZXMgaW4gT3BlbkdMIChtYWtpbmcgcGl4ZWwgYmxhY2spXHJcblxyXG5cdFx0XHRcdGlmICggX2RpcmVjdGlvbi54ID09PSAwICYmIF9kaXJlY3Rpb24ueSA9PT0gMCAmJiBfZGlyZWN0aW9uLnogPT09IDAgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0ZGlyT2Zmc2V0ID0gZGlyTGVuZ3RoICogMztcclxuXHJcblx0XHRcdFx0ZGlyUG9zaXRpb25zWyBkaXJPZmZzZXQgXSAgICAgPSBfZGlyZWN0aW9uLng7XHJcblx0XHRcdFx0ZGlyUG9zaXRpb25zWyBkaXJPZmZzZXQgKyAxIF0gPSBfZGlyZWN0aW9uLnk7XHJcblx0XHRcdFx0ZGlyUG9zaXRpb25zWyBkaXJPZmZzZXQgKyAyIF0gPSBfZGlyZWN0aW9uLno7XHJcblxyXG5cdFx0XHRcdGlmICggX3RoaXMuZ2FtbWFJbnB1dCApIHtcclxuXHJcblx0XHRcdFx0XHRzZXRDb2xvckdhbW1hKCBkaXJDb2xvcnMsIGRpck9mZnNldCwgY29sb3IsIGludGVuc2l0eSAqIGludGVuc2l0eSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHNldENvbG9yTGluZWFyKCBkaXJDb2xvcnMsIGRpck9mZnNldCwgY29sb3IsIGludGVuc2l0eSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGRpckxlbmd0aCArPSAxO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludExpZ2h0ICkge1xyXG5cclxuXHRcdFx0XHRwb2ludENvdW50ICs9IDE7XHJcblxyXG5cdFx0XHRcdGlmICggISBsaWdodC52aXNpYmxlICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdHBvaW50T2Zmc2V0ID0gcG9pbnRMZW5ndGggKiAzO1xyXG5cclxuXHRcdFx0XHRpZiAoIF90aGlzLmdhbW1hSW5wdXQgKSB7XHJcblxyXG5cdFx0XHRcdFx0c2V0Q29sb3JHYW1tYSggcG9pbnRDb2xvcnMsIHBvaW50T2Zmc2V0LCBjb2xvciwgaW50ZW5zaXR5ICogaW50ZW5zaXR5ICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0c2V0Q29sb3JMaW5lYXIoIHBvaW50Q29sb3JzLCBwb2ludE9mZnNldCwgY29sb3IsIGludGVuc2l0eSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdF92ZWN0b3IzLmdldFBvc2l0aW9uRnJvbU1hdHJpeCggbGlnaHQubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdFx0cG9pbnRQb3NpdGlvbnNbIHBvaW50T2Zmc2V0IF0gICAgID0gX3ZlY3RvcjMueDtcclxuXHRcdFx0XHRwb2ludFBvc2l0aW9uc1sgcG9pbnRPZmZzZXQgKyAxIF0gPSBfdmVjdG9yMy55O1xyXG5cdFx0XHRcdHBvaW50UG9zaXRpb25zWyBwb2ludE9mZnNldCArIDIgXSA9IF92ZWN0b3IzLno7XHJcblxyXG5cdFx0XHRcdHBvaW50RGlzdGFuY2VzWyBwb2ludExlbmd0aCBdID0gZGlzdGFuY2U7XHJcblxyXG5cdFx0XHRcdHBvaW50TGVuZ3RoICs9IDE7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlNwb3RMaWdodCApIHtcclxuXHJcblx0XHRcdFx0c3BvdENvdW50ICs9IDE7XHJcblxyXG5cdFx0XHRcdGlmICggISBsaWdodC52aXNpYmxlICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdHNwb3RPZmZzZXQgPSBzcG90TGVuZ3RoICogMztcclxuXHJcblx0XHRcdFx0aWYgKCBfdGhpcy5nYW1tYUlucHV0ICkge1xyXG5cclxuXHRcdFx0XHRcdHNldENvbG9yR2FtbWEoIHNwb3RDb2xvcnMsIHNwb3RPZmZzZXQsIGNvbG9yLCBpbnRlbnNpdHkgKiBpbnRlbnNpdHkgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRzZXRDb2xvckxpbmVhciggc3BvdENvbG9ycywgc3BvdE9mZnNldCwgY29sb3IsIGludGVuc2l0eSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdF92ZWN0b3IzLmdldFBvc2l0aW9uRnJvbU1hdHJpeCggbGlnaHQubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdFx0c3BvdFBvc2l0aW9uc1sgc3BvdE9mZnNldCBdICAgICA9IF92ZWN0b3IzLng7XHJcblx0XHRcdFx0c3BvdFBvc2l0aW9uc1sgc3BvdE9mZnNldCArIDEgXSA9IF92ZWN0b3IzLnk7XHJcblx0XHRcdFx0c3BvdFBvc2l0aW9uc1sgc3BvdE9mZnNldCArIDIgXSA9IF92ZWN0b3IzLno7XHJcblxyXG5cdFx0XHRcdHNwb3REaXN0YW5jZXNbIHNwb3RMZW5ndGggXSA9IGRpc3RhbmNlO1xyXG5cclxuXHRcdFx0XHRfZGlyZWN0aW9uLmNvcHkoIF92ZWN0b3IzICk7XHJcblx0XHRcdFx0X3ZlY3RvcjMuZ2V0UG9zaXRpb25Gcm9tTWF0cml4KCBsaWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHRfZGlyZWN0aW9uLnN1YiggX3ZlY3RvcjMgKTtcclxuXHRcdFx0XHRfZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0XHRzcG90RGlyZWN0aW9uc1sgc3BvdE9mZnNldCBdICAgICA9IF9kaXJlY3Rpb24ueDtcclxuXHRcdFx0XHRzcG90RGlyZWN0aW9uc1sgc3BvdE9mZnNldCArIDEgXSA9IF9kaXJlY3Rpb24ueTtcclxuXHRcdFx0XHRzcG90RGlyZWN0aW9uc1sgc3BvdE9mZnNldCArIDIgXSA9IF9kaXJlY3Rpb24uejtcclxuXHJcblx0XHRcdFx0c3BvdEFuZ2xlc0Nvc1sgc3BvdExlbmd0aCBdID0gTWF0aC5jb3MoIGxpZ2h0LmFuZ2xlICk7XHJcblx0XHRcdFx0c3BvdEV4cG9uZW50c1sgc3BvdExlbmd0aCBdID0gbGlnaHQuZXhwb25lbnQ7XHJcblxyXG5cdFx0XHRcdHNwb3RMZW5ndGggKz0gMTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuSGVtaXNwaGVyZUxpZ2h0ICkge1xyXG5cclxuXHRcdFx0XHRoZW1pQ291bnQgKz0gMTtcclxuXHJcblx0XHRcdFx0aWYgKCAhIGxpZ2h0LnZpc2libGUgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0X2RpcmVjdGlvbi5nZXRQb3NpdGlvbkZyb21NYXRyaXgoIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdFx0X2RpcmVjdGlvbi5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdFx0Ly8gc2tpcCBsaWdodHMgd2l0aCB1bmRlZmluZWQgZGlyZWN0aW9uXHJcblx0XHRcdFx0Ly8gdGhlc2UgY3JlYXRlIHRyb3VibGVzIGluIE9wZW5HTCAobWFraW5nIHBpeGVsIGJsYWNrKVxyXG5cclxuXHRcdFx0XHRpZiAoIF9kaXJlY3Rpb24ueCA9PT0gMCAmJiBfZGlyZWN0aW9uLnkgPT09IDAgJiYgX2RpcmVjdGlvbi56ID09PSAwICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdGhlbWlPZmZzZXQgPSBoZW1pTGVuZ3RoICogMztcclxuXHJcblx0XHRcdFx0aGVtaVBvc2l0aW9uc1sgaGVtaU9mZnNldCBdICAgICA9IF9kaXJlY3Rpb24ueDtcclxuXHRcdFx0XHRoZW1pUG9zaXRpb25zWyBoZW1pT2Zmc2V0ICsgMSBdID0gX2RpcmVjdGlvbi55O1xyXG5cdFx0XHRcdGhlbWlQb3NpdGlvbnNbIGhlbWlPZmZzZXQgKyAyIF0gPSBfZGlyZWN0aW9uLno7XHJcblxyXG5cdFx0XHRcdHNreUNvbG9yID0gbGlnaHQuY29sb3I7XHJcblx0XHRcdFx0Z3JvdW5kQ29sb3IgPSBsaWdodC5ncm91bmRDb2xvcjtcclxuXHJcblx0XHRcdFx0aWYgKCBfdGhpcy5nYW1tYUlucHV0ICkge1xyXG5cclxuXHRcdFx0XHRcdGludGVuc2l0eVNxID0gaW50ZW5zaXR5ICogaW50ZW5zaXR5O1xyXG5cclxuXHRcdFx0XHRcdHNldENvbG9yR2FtbWEoIGhlbWlTa3lDb2xvcnMsIGhlbWlPZmZzZXQsIHNreUNvbG9yLCBpbnRlbnNpdHlTcSApO1xyXG5cdFx0XHRcdFx0c2V0Q29sb3JHYW1tYSggaGVtaUdyb3VuZENvbG9ycywgaGVtaU9mZnNldCwgZ3JvdW5kQ29sb3IsIGludGVuc2l0eVNxICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0c2V0Q29sb3JMaW5lYXIoIGhlbWlTa3lDb2xvcnMsIGhlbWlPZmZzZXQsIHNreUNvbG9yLCBpbnRlbnNpdHkgKTtcclxuXHRcdFx0XHRcdHNldENvbG9yTGluZWFyKCBoZW1pR3JvdW5kQ29sb3JzLCBoZW1pT2Zmc2V0LCBncm91bmRDb2xvciwgaW50ZW5zaXR5ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aGVtaUxlbmd0aCArPSAxO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBudWxsIGV2ZW50dWFsIHJlbWFpbnMgZnJvbSByZW1vdmVkIGxpZ2h0c1xyXG5cdFx0Ly8gKHRoaXMgaXMgdG8gYXZvaWQgaWYgaW4gc2hhZGVyKVxyXG5cclxuXHRcdGZvciAoIGwgPSBkaXJMZW5ndGggKiAzLCBsbCA9IE1hdGgubWF4KCBkaXJDb2xvcnMubGVuZ3RoLCBkaXJDb3VudCAqIDMgKTsgbCA8IGxsOyBsICsrICkgZGlyQ29sb3JzWyBsIF0gPSAwLjA7XHJcblx0XHRmb3IgKCBsID0gcG9pbnRMZW5ndGggKiAzLCBsbCA9IE1hdGgubWF4KCBwb2ludENvbG9ycy5sZW5ndGgsIHBvaW50Q291bnQgKiAzICk7IGwgPCBsbDsgbCArKyApIHBvaW50Q29sb3JzWyBsIF0gPSAwLjA7XHJcblx0XHRmb3IgKCBsID0gc3BvdExlbmd0aCAqIDMsIGxsID0gTWF0aC5tYXgoIHNwb3RDb2xvcnMubGVuZ3RoLCBzcG90Q291bnQgKiAzICk7IGwgPCBsbDsgbCArKyApIHNwb3RDb2xvcnNbIGwgXSA9IDAuMDtcclxuXHRcdGZvciAoIGwgPSBoZW1pTGVuZ3RoICogMywgbGwgPSBNYXRoLm1heCggaGVtaVNreUNvbG9ycy5sZW5ndGgsIGhlbWlDb3VudCAqIDMgKTsgbCA8IGxsOyBsICsrICkgaGVtaVNreUNvbG9yc1sgbCBdID0gMC4wO1xyXG5cdFx0Zm9yICggbCA9IGhlbWlMZW5ndGggKiAzLCBsbCA9IE1hdGgubWF4KCBoZW1pR3JvdW5kQ29sb3JzLmxlbmd0aCwgaGVtaUNvdW50ICogMyApOyBsIDwgbGw7IGwgKysgKSBoZW1pR3JvdW5kQ29sb3JzWyBsIF0gPSAwLjA7XHJcblxyXG5cdFx0emxpZ2h0cy5kaXJlY3Rpb25hbC5sZW5ndGggPSBkaXJMZW5ndGg7XHJcblx0XHR6bGlnaHRzLnBvaW50Lmxlbmd0aCA9IHBvaW50TGVuZ3RoO1xyXG5cdFx0emxpZ2h0cy5zcG90Lmxlbmd0aCA9IHNwb3RMZW5ndGg7XHJcblx0XHR6bGlnaHRzLmhlbWkubGVuZ3RoID0gaGVtaUxlbmd0aDtcclxuXHJcblx0XHR6bGlnaHRzLmFtYmllbnRbIDAgXSA9IHI7XHJcblx0XHR6bGlnaHRzLmFtYmllbnRbIDEgXSA9IGc7XHJcblx0XHR6bGlnaHRzLmFtYmllbnRbIDIgXSA9IGI7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIEdMIHN0YXRlIHNldHRpbmdcclxuXHJcblx0dGhpcy5zZXRGYWNlQ3VsbGluZyA9IGZ1bmN0aW9uICggY3VsbEZhY2UsIGZyb250RmFjZURpcmVjdGlvbiApIHtcclxuXHJcblx0XHRpZiAoIGN1bGxGYWNlID09PSBUSFJFRS5DdWxsRmFjZU5vbmUgKSB7XHJcblxyXG5cdFx0XHRfZ2wuZGlzYWJsZSggX2dsLkNVTExfRkFDRSApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRpZiAoIGZyb250RmFjZURpcmVjdGlvbiA9PT0gVEhSRUUuRnJvbnRGYWNlRGlyZWN0aW9uQ1cgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5mcm9udEZhY2UoIF9nbC5DVyApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0X2dsLmZyb250RmFjZSggX2dsLkNDVyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBjdWxsRmFjZSA9PT0gVEhSRUUuQ3VsbEZhY2VCYWNrICkge1xyXG5cclxuXHRcdFx0XHRfZ2wuY3VsbEZhY2UoIF9nbC5CQUNLICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBjdWxsRmFjZSA9PT0gVEhSRUUuQ3VsbEZhY2VGcm9udCApIHtcclxuXHJcblx0XHRcdFx0X2dsLmN1bGxGYWNlKCBfZ2wuRlJPTlQgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdF9nbC5jdWxsRmFjZSggX2dsLkZST05UX0FORF9CQUNLICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRfZ2wuZW5hYmxlKCBfZ2wuQ1VMTF9GQUNFICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnNldE1hdGVyaWFsRmFjZXMgPSBmdW5jdGlvbiAoIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdHZhciBkb3VibGVTaWRlZCA9IG1hdGVyaWFsLnNpZGUgPT09IFRIUkVFLkRvdWJsZVNpZGU7XHJcblx0XHR2YXIgZmxpcFNpZGVkID0gbWF0ZXJpYWwuc2lkZSA9PT0gVEhSRUUuQmFja1NpZGU7XHJcblxyXG5cdFx0aWYgKCBfb2xkRG91YmxlU2lkZWQgIT09IGRvdWJsZVNpZGVkICkge1xyXG5cclxuXHRcdFx0aWYgKCBkb3VibGVTaWRlZCApIHtcclxuXHJcblx0XHRcdFx0X2dsLmRpc2FibGUoIF9nbC5DVUxMX0ZBQ0UgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdF9nbC5lbmFibGUoIF9nbC5DVUxMX0ZBQ0UgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdF9vbGREb3VibGVTaWRlZCA9IGRvdWJsZVNpZGVkO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIF9vbGRGbGlwU2lkZWQgIT09IGZsaXBTaWRlZCApIHtcclxuXHJcblx0XHRcdGlmICggZmxpcFNpZGVkICkge1xyXG5cclxuXHRcdFx0XHRfZ2wuZnJvbnRGYWNlKCBfZ2wuQ1cgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdF9nbC5mcm9udEZhY2UoIF9nbC5DQ1cgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdF9vbGRGbGlwU2lkZWQgPSBmbGlwU2lkZWQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnNldERlcHRoVGVzdCA9IGZ1bmN0aW9uICggZGVwdGhUZXN0ICkge1xyXG5cclxuXHRcdGlmICggX29sZERlcHRoVGVzdCAhPT0gZGVwdGhUZXN0ICkge1xyXG5cclxuXHRcdFx0aWYgKCBkZXB0aFRlc3QgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5lbmFibGUoIF9nbC5ERVBUSF9URVNUICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRfZ2wuZGlzYWJsZSggX2dsLkRFUFRIX1RFU1QgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdF9vbGREZXB0aFRlc3QgPSBkZXB0aFRlc3Q7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnNldERlcHRoV3JpdGUgPSBmdW5jdGlvbiAoIGRlcHRoV3JpdGUgKSB7XHJcblxyXG5cdFx0aWYgKCBfb2xkRGVwdGhXcml0ZSAhPT0gZGVwdGhXcml0ZSApIHtcclxuXHJcblx0XHRcdF9nbC5kZXB0aE1hc2soIGRlcHRoV3JpdGUgKTtcclxuXHRcdFx0X29sZERlcHRoV3JpdGUgPSBkZXB0aFdyaXRlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gc2V0TGluZVdpZHRoICggd2lkdGggKSB7XHJcblxyXG5cdFx0aWYgKCB3aWR0aCAhPT0gX29sZExpbmVXaWR0aCApIHtcclxuXHJcblx0XHRcdF9nbC5saW5lV2lkdGgoIHdpZHRoICk7XHJcblxyXG5cdFx0XHRfb2xkTGluZVdpZHRoID0gd2lkdGg7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBzZXRQb2x5Z29uT2Zmc2V0ICggcG9seWdvbm9mZnNldCwgZmFjdG9yLCB1bml0cyApIHtcclxuXHJcblx0XHRpZiAoIF9vbGRQb2x5Z29uT2Zmc2V0ICE9PSBwb2x5Z29ub2Zmc2V0ICkge1xyXG5cclxuXHRcdFx0aWYgKCBwb2x5Z29ub2Zmc2V0ICkge1xyXG5cclxuXHRcdFx0XHRfZ2wuZW5hYmxlKCBfZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0X2dsLmRpc2FibGUoIF9nbC5QT0xZR09OX09GRlNFVF9GSUxMICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRfb2xkUG9seWdvbk9mZnNldCA9IHBvbHlnb25vZmZzZXQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggcG9seWdvbm9mZnNldCAmJiAoIF9vbGRQb2x5Z29uT2Zmc2V0RmFjdG9yICE9PSBmYWN0b3IgfHwgX29sZFBvbHlnb25PZmZzZXRVbml0cyAhPT0gdW5pdHMgKSApIHtcclxuXHJcblx0XHRcdF9nbC5wb2x5Z29uT2Zmc2V0KCBmYWN0b3IsIHVuaXRzICk7XHJcblxyXG5cdFx0XHRfb2xkUG9seWdvbk9mZnNldEZhY3RvciA9IGZhY3RvcjtcclxuXHRcdFx0X29sZFBvbHlnb25PZmZzZXRVbml0cyA9IHVuaXRzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5zZXRCbGVuZGluZyA9IGZ1bmN0aW9uICggYmxlbmRpbmcsIGJsZW5kRXF1YXRpb24sIGJsZW5kU3JjLCBibGVuZERzdCApIHtcclxuXHJcblx0XHRpZiAoIGJsZW5kaW5nICE9PSBfb2xkQmxlbmRpbmcgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGJsZW5kaW5nID09PSBUSFJFRS5Ob0JsZW5kaW5nICkge1xyXG5cclxuXHRcdFx0XHRfZ2wuZGlzYWJsZSggX2dsLkJMRU5EICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBibGVuZGluZyA9PT0gVEhSRUUuQWRkaXRpdmVCbGVuZGluZyApIHtcclxuXHJcblx0XHRcdFx0X2dsLmVuYWJsZSggX2dsLkJMRU5EICk7XHJcblx0XHRcdFx0X2dsLmJsZW5kRXF1YXRpb24oIF9nbC5GVU5DX0FERCApO1xyXG5cdFx0XHRcdF9nbC5ibGVuZEZ1bmMoIF9nbC5TUkNfQUxQSEEsIF9nbC5PTkUgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGJsZW5kaW5nID09PSBUSFJFRS5TdWJ0cmFjdGl2ZUJsZW5kaW5nICkge1xyXG5cclxuXHRcdFx0XHQvLyBUT0RPOiBGaW5kIGJsZW5kRnVuY1NlcGFyYXRlKCkgY29tYmluYXRpb25cclxuXHRcdFx0XHRfZ2wuZW5hYmxlKCBfZ2wuQkxFTkQgKTtcclxuXHRcdFx0XHRfZ2wuYmxlbmRFcXVhdGlvbiggX2dsLkZVTkNfQUREICk7XHJcblx0XHRcdFx0X2dsLmJsZW5kRnVuYyggX2dsLlpFUk8sIF9nbC5PTkVfTUlOVVNfU1JDX0NPTE9SICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBibGVuZGluZyA9PT0gVEhSRUUuTXVsdGlwbHlCbGVuZGluZyApIHtcclxuXHJcblx0XHRcdFx0Ly8gVE9ETzogRmluZCBibGVuZEZ1bmNTZXBhcmF0ZSgpIGNvbWJpbmF0aW9uXHJcblx0XHRcdFx0X2dsLmVuYWJsZSggX2dsLkJMRU5EICk7XHJcblx0XHRcdFx0X2dsLmJsZW5kRXF1YXRpb24oIF9nbC5GVU5DX0FERCApO1xyXG5cdFx0XHRcdF9nbC5ibGVuZEZ1bmMoIF9nbC5aRVJPLCBfZ2wuU1JDX0NPTE9SICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBibGVuZGluZyA9PT0gVEhSRUUuQ3VzdG9tQmxlbmRpbmcgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5lbmFibGUoIF9nbC5CTEVORCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0X2dsLmVuYWJsZSggX2dsLkJMRU5EICk7XHJcblx0XHRcdFx0X2dsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZSggX2dsLkZVTkNfQURELCBfZ2wuRlVOQ19BREQgKTtcclxuXHRcdFx0XHRfZ2wuYmxlbmRGdW5jU2VwYXJhdGUoIF9nbC5TUkNfQUxQSEEsIF9nbC5PTkVfTUlOVVNfU1JDX0FMUEhBLCBfZ2wuT05FLCBfZ2wuT05FX01JTlVTX1NSQ19BTFBIQSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0X29sZEJsZW5kaW5nID0gYmxlbmRpbmc7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggYmxlbmRpbmcgPT09IFRIUkVFLkN1c3RvbUJsZW5kaW5nICkge1xyXG5cclxuXHRcdFx0aWYgKCBibGVuZEVxdWF0aW9uICE9PSBfb2xkQmxlbmRFcXVhdGlvbiApIHtcclxuXHJcblx0XHRcdFx0X2dsLmJsZW5kRXF1YXRpb24oIHBhcmFtVGhyZWVUb0dMKCBibGVuZEVxdWF0aW9uICkgKTtcclxuXHJcblx0XHRcdFx0X29sZEJsZW5kRXF1YXRpb24gPSBibGVuZEVxdWF0aW9uO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBibGVuZFNyYyAhPT0gX29sZEJsZW5kU3JjIHx8IGJsZW5kRHN0ICE9PSBfb2xkQmxlbmREc3QgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5ibGVuZEZ1bmMoIHBhcmFtVGhyZWVUb0dMKCBibGVuZFNyYyApLCBwYXJhbVRocmVlVG9HTCggYmxlbmREc3QgKSApO1xyXG5cclxuXHRcdFx0XHRfb2xkQmxlbmRTcmMgPSBibGVuZFNyYztcclxuXHRcdFx0XHRfb2xkQmxlbmREc3QgPSBibGVuZERzdDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0X29sZEJsZW5kRXF1YXRpb24gPSBudWxsO1xyXG5cdFx0XHRfb2xkQmxlbmRTcmMgPSBudWxsO1xyXG5cdFx0XHRfb2xkQmxlbmREc3QgPSBudWxsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0Ly8gRGVmaW5lc1xyXG5cclxuXHRmdW5jdGlvbiBnZW5lcmF0ZURlZmluZXMgKCBkZWZpbmVzICkge1xyXG5cclxuXHRcdHZhciB2YWx1ZSwgY2h1bmssIGNodW5rcyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIHZhciBkIGluIGRlZmluZXMgKSB7XHJcblxyXG5cdFx0XHR2YWx1ZSA9IGRlZmluZXNbIGQgXTtcclxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdGNodW5rID0gXCIjZGVmaW5lIFwiICsgZCArIFwiIFwiICsgdmFsdWU7XHJcblx0XHRcdGNodW5rcy5wdXNoKCBjaHVuayApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gY2h1bmtzLmpvaW4oIFwiXFxuXCIgKTtcclxuXHJcblx0fTtcclxuXHJcblx0Ly8gU2hhZGVyc1xyXG5cclxuXHRmdW5jdGlvbiBidWlsZFByb2dyYW0gKCBzaGFkZXJJRCwgZnJhZ21lbnRTaGFkZXIsIHZlcnRleFNoYWRlciwgdW5pZm9ybXMsIGF0dHJpYnV0ZXMsIGRlZmluZXMsIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFx0dmFyIHAsIHBsLCBkLCBwcm9ncmFtLCBjb2RlO1xyXG5cdFx0dmFyIGNodW5rcyA9IFtdO1xyXG5cclxuXHRcdC8vIEdlbmVyYXRlIGNvZGVcclxuXHJcblx0XHRpZiAoIHNoYWRlcklEICkge1xyXG5cclxuXHRcdFx0Y2h1bmtzLnB1c2goIHNoYWRlcklEICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGNodW5rcy5wdXNoKCBmcmFnbWVudFNoYWRlciApO1xyXG5cdFx0XHRjaHVua3MucHVzaCggdmVydGV4U2hhZGVyICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIGQgaW4gZGVmaW5lcyApIHtcclxuXHJcblx0XHRcdGNodW5rcy5wdXNoKCBkICk7XHJcblx0XHRcdGNodW5rcy5wdXNoKCBkZWZpbmVzWyBkIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggcCBpbiBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRcdFx0Y2h1bmtzLnB1c2goIHAgKTtcclxuXHRcdFx0Y2h1bmtzLnB1c2goIHBhcmFtZXRlcnNbIHAgXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb2RlID0gY2h1bmtzLmpvaW4oKTtcclxuXHJcblx0XHQvLyBDaGVjayBpZiBjb2RlIGhhcyBiZWVuIGFscmVhZHkgY29tcGlsZWRcclxuXHJcblx0XHRmb3IgKCBwID0gMCwgcGwgPSBfcHJvZ3JhbXMubGVuZ3RoOyBwIDwgcGw7IHAgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgcHJvZ3JhbUluZm8gPSBfcHJvZ3JhbXNbIHAgXTtcclxuXHJcblx0XHRcdGlmICggcHJvZ3JhbUluZm8uY29kZSA9PT0gY29kZSApIHtcclxuXHJcblx0XHRcdFx0Ly9jb25zb2xlLmxvZyggXCJDb2RlIGFscmVhZHkgY29tcGlsZWQuXCIgLyo6IFxcblxcblwiICsgY29kZSovICk7XHJcblxyXG5cdFx0XHRcdHByb2dyYW1JbmZvLnVzZWRUaW1lcyArKztcclxuXHJcblx0XHRcdFx0cmV0dXJuIHByb2dyYW1JbmZvLnByb2dyYW07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzaGFkb3dNYXBUeXBlRGVmaW5lID0gXCJTSEFET1dNQVBfVFlQRV9CQVNJQ1wiO1xyXG5cclxuXHRcdGlmICggcGFyYW1ldGVycy5zaGFkb3dNYXBUeXBlID09PSBUSFJFRS5QQ0ZTaGFkb3dNYXAgKSB7XHJcblxyXG5cdFx0XHRzaGFkb3dNYXBUeXBlRGVmaW5lID0gXCJTSEFET1dNQVBfVFlQRV9QQ0ZcIjtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBwYXJhbWV0ZXJzLnNoYWRvd01hcFR5cGUgPT09IFRIUkVFLlBDRlNvZnRTaGFkb3dNYXAgKSB7XHJcblxyXG5cdFx0XHRzaGFkb3dNYXBUeXBlRGVmaW5lID0gXCJTSEFET1dNQVBfVFlQRV9QQ0ZfU09GVFwiO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvL2NvbnNvbGUubG9nKCBcImJ1aWxkaW5nIG5ldyBwcm9ncmFtIFwiICk7XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHR2YXIgY3VzdG9tRGVmaW5lcyA9IGdlbmVyYXRlRGVmaW5lcyggZGVmaW5lcyApO1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0cHJvZ3JhbSA9IF9nbC5jcmVhdGVQcm9ncmFtKCk7XHJcblxyXG5cdFx0dmFyIHByZWZpeF92ZXJ0ZXggPSBbXHJcblxyXG5cdFx0XHRcInByZWNpc2lvbiBcIiArIF9wcmVjaXNpb24gKyBcIiBmbG9hdDtcIixcclxuXHJcblx0XHRcdGN1c3RvbURlZmluZXMsXHJcblxyXG5cdFx0XHRfc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcyA/IFwiI2RlZmluZSBWRVJURVhfVEVYVFVSRVNcIiA6IFwiXCIsXHJcblxyXG5cdFx0XHRfdGhpcy5nYW1tYUlucHV0ID8gXCIjZGVmaW5lIEdBTU1BX0lOUFVUXCIgOiBcIlwiLFxyXG5cdFx0XHRfdGhpcy5nYW1tYU91dHB1dCA/IFwiI2RlZmluZSBHQU1NQV9PVVRQVVRcIiA6IFwiXCIsXHJcblx0XHRcdF90aGlzLnBoeXNpY2FsbHlCYXNlZFNoYWRpbmcgPyBcIiNkZWZpbmUgUEhZU0lDQUxMWV9CQVNFRF9TSEFESU5HXCIgOiBcIlwiLFxyXG5cclxuXHRcdFx0XCIjZGVmaW5lIE1BWF9ESVJfTElHSFRTIFwiICsgcGFyYW1ldGVycy5tYXhEaXJMaWdodHMsXHJcblx0XHRcdFwiI2RlZmluZSBNQVhfUE9JTlRfTElHSFRTIFwiICsgcGFyYW1ldGVycy5tYXhQb2ludExpZ2h0cyxcclxuXHRcdFx0XCIjZGVmaW5lIE1BWF9TUE9UX0xJR0hUUyBcIiArIHBhcmFtZXRlcnMubWF4U3BvdExpZ2h0cyxcclxuXHRcdFx0XCIjZGVmaW5lIE1BWF9IRU1JX0xJR0hUUyBcIiArIHBhcmFtZXRlcnMubWF4SGVtaUxpZ2h0cyxcclxuXHJcblx0XHRcdFwiI2RlZmluZSBNQVhfU0hBRE9XUyBcIiArIHBhcmFtZXRlcnMubWF4U2hhZG93cyxcclxuXHJcblx0XHRcdFwiI2RlZmluZSBNQVhfQk9ORVMgXCIgKyBwYXJhbWV0ZXJzLm1heEJvbmVzLFxyXG5cclxuXHRcdFx0cGFyYW1ldGVycy5tYXAgPyBcIiNkZWZpbmUgVVNFX01BUFwiIDogXCJcIixcclxuXHRcdFx0cGFyYW1ldGVycy5lbnZNYXAgPyBcIiNkZWZpbmUgVVNFX0VOVk1BUFwiIDogXCJcIixcclxuXHRcdFx0cGFyYW1ldGVycy5saWdodE1hcCA/IFwiI2RlZmluZSBVU0VfTElHSFRNQVBcIiA6IFwiXCIsXHJcblx0XHRcdHBhcmFtZXRlcnMuYnVtcE1hcCA/IFwiI2RlZmluZSBVU0VfQlVNUE1BUFwiIDogXCJcIixcclxuXHRcdFx0cGFyYW1ldGVycy5ub3JtYWxNYXAgPyBcIiNkZWZpbmUgVVNFX05PUk1BTE1BUFwiIDogXCJcIixcclxuXHRcdFx0cGFyYW1ldGVycy5zcGVjdWxhck1hcCA/IFwiI2RlZmluZSBVU0VfU1BFQ1VMQVJNQVBcIiA6IFwiXCIsXHJcblx0XHRcdHBhcmFtZXRlcnMudmVydGV4Q29sb3JzID8gXCIjZGVmaW5lIFVTRV9DT0xPUlwiIDogXCJcIixcclxuXHJcblx0XHRcdHBhcmFtZXRlcnMuc2tpbm5pbmcgPyBcIiNkZWZpbmUgVVNFX1NLSU5OSU5HXCIgOiBcIlwiLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLnVzZVZlcnRleFRleHR1cmUgPyBcIiNkZWZpbmUgQk9ORV9URVhUVVJFXCIgOiBcIlwiLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLmJvbmVUZXh0dXJlV2lkdGggPyBcIiNkZWZpbmUgTl9CT05FX1BJWEVMX1ggXCIgKyBwYXJhbWV0ZXJzLmJvbmVUZXh0dXJlV2lkdGgudG9GaXhlZCggMSApIDogXCJcIixcclxuXHRcdFx0cGFyYW1ldGVycy5ib25lVGV4dHVyZUhlaWdodCA/IFwiI2RlZmluZSBOX0JPTkVfUElYRUxfWSBcIiArIHBhcmFtZXRlcnMuYm9uZVRleHR1cmVIZWlnaHQudG9GaXhlZCggMSApIDogXCJcIixcclxuXHJcblx0XHRcdHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzID8gXCIjZGVmaW5lIFVTRV9NT1JQSFRBUkdFVFNcIiA6IFwiXCIsXHJcblx0XHRcdHBhcmFtZXRlcnMubW9ycGhOb3JtYWxzID8gXCIjZGVmaW5lIFVTRV9NT1JQSE5PUk1BTFNcIiA6IFwiXCIsXHJcblx0XHRcdHBhcmFtZXRlcnMucGVyUGl4ZWwgPyBcIiNkZWZpbmUgUEhPTkdfUEVSX1BJWEVMXCIgOiBcIlwiLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLndyYXBBcm91bmQgPyBcIiNkZWZpbmUgV1JBUF9BUk9VTkRcIiA6IFwiXCIsXHJcblx0XHRcdHBhcmFtZXRlcnMuZG91YmxlU2lkZWQgPyBcIiNkZWZpbmUgRE9VQkxFX1NJREVEXCIgOiBcIlwiLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLmZsaXBTaWRlZCA/IFwiI2RlZmluZSBGTElQX1NJREVEXCIgOiBcIlwiLFxyXG5cclxuXHRcdFx0cGFyYW1ldGVycy5zaGFkb3dNYXBFbmFibGVkID8gXCIjZGVmaW5lIFVTRV9TSEFET1dNQVBcIiA6IFwiXCIsXHJcblx0XHRcdHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/IFwiI2RlZmluZSBcIiArIHNoYWRvd01hcFR5cGVEZWZpbmUgOiBcIlwiLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLnNoYWRvd01hcERlYnVnID8gXCIjZGVmaW5lIFNIQURPV01BUF9ERUJVR1wiIDogXCJcIixcclxuXHRcdFx0cGFyYW1ldGVycy5zaGFkb3dNYXBDYXNjYWRlID8gXCIjZGVmaW5lIFNIQURPV01BUF9DQVNDQURFXCIgOiBcIlwiLFxyXG5cclxuXHRcdFx0cGFyYW1ldGVycy5zaXplQXR0ZW51YXRpb24gPyBcIiNkZWZpbmUgVVNFX1NJWkVBVFRFTlVBVElPTlwiIDogXCJcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSBtYXQ0IG1vZGVsTWF0cml4O1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBtYXQ0IHByb2plY3Rpb25NYXRyaXg7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBtYXQ0IHZpZXdNYXRyaXg7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBtYXQzIG5vcm1hbE1hdHJpeDtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgY2FtZXJhUG9zaXRpb247XCIsXHJcblxyXG5cdFx0XHRcImF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uO1wiLFxyXG5cdFx0XHRcImF0dHJpYnV0ZSB2ZWMzIG5vcm1hbDtcIixcclxuXHRcdFx0XCJhdHRyaWJ1dGUgdmVjMiB1djtcIixcclxuXHRcdFx0XCJhdHRyaWJ1dGUgdmVjMiB1djI7XCIsXHJcblxyXG5cdFx0XHRcIiNpZmRlZiBVU0VfQ09MT1JcIixcclxuXHJcblx0XHRcdFx0XCJhdHRyaWJ1dGUgdmVjMyBjb2xvcjtcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcIiNpZmRlZiBVU0VfTU9SUEhUQVJHRVRTXCIsXHJcblxyXG5cdFx0XHRcdFwiYXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQwO1wiLFxyXG5cdFx0XHRcdFwiYXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQxO1wiLFxyXG5cdFx0XHRcdFwiYXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQyO1wiLFxyXG5cdFx0XHRcdFwiYXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQzO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNpZmRlZiBVU0VfTU9SUEhOT1JNQUxTXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDA7XCIsXHJcblx0XHRcdFx0XHRcImF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMTtcIixcclxuXHRcdFx0XHRcdFwiYXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwyO1wiLFxyXG5cdFx0XHRcdFx0XCJhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDM7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2Vsc2VcIixcclxuXHJcblx0XHRcdFx0XHRcImF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NDtcIixcclxuXHRcdFx0XHRcdFwiYXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ1O1wiLFxyXG5cdFx0XHRcdFx0XCJhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDY7XCIsXHJcblx0XHRcdFx0XHRcImF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NztcIixcclxuXHJcblx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcIiNpZmRlZiBVU0VfU0tJTk5JTkdcIixcclxuXHJcblx0XHRcdFx0XCJhdHRyaWJ1dGUgdmVjNCBza2luSW5kZXg7XCIsXHJcblx0XHRcdFx0XCJhdHRyaWJ1dGUgdmVjNCBza2luV2VpZ2h0O1wiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFwiXCJcclxuXHJcblx0XHRdLmpvaW4oXCJcXG5cIik7XHJcblxyXG5cdFx0dmFyIHByZWZpeF9mcmFnbWVudCA9IFtcclxuXHJcblx0XHRcdFwicHJlY2lzaW9uIFwiICsgX3ByZWNpc2lvbiArIFwiIGZsb2F0O1wiLFxyXG5cclxuXHRcdFx0KCBwYXJhbWV0ZXJzLmJ1bXBNYXAgfHwgcGFyYW1ldGVycy5ub3JtYWxNYXAgKSA/IFwiI2V4dGVuc2lvbiBHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMgOiBlbmFibGVcIiA6IFwiXCIsXHJcblxyXG5cdFx0XHRjdXN0b21EZWZpbmVzLFxyXG5cclxuXHRcdFx0XCIjZGVmaW5lIE1BWF9ESVJfTElHSFRTIFwiICsgcGFyYW1ldGVycy5tYXhEaXJMaWdodHMsXHJcblx0XHRcdFwiI2RlZmluZSBNQVhfUE9JTlRfTElHSFRTIFwiICsgcGFyYW1ldGVycy5tYXhQb2ludExpZ2h0cyxcclxuXHRcdFx0XCIjZGVmaW5lIE1BWF9TUE9UX0xJR0hUUyBcIiArIHBhcmFtZXRlcnMubWF4U3BvdExpZ2h0cyxcclxuXHRcdFx0XCIjZGVmaW5lIE1BWF9IRU1JX0xJR0hUUyBcIiArIHBhcmFtZXRlcnMubWF4SGVtaUxpZ2h0cyxcclxuXHJcblx0XHRcdFwiI2RlZmluZSBNQVhfU0hBRE9XUyBcIiArIHBhcmFtZXRlcnMubWF4U2hhZG93cyxcclxuXHJcblx0XHRcdHBhcmFtZXRlcnMuYWxwaGFUZXN0ID8gXCIjZGVmaW5lIEFMUEhBVEVTVCBcIiArIHBhcmFtZXRlcnMuYWxwaGFUZXN0OiBcIlwiLFxyXG5cclxuXHRcdFx0X3RoaXMuZ2FtbWFJbnB1dCA/IFwiI2RlZmluZSBHQU1NQV9JTlBVVFwiIDogXCJcIixcclxuXHRcdFx0X3RoaXMuZ2FtbWFPdXRwdXQgPyBcIiNkZWZpbmUgR0FNTUFfT1VUUFVUXCIgOiBcIlwiLFxyXG5cdFx0XHRfdGhpcy5waHlzaWNhbGx5QmFzZWRTaGFkaW5nID8gXCIjZGVmaW5lIFBIWVNJQ0FMTFlfQkFTRURfU0hBRElOR1wiIDogXCJcIixcclxuXHJcblx0XHRcdCggcGFyYW1ldGVycy51c2VGb2cgJiYgcGFyYW1ldGVycy5mb2cgKSA/IFwiI2RlZmluZSBVU0VfRk9HXCIgOiBcIlwiLFxyXG5cdFx0XHQoIHBhcmFtZXRlcnMudXNlRm9nICYmIHBhcmFtZXRlcnMuZm9nRXhwICkgPyBcIiNkZWZpbmUgRk9HX0VYUDJcIiA6IFwiXCIsXHJcblxyXG5cdFx0XHRwYXJhbWV0ZXJzLm1hcCA/IFwiI2RlZmluZSBVU0VfTUFQXCIgOiBcIlwiLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLmVudk1hcCA/IFwiI2RlZmluZSBVU0VfRU5WTUFQXCIgOiBcIlwiLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLmxpZ2h0TWFwID8gXCIjZGVmaW5lIFVTRV9MSUdIVE1BUFwiIDogXCJcIixcclxuXHRcdFx0cGFyYW1ldGVycy5idW1wTWFwID8gXCIjZGVmaW5lIFVTRV9CVU1QTUFQXCIgOiBcIlwiLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLm5vcm1hbE1hcCA/IFwiI2RlZmluZSBVU0VfTk9STUFMTUFQXCIgOiBcIlwiLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLnNwZWN1bGFyTWFwID8gXCIjZGVmaW5lIFVTRV9TUEVDVUxBUk1BUFwiIDogXCJcIixcclxuXHRcdFx0cGFyYW1ldGVycy52ZXJ0ZXhDb2xvcnMgPyBcIiNkZWZpbmUgVVNFX0NPTE9SXCIgOiBcIlwiLFxyXG5cclxuXHRcdFx0cGFyYW1ldGVycy5tZXRhbCA/IFwiI2RlZmluZSBNRVRBTFwiIDogXCJcIixcclxuXHRcdFx0cGFyYW1ldGVycy5wZXJQaXhlbCA/IFwiI2RlZmluZSBQSE9OR19QRVJfUElYRUxcIiA6IFwiXCIsXHJcblx0XHRcdHBhcmFtZXRlcnMud3JhcEFyb3VuZCA/IFwiI2RlZmluZSBXUkFQX0FST1VORFwiIDogXCJcIixcclxuXHRcdFx0cGFyYW1ldGVycy5kb3VibGVTaWRlZCA/IFwiI2RlZmluZSBET1VCTEVfU0lERURcIiA6IFwiXCIsXHJcblx0XHRcdHBhcmFtZXRlcnMuZmxpcFNpZGVkID8gXCIjZGVmaW5lIEZMSVBfU0lERURcIiA6IFwiXCIsXHJcblxyXG5cdFx0XHRwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyBcIiNkZWZpbmUgVVNFX1NIQURPV01BUFwiIDogXCJcIixcclxuXHRcdFx0cGFyYW1ldGVycy5zaGFkb3dNYXBFbmFibGVkID8gXCIjZGVmaW5lIFwiICsgc2hhZG93TWFwVHlwZURlZmluZSA6IFwiXCIsXHJcblx0XHRcdHBhcmFtZXRlcnMuc2hhZG93TWFwRGVidWcgPyBcIiNkZWZpbmUgU0hBRE9XTUFQX0RFQlVHXCIgOiBcIlwiLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLnNoYWRvd01hcENhc2NhZGUgPyBcIiNkZWZpbmUgU0hBRE9XTUFQX0NBU0NBREVcIiA6IFwiXCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gbWF0NCB2aWV3TWF0cml4O1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBjYW1lcmFQb3NpdGlvbjtcIixcclxuXHRcdFx0XCJcIlxyXG5cclxuXHRcdF0uam9pbihcIlxcblwiKTtcclxuXHJcblx0XHR2YXIgZ2xGcmFnbWVudFNoYWRlciA9IGdldFNoYWRlciggXCJmcmFnbWVudFwiLCBwcmVmaXhfZnJhZ21lbnQgKyBmcmFnbWVudFNoYWRlciApO1xyXG5cdFx0dmFyIGdsVmVydGV4U2hhZGVyID0gZ2V0U2hhZGVyKCBcInZlcnRleFwiLCBwcmVmaXhfdmVydGV4ICsgdmVydGV4U2hhZGVyICk7XHJcblxyXG5cdFx0X2dsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgZ2xWZXJ0ZXhTaGFkZXIgKTtcclxuXHRcdF9nbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIGdsRnJhZ21lbnRTaGFkZXIgKTtcclxuXHJcblx0XHRfZ2wubGlua1Byb2dyYW0oIHByb2dyYW0gKTtcclxuXHJcblx0XHRpZiAoICFfZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbSwgX2dsLkxJTktfU1RBVFVTICkgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCBcIkNvdWxkIG5vdCBpbml0aWFsaXNlIHNoYWRlclxcblwiICsgXCJWQUxJREFURV9TVEFUVVM6IFwiICsgX2dsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW0sIF9nbC5WQUxJREFURV9TVEFUVVMgKSArIFwiLCBnbCBlcnJvciBbXCIgKyBfZ2wuZ2V0RXJyb3IoKSArIFwiXVwiICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGNsZWFuIHVwXHJcblxyXG5cdFx0X2dsLmRlbGV0ZVNoYWRlciggZ2xGcmFnbWVudFNoYWRlciApO1xyXG5cdFx0X2dsLmRlbGV0ZVNoYWRlciggZ2xWZXJ0ZXhTaGFkZXIgKTtcclxuXHJcblx0XHQvL2NvbnNvbGUubG9nKCBwcmVmaXhfZnJhZ21lbnQgKyBmcmFnbWVudFNoYWRlciApO1xyXG5cdFx0Ly9jb25zb2xlLmxvZyggcHJlZml4X3ZlcnRleCArIHZlcnRleFNoYWRlciApO1xyXG5cclxuXHRcdHByb2dyYW0udW5pZm9ybXMgPSB7fTtcclxuXHRcdHByb2dyYW0uYXR0cmlidXRlcyA9IHt9O1xyXG5cclxuXHRcdHZhciBpZGVudGlmaWVycywgdSwgYSwgaTtcclxuXHJcblx0XHQvLyBjYWNoZSB1bmlmb3JtIGxvY2F0aW9uc1xyXG5cclxuXHRcdGlkZW50aWZpZXJzID0gW1xyXG5cclxuXHRcdFx0J3ZpZXdNYXRyaXgnLCAnbW9kZWxWaWV3TWF0cml4JywgJ3Byb2plY3Rpb25NYXRyaXgnLCAnbm9ybWFsTWF0cml4JywgJ21vZGVsTWF0cml4JywgJ2NhbWVyYVBvc2l0aW9uJyxcclxuXHRcdFx0J21vcnBoVGFyZ2V0SW5mbHVlbmNlcydcclxuXHJcblx0XHRdO1xyXG5cclxuXHRcdGlmICggcGFyYW1ldGVycy51c2VWZXJ0ZXhUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0aWRlbnRpZmllcnMucHVzaCggJ2JvbmVUZXh0dXJlJyApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRpZGVudGlmaWVycy5wdXNoKCAnYm9uZUdsb2JhbE1hdHJpY2VzJyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCB1IGluIHVuaWZvcm1zICkge1xyXG5cclxuXHRcdFx0aWRlbnRpZmllcnMucHVzaCggdSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjYWNoZVVuaWZvcm1Mb2NhdGlvbnMoIHByb2dyYW0sIGlkZW50aWZpZXJzICk7XHJcblxyXG5cdFx0Ly8gY2FjaGUgYXR0cmlidXRlcyBsb2NhdGlvbnNcclxuXHJcblx0XHRpZGVudGlmaWVycyA9IFtcclxuXHJcblx0XHRcdFwicG9zaXRpb25cIiwgXCJub3JtYWxcIiwgXCJ1dlwiLCBcInV2MlwiLCBcInRhbmdlbnRcIiwgXCJjb2xvclwiLFxyXG5cdFx0XHRcInNraW5JbmRleFwiLCBcInNraW5XZWlnaHRcIiwgXCJsaW5lRGlzdGFuY2VcIlxyXG5cclxuXHRcdF07XHJcblxyXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBwYXJhbWV0ZXJzLm1heE1vcnBoVGFyZ2V0czsgaSArKyApIHtcclxuXHJcblx0XHRcdGlkZW50aWZpZXJzLnB1c2goIFwibW9ycGhUYXJnZXRcIiArIGkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBwYXJhbWV0ZXJzLm1heE1vcnBoTm9ybWFsczsgaSArKyApIHtcclxuXHJcblx0XHRcdGlkZW50aWZpZXJzLnB1c2goIFwibW9ycGhOb3JtYWxcIiArIGkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggYSBpbiBhdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdFx0aWRlbnRpZmllcnMucHVzaCggYSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjYWNoZUF0dHJpYnV0ZUxvY2F0aW9ucyggcHJvZ3JhbSwgaWRlbnRpZmllcnMgKTtcclxuXHJcblx0XHRwcm9ncmFtLmlkID0gX3Byb2dyYW1zX2NvdW50ZXIgKys7XHJcblxyXG5cdFx0X3Byb2dyYW1zLnB1c2goIHsgcHJvZ3JhbTogcHJvZ3JhbSwgY29kZTogY29kZSwgdXNlZFRpbWVzOiAxIH0gKTtcclxuXHJcblx0XHRfdGhpcy5pbmZvLm1lbW9yeS5wcm9ncmFtcyA9IF9wcm9ncmFtcy5sZW5ndGg7XHJcblxyXG5cdFx0cmV0dXJuIHByb2dyYW07XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIFNoYWRlciBwYXJhbWV0ZXJzIGNhY2hlXHJcblxyXG5cdGZ1bmN0aW9uIGNhY2hlVW5pZm9ybUxvY2F0aW9ucyAoIHByb2dyYW0sIGlkZW50aWZpZXJzICkge1xyXG5cclxuXHRcdHZhciBpLCBsLCBpZDtcclxuXHJcblx0XHRmb3IoIGkgPSAwLCBsID0gaWRlbnRpZmllcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGlkID0gaWRlbnRpZmllcnNbIGkgXTtcclxuXHRcdFx0cHJvZ3JhbS51bmlmb3Jtc1sgaWQgXSA9IF9nbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIGlkICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBjYWNoZUF0dHJpYnV0ZUxvY2F0aW9ucyAoIHByb2dyYW0sIGlkZW50aWZpZXJzICkge1xyXG5cclxuXHRcdHZhciBpLCBsLCBpZDtcclxuXHJcblx0XHRmb3IoIGkgPSAwLCBsID0gaWRlbnRpZmllcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGlkID0gaWRlbnRpZmllcnNbIGkgXTtcclxuXHRcdFx0cHJvZ3JhbS5hdHRyaWJ1dGVzWyBpZCBdID0gX2dsLmdldEF0dHJpYkxvY2F0aW9uKCBwcm9ncmFtLCBpZCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gYWRkTGluZU51bWJlcnMgKCBzdHJpbmcgKSB7XHJcblxyXG5cdFx0dmFyIGNodW5rcyA9IHN0cmluZy5zcGxpdCggXCJcXG5cIiApO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBjaHVua3MubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHQvLyBDaHJvbWUgcmVwb3J0cyBzaGFkZXIgZXJyb3JzIG9uIGxpbmVzXHJcblx0XHRcdC8vIHN0YXJ0aW5nIGNvdW50aW5nIGZyb20gMVxyXG5cclxuXHRcdFx0Y2h1bmtzWyBpIF0gPSAoIGkgKyAxICkgKyBcIjogXCIgKyBjaHVua3NbIGkgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNodW5rcy5qb2luKCBcIlxcblwiICk7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGdldFNoYWRlciAoIHR5cGUsIHN0cmluZyApIHtcclxuXHJcblx0XHR2YXIgc2hhZGVyO1xyXG5cclxuXHRcdGlmICggdHlwZSA9PT0gXCJmcmFnbWVudFwiICkge1xyXG5cclxuXHRcdFx0c2hhZGVyID0gX2dsLmNyZWF0ZVNoYWRlciggX2dsLkZSQUdNRU5UX1NIQURFUiApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwidmVydGV4XCIgKSB7XHJcblxyXG5cdFx0XHRzaGFkZXIgPSBfZ2wuY3JlYXRlU2hhZGVyKCBfZ2wuVkVSVEVYX1NIQURFUiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRfZ2wuc2hhZGVyU291cmNlKCBzaGFkZXIsIHN0cmluZyApO1xyXG5cdFx0X2dsLmNvbXBpbGVTaGFkZXIoIHNoYWRlciApO1xyXG5cclxuXHRcdGlmICggIV9nbC5nZXRTaGFkZXJQYXJhbWV0ZXIoIHNoYWRlciwgX2dsLkNPTVBJTEVfU1RBVFVTICkgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCBfZ2wuZ2V0U2hhZGVySW5mb0xvZyggc2hhZGVyICkgKTtcclxuXHRcdFx0Y29uc29sZS5lcnJvciggYWRkTGluZU51bWJlcnMoIHN0cmluZyApICk7XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gc2hhZGVyO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBUZXh0dXJlc1xyXG5cclxuXHJcblx0ZnVuY3Rpb24gaXNQb3dlck9mVHdvICggdmFsdWUgKSB7XHJcblxyXG5cdFx0cmV0dXJuICggdmFsdWUgJiAoIHZhbHVlIC0gMSApICkgPT09IDA7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIHNldFRleHR1cmVQYXJhbWV0ZXJzICggdGV4dHVyZVR5cGUsIHRleHR1cmUsIGlzSW1hZ2VQb3dlck9mVHdvICkge1xyXG5cclxuXHRcdGlmICggaXNJbWFnZVBvd2VyT2ZUd28gKSB7XHJcblxyXG5cdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfUywgcGFyYW1UaHJlZVRvR0woIHRleHR1cmUud3JhcFMgKSApO1xyXG5cdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfVCwgcGFyYW1UaHJlZVRvR0woIHRleHR1cmUud3JhcFQgKSApO1xyXG5cclxuXHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS5tYWdGaWx0ZXIgKSApO1xyXG5cdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01JTl9GSUxURVIsIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLm1pbkZpbHRlciApICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfV1JBUF9TLCBfZ2wuQ0xBTVBfVE9fRURHRSApO1xyXG5cdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfVCwgX2dsLkNMQU1QX1RPX0VER0UgKTtcclxuXHJcblx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZmlsdGVyRmFsbGJhY2soIHRleHR1cmUubWFnRmlsdGVyICkgKTtcclxuXHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBmaWx0ZXJGYWxsYmFjayggdGV4dHVyZS5taW5GaWx0ZXIgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIF9nbEV4dGVuc2lvblRleHR1cmVGaWx0ZXJBbmlzb3Ryb3BpYyAmJiB0ZXh0dXJlLnR5cGUgIT09IFRIUkVFLkZsb2F0VHlwZSApIHtcclxuXHJcblx0XHRcdGlmICggdGV4dHVyZS5hbmlzb3Ryb3B5ID4gMSB8fCB0ZXh0dXJlLl9fb2xkQW5pc290cm9weSApIHtcclxuXHJcblx0XHRcdFx0X2dsLnRleFBhcmFtZXRlcmYoIHRleHR1cmVUeXBlLCBfZ2xFeHRlbnNpb25UZXh0dXJlRmlsdGVyQW5pc290cm9waWMuVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQsIE1hdGgubWluKCB0ZXh0dXJlLmFuaXNvdHJvcHksIF9tYXhBbmlzb3Ryb3B5ICkgKTtcclxuXHRcdFx0XHR0ZXh0dXJlLl9fb2xkQW5pc290cm9weSA9IHRleHR1cmUuYW5pc290cm9weTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuc2V0VGV4dHVyZSA9IGZ1bmN0aW9uICggdGV4dHVyZSwgc2xvdCApIHtcclxuXHJcblx0XHRpZiAoIHRleHR1cmUubmVlZHNVcGRhdGUgKSB7XHJcblxyXG5cdFx0XHRpZiAoICEgdGV4dHVyZS5fX3dlYmdsSW5pdCApIHtcclxuXHJcblx0XHRcdFx0dGV4dHVyZS5fX3dlYmdsSW5pdCA9IHRydWU7XHJcblxyXG5cdFx0XHRcdHRleHR1cmUuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlICk7XHJcblxyXG5cdFx0XHRcdHRleHR1cmUuX193ZWJnbFRleHR1cmUgPSBfZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG5cclxuXHRcdFx0XHRfdGhpcy5pbmZvLm1lbW9yeS50ZXh0dXJlcyArKztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdF9nbC5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XHJcblx0XHRcdF9nbC5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIHRleHR1cmUuX193ZWJnbFRleHR1cmUgKTtcclxuXHJcblx0XHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRleHR1cmUuZmxpcFkgKTtcclxuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0ZXh0dXJlLnByZW11bHRpcGx5QWxwaGEgKTtcclxuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX0FMSUdOTUVOVCwgdGV4dHVyZS51bnBhY2tBbGlnbm1lbnQgKTtcclxuXHJcblx0XHRcdHZhciBpbWFnZSA9IHRleHR1cmUuaW1hZ2UsXHJcblx0XHRcdGlzSW1hZ2VQb3dlck9mVHdvID0gaXNQb3dlck9mVHdvKCBpbWFnZS53aWR0aCApICYmIGlzUG93ZXJPZlR3byggaW1hZ2UuaGVpZ2h0ICksXHJcblx0XHRcdGdsRm9ybWF0ID0gcGFyYW1UaHJlZVRvR0woIHRleHR1cmUuZm9ybWF0ICksXHJcblx0XHRcdGdsVHlwZSA9IHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLnR5cGUgKTtcclxuXHJcblx0XHRcdHNldFRleHR1cmVQYXJhbWV0ZXJzKCBfZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgaXNJbWFnZVBvd2VyT2ZUd28gKTtcclxuXHJcblx0XHRcdHZhciBtaXBtYXAsIG1pcG1hcHMgPSB0ZXh0dXJlLm1pcG1hcHM7XHJcblxyXG5cdFx0XHRpZiAoIHRleHR1cmUgaW5zdGFuY2VvZiBUSFJFRS5EYXRhVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdFx0Ly8gdXNlIG1hbnVhbGx5IGNyZWF0ZWQgbWlwbWFwcyBpZiBhdmFpbGFibGVcclxuXHRcdFx0XHQvLyBpZiB0aGVyZSBhcmUgbm8gbWFudWFsIG1pcG1hcHNcclxuXHRcdFx0XHQvLyBzZXQgMCBsZXZlbCBtaXBtYXAgYW5kIHRoZW4gdXNlIEdMIHRvIGdlbmVyYXRlIG90aGVyIG1pcG1hcCBsZXZlbHNcclxuXHJcblx0XHRcdFx0aWYgKCBtaXBtYXBzLmxlbmd0aCA+IDAgJiYgaXNJbWFnZVBvd2VyT2ZUd28gKSB7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG1pcG1hcHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRtaXBtYXAgPSBtaXBtYXBzWyBpIF07XHJcblx0XHRcdFx0XHRcdF9nbC50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgZ2xGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0dGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRfZ2wudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIDAsIGdsRm9ybWF0LCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBpbWFnZS5kYXRhICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHRleHR1cmUgaW5zdGFuY2VvZiBUSFJFRS5Db21wcmVzc2VkVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdFx0Ly8gY29tcHJlc3NlZCB0ZXh0dXJlcyBjYW4gb25seSB1c2UgbWFudWFsbHkgY3JlYXRlZCBtaXBtYXBzXHJcblx0XHRcdFx0Ly8gV2ViR0wgY2FuJ3QgZ2VuZXJhdGUgbWlwbWFwcyBmb3IgRERTIHRleHR1cmVzXHJcblxyXG5cdFx0XHRcdGZvciggdmFyIGkgPSAwLCBpbCA9IG1pcG1hcHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0bWlwbWFwID0gbWlwbWFwc1sgaSBdO1xyXG5cdFx0XHRcdFx0X2dsLmNvbXByZXNzZWRUZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgZ2xGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgbWlwbWFwLmRhdGEgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHsgLy8gcmVndWxhciBUZXh0dXJlIChpbWFnZSwgdmlkZW8sIGNhbnZhcylcclxuXHJcblx0XHRcdFx0Ly8gdXNlIG1hbnVhbGx5IGNyZWF0ZWQgbWlwbWFwcyBpZiBhdmFpbGFibGVcclxuXHRcdFx0XHQvLyBpZiB0aGVyZSBhcmUgbm8gbWFudWFsIG1pcG1hcHNcclxuXHRcdFx0XHQvLyBzZXQgMCBsZXZlbCBtaXBtYXAgYW5kIHRoZW4gdXNlIEdMIHRvIGdlbmVyYXRlIG90aGVyIG1pcG1hcCBsZXZlbHNcclxuXHJcblx0XHRcdFx0aWYgKCBtaXBtYXBzLmxlbmd0aCA+IDAgJiYgaXNJbWFnZVBvd2VyT2ZUd28gKSB7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG1pcG1hcHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRtaXBtYXAgPSBtaXBtYXBzWyBpIF07XHJcblx0XHRcdFx0XHRcdF9nbC50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgZ2xGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdF9nbC50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgMCwgZ2xGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIHRleHR1cmUuaW1hZ2UgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyAmJiBpc0ltYWdlUG93ZXJPZlR3byApIF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfMkQgKTtcclxuXHJcblx0XHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHRcdGlmICggdGV4dHVyZS5vblVwZGF0ZSApIHRleHR1cmUub25VcGRhdGUoKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0X2dsLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcclxuXHRcdFx0X2dsLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZS5fX3dlYmdsVGV4dHVyZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gY2xhbXBUb01heFNpemUgKCBpbWFnZSwgbWF4U2l6ZSApIHtcclxuXHJcblx0XHRpZiAoIGltYWdlLndpZHRoIDw9IG1heFNpemUgJiYgaW1hZ2UuaGVpZ2h0IDw9IG1heFNpemUgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gaW1hZ2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFdhcm5pbmc6IFNjYWxpbmcgdGhyb3VnaCB0aGUgY2FudmFzIHdpbGwgb25seSB3b3JrIHdpdGggaW1hZ2VzIHRoYXQgdXNlXHJcblx0XHQvLyBwcmVtdWx0aXBsaWVkIGFscGhhLlxyXG5cclxuXHRcdHZhciBtYXhEaW1lbnNpb24gPSBNYXRoLm1heCggaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCApO1xyXG5cdFx0dmFyIG5ld1dpZHRoID0gTWF0aC5mbG9vciggaW1hZ2Uud2lkdGggKiBtYXhTaXplIC8gbWF4RGltZW5zaW9uICk7XHJcblx0XHR2YXIgbmV3SGVpZ2h0ID0gTWF0aC5mbG9vciggaW1hZ2UuaGVpZ2h0ICogbWF4U2l6ZSAvIG1heERpbWVuc2lvbiApO1xyXG5cclxuXHRcdHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApO1xyXG5cdFx0Y2FudmFzLndpZHRoID0gbmV3V2lkdGg7XHJcblx0XHRjYW52YXMuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xyXG5cclxuXHRcdHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCggXCIyZFwiICk7XHJcblx0XHRjdHguZHJhd0ltYWdlKCBpbWFnZSwgMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgMCwgMCwgbmV3V2lkdGgsIG5ld0hlaWdodCApO1xyXG5cclxuXHRcdHJldHVybiBjYW52YXM7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gc2V0Q3ViZVRleHR1cmUgKCB0ZXh0dXJlLCBzbG90ICkge1xyXG5cclxuXHRcdGlmICggdGV4dHVyZS5pbWFnZS5sZW5ndGggPT09IDYgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRleHR1cmUubmVlZHNVcGRhdGUgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggISB0ZXh0dXJlLmltYWdlLl9fd2ViZ2xUZXh0dXJlQ3ViZSApIHtcclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlLmltYWdlLl9fd2ViZ2xUZXh0dXJlQ3ViZSA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XHJcblxyXG5cdFx0XHRcdFx0X3RoaXMuaW5mby5tZW1vcnkudGV4dHVyZXMgKys7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0X2dsLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcclxuXHRcdFx0XHRfZ2wuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlLmltYWdlLl9fd2ViZ2xUZXh0dXJlQ3ViZSApO1xyXG5cclxuXHRcdFx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0ZXh0dXJlLmZsaXBZICk7XHJcblxyXG5cdFx0XHRcdHZhciBpc0NvbXByZXNzZWQgPSB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuQ29tcHJlc3NlZFRleHR1cmU7XHJcblxyXG5cdFx0XHRcdHZhciBjdWJlSW1hZ2UgPSBbXTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIF90aGlzLmF1dG9TY2FsZUN1YmVtYXBzICYmICEgaXNDb21wcmVzc2VkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y3ViZUltYWdlWyBpIF0gPSBjbGFtcFRvTWF4U2l6ZSggdGV4dHVyZS5pbWFnZVsgaSBdLCBfbWF4Q3ViZW1hcFNpemUgKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0Y3ViZUltYWdlWyBpIF0gPSB0ZXh0dXJlLmltYWdlWyBpIF07XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHZhciBpbWFnZSA9IGN1YmVJbWFnZVsgMCBdLFxyXG5cdFx0XHRcdGlzSW1hZ2VQb3dlck9mVHdvID0gaXNQb3dlck9mVHdvKCBpbWFnZS53aWR0aCApICYmIGlzUG93ZXJPZlR3byggaW1hZ2UuaGVpZ2h0ICksXHJcblx0XHRcdFx0Z2xGb3JtYXQgPSBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS5mb3JtYXQgKSxcclxuXHRcdFx0XHRnbFR5cGUgPSBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS50eXBlICk7XHJcblxyXG5cdFx0XHRcdHNldFRleHR1cmVQYXJhbWV0ZXJzKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZSwgaXNJbWFnZVBvd2VyT2ZUd28gKTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGlzQ29tcHJlc3NlZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHZhciBtaXBtYXAsIG1pcG1hcHMgPSBjdWJlSW1hZ2VbIGkgXS5taXBtYXBzO1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yKCB2YXIgaiA9IDAsIGpsID0gbWlwbWFwcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0bWlwbWFwID0gbWlwbWFwc1sgaiBdO1xyXG5cdFx0XHRcdFx0XHRcdF9nbC5jb21wcmVzc2VkVGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIGosIGdsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIG1pcG1hcC5kYXRhICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdF9nbC50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgMCwgZ2xGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIGN1YmVJbWFnZVsgaSBdICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgJiYgaXNJbWFnZVBvd2VyT2ZUd28gKSB7XHJcblxyXG5cdFx0XHRcdFx0X2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHRcdFx0aWYgKCB0ZXh0dXJlLm9uVXBkYXRlICkgdGV4dHVyZS5vblVwZGF0ZSgpO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0X2dsLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcclxuXHRcdFx0XHRfZ2wuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlLmltYWdlLl9fd2ViZ2xUZXh0dXJlQ3ViZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gc2V0Q3ViZVRleHR1cmVEeW5hbWljICggdGV4dHVyZSwgc2xvdCApIHtcclxuXHJcblx0XHRfZ2wuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xyXG5cdFx0X2dsLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZS5fX3dlYmdsVGV4dHVyZSApO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBSZW5kZXIgdGFyZ2V0c1xyXG5cclxuXHRmdW5jdGlvbiBzZXR1cEZyYW1lQnVmZmVyICggZnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCwgdGV4dHVyZVRhcmdldCApIHtcclxuXHJcblx0XHRfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyICk7XHJcblx0XHRfZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwLCB0ZXh0dXJlVGFyZ2V0LCByZW5kZXJUYXJnZXQuX193ZWJnbFRleHR1cmUsIDAgKTtcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gc2V0dXBSZW5kZXJCdWZmZXIgKCByZW5kZXJidWZmZXIsIHJlbmRlclRhcmdldCAgKSB7XHJcblxyXG5cdFx0X2dsLmJpbmRSZW5kZXJidWZmZXIoIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xyXG5cclxuXHRcdGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICYmICEgcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgKSB7XHJcblxyXG5cdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggX2dsLlJFTkRFUkJVRkZFUiwgX2dsLkRFUFRIX0NPTVBPTkVOVDE2LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcclxuXHRcdFx0X2dsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5ERVBUSF9BVFRBQ0hNRU5ULCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIgKTtcclxuXHJcblx0XHQvKiBGb3Igc29tZSByZWFzb24gdGhpcyBpcyBub3Qgd29ya2luZy4gRGVmYXVsdGluZyB0byBSR0JBNC5cclxuXHRcdH0gZWxzZSBpZiggISByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgJiYgcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgKSB7XHJcblxyXG5cdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggX2dsLlJFTkRFUkJVRkZFUiwgX2dsLlNURU5DSUxfSU5ERVg4LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcclxuXHRcdFx0X2dsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5TVEVOQ0lMX0FUVEFDSE1FTlQsIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xyXG5cdFx0Ki9cclxuXHRcdH0gZWxzZSBpZiAoIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciAmJiByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciApIHtcclxuXHJcblx0XHRcdF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlKCBfZ2wuUkVOREVSQlVGRkVSLCBfZ2wuREVQVEhfU1RFTkNJTCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XHJcblx0XHRcdF9nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0X2dsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoIF9nbC5SRU5ERVJCVUZGRVIsIF9nbC5SR0JBNCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnNldFJlbmRlclRhcmdldCA9IGZ1bmN0aW9uICggcmVuZGVyVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciBpc0N1YmUgPSAoIHJlbmRlclRhcmdldCBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSApO1xyXG5cclxuXHRcdGlmICggcmVuZGVyVGFyZ2V0ICYmICEgcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xGcmFtZWJ1ZmZlciApIHtcclxuXHJcblx0XHRcdGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyID09PSB1bmRlZmluZWQgKSByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgPSB0cnVlO1xyXG5cdFx0XHRpZiAoIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyID09PSB1bmRlZmluZWQgKSByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciA9IHRydWU7XHJcblxyXG5cdFx0XHRyZW5kZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblJlbmRlclRhcmdldERpc3Bvc2UgKTtcclxuXHJcblx0XHRcdHJlbmRlclRhcmdldC5fX3dlYmdsVGV4dHVyZSA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XHJcblxyXG5cdFx0XHRfdGhpcy5pbmZvLm1lbW9yeS50ZXh0dXJlcyArKztcclxuXHJcblx0XHRcdC8vIFNldHVwIHRleHR1cmUsIGNyZWF0ZSByZW5kZXIgYW5kIGZyYW1lIGJ1ZmZlcnNcclxuXHJcblx0XHRcdHZhciBpc1RhcmdldFBvd2VyT2ZUd28gPSBpc1Bvd2VyT2ZUd28oIHJlbmRlclRhcmdldC53aWR0aCApICYmIGlzUG93ZXJPZlR3byggcmVuZGVyVGFyZ2V0LmhlaWdodCApLFxyXG5cdFx0XHRcdGdsRm9ybWF0ID0gcGFyYW1UaHJlZVRvR0woIHJlbmRlclRhcmdldC5mb3JtYXQgKSxcclxuXHRcdFx0XHRnbFR5cGUgPSBwYXJhbVRocmVlVG9HTCggcmVuZGVyVGFyZ2V0LnR5cGUgKTtcclxuXHJcblx0XHRcdGlmICggaXNDdWJlICkge1xyXG5cclxuXHRcdFx0XHRyZW5kZXJUYXJnZXQuX193ZWJnbEZyYW1lYnVmZmVyID0gW107XHJcblx0XHRcdFx0cmVuZGVyVGFyZ2V0Ll9fd2ViZ2xSZW5kZXJidWZmZXIgPSBbXTtcclxuXHJcblx0XHRcdFx0X2dsLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xUZXh0dXJlICk7XHJcblx0XHRcdFx0c2V0VGV4dHVyZVBhcmFtZXRlcnMoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCByZW5kZXJUYXJnZXQsIGlzVGFyZ2V0UG93ZXJPZlR3byApO1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHJlbmRlclRhcmdldC5fX3dlYmdsRnJhbWVidWZmZXJbIGkgXSA9IF9nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xyXG5cdFx0XHRcdFx0cmVuZGVyVGFyZ2V0Ll9fd2ViZ2xSZW5kZXJidWZmZXJbIGkgXSA9IF9nbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcclxuXHJcblx0XHRcdFx0XHRfZ2wudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIDAsIGdsRm9ybWF0LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG51bGwgKTtcclxuXHJcblx0XHRcdFx0XHRzZXR1cEZyYW1lQnVmZmVyKCByZW5kZXJUYXJnZXQuX193ZWJnbEZyYW1lYnVmZmVyWyBpIF0sIHJlbmRlclRhcmdldCwgX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGkgKTtcclxuXHRcdFx0XHRcdHNldHVwUmVuZGVyQnVmZmVyKCByZW5kZXJUYXJnZXQuX193ZWJnbFJlbmRlcmJ1ZmZlclsgaSBdLCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIGlzVGFyZ2V0UG93ZXJPZlR3byApIF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfQ1VCRV9NQVAgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHJlbmRlclRhcmdldC5fX3dlYmdsRnJhbWVidWZmZXIgPSBfZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcclxuXHJcblx0XHRcdFx0aWYgKCByZW5kZXJUYXJnZXQuc2hhcmVEZXB0aEZyb20gKSB7XHJcblxyXG5cdFx0XHRcdFx0cmVuZGVyVGFyZ2V0Ll9fd2ViZ2xSZW5kZXJidWZmZXIgPSByZW5kZXJUYXJnZXQuc2hhcmVEZXB0aEZyb20uX193ZWJnbFJlbmRlcmJ1ZmZlcjtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRyZW5kZXJUYXJnZXQuX193ZWJnbFJlbmRlcmJ1ZmZlciA9IF9nbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRfZ2wuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCByZW5kZXJUYXJnZXQuX193ZWJnbFRleHR1cmUgKTtcclxuXHRcdFx0XHRzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfMkQsIHJlbmRlclRhcmdldCwgaXNUYXJnZXRQb3dlck9mVHdvICk7XHJcblxyXG5cdFx0XHRcdF9nbC50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgMCwgZ2xGb3JtYXQsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbnVsbCApO1xyXG5cclxuXHRcdFx0XHRzZXR1cEZyYW1lQnVmZmVyKCByZW5kZXJUYXJnZXQuX193ZWJnbEZyYW1lYnVmZmVyLCByZW5kZXJUYXJnZXQsIF9nbC5URVhUVVJFXzJEICk7XHJcblxyXG5cdFx0XHRcdGlmICggcmVuZGVyVGFyZ2V0LnNoYXJlRGVwdGhGcm9tICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICYmICEgcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX0FUVEFDSE1FTlQsIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlclRhcmdldC5fX3dlYmdsUmVuZGVyYnVmZmVyICk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICYmIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyICkge1xyXG5cclxuXHRcdFx0XHRcdFx0X2dsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlclRhcmdldC5fX3dlYmdsUmVuZGVyYnVmZmVyICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHNldHVwUmVuZGVyQnVmZmVyKCByZW5kZXJUYXJnZXQuX193ZWJnbFJlbmRlcmJ1ZmZlciwgcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBpc1RhcmdldFBvd2VyT2ZUd28gKSBfZ2wuZ2VuZXJhdGVNaXBtYXAoIF9nbC5URVhUVVJFXzJEICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBSZWxlYXNlIGV2ZXJ5dGhpbmdcclxuXHJcblx0XHRcdGlmICggaXNDdWJlICkge1xyXG5cclxuXHRcdFx0XHRfZ2wuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCBudWxsICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRfZ2wuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCBudWxsICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRfZ2wuYmluZFJlbmRlcmJ1ZmZlciggX2dsLlJFTkRFUkJVRkZFUiwgbnVsbCApO1xyXG5cdFx0XHRfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIG51bGwgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGZyYW1lYnVmZmVyLCB3aWR0aCwgaGVpZ2h0LCB2eCwgdnk7XHJcblxyXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGlzQ3ViZSApIHtcclxuXHJcblx0XHRcdFx0ZnJhbWVidWZmZXIgPSByZW5kZXJUYXJnZXQuX193ZWJnbEZyYW1lYnVmZmVyWyByZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgXTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGZyYW1lYnVmZmVyID0gcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xGcmFtZWJ1ZmZlcjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHdpZHRoID0gcmVuZGVyVGFyZ2V0LndpZHRoO1xyXG5cdFx0XHRoZWlnaHQgPSByZW5kZXJUYXJnZXQuaGVpZ2h0O1xyXG5cclxuXHRcdFx0dnggPSAwO1xyXG5cdFx0XHR2eSA9IDA7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGZyYW1lYnVmZmVyID0gbnVsbDtcclxuXHJcblx0XHRcdHdpZHRoID0gX3ZpZXdwb3J0V2lkdGg7XHJcblx0XHRcdGhlaWdodCA9IF92aWV3cG9ydEhlaWdodDtcclxuXHJcblx0XHRcdHZ4ID0gX3ZpZXdwb3J0WDtcclxuXHRcdFx0dnkgPSBfdmlld3BvcnRZO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGZyYW1lYnVmZmVyICE9PSBfY3VycmVudEZyYW1lYnVmZmVyICkge1xyXG5cclxuXHRcdFx0X2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlciApO1xyXG5cdFx0XHRfZ2wudmlld3BvcnQoIHZ4LCB2eSwgd2lkdGgsIGhlaWdodCApO1xyXG5cclxuXHRcdFx0X2N1cnJlbnRGcmFtZWJ1ZmZlciA9IGZyYW1lYnVmZmVyO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRfY3VycmVudFdpZHRoID0gd2lkdGg7XHJcblx0XHRfY3VycmVudEhlaWdodCA9IGhlaWdodDtcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gdXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwICggcmVuZGVyVGFyZ2V0ICkge1xyXG5cclxuXHRcdGlmICggcmVuZGVyVGFyZ2V0IGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlICkge1xyXG5cclxuXHRcdFx0X2dsLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xUZXh0dXJlICk7XHJcblx0XHRcdF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfQ1VCRV9NQVAgKTtcclxuXHRcdFx0X2dsLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgbnVsbCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRfZ2wuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCByZW5kZXJUYXJnZXQuX193ZWJnbFRleHR1cmUgKTtcclxuXHRcdFx0X2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV8yRCApO1xyXG5cdFx0XHRfZ2wuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCBudWxsICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBGYWxsYmFjayBmaWx0ZXJzIGZvciBub24tcG93ZXItb2YtMiB0ZXh0dXJlc1xyXG5cclxuXHRmdW5jdGlvbiBmaWx0ZXJGYWxsYmFjayAoIGYgKSB7XHJcblxyXG5cdFx0aWYgKCBmID09PSBUSFJFRS5OZWFyZXN0RmlsdGVyIHx8IGYgPT09IFRIUkVFLk5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyIHx8IGYgPT09IFRIUkVFLk5lYXJlc3RNaXBNYXBMaW5lYXJGaWx0ZXIgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gX2dsLk5FQVJFU1Q7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBfZ2wuTElORUFSO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBNYXAgdGhyZWUuanMgY29uc3RhbnRzIHRvIFdlYkdMIGNvbnN0YW50c1xyXG5cclxuXHRmdW5jdGlvbiBwYXJhbVRocmVlVG9HTCAoIHAgKSB7XHJcblxyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5SZXBlYXRXcmFwcGluZyApIHJldHVybiBfZ2wuUkVQRUFUO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nICkgcmV0dXJuIF9nbC5DTEFNUF9UT19FREdFO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5NaXJyb3JlZFJlcGVhdFdyYXBwaW5nICkgcmV0dXJuIF9nbC5NSVJST1JFRF9SRVBFQVQ7XHJcblxyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5OZWFyZXN0RmlsdGVyICkgcmV0dXJuIF9nbC5ORUFSRVNUO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5OZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlciApIHJldHVybiBfZ2wuTkVBUkVTVF9NSVBNQVBfTkVBUkVTVDtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlciApIHJldHVybiBfZ2wuTkVBUkVTVF9NSVBNQVBfTElORUFSO1xyXG5cclxuXHRcdGlmICggcCA9PT0gVEhSRUUuTGluZWFyRmlsdGVyICkgcmV0dXJuIF9nbC5MSU5FQVI7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLkxpbmVhck1pcE1hcE5lYXJlc3RGaWx0ZXIgKSByZXR1cm4gX2dsLkxJTkVBUl9NSVBNQVBfTkVBUkVTVDtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyICkgcmV0dXJuIF9nbC5MSU5FQVJfTUlQTUFQX0xJTkVBUjtcclxuXHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLlVuc2lnbmVkQnl0ZVR5cGUgKSByZXR1cm4gX2dsLlVOU0lHTkVEX0JZVEU7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLlVuc2lnbmVkU2hvcnQ0NDQ0VHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfU0hPUlRfNF80XzRfNDtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuVW5zaWduZWRTaG9ydDU1NTFUeXBlICkgcmV0dXJuIF9nbC5VTlNJR05FRF9TSE9SVF81XzVfNV8xO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5VbnNpZ25lZFNob3J0NTY1VHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfU0hPUlRfNV82XzU7XHJcblxyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5CeXRlVHlwZSApIHJldHVybiBfZ2wuQllURTtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuU2hvcnRUeXBlICkgcmV0dXJuIF9nbC5TSE9SVDtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuVW5zaWduZWRTaG9ydFR5cGUgKSByZXR1cm4gX2dsLlVOU0lHTkVEX1NIT1JUO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5JbnRUeXBlICkgcmV0dXJuIF9nbC5JTlQ7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLlVuc2lnbmVkSW50VHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfSU5UO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5GbG9hdFR5cGUgKSByZXR1cm4gX2dsLkZMT0FUO1xyXG5cclxuXHRcdGlmICggcCA9PT0gVEhSRUUuQWxwaGFGb3JtYXQgKSByZXR1cm4gX2dsLkFMUEhBO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5SR0JGb3JtYXQgKSByZXR1cm4gX2dsLlJHQjtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuUkdCQUZvcm1hdCApIHJldHVybiBfZ2wuUkdCQTtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuTHVtaW5hbmNlRm9ybWF0ICkgcmV0dXJuIF9nbC5MVU1JTkFOQ0U7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLkx1bWluYW5jZUFscGhhRm9ybWF0ICkgcmV0dXJuIF9nbC5MVU1JTkFOQ0VfQUxQSEE7XHJcblxyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5BZGRFcXVhdGlvbiApIHJldHVybiBfZ2wuRlVOQ19BREQ7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLlN1YnRyYWN0RXF1YXRpb24gKSByZXR1cm4gX2dsLkZVTkNfU1VCVFJBQ1Q7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLlJldmVyc2VTdWJ0cmFjdEVxdWF0aW9uICkgcmV0dXJuIF9nbC5GVU5DX1JFVkVSU0VfU1VCVFJBQ1Q7XHJcblxyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5aZXJvRmFjdG9yICkgcmV0dXJuIF9nbC5aRVJPO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5PbmVGYWN0b3IgKSByZXR1cm4gX2dsLk9ORTtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuU3JjQ29sb3JGYWN0b3IgKSByZXR1cm4gX2dsLlNSQ19DT0xPUjtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuT25lTWludXNTcmNDb2xvckZhY3RvciApIHJldHVybiBfZ2wuT05FX01JTlVTX1NSQ19DT0xPUjtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuU3JjQWxwaGFGYWN0b3IgKSByZXR1cm4gX2dsLlNSQ19BTFBIQTtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuT25lTWludXNTcmNBbHBoYUZhY3RvciApIHJldHVybiBfZ2wuT05FX01JTlVTX1NSQ19BTFBIQTtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuRHN0QWxwaGFGYWN0b3IgKSByZXR1cm4gX2dsLkRTVF9BTFBIQTtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuT25lTWludXNEc3RBbHBoYUZhY3RvciApIHJldHVybiBfZ2wuT05FX01JTlVTX0RTVF9BTFBIQTtcclxuXHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLkRzdENvbG9yRmFjdG9yICkgcmV0dXJuIF9nbC5EU1RfQ09MT1I7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLk9uZU1pbnVzRHN0Q29sb3JGYWN0b3IgKSByZXR1cm4gX2dsLk9ORV9NSU5VU19EU1RfQ09MT1I7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLlNyY0FscGhhU2F0dXJhdGVGYWN0b3IgKSByZXR1cm4gX2dsLlNSQ19BTFBIQV9TQVRVUkFURTtcclxuXHJcblx0XHRpZiAoIF9nbEV4dGVuc2lvbkNvbXByZXNzZWRUZXh0dXJlUzNUQyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0aWYgKCBwID09PSBUSFJFRS5SR0JfUzNUQ19EWFQxX0Zvcm1hdCApIHJldHVybiBfZ2xFeHRlbnNpb25Db21wcmVzc2VkVGV4dHVyZVMzVEMuQ09NUFJFU1NFRF9SR0JfUzNUQ19EWFQxX0VYVDtcclxuXHRcdFx0aWYgKCBwID09PSBUSFJFRS5SR0JBX1MzVENfRFhUMV9Gb3JtYXQgKSByZXR1cm4gX2dsRXh0ZW5zaW9uQ29tcHJlc3NlZFRleHR1cmVTM1RDLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDFfRVhUO1xyXG5cdFx0XHRpZiAoIHAgPT09IFRIUkVFLlJHQkFfUzNUQ19EWFQzX0Zvcm1hdCApIHJldHVybiBfZ2xFeHRlbnNpb25Db21wcmVzc2VkVGV4dHVyZVMzVEMuQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUM19FWFQ7XHJcblx0XHRcdGlmICggcCA9PT0gVEhSRUUuUkdCQV9TM1RDX0RYVDVfRm9ybWF0ICkgcmV0dXJuIF9nbEV4dGVuc2lvbkNvbXByZXNzZWRUZXh0dXJlUzNUQy5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQ1X0VYVDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIDA7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIEFsbG9jYXRpb25zXHJcblxyXG5cdGZ1bmN0aW9uIGFsbG9jYXRlQm9uZXMgKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0aWYgKCBfc3VwcG9ydHNCb25lVGV4dHVyZXMgJiYgb2JqZWN0ICYmIG9iamVjdC51c2VWZXJ0ZXhUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIDEwMjQ7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdC8vIGRlZmF1bHQgZm9yIHdoZW4gb2JqZWN0IGlzIG5vdCBzcGVjaWZpZWRcclxuXHRcdFx0Ly8gKCBmb3IgZXhhbXBsZSB3aGVuIHByZWJ1aWxkaW5nIHNoYWRlclxyXG5cdFx0XHQvLyAgIHRvIGJlIHVzZWQgd2l0aCBtdWx0aXBsZSBvYmplY3RzIClcclxuXHRcdFx0Ly9cclxuXHRcdFx0Ly8gXHQtIGxlYXZlIHNvbWUgZXh0cmEgc3BhY2UgZm9yIG90aGVyIHVuaWZvcm1zXHJcblx0XHRcdC8vICAtIGxpbWl0IGhlcmUgaXMgQU5HTEUncyAyNTQgbWF4IHVuaWZvcm0gdmVjdG9yc1xyXG5cdFx0XHQvLyAgICAodXAgdG8gNTQgc2hvdWxkIGJlIHNhZmUpXHJcblxyXG5cdFx0XHR2YXIgblZlcnRleFVuaWZvcm1zID0gX2dsLmdldFBhcmFtZXRlciggX2dsLk1BWF9WRVJURVhfVU5JRk9STV9WRUNUT1JTICk7XHJcblx0XHRcdHZhciBuVmVydGV4TWF0cmljZXMgPSBNYXRoLmZsb29yKCAoIG5WZXJ0ZXhVbmlmb3JtcyAtIDIwICkgLyA0ICk7XHJcblxyXG5cdFx0XHR2YXIgbWF4Qm9uZXMgPSBuVmVydGV4TWF0cmljZXM7XHJcblxyXG5cdFx0XHRpZiAoIG9iamVjdCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlNraW5uZWRNZXNoICkge1xyXG5cclxuXHRcdFx0XHRtYXhCb25lcyA9IE1hdGgubWluKCBvYmplY3QuYm9uZXMubGVuZ3RoLCBtYXhCb25lcyApO1xyXG5cclxuXHRcdFx0XHRpZiAoIG1heEJvbmVzIDwgb2JqZWN0LmJvbmVzLmxlbmd0aCApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oIFwiV2ViR0xSZW5kZXJlcjogdG9vIG1hbnkgYm9uZXMgLSBcIiArIG9iamVjdC5ib25lcy5sZW5ndGggKyBcIiwgdGhpcyBHUFUgc3VwcG9ydHMganVzdCBcIiArIG1heEJvbmVzICsgXCIgKHRyeSBPcGVuR0wgaW5zdGVhZCBvZiBBTkdMRSlcIiApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gbWF4Qm9uZXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBhbGxvY2F0ZUxpZ2h0cyAoIGxpZ2h0cyApIHtcclxuXHJcblx0XHR2YXIgbCwgbGwsIGxpZ2h0LCBkaXJMaWdodHMsIHBvaW50TGlnaHRzLCBzcG90TGlnaHRzLCBoZW1pTGlnaHRzO1xyXG5cclxuXHRcdGRpckxpZ2h0cyA9IHBvaW50TGlnaHRzID0gc3BvdExpZ2h0cyA9IGhlbWlMaWdodHMgPSAwO1xyXG5cclxuXHRcdGZvciAoIGwgPSAwLCBsbCA9IGxpZ2h0cy5sZW5ndGg7IGwgPCBsbDsgbCArKyApIHtcclxuXHJcblx0XHRcdGxpZ2h0ID0gbGlnaHRzWyBsIF07XHJcblxyXG5cdFx0XHRpZiAoIGxpZ2h0Lm9ubHlTaGFkb3cgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0ICkgZGlyTGlnaHRzICsrO1xyXG5cdFx0XHRpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRMaWdodCApIHBvaW50TGlnaHRzICsrO1xyXG5cdFx0XHRpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuU3BvdExpZ2h0ICkgc3BvdExpZ2h0cyArKztcclxuXHRcdFx0aWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkhlbWlzcGhlcmVMaWdodCApIGhlbWlMaWdodHMgKys7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB7ICdkaXJlY3Rpb25hbCcgOiBkaXJMaWdodHMsICdwb2ludCcgOiBwb2ludExpZ2h0cywgJ3Nwb3QnOiBzcG90TGlnaHRzLCAnaGVtaSc6IGhlbWlMaWdodHMgfTtcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gYWxsb2NhdGVTaGFkb3dzICggbGlnaHRzICkge1xyXG5cclxuXHRcdHZhciBsLCBsbCwgbGlnaHQsIG1heFNoYWRvd3MgPSAwO1xyXG5cclxuXHRcdGZvciAoIGwgPSAwLCBsbCA9IGxpZ2h0cy5sZW5ndGg7IGwgPCBsbDsgbCsrICkge1xyXG5cclxuXHRcdFx0bGlnaHQgPSBsaWdodHNbIGwgXTtcclxuXHJcblx0XHRcdGlmICggISBsaWdodC5jYXN0U2hhZG93ICkgY29udGludWU7XHJcblxyXG5cdFx0XHRpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuU3BvdExpZ2h0ICkgbWF4U2hhZG93cyArKztcclxuXHRcdFx0aWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQgJiYgISBsaWdodC5zaGFkb3dDYXNjYWRlICkgbWF4U2hhZG93cyArKztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG1heFNoYWRvd3M7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIEluaXRpYWxpemF0aW9uXHJcblxyXG5cdGZ1bmN0aW9uIGluaXRHTCAoKSB7XHJcblxyXG5cdFx0dHJ5IHtcclxuXHJcblx0XHRcdGlmICggISAoIF9nbCA9IF9jYW52YXMuZ2V0Q29udGV4dCggJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIHsgYWxwaGE6IF9hbHBoYSwgcHJlbXVsdGlwbGllZEFscGhhOiBfcHJlbXVsdGlwbGllZEFscGhhLCBhbnRpYWxpYXM6IF9hbnRpYWxpYXMsIHN0ZW5jaWw6IF9zdGVuY2lsLCBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IF9wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgfSApICkgKSB7XHJcblxyXG5cdFx0XHRcdHRocm93ICdFcnJvciBjcmVhdGluZyBXZWJHTCBjb250ZXh0Lic7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBjYXRjaCAoIGVycm9yICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggZXJyb3IgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0X2dsRXh0ZW5zaW9uVGV4dHVyZUZsb2F0ID0gX2dsLmdldEV4dGVuc2lvbiggJ09FU190ZXh0dXJlX2Zsb2F0JyApO1xyXG5cdFx0X2dsRXh0ZW5zaW9uU3RhbmRhcmREZXJpdmF0aXZlcyA9IF9nbC5nZXRFeHRlbnNpb24oICdPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMnICk7XHJcblxyXG5cdFx0X2dsRXh0ZW5zaW9uVGV4dHVyZUZpbHRlckFuaXNvdHJvcGljID0gX2dsLmdldEV4dGVuc2lvbiggJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKSB8fFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ICAgX2dsLmdldEV4dGVuc2lvbiggJ01PWl9FWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICkgfHxcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCAgIF9nbC5nZXRFeHRlbnNpb24oICdXRUJLSVRfRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApO1xyXG5cclxuXHJcblx0XHRfZ2xFeHRlbnNpb25Db21wcmVzc2VkVGV4dHVyZVMzVEMgPSBfZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICkgfHxcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdF9nbC5nZXRFeHRlbnNpb24oICdNT1pfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICkgfHxcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdF9nbC5nZXRFeHRlbnNpb24oICdXRUJLSVRfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICk7XHJcblxyXG5cdFx0aWYgKCAhIF9nbEV4dGVuc2lvblRleHR1cmVGbG9hdCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUubG9nKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogRmxvYXQgdGV4dHVyZXMgbm90IHN1cHBvcnRlZC4nICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggISBfZ2xFeHRlbnNpb25TdGFuZGFyZERlcml2YXRpdmVzICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5sb2coICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBTdGFuZGFyZCBkZXJpdmF0aXZlcyBub3Qgc3VwcG9ydGVkLicgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCAhIF9nbEV4dGVuc2lvblRleHR1cmVGaWx0ZXJBbmlzb3Ryb3BpYyApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUubG9nKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogQW5pc290cm9waWMgdGV4dHVyZSBmaWx0ZXJpbmcgbm90IHN1cHBvcnRlZC4nICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggISBfZ2xFeHRlbnNpb25Db21wcmVzc2VkVGV4dHVyZVMzVEMgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmxvZyggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFMzVEMgY29tcHJlc3NlZCB0ZXh0dXJlcyBub3Qgc3VwcG9ydGVkLicgKTtcclxuXHJcblx0XHR9XHJcblx0XHRcclxuXHRcdGlmICggX2dsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCA9PT0gdW5kZWZpbmVkICkge1xyXG5cdFx0XHRcclxuXHRcdFx0X2dsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCA9IGZ1bmN0aW9uKCkgeyBcclxuXHRcdFx0XHRcclxuXHRcdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdFx0XCJyYW5nZU1pblwiICA6IDEsXHJcblx0XHRcdFx0XHRcInJhbmdlTWF4XCIgIDogMSxcclxuXHRcdFx0XHRcdFwicHJlY2lzaW9uXCIgOiAxXHJcblx0XHRcdFx0fTtcclxuXHRcdFx0XHRcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBzZXREZWZhdWx0R0xTdGF0ZSAoKSB7XHJcblxyXG5cdFx0X2dsLmNsZWFyQ29sb3IoIDAsIDAsIDAsIDEgKTtcclxuXHRcdF9nbC5jbGVhckRlcHRoKCAxICk7XHJcblx0XHRfZ2wuY2xlYXJTdGVuY2lsKCAwICk7XHJcblxyXG5cdFx0X2dsLmVuYWJsZSggX2dsLkRFUFRIX1RFU1QgKTtcclxuXHRcdF9nbC5kZXB0aEZ1bmMoIF9nbC5MRVFVQUwgKTtcclxuXHJcblx0XHRfZ2wuZnJvbnRGYWNlKCBfZ2wuQ0NXICk7XHJcblx0XHRfZ2wuY3VsbEZhY2UoIF9nbC5CQUNLICk7XHJcblx0XHRfZ2wuZW5hYmxlKCBfZ2wuQ1VMTF9GQUNFICk7XHJcblxyXG5cdFx0X2dsLmVuYWJsZSggX2dsLkJMRU5EICk7XHJcblx0XHRfZ2wuYmxlbmRFcXVhdGlvbiggX2dsLkZVTkNfQUREICk7XHJcblx0XHRfZ2wuYmxlbmRGdW5jKCBfZ2wuU1JDX0FMUEhBLCBfZ2wuT05FX01JTlVTX1NSQ19BTFBIQSApO1xyXG5cclxuXHRcdF9nbC5jbGVhckNvbG9yKCBfY2xlYXJDb2xvci5yLCBfY2xlYXJDb2xvci5nLCBfY2xlYXJDb2xvci5iLCBfY2xlYXJBbHBoYSApO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBkZWZhdWx0IHBsdWdpbnMgKG9yZGVyIGlzIGltcG9ydGFudClcclxuXHJcblx0dGhpcy5zaGFkb3dNYXBQbHVnaW4gPSBuZXcgVEhSRUUuU2hhZG93TWFwUGx1Z2luKCk7XHJcblx0dGhpcy5hZGRQcmVQbHVnaW4oIHRoaXMuc2hhZG93TWFwUGx1Z2luICk7XHJcblxyXG5cdHRoaXMuYWRkUG9zdFBsdWdpbiggbmV3IFRIUkVFLlNwcml0ZVBsdWdpbigpICk7XHJcblx0dGhpcy5hZGRQb3N0UGx1Z2luKCBuZXcgVEhSRUUuTGVuc0ZsYXJlUGx1Z2luKCkgKTtcclxuXHJcbn07XHJcbi8qKlxyXG4gKiBAYXV0aG9yIHN6aW1layAvIGh0dHBzOi8vZ2l0aHViLmNvbS9zemltZWsvXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMgKSB7XHJcblxyXG5cdFRIUkVFLkV2ZW50RGlzcGF0Y2hlci5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMud2lkdGggPSB3aWR0aDtcclxuXHR0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuXHJcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG5cdHRoaXMud3JhcFMgPSBvcHRpb25zLndyYXBTICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLndyYXBTIDogVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZztcclxuXHR0aGlzLndyYXBUID0gb3B0aW9ucy53cmFwVCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy53cmFwVCA6IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc7XHJcblxyXG5cdHRoaXMubWFnRmlsdGVyID0gb3B0aW9ucy5tYWdGaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubWFnRmlsdGVyIDogVEhSRUUuTGluZWFyRmlsdGVyO1xyXG5cdHRoaXMubWluRmlsdGVyID0gb3B0aW9ucy5taW5GaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubWluRmlsdGVyIDogVEhSRUUuTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyO1xyXG5cclxuXHR0aGlzLmFuaXNvdHJvcHkgPSBvcHRpb25zLmFuaXNvdHJvcHkgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYW5pc290cm9weSA6IDE7XHJcblxyXG5cdHRoaXMub2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjIoIDAsIDAgKTtcclxuXHR0aGlzLnJlcGVhdCA9IG5ldyBUSFJFRS5WZWN0b3IyKCAxLCAxICk7XHJcblxyXG5cdHRoaXMuZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZm9ybWF0IDogVEhSRUUuUkdCQUZvcm1hdDtcclxuXHR0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudHlwZSA6IFRIUkVFLlVuc2lnbmVkQnl0ZVR5cGU7XHJcblxyXG5cdHRoaXMuZGVwdGhCdWZmZXIgPSBvcHRpb25zLmRlcHRoQnVmZmVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRlcHRoQnVmZmVyIDogdHJ1ZTtcclxuXHR0aGlzLnN0ZW5jaWxCdWZmZXIgPSBvcHRpb25zLnN0ZW5jaWxCdWZmZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc3RlbmNpbEJ1ZmZlciA6IHRydWU7XHJcblxyXG5cdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gdHJ1ZTtcclxuXHJcblx0dGhpcy5zaGFyZURlcHRoRnJvbSA9IG51bGw7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdHZhciB0bXAgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQoIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0ICk7XHJcblxyXG5cdHRtcC53cmFwUyA9IHRoaXMud3JhcFM7XHJcblx0dG1wLndyYXBUID0gdGhpcy53cmFwVDtcclxuXHJcblx0dG1wLm1hZ0ZpbHRlciA9IHRoaXMubWFnRmlsdGVyO1xyXG5cdHRtcC5taW5GaWx0ZXIgPSB0aGlzLm1pbkZpbHRlcjtcclxuXHJcblx0dG1wLmFuaXNvdHJvcHkgPSB0aGlzLmFuaXNvdHJvcHk7XHJcblxyXG5cdHRtcC5vZmZzZXQuY29weSggdGhpcy5vZmZzZXQgKTtcclxuXHR0bXAucmVwZWF0LmNvcHkoIHRoaXMucmVwZWF0ICk7XHJcblxyXG5cdHRtcC5mb3JtYXQgPSB0aGlzLmZvcm1hdDtcclxuXHR0bXAudHlwZSA9IHRoaXMudHlwZTtcclxuXHJcblx0dG1wLmRlcHRoQnVmZmVyID0gdGhpcy5kZXB0aEJ1ZmZlcjtcclxuXHR0bXAuc3RlbmNpbEJ1ZmZlciA9IHRoaXMuc3RlbmNpbEJ1ZmZlcjtcclxuXHJcblx0dG1wLmdlbmVyYXRlTWlwbWFwcyA9IHRoaXMuZ2VuZXJhdGVNaXBtYXBzO1xyXG5cclxuXHR0bXAuc2hhcmVEZXB0aEZyb20gPSB0aGlzLnNoYXJlRGVwdGhGcm9tO1xyXG5cclxuXHRyZXR1cm4gdG1wO1xyXG5cclxufTtcclxuXHJcblRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcclxuXHJcbn07XHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tXHJcbiAqL1xyXG5cclxuVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zICkge1xyXG5cclxuXHRUSFJFRS5XZWJHTFJlbmRlclRhcmdldC5jYWxsKCB0aGlzLCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zICk7XHJcblxyXG5cdHRoaXMuYWN0aXZlQ3ViZUZhY2UgPSAwOyAvLyBQWCAwLCBOWCAxLCBQWSAyLCBOWSAzLCBQWiA0LCBOWiA1XHJcblxyXG59O1xyXG5cclxuVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LnByb3RvdHlwZSApO1xyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5SZW5kZXJhYmxlVmVydGV4ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR0aGlzLnBvc2l0aW9uV29ybGQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHRoaXMucG9zaXRpb25TY3JlZW4gPSBuZXcgVEhSRUUuVmVjdG9yNCgpO1xyXG5cclxuXHR0aGlzLnZpc2libGUgPSB0cnVlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlJlbmRlcmFibGVWZXJ0ZXgucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHZlcnRleCApIHtcclxuXHJcblx0dGhpcy5wb3NpdGlvbldvcmxkLmNvcHkoIHZlcnRleC5wb3NpdGlvbldvcmxkICk7XHJcblx0dGhpcy5wb3NpdGlvblNjcmVlbi5jb3B5KCB2ZXJ0ZXgucG9zaXRpb25TY3JlZW4gKTtcclxuXHJcbn07XHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlJlbmRlcmFibGVGYWNlMyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dGhpcy52MSA9IG5ldyBUSFJFRS5SZW5kZXJhYmxlVmVydGV4KCk7XHJcblx0dGhpcy52MiA9IG5ldyBUSFJFRS5SZW5kZXJhYmxlVmVydGV4KCk7XHJcblx0dGhpcy52MyA9IG5ldyBUSFJFRS5SZW5kZXJhYmxlVmVydGV4KCk7XHJcblxyXG5cdHRoaXMuY2VudHJvaWRNb2RlbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdHRoaXMubm9ybWFsTW9kZWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHRoaXMubm9ybWFsTW9kZWxWaWV3ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0dGhpcy52ZXJ0ZXhOb3JtYWxzTGVuZ3RoID0gMDtcclxuXHR0aGlzLnZlcnRleE5vcm1hbHNNb2RlbCA9IFsgbmV3IFRIUkVFLlZlY3RvcjMoKSwgbmV3IFRIUkVFLlZlY3RvcjMoKSwgbmV3IFRIUkVFLlZlY3RvcjMoKSBdO1xyXG5cdHRoaXMudmVydGV4Tm9ybWFsc01vZGVsVmlldyA9IFsgbmV3IFRIUkVFLlZlY3RvcjMoKSwgbmV3IFRIUkVFLlZlY3RvcjMoKSwgbmV3IFRIUkVFLlZlY3RvcjMoKSBdO1xyXG5cclxuXHR0aGlzLmNvbG9yID0gbnVsbDtcclxuXHR0aGlzLm1hdGVyaWFsID0gbnVsbDtcclxuXHR0aGlzLnV2cyA9IFtbXV07XHJcblxyXG5cdHRoaXMueiA9IG51bGw7XHJcblxyXG59O1xyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5SZW5kZXJhYmxlRmFjZTQgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHRoaXMudjEgPSBuZXcgVEhSRUUuUmVuZGVyYWJsZVZlcnRleCgpO1xyXG5cdHRoaXMudjIgPSBuZXcgVEhSRUUuUmVuZGVyYWJsZVZlcnRleCgpO1xyXG5cdHRoaXMudjMgPSBuZXcgVEhSRUUuUmVuZGVyYWJsZVZlcnRleCgpO1xyXG5cdHRoaXMudjQgPSBuZXcgVEhSRUUuUmVuZGVyYWJsZVZlcnRleCgpO1xyXG5cclxuXHR0aGlzLmNlbnRyb2lkTW9kZWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHR0aGlzLm5vcm1hbE1vZGVsID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR0aGlzLm5vcm1hbE1vZGVsVmlldyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdHRoaXMudmVydGV4Tm9ybWFsc0xlbmd0aCA9IDA7XHJcblx0dGhpcy52ZXJ0ZXhOb3JtYWxzTW9kZWwgPSBbIG5ldyBUSFJFRS5WZWN0b3IzKCksIG5ldyBUSFJFRS5WZWN0b3IzKCksIG5ldyBUSFJFRS5WZWN0b3IzKCksIG5ldyBUSFJFRS5WZWN0b3IzKCkgXTtcclxuXHR0aGlzLnZlcnRleE5vcm1hbHNNb2RlbFZpZXcgPSBbIG5ldyBUSFJFRS5WZWN0b3IzKCksIG5ldyBUSFJFRS5WZWN0b3IzKCksIG5ldyBUSFJFRS5WZWN0b3IzKCksIG5ldyBUSFJFRS5WZWN0b3IzKCkgXTtcclxuXHJcblx0dGhpcy5jb2xvciA9IG51bGw7XHJcblx0dGhpcy5tYXRlcmlhbCA9IG51bGw7XHJcblx0dGhpcy51dnMgPSBbW11dO1xyXG5cclxuXHR0aGlzLnogPSBudWxsO1xyXG5cclxufTtcclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuUmVuZGVyYWJsZU9iamVjdCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dGhpcy5vYmplY3QgPSBudWxsO1xyXG5cdHRoaXMueiA9IG51bGw7XHJcblxyXG59O1xyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5SZW5kZXJhYmxlUGFydGljbGUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHRoaXMub2JqZWN0ID0gbnVsbDtcclxuXHJcblx0dGhpcy54ID0gbnVsbDtcclxuXHR0aGlzLnkgPSBudWxsO1xyXG5cdHRoaXMueiA9IG51bGw7XHJcblxyXG5cdHRoaXMucm90YXRpb24gPSBudWxsO1xyXG5cdHRoaXMuc2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG5cclxuXHR0aGlzLm1hdGVyaWFsID0gbnVsbDtcclxuXHJcbn07XHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlJlbmRlcmFibGVMaW5lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR0aGlzLnogPSBudWxsO1xyXG5cclxuXHR0aGlzLnYxID0gbmV3IFRIUkVFLlJlbmRlcmFibGVWZXJ0ZXgoKTtcclxuXHR0aGlzLnYyID0gbmV3IFRIUkVFLlJlbmRlcmFibGVWZXJ0ZXgoKTtcclxuXHJcblx0dGhpcy5tYXRlcmlhbCA9IG51bGw7XHJcblxyXG59O1xyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5HZW9tZXRyeVV0aWxzID0ge1xyXG5cclxuXHQvLyBNZXJnZSB0d28gZ2VvbWV0cmllcyBvciBnZW9tZXRyeSBhbmQgZ2VvbWV0cnkgZnJvbSBvYmplY3QgKHVzaW5nIG9iamVjdCdzIHRyYW5zZm9ybSlcclxuXHJcblx0bWVyZ2U6IGZ1bmN0aW9uICggZ2VvbWV0cnkxLCBvYmplY3QyIC8qIG1lc2ggfCBnZW9tZXRyeSAqLyApIHtcclxuXHJcblx0XHR2YXIgbWF0cml4LCBub3JtYWxNYXRyaXgsXHJcblx0XHR2ZXJ0ZXhPZmZzZXQgPSBnZW9tZXRyeTEudmVydGljZXMubGVuZ3RoLFxyXG5cdFx0dXZQb3NpdGlvbiA9IGdlb21ldHJ5MS5mYWNlVmVydGV4VXZzWyAwIF0ubGVuZ3RoLFxyXG5cdFx0Z2VvbWV0cnkyID0gb2JqZWN0MiBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggPyBvYmplY3QyLmdlb21ldHJ5IDogb2JqZWN0MixcclxuXHRcdHZlcnRpY2VzMSA9IGdlb21ldHJ5MS52ZXJ0aWNlcyxcclxuXHRcdHZlcnRpY2VzMiA9IGdlb21ldHJ5Mi52ZXJ0aWNlcyxcclxuXHRcdGZhY2VzMSA9IGdlb21ldHJ5MS5mYWNlcyxcclxuXHRcdGZhY2VzMiA9IGdlb21ldHJ5Mi5mYWNlcyxcclxuXHRcdHV2czEgPSBnZW9tZXRyeTEuZmFjZVZlcnRleFV2c1sgMCBdLFxyXG5cdFx0dXZzMiA9IGdlb21ldHJ5Mi5mYWNlVmVydGV4VXZzWyAwIF07XHJcblxyXG5cdFx0aWYgKCBvYmplY3QyIGluc3RhbmNlb2YgVEhSRUUuTWVzaCApIHtcclxuXHJcblx0XHRcdG9iamVjdDIubWF0cml4QXV0b1VwZGF0ZSAmJiBvYmplY3QyLnVwZGF0ZU1hdHJpeCgpO1xyXG5cclxuXHRcdFx0bWF0cml4ID0gb2JqZWN0Mi5tYXRyaXg7XHJcblxyXG5cdFx0XHRub3JtYWxNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4MygpO1xyXG5cdFx0XHRub3JtYWxNYXRyaXguZ2V0SW52ZXJzZSggbWF0cml4ICk7XHJcblx0XHRcdG5vcm1hbE1hdHJpeC50cmFuc3Bvc2UoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdmVydGljZXNcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmVydGljZXMyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHZlcnRleCA9IHZlcnRpY2VzMlsgaSBdO1xyXG5cclxuXHRcdFx0dmFyIHZlcnRleENvcHkgPSB2ZXJ0ZXguY2xvbmUoKTtcclxuXHJcblx0XHRcdGlmICggbWF0cml4ICkgdmVydGV4Q29weS5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xyXG5cclxuXHRcdFx0dmVydGljZXMxLnB1c2goIHZlcnRleENvcHkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZmFjZXNcclxuXHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSBmYWNlczIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgZmFjZSA9IGZhY2VzMlsgaSBdLCBmYWNlQ29weSwgbm9ybWFsLCBjb2xvcixcclxuXHRcdFx0ZmFjZVZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHMsXHJcblx0XHRcdGZhY2VWZXJ0ZXhDb2xvcnMgPSBmYWNlLnZlcnRleENvbG9ycztcclxuXHJcblx0XHRcdGlmICggZmFjZSBpbnN0YW5jZW9mIFRIUkVFLkZhY2UzICkge1xyXG5cclxuXHRcdFx0XHRmYWNlQ29weSA9IG5ldyBUSFJFRS5GYWNlMyggZmFjZS5hICsgdmVydGV4T2Zmc2V0LCBmYWNlLmIgKyB2ZXJ0ZXhPZmZzZXQsIGZhY2UuYyArIHZlcnRleE9mZnNldCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggZmFjZSBpbnN0YW5jZW9mIFRIUkVFLkZhY2U0ICkge1xyXG5cclxuXHRcdFx0XHRmYWNlQ29weSA9IG5ldyBUSFJFRS5GYWNlNCggZmFjZS5hICsgdmVydGV4T2Zmc2V0LCBmYWNlLmIgKyB2ZXJ0ZXhPZmZzZXQsIGZhY2UuYyArIHZlcnRleE9mZnNldCwgZmFjZS5kICsgdmVydGV4T2Zmc2V0ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmYWNlQ29weS5ub3JtYWwuY29weSggZmFjZS5ub3JtYWwgKTtcclxuXHJcblx0XHRcdGlmICggbm9ybWFsTWF0cml4ICkge1xyXG5cclxuXHRcdFx0XHRmYWNlQ29weS5ub3JtYWwuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBmYWNlVmVydGV4Tm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0bm9ybWFsID0gZmFjZVZlcnRleE5vcm1hbHNbIGogXS5jbG9uZSgpO1xyXG5cclxuXHRcdFx0XHRpZiAoIG5vcm1hbE1hdHJpeCApIHtcclxuXHJcblx0XHRcdFx0XHRub3JtYWwuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmYWNlQ29weS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZmFjZUNvcHkuY29sb3IuY29weSggZmFjZS5jb2xvciApO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2VWZXJ0ZXhDb2xvcnMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdGNvbG9yID0gZmFjZVZlcnRleENvbG9yc1sgaiBdO1xyXG5cdFx0XHRcdGZhY2VDb3B5LnZlcnRleENvbG9ycy5wdXNoKCBjb2xvci5jbG9uZSgpICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmYWNlQ29weS5tYXRlcmlhbEluZGV4ID0gZmFjZS5tYXRlcmlhbEluZGV4O1xyXG5cclxuXHRcdFx0ZmFjZUNvcHkuY2VudHJvaWQuY29weSggZmFjZS5jZW50cm9pZCApO1xyXG5cclxuXHRcdFx0aWYgKCBtYXRyaXggKSB7XHJcblxyXG5cdFx0XHRcdGZhY2VDb3B5LmNlbnRyb2lkLmFwcGx5TWF0cml4NCggbWF0cml4ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmYWNlczEucHVzaCggZmFjZUNvcHkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdXZzXHJcblxyXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gdXZzMi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciB1diA9IHV2czJbIGkgXSwgdXZDb3B5ID0gW107XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gdXYubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdHV2Q29weS5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggdXZbIGogXS54LCB1dlsgaiBdLnkgKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dXZzMS5wdXNoKCB1dkNvcHkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdHJlbW92ZU1hdGVyaWFsczogZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWxJbmRleEFycmF5ICkge1xyXG5cclxuXHRcdHZhciBtYXRlcmlhbEluZGV4TWFwID0ge307XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG1hdGVyaWFsSW5kZXhBcnJheS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdG1hdGVyaWFsSW5kZXhNYXBbIG1hdGVyaWFsSW5kZXhBcnJheVtpXSBdID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGZhY2UsIG5ld0ZhY2VzID0gW107XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGdlb21ldHJ5LmZhY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0ZmFjZSA9IGdlb21ldHJ5LmZhY2VzWyBpIF07XHJcblx0XHRcdGlmICggISAoIGZhY2UubWF0ZXJpYWxJbmRleCBpbiBtYXRlcmlhbEluZGV4TWFwICkgKSBuZXdGYWNlcy5wdXNoKCBmYWNlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGdlb21ldHJ5LmZhY2VzID0gbmV3RmFjZXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIEdldCByYW5kb20gcG9pbnQgaW4gdHJpYW5nbGUgKHZpYSBiYXJ5Y2VudHJpYyBjb29yZGluYXRlcylcclxuXHQvLyBcdCh1bmlmb3JtIGRpc3RyaWJ1dGlvbilcclxuXHQvLyBcdGh0dHA6Ly93d3cuY2dhZmFxLmluZm8vd2lraS9SYW5kb21fUG9pbnRfSW5fVHJpYW5nbGVcclxuXHJcblx0cmFuZG9tUG9pbnRJblRyaWFuZ2xlOiBmdW5jdGlvbiAoIHZlY3RvckEsIHZlY3RvckIsIHZlY3RvckMgKSB7XHJcblxyXG5cdFx0dmFyIGEsIGIsIGMsXHJcblx0XHRcdHBvaW50ID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0dG1wID0gVEhSRUUuR2VvbWV0cnlVdGlscy5fX3YxO1xyXG5cclxuXHRcdGEgPSBUSFJFRS5HZW9tZXRyeVV0aWxzLnJhbmRvbSgpO1xyXG5cdFx0YiA9IFRIUkVFLkdlb21ldHJ5VXRpbHMucmFuZG9tKCk7XHJcblxyXG5cdFx0aWYgKCAoIGEgKyBiICkgPiAxICkge1xyXG5cclxuXHRcdFx0YSA9IDEgLSBhO1xyXG5cdFx0XHRiID0gMSAtIGI7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGMgPSAxIC0gYSAtIGI7XHJcblxyXG5cdFx0cG9pbnQuY29weSggdmVjdG9yQSApO1xyXG5cdFx0cG9pbnQubXVsdGlwbHlTY2FsYXIoIGEgKTtcclxuXHJcblx0XHR0bXAuY29weSggdmVjdG9yQiApO1xyXG5cdFx0dG1wLm11bHRpcGx5U2NhbGFyKCBiICk7XHJcblxyXG5cdFx0cG9pbnQuYWRkKCB0bXAgKTtcclxuXHJcblx0XHR0bXAuY29weSggdmVjdG9yQyApO1xyXG5cdFx0dG1wLm11bHRpcGx5U2NhbGFyKCBjICk7XHJcblxyXG5cdFx0cG9pbnQuYWRkKCB0bXAgKTtcclxuXHJcblx0XHRyZXR1cm4gcG9pbnQ7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIEdldCByYW5kb20gcG9pbnQgaW4gZmFjZSAodHJpYW5nbGUgLyBxdWFkKVxyXG5cdC8vICh1bmlmb3JtIGRpc3RyaWJ1dGlvbilcclxuXHJcblx0cmFuZG9tUG9pbnRJbkZhY2U6IGZ1bmN0aW9uICggZmFjZSwgZ2VvbWV0cnksIHVzZUNhY2hlZEFyZWFzICkge1xyXG5cclxuXHRcdHZhciB2QSwgdkIsIHZDLCB2RDtcclxuXHJcblx0XHRpZiAoIGZhY2UgaW5zdGFuY2VvZiBUSFJFRS5GYWNlMyApIHtcclxuXHJcblx0XHRcdHZBID0gZ2VvbWV0cnkudmVydGljZXNbIGZhY2UuYSBdO1xyXG5cdFx0XHR2QiA9IGdlb21ldHJ5LnZlcnRpY2VzWyBmYWNlLmIgXTtcclxuXHRcdFx0dkMgPSBnZW9tZXRyeS52ZXJ0aWNlc1sgZmFjZS5jIF07XHJcblxyXG5cdFx0XHRyZXR1cm4gVEhSRUUuR2VvbWV0cnlVdGlscy5yYW5kb21Qb2ludEluVHJpYW5nbGUoIHZBLCB2QiwgdkMgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBmYWNlIGluc3RhbmNlb2YgVEhSRUUuRmFjZTQgKSB7XHJcblxyXG5cdFx0XHR2QSA9IGdlb21ldHJ5LnZlcnRpY2VzWyBmYWNlLmEgXTtcclxuXHRcdFx0dkIgPSBnZW9tZXRyeS52ZXJ0aWNlc1sgZmFjZS5iIF07XHJcblx0XHRcdHZDID0gZ2VvbWV0cnkudmVydGljZXNbIGZhY2UuYyBdO1xyXG5cdFx0XHR2RCA9IGdlb21ldHJ5LnZlcnRpY2VzWyBmYWNlLmQgXTtcclxuXHJcblx0XHRcdHZhciBhcmVhMSwgYXJlYTI7XHJcblxyXG5cdFx0XHRpZiAoIHVzZUNhY2hlZEFyZWFzICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGZhY2UuX2FyZWExICYmIGZhY2UuX2FyZWEyICkge1xyXG5cclxuXHRcdFx0XHRcdGFyZWExID0gZmFjZS5fYXJlYTE7XHJcblx0XHRcdFx0XHRhcmVhMiA9IGZhY2UuX2FyZWEyO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGFyZWExID0gVEhSRUUuR2VvbWV0cnlVdGlscy50cmlhbmdsZUFyZWEoIHZBLCB2QiwgdkQgKTtcclxuXHRcdFx0XHRcdGFyZWEyID0gVEhSRUUuR2VvbWV0cnlVdGlscy50cmlhbmdsZUFyZWEoIHZCLCB2QywgdkQgKTtcclxuXHJcblx0XHRcdFx0XHRmYWNlLl9hcmVhMSA9IGFyZWExO1xyXG5cdFx0XHRcdFx0ZmFjZS5fYXJlYTIgPSBhcmVhMjtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0YXJlYTEgPSBUSFJFRS5HZW9tZXRyeVV0aWxzLnRyaWFuZ2xlQXJlYSggdkEsIHZCLCB2RCApLFxyXG5cdFx0XHRcdGFyZWEyID0gVEhSRUUuR2VvbWV0cnlVdGlscy50cmlhbmdsZUFyZWEoIHZCLCB2QywgdkQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciByID0gVEhSRUUuR2VvbWV0cnlVdGlscy5yYW5kb20oKSAqICggYXJlYTEgKyBhcmVhMiApO1xyXG5cclxuXHRcdFx0aWYgKCByIDwgYXJlYTEgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBUSFJFRS5HZW9tZXRyeVV0aWxzLnJhbmRvbVBvaW50SW5UcmlhbmdsZSggdkEsIHZCLCB2RCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIFRIUkVFLkdlb21ldHJ5VXRpbHMucmFuZG9tUG9pbnRJblRyaWFuZ2xlKCB2QiwgdkMsIHZEICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBHZXQgdW5pZm9ybWx5IGRpc3RyaWJ1dGVkIHJhbmRvbSBwb2ludHMgaW4gbWVzaFxyXG5cdC8vIFx0LSBjcmVhdGUgYXJyYXkgd2l0aCBjdW11bGF0aXZlIHN1bXMgb2YgZmFjZSBhcmVhc1xyXG5cdC8vICAtIHBpY2sgcmFuZG9tIG51bWJlciBmcm9tIDAgdG8gdG90YWwgYXJlYVxyXG5cdC8vICAtIGZpbmQgY29ycmVzcG9uZGluZyBwbGFjZSBpbiBhcmVhIGFycmF5IGJ5IGJpbmFyeSBzZWFyY2hcclxuXHQvL1x0LSBnZXQgcmFuZG9tIHBvaW50IGluIGZhY2VcclxuXHJcblx0cmFuZG9tUG9pbnRzSW5HZW9tZXRyeTogZnVuY3Rpb24gKCBnZW9tZXRyeSwgbiApIHtcclxuXHJcblx0XHR2YXIgZmFjZSwgaSxcclxuXHRcdFx0ZmFjZXMgPSBnZW9tZXRyeS5mYWNlcyxcclxuXHRcdFx0dmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcyxcclxuXHRcdFx0aWwgPSBmYWNlcy5sZW5ndGgsXHJcblx0XHRcdHRvdGFsQXJlYSA9IDAsXHJcblx0XHRcdGN1bXVsYXRpdmVBcmVhcyA9IFtdLFxyXG5cdFx0XHR2QSwgdkIsIHZDLCB2RDtcclxuXHJcblx0XHQvLyBwcmVjb21wdXRlIGZhY2UgYXJlYXNcclxuXHJcblx0XHRmb3IgKCBpID0gMDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0ZmFjZSA9IGZhY2VzWyBpIF07XHJcblxyXG5cdFx0XHRpZiAoIGZhY2UgaW5zdGFuY2VvZiBUSFJFRS5GYWNlMyApIHtcclxuXHJcblx0XHRcdFx0dkEgPSB2ZXJ0aWNlc1sgZmFjZS5hIF07XHJcblx0XHRcdFx0dkIgPSB2ZXJ0aWNlc1sgZmFjZS5iIF07XHJcblx0XHRcdFx0dkMgPSB2ZXJ0aWNlc1sgZmFjZS5jIF07XHJcblxyXG5cdFx0XHRcdGZhY2UuX2FyZWEgPSBUSFJFRS5HZW9tZXRyeVV0aWxzLnRyaWFuZ2xlQXJlYSggdkEsIHZCLCB2QyApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggZmFjZSBpbnN0YW5jZW9mIFRIUkVFLkZhY2U0ICkge1xyXG5cclxuXHRcdFx0XHR2QSA9IHZlcnRpY2VzWyBmYWNlLmEgXTtcclxuXHRcdFx0XHR2QiA9IHZlcnRpY2VzWyBmYWNlLmIgXTtcclxuXHRcdFx0XHR2QyA9IHZlcnRpY2VzWyBmYWNlLmMgXTtcclxuXHRcdFx0XHR2RCA9IHZlcnRpY2VzWyBmYWNlLmQgXTtcclxuXHJcblx0XHRcdFx0ZmFjZS5fYXJlYTEgPSBUSFJFRS5HZW9tZXRyeVV0aWxzLnRyaWFuZ2xlQXJlYSggdkEsIHZCLCB2RCApO1xyXG5cdFx0XHRcdGZhY2UuX2FyZWEyID0gVEhSRUUuR2VvbWV0cnlVdGlscy50cmlhbmdsZUFyZWEoIHZCLCB2QywgdkQgKTtcclxuXHJcblx0XHRcdFx0ZmFjZS5fYXJlYSA9IGZhY2UuX2FyZWExICsgZmFjZS5fYXJlYTI7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0b3RhbEFyZWEgKz0gZmFjZS5fYXJlYTtcclxuXHJcblx0XHRcdGN1bXVsYXRpdmVBcmVhc1sgaSBdID0gdG90YWxBcmVhO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBiaW5hcnkgc2VhcmNoIGN1bXVsYXRpdmUgYXJlYXMgYXJyYXlcclxuXHJcblx0XHRmdW5jdGlvbiBiaW5hcnlTZWFyY2hJbmRpY2VzKCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdGZ1bmN0aW9uIGJpbmFyeVNlYXJjaCggc3RhcnQsIGVuZCApIHtcclxuXHJcblx0XHRcdFx0Ly8gcmV0dXJuIGNsb3Nlc3QgbGFyZ2VyIGluZGV4XHJcblx0XHRcdFx0Ly8gaWYgZXhhY3QgbnVtYmVyIGlzIG5vdCBmb3VuZFxyXG5cclxuXHRcdFx0XHRpZiAoIGVuZCA8IHN0YXJ0IClcclxuXHRcdFx0XHRcdHJldHVybiBzdGFydDtcclxuXHJcblx0XHRcdFx0dmFyIG1pZCA9IHN0YXJ0ICsgTWF0aC5mbG9vciggKCBlbmQgLSBzdGFydCApIC8gMiApO1xyXG5cclxuXHRcdFx0XHRpZiAoIGN1bXVsYXRpdmVBcmVhc1sgbWlkIF0gPiB2YWx1ZSApIHtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gYmluYXJ5U2VhcmNoKCBzdGFydCwgbWlkIC0gMSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBjdW11bGF0aXZlQXJlYXNbIG1pZCBdIDwgdmFsdWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIGJpbmFyeVNlYXJjaCggbWlkICsgMSwgZW5kICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIG1pZDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIHJlc3VsdCA9IGJpbmFyeVNlYXJjaCggMCwgY3VtdWxhdGl2ZUFyZWFzLmxlbmd0aCAtIDEgKVxyXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBwaWNrIHJhbmRvbSBmYWNlIHdlaWdodGVkIGJ5IGZhY2UgYXJlYVxyXG5cclxuXHRcdHZhciByLCBpbmRleCxcclxuXHRcdFx0cmVzdWx0ID0gW107XHJcblxyXG5cdFx0dmFyIHN0YXRzID0ge307XHJcblxyXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBuOyBpICsrICkge1xyXG5cclxuXHRcdFx0ciA9IFRIUkVFLkdlb21ldHJ5VXRpbHMucmFuZG9tKCkgKiB0b3RhbEFyZWE7XHJcblxyXG5cdFx0XHRpbmRleCA9IGJpbmFyeVNlYXJjaEluZGljZXMoIHIgKTtcclxuXHJcblx0XHRcdHJlc3VsdFsgaSBdID0gVEhSRUUuR2VvbWV0cnlVdGlscy5yYW5kb21Qb2ludEluRmFjZSggZmFjZXNbIGluZGV4IF0sIGdlb21ldHJ5LCB0cnVlICk7XHJcblxyXG5cdFx0XHRpZiAoICEgc3RhdHNbIGluZGV4IF0gKSB7XHJcblxyXG5cdFx0XHRcdHN0YXRzWyBpbmRleCBdID0gMTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHN0YXRzWyBpbmRleCBdICs9IDE7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIEdldCB0cmlhbmdsZSBhcmVhIChoYWxmIG9mIHBhcmFsbGVsb2dyYW0pXHJcblx0Ly9cdGh0dHA6Ly9tYXRod29ybGQud29sZnJhbS5jb20vVHJpYW5nbGVBcmVhLmh0bWxcclxuXHJcblx0dHJpYW5nbGVBcmVhOiBmdW5jdGlvbiAoIHZlY3RvckEsIHZlY3RvckIsIHZlY3RvckMgKSB7XHJcblxyXG5cdFx0dmFyIHRtcDEgPSBUSFJFRS5HZW9tZXRyeVV0aWxzLl9fdjEsXHJcblx0XHRcdHRtcDIgPSBUSFJFRS5HZW9tZXRyeVV0aWxzLl9fdjI7XHJcblxyXG5cdFx0dG1wMS5zdWJWZWN0b3JzKCB2ZWN0b3JCLCB2ZWN0b3JBICk7XHJcblx0XHR0bXAyLnN1YlZlY3RvcnMoIHZlY3RvckMsIHZlY3RvckEgKTtcclxuXHRcdHRtcDEuY3Jvc3MoIHRtcDIgKTtcclxuXHJcblx0XHRyZXR1cm4gMC41ICogdG1wMS5sZW5ndGgoKTtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gQ2VudGVyIGdlb21ldHJ5IHNvIHRoYXQgMCwwLDAgaXMgaW4gY2VudGVyIG9mIGJvdW5kaW5nIGJveFxyXG5cclxuXHRjZW50ZXI6IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0Z2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk7XHJcblxyXG5cdFx0dmFyIGJiID0gZ2VvbWV0cnkuYm91bmRpbmdCb3g7XHJcblxyXG5cdFx0dmFyIG9mZnNldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0b2Zmc2V0LmFkZFZlY3RvcnMoIGJiLm1pbiwgYmIubWF4ICk7XHJcblx0XHRvZmZzZXQubXVsdGlwbHlTY2FsYXIoIC0wLjUgKTtcclxuXHJcblx0XHRnZW9tZXRyeS5hcHBseU1hdHJpeCggbmV3IFRIUkVFLk1hdHJpeDQoKS5tYWtlVHJhbnNsYXRpb24oIG9mZnNldC54LCBvZmZzZXQueSwgb2Zmc2V0LnogKSApO1xyXG5cdFx0Z2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk7XHJcblxyXG5cdFx0cmV0dXJuIG9mZnNldDtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gTm9ybWFsaXplIFVWcyB0byBiZSBmcm9tIDwwLDE+XHJcblx0Ly8gKGZvciBub3cganVzdCB0aGUgZmlyc3Qgc2V0IG9mIFVWcylcclxuXHJcblx0bm9ybWFsaXplVVZzOiBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xyXG5cclxuXHRcdHZhciB1dlNldCA9IGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIDAgXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdXZTZXQubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgdXZzID0gdXZTZXRbIGkgXTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSB1dnMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdC8vIHRleHR1cmUgcmVwZWF0XHJcblxyXG5cdFx0XHRcdGlmKCB1dnNbIGogXS54ICE9PSAxLjAgKSB1dnNbIGogXS54ID0gdXZzWyBqIF0ueCAtIE1hdGguZmxvb3IoIHV2c1sgaiBdLnggKTtcclxuXHRcdFx0XHRpZiggdXZzWyBqIF0ueSAhPT0gMS4wICkgdXZzWyBqIF0ueSA9IHV2c1sgaiBdLnkgLSBNYXRoLmZsb29yKCB1dnNbIGogXS55ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHR0cmlhbmd1bGF0ZVF1YWRzOiBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xyXG5cclxuXHRcdHZhciBpLCBpbCwgaiwgamw7XHJcblxyXG5cdFx0dmFyIGZhY2VzID0gW107XHJcblx0XHR2YXIgZmFjZVV2cyA9IFtdO1xyXG5cdFx0dmFyIGZhY2VWZXJ0ZXhVdnMgPSBbXTtcclxuXHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSBnZW9tZXRyeS5mYWNlVXZzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0ZmFjZVV2c1sgaSBdID0gW107XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRmYWNlVmVydGV4VXZzWyBpIF0gPSBbXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gZ2VvbWV0cnkuZmFjZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgZmFjZSA9IGdlb21ldHJ5LmZhY2VzWyBpIF07XHJcblxyXG5cdFx0XHRpZiAoIGZhY2UgaW5zdGFuY2VvZiBUSFJFRS5GYWNlNCApIHtcclxuXHJcblx0XHRcdFx0dmFyIGEgPSBmYWNlLmE7XHJcblx0XHRcdFx0dmFyIGIgPSBmYWNlLmI7XHJcblx0XHRcdFx0dmFyIGMgPSBmYWNlLmM7XHJcblx0XHRcdFx0dmFyIGQgPSBmYWNlLmQ7XHJcblxyXG5cdFx0XHRcdHZhciB0cmlBID0gbmV3IFRIUkVFLkZhY2UzKCk7XHJcblx0XHRcdFx0dmFyIHRyaUIgPSBuZXcgVEhSRUUuRmFjZTMoKTtcclxuXHJcblx0XHRcdFx0dHJpQS5jb2xvci5jb3B5KCBmYWNlLmNvbG9yICk7XHJcblx0XHRcdFx0dHJpQi5jb2xvci5jb3B5KCBmYWNlLmNvbG9yICk7XHJcblxyXG5cdFx0XHRcdHRyaUEubWF0ZXJpYWxJbmRleCA9IGZhY2UubWF0ZXJpYWxJbmRleDtcclxuXHRcdFx0XHR0cmlCLm1hdGVyaWFsSW5kZXggPSBmYWNlLm1hdGVyaWFsSW5kZXg7XHJcblxyXG5cdFx0XHRcdHRyaUEuYSA9IGE7XHJcblx0XHRcdFx0dHJpQS5iID0gYjtcclxuXHRcdFx0XHR0cmlBLmMgPSBkO1xyXG5cclxuXHRcdFx0XHR0cmlCLmEgPSBiO1xyXG5cdFx0XHRcdHRyaUIuYiA9IGM7XHJcblx0XHRcdFx0dHJpQi5jID0gZDtcclxuXHJcblx0XHRcdFx0aWYgKCBmYWNlLnZlcnRleENvbG9ycy5sZW5ndGggPT09IDQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dHJpQS52ZXJ0ZXhDb2xvcnNbIDAgXSA9IGZhY2UudmVydGV4Q29sb3JzWyAwIF0uY2xvbmUoKTtcclxuXHRcdFx0XHRcdHRyaUEudmVydGV4Q29sb3JzWyAxIF0gPSBmYWNlLnZlcnRleENvbG9yc1sgMSBdLmNsb25lKCk7XHJcblx0XHRcdFx0XHR0cmlBLnZlcnRleENvbG9yc1sgMiBdID0gZmFjZS52ZXJ0ZXhDb2xvcnNbIDMgXS5jbG9uZSgpO1xyXG5cclxuXHRcdFx0XHRcdHRyaUIudmVydGV4Q29sb3JzWyAwIF0gPSBmYWNlLnZlcnRleENvbG9yc1sgMSBdLmNsb25lKCk7XHJcblx0XHRcdFx0XHR0cmlCLnZlcnRleENvbG9yc1sgMSBdID0gZmFjZS52ZXJ0ZXhDb2xvcnNbIDIgXS5jbG9uZSgpO1xyXG5cdFx0XHRcdFx0dHJpQi52ZXJ0ZXhDb2xvcnNbIDIgXSA9IGZhY2UudmVydGV4Q29sb3JzWyAzIF0uY2xvbmUoKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmYWNlcy5wdXNoKCB0cmlBLCB0cmlCICk7XHJcblxyXG5cdFx0XHRcdGZvciAoIGogPSAwLCBqbCA9IGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBqIF0ubGVuZ3RoICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIHV2cyA9IGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGogXVsgaSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIHV2QSA9IHV2c1sgMCBdO1xyXG5cdFx0XHRcdFx0XHR2YXIgdXZCID0gdXZzWyAxIF07XHJcblx0XHRcdFx0XHRcdHZhciB1dkMgPSB1dnNbIDIgXTtcclxuXHRcdFx0XHRcdFx0dmFyIHV2RCA9IHV2c1sgMyBdO1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIHV2c1RyaUEgPSBbIHV2QS5jbG9uZSgpLCB1dkIuY2xvbmUoKSwgdXZELmNsb25lKCkgXTtcclxuXHRcdFx0XHRcdFx0dmFyIHV2c1RyaUIgPSBbIHV2Qi5jbG9uZSgpLCB1dkMuY2xvbmUoKSwgdXZELmNsb25lKCkgXTtcclxuXHJcblx0XHRcdFx0XHRcdGZhY2VWZXJ0ZXhVdnNbIGogXS5wdXNoKCB1dnNUcmlBLCB1dnNUcmlCICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGZvciAoIGogPSAwLCBqbCA9IGdlb21ldHJ5LmZhY2VVdnMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBnZW9tZXRyeS5mYWNlVXZzWyBqIF0ubGVuZ3RoICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIGZhY2VVdiA9IGdlb21ldHJ5LmZhY2VVdnNbIGogXVsgaSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0ZmFjZVV2c1sgaiBdLnB1c2goIGZhY2VVdiwgZmFjZVV2ICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRmYWNlcy5wdXNoKCBmYWNlICk7XHJcblxyXG5cdFx0XHRcdGZvciAoIGogPSAwLCBqbCA9IGdlb21ldHJ5LmZhY2VVdnMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0ZmFjZVV2c1sgaiBdLnB1c2goIGdlb21ldHJ5LmZhY2VVdnNbIGogXVsgaSBdICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Zm9yICggaiA9IDAsIGpsID0gZ2VvbWV0cnkuZmFjZVZlcnRleFV2cy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRmYWNlVmVydGV4VXZzWyBqIF0ucHVzaCggZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaiBdWyBpIF0gKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRnZW9tZXRyeS5mYWNlcyA9IGZhY2VzO1xyXG5cdFx0Z2VvbWV0cnkuZmFjZVV2cyA9IGZhY2VVdnM7XHJcblx0XHRnZW9tZXRyeS5mYWNlVmVydGV4VXZzID0gZmFjZVZlcnRleFV2cztcclxuXHJcblx0XHRnZW9tZXRyeS5jb21wdXRlQ2VudHJvaWRzKCk7XHJcblx0XHRnZW9tZXRyeS5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHRcdGdlb21ldHJ5LmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS5oYXNUYW5nZW50cyApIGdlb21ldHJ5LmNvbXB1dGVUYW5nZW50cygpO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRNYXRlcmlhbEluZGV4OiBmdW5jdGlvbiAoIGdlb21ldHJ5LCBpbmRleCwgc3RhcnRGYWNlLCBlbmRGYWNlICl7XHJcblxyXG5cdFx0dmFyIGZhY2VzID0gZ2VvbWV0cnkuZmFjZXM7XHJcblx0XHR2YXIgc3RhcnQgPSBzdGFydEZhY2UgfHwgMDtcclxuXHRcdHZhciBlbmQgPSBlbmRGYWNlIHx8IGZhY2VzLmxlbmd0aCAtIDE7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSBzdGFydDsgaSA8PSBlbmQ7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRmYWNlc1tpXS5tYXRlcmlhbEluZGV4ID0gaW5kZXg7XHJcblxyXG5cdFx0fVxyXG5cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5HZW9tZXRyeVV0aWxzLnJhbmRvbSA9IFRIUkVFLk1hdGgucmFuZG9tMTY7XHJcblxyXG5USFJFRS5HZW9tZXRyeVV0aWxzLl9fdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5USFJFRS5HZW9tZXRyeVV0aWxzLl9fdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5JbWFnZVV0aWxzID0ge1xyXG5cclxuXHRjcm9zc09yaWdpbjogJ2Fub255bW91cycsXHJcblxyXG5cdGxvYWRUZXh0dXJlOiBmdW5jdGlvbiAoIHVybCwgbWFwcGluZywgb25Mb2FkLCBvbkVycm9yICkge1xyXG5cclxuXHRcdHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpO1xyXG5cdFx0dmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuVGV4dHVyZSggaW1hZ2UsIG1hcHBpbmcgKTtcclxuXHJcblx0XHR2YXIgbG9hZGVyID0gbmV3IFRIUkVFLkltYWdlTG9hZGVyKCk7XHJcblxyXG5cdFx0bG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoICdsb2FkJywgZnVuY3Rpb24gKCBldmVudCApIHtcclxuXHJcblx0XHRcdHRleHR1cmUuaW1hZ2UgPSBldmVudC5jb250ZW50O1xyXG5cdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCB0ZXh0dXJlICk7XHJcblxyXG5cdFx0fSApO1xyXG5cclxuXHRcdGxvYWRlci5hZGRFdmVudExpc3RlbmVyKCAnZXJyb3InLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xyXG5cclxuXHRcdFx0aWYgKCBvbkVycm9yICkgb25FcnJvciggZXZlbnQubWVzc2FnZSApO1xyXG5cclxuXHRcdH0gKTtcclxuXHJcblx0XHRsb2FkZXIuY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xyXG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgaW1hZ2UgKTtcclxuXHJcblx0XHR0ZXh0dXJlLnNvdXJjZUZpbGUgPSB1cmw7XHJcblxyXG5cdFx0cmV0dXJuIHRleHR1cmU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxvYWRDb21wcmVzc2VkVGV4dHVyZTogZnVuY3Rpb24gKCB1cmwsIG1hcHBpbmcsIG9uTG9hZCwgb25FcnJvciApIHtcclxuXHJcblx0XHR2YXIgdGV4dHVyZSA9IG5ldyBUSFJFRS5Db21wcmVzc2VkVGV4dHVyZSgpO1xyXG5cdFx0dGV4dHVyZS5tYXBwaW5nID0gbWFwcGluZztcclxuXHJcblx0XHR2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG5cclxuXHRcdHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIGJ1ZmZlciA9IHJlcXVlc3QucmVzcG9uc2U7XHJcblx0XHRcdHZhciBkZHMgPSBUSFJFRS5JbWFnZVV0aWxzLnBhcnNlRERTKCBidWZmZXIsIHRydWUgKTtcclxuXHJcblx0XHRcdHRleHR1cmUuZm9ybWF0ID0gZGRzLmZvcm1hdDtcclxuXHJcblx0XHRcdHRleHR1cmUubWlwbWFwcyA9IGRkcy5taXBtYXBzO1xyXG5cdFx0XHR0ZXh0dXJlLmltYWdlLndpZHRoID0gZGRzLndpZHRoO1xyXG5cdFx0XHR0ZXh0dXJlLmltYWdlLmhlaWdodCA9IGRkcy5oZWlnaHQ7XHJcblxyXG5cdFx0XHQvLyBnbC5nZW5lcmF0ZU1pcG1hcCBmYWlscyBmb3IgY29tcHJlc3NlZCB0ZXh0dXJlc1xyXG5cdFx0XHQvLyBtaXBtYXBzIG11c3QgYmUgZW1iZWRkZWQgaW4gdGhlIEREUyBmaWxlXHJcblx0XHRcdC8vIG9yIHRleHR1cmUgZmlsdGVycyBtdXN0IG5vdCB1c2UgbWlwbWFwcGluZ1xyXG5cclxuXHRcdFx0dGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcclxuXHJcblx0XHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmVxdWVzdC5vbmVycm9yID0gb25FcnJvcjtcclxuXHJcblx0XHRyZXF1ZXN0Lm9wZW4oICdHRVQnLCB1cmwsIHRydWUgKTtcclxuXHRcdHJlcXVlc3QucmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xyXG5cdFx0cmVxdWVzdC5zZW5kKCBudWxsICk7XHJcblxyXG5cdFx0cmV0dXJuIHRleHR1cmU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxvYWRUZXh0dXJlQ3ViZTogZnVuY3Rpb24gKCBhcnJheSwgbWFwcGluZywgb25Mb2FkLCBvbkVycm9yICkge1xyXG5cclxuXHRcdHZhciBpbWFnZXMgPSBbXTtcclxuXHRcdGltYWdlcy5sb2FkQ291bnQgPSAwO1xyXG5cclxuXHRcdHZhciB0ZXh0dXJlID0gbmV3IFRIUkVFLlRleHR1cmUoKTtcclxuXHRcdHRleHR1cmUuaW1hZ2UgPSBpbWFnZXM7XHJcblx0XHRpZiAoIG1hcHBpbmcgIT09IHVuZGVmaW5lZCApIHRleHR1cmUubWFwcGluZyA9IG1hcHBpbmc7XHJcblxyXG5cdFx0Ly8gbm8gZmxpcHBpbmcgbmVlZGVkIGZvciBjdWJlIHRleHR1cmVzXHJcblxyXG5cdFx0dGV4dHVyZS5mbGlwWSA9IGZhbHNlO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBhcnJheS5sZW5ndGg7IGkgPCBpbDsgKysgaSApIHtcclxuXHJcblx0XHRcdHZhciBjdWJlSW1hZ2UgPSBuZXcgSW1hZ2UoKTtcclxuXHRcdFx0aW1hZ2VzWyBpIF0gPSBjdWJlSW1hZ2U7XHJcblxyXG5cdFx0XHRjdWJlSW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0XHRpbWFnZXMubG9hZENvdW50ICs9IDE7XHJcblxyXG5cdFx0XHRcdGlmICggaW1hZ2VzLmxvYWRDb3VudCA9PT0gNiApIHtcclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHRcdFx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCB0ZXh0dXJlICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRjdWJlSW1hZ2Uub25lcnJvciA9IG9uRXJyb3I7XHJcblxyXG5cdFx0XHRjdWJlSW1hZ2UuY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xyXG5cdFx0XHRjdWJlSW1hZ2Uuc3JjID0gYXJyYXlbIGkgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRleHR1cmU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxvYWRDb21wcmVzc2VkVGV4dHVyZUN1YmU6IGZ1bmN0aW9uICggYXJyYXksIG1hcHBpbmcsIG9uTG9hZCwgb25FcnJvciApIHtcclxuXHJcblx0XHR2YXIgaW1hZ2VzID0gW107XHJcblx0XHRpbWFnZXMubG9hZENvdW50ID0gMDtcclxuXHJcblx0XHR2YXIgdGV4dHVyZSA9IG5ldyBUSFJFRS5Db21wcmVzc2VkVGV4dHVyZSgpO1xyXG5cdFx0dGV4dHVyZS5pbWFnZSA9IGltYWdlcztcclxuXHRcdGlmICggbWFwcGluZyAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5tYXBwaW5nID0gbWFwcGluZztcclxuXHJcblx0XHQvLyBubyBmbGlwcGluZyBmb3IgY3ViZSB0ZXh0dXJlc1xyXG5cdFx0Ly8gKGFsc28gZmxpcHBpbmcgZG9lc24ndCB3b3JrIGZvciBjb21wcmVzc2VkIHRleHR1cmVzIClcclxuXHJcblx0XHR0ZXh0dXJlLmZsaXBZID0gZmFsc2U7XHJcblxyXG5cdFx0Ly8gY2FuJ3QgZ2VuZXJhdGUgbWlwbWFwcyBmb3IgY29tcHJlc3NlZCB0ZXh0dXJlc1xyXG5cdFx0Ly8gbWlwcyBtdXN0IGJlIGVtYmVkZGVkIGluIEREUyBmaWxlc1xyXG5cclxuXHRcdHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XHJcblxyXG5cdFx0dmFyIGdlbmVyYXRlQ3ViZUZhY2VDYWxsYmFjayA9IGZ1bmN0aW9uICggcnEsIGltZyApIHtcclxuXHJcblx0XHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRcdHZhciBidWZmZXIgPSBycS5yZXNwb25zZTtcclxuXHRcdFx0XHR2YXIgZGRzID0gVEhSRUUuSW1hZ2VVdGlscy5wYXJzZUREUyggYnVmZmVyLCB0cnVlICk7XHJcblxyXG5cdFx0XHRcdGltZy5mb3JtYXQgPSBkZHMuZm9ybWF0O1xyXG5cclxuXHRcdFx0XHRpbWcubWlwbWFwcyA9IGRkcy5taXBtYXBzO1xyXG5cdFx0XHRcdGltZy53aWR0aCA9IGRkcy53aWR0aDtcclxuXHRcdFx0XHRpbWcuaGVpZ2h0ID0gZGRzLmhlaWdodDtcclxuXHJcblx0XHRcdFx0aW1hZ2VzLmxvYWRDb3VudCArPSAxO1xyXG5cclxuXHRcdFx0XHRpZiAoIGltYWdlcy5sb2FkQ291bnQgPT09IDYgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGV4dHVyZS5mb3JtYXQgPSBkZHMuZm9ybWF0O1xyXG5cdFx0XHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblx0XHRcdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGNvbXByZXNzZWQgY3ViZW1hcCB0ZXh0dXJlcyBhcyA2IHNlcGFyYXRlIEREUyBmaWxlc1xyXG5cclxuXHRcdGlmICggYXJyYXkgaW5zdGFuY2VvZiBBcnJheSApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBhcnJheS5sZW5ndGg7IGkgPCBpbDsgKysgaSApIHtcclxuXHJcblx0XHRcdFx0dmFyIGN1YmVJbWFnZSA9IHt9O1xyXG5cdFx0XHRcdGltYWdlc1sgaSBdID0gY3ViZUltYWdlO1xyXG5cclxuXHRcdFx0XHR2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG5cclxuXHRcdFx0XHRyZXF1ZXN0Lm9ubG9hZCA9IGdlbmVyYXRlQ3ViZUZhY2VDYWxsYmFjayggcmVxdWVzdCwgY3ViZUltYWdlICk7XHJcblx0XHRcdFx0cmVxdWVzdC5vbmVycm9yID0gb25FcnJvcjtcclxuXHJcblx0XHRcdFx0dmFyIHVybCA9IGFycmF5WyBpIF07XHJcblxyXG5cdFx0XHRcdHJlcXVlc3Qub3BlbiggJ0dFVCcsIHVybCwgdHJ1ZSApO1xyXG5cdFx0XHRcdHJlcXVlc3QucmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xyXG5cdFx0XHRcdHJlcXVlc3Quc2VuZCggbnVsbCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdC8vIGNvbXByZXNzZWQgY3ViZW1hcCB0ZXh0dXJlIHN0b3JlZCBpbiBhIHNpbmdsZSBERFMgZmlsZVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR2YXIgdXJsID0gYXJyYXk7XHJcblx0XHRcdHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcblxyXG5cdFx0XHRyZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uKCApIHtcclxuXHJcblx0XHRcdFx0dmFyIGJ1ZmZlciA9IHJlcXVlc3QucmVzcG9uc2U7XHJcblx0XHRcdFx0dmFyIGRkcyA9IFRIUkVFLkltYWdlVXRpbHMucGFyc2VERFMoIGJ1ZmZlciwgdHJ1ZSApO1xyXG5cclxuXHRcdFx0XHRpZiAoIGRkcy5pc0N1YmVtYXAgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGZhY2VzID0gZGRzLm1pcG1hcHMubGVuZ3RoIC8gZGRzLm1pcG1hcENvdW50O1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIHZhciBmID0gMDsgZiA8IGZhY2VzOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aW1hZ2VzWyBmIF0gPSB7IG1pcG1hcHMgOiBbXSB9O1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZGRzLm1pcG1hcENvdW50OyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpbWFnZXNbIGYgXS5taXBtYXBzLnB1c2goIGRkcy5taXBtYXBzWyBmICogZGRzLm1pcG1hcENvdW50ICsgaSBdICk7XHJcblx0XHRcdFx0XHRcdFx0aW1hZ2VzWyBmIF0uZm9ybWF0ID0gZGRzLmZvcm1hdDtcclxuXHRcdFx0XHRcdFx0XHRpbWFnZXNbIGYgXS53aWR0aCA9IGRkcy53aWR0aDtcclxuXHRcdFx0XHRcdFx0XHRpbWFnZXNbIGYgXS5oZWlnaHQgPSBkZHMuaGVpZ2h0O1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlLmZvcm1hdCA9IGRkcy5mb3JtYXQ7XHJcblx0XHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHRcdFx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCB0ZXh0dXJlICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJlcXVlc3Qub25lcnJvciA9IG9uRXJyb3I7XHJcblxyXG5cdFx0XHRyZXF1ZXN0Lm9wZW4oICdHRVQnLCB1cmwsIHRydWUgKTtcclxuXHRcdFx0cmVxdWVzdC5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XHJcblx0XHRcdHJlcXVlc3Quc2VuZCggbnVsbCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGV4dHVyZTtcclxuXHJcblx0fSxcclxuXHJcblx0cGFyc2VERFM6IGZ1bmN0aW9uICggYnVmZmVyLCBsb2FkTWlwbWFwcyApIHtcclxuXHJcblx0XHR2YXIgZGRzID0geyBtaXBtYXBzOiBbXSwgd2lkdGg6IDAsIGhlaWdodDogMCwgZm9ybWF0OiBudWxsLCBtaXBtYXBDb3VudDogMSB9O1xyXG5cclxuXHRcdC8vIEFkYXB0ZWQgZnJvbSBAdG9qaSdzIEREUyB1dGlsc1xyXG5cdFx0Ly9cdGh0dHBzOi8vZ2l0aHViLmNvbS90b2ppL3dlYmdsLXRleHR1cmUtdXRpbHMvYmxvYi9tYXN0ZXIvdGV4dHVyZS11dGlsL2Rkcy5qc1xyXG5cclxuXHRcdC8vIEFsbCB2YWx1ZXMgYW5kIHN0cnVjdHVyZXMgcmVmZXJlbmNlZCBmcm9tOlxyXG5cdFx0Ly8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2JiOTQzOTkxLmFzcHgvXHJcblxyXG5cdFx0dmFyIEREU19NQUdJQyA9IDB4MjA1MzQ0NDQ7XHJcblxyXG5cdFx0dmFyIEREU0RfQ0FQUyA9IDB4MSxcclxuXHRcdFx0RERTRF9IRUlHSFQgPSAweDIsXHJcblx0XHRcdEREU0RfV0lEVEggPSAweDQsXHJcblx0XHRcdEREU0RfUElUQ0ggPSAweDgsXHJcblx0XHRcdEREU0RfUElYRUxGT1JNQVQgPSAweDEwMDAsXHJcblx0XHRcdEREU0RfTUlQTUFQQ09VTlQgPSAweDIwMDAwLFxyXG5cdFx0XHRERFNEX0xJTkVBUlNJWkUgPSAweDgwMDAwLFxyXG5cdFx0XHRERFNEX0RFUFRIID0gMHg4MDAwMDA7XHJcblxyXG5cdFx0dmFyIEREU0NBUFNfQ09NUExFWCA9IDB4OCxcclxuXHRcdFx0RERTQ0FQU19NSVBNQVAgPSAweDQwMDAwMCxcclxuXHRcdFx0RERTQ0FQU19URVhUVVJFID0gMHgxMDAwO1xyXG5cclxuXHRcdHZhciBERFNDQVBTMl9DVUJFTUFQID0gMHgyMDAsXHJcblx0XHRcdEREU0NBUFMyX0NVQkVNQVBfUE9TSVRJVkVYID0gMHg0MDAsXHJcblx0XHRcdEREU0NBUFMyX0NVQkVNQVBfTkVHQVRJVkVYID0gMHg4MDAsXHJcblx0XHRcdEREU0NBUFMyX0NVQkVNQVBfUE9TSVRJVkVZID0gMHgxMDAwLFxyXG5cdFx0XHRERFNDQVBTMl9DVUJFTUFQX05FR0FUSVZFWSA9IDB4MjAwMCxcclxuXHRcdFx0RERTQ0FQUzJfQ1VCRU1BUF9QT1NJVElWRVogPSAweDQwMDAsXHJcblx0XHRcdEREU0NBUFMyX0NVQkVNQVBfTkVHQVRJVkVaID0gMHg4MDAwLFxyXG5cdFx0XHRERFNDQVBTMl9WT0xVTUUgPSAweDIwMDAwMDtcclxuXHJcblx0XHR2YXIgRERQRl9BTFBIQVBJWEVMUyA9IDB4MSxcclxuXHRcdFx0RERQRl9BTFBIQSA9IDB4MixcclxuXHRcdFx0RERQRl9GT1VSQ0MgPSAweDQsXHJcblx0XHRcdEREUEZfUkdCID0gMHg0MCxcclxuXHRcdFx0RERQRl9ZVVYgPSAweDIwMCxcclxuXHRcdFx0RERQRl9MVU1JTkFOQ0UgPSAweDIwMDAwO1xyXG5cclxuXHRcdGZ1bmN0aW9uIGZvdXJDQ1RvSW50MzIoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHZhbHVlLmNoYXJDb2RlQXQoMCkgK1xyXG5cdFx0XHRcdCh2YWx1ZS5jaGFyQ29kZUF0KDEpIDw8IDgpICtcclxuXHRcdFx0XHQodmFsdWUuY2hhckNvZGVBdCgyKSA8PCAxNikgK1xyXG5cdFx0XHRcdCh2YWx1ZS5jaGFyQ29kZUF0KDMpIDw8IDI0KTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gaW50MzJUb0ZvdXJDQyggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShcclxuXHRcdFx0XHR2YWx1ZSAmIDB4ZmYsXHJcblx0XHRcdFx0KHZhbHVlID4+IDgpICYgMHhmZixcclxuXHRcdFx0XHQodmFsdWUgPj4gMTYpICYgMHhmZixcclxuXHRcdFx0XHQodmFsdWUgPj4gMjQpICYgMHhmZlxyXG5cdFx0XHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBGT1VSQ0NfRFhUMSA9IGZvdXJDQ1RvSW50MzIoXCJEWFQxXCIpO1xyXG5cdFx0dmFyIEZPVVJDQ19EWFQzID0gZm91ckNDVG9JbnQzMihcIkRYVDNcIik7XHJcblx0XHR2YXIgRk9VUkNDX0RYVDUgPSBmb3VyQ0NUb0ludDMyKFwiRFhUNVwiKTtcclxuXHJcblx0XHR2YXIgaGVhZGVyTGVuZ3RoSW50ID0gMzE7IC8vIFRoZSBoZWFkZXIgbGVuZ3RoIGluIDMyIGJpdCBpbnRzXHJcblxyXG5cdFx0Ly8gT2Zmc2V0cyBpbnRvIHRoZSBoZWFkZXIgYXJyYXlcclxuXHJcblx0XHR2YXIgb2ZmX21hZ2ljID0gMDtcclxuXHJcblx0XHR2YXIgb2ZmX3NpemUgPSAxO1xyXG5cdFx0dmFyIG9mZl9mbGFncyA9IDI7XHJcblx0XHR2YXIgb2ZmX2hlaWdodCA9IDM7XHJcblx0XHR2YXIgb2ZmX3dpZHRoID0gNDtcclxuXHJcblx0XHR2YXIgb2ZmX21pcG1hcENvdW50ID0gNztcclxuXHJcblx0XHR2YXIgb2ZmX3BmRmxhZ3MgPSAyMDtcclxuXHRcdHZhciBvZmZfcGZGb3VyQ0MgPSAyMTtcclxuXHJcblx0XHR2YXIgb2ZmX2NhcHMgPSAyNztcclxuXHRcdHZhciBvZmZfY2FwczIgPSAyODtcclxuXHRcdHZhciBvZmZfY2FwczMgPSAyOTtcclxuXHRcdHZhciBvZmZfY2FwczQgPSAzMDtcclxuXHJcblx0XHQvLyBQYXJzZSBoZWFkZXJcclxuXHJcblx0XHR2YXIgaGVhZGVyID0gbmV3IEludDMyQXJyYXkoIGJ1ZmZlciwgMCwgaGVhZGVyTGVuZ3RoSW50ICk7XHJcblxyXG5cdFx0aWYgKCBoZWFkZXJbIG9mZl9tYWdpYyBdICE9PSBERFNfTUFHSUMgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCBcIkltYWdlVXRpbHMucGFyc2VERFMoKTogSW52YWxpZCBtYWdpYyBudW1iZXIgaW4gRERTIGhlYWRlclwiICk7XHJcblx0XHRcdHJldHVybiBkZHM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggISBoZWFkZXJbIG9mZl9wZkZsYWdzIF0gJiBERFBGX0ZPVVJDQyApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoIFwiSW1hZ2VVdGlscy5wYXJzZUREUygpOiBVbnN1cHBvcnRlZCBmb3JtYXQsIG11c3QgY29udGFpbiBhIEZvdXJDQyBjb2RlXCIgKTtcclxuXHRcdFx0cmV0dXJuIGRkcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGJsb2NrQnl0ZXM7XHJcblxyXG5cdFx0dmFyIGZvdXJDQyA9IGhlYWRlclsgb2ZmX3BmRm91ckNDIF07XHJcblxyXG5cdFx0c3dpdGNoICggZm91ckNDICkge1xyXG5cclxuXHRcdFx0Y2FzZSBGT1VSQ0NfRFhUMTpcclxuXHJcblx0XHRcdFx0YmxvY2tCeXRlcyA9IDg7XHJcblx0XHRcdFx0ZGRzLmZvcm1hdCA9IFRIUkVFLlJHQl9TM1RDX0RYVDFfRm9ybWF0O1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSBGT1VSQ0NfRFhUMzpcclxuXHJcblx0XHRcdFx0YmxvY2tCeXRlcyA9IDE2O1xyXG5cdFx0XHRcdGRkcy5mb3JtYXQgPSBUSFJFRS5SR0JBX1MzVENfRFhUM19Gb3JtYXQ7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlIEZPVVJDQ19EWFQ1OlxyXG5cclxuXHRcdFx0XHRibG9ja0J5dGVzID0gMTY7XHJcblx0XHRcdFx0ZGRzLmZvcm1hdCA9IFRIUkVFLlJHQkFfUzNUQ19EWFQ1X0Zvcm1hdDtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGRlZmF1bHQ6XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoIFwiSW1hZ2VVdGlscy5wYXJzZUREUygpOiBVbnN1cHBvcnRlZCBGb3VyQ0MgY29kZTogXCIsIGludDMyVG9Gb3VyQ0MoIGZvdXJDQyApICk7XHJcblx0XHRcdFx0cmV0dXJuIGRkcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZGRzLm1pcG1hcENvdW50ID0gMTtcclxuXHJcblx0XHRpZiAoIGhlYWRlclsgb2ZmX2ZsYWdzIF0gJiBERFNEX01JUE1BUENPVU5UICYmIGxvYWRNaXBtYXBzICE9PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdGRkcy5taXBtYXBDb3VudCA9IE1hdGgubWF4KCAxLCBoZWFkZXJbIG9mZl9taXBtYXBDb3VudCBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vVE9ETzogVmVyaWZ5IHRoYXQgYWxsIGZhY2VzIG9mIHRoZSBjdWJlbWFwIGFyZSBwcmVzZW50IHdpdGggRERTQ0FQUzJfQ1VCRU1BUF9QT1NJVElWRVgsIGV0Yy5cclxuXHJcblx0XHRkZHMuaXNDdWJlbWFwID0gaGVhZGVyWyBvZmZfY2FwczIgXSAmIEREU0NBUFMyX0NVQkVNQVAgPyB0cnVlIDogZmFsc2U7XHJcblxyXG5cdFx0ZGRzLndpZHRoID0gaGVhZGVyWyBvZmZfd2lkdGggXTtcclxuXHRcdGRkcy5oZWlnaHQgPSBoZWFkZXJbIG9mZl9oZWlnaHQgXTtcclxuXHJcblx0XHR2YXIgZGF0YU9mZnNldCA9IGhlYWRlclsgb2ZmX3NpemUgXSArIDQ7XHJcblxyXG5cdFx0Ly8gRXh0cmFjdCBtaXBtYXBzIGJ1ZmZlcnNcclxuXHJcblx0XHR2YXIgd2lkdGggPSBkZHMud2lkdGg7XHJcblx0XHR2YXIgaGVpZ2h0ID0gZGRzLmhlaWdodDtcclxuXHJcblx0XHR2YXIgZmFjZXMgPSBkZHMuaXNDdWJlbWFwID8gNiA6IDE7XHJcblxyXG5cdFx0Zm9yICggdmFyIGZhY2UgPSAwOyBmYWNlIDwgZmFjZXM7IGZhY2UgKysgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBkZHMubWlwbWFwQ291bnQ7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBkYXRhTGVuZ3RoID0gTWF0aC5tYXgoIDQsIHdpZHRoICkgLyA0ICogTWF0aC5tYXgoIDQsIGhlaWdodCApIC8gNCAqIGJsb2NrQnl0ZXM7XHJcblx0XHRcdFx0dmFyIGJ5dGVBcnJheSA9IG5ldyBVaW50OEFycmF5KCBidWZmZXIsIGRhdGFPZmZzZXQsIGRhdGFMZW5ndGggKTtcclxuXHJcblx0XHRcdFx0dmFyIG1pcG1hcCA9IHsgXCJkYXRhXCI6IGJ5dGVBcnJheSwgXCJ3aWR0aFwiOiB3aWR0aCwgXCJoZWlnaHRcIjogaGVpZ2h0IH07XHJcblx0XHRcdFx0ZGRzLm1pcG1hcHMucHVzaCggbWlwbWFwICk7XHJcblxyXG5cdFx0XHRcdGRhdGFPZmZzZXQgKz0gZGF0YUxlbmd0aDtcclxuXHJcblx0XHRcdFx0d2lkdGggPSBNYXRoLm1heCggd2lkdGggKiAwLjUsIDEgKTtcclxuXHRcdFx0XHRoZWlnaHQgPSBNYXRoLm1heCggaGVpZ2h0ICogMC41LCAxICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR3aWR0aCA9IGRkcy53aWR0aDtcclxuXHRcdFx0aGVpZ2h0ID0gZGRzLmhlaWdodDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGRkcztcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0Tm9ybWFsTWFwOiBmdW5jdGlvbiAoIGltYWdlLCBkZXB0aCApIHtcclxuXHJcblx0XHQvLyBBZGFwdGVkIGZyb20gaHR0cDovL3d3dy5wYXVsYnJ1bnQuY28udWsvbGFiL2hlaWdodG5vcm1hbC9cclxuXHJcblx0XHR2YXIgY3Jvc3MgPSBmdW5jdGlvbiAoIGEsIGIgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gWyBhWyAxIF0gKiBiWyAyIF0gLSBhWyAyIF0gKiBiWyAxIF0sIGFbIDIgXSAqIGJbIDAgXSAtIGFbIDAgXSAqIGJbIDIgXSwgYVsgMCBdICogYlsgMSBdIC0gYVsgMSBdICogYlsgMCBdIF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzdWJ0cmFjdCA9IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcblx0XHRcdHJldHVybiBbIGFbIDAgXSAtIGJbIDAgXSwgYVsgMSBdIC0gYlsgMSBdLCBhWyAyIF0gLSBiWyAyIF0gXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG5vcm1hbGl6ZSA9IGZ1bmN0aW9uICggYSApIHtcclxuXHJcblx0XHRcdHZhciBsID0gTWF0aC5zcXJ0KCBhWyAwIF0gKiBhWyAwIF0gKyBhWyAxIF0gKiBhWyAxIF0gKyBhWyAyIF0gKiBhWyAyIF0gKTtcclxuXHRcdFx0cmV0dXJuIFsgYVsgMCBdIC8gbCwgYVsgMSBdIC8gbCwgYVsgMiBdIC8gbCBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRkZXB0aCA9IGRlcHRoIHwgMTtcclxuXHJcblx0XHR2YXIgd2lkdGggPSBpbWFnZS53aWR0aDtcclxuXHRcdHZhciBoZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XHJcblxyXG5cdFx0dmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XHJcblx0XHRjYW52YXMud2lkdGggPSB3aWR0aDtcclxuXHRcdGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG5cdFx0dmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xyXG5cdFx0Y29udGV4dC5kcmF3SW1hZ2UoIGltYWdlLCAwLCAwICk7XHJcblxyXG5cdFx0dmFyIGRhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSggMCwgMCwgd2lkdGgsIGhlaWdodCApLmRhdGE7XHJcblx0XHR2YXIgaW1hZ2VEYXRhID0gY29udGV4dC5jcmVhdGVJbWFnZURhdGEoIHdpZHRoLCBoZWlnaHQgKTtcclxuXHRcdHZhciBvdXRwdXQgPSBpbWFnZURhdGEuZGF0YTtcclxuXHJcblx0XHRmb3IgKCB2YXIgeCA9IDA7IHggPCB3aWR0aDsgeCArKyApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciB5ID0gMDsgeSA8IGhlaWdodDsgeSArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGx5ID0geSAtIDEgPCAwID8gMCA6IHkgLSAxO1xyXG5cdFx0XHRcdHZhciB1eSA9IHkgKyAxID4gaGVpZ2h0IC0gMSA/IGhlaWdodCAtIDEgOiB5ICsgMTtcclxuXHRcdFx0XHR2YXIgbHggPSB4IC0gMSA8IDAgPyAwIDogeCAtIDE7XHJcblx0XHRcdFx0dmFyIHV4ID0geCArIDEgPiB3aWR0aCAtIDEgPyB3aWR0aCAtIDEgOiB4ICsgMTtcclxuXHJcblx0XHRcdFx0dmFyIHBvaW50cyA9IFtdO1xyXG5cdFx0XHRcdHZhciBvcmlnaW4gPSBbIDAsIDAsIGRhdGFbICggeSAqIHdpZHRoICsgeCApICogNCBdIC8gMjU1ICogZGVwdGggXTtcclxuXHRcdFx0XHRwb2ludHMucHVzaCggWyAtIDEsIDAsIGRhdGFbICggeSAqIHdpZHRoICsgbHggKSAqIDQgXSAvIDI1NSAqIGRlcHRoIF0gKTtcclxuXHRcdFx0XHRwb2ludHMucHVzaCggWyAtIDEsIC0gMSwgZGF0YVsgKCBseSAqIHdpZHRoICsgbHggKSAqIDQgXSAvIDI1NSAqIGRlcHRoIF0gKTtcclxuXHRcdFx0XHRwb2ludHMucHVzaCggWyAwLCAtIDEsIGRhdGFbICggbHkgKiB3aWR0aCArIHggKSAqIDQgXSAvIDI1NSAqIGRlcHRoIF0gKTtcclxuXHRcdFx0XHRwb2ludHMucHVzaCggWyAgMSwgLSAxLCBkYXRhWyAoIGx5ICogd2lkdGggKyB1eCApICogNCBdIC8gMjU1ICogZGVwdGggXSApO1xyXG5cdFx0XHRcdHBvaW50cy5wdXNoKCBbIDEsIDAsIGRhdGFbICggeSAqIHdpZHRoICsgdXggKSAqIDQgXSAvIDI1NSAqIGRlcHRoIF0gKTtcclxuXHRcdFx0XHRwb2ludHMucHVzaCggWyAxLCAxLCBkYXRhWyAoIHV5ICogd2lkdGggKyB1eCApICogNCBdIC8gMjU1ICogZGVwdGggXSApO1xyXG5cdFx0XHRcdHBvaW50cy5wdXNoKCBbIDAsIDEsIGRhdGFbICggdXkgKiB3aWR0aCArIHggKSAqIDQgXSAvIDI1NSAqIGRlcHRoIF0gKTtcclxuXHRcdFx0XHRwb2ludHMucHVzaCggWyAtIDEsIDEsIGRhdGFbICggdXkgKiB3aWR0aCArIGx4ICkgKiA0IF0gLyAyNTUgKiBkZXB0aCBdICk7XHJcblxyXG5cdFx0XHRcdHZhciBub3JtYWxzID0gW107XHJcblx0XHRcdFx0dmFyIG51bV9wb2ludHMgPSBwb2ludHMubGVuZ3RoO1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBudW1fcG9pbnRzOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciB2MSA9IHBvaW50c1sgaSBdO1xyXG5cdFx0XHRcdFx0dmFyIHYyID0gcG9pbnRzWyAoIGkgKyAxICkgJSBudW1fcG9pbnRzIF07XHJcblx0XHRcdFx0XHR2MSA9IHN1YnRyYWN0KCB2MSwgb3JpZ2luICk7XHJcblx0XHRcdFx0XHR2MiA9IHN1YnRyYWN0KCB2Miwgb3JpZ2luICk7XHJcblx0XHRcdFx0XHRub3JtYWxzLnB1c2goIG5vcm1hbGl6ZSggY3Jvc3MoIHYxLCB2MiApICkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR2YXIgbm9ybWFsID0gWyAwLCAwLCAwIF07XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG5vcm1hbHMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbFsgMCBdICs9IG5vcm1hbHNbIGkgXVsgMCBdO1xyXG5cdFx0XHRcdFx0bm9ybWFsWyAxIF0gKz0gbm9ybWFsc1sgaSBdWyAxIF07XHJcblx0XHRcdFx0XHRub3JtYWxbIDIgXSArPSBub3JtYWxzWyBpIF1bIDIgXTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRub3JtYWxbIDAgXSAvPSBub3JtYWxzLmxlbmd0aDtcclxuXHRcdFx0XHRub3JtYWxbIDEgXSAvPSBub3JtYWxzLmxlbmd0aDtcclxuXHRcdFx0XHRub3JtYWxbIDIgXSAvPSBub3JtYWxzLmxlbmd0aDtcclxuXHJcblx0XHRcdFx0dmFyIGlkeCA9ICggeSAqIHdpZHRoICsgeCApICogNDtcclxuXHJcblx0XHRcdFx0b3V0cHV0WyBpZHggXSA9ICggKCBub3JtYWxbIDAgXSArIDEuMCApIC8gMi4wICogMjU1ICkgfCAwO1xyXG5cdFx0XHRcdG91dHB1dFsgaWR4ICsgMSBdID0gKCAoIG5vcm1hbFsgMSBdICsgMS4wICkgLyAyLjAgKiAyNTUgKSB8IDA7XHJcblx0XHRcdFx0b3V0cHV0WyBpZHggKyAyIF0gPSAoIG5vcm1hbFsgMiBdICogMjU1ICkgfCAwO1xyXG5cdFx0XHRcdG91dHB1dFsgaWR4ICsgMyBdID0gMjU1O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRjb250ZXh0LnB1dEltYWdlRGF0YSggaW1hZ2VEYXRhLCAwLCAwICk7XHJcblxyXG5cdFx0cmV0dXJuIGNhbnZhcztcclxuXHJcblx0fSxcclxuXHJcblx0Z2VuZXJhdGVEYXRhVGV4dHVyZTogZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0LCBjb2xvciApIHtcclxuXHJcblx0XHR2YXIgc2l6ZSA9IHdpZHRoICogaGVpZ2h0O1xyXG5cdFx0dmFyIGRhdGEgPSBuZXcgVWludDhBcnJheSggMyAqIHNpemUgKTtcclxuXHJcblx0XHR2YXIgciA9IE1hdGguZmxvb3IoIGNvbG9yLnIgKiAyNTUgKTtcclxuXHRcdHZhciBnID0gTWF0aC5mbG9vciggY29sb3IuZyAqIDI1NSApO1xyXG5cdFx0dmFyIGIgPSBNYXRoLmZsb29yKCBjb2xvci5iICogMjU1ICk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSArKyApIHtcclxuXHJcblx0XHRcdGRhdGFbIGkgKiAzIF0gXHQgID0gcjtcclxuXHRcdFx0ZGF0YVsgaSAqIDMgKyAxIF0gPSBnO1xyXG5cdFx0XHRkYXRhWyBpICogMyArIDIgXSA9IGI7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0ZXh0dXJlID0gbmV3IFRIUkVFLkRhdGFUZXh0dXJlKCBkYXRhLCB3aWR0aCwgaGVpZ2h0LCBUSFJFRS5SR0JGb3JtYXQgKTtcclxuXHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdHJldHVybiB0ZXh0dXJlO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5TY2VuZVV0aWxzID0ge1xyXG5cclxuXHRjcmVhdGVNdWx0aU1hdGVyaWFsT2JqZWN0OiBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbHMgKSB7XHJcblxyXG5cdFx0dmFyIGdyb3VwID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbWF0ZXJpYWxzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRncm91cC5hZGQoIG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWxzWyBpIF0gKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZ3JvdXA7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRldGFjaCA6IGZ1bmN0aW9uICggY2hpbGQsIHBhcmVudCwgc2NlbmUgKSB7XHJcblxyXG5cdFx0Y2hpbGQuYXBwbHlNYXRyaXgoIHBhcmVudC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0cGFyZW50LnJlbW92ZSggY2hpbGQgKTtcclxuXHRcdHNjZW5lLmFkZCggY2hpbGQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0YXR0YWNoOiBmdW5jdGlvbiAoIGNoaWxkLCBzY2VuZSwgcGFyZW50ICkge1xyXG5cclxuXHRcdHZhciBtYXRyaXhXb3JsZEludmVyc2UgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cdFx0bWF0cml4V29ybGRJbnZlcnNlLmdldEludmVyc2UoIHBhcmVudC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0Y2hpbGQuYXBwbHlNYXRyaXgoIG1hdHJpeFdvcmxkSW52ZXJzZSApO1xyXG5cclxuXHRcdHNjZW5lLnJlbW92ZSggY2hpbGQgKTtcclxuXHRcdHBhcmVudC5hZGQoIGNoaWxkICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcbi8qKlxyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqXHJcbiAqIEZvciBUZXh0IG9wZXJhdGlvbnMgaW4gdGhyZWUuanMgKFNlZSBUZXh0R2VvbWV0cnkpXHJcbiAqXHJcbiAqIEl0IHVzZXMgdGVjaG5pcXVlcyB1c2VkIGluOlxyXG4gKlxyXG4gKiBcdHR5cGVmYWNlLmpzIGFuZCBjYW52YXN0ZXh0XHJcbiAqIFx0XHRGb3IgY29udmVydGluZyBmb250cyBhbmQgcmVuZGVyaW5nIHdpdGggamF2YXNjcmlwdFxyXG4gKlx0XHRodHRwOi8vdHlwZWZhY2UubmVvY3JhY3kub3JnXHJcbiAqXHJcbiAqXHRUcmlhbmd1bGF0aW9uIHBvcnRlZCBmcm9tIEFTM1xyXG4gKlx0XHRTaW1wbGUgUG9seWdvbiBUcmlhbmd1bGF0aW9uXHJcbiAqXHRcdGh0dHA6Ly9hY3Rpb25zbmlwcGV0LmNvbS8/cD0xNDYyXHJcbiAqXHJcbiAqIFx0QSBNZXRob2QgdG8gdHJpYW5ndWxhdGUgc2hhcGVzIHdpdGggaG9sZXNcclxuICpcdFx0aHR0cDovL3d3dy5zYWtyaS5uZXQvYmxvZy8yMDA5LzA2LzEyL2FuLWFwcHJvYWNoLXRvLXRyaWFuZ3VsYXRpbmctcG9seWdvbnMtd2l0aC1ob2xlcy9cclxuICpcclxuICovXHJcblxyXG5USFJFRS5Gb250VXRpbHMgPSB7XHJcblxyXG5cdGZhY2VzIDoge30sXHJcblxyXG5cdC8vIEp1c3QgZm9yIG5vdy4gZmFjZVt3ZWlnaHRdW3N0eWxlXVxyXG5cclxuXHRmYWNlIDogXCJoZWx2ZXRpa2VyXCIsXHJcblx0d2VpZ2h0OiBcIm5vcm1hbFwiLFxyXG5cdHN0eWxlIDogXCJub3JtYWxcIixcclxuXHRzaXplIDogMTUwLFxyXG5cdGRpdmlzaW9ucyA6IDEwLFxyXG5cclxuXHRnZXRGYWNlIDogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZmFjZXNbIHRoaXMuZmFjZSBdWyB0aGlzLndlaWdodCBdWyB0aGlzLnN0eWxlIF07XHJcblxyXG5cdH0sXHJcblxyXG5cdGxvYWRGYWNlIDogZnVuY3Rpb24oIGRhdGEgKSB7XHJcblxyXG5cdFx0dmFyIGZhbWlseSA9IGRhdGEuZmFtaWx5TmFtZS50b0xvd2VyQ2FzZSgpO1xyXG5cclxuXHRcdHZhciBUaHJlZUZvbnQgPSB0aGlzO1xyXG5cclxuXHRcdFRocmVlRm9udC5mYWNlc1sgZmFtaWx5IF0gPSBUaHJlZUZvbnQuZmFjZXNbIGZhbWlseSBdIHx8IHt9O1xyXG5cclxuXHRcdFRocmVlRm9udC5mYWNlc1sgZmFtaWx5IF1bIGRhdGEuY3NzRm9udFdlaWdodCBdID0gVGhyZWVGb250LmZhY2VzWyBmYW1pbHkgXVsgZGF0YS5jc3NGb250V2VpZ2h0IF0gfHwge307XHJcblx0XHRUaHJlZUZvbnQuZmFjZXNbIGZhbWlseSBdWyBkYXRhLmNzc0ZvbnRXZWlnaHQgXVsgZGF0YS5jc3NGb250U3R5bGUgXSA9IGRhdGE7XHJcblxyXG5cdFx0dmFyIGZhY2UgPSBUaHJlZUZvbnQuZmFjZXNbIGZhbWlseSBdWyBkYXRhLmNzc0ZvbnRXZWlnaHQgXVsgZGF0YS5jc3NGb250U3R5bGUgXSA9IGRhdGE7XHJcblxyXG5cdFx0cmV0dXJuIGRhdGE7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRyYXdUZXh0IDogZnVuY3Rpb24oIHRleHQgKSB7XHJcblxyXG5cdFx0dmFyIGNoYXJhY3RlclB0cyA9IFtdLCBhbGxQdHMgPSBbXTtcclxuXHJcblx0XHQvLyBSZW5kZXJUZXh0XHJcblxyXG5cdFx0dmFyIGksIHAsXHJcblx0XHRcdGZhY2UgPSB0aGlzLmdldEZhY2UoKSxcclxuXHRcdFx0c2NhbGUgPSB0aGlzLnNpemUgLyBmYWNlLnJlc29sdXRpb24sXHJcblx0XHRcdG9mZnNldCA9IDAsXHJcblx0XHRcdGNoYXJzID0gU3RyaW5nKCB0ZXh0ICkuc3BsaXQoICcnICksXHJcblx0XHRcdGxlbmd0aCA9IGNoYXJzLmxlbmd0aDtcclxuXHJcblx0XHR2YXIgZm9udFBhdGhzID0gW107XHJcblxyXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgcGF0aCA9IG5ldyBUSFJFRS5QYXRoKCk7XHJcblxyXG5cdFx0XHR2YXIgcmV0ID0gdGhpcy5leHRyYWN0R2x5cGhQb2ludHMoIGNoYXJzWyBpIF0sIGZhY2UsIHNjYWxlLCBvZmZzZXQsIHBhdGggKTtcclxuXHRcdFx0b2Zmc2V0ICs9IHJldC5vZmZzZXQ7XHJcblxyXG5cdFx0XHRmb250UGF0aHMucHVzaCggcmV0LnBhdGggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZ2V0IHRoZSB3aWR0aFxyXG5cclxuXHRcdHZhciB3aWR0aCA9IG9mZnNldCAvIDI7XHJcblx0XHQvL1xyXG5cdFx0Ly8gZm9yICggcCA9IDA7IHAgPCBhbGxQdHMubGVuZ3RoOyBwKysgKSB7XHJcblx0XHQvL1xyXG5cdFx0Ly8gXHRhbGxQdHNbIHAgXS54IC09IHdpZHRoO1xyXG5cdFx0Ly9cclxuXHRcdC8vIH1cclxuXHJcblx0XHQvL3ZhciBleHRyYWN0ID0gdGhpcy5leHRyYWN0UG9pbnRzKCBhbGxQdHMsIGNoYXJhY3RlclB0cyApO1xyXG5cdFx0Ly9leHRyYWN0LmNvbnRvdXIgPSBhbGxQdHM7XHJcblxyXG5cdFx0Ly9leHRyYWN0LnBhdGhzID0gZm9udFBhdGhzO1xyXG5cdFx0Ly9leHRyYWN0Lm9mZnNldCA9IHdpZHRoO1xyXG5cclxuXHRcdHJldHVybiB7IHBhdGhzIDogZm9udFBhdGhzLCBvZmZzZXQgOiB3aWR0aCB9O1xyXG5cclxuXHR9LFxyXG5cclxuXHJcblxyXG5cclxuXHRleHRyYWN0R2x5cGhQb2ludHMgOiBmdW5jdGlvbiggYywgZmFjZSwgc2NhbGUsIG9mZnNldCwgcGF0aCApIHtcclxuXHJcblx0XHR2YXIgcHRzID0gW107XHJcblxyXG5cdFx0dmFyIGksIGkyLCBkaXZpc2lvbnMsXHJcblx0XHRcdG91dGxpbmUsIGFjdGlvbiwgbGVuZ3RoLFxyXG5cdFx0XHRzY2FsZVgsIHNjYWxlWSxcclxuXHRcdFx0eCwgeSwgY3B4LCBjcHksIGNweDAsIGNweTAsIGNweDEsIGNweTEsIGNweDIsIGNweTIsXHJcblx0XHRcdGxhc3RlLFxyXG5cdFx0XHRnbHlwaCA9IGZhY2UuZ2x5cGhzWyBjIF0gfHwgZmFjZS5nbHlwaHNbICc/JyBdO1xyXG5cclxuXHRcdGlmICggIWdseXBoICkgcmV0dXJuO1xyXG5cclxuXHRcdGlmICggZ2x5cGgubyApIHtcclxuXHJcblx0XHRcdG91dGxpbmUgPSBnbHlwaC5fY2FjaGVkT3V0bGluZSB8fCAoIGdseXBoLl9jYWNoZWRPdXRsaW5lID0gZ2x5cGguby5zcGxpdCggJyAnICkgKTtcclxuXHRcdFx0bGVuZ3RoID0gb3V0bGluZS5sZW5ndGg7XHJcblxyXG5cdFx0XHRzY2FsZVggPSBzY2FsZTtcclxuXHRcdFx0c2NhbGVZID0gc2NhbGU7XHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbmd0aDsgKSB7XHJcblxyXG5cdFx0XHRcdGFjdGlvbiA9IG91dGxpbmVbIGkgKysgXTtcclxuXHJcblx0XHRcdFx0Ly9jb25zb2xlLmxvZyggYWN0aW9uICk7XHJcblxyXG5cdFx0XHRcdHN3aXRjaCggYWN0aW9uICkge1xyXG5cclxuXHRcdFx0XHRjYXNlICdtJzpcclxuXHJcblx0XHRcdFx0XHQvLyBNb3ZlIFRvXHJcblxyXG5cdFx0XHRcdFx0eCA9IG91dGxpbmVbIGkrKyBdICogc2NhbGVYICsgb2Zmc2V0O1xyXG5cdFx0XHRcdFx0eSA9IG91dGxpbmVbIGkrKyBdICogc2NhbGVZO1xyXG5cclxuXHRcdFx0XHRcdHBhdGgubW92ZVRvKCB4LCB5ICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnbCc6XHJcblxyXG5cdFx0XHRcdFx0Ly8gTGluZSBUb1xyXG5cclxuXHRcdFx0XHRcdHggPSBvdXRsaW5lWyBpKysgXSAqIHNjYWxlWCArIG9mZnNldDtcclxuXHRcdFx0XHRcdHkgPSBvdXRsaW5lWyBpKysgXSAqIHNjYWxlWTtcclxuXHRcdFx0XHRcdHBhdGgubGluZVRvKHgseSk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAncSc6XHJcblxyXG5cdFx0XHRcdFx0Ly8gUXVhZHJhdGljQ3VydmVUb1xyXG5cclxuXHRcdFx0XHRcdGNweCAgPSBvdXRsaW5lWyBpKysgXSAqIHNjYWxlWCArIG9mZnNldDtcclxuXHRcdFx0XHRcdGNweSAgPSBvdXRsaW5lWyBpKysgXSAqIHNjYWxlWTtcclxuXHRcdFx0XHRcdGNweDEgPSBvdXRsaW5lWyBpKysgXSAqIHNjYWxlWCArIG9mZnNldDtcclxuXHRcdFx0XHRcdGNweTEgPSBvdXRsaW5lWyBpKysgXSAqIHNjYWxlWTtcclxuXHJcblx0XHRcdFx0XHRwYXRoLnF1YWRyYXRpY0N1cnZlVG8oY3B4MSwgY3B5MSwgY3B4LCBjcHkpO1xyXG5cclxuXHRcdFx0XHRcdGxhc3RlID0gcHRzWyBwdHMubGVuZ3RoIC0gMSBdO1xyXG5cclxuXHRcdFx0XHRcdGlmICggbGFzdGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjcHgwID0gbGFzdGUueDtcclxuXHRcdFx0XHRcdFx0Y3B5MCA9IGxhc3RlLnk7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCBpMiA9IDEsIGRpdmlzaW9ucyA9IHRoaXMuZGl2aXNpb25zOyBpMiA8PSBkaXZpc2lvbnM7IGkyICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2YXIgdCA9IGkyIC8gZGl2aXNpb25zO1xyXG5cdFx0XHRcdFx0XHRcdHZhciB0eCA9IFRIUkVFLlNoYXBlLlV0aWxzLmIyKCB0LCBjcHgwLCBjcHgxLCBjcHggKTtcclxuXHRcdFx0XHRcdFx0XHR2YXIgdHkgPSBUSFJFRS5TaGFwZS5VdGlscy5iMiggdCwgY3B5MCwgY3B5MSwgY3B5ICk7XHJcblx0XHRcdFx0XHQgIH1cclxuXHJcblx0XHRcdFx0ICB9XHJcblxyXG5cdFx0XHRcdCAgYnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ2InOlxyXG5cclxuXHRcdFx0XHRcdC8vIEN1YmljIEJlemllciBDdXJ2ZVxyXG5cclxuXHRcdFx0XHRcdGNweCAgPSBvdXRsaW5lWyBpKysgXSAqICBzY2FsZVggKyBvZmZzZXQ7XHJcblx0XHRcdFx0XHRjcHkgID0gb3V0bGluZVsgaSsrIF0gKiAgc2NhbGVZO1xyXG5cdFx0XHRcdFx0Y3B4MSA9IG91dGxpbmVbIGkrKyBdICogIHNjYWxlWCArIG9mZnNldDtcclxuXHRcdFx0XHRcdGNweTEgPSBvdXRsaW5lWyBpKysgXSAqIC1zY2FsZVk7XHJcblx0XHRcdFx0XHRjcHgyID0gb3V0bGluZVsgaSsrIF0gKiAgc2NhbGVYICsgb2Zmc2V0O1xyXG5cdFx0XHRcdFx0Y3B5MiA9IG91dGxpbmVbIGkrKyBdICogLXNjYWxlWTtcclxuXHJcblx0XHRcdFx0XHRwYXRoLmJlemllckN1cnZlVG8oIGNweCwgY3B5LCBjcHgxLCBjcHkxLCBjcHgyLCBjcHkyICk7XHJcblxyXG5cdFx0XHRcdFx0bGFzdGUgPSBwdHNbIHB0cy5sZW5ndGggLSAxIF07XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBsYXN0ZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdGNweDAgPSBsYXN0ZS54O1xyXG5cdFx0XHRcdFx0XHRjcHkwID0gbGFzdGUueTtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGkyID0gMSwgZGl2aXNpb25zID0gdGhpcy5kaXZpc2lvbnM7IGkyIDw9IGRpdmlzaW9uczsgaTIgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhciB0ID0gaTIgLyBkaXZpc2lvbnM7XHJcblx0XHRcdFx0XHRcdFx0dmFyIHR4ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjMoIHQsIGNweDAsIGNweDEsIGNweDIsIGNweCApO1xyXG5cdFx0XHRcdFx0XHRcdHZhciB0eSA9IFRIUkVFLlNoYXBlLlV0aWxzLmIzKCB0LCBjcHkwLCBjcHkxLCBjcHkyLCBjcHkgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblxyXG5cclxuXHRcdHJldHVybiB7IG9mZnNldDogZ2x5cGguaGEqc2NhbGUsIHBhdGg6cGF0aH07XHJcblx0fVxyXG5cclxufTtcclxuXHJcblxyXG5USFJFRS5Gb250VXRpbHMuZ2VuZXJhdGVTaGFwZXMgPSBmdW5jdGlvbiggdGV4dCwgcGFyYW1ldGVycyApIHtcclxuXHJcblx0Ly8gUGFyYW1ldGVycyBcclxuXHJcblx0cGFyYW1ldGVycyA9IHBhcmFtZXRlcnMgfHwge307XHJcblxyXG5cdHZhciBzaXplID0gcGFyYW1ldGVycy5zaXplICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnNpemUgOiAxMDA7XHJcblx0dmFyIGN1cnZlU2VnbWVudHMgPSBwYXJhbWV0ZXJzLmN1cnZlU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuY3VydmVTZWdtZW50czogNDtcclxuXHJcblx0dmFyIGZvbnQgPSBwYXJhbWV0ZXJzLmZvbnQgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuZm9udCA6IFwiaGVsdmV0aWtlclwiO1xyXG5cdHZhciB3ZWlnaHQgPSBwYXJhbWV0ZXJzLndlaWdodCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy53ZWlnaHQgOiBcIm5vcm1hbFwiO1xyXG5cdHZhciBzdHlsZSA9IHBhcmFtZXRlcnMuc3R5bGUgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuc3R5bGUgOiBcIm5vcm1hbFwiO1xyXG5cclxuXHRUSFJFRS5Gb250VXRpbHMuc2l6ZSA9IHNpemU7XHJcblx0VEhSRUUuRm9udFV0aWxzLmRpdmlzaW9ucyA9IGN1cnZlU2VnbWVudHM7XHJcblxyXG5cdFRIUkVFLkZvbnRVdGlscy5mYWNlID0gZm9udDtcclxuXHRUSFJFRS5Gb250VXRpbHMud2VpZ2h0ID0gd2VpZ2h0O1xyXG5cdFRIUkVFLkZvbnRVdGlscy5zdHlsZSA9IHN0eWxlO1xyXG5cclxuXHQvLyBHZXQgYSBGb250IGRhdGEganNvbiBvYmplY3RcclxuXHJcblx0dmFyIGRhdGEgPSBUSFJFRS5Gb250VXRpbHMuZHJhd1RleHQoIHRleHQgKTtcclxuXHJcblx0dmFyIHBhdGhzID0gZGF0YS5wYXRocztcclxuXHR2YXIgc2hhcGVzID0gW107XHJcblxyXG5cdGZvciAoIHZhciBwID0gMCwgcGwgPSBwYXRocy5sZW5ndGg7IHAgPCBwbDsgcCArKyApIHtcclxuXHJcblx0XHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSggc2hhcGVzLCBwYXRoc1sgcCBdLnRvU2hhcGVzKCkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gc2hhcGVzO1xyXG5cclxufTtcclxuXHJcblxyXG4vKipcclxuICogVGhpcyBjb2RlIGlzIGEgcXVpY2sgcG9ydCBvZiBjb2RlIHdyaXR0ZW4gaW4gQysrIHdoaWNoIHdhcyBzdWJtaXR0ZWQgdG9cclxuICogZmxpcGNvZGUuY29tIGJ5IEpvaG4gVy4gUmF0Y2xpZmYgIC8vIEp1bHkgMjIsIDIwMDBcclxuICogU2VlIG9yaWdpbmFsIGNvZGUgYW5kIG1vcmUgaW5mb3JtYXRpb24gaGVyZTpcclxuICogaHR0cDovL3d3dy5mbGlwY29kZS5jb20vYXJjaGl2ZXMvRWZmaWNpZW50X1BvbHlnb25fVHJpYW5ndWxhdGlvbi5zaHRtbFxyXG4gKlxyXG4gKiBwb3J0ZWQgdG8gYWN0aW9uc2NyaXB0IGJ5IFpldmFuIFJvc3NlclxyXG4gKiB3d3cuYWN0aW9uc25pcHBldC5jb21cclxuICpcclxuICogcG9ydGVkIHRvIGphdmFzY3JpcHQgYnkgSm9zaHVhIEtvb1xyXG4gKiBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXHJcbiAqXHJcbiAqL1xyXG5cclxuXHJcbiggZnVuY3Rpb24oIG5hbWVzcGFjZSApIHtcclxuXHJcblx0dmFyIEVQU0lMT04gPSAwLjAwMDAwMDAwMDE7XHJcblxyXG5cdC8vIHRha2VzIGluIGFuIGNvbnRvdXIgYXJyYXkgYW5kIHJldHVybnNcclxuXHJcblx0dmFyIHByb2Nlc3MgPSBmdW5jdGlvbiggY29udG91ciwgaW5kaWNlcyApIHtcclxuXHJcblx0XHR2YXIgbiA9IGNvbnRvdXIubGVuZ3RoO1xyXG5cclxuXHRcdGlmICggbiA8IDMgKSByZXR1cm4gbnVsbDtcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gW10sXHJcblx0XHRcdHZlcnRzID0gW10sXHJcblx0XHRcdHZlcnRJbmRpY2VzID0gW107XHJcblxyXG5cdFx0Lyogd2Ugd2FudCBhIGNvdW50ZXItY2xvY2t3aXNlIHBvbHlnb24gaW4gdmVydHMgKi9cclxuXHJcblx0XHR2YXIgdSwgdiwgdztcclxuXHJcblx0XHRpZiAoIGFyZWEoIGNvbnRvdXIgKSA+IDAuMCApIHtcclxuXHJcblx0XHRcdGZvciAoIHYgPSAwOyB2IDwgbjsgdisrICkgdmVydHNbIHYgXSA9IHY7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGZvciAoIHYgPSAwOyB2IDwgbjsgdisrICkgdmVydHNbIHYgXSA9ICggbiAtIDEgKSAtIHY7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBudiA9IG47XHJcblxyXG5cdFx0LyogIHJlbW92ZSBudiAtIDIgdmVydGljZXMsIGNyZWF0aW5nIDEgdHJpYW5nbGUgZXZlcnkgdGltZSAqL1xyXG5cclxuXHRcdHZhciBjb3VudCA9IDIgKiBudjsgICAvKiBlcnJvciBkZXRlY3Rpb24gKi9cclxuXHJcblx0XHRmb3IoIHYgPSBudiAtIDE7IG52ID4gMjsgKSB7XHJcblxyXG5cdFx0XHQvKiBpZiB3ZSBsb29wLCBpdCBpcyBwcm9iYWJseSBhIG5vbi1zaW1wbGUgcG9seWdvbiAqL1xyXG5cclxuXHRcdFx0aWYgKCAoIGNvdW50LS0gKSA8PSAwICkge1xyXG5cclxuXHRcdFx0XHQvLyoqIFRyaWFuZ3VsYXRlOiBFUlJPUiAtIHByb2JhYmxlIGJhZCBwb2x5Z29uIVxyXG5cclxuXHRcdFx0XHQvL3Rocm93ICggXCJXYXJuaW5nLCB1bmFibGUgdG8gdHJpYW5ndWxhdGUgcG9seWdvbiFcIiApO1xyXG5cdFx0XHRcdC8vcmV0dXJuIG51bGw7XHJcblx0XHRcdFx0Ly8gU29tZXRpbWVzIHdhcm5pbmcgaXMgZmluZSwgZXNwZWNpYWxseSBwb2x5Z29ucyBhcmUgdHJpYW5ndWxhdGVkIGluIHJldmVyc2UuXHJcblx0XHRcdFx0Y29uc29sZS5sb2coIFwiV2FybmluZywgdW5hYmxlIHRvIHRyaWFuZ3VsYXRlIHBvbHlnb24hXCIgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBpbmRpY2VzICkgcmV0dXJuIHZlcnRJbmRpY2VzO1xyXG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvKiB0aHJlZSBjb25zZWN1dGl2ZSB2ZXJ0aWNlcyBpbiBjdXJyZW50IHBvbHlnb24sIDx1LHYsdz4gKi9cclxuXHJcblx0XHRcdHUgPSB2OyBcdCBcdGlmICggbnYgPD0gdSApIHUgPSAwOyAgICAgLyogcHJldmlvdXMgKi9cclxuXHRcdFx0diA9IHUgKyAxOyAgaWYgKCBudiA8PSB2ICkgdiA9IDA7ICAgICAvKiBuZXcgdiAgICAqL1xyXG5cdFx0XHR3ID0gdiArIDE7ICBpZiAoIG52IDw9IHcgKSB3ID0gMDsgICAgIC8qIG5leHQgICAgICovXHJcblxyXG5cdFx0XHRpZiAoIHNuaXAoIGNvbnRvdXIsIHUsIHYsIHcsIG52LCB2ZXJ0cyApICkge1xyXG5cclxuXHRcdFx0XHR2YXIgYSwgYiwgYywgcywgdDtcclxuXHJcblx0XHRcdFx0LyogdHJ1ZSBuYW1lcyBvZiB0aGUgdmVydGljZXMgKi9cclxuXHJcblx0XHRcdFx0YSA9IHZlcnRzWyB1IF07XHJcblx0XHRcdFx0YiA9IHZlcnRzWyB2IF07XHJcblx0XHRcdFx0YyA9IHZlcnRzWyB3IF07XHJcblxyXG5cdFx0XHRcdC8qIG91dHB1dCBUcmlhbmdsZSAqL1xyXG5cclxuXHRcdFx0XHRyZXN1bHQucHVzaCggWyBjb250b3VyWyBhIF0sXHJcblx0XHRcdFx0XHRjb250b3VyWyBiIF0sXHJcblx0XHRcdFx0XHRjb250b3VyWyBjIF0gXSApO1xyXG5cclxuXHJcblx0XHRcdFx0dmVydEluZGljZXMucHVzaCggWyB2ZXJ0c1sgdSBdLCB2ZXJ0c1sgdiBdLCB2ZXJ0c1sgdyBdIF0gKTtcclxuXHJcblx0XHRcdFx0LyogcmVtb3ZlIHYgZnJvbSB0aGUgcmVtYWluaW5nIHBvbHlnb24gKi9cclxuXHJcblx0XHRcdFx0Zm9yKCBzID0gdiwgdCA9IHYgKyAxOyB0IDwgbnY7IHMrKywgdCsrICkge1xyXG5cclxuXHRcdFx0XHRcdHZlcnRzWyBzIF0gPSB2ZXJ0c1sgdCBdO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdG52LS07XHJcblxyXG5cdFx0XHRcdC8qIHJlc2V0IGVycm9yIGRldGVjdGlvbiBjb3VudGVyICovXHJcblxyXG5cdFx0XHRcdGNvdW50ID0gMiAqIG52O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGluZGljZXMgKSByZXR1cm4gdmVydEluZGljZXM7XHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBjYWxjdWxhdGUgYXJlYSBvZiB0aGUgY29udG91ciBwb2x5Z29uXHJcblxyXG5cdHZhciBhcmVhID0gZnVuY3Rpb24gKCBjb250b3VyICkge1xyXG5cclxuXHRcdHZhciBuID0gY29udG91ci5sZW5ndGg7XHJcblx0XHR2YXIgYSA9IDAuMDtcclxuXHJcblx0XHRmb3IoIHZhciBwID0gbiAtIDEsIHEgPSAwOyBxIDwgbjsgcCA9IHErKyApIHtcclxuXHJcblx0XHRcdGEgKz0gY29udG91clsgcCBdLnggKiBjb250b3VyWyBxIF0ueSAtIGNvbnRvdXJbIHEgXS54ICogY29udG91clsgcCBdLnk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBhICogMC41O1xyXG5cclxuXHR9O1xyXG5cclxuXHR2YXIgc25pcCA9IGZ1bmN0aW9uICggY29udG91ciwgdSwgdiwgdywgbiwgdmVydHMgKSB7XHJcblxyXG5cdFx0dmFyIHA7XHJcblx0XHR2YXIgYXgsIGF5LCBieCwgYnk7XHJcblx0XHR2YXIgY3gsIGN5LCBweCwgcHk7XHJcblxyXG5cdFx0YXggPSBjb250b3VyWyB2ZXJ0c1sgdSBdIF0ueDtcclxuXHRcdGF5ID0gY29udG91clsgdmVydHNbIHUgXSBdLnk7XHJcblxyXG5cdFx0YnggPSBjb250b3VyWyB2ZXJ0c1sgdiBdIF0ueDtcclxuXHRcdGJ5ID0gY29udG91clsgdmVydHNbIHYgXSBdLnk7XHJcblxyXG5cdFx0Y3ggPSBjb250b3VyWyB2ZXJ0c1sgdyBdIF0ueDtcclxuXHRcdGN5ID0gY29udG91clsgdmVydHNbIHcgXSBdLnk7XHJcblxyXG5cdFx0aWYgKCBFUFNJTE9OID4gKCgoYngtYXgpKihjeS1heSkpIC0gKChieS1heSkqKGN4LWF4KSkpICkgcmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdHZhciBhWCwgYVksIGJYLCBiWSwgY1gsIGNZO1xyXG5cdFx0dmFyIGFweCwgYXB5LCBicHgsIGJweSwgY3B4LCBjcHk7XHJcblx0XHR2YXIgY0NST1NTYXAsIGJDUk9TU2NwLCBhQ1JPU1NicDtcclxuXHJcblx0XHRhWCA9IGN4IC0gYng7ICBhWSA9IGN5IC0gYnk7XHJcblx0XHRiWCA9IGF4IC0gY3g7ICBiWSA9IGF5IC0gY3k7XHJcblx0XHRjWCA9IGJ4IC0gYXg7ICBjWSA9IGJ5IC0gYXk7XHJcblxyXG5cdFx0Zm9yICggcCA9IDA7IHAgPCBuOyBwKysgKSB7XHJcblxyXG5cdFx0XHRpZiggKHAgPT09IHUpIHx8IChwID09PSB2KSB8fCAocCA9PT0gdykgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdHB4ID0gY29udG91clsgdmVydHNbIHAgXSBdLnhcclxuXHRcdFx0cHkgPSBjb250b3VyWyB2ZXJ0c1sgcCBdIF0ueVxyXG5cclxuXHRcdFx0YXB4ID0gcHggLSBheDsgIGFweSA9IHB5IC0gYXk7XHJcblx0XHRcdGJweCA9IHB4IC0gYng7ICBicHkgPSBweSAtIGJ5O1xyXG5cdFx0XHRjcHggPSBweCAtIGN4OyAgY3B5ID0gcHkgLSBjeTtcclxuXHJcblx0XHRcdC8vIHNlZSBpZiBwIGlzIGluc2lkZSB0cmlhbmdsZSBhYmNcclxuXHJcblx0XHRcdGFDUk9TU2JwID0gYVgqYnB5IC0gYVkqYnB4O1xyXG5cdFx0XHRjQ1JPU1NhcCA9IGNYKmFweSAtIGNZKmFweDtcclxuXHRcdFx0YkNST1NTY3AgPSBiWCpjcHkgLSBiWSpjcHg7XHJcblxyXG5cdFx0XHRpZiAoIChhQ1JPU1NicCA+PSAwLjApICYmIChiQ1JPU1NjcCA+PSAwLjApICYmIChjQ1JPU1NhcCA+PSAwLjApICkgcmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0fTtcclxuXHJcblxyXG5cdG5hbWVzcGFjZS5Ucmlhbmd1bGF0ZSA9IHByb2Nlc3M7XHJcblx0bmFtZXNwYWNlLlRyaWFuZ3VsYXRlLmFyZWEgPSBhcmVhO1xyXG5cclxuXHRyZXR1cm4gbmFtZXNwYWNlO1xyXG5cclxufSkoVEhSRUUuRm9udFV0aWxzKTtcclxuXHJcbi8vIFRvIHVzZSB0aGUgdHlwZWZhY2UuanMgZmFjZSBmaWxlcywgaG9vayB1cCB0aGUgQVBJXHJcbnNlbGYuX3R5cGVmYWNlX2pzID0geyBmYWNlczogVEhSRUUuRm9udFV0aWxzLmZhY2VzLCBsb2FkRmFjZTogVEhSRUUuRm9udFV0aWxzLmxvYWRGYWNlIH07LyoqXHJcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcclxuICogRXh0ZW5zaWJsZSBjdXJ2ZSBvYmplY3RcclxuICpcclxuICogU29tZSBjb21tb24gb2YgQ3VydmUgbWV0aG9kc1xyXG4gKiAuZ2V0UG9pbnQodCksIGdldFRhbmdlbnQodClcclxuICogLmdldFBvaW50QXQodSksIGdldFRhZ2VudEF0KHUpXHJcbiAqIC5nZXRQb2ludHMoKSwgLmdldFNwYWNlZFBvaW50cygpXHJcbiAqIC5nZXRMZW5ndGgoKVxyXG4gKiAudXBkYXRlQXJjTGVuZ3RocygpXHJcbiAqXHJcbiAqIFRoaXMgZmlsZSBjb250YWlucyBmb2xsb3dpbmcgY2xhc3NlczpcclxuICpcclxuICogLS0gMmQgY2xhc3NlcyAtLVxyXG4gKiBUSFJFRS5DdXJ2ZVxyXG4gKiBUSFJFRS5MaW5lQ3VydmVcclxuICogVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmVcclxuICogVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZVxyXG4gKiBUSFJFRS5TcGxpbmVDdXJ2ZVxyXG4gKiBUSFJFRS5BcmNDdXJ2ZVxyXG4gKiBUSFJFRS5FbGxpcHNlQ3VydmVcclxuICpcclxuICogLS0gM2QgY2xhc3NlcyAtLVxyXG4gKiBUSFJFRS5MaW5lQ3VydmUzXHJcbiAqIFRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlM1xyXG4gKiBUSFJFRS5DdWJpY0JlemllckN1cnZlM1xyXG4gKiBUSFJFRS5TcGxpbmVDdXJ2ZTNcclxuICogVEhSRUUuQ2xvc2VkU3BsaW5lQ3VydmUzXHJcbiAqXHJcbiAqIEEgc2VyaWVzIG9mIGN1cnZlcyBjYW4gYmUgcmVwcmVzZW50ZWQgYXMgYSBUSFJFRS5DdXJ2ZVBhdGhcclxuICpcclxuICoqL1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRBYnN0cmFjdCBDdXJ2ZSBiYXNlIGNsYXNzXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblRIUkVFLkN1cnZlID0gZnVuY3Rpb24gKCkge1xyXG5cclxufTtcclxuXHJcbi8vIFZpcnR1YWwgYmFzZSBjbGFzcyBtZXRob2QgdG8gb3ZlcndyaXRlIGFuZCBpbXBsZW1lbnQgaW4gc3ViY2xhc3Nlc1xyXG4vL1x0LSB0IFswIC4uIDFdXHJcblxyXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQgKSB7XHJcblxyXG5cdGNvbnNvbGUubG9nKCBcIldhcm5pbmcsIGdldFBvaW50KCkgbm90IGltcGxlbWVudGVkIVwiICk7XHJcblx0cmV0dXJuIG51bGw7XHJcblxyXG59O1xyXG5cclxuLy8gR2V0IHBvaW50IGF0IHJlbGF0aXZlIHBvc2l0aW9uIGluIGN1cnZlIGFjY29yZGluZyB0byBhcmMgbGVuZ3RoXHJcbi8vIC0gdSBbMCAuLiAxXVxyXG5cclxuVEhSRUUuQ3VydmUucHJvdG90eXBlLmdldFBvaW50QXQgPSBmdW5jdGlvbiAoIHUgKSB7XHJcblxyXG5cdHZhciB0ID0gdGhpcy5nZXRVdG9UbWFwcGluZyggdSApO1xyXG5cdHJldHVybiB0aGlzLmdldFBvaW50KCB0ICk7XHJcblxyXG59O1xyXG5cclxuLy8gR2V0IHNlcXVlbmNlIG9mIHBvaW50cyB1c2luZyBnZXRQb2ludCggdCApXHJcblxyXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnRzID0gZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XHJcblxyXG5cdGlmICggIWRpdmlzaW9ucyApIGRpdmlzaW9ucyA9IDU7XHJcblxyXG5cdHZhciBkLCBwdHMgPSBbXTtcclxuXHJcblx0Zm9yICggZCA9IDA7IGQgPD0gZGl2aXNpb25zOyBkICsrICkge1xyXG5cclxuXHRcdHB0cy5wdXNoKCB0aGlzLmdldFBvaW50KCBkIC8gZGl2aXNpb25zICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcHRzO1xyXG5cclxufTtcclxuXHJcbi8vIEdldCBzZXF1ZW5jZSBvZiBwb2ludHMgdXNpbmcgZ2V0UG9pbnRBdCggdSApXHJcblxyXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0U3BhY2VkUG9pbnRzID0gZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XHJcblxyXG5cdGlmICggIWRpdmlzaW9ucyApIGRpdmlzaW9ucyA9IDU7XHJcblxyXG5cdHZhciBkLCBwdHMgPSBbXTtcclxuXHJcblx0Zm9yICggZCA9IDA7IGQgPD0gZGl2aXNpb25zOyBkICsrICkge1xyXG5cclxuXHRcdHB0cy5wdXNoKCB0aGlzLmdldFBvaW50QXQoIGQgLyBkaXZpc2lvbnMgKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBwdHM7XHJcblxyXG59O1xyXG5cclxuLy8gR2V0IHRvdGFsIGN1cnZlIGFyYyBsZW5ndGhcclxuXHJcblRIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBsZW5ndGhzID0gdGhpcy5nZXRMZW5ndGhzKCk7XHJcblx0cmV0dXJuIGxlbmd0aHNbIGxlbmd0aHMubGVuZ3RoIC0gMSBdO1xyXG5cclxufTtcclxuXHJcbi8vIEdldCBsaXN0IG9mIGN1bXVsYXRpdmUgc2VnbWVudCBsZW5ndGhzXHJcblxyXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0TGVuZ3RocyA9IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xyXG5cclxuXHRpZiAoICFkaXZpc2lvbnMgKSBkaXZpc2lvbnMgPSAodGhpcy5fX2FyY0xlbmd0aERpdmlzaW9ucykgPyAodGhpcy5fX2FyY0xlbmd0aERpdmlzaW9ucyk6IDIwMDtcclxuXHJcblx0aWYgKCB0aGlzLmNhY2hlQXJjTGVuZ3Roc1xyXG5cdFx0JiYgKCB0aGlzLmNhY2hlQXJjTGVuZ3Rocy5sZW5ndGggPT0gZGl2aXNpb25zICsgMSApXHJcblx0XHQmJiAhdGhpcy5uZWVkc1VwZGF0ZSkge1xyXG5cclxuXHRcdC8vY29uc29sZS5sb2coIFwiY2FjaGVkXCIsIHRoaXMuY2FjaGVBcmNMZW5ndGhzICk7XHJcblx0XHRyZXR1cm4gdGhpcy5jYWNoZUFyY0xlbmd0aHM7XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHR2YXIgY2FjaGUgPSBbXTtcclxuXHR2YXIgY3VycmVudCwgbGFzdCA9IHRoaXMuZ2V0UG9pbnQoIDAgKTtcclxuXHR2YXIgcCwgc3VtID0gMDtcclxuXHJcblx0Y2FjaGUucHVzaCggMCApO1xyXG5cclxuXHRmb3IgKCBwID0gMTsgcCA8PSBkaXZpc2lvbnM7IHAgKysgKSB7XHJcblxyXG5cdFx0Y3VycmVudCA9IHRoaXMuZ2V0UG9pbnQgKCBwIC8gZGl2aXNpb25zICk7XHJcblx0XHRzdW0gKz0gY3VycmVudC5kaXN0YW5jZVRvKCBsYXN0ICk7XHJcblx0XHRjYWNoZS5wdXNoKCBzdW0gKTtcclxuXHRcdGxhc3QgPSBjdXJyZW50O1xyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMuY2FjaGVBcmNMZW5ndGhzID0gY2FjaGU7XHJcblxyXG5cdHJldHVybiBjYWNoZTsgLy8geyBzdW1zOiBjYWNoZSwgc3VtOnN1bSB9OyBTdW0gaXMgaW4gdGhlIGxhc3QgZWxlbWVudC5cclxuXHJcbn07XHJcblxyXG5cclxuVEhSRUUuQ3VydmUucHJvdG90eXBlLnVwZGF0ZUFyY0xlbmd0aHMgPSBmdW5jdGlvbigpIHtcclxuXHR0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHR0aGlzLmdldExlbmd0aHMoKTtcclxufTtcclxuXHJcbi8vIEdpdmVuIHUgKCAwIC4uIDEgKSwgZ2V0IGEgdCB0byBmaW5kIHAuIFRoaXMgZ2l2ZXMgeW91IHBvaW50cyB3aGljaCBhcmUgZXF1aSBkaXN0YW5jZVxyXG5cclxuVEhSRUUuQ3VydmUucHJvdG90eXBlLmdldFV0b1RtYXBwaW5nID0gZnVuY3Rpb24gKCB1LCBkaXN0YW5jZSApIHtcclxuXHJcblx0dmFyIGFyY0xlbmd0aHMgPSB0aGlzLmdldExlbmd0aHMoKTtcclxuXHJcblx0dmFyIGkgPSAwLCBpbCA9IGFyY0xlbmd0aHMubGVuZ3RoO1xyXG5cclxuXHR2YXIgdGFyZ2V0QXJjTGVuZ3RoOyAvLyBUaGUgdGFyZ2V0ZWQgdSBkaXN0YW5jZSB2YWx1ZSB0byBnZXRcclxuXHJcblx0aWYgKCBkaXN0YW5jZSApIHtcclxuXHJcblx0XHR0YXJnZXRBcmNMZW5ndGggPSBkaXN0YW5jZTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHR0YXJnZXRBcmNMZW5ndGggPSB1ICogYXJjTGVuZ3Roc1sgaWwgLSAxIF07XHJcblxyXG5cdH1cclxuXHJcblx0Ly92YXIgdGltZSA9IERhdGUubm93KCk7XHJcblxyXG5cdC8vIGJpbmFyeSBzZWFyY2ggZm9yIHRoZSBpbmRleCB3aXRoIGxhcmdlc3QgdmFsdWUgc21hbGxlciB0aGFuIHRhcmdldCB1IGRpc3RhbmNlXHJcblxyXG5cdHZhciBsb3cgPSAwLCBoaWdoID0gaWwgLSAxLCBjb21wYXJpc29uO1xyXG5cclxuXHR3aGlsZSAoIGxvdyA8PSBoaWdoICkge1xyXG5cclxuXHRcdGkgPSBNYXRoLmZsb29yKCBsb3cgKyAoIGhpZ2ggLSBsb3cgKSAvIDIgKTsgLy8gbGVzcyBsaWtlbHkgdG8gb3ZlcmZsb3csIHRob3VnaCBwcm9iYWJseSBub3QgaXNzdWUgaGVyZSwgSlMgZG9lc24ndCByZWFsbHkgaGF2ZSBpbnRlZ2VycywgYWxsIG51bWJlcnMgYXJlIGZsb2F0c1xyXG5cclxuXHRcdGNvbXBhcmlzb24gPSBhcmNMZW5ndGhzWyBpIF0gLSB0YXJnZXRBcmNMZW5ndGg7XHJcblxyXG5cdFx0aWYgKCBjb21wYXJpc29uIDwgMCApIHtcclxuXHJcblx0XHRcdGxvdyA9IGkgKyAxO1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBjb21wYXJpc29uID4gMCApIHtcclxuXHJcblx0XHRcdGhpZ2ggPSBpIC0gMTtcclxuXHRcdFx0Y29udGludWU7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGhpZ2ggPSBpO1xyXG5cdFx0XHRicmVhaztcclxuXHJcblx0XHRcdC8vIERPTkVcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0aSA9IGhpZ2g7XHJcblxyXG5cdC8vY29uc29sZS5sb2coJ2InICwgaSwgbG93LCBoaWdoLCBEYXRlLm5vdygpLSB0aW1lKTtcclxuXHJcblx0aWYgKCBhcmNMZW5ndGhzWyBpIF0gPT0gdGFyZ2V0QXJjTGVuZ3RoICkge1xyXG5cclxuXHRcdHZhciB0ID0gaSAvICggaWwgLSAxICk7XHJcblx0XHRyZXR1cm4gdDtcclxuXHJcblx0fVxyXG5cclxuXHQvLyB3ZSBjb3VsZCBnZXQgZmluZXIgZ3JhaW4gYXQgbGVuZ3Rocywgb3IgdXNlIHNpbXBsZSBpbnRlcnBvbGF0YXRpb24gYmV0d2VlbiB0d28gcG9pbnRzXHJcblxyXG5cdHZhciBsZW5ndGhCZWZvcmUgPSBhcmNMZW5ndGhzWyBpIF07XHJcbiAgICB2YXIgbGVuZ3RoQWZ0ZXIgPSBhcmNMZW5ndGhzWyBpICsgMSBdO1xyXG5cclxuICAgIHZhciBzZWdtZW50TGVuZ3RoID0gbGVuZ3RoQWZ0ZXIgLSBsZW5ndGhCZWZvcmU7XHJcblxyXG4gICAgLy8gZGV0ZXJtaW5lIHdoZXJlIHdlIGFyZSBiZXR3ZWVuIHRoZSAnYmVmb3JlJyBhbmQgJ2FmdGVyJyBwb2ludHNcclxuXHJcbiAgICB2YXIgc2VnbWVudEZyYWN0aW9uID0gKCB0YXJnZXRBcmNMZW5ndGggLSBsZW5ndGhCZWZvcmUgKSAvIHNlZ21lbnRMZW5ndGg7XHJcblxyXG4gICAgLy8gYWRkIHRoYXQgZnJhY3Rpb25hbCBhbW91bnQgdG8gdFxyXG5cclxuICAgIHZhciB0ID0gKCBpICsgc2VnbWVudEZyYWN0aW9uICkgLyAoIGlsIC0xICk7XHJcblxyXG5cdHJldHVybiB0O1xyXG5cclxufTtcclxuXHJcbi8vIFJldHVybnMgYSB1bml0IHZlY3RvciB0YW5nZW50IGF0IHRcclxuLy8gSW4gY2FzZSBhbnkgc3ViIGN1cnZlIGRvZXMgbm90IGltcGxlbWVudCBpdHMgdGFuZ2VudCBkZXJpdmF0aW9uLFxyXG4vLyAyIHBvaW50cyBhIHNtYWxsIGRlbHRhIGFwYXJ0IHdpbGwgYmUgdXNlZCB0byBmaW5kIGl0cyBncmFkaWVudFxyXG4vLyB3aGljaCBzZWVtcyB0byBnaXZlIGEgcmVhc29uYWJsZSBhcHByb3hpbWF0aW9uXHJcblxyXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0VGFuZ2VudCA9IGZ1bmN0aW9uKCB0ICkge1xyXG5cclxuXHR2YXIgZGVsdGEgPSAwLjAwMDE7XHJcblx0dmFyIHQxID0gdCAtIGRlbHRhO1xyXG5cdHZhciB0MiA9IHQgKyBkZWx0YTtcclxuXHJcblx0Ly8gQ2FwcGluZyBpbiBjYXNlIG9mIGRhbmdlclxyXG5cclxuXHRpZiAoIHQxIDwgMCApIHQxID0gMDtcclxuXHRpZiAoIHQyID4gMSApIHQyID0gMTtcclxuXHJcblx0dmFyIHB0MSA9IHRoaXMuZ2V0UG9pbnQoIHQxICk7XHJcblx0dmFyIHB0MiA9IHRoaXMuZ2V0UG9pbnQoIHQyICk7XHJcblxyXG5cdHZhciB2ZWMgPSBwdDIuY2xvbmUoKS5zdWIocHQxKTtcclxuXHRyZXR1cm4gdmVjLm5vcm1hbGl6ZSgpO1xyXG5cclxufTtcclxuXHJcblxyXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0VGFuZ2VudEF0ID0gZnVuY3Rpb24gKCB1ICkge1xyXG5cclxuXHR2YXIgdCA9IHRoaXMuZ2V0VXRvVG1hcHBpbmcoIHUgKTtcclxuXHRyZXR1cm4gdGhpcy5nZXRUYW5nZW50KCB0ICk7XHJcblxyXG59O1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRMaW5lXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblRIUkVFLkxpbmVDdXJ2ZSA9IGZ1bmN0aW9uICggdjEsIHYyICkge1xyXG5cclxuXHR0aGlzLnYxID0gdjE7XHJcblx0dGhpcy52MiA9IHYyO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkxpbmVDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLkxpbmVDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQgKSB7XHJcblxyXG5cdHZhciBwb2ludCA9IHRoaXMudjIuY2xvbmUoKS5zdWIodGhpcy52MSk7XHJcblx0cG9pbnQubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMudjEgKTtcclxuXHJcblx0cmV0dXJuIHBvaW50O1xyXG5cclxufTtcclxuXHJcbi8vIExpbmUgY3VydmUgaXMgbGluZWFyLCBzbyB3ZSBjYW4gb3ZlcndyaXRlIGRlZmF1bHQgZ2V0UG9pbnRBdFxyXG5cclxuVEhSRUUuTGluZUN1cnZlLnByb3RvdHlwZS5nZXRQb2ludEF0ID0gZnVuY3Rpb24gKCB1ICkge1xyXG5cclxuXHRyZXR1cm4gdGhpcy5nZXRQb2ludCggdSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkxpbmVDdXJ2ZS5wcm90b3R5cGUuZ2V0VGFuZ2VudCA9IGZ1bmN0aW9uKCB0ICkge1xyXG5cclxuXHR2YXIgdGFuZ2VudCA9IHRoaXMudjIuY2xvbmUoKS5zdWIodGhpcy52MSk7XHJcblxyXG5cdHJldHVybiB0YW5nZW50Lm5vcm1hbGl6ZSgpO1xyXG5cclxufTtcclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKlx0UXVhZHJhdGljIEJlemllciBjdXJ2ZVxyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5cclxuVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUgPSBmdW5jdGlvbiAoIHYwLCB2MSwgdjIgKSB7XHJcblxyXG5cdHRoaXMudjAgPSB2MDtcclxuXHR0aGlzLnYxID0gdjE7XHJcblx0dGhpcy52MiA9IHYyO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xyXG5cclxuXHJcblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCApIHtcclxuXHJcblx0dmFyIHR4LCB0eTtcclxuXHJcblx0dHggPSBUSFJFRS5TaGFwZS5VdGlscy5iMiggdCwgdGhpcy52MC54LCB0aGlzLnYxLngsIHRoaXMudjIueCApO1xyXG5cdHR5ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjIoIHQsIHRoaXMudjAueSwgdGhpcy52MS55LCB0aGlzLnYyLnkgKTtcclxuXHJcblx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IyKCB0eCwgdHkgKTtcclxuXHJcbn07XHJcblxyXG5cclxuVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlLmdldFRhbmdlbnQgPSBmdW5jdGlvbiggdCApIHtcclxuXHJcblx0dmFyIHR4LCB0eTtcclxuXHJcblx0dHggPSBUSFJFRS5DdXJ2ZS5VdGlscy50YW5nZW50UXVhZHJhdGljQmV6aWVyKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54ICk7XHJcblx0dHkgPSBUSFJFRS5DdXJ2ZS5VdGlscy50YW5nZW50UXVhZHJhdGljQmV6aWVyKCB0LCB0aGlzLnYwLnksIHRoaXMudjEueSwgdGhpcy52Mi55ICk7XHJcblxyXG5cdC8vIHJldHVybnMgdW5pdCB2ZWN0b3JcclxuXHJcblx0dmFyIHRhbmdlbnQgPSBuZXcgVEhSRUUuVmVjdG9yMiggdHgsIHR5ICk7XHJcblx0dGFuZ2VudC5ub3JtYWxpemUoKTtcclxuXHJcblx0cmV0dXJuIHRhbmdlbnQ7XHJcblxyXG59O1xyXG5cclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKlx0Q3ViaWMgQmV6aWVyIGN1cnZlXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblRIUkVFLkN1YmljQmV6aWVyQ3VydmUgPSBmdW5jdGlvbiAoIHYwLCB2MSwgdjIsIHYzICkge1xyXG5cclxuXHR0aGlzLnYwID0gdjA7XHJcblx0dGhpcy52MSA9IHYxO1xyXG5cdHRoaXMudjIgPSB2MjtcclxuXHR0aGlzLnYzID0gdjM7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLkN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuXHR2YXIgdHgsIHR5O1xyXG5cclxuXHR0eCA9IFRIUkVFLlNoYXBlLlV0aWxzLmIzKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54LCB0aGlzLnYzLnggKTtcclxuXHR0eSA9IFRIUkVFLlNoYXBlLlV0aWxzLmIzKCB0LCB0aGlzLnYwLnksIHRoaXMudjEueSwgdGhpcy52Mi55LCB0aGlzLnYzLnkgKTtcclxuXHJcblx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IyKCB0eCwgdHkgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5DdWJpY0JlemllckN1cnZlLnByb3RvdHlwZS5nZXRUYW5nZW50ID0gZnVuY3Rpb24oIHQgKSB7XHJcblxyXG5cdHZhciB0eCwgdHk7XHJcblxyXG5cdHR4ID0gVEhSRUUuQ3VydmUuVXRpbHMudGFuZ2VudEN1YmljQmV6aWVyKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54LCB0aGlzLnYzLnggKTtcclxuXHR0eSA9IFRIUkVFLkN1cnZlLlV0aWxzLnRhbmdlbnRDdWJpY0JlemllciggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSwgdGhpcy52My55ICk7XHJcblxyXG5cdHZhciB0YW5nZW50ID0gbmV3IFRIUkVFLlZlY3RvcjIoIHR4LCB0eSApO1xyXG5cdHRhbmdlbnQubm9ybWFsaXplKCk7XHJcblxyXG5cdHJldHVybiB0YW5nZW50O1xyXG5cclxufTtcclxuXHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICpcdFNwbGluZSBjdXJ2ZVxyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5USFJFRS5TcGxpbmVDdXJ2ZSA9IGZ1bmN0aW9uICggcG9pbnRzIC8qIGFycmF5IG9mIFZlY3RvcjIgKi8gKSB7XHJcblxyXG5cdHRoaXMucG9pbnRzID0gKHBvaW50cyA9PSB1bmRlZmluZWQpID8gW10gOiBwb2ludHM7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU3BsaW5lQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ3VydmUucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5TcGxpbmVDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQgKSB7XHJcblxyXG5cdHZhciB2ID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHR2YXIgYyA9IFtdO1xyXG5cdHZhciBwb2ludHMgPSB0aGlzLnBvaW50cywgcG9pbnQsIGludFBvaW50LCB3ZWlnaHQ7XHJcblx0cG9pbnQgPSAoIHBvaW50cy5sZW5ndGggLSAxICkgKiB0O1xyXG5cclxuXHRpbnRQb2ludCA9IE1hdGguZmxvb3IoIHBvaW50ICk7XHJcblx0d2VpZ2h0ID0gcG9pbnQgLSBpbnRQb2ludDtcclxuXHJcblx0Y1sgMCBdID0gaW50UG9pbnQgPT0gMCA/IGludFBvaW50IDogaW50UG9pbnQgLSAxO1xyXG5cdGNbIDEgXSA9IGludFBvaW50O1xyXG5cdGNbIDIgXSA9IGludFBvaW50ICA+IHBvaW50cy5sZW5ndGggLSAyID8gcG9pbnRzLmxlbmd0aCAtMSA6IGludFBvaW50ICsgMTtcclxuXHRjWyAzIF0gPSBpbnRQb2ludCAgPiBwb2ludHMubGVuZ3RoIC0gMyA/IHBvaW50cy5sZW5ndGggLTEgOiBpbnRQb2ludCArIDI7XHJcblxyXG5cdHYueCA9IFRIUkVFLkN1cnZlLlV0aWxzLmludGVycG9sYXRlKCBwb2ludHNbIGNbIDAgXSBdLngsIHBvaW50c1sgY1sgMSBdIF0ueCwgcG9pbnRzWyBjWyAyIF0gXS54LCBwb2ludHNbIGNbIDMgXSBdLngsIHdlaWdodCApO1xyXG5cdHYueSA9IFRIUkVFLkN1cnZlLlV0aWxzLmludGVycG9sYXRlKCBwb2ludHNbIGNbIDAgXSBdLnksIHBvaW50c1sgY1sgMSBdIF0ueSwgcG9pbnRzWyBjWyAyIF0gXS55LCBwb2ludHNbIGNbIDMgXSBdLnksIHdlaWdodCApO1xyXG5cclxuXHRyZXR1cm4gdjtcclxuXHJcbn07XHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICpcdEVsbGlwc2UgY3VydmVcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuVEhSRUUuRWxsaXBzZUN1cnZlID0gZnVuY3Rpb24gKCBhWCwgYVksIHhSYWRpdXMsIHlSYWRpdXMsXHJcblx0XHRcdFx0XHRcdFx0YVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSxcclxuXHRcdFx0XHRcdFx0XHRhQ2xvY2t3aXNlICkge1xyXG5cclxuXHR0aGlzLmFYID0gYVg7XHJcblx0dGhpcy5hWSA9IGFZO1xyXG5cclxuXHR0aGlzLnhSYWRpdXMgPSB4UmFkaXVzO1xyXG5cdHRoaXMueVJhZGl1cyA9IHlSYWRpdXM7XHJcblxyXG5cdHRoaXMuYVN0YXJ0QW5nbGUgPSBhU3RhcnRBbmdsZTtcclxuXHR0aGlzLmFFbmRBbmdsZSA9IGFFbmRBbmdsZTtcclxuXHJcblx0dGhpcy5hQ2xvY2t3aXNlID0gYUNsb2Nrd2lzZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5FbGxpcHNlQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ3VydmUucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5FbGxpcHNlQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuXHR2YXIgZGVsdGFBbmdsZSA9IHRoaXMuYUVuZEFuZ2xlIC0gdGhpcy5hU3RhcnRBbmdsZTtcclxuXHJcblx0aWYgKCAhdGhpcy5hQ2xvY2t3aXNlICkge1xyXG5cclxuXHRcdHQgPSAxIC0gdDtcclxuXHJcblx0fVxyXG5cclxuXHR2YXIgYW5nbGUgPSB0aGlzLmFTdGFydEFuZ2xlICsgdCAqIGRlbHRhQW5nbGU7XHJcblxyXG5cdHZhciB0eCA9IHRoaXMuYVggKyB0aGlzLnhSYWRpdXMgKiBNYXRoLmNvcyggYW5nbGUgKTtcclxuXHR2YXIgdHkgPSB0aGlzLmFZICsgdGhpcy55UmFkaXVzICogTWF0aC5zaW4oIGFuZ2xlICk7XHJcblxyXG5cdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMiggdHgsIHR5ICk7XHJcblxyXG59O1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRBcmMgY3VydmVcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuVEhSRUUuQXJjQ3VydmUgPSBmdW5jdGlvbiAoIGFYLCBhWSwgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApIHtcclxuXHJcblx0VEhSRUUuRWxsaXBzZUN1cnZlLmNhbGwoIHRoaXMsIGFYLCBhWSwgYVJhZGl1cywgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xyXG59O1xyXG5cclxuVEhSRUUuQXJjQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuRWxsaXBzZUN1cnZlLnByb3RvdHlwZSApO1xyXG5cclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKlx0VXRpbHNcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuVEhSRUUuQ3VydmUuVXRpbHMgPSB7XHJcblxyXG5cdHRhbmdlbnRRdWFkcmF0aWNCZXppZXI6IGZ1bmN0aW9uICggdCwgcDAsIHAxLCBwMiApIHtcclxuXHJcblx0XHRyZXR1cm4gMiAqICggMSAtIHQgKSAqICggcDEgLSBwMCApICsgMiAqIHQgKiAoIHAyIC0gcDEgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gUHVheSBCaW5nLCB0aGFua3MgZm9yIGhlbHBpbmcgd2l0aCB0aGlzIGRlcml2YXRpdmUhXHJcblxyXG5cdHRhbmdlbnRDdWJpY0JlemllcjogZnVuY3Rpb24gKHQsIHAwLCBwMSwgcDIsIHAzICkge1xyXG5cclxuXHRcdHJldHVybiAtMyAqIHAwICogKDEgLSB0KSAqICgxIC0gdCkgICtcclxuXHRcdFx0MyAqIHAxICogKDEgLSB0KSAqICgxLXQpIC0gNiAqdCAqcDEgKiAoMS10KSArXHJcblx0XHRcdDYgKiB0ICogIHAyICogKDEtdCkgLSAzICogdCAqIHQgKiBwMiArXHJcblx0XHRcdDMgKiB0ICogdCAqIHAzO1xyXG5cdH0sXHJcblxyXG5cclxuXHR0YW5nZW50U3BsaW5lOiBmdW5jdGlvbiAoIHQsIHAwLCBwMSwgcDIsIHAzICkge1xyXG5cclxuXHRcdC8vIFRvIGNoZWNrIGlmIG15IGZvcm11bGFzIGFyZSBjb3JyZWN0XHJcblxyXG5cdFx0dmFyIGgwMCA9IDYgKiB0ICogdCAtIDYgKiB0OyBcdC8vIGRlcml2ZWQgZnJvbSAydF4zIOKIkiAzdF4yICsgMVxyXG5cdFx0dmFyIGgxMCA9IDMgKiB0ICogdCAtIDQgKiB0ICsgMTsgLy8gdF4zIOKIkiAydF4yICsgdFxyXG5cdFx0dmFyIGgwMSA9IC02ICogdCAqIHQgKyA2ICogdDsgXHQvLyDiiJIgMnQzICsgM3QyXHJcblx0XHR2YXIgaDExID0gMyAqIHQgKiB0IC0gMiAqIHQ7XHQvLyB0MyDiiJIgdDJcclxuXHJcblx0XHRyZXR1cm4gaDAwICsgaDEwICsgaDAxICsgaDExO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBDYXRtdWxsLVJvbVxyXG5cclxuXHRpbnRlcnBvbGF0ZTogZnVuY3Rpb24oIHAwLCBwMSwgcDIsIHAzLCB0ICkge1xyXG5cclxuXHRcdHZhciB2MCA9ICggcDIgLSBwMCApICogMC41O1xyXG5cdFx0dmFyIHYxID0gKCBwMyAtIHAxICkgKiAwLjU7XHJcblx0XHR2YXIgdDIgPSB0ICogdDtcclxuXHRcdHZhciB0MyA9IHQgKiB0MjtcclxuXHRcdHJldHVybiAoIDIgKiBwMSAtIDIgKiBwMiArIHYwICsgdjEgKSAqIHQzICsgKCAtIDMgKiBwMSArIDMgKiBwMiAtIDIgKiB2MCAtIHYxICkgKiB0MiArIHYwICogdCArIHAxO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuXHJcbi8vIFRPRE86IFRyYW5zZm9ybWF0aW9uIGZvciBDdXJ2ZXM/XHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICpcdDNEIEN1cnZlc1xyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG4vLyBBIEZhY3RvcnkgbWV0aG9kIGZvciBjcmVhdGluZyBuZXcgY3VydmUgc3ViY2xhc3Nlc1xyXG5cclxuVEhSRUUuQ3VydmUuY3JlYXRlID0gZnVuY3Rpb24gKCBjb25zdHJ1Y3RvciwgZ2V0UG9pbnRGdW5jICkge1xyXG5cclxuXHRjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcclxuXHRjb25zdHJ1Y3Rvci5wcm90b3R5cGUuZ2V0UG9pbnQgPSBnZXRQb2ludEZ1bmM7XHJcblxyXG5cdHJldHVybiBjb25zdHJ1Y3RvcjtcclxuXHJcbn07XHJcblxyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRMaW5lM0RcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuVEhSRUUuTGluZUN1cnZlMyA9IFRIUkVFLkN1cnZlLmNyZWF0ZShcclxuXHJcblx0ZnVuY3Rpb24gKCB2MSwgdjIgKSB7XHJcblxyXG5cdFx0dGhpcy52MSA9IHYxO1xyXG5cdFx0dGhpcy52MiA9IHYyO1xyXG5cclxuXHR9LFxyXG5cclxuXHRmdW5jdGlvbiAoIHQgKSB7XHJcblxyXG5cdFx0dmFyIHIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHJcblx0XHRyLnN1YlZlY3RvcnMoIHRoaXMudjIsIHRoaXMudjEgKTsgLy8gZGlmZlxyXG5cdFx0ci5tdWx0aXBseVNjYWxhciggdCApO1xyXG5cdFx0ci5hZGQoIHRoaXMudjEgKTtcclxuXHJcblx0XHRyZXR1cm4gcjtcclxuXHJcblx0fVxyXG5cclxuKTtcclxuXHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICpcdFF1YWRyYXRpYyBCZXppZXIgM0QgY3VydmVcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUzID0gVEhSRUUuQ3VydmUuY3JlYXRlKFxyXG5cclxuXHRmdW5jdGlvbiAoIHYwLCB2MSwgdjIgKSB7XHJcblxyXG5cdFx0dGhpcy52MCA9IHYwO1xyXG5cdFx0dGhpcy52MSA9IHYxO1xyXG5cdFx0dGhpcy52MiA9IHYyO1xyXG5cclxuXHR9LFxyXG5cclxuXHRmdW5jdGlvbiAoIHQgKSB7XHJcblxyXG5cdFx0dmFyIHR4LCB0eSwgdHo7XHJcblxyXG5cdFx0dHggPSBUSFJFRS5TaGFwZS5VdGlscy5iMiggdCwgdGhpcy52MC54LCB0aGlzLnYxLngsIHRoaXMudjIueCApO1xyXG5cdFx0dHkgPSBUSFJFRS5TaGFwZS5VdGlscy5iMiggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSApO1xyXG5cdFx0dHogPSBUSFJFRS5TaGFwZS5VdGlscy5iMiggdCwgdGhpcy52MC56LCB0aGlzLnYxLnosIHRoaXMudjIueiApO1xyXG5cclxuXHRcdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMyggdHgsIHR5LCB0eiApO1xyXG5cclxuXHR9XHJcblxyXG4pO1xyXG5cclxuXHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICpcdEN1YmljIEJlemllciAzRCBjdXJ2ZVxyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5USFJFRS5DdWJpY0JlemllckN1cnZlMyA9IFRIUkVFLkN1cnZlLmNyZWF0ZShcclxuXHJcblx0ZnVuY3Rpb24gKCB2MCwgdjEsIHYyLCB2MyApIHtcclxuXHJcblx0XHR0aGlzLnYwID0gdjA7XHJcblx0XHR0aGlzLnYxID0gdjE7XHJcblx0XHR0aGlzLnYyID0gdjI7XHJcblx0XHR0aGlzLnYzID0gdjM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGZ1bmN0aW9uICggdCApIHtcclxuXHJcblx0XHR2YXIgdHgsIHR5LCB0ejtcclxuXHJcblx0XHR0eCA9IFRIUkVFLlNoYXBlLlV0aWxzLmIzKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54LCB0aGlzLnYzLnggKTtcclxuXHRcdHR5ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjMoIHQsIHRoaXMudjAueSwgdGhpcy52MS55LCB0aGlzLnYyLnksIHRoaXMudjMueSApO1xyXG5cdFx0dHogPSBUSFJFRS5TaGFwZS5VdGlscy5iMyggdCwgdGhpcy52MC56LCB0aGlzLnYxLnosIHRoaXMudjIueiwgdGhpcy52My56ICk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKCB0eCwgdHksIHR6ICk7XHJcblxyXG5cdH1cclxuXHJcbik7XHJcblxyXG5cclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKlx0U3BsaW5lIDNEIGN1cnZlXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblxyXG5USFJFRS5TcGxpbmVDdXJ2ZTMgPSBUSFJFRS5DdXJ2ZS5jcmVhdGUoXHJcblxyXG5cdGZ1bmN0aW9uICggcG9pbnRzIC8qIGFycmF5IG9mIFZlY3RvcjMgKi8pIHtcclxuXHJcblx0XHR0aGlzLnBvaW50cyA9IChwb2ludHMgPT0gdW5kZWZpbmVkKSA/IFtdIDogcG9pbnRzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRmdW5jdGlvbiAoIHQgKSB7XHJcblxyXG5cdFx0dmFyIHYgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0dmFyIGMgPSBbXTtcclxuXHRcdHZhciBwb2ludHMgPSB0aGlzLnBvaW50cywgcG9pbnQsIGludFBvaW50LCB3ZWlnaHQ7XHJcblx0XHRwb2ludCA9ICggcG9pbnRzLmxlbmd0aCAtIDEgKSAqIHQ7XHJcblxyXG5cdFx0aW50UG9pbnQgPSBNYXRoLmZsb29yKCBwb2ludCApO1xyXG5cdFx0d2VpZ2h0ID0gcG9pbnQgLSBpbnRQb2ludDtcclxuXHJcblx0XHRjWyAwIF0gPSBpbnRQb2ludCA9PSAwID8gaW50UG9pbnQgOiBpbnRQb2ludCAtIDE7XHJcblx0XHRjWyAxIF0gPSBpbnRQb2ludDtcclxuXHRcdGNbIDIgXSA9IGludFBvaW50ICA+IHBvaW50cy5sZW5ndGggLSAyID8gcG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDE7XHJcblx0XHRjWyAzIF0gPSBpbnRQb2ludCAgPiBwb2ludHMubGVuZ3RoIC0gMyA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAyO1xyXG5cclxuXHRcdHZhciBwdDAgPSBwb2ludHNbIGNbMF0gXSxcclxuXHRcdFx0cHQxID0gcG9pbnRzWyBjWzFdIF0sXHJcblx0XHRcdHB0MiA9IHBvaW50c1sgY1syXSBdLFxyXG5cdFx0XHRwdDMgPSBwb2ludHNbIGNbM10gXTtcclxuXHJcblx0XHR2LnggPSBUSFJFRS5DdXJ2ZS5VdGlscy5pbnRlcnBvbGF0ZShwdDAueCwgcHQxLngsIHB0Mi54LCBwdDMueCwgd2VpZ2h0KTtcclxuXHRcdHYueSA9IFRIUkVFLkN1cnZlLlV0aWxzLmludGVycG9sYXRlKHB0MC55LCBwdDEueSwgcHQyLnksIHB0My55LCB3ZWlnaHQpO1xyXG5cdFx0di56ID0gVEhSRUUuQ3VydmUuVXRpbHMuaW50ZXJwb2xhdGUocHQwLnosIHB0MS56LCBwdDIueiwgcHQzLnosIHdlaWdodCk7XHJcblxyXG5cdFx0cmV0dXJuIHY7XHJcblxyXG5cdH1cclxuXHJcbik7XHJcblxyXG5cclxuLy8gVEhSRUUuU3BsaW5lQ3VydmUzLnByb3RvdHlwZS5nZXRUYW5nZW50ID0gZnVuY3Rpb24odCkge1xyXG4vLyBcdFx0dmFyIHYgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4vLyBcdFx0dmFyIGMgPSBbXTtcclxuLy8gXHRcdHZhciBwb2ludHMgPSB0aGlzLnBvaW50cywgcG9pbnQsIGludFBvaW50LCB3ZWlnaHQ7XHJcbi8vIFx0XHRwb2ludCA9ICggcG9pbnRzLmxlbmd0aCAtIDEgKSAqIHQ7XHJcblxyXG4vLyBcdFx0aW50UG9pbnQgPSBNYXRoLmZsb29yKCBwb2ludCApO1xyXG4vLyBcdFx0d2VpZ2h0ID0gcG9pbnQgLSBpbnRQb2ludDtcclxuXHJcbi8vIFx0XHRjWyAwIF0gPSBpbnRQb2ludCA9PSAwID8gaW50UG9pbnQgOiBpbnRQb2ludCAtIDE7XHJcbi8vIFx0XHRjWyAxIF0gPSBpbnRQb2ludDtcclxuLy8gXHRcdGNbIDIgXSA9IGludFBvaW50ICA+IHBvaW50cy5sZW5ndGggLSAyID8gcG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDE7XHJcbi8vIFx0XHRjWyAzIF0gPSBpbnRQb2ludCAgPiBwb2ludHMubGVuZ3RoIC0gMyA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAyO1xyXG5cclxuLy8gXHRcdHZhciBwdDAgPSBwb2ludHNbIGNbMF0gXSxcclxuLy8gXHRcdFx0cHQxID0gcG9pbnRzWyBjWzFdIF0sXHJcbi8vIFx0XHRcdHB0MiA9IHBvaW50c1sgY1syXSBdLFxyXG4vLyBcdFx0XHRwdDMgPSBwb2ludHNbIGNbM10gXTtcclxuXHJcbi8vIFx0Ly8gdCA9IHdlaWdodDtcclxuLy8gXHR2LnggPSBUSFJFRS5DdXJ2ZS5VdGlscy50YW5nZW50U3BsaW5lKCB0LCBwdDAueCwgcHQxLngsIHB0Mi54LCBwdDMueCApO1xyXG4vLyBcdHYueSA9IFRIUkVFLkN1cnZlLlV0aWxzLnRhbmdlbnRTcGxpbmUoIHQsIHB0MC55LCBwdDEueSwgcHQyLnksIHB0My55ICk7XHJcbi8vIFx0di56ID0gVEhSRUUuQ3VydmUuVXRpbHMudGFuZ2VudFNwbGluZSggdCwgcHQwLnosIHB0MS56LCBwdDIueiwgcHQzLnogKTtcclxuXHJcbi8vIFx0cmV0dXJuIHY7XHJcblxyXG4vLyB9XHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICpcdENsb3NlZCBTcGxpbmUgM0QgY3VydmVcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuXHJcblRIUkVFLkNsb3NlZFNwbGluZUN1cnZlMyA9IFRIUkVFLkN1cnZlLmNyZWF0ZShcclxuXHJcblx0ZnVuY3Rpb24gKCBwb2ludHMgLyogYXJyYXkgb2YgVmVjdG9yMyAqLykge1xyXG5cclxuXHRcdHRoaXMucG9pbnRzID0gKHBvaW50cyA9PSB1bmRlZmluZWQpID8gW10gOiBwb2ludHM7XHJcblxyXG5cdH0sXHJcblxyXG4gICAgZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuICAgICAgICB2YXIgdiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgICAgICAgdmFyIGMgPSBbXTtcclxuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHMsIHBvaW50LCBpbnRQb2ludCwgd2VpZ2h0O1xyXG4gICAgICAgIHBvaW50ID0gKCBwb2ludHMubGVuZ3RoIC0gMCApICogdDtcclxuICAgICAgICAgICAgLy8gVGhpcyBuZWVkcyB0byBiZSBmcm9tIDAtbGVuZ3RoICsxXHJcblxyXG4gICAgICAgIGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcclxuICAgICAgICB3ZWlnaHQgPSBwb2ludCAtIGludFBvaW50O1xyXG5cclxuICAgICAgICBpbnRQb2ludCArPSBpbnRQb2ludCA+IDAgPyAwIDogKCBNYXRoLmZsb29yKCBNYXRoLmFicyggaW50UG9pbnQgKSAvIHBvaW50cy5sZW5ndGggKSArIDEgKSAqIHBvaW50cy5sZW5ndGg7XHJcbiAgICAgICAgY1sgMCBdID0gKCBpbnRQb2ludCAtIDEgKSAlIHBvaW50cy5sZW5ndGg7XHJcbiAgICAgICAgY1sgMSBdID0gKCBpbnRQb2ludCApICUgcG9pbnRzLmxlbmd0aDtcclxuICAgICAgICBjWyAyIF0gPSAoIGludFBvaW50ICsgMSApICUgcG9pbnRzLmxlbmd0aDtcclxuICAgICAgICBjWyAzIF0gPSAoIGludFBvaW50ICsgMiApICUgcG9pbnRzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgdi54ID0gVEhSRUUuQ3VydmUuVXRpbHMuaW50ZXJwb2xhdGUoIHBvaW50c1sgY1sgMCBdIF0ueCwgcG9pbnRzWyBjWyAxIF0gXS54LCBwb2ludHNbIGNbIDIgXSBdLngsIHBvaW50c1sgY1sgMyBdIF0ueCwgd2VpZ2h0ICk7XHJcbiAgICAgICAgdi55ID0gVEhSRUUuQ3VydmUuVXRpbHMuaW50ZXJwb2xhdGUoIHBvaW50c1sgY1sgMCBdIF0ueSwgcG9pbnRzWyBjWyAxIF0gXS55LCBwb2ludHNbIGNbIDIgXSBdLnksIHBvaW50c1sgY1sgMyBdIF0ueSwgd2VpZ2h0ICk7XHJcbiAgICAgICAgdi56ID0gVEhSRUUuQ3VydmUuVXRpbHMuaW50ZXJwb2xhdGUoIHBvaW50c1sgY1sgMCBdIF0ueiwgcG9pbnRzWyBjWyAxIF0gXS56LCBwb2ludHNbIGNbIDIgXSBdLnosIHBvaW50c1sgY1sgMyBdIF0ueiwgd2VpZ2h0ICk7XHJcblxyXG4gICAgICAgIHJldHVybiB2O1xyXG5cclxuICAgIH1cclxuXHJcbik7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXHJcbiAqXHJcbiAqKi9cclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKlx0Q3VydmVkIFBhdGggLSBhIGN1cnZlIHBhdGggaXMgc2ltcGx5IGEgYXJyYXkgb2YgY29ubmVjdGVkXHJcbiAqICBjdXJ2ZXMsIGJ1dCByZXRhaW5zIHRoZSBhcGkgb2YgYSBjdXJ2ZVxyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5USFJFRS5DdXJ2ZVBhdGggPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHRoaXMuY3VydmVzID0gW107XHJcblx0dGhpcy5iZW5kcyA9IFtdO1xyXG5cdFxyXG5cdHRoaXMuYXV0b0Nsb3NlID0gZmFsc2U7IC8vIEF1dG9tYXRpY2FsbHkgY2xvc2VzIHRoZSBwYXRoXHJcbn07XHJcblxyXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ3VydmUucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICggY3VydmUgKSB7XHJcblxyXG5cdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jaGVja0Nvbm5lY3Rpb24gPSBmdW5jdGlvbigpIHtcclxuXHQvLyBUT0RPXHJcblx0Ly8gSWYgdGhlIGVuZGluZyBvZiBjdXJ2ZSBpcyBub3QgY29ubmVjdGVkIHRvIHRoZSBzdGFydGluZ1xyXG5cdC8vIG9yIHRoZSBuZXh0IGN1cnZlLCB0aGVuLCB0aGlzIGlzIG5vdCBhIHJlYWwgcGF0aFxyXG59O1xyXG5cclxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jbG9zZVBhdGggPSBmdW5jdGlvbigpIHtcclxuXHQvLyBUT0RPIFRlc3RcclxuXHQvLyBhbmQgdmVyaWZ5IGZvciB2ZWN0b3IzIChuZWVkcyB0byBpbXBsZW1lbnQgZXF1YWxzKVxyXG5cdC8vIEFkZCBhIGxpbmUgY3VydmUgaWYgc3RhcnQgYW5kIGVuZCBvZiBsaW5lcyBhcmUgbm90IGNvbm5lY3RlZFxyXG5cdHZhciBzdGFydFBvaW50ID0gdGhpcy5jdXJ2ZXNbMF0uZ2V0UG9pbnQoMCk7XHJcblx0dmFyIGVuZFBvaW50ID0gdGhpcy5jdXJ2ZXNbdGhpcy5jdXJ2ZXMubGVuZ3RoLTFdLmdldFBvaW50KDEpO1xyXG5cdFxyXG5cdGlmICghc3RhcnRQb2ludC5lcXVhbHMoZW5kUG9pbnQpKSB7XHJcblx0XHR0aGlzLmN1cnZlcy5wdXNoKCBuZXcgVEhSRUUuTGluZUN1cnZlKGVuZFBvaW50LCBzdGFydFBvaW50KSApO1xyXG5cdH1cclxuXHRcclxufTtcclxuXHJcbi8vIFRvIGdldCBhY2N1cmF0ZSBwb2ludCB3aXRoIHJlZmVyZW5jZSB0b1xyXG4vLyBlbnRpcmUgcGF0aCBkaXN0YW5jZSBhdCB0aW1lIHQsXHJcbi8vIGZvbGxvd2luZyBoYXMgdG8gYmUgZG9uZTpcclxuXHJcbi8vIDEuIExlbmd0aCBvZiBlYWNoIHN1YiBwYXRoIGhhdmUgdG8gYmUga25vd25cclxuLy8gMi4gTG9jYXRlIGFuZCBpZGVudGlmeSB0eXBlIG9mIGN1cnZlXHJcbi8vIDMuIEdldCB0IGZvciB0aGUgY3VydmVcclxuLy8gNC4gUmV0dXJuIGN1cnZlLmdldFBvaW50QXQodCcpXHJcblxyXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24oIHQgKSB7XHJcblxyXG5cdHZhciBkID0gdCAqIHRoaXMuZ2V0TGVuZ3RoKCk7XHJcblx0dmFyIGN1cnZlTGVuZ3RocyA9IHRoaXMuZ2V0Q3VydmVMZW5ndGhzKCk7XHJcblx0dmFyIGkgPSAwLCBkaWZmLCBjdXJ2ZTtcclxuXHJcblx0Ly8gVG8gdGhpbmsgYWJvdXQgYm91bmRhcmllcyBwb2ludHMuXHJcblxyXG5cdHdoaWxlICggaSA8IGN1cnZlTGVuZ3Rocy5sZW5ndGggKSB7XHJcblxyXG5cdFx0aWYgKCBjdXJ2ZUxlbmd0aHNbIGkgXSA+PSBkICkge1xyXG5cclxuXHRcdFx0ZGlmZiA9IGN1cnZlTGVuZ3Roc1sgaSBdIC0gZDtcclxuXHRcdFx0Y3VydmUgPSB0aGlzLmN1cnZlc1sgaSBdO1xyXG5cclxuXHRcdFx0dmFyIHUgPSAxIC0gZGlmZiAvIGN1cnZlLmdldExlbmd0aCgpO1xyXG5cclxuXHRcdFx0cmV0dXJuIGN1cnZlLmdldFBvaW50QXQoIHUgKTtcclxuXHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0fVxyXG5cclxuXHRcdGkgKys7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIG51bGw7XHJcblxyXG5cdC8vIGxvb3Agd2hlcmUgc3VtICE9IDAsIHN1bSA+IGQgLCBzdW0rMSA8ZFxyXG5cclxufTtcclxuXHJcbi8qXHJcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuZ2V0VGFuZ2VudCA9IGZ1bmN0aW9uKCB0ICkge1xyXG59OyovXHJcblxyXG5cclxuLy8gV2UgY2Fubm90IHVzZSB0aGUgZGVmYXVsdCBUSFJFRS5DdXJ2ZSBnZXRQb2ludCgpIHdpdGggZ2V0TGVuZ3RoKCkgYmVjYXVzZSBpblxyXG4vLyBUSFJFRS5DdXJ2ZSwgZ2V0TGVuZ3RoKCkgZGVwZW5kcyBvbiBnZXRQb2ludCgpIGJ1dCBpbiBUSFJFRS5DdXJ2ZVBhdGhcclxuLy8gZ2V0UG9pbnQoKSBkZXBlbmRzIG9uIGdldExlbmd0aFxyXG5cclxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbigpIHtcclxuXHJcblx0dmFyIGxlbnMgPSB0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xyXG5cdHJldHVybiBsZW5zWyBsZW5zLmxlbmd0aCAtIDEgXTtcclxuXHJcbn07XHJcblxyXG4vLyBDb21wdXRlIGxlbmd0aHMgYW5kIGNhY2hlIHRoZW1cclxuLy8gV2UgY2Fubm90IG92ZXJ3cml0ZSBnZXRMZW5ndGhzKCkgYmVjYXVzZSBVdG9UIG1hcHBpbmcgdXNlcyBpdC5cclxuXHJcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuZ2V0Q3VydmVMZW5ndGhzID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdC8vIFdlIHVzZSBjYWNoZSB2YWx1ZXMgaWYgY3VydmVzIGFuZCBjYWNoZSBhcnJheSBhcmUgc2FtZSBsZW5ndGhcclxuXHJcblx0aWYgKCB0aGlzLmNhY2hlTGVuZ3RocyAmJiB0aGlzLmNhY2hlTGVuZ3Rocy5sZW5ndGggPT0gdGhpcy5jdXJ2ZXMubGVuZ3RoICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmNhY2hlTGVuZ3RocztcclxuXHJcblx0fTtcclxuXHJcblx0Ly8gR2V0IGxlbmd0aCBvZiBzdWJzdXJ2ZVxyXG5cdC8vIFB1c2ggc3VtcyBpbnRvIGNhY2hlZCBhcnJheVxyXG5cclxuXHR2YXIgbGVuZ3RocyA9IFtdLCBzdW1zID0gMDtcclxuXHR2YXIgaSwgaWwgPSB0aGlzLmN1cnZlcy5sZW5ndGg7XHJcblxyXG5cdGZvciAoIGkgPSAwOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0c3VtcyArPSB0aGlzLmN1cnZlc1sgaSBdLmdldExlbmd0aCgpO1xyXG5cdFx0bGVuZ3Rocy5wdXNoKCBzdW1zICk7XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5jYWNoZUxlbmd0aHMgPSBsZW5ndGhzO1xyXG5cclxuXHRyZXR1cm4gbGVuZ3RocztcclxuXHJcbn07XHJcblxyXG5cclxuXHJcbi8vIFJldHVybnMgbWluIGFuZCBtYXggY29vcmRpbmF0ZXMsIGFzIHdlbGwgYXMgY2VudHJvaWRcclxuXHJcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuZ2V0Qm91bmRpbmdCb3ggPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBwb2ludHMgPSB0aGlzLmdldFBvaW50cygpO1xyXG5cclxuXHR2YXIgbWF4WCwgbWF4WSwgbWF4WjtcclxuXHR2YXIgbWluWCwgbWluWSwgbWluWjtcclxuXHJcblx0bWF4WCA9IG1heFkgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XHJcblx0bWluWCA9IG1pblkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XHJcblxyXG5cdHZhciBwLCBpLCBpbCwgc3VtO1xyXG5cclxuXHR2YXIgdjMgPSBwb2ludHNbMF0gaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IzO1xyXG5cclxuXHRzdW0gPSB2MyA/IG5ldyBUSFJFRS5WZWN0b3IzKCkgOiBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG5cclxuXHRmb3IgKCBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0cCA9IHBvaW50c1sgaSBdO1xyXG5cclxuXHRcdGlmICggcC54ID4gbWF4WCApIG1heFggPSBwLng7XHJcblx0XHRlbHNlIGlmICggcC54IDwgbWluWCApIG1pblggPSBwLng7XHJcblxyXG5cdFx0aWYgKCBwLnkgPiBtYXhZICkgbWF4WSA9IHAueTtcclxuXHRcdGVsc2UgaWYgKCBwLnkgPCBtaW5ZICkgbWluWSA9IHAueTtcclxuXHJcblx0XHRpZiAoIHYzICkge1xyXG5cclxuXHRcdFx0aWYgKCBwLnogPiBtYXhaICkgbWF4WiA9IHAuejtcclxuXHRcdFx0ZWxzZSBpZiAoIHAueiA8IG1pblogKSBtaW5aID0gcC56O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRzdW0uYWRkKCBwICk7XHJcblxyXG5cdH1cclxuXHJcblx0dmFyIHJldCA9IHtcclxuXHJcblx0XHRtaW5YOiBtaW5YLFxyXG5cdFx0bWluWTogbWluWSxcclxuXHRcdG1heFg6IG1heFgsXHJcblx0XHRtYXhZOiBtYXhZLFxyXG5cdFx0Y2VudHJvaWQ6IHN1bS5kaXZpZGVTY2FsYXIoIGlsIClcclxuXHJcblx0fTtcclxuXHJcblx0aWYgKCB2MyApIHtcclxuXHJcblx0XHRyZXQubWF4WiA9IG1heFo7XHJcblx0XHRyZXQubWluWiA9IG1pblo7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHJldDtcclxuXHJcbn07XHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICpcdENyZWF0ZSBHZW9tZXRyaWVzIEhlbHBlcnNcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuLy8vIEdlbmVyYXRlIGdlb21ldHJ5IGZyb20gcGF0aCBwb2ludHMgKGZvciBMaW5lIG9yIFBhcnRpY2xlU3lzdGVtIG9iamVjdHMpXHJcblxyXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmNyZWF0ZVBvaW50c0dlb21ldHJ5ID0gZnVuY3Rpb24oIGRpdmlzaW9ucyApIHtcclxuXHJcblx0dmFyIHB0cyA9IHRoaXMuZ2V0UG9pbnRzKCBkaXZpc2lvbnMsIHRydWUgKTtcclxuXHRyZXR1cm4gdGhpcy5jcmVhdGVHZW9tZXRyeSggcHRzICk7XHJcblxyXG59O1xyXG5cclxuLy8gR2VuZXJhdGUgZ2VvbWV0cnkgZnJvbSBlcXVpZGlzdGFuY2Ugc2FtcGxpbmcgYWxvbmcgdGhlIHBhdGhcclxuXHJcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuY3JlYXRlU3BhY2VkUG9pbnRzR2VvbWV0cnkgPSBmdW5jdGlvbiggZGl2aXNpb25zICkge1xyXG5cclxuXHR2YXIgcHRzID0gdGhpcy5nZXRTcGFjZWRQb2ludHMoIGRpdmlzaW9ucywgdHJ1ZSApO1xyXG5cdHJldHVybiB0aGlzLmNyZWF0ZUdlb21ldHJ5KCBwdHMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmNyZWF0ZUdlb21ldHJ5ID0gZnVuY3Rpb24oIHBvaW50cyApIHtcclxuXHJcblx0dmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XHJcblxyXG5cdGZvciAoIHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0Z2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIHBvaW50c1sgaSBdLngsIHBvaW50c1sgaSBdLnksIHBvaW50c1sgaSBdLnogfHwgMCkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gZ2VvbWV0cnk7XHJcblxyXG59O1xyXG5cclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKlx0QmVuZCAvIFdyYXAgSGVscGVyIE1ldGhvZHNcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuLy8gV3JhcCBwYXRoIC8gQmVuZCBtb2RpZmllcnM/XHJcblxyXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmFkZFdyYXBQYXRoID0gZnVuY3Rpb24gKCBiZW5kcGF0aCApIHtcclxuXHJcblx0dGhpcy5iZW5kcy5wdXNoKCBiZW5kcGF0aCApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuZ2V0VHJhbnNmb3JtZWRQb2ludHMgPSBmdW5jdGlvbiggc2VnbWVudHMsIGJlbmRzICkge1xyXG5cclxuXHR2YXIgb2xkUHRzID0gdGhpcy5nZXRQb2ludHMoIHNlZ21lbnRzICk7IC8vIGdldFBvaW50cyBnZXRTcGFjZWRQb2ludHNcclxuXHR2YXIgaSwgaWw7XHJcblxyXG5cdGlmICggIWJlbmRzICkge1xyXG5cclxuXHRcdGJlbmRzID0gdGhpcy5iZW5kcztcclxuXHJcblx0fVxyXG5cclxuXHRmb3IgKCBpID0gMCwgaWwgPSBiZW5kcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRvbGRQdHMgPSB0aGlzLmdldFdyYXBQb2ludHMoIG9sZFB0cywgYmVuZHNbIGkgXSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBvbGRQdHM7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRUcmFuc2Zvcm1lZFNwYWNlZFBvaW50cyA9IGZ1bmN0aW9uKCBzZWdtZW50cywgYmVuZHMgKSB7XHJcblxyXG5cdHZhciBvbGRQdHMgPSB0aGlzLmdldFNwYWNlZFBvaW50cyggc2VnbWVudHMgKTtcclxuXHJcblx0dmFyIGksIGlsO1xyXG5cclxuXHRpZiAoICFiZW5kcyApIHtcclxuXHJcblx0XHRiZW5kcyA9IHRoaXMuYmVuZHM7XHJcblxyXG5cdH1cclxuXHJcblx0Zm9yICggaSA9IDAsIGlsID0gYmVuZHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0b2xkUHRzID0gdGhpcy5nZXRXcmFwUG9pbnRzKCBvbGRQdHMsIGJlbmRzWyBpIF0gKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gb2xkUHRzO1xyXG5cclxufTtcclxuXHJcbi8vIFRoaXMgcmV0dXJucyBnZXRQb2ludHMoKSBiZW5kL3dyYXBwZWQgYXJvdW5kIHRoZSBjb250b3VyIG9mIGEgcGF0aC5cclxuLy8gUmVhZCBodHRwOi8vd3d3LnBsYW5ldGNsZWdnLmNvbS9wcm9qZWN0cy9XYXJwaW5nVGV4dFRvU3BsaW5lcy5odG1sXHJcblxyXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmdldFdyYXBQb2ludHMgPSBmdW5jdGlvbiAoIG9sZFB0cywgcGF0aCApIHtcclxuXHJcblx0dmFyIGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRpbmdCb3goKTtcclxuXHJcblx0dmFyIGksIGlsLCBwLCBvbGRYLCBvbGRZLCB4Tm9ybTtcclxuXHJcblx0Zm9yICggaSA9IDAsIGlsID0gb2xkUHRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdHAgPSBvbGRQdHNbIGkgXTtcclxuXHJcblx0XHRvbGRYID0gcC54O1xyXG5cdFx0b2xkWSA9IHAueTtcclxuXHJcblx0XHR4Tm9ybSA9IG9sZFggLyBib3VuZHMubWF4WDtcclxuXHJcblx0XHQvLyBJZiB1c2luZyBhY3R1YWwgZGlzdGFuY2UsIGZvciBsZW5ndGggPiBwYXRoLCByZXF1aXJlcyBsaW5lIGV4dHJ1c2lvbnNcclxuXHRcdC8veE5vcm0gPSBwYXRoLmdldFV0b1RtYXBwaW5nKHhOb3JtLCBvbGRYKTsgLy8gMyBzdHlsZXMuIDEpIHdyYXAgc3RyZXRjaGVkLiAyKSB3cmFwIHN0cmV0Y2ggYnkgYXJjIGxlbmd0aCAzKSB3YXJwIGJ5IGFjdHVhbCBkaXN0YW5jZVxyXG5cclxuXHRcdHhOb3JtID0gcGF0aC5nZXRVdG9UbWFwcGluZyggeE5vcm0sIG9sZFggKTtcclxuXHJcblx0XHQvLyBjaGVjayBmb3Igb3V0IG9mIGJvdW5kcz9cclxuXHJcblx0XHR2YXIgcGF0aFB0ID0gcGF0aC5nZXRQb2ludCggeE5vcm0gKTtcclxuXHRcdHZhciBub3JtYWwgPSBwYXRoLmdldE5vcm1hbFZlY3RvciggeE5vcm0gKS5tdWx0aXBseVNjYWxhciggb2xkWSApO1xyXG5cclxuXHRcdHAueCA9IHBhdGhQdC54ICsgbm9ybWFsLng7XHJcblx0XHRwLnkgPSBwYXRoUHQueSArIG5vcm1hbC55O1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBvbGRQdHM7XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuR3lyb3Njb3BlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuR3lyb3Njb3BlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuR3lyb3Njb3BlLnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZCA9IGZ1bmN0aW9uICggZm9yY2UgKSB7XHJcblxyXG5cdHRoaXMubWF0cml4QXV0b1VwZGF0ZSAmJiB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xyXG5cclxuXHQvLyB1cGRhdGUgbWF0cml4V29ybGRcclxuXHJcblx0aWYgKCB0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgfHwgZm9yY2UgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnBhcmVudCApIHtcclxuXHJcblx0XHRcdHRoaXMubWF0cml4V29ybGQubXVsdGlwbHlNYXRyaWNlcyggdGhpcy5wYXJlbnQubWF0cml4V29ybGQsIHRoaXMubWF0cml4ICk7XHJcblxyXG5cdFx0XHR0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZSggdGhpcy50cmFuc2xhdGlvbldvcmxkLCB0aGlzLnJvdGF0aW9uV29ybGQsIHRoaXMuc2NhbGVXb3JsZCApO1xyXG5cdFx0XHR0aGlzLm1hdHJpeC5kZWNvbXBvc2UoIHRoaXMudHJhbnNsYXRpb25PYmplY3QsIHRoaXMucm90YXRpb25PYmplY3QsIHRoaXMuc2NhbGVPYmplY3QgKTtcclxuXHJcblx0XHRcdHRoaXMubWF0cml4V29ybGQuY29tcG9zZSggdGhpcy50cmFuc2xhdGlvbldvcmxkLCB0aGlzLnJvdGF0aW9uT2JqZWN0LCB0aGlzLnNjYWxlV29ybGQgKTtcclxuXHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMubWF0cml4V29ybGQuY29weSggdGhpcy5tYXRyaXggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cclxuXHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdGZvcmNlID0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuXHQvLyB1cGRhdGUgY2hpbGRyZW5cclxuXHJcblx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdHRoaXMuY2hpbGRyZW5bIGkgXS51cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLkd5cm9zY29wZS5wcm90b3R5cGUudHJhbnNsYXRpb25Xb3JsZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblRIUkVFLkd5cm9zY29wZS5wcm90b3R5cGUudHJhbnNsYXRpb25PYmplY3QgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5USFJFRS5HeXJvc2NvcGUucHJvdG90eXBlLnJvdGF0aW9uV29ybGQgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xyXG5USFJFRS5HeXJvc2NvcGUucHJvdG90eXBlLnJvdGF0aW9uT2JqZWN0ID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcclxuVEhSRUUuR3lyb3Njb3BlLnByb3RvdHlwZS5zY2FsZVdvcmxkID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuVEhSRUUuR3lyb3Njb3BlLnByb3RvdHlwZS5zY2FsZU9iamVjdCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4vKipcclxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG4gKiBDcmVhdGVzIGZyZWUgZm9ybSAyZCBwYXRoIHVzaW5nIHNlcmllcyBvZiBwb2ludHMsIGxpbmVzIG9yIGN1cnZlcy5cclxuICpcclxuICoqL1xyXG5cclxuVEhSRUUuUGF0aCA9IGZ1bmN0aW9uICggcG9pbnRzICkge1xyXG5cclxuXHRUSFJFRS5DdXJ2ZVBhdGguY2FsbCh0aGlzKTtcclxuXHJcblx0dGhpcy5hY3Rpb25zID0gW107XHJcblxyXG5cdGlmICggcG9pbnRzICkge1xyXG5cclxuXHRcdHRoaXMuZnJvbVBvaW50cyggcG9pbnRzICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5QYXRoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLlBhdGhBY3Rpb25zID0ge1xyXG5cclxuXHRNT1ZFX1RPOiAnbW92ZVRvJyxcclxuXHRMSU5FX1RPOiAnbGluZVRvJyxcclxuXHRRVUFEUkFUSUNfQ1VSVkVfVE86ICdxdWFkcmF0aWNDdXJ2ZVRvJywgLy8gQmV6aWVyIHF1YWRyYXRpYyBjdXJ2ZVxyXG5cdEJFWklFUl9DVVJWRV9UTzogJ2JlemllckN1cnZlVG8nLCBcdFx0Ly8gQmV6aWVyIGN1YmljIGN1cnZlXHJcblx0Q1NQTElORV9USFJVOiAnc3BsaW5lVGhydScsXHRcdFx0XHQvLyBDYXRtdWxsLXJvbSBzcGxpbmVcclxuXHRBUkM6ICdhcmMnLFx0XHRcdFx0XHRcdFx0XHQvLyBDaXJjbGVcclxuXHRFTExJUFNFOiAnZWxsaXBzZSdcclxufTtcclxuXHJcbi8vIFRPRE8gQ2xlYW4gdXAgUEFUSCBBUElcclxuXHJcbi8vIENyZWF0ZSBwYXRoIHVzaW5nIHN0cmFpZ2h0IGxpbmVzIHRvIGNvbm5lY3QgYWxsIHBvaW50c1xyXG4vLyAtIHZlY3RvcnM6IGFycmF5IG9mIFZlY3RvcjJcclxuXHJcblRIUkVFLlBhdGgucHJvdG90eXBlLmZyb21Qb2ludHMgPSBmdW5jdGlvbiAoIHZlY3RvcnMgKSB7XHJcblxyXG5cdHRoaXMubW92ZVRvKCB2ZWN0b3JzWyAwIF0ueCwgdmVjdG9yc1sgMCBdLnkgKTtcclxuXHJcblx0Zm9yICggdmFyIHYgPSAxLCB2bGVuID0gdmVjdG9ycy5sZW5ndGg7IHYgPCB2bGVuOyB2ICsrICkge1xyXG5cclxuXHRcdHRoaXMubGluZVRvKCB2ZWN0b3JzWyB2IF0ueCwgdmVjdG9yc1sgdiBdLnkgKTtcclxuXHJcblx0fTtcclxuXHJcbn07XHJcblxyXG4vLyBzdGFydFBhdGgoKSBlbmRQYXRoKCk/XHJcblxyXG5USFJFRS5QYXRoLnByb3RvdHlwZS5tb3ZlVG8gPSBmdW5jdGlvbiAoIHgsIHkgKSB7XHJcblxyXG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xyXG5cdHRoaXMuYWN0aW9ucy5wdXNoKCB7IGFjdGlvbjogVEhSRUUuUGF0aEFjdGlvbnMuTU9WRV9UTywgYXJnczogYXJncyB9ICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUGF0aC5wcm90b3R5cGUubGluZVRvID0gZnVuY3Rpb24gKCB4LCB5ICkge1xyXG5cclxuXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcclxuXHJcblx0dmFyIGxhc3RhcmdzID0gdGhpcy5hY3Rpb25zWyB0aGlzLmFjdGlvbnMubGVuZ3RoIC0gMSBdLmFyZ3M7XHJcblxyXG5cdHZhciB4MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAyIF07XHJcblx0dmFyIHkwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDEgXTtcclxuXHJcblx0dmFyIGN1cnZlID0gbmV3IFRIUkVFLkxpbmVDdXJ2ZSggbmV3IFRIUkVFLlZlY3RvcjIoIHgwLCB5MCApLCBuZXcgVEhSRUUuVmVjdG9yMiggeCwgeSApICk7XHJcblx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcclxuXHJcblx0dGhpcy5hY3Rpb25zLnB1c2goIHsgYWN0aW9uOiBUSFJFRS5QYXRoQWN0aW9ucy5MSU5FX1RPLCBhcmdzOiBhcmdzIH0gKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5QYXRoLnByb3RvdHlwZS5xdWFkcmF0aWNDdXJ2ZVRvID0gZnVuY3Rpb24oIGFDUHgsIGFDUHksIGFYLCBhWSApIHtcclxuXHJcblx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XHJcblxyXG5cdHZhciBsYXN0YXJncyA9IHRoaXMuYWN0aW9uc1sgdGhpcy5hY3Rpb25zLmxlbmd0aCAtIDEgXS5hcmdzO1xyXG5cclxuXHR2YXIgeDAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMiBdO1xyXG5cdHZhciB5MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAxIF07XHJcblxyXG5cdHZhciBjdXJ2ZSA9IG5ldyBUSFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZSggbmV3IFRIUkVFLlZlY3RvcjIoIHgwLCB5MCApLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYUNQeCwgYUNQeSApLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYVgsIGFZICkgKTtcclxuXHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xyXG5cclxuXHR0aGlzLmFjdGlvbnMucHVzaCggeyBhY3Rpb246IFRIUkVFLlBhdGhBY3Rpb25zLlFVQURSQVRJQ19DVVJWRV9UTywgYXJnczogYXJncyB9ICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUGF0aC5wcm90b3R5cGUuYmV6aWVyQ3VydmVUbyA9IGZ1bmN0aW9uKCBhQ1AxeCwgYUNQMXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUNQMngsIGFDUDJ5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFYLCBhWSApIHtcclxuXHJcblx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XHJcblxyXG5cdHZhciBsYXN0YXJncyA9IHRoaXMuYWN0aW9uc1sgdGhpcy5hY3Rpb25zLmxlbmd0aCAtIDEgXS5hcmdzO1xyXG5cclxuXHR2YXIgeDAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMiBdO1xyXG5cdHZhciB5MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAxIF07XHJcblxyXG5cdHZhciBjdXJ2ZSA9IG5ldyBUSFJFRS5DdWJpY0JlemllckN1cnZlKCBuZXcgVEhSRUUuVmVjdG9yMiggeDAsIHkwICksXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYUNQMXgsIGFDUDF5ICksXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYUNQMngsIGFDUDJ5ICksXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYVgsIGFZICkgKTtcclxuXHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xyXG5cclxuXHR0aGlzLmFjdGlvbnMucHVzaCggeyBhY3Rpb246IFRIUkVFLlBhdGhBY3Rpb25zLkJFWklFUl9DVVJWRV9UTywgYXJnczogYXJncyB9ICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUGF0aC5wcm90b3R5cGUuc3BsaW5lVGhydSA9IGZ1bmN0aW9uKCBwdHMgLypBcnJheSBvZiBWZWN0b3IqLyApIHtcclxuXHJcblx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XHJcblx0dmFyIGxhc3RhcmdzID0gdGhpcy5hY3Rpb25zWyB0aGlzLmFjdGlvbnMubGVuZ3RoIC0gMSBdLmFyZ3M7XHJcblxyXG5cdHZhciB4MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAyIF07XHJcblx0dmFyIHkwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDEgXTtcclxuLy8tLS1cclxuXHR2YXIgbnB0cyA9IFsgbmV3IFRIUkVFLlZlY3RvcjIoIHgwLCB5MCApIF07XHJcblx0QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoIG5wdHMsIHB0cyApO1xyXG5cclxuXHR2YXIgY3VydmUgPSBuZXcgVEhSRUUuU3BsaW5lQ3VydmUoIG5wdHMgKTtcclxuXHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xyXG5cclxuXHR0aGlzLmFjdGlvbnMucHVzaCggeyBhY3Rpb246IFRIUkVFLlBhdGhBY3Rpb25zLkNTUExJTkVfVEhSVSwgYXJnczogYXJncyB9ICk7XHJcblxyXG59O1xyXG5cclxuLy8gRlVUVVJFOiBDaGFuZ2UgdGhlIEFQSSBvciBmb2xsb3cgY2FudmFzIEFQST9cclxuXHJcblRIUkVFLlBhdGgucHJvdG90eXBlLmFyYyA9IGZ1bmN0aW9uICggYVgsIGFZLCBhUmFkaXVzLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHQgIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XHJcblxyXG5cdHZhciBsYXN0YXJncyA9IHRoaXMuYWN0aW9uc1sgdGhpcy5hY3Rpb25zLmxlbmd0aCAtIDFdLmFyZ3M7XHJcblx0dmFyIHgwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDIgXTtcclxuXHR2YXIgeTAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMSBdO1xyXG5cclxuXHR0aGlzLmFic2FyYyhhWCArIHgwLCBhWSArIHkwLCBhUmFkaXVzLFxyXG5cdFx0YVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xyXG5cdFxyXG4gfTtcclxuXHJcbiBUSFJFRS5QYXRoLnByb3RvdHlwZS5hYnNhcmMgPSBmdW5jdGlvbiAoIGFYLCBhWSwgYVJhZGl1cyxcclxuXHRcdFx0XHRcdFx0XHRcdFx0ICBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICkge1xyXG5cdHRoaXMuYWJzZWxsaXBzZShhWCwgYVksIGFSYWRpdXMsIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UpO1xyXG4gfTtcclxuIFxyXG5USFJFRS5QYXRoLnByb3RvdHlwZS5lbGxpcHNlID0gZnVuY3Rpb24gKCBhWCwgYVksIHhSYWRpdXMsIHlSYWRpdXMsXHJcblx0XHRcdFx0XHRcdFx0XHRcdCAgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApIHtcclxuXHJcblx0dmFyIGxhc3RhcmdzID0gdGhpcy5hY3Rpb25zWyB0aGlzLmFjdGlvbnMubGVuZ3RoIC0gMV0uYXJncztcclxuXHR2YXIgeDAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMiBdO1xyXG5cdHZhciB5MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAxIF07XHJcblxyXG5cdHRoaXMuYWJzZWxsaXBzZShhWCArIHgwLCBhWSArIHkwLCB4UmFkaXVzLCB5UmFkaXVzLFxyXG5cdFx0YVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xyXG5cclxuIH07XHJcbiBcclxuXHJcblRIUkVFLlBhdGgucHJvdG90eXBlLmFic2VsbGlwc2UgPSBmdW5jdGlvbiAoIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cyxcclxuXHRcdFx0XHRcdFx0XHRcdFx0ICBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICkge1xyXG5cclxuXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcclxuXHR2YXIgY3VydmUgPSBuZXcgVEhSRUUuRWxsaXBzZUN1cnZlKCBhWCwgYVksIHhSYWRpdXMsIHlSYWRpdXMsXHJcblx0XHRcdFx0XHRcdFx0XHRcdGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKTtcclxuXHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xyXG5cclxuXHR2YXIgbGFzdFBvaW50ID0gY3VydmUuZ2V0UG9pbnQoYUNsb2Nrd2lzZSA/IDEgOiAwKTtcclxuXHRhcmdzLnB1c2gobGFzdFBvaW50LngpO1xyXG5cdGFyZ3MucHVzaChsYXN0UG9pbnQueSk7XHJcblxyXG5cdHRoaXMuYWN0aW9ucy5wdXNoKCB7IGFjdGlvbjogVEhSRUUuUGF0aEFjdGlvbnMuRUxMSVBTRSwgYXJnczogYXJncyB9ICk7XHJcblxyXG4gfTtcclxuXHJcblRIUkVFLlBhdGgucHJvdG90eXBlLmdldFNwYWNlZFBvaW50cyA9IGZ1bmN0aW9uICggZGl2aXNpb25zLCBjbG9zZWRQYXRoICkge1xyXG5cclxuXHRpZiAoICEgZGl2aXNpb25zICkgZGl2aXNpb25zID0gNDA7XHJcblxyXG5cdHZhciBwb2ludHMgPSBbXTtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZGl2aXNpb25zOyBpICsrICkge1xyXG5cclxuXHRcdHBvaW50cy5wdXNoKCB0aGlzLmdldFBvaW50KCBpIC8gZGl2aXNpb25zICkgKTtcclxuXHJcblx0XHQvL2lmKCAhdGhpcy5nZXRQb2ludCggaSAvIGRpdmlzaW9ucyApICkgdGhyb3cgXCJESUVcIjtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBpZiAoIGNsb3NlZFBhdGggKSB7XHJcblx0Ly9cclxuXHQvLyBcdHBvaW50cy5wdXNoKCBwb2ludHNbIDAgXSApO1xyXG5cdC8vXHJcblx0Ly8gfVxyXG5cclxuXHRyZXR1cm4gcG9pbnRzO1xyXG5cclxufTtcclxuXHJcbi8qIFJldHVybiBhbiBhcnJheSBvZiB2ZWN0b3JzIGJhc2VkIG9uIGNvbnRvdXIgb2YgdGhlIHBhdGggKi9cclxuXHJcblRIUkVFLlBhdGgucHJvdG90eXBlLmdldFBvaW50cyA9IGZ1bmN0aW9uKCBkaXZpc2lvbnMsIGNsb3NlZFBhdGggKSB7XHJcblxyXG5cdGlmICh0aGlzLnVzZVNwYWNlZFBvaW50cykge1xyXG5cdFx0Y29uc29sZS5sb2coJ3RhdGEnKTtcclxuXHRcdHJldHVybiB0aGlzLmdldFNwYWNlZFBvaW50cyggZGl2aXNpb25zLCBjbG9zZWRQYXRoICk7XHJcblx0fVxyXG5cclxuXHRkaXZpc2lvbnMgPSBkaXZpc2lvbnMgfHwgMTI7XHJcblxyXG5cdHZhciBwb2ludHMgPSBbXTtcclxuXHJcblx0dmFyIGksIGlsLCBpdGVtLCBhY3Rpb24sIGFyZ3M7XHJcblx0dmFyIGNweCwgY3B5LCBjcHgyLCBjcHkyLCBjcHgxLCBjcHkxLCBjcHgwLCBjcHkwLFxyXG5cdFx0bGFzdGUsIGosXHJcblx0XHR0LCB0eCwgdHk7XHJcblxyXG5cdGZvciAoIGkgPSAwLCBpbCA9IHRoaXMuYWN0aW9ucy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRpdGVtID0gdGhpcy5hY3Rpb25zWyBpIF07XHJcblxyXG5cdFx0YWN0aW9uID0gaXRlbS5hY3Rpb247XHJcblx0XHRhcmdzID0gaXRlbS5hcmdzO1xyXG5cclxuXHRcdHN3aXRjaCggYWN0aW9uICkge1xyXG5cclxuXHRcdGNhc2UgVEhSRUUuUGF0aEFjdGlvbnMuTU9WRV9UTzpcclxuXHJcblx0XHRcdHBvaW50cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggYXJnc1sgMCBdLCBhcmdzWyAxIF0gKSApO1xyXG5cclxuXHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0Y2FzZSBUSFJFRS5QYXRoQWN0aW9ucy5MSU5FX1RPOlxyXG5cclxuXHRcdFx0cG9pbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCBhcmdzWyAwIF0sIGFyZ3NbIDEgXSApICk7XHJcblxyXG5cdFx0XHRicmVhaztcclxuXHJcblx0XHRjYXNlIFRIUkVFLlBhdGhBY3Rpb25zLlFVQURSQVRJQ19DVVJWRV9UTzpcclxuXHJcblx0XHRcdGNweCAgPSBhcmdzWyAyIF07XHJcblx0XHRcdGNweSAgPSBhcmdzWyAzIF07XHJcblxyXG5cdFx0XHRjcHgxID0gYXJnc1sgMCBdO1xyXG5cdFx0XHRjcHkxID0gYXJnc1sgMSBdO1xyXG5cclxuXHRcdFx0aWYgKCBwb2ludHMubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdFx0bGFzdGUgPSBwb2ludHNbIHBvaW50cy5sZW5ndGggLSAxIF07XHJcblxyXG5cdFx0XHRcdGNweDAgPSBsYXN0ZS54O1xyXG5cdFx0XHRcdGNweTAgPSBsYXN0ZS55O1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0bGFzdGUgPSB0aGlzLmFjdGlvbnNbIGkgLSAxIF0uYXJncztcclxuXHJcblx0XHRcdFx0Y3B4MCA9IGxhc3RlWyBsYXN0ZS5sZW5ndGggLSAyIF07XHJcblx0XHRcdFx0Y3B5MCA9IGxhc3RlWyBsYXN0ZS5sZW5ndGggLSAxIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKCBqID0gMTsgaiA8PSBkaXZpc2lvbnM7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdHQgPSBqIC8gZGl2aXNpb25zO1xyXG5cclxuXHRcdFx0XHR0eCA9IFRIUkVFLlNoYXBlLlV0aWxzLmIyKCB0LCBjcHgwLCBjcHgxLCBjcHggKTtcclxuXHRcdFx0XHR0eSA9IFRIUkVFLlNoYXBlLlV0aWxzLmIyKCB0LCBjcHkwLCBjcHkxLCBjcHkgKTtcclxuXHJcblx0XHRcdFx0cG9pbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB0eCwgdHkgKSApO1xyXG5cclxuXHRcdCAgXHR9XHJcblxyXG5cdFx0XHRicmVhaztcclxuXHJcblx0XHRjYXNlIFRIUkVFLlBhdGhBY3Rpb25zLkJFWklFUl9DVVJWRV9UTzpcclxuXHJcblx0XHRcdGNweCAgPSBhcmdzWyA0IF07XHJcblx0XHRcdGNweSAgPSBhcmdzWyA1IF07XHJcblxyXG5cdFx0XHRjcHgxID0gYXJnc1sgMCBdO1xyXG5cdFx0XHRjcHkxID0gYXJnc1sgMSBdO1xyXG5cclxuXHRcdFx0Y3B4MiA9IGFyZ3NbIDIgXTtcclxuXHRcdFx0Y3B5MiA9IGFyZ3NbIDMgXTtcclxuXHJcblx0XHRcdGlmICggcG9pbnRzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdGxhc3RlID0gcG9pbnRzWyBwb2ludHMubGVuZ3RoIC0gMSBdO1xyXG5cclxuXHRcdFx0XHRjcHgwID0gbGFzdGUueDtcclxuXHRcdFx0XHRjcHkwID0gbGFzdGUueTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGxhc3RlID0gdGhpcy5hY3Rpb25zWyBpIC0gMSBdLmFyZ3M7XHJcblxyXG5cdFx0XHRcdGNweDAgPSBsYXN0ZVsgbGFzdGUubGVuZ3RoIC0gMiBdO1xyXG5cdFx0XHRcdGNweTAgPSBsYXN0ZVsgbGFzdGUubGVuZ3RoIC0gMSBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdGZvciAoIGogPSAxOyBqIDw9IGRpdmlzaW9uczsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0dCA9IGogLyBkaXZpc2lvbnM7XHJcblxyXG5cdFx0XHRcdHR4ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjMoIHQsIGNweDAsIGNweDEsIGNweDIsIGNweCApO1xyXG5cdFx0XHRcdHR5ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjMoIHQsIGNweTAsIGNweTEsIGNweTIsIGNweSApO1xyXG5cclxuXHRcdFx0XHRwb2ludHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHR4LCB0eSApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRicmVhaztcclxuXHJcblx0XHRjYXNlIFRIUkVFLlBhdGhBY3Rpb25zLkNTUExJTkVfVEhSVTpcclxuXHJcblx0XHRcdGxhc3RlID0gdGhpcy5hY3Rpb25zWyBpIC0gMSBdLmFyZ3M7XHJcblxyXG5cdFx0XHR2YXIgbGFzdCA9IG5ldyBUSFJFRS5WZWN0b3IyKCBsYXN0ZVsgbGFzdGUubGVuZ3RoIC0gMiBdLCBsYXN0ZVsgbGFzdGUubGVuZ3RoIC0gMSBdICk7XHJcblx0XHRcdHZhciBzcHRzID0gWyBsYXN0IF07XHJcblxyXG5cdFx0XHR2YXIgbiA9IGRpdmlzaW9ucyAqIGFyZ3NbIDAgXS5sZW5ndGg7XHJcblxyXG5cdFx0XHRzcHRzID0gc3B0cy5jb25jYXQoIGFyZ3NbIDAgXSApO1xyXG5cclxuXHRcdFx0dmFyIHNwbGluZSA9IG5ldyBUSFJFRS5TcGxpbmVDdXJ2ZSggc3B0cyApO1xyXG5cclxuXHRcdFx0Zm9yICggaiA9IDE7IGogPD0gbjsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0cG9pbnRzLnB1c2goIHNwbGluZS5nZXRQb2ludEF0KCBqIC8gbiApICkgO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0Y2FzZSBUSFJFRS5QYXRoQWN0aW9ucy5BUkM6XHJcblxyXG5cdFx0XHR2YXIgYVggPSBhcmdzWyAwIF0sIGFZID0gYXJnc1sgMSBdLFxyXG5cdFx0XHRcdGFSYWRpdXMgPSBhcmdzWyAyIF0sXHJcblx0XHRcdFx0YVN0YXJ0QW5nbGUgPSBhcmdzWyAzIF0sIGFFbmRBbmdsZSA9IGFyZ3NbIDQgXSxcclxuXHRcdFx0XHRhQ2xvY2t3aXNlID0gISFhcmdzWyA1IF07XHJcblxyXG5cdFx0XHR2YXIgZGVsdGFBbmdsZSA9IGFFbmRBbmdsZSAtIGFTdGFydEFuZ2xlO1xyXG5cdFx0XHR2YXIgYW5nbGU7XHJcblx0XHRcdHZhciB0ZGl2aXNpb25zID0gZGl2aXNpb25zICogMjtcclxuXHJcblx0XHRcdGZvciAoIGogPSAxOyBqIDw9IHRkaXZpc2lvbnM7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdHQgPSBqIC8gdGRpdmlzaW9ucztcclxuXHJcblx0XHRcdFx0aWYgKCAhIGFDbG9ja3dpc2UgKSB7XHJcblxyXG5cdFx0XHRcdFx0dCA9IDEgLSB0O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGFuZ2xlID0gYVN0YXJ0QW5nbGUgKyB0ICogZGVsdGFBbmdsZTtcclxuXHJcblx0XHRcdFx0dHggPSBhWCArIGFSYWRpdXMgKiBNYXRoLmNvcyggYW5nbGUgKTtcclxuXHRcdFx0XHR0eSA9IGFZICsgYVJhZGl1cyAqIE1hdGguc2luKCBhbmdsZSApO1xyXG5cclxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCd0JywgdCwgJ2FuZ2xlJywgYW5nbGUsICd0eCcsIHR4LCAndHknLCB0eSk7XHJcblxyXG5cdFx0XHRcdHBvaW50cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggdHgsIHR5ICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vY29uc29sZS5sb2cocG9pbnRzKTtcclxuXHJcblx0XHQgIGJyZWFrO1xyXG5cdFx0ICBcclxuXHRcdGNhc2UgVEhSRUUuUGF0aEFjdGlvbnMuRUxMSVBTRTpcclxuXHJcblx0XHRcdHZhciBhWCA9IGFyZ3NbIDAgXSwgYVkgPSBhcmdzWyAxIF0sXHJcblx0XHRcdFx0eFJhZGl1cyA9IGFyZ3NbIDIgXSxcclxuXHRcdFx0XHR5UmFkaXVzID0gYXJnc1sgMyBdLFxyXG5cdFx0XHRcdGFTdGFydEFuZ2xlID0gYXJnc1sgNCBdLCBhRW5kQW5nbGUgPSBhcmdzWyA1IF0sXHJcblx0XHRcdFx0YUNsb2Nrd2lzZSA9ICEhYXJnc1sgNiBdO1xyXG5cclxuXHJcblx0XHRcdHZhciBkZWx0YUFuZ2xlID0gYUVuZEFuZ2xlIC0gYVN0YXJ0QW5nbGU7XHJcblx0XHRcdHZhciBhbmdsZTtcclxuXHRcdFx0dmFyIHRkaXZpc2lvbnMgPSBkaXZpc2lvbnMgKiAyO1xyXG5cclxuXHRcdFx0Zm9yICggaiA9IDE7IGogPD0gdGRpdmlzaW9uczsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0dCA9IGogLyB0ZGl2aXNpb25zO1xyXG5cclxuXHRcdFx0XHRpZiAoICEgYUNsb2Nrd2lzZSApIHtcclxuXHJcblx0XHRcdFx0XHR0ID0gMSAtIHQ7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0YW5nbGUgPSBhU3RhcnRBbmdsZSArIHQgKiBkZWx0YUFuZ2xlO1xyXG5cclxuXHRcdFx0XHR0eCA9IGFYICsgeFJhZGl1cyAqIE1hdGguY29zKCBhbmdsZSApO1xyXG5cdFx0XHRcdHR5ID0gYVkgKyB5UmFkaXVzICogTWF0aC5zaW4oIGFuZ2xlICk7XHJcblxyXG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ3QnLCB0LCAnYW5nbGUnLCBhbmdsZSwgJ3R4JywgdHgsICd0eScsIHR5KTtcclxuXHJcblx0XHRcdFx0cG9pbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB0eCwgdHkgKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly9jb25zb2xlLmxvZyhwb2ludHMpO1xyXG5cclxuXHRcdCAgYnJlYWs7XHJcblxyXG5cdFx0fSAvLyBlbmQgc3dpdGNoXHJcblxyXG5cdH1cclxuXHJcblxyXG5cclxuXHQvLyBOb3JtYWxpemUgdG8gcmVtb3ZlIHRoZSBjbG9zaW5nIHBvaW50IGJ5IGRlZmF1bHQuXHJcblx0dmFyIGxhc3RQb2ludCA9IHBvaW50c1sgcG9pbnRzLmxlbmd0aCAtIDFdO1xyXG5cdHZhciBFUFNJTE9OID0gMC4wMDAwMDAwMDAxO1xyXG5cdGlmICggTWF0aC5hYnMobGFzdFBvaW50LnggLSBwb2ludHNbIDAgXS54KSA8IEVQU0lMT04gJiZcclxuICAgICAgICAgICAgIE1hdGguYWJzKGxhc3RQb2ludC55IC0gcG9pbnRzWyAwIF0ueSkgPCBFUFNJTE9OKVxyXG5cdFx0cG9pbnRzLnNwbGljZSggcG9pbnRzLmxlbmd0aCAtIDEsIDEpO1xyXG5cdGlmICggY2xvc2VkUGF0aCApIHtcclxuXHJcblx0XHRwb2ludHMucHVzaCggcG9pbnRzWyAwIF0gKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcG9pbnRzO1xyXG5cclxufTtcclxuXHJcbi8vIEJyZWFrcyBwYXRoIGludG8gc2hhcGVzXHJcblxyXG5USFJFRS5QYXRoLnByb3RvdHlwZS50b1NoYXBlcyA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHR2YXIgaSwgaWwsIGl0ZW0sIGFjdGlvbiwgYXJncztcclxuXHJcblx0dmFyIHN1YlBhdGhzID0gW10sIGxhc3RQYXRoID0gbmV3IFRIUkVFLlBhdGgoKTtcclxuXHJcblx0Zm9yICggaSA9IDAsIGlsID0gdGhpcy5hY3Rpb25zLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdGl0ZW0gPSB0aGlzLmFjdGlvbnNbIGkgXTtcclxuXHJcblx0XHRhcmdzID0gaXRlbS5hcmdzO1xyXG5cdFx0YWN0aW9uID0gaXRlbS5hY3Rpb247XHJcblxyXG5cdFx0aWYgKCBhY3Rpb24gPT0gVEhSRUUuUGF0aEFjdGlvbnMuTU9WRV9UTyApIHtcclxuXHJcblx0XHRcdGlmICggbGFzdFBhdGguYWN0aW9ucy5sZW5ndGggIT0gMCApIHtcclxuXHJcblx0XHRcdFx0c3ViUGF0aHMucHVzaCggbGFzdFBhdGggKTtcclxuXHRcdFx0XHRsYXN0UGF0aCA9IG5ldyBUSFJFRS5QYXRoKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGxhc3RQYXRoWyBhY3Rpb24gXS5hcHBseSggbGFzdFBhdGgsIGFyZ3MgKTtcclxuXHJcblx0fVxyXG5cclxuXHRpZiAoIGxhc3RQYXRoLmFjdGlvbnMubGVuZ3RoICE9IDAgKSB7XHJcblxyXG5cdFx0c3ViUGF0aHMucHVzaCggbGFzdFBhdGggKTtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBjb25zb2xlLmxvZyhzdWJQYXRocyk7XHJcblxyXG5cdGlmICggc3ViUGF0aHMubGVuZ3RoID09IDAgKSByZXR1cm4gW107XHJcblxyXG5cdHZhciB0bXBQYXRoLCB0bXBTaGFwZSwgc2hhcGVzID0gW107XHJcblxyXG5cdHZhciBob2xlc0ZpcnN0ID0gIVRIUkVFLlNoYXBlLlV0aWxzLmlzQ2xvY2tXaXNlKCBzdWJQYXRoc1sgMCBdLmdldFBvaW50cygpICk7XHJcblx0Ly8gY29uc29sZS5sb2coXCJIb2xlcyBmaXJzdFwiLCBob2xlc0ZpcnN0KTtcclxuXHJcblx0aWYgKCBzdWJQYXRocy5sZW5ndGggPT0gMSkge1xyXG5cdFx0dG1wUGF0aCA9IHN1YlBhdGhzWzBdO1xyXG5cdFx0dG1wU2hhcGUgPSBuZXcgVEhSRUUuU2hhcGUoKTtcclxuXHRcdHRtcFNoYXBlLmFjdGlvbnMgPSB0bXBQYXRoLmFjdGlvbnM7XHJcblx0XHR0bXBTaGFwZS5jdXJ2ZXMgPSB0bXBQYXRoLmN1cnZlcztcclxuXHRcdHNoYXBlcy5wdXNoKCB0bXBTaGFwZSApO1xyXG5cdFx0cmV0dXJuIHNoYXBlcztcclxuXHR9O1xyXG5cclxuXHRpZiAoIGhvbGVzRmlyc3QgKSB7XHJcblxyXG5cdFx0dG1wU2hhcGUgPSBuZXcgVEhSRUUuU2hhcGUoKTtcclxuXHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSBzdWJQYXRocy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHRtcFBhdGggPSBzdWJQYXRoc1sgaSBdO1xyXG5cclxuXHRcdFx0aWYgKCBUSFJFRS5TaGFwZS5VdGlscy5pc0Nsb2NrV2lzZSggdG1wUGF0aC5nZXRQb2ludHMoKSApICkge1xyXG5cclxuXHRcdFx0XHR0bXBTaGFwZS5hY3Rpb25zID0gdG1wUGF0aC5hY3Rpb25zO1xyXG5cdFx0XHRcdHRtcFNoYXBlLmN1cnZlcyA9IHRtcFBhdGguY3VydmVzO1xyXG5cclxuXHRcdFx0XHRzaGFwZXMucHVzaCggdG1wU2hhcGUgKTtcclxuXHRcdFx0XHR0bXBTaGFwZSA9IG5ldyBUSFJFRS5TaGFwZSgpO1xyXG5cclxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdjdycsIGkpO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dG1wU2hhcGUuaG9sZXMucHVzaCggdG1wUGF0aCApO1xyXG5cclxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdjY3cnLCBpKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0Ly8gU2hhcGVzIGZpcnN0XHJcblxyXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gc3ViUGF0aHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR0bXBQYXRoID0gc3ViUGF0aHNbIGkgXTtcclxuXHJcblx0XHRcdGlmICggVEhSRUUuU2hhcGUuVXRpbHMuaXNDbG9ja1dpc2UoIHRtcFBhdGguZ2V0UG9pbnRzKCkgKSApIHtcclxuXHJcblxyXG5cdFx0XHRcdGlmICggdG1wU2hhcGUgKSBzaGFwZXMucHVzaCggdG1wU2hhcGUgKTtcclxuXHJcblx0XHRcdFx0dG1wU2hhcGUgPSBuZXcgVEhSRUUuU2hhcGUoKTtcclxuXHRcdFx0XHR0bXBTaGFwZS5hY3Rpb25zID0gdG1wUGF0aC5hY3Rpb25zO1xyXG5cdFx0XHRcdHRtcFNoYXBlLmN1cnZlcyA9IHRtcFBhdGguY3VydmVzO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dG1wU2hhcGUuaG9sZXMucHVzaCggdG1wUGF0aCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRzaGFwZXMucHVzaCggdG1wU2hhcGUgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvL2NvbnNvbGUubG9nKFwic2hhcGVcIiwgc2hhcGVzKTtcclxuXHJcblx0cmV0dXJuIHNoYXBlcztcclxuXHJcbn07XHJcbi8qKlxyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXHJcbiAqIERlZmluZXMgYSAyZCBzaGFwZSBwbGFuZSB1c2luZyBwYXRocy5cclxuICoqL1xyXG5cclxuLy8gU1RFUCAxIENyZWF0ZSBhIHBhdGguXHJcbi8vIFNURVAgMiBUdXJuIHBhdGggaW50byBzaGFwZS5cclxuLy8gU1RFUCAzIEV4dHJ1ZGVHZW9tZXRyeSB0YWtlcyBpbiBTaGFwZS9TaGFwZXNcclxuLy8gU1RFUCAzYSAtIEV4dHJhY3QgcG9pbnRzIGZyb20gZWFjaCBzaGFwZSwgdHVybiB0byB2ZXJ0aWNlc1xyXG4vLyBTVEVQIDNiIC0gVHJpYW5ndWxhdGUgZWFjaCBzaGFwZSwgYWRkIGZhY2VzLlxyXG5cclxuVEhSRUUuU2hhcGUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFRIUkVFLlBhdGguYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xyXG5cdHRoaXMuaG9sZXMgPSBbXTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5TaGFwZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5QYXRoLnByb3RvdHlwZSApO1xyXG5cclxuLy8gQ29udmVuaWVuY2UgbWV0aG9kIHRvIHJldHVybiBFeHRydWRlR2VvbWV0cnlcclxuXHJcblRIUkVFLlNoYXBlLnByb3RvdHlwZS5leHRydWRlID0gZnVuY3Rpb24gKCBvcHRpb25zICkge1xyXG5cclxuXHR2YXIgZXh0cnVkZWQgPSBuZXcgVEhSRUUuRXh0cnVkZUdlb21ldHJ5KCB0aGlzLCBvcHRpb25zICk7XHJcblx0cmV0dXJuIGV4dHJ1ZGVkO1xyXG5cclxufTtcclxuXHJcbi8vIENvbnZlbmllbmNlIG1ldGhvZCB0byByZXR1cm4gU2hhcGVHZW9tZXRyeVxyXG5cclxuVEhSRUUuU2hhcGUucHJvdG90eXBlLm1ha2VHZW9tZXRyeSA9IGZ1bmN0aW9uICggb3B0aW9ucyApIHtcclxuXHJcblx0dmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlNoYXBlR2VvbWV0cnkoIHRoaXMsIG9wdGlvbnMgKTtcclxuXHRyZXR1cm4gZ2VvbWV0cnk7XHJcblxyXG59O1xyXG5cclxuLy8gR2V0IHBvaW50cyBvZiBob2xlc1xyXG5cclxuVEhSRUUuU2hhcGUucHJvdG90eXBlLmdldFBvaW50c0hvbGVzID0gZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XHJcblxyXG5cdHZhciBpLCBpbCA9IHRoaXMuaG9sZXMubGVuZ3RoLCBob2xlc1B0cyA9IFtdO1xyXG5cclxuXHRmb3IgKCBpID0gMDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdGhvbGVzUHRzWyBpIF0gPSB0aGlzLmhvbGVzWyBpIF0uZ2V0VHJhbnNmb3JtZWRQb2ludHMoIGRpdmlzaW9ucywgdGhpcy5iZW5kcyApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBob2xlc1B0cztcclxuXHJcbn07XHJcblxyXG4vLyBHZXQgcG9pbnRzIG9mIGhvbGVzIChzcGFjZWQgYnkgcmVndWxhciBkaXN0YW5jZSlcclxuXHJcblRIUkVFLlNoYXBlLnByb3RvdHlwZS5nZXRTcGFjZWRQb2ludHNIb2xlcyA9IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xyXG5cclxuXHR2YXIgaSwgaWwgPSB0aGlzLmhvbGVzLmxlbmd0aCwgaG9sZXNQdHMgPSBbXTtcclxuXHJcblx0Zm9yICggaSA9IDA7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRob2xlc1B0c1sgaSBdID0gdGhpcy5ob2xlc1sgaSBdLmdldFRyYW5zZm9ybWVkU3BhY2VkUG9pbnRzKCBkaXZpc2lvbnMsIHRoaXMuYmVuZHMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gaG9sZXNQdHM7XHJcblxyXG59O1xyXG5cclxuXHJcbi8vIEdldCBwb2ludHMgb2Ygc2hhcGUgYW5kIGhvbGVzIChrZXlwb2ludHMgYmFzZWQgb24gc2VnbWVudHMgcGFyYW1ldGVyKVxyXG5cclxuVEhSRUUuU2hhcGUucHJvdG90eXBlLmV4dHJhY3RBbGxQb2ludHMgPSBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcclxuXHJcblx0cmV0dXJuIHtcclxuXHJcblx0XHRzaGFwZTogdGhpcy5nZXRUcmFuc2Zvcm1lZFBvaW50cyggZGl2aXNpb25zICksXHJcblx0XHRob2xlczogdGhpcy5nZXRQb2ludHNIb2xlcyggZGl2aXNpb25zIClcclxuXHJcblx0fTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5TaGFwZS5wcm90b3R5cGUuZXh0cmFjdFBvaW50cyA9IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xyXG5cclxuXHRpZiAodGhpcy51c2VTcGFjZWRQb2ludHMpIHtcclxuXHRcdHJldHVybiB0aGlzLmV4dHJhY3RBbGxTcGFjZWRQb2ludHMoZGl2aXNpb25zKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiB0aGlzLmV4dHJhY3RBbGxQb2ludHMoZGl2aXNpb25zKTtcclxuXHJcbn07XHJcblxyXG4vL1xyXG4vLyBUSFJFRS5TaGFwZS5wcm90b3R5cGUuZXh0cmFjdEFsbFBvaW50c1dpdGhCZW5kID0gZnVuY3Rpb24gKCBkaXZpc2lvbnMsIGJlbmQgKSB7XHJcbi8vXHJcbi8vIFx0cmV0dXJuIHtcclxuLy9cclxuLy8gXHRcdHNoYXBlOiB0aGlzLnRyYW5zZm9ybSggYmVuZCwgZGl2aXNpb25zICksXHJcbi8vIFx0XHRob2xlczogdGhpcy5nZXRQb2ludHNIb2xlcyggZGl2aXNpb25zLCBiZW5kIClcclxuLy9cclxuLy8gXHR9O1xyXG4vL1xyXG4vLyB9O1xyXG5cclxuLy8gR2V0IHBvaW50cyBvZiBzaGFwZSBhbmQgaG9sZXMgKHNwYWNlZCBieSByZWd1bGFyIGRpc3RhbmNlKVxyXG5cclxuVEhSRUUuU2hhcGUucHJvdG90eXBlLmV4dHJhY3RBbGxTcGFjZWRQb2ludHMgPSBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcclxuXHJcblx0cmV0dXJuIHtcclxuXHJcblx0XHRzaGFwZTogdGhpcy5nZXRUcmFuc2Zvcm1lZFNwYWNlZFBvaW50cyggZGl2aXNpb25zICksXHJcblx0XHRob2xlczogdGhpcy5nZXRTcGFjZWRQb2ludHNIb2xlcyggZGl2aXNpb25zIClcclxuXHJcblx0fTtcclxuXHJcbn07XHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICpcdFV0aWxzXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblRIUkVFLlNoYXBlLlV0aWxzID0ge1xyXG5cclxuXHQvKlxyXG5cdFx0Y29udG91ciAtIGFycmF5IG9mIHZlY3RvcjIgZm9yIGNvbnRvdXJcclxuXHRcdGhvbGVzICAgLSBhcnJheSBvZiBhcnJheSBvZiB2ZWN0b3IyXHJcblx0Ki9cclxuXHJcblx0cmVtb3ZlSG9sZXM6IGZ1bmN0aW9uICggY29udG91ciwgaG9sZXMgKSB7XHJcblxyXG5cdFx0dmFyIHNoYXBlID0gY29udG91ci5jb25jYXQoKTsgLy8gd29yayBvbiB0aGlzIHNoYXBlXHJcblx0XHR2YXIgYWxscG9pbnRzID0gc2hhcGUuY29uY2F0KCk7XHJcblxyXG5cdFx0LyogRm9yIGVhY2ggaXNvbGF0ZWQgc2hhcGUsIGZpbmQgdGhlIGNsb3Nlc3QgcG9pbnRzIGFuZCBicmVhayB0byB0aGUgaG9sZSB0byBhbGxvdyB0cmlhbmd1bGF0aW9uICovXHJcblxyXG5cclxuXHRcdHZhciBwcmV2U2hhcGVWZXJ0LCBuZXh0U2hhcGVWZXJ0LFxyXG5cdFx0XHRwcmV2SG9sZVZlcnQsIG5leHRIb2xlVmVydCxcclxuXHRcdFx0aG9sZUluZGV4LCBzaGFwZUluZGV4LFxyXG5cdFx0XHRzaGFwZUlkLCBzaGFwZUdyb3VwLFxyXG5cdFx0XHRoLCBoMixcclxuXHRcdFx0aG9sZSwgc2hvcnRlc3QsIGQsXHJcblx0XHRcdHAsIHB0czEsIHB0czIsXHJcblx0XHRcdHRtcFNoYXBlMSwgdG1wU2hhcGUyLFxyXG5cdFx0XHR0bXBIb2xlMSwgdG1wSG9sZTIsXHJcblx0XHRcdHZlcnRzID0gW107XHJcblxyXG5cdFx0Zm9yICggaCA9IDA7IGggPCBob2xlcy5sZW5ndGg7IGggKysgKSB7XHJcblxyXG5cdFx0XHRob2xlID0gaG9sZXNbIGggXTtcclxuXHJcblx0XHRcdC8qXHJcblx0XHRcdHNoYXBlaG9sZXNbIGggXS5jb25jYXQoKTsgLy8gcHJlc2VydmVzIG9yaWdpbmFsXHJcblx0XHRcdGhvbGVzLnB1c2goIGhvbGUgKTtcclxuXHRcdFx0Ki9cclxuXHJcblx0XHRcdEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KCBhbGxwb2ludHMsIGhvbGUgKTtcclxuXHJcblx0XHRcdHNob3J0ZXN0ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xyXG5cclxuXHJcblx0XHRcdC8vIEZpbmQgdGhlIHNob3J0ZXN0IHBhaXIgb2YgcHRzIGJldHdlZW4gc2hhcGUgYW5kIGhvbGVcclxuXHJcblx0XHRcdC8vIE5vdGU6IEFjdHVhbGx5LCBJJ20gbm90IHN1cmUgbm93IGlmIHdlIGNvdWxkIG9wdGltaXplIHRoaXMgdG8gYmUgZmFzdGVyIHRoYW4gTyhtKm4pXHJcblx0XHRcdC8vIFVzaW5nIGRpc3RhbmNlVG9TcXVhcmVkKCkgaW50ZWFkIG9mIGRpc3RhbmNlVG8oKSBzaG91bGQgc3BlZWQgYSBsaXR0bGVcclxuXHRcdFx0Ly8gc2luY2UgcnVubmluZyBzcXVhcmUgcm9vdHMgb3BlcmF0aW9ucyBhcmUgcmVkdWNlZC5cclxuXHJcblx0XHRcdGZvciAoIGgyID0gMDsgaDIgPCBob2xlLmxlbmd0aDsgaDIgKysgKSB7XHJcblxyXG5cdFx0XHRcdHB0czEgPSBob2xlWyBoMiBdO1xyXG5cdFx0XHRcdHZhciBkaXN0ID0gW107XHJcblxyXG5cdFx0XHRcdGZvciAoIHAgPSAwOyBwIDwgc2hhcGUubGVuZ3RoOyBwKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0cHRzMiA9IHNoYXBlWyBwIF07XHJcblx0XHRcdFx0XHRkID0gcHRzMS5kaXN0YW5jZVRvU3F1YXJlZCggcHRzMiApO1xyXG5cdFx0XHRcdFx0ZGlzdC5wdXNoKCBkICk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBkIDwgc2hvcnRlc3QgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRzaG9ydGVzdCA9IGQ7XHJcblx0XHRcdFx0XHRcdGhvbGVJbmRleCA9IGgyO1xyXG5cdFx0XHRcdFx0XHRzaGFwZUluZGV4ID0gcDtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vY29uc29sZS5sb2coXCJzaG9ydGVzdFwiLCBzaG9ydGVzdCwgZGlzdCk7XHJcblxyXG5cdFx0XHRwcmV2U2hhcGVWZXJ0ID0gKCBzaGFwZUluZGV4IC0gMSApID49IDAgPyBzaGFwZUluZGV4IC0gMSA6IHNoYXBlLmxlbmd0aCAtIDE7XHJcblx0XHRcdHByZXZIb2xlVmVydCA9ICggaG9sZUluZGV4IC0gMSApID49IDAgPyBob2xlSW5kZXggLSAxIDogaG9sZS5sZW5ndGggLSAxO1xyXG5cclxuXHRcdFx0dmFyIGFyZWFhcHRzID0gW1xyXG5cclxuXHRcdFx0XHRob2xlWyBob2xlSW5kZXggXSxcclxuXHRcdFx0XHRzaGFwZVsgc2hhcGVJbmRleCBdLFxyXG5cdFx0XHRcdHNoYXBlWyBwcmV2U2hhcGVWZXJ0IF1cclxuXHJcblx0XHRcdF07XHJcblxyXG5cdFx0XHR2YXIgYXJlYWEgPSBUSFJFRS5Gb250VXRpbHMuVHJpYW5ndWxhdGUuYXJlYSggYXJlYWFwdHMgKTtcclxuXHJcblx0XHRcdHZhciBhcmVhYnB0cyA9IFtcclxuXHJcblx0XHRcdFx0aG9sZVsgaG9sZUluZGV4IF0sXHJcblx0XHRcdFx0aG9sZVsgcHJldkhvbGVWZXJ0IF0sXHJcblx0XHRcdFx0c2hhcGVbIHNoYXBlSW5kZXggXVxyXG5cclxuXHRcdFx0XTtcclxuXHJcblx0XHRcdHZhciBhcmVhYiA9IFRIUkVFLkZvbnRVdGlscy5Ucmlhbmd1bGF0ZS5hcmVhKCBhcmVhYnB0cyApO1xyXG5cclxuXHRcdFx0dmFyIHNoYXBlT2Zmc2V0ID0gMTtcclxuXHRcdFx0dmFyIGhvbGVPZmZzZXQgPSAtMTtcclxuXHJcblx0XHRcdHZhciBvbGRTaGFwZUluZGV4ID0gc2hhcGVJbmRleCwgb2xkSG9sZUluZGV4ID0gaG9sZUluZGV4O1xyXG5cdFx0XHRzaGFwZUluZGV4ICs9IHNoYXBlT2Zmc2V0O1xyXG5cdFx0XHRob2xlSW5kZXggKz0gaG9sZU9mZnNldDtcclxuXHJcblx0XHRcdGlmICggc2hhcGVJbmRleCA8IDAgKSB7IHNoYXBlSW5kZXggKz0gc2hhcGUubGVuZ3RoOyAgfVxyXG5cdFx0XHRzaGFwZUluZGV4ICU9IHNoYXBlLmxlbmd0aDtcclxuXHJcblx0XHRcdGlmICggaG9sZUluZGV4IDwgMCApIHsgaG9sZUluZGV4ICs9IGhvbGUubGVuZ3RoOyAgfVxyXG5cdFx0XHRob2xlSW5kZXggJT0gaG9sZS5sZW5ndGg7XHJcblxyXG5cdFx0XHRwcmV2U2hhcGVWZXJ0ID0gKCBzaGFwZUluZGV4IC0gMSApID49IDAgPyBzaGFwZUluZGV4IC0gMSA6IHNoYXBlLmxlbmd0aCAtIDE7XHJcblx0XHRcdHByZXZIb2xlVmVydCA9ICggaG9sZUluZGV4IC0gMSApID49IDAgPyBob2xlSW5kZXggLSAxIDogaG9sZS5sZW5ndGggLSAxO1xyXG5cclxuXHRcdFx0YXJlYWFwdHMgPSBbXHJcblxyXG5cdFx0XHRcdGhvbGVbIGhvbGVJbmRleCBdLFxyXG5cdFx0XHRcdHNoYXBlWyBzaGFwZUluZGV4IF0sXHJcblx0XHRcdFx0c2hhcGVbIHByZXZTaGFwZVZlcnQgXVxyXG5cclxuXHRcdFx0XTtcclxuXHJcblx0XHRcdHZhciBhcmVhYTIgPSBUSFJFRS5Gb250VXRpbHMuVHJpYW5ndWxhdGUuYXJlYSggYXJlYWFwdHMgKTtcclxuXHJcblx0XHRcdGFyZWFicHRzID0gW1xyXG5cclxuXHRcdFx0XHRob2xlWyBob2xlSW5kZXggXSxcclxuXHRcdFx0XHRob2xlWyBwcmV2SG9sZVZlcnQgXSxcclxuXHRcdFx0XHRzaGFwZVsgc2hhcGVJbmRleCBdXHJcblxyXG5cdFx0XHRdO1xyXG5cclxuXHRcdFx0dmFyIGFyZWFiMiA9IFRIUkVFLkZvbnRVdGlscy5Ucmlhbmd1bGF0ZS5hcmVhKCBhcmVhYnB0cyApO1xyXG5cdFx0XHQvL2NvbnNvbGUubG9nKGFyZWFhLGFyZWFiICxhcmVhYTIsYXJlYWIyLCAoIGFyZWFhICsgYXJlYWIgKSwgICggYXJlYWEyICsgYXJlYWIyICkpO1xyXG5cclxuXHRcdFx0aWYgKCAoIGFyZWFhICsgYXJlYWIgKSA+ICggYXJlYWEyICsgYXJlYWIyICkgKSB7XHJcblxyXG5cdFx0XHRcdC8vIEluIGNhc2UgYXJlYXMgYXJlIG5vdCBjb3JyZWN0LlxyXG5cdFx0XHRcdC8vY29uc29sZS5sb2coXCJVU0UgVEhJU1wiKTtcclxuXHJcblx0XHRcdFx0c2hhcGVJbmRleCA9IG9sZFNoYXBlSW5kZXg7XHJcblx0XHRcdFx0aG9sZUluZGV4ID0gb2xkSG9sZUluZGV4IDtcclxuXHJcblx0XHRcdFx0aWYgKCBzaGFwZUluZGV4IDwgMCApIHsgc2hhcGVJbmRleCArPSBzaGFwZS5sZW5ndGg7ICB9XHJcblx0XHRcdFx0c2hhcGVJbmRleCAlPSBzaGFwZS5sZW5ndGg7XHJcblxyXG5cdFx0XHRcdGlmICggaG9sZUluZGV4IDwgMCApIHsgaG9sZUluZGV4ICs9IGhvbGUubGVuZ3RoOyAgfVxyXG5cdFx0XHRcdGhvbGVJbmRleCAlPSBob2xlLmxlbmd0aDtcclxuXHJcblx0XHRcdFx0cHJldlNoYXBlVmVydCA9ICggc2hhcGVJbmRleCAtIDEgKSA+PSAwID8gc2hhcGVJbmRleCAtIDEgOiBzaGFwZS5sZW5ndGggLSAxO1xyXG5cdFx0XHRcdHByZXZIb2xlVmVydCA9ICggaG9sZUluZGV4IC0gMSApID49IDAgPyBob2xlSW5kZXggLSAxIDogaG9sZS5sZW5ndGggLSAxO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ly9jb25zb2xlLmxvZyhcIlVTRSBUSEFUIFwiKVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dG1wU2hhcGUxID0gc2hhcGUuc2xpY2UoIDAsIHNoYXBlSW5kZXggKTtcclxuXHRcdFx0dG1wU2hhcGUyID0gc2hhcGUuc2xpY2UoIHNoYXBlSW5kZXggKTtcclxuXHRcdFx0dG1wSG9sZTEgPSBob2xlLnNsaWNlKCBob2xlSW5kZXggKTtcclxuXHRcdFx0dG1wSG9sZTIgPSBob2xlLnNsaWNlKCAwLCBob2xlSW5kZXggKTtcclxuXHJcblx0XHRcdC8vIFNob3VsZCBjaGVjayBvcmRlcnMgaGVyZSBhZ2Fpbj9cclxuXHJcblx0XHRcdHZhciB0cmlhbmdsZWEgPSBbXHJcblxyXG5cdFx0XHRcdGhvbGVbIGhvbGVJbmRleCBdLFxyXG5cdFx0XHRcdHNoYXBlWyBzaGFwZUluZGV4IF0sXHJcblx0XHRcdFx0c2hhcGVbIHByZXZTaGFwZVZlcnQgXVxyXG5cclxuXHRcdFx0XTtcclxuXHJcblx0XHRcdHZhciB0cmlhbmdsZWIgPSBbXHJcblxyXG5cdFx0XHRcdGhvbGVbIGhvbGVJbmRleCBdICxcclxuXHRcdFx0XHRob2xlWyBwcmV2SG9sZVZlcnQgXSxcclxuXHRcdFx0XHRzaGFwZVsgc2hhcGVJbmRleCBdXHJcblxyXG5cdFx0XHRdO1xyXG5cclxuXHRcdFx0dmVydHMucHVzaCggdHJpYW5nbGVhICk7XHJcblx0XHRcdHZlcnRzLnB1c2goIHRyaWFuZ2xlYiApO1xyXG5cclxuXHRcdFx0c2hhcGUgPSB0bXBTaGFwZTEuY29uY2F0KCB0bXBIb2xlMSApLmNvbmNhdCggdG1wSG9sZTIgKS5jb25jYXQoIHRtcFNoYXBlMiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cclxuXHRcdFx0c2hhcGU6c2hhcGUsIFx0XHQvKiBzaGFwZSB3aXRoIG5vIGhvbGVzICovXHJcblx0XHRcdGlzb2xhdGVkUHRzOiB2ZXJ0cywgLyogaXNvbGF0ZWQgZmFjZXMgKi9cclxuXHRcdFx0YWxscG9pbnRzOiBhbGxwb2ludHNcclxuXHJcblx0XHR9XHJcblxyXG5cclxuXHR9LFxyXG5cclxuXHR0cmlhbmd1bGF0ZVNoYXBlOiBmdW5jdGlvbiAoIGNvbnRvdXIsIGhvbGVzICkge1xyXG5cclxuXHRcdHZhciBzaGFwZVdpdGhvdXRIb2xlcyA9IFRIUkVFLlNoYXBlLlV0aWxzLnJlbW92ZUhvbGVzKCBjb250b3VyLCBob2xlcyApO1xyXG5cclxuXHRcdHZhciBzaGFwZSA9IHNoYXBlV2l0aG91dEhvbGVzLnNoYXBlLFxyXG5cdFx0XHRhbGxwb2ludHMgPSBzaGFwZVdpdGhvdXRIb2xlcy5hbGxwb2ludHMsXHJcblx0XHRcdGlzb2xhdGVkUHRzID0gc2hhcGVXaXRob3V0SG9sZXMuaXNvbGF0ZWRQdHM7XHJcblxyXG5cdFx0dmFyIHRyaWFuZ2xlcyA9IFRIUkVFLkZvbnRVdGlscy5Ucmlhbmd1bGF0ZSggc2hhcGUsIGZhbHNlICk7IC8vIFRydWUgcmV0dXJucyBpbmRpY2VzIGZvciBwb2ludHMgb2Ygc3Bvb2xlZCBzaGFwZVxyXG5cclxuXHRcdC8vIFRvIG1haW50YWluIHJlZmVyZW5jZSB0byBvbGQgc2hhcGUsIG9uZSBtdXN0IG1hdGNoIGNvb3JkaW5hdGVzLCBvciBvZmZzZXQgdGhlIGluZGljZXMgZnJvbSBvcmlnaW5hbCBhcnJheXMuIEl0J3MgcHJvYmFibHkgZWFzaWVyIHRvIGRvIHRoZSBmaXJzdC5cclxuXHJcblx0XHQvL2NvbnNvbGUubG9nKCBcInRyaWFuZ2xlc1wiLHRyaWFuZ2xlcywgdHJpYW5nbGVzLmxlbmd0aCApO1xyXG5cdFx0Ly9jb25zb2xlLmxvZyggXCJhbGxwb2ludHNcIixhbGxwb2ludHMsIGFsbHBvaW50cy5sZW5ndGggKTtcclxuXHJcblx0XHR2YXIgaSwgaWwsIGYsIGZhY2UsXHJcblx0XHRcdGtleSwgaW5kZXgsXHJcblx0XHRcdGFsbFBvaW50c01hcCA9IHt9LFxyXG5cdFx0XHRpc29sYXRlZFBvaW50c01hcCA9IHt9O1xyXG5cclxuXHRcdC8vIHByZXBhcmUgYWxsIHBvaW50cyBtYXBcclxuXHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSBhbGxwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRrZXkgPSBhbGxwb2ludHNbIGkgXS54ICsgXCI6XCIgKyBhbGxwb2ludHNbIGkgXS55O1xyXG5cclxuXHRcdFx0aWYgKCBhbGxQb2ludHNNYXBbIGtleSBdICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUubG9nKCBcIkR1cGxpY2F0ZSBwb2ludFwiLCBrZXkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGFsbFBvaW50c01hcFsga2V5IF0gPSBpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBjaGVjayBhbGwgZmFjZSB2ZXJ0aWNlcyBhZ2FpbnN0IGFsbCBwb2ludHMgbWFwXHJcblxyXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gdHJpYW5nbGVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0ZmFjZSA9IHRyaWFuZ2xlc1sgaSBdO1xyXG5cclxuXHRcdFx0Zm9yICggZiA9IDA7IGYgPCAzOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRrZXkgPSBmYWNlWyBmIF0ueCArIFwiOlwiICsgZmFjZVsgZiBdLnk7XHJcblxyXG5cdFx0XHRcdGluZGV4ID0gYWxsUG9pbnRzTWFwWyBrZXkgXTtcclxuXHJcblx0XHRcdFx0aWYgKCBpbmRleCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdGZhY2VbIGYgXSA9IGluZGV4O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGNoZWNrIGlzb2xhdGVkIHBvaW50cyB2ZXJ0aWNlcyBhZ2FpbnN0IGFsbCBwb2ludHMgbWFwXHJcblxyXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gaXNvbGF0ZWRQdHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRmYWNlID0gaXNvbGF0ZWRQdHNbIGkgXTtcclxuXHJcblx0XHRcdGZvciAoIGYgPSAwOyBmIDwgMzsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0a2V5ID0gZmFjZVsgZiBdLnggKyBcIjpcIiArIGZhY2VbIGYgXS55O1xyXG5cclxuXHRcdFx0XHRpbmRleCA9IGFsbFBvaW50c01hcFsga2V5IF07XHJcblxyXG5cdFx0XHRcdGlmICggaW5kZXggIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRmYWNlWyBmIF0gPSBpbmRleDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJpYW5nbGVzLmNvbmNhdCggaXNvbGF0ZWRQdHMgKTtcclxuXHJcblx0fSwgLy8gZW5kIHRyaWFuZ3VsYXRlIHNoYXBlc1xyXG5cclxuXHQvKlxyXG5cdHRyaWFuZ3VsYXRlMiA6IGZ1bmN0aW9uKCBwdHMsIGhvbGVzICkge1xyXG5cclxuXHRcdC8vIEZvciB1c2Ugd2l0aCBQb2x5MlRyaS5qc1xyXG5cclxuXHRcdHZhciBhbGxwdHMgPSBwdHMuY29uY2F0KCk7XHJcblx0XHR2YXIgc2hhcGUgPSBbXTtcclxuXHRcdGZvciAodmFyIHAgaW4gcHRzKSB7XHJcblx0XHRcdHNoYXBlLnB1c2gobmV3IGpzLnBvbHkydHJpLlBvaW50KHB0c1twXS54LCBwdHNbcF0ueSkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzd2N0eCA9IG5ldyBqcy5wb2x5MnRyaS5Td2VlcENvbnRleHQoc2hhcGUpO1xyXG5cclxuXHRcdGZvciAodmFyIGggaW4gaG9sZXMpIHtcclxuXHRcdFx0dmFyIGFIb2xlID0gaG9sZXNbaF07XHJcblx0XHRcdHZhciBuZXdIb2xlID0gW11cclxuXHRcdFx0Zm9yIChpIGluIGFIb2xlKSB7XHJcblx0XHRcdFx0bmV3SG9sZS5wdXNoKG5ldyBqcy5wb2x5MnRyaS5Qb2ludChhSG9sZVtpXS54LCBhSG9sZVtpXS55KSk7XHJcblx0XHRcdFx0YWxscHRzLnB1c2goYUhvbGVbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdHN3Y3R4LkFkZEhvbGUobmV3SG9sZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGZpbmQ7XHJcblx0XHR2YXIgZmluZEluZGV4Rm9yUHQgPSBmdW5jdGlvbiAocHQpIHtcclxuXHRcdFx0ZmluZCA9IG5ldyBUSFJFRS5WZWN0b3IyKHB0LngsIHB0LnkpO1xyXG5cdFx0XHR2YXIgcDtcclxuXHRcdFx0Zm9yIChwPTAsIHBsID0gYWxscHRzLmxlbmd0aDsgcDxwbDsgcCsrKSB7XHJcblx0XHRcdFx0aWYgKGFsbHB0c1twXS5lcXVhbHMoZmluZCkpIHJldHVybiBwO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiAtMTtcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gdHJpYW5ndWxhdGVcclxuXHRcdGpzLnBvbHkydHJpLnN3ZWVwLlRyaWFuZ3VsYXRlKHN3Y3R4KTtcclxuXHJcblx0XHR2YXIgdHJpYW5nbGVzID0gIHN3Y3R4LkdldFRyaWFuZ2xlcygpO1xyXG5cdFx0dmFyIHRyIDtcclxuXHRcdHZhciBmYWNlc1B0cyA9IFtdO1xyXG5cdFx0Zm9yICh2YXIgdCBpbiB0cmlhbmdsZXMpIHtcclxuXHRcdFx0dHIgPSAgdHJpYW5nbGVzW3RdO1xyXG5cdFx0XHRmYWNlc1B0cy5wdXNoKFtcclxuXHRcdFx0XHRmaW5kSW5kZXhGb3JQdCh0ci5HZXRQb2ludCgwKSksXHJcblx0XHRcdFx0ZmluZEluZGV4Rm9yUHQodHIuR2V0UG9pbnQoMSkpLFxyXG5cdFx0XHRcdGZpbmRJbmRleEZvclB0KHRyLkdldFBvaW50KDIpKVxyXG5cdFx0XHRcdFx0XSk7XHJcblx0XHR9XHJcblxyXG5cclxuXHQvL1x0Y29uc29sZS5sb2coZmFjZXNQdHMpO1xyXG5cdC8vXHRjb25zb2xlLmxvZyhcInRyaWFuZ2xlc1wiLCB0cmlhbmdsZXMubGVuZ3RoLCB0cmlhbmdsZXMpO1xyXG5cclxuXHRcdC8vIFJldHVybnMgYXJyYXkgb2YgZmFjZXMgd2l0aCAzIGVsZW1lbnQgZWFjaFxyXG5cdHJldHVybiBmYWNlc1B0cztcclxuXHR9LFxyXG4qL1xyXG5cclxuXHRpc0Nsb2NrV2lzZTogZnVuY3Rpb24gKCBwdHMgKSB7XHJcblxyXG5cdFx0cmV0dXJuIFRIUkVFLkZvbnRVdGlscy5Ucmlhbmd1bGF0ZS5hcmVhKCBwdHMgKSA8IDA7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIEJlemllciBDdXJ2ZXMgZm9ybXVsYXMgb2J0YWluZWQgZnJvbVxyXG5cdC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQiVDMyVBOXppZXJfY3VydmVcclxuXHJcblx0Ly8gUXVhZCBCZXppZXIgRnVuY3Rpb25zXHJcblxyXG5cdGIycDA6IGZ1bmN0aW9uICggdCwgcCApIHtcclxuXHJcblx0XHR2YXIgayA9IDEgLSB0O1xyXG5cdFx0cmV0dXJuIGsgKiBrICogcDtcclxuXHJcblx0fSxcclxuXHJcblx0YjJwMTogZnVuY3Rpb24gKCB0LCBwICkge1xyXG5cclxuXHRcdHJldHVybiAyICogKCAxIC0gdCApICogdCAqIHA7XHJcblxyXG5cdH0sXHJcblxyXG5cdGIycDI6IGZ1bmN0aW9uICggdCwgcCApIHtcclxuXHJcblx0XHRyZXR1cm4gdCAqIHQgKiBwO1xyXG5cclxuXHR9LFxyXG5cclxuXHRiMjogZnVuY3Rpb24gKCB0LCBwMCwgcDEsIHAyICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmIycDAoIHQsIHAwICkgKyB0aGlzLmIycDEoIHQsIHAxICkgKyB0aGlzLmIycDIoIHQsIHAyICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIEN1YmljIEJlemllciBGdW5jdGlvbnNcclxuXHJcblx0YjNwMDogZnVuY3Rpb24gKCB0LCBwICkge1xyXG5cclxuXHRcdHZhciBrID0gMSAtIHQ7XHJcblx0XHRyZXR1cm4gayAqIGsgKiBrICogcDtcclxuXHJcblx0fSxcclxuXHJcblx0YjNwMTogZnVuY3Rpb24gKCB0LCBwICkge1xyXG5cclxuXHRcdHZhciBrID0gMSAtIHQ7XHJcblx0XHRyZXR1cm4gMyAqIGsgKiBrICogdCAqIHA7XHJcblxyXG5cdH0sXHJcblxyXG5cdGIzcDI6IGZ1bmN0aW9uICggdCwgcCApIHtcclxuXHJcblx0XHR2YXIgayA9IDEgLSB0O1xyXG5cdFx0cmV0dXJuIDMgKiBrICogdCAqIHQgKiBwO1xyXG5cclxuXHR9LFxyXG5cclxuXHRiM3AzOiBmdW5jdGlvbiAoIHQsIHAgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHQgKiB0ICogdCAqIHA7XHJcblxyXG5cdH0sXHJcblxyXG5cdGIzOiBmdW5jdGlvbiAoIHQsIHAwLCBwMSwgcDIsIHAzICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmIzcDAoIHQsIHAwICkgKyB0aGlzLmIzcDEoIHQsIHAxICkgKyB0aGlzLmIzcDIoIHQsIHAyICkgKyAgdGhpcy5iM3AzKCB0LCBwMyApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqL1xyXG5cclxuVEhSRUUuQW5pbWF0aW9uSGFuZGxlciA9IChmdW5jdGlvbigpIHtcclxuXHJcblx0dmFyIHBsYXlpbmcgPSBbXTtcclxuXHR2YXIgbGlicmFyeSA9IHt9O1xyXG5cdHZhciB0aGF0ICAgID0ge307XHJcblxyXG5cclxuXHQvLy0tLSB1cGRhdGUgLS0tXHJcblxyXG5cdHRoYXQudXBkYXRlID0gZnVuY3Rpb24oIGRlbHRhVGltZU1TICkge1xyXG5cclxuXHRcdGZvciggdmFyIGkgPSAwOyBpIDwgcGxheWluZy5sZW5ndGg7IGkgKysgKVxyXG5cdFx0XHRwbGF5aW5nWyBpIF0udXBkYXRlKCBkZWx0YVRpbWVNUyApO1xyXG5cclxuXHR9O1xyXG5cclxuXHJcblx0Ly8tLS0gYWRkIC0tLVxyXG5cclxuXHR0aGF0LmFkZFRvVXBkYXRlID0gZnVuY3Rpb24oIGFuaW1hdGlvbiApIHtcclxuXHJcblx0XHRpZiAoIHBsYXlpbmcuaW5kZXhPZiggYW5pbWF0aW9uICkgPT09IC0xIClcclxuXHRcdFx0cGxheWluZy5wdXNoKCBhbmltYXRpb24gKTtcclxuXHJcblx0fTtcclxuXHJcblxyXG5cdC8vLS0tIHJlbW92ZSAtLS1cclxuXHJcblx0dGhhdC5yZW1vdmVGcm9tVXBkYXRlID0gZnVuY3Rpb24oIGFuaW1hdGlvbiApIHtcclxuXHJcblx0XHR2YXIgaW5kZXggPSBwbGF5aW5nLmluZGV4T2YoIGFuaW1hdGlvbiApO1xyXG5cclxuXHRcdGlmKCBpbmRleCAhPT0gLTEgKVxyXG5cdFx0XHRwbGF5aW5nLnNwbGljZSggaW5kZXgsIDEgKTtcclxuXHJcblx0fTtcclxuXHJcblxyXG5cdC8vLS0tIGFkZCAtLS1cclxuXHJcblx0dGhhdC5hZGQgPSBmdW5jdGlvbiggZGF0YSApIHtcclxuXHJcblx0XHRpZiAoIGxpYnJhcnlbIGRhdGEubmFtZSBdICE9PSB1bmRlZmluZWQgKVxyXG5cdFx0XHRjb25zb2xlLmxvZyggXCJUSFJFRS5BbmltYXRpb25IYW5kbGVyLmFkZDogV2FybmluZyEgXCIgKyBkYXRhLm5hbWUgKyBcIiBhbHJlYWR5IGV4aXN0cyBpbiBsaWJyYXJ5LiBPdmVyd3JpdGluZy5cIiApO1xyXG5cclxuXHRcdGxpYnJhcnlbIGRhdGEubmFtZSBdID0gZGF0YTtcclxuXHRcdGluaXREYXRhKCBkYXRhICk7XHJcblxyXG5cdH07XHJcblxyXG5cclxuXHQvLy0tLSBnZXQgLS0tXHJcblxyXG5cdHRoYXQuZ2V0ID0gZnVuY3Rpb24oIG5hbWUgKSB7XHJcblxyXG5cdFx0aWYgKCB0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIiApIHtcclxuXHJcblx0XHRcdGlmICggbGlicmFyeVsgbmFtZSBdICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gbGlicmFyeVsgbmFtZSBdO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS5sb2coIFwiVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5nZXQ6IENvdWxkbid0IGZpbmQgYW5pbWF0aW9uIFwiICsgbmFtZSApO1xyXG5cdFx0XHRcdHJldHVybiBudWxsO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHQvLyB0b2RvOiBhZGQgc2ltcGxlIHR3ZWVuIGxpYnJhcnlcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdC8vLS0tIHBhcnNlIC0tLVxyXG5cclxuXHR0aGF0LnBhcnNlID0gZnVuY3Rpb24oIHJvb3QgKSB7XHJcblxyXG5cdFx0Ly8gc2V0dXAgaGllcmFyY2h5XHJcblxyXG5cdFx0dmFyIGhpZXJhcmNoeSA9IFtdO1xyXG5cclxuXHRcdGlmICggcm9vdCBpbnN0YW5jZW9mIFRIUkVFLlNraW5uZWRNZXNoICkge1xyXG5cclxuXHRcdFx0Zm9yKCB2YXIgYiA9IDA7IGIgPCByb290LmJvbmVzLmxlbmd0aDsgYisrICkge1xyXG5cclxuXHRcdFx0XHRoaWVyYXJjaHkucHVzaCggcm9vdC5ib25lc1sgYiBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHBhcnNlUmVjdXJzZUhpZXJhcmNoeSggcm9vdCwgaGllcmFyY2h5ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBoaWVyYXJjaHk7XHJcblxyXG5cdH07XHJcblxyXG5cdHZhciBwYXJzZVJlY3Vyc2VIaWVyYXJjaHkgPSBmdW5jdGlvbiggcm9vdCwgaGllcmFyY2h5ICkge1xyXG5cclxuXHRcdGhpZXJhcmNoeS5wdXNoKCByb290ICk7XHJcblxyXG5cdFx0Zm9yKCB2YXIgYyA9IDA7IGMgPCByb290LmNoaWxkcmVuLmxlbmd0aDsgYysrIClcclxuXHRcdFx0cGFyc2VSZWN1cnNlSGllcmFyY2h5KCByb290LmNoaWxkcmVuWyBjIF0sIGhpZXJhcmNoeSApO1xyXG5cclxuXHR9XHJcblxyXG5cclxuXHQvLy0tLSBpbml0IGRhdGEgLS0tXHJcblxyXG5cdHZhciBpbml0RGF0YSA9IGZ1bmN0aW9uKCBkYXRhICkge1xyXG5cclxuXHRcdGlmKCBkYXRhLmluaXRpYWxpemVkID09PSB0cnVlIClcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHJcblx0XHQvLyBsb29wIHRocm91Z2ggYWxsIGtleXNcclxuXHJcblx0XHRmb3IoIHZhciBoID0gMDsgaCA8IGRhdGEuaGllcmFyY2h5Lmxlbmd0aDsgaCArKyApIHtcclxuXHJcblx0XHRcdGZvciggdmFyIGsgPSAwOyBrIDwgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzLmxlbmd0aDsgayArKyApIHtcclxuXHJcblx0XHRcdFx0Ly8gcmVtb3ZlIG1pbnVzIHRpbWVzXHJcblxyXG5cdFx0XHRcdGlmKCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS50aW1lIDwgMCApXHJcblx0XHRcdFx0XHRkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS50aW1lID0gMDtcclxuXHJcblxyXG5cdFx0XHRcdC8vIGNyZWF0ZSBxdWF0ZXJuaW9uc1xyXG5cclxuXHRcdFx0XHRpZiggZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0ucm90ICE9PSB1bmRlZmluZWQgJiZcclxuXHRcdFx0XHQgISggZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0ucm90IGluc3RhbmNlb2YgVEhSRUUuUXVhdGVybmlvbiApICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBxdWF0ID0gZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0ucm90O1xyXG5cdFx0XHRcdFx0ZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0ucm90ID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oIHF1YXRbMF0sIHF1YXRbMV0sIHF1YXRbMl0sIHF1YXRbM10gKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdC8vIHByZXBhcmUgbW9ycGggdGFyZ2V0IGtleXNcclxuXHJcblx0XHRcdGlmKCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXMubGVuZ3RoICYmIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgMCBdLm1vcnBoVGFyZ2V0cyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHQvLyBnZXQgYWxsIHVzZWRcclxuXHJcblx0XHRcdFx0dmFyIHVzZWRNb3JwaFRhcmdldHMgPSB7fTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGsgPSAwOyBrIDwgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzLmxlbmd0aDsgayArKyApIHtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCB2YXIgbSA9IDA7IG0gPCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5tb3JwaFRhcmdldHMubGVuZ3RoOyBtICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIG1vcnBoVGFyZ2V0TmFtZSA9IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLm1vcnBoVGFyZ2V0c1sgbSBdO1xyXG5cdFx0XHRcdFx0XHR1c2VkTW9ycGhUYXJnZXRzWyBtb3JwaFRhcmdldE5hbWUgXSA9IC0xO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRkYXRhLmhpZXJhcmNoeVsgaCBdLnVzZWRNb3JwaFRhcmdldHMgPSB1c2VkTW9ycGhUYXJnZXRzO1xyXG5cclxuXHJcblx0XHRcdFx0Ly8gc2V0IGFsbCB1c2VkIG9uIGFsbCBmcmFtZXNcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGsgPSAwOyBrIDwgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzLmxlbmd0aDsgayArKyApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgaW5mbHVlbmNlcyA9IHt9O1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIHZhciBtb3JwaFRhcmdldE5hbWUgaW4gdXNlZE1vcnBoVGFyZ2V0cyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIHZhciBtID0gMDsgbSA8IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLm1vcnBoVGFyZ2V0cy5sZW5ndGg7IG0gKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0ubW9ycGhUYXJnZXRzWyBtIF0gPT09IG1vcnBoVGFyZ2V0TmFtZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRpbmZsdWVuY2VzWyBtb3JwaFRhcmdldE5hbWUgXSA9IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLm1vcnBoVGFyZ2V0c0luZmx1ZW5jZXNbIG0gXTtcclxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIG0gPT09IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLm1vcnBoVGFyZ2V0cy5sZW5ndGggKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGluZmx1ZW5jZXNbIG1vcnBoVGFyZ2V0TmFtZSBdID0gMDtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0ZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0ubW9ycGhUYXJnZXRzSW5mbHVlbmNlcyA9IGluZmx1ZW5jZXM7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblxyXG5cdFx0XHQvLyByZW1vdmUgYWxsIGtleXMgdGhhdCBhcmUgb24gdGhlIHNhbWUgdGltZVxyXG5cclxuXHRcdFx0Zm9yICggdmFyIGsgPSAxOyBrIDwgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzLmxlbmd0aDsgayArKyApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS50aW1lID09PSBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgLSAxIF0udGltZSApIHtcclxuXHJcblx0XHRcdFx0XHRkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXMuc3BsaWNlKCBrLCAxICk7XHJcblx0XHRcdFx0XHRrIC0tO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cclxuXHRcdFx0Ly8gc2V0IGluZGV4XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgayA9IDA7IGsgPCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXMubGVuZ3RoOyBrICsrICkge1xyXG5cclxuXHRcdFx0XHRkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5pbmRleCA9IGs7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHJcblx0XHQvLyBKSVRcclxuXHJcblx0XHR2YXIgbGVuZ3RoSW5GcmFtZXMgPSBwYXJzZUludCggZGF0YS5sZW5ndGggKiBkYXRhLmZwcywgMTAgKTtcclxuXHJcblx0XHRkYXRhLkpJVCA9IHt9O1xyXG5cdFx0ZGF0YS5KSVQuaGllcmFyY2h5ID0gW107XHJcblxyXG5cdFx0Zm9yKCB2YXIgaCA9IDA7IGggPCBkYXRhLmhpZXJhcmNoeS5sZW5ndGg7IGggKysgKVxyXG5cdFx0XHRkYXRhLkpJVC5oaWVyYXJjaHkucHVzaCggbmV3IEFycmF5KCBsZW5ndGhJbkZyYW1lcyApICk7XHJcblxyXG5cclxuXHRcdC8vIGRvbmVcclxuXHJcblx0XHRkYXRhLmluaXRpYWxpemVkID0gdHJ1ZTtcclxuXHJcblx0fTtcclxuXHJcblxyXG5cdC8vIGludGVycG9sYXRpb24gdHlwZXNcclxuXHJcblx0dGhhdC5MSU5FQVIgPSAwO1xyXG5cdHRoYXQuQ0FUTVVMTFJPTSA9IDE7XHJcblx0dGhhdC5DQVRNVUxMUk9NX0ZPUldBUkQgPSAyO1xyXG5cclxuXHRyZXR1cm4gdGhhdDtcclxuXHJcbn0oKSk7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkFuaW1hdGlvbiA9IGZ1bmN0aW9uICggcm9vdCwgbmFtZSwgaW50ZXJwb2xhdGlvblR5cGUgKSB7XHJcblxyXG5cdHRoaXMucm9vdCA9IHJvb3Q7XHJcblx0dGhpcy5kYXRhID0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5nZXQoIG5hbWUgKTtcclxuXHR0aGlzLmhpZXJhcmNoeSA9IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIucGFyc2UoIHJvb3QgKTtcclxuXHJcblx0dGhpcy5jdXJyZW50VGltZSA9IDA7XHJcblx0dGhpcy50aW1lU2NhbGUgPSAxO1xyXG5cclxuXHR0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xyXG5cdHRoaXMuaXNQYXVzZWQgPSB0cnVlO1xyXG5cdHRoaXMubG9vcCA9IHRydWU7XHJcblxyXG5cdHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPSBpbnRlcnBvbGF0aW9uVHlwZSAhPT0gdW5kZWZpbmVkID8gaW50ZXJwb2xhdGlvblR5cGUgOiBUSFJFRS5BbmltYXRpb25IYW5kbGVyLkxJTkVBUjtcclxuXHJcblx0dGhpcy5wb2ludHMgPSBbXTtcclxuXHR0aGlzLnRhcmdldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQW5pbWF0aW9uLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKCBsb29wLCBzdGFydFRpbWVNUyApIHtcclxuXHJcblx0aWYgKCB0aGlzLmlzUGxheWluZyA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0dGhpcy5pc1BsYXlpbmcgPSB0cnVlO1xyXG5cdFx0dGhpcy5sb29wID0gbG9vcCAhPT0gdW5kZWZpbmVkID8gbG9vcCA6IHRydWU7XHJcblx0XHR0aGlzLmN1cnJlbnRUaW1lID0gc3RhcnRUaW1lTVMgIT09IHVuZGVmaW5lZCA/IHN0YXJ0VGltZU1TIDogMDtcclxuXHJcblx0XHQvLyByZXNldCBrZXkgY2FjaGVcclxuXHJcblx0XHR2YXIgaCwgaGwgPSB0aGlzLmhpZXJhcmNoeS5sZW5ndGgsXHJcblx0XHRcdG9iamVjdDtcclxuXHJcblx0XHRmb3IgKCBoID0gMDsgaCA8IGhsOyBoICsrICkge1xyXG5cclxuXHRcdFx0b2JqZWN0ID0gdGhpcy5oaWVyYXJjaHlbIGggXTtcclxuXHJcblx0XHRcdGlmICggdGhpcy5pbnRlcnBvbGF0aW9uVHlwZSAhPT0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5DQVRNVUxMUk9NX0ZPUldBUkQgKSB7XHJcblxyXG5cdFx0XHRcdG9iamVjdC51c2VRdWF0ZXJuaW9uID0gdHJ1ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG9iamVjdC5tYXRyaXhBdXRvVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdGlmICggb2JqZWN0LmFuaW1hdGlvbkNhY2hlID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdG9iamVjdC5hbmltYXRpb25DYWNoZSA9IHt9O1xyXG5cdFx0XHRcdG9iamVjdC5hbmltYXRpb25DYWNoZS5wcmV2S2V5ID0geyBwb3M6IDAsIHJvdDogMCwgc2NsOiAwIH07XHJcblx0XHRcdFx0b2JqZWN0LmFuaW1hdGlvbkNhY2hlLm5leHRLZXkgPSB7IHBvczogMCwgcm90OiAwLCBzY2w6IDAgfTtcclxuXHRcdFx0XHRvYmplY3QuYW5pbWF0aW9uQ2FjaGUub3JpZ2luYWxNYXRyaXggPSBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Cb25lID8gb2JqZWN0LnNraW5NYXRyaXggOiBvYmplY3QubWF0cml4O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIHByZXZLZXkgPSBvYmplY3QuYW5pbWF0aW9uQ2FjaGUucHJldktleTtcclxuXHRcdFx0dmFyIG5leHRLZXkgPSBvYmplY3QuYW5pbWF0aW9uQ2FjaGUubmV4dEtleTtcclxuXHJcblx0XHRcdHByZXZLZXkucG9zID0gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIDAgXTtcclxuXHRcdFx0cHJldktleS5yb3QgPSB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgMCBdO1xyXG5cdFx0XHRwcmV2S2V5LnNjbCA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyAwIF07XHJcblxyXG5cdFx0XHRuZXh0S2V5LnBvcyA9IHRoaXMuZ2V0TmV4dEtleVdpdGgoIFwicG9zXCIsIGgsIDEgKTtcclxuXHRcdFx0bmV4dEtleS5yb3QgPSB0aGlzLmdldE5leHRLZXlXaXRoKCBcInJvdFwiLCBoLCAxICk7XHJcblx0XHRcdG5leHRLZXkuc2NsID0gdGhpcy5nZXROZXh0S2V5V2l0aCggXCJzY2xcIiwgaCwgMSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnVwZGF0ZSggMCApO1xyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMuaXNQYXVzZWQgPSBmYWxzZTtcclxuXHJcblx0VEhSRUUuQW5pbWF0aW9uSGFuZGxlci5hZGRUb1VwZGF0ZSggdGhpcyApO1xyXG5cclxufTtcclxuXHJcblxyXG5USFJFRS5BbmltYXRpb24ucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdGlmICggdGhpcy5pc1BhdXNlZCA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRUSFJFRS5BbmltYXRpb25IYW5kbGVyLmFkZFRvVXBkYXRlKCB0aGlzICk7XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0VEhSRUUuQW5pbWF0aW9uSGFuZGxlci5yZW1vdmVGcm9tVXBkYXRlKCB0aGlzICk7XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5pc1BhdXNlZCA9ICF0aGlzLmlzUGF1c2VkO1xyXG5cclxufTtcclxuXHJcblxyXG5USFJFRS5BbmltYXRpb24ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0dGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcclxuXHR0aGlzLmlzUGF1c2VkICA9IGZhbHNlO1xyXG5cdFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIucmVtb3ZlRnJvbVVwZGF0ZSggdGhpcyApO1xyXG5cclxufTtcclxuXHJcblxyXG5USFJFRS5BbmltYXRpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICggZGVsdGFUaW1lTVMgKSB7XHJcblxyXG5cdC8vIGVhcmx5IG91dFxyXG5cclxuXHRpZiAoIHRoaXMuaXNQbGF5aW5nID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblxyXG5cdC8vIHZhcnNcclxuXHJcblx0dmFyIHR5cGVzID0gWyBcInBvc1wiLCBcInJvdFwiLCBcInNjbFwiIF07XHJcblx0dmFyIHR5cGU7XHJcblx0dmFyIHNjYWxlO1xyXG5cdHZhciB2ZWN0b3I7XHJcblx0dmFyIHByZXZYWVosIG5leHRYWVo7XHJcblx0dmFyIHByZXZLZXksIG5leHRLZXk7XHJcblx0dmFyIG9iamVjdDtcclxuXHR2YXIgYW5pbWF0aW9uQ2FjaGU7XHJcblx0dmFyIGZyYW1lO1xyXG5cdHZhciBKSVRoaWVyYXJjaHkgPSB0aGlzLmRhdGEuSklULmhpZXJhcmNoeTtcclxuXHR2YXIgY3VycmVudFRpbWUsIHVubG9vcGVkQ3VycmVudFRpbWU7XHJcblx0dmFyIGN1cnJlbnRQb2ludCwgZm9yd2FyZFBvaW50LCBhbmdsZTtcclxuXHJcblxyXG5cdHRoaXMuY3VycmVudFRpbWUgKz0gZGVsdGFUaW1lTVMgKiB0aGlzLnRpbWVTY2FsZTtcclxuXHJcblx0dW5sb29wZWRDdXJyZW50VGltZSA9IHRoaXMuY3VycmVudFRpbWU7XHJcblx0Y3VycmVudFRpbWUgPSB0aGlzLmN1cnJlbnRUaW1lID0gdGhpcy5jdXJyZW50VGltZSAlIHRoaXMuZGF0YS5sZW5ndGg7XHJcblx0ZnJhbWUgPSBwYXJzZUludCggTWF0aC5taW4oIGN1cnJlbnRUaW1lICogdGhpcy5kYXRhLmZwcywgdGhpcy5kYXRhLmxlbmd0aCAqIHRoaXMuZGF0YS5mcHMgKSwgMTAgKTtcclxuXHJcblxyXG5cdGZvciAoIHZhciBoID0gMCwgaGwgPSB0aGlzLmhpZXJhcmNoeS5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcclxuXHJcblx0XHRvYmplY3QgPSB0aGlzLmhpZXJhcmNoeVsgaCBdO1xyXG5cdFx0YW5pbWF0aW9uQ2FjaGUgPSBvYmplY3QuYW5pbWF0aW9uQ2FjaGU7XHJcblxyXG5cdFx0Ly8gbG9vcCB0aHJvdWdoIHBvcy9yb3Qvc2NsXHJcblxyXG5cdFx0Zm9yICggdmFyIHQgPSAwOyB0IDwgMzsgdCArKyApIHtcclxuXHJcblx0XHRcdC8vIGdldCBrZXlzXHJcblxyXG5cdFx0XHR0eXBlICAgID0gdHlwZXNbIHQgXTtcclxuXHRcdFx0cHJldktleSA9IGFuaW1hdGlvbkNhY2hlLnByZXZLZXlbIHR5cGUgXTtcclxuXHRcdFx0bmV4dEtleSA9IGFuaW1hdGlvbkNhY2hlLm5leHRLZXlbIHR5cGUgXTtcclxuXHJcblx0XHRcdC8vIHN3aXRjaCBrZXlzP1xyXG5cclxuXHRcdFx0aWYgKCBuZXh0S2V5LnRpbWUgPD0gdW5sb29wZWRDdXJyZW50VGltZSApIHtcclxuXHJcblx0XHRcdFx0Ly8gZGlkIHdlIGxvb3A/XHJcblxyXG5cdFx0XHRcdGlmICggY3VycmVudFRpbWUgPCB1bmxvb3BlZEN1cnJlbnRUaW1lICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggdGhpcy5sb29wICkge1xyXG5cclxuXHRcdFx0XHRcdFx0cHJldktleSA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyAwIF07XHJcblx0XHRcdFx0XHRcdG5leHRLZXkgPSB0aGlzLmdldE5leHRLZXlXaXRoKCB0eXBlLCBoLCAxICk7XHJcblxyXG5cdFx0XHRcdFx0XHR3aGlsZSggbmV4dEtleS50aW1lIDwgY3VycmVudFRpbWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHByZXZLZXkgPSBuZXh0S2V5O1xyXG5cdFx0XHRcdFx0XHRcdG5leHRLZXkgPSB0aGlzLmdldE5leHRLZXlXaXRoKCB0eXBlLCBoLCBuZXh0S2V5LmluZGV4ICsgMSApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHR0aGlzLnN0b3AoKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRkbyB7XHJcblxyXG5cdFx0XHRcdFx0XHRwcmV2S2V5ID0gbmV4dEtleTtcclxuXHRcdFx0XHRcdFx0bmV4dEtleSA9IHRoaXMuZ2V0TmV4dEtleVdpdGgoIHR5cGUsIGgsIG5leHRLZXkuaW5kZXggKyAxICk7XHJcblxyXG5cdFx0XHRcdFx0fSB3aGlsZSggbmV4dEtleS50aW1lIDwgY3VycmVudFRpbWUgKVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGFuaW1hdGlvbkNhY2hlLnByZXZLZXlbIHR5cGUgXSA9IHByZXZLZXk7XHJcblx0XHRcdFx0YW5pbWF0aW9uQ2FjaGUubmV4dEtleVsgdHlwZSBdID0gbmV4dEtleTtcclxuXHJcblx0XHRcdH1cclxuXHJcblxyXG5cdFx0XHRvYmplY3QubWF0cml4QXV0b1VwZGF0ZSA9IHRydWU7XHJcblx0XHRcdG9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdHNjYWxlID0gKCBjdXJyZW50VGltZSAtIHByZXZLZXkudGltZSApIC8gKCBuZXh0S2V5LnRpbWUgLSBwcmV2S2V5LnRpbWUgKTtcclxuXHRcdFx0cHJldlhZWiA9IHByZXZLZXlbIHR5cGUgXTtcclxuXHRcdFx0bmV4dFhZWiA9IG5leHRLZXlbIHR5cGUgXTtcclxuXHJcblxyXG5cdFx0XHQvLyBjaGVjayBzY2FsZSBlcnJvclxyXG5cclxuXHRcdFx0aWYgKCBzY2FsZSA8IDAgfHwgc2NhbGUgPiAxICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLmxvZyggXCJUSFJFRS5BbmltYXRpb24udXBkYXRlOiBXYXJuaW5nISBTY2FsZSBvdXQgb2YgYm91bmRzOlwiICsgc2NhbGUgKyBcIiBvbiBib25lIFwiICsgaCApO1xyXG5cdFx0XHRcdHNjYWxlID0gc2NhbGUgPCAwID8gMCA6IDE7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBpbnRlcnBvbGF0ZVxyXG5cclxuXHRcdFx0aWYgKCB0eXBlID09PSBcInBvc1wiICkge1xyXG5cclxuXHRcdFx0XHR2ZWN0b3IgPSBvYmplY3QucG9zaXRpb247XHJcblxyXG5cdFx0XHRcdGlmICggdGhpcy5pbnRlcnBvbGF0aW9uVHlwZSA9PT0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5MSU5FQVIgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmVjdG9yLnggPSBwcmV2WFlaWyAwIF0gKyAoIG5leHRYWVpbIDAgXSAtIHByZXZYWVpbIDAgXSApICogc2NhbGU7XHJcblx0XHRcdFx0XHR2ZWN0b3IueSA9IHByZXZYWVpbIDEgXSArICggbmV4dFhZWlsgMSBdIC0gcHJldlhZWlsgMSBdICkgKiBzY2FsZTtcclxuXHRcdFx0XHRcdHZlY3Rvci56ID0gcHJldlhZWlsgMiBdICsgKCBuZXh0WFlaWyAyIF0gLSBwcmV2WFlaWyAyIF0gKSAqIHNjYWxlO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCB0aGlzLmludGVycG9sYXRpb25UeXBlID09PSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLkNBVE1VTExST00gfHxcclxuXHRcdFx0XHRcdFx0ICAgIHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPT09IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuQ0FUTVVMTFJPTV9GT1JXQVJEICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMucG9pbnRzWyAwIF0gPSB0aGlzLmdldFByZXZLZXlXaXRoKCBcInBvc1wiLCBoLCBwcmV2S2V5LmluZGV4IC0gMSApWyBcInBvc1wiIF07XHJcblx0XHRcdFx0XHR0aGlzLnBvaW50c1sgMSBdID0gcHJldlhZWjtcclxuXHRcdFx0XHRcdHRoaXMucG9pbnRzWyAyIF0gPSBuZXh0WFlaO1xyXG5cdFx0XHRcdFx0dGhpcy5wb2ludHNbIDMgXSA9IHRoaXMuZ2V0TmV4dEtleVdpdGgoIFwicG9zXCIsIGgsIG5leHRLZXkuaW5kZXggKyAxIClbIFwicG9zXCIgXTtcclxuXHJcblx0XHRcdFx0XHRzY2FsZSA9IHNjYWxlICogMC4zMyArIDAuMzM7XHJcblxyXG5cdFx0XHRcdFx0Y3VycmVudFBvaW50ID0gdGhpcy5pbnRlcnBvbGF0ZUNhdG11bGxSb20oIHRoaXMucG9pbnRzLCBzY2FsZSApO1xyXG5cclxuXHRcdFx0XHRcdHZlY3Rvci54ID0gY3VycmVudFBvaW50WyAwIF07XHJcblx0XHRcdFx0XHR2ZWN0b3IueSA9IGN1cnJlbnRQb2ludFsgMSBdO1xyXG5cdFx0XHRcdFx0dmVjdG9yLnogPSBjdXJyZW50UG9pbnRbIDIgXTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPT09IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuQ0FUTVVMTFJPTV9GT1JXQVJEICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yd2FyZFBvaW50ID0gdGhpcy5pbnRlcnBvbGF0ZUNhdG11bGxSb20oIHRoaXMucG9pbnRzLCBzY2FsZSAqIDEuMDEgKTtcclxuXHJcblx0XHRcdFx0XHRcdHRoaXMudGFyZ2V0LnNldCggZm9yd2FyZFBvaW50WyAwIF0sIGZvcndhcmRQb2ludFsgMSBdLCBmb3J3YXJkUG9pbnRbIDIgXSApO1xyXG5cdFx0XHRcdFx0XHR0aGlzLnRhcmdldC5zdWIoIHZlY3RvciApO1xyXG5cdFx0XHRcdFx0XHR0aGlzLnRhcmdldC55ID0gMDtcclxuXHRcdFx0XHRcdFx0dGhpcy50YXJnZXQubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHRcdFx0XHRhbmdsZSA9IE1hdGguYXRhbjIoIHRoaXMudGFyZ2V0LngsIHRoaXMudGFyZ2V0LnogKTtcclxuXHRcdFx0XHRcdFx0b2JqZWN0LnJvdGF0aW9uLnNldCggMCwgYW5nbGUsIDAgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwicm90XCIgKSB7XHJcblxyXG5cdFx0XHRcdFRIUkVFLlF1YXRlcm5pb24uc2xlcnAoIHByZXZYWVosIG5leHRYWVosIG9iamVjdC5xdWF0ZXJuaW9uLCBzY2FsZSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJzY2xcIiApIHtcclxuXHJcblx0XHRcdFx0dmVjdG9yID0gb2JqZWN0LnNjYWxlO1xyXG5cclxuXHRcdFx0XHR2ZWN0b3IueCA9IHByZXZYWVpbIDAgXSArICggbmV4dFhZWlsgMCBdIC0gcHJldlhZWlsgMCBdICkgKiBzY2FsZTtcclxuXHRcdFx0XHR2ZWN0b3IueSA9IHByZXZYWVpbIDEgXSArICggbmV4dFhZWlsgMSBdIC0gcHJldlhZWlsgMSBdICkgKiBzY2FsZTtcclxuXHRcdFx0XHR2ZWN0b3IueiA9IHByZXZYWVpbIDIgXSArICggbmV4dFhZWlsgMiBdIC0gcHJldlhZWlsgMiBdICkgKiBzY2FsZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBDYXRtdWxsLVJvbSBzcGxpbmVcclxuXHJcblRIUkVFLkFuaW1hdGlvbi5wcm90b3R5cGUuaW50ZXJwb2xhdGVDYXRtdWxsUm9tID0gZnVuY3Rpb24gKCBwb2ludHMsIHNjYWxlICkge1xyXG5cclxuXHR2YXIgYyA9IFtdLCB2MyA9IFtdLFxyXG5cdHBvaW50LCBpbnRQb2ludCwgd2VpZ2h0LCB3MiwgdzMsXHJcblx0cGEsIHBiLCBwYywgcGQ7XHJcblxyXG5cdHBvaW50ID0gKCBwb2ludHMubGVuZ3RoIC0gMSApICogc2NhbGU7XHJcblx0aW50UG9pbnQgPSBNYXRoLmZsb29yKCBwb2ludCApO1xyXG5cdHdlaWdodCA9IHBvaW50IC0gaW50UG9pbnQ7XHJcblxyXG5cdGNbIDAgXSA9IGludFBvaW50ID09PSAwID8gaW50UG9pbnQgOiBpbnRQb2ludCAtIDE7XHJcblx0Y1sgMSBdID0gaW50UG9pbnQ7XHJcblx0Y1sgMiBdID0gaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMiA/IGludFBvaW50IDogaW50UG9pbnQgKyAxO1xyXG5cdGNbIDMgXSA9IGludFBvaW50ID4gcG9pbnRzLmxlbmd0aCAtIDMgPyBpbnRQb2ludCA6IGludFBvaW50ICsgMjtcclxuXHJcblx0cGEgPSBwb2ludHNbIGNbIDAgXSBdO1xyXG5cdHBiID0gcG9pbnRzWyBjWyAxIF0gXTtcclxuXHRwYyA9IHBvaW50c1sgY1sgMiBdIF07XHJcblx0cGQgPSBwb2ludHNbIGNbIDMgXSBdO1xyXG5cclxuXHR3MiA9IHdlaWdodCAqIHdlaWdodDtcclxuXHR3MyA9IHdlaWdodCAqIHcyO1xyXG5cclxuXHR2M1sgMCBdID0gdGhpcy5pbnRlcnBvbGF0ZSggcGFbIDAgXSwgcGJbIDAgXSwgcGNbIDAgXSwgcGRbIDAgXSwgd2VpZ2h0LCB3MiwgdzMgKTtcclxuXHR2M1sgMSBdID0gdGhpcy5pbnRlcnBvbGF0ZSggcGFbIDEgXSwgcGJbIDEgXSwgcGNbIDEgXSwgcGRbIDEgXSwgd2VpZ2h0LCB3MiwgdzMgKTtcclxuXHR2M1sgMiBdID0gdGhpcy5pbnRlcnBvbGF0ZSggcGFbIDIgXSwgcGJbIDIgXSwgcGNbIDIgXSwgcGRbIDIgXSwgd2VpZ2h0LCB3MiwgdzMgKTtcclxuXHJcblx0cmV0dXJuIHYzO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkFuaW1hdGlvbi5wcm90b3R5cGUuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiAoIHAwLCBwMSwgcDIsIHAzLCB0LCB0MiwgdDMgKSB7XHJcblxyXG5cdHZhciB2MCA9ICggcDIgLSBwMCApICogMC41LFxyXG5cdFx0djEgPSAoIHAzIC0gcDEgKSAqIDAuNTtcclxuXHJcblx0cmV0dXJuICggMiAqICggcDEgLSBwMiApICsgdjAgKyB2MSApICogdDMgKyAoIC0gMyAqICggcDEgLSBwMiApIC0gMiAqIHYwIC0gdjEgKSAqIHQyICsgdjAgKiB0ICsgcDE7XHJcblxyXG59O1xyXG5cclxuXHJcblxyXG4vLyBHZXQgbmV4dCBrZXkgd2l0aFxyXG5cclxuVEhSRUUuQW5pbWF0aW9uLnByb3RvdHlwZS5nZXROZXh0S2V5V2l0aCA9IGZ1bmN0aW9uICggdHlwZSwgaCwga2V5ICkge1xyXG5cclxuXHR2YXIga2V5cyA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzO1xyXG5cclxuXHRpZiAoIHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPT09IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuQ0FUTVVMTFJPTSB8fFxyXG5cdFx0IHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPT09IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuQ0FUTVVMTFJPTV9GT1JXQVJEICkge1xyXG5cclxuXHRcdGtleSA9IGtleSA8IGtleXMubGVuZ3RoIC0gMSA/IGtleSA6IGtleXMubGVuZ3RoIC0gMTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHRrZXkgPSBrZXkgJSBrZXlzLmxlbmd0aDtcclxuXHJcblx0fVxyXG5cclxuXHRmb3IgKCA7IGtleSA8IGtleXMubGVuZ3RoOyBrZXkrKyApIHtcclxuXHJcblx0XHRpZiAoIGtleXNbIGtleSBdWyB0eXBlIF0gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHJldHVybiBrZXlzWyBrZXkgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyAwIF07XHJcblxyXG59O1xyXG5cclxuLy8gR2V0IHByZXZpb3VzIGtleSB3aXRoXHJcblxyXG5USFJFRS5BbmltYXRpb24ucHJvdG90eXBlLmdldFByZXZLZXlXaXRoID0gZnVuY3Rpb24gKCB0eXBlLCBoLCBrZXkgKSB7XHJcblxyXG5cdHZhciBrZXlzID0gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdLmtleXM7XHJcblxyXG5cdGlmICggdGhpcy5pbnRlcnBvbGF0aW9uVHlwZSA9PT0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5DQVRNVUxMUk9NIHx8XHJcblx0XHQgdGhpcy5pbnRlcnBvbGF0aW9uVHlwZSA9PT0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5DQVRNVUxMUk9NX0ZPUldBUkQgKSB7XHJcblxyXG5cdFx0a2V5ID0ga2V5ID4gMCA/IGtleSA6IDA7XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0a2V5ID0ga2V5ID49IDAgPyBrZXkgOiBrZXkgKyBrZXlzLmxlbmd0aDtcclxuXHJcblx0fVxyXG5cclxuXHJcblx0Zm9yICggOyBrZXkgPj0gMDsga2V5IC0tICkge1xyXG5cclxuXHRcdGlmICgga2V5c1sga2V5IF1bIHR5cGUgXSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGtleXNbIGtleSBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGtleXMubGVuZ3RoIC0gMSBdO1xyXG5cclxufTtcclxuLyoqXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3Iga2hhbmcgZHVvbmdcclxuICogQGF1dGhvciBlcmlrIGtpdHNvblxyXG4gKi9cclxuXHJcblRIUkVFLktleUZyYW1lQW5pbWF0aW9uID0gZnVuY3Rpb24oIHJvb3QsIGRhdGEsIEpJVENvbXBpbGUgKSB7XHJcblxyXG5cdHRoaXMucm9vdCA9IHJvb3Q7XHJcblx0dGhpcy5kYXRhID0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5nZXQoIGRhdGEgKTtcclxuXHR0aGlzLmhpZXJhcmNoeSA9IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIucGFyc2UoIHJvb3QgKTtcclxuXHR0aGlzLmN1cnJlbnRUaW1lID0gMDtcclxuXHR0aGlzLnRpbWVTY2FsZSA9IDAuMDAxO1xyXG5cdHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XHJcblx0dGhpcy5pc1BhdXNlZCA9IHRydWU7XHJcblx0dGhpcy5sb29wID0gdHJ1ZTtcclxuXHR0aGlzLkpJVENvbXBpbGUgPSBKSVRDb21waWxlICE9PSB1bmRlZmluZWQgPyBKSVRDb21waWxlIDogdHJ1ZTtcclxuXHJcblx0Ly8gaW5pdGlhbGl6ZSB0byBmaXJzdCBrZXlmcmFtZXNcclxuXHJcblx0Zm9yICggdmFyIGggPSAwLCBobCA9IHRoaXMuaGllcmFyY2h5Lmxlbmd0aDsgaCA8IGhsOyBoKysgKSB7XHJcblxyXG5cdFx0dmFyIGtleXMgPSB0aGlzLmRhdGEuaGllcmFyY2h5W2hdLmtleXMsXHJcblx0XHRcdHNpZHMgPSB0aGlzLmRhdGEuaGllcmFyY2h5W2hdLnNpZHMsXHJcblx0XHRcdG9iaiA9IHRoaXMuaGllcmFyY2h5W2hdO1xyXG5cclxuXHRcdGlmICgga2V5cy5sZW5ndGggJiYgc2lkcyApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBzID0gMDsgcyA8IHNpZHMubGVuZ3RoOyBzKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBzaWQgPSBzaWRzWyBzIF0sXHJcblx0XHRcdFx0XHRuZXh0ID0gdGhpcy5nZXROZXh0S2V5V2l0aCggc2lkLCBoLCAwICk7XHJcblxyXG5cdFx0XHRcdGlmICggbmV4dCApIHtcclxuXHJcblx0XHRcdFx0XHRuZXh0LmFwcGx5KCBzaWQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0b2JqLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHRcdFx0dGhpcy5kYXRhLmhpZXJhcmNoeVtoXS5ub2RlLnVwZGF0ZU1hdHJpeCgpO1xyXG5cdFx0XHRvYmoubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gUGxheVxyXG5cclxuVEhSRUUuS2V5RnJhbWVBbmltYXRpb24ucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiggbG9vcCwgc3RhcnRUaW1lTVMgKSB7XHJcblxyXG5cdGlmKCAhdGhpcy5pc1BsYXlpbmcgKSB7XHJcblxyXG5cdFx0dGhpcy5pc1BsYXlpbmcgPSB0cnVlO1xyXG5cdFx0dGhpcy5sb29wID0gbG9vcCAhPT0gdW5kZWZpbmVkID8gbG9vcCA6IHRydWU7XHJcblx0XHR0aGlzLmN1cnJlbnRUaW1lID0gc3RhcnRUaW1lTVMgIT09IHVuZGVmaW5lZCA/IHN0YXJ0VGltZU1TIDogMDtcclxuXHRcdHRoaXMuc3RhcnRUaW1lTXMgPSBzdGFydFRpbWVNUztcclxuXHRcdHRoaXMuc3RhcnRUaW1lID0gMTAwMDAwMDA7XHJcblx0XHR0aGlzLmVuZFRpbWUgPSAtdGhpcy5zdGFydFRpbWU7XHJcblxyXG5cclxuXHRcdC8vIHJlc2V0IGtleSBjYWNoZVxyXG5cclxuXHRcdHZhciBoLCBobCA9IHRoaXMuaGllcmFyY2h5Lmxlbmd0aCxcclxuXHRcdFx0b2JqZWN0LFxyXG5cdFx0XHRub2RlO1xyXG5cclxuXHRcdGZvciAoIGggPSAwOyBoIDwgaGw7IGgrKyApIHtcclxuXHJcblx0XHRcdG9iamVjdCA9IHRoaXMuaGllcmFyY2h5WyBoIF07XHJcblx0XHRcdG5vZGUgPSB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF07XHJcblx0XHRcdG9iamVjdC51c2VRdWF0ZXJuaW9uID0gdHJ1ZTtcclxuXHJcblx0XHRcdGlmICggbm9kZS5hbmltYXRpb25DYWNoZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRub2RlLmFuaW1hdGlvbkNhY2hlID0ge307XHJcblx0XHRcdFx0bm9kZS5hbmltYXRpb25DYWNoZS5wcmV2S2V5ID0gbnVsbDtcclxuXHRcdFx0XHRub2RlLmFuaW1hdGlvbkNhY2hlLm5leHRLZXkgPSBudWxsO1xyXG5cdFx0XHRcdG5vZGUuYW5pbWF0aW9uQ2FjaGUub3JpZ2luYWxNYXRyaXggPSBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Cb25lID8gb2JqZWN0LnNraW5NYXRyaXggOiBvYmplY3QubWF0cml4O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGtleXMgPSB0aGlzLmRhdGEuaGllcmFyY2h5W2hdLmtleXM7XHJcblxyXG5cdFx0XHRpZiAoa2V5cy5sZW5ndGgpIHtcclxuXHJcblx0XHRcdFx0bm9kZS5hbmltYXRpb25DYWNoZS5wcmV2S2V5ID0ga2V5c1sgMCBdO1xyXG5cdFx0XHRcdG5vZGUuYW5pbWF0aW9uQ2FjaGUubmV4dEtleSA9IGtleXNbIDEgXTtcclxuXHJcblx0XHRcdFx0dGhpcy5zdGFydFRpbWUgPSBNYXRoLm1pbigga2V5c1swXS50aW1lLCB0aGlzLnN0YXJ0VGltZSApO1xyXG5cdFx0XHRcdHRoaXMuZW5kVGltZSA9IE1hdGgubWF4KCBrZXlzW2tleXMubGVuZ3RoIC0gMV0udGltZSwgdGhpcy5lbmRUaW1lICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMudXBkYXRlKCAwICk7XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5pc1BhdXNlZCA9IGZhbHNlO1xyXG5cclxuXHRUSFJFRS5BbmltYXRpb25IYW5kbGVyLmFkZFRvVXBkYXRlKCB0aGlzICk7XHJcblxyXG59O1xyXG5cclxuXHJcblxyXG4vLyBQYXVzZVxyXG5cclxuVEhSRUUuS2V5RnJhbWVBbmltYXRpb24ucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdGlmKCB0aGlzLmlzUGF1c2VkICkge1xyXG5cclxuXHRcdFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuYWRkVG9VcGRhdGUoIHRoaXMgKTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHRUSFJFRS5BbmltYXRpb25IYW5kbGVyLnJlbW92ZUZyb21VcGRhdGUoIHRoaXMgKTtcclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLmlzUGF1c2VkID0gIXRoaXMuaXNQYXVzZWQ7XHJcblxyXG59O1xyXG5cclxuXHJcbi8vIFN0b3BcclxuXHJcblRIUkVFLktleUZyYW1lQW5pbWF0aW9uLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XHJcblx0dGhpcy5pc1BhdXNlZCAgPSBmYWxzZTtcclxuXHRUSFJFRS5BbmltYXRpb25IYW5kbGVyLnJlbW92ZUZyb21VcGRhdGUoIHRoaXMgKTtcclxuXHJcblxyXG5cdC8vIHJlc2V0IEpJVCBtYXRyaXggYW5kIHJlbW92ZSBjYWNoZVxyXG5cclxuXHRmb3IgKCB2YXIgaCA9IDA7IGggPCB0aGlzLmRhdGEuaGllcmFyY2h5Lmxlbmd0aDsgaCsrICkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBvYmogPSB0aGlzLmhpZXJhcmNoeVsgaCBdO1xyXG5cdFx0dmFyIG5vZGUgPSB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF07XHJcblxyXG5cdFx0aWYgKCBub2RlLmFuaW1hdGlvbkNhY2hlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR2YXIgb3JpZ2luYWwgPSBub2RlLmFuaW1hdGlvbkNhY2hlLm9yaWdpbmFsTWF0cml4O1xyXG5cclxuXHRcdFx0aWYoIG9iaiBpbnN0YW5jZW9mIFRIUkVFLkJvbmUgKSB7XHJcblxyXG5cdFx0XHRcdG9yaWdpbmFsLmNvcHkoIG9iai5za2luTWF0cml4ICk7XHJcblx0XHRcdFx0b2JqLnNraW5NYXRyaXggPSBvcmlnaW5hbDtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdG9yaWdpbmFsLmNvcHkoIG9iai5tYXRyaXggKTtcclxuXHRcdFx0XHRvYmoubWF0cml4ID0gb3JpZ2luYWw7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRkZWxldGUgbm9kZS5hbmltYXRpb25DYWNoZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5cclxuLy8gVXBkYXRlXHJcblxyXG5USFJFRS5LZXlGcmFtZUFuaW1hdGlvbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oIGRlbHRhVGltZU1TICkge1xyXG5cclxuXHQvLyBlYXJseSBvdXRcclxuXHJcblx0aWYoICF0aGlzLmlzUGxheWluZyApIHJldHVybjtcclxuXHJcblxyXG5cdC8vIHZhcnNcclxuXHJcblx0dmFyIHByZXZLZXksIG5leHRLZXk7XHJcblx0dmFyIG9iamVjdDtcclxuXHR2YXIgbm9kZTtcclxuXHR2YXIgZnJhbWU7XHJcblx0dmFyIEpJVGhpZXJhcmNoeSA9IHRoaXMuZGF0YS5KSVQuaGllcmFyY2h5O1xyXG5cdHZhciBjdXJyZW50VGltZSwgdW5sb29wZWRDdXJyZW50VGltZTtcclxuXHR2YXIgbG9vcGVkO1xyXG5cclxuXHJcblx0Ly8gdXBkYXRlXHJcblxyXG5cdHRoaXMuY3VycmVudFRpbWUgKz0gZGVsdGFUaW1lTVMgKiB0aGlzLnRpbWVTY2FsZTtcclxuXHJcblx0dW5sb29wZWRDdXJyZW50VGltZSA9IHRoaXMuY3VycmVudFRpbWU7XHJcblx0Y3VycmVudFRpbWUgICAgICAgICA9IHRoaXMuY3VycmVudFRpbWUgPSB0aGlzLmN1cnJlbnRUaW1lICUgdGhpcy5kYXRhLmxlbmd0aDtcclxuXHJcblx0Ly8gaWYgbG9vcGVkIGFyb3VuZCwgdGhlIGN1cnJlbnQgdGltZSBzaG91bGQgYmUgYmFzZWQgb24gdGhlIHN0YXJ0VGltZVxyXG5cdGlmICggY3VycmVudFRpbWUgPCB0aGlzLnN0YXJ0VGltZU1zICkge1xyXG5cclxuXHRcdGN1cnJlbnRUaW1lID0gdGhpcy5jdXJyZW50VGltZSA9IHRoaXMuc3RhcnRUaW1lTXMgKyBjdXJyZW50VGltZTtcclxuXHJcblx0fVxyXG5cclxuXHRmcmFtZSAgICAgICAgICAgICAgID0gcGFyc2VJbnQoIE1hdGgubWluKCBjdXJyZW50VGltZSAqIHRoaXMuZGF0YS5mcHMsIHRoaXMuZGF0YS5sZW5ndGggKiB0aGlzLmRhdGEuZnBzICksIDEwICk7XHJcblx0bG9vcGVkIFx0XHRcdFx0PSBjdXJyZW50VGltZSA8IHVubG9vcGVkQ3VycmVudFRpbWU7XHJcblxyXG5cdGlmICggbG9vcGVkICYmICF0aGlzLmxvb3AgKSB7XHJcblxyXG5cdFx0Ly8gU2V0IHRoZSBhbmltYXRpb24gdG8gdGhlIGxhc3Qga2V5ZnJhbWVzIGFuZCBzdG9wXHJcblx0XHRmb3IgKCB2YXIgaCA9IDAsIGhsID0gdGhpcy5oaWVyYXJjaHkubGVuZ3RoOyBoIDwgaGw7IGgrKyApIHtcclxuXHJcblx0XHRcdHZhciBrZXlzID0gdGhpcy5kYXRhLmhpZXJhcmNoeVtoXS5rZXlzLFxyXG5cdFx0XHRcdHNpZHMgPSB0aGlzLmRhdGEuaGllcmFyY2h5W2hdLnNpZHMsXHJcblx0XHRcdFx0ZW5kID0ga2V5cy5sZW5ndGgtMSxcclxuXHRcdFx0XHRvYmogPSB0aGlzLmhpZXJhcmNoeVtoXTtcclxuXHJcblx0XHRcdGlmICgga2V5cy5sZW5ndGggKSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBzID0gMDsgcyA8IHNpZHMubGVuZ3RoOyBzKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHNpZCA9IHNpZHNbIHMgXSxcclxuXHRcdFx0XHRcdFx0cHJldiA9IHRoaXMuZ2V0UHJldktleVdpdGgoIHNpZCwgaCwgZW5kICk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBwcmV2ICkge1xyXG5cdFx0XHRcdFx0XHRwcmV2LmFwcGx5KCBzaWQgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5kYXRhLmhpZXJhcmNoeVtoXS5ub2RlLnVwZGF0ZU1hdHJpeCgpO1xyXG5cdFx0XHRcdG9iai5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5zdG9wKCk7XHJcblx0XHRyZXR1cm47XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gY2hlY2sgcHJlLWluZmluaXR5XHJcblx0aWYgKCBjdXJyZW50VGltZSA8IHRoaXMuc3RhcnRUaW1lICkge1xyXG5cclxuXHRcdHJldHVybjtcclxuXHJcblx0fVxyXG5cclxuXHQvLyB1cGRhdGVcclxuXHJcblx0Zm9yICggdmFyIGggPSAwLCBobCA9IHRoaXMuaGllcmFyY2h5Lmxlbmd0aDsgaCA8IGhsOyBoKysgKSB7XHJcblxyXG5cdFx0b2JqZWN0ID0gdGhpcy5oaWVyYXJjaHlbIGggXTtcclxuXHRcdG5vZGUgPSB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF07XHJcblxyXG5cdFx0dmFyIGtleXMgPSBub2RlLmtleXMsXHJcblx0XHRcdGFuaW1hdGlvbkNhY2hlID0gbm9kZS5hbmltYXRpb25DYWNoZTtcclxuXHJcblx0XHQvLyB1c2UgSklUP1xyXG5cclxuXHRcdGlmICggdGhpcy5KSVRDb21waWxlICYmIEpJVGhpZXJhcmNoeVsgaCBdWyBmcmFtZSBdICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRpZiggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuQm9uZSApIHtcclxuXHJcblx0XHRcdFx0b2JqZWN0LnNraW5NYXRyaXggPSBKSVRoaWVyYXJjaHlbIGggXVsgZnJhbWUgXTtcclxuXHRcdFx0XHRvYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0b2JqZWN0Lm1hdHJpeCA9IEpJVGhpZXJhcmNoeVsgaCBdWyBmcmFtZSBdO1xyXG5cdFx0XHRcdG9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHQvLyB1c2UgaW50ZXJwb2xhdGlvblxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGtleXMubGVuZ3RoICkge1xyXG5cclxuXHRcdFx0Ly8gbWFrZSBzdXJlIHNvIG9yaWdpbmFsIG1hdHJpeCBhbmQgbm90IEpJVCBtYXRyaXggaXMgc2V0XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuSklUQ29tcGlsZSAmJiBhbmltYXRpb25DYWNoZSApIHtcclxuXHJcblx0XHRcdFx0aWYoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkJvbmUgKSB7XHJcblxyXG5cdFx0XHRcdFx0b2JqZWN0LnNraW5NYXRyaXggPSBhbmltYXRpb25DYWNoZS5vcmlnaW5hbE1hdHJpeDtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRvYmplY3QubWF0cml4ID0gYW5pbWF0aW9uQ2FjaGUub3JpZ2luYWxNYXRyaXg7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHByZXZLZXkgPSBhbmltYXRpb25DYWNoZS5wcmV2S2V5O1xyXG5cdFx0XHRuZXh0S2V5ID0gYW5pbWF0aW9uQ2FjaGUubmV4dEtleTtcclxuXHJcblx0XHRcdGlmICggcHJldktleSAmJiBuZXh0S2V5ICkge1xyXG5cclxuXHRcdFx0XHQvLyBzd2l0Y2gga2V5cz9cclxuXHJcblx0XHRcdFx0aWYgKCBuZXh0S2V5LnRpbWUgPD0gdW5sb29wZWRDdXJyZW50VGltZSApIHtcclxuXHJcblx0XHRcdFx0XHQvLyBkaWQgd2UgbG9vcD9cclxuXHJcblx0XHRcdFx0XHRpZiAoIGxvb3BlZCAmJiB0aGlzLmxvb3AgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRwcmV2S2V5ID0ga2V5c1sgMCBdO1xyXG5cdFx0XHRcdFx0XHRuZXh0S2V5ID0ga2V5c1sgMSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0d2hpbGUgKCBuZXh0S2V5LnRpbWUgPCBjdXJyZW50VGltZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0cHJldktleSA9IG5leHRLZXk7XHJcblx0XHRcdFx0XHRcdFx0bmV4dEtleSA9IGtleXNbIHByZXZLZXkuaW5kZXggKyAxIF07XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggIWxvb3BlZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHZhciBsYXN0SW5kZXggPSBrZXlzLmxlbmd0aCAtIDE7XHJcblxyXG5cdFx0XHRcdFx0XHR3aGlsZSAoIG5leHRLZXkudGltZSA8IGN1cnJlbnRUaW1lICYmIG5leHRLZXkuaW5kZXggIT09IGxhc3RJbmRleCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0cHJldktleSA9IG5leHRLZXk7XHJcblx0XHRcdFx0XHRcdFx0bmV4dEtleSA9IGtleXNbIHByZXZLZXkuaW5kZXggKyAxIF07XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGFuaW1hdGlvbkNhY2hlLnByZXZLZXkgPSBwcmV2S2V5O1xyXG5cdFx0XHRcdFx0YW5pbWF0aW9uQ2FjaGUubmV4dEtleSA9IG5leHRLZXk7XHJcblxyXG5cdFx0XHRcdH1cclxuICAgICAgICAgICAgICAgIGlmKG5leHRLZXkudGltZSA+PSBjdXJyZW50VGltZSlcclxuICAgICAgICAgICAgICAgICAgICBwcmV2S2V5LmludGVycG9sYXRlKCBuZXh0S2V5LCBjdXJyZW50VGltZSApO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHByZXZLZXkuaW50ZXJwb2xhdGUoIG5leHRLZXksIG5leHRLZXkudGltZSk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmRhdGEuaGllcmFyY2h5W2hdLm5vZGUudXBkYXRlTWF0cml4KCk7XHJcblx0XHRcdG9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gdXBkYXRlIEpJVD9cclxuXHJcblx0aWYgKCB0aGlzLkpJVENvbXBpbGUgKSB7XHJcblxyXG5cdFx0aWYgKCBKSVRoaWVyYXJjaHlbIDAgXVsgZnJhbWUgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0dGhpcy5oaWVyYXJjaHlbIDAgXS51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGggPSAwOyBoIDwgdGhpcy5oaWVyYXJjaHkubGVuZ3RoOyBoKysgKSB7XHJcblxyXG5cdFx0XHRcdGlmKCB0aGlzLmhpZXJhcmNoeVsgaCBdIGluc3RhbmNlb2YgVEhSRUUuQm9uZSApIHtcclxuXHJcblx0XHRcdFx0XHRKSVRoaWVyYXJjaHlbIGggXVsgZnJhbWUgXSA9IHRoaXMuaGllcmFyY2h5WyBoIF0uc2tpbk1hdHJpeC5jbG9uZSgpO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdEpJVGhpZXJhcmNoeVsgaCBdWyBmcmFtZSBdID0gdGhpcy5oaWVyYXJjaHlbIGggXS5tYXRyaXguY2xvbmUoKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEdldCBuZXh0IGtleSB3aXRoXHJcblxyXG5USFJFRS5LZXlGcmFtZUFuaW1hdGlvbi5wcm90b3R5cGUuZ2V0TmV4dEtleVdpdGggPSBmdW5jdGlvbiggc2lkLCBoLCBrZXkgKSB7XHJcblxyXG5cdHZhciBrZXlzID0gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdLmtleXM7XHJcblx0a2V5ID0ga2V5ICUga2V5cy5sZW5ndGg7XHJcblxyXG5cdGZvciAoIDsga2V5IDwga2V5cy5sZW5ndGg7IGtleSsrICkge1xyXG5cclxuXHRcdGlmICgga2V5c1sga2V5IF0uaGFzVGFyZ2V0KCBzaWQgKSApIHtcclxuXHJcblx0XHRcdHJldHVybiBrZXlzWyBrZXkgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIGtleXNbIDAgXTtcclxuXHJcbn07XHJcblxyXG4vLyBHZXQgcHJldmlvdXMga2V5IHdpdGhcclxuXHJcblRIUkVFLktleUZyYW1lQW5pbWF0aW9uLnByb3RvdHlwZS5nZXRQcmV2S2V5V2l0aCA9IGZ1bmN0aW9uKCBzaWQsIGgsIGtleSApIHtcclxuXHJcblx0dmFyIGtleXMgPSB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF0ua2V5cztcclxuXHRrZXkgPSBrZXkgPj0gMCA/IGtleSA6IGtleSArIGtleXMubGVuZ3RoO1xyXG5cclxuXHRmb3IgKCA7IGtleSA+PSAwOyBrZXktLSApIHtcclxuXHJcblx0XHRpZiAoIGtleXNbIGtleSBdLmhhc1RhcmdldCggc2lkICkgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4ga2V5c1sga2V5IF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBrZXlzWyBrZXlzLmxlbmd0aCAtIDEgXTtcclxuXHJcbn07XHJcbi8qKlxyXG4gKiBDYW1lcmEgZm9yIHJlbmRlcmluZyBjdWJlIG1hcHNcclxuICpcdC0gcmVuZGVycyBzY2VuZSBpbnRvIGF4aXMtYWxpZ25lZCBjdWJlXHJcbiAqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQ3ViZUNhbWVyYSA9IGZ1bmN0aW9uICggbmVhciwgZmFyLCBjdWJlUmVzb2x1dGlvbiApIHtcclxuXHJcblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuXHR2YXIgZm92ID0gOTAsIGFzcGVjdCA9IDE7XHJcblxyXG5cdHZhciBjYW1lcmFQWCA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xyXG5cdGNhbWVyYVBYLnVwLnNldCggMCwgLTEsIDAgKTtcclxuXHRjYW1lcmFQWC5sb29rQXQoIG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAwLCAwICkgKTtcclxuXHR0aGlzLmFkZCggY2FtZXJhUFggKTtcclxuXHJcblx0dmFyIGNhbWVyYU5YID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XHJcblx0Y2FtZXJhTlgudXAuc2V0KCAwLCAtMSwgMCApO1xyXG5cdGNhbWVyYU5YLmxvb2tBdCggbmV3IFRIUkVFLlZlY3RvcjMoIC0xLCAwLCAwICkgKTtcclxuXHR0aGlzLmFkZCggY2FtZXJhTlggKTtcclxuXHJcblx0dmFyIGNhbWVyYVBZID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XHJcblx0Y2FtZXJhUFkudXAuc2V0KCAwLCAwLCAxICk7XHJcblx0Y2FtZXJhUFkubG9va0F0KCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApICk7XHJcblx0dGhpcy5hZGQoIGNhbWVyYVBZICk7XHJcblxyXG5cdHZhciBjYW1lcmFOWSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xyXG5cdGNhbWVyYU5ZLnVwLnNldCggMCwgMCwgLTEgKTtcclxuXHRjYW1lcmFOWS5sb29rQXQoIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAtMSwgMCApICk7XHJcblx0dGhpcy5hZGQoIGNhbWVyYU5ZICk7XHJcblxyXG5cdHZhciBjYW1lcmFQWiA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xyXG5cdGNhbWVyYVBaLnVwLnNldCggMCwgLTEsIDAgKTtcclxuXHRjYW1lcmFQWi5sb29rQXQoIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAxICkgKTtcclxuXHR0aGlzLmFkZCggY2FtZXJhUFogKTtcclxuXHJcblx0dmFyIGNhbWVyYU5aID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XHJcblx0Y2FtZXJhTloudXAuc2V0KCAwLCAtMSwgMCApO1xyXG5cdGNhbWVyYU5aLmxvb2tBdCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIC0xICkgKTtcclxuXHR0aGlzLmFkZCggY2FtZXJhTlogKTtcclxuXHJcblx0dGhpcy5yZW5kZXJUYXJnZXQgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlKCBjdWJlUmVzb2x1dGlvbiwgY3ViZVJlc29sdXRpb24sIHsgZm9ybWF0OiBUSFJFRS5SR0JGb3JtYXQsIG1hZ0ZpbHRlcjogVEhSRUUuTGluZWFyRmlsdGVyLCBtaW5GaWx0ZXI6IFRIUkVFLkxpbmVhckZpbHRlciB9ICk7XHJcblxyXG5cdHRoaXMudXBkYXRlQ3ViZU1hcCA9IGZ1bmN0aW9uICggcmVuZGVyZXIsIHNjZW5lICkge1xyXG5cclxuXHRcdHZhciByZW5kZXJUYXJnZXQgPSB0aGlzLnJlbmRlclRhcmdldDtcclxuXHRcdHZhciBnZW5lcmF0ZU1pcG1hcHMgPSByZW5kZXJUYXJnZXQuZ2VuZXJhdGVNaXBtYXBzO1xyXG5cclxuXHRcdHJlbmRlclRhcmdldC5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcclxuXHJcblx0XHRyZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSAwO1xyXG5cdFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhUFgsIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDE7XHJcblx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFOWCwgcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMjtcclxuXHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYVBZLCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRyZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSAzO1xyXG5cdFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhTlksIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDQ7XHJcblx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFQWiwgcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0cmVuZGVyVGFyZ2V0LmdlbmVyYXRlTWlwbWFwcyA9IGdlbmVyYXRlTWlwbWFwcztcclxuXHJcblx0XHRyZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSA1O1xyXG5cdFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhTlosIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHR9O1xyXG5cclxufTtcclxuXHJcblRIUkVFLkN1YmVDYW1lcmEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XHJcbi8qXHJcbiAqXHRAYXV0aG9yIHp6ODUgLyBodHRwOi8vdHdpdHRlci5jb20vYmx1cnNwbGluZSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcclxuICpcclxuICpcdEEgZ2VuZXJhbCBwZXJwb3NlIGNhbWVyYSwgZm9yIHNldHRpbmcgRk9WLCBMZW5zIEZvY2FsIExlbmd0aCxcclxuICpcdFx0YW5kIHN3aXRjaGluZyBiZXR3ZWVuIHBlcnNwZWN0aXZlIGFuZCBvcnRob2dyYXBoaWMgdmlld3MgZWFzaWx5LlxyXG4gKlx0XHRVc2UgdGhpcyBvbmx5IGlmIHlvdSBkbyBub3Qgd2lzaCB0byBtYW5hZ2VcclxuICpcdFx0Ym90aCBhIE9ydGhvZ3JhcGhpYyBhbmQgUGVyc3BlY3RpdmUgQ2FtZXJhXHJcbiAqXHJcbiAqL1xyXG5cclxuXHJcblRIUkVFLkNvbWJpbmVkQ2FtZXJhID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0LCBmb3YsIG5lYXIsIGZhciwgb3J0aG9OZWFyLCBvcnRob0ZhciApIHtcclxuXHJcblx0VEhSRUUuQ2FtZXJhLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy5mb3YgPSBmb3Y7XHJcblxyXG5cdHRoaXMubGVmdCA9IC13aWR0aCAvIDI7XHJcblx0dGhpcy5yaWdodCA9IHdpZHRoIC8gMlxyXG5cdHRoaXMudG9wID0gaGVpZ2h0IC8gMjtcclxuXHR0aGlzLmJvdHRvbSA9IC1oZWlnaHQgLyAyO1xyXG5cclxuXHQvLyBXZSBjb3VsZCBhbHNvIGhhbmRsZSB0aGUgcHJvamVjdGlvbk1hdHJpeCBpbnRlcm5hbGx5LCBidXQganVzdCB3YW50ZWQgdG8gdGVzdCBuZXN0ZWQgY2FtZXJhIG9iamVjdHNcclxuXHJcblx0dGhpcy5jYW1lcmFPID0gbmV3IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSggd2lkdGggLyAtIDIsIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMiwgaGVpZ2h0IC8gLSAyLCBcdG9ydGhvTmVhciwgb3J0aG9GYXIgKTtcclxuXHR0aGlzLmNhbWVyYVAgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgd2lkdGggLyBoZWlnaHQsIG5lYXIsIGZhciApO1xyXG5cclxuXHR0aGlzLnpvb20gPSAxO1xyXG5cclxuXHR0aGlzLnRvUGVyc3BlY3RpdmUoKTtcclxuXHJcblx0dmFyIGFzcGVjdCA9IHdpZHRoL2hlaWdodDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Db21iaW5lZENhbWVyYS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DYW1lcmEucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5Db21iaW5lZENhbWVyYS5wcm90b3R5cGUudG9QZXJzcGVjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0Ly8gU3dpdGNoZXMgdG8gdGhlIFBlcnNwZWN0aXZlIENhbWVyYVxyXG5cclxuXHR0aGlzLm5lYXIgPSB0aGlzLmNhbWVyYVAubmVhcjtcclxuXHR0aGlzLmZhciA9IHRoaXMuY2FtZXJhUC5mYXI7XHJcblxyXG5cdHRoaXMuY2FtZXJhUC5mb3YgPSAgdGhpcy5mb3YgLyB0aGlzLnpvb20gO1xyXG5cclxuXHR0aGlzLmNhbWVyYVAudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xyXG5cclxuXHR0aGlzLnByb2plY3Rpb25NYXRyaXggPSB0aGlzLmNhbWVyYVAucHJvamVjdGlvbk1hdHJpeDtcclxuXHJcblx0dGhpcy5pblBlcnNwZWN0aXZlTW9kZSA9IHRydWU7XHJcblx0dGhpcy5pbk9ydGhvZ3JhcGhpY01vZGUgPSBmYWxzZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Db21iaW5lZENhbWVyYS5wcm90b3R5cGUudG9PcnRob2dyYXBoaWMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdC8vIFN3aXRjaGVzIHRvIHRoZSBPcnRob2dyYXBoaWMgY2FtZXJhIGVzdGltYXRpbmcgdmlld3BvcnQgZnJvbSBQZXJzcGVjdGl2ZVxyXG5cclxuXHR2YXIgZm92ID0gdGhpcy5mb3Y7XHJcblx0dmFyIGFzcGVjdCA9IHRoaXMuY2FtZXJhUC5hc3BlY3Q7XHJcblx0dmFyIG5lYXIgPSB0aGlzLmNhbWVyYVAubmVhcjtcclxuXHR2YXIgZmFyID0gdGhpcy5jYW1lcmFQLmZhcjtcclxuXHJcblx0Ly8gVGhlIHNpemUgdGhhdCB3ZSBzZXQgaXMgdGhlIG1pZCBwbGFuZSBvZiB0aGUgdmlld2luZyBmcnVzdHVtXHJcblxyXG5cdHZhciBoeXBlcmZvY3VzID0gKCBuZWFyICsgZmFyICkgLyAyO1xyXG5cclxuXHR2YXIgaGFsZkhlaWdodCA9IE1hdGgudGFuKCBmb3YgLyAyICkgKiBoeXBlcmZvY3VzO1xyXG5cdHZhciBwbGFuZUhlaWdodCA9IDIgKiBoYWxmSGVpZ2h0O1xyXG5cdHZhciBwbGFuZVdpZHRoID0gcGxhbmVIZWlnaHQgKiBhc3BlY3Q7XHJcblx0dmFyIGhhbGZXaWR0aCA9IHBsYW5lV2lkdGggLyAyO1xyXG5cclxuXHRoYWxmSGVpZ2h0IC89IHRoaXMuem9vbTtcclxuXHRoYWxmV2lkdGggLz0gdGhpcy56b29tO1xyXG5cclxuXHR0aGlzLmNhbWVyYU8ubGVmdCA9IC1oYWxmV2lkdGg7XHJcblx0dGhpcy5jYW1lcmFPLnJpZ2h0ID0gaGFsZldpZHRoO1xyXG5cdHRoaXMuY2FtZXJhTy50b3AgPSBoYWxmSGVpZ2h0O1xyXG5cdHRoaXMuY2FtZXJhTy5ib3R0b20gPSAtaGFsZkhlaWdodDtcclxuXHJcblx0Ly8gdGhpcy5jYW1lcmFPLmxlZnQgPSAtZmFySGFsZldpZHRoO1xyXG5cdC8vIHRoaXMuY2FtZXJhTy5yaWdodCA9IGZhckhhbGZXaWR0aDtcclxuXHQvLyB0aGlzLmNhbWVyYU8udG9wID0gZmFySGFsZkhlaWdodDtcclxuXHQvLyB0aGlzLmNhbWVyYU8uYm90dG9tID0gLWZhckhhbGZIZWlnaHQ7XHJcblxyXG5cdC8vIHRoaXMuY2FtZXJhTy5sZWZ0ID0gdGhpcy5sZWZ0IC8gdGhpcy56b29tO1xyXG5cdC8vIHRoaXMuY2FtZXJhTy5yaWdodCA9IHRoaXMucmlnaHQgLyB0aGlzLnpvb207XHJcblx0Ly8gdGhpcy5jYW1lcmFPLnRvcCA9IHRoaXMudG9wIC8gdGhpcy56b29tO1xyXG5cdC8vIHRoaXMuY2FtZXJhTy5ib3R0b20gPSB0aGlzLmJvdHRvbSAvIHRoaXMuem9vbTtcclxuXHJcblx0dGhpcy5jYW1lcmFPLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcclxuXHJcblx0dGhpcy5uZWFyID0gdGhpcy5jYW1lcmFPLm5lYXI7XHJcblx0dGhpcy5mYXIgPSB0aGlzLmNhbWVyYU8uZmFyO1xyXG5cdHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IHRoaXMuY2FtZXJhTy5wcm9qZWN0aW9uTWF0cml4O1xyXG5cclxuXHR0aGlzLmluUGVyc3BlY3RpdmVNb2RlID0gZmFsc2U7XHJcblx0dGhpcy5pbk9ydGhvZ3JhcGhpY01vZGUgPSB0cnVlO1xyXG5cclxufTtcclxuXHJcblxyXG5USFJFRS5Db21iaW5lZENhbWVyYS5wcm90b3R5cGUuc2V0U2l6ZSA9IGZ1bmN0aW9uKCB3aWR0aCwgaGVpZ2h0ICkge1xyXG5cclxuXHR0aGlzLmNhbWVyYVAuYXNwZWN0ID0gd2lkdGggLyBoZWlnaHQ7XHJcblx0dGhpcy5sZWZ0ID0gLXdpZHRoIC8gMjtcclxuXHR0aGlzLnJpZ2h0ID0gd2lkdGggLyAyXHJcblx0dGhpcy50b3AgPSBoZWlnaHQgLyAyO1xyXG5cdHRoaXMuYm90dG9tID0gLWhlaWdodCAvIDI7XHJcblxyXG59O1xyXG5cclxuXHJcblRIUkVFLkNvbWJpbmVkQ2FtZXJhLnByb3RvdHlwZS5zZXRGb3YgPSBmdW5jdGlvbiggZm92ICkge1xyXG5cclxuXHR0aGlzLmZvdiA9IGZvdjtcclxuXHJcblx0aWYgKCB0aGlzLmluUGVyc3BlY3RpdmVNb2RlICkge1xyXG5cclxuXHRcdHRoaXMudG9QZXJzcGVjdGl2ZSgpO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdHRoaXMudG9PcnRob2dyYXBoaWMoKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEZvciBtYW50YWluaW5nIHNpbWlsYXIgQVBJIHdpdGggUGVyc3BlY3RpdmVDYW1lcmFcclxuXHJcblRIUkVFLkNvbWJpbmVkQ2FtZXJhLnByb3RvdHlwZS51cGRhdGVQcm9qZWN0aW9uTWF0cml4ID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdGlmICggdGhpcy5pblBlcnNwZWN0aXZlTW9kZSApIHtcclxuXHJcblx0XHR0aGlzLnRvUGVyc3BlY3RpdmUoKTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHR0aGlzLnRvUGVyc3BlY3RpdmUoKTtcclxuXHRcdHRoaXMudG9PcnRob2dyYXBoaWMoKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8qXHJcbiogVXNlcyBGb2NhbCBMZW5ndGggKGluIG1tKSB0byBlc3RpbWF0ZSBhbmQgc2V0IEZPVlxyXG4qIDM1bW0gKGZ1bGxmcmFtZSkgY2FtZXJhIGlzIHVzZWQgaWYgZnJhbWUgc2l6ZSBpcyBub3Qgc3BlY2lmaWVkO1xyXG4qIEZvcm11bGEgYmFzZWQgb24gaHR0cDovL3d3dy5ib2JhdGtpbnMuY29tL3Bob3RvZ3JhcGh5L3RlY2huaWNhbC9maWVsZF9vZl92aWV3Lmh0bWxcclxuKi9cclxuVEhSRUUuQ29tYmluZWRDYW1lcmEucHJvdG90eXBlLnNldExlbnMgPSBmdW5jdGlvbiAoIGZvY2FsTGVuZ3RoLCBmcmFtZUhlaWdodCApIHtcclxuXHJcblx0aWYgKCBmcmFtZUhlaWdodCA9PT0gdW5kZWZpbmVkICkgZnJhbWVIZWlnaHQgPSAyNDtcclxuXHJcblx0dmFyIGZvdiA9IDIgKiBUSFJFRS5NYXRoLnJhZFRvRGVnKCBNYXRoLmF0YW4oIGZyYW1lSGVpZ2h0IC8gKCBmb2NhbExlbmd0aCAqIDIgKSApICk7XHJcblxyXG5cdHRoaXMuc2V0Rm92KCBmb3YgKTtcclxuXHJcblx0cmV0dXJuIGZvdjtcclxufTtcclxuXHJcblxyXG5USFJFRS5Db21iaW5lZENhbWVyYS5wcm90b3R5cGUuc2V0Wm9vbSA9IGZ1bmN0aW9uKCB6b29tICkge1xyXG5cclxuXHR0aGlzLnpvb20gPSB6b29tO1xyXG5cclxuXHRpZiAoIHRoaXMuaW5QZXJzcGVjdGl2ZU1vZGUgKSB7XHJcblxyXG5cdFx0dGhpcy50b1BlcnNwZWN0aXZlKCk7XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0dGhpcy50b09ydGhvZ3JhcGhpYygpO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ29tYmluZWRDYW1lcmEucHJvdG90eXBlLnRvRnJvbnRWaWV3ID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdHRoaXMucm90YXRpb24ueCA9IDA7XHJcblx0dGhpcy5yb3RhdGlvbi55ID0gMDtcclxuXHR0aGlzLnJvdGF0aW9uLnogPSAwO1xyXG5cclxuXHQvLyBzaG91bGQgd2UgYmUgbW9kaWZpbmcgdGhlIG1hdHJpeCBpbnN0ZWFkP1xyXG5cclxuXHR0aGlzLnJvdGF0aW9uQXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkNvbWJpbmVkQ2FtZXJhLnByb3RvdHlwZS50b0JhY2tWaWV3ID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdHRoaXMucm90YXRpb24ueCA9IDA7XHJcblx0dGhpcy5yb3RhdGlvbi55ID0gTWF0aC5QSTtcclxuXHR0aGlzLnJvdGF0aW9uLnogPSAwO1xyXG5cdHRoaXMucm90YXRpb25BdXRvVXBkYXRlID0gZmFsc2U7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ29tYmluZWRDYW1lcmEucHJvdG90eXBlLnRvTGVmdFZpZXcgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0dGhpcy5yb3RhdGlvbi54ID0gMDtcclxuXHR0aGlzLnJvdGF0aW9uLnkgPSAtIE1hdGguUEkgLyAyO1xyXG5cdHRoaXMucm90YXRpb24ueiA9IDA7XHJcblx0dGhpcy5yb3RhdGlvbkF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Db21iaW5lZENhbWVyYS5wcm90b3R5cGUudG9SaWdodFZpZXcgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0dGhpcy5yb3RhdGlvbi54ID0gMDtcclxuXHR0aGlzLnJvdGF0aW9uLnkgPSBNYXRoLlBJIC8gMjtcclxuXHR0aGlzLnJvdGF0aW9uLnogPSAwO1xyXG5cdHRoaXMucm90YXRpb25BdXRvVXBkYXRlID0gZmFsc2U7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ29tYmluZWRDYW1lcmEucHJvdG90eXBlLnRvVG9wVmlldyA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHR0aGlzLnJvdGF0aW9uLnggPSAtIE1hdGguUEkgLyAyO1xyXG5cdHRoaXMucm90YXRpb24ueSA9IDA7XHJcblx0dGhpcy5yb3RhdGlvbi56ID0gMDtcclxuXHR0aGlzLnJvdGF0aW9uQXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkNvbWJpbmVkQ2FtZXJhLnByb3RvdHlwZS50b0JvdHRvbVZpZXcgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0dGhpcy5yb3RhdGlvbi54ID0gTWF0aC5QSSAvIDI7XHJcblx0dGhpcy5yb3RhdGlvbi55ID0gMDtcclxuXHR0aGlzLnJvdGF0aW9uLnogPSAwO1xyXG5cdHRoaXMucm90YXRpb25BdXRvVXBkYXRlID0gZmFsc2U7XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqXHJcbiAqXHQtIDNkIGFzdGVyaXNrIHNoYXBlIChmb3IgbGluZSBwaWVjZXMgVEhSRUUuTGluZSlcclxuICovXHJcblxyXG5USFJFRS5Bc3Rlcmlza0dlb21ldHJ5ID0gZnVuY3Rpb24gKCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMgKSB7XHJcblxyXG5cdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dmFyIHNkID0gaW5uZXJSYWRpdXM7XHJcblx0dmFyIGVkID0gb3V0ZXJSYWRpdXM7XHJcblxyXG5cdHZhciBzZDIgPSAwLjcwNyAqIHNkO1xyXG5cdHZhciBlZDIgPSAwLjcwNyAqIGVkO1xyXG5cclxuXHR2YXIgcmF5cyA9IFsgWyBzZCwgMCwgMCBdLCBbIGVkLCAwLCAwIF0sIFsgLXNkLCAwLCAwIF0sIFsgLWVkLCAwLCAwIF0sXHJcblx0XHRcdFx0IFsgMCwgc2QsIDAgXSwgWyAwLCBlZCwgMCBdLCBbIDAsIC1zZCwgMCBdLCBbIDAsIC1lZCwgMCBdLFxyXG5cdFx0XHRcdCBbIDAsIDAsIHNkIF0sIFsgMCwgMCwgZWQgXSwgWyAwLCAwLCAtc2QgXSwgWyAwLCAwLCAtZWQgXSxcclxuXHRcdFx0XHQgWyBzZDIsIHNkMiwgMCBdLCBbIGVkMiwgZWQyLCAwIF0sIFsgLXNkMiwgLXNkMiwgMCBdLCBbIC1lZDIsIC1lZDIsIDAgXSxcclxuXHRcdFx0XHQgWyBzZDIsIC1zZDIsIDAgXSwgWyBlZDIsIC1lZDIsIDAgXSwgWyAtc2QyLCBzZDIsIDAgXSwgWyAtZWQyLCBlZDIsIDAgXSxcclxuXHRcdFx0XHQgWyBzZDIsIDAsIHNkMiBdLCBbIGVkMiwgMCwgZWQyIF0sIFsgLXNkMiwgMCwgLXNkMiBdLCBbIC1lZDIsIDAsIC1lZDIgXSxcclxuXHRcdFx0XHQgWyBzZDIsIDAsIC1zZDIgXSwgWyBlZDIsIDAsIC1lZDIgXSwgWyAtc2QyLCAwLCBzZDIgXSwgWyAtZWQyLCAwLCBlZDIgXSxcclxuXHRcdFx0XHQgWyAwLCBzZDIsIHNkMiBdLCBbIDAsIGVkMiwgZWQyIF0sIFsgMCwgLXNkMiwgLXNkMiBdLCBbIDAsIC1lZDIsIC1lZDIgXSxcclxuXHRcdFx0XHQgWyAwLCBzZDIsIC1zZDIgXSwgWyAwLCBlZDIsIC1lZDIgXSwgWyAwLCAtc2QyLCBzZDIgXSwgWyAwLCAtZWQyLCBlZDIgXVxyXG5cdF07XHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgaWwgPSByYXlzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdHZhciB4ID0gcmF5c1sgaSBdWyAwIF07XHJcblx0XHR2YXIgeSA9IHJheXNbIGkgXVsgMSBdO1xyXG5cdFx0dmFyIHogPSByYXlzWyBpIF1bIDIgXTtcclxuXHJcblx0XHR0aGlzLnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCB4LCB5LCB6ICkgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLkFzdGVyaXNrR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7LyoqXHJcbiAqIEBhdXRob3IgaHVnaGVzXHJcbiAqL1xyXG5cclxuVEhSRUUuQ2lyY2xlR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgc2VnbWVudHMsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xyXG5cclxuICAgIFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcbiAgICByYWRpdXMgPSByYWRpdXMgfHwgNTA7XHJcblxyXG4gICAgdGhldGFTdGFydCA9IHRoZXRhU3RhcnQgIT09IHVuZGVmaW5lZCA/IHRoZXRhU3RhcnQgOiAwO1xyXG4gICAgdGhldGFMZW5ndGggPSB0aGV0YUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gdGhldGFMZW5ndGggOiBNYXRoLlBJICogMjtcclxuICAgIHNlZ21lbnRzID0gc2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IE1hdGgubWF4KCAzLCBzZWdtZW50cyApIDogODtcclxuXHJcbiAgICB2YXIgaSwgdXZzID0gW10sXHJcbiAgICBjZW50ZXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpLCBjZW50ZXJVViA9IG5ldyBUSFJFRS5WZWN0b3IyKCAwLjUsIDAuNSApO1xyXG5cclxuICAgIHRoaXMudmVydGljZXMucHVzaChjZW50ZXIpO1xyXG4gICAgdXZzLnB1c2goIGNlbnRlclVWICk7XHJcblxyXG4gICAgZm9yICggaSA9IDA7IGkgPD0gc2VnbWVudHM7IGkgKysgKSB7XHJcblxyXG4gICAgICAgIHZhciB2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuICAgICAgICB2ZXJ0ZXgueCA9IHJhZGl1cyAqIE1hdGguY29zKCB0aGV0YVN0YXJ0ICsgaSAvIHNlZ21lbnRzICogdGhldGFMZW5ndGggKTtcclxuICAgICAgICB2ZXJ0ZXgueSA9IHJhZGl1cyAqIE1hdGguc2luKCB0aGV0YVN0YXJ0ICsgaSAvIHNlZ21lbnRzICogdGhldGFMZW5ndGggKTtcclxuXHJcbiAgICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcclxuICAgICAgICB1dnMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoICggdmVydGV4LnggLyByYWRpdXMgKyAxICkgLyAyLCAtICggdmVydGV4LnkgLyByYWRpdXMgKyAxICkgLyAyICsgMSApICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHZhciBuID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIC0xICk7XHJcblxyXG4gICAgZm9yICggaSA9IDE7IGkgPD0gc2VnbWVudHM7IGkgKysgKSB7XHJcblxyXG4gICAgICAgIHZhciB2MSA9IGk7XHJcbiAgICAgICAgdmFyIHYyID0gaSArIDEgO1xyXG4gICAgICAgIHZhciB2MyA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2MSwgdjIsIHYzLCBbIG4sIG4sIG4gXSApICk7XHJcbiAgICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dnNbIGkgXSwgdXZzWyBpICsgMSBdLCBjZW50ZXJVViBdICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuY29tcHV0ZUNlbnRyb2lkcygpO1xyXG4gICAgdGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHJcbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSggbmV3IFRIUkVFLlZlY3RvcjMoKSwgcmFkaXVzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ2lyY2xlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBiYXNlZCBvbiBodHRwOi8vcGFwZXJ2aXNpb24zZC5nb29nbGVjb2RlLmNvbS9zdm4vdHJ1bmsvYXMzL3RydW5rL3NyYy9vcmcvcGFwZXJ2aXNpb24zZC9vYmplY3RzL3ByaW1pdGl2ZXMvQ3ViZS5hc1xyXG4gKi9cclxuXHJcblRIUkVFLkN1YmVHZW9tZXRyeSA9IGZ1bmN0aW9uICggd2lkdGgsIGhlaWdodCwgZGVwdGgsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBkZXB0aFNlZ21lbnRzICkge1xyXG5cclxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdHRoaXMud2lkdGggPSB3aWR0aDtcclxuXHR0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuXHR0aGlzLmRlcHRoID0gZGVwdGg7XHJcblxyXG5cdHRoaXMud2lkdGhTZWdtZW50cyA9IHdpZHRoU2VnbWVudHMgfHwgMTtcclxuXHR0aGlzLmhlaWdodFNlZ21lbnRzID0gaGVpZ2h0U2VnbWVudHMgfHwgMTtcclxuXHR0aGlzLmRlcHRoU2VnbWVudHMgPSBkZXB0aFNlZ21lbnRzIHx8IDE7XHJcblxyXG5cdHZhciB3aWR0aF9oYWxmID0gdGhpcy53aWR0aCAvIDI7XHJcblx0dmFyIGhlaWdodF9oYWxmID0gdGhpcy5oZWlnaHQgLyAyO1xyXG5cdHZhciBkZXB0aF9oYWxmID0gdGhpcy5kZXB0aCAvIDI7XHJcblxyXG5cdGJ1aWxkUGxhbmUoICd6JywgJ3knLCAtIDEsIC0gMSwgdGhpcy5kZXB0aCwgdGhpcy5oZWlnaHQsIHdpZHRoX2hhbGYsIDAgKTsgLy8gcHhcclxuXHRidWlsZFBsYW5lKCAneicsICd5JywgICAxLCAtIDEsIHRoaXMuZGVwdGgsIHRoaXMuaGVpZ2h0LCAtIHdpZHRoX2hhbGYsIDEgKTsgLy8gbnhcclxuXHRidWlsZFBsYW5lKCAneCcsICd6JywgICAxLCAgIDEsIHRoaXMud2lkdGgsIHRoaXMuZGVwdGgsIGhlaWdodF9oYWxmLCAyICk7IC8vIHB5XHJcblx0YnVpbGRQbGFuZSggJ3gnLCAneicsICAgMSwgLSAxLCB0aGlzLndpZHRoLCB0aGlzLmRlcHRoLCAtIGhlaWdodF9oYWxmLCAzICk7IC8vIG55XHJcblx0YnVpbGRQbGFuZSggJ3gnLCAneScsICAgMSwgLSAxLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgZGVwdGhfaGFsZiwgNCApOyAvLyBwelxyXG5cdGJ1aWxkUGxhbmUoICd4JywgJ3knLCAtIDEsIC0gMSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIC0gZGVwdGhfaGFsZiwgNSApOyAvLyBuelxyXG5cclxuXHRmdW5jdGlvbiBidWlsZFBsYW5lKCB1LCB2LCB1ZGlyLCB2ZGlyLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgbWF0ZXJpYWxJbmRleCApIHtcclxuXHJcblx0XHR2YXIgdywgaXgsIGl5LFxyXG5cdFx0Z3JpZFggPSBzY29wZS53aWR0aFNlZ21lbnRzLFxyXG5cdFx0Z3JpZFkgPSBzY29wZS5oZWlnaHRTZWdtZW50cyxcclxuXHRcdHdpZHRoX2hhbGYgPSB3aWR0aCAvIDIsXHJcblx0XHRoZWlnaHRfaGFsZiA9IGhlaWdodCAvIDIsXHJcblx0XHRvZmZzZXQgPSBzY29wZS52ZXJ0aWNlcy5sZW5ndGg7XHJcblxyXG5cdFx0aWYgKCAoIHUgPT09ICd4JyAmJiB2ID09PSAneScgKSB8fCAoIHUgPT09ICd5JyAmJiB2ID09PSAneCcgKSApIHtcclxuXHJcblx0XHRcdHcgPSAneic7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggKCB1ID09PSAneCcgJiYgdiA9PT0gJ3onICkgfHwgKCB1ID09PSAneicgJiYgdiA9PT0gJ3gnICkgKSB7XHJcblxyXG5cdFx0XHR3ID0gJ3knO1xyXG5cdFx0XHRncmlkWSA9IHNjb3BlLmRlcHRoU2VnbWVudHM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggKCB1ID09PSAneicgJiYgdiA9PT0gJ3knICkgfHwgKCB1ID09PSAneScgJiYgdiA9PT0gJ3onICkgKSB7XHJcblxyXG5cdFx0XHR3ID0gJ3gnO1xyXG5cdFx0XHRncmlkWCA9IHNjb3BlLmRlcHRoU2VnbWVudHM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBncmlkWDEgPSBncmlkWCArIDEsXHJcblx0XHRncmlkWTEgPSBncmlkWSArIDEsXHJcblx0XHRzZWdtZW50X3dpZHRoID0gd2lkdGggLyBncmlkWCxcclxuXHRcdHNlZ21lbnRfaGVpZ2h0ID0gaGVpZ2h0IC8gZ3JpZFksXHJcblx0XHRub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdG5vcm1hbFsgdyBdID0gZGVwdGggPiAwID8gMSA6IC0gMTtcclxuXHJcblx0XHRmb3IgKCBpeSA9IDA7IGl5IDwgZ3JpZFkxOyBpeSArKyApIHtcclxuXHJcblx0XHRcdGZvciAoIGl4ID0gMDsgaXggPCBncmlkWDE7IGl4ICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdFx0XHR2ZWN0b3JbIHUgXSA9ICggaXggKiBzZWdtZW50X3dpZHRoIC0gd2lkdGhfaGFsZiApICogdWRpcjtcclxuXHRcdFx0XHR2ZWN0b3JbIHYgXSA9ICggaXkgKiBzZWdtZW50X2hlaWdodCAtIGhlaWdodF9oYWxmICkgKiB2ZGlyO1xyXG5cdFx0XHRcdHZlY3RvclsgdyBdID0gZGVwdGg7XHJcblxyXG5cdFx0XHRcdHNjb3BlLnZlcnRpY2VzLnB1c2goIHZlY3RvciApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCBpeSA9IDA7IGl5IDwgZ3JpZFk7IGl5KysgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCBpeCA9IDA7IGl4IDwgZ3JpZFg7IGl4KysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBhID0gaXggKyBncmlkWDEgKiBpeTtcclxuXHRcdFx0XHR2YXIgYiA9IGl4ICsgZ3JpZFgxICogKCBpeSArIDEgKTtcclxuXHRcdFx0XHR2YXIgYyA9ICggaXggKyAxICkgKyBncmlkWDEgKiAoIGl5ICsgMSApO1xyXG5cdFx0XHRcdHZhciBkID0gKCBpeCArIDEgKSArIGdyaWRYMSAqIGl5O1xyXG5cclxuXHRcdFx0XHR2YXIgZmFjZSA9IG5ldyBUSFJFRS5GYWNlNCggYSArIG9mZnNldCwgYiArIG9mZnNldCwgYyArIG9mZnNldCwgZCArIG9mZnNldCApO1xyXG5cdFx0XHRcdGZhY2Uubm9ybWFsLmNvcHkoIG5vcm1hbCApO1xyXG5cdFx0XHRcdGZhY2UudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwuY2xvbmUoKSwgbm9ybWFsLmNsb25lKCksIG5vcm1hbC5jbG9uZSgpLCBub3JtYWwuY2xvbmUoKSApO1xyXG5cdFx0XHRcdGZhY2UubWF0ZXJpYWxJbmRleCA9IG1hdGVyaWFsSW5kZXg7XHJcblxyXG5cdFx0XHRcdHNjb3BlLmZhY2VzLnB1c2goIGZhY2UgKTtcclxuXHRcdFx0XHRzY29wZS5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggW1xyXG5cdFx0XHRcdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBpeCAvIGdyaWRYLCAxIC0gaXkgLyBncmlkWSApLFxyXG5cdFx0XHRcdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBpeCAvIGdyaWRYLCAxIC0gKCBpeSArIDEgKSAvIGdyaWRZICksXHJcblx0XHRcdFx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoICggaXggKyAxICkgLyBncmlkWCwgMS0gKCBpeSArIDEgKSAvIGdyaWRZICksXHJcblx0XHRcdFx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoICggaXggKyAxICkgLyBncmlkWCwgMSAtIGl5IC8gZ3JpZFkgKVxyXG5cdFx0XHRcdFx0XHRdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMuY29tcHV0ZUNlbnRyb2lkcygpO1xyXG5cdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkN1YmVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzVG9wLCByYWRpdXNCb3R0b20sIGhlaWdodCwgcmFkaXVzU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBvcGVuRW5kZWQgKSB7XHJcblxyXG5cdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcblx0cmFkaXVzVG9wID0gcmFkaXVzVG9wICE9PSB1bmRlZmluZWQgPyByYWRpdXNUb3AgOiAyMDtcclxuXHRyYWRpdXNCb3R0b20gPSByYWRpdXNCb3R0b20gIT09IHVuZGVmaW5lZCA/IHJhZGl1c0JvdHRvbSA6IDIwO1xyXG5cdGhlaWdodCA9IGhlaWdodCAhPT0gdW5kZWZpbmVkID8gaGVpZ2h0IDogMTAwO1xyXG5cclxuXHR2YXIgaGVpZ2h0SGFsZiA9IGhlaWdodCAvIDI7XHJcblx0dmFyIHNlZ21lbnRzWCA9IHJhZGl1c1NlZ21lbnRzIHx8IDg7XHJcblx0dmFyIHNlZ21lbnRzWSA9IGhlaWdodFNlZ21lbnRzIHx8IDE7XHJcblxyXG5cdHZhciB4LCB5LCB2ZXJ0aWNlcyA9IFtdLCB1dnMgPSBbXTtcclxuXHJcblx0Zm9yICggeSA9IDA7IHkgPD0gc2VnbWVudHNZOyB5ICsrICkge1xyXG5cclxuXHRcdHZhciB2ZXJ0aWNlc1JvdyA9IFtdO1xyXG5cdFx0dmFyIHV2c1JvdyA9IFtdO1xyXG5cclxuXHRcdHZhciB2ID0geSAvIHNlZ21lbnRzWTtcclxuXHRcdHZhciByYWRpdXMgPSB2ICogKCByYWRpdXNCb3R0b20gLSByYWRpdXNUb3AgKSArIHJhZGl1c1RvcDtcclxuXHJcblx0XHRmb3IgKCB4ID0gMDsgeCA8PSBzZWdtZW50c1g7IHggKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgdSA9IHggLyBzZWdtZW50c1g7XHJcblxyXG5cdFx0XHR2YXIgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdFx0dmVydGV4LnggPSByYWRpdXMgKiBNYXRoLnNpbiggdSAqIE1hdGguUEkgKiAyICk7XHJcblx0XHRcdHZlcnRleC55ID0gLSB2ICogaGVpZ2h0ICsgaGVpZ2h0SGFsZjtcclxuXHRcdFx0dmVydGV4LnogPSByYWRpdXMgKiBNYXRoLmNvcyggdSAqIE1hdGguUEkgKiAyICk7XHJcblxyXG5cdFx0XHR0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xyXG5cclxuXHRcdFx0dmVydGljZXNSb3cucHVzaCggdGhpcy52ZXJ0aWNlcy5sZW5ndGggLSAxICk7XHJcblx0XHRcdHV2c1Jvdy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggdSwgMSAtIHYgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0aWNlc1JvdyApO1xyXG5cdFx0dXZzLnB1c2goIHV2c1JvdyApO1xyXG5cclxuXHR9XHJcblxyXG5cdHZhciB0YW5UaGV0YSA9ICggcmFkaXVzQm90dG9tIC0gcmFkaXVzVG9wICkgLyBoZWlnaHQ7XHJcblx0dmFyIG5hLCBuYjtcclxuXHJcblx0Zm9yICggeCA9IDA7IHggPCBzZWdtZW50c1g7IHggKysgKSB7XHJcblxyXG5cdFx0aWYgKCByYWRpdXNUb3AgIT09IDAgKSB7XHJcblxyXG5cdFx0XHRuYSA9IHRoaXMudmVydGljZXNbIHZlcnRpY2VzWyAwIF1bIHggXSBdLmNsb25lKCk7XHJcblx0XHRcdG5iID0gdGhpcy52ZXJ0aWNlc1sgdmVydGljZXNbIDAgXVsgeCArIDEgXSBdLmNsb25lKCk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdG5hID0gdGhpcy52ZXJ0aWNlc1sgdmVydGljZXNbIDEgXVsgeCBdIF0uY2xvbmUoKTtcclxuXHRcdFx0bmIgPSB0aGlzLnZlcnRpY2VzWyB2ZXJ0aWNlc1sgMSBdWyB4ICsgMSBdIF0uY2xvbmUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0bmEuc2V0WSggTWF0aC5zcXJ0KCBuYS54ICogbmEueCArIG5hLnogKiBuYS56ICkgKiB0YW5UaGV0YSApLm5vcm1hbGl6ZSgpO1xyXG5cdFx0bmIuc2V0WSggTWF0aC5zcXJ0KCBuYi54ICogbmIueCArIG5iLnogKiBuYi56ICkgKiB0YW5UaGV0YSApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdGZvciAoIHkgPSAwOyB5IDwgc2VnbWVudHNZOyB5ICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHYxID0gdmVydGljZXNbIHkgXVsgeCBdO1xyXG5cdFx0XHR2YXIgdjIgPSB2ZXJ0aWNlc1sgeSArIDEgXVsgeCBdO1xyXG5cdFx0XHR2YXIgdjMgPSB2ZXJ0aWNlc1sgeSArIDEgXVsgeCArIDEgXTtcclxuXHRcdFx0dmFyIHY0ID0gdmVydGljZXNbIHkgXVsgeCArIDEgXTtcclxuXHJcblx0XHRcdHZhciBuMSA9IG5hLmNsb25lKCk7XHJcblx0XHRcdHZhciBuMiA9IG5hLmNsb25lKCk7XHJcblx0XHRcdHZhciBuMyA9IG5iLmNsb25lKCk7XHJcblx0XHRcdHZhciBuNCA9IG5iLmNsb25lKCk7XHJcblxyXG5cdFx0XHR2YXIgdXYxID0gdXZzWyB5IF1bIHggXS5jbG9uZSgpO1xyXG5cdFx0XHR2YXIgdXYyID0gdXZzWyB5ICsgMSBdWyB4IF0uY2xvbmUoKTtcclxuXHRcdFx0dmFyIHV2MyA9IHV2c1sgeSArIDEgXVsgeCArIDEgXS5jbG9uZSgpO1xyXG5cdFx0XHR2YXIgdXY0ID0gdXZzWyB5IF1bIHggKyAxIF0uY2xvbmUoKTtcclxuXHJcblx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2U0KCB2MSwgdjIsIHYzLCB2NCwgWyBuMSwgbjIsIG4zLCBuNCBdICkgKTtcclxuXHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1djEsIHV2MiwgdXYzLCB1djQgXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvLyB0b3AgY2FwXHJcblxyXG5cdGlmICggIW9wZW5FbmRlZCAmJiByYWRpdXNUb3AgPiAwICkge1xyXG5cclxuXHRcdHRoaXMudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIGhlaWdodEhhbGYsIDAgKSApO1xyXG5cclxuXHRcdGZvciAoIHggPSAwOyB4IDwgc2VnbWVudHNYOyB4ICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHYxID0gdmVydGljZXNbIDAgXVsgeCBdO1xyXG5cdFx0XHR2YXIgdjIgPSB2ZXJ0aWNlc1sgMCBdWyB4ICsgMSBdO1xyXG5cdFx0XHR2YXIgdjMgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aCAtIDE7XHJcblxyXG5cdFx0XHR2YXIgbjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApO1xyXG5cdFx0XHR2YXIgbjIgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApO1xyXG5cdFx0XHR2YXIgbjMgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApO1xyXG5cclxuXHRcdFx0dmFyIHV2MSA9IHV2c1sgMCBdWyB4IF0uY2xvbmUoKTtcclxuXHRcdFx0dmFyIHV2MiA9IHV2c1sgMCBdWyB4ICsgMSBdLmNsb25lKCk7XHJcblx0XHRcdHZhciB1djMgPSBuZXcgVEhSRUUuVmVjdG9yMiggdXYyLnUsIDAgKTtcclxuXHJcblx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2MSwgdjIsIHYzLCBbIG4xLCBuMiwgbjMgXSApICk7XHJcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXYxLCB1djIsIHV2MyBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8vIGJvdHRvbSBjYXBcclxuXHJcblx0aWYgKCAhb3BlbkVuZGVkICYmIHJhZGl1c0JvdHRvbSA+IDAgKSB7XHJcblxyXG5cdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgLSBoZWlnaHRIYWxmLCAwICkgKTtcclxuXHJcblx0XHRmb3IgKCB4ID0gMDsgeCA8IHNlZ21lbnRzWDsgeCArKyApIHtcclxuXHJcblx0XHRcdHZhciB2MSA9IHZlcnRpY2VzWyB5IF1bIHggKyAxIF07XHJcblx0XHRcdHZhciB2MiA9IHZlcnRpY2VzWyB5IF1bIHggXTtcclxuXHRcdFx0dmFyIHYzID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGggLSAxO1xyXG5cclxuXHRcdFx0dmFyIG4xID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIC0gMSwgMCApO1xyXG5cdFx0XHR2YXIgbjIgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgLSAxLCAwICk7XHJcblx0XHRcdHZhciBuMyA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAtIDEsIDAgKTtcclxuXHJcblx0XHRcdHZhciB1djEgPSB1dnNbIHkgXVsgeCArIDEgXS5jbG9uZSgpO1xyXG5cdFx0XHR2YXIgdXYyID0gdXZzWyB5IF1bIHggXS5jbG9uZSgpO1xyXG5cdFx0XHR2YXIgdXYzID0gbmV3IFRIUkVFLlZlY3RvcjIoIHV2Mi51LCAxICk7XHJcblxyXG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjEsIHYyLCB2MywgWyBuMSwgbjIsIG4zIF0gKSApO1xyXG5cdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2MSwgdXYyLCB1djMgXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLmNvbXB1dGVDZW50cm9pZHMoKTtcclxuXHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG5cclxufVxyXG5cclxuVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuLyoqXHJcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcclxuICpcclxuICogQ3JlYXRlcyBleHRydWRlZCBnZW9tZXRyeSBmcm9tIGEgcGF0aCBzaGFwZS5cclxuICpcclxuICogcGFyYW1ldGVycyA9IHtcclxuICpcclxuICogIHNpemU6IDxmbG9hdD4sIC8vIHNpemUgb2YgdGhlIHRleHRcclxuICogIGhlaWdodDogPGZsb2F0PiwgLy8gdGhpY2tuZXNzIHRvIGV4dHJ1ZGUgdGV4dFxyXG4gKiAgY3VydmVTZWdtZW50czogPGludD4sIC8vIG51bWJlciBvZiBwb2ludHMgb24gdGhlIGN1cnZlc1xyXG4gKiAgc3RlcHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgcG9pbnRzIGZvciB6LXNpZGUgZXh0cnVzaW9ucyAvIHVzZWQgZm9yIHN1YmRpdmlkaW5nIHNlZ2VtZW50cyBvZiBleHRydWRlIHNwbGluZSB0b29cclxuICogIGFtb3VudDogPGludD4sIC8vIEFtb3VudFxyXG4gKlxyXG4gKiAgYmV2ZWxFbmFibGVkOiA8Ym9vbD4sIC8vIHR1cm4gb24gYmV2ZWxcclxuICogIGJldmVsVGhpY2tuZXNzOiA8ZmxvYXQ+LCAvLyBob3cgZGVlcCBpbnRvIHRleHQgYmV2ZWwgZ29lc1xyXG4gKiAgYmV2ZWxTaXplOiA8ZmxvYXQ+LCAvLyBob3cgZmFyIGZyb20gdGV4dCBvdXRsaW5lIGlzIGJldmVsXHJcbiAqICBiZXZlbFNlZ21lbnRzOiA8aW50PiwgLy8gbnVtYmVyIG9mIGJldmVsIGxheWVyc1xyXG4gKlxyXG4gKiAgZXh0cnVkZVBhdGg6IDxUSFJFRS5DdXJ2ZVBhdGg+IC8vIDNkIHNwbGluZSBwYXRoIHRvIGV4dHJ1ZGUgc2hhcGUgYWxvbmcuIChjcmVhdGVzIEZyYW1lcyBpZiAuZnJhbWVzIGFyZW4ndCBkZWZpbmVkKVxyXG4gKiAgZnJhbWVzOiA8VEhSRUUuVHViZUdlb21ldHJ5LkZyZW5ldEZyYW1lcz4gLy8gY29udGFpbmluZyBhcnJheXMgb2YgdGFuZ2VudHMsIG5vcm1hbHMsIGJpbm9ybWFsc1xyXG4gKlxyXG4gKiAgbWF0ZXJpYWw6IDxpbnQ+IC8vIG1hdGVyaWFsIGluZGV4IGZvciBmcm9udCBhbmQgYmFjayBmYWNlc1xyXG4gKiAgZXh0cnVkZU1hdGVyaWFsOiA8aW50PiAvLyBtYXRlcmlhbCBpbmRleCBmb3IgZXh0cnVzaW9uIGFuZCBiZXZlbGVkIGZhY2VzXHJcbiAqICB1dkdlbmVyYXRvcjogPE9iamVjdD4gLy8gb2JqZWN0IHRoYXQgcHJvdmlkZXMgVVYgZ2VuZXJhdG9yIGZ1bmN0aW9uc1xyXG4gKlxyXG4gKiB9XHJcbiAqKi9cclxuXHJcblRIUkVFLkV4dHJ1ZGVHZW9tZXRyeSA9IGZ1bmN0aW9uICggc2hhcGVzLCBvcHRpb25zICkge1xyXG5cclxuXHRpZiAoIHR5cGVvZiggc2hhcGVzICkgPT09IFwidW5kZWZpbmVkXCIgKSB7XHJcblx0XHRzaGFwZXMgPSBbXTtcclxuXHRcdHJldHVybjtcclxuXHR9XHJcblxyXG5cdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcblx0c2hhcGVzID0gc2hhcGVzIGluc3RhbmNlb2YgQXJyYXkgPyBzaGFwZXMgOiBbIHNoYXBlcyBdO1xyXG5cclxuXHR0aGlzLnNoYXBlYmIgPSBzaGFwZXNbIHNoYXBlcy5sZW5ndGggLSAxIF0uZ2V0Qm91bmRpbmdCb3goKTtcclxuXHJcblx0dGhpcy5hZGRTaGFwZUxpc3QoIHNoYXBlcywgb3B0aW9ucyApO1xyXG5cclxuXHR0aGlzLmNvbXB1dGVDZW50cm9pZHMoKTtcclxuXHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG5cclxuXHQvLyBjYW4ndCByZWFsbHkgdXNlIGF1dG9tYXRpYyB2ZXJ0ZXggbm9ybWFsc1xyXG5cdC8vIGFzIHRoZW4gZnJvbnQgYW5kIGJhY2sgc2lkZXMgZ2V0IHNtb290aGVkIHRvb1xyXG5cdC8vIHNob3VsZCBkbyBzZXBhcmF0ZSBzbW9vdGhpbmcganVzdCBmb3Igc2lkZXNcclxuXHJcblx0Ly90aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XHJcblxyXG5cdC8vY29uc29sZS5sb2coIFwidG9va1wiLCAoIERhdGUubm93KCkgLSBzdGFydFRpbWUgKSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5wcm90b3R5cGUuYWRkU2hhcGVMaXN0ID0gZnVuY3Rpb24gKCBzaGFwZXMsIG9wdGlvbnMgKSB7XHJcblx0dmFyIHNsID0gc2hhcGVzLmxlbmd0aDtcclxuXHJcblx0Zm9yICggdmFyIHMgPSAwOyBzIDwgc2w7IHMgKysgKSB7XHJcblx0XHR2YXIgc2hhcGUgPSBzaGFwZXNbIHMgXTtcclxuXHRcdHRoaXMuYWRkU2hhcGUoIHNoYXBlLCBvcHRpb25zICk7XHJcblx0fVxyXG59O1xyXG5cclxuVEhSRUUuRXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZS5hZGRTaGFwZSA9IGZ1bmN0aW9uICggc2hhcGUsIG9wdGlvbnMgKSB7XHJcblxyXG5cdHZhciBhbW91bnQgPSBvcHRpb25zLmFtb3VudCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5hbW91bnQgOiAxMDA7XHJcblxyXG5cdHZhciBiZXZlbFRoaWNrbmVzcyA9IG9wdGlvbnMuYmV2ZWxUaGlja25lc3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxUaGlja25lc3MgOiA2OyAvLyAxMFxyXG5cdHZhciBiZXZlbFNpemUgPSBvcHRpb25zLmJldmVsU2l6ZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFNpemUgOiBiZXZlbFRoaWNrbmVzcyAtIDI7IC8vIDhcclxuXHR2YXIgYmV2ZWxTZWdtZW50cyA9IG9wdGlvbnMuYmV2ZWxTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFNlZ21lbnRzIDogMztcclxuXHJcblx0dmFyIGJldmVsRW5hYmxlZCA9IG9wdGlvbnMuYmV2ZWxFbmFibGVkICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsRW5hYmxlZCA6IHRydWU7IC8vIGZhbHNlXHJcblxyXG5cdHZhciBjdXJ2ZVNlZ21lbnRzID0gb3B0aW9ucy5jdXJ2ZVNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmN1cnZlU2VnbWVudHMgOiAxMjtcclxuXHJcblx0dmFyIHN0ZXBzID0gb3B0aW9ucy5zdGVwcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zdGVwcyA6IDE7XHJcblxyXG5cdHZhciBleHRydWRlUGF0aCA9IG9wdGlvbnMuZXh0cnVkZVBhdGg7XHJcblx0dmFyIGV4dHJ1ZGVQdHMsIGV4dHJ1ZGVCeVBhdGggPSBmYWxzZTtcclxuXHJcblx0dmFyIG1hdGVyaWFsID0gb3B0aW9ucy5tYXRlcmlhbDtcclxuXHR2YXIgZXh0cnVkZU1hdGVyaWFsID0gb3B0aW9ucy5leHRydWRlTWF0ZXJpYWw7XHJcblxyXG5cdC8vIFVzZSBkZWZhdWx0IFdvcmxkVVZHZW5lcmF0b3IgaWYgbm8gVVYgZ2VuZXJhdG9ycyBhcmUgc3BlY2lmaWVkLlxyXG5cdHZhciB1dmdlbiA9IG9wdGlvbnMuVVZHZW5lcmF0b3IgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuVVZHZW5lcmF0b3IgOiBUSFJFRS5FeHRydWRlR2VvbWV0cnkuV29ybGRVVkdlbmVyYXRvcjtcclxuXHJcblx0dmFyIHNoYXBlYmIgPSB0aGlzLnNoYXBlYmI7XHJcblx0Ly9zaGFwZWJiID0gc2hhcGUuZ2V0Qm91bmRpbmdCb3goKTtcclxuXHJcblxyXG5cclxuXHR2YXIgc3BsaW5lVHViZSwgYmlub3JtYWwsIG5vcm1hbCwgcG9zaXRpb24yO1xyXG5cdGlmICggZXh0cnVkZVBhdGggKSB7XHJcblxyXG5cdFx0ZXh0cnVkZVB0cyA9IGV4dHJ1ZGVQYXRoLmdldFNwYWNlZFBvaW50cyggc3RlcHMgKTtcclxuXHJcblx0XHRleHRydWRlQnlQYXRoID0gdHJ1ZTtcclxuXHRcdGJldmVsRW5hYmxlZCA9IGZhbHNlOyAvLyBiZXZlbHMgbm90IHN1cHBvcnRlZCBmb3IgcGF0aCBleHRydXNpb25cclxuXHJcblx0XHQvLyBTRVRVUCBUTkIgdmFyaWFibGVzXHJcblxyXG5cdFx0Ly8gUmV1c2UgVE5CIGZyb20gVHViZUdlb210cnkgZm9yIG5vdy5cclxuXHRcdC8vIFRPRE8xIC0gaGF2ZSBhIC5pc0Nsb3NlZCBpbiBzcGxpbmU/XHJcblxyXG5cdFx0c3BsaW5lVHViZSA9IG9wdGlvbnMuZnJhbWVzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmZyYW1lcyA6IG5ldyBUSFJFRS5UdWJlR2VvbWV0cnkuRnJlbmV0RnJhbWVzKGV4dHJ1ZGVQYXRoLCBzdGVwcywgZmFsc2UpO1xyXG5cclxuXHRcdC8vIGNvbnNvbGUubG9nKHNwbGluZVR1YmUsICdzcGxpbmVUdWJlJywgc3BsaW5lVHViZS5ub3JtYWxzLmxlbmd0aCwgJ3N0ZXBzJywgc3RlcHMsICdleHRydWRlUHRzJywgZXh0cnVkZVB0cy5sZW5ndGgpO1xyXG5cclxuXHRcdGJpbm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRwb3NpdGlvbjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIFNhZmVndWFyZHMgaWYgYmV2ZWxzIGFyZSBub3QgZW5hYmxlZFxyXG5cclxuXHRpZiAoICEgYmV2ZWxFbmFibGVkICkge1xyXG5cclxuXHRcdGJldmVsU2VnbWVudHMgPSAwO1xyXG5cdFx0YmV2ZWxUaGlja25lc3MgPSAwO1xyXG5cdFx0YmV2ZWxTaXplID0gMDtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBWYXJpYWJsZXMgaW5pdGFsaXphdGlvblxyXG5cclxuXHR2YXIgYWhvbGUsIGgsIGhsOyAvLyBsb29waW5nIG9mIGhvbGVzXHJcblx0dmFyIHNjb3BlID0gdGhpcztcclxuXHR2YXIgYmV2ZWxQb2ludHMgPSBbXTtcclxuXHJcblx0dmFyIHNoYXBlc09mZnNldCA9IHRoaXMudmVydGljZXMubGVuZ3RoO1xyXG5cclxuXHR2YXIgc2hhcGVQb2ludHMgPSBzaGFwZS5leHRyYWN0UG9pbnRzKCBjdXJ2ZVNlZ21lbnRzICk7XHJcblxyXG5cdHZhciB2ZXJ0aWNlcyA9IHNoYXBlUG9pbnRzLnNoYXBlO1xyXG5cdHZhciBob2xlcyA9IHNoYXBlUG9pbnRzLmhvbGVzO1xyXG5cclxuXHR2YXIgcmV2ZXJzZSA9ICFUSFJFRS5TaGFwZS5VdGlscy5pc0Nsb2NrV2lzZSggdmVydGljZXMgKSA7XHJcblxyXG5cdGlmICggcmV2ZXJzZSApIHtcclxuXHJcblx0XHR2ZXJ0aWNlcyA9IHZlcnRpY2VzLnJldmVyc2UoKTtcclxuXHJcblx0XHQvLyBNYXliZSB3ZSBzaG91bGQgYWxzbyBjaGVjayBpZiBob2xlcyBhcmUgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiwganVzdCB0byBiZSBzYWZlIC4uLlxyXG5cclxuXHRcdGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xyXG5cclxuXHRcdFx0YWhvbGUgPSBob2xlc1sgaCBdO1xyXG5cclxuXHRcdFx0aWYgKCBUSFJFRS5TaGFwZS5VdGlscy5pc0Nsb2NrV2lzZSggYWhvbGUgKSApIHtcclxuXHJcblx0XHRcdFx0aG9sZXNbIGggXSA9IGFob2xlLnJldmVyc2UoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV2ZXJzZSA9IGZhbHNlOyAvLyBJZiB2ZXJ0aWNlcyBhcmUgaW4gb3JkZXIgbm93LCB3ZSBzaG91bGRuJ3QgbmVlZCB0byB3b3JyeSBhYm91dCB0aGVtIGFnYWluIChob3BlZnVsbHkpIVxyXG5cclxuXHR9XHJcblxyXG5cclxuXHR2YXIgZmFjZXMgPSBUSFJFRS5TaGFwZS5VdGlscy50cmlhbmd1bGF0ZVNoYXBlICggdmVydGljZXMsIGhvbGVzICk7XHJcblxyXG5cdC8qIFZlcnRpY2VzICovXHJcblxyXG5cdHZhciBjb250b3VyID0gdmVydGljZXM7IC8vIHZlcnRpY2VzIGhhcyBhbGwgcG9pbnRzIGJ1dCBjb250b3VyIGhhcyBvbmx5IHBvaW50cyBvZiBjaXJjdW1mZXJlbmNlXHJcblxyXG5cdGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgIGggPCBobDsgaCArKyApIHtcclxuXHJcblx0XHRhaG9sZSA9IGhvbGVzWyBoIF07XHJcblxyXG5cdFx0dmVydGljZXMgPSB2ZXJ0aWNlcy5jb25jYXQoIGFob2xlICk7XHJcblxyXG5cdH1cclxuXHJcblxyXG5cdGZ1bmN0aW9uIHNjYWxlUHQyICggcHQsIHZlYywgc2l6ZSApIHtcclxuXHJcblx0XHRpZiAoICF2ZWMgKSBjb25zb2xlLmxvZyggXCJkaWVcIiApO1xyXG5cclxuXHRcdHJldHVybiB2ZWMuY2xvbmUoKS5tdWx0aXBseVNjYWxhciggc2l6ZSApLmFkZCggcHQgKTtcclxuXHJcblx0fVxyXG5cclxuXHR2YXIgYiwgYnMsIHQsIHosXHJcblx0XHR2ZXJ0LCB2bGVuID0gdmVydGljZXMubGVuZ3RoLFxyXG5cdFx0ZmFjZSwgZmxlbiA9IGZhY2VzLmxlbmd0aCxcclxuXHRcdGNvbnQsIGNsZW4gPSBjb250b3VyLmxlbmd0aDtcclxuXHJcblxyXG5cdC8vIEZpbmQgZGlyZWN0aW9ucyBmb3IgcG9pbnQgbW92ZW1lbnRcclxuXHJcblx0dmFyIFJBRF9UT19ERUdSRUVTID0gMTgwIC8gTWF0aC5QSTtcclxuXHJcblxyXG5cdGZ1bmN0aW9uIGdldEJldmVsVmVjKCBwdF9pLCBwdF9qLCBwdF9rICkge1xyXG5cclxuXHRcdC8vIEFsZ29yaXRobSAyXHJcblxyXG5cdFx0cmV0dXJuIGdldEJldmVsVmVjMiggcHRfaSwgcHRfaiwgcHRfayApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdldEJldmVsVmVjMSggcHRfaSwgcHRfaiwgcHRfayApIHtcclxuXHJcblx0XHR2YXIgYW5nbGVhID0gTWF0aC5hdGFuMiggcHRfai55IC0gcHRfaS55LCBwdF9qLnggLSBwdF9pLnggKTtcclxuXHRcdHZhciBhbmdsZWIgPSBNYXRoLmF0YW4yKCBwdF9rLnkgLSBwdF9pLnksIHB0X2sueCAtIHB0X2kueCApO1xyXG5cclxuXHRcdGlmICggYW5nbGVhID4gYW5nbGViICkge1xyXG5cclxuXHRcdFx0YW5nbGViICs9IE1hdGguUEkgKiAyO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgYW5nbGVjID0gKCBhbmdsZWEgKyBhbmdsZWIgKSAvIDI7XHJcblxyXG5cclxuXHRcdC8vY29uc29sZS5sb2coJ2FuZ2xlMScsIGFuZ2xlYSAqIFJBRF9UT19ERUdSRUVTLCdhbmdsZTInLCBhbmdsZWIgKiBSQURfVE9fREVHUkVFUywgJ2FuZ2xlYycsIGFuZ2xlYyAqUkFEX1RPX0RFR1JFRVMpO1xyXG5cclxuXHRcdHZhciB4ID0gLSBNYXRoLmNvcyggYW5nbGVjICk7XHJcblx0XHR2YXIgeSA9IC0gTWF0aC5zaW4oIGFuZ2xlYyApO1xyXG5cclxuXHRcdHZhciB2ZWMgPSBuZXcgVEhSRUUuVmVjdG9yMiggeCwgeSApOyAvLy5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRyZXR1cm4gdmVjO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdldEJldmVsVmVjMiggcHRfaSwgcHRfaiwgcHRfayApIHtcclxuXHJcblx0XHR2YXIgYSA9IFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5fX3YxLFxyXG5cdFx0XHRiID0gVEhSRUUuRXh0cnVkZUdlb21ldHJ5Ll9fdjIsXHJcblx0XHRcdHZfaGF0ID0gVEhSRUUuRXh0cnVkZUdlb21ldHJ5Ll9fdjMsXHJcblx0XHRcdHdfaGF0ID0gVEhSRUUuRXh0cnVkZUdlb21ldHJ5Ll9fdjQsXHJcblx0XHRcdHAgPSBUSFJFRS5FeHRydWRlR2VvbWV0cnkuX192NSxcclxuXHRcdFx0cSA9IFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5fX3Y2LFxyXG5cdFx0XHR2LCB3LFxyXG5cdFx0XHR2X2RvdF93X2hhdCwgcV9zdWJfcF9kb3Rfd19oYXQsXHJcblx0XHRcdHMsIGludGVyc2VjdGlvbjtcclxuXHJcblx0XHQvLyBnb29kIHJlYWRpbmcgZm9yIGxpbmUtbGluZSBpbnRlcnNlY3Rpb25cclxuXHRcdC8vIGh0dHA6Ly9zcHV0c29mdC5jb20vYmxvZy8yMDEwLzAzL2xpbmUtbGluZS1pbnRlcnNlY3Rpb24uaHRtbFxyXG5cclxuXHRcdC8vIGRlZmluZSBhIGFzIHZlY3RvciBqLT5pXHJcblx0XHQvLyBkZWZpbmUgYiBhcyB2ZWN0b3Qgay0+aVxyXG5cclxuXHRcdGEuc2V0KCBwdF9pLnggLSBwdF9qLngsIHB0X2kueSAtIHB0X2oueSApO1xyXG5cdFx0Yi5zZXQoIHB0X2kueCAtIHB0X2sueCwgcHRfaS55IC0gcHRfay55ICk7XHJcblxyXG5cdFx0Ly8gZ2V0IHVuaXQgdmVjdG9yc1xyXG5cclxuXHRcdHYgPSBhLm5vcm1hbGl6ZSgpO1xyXG5cdFx0dyA9IGIubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0Ly8gbm9ybWFscyBmcm9tIHB0IGlcclxuXHJcblx0XHR2X2hhdC5zZXQoIC12LnksIHYueCApO1xyXG5cdFx0d19oYXQuc2V0KCB3LnksIC13LnggKTtcclxuXHJcblx0XHQvLyBwdHMgZnJvbSBpXHJcblxyXG5cdFx0cC5jb3B5KCBwdF9pICkuYWRkKCB2X2hhdCApO1xyXG5cdFx0cS5jb3B5KCBwdF9pICkuYWRkKCB3X2hhdCApO1xyXG5cclxuXHRcdGlmICggcC5lcXVhbHMoIHEgKSApIHtcclxuXHJcblx0XHRcdC8vY29uc29sZS5sb2coXCJXYXJuaW5nOiBsaW5lcyBhcmUgc3RyYWlnaHRcIik7XHJcblx0XHRcdHJldHVybiB3X2hhdC5jbG9uZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBQb2ludHMgZnJvbSBqLCBrLiBoZWxwcyBwcmV2ZW50cyBwb2ludHMgY3Jvc3Mgb3Zlcm92ZXIgbW9zdCBvZiB0aGUgdGltZVxyXG5cclxuXHRcdHAuY29weSggcHRfaiApLmFkZCggdl9oYXQgKTtcclxuXHRcdHEuY29weSggcHRfayApLmFkZCggd19oYXQgKTtcclxuXHJcblx0XHR2X2RvdF93X2hhdCA9IHYuZG90KCB3X2hhdCApO1xyXG5cdFx0cV9zdWJfcF9kb3Rfd19oYXQgPSBxLnN1YiggcCApLmRvdCggd19oYXQgKTtcclxuXHJcblx0XHQvLyBXZSBzaG91bGQgbm90IHJlYWNoIHRoZXNlIGNvbmRpdGlvbnNcclxuXHJcblx0XHRpZiAoIHZfZG90X3dfaGF0ID09PSAwICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5sb2coIFwiRWl0aGVyIGluZmluaXRlIG9yIG5vIHNvbHV0aW9ucyFcIiApO1xyXG5cclxuXHRcdFx0aWYgKCBxX3N1Yl9wX2RvdF93X2hhdCA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS5sb2coIFwiSXRzIGZpbml0ZSBzb2x1dGlvbnMuXCIgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUubG9nKCBcIlRvbyBiYWQsIG5vIHNvbHV0aW9ucy5cIiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRzID0gcV9zdWJfcF9kb3Rfd19oYXQgLyB2X2RvdF93X2hhdDtcclxuXHJcblx0XHRpZiAoIHMgPCAwICkge1xyXG5cclxuXHRcdFx0Ly8gaW4gY2FzZSBvZiBlbWVyZ2VjeSwgcmV2ZXJ0IHRvIGFsZ29yaXRobSAxLlxyXG5cclxuXHRcdFx0cmV0dXJuIGdldEJldmVsVmVjMSggcHRfaSwgcHRfaiwgcHRfayApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpbnRlcnNlY3Rpb24gPSB2Lm11bHRpcGx5U2NhbGFyKCBzICkuYWRkKCBwICk7XHJcblxyXG5cdFx0cmV0dXJuIGludGVyc2VjdGlvbi5zdWIoIHB0X2kgKS5jbG9uZSgpOyAvLyBEb24ndCBub3JtYWxpemUhLCBvdGhlcndpc2Ugc2hhcnAgY29ybmVycyBiZWNvbWUgdWdseVxyXG5cclxuXHR9XHJcblxyXG5cdHZhciBjb250b3VyTW92ZW1lbnRzID0gW107XHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgaWwgPSBjb250b3VyLmxlbmd0aCwgaiA9IGlsIC0gMSwgayA9IGkgKyAxOyBpIDwgaWw7IGkgKyssIGogKyssIGsgKysgKSB7XHJcblxyXG5cdFx0aWYgKCBqID09PSBpbCApIGogPSAwO1xyXG5cdFx0aWYgKCBrID09PSBpbCApIGsgPSAwO1xyXG5cclxuXHRcdC8vICAoaiktLS0oaSktLS0oaylcclxuXHRcdC8vIGNvbnNvbGUubG9nKCdpLGosaycsIGksIGogLCBrKVxyXG5cclxuXHRcdHZhciBwdF9pID0gY29udG91clsgaSBdO1xyXG5cdFx0dmFyIHB0X2ogPSBjb250b3VyWyBqIF07XHJcblx0XHR2YXIgcHRfayA9IGNvbnRvdXJbIGsgXTtcclxuXHJcblx0XHRjb250b3VyTW92ZW1lbnRzWyBpIF09IGdldEJldmVsVmVjKCBjb250b3VyWyBpIF0sIGNvbnRvdXJbIGogXSwgY29udG91clsgayBdICk7XHJcblxyXG5cdH1cclxuXHJcblx0dmFyIGhvbGVzTW92ZW1lbnRzID0gW10sIG9uZUhvbGVNb3ZlbWVudHMsIHZlcnRpY2VzTW92ZW1lbnRzID0gY29udG91ck1vdmVtZW50cy5jb25jYXQoKTtcclxuXHJcblx0Zm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XHJcblxyXG5cdFx0YWhvbGUgPSBob2xlc1sgaCBdO1xyXG5cclxuXHRcdG9uZUhvbGVNb3ZlbWVudHMgPSBbXTtcclxuXHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSBhaG9sZS5sZW5ndGgsIGogPSBpbCAtIDEsIGsgPSBpICsgMTsgaSA8IGlsOyBpICsrLCBqICsrLCBrICsrICkge1xyXG5cclxuXHRcdFx0aWYgKCBqID09PSBpbCApIGogPSAwO1xyXG5cdFx0XHRpZiAoIGsgPT09IGlsICkgayA9IDA7XHJcblxyXG5cdFx0XHQvLyAgKGopLS0tKGkpLS0tKGspXHJcblx0XHRcdG9uZUhvbGVNb3ZlbWVudHNbIGkgXT0gZ2V0QmV2ZWxWZWMoIGFob2xlWyBpIF0sIGFob2xlWyBqIF0sIGFob2xlWyBrIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aG9sZXNNb3ZlbWVudHMucHVzaCggb25lSG9sZU1vdmVtZW50cyApO1xyXG5cdFx0dmVydGljZXNNb3ZlbWVudHMgPSB2ZXJ0aWNlc01vdmVtZW50cy5jb25jYXQoIG9uZUhvbGVNb3ZlbWVudHMgKTtcclxuXHJcblx0fVxyXG5cclxuXHJcblx0Ly8gTG9vcCBiZXZlbFNlZ21lbnRzLCAxIGZvciB0aGUgZnJvbnQsIDEgZm9yIHRoZSBiYWNrXHJcblxyXG5cdGZvciAoIGIgPSAwOyBiIDwgYmV2ZWxTZWdtZW50czsgYiArKyApIHtcclxuXHQvL2ZvciAoIGIgPSBiZXZlbFNlZ21lbnRzOyBiID4gMDsgYiAtLSApIHtcclxuXHJcblx0XHR0ID0gYiAvIGJldmVsU2VnbWVudHM7XHJcblx0XHR6ID0gYmV2ZWxUaGlja25lc3MgKiAoIDEgLSB0ICk7XHJcblxyXG5cdFx0Ly96ID0gYmV2ZWxUaGlja25lc3MgKiB0O1xyXG5cdFx0YnMgPSBiZXZlbFNpemUgKiAoIE1hdGguc2luICggdCAqIE1hdGguUEkvMiApICkgOyAvLyBjdXJ2ZWRcclxuXHRcdC8vYnMgPSBiZXZlbFNpemUgKiB0IDsgLy8gbGluZWFyXHJcblxyXG5cdFx0Ly8gY29udHJhY3Qgc2hhcGVcclxuXHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSBjb250b3VyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmVydCA9IHNjYWxlUHQyKCBjb250b3VyWyBpIF0sIGNvbnRvdXJNb3ZlbWVudHNbIGkgXSwgYnMgKTtcclxuXHRcdFx0Ly92ZXJ0ID0gc2NhbGVQdCggY29udG91clsgaSBdLCBjb250b3VyQ2VudHJvaWQsIGJzLCBmYWxzZSApO1xyXG5cdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgIC0geiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBleHBhbmQgaG9sZXNcclxuXHJcblx0XHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCsrICkge1xyXG5cclxuXHRcdFx0YWhvbGUgPSBob2xlc1sgaCBdO1xyXG5cdFx0XHRvbmVIb2xlTW92ZW1lbnRzID0gaG9sZXNNb3ZlbWVudHNbIGggXTtcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IGFob2xlLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XHJcblxyXG5cdFx0XHRcdHZlcnQgPSBzY2FsZVB0MiggYWhvbGVbIGkgXSwgb25lSG9sZU1vdmVtZW50c1sgaSBdLCBicyApO1xyXG5cdFx0XHRcdC8vdmVydCA9IHNjYWxlUHQoIGFob2xlWyBpIF0sIGhvbGVzQ2VudHJvaWRzWyBoIF0sIGJzLCB0cnVlICk7XHJcblxyXG5cdFx0XHRcdHYoIHZlcnQueCwgdmVydC55LCAgLXogKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0YnMgPSBiZXZlbFNpemU7XHJcblxyXG5cdC8vIEJhY2sgZmFjaW5nIHZlcnRpY2VzXHJcblxyXG5cdGZvciAoIGkgPSAwOyBpIDwgdmxlbjsgaSArKyApIHtcclxuXHJcblx0XHR2ZXJ0ID0gYmV2ZWxFbmFibGVkID8gc2NhbGVQdDIoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzTW92ZW1lbnRzWyBpIF0sIGJzICkgOiB2ZXJ0aWNlc1sgaSBdO1xyXG5cclxuXHRcdGlmICggIWV4dHJ1ZGVCeVBhdGggKSB7XHJcblxyXG5cdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgMCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHQvLyB2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIDAgXS55LCBleHRydWRlUHRzWyAwIF0ueCApO1xyXG5cclxuXHRcdFx0bm9ybWFsLmNvcHkoIHNwbGluZVR1YmUubm9ybWFsc1swXSApLm11bHRpcGx5U2NhbGFyKHZlcnQueCk7XHJcblx0XHRcdGJpbm9ybWFsLmNvcHkoIHNwbGluZVR1YmUuYmlub3JtYWxzWzBdICkubXVsdGlwbHlTY2FsYXIodmVydC55KTtcclxuXHJcblx0XHRcdHBvc2l0aW9uMi5jb3B5KCBleHRydWRlUHRzWzBdICkuYWRkKG5vcm1hbCkuYWRkKGJpbm9ybWFsKTtcclxuXHJcblx0XHRcdHYoIHBvc2l0aW9uMi54LCBwb3NpdGlvbjIueSwgcG9zaXRpb24yLnogKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gQWRkIHN0ZXBwZWQgdmVydGljZXMuLi5cclxuXHQvLyBJbmNsdWRpbmcgZnJvbnQgZmFjaW5nIHZlcnRpY2VzXHJcblxyXG5cdHZhciBzO1xyXG5cclxuXHRmb3IgKCBzID0gMTsgcyA8PSBzdGVwczsgcyArKyApIHtcclxuXHJcblx0XHRmb3IgKCBpID0gMDsgaSA8IHZsZW47IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2ZXJ0ID0gYmV2ZWxFbmFibGVkID8gc2NhbGVQdDIoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzTW92ZW1lbnRzWyBpIF0sIGJzICkgOiB2ZXJ0aWNlc1sgaSBdO1xyXG5cclxuXHRcdFx0aWYgKCAhZXh0cnVkZUJ5UGF0aCApIHtcclxuXHJcblx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnksIGFtb3VudCAvIHN0ZXBzICogcyApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ly8gdiggdmVydC54LCB2ZXJ0LnkgKyBleHRydWRlUHRzWyBzIC0gMSBdLnksIGV4dHJ1ZGVQdHNbIHMgLSAxIF0ueCApO1xyXG5cclxuXHRcdFx0XHRub3JtYWwuY29weSggc3BsaW5lVHViZS5ub3JtYWxzW3NdICkubXVsdGlwbHlTY2FsYXIoIHZlcnQueCApO1xyXG5cdFx0XHRcdGJpbm9ybWFsLmNvcHkoIHNwbGluZVR1YmUuYmlub3JtYWxzW3NdICkubXVsdGlwbHlTY2FsYXIoIHZlcnQueSApO1xyXG5cclxuXHRcdFx0XHRwb3NpdGlvbjIuY29weSggZXh0cnVkZVB0c1tzXSApLmFkZCggbm9ybWFsICkuYWRkKCBiaW5vcm1hbCApO1xyXG5cclxuXHRcdFx0XHR2KCBwb3NpdGlvbjIueCwgcG9zaXRpb24yLnksIHBvc2l0aW9uMi56ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cclxuXHQvLyBBZGQgYmV2ZWwgc2VnbWVudHMgcGxhbmVzXHJcblxyXG5cdC8vZm9yICggYiA9IDE7IGIgPD0gYmV2ZWxTZWdtZW50czsgYiArKyApIHtcclxuXHRmb3IgKCBiID0gYmV2ZWxTZWdtZW50cyAtIDE7IGIgPj0gMDsgYiAtLSApIHtcclxuXHJcblx0XHR0ID0gYiAvIGJldmVsU2VnbWVudHM7XHJcblx0XHR6ID0gYmV2ZWxUaGlja25lc3MgKiAoIDEgLSB0ICk7XHJcblx0XHQvL2JzID0gYmV2ZWxTaXplICogKCAxLU1hdGguc2luICggKCAxIC0gdCApICogTWF0aC5QSS8yICkgKTtcclxuXHRcdGJzID0gYmV2ZWxTaXplICogTWF0aC5zaW4gKCB0ICogTWF0aC5QSS8yICkgO1xyXG5cclxuXHRcdC8vIGNvbnRyYWN0IHNoYXBlXHJcblxyXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gY29udG91ci5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZlcnQgPSBzY2FsZVB0MiggY29udG91clsgaSBdLCBjb250b3VyTW92ZW1lbnRzWyBpIF0sIGJzICk7XHJcblx0XHRcdHYoIHZlcnQueCwgdmVydC55LCAgYW1vdW50ICsgeiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBleHBhbmQgaG9sZXNcclxuXHJcblx0XHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcclxuXHJcblx0XHRcdGFob2xlID0gaG9sZXNbIGggXTtcclxuXHRcdFx0b25lSG9sZU1vdmVtZW50cyA9IGhvbGVzTW92ZW1lbnRzWyBoIF07XHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMCwgaWwgPSBhaG9sZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dmVydCA9IHNjYWxlUHQyKCBhaG9sZVsgaSBdLCBvbmVIb2xlTW92ZW1lbnRzWyBpIF0sIGJzICk7XHJcblxyXG5cdFx0XHRcdGlmICggIWV4dHJ1ZGVCeVBhdGggKSB7XHJcblxyXG5cdFx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnksICBhbW91bnQgKyB6ICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnkgKyBleHRydWRlUHRzWyBzdGVwcyAtIDEgXS55LCBleHRydWRlUHRzWyBzdGVwcyAtIDEgXS54ICsgeiApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8qIEZhY2VzICovXHJcblxyXG5cdC8vIFRvcCBhbmQgYm90dG9tIGZhY2VzXHJcblxyXG5cdGJ1aWxkTGlkRmFjZXMoKTtcclxuXHJcblx0Ly8gU2lkZXMgZmFjZXNcclxuXHJcblx0YnVpbGRTaWRlRmFjZXMoKTtcclxuXHJcblxyXG5cdC8vLy8vICBJbnRlcm5hbCBmdW5jdGlvbnNcclxuXHJcblx0ZnVuY3Rpb24gYnVpbGRMaWRGYWNlcygpIHtcclxuXHJcblx0XHRpZiAoIGJldmVsRW5hYmxlZCApIHtcclxuXHJcblx0XHRcdHZhciBsYXllciA9IDAgOyAvLyBzdGVwcyArIDFcclxuXHRcdFx0dmFyIG9mZnNldCA9IHZsZW4gKiBsYXllcjtcclxuXHJcblx0XHRcdC8vIEJvdHRvbSBmYWNlc1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRmYWNlID0gZmFjZXNbIGkgXTtcclxuXHRcdFx0XHRmMyggZmFjZVsgMiBdKyBvZmZzZXQsIGZhY2VbIDEgXSsgb2Zmc2V0LCBmYWNlWyAwIF0gKyBvZmZzZXQsIHRydWUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxheWVyID0gc3RlcHMgKyBiZXZlbFNlZ21lbnRzICogMjtcclxuXHRcdFx0b2Zmc2V0ID0gdmxlbiAqIGxheWVyO1xyXG5cclxuXHRcdFx0Ly8gVG9wIGZhY2VzXHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2UgPSBmYWNlc1sgaSBdO1xyXG5cdFx0XHRcdGYzKCBmYWNlWyAwIF0gKyBvZmZzZXQsIGZhY2VbIDEgXSArIG9mZnNldCwgZmFjZVsgMiBdICsgb2Zmc2V0LCBmYWxzZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHQvLyBCb3R0b20gZmFjZXNcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZmxlbjsgaSsrICkge1xyXG5cclxuXHRcdFx0XHRmYWNlID0gZmFjZXNbIGkgXTtcclxuXHRcdFx0XHRmMyggZmFjZVsgMiBdLCBmYWNlWyAxIF0sIGZhY2VbIDAgXSwgdHJ1ZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gVG9wIGZhY2VzXHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2UgPSBmYWNlc1sgaSBdO1xyXG5cdFx0XHRcdGYzKCBmYWNlWyAwIF0gKyB2bGVuICogc3RlcHMsIGZhY2VbIDEgXSArIHZsZW4gKiBzdGVwcywgZmFjZVsgMiBdICsgdmxlbiAqIHN0ZXBzLCBmYWxzZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8vIENyZWF0ZSBmYWNlcyBmb3IgdGhlIHotc2lkZXMgb2YgdGhlIHNoYXBlXHJcblxyXG5cdGZ1bmN0aW9uIGJ1aWxkU2lkZUZhY2VzKCkge1xyXG5cclxuXHRcdHZhciBsYXllcm9mZnNldCA9IDA7XHJcblx0XHRzaWRld2FsbHMoIGNvbnRvdXIsIGxheWVyb2Zmc2V0ICk7XHJcblx0XHRsYXllcm9mZnNldCArPSBjb250b3VyLmxlbmd0aDtcclxuXHJcblx0XHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7ICBoIDwgaGw7IGggKysgKSB7XHJcblxyXG5cdFx0XHRhaG9sZSA9IGhvbGVzWyBoIF07XHJcblx0XHRcdHNpZGV3YWxscyggYWhvbGUsIGxheWVyb2Zmc2V0ICk7XHJcblxyXG5cdFx0XHQvLywgdHJ1ZVxyXG5cdFx0XHRsYXllcm9mZnNldCArPSBhaG9sZS5sZW5ndGg7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHNpZGV3YWxscyggY29udG91ciwgbGF5ZXJvZmZzZXQgKSB7XHJcblxyXG5cdFx0dmFyIGosIGs7XHJcblx0XHRpID0gY29udG91ci5sZW5ndGg7XHJcblxyXG5cdFx0d2hpbGUgKCAtLWkgPj0gMCApIHtcclxuXHJcblx0XHRcdGogPSBpO1xyXG5cdFx0XHRrID0gaSAtIDE7XHJcblx0XHRcdGlmICggayA8IDAgKSBrID0gY29udG91ci5sZW5ndGggLSAxO1xyXG5cclxuXHRcdFx0Ly9jb25zb2xlLmxvZygnYicsIGksaiwgaS0xLCBrLHZlcnRpY2VzLmxlbmd0aCk7XHJcblxyXG5cdFx0XHR2YXIgcyA9IDAsIHNsID0gc3RlcHMgICsgYmV2ZWxTZWdtZW50cyAqIDI7XHJcblxyXG5cdFx0XHRmb3IgKCBzID0gMDsgcyA8IHNsOyBzICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgc2xlbjEgPSB2bGVuICogcztcclxuXHRcdFx0XHR2YXIgc2xlbjIgPSB2bGVuICogKCBzICsgMSApO1xyXG5cclxuXHRcdFx0XHR2YXIgYSA9IGxheWVyb2Zmc2V0ICsgaiArIHNsZW4xLFxyXG5cdFx0XHRcdFx0YiA9IGxheWVyb2Zmc2V0ICsgayArIHNsZW4xLFxyXG5cdFx0XHRcdFx0YyA9IGxheWVyb2Zmc2V0ICsgayArIHNsZW4yLFxyXG5cdFx0XHRcdFx0ZCA9IGxheWVyb2Zmc2V0ICsgaiArIHNsZW4yO1xyXG5cclxuXHRcdFx0XHRmNCggYSwgYiwgYywgZCwgY29udG91ciwgcywgc2wsIGosIGsgKTtcclxuXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHJcblx0ZnVuY3Rpb24gdiggeCwgeSwgeiApIHtcclxuXHJcblx0XHRzY29wZS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggeCwgeSwgeiApICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZjMoIGEsIGIsIGMsIGlzQm90dG9tICkge1xyXG5cclxuXHRcdGEgKz0gc2hhcGVzT2Zmc2V0O1xyXG5cdFx0YiArPSBzaGFwZXNPZmZzZXQ7XHJcblx0XHRjICs9IHNoYXBlc09mZnNldDtcclxuXHJcblx0XHQvLyBub3JtYWwsIGNvbG9yLCBtYXRlcmlhbFxyXG5cdFx0c2NvcGUuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBjLCBudWxsLCBudWxsLCBtYXRlcmlhbCApICk7XHJcblxyXG5cdFx0dmFyIHV2cyA9IGlzQm90dG9tID8gdXZnZW4uZ2VuZXJhdGVCb3R0b21VViggc2NvcGUsIHNoYXBlLCBvcHRpb25zLCBhLCBiLCBjICkgOiB1dmdlbi5nZW5lcmF0ZVRvcFVWKCBzY29wZSwgc2hhcGUsIG9wdGlvbnMsIGEsIGIsIGMgKTtcclxuXHJcbiBcdFx0c2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIHV2cyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGY0KCBhLCBiLCBjLCBkLCB3YWxsQ29udG91ciwgc3RlcEluZGV4LCBzdGVwc0xlbmd0aCwgY29udG91ckluZGV4MSwgY29udG91ckluZGV4MiApIHtcclxuXHJcblx0XHRhICs9IHNoYXBlc09mZnNldDtcclxuXHRcdGIgKz0gc2hhcGVzT2Zmc2V0O1xyXG5cdFx0YyArPSBzaGFwZXNPZmZzZXQ7XHJcblx0XHRkICs9IHNoYXBlc09mZnNldDtcclxuXHJcbiBcdFx0c2NvcGUuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2U0KCBhLCBiLCBjLCBkLCBudWxsLCBudWxsLCBleHRydWRlTWF0ZXJpYWwgKSApO1xyXG5cclxuIFx0XHR2YXIgdXZzID0gdXZnZW4uZ2VuZXJhdGVTaWRlV2FsbFVWKCBzY29wZSwgc2hhcGUsIHdhbGxDb250b3VyLCBvcHRpb25zLCBhLCBiLCBjLCBkLFxyXG4gXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXBJbmRleCwgc3RlcHNMZW5ndGgsIGNvbnRvdXJJbmRleDEsIGNvbnRvdXJJbmRleDIgKTtcclxuIFx0XHRzY29wZS5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggdXZzICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5FeHRydWRlR2VvbWV0cnkuV29ybGRVVkdlbmVyYXRvciA9IHtcclxuXHJcblx0Z2VuZXJhdGVUb3BVVjogZnVuY3Rpb24oIGdlb21ldHJ5LCBleHRydWRlZFNoYXBlLCBleHRydWRlT3B0aW9ucywgaW5kZXhBLCBpbmRleEIsIGluZGV4QyApIHtcclxuXHRcdHZhciBheCA9IGdlb21ldHJ5LnZlcnRpY2VzWyBpbmRleEEgXS54LFxyXG5cdFx0XHRheSA9IGdlb21ldHJ5LnZlcnRpY2VzWyBpbmRleEEgXS55LFxyXG5cclxuXHRcdFx0YnggPSBnZW9tZXRyeS52ZXJ0aWNlc1sgaW5kZXhCIF0ueCxcclxuXHRcdFx0YnkgPSBnZW9tZXRyeS52ZXJ0aWNlc1sgaW5kZXhCIF0ueSxcclxuXHJcblx0XHRcdGN4ID0gZ2VvbWV0cnkudmVydGljZXNbIGluZGV4QyBdLngsXHJcblx0XHRcdGN5ID0gZ2VvbWV0cnkudmVydGljZXNbIGluZGV4QyBdLnk7XHJcblxyXG5cdFx0cmV0dXJuIFtcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGF4LCBheSApLFxyXG5cdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYngsIGJ5ICksXHJcblx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBjeCwgY3kgKVxyXG5cdFx0XTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2VuZXJhdGVCb3R0b21VVjogZnVuY3Rpb24oIGdlb21ldHJ5LCBleHRydWRlZFNoYXBlLCBleHRydWRlT3B0aW9ucywgaW5kZXhBLCBpbmRleEIsIGluZGV4QyApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5nZW5lcmF0ZVRvcFVWKCBnZW9tZXRyeSwgZXh0cnVkZWRTaGFwZSwgZXh0cnVkZU9wdGlvbnMsIGluZGV4QSwgaW5kZXhCLCBpbmRleEMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2VuZXJhdGVTaWRlV2FsbFVWOiBmdW5jdGlvbiggZ2VvbWV0cnksIGV4dHJ1ZGVkU2hhcGUsIHdhbGxDb250b3VyLCBleHRydWRlT3B0aW9ucyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleEEsIGluZGV4QiwgaW5kZXhDLCBpbmRleEQsIHN0ZXBJbmRleCwgc3RlcHNMZW5ndGgsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udG91ckluZGV4MSwgY29udG91ckluZGV4MiApIHtcclxuXHJcblx0XHR2YXIgYXggPSBnZW9tZXRyeS52ZXJ0aWNlc1sgaW5kZXhBIF0ueCxcclxuXHRcdFx0YXkgPSBnZW9tZXRyeS52ZXJ0aWNlc1sgaW5kZXhBIF0ueSxcclxuXHRcdFx0YXogPSBnZW9tZXRyeS52ZXJ0aWNlc1sgaW5kZXhBIF0ueixcclxuXHJcblx0XHRcdGJ4ID0gZ2VvbWV0cnkudmVydGljZXNbIGluZGV4QiBdLngsXHJcblx0XHRcdGJ5ID0gZ2VvbWV0cnkudmVydGljZXNbIGluZGV4QiBdLnksXHJcblx0XHRcdGJ6ID0gZ2VvbWV0cnkudmVydGljZXNbIGluZGV4QiBdLnosXHJcblxyXG5cdFx0XHRjeCA9IGdlb21ldHJ5LnZlcnRpY2VzWyBpbmRleEMgXS54LFxyXG5cdFx0XHRjeSA9IGdlb21ldHJ5LnZlcnRpY2VzWyBpbmRleEMgXS55LFxyXG5cdFx0XHRjeiA9IGdlb21ldHJ5LnZlcnRpY2VzWyBpbmRleEMgXS56LFxyXG5cclxuXHRcdFx0ZHggPSBnZW9tZXRyeS52ZXJ0aWNlc1sgaW5kZXhEIF0ueCxcclxuXHRcdFx0ZHkgPSBnZW9tZXRyeS52ZXJ0aWNlc1sgaW5kZXhEIF0ueSxcclxuXHRcdFx0ZHogPSBnZW9tZXRyeS52ZXJ0aWNlc1sgaW5kZXhEIF0uejtcclxuXHJcblx0XHRpZiAoIE1hdGguYWJzKCBheSAtIGJ5ICkgPCAwLjAxICkge1xyXG5cdFx0XHRyZXR1cm4gW1xyXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBheCwgMSAtIGF6ICksXHJcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGJ4LCAxIC0gYnogKSxcclxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggY3gsIDEgLSBjeiApLFxyXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBkeCwgMSAtIGR6IClcclxuXHRcdFx0XTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiBbXHJcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGF5LCAxIC0gYXogKSxcclxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYnksIDEgLSBieiApLFxyXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBjeSwgMSAtIGN6ICksXHJcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGR5LCAxIC0gZHogKVxyXG5cdFx0XHRdO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXHJcblRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5fX3YxID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuVEhSRUUuRXh0cnVkZUdlb21ldHJ5Ll9fdjIgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG5USFJFRS5FeHRydWRlR2VvbWV0cnkuX192MyA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5fX3Y0ID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuVEhSRUUuRXh0cnVkZUdlb21ldHJ5Ll9fdjUgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG5USFJFRS5FeHRydWRlR2VvbWV0cnkuX192NiA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIGpvbm9icjEgLyBodHRwOi8vam9ub2JyMS5jb21cclxuICpcclxuICogQ3JlYXRlcyBhIG9uZS1zaWRlZCBwb2x5Z29uYWwgZ2VvbWV0cnkgZnJvbSBhIHBhdGggc2hhcGUuIFNpbWlsYXIgdG9cclxuICogRXh0cnVkZUdlb21ldHJ5LlxyXG4gKlxyXG4gKiBwYXJhbWV0ZXJzID0ge1xyXG4gKlxyXG4gKlx0Y3VydmVTZWdtZW50czogPGludD4sIC8vIG51bWJlciBvZiBwb2ludHMgb24gdGhlIGN1cnZlcy4gTk9UIFVTRUQgQVQgVEhFIE1PTUVOVC5cclxuICpcclxuICpcdG1hdGVyaWFsOiA8aW50PiAvLyBtYXRlcmlhbCBpbmRleCBmb3IgZnJvbnQgYW5kIGJhY2sgZmFjZXNcclxuICpcdHV2R2VuZXJhdG9yOiA8T2JqZWN0PiAvLyBvYmplY3QgdGhhdCBwcm92aWRlcyBVViBnZW5lcmF0b3IgZnVuY3Rpb25zXHJcbiAqXHJcbiAqIH1cclxuICoqL1xyXG5cclxuVEhSRUUuU2hhcGVHZW9tZXRyeSA9IGZ1bmN0aW9uICggc2hhcGVzLCBvcHRpb25zICkge1xyXG5cclxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdGlmICggc2hhcGVzIGluc3RhbmNlb2YgQXJyYXkgPT09IGZhbHNlICkgc2hhcGVzID0gWyBzaGFwZXMgXTtcclxuXHJcblx0dGhpcy5zaGFwZWJiID0gc2hhcGVzWyBzaGFwZXMubGVuZ3RoIC0gMSBdLmdldEJvdW5kaW5nQm94KCk7XHJcblxyXG5cdHRoaXMuYWRkU2hhcGVMaXN0KCBzaGFwZXMsIG9wdGlvbnMgKTtcclxuXHJcblx0dGhpcy5jb21wdXRlQ2VudHJvaWRzKCk7XHJcblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5TaGFwZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5cclxuLyoqXHJcbiAqIEFkZCBhbiBhcnJheSBvZiBzaGFwZXMgdG8gVEhSRUUuU2hhcGVHZW9tZXRyeS5cclxuICovXHJcblRIUkVFLlNoYXBlR2VvbWV0cnkucHJvdG90eXBlLmFkZFNoYXBlTGlzdCA9IGZ1bmN0aW9uICggc2hhcGVzLCBvcHRpb25zICkge1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBzaGFwZXMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xyXG5cclxuXHRcdHRoaXMuYWRkU2hhcGUoIHNoYXBlc1sgaSBdLCBvcHRpb25zICk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgYSBzaGFwZSB0byBUSFJFRS5TaGFwZUdlb21ldHJ5LCBiYXNlZCBvbiBUSFJFRS5FeHRydWRlR2VvbWV0cnkuXHJcbiAqL1xyXG5USFJFRS5TaGFwZUdlb21ldHJ5LnByb3RvdHlwZS5hZGRTaGFwZSA9IGZ1bmN0aW9uICggc2hhcGUsIG9wdGlvbnMgKSB7XHJcblxyXG5cdGlmICggb3B0aW9ucyA9PT0gdW5kZWZpbmVkICkgb3B0aW9ucyA9IHt9O1xyXG5cdHZhciBjdXJ2ZVNlZ21lbnRzID0gb3B0aW9ucy5jdXJ2ZVNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmN1cnZlU2VnbWVudHMgOiAxMjtcclxuXHJcblx0dmFyIG1hdGVyaWFsID0gb3B0aW9ucy5tYXRlcmlhbDtcclxuXHR2YXIgdXZnZW4gPSBvcHRpb25zLlVWR2VuZXJhdG9yID09PSB1bmRlZmluZWQgPyBUSFJFRS5FeHRydWRlR2VvbWV0cnkuV29ybGRVVkdlbmVyYXRvciA6IG9wdGlvbnMuVVZHZW5lcmF0b3I7XHJcblxyXG5cdHZhciBzaGFwZWJiID0gdGhpcy5zaGFwZWJiO1xyXG5cclxuXHQvL1xyXG5cclxuXHR2YXIgaSwgbCwgaG9sZSwgcztcclxuXHJcblx0dmFyIHNoYXBlc09mZnNldCA9IHRoaXMudmVydGljZXMubGVuZ3RoO1xyXG5cdHZhciBzaGFwZVBvaW50cyA9IHNoYXBlLmV4dHJhY3RQb2ludHMoIGN1cnZlU2VnbWVudHMgKTtcclxuXHJcblx0dmFyIHZlcnRpY2VzID0gc2hhcGVQb2ludHMuc2hhcGU7XHJcblx0dmFyIGhvbGVzID0gc2hhcGVQb2ludHMuaG9sZXM7XHJcblxyXG5cdHZhciByZXZlcnNlID0gIVRIUkVFLlNoYXBlLlV0aWxzLmlzQ2xvY2tXaXNlKCB2ZXJ0aWNlcyApO1xyXG5cclxuXHRpZiAoIHJldmVyc2UgKSB7XHJcblxyXG5cdFx0dmVydGljZXMgPSB2ZXJ0aWNlcy5yZXZlcnNlKCk7XHJcblxyXG5cdFx0Ly8gTWF5YmUgd2Ugc2hvdWxkIGFsc28gY2hlY2sgaWYgaG9sZXMgYXJlIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24sIGp1c3QgdG8gYmUgc2FmZS4uLlxyXG5cclxuXHRcdGZvciAoIGkgPSAwLCBsID0gaG9sZXMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xyXG5cclxuXHRcdFx0aG9sZSA9IGhvbGVzWyBpIF07XHJcblxyXG5cdFx0XHRpZiAoIFRIUkVFLlNoYXBlLlV0aWxzLmlzQ2xvY2tXaXNlKCBob2xlICkgKSB7XHJcblxyXG5cdFx0XHRcdGhvbGVzWyBpIF0gPSBob2xlLnJldmVyc2UoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV2ZXJzZSA9IGZhbHNlO1xyXG5cclxuXHR9XHJcblxyXG5cdHZhciBmYWNlcyA9IFRIUkVFLlNoYXBlLlV0aWxzLnRyaWFuZ3VsYXRlU2hhcGUoIHZlcnRpY2VzLCBob2xlcyApO1xyXG5cclxuXHQvLyBWZXJ0aWNlc1xyXG5cclxuXHR2YXIgY29udG91ciA9IHZlcnRpY2VzO1xyXG5cclxuXHRmb3IgKCBpID0gMCwgbCA9IGhvbGVzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcclxuXHJcblx0XHRob2xlID0gaG9sZXNbIGkgXTtcclxuXHRcdHZlcnRpY2VzID0gdmVydGljZXMuY29uY2F0KCBob2xlICk7XHJcblxyXG5cdH1cclxuXHJcblx0Ly9cclxuXHJcblx0dmFyIHZlcnQsIHZsZW4gPSB2ZXJ0aWNlcy5sZW5ndGg7XHJcblx0dmFyIGZhY2UsIGZsZW4gPSBmYWNlcy5sZW5ndGg7XHJcblx0dmFyIGNvbnQsIGNsZW4gPSBjb250b3VyLmxlbmd0aDtcclxuXHJcblx0Zm9yICggaSA9IDA7IGkgPCB2bGVuOyBpKysgKSB7XHJcblxyXG5cdFx0dmVydCA9IHZlcnRpY2VzWyBpIF07XHJcblxyXG5cdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggdmVydC54LCB2ZXJ0LnksIDAgKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZvciAoIGkgPSAwOyBpIDwgZmxlbjsgaSsrICkge1xyXG5cclxuXHRcdGZhY2UgPSBmYWNlc1sgaSBdO1xyXG5cclxuXHRcdHZhciBhID0gZmFjZVsgMCBdICsgc2hhcGVzT2Zmc2V0O1xyXG5cdFx0dmFyIGIgPSBmYWNlWyAxIF0gKyBzaGFwZXNPZmZzZXQ7XHJcblx0XHR2YXIgYyA9IGZhY2VbIDIgXSArIHNoYXBlc09mZnNldDtcclxuXHJcblx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgYywgbnVsbCwgbnVsbCwgbWF0ZXJpYWwgKSApO1xyXG5cdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggdXZnZW4uZ2VuZXJhdGVCb3R0b21VViggdGhpcywgc2hhcGUsIG9wdGlvbnMsIGEsIGIsIGMgKSApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG4vKipcclxuICogQGF1dGhvciBhc3Ryb2R1ZCAvIGh0dHA6Ly9hc3Ryb2R1ZC5pc2dyZWF0Lm9yZy9cclxuICogQGF1dGhvciB6ejg1IC8gaHR0cHM6Ly9naXRodWIuY29tL3p6ODVcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXHJcbiAqL1xyXG5cclxuLy8gcG9pbnRzIC0gdG8gY3JlYXRlIGEgY2xvc2VkIHRvcnVzLCBvbmUgbXVzdCB1c2UgYSBzZXQgb2YgcG9pbnRzIFxyXG4vLyAgICBsaWtlIHNvOiBbIGEsIGIsIGMsIGQsIGEgXSwgc2VlIGZpcnN0IGlzIHRoZSBzYW1lIGFzIGxhc3QuXHJcbi8vIHNlZ21lbnRzIC0gdGhlIG51bWJlciBvZiBjaXJjdW1mZXJlbmNlIHNlZ21lbnRzIHRvIGNyZWF0ZVxyXG4vLyBwaGlTdGFydCAtIHRoZSBzdGFydGluZyByYWRpYW5cclxuLy8gcGhpTGVuZ3RoIC0gdGhlIHJhZGlhbiAoMCB0byAyKlBJKSByYW5nZSBvZiB0aGUgbGF0aGVkIHNlY3Rpb25cclxuLy8gICAgMipwaSBpcyBhIGNsb3NlZCBsYXRoZSwgbGVzcyB0aGFuIDJQSSBpcyBhIHBvcnRpb24uXHJcblRIUkVFLkxhdGhlR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHBvaW50cywgc2VnbWVudHMsIHBoaVN0YXJ0LCBwaGlMZW5ndGggKSB7XHJcblxyXG5cdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcblx0c2VnbWVudHMgPSBzZWdtZW50cyB8fCAxMjtcclxuXHRwaGlTdGFydCA9IHBoaVN0YXJ0IHx8IDA7XHJcblx0cGhpTGVuZ3RoID0gcGhpTGVuZ3RoIHx8IDIgKiBNYXRoLlBJO1xyXG5cclxuXHR2YXIgaW52ZXJzZVBvaW50TGVuZ3RoID0gMS4wIC8gKCBwb2ludHMubGVuZ3RoIC0gMSApO1xyXG5cdHZhciBpbnZlcnNlU2VnbWVudHMgPSAxLjAgLyBzZWdtZW50cztcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHNlZ21lbnRzOyBpIDw9IGlsOyBpICsrICkge1xyXG5cclxuXHRcdHZhciBwaGkgPSBwaGlTdGFydCArIGkgKiBpbnZlcnNlU2VnbWVudHMgKiBwaGlMZW5ndGg7XHJcblxyXG5cdFx0dmFyIGMgPSBNYXRoLmNvcyggcGhpICksXHJcblx0XHRcdHMgPSBNYXRoLnNpbiggcGhpICk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IHBvaW50cy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdHZhciBwdCA9IHBvaW50c1sgaiBdO1xyXG5cclxuXHRcdFx0dmFyIHZlcnRleCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0XHR2ZXJ0ZXgueCA9IGMgKiBwdC54IC0gcyAqIHB0Lnk7XHJcblx0XHRcdHZlcnRleC55ID0gcyAqIHB0LnggKyBjICogcHQueTtcclxuXHRcdFx0dmVydGV4LnogPSBwdC56O1xyXG5cclxuXHRcdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dmFyIG5wID0gcG9pbnRzLmxlbmd0aDtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHNlZ21lbnRzOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IHBvaW50cy5sZW5ndGggLSAxOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgYmFzZSA9IGogKyBucCAqIGk7XHJcblx0XHRcdHZhciBhID0gYmFzZTtcclxuXHRcdFx0dmFyIGIgPSBiYXNlICsgbnA7XHJcblx0XHRcdHZhciBjID0gYmFzZSArIDEgKyBucDtcclxuXHRcdFx0dmFyIGQgPSBiYXNlICsgMTtcclxuXHJcblx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2U0KCBhLCBiLCBjLCBkICkgKTtcclxuXHJcblx0XHRcdHZhciB1MCA9IGkgKiBpbnZlcnNlU2VnbWVudHM7XHJcblx0XHRcdHZhciB2MCA9IGogKiBpbnZlcnNlUG9pbnRMZW5ndGg7XHJcblx0XHRcdHZhciB1MSA9IHUwICsgaW52ZXJzZVNlZ21lbnRzO1xyXG5cdFx0XHR2YXIgdjEgPSB2MCArIGludmVyc2VQb2ludExlbmd0aDtcclxuXHJcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFtcclxuXHJcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIHUwLCB2MCApLCBcclxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggdTEsIHYwICksXHJcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIHUxLCB2MSApLFxyXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCB1MCwgdjEgKVxyXG5cclxuXHRcdFx0XSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLm1lcmdlVmVydGljZXMoKTtcclxuXHR0aGlzLmNvbXB1dGVDZW50cm9pZHMoKTtcclxuXHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG5cdHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5MYXRoZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogYmFzZWQgb24gaHR0cDovL3BhcGVydmlzaW9uM2QuZ29vZ2xlY29kZS5jb20vc3ZuL3RydW5rL2FzMy90cnVuay9zcmMvb3JnL3BhcGVydmlzaW9uM2Qvb2JqZWN0cy9wcmltaXRpdmVzL1BsYW5lLmFzXHJcbiAqL1xyXG5cclxuVEhSRUUuUGxhbmVHZW9tZXRyeSA9IGZ1bmN0aW9uICggd2lkdGgsIGhlaWdodCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMgKSB7XHJcblxyXG5cdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy53aWR0aCA9IHdpZHRoO1xyXG5cdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuXHR0aGlzLndpZHRoU2VnbWVudHMgPSB3aWR0aFNlZ21lbnRzIHx8IDE7XHJcblx0dGhpcy5oZWlnaHRTZWdtZW50cyA9IGhlaWdodFNlZ21lbnRzIHx8IDE7XHJcblxyXG5cdHZhciBpeCwgaXo7XHJcblx0dmFyIHdpZHRoX2hhbGYgPSB3aWR0aCAvIDI7XHJcblx0dmFyIGhlaWdodF9oYWxmID0gaGVpZ2h0IC8gMjtcclxuXHJcblx0dmFyIGdyaWRYID0gdGhpcy53aWR0aFNlZ21lbnRzO1xyXG5cdHZhciBncmlkWiA9IHRoaXMuaGVpZ2h0U2VnbWVudHM7XHJcblxyXG5cdHZhciBncmlkWDEgPSBncmlkWCArIDE7XHJcblx0dmFyIGdyaWRaMSA9IGdyaWRaICsgMTtcclxuXHJcblx0dmFyIHNlZ21lbnRfd2lkdGggPSB0aGlzLndpZHRoIC8gZ3JpZFg7XHJcblx0dmFyIHNlZ21lbnRfaGVpZ2h0ID0gdGhpcy5oZWlnaHQgLyBncmlkWjtcclxuXHJcblx0dmFyIG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAxICk7XHJcblxyXG5cdGZvciAoIGl6ID0gMDsgaXogPCBncmlkWjE7IGl6ICsrICkge1xyXG5cclxuXHRcdGZvciAoIGl4ID0gMDsgaXggPCBncmlkWDE7IGl4ICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHggPSBpeCAqIHNlZ21lbnRfd2lkdGggLSB3aWR0aF9oYWxmO1xyXG5cdFx0XHR2YXIgeSA9IGl6ICogc2VnbWVudF9oZWlnaHQgLSBoZWlnaHRfaGFsZjtcclxuXHJcblx0XHRcdHRoaXMudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIHgsIC0geSwgMCApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZvciAoIGl6ID0gMDsgaXogPCBncmlkWjsgaXogKysgKSB7XHJcblxyXG5cdFx0Zm9yICggaXggPSAwOyBpeCA8IGdyaWRYOyBpeCArKyApIHtcclxuXHJcblx0XHRcdHZhciBhID0gaXggKyBncmlkWDEgKiBpejtcclxuXHRcdFx0dmFyIGIgPSBpeCArIGdyaWRYMSAqICggaXogKyAxICk7XHJcblx0XHRcdHZhciBjID0gKCBpeCArIDEgKSArIGdyaWRYMSAqICggaXogKyAxICk7XHJcblx0XHRcdHZhciBkID0gKCBpeCArIDEgKSArIGdyaWRYMSAqIGl6O1xyXG5cclxuXHRcdFx0dmFyIGZhY2UgPSBuZXcgVEhSRUUuRmFjZTQoIGEsIGIsIGMsIGQgKTtcclxuXHRcdFx0ZmFjZS5ub3JtYWwuY29weSggbm9ybWFsICk7XHJcblx0XHRcdGZhY2UudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwuY2xvbmUoKSwgbm9ybWFsLmNsb25lKCksIG5vcm1hbC5jbG9uZSgpLCBub3JtYWwuY2xvbmUoKSApO1xyXG5cclxuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBmYWNlICk7XHJcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFtcclxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggaXggLyBncmlkWCwgMSAtIGl6IC8gZ3JpZFogKSxcclxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggaXggLyBncmlkWCwgMSAtICggaXogKyAxICkgLyBncmlkWiApLFxyXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCAoIGl4ICsgMSApIC8gZ3JpZFgsIDEgLSAoIGl6ICsgMSApIC8gZ3JpZFogKSxcclxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggKCBpeCArIDEgKSAvIGdyaWRYLCAxIC0gaXogLyBncmlkWiApXHJcblx0XHRcdF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5jb21wdXRlQ2VudHJvaWRzKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUGxhbmVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuU3BoZXJlR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIHBoaVN0YXJ0LCBwaGlMZW5ndGgsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xyXG5cclxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMucmFkaXVzID0gcmFkaXVzIHx8IDUwO1xyXG5cclxuXHR0aGlzLndpZHRoU2VnbWVudHMgPSBNYXRoLm1heCggMywgTWF0aC5mbG9vciggd2lkdGhTZWdtZW50cyApIHx8IDggKTtcclxuXHR0aGlzLmhlaWdodFNlZ21lbnRzID0gTWF0aC5tYXgoIDIsIE1hdGguZmxvb3IoIGhlaWdodFNlZ21lbnRzICkgfHwgNiApO1xyXG5cclxuXHRwaGlTdGFydCA9IHBoaVN0YXJ0ICE9PSB1bmRlZmluZWQgPyBwaGlTdGFydCA6IDA7XHJcblx0cGhpTGVuZ3RoID0gcGhpTGVuZ3RoICE9PSB1bmRlZmluZWQgPyBwaGlMZW5ndGggOiBNYXRoLlBJICogMjtcclxuXHJcblx0dGhldGFTdGFydCA9IHRoZXRhU3RhcnQgIT09IHVuZGVmaW5lZCA/IHRoZXRhU3RhcnQgOiAwO1xyXG5cdHRoZXRhTGVuZ3RoID0gdGhldGFMZW5ndGggIT09IHVuZGVmaW5lZCA/IHRoZXRhTGVuZ3RoIDogTWF0aC5QSTtcclxuXHJcblx0dmFyIHgsIHksIHZlcnRpY2VzID0gW10sIHV2cyA9IFtdO1xyXG5cclxuXHRmb3IgKCB5ID0gMDsgeSA8PSB0aGlzLmhlaWdodFNlZ21lbnRzOyB5ICsrICkge1xyXG5cclxuXHRcdHZhciB2ZXJ0aWNlc1JvdyA9IFtdO1xyXG5cdFx0dmFyIHV2c1JvdyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIHggPSAwOyB4IDw9IHRoaXMud2lkdGhTZWdtZW50czsgeCArKyApIHtcclxuXHJcblx0XHRcdHZhciB1ID0geCAvIHRoaXMud2lkdGhTZWdtZW50cztcclxuXHRcdFx0dmFyIHYgPSB5IC8gdGhpcy5oZWlnaHRTZWdtZW50cztcclxuXHJcblx0XHRcdHZhciB2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0XHR2ZXJ0ZXgueCA9IC0gdGhpcy5yYWRpdXMgKiBNYXRoLmNvcyggcGhpU3RhcnQgKyB1ICogcGhpTGVuZ3RoICkgKiBNYXRoLnNpbiggdGhldGFTdGFydCArIHYgKiB0aGV0YUxlbmd0aCApO1xyXG5cdFx0XHR2ZXJ0ZXgueSA9IHRoaXMucmFkaXVzICogTWF0aC5jb3MoIHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGggKTtcclxuXHRcdFx0dmVydGV4LnogPSB0aGlzLnJhZGl1cyAqIE1hdGguc2luKCBwaGlTdGFydCArIHUgKiBwaGlMZW5ndGggKSAqIE1hdGguc2luKCB0aGV0YVN0YXJ0ICsgdiAqIHRoZXRhTGVuZ3RoICk7XHJcblxyXG5cdFx0XHR0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xyXG5cclxuXHRcdFx0dmVydGljZXNSb3cucHVzaCggdGhpcy52ZXJ0aWNlcy5sZW5ndGggLSAxICk7XHJcblx0XHRcdHV2c1Jvdy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggdSwgMSAtIHYgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0aWNlc1JvdyApO1xyXG5cdFx0dXZzLnB1c2goIHV2c1JvdyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZvciAoIHkgPSAwOyB5IDwgdGhpcy5oZWlnaHRTZWdtZW50czsgeSArKyApIHtcclxuXHJcblx0XHRmb3IgKCB4ID0gMDsgeCA8IHRoaXMud2lkdGhTZWdtZW50czsgeCArKyApIHtcclxuXHJcblx0XHRcdHZhciB2MSA9IHZlcnRpY2VzWyB5IF1bIHggKyAxIF07XHJcblx0XHRcdHZhciB2MiA9IHZlcnRpY2VzWyB5IF1bIHggXTtcclxuXHRcdFx0dmFyIHYzID0gdmVydGljZXNbIHkgKyAxIF1bIHggXTtcclxuXHRcdFx0dmFyIHY0ID0gdmVydGljZXNbIHkgKyAxIF1bIHggKyAxIF07XHJcblxyXG5cdFx0XHR2YXIgbjEgPSB0aGlzLnZlcnRpY2VzWyB2MSBdLmNsb25lKCkubm9ybWFsaXplKCk7XHJcblx0XHRcdHZhciBuMiA9IHRoaXMudmVydGljZXNbIHYyIF0uY2xvbmUoKS5ub3JtYWxpemUoKTtcclxuXHRcdFx0dmFyIG4zID0gdGhpcy52ZXJ0aWNlc1sgdjMgXS5jbG9uZSgpLm5vcm1hbGl6ZSgpO1xyXG5cdFx0XHR2YXIgbjQgPSB0aGlzLnZlcnRpY2VzWyB2NCBdLmNsb25lKCkubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHR2YXIgdXYxID0gdXZzWyB5IF1bIHggKyAxIF0uY2xvbmUoKTtcclxuXHRcdFx0dmFyIHV2MiA9IHV2c1sgeSBdWyB4IF0uY2xvbmUoKTtcclxuXHRcdFx0dmFyIHV2MyA9IHV2c1sgeSArIDEgXVsgeCBdLmNsb25lKCk7XHJcblx0XHRcdHZhciB1djQgPSB1dnNbIHkgKyAxIF1bIHggKyAxIF0uY2xvbmUoKTtcclxuXHJcblx0XHRcdGlmICggTWF0aC5hYnMoIHRoaXMudmVydGljZXNbIHYxIF0ueSApID09PSB0aGlzLnJhZGl1cyApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYxLCB2MywgdjQsIFsgbjEsIG4zLCBuNCBdICkgKTtcclxuXHRcdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2MSwgdXYzLCB1djQgXSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggTWF0aC5hYnMoIHRoaXMudmVydGljZXNbIHYzIF0ueSApID09PSB0aGlzLnJhZGl1cyApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYxLCB2MiwgdjMsIFsgbjEsIG4yLCBuMyBdICkgKTtcclxuXHRcdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2MSwgdXYyLCB1djMgXSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTQoIHYxLCB2MiwgdjMsIHY0LCBbIG4xLCBuMiwgbjMsIG40IF0gKSApO1xyXG5cdFx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXYxLCB1djIsIHV2MywgdXY0IF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5jb21wdXRlQ2VudHJvaWRzKCk7XHJcblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHJcbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSggbmV3IFRIUkVFLlZlY3RvcjMoKSwgcmFkaXVzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU3BoZXJlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqXHJcbiAqIEZvciBjcmVhdGluZyAzRCB0ZXh0IGdlb21ldHJ5IGluIHRocmVlLmpzXHJcbiAqXHJcbiAqIFRleHQgPSAzRCBUZXh0XHJcbiAqXHJcbiAqIHBhcmFtZXRlcnMgPSB7XHJcbiAqICBzaXplOiBcdFx0XHQ8ZmxvYXQ+LCBcdC8vIHNpemUgb2YgdGhlIHRleHRcclxuICogIGhlaWdodDogXHRcdDxmbG9hdD4sIFx0Ly8gdGhpY2tuZXNzIHRvIGV4dHJ1ZGUgdGV4dFxyXG4gKiAgY3VydmVTZWdtZW50czogXHQ8aW50PixcdFx0Ly8gbnVtYmVyIG9mIHBvaW50cyBvbiB0aGUgY3VydmVzXHJcbiAqXHJcbiAqICBmb250OiBcdFx0XHQ8c3RyaW5nPixcdFx0Ly8gZm9udCBuYW1lXHJcbiAqICB3ZWlnaHQ6IFx0XHQ8c3RyaW5nPixcdFx0Ly8gZm9udCB3ZWlnaHQgKG5vcm1hbCwgYm9sZClcclxuICogIHN0eWxlOiBcdFx0XHQ8c3RyaW5nPixcdFx0Ly8gZm9udCBzdHlsZSAgKG5vcm1hbCwgaXRhbGljcylcclxuICpcclxuICogIGJldmVsRW5hYmxlZDpcdDxib29sPixcdFx0XHQvLyB0dXJuIG9uIGJldmVsXHJcbiAqICBiZXZlbFRoaWNrbmVzczogPGZsb2F0PiwgXHRcdC8vIGhvdyBkZWVwIGludG8gdGV4dCBiZXZlbCBnb2VzXHJcbiAqICBiZXZlbFNpemU6XHRcdDxmbG9hdD4sIFx0XHQvLyBob3cgZmFyIGZyb20gdGV4dCBvdXRsaW5lIGlzIGJldmVsXHJcbiAqICB9XHJcbiAqXHJcbiAqL1xyXG5cclxuLypcdFVzYWdlIEV4YW1wbGVzXHJcblxyXG5cdC8vIFRleHRHZW9tZXRyeSB3cmFwcGVyXHJcblxyXG5cdHZhciB0ZXh0M2QgPSBuZXcgVGV4dEdlb21ldHJ5KCB0ZXh0LCBvcHRpb25zICk7XHJcblxyXG5cdC8vIENvbXBsZXRlIG1hbm5lclxyXG5cclxuXHR2YXIgdGV4dFNoYXBlcyA9IFRIUkVFLkZvbnRVdGlscy5nZW5lcmF0ZVNoYXBlcyggdGV4dCwgb3B0aW9ucyApO1xyXG5cdHZhciB0ZXh0M2QgPSBuZXcgRXh0cnVkZUdlb21ldHJ5KCB0ZXh0U2hhcGVzLCBvcHRpb25zICk7XHJcblxyXG4qL1xyXG5cclxuXHJcblRIUkVFLlRleHRHZW9tZXRyeSA9IGZ1bmN0aW9uICggdGV4dCwgcGFyYW1ldGVycyApIHtcclxuXHJcblx0dmFyIHRleHRTaGFwZXMgPSBUSFJFRS5Gb250VXRpbHMuZ2VuZXJhdGVTaGFwZXMoIHRleHQsIHBhcmFtZXRlcnMgKTtcclxuXHJcblx0Ly8gdHJhbnNsYXRlIHBhcmFtZXRlcnMgdG8gRXh0cnVkZUdlb21ldHJ5IEFQSVxyXG5cclxuXHRwYXJhbWV0ZXJzLmFtb3VudCA9IHBhcmFtZXRlcnMuaGVpZ2h0ICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmhlaWdodCA6IDUwO1xyXG5cclxuXHQvLyBkZWZhdWx0c1xyXG5cclxuXHRpZiAoIHBhcmFtZXRlcnMuYmV2ZWxUaGlja25lc3MgPT09IHVuZGVmaW5lZCApIHBhcmFtZXRlcnMuYmV2ZWxUaGlja25lc3MgPSAxMDtcclxuXHRpZiAoIHBhcmFtZXRlcnMuYmV2ZWxTaXplID09PSB1bmRlZmluZWQgKSBwYXJhbWV0ZXJzLmJldmVsU2l6ZSA9IDg7XHJcblx0aWYgKCBwYXJhbWV0ZXJzLmJldmVsRW5hYmxlZCA9PT0gdW5kZWZpbmVkICkgcGFyYW1ldGVycy5iZXZlbEVuYWJsZWQgPSBmYWxzZTtcclxuXHJcblx0VEhSRUUuRXh0cnVkZUdlb21ldHJ5LmNhbGwoIHRoaXMsIHRleHRTaGFwZXMsIHBhcmFtZXRlcnMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5UZXh0R2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuRXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG4vKipcclxuICogQGF1dGhvciBvb3Ntb3hpZWNvZGVcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogYmFzZWQgb24gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2F3YXkzZC9zb3VyY2UvYnJvd3NlL3RydW5rL2ZwMTAvQXdheTNETGl0ZS9zcmMvYXdheTNkbGl0ZS9wcmltaXRpdmVzL1RvcnVzLmFzP3I9Mjg4OFxyXG4gKi9cclxuXHJcblRIUkVFLlRvcnVzR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgdHViZSwgcmFkaWFsU2VnbWVudHMsIHR1YnVsYXJTZWdtZW50cywgYXJjICkge1xyXG5cclxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdHRoaXMucmFkaXVzID0gcmFkaXVzIHx8IDEwMDtcclxuXHR0aGlzLnR1YmUgPSB0dWJlIHx8IDQwO1xyXG5cdHRoaXMucmFkaWFsU2VnbWVudHMgPSByYWRpYWxTZWdtZW50cyB8fCA4O1xyXG5cdHRoaXMudHVidWxhclNlZ21lbnRzID0gdHVidWxhclNlZ21lbnRzIHx8IDY7XHJcblx0dGhpcy5hcmMgPSBhcmMgfHwgTWF0aC5QSSAqIDI7XHJcblxyXG5cdHZhciBjZW50ZXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpLCB1dnMgPSBbXSwgbm9ybWFscyA9IFtdO1xyXG5cclxuXHRmb3IgKCB2YXIgaiA9IDA7IGogPD0gdGhpcy5yYWRpYWxTZWdtZW50czsgaiArKyApIHtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPD0gdGhpcy50dWJ1bGFyU2VnbWVudHM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgdSA9IGkgLyB0aGlzLnR1YnVsYXJTZWdtZW50cyAqIHRoaXMuYXJjO1xyXG5cdFx0XHR2YXIgdiA9IGogLyB0aGlzLnJhZGlhbFNlZ21lbnRzICogTWF0aC5QSSAqIDI7XHJcblxyXG5cdFx0XHRjZW50ZXIueCA9IHRoaXMucmFkaXVzICogTWF0aC5jb3MoIHUgKTtcclxuXHRcdFx0Y2VudGVyLnkgPSB0aGlzLnJhZGl1cyAqIE1hdGguc2luKCB1ICk7XHJcblxyXG5cdFx0XHR2YXIgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdFx0dmVydGV4LnggPSAoIHRoaXMucmFkaXVzICsgdGhpcy50dWJlICogTWF0aC5jb3MoIHYgKSApICogTWF0aC5jb3MoIHUgKTtcclxuXHRcdFx0dmVydGV4LnkgPSAoIHRoaXMucmFkaXVzICsgdGhpcy50dWJlICogTWF0aC5jb3MoIHYgKSApICogTWF0aC5zaW4oIHUgKTtcclxuXHRcdFx0dmVydGV4LnogPSB0aGlzLnR1YmUgKiBNYXRoLnNpbiggdiApO1xyXG5cclxuXHRcdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcclxuXHJcblx0XHRcdHV2cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggaSAvIHRoaXMudHVidWxhclNlZ21lbnRzLCBqIC8gdGhpcy5yYWRpYWxTZWdtZW50cyApICk7XHJcblx0XHRcdG5vcm1hbHMucHVzaCggdmVydGV4LmNsb25lKCkuc3ViKCBjZW50ZXIgKS5ub3JtYWxpemUoKSApO1xyXG5cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cclxuXHRmb3IgKCB2YXIgaiA9IDE7IGogPD0gdGhpcy5yYWRpYWxTZWdtZW50czsgaiArKyApIHtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDE7IGkgPD0gdGhpcy50dWJ1bGFyU2VnbWVudHM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgYSA9ICggdGhpcy50dWJ1bGFyU2VnbWVudHMgKyAxICkgKiBqICsgaSAtIDE7XHJcblx0XHRcdHZhciBiID0gKCB0aGlzLnR1YnVsYXJTZWdtZW50cyArIDEgKSAqICggaiAtIDEgKSArIGkgLSAxO1xyXG5cdFx0XHR2YXIgYyA9ICggdGhpcy50dWJ1bGFyU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyBpO1xyXG5cdFx0XHR2YXIgZCA9ICggdGhpcy50dWJ1bGFyU2VnbWVudHMgKyAxICkgKiBqICsgaTtcclxuXHJcblx0XHRcdHZhciBmYWNlID0gbmV3IFRIUkVFLkZhY2U0KCBhLCBiLCBjLCBkLCBbIG5vcm1hbHNbIGEgXSwgbm9ybWFsc1sgYiBdLCBub3JtYWxzWyBjIF0sIG5vcm1hbHNbIGQgXSBdICk7XHJcblx0XHRcdGZhY2Uubm9ybWFsLmFkZCggbm9ybWFsc1sgYSBdICk7XHJcblx0XHRcdGZhY2Uubm9ybWFsLmFkZCggbm9ybWFsc1sgYiBdICk7XHJcblx0XHRcdGZhY2Uubm9ybWFsLmFkZCggbm9ybWFsc1sgYyBdICk7XHJcblx0XHRcdGZhY2Uubm9ybWFsLmFkZCggbm9ybWFsc1sgZCBdICk7XHJcblx0XHRcdGZhY2Uubm9ybWFsLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBmYWNlICk7XHJcblxyXG5cdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2c1sgYSBdLmNsb25lKCksIHV2c1sgYiBdLmNsb25lKCksIHV2c1sgYyBdLmNsb25lKCksIHV2c1sgZCBdLmNsb25lKCkgXSApO1xyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMuY29tcHV0ZUNlbnRyb2lkcygpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlRvcnVzR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIG9vc21veGllY29kZVxyXG4gKiBiYXNlZCBvbiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvYXdheTNkL3NvdXJjZS9icm93c2UvdHJ1bmsvZnAxMC9Bd2F5M0Qvc3JjL2F3YXkzZC9wcmltaXRpdmVzL1RvcnVzS25vdC5hcz9zcGVjPXN2bjI0NzMmcj0yNDczXHJcbiAqL1xyXG5cclxuVEhSRUUuVG9ydXNLbm90R2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgdHViZSwgcmFkaWFsU2VnbWVudHMsIHR1YnVsYXJTZWdtZW50cywgcCwgcSwgaGVpZ2h0U2NhbGUgKSB7XHJcblxyXG5cdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dmFyIHNjb3BlID0gdGhpcztcclxuXHJcblx0dGhpcy5yYWRpdXMgPSByYWRpdXMgfHwgMTAwO1xyXG5cdHRoaXMudHViZSA9IHR1YmUgfHwgNDA7XHJcblx0dGhpcy5yYWRpYWxTZWdtZW50cyA9IHJhZGlhbFNlZ21lbnRzIHx8IDY0O1xyXG5cdHRoaXMudHVidWxhclNlZ21lbnRzID0gdHVidWxhclNlZ21lbnRzIHx8IDg7XHJcblx0dGhpcy5wID0gcCB8fCAyO1xyXG5cdHRoaXMucSA9IHEgfHwgMztcclxuXHR0aGlzLmhlaWdodFNjYWxlID0gaGVpZ2h0U2NhbGUgfHwgMTtcclxuXHR0aGlzLmdyaWQgPSBuZXcgQXJyYXkoIHRoaXMucmFkaWFsU2VnbWVudHMgKTtcclxuXHJcblx0dmFyIHRhbmcgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHZhciBuID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR2YXIgYml0YW4gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLnJhZGlhbFNlZ21lbnRzOyArKyBpICkge1xyXG5cclxuXHRcdHRoaXMuZ3JpZFsgaSBdID0gbmV3IEFycmF5KCB0aGlzLnR1YnVsYXJTZWdtZW50cyApO1xyXG5cclxuXHRcdGZvciAoIHZhciBqID0gMDsgaiA8IHRoaXMudHVidWxhclNlZ21lbnRzOyArKyBqICkge1xyXG5cclxuXHRcdFx0dmFyIHUgPSBpIC8gdGhpcy5yYWRpYWxTZWdtZW50cyAqIDIgKiB0aGlzLnAgKiBNYXRoLlBJO1xyXG5cdFx0XHR2YXIgdiA9IGogLyB0aGlzLnR1YnVsYXJTZWdtZW50cyAqIDIgKiBNYXRoLlBJO1xyXG5cdFx0XHR2YXIgcDEgPSBnZXRQb3MoIHUsIHYsIHRoaXMucSwgdGhpcy5wLCB0aGlzLnJhZGl1cywgdGhpcy5oZWlnaHRTY2FsZSApO1xyXG5cdFx0XHR2YXIgcDIgPSBnZXRQb3MoIHUgKyAwLjAxLCB2LCB0aGlzLnEsIHRoaXMucCwgdGhpcy5yYWRpdXMsIHRoaXMuaGVpZ2h0U2NhbGUgKTtcclxuXHRcdFx0dmFyIGN4LCBjeTtcclxuXHJcblx0XHRcdHRhbmcuc3ViVmVjdG9ycyggcDIsIHAxICk7XHJcblx0XHRcdG4uYWRkVmVjdG9ycyggcDIsIHAxICk7XHJcblxyXG5cdFx0XHRiaXRhbi5jcm9zc1ZlY3RvcnMoIHRhbmcsIG4gKTtcclxuXHRcdFx0bi5jcm9zc1ZlY3RvcnMoIGJpdGFuLCB0YW5nICk7XHJcblx0XHRcdGJpdGFuLm5vcm1hbGl6ZSgpO1xyXG5cdFx0XHRuLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0Y3ggPSAtIHRoaXMudHViZSAqIE1hdGguY29zKCB2ICk7IC8vIFRPRE86IEhhY2s6IE5lZ2F0aW5nIGl0IHNvIGl0IGZhY2VzIG91dHNpZGUuXHJcblx0XHRcdGN5ID0gdGhpcy50dWJlICogTWF0aC5zaW4oIHYgKTtcclxuXHJcblx0XHRcdHAxLnggKz0gY3ggKiBuLnggKyBjeSAqIGJpdGFuLng7XHJcblx0XHRcdHAxLnkgKz0gY3ggKiBuLnkgKyBjeSAqIGJpdGFuLnk7XHJcblx0XHRcdHAxLnogKz0gY3ggKiBuLnogKyBjeSAqIGJpdGFuLno7XHJcblxyXG5cdFx0XHR0aGlzLmdyaWRbIGkgXVsgaiBdID0gdmVydCggcDEueCwgcDEueSwgcDEueiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLnJhZGlhbFNlZ21lbnRzOyArKyBpICkge1xyXG5cclxuXHRcdGZvciAoIHZhciBqID0gMDsgaiA8IHRoaXMudHVidWxhclNlZ21lbnRzOyArKyBqICkge1xyXG5cclxuXHRcdFx0dmFyIGlwID0gKCBpICsgMSApICUgdGhpcy5yYWRpYWxTZWdtZW50cztcclxuXHRcdFx0dmFyIGpwID0gKCBqICsgMSApICUgdGhpcy50dWJ1bGFyU2VnbWVudHM7XHJcblxyXG5cdFx0XHR2YXIgYSA9IHRoaXMuZ3JpZFsgaSBdWyBqIF07XHJcblx0XHRcdHZhciBiID0gdGhpcy5ncmlkWyBpcCBdWyBqIF07XHJcblx0XHRcdHZhciBjID0gdGhpcy5ncmlkWyBpcCBdWyBqcCBdO1xyXG5cdFx0XHR2YXIgZCA9IHRoaXMuZ3JpZFsgaSBdWyBqcCBdO1xyXG5cclxuXHRcdFx0dmFyIHV2YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCBpIC8gdGhpcy5yYWRpYWxTZWdtZW50cywgaiAvIHRoaXMudHVidWxhclNlZ21lbnRzICk7XHJcblx0XHRcdHZhciB1dmIgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBpICsgMSApIC8gdGhpcy5yYWRpYWxTZWdtZW50cywgaiAvIHRoaXMudHVidWxhclNlZ21lbnRzICk7XHJcblx0XHRcdHZhciB1dmMgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBpICsgMSApIC8gdGhpcy5yYWRpYWxTZWdtZW50cywgKCBqICsgMSApIC8gdGhpcy50dWJ1bGFyU2VnbWVudHMgKTtcclxuXHRcdFx0dmFyIHV2ZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCBpIC8gdGhpcy5yYWRpYWxTZWdtZW50cywgKCBqICsgMSApIC8gdGhpcy50dWJ1bGFyU2VnbWVudHMgKTtcclxuXHJcblx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2U0KCBhLCBiLCBjLCBkICkgKTtcclxuXHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dmEsdXZiLHV2YywgdXZkIF0gKTtcclxuXHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHR0aGlzLmNvbXB1dGVDZW50cm9pZHMoKTtcclxuXHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG5cdHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcclxuXHJcblx0ZnVuY3Rpb24gdmVydCggeCwgeSwgeiApIHtcclxuXHJcblx0XHRyZXR1cm4gc2NvcGUudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIHgsIHksIHogKSApIC0gMTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZXRQb3MoIHUsIHYsIGluX3EsIGluX3AsIHJhZGl1cywgaGVpZ2h0U2NhbGUgKSB7XHJcblxyXG5cdFx0dmFyIGN1ID0gTWF0aC5jb3MoIHUgKTtcclxuXHRcdHZhciBjdiA9IE1hdGguY29zKCB2ICk7XHJcblx0XHR2YXIgc3UgPSBNYXRoLnNpbiggdSApO1xyXG5cdFx0dmFyIHF1T3ZlclAgPSBpbl9xIC8gaW5fcCAqIHU7XHJcblx0XHR2YXIgY3MgPSBNYXRoLmNvcyggcXVPdmVyUCApO1xyXG5cclxuXHRcdHZhciB0eCA9IHJhZGl1cyAqICggMiArIGNzICkgKiAwLjUgKiBjdTtcclxuXHRcdHZhciB0eSA9IHJhZGl1cyAqICggMiArIGNzICkgKiBzdSAqIDAuNTtcclxuXHRcdHZhciB0eiA9IGhlaWdodFNjYWxlICogcmFkaXVzICogTWF0aC5zaW4oIHF1T3ZlclAgKSAqIDAuNTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjMoIHR4LCB0eSwgdHogKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLlRvcnVzS25vdEdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG4vKipcclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwczovL2dpdGh1Yi5jb20veno4NVxyXG4gKiBAYXV0aG9yIG1pbmluZ29sZCAvIGh0dHBzOi8vZ2l0aHViLmNvbS9taW5pbmdvbGRcclxuICpcclxuICogTW9kaWZpZWQgZnJvbSB0aGUgVG9ydXNLbm90R2VvbWV0cnkgYnkgQG9vc21veGllY29kZVxyXG4gKlxyXG4gKiBDcmVhdGVzIGEgdHViZSB3aGljaCBleHRydWRlcyBhbG9uZyBhIDNkIHNwbGluZVxyXG4gKlxyXG4gKiBVc2VzIHBhcmFsbGVsIHRyYW5zcG9ydCBmcmFtZXMgYXMgZGVzY3JpYmVkIGluXHJcbiAqIGh0dHA6Ly93d3cuY3MuaW5kaWFuYS5lZHUvcHViL3RlY2hyZXBvcnRzL1RSNDI1LnBkZlxyXG4gKi9cclxuXHJcblRIUkVFLlR1YmVHZW9tZXRyeSA9IGZ1bmN0aW9uKCBwYXRoLCBzZWdtZW50cywgcmFkaXVzLCByYWRpdXNTZWdtZW50cywgY2xvc2VkLCBkZWJ1ZyApIHtcclxuXHJcblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnBhdGggPSBwYXRoO1xyXG5cdHRoaXMuc2VnbWVudHMgPSBzZWdtZW50cyB8fCA2NDtcclxuXHR0aGlzLnJhZGl1cyA9IHJhZGl1cyB8fCAxO1xyXG5cdHRoaXMucmFkaXVzU2VnbWVudHMgPSByYWRpdXNTZWdtZW50cyB8fCA4O1xyXG5cdHRoaXMuY2xvc2VkID0gY2xvc2VkIHx8IGZhbHNlO1xyXG5cclxuXHRpZiAoIGRlYnVnICkgdGhpcy5kZWJ1ZyA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xyXG5cclxuXHR0aGlzLmdyaWQgPSBbXTtcclxuXHJcblx0dmFyIHNjb3BlID0gdGhpcyxcclxuXHJcblx0XHR0YW5nZW50LFxyXG5cdFx0bm9ybWFsLFxyXG5cdFx0Ymlub3JtYWwsXHJcblxyXG5cdFx0bnVtcG9pbnRzID0gdGhpcy5zZWdtZW50cyArIDEsXHJcblxyXG5cdFx0eCwgeSwgeixcclxuXHRcdHR4LCB0eSwgdHosXHJcblx0XHR1LCB2LFxyXG5cclxuXHRcdGN4LCBjeSxcclxuXHRcdHBvcywgcG9zMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblx0XHRpLCBqLFxyXG5cdFx0aXAsIGpwLFxyXG5cdFx0YSwgYiwgYywgZCxcclxuXHRcdHV2YSwgdXZiLCB1dmMsIHV2ZDtcclxuXHJcblx0dmFyIGZyYW1lcyA9IG5ldyBUSFJFRS5UdWJlR2VvbWV0cnkuRnJlbmV0RnJhbWVzKCB0aGlzLnBhdGgsIHRoaXMuc2VnbWVudHMsIHRoaXMuY2xvc2VkICksXHJcblx0XHR0YW5nZW50cyA9IGZyYW1lcy50YW5nZW50cyxcclxuXHRcdG5vcm1hbHMgPSBmcmFtZXMubm9ybWFscyxcclxuXHRcdGJpbm9ybWFscyA9IGZyYW1lcy5iaW5vcm1hbHM7XHJcblxyXG5cdC8vIHByb3h5IGludGVybmFsc1xyXG5cdHRoaXMudGFuZ2VudHMgPSB0YW5nZW50cztcclxuXHR0aGlzLm5vcm1hbHMgPSBub3JtYWxzO1xyXG5cdHRoaXMuYmlub3JtYWxzID0gYmlub3JtYWxzO1xyXG5cclxuXHRmdW5jdGlvbiB2ZXJ0KCB4LCB5LCB6ICkge1xyXG5cclxuXHRcdHJldHVybiBzY29wZS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggeCwgeSwgeiApICkgLSAxO1xyXG5cclxuXHR9XHJcblxyXG5cclxuXHQvLyBjb25zcnVjdCB0aGUgZ3JpZFxyXG5cclxuXHRmb3IgKCBpID0gMDsgaSA8IG51bXBvaW50czsgaSsrICkge1xyXG5cclxuXHRcdHRoaXMuZ3JpZFsgaSBdID0gW107XHJcblxyXG5cdFx0dSA9IGkgLyAoIG51bXBvaW50cyAtIDEgKTtcclxuXHJcblx0XHRwb3MgPSBwYXRoLmdldFBvaW50QXQoIHUgKTtcclxuXHJcblx0XHR0YW5nZW50ID0gdGFuZ2VudHNbIGkgXTtcclxuXHRcdG5vcm1hbCA9IG5vcm1hbHNbIGkgXTtcclxuXHRcdGJpbm9ybWFsID0gYmlub3JtYWxzWyBpIF07XHJcblxyXG5cdFx0aWYgKCB0aGlzLmRlYnVnICkge1xyXG5cclxuXHRcdFx0dGhpcy5kZWJ1Zy5hZGQoIG5ldyBUSFJFRS5BcnJvd0hlbHBlcih0YW5nZW50LCBwb3MsIHJhZGl1cywgMHgwMDAwZmYgKSApO1xyXG5cdFx0XHR0aGlzLmRlYnVnLmFkZCggbmV3IFRIUkVFLkFycm93SGVscGVyKG5vcm1hbCwgcG9zLCByYWRpdXMsIDB4ZmYwMDAwICkgKTtcclxuXHRcdFx0dGhpcy5kZWJ1Zy5hZGQoIG5ldyBUSFJFRS5BcnJvd0hlbHBlcihiaW5vcm1hbCwgcG9zLCByYWRpdXMsIDB4MDBmZjAwICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggaiA9IDA7IGogPCB0aGlzLnJhZGl1c1NlZ21lbnRzOyBqKysgKSB7XHJcblxyXG5cdFx0XHR2ID0gaiAvIHRoaXMucmFkaXVzU2VnbWVudHMgKiAyICogTWF0aC5QSTtcclxuXHJcblx0XHRcdGN4ID0gLXRoaXMucmFkaXVzICogTWF0aC5jb3MoIHYgKTsgLy8gVE9ETzogSGFjazogTmVnYXRpbmcgaXQgc28gaXQgZmFjZXMgb3V0c2lkZS5cclxuXHRcdFx0Y3kgPSB0aGlzLnJhZGl1cyAqIE1hdGguc2luKCB2ICk7XHJcblxyXG5cdFx0XHRwb3MyLmNvcHkoIHBvcyApO1xyXG5cdFx0XHRwb3MyLnggKz0gY3ggKiBub3JtYWwueCArIGN5ICogYmlub3JtYWwueDtcclxuXHRcdFx0cG9zMi55ICs9IGN4ICogbm9ybWFsLnkgKyBjeSAqIGJpbm9ybWFsLnk7XHJcblx0XHRcdHBvczIueiArPSBjeCAqIG5vcm1hbC56ICsgY3kgKiBiaW5vcm1hbC56O1xyXG5cclxuXHRcdFx0dGhpcy5ncmlkWyBpIF1bIGogXSA9IHZlcnQoIHBvczIueCwgcG9zMi55LCBwb3MyLnogKTtcclxuXHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHJcblx0Ly8gY29uc3RydWN0IHRoZSBtZXNoXHJcblxyXG5cdGZvciAoIGkgPSAwOyBpIDwgdGhpcy5zZWdtZW50czsgaSsrICkge1xyXG5cclxuXHRcdGZvciAoIGogPSAwOyBqIDwgdGhpcy5yYWRpdXNTZWdtZW50czsgaisrICkge1xyXG5cclxuXHRcdFx0aXAgPSAoIHRoaXMuY2xvc2VkICkgPyAoaSArIDEpICUgdGhpcy5zZWdtZW50cyA6IGkgKyAxO1xyXG5cdFx0XHRqcCA9IChqICsgMSkgJSB0aGlzLnJhZGl1c1NlZ21lbnRzO1xyXG5cclxuXHRcdFx0YSA9IHRoaXMuZ3JpZFsgaSBdWyBqIF07XHRcdC8vICoqKiBOT1QgTkVDRVNTQVJJTFkgUExBTkFSICEgKioqXHJcblx0XHRcdGIgPSB0aGlzLmdyaWRbIGlwIF1bIGogXTtcclxuXHRcdFx0YyA9IHRoaXMuZ3JpZFsgaXAgXVsganAgXTtcclxuXHRcdFx0ZCA9IHRoaXMuZ3JpZFsgaSBdWyBqcCBdO1xyXG5cclxuXHRcdFx0dXZhID0gbmV3IFRIUkVFLlZlY3RvcjIoIGkgLyB0aGlzLnNlZ21lbnRzLCBqIC8gdGhpcy5yYWRpdXNTZWdtZW50cyApO1xyXG5cdFx0XHR1dmIgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBpICsgMSApIC8gdGhpcy5zZWdtZW50cywgaiAvIHRoaXMucmFkaXVzU2VnbWVudHMgKTtcclxuXHRcdFx0dXZjID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaSArIDEgKSAvIHRoaXMuc2VnbWVudHMsICggaiArIDEgKSAvIHRoaXMucmFkaXVzU2VnbWVudHMgKTtcclxuXHRcdFx0dXZkID0gbmV3IFRIUkVFLlZlY3RvcjIoIGkgLyB0aGlzLnNlZ21lbnRzLCAoIGogKyAxICkgLyB0aGlzLnJhZGl1c1NlZ21lbnRzICk7XHJcblxyXG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlNCggYSwgYiwgYywgZCApICk7XHJcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZhLCB1dmIsIHV2YywgdXZkIF0gKTtcclxuXHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHR0aGlzLmNvbXB1dGVDZW50cm9pZHMoKTtcclxuXHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG5cdHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5UdWJlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblxyXG5cclxuLy8gRm9yIGNvbXB1dGluZyBvZiBGcmVuZXQgZnJhbWVzLCBleHBvc2luZyB0aGUgdGFuZ2VudHMsIG5vcm1hbHMgYW5kIGJpbm9ybWFscyB0aGUgc3BsaW5lXHJcblRIUkVFLlR1YmVHZW9tZXRyeS5GcmVuZXRGcmFtZXMgPSBmdW5jdGlvbihwYXRoLCBzZWdtZW50cywgY2xvc2VkKSB7XHJcblxyXG5cdHZhclx0dGFuZ2VudCA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblx0XHRub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0Ymlub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cclxuXHRcdHRhbmdlbnRzID0gW10sXHJcblx0XHRub3JtYWxzID0gW10sXHJcblx0XHRiaW5vcm1hbHMgPSBbXSxcclxuXHJcblx0XHR2ZWMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0bWF0ID0gbmV3IFRIUkVFLk1hdHJpeDQoKSxcclxuXHJcblx0XHRudW1wb2ludHMgPSBzZWdtZW50cyArIDEsXHJcblx0XHR0aGV0YSxcclxuXHRcdGVwc2lsb24gPSAwLjAwMDEsXHJcblx0XHRzbWFsbGVzdCxcclxuXHJcblx0XHR0eCwgdHksIHR6LFxyXG5cdFx0aSwgdSwgdjtcclxuXHJcblxyXG5cdC8vIGV4cG9zZSBpbnRlcm5hbHNcclxuXHR0aGlzLnRhbmdlbnRzID0gdGFuZ2VudHM7XHJcblx0dGhpcy5ub3JtYWxzID0gbm9ybWFscztcclxuXHR0aGlzLmJpbm9ybWFscyA9IGJpbm9ybWFscztcclxuXHJcblx0Ly8gY29tcHV0ZSB0aGUgdGFuZ2VudCB2ZWN0b3JzIGZvciBlYWNoIHNlZ21lbnQgb24gdGhlIHBhdGhcclxuXHJcblx0Zm9yICggaSA9IDA7IGkgPCBudW1wb2ludHM7IGkrKyApIHtcclxuXHJcblx0XHR1ID0gaSAvICggbnVtcG9pbnRzIC0gMSApO1xyXG5cclxuXHRcdHRhbmdlbnRzWyBpIF0gPSBwYXRoLmdldFRhbmdlbnRBdCggdSApO1xyXG5cdFx0dGFuZ2VudHNbIGkgXS5ub3JtYWxpemUoKTtcclxuXHJcblx0fVxyXG5cclxuXHRpbml0aWFsTm9ybWFsMygpO1xyXG5cclxuXHRmdW5jdGlvbiBpbml0aWFsTm9ybWFsMShsYXN0Qmlub3JtYWwpIHtcclxuXHRcdC8vIGZpeGVkIHN0YXJ0IGJpbm9ybWFsLiBIYXMgZGFuZ2VycyBvZiAwIHZlY3RvcnNcclxuXHRcdG5vcm1hbHNbIDAgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRiaW5vcm1hbHNbIDAgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRpZiAobGFzdEJpbm9ybWFsPT09dW5kZWZpbmVkKSBsYXN0Qmlub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMSApO1xyXG5cdFx0bm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggbGFzdEJpbm9ybWFsLCB0YW5nZW50c1sgMCBdICkubm9ybWFsaXplKCk7XHJcblx0XHRiaW5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyAwIF0sIG5vcm1hbHNbIDAgXSApLm5vcm1hbGl6ZSgpO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gaW5pdGlhbE5vcm1hbDIoKSB7XHJcblxyXG5cdFx0Ly8gVGhpcyB1c2VzIHRoZSBGcmVuZXQtU2VycmV0IGZvcm11bGEgZm9yIGRlcml2aW5nIGJpbm9ybWFsXHJcblx0XHR2YXIgdDIgPSBwYXRoLmdldFRhbmdlbnRBdCggZXBzaWxvbiApO1xyXG5cclxuXHRcdG5vcm1hbHNbIDAgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCkuc3ViVmVjdG9ycyggdDIsIHRhbmdlbnRzWyAwIF0gKS5ub3JtYWxpemUoKTtcclxuXHRcdGJpbm9ybWFsc1sgMCBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyAwIF0sIG5vcm1hbHNbIDAgXSApO1xyXG5cclxuXHRcdG5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIGJpbm9ybWFsc1sgMCBdLCB0YW5nZW50c1sgMCBdICkubm9ybWFsaXplKCk7IC8vIGxhc3QgYmlub3JtYWwgeCB0YW5nZW50XHJcblx0XHRiaW5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyAwIF0sIG5vcm1hbHNbIDAgXSApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGluaXRpYWxOb3JtYWwzKCkge1xyXG5cdFx0Ly8gc2VsZWN0IGFuIGluaXRpYWwgbm9ybWFsIHZlY3RvciBwZXJwZW5pY3VsYXIgdG8gdGhlIGZpcnN0IHRhbmdlbnQgdmVjdG9yLFxyXG5cdFx0Ly8gYW5kIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHNtYWxsZXN0IHRhbmdlbnQgeHl6IGNvbXBvbmVudFxyXG5cclxuXHRcdG5vcm1hbHNbIDAgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRiaW5vcm1hbHNbIDAgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRzbWFsbGVzdCA9IE51bWJlci5NQVhfVkFMVUU7XHJcblx0XHR0eCA9IE1hdGguYWJzKCB0YW5nZW50c1sgMCBdLnggKTtcclxuXHRcdHR5ID0gTWF0aC5hYnMoIHRhbmdlbnRzWyAwIF0ueSApO1xyXG5cdFx0dHogPSBNYXRoLmFicyggdGFuZ2VudHNbIDAgXS56ICk7XHJcblxyXG5cdFx0aWYgKCB0eCA8PSBzbWFsbGVzdCApIHtcclxuXHRcdFx0c21hbGxlc3QgPSB0eDtcclxuXHRcdFx0bm9ybWFsLnNldCggMSwgMCwgMCApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdHkgPD0gc21hbGxlc3QgKSB7XHJcblx0XHRcdHNtYWxsZXN0ID0gdHk7XHJcblx0XHRcdG5vcm1hbC5zZXQoIDAsIDEsIDAgKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHR6IDw9IHNtYWxsZXN0ICkge1xyXG5cdFx0XHRub3JtYWwuc2V0KCAwLCAwLCAxICk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmVjLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsICkubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0bm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgdmVjICk7XHJcblx0XHRiaW5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyAwIF0sIG5vcm1hbHNbIDAgXSApO1xyXG5cdH1cclxuXHJcblxyXG5cdC8vIGNvbXB1dGUgdGhlIHNsb3dseS12YXJ5aW5nIG5vcm1hbCBhbmQgYmlub3JtYWwgdmVjdG9ycyBmb3IgZWFjaCBzZWdtZW50IG9uIHRoZSBwYXRoXHJcblxyXG5cdGZvciAoIGkgPSAxOyBpIDwgbnVtcG9pbnRzOyBpKysgKSB7XHJcblxyXG5cdFx0bm9ybWFsc1sgaSBdID0gbm9ybWFsc1sgaS0xIF0uY2xvbmUoKTtcclxuXHJcblx0XHRiaW5vcm1hbHNbIGkgXSA9IGJpbm9ybWFsc1sgaS0xIF0uY2xvbmUoKTtcclxuXHJcblx0XHR2ZWMuY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgaS0xIF0sIHRhbmdlbnRzWyBpIF0gKTtcclxuXHJcblx0XHRpZiAoIHZlYy5sZW5ndGgoKSA+IGVwc2lsb24gKSB7XHJcblxyXG5cdFx0XHR2ZWMubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHR0aGV0YSA9IE1hdGguYWNvcyggdGFuZ2VudHNbIGktMSBdLmRvdCggdGFuZ2VudHNbIGkgXSApICk7XHJcblxyXG5cdFx0XHRub3JtYWxzWyBpIF0uYXBwbHlNYXRyaXg0KCBtYXQubWFrZVJvdGF0aW9uQXhpcyggdmVjLCB0aGV0YSApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGJpbm9ybWFsc1sgaSBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIGkgXSwgbm9ybWFsc1sgaSBdICk7XHJcblxyXG5cdH1cclxuXHJcblxyXG5cdC8vIGlmIHRoZSBjdXJ2ZSBpcyBjbG9zZWQsIHBvc3Rwcm9jZXNzIHRoZSB2ZWN0b3JzIHNvIHRoZSBmaXJzdCBhbmQgbGFzdCBub3JtYWwgdmVjdG9ycyBhcmUgdGhlIHNhbWVcclxuXHJcblx0aWYgKCBjbG9zZWQgKSB7XHJcblxyXG5cdFx0dGhldGEgPSBNYXRoLmFjb3MoIG5vcm1hbHNbIDAgXS5kb3QoIG5vcm1hbHNbIG51bXBvaW50cy0xIF0gKSApO1xyXG5cdFx0dGhldGEgLz0gKCBudW1wb2ludHMgLSAxICk7XHJcblxyXG5cdFx0aWYgKCB0YW5nZW50c1sgMCBdLmRvdCggdmVjLmNyb3NzVmVjdG9ycyggbm9ybWFsc1sgMCBdLCBub3JtYWxzWyBudW1wb2ludHMtMSBdICkgKSA+IDAgKSB7XHJcblxyXG5cdFx0XHR0aGV0YSA9IC10aGV0YTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggaSA9IDE7IGkgPCBudW1wb2ludHM7IGkrKyApIHtcclxuXHJcblx0XHRcdC8vIHR3aXN0IGEgbGl0dGxlLi4uXHJcblx0XHRcdG5vcm1hbHNbIGkgXS5hcHBseU1hdHJpeDQoIG1hdC5tYWtlUm90YXRpb25BeGlzKCB0YW5nZW50c1sgaSBdLCB0aGV0YSAqIGkgKSApO1xyXG5cdFx0XHRiaW5vcm1hbHNbIGkgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyBpIF0sIG5vcm1hbHNbIGkgXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG59O1xyXG4vKipcclxuICogQGF1dGhvciBjbG9ja3dvcmtnZWVrIC8gaHR0cHM6Ly9naXRodWIuY29tL2Nsb2Nrd29ya2dlZWtcclxuICogQGF1dGhvciB0aW1vdGh5cHJhdGxleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1vdGh5cHJhdGxleVxyXG4gKi9cclxuXHJcblRIUkVFLlBvbHloZWRyb25HZW9tZXRyeSA9IGZ1bmN0aW9uICggdmVydGljZXMsIGZhY2VzLCByYWRpdXMsIGRldGFpbCApIHtcclxuXHJcblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHRyYWRpdXMgPSByYWRpdXMgfHwgMTtcclxuXHRkZXRhaWwgPSBkZXRhaWwgfHwgMDtcclxuXHJcblx0dmFyIHRoYXQgPSB0aGlzO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdHByZXBhcmUoIG5ldyBUSFJFRS5WZWN0b3IzKCB2ZXJ0aWNlc1sgaSBdWyAwIF0sIHZlcnRpY2VzWyBpIF1bIDEgXSwgdmVydGljZXNbIGkgXVsgMiBdICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHR2YXIgbWlkcG9pbnRzID0gW10sIHAgPSB0aGlzLnZlcnRpY2VzO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdG1ha2UoIHBbIGZhY2VzWyBpIF1bIDAgXSBdLCBwWyBmYWNlc1sgaSBdWyAxIF0gXSwgcFsgZmFjZXNbIGkgXVsgMiBdIF0sIGRldGFpbCApO1xyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xyXG5cclxuXHQvLyBBcHBseSByYWRpdXNcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdHRoaXMudmVydGljZXNbIGkgXS5tdWx0aXBseVNjYWxhciggcmFkaXVzICk7XHJcblxyXG5cdH1cclxuXHJcblxyXG5cdC8vIFByb2plY3QgdmVjdG9yIG9udG8gc3BoZXJlJ3Mgc3VyZmFjZVxyXG5cclxuXHRmdW5jdGlvbiBwcmVwYXJlKCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0dmFyIHZlcnRleCA9IHZlY3Rvci5ub3JtYWxpemUoKS5jbG9uZSgpO1xyXG5cdFx0dmVydGV4LmluZGV4ID0gdGhhdC52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKSAtIDE7XHJcblxyXG5cdFx0Ly8gVGV4dHVyZSBjb29yZHMgYXJlIGVxdWl2YWxlbnQgdG8gbWFwIGNvb3JkcywgY2FsY3VsYXRlIGFuZ2xlIGFuZCBjb252ZXJ0IHRvIGZyYWN0aW9uIG9mIGEgY2lyY2xlLlxyXG5cclxuXHRcdHZhciB1ID0gYXppbXV0aCggdmVjdG9yICkgLyAyIC8gTWF0aC5QSSArIDAuNTtcclxuXHRcdHZhciB2ID0gaW5jbGluYXRpb24oIHZlY3RvciApIC8gTWF0aC5QSSArIDAuNTtcclxuXHRcdHZlcnRleC51diA9IG5ldyBUSFJFRS5WZWN0b3IyKCB1LCAxIC0gdiApO1xyXG5cclxuXHRcdHJldHVybiB2ZXJ0ZXg7XHJcblxyXG5cdH1cclxuXHJcblxyXG5cdC8vIEFwcHJveGltYXRlIGEgY3VydmVkIGZhY2Ugd2l0aCByZWN1cnNpdmVseSBzdWItZGl2aWRlZCB0cmlhbmdsZXMuXHJcblxyXG5cdGZ1bmN0aW9uIG1ha2UoIHYxLCB2MiwgdjMsIGRldGFpbCApIHtcclxuXHJcblx0XHRpZiAoIGRldGFpbCA8IDEgKSB7XHJcblxyXG5cdFx0XHR2YXIgZmFjZSA9IG5ldyBUSFJFRS5GYWNlMyggdjEuaW5kZXgsIHYyLmluZGV4LCB2My5pbmRleCwgWyB2MS5jbG9uZSgpLCB2Mi5jbG9uZSgpLCB2My5jbG9uZSgpIF0gKTtcclxuXHRcdFx0ZmFjZS5jZW50cm9pZC5hZGQoIHYxICkuYWRkKCB2MiApLmFkZCggdjMgKS5kaXZpZGVTY2FsYXIoIDMgKTtcclxuXHRcdFx0ZmFjZS5ub3JtYWwgPSBmYWNlLmNlbnRyb2lkLmNsb25lKCkubm9ybWFsaXplKCk7XHJcblx0XHRcdHRoYXQuZmFjZXMucHVzaCggZmFjZSApO1xyXG5cclxuXHRcdFx0dmFyIGF6aSA9IGF6aW11dGgoIGZhY2UuY2VudHJvaWQgKTtcclxuXHRcdFx0dGhhdC5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggW1xyXG5cdFx0XHRcdGNvcnJlY3RVViggdjEudXYsIHYxLCBhemkgKSxcclxuXHRcdFx0XHRjb3JyZWN0VVYoIHYyLnV2LCB2MiwgYXppICksXHJcblx0XHRcdFx0Y29ycmVjdFVWKCB2My51diwgdjMsIGF6aSApXHJcblx0XHRcdF0gKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0ZGV0YWlsIC09IDE7XHJcblxyXG5cdFx0XHQvLyBzcGxpdCB0cmlhbmdsZSBpbnRvIDQgc21hbGxlciB0cmlhbmdsZXNcclxuXHJcblx0XHRcdG1ha2UoIHYxLCBtaWRwb2ludCggdjEsIHYyICksIG1pZHBvaW50KCB2MSwgdjMgKSwgZGV0YWlsICk7IC8vIHRvcCBxdWFkcmFudFxyXG5cdFx0XHRtYWtlKCBtaWRwb2ludCggdjEsIHYyICksIHYyLCBtaWRwb2ludCggdjIsIHYzICksIGRldGFpbCApOyAvLyBsZWZ0IHF1YWRyYW50XHJcblx0XHRcdG1ha2UoIG1pZHBvaW50KCB2MSwgdjMgKSwgbWlkcG9pbnQoIHYyLCB2MyApLCB2MywgZGV0YWlsICk7IC8vIHJpZ2h0IHF1YWRyYW50XHJcblx0XHRcdG1ha2UoIG1pZHBvaW50KCB2MSwgdjIgKSwgbWlkcG9pbnQoIHYyLCB2MyApLCBtaWRwb2ludCggdjEsIHYzICksIGRldGFpbCApOyAvLyBjZW50ZXIgcXVhZHJhbnRcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gbWlkcG9pbnQoIHYxLCB2MiApIHtcclxuXHJcblx0XHRpZiAoICFtaWRwb2ludHNbIHYxLmluZGV4IF0gKSBtaWRwb2ludHNbIHYxLmluZGV4IF0gPSBbXTtcclxuXHRcdGlmICggIW1pZHBvaW50c1sgdjIuaW5kZXggXSApIG1pZHBvaW50c1sgdjIuaW5kZXggXSA9IFtdO1xyXG5cclxuXHRcdHZhciBtaWQgPSBtaWRwb2ludHNbIHYxLmluZGV4IF1bIHYyLmluZGV4IF07XHJcblxyXG5cdFx0aWYgKCBtaWQgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdC8vIGdlbmVyYXRlIG1lYW4gcG9pbnQgYW5kIHByb2plY3QgdG8gc3VyZmFjZSB3aXRoIHByZXBhcmUoKVxyXG5cclxuXHRcdFx0bWlkcG9pbnRzWyB2MS5pbmRleCBdWyB2Mi5pbmRleCBdID0gbWlkcG9pbnRzWyB2Mi5pbmRleCBdWyB2MS5pbmRleCBdID0gbWlkID0gcHJlcGFyZShcclxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMygpLmFkZFZlY3RvcnMoIHYxLCB2MiApLmRpdmlkZVNjYWxhciggMiApXHJcblx0XHRcdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG1pZDtcclxuXHJcblx0fVxyXG5cclxuXHJcblx0Ly8gQW5nbGUgYXJvdW5kIHRoZSBZIGF4aXMsIGNvdW50ZXItY2xvY2t3aXNlIHdoZW4gbG9va2luZyBmcm9tIGFib3ZlLlxyXG5cclxuXHRmdW5jdGlvbiBhemltdXRoKCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguYXRhbjIoIHZlY3Rvci56LCAtdmVjdG9yLnggKTtcclxuXHJcblx0fVxyXG5cclxuXHJcblx0Ly8gQW5nbGUgYWJvdmUgdGhlIFhaIHBsYW5lLlxyXG5cclxuXHRmdW5jdGlvbiBpbmNsaW5hdGlvbiggdmVjdG9yICkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLmF0YW4yKCAtdmVjdG9yLnksIE1hdGguc3FydCggKCB2ZWN0b3IueCAqIHZlY3Rvci54ICkgKyAoIHZlY3Rvci56ICogdmVjdG9yLnogKSApICk7XHJcblxyXG5cdH1cclxuXHJcblxyXG5cdC8vIFRleHR1cmUgZml4aW5nIGhlbHBlci4gU3BoZXJlcyBoYXZlIHNvbWUgb2RkIGJlaGF2aW91cnMuXHJcblxyXG5cdGZ1bmN0aW9uIGNvcnJlY3RVViggdXYsIHZlY3RvciwgYXppbXV0aCApIHtcclxuXHJcblx0XHRpZiAoICggYXppbXV0aCA8IDAgKSAmJiAoIHV2LnggPT09IDEgKSApIHV2ID0gbmV3IFRIUkVFLlZlY3RvcjIoIHV2LnggLSAxLCB1di55ICk7XHJcblx0XHRpZiAoICggdmVjdG9yLnggPT09IDAgKSAmJiAoIHZlY3Rvci56ID09PSAwICkgKSB1diA9IG5ldyBUSFJFRS5WZWN0b3IyKCBhemltdXRoIC8gMiAvIE1hdGguUEkgKyAwLjUsIHV2LnkgKTtcclxuXHRcdHJldHVybiB1djtcclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLmNvbXB1dGVDZW50cm9pZHMoKTtcclxuXHJcbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSggbmV3IFRIUkVFLlZlY3RvcjMoKSwgcmFkaXVzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG4vKipcclxuICogQGF1dGhvciB0aW1vdGh5cHJhdGxleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1vdGh5cHJhdGxleVxyXG4gKi9cclxuXHJcblRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgZGV0YWlsICkge1xyXG5cclxuXHR2YXIgdCA9ICggMSArIE1hdGguc3FydCggNSApICkgLyAyO1xyXG5cclxuXHR2YXIgdmVydGljZXMgPSBbXHJcblx0XHRbIC0xLCAgdCwgIDAgXSwgWyAgMSwgdCwgMCBdLCBbIC0xLCAtdCwgIDAgXSwgWyAgMSwgLXQsICAwIF0sXHJcblx0XHRbICAwLCAtMSwgIHQgXSwgWyAgMCwgMSwgdCBdLCBbICAwLCAtMSwgLXQgXSwgWyAgMCwgIDEsIC10IF0sXHJcblx0XHRbICB0LCAgMCwgLTEgXSwgWyAgdCwgMCwgMSBdLCBbIC10LCAgMCwgLTEgXSwgWyAtdCwgIDAsICAxIF1cclxuXHRdO1xyXG5cclxuXHR2YXIgZmFjZXMgPSBbXHJcblx0XHRbIDAsIDExLCAgNSBdLCBbIDAsICA1LCAgMSBdLCBbICAwLCAgMSwgIDcgXSwgWyAgMCwgIDcsIDEwIF0sIFsgIDAsIDEwLCAxMSBdLFxyXG5cdFx0WyAxLCAgNSwgIDkgXSwgWyA1LCAxMSwgIDQgXSwgWyAxMSwgMTAsICAyIF0sIFsgMTAsICA3LCAgNiBdLCBbICA3LCAgMSwgIDggXSxcclxuXHRcdFsgMywgIDksICA0IF0sIFsgMywgIDQsICAyIF0sIFsgIDMsICAyLCAgNiBdLCBbICAzLCAgNiwgIDggXSwgWyAgMywgIDgsICA5IF0sXHJcblx0XHRbIDQsICA5LCAgNSBdLCBbIDIsICA0LCAxMSBdLCBbICA2LCAgMiwgMTAgXSwgWyAgOCwgIDYsICA3IF0sIFsgIDksICA4LCAgMSBdXHJcblx0XTtcclxuXHJcblx0VEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LmNhbGwoIHRoaXMsIHZlcnRpY2VzLCBmYWNlcywgcmFkaXVzLCBkZXRhaWwgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG4vKipcclxuICogQGF1dGhvciB0aW1vdGh5cHJhdGxleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1vdGh5cHJhdGxleVxyXG4gKi9cclxuXHJcblRIUkVFLk9jdGFoZWRyb25HZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCBkZXRhaWwgKSB7XHJcblxyXG5cdHZhciB2ZXJ0aWNlcyA9IFtcclxuXHRcdFsgMSwgMCwgMCBdLCBbIC0xLCAwLCAwIF0sIFsgMCwgMSwgMCBdLCBbIDAsIC0xLCAwIF0sIFsgMCwgMCwgMSBdLCBbIDAsIDAsIC0xIF1cclxuXHRdO1xyXG5cclxuXHR2YXIgZmFjZXMgPSBbXHJcblx0XHRbIDAsIDIsIDQgXSwgWyAwLCA0LCAzIF0sIFsgMCwgMywgNSBdLCBbIDAsIDUsIDIgXSwgWyAxLCAyLCA1IF0sIFsgMSwgNSwgMyBdLCBbIDEsIDMsIDQgXSwgWyAxLCA0LCAyIF1cclxuXHRdO1xyXG5cclxuXHRUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkuY2FsbCggdGhpcywgdmVydGljZXMsIGZhY2VzLCByYWRpdXMsIGRldGFpbCApO1xyXG59O1xyXG5cclxuVEhSRUUuT2N0YWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG4vKipcclxuICogQGF1dGhvciB0aW1vdGh5cHJhdGxleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1vdGh5cHJhdGxleVxyXG4gKi9cclxuXHJcblRIUkVFLlRldHJhaGVkcm9uR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgZGV0YWlsICkge1xyXG5cclxuXHR2YXIgdmVydGljZXMgPSBbXHJcblx0XHRbIDEsICAxLCAgMSBdLCBbIC0xLCAtMSwgMSBdLCBbIC0xLCAxLCAtMSBdLCBbIDEsIC0xLCAtMSBdXHJcblx0XTtcclxuXHJcblx0dmFyIGZhY2VzID0gW1xyXG5cdFx0WyAyLCAxLCAwIF0sIFsgMCwgMywgMiBdLCBbIDEsIDMsIDAgXSwgWyAyLCAzLCAxIF1cclxuXHRdO1xyXG5cclxuXHRUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkuY2FsbCggdGhpcywgdmVydGljZXMsIGZhY2VzLCByYWRpdXMsIGRldGFpbCApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlRldHJhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwczovL2dpdGh1Yi5jb20veno4NVxyXG4gKiBQYXJhbWV0cmljIFN1cmZhY2VzIEdlb21ldHJ5XHJcbiAqIGJhc2VkIG9uIHRoZSBicmlsbGlhbnQgYXJ0aWNsZSBieSBAcHJpZGVvdXQgaHR0cDovL3ByaWRlb3V0Lm5ldC9ibG9nLz9wPTQ0XHJcbiAqXHJcbiAqIG5ldyBUSFJFRS5QYXJhbWV0cmljR2VvbWV0cnkoIHBhcmFtZXRyaWNGdW5jdGlvbiwgdVNlZ21lbnRzLCB5U2VnZW1lbnRzLCB1c2VUcmlzICk7XHJcbiAqXHJcbiAqL1xyXG5cclxuVEhSRUUuUGFyYW1ldHJpY0dlb21ldHJ5ID0gZnVuY3Rpb24gKCBmdW5jLCBzbGljZXMsIHN0YWNrcywgdXNlVHJpcyApIHtcclxuXHJcblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHR2YXIgdmVydHMgPSB0aGlzLnZlcnRpY2VzO1xyXG5cdHZhciBmYWNlcyA9IHRoaXMuZmFjZXM7XHJcblx0dmFyIHV2cyA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdO1xyXG5cclxuXHR1c2VUcmlzID0gKHVzZVRyaXMgPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IHVzZVRyaXM7XHJcblxyXG5cdHZhciBpLCBpbCwgaiwgcDtcclxuXHR2YXIgdSwgdjtcclxuXHJcblx0dmFyIHN0YWNrQ291bnQgPSBzdGFja3MgKyAxO1xyXG5cdHZhciBzbGljZUNvdW50ID0gc2xpY2VzICsgMTtcclxuXHJcblx0Zm9yICggaSA9IDA7IGkgPD0gc3RhY2tzOyBpICsrICkge1xyXG5cclxuXHRcdHYgPSBpIC8gc3RhY2tzO1xyXG5cclxuXHRcdGZvciAoIGogPSAwOyBqIDw9IHNsaWNlczsgaiArKyApIHtcclxuXHJcblx0XHRcdHUgPSBqIC8gc2xpY2VzO1xyXG5cclxuXHRcdFx0cCA9IGZ1bmMoIHUsIHYgKTtcclxuXHRcdFx0dmVydHMucHVzaCggcCApO1xyXG5cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHZhciBhLCBiLCBjLCBkO1xyXG5cdHZhciB1dmEsIHV2YiwgdXZjLCB1dmQ7XHJcblxyXG5cdGZvciAoIGkgPSAwOyBpIDwgc3RhY2tzOyBpICsrICkge1xyXG5cclxuXHRcdGZvciAoIGogPSAwOyBqIDwgc2xpY2VzOyBqICsrICkge1xyXG5cclxuXHRcdFx0YSA9IGkgKiBzbGljZUNvdW50ICsgajtcclxuXHRcdFx0YiA9IGkgKiBzbGljZUNvdW50ICsgaiArIDE7XHJcblx0XHRcdGMgPSAoaSArIDEpICogc2xpY2VDb3VudCArIGo7XHJcblx0XHRcdGQgPSAoaSArIDEpICogc2xpY2VDb3VudCArIGogKyAxO1xyXG5cclxuXHRcdFx0dXZhID0gbmV3IFRIUkVFLlZlY3RvcjIoIGogLyBzbGljZXMsIGkgLyBzdGFja3MgKTtcclxuXHRcdFx0dXZiID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaiArIDEgKSAvIHNsaWNlcywgaSAvIHN0YWNrcyApO1xyXG5cdFx0XHR1dmMgPSBuZXcgVEhSRUUuVmVjdG9yMiggaiAvIHNsaWNlcywgKCBpICsgMSApIC8gc3RhY2tzICk7XHJcblx0XHRcdHV2ZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGogKyAxICkgLyBzbGljZXMsICggaSArIDEgKSAvIHN0YWNrcyApO1xyXG5cclxuXHRcdFx0aWYgKCB1c2VUcmlzICkge1xyXG5cclxuXHRcdFx0XHRmYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGMgKSApO1xyXG5cdFx0XHRcdGZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYiwgZCwgYyApICk7XHJcblxyXG5cdFx0XHRcdHV2cy5wdXNoKCBbIHV2YSwgdXZiLCB1dmMgXSApO1xyXG5cdFx0XHRcdHV2cy5wdXNoKCBbIHV2YiwgdXZkLCB1dmMgXSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0ZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2U0KCBhLCBiLCBkLCBjICkgKTtcclxuXHRcdFx0XHR1dnMucHVzaCggWyB1dmEsIHV2YiwgdXZkLCB1dmMgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvLyBjb25zb2xlLmxvZyh0aGlzKTtcclxuXHJcblx0Ly8gbWFnaWMgYnVsbGV0XHJcblx0Ly8gdmFyIGRpZmYgPSB0aGlzLm1lcmdlVmVydGljZXMoKTtcclxuXHQvLyBjb25zb2xlLmxvZygncmVtb3ZlZCAnLCBkaWZmLCAnIHZlcnRpY2VzIGJ5IG1lcmdpbmcnKTtcclxuXHJcblx0dGhpcy5jb21wdXRlQ2VudHJvaWRzKCk7XHJcblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHR0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUGFyYW1ldHJpY0dlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG4vKipcclxuICogQGF1dGhvciBxaWFvIC8gaHR0cHM6Ly9naXRodWIuY29tL3FpYW9cclxuICogQGZpbGVvdmVydmlldyBUaGlzIGlzIGEgY29udmV4IGh1bGwgZ2VuZXJhdG9yIHVzaW5nIHRoZSBpbmNyZW1lbnRhbCBtZXRob2QuIFxyXG4gKiBUaGUgY29tcGxleGl0eSBpcyBPKG5eMikgd2hlcmUgbiBpcyB0aGUgbnVtYmVyIG9mIHZlcnRpY2VzLlxyXG4gKiBPKG5sb2duKSBhbGdvcml0aG1zIGRvIGV4aXN0LCBidXQgdGhleSBhcmUgbXVjaCBtb3JlIGNvbXBsaWNhdGVkLlxyXG4gKlxyXG4gKiBCZW5jaG1hcms6IFxyXG4gKlxyXG4gKiAgUGxhdGZvcm06IENQVTogUDczNTAgQDIuMDBHSHogRW5naW5lOiBWOFxyXG4gKlxyXG4gKiAgTnVtIFZlcnRpY2VzXHRUaW1lKG1zKVxyXG4gKlxyXG4gKiAgICAgMTAgICAgICAgICAgIDFcclxuICogICAgIDIwICAgICAgICAgICAzXHJcbiAqICAgICAzMCAgICAgICAgICAgMTlcclxuICogICAgIDQwICAgICAgICAgICA0OFxyXG4gKiAgICAgNTAgICAgICAgICAgIDEwN1xyXG4gKi9cclxuXHJcblRIUkVFLkNvbnZleEdlb21ldHJ5ID0gZnVuY3Rpb24oIHZlcnRpY2VzICkge1xyXG5cclxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHZhciBmYWNlcyA9IFsgWyAwLCAxLCAyIF0sIFsgMCwgMiwgMSBdIF07IFxyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDM7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKyApIHtcclxuXHJcblx0XHRhZGRQb2ludCggaSApO1xyXG5cclxuXHR9XHJcblxyXG5cclxuXHRmdW5jdGlvbiBhZGRQb2ludCggdmVydGV4SWQgKSB7XHJcblxyXG5cdFx0dmFyIHZlcnRleCA9IHZlcnRpY2VzWyB2ZXJ0ZXhJZCBdLmNsb25lKCk7XHJcblxyXG5cdFx0dmFyIG1hZyA9IHZlcnRleC5sZW5ndGgoKTtcclxuXHRcdHZlcnRleC54ICs9IG1hZyAqIHJhbmRvbU9mZnNldCgpO1xyXG5cdFx0dmVydGV4LnkgKz0gbWFnICogcmFuZG9tT2Zmc2V0KCk7XHJcblx0XHR2ZXJ0ZXgueiArPSBtYWcgKiByYW5kb21PZmZzZXQoKTtcclxuXHJcblx0XHR2YXIgaG9sZSA9IFtdO1xyXG5cclxuXHRcdGZvciAoIHZhciBmID0gMDsgZiA8IGZhY2VzLmxlbmd0aDsgKSB7XHJcblxyXG5cdFx0XHR2YXIgZmFjZSA9IGZhY2VzWyBmIF07XHJcblxyXG5cdFx0XHQvLyBmb3IgZWFjaCBmYWNlLCBpZiB0aGUgdmVydGV4IGNhbiBzZWUgaXQsXHJcblx0XHRcdC8vIHRoZW4gd2UgdHJ5IHRvIGFkZCB0aGUgZmFjZSdzIGVkZ2VzIGludG8gdGhlIGhvbGUuXHJcblx0XHRcdGlmICggdmlzaWJsZSggZmFjZSwgdmVydGV4ICkgKSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBlID0gMDsgZSA8IDM7IGUrKyApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgZWRnZSA9IFsgZmFjZVsgZSBdLCBmYWNlWyAoIGUgKyAxICkgJSAzIF0gXTtcclxuXHRcdFx0XHRcdHZhciBib3VuZGFyeSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdFx0Ly8gcmVtb3ZlIGR1cGxpY2F0ZWQgZWRnZXMuXHJcblx0XHRcdFx0XHRmb3IgKCB2YXIgaCA9IDA7IGggPCBob2xlLmxlbmd0aDsgaCsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBlcXVhbEVkZ2UoIGhvbGVbIGggXSwgZWRnZSApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRob2xlWyBoIF0gPSBob2xlWyBob2xlLmxlbmd0aCAtIDEgXTtcclxuXHRcdFx0XHRcdFx0XHRob2xlLnBvcCgpO1xyXG5cdFx0XHRcdFx0XHRcdGJvdW5kYXJ5ID0gZmFsc2U7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmICggYm91bmRhcnkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRob2xlLnB1c2goIGVkZ2UgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gcmVtb3ZlIGZhY2VzWyBmIF1cclxuXHRcdFx0XHRmYWNlc1sgZiBdID0gZmFjZXNbIGZhY2VzLmxlbmd0aCAtIDEgXTtcclxuXHRcdFx0XHRmYWNlcy5wb3AoKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7IC8vIG5vdCB2aXNpYmxlXHJcblxyXG5cdFx0XHRcdGYrKztcclxuXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBjb25zdHJ1Y3QgdGhlIG5ldyBmYWNlcyBmb3JtZWQgYnkgdGhlIGVkZ2VzIG9mIHRoZSBob2xlIGFuZCB0aGUgdmVydGV4XHJcblx0XHRmb3IgKCB2YXIgaCA9IDA7IGggPCBob2xlLmxlbmd0aDsgaCsrICkge1xyXG5cclxuXHRcdFx0ZmFjZXMucHVzaCggWyBcclxuXHRcdFx0XHRob2xlWyBoIF1bIDAgXSxcclxuXHRcdFx0XHRob2xlWyBoIF1bIDEgXSxcclxuXHRcdFx0XHR2ZXJ0ZXhJZFxyXG5cdFx0XHRdICk7XHJcblxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogV2hldGhlciB0aGUgZmFjZSBpcyB2aXNpYmxlIGZyb20gdGhlIHZlcnRleFxyXG5cdCAqL1xyXG5cdGZ1bmN0aW9uIHZpc2libGUoIGZhY2UsIHZlcnRleCApIHtcclxuXHJcblx0XHR2YXIgdmEgPSB2ZXJ0aWNlc1sgZmFjZVsgMCBdIF07XHJcblx0XHR2YXIgdmIgPSB2ZXJ0aWNlc1sgZmFjZVsgMSBdIF07XHJcblx0XHR2YXIgdmMgPSB2ZXJ0aWNlc1sgZmFjZVsgMiBdIF07XHJcblxyXG5cdFx0dmFyIG4gPSBub3JtYWwoIHZhLCB2YiwgdmMgKTtcclxuXHJcblx0XHQvLyBkaXN0YW5jZSBmcm9tIGZhY2UgdG8gb3JpZ2luXHJcblx0XHR2YXIgZGlzdCA9IG4uZG90KCB2YSApO1xyXG5cclxuXHRcdHJldHVybiBuLmRvdCggdmVydGV4ICkgPj0gZGlzdDsgXHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRmFjZSBub3JtYWxcclxuXHQgKi9cclxuXHRmdW5jdGlvbiBub3JtYWwoIHZhLCB2YiwgdmMgKSB7XHJcblxyXG5cdFx0dmFyIGNiID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHZhciBhYiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0Y2Iuc3ViVmVjdG9ycyggdmMsIHZiICk7XHJcblx0XHRhYi5zdWJWZWN0b3JzKCB2YSwgdmIgKTtcclxuXHRcdGNiLmNyb3NzKCBhYiApO1xyXG5cclxuXHRcdGNiLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdHJldHVybiBjYjtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBEZXRlY3Qgd2hldGhlciB0d28gZWRnZXMgYXJlIGVxdWFsLlxyXG5cdCAqIE5vdGUgdGhhdCB3aGVuIGNvbnN0cnVjdGluZyB0aGUgY29udmV4IGh1bGwsIHR3byBzYW1lIGVkZ2VzIGNhbiBvbmx5XHJcblx0ICogYmUgb2YgdGhlIG5lZ2F0aXZlIGRpcmVjdGlvbi5cclxuXHQgKi9cclxuXHRmdW5jdGlvbiBlcXVhbEVkZ2UoIGVhLCBlYiApIHtcclxuXHJcblx0XHRyZXR1cm4gZWFbIDAgXSA9PT0gZWJbIDEgXSAmJiBlYVsgMSBdID09PSBlYlsgMCBdOyBcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDcmVhdGUgYSByYW5kb20gb2Zmc2V0IGJldHdlZW4gLTFlLTYgYW5kIDFlLTYuXHJcblx0ICovXHJcblx0ZnVuY3Rpb24gcmFuZG9tT2Zmc2V0KCkge1xyXG5cclxuXHRcdHJldHVybiAoIE1hdGgucmFuZG9tKCkgLSAwLjUgKSAqIDIgKiAxZS02O1xyXG5cclxuXHR9XHJcblxyXG5cclxuXHQvKipcclxuXHQgKiBYWFg6IE5vdCBzdXJlIGlmIHRoaXMgaXMgdGhlIGNvcnJlY3QgYXBwcm9hY2guIE5lZWQgc29tZW9uZSB0byByZXZpZXcuXHJcblx0ICovXHJcblx0ZnVuY3Rpb24gdmVydGV4VXYoIHZlcnRleCApIHtcclxuXHJcblx0XHR2YXIgbWFnID0gdmVydGV4Lmxlbmd0aCgpO1xyXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IyKCB2ZXJ0ZXgueCAvIG1hZywgdmVydGV4LnkgLyBtYWcgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBQdXNoIHZlcnRpY2VzIGludG8gYHRoaXMudmVydGljZXNgLCBza2lwcGluZyB0aG9zZSBpbnNpZGUgdGhlIGh1bGxcclxuXHR2YXIgaWQgPSAwO1xyXG5cdHZhciBuZXdJZCA9IG5ldyBBcnJheSggdmVydGljZXMubGVuZ3RoICk7IC8vIG1hcCBmcm9tIG9sZCB2ZXJ0ZXggaWQgdG8gbmV3IGlkXHJcblxyXG5cdGZvciAoIHZhciBpID0gMDsgaSA8IGZhY2VzLmxlbmd0aDsgaSsrICkge1xyXG5cclxuXHRcdCB2YXIgZmFjZSA9IGZhY2VzWyBpIF07XHJcblxyXG5cdFx0IGZvciAoIHZhciBqID0gMDsgaiA8IDM7IGorKyApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBuZXdJZFsgZmFjZVsgaiBdIF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdG5ld0lkWyBmYWNlWyBqIF0gXSA9IGlkKys7XHJcblx0XHRcdFx0XHRcdHRoaXMudmVydGljZXMucHVzaCggdmVydGljZXNbIGZhY2VbIGogXSBdICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0ZmFjZVsgaiBdID0gbmV3SWRbIGZhY2VbIGogXSBdO1xyXG5cclxuXHRcdCB9XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gQ29udmVydCBmYWNlcyBpbnRvIGluc3RhbmNlcyBvZiBUSFJFRS5GYWNlM1xyXG5cdGZvciAoIHZhciBpID0gMDsgaSA8IGZhY2VzLmxlbmd0aDsgaSsrICkge1xyXG5cclxuXHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBcclxuXHRcdFx0XHRmYWNlc1sgaSBdWyAwIF0sXHJcblx0XHRcdFx0ZmFjZXNbIGkgXVsgMSBdLFxyXG5cdFx0XHRcdGZhY2VzWyBpIF1bIDIgXVxyXG5cdFx0KSApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIENvbXB1dGUgVVZzXHJcblx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5mYWNlcy5sZW5ndGg7IGkrKyApIHtcclxuXHJcblx0XHR2YXIgZmFjZSA9IHRoaXMuZmFjZXNbIGkgXTtcclxuXHJcblx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbXHJcblx0XHRcdHZlcnRleFV2KCB0aGlzLnZlcnRpY2VzWyBmYWNlLmEgXSApLFxyXG5cdFx0XHR2ZXJ0ZXhVdiggdGhpcy52ZXJ0aWNlc1sgZmFjZS5iIF0gKSxcclxuXHRcdFx0dmVydGV4VXYoIHRoaXMudmVydGljZXNbIGZhY2UuYyBdKVxyXG5cdFx0XSApO1xyXG5cclxuXHR9XHJcblxyXG5cclxuXHR0aGlzLmNvbXB1dGVDZW50cm9pZHMoKTtcclxuXHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG5cdHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Db252ZXhHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuLyoqXHJcbiAqIEBhdXRob3Igc3JvdWNoZXJheSAvIGh0dHA6Ly9zcm91Y2hlcmF5Lm9yZy9cclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5BeGlzSGVscGVyID0gZnVuY3Rpb24gKCBzaXplICkge1xyXG5cclxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuXHJcblx0Z2VvbWV0cnkudmVydGljZXMucHVzaChcclxuXHRcdG5ldyBUSFJFRS5WZWN0b3IzKCksIG5ldyBUSFJFRS5WZWN0b3IzKCBzaXplIHx8IDEsIDAsIDAgKSxcclxuXHRcdG5ldyBUSFJFRS5WZWN0b3IzKCksIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCBzaXplIHx8IDEsIDAgKSxcclxuXHRcdG5ldyBUSFJFRS5WZWN0b3IzKCksIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCBzaXplIHx8IDEgKVxyXG5cdCk7XHJcblxyXG5cdGdlb21ldHJ5LmNvbG9ycy5wdXNoKFxyXG5cdFx0bmV3IFRIUkVFLkNvbG9yKCAweGZmMDAwMCApLCBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZhYTAwICksXHJcblx0XHRuZXcgVEhSRUUuQ29sb3IoIDB4MDBmZjAwICksIG5ldyBUSFJFRS5Db2xvciggMHhhYWZmMDAgKSxcclxuXHRcdG5ldyBUSFJFRS5Db2xvciggMHgwMDAwZmYgKSwgbmV3IFRIUkVFLkNvbG9yKCAweDAwYWFmZiApXHJcblx0KTtcclxuXHJcblx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IHZlcnRleENvbG9yczogVEhSRUUuVmVydGV4Q29sb3JzIH0gKTtcclxuXHJcblx0VEhSRUUuTGluZS5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIFRIUkVFLkxpbmVQaWVjZXMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BeGlzSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmUucHJvdG90eXBlICk7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICogQGF1dGhvciB6ejg1IC8gaHR0cHM6Ly9naXRodWIuY29tL3p6ODVcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHBzOi8vZXhvY29ydGV4LmNvbVxyXG4gKlxyXG4gKiBDcmVhdGVzIGFuIGFycm93IGZvciB2aXN1YWxpemluZyBkaXJlY3Rpb25zXHJcbiAqXHJcbiAqIFBhcmFtZXRlcnM6XHJcbiAqICBkaXIgLSBWZWN0b3IzXHJcbiAqICBvcmlnaW4gLSBWZWN0b3IzXHJcbiAqICBsZW5ndGggLSBOdW1iZXJcclxuICogIGhleCAtIGNvbG9yIGluIGhleCB2YWx1ZVxyXG4gKi9cclxuXHJcblRIUkVFLkFycm93SGVscGVyID0gZnVuY3Rpb24gKCBkaXIsIG9yaWdpbiwgbGVuZ3RoLCBoZXggKSB7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0aWYgKCBsZW5ndGggPT09IHVuZGVmaW5lZCApIGxlbmd0aCA9IDIwO1xyXG5cdGlmICggaGV4ID09PSB1bmRlZmluZWQgKSBoZXggPSAweGZmZmYwMDtcclxuXHJcblx0dmFyIGxpbmVHZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xyXG5cdGxpbmVHZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMCApICk7XHJcblx0bGluZUdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICkgKTtcclxuXHJcblx0dGhpcy5saW5lID0gbmV3IFRIUkVFLkxpbmUoIGxpbmVHZW9tZXRyeSwgbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBoZXggfSApICk7XHJcblx0dGhpcy5hZGQoIHRoaXMubGluZSApO1xyXG5cclxuXHR2YXIgY29uZUdlb21ldHJ5ID0gbmV3IFRIUkVFLkN5bGluZGVyR2VvbWV0cnkoIDAsIDAuMDUsIDAuMjUsIDUsIDEgKTtcclxuXHJcblx0dGhpcy5jb25lID0gbmV3IFRIUkVFLk1lc2goIGNvbmVHZW9tZXRyeSwgbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBoZXggfSApICk7XHJcblx0dGhpcy5jb25lLnBvc2l0aW9uLnNldCggMCwgMSwgMCApO1xyXG5cdHRoaXMuYWRkKCB0aGlzLmNvbmUgKTtcclxuXHJcblx0aWYgKCBvcmlnaW4gaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IzICkgdGhpcy5wb3NpdGlvbiA9IG9yaWdpbjtcclxuXHJcblx0dGhpcy5zZXREaXJlY3Rpb24oIGRpciApO1xyXG5cdHRoaXMuc2V0TGVuZ3RoKCBsZW5ndGggKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BcnJvd0hlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLkFycm93SGVscGVyLnByb3RvdHlwZS5zZXREaXJlY3Rpb24gPSBmdW5jdGlvbiAoIGRpciApIHtcclxuXHJcbiAgICB2YXIgZCA9IFRIUkVFLkFycm93SGVscGVyLl9fdjEuY29weSggZGlyICkubm9ybWFsaXplKCk7XHJcblxyXG4gICAgaWYgKCBkLnkgPiAwLjk5OSApIHtcclxuXHJcbiAgICAgICAgdGhpcy5yb3RhdGlvbi5zZXQoIDAsIDAsIDAgKTtcclxuIFxyXG4gICAgfSBlbHNlIGlmICggZC55IDwgLSAwLjk5OSApIHtcclxuXHJcbiAgICAgICAgdGhpcy5yb3RhdGlvbi5zZXQoIE1hdGguUEksIDAsIDAgKTtcclxuXHJcbiAgICB9IGVsc2Uge1xyXG5cclxuXHQgICAgdmFyIGF4aXMgPSBUSFJFRS5BcnJvd0hlbHBlci5fX3YyLnNldCggZC56LCAwLCAtIGQueCApLm5vcm1hbGl6ZSgpO1xyXG5cdCAgICB2YXIgcmFkaWFucyA9IE1hdGguYWNvcyggZC55ICk7XHJcblx0ICAgIHZhciBxdWF0ZXJuaW9uID0gVEhSRUUuQXJyb3dIZWxwZXIuX19xMS5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCByYWRpYW5zICk7XHJcblxyXG5cdCAgICB0aGlzLnJvdGF0aW9uLnNldEV1bGVyRnJvbVF1YXRlcm5pb24oIHF1YXRlcm5pb24sIHRoaXMuZXVsZXJPcmRlciApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXJyb3dIZWxwZXIucHJvdG90eXBlLnNldExlbmd0aCA9IGZ1bmN0aW9uICggbGVuZ3RoICkge1xyXG5cclxuXHR0aGlzLnNjYWxlLnNldCggbGVuZ3RoLCBsZW5ndGgsIGxlbmd0aCApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkFycm93SGVscGVyLnByb3RvdHlwZS5zZXRDb2xvciA9IGZ1bmN0aW9uICggaGV4ICkge1xyXG5cclxuXHR0aGlzLmxpbmUubWF0ZXJpYWwuY29sb3Iuc2V0SGV4KCBoZXggKTtcclxuXHR0aGlzLmNvbmUubWF0ZXJpYWwuY29sb3Iuc2V0SGV4KCBoZXggKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BcnJvd0hlbHBlci5fX3YxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuVEhSRUUuQXJyb3dIZWxwZXIuX192MiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblRIUkVFLkFycm93SGVscGVyLl9fcTEgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICpcclxuICpcdC0gc2hvd3MgZnJ1c3R1bSwgbGluZSBvZiBzaWdodCBhbmQgdXAgb2YgdGhlIGNhbWVyYVxyXG4gKlx0LSBzdWl0YWJsZSBmb3IgZmFzdCB1cGRhdGVzXHJcbiAqIFx0LSBiYXNlZCBvbiBmcnVzdHVtIHZpc3VhbGl6YXRpb24gaW4gbGlnaHRnbC5qcyBzaGFkb3dtYXAgZXhhbXBsZVxyXG4gKlx0XHRodHRwOi8vZXZhbncuZ2l0aHViLmNvbS9saWdodGdsLmpzL3Rlc3RzL3NoYWRvd21hcC5odG1sXHJcbiAqL1xyXG5cclxuVEhSRUUuQ2FtZXJhSGVscGVyID0gZnVuY3Rpb24gKCBjYW1lcmEgKSB7XHJcblxyXG5cdFRIUkVFLkxpbmUuY2FsbCggdGhpcyApO1xyXG5cclxuXHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHR0aGlzLmdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XHJcblx0dGhpcy5tYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHhmZmZmZmYsIHZlcnRleENvbG9yczogVEhSRUUuRmFjZUNvbG9ycyB9ICk7XHJcblx0dGhpcy50eXBlID0gVEhSRUUuTGluZVBpZWNlcztcclxuXHJcblx0dGhpcy5tYXRyaXhXb3JsZCA9IGNhbWVyYS5tYXRyaXhXb3JsZDtcclxuXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0dGhpcy5wb2ludE1hcCA9IHt9O1xyXG5cclxuXHQvLyBjb2xvcnNcclxuXHJcblx0dmFyIGhleEZydXN0dW0gPSAweGZmYWEwMDtcclxuXHR2YXIgaGV4Q29uZSA9IDB4ZmYwMDAwO1xyXG5cdHZhciBoZXhVcCA9IDB4MDBhYWZmO1xyXG5cdHZhciBoZXhUYXJnZXQgPSAweGZmZmZmZjtcclxuXHR2YXIgaGV4Q3Jvc3MgPSAweDMzMzMzMztcclxuXHJcblx0Ly8gbmVhclxyXG5cclxuXHRhZGRMaW5lKCBcIm4xXCIsIFwibjJcIiwgaGV4RnJ1c3R1bSApO1xyXG5cdGFkZExpbmUoIFwibjJcIiwgXCJuNFwiLCBoZXhGcnVzdHVtICk7XHJcblx0YWRkTGluZSggXCJuNFwiLCBcIm4zXCIsIGhleEZydXN0dW0gKTtcclxuXHRhZGRMaW5lKCBcIm4zXCIsIFwibjFcIiwgaGV4RnJ1c3R1bSApO1xyXG5cclxuXHQvLyBmYXJcclxuXHJcblx0YWRkTGluZSggXCJmMVwiLCBcImYyXCIsIGhleEZydXN0dW0gKTtcclxuXHRhZGRMaW5lKCBcImYyXCIsIFwiZjRcIiwgaGV4RnJ1c3R1bSApO1xyXG5cdGFkZExpbmUoIFwiZjRcIiwgXCJmM1wiLCBoZXhGcnVzdHVtICk7XHJcblx0YWRkTGluZSggXCJmM1wiLCBcImYxXCIsIGhleEZydXN0dW0gKTtcclxuXHJcblx0Ly8gc2lkZXNcclxuXHJcblx0YWRkTGluZSggXCJuMVwiLCBcImYxXCIsIGhleEZydXN0dW0gKTtcclxuXHRhZGRMaW5lKCBcIm4yXCIsIFwiZjJcIiwgaGV4RnJ1c3R1bSApO1xyXG5cdGFkZExpbmUoIFwibjNcIiwgXCJmM1wiLCBoZXhGcnVzdHVtICk7XHJcblx0YWRkTGluZSggXCJuNFwiLCBcImY0XCIsIGhleEZydXN0dW0gKTtcclxuXHJcblx0Ly8gY29uZVxyXG5cclxuXHRhZGRMaW5lKCBcInBcIiwgXCJuMVwiLCBoZXhDb25lICk7XHJcblx0YWRkTGluZSggXCJwXCIsIFwibjJcIiwgaGV4Q29uZSApO1xyXG5cdGFkZExpbmUoIFwicFwiLCBcIm4zXCIsIGhleENvbmUgKTtcclxuXHRhZGRMaW5lKCBcInBcIiwgXCJuNFwiLCBoZXhDb25lICk7XHJcblxyXG5cdC8vIHVwXHJcblxyXG5cdGFkZExpbmUoIFwidTFcIiwgXCJ1MlwiLCBoZXhVcCApO1xyXG5cdGFkZExpbmUoIFwidTJcIiwgXCJ1M1wiLCBoZXhVcCApO1xyXG5cdGFkZExpbmUoIFwidTNcIiwgXCJ1MVwiLCBoZXhVcCApO1xyXG5cclxuXHQvLyB0YXJnZXRcclxuXHJcblx0YWRkTGluZSggXCJjXCIsIFwidFwiLCBoZXhUYXJnZXQgKTtcclxuXHRhZGRMaW5lKCBcInBcIiwgXCJjXCIsIGhleENyb3NzICk7XHJcblxyXG5cdC8vIGNyb3NzXHJcblxyXG5cdGFkZExpbmUoIFwiY24xXCIsIFwiY24yXCIsIGhleENyb3NzICk7XHJcblx0YWRkTGluZSggXCJjbjNcIiwgXCJjbjRcIiwgaGV4Q3Jvc3MgKTtcclxuXHJcblx0YWRkTGluZSggXCJjZjFcIiwgXCJjZjJcIiwgaGV4Q3Jvc3MgKTtcclxuXHRhZGRMaW5lKCBcImNmM1wiLCBcImNmNFwiLCBoZXhDcm9zcyApO1xyXG5cclxuXHR0aGlzLmNhbWVyYSA9IGNhbWVyYTtcclxuXHJcblx0ZnVuY3Rpb24gYWRkTGluZSggYSwgYiwgaGV4ICkge1xyXG5cclxuXHRcdGFkZFBvaW50KCBhLCBoZXggKTtcclxuXHRcdGFkZFBvaW50KCBiLCBoZXggKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBhZGRQb2ludCggaWQsIGhleCApIHtcclxuXHJcblx0XHRzY29wZS5nZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMygpICk7XHJcblx0XHRzY29wZS5nZW9tZXRyeS5jb2xvcnMucHVzaCggbmV3IFRIUkVFLkNvbG9yKCBoZXggKSApO1xyXG5cclxuXHRcdGlmICggc2NvcGUucG9pbnRNYXBbIGlkIF0gPT09IHVuZGVmaW5lZCApIHNjb3BlLnBvaW50TWFwWyBpZCBdID0gW107XHJcblxyXG5cdFx0c2NvcGUucG9pbnRNYXBbIGlkIF0ucHVzaCggc2NvcGUuZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoIC0gMSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMudXBkYXRlKCBjYW1lcmEgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5DYW1lcmFIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZS5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLkNhbWVyYUhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHR2YXIgdyA9IDEsIGggPSAxO1xyXG5cclxuXHQvLyB3ZSBuZWVkIGp1c3QgY2FtZXJhIHByb2plY3Rpb24gbWF0cml4XHJcblx0Ly8gd29ybGQgbWF0cml4IG11c3QgYmUgaWRlbnRpdHlcclxuXHJcblx0VEhSRUUuQ2FtZXJhSGVscGVyLl9fYy5wcm9qZWN0aW9uTWF0cml4LmNvcHkoIHRoaXMuY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcclxuXHJcblx0Ly8gY2VudGVyIC8gdGFyZ2V0XHJcblxyXG5cdHNldFBvaW50KCBcImNcIiwgMCwgMCwgLTEgKTtcclxuXHRzZXRQb2ludCggXCJ0XCIsIDAsIDAsICAxICk7XHJcblxyXG5cdC8vIG5lYXJcclxuXHJcblx0c2V0UG9pbnQoIFwibjFcIiwgLXcsIC1oLCAtMSApO1xyXG5cdHNldFBvaW50KCBcIm4yXCIsICB3LCAtaCwgLTEgKTtcclxuXHRzZXRQb2ludCggXCJuM1wiLCAtdywgIGgsIC0xICk7XHJcblx0c2V0UG9pbnQoIFwibjRcIiwgIHcsICBoLCAtMSApO1xyXG5cclxuXHQvLyBmYXJcclxuXHJcblx0c2V0UG9pbnQoIFwiZjFcIiwgLXcsIC1oLCAxICk7XHJcblx0c2V0UG9pbnQoIFwiZjJcIiwgIHcsIC1oLCAxICk7XHJcblx0c2V0UG9pbnQoIFwiZjNcIiwgLXcsICBoLCAxICk7XHJcblx0c2V0UG9pbnQoIFwiZjRcIiwgIHcsICBoLCAxICk7XHJcblxyXG5cdC8vIHVwXHJcblxyXG5cdHNldFBvaW50KCBcInUxXCIsICB3ICogMC43LCBoICogMS4xLCAtMSApO1xyXG5cdHNldFBvaW50KCBcInUyXCIsIC13ICogMC43LCBoICogMS4xLCAtMSApO1xyXG5cdHNldFBvaW50KCBcInUzXCIsICAgICAgICAwLCBoICogMiwgICAtMSApO1xyXG5cclxuXHQvLyBjcm9zc1xyXG5cclxuXHRzZXRQb2ludCggXCJjZjFcIiwgLXcsICAwLCAxICk7XHJcblx0c2V0UG9pbnQoIFwiY2YyXCIsICB3LCAgMCwgMSApO1xyXG5cdHNldFBvaW50KCBcImNmM1wiLCAgMCwgLWgsIDEgKTtcclxuXHRzZXRQb2ludCggXCJjZjRcIiwgIDAsICBoLCAxICk7XHJcblxyXG5cdHNldFBvaW50KCBcImNuMVwiLCAtdywgIDAsIC0xICk7XHJcblx0c2V0UG9pbnQoIFwiY24yXCIsICB3LCAgMCwgLTEgKTtcclxuXHRzZXRQb2ludCggXCJjbjNcIiwgIDAsIC1oLCAtMSApO1xyXG5cdHNldFBvaW50KCBcImNuNFwiLCAgMCwgIGgsIC0xICk7XHJcblxyXG5cdGZ1bmN0aW9uIHNldFBvaW50KCBwb2ludCwgeCwgeSwgeiApIHtcclxuXHJcblx0XHRUSFJFRS5DYW1lcmFIZWxwZXIuX192LnNldCggeCwgeSwgeiApO1xyXG5cdFx0VEhSRUUuQ2FtZXJhSGVscGVyLl9fcHJvamVjdG9yLnVucHJvamVjdFZlY3RvciggVEhSRUUuQ2FtZXJhSGVscGVyLl9fdiwgVEhSRUUuQ2FtZXJhSGVscGVyLl9fYyApO1xyXG5cclxuXHRcdHZhciBwb2ludHMgPSBzY29wZS5wb2ludE1hcFsgcG9pbnQgXTtcclxuXHJcblx0XHRpZiAoIHBvaW50cyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0c2NvcGUuZ2VvbWV0cnkudmVydGljZXNbIHBvaW50c1sgaSBdIF0uY29weSggVEhSRUUuQ2FtZXJhSGVscGVyLl9fdiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLmdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ2FtZXJhSGVscGVyLl9fcHJvamVjdG9yID0gbmV3IFRIUkVFLlByb2plY3RvcigpO1xyXG5USFJFRS5DYW1lcmFIZWxwZXIuX192ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuVEhSRUUuQ2FtZXJhSGVscGVyLl9fYyA9IG5ldyBUSFJFRS5DYW1lcmEoKTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKlxyXG4gKlx0LSBzaG93cyBkaXJlY3Rpb25hbCBsaWdodCBjb2xvciwgaW50ZW5zaXR5LCBwb3NpdGlvbiwgb3JpZW50YXRpb24gYW5kIHRhcmdldFxyXG4gKi9cclxuXHJcblRIUkVFLkRpcmVjdGlvbmFsTGlnaHRIZWxwZXIgPSBmdW5jdGlvbiAoIGxpZ2h0LCBzcGhlcmVTaXplICkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMubGlnaHQgPSBsaWdodDtcclxuXHJcblx0Ly8gcG9zaXRpb25cclxuXHJcblx0dGhpcy5wb3NpdGlvbiA9IGxpZ2h0LnBvc2l0aW9uO1xyXG5cclxuXHQvLyBkaXJlY3Rpb25cclxuXHJcblx0dGhpcy5kaXJlY3Rpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHRoaXMuZGlyZWN0aW9uLnN1YlZlY3RvcnMoIGxpZ2h0LnRhcmdldC5wb3NpdGlvbiwgbGlnaHQucG9zaXRpb24gKTtcclxuXHJcblx0Ly8gY29sb3JcclxuXHJcblx0dmFyIGludGVuc2l0eSA9IFRIUkVFLk1hdGguY2xhbXAoIGxpZ2h0LmludGVuc2l0eSwgMCwgMSApO1xyXG5cclxuXHR0aGlzLmNvbG9yID0gbGlnaHQuY29sb3IuY2xvbmUoKTtcclxuXHR0aGlzLmNvbG9yLm11bHRpcGx5U2NhbGFyKCBpbnRlbnNpdHkgKTtcclxuXHJcblx0dmFyIGhleENvbG9yID0gdGhpcy5jb2xvci5nZXRIZXgoKTtcclxuXHJcblx0Ly8gbGlnaHQgaGVscGVyXHJcblxyXG5cdHZhciBidWxiR2VvbWV0cnkgPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoIHNwaGVyZVNpemUsIDE2LCA4ICk7XHJcblx0dmFyIHJheXNHZW9tZXRyeSA9IG5ldyBUSFJFRS5Bc3Rlcmlza0dlb21ldHJ5KCBzcGhlcmVTaXplICogMS4yNSwgc3BoZXJlU2l6ZSAqIDIuMjUgKTtcclxuXHJcblx0dmFyIGJ1bGJNYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogaGV4Q29sb3IsIGZvZzogZmFsc2UgfSApO1xyXG5cdHZhciByYXlzTWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGhleENvbG9yLCBmb2c6IGZhbHNlIH0gKTtcclxuXHJcblx0dGhpcy5saWdodFNwaGVyZSA9IG5ldyBUSFJFRS5NZXNoKCBidWxiR2VvbWV0cnksIGJ1bGJNYXRlcmlhbCApO1xyXG5cclxuXHR0aGlzLmxpZ2h0UmF5cyA9IG5ldyBUSFJFRS5MaW5lKCByYXlzR2VvbWV0cnksIHJheXNNYXRlcmlhbCwgVEhSRUUuTGluZVBpZWNlcyApO1xyXG5cclxuXHR0aGlzLmFkZCggdGhpcy5saWdodFNwaGVyZSApO1xyXG5cdHRoaXMuYWRkKCB0aGlzLmxpZ2h0UmF5cyApO1xyXG5cclxuXHR0aGlzLmxpZ2h0U3BoZXJlLnByb3BlcnRpZXMuaXNHaXptbyA9IHRydWU7XHJcblx0dGhpcy5saWdodFNwaGVyZS5wcm9wZXJ0aWVzLmdpem1vU3ViamVjdCA9IGxpZ2h0O1xyXG5cdHRoaXMubGlnaHRTcGhlcmUucHJvcGVydGllcy5naXptb1Jvb3QgPSB0aGlzO1xyXG5cclxuXHQvLyBsaWdodCB0YXJnZXQgaGVscGVyXHJcblxyXG5cdHRoaXMudGFyZ2V0U3BoZXJlID0gbnVsbDtcclxuXHJcblx0aWYgKCBsaWdodC50YXJnZXQucHJvcGVydGllcy50YXJnZXRJbnZlcnNlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0dmFyIHRhcmdldEdlbyA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeSggc3BoZXJlU2l6ZSwgOCwgNCApO1xyXG5cdFx0dmFyIHRhcmdldE1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBoZXhDb2xvciwgd2lyZWZyYW1lOiB0cnVlLCBmb2c6IGZhbHNlIH0gKTtcclxuXHJcblx0XHR0aGlzLnRhcmdldFNwaGVyZSA9IG5ldyBUSFJFRS5NZXNoKCB0YXJnZXRHZW8sIHRhcmdldE1hdGVyaWFsICk7XHJcblx0XHR0aGlzLnRhcmdldFNwaGVyZS5wb3NpdGlvbiA9IGxpZ2h0LnRhcmdldC5wb3NpdGlvbjtcclxuXHJcblx0XHR0aGlzLnRhcmdldFNwaGVyZS5wcm9wZXJ0aWVzLmlzR2l6bW8gPSB0cnVlO1xyXG5cdFx0dGhpcy50YXJnZXRTcGhlcmUucHJvcGVydGllcy5naXptb1N1YmplY3QgPSBsaWdodC50YXJnZXQ7XHJcblx0XHR0aGlzLnRhcmdldFNwaGVyZS5wcm9wZXJ0aWVzLmdpem1vUm9vdCA9IHRoaXMudGFyZ2V0U3BoZXJlO1xyXG5cclxuXHRcdHZhciBsaW5lTWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZURhc2hlZE1hdGVyaWFsKCB7IGNvbG9yOiBoZXhDb2xvciwgZGFzaFNpemU6IDQsIGdhcFNpemU6IDQsIG9wYWNpdHk6IDAuNzUsIHRyYW5zcGFyZW50OiB0cnVlLCBmb2c6IGZhbHNlIH0gKTtcclxuXHRcdHZhciBsaW5lR2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuXHRcdGxpbmVHZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCB0aGlzLnBvc2l0aW9uLmNsb25lKCkgKTtcclxuXHRcdGxpbmVHZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCB0aGlzLnRhcmdldFNwaGVyZS5wb3NpdGlvbi5jbG9uZSgpICk7XHJcblx0XHRsaW5lR2VvbWV0cnkuY29tcHV0ZUxpbmVEaXN0YW5jZXMoKTtcclxuXHJcblx0XHR0aGlzLnRhcmdldExpbmUgPSBuZXcgVEhSRUUuTGluZSggbGluZUdlb21ldHJ5LCBsaW5lTWF0ZXJpYWwgKTtcclxuXHRcdHRoaXMudGFyZ2V0TGluZS5wcm9wZXJ0aWVzLmlzR2l6bW8gPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vXHJcblxyXG5cdHRoaXMucHJvcGVydGllcy5pc0dpem1vID0gdHJ1ZTtcclxuXHJcbn1cclxuXHJcblRIUkVFLkRpcmVjdGlvbmFsTGlnaHRIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5EaXJlY3Rpb25hbExpZ2h0SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdC8vIHVwZGF0ZSBhcnJvdyBvcmllbnRhdGlvblxyXG5cdC8vIHBvaW50aW5nIGZyb20gbGlnaHQgdG8gdGFyZ2V0XHJcblxyXG5cdHRoaXMuZGlyZWN0aW9uLnN1YlZlY3RvcnMoIHRoaXMubGlnaHQudGFyZ2V0LnBvc2l0aW9uLCB0aGlzLmxpZ2h0LnBvc2l0aW9uICk7XHJcblxyXG5cdC8vIHVwZGF0ZSBhcnJvdywgc3BoZXJlcywgcmF5cyBhbmQgbGluZSBjb2xvcnMgdG8gbGlnaHQgY29sb3IgKiBsaWdodCBpbnRlbnNpdHlcclxuXHJcblx0dmFyIGludGVuc2l0eSA9IFRIUkVFLk1hdGguY2xhbXAoIHRoaXMubGlnaHQuaW50ZW5zaXR5LCAwLCAxICk7XHJcblxyXG5cdHRoaXMuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApO1xyXG5cdHRoaXMuY29sb3IubXVsdGlwbHlTY2FsYXIoIGludGVuc2l0eSApO1xyXG5cclxuXHR0aGlzLmxpZ2h0U3BoZXJlLm1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMuY29sb3IgKTtcclxuXHR0aGlzLmxpZ2h0UmF5cy5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmNvbG9yICk7XHJcblxyXG5cdC8vIE9ubHkgdXBkYXRlIHRhcmdldFNwaGVyZSBhbmQgdGFyZ2V0TGluZSBpZiBhdmFpbGFibGVcclxuXHRpZiAoIHRoaXMudGFyZ2V0U3BoZXJlICE9PSBudWxsICkge1xyXG5cclxuXHRcdHRoaXMudGFyZ2V0U3BoZXJlLm1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMuY29sb3IgKTtcclxuXHRcdHRoaXMudGFyZ2V0TGluZS5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmNvbG9yICk7XHJcblxyXG5cdFx0Ly8gdXBkYXRlIHRhcmdldCBsaW5lIHZlcnRpY2VzXHJcblxyXG5cdFx0dGhpcy50YXJnZXRMaW5lLmdlb21ldHJ5LnZlcnRpY2VzWyAwIF0uY29weSggdGhpcy5saWdodC5wb3NpdGlvbiApO1xyXG5cdFx0dGhpcy50YXJnZXRMaW5lLmdlb21ldHJ5LnZlcnRpY2VzWyAxIF0uY29weSggdGhpcy5saWdodC50YXJnZXQucG9zaXRpb24gKTtcclxuXHJcblx0XHR0aGlzLnRhcmdldExpbmUuZ2VvbWV0cnkuY29tcHV0ZUxpbmVEaXN0YW5jZXMoKTtcclxuXHRcdHRoaXMudGFyZ2V0TGluZS5nZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICpcclxuICpcdC0gc2hvd3MgaGVtaXNwaGVyZSBsaWdodCBpbnRlbnNpdHksIHNreSBhbmQgZ3JvdW5kIGNvbG9ycyBhbmQgZGlyZWN0aW9uc1xyXG4gKi9cclxuXHJcblRIUkVFLkhlbWlzcGhlcmVMaWdodEhlbHBlciA9IGZ1bmN0aW9uICggbGlnaHQsIHNwaGVyZVNpemUsIGFycm93TGVuZ3RoLCBkb21lU2l6ZSApIHtcclxuXHJcblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLmxpZ2h0ID0gbGlnaHQ7XHJcblxyXG5cdC8vIHBvc2l0aW9uXHJcblxyXG5cdHRoaXMucG9zaXRpb24gPSBsaWdodC5wb3NpdGlvbjtcclxuXHJcblx0Ly9cclxuXHJcblx0dmFyIGludGVuc2l0eSA9IFRIUkVFLk1hdGguY2xhbXAoIGxpZ2h0LmludGVuc2l0eSwgMCwgMSApO1xyXG5cclxuXHQvLyBza3kgY29sb3JcclxuXHJcblx0dGhpcy5jb2xvciA9IGxpZ2h0LmNvbG9yLmNsb25lKCk7XHJcblx0dGhpcy5jb2xvci5tdWx0aXBseVNjYWxhciggaW50ZW5zaXR5ICk7XHJcblxyXG5cdHZhciBoZXhDb2xvciA9IHRoaXMuY29sb3IuZ2V0SGV4KCk7XHJcblxyXG5cdC8vIGdyb3VuZCBjb2xvclxyXG5cclxuXHR0aGlzLmdyb3VuZENvbG9yID0gbGlnaHQuZ3JvdW5kQ29sb3IuY2xvbmUoKTtcclxuXHR0aGlzLmdyb3VuZENvbG9yLm11bHRpcGx5U2NhbGFyKCBpbnRlbnNpdHkgKTtcclxuXHJcblx0dmFyIGhleENvbG9yR3JvdW5kID0gdGhpcy5ncm91bmRDb2xvci5nZXRIZXgoKTtcclxuXHJcblx0Ly8gZG91YmxlIGNvbG9yZWQgbGlnaHQgYnVsYlxyXG5cclxuXHR2YXIgYnVsYkdlb21ldHJ5ID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KCBzcGhlcmVTaXplLCAxNiwgOCwgMCwgTWF0aC5QSSAqIDIsIDAsIE1hdGguUEkgKiAwLjUgKTtcclxuXHR2YXIgYnVsYkdyb3VuZEdlb21ldHJ5ID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KCBzcGhlcmVTaXplLCAxNiwgOCwgMCwgTWF0aC5QSSAqIDIsIE1hdGguUEkgKiAwLjUsIE1hdGguUEkgKTtcclxuXHJcblx0dmFyIGJ1bGJTa3lNYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogaGV4Q29sb3IsIGZvZzogZmFsc2UgfSApO1xyXG5cdHZhciBidWxiR3JvdW5kTWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGhleENvbG9yR3JvdW5kLCBmb2c6IGZhbHNlIH0gKTtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGJ1bGJHZW9tZXRyeS5mYWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRidWxiR2VvbWV0cnkuZmFjZXNbIGkgXS5tYXRlcmlhbEluZGV4ID0gMDtcclxuXHJcblx0fVxyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gYnVsYkdyb3VuZEdlb21ldHJ5LmZhY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdGJ1bGJHcm91bmRHZW9tZXRyeS5mYWNlc1sgaSBdLm1hdGVyaWFsSW5kZXggPSAxO1xyXG5cclxuXHR9XHJcblxyXG5cdFRIUkVFLkdlb21ldHJ5VXRpbHMubWVyZ2UoIGJ1bGJHZW9tZXRyeSwgYnVsYkdyb3VuZEdlb21ldHJ5ICk7XHJcblxyXG5cdHRoaXMubGlnaHRTcGhlcmUgPSBuZXcgVEhSRUUuTWVzaCggYnVsYkdlb21ldHJ5LCBuZXcgVEhSRUUuTWVzaEZhY2VNYXRlcmlhbCggWyBidWxiU2t5TWF0ZXJpYWwsIGJ1bGJHcm91bmRNYXRlcmlhbCBdICkgKTtcclxuXHJcblx0Ly8gYXJyb3dzIGZvciBza3kgYW5kIGdyb3VuZCBsaWdodCBkaXJlY3Rpb25zXHJcblxyXG5cdHRoaXMubGlnaHRBcnJvdyA9IG5ldyBUSFJFRS5BcnJvd0hlbHBlciggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKSwgbmV3IFRIUkVFLlZlY3RvcjMoIDAsICggc3BoZXJlU2l6ZSArIGFycm93TGVuZ3RoICkgKiAxLjEsIDAgKSwgYXJyb3dMZW5ndGgsIGhleENvbG9yICk7XHJcblx0dGhpcy5saWdodEFycm93LnJvdGF0aW9uLnggPSBNYXRoLlBJO1xyXG5cclxuXHR0aGlzLmxpZ2h0QXJyb3dHcm91bmQgPSBuZXcgVEhSRUUuQXJyb3dIZWxwZXIoIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICksIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAoIHNwaGVyZVNpemUgKyBhcnJvd0xlbmd0aCApICogLTEuMSwgMCApLCBhcnJvd0xlbmd0aCwgaGV4Q29sb3JHcm91bmQgKTtcclxuXHJcblx0dmFyIGpvaW50ID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XHJcblx0am9pbnQucm90YXRpb24ueCA9IC1NYXRoLlBJICogMC41O1xyXG5cclxuXHRqb2ludC5hZGQoIHRoaXMubGlnaHRTcGhlcmUgKTtcclxuXHRqb2ludC5hZGQoIHRoaXMubGlnaHRBcnJvdyApO1xyXG5cdGpvaW50LmFkZCggdGhpcy5saWdodEFycm93R3JvdW5kICk7XHJcblxyXG5cdHRoaXMuYWRkKCBqb2ludCApO1xyXG5cclxuXHQvL1xyXG5cclxuXHR0aGlzLmxpZ2h0U3BoZXJlLnByb3BlcnRpZXMuaXNHaXptbyA9IHRydWU7XHJcblx0dGhpcy5saWdodFNwaGVyZS5wcm9wZXJ0aWVzLmdpem1vU3ViamVjdCA9IGxpZ2h0O1xyXG5cdHRoaXMubGlnaHRTcGhlcmUucHJvcGVydGllcy5naXptb1Jvb3QgPSB0aGlzO1xyXG5cclxuXHQvL1xyXG5cclxuXHR0aGlzLnByb3BlcnRpZXMuaXNHaXptbyA9IHRydWU7XHJcblxyXG5cdC8vXHJcblxyXG5cdHRoaXMudGFyZ2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR0aGlzLmxvb2tBdCggdGhpcy50YXJnZXQgKTtcclxuXHJcbn1cclxuXHJcblRIUkVFLkhlbWlzcGhlcmVMaWdodEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLkhlbWlzcGhlcmVMaWdodEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHQvLyB1cGRhdGUgc3BoZXJlIHNreSBhbmQgZ3JvdW5kIGNvbG9ycyB0byBsaWdodCBjb2xvciAqIGxpZ2h0IGludGVuc2l0eVxyXG5cclxuXHR2YXIgaW50ZW5zaXR5ID0gVEhSRUUuTWF0aC5jbGFtcCggdGhpcy5saWdodC5pbnRlbnNpdHksIDAsIDEgKTtcclxuXHJcblx0dGhpcy5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICk7XHJcblx0dGhpcy5jb2xvci5tdWx0aXBseVNjYWxhciggaW50ZW5zaXR5ICk7XHJcblxyXG5cdHRoaXMuZ3JvdW5kQ29sb3IuY29weSggdGhpcy5saWdodC5ncm91bmRDb2xvciApO1xyXG5cdHRoaXMuZ3JvdW5kQ29sb3IubXVsdGlwbHlTY2FsYXIoIGludGVuc2l0eSApO1xyXG5cclxuXHR0aGlzLmxpZ2h0U3BoZXJlLm1hdGVyaWFsLm1hdGVyaWFsc1sgMCBdLmNvbG9yLmNvcHkoIHRoaXMuY29sb3IgKTtcclxuXHR0aGlzLmxpZ2h0U3BoZXJlLm1hdGVyaWFsLm1hdGVyaWFsc1sgMSBdLmNvbG9yLmNvcHkoIHRoaXMuZ3JvdW5kQ29sb3IgKTtcclxuXHJcblx0dGhpcy5saWdodEFycm93LnNldENvbG9yKCB0aGlzLmNvbG9yLmdldEhleCgpICk7XHJcblx0dGhpcy5saWdodEFycm93R3JvdW5kLnNldENvbG9yKCB0aGlzLmdyb3VuZENvbG9yLmdldEhleCgpICk7XHJcblxyXG5cdHRoaXMubG9va0F0KCB0aGlzLnRhcmdldCApO1xyXG5cclxufVxyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqXHJcbiAqXHQtIHNob3dzIHBvaW50IGxpZ2h0IGNvbG9yLCBpbnRlbnNpdHksIHBvc2l0aW9uIGFuZCBkaXN0YW5jZVxyXG4gKi9cclxuXHJcblRIUkVFLlBvaW50TGlnaHRIZWxwZXIgPSBmdW5jdGlvbiAoIGxpZ2h0LCBzcGhlcmVTaXplICkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMubGlnaHQgPSBsaWdodDtcclxuXHJcblx0Ly8gcG9zaXRpb25cclxuXHJcblx0dGhpcy5wb3NpdGlvbiA9IGxpZ2h0LnBvc2l0aW9uO1xyXG5cclxuXHQvLyBjb2xvclxyXG5cclxuXHR2YXIgaW50ZW5zaXR5ID0gVEhSRUUuTWF0aC5jbGFtcCggbGlnaHQuaW50ZW5zaXR5LCAwLCAxICk7XHJcblxyXG5cdHRoaXMuY29sb3IgPSBsaWdodC5jb2xvci5jbG9uZSgpO1xyXG5cdHRoaXMuY29sb3IubXVsdGlwbHlTY2FsYXIoIGludGVuc2l0eSApO1xyXG5cclxuXHR2YXIgaGV4Q29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpO1xyXG5cclxuXHQvLyBsaWdodCBoZWxwZXJcclxuXHJcblx0dmFyIGJ1bGJHZW9tZXRyeSA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeSggc3BoZXJlU2l6ZSwgMTYsIDggKTtcclxuXHR2YXIgcmF5c0dlb21ldHJ5ID0gbmV3IFRIUkVFLkFzdGVyaXNrR2VvbWV0cnkoIHNwaGVyZVNpemUgKiAxLjI1LCBzcGhlcmVTaXplICogMi4yNSApO1xyXG5cdHZhciBkaXN0YW5jZUdlb21ldHJ5ID0gbmV3IFRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkoIDEsIDIgKTtcclxuXHJcblx0dmFyIGJ1bGJNYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogaGV4Q29sb3IsIGZvZzogZmFsc2UgfSApO1xyXG5cdHZhciByYXlzTWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGhleENvbG9yLCBmb2c6IGZhbHNlIH0gKTtcclxuXHR2YXIgZGlzdGFuY2VNYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogaGV4Q29sb3IsIGZvZzogZmFsc2UsIHdpcmVmcmFtZTogdHJ1ZSwgb3BhY2l0eTogMC4xLCB0cmFuc3BhcmVudDogdHJ1ZSB9ICk7XHJcblxyXG5cdHRoaXMubGlnaHRTcGhlcmUgPSBuZXcgVEhSRUUuTWVzaCggYnVsYkdlb21ldHJ5LCBidWxiTWF0ZXJpYWwgKTtcclxuXHR0aGlzLmxpZ2h0UmF5cyA9IG5ldyBUSFJFRS5MaW5lKCByYXlzR2VvbWV0cnksIHJheXNNYXRlcmlhbCwgVEhSRUUuTGluZVBpZWNlcyApO1xyXG5cdHRoaXMubGlnaHREaXN0YW5jZSA9IG5ldyBUSFJFRS5NZXNoKCBkaXN0YW5jZUdlb21ldHJ5LCBkaXN0YW5jZU1hdGVyaWFsICk7XHJcblxyXG5cdHZhciBkID0gbGlnaHQuZGlzdGFuY2U7XHJcblxyXG5cdGlmICggZCA9PT0gMC4wICkge1xyXG5cclxuXHRcdHRoaXMubGlnaHREaXN0YW5jZS52aXNpYmxlID0gZmFsc2U7XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0dGhpcy5saWdodERpc3RhbmNlLnNjYWxlLnNldCggZCwgZCwgZCApO1xyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMuYWRkKCB0aGlzLmxpZ2h0U3BoZXJlICk7XHJcblx0dGhpcy5hZGQoIHRoaXMubGlnaHRSYXlzICk7XHJcblx0dGhpcy5hZGQoIHRoaXMubGlnaHREaXN0YW5jZSApO1xyXG5cclxuXHQvL1xyXG5cclxuXHR0aGlzLmxpZ2h0U3BoZXJlLnByb3BlcnRpZXMuaXNHaXptbyA9IHRydWU7XHJcblx0dGhpcy5saWdodFNwaGVyZS5wcm9wZXJ0aWVzLmdpem1vU3ViamVjdCA9IGxpZ2h0O1xyXG5cdHRoaXMubGlnaHRTcGhlcmUucHJvcGVydGllcy5naXptb1Jvb3QgPSB0aGlzO1xyXG5cclxuXHQvL1xyXG5cclxuXHR0aGlzLnByb3BlcnRpZXMuaXNHaXptbyA9IHRydWU7XHJcblxyXG59XHJcblxyXG5USFJFRS5Qb2ludExpZ2h0SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuUG9pbnRMaWdodEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHQvLyB1cGRhdGUgc3BoZXJlIGFuZCByYXlzIGNvbG9ycyB0byBsaWdodCBjb2xvciAqIGxpZ2h0IGludGVuc2l0eVxyXG5cclxuXHR2YXIgaW50ZW5zaXR5ID0gVEhSRUUuTWF0aC5jbGFtcCggdGhpcy5saWdodC5pbnRlbnNpdHksIDAsIDEgKTtcclxuXHJcblx0dGhpcy5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICk7XHJcblx0dGhpcy5jb2xvci5tdWx0aXBseVNjYWxhciggaW50ZW5zaXR5ICk7XHJcblxyXG5cdHRoaXMubGlnaHRTcGhlcmUubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5jb2xvciApO1xyXG5cdHRoaXMubGlnaHRSYXlzLm1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMuY29sb3IgKTtcclxuXHR0aGlzLmxpZ2h0RGlzdGFuY2UubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5jb2xvciApO1xyXG5cclxuXHQvL1xyXG5cclxuXHR2YXIgZCA9IHRoaXMubGlnaHQuZGlzdGFuY2U7XHJcblxyXG5cdGlmICggZCA9PT0gMC4wICkge1xyXG5cclxuXHRcdHRoaXMubGlnaHREaXN0YW5jZS52aXNpYmxlID0gZmFsc2U7XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0dGhpcy5saWdodERpc3RhbmNlLnZpc2libGUgPSB0cnVlO1xyXG5cdFx0dGhpcy5saWdodERpc3RhbmNlLnNjYWxlLnNldCggZCwgZCwgZCApO1xyXG5cclxuXHR9XHJcblxyXG59XHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICpcclxuICpcdC0gc2hvd3Mgc3BvdCBsaWdodCBjb2xvciwgaW50ZW5zaXR5LCBwb3NpdGlvbiwgb3JpZW50YXRpb24sIGxpZ2h0IGNvbmUgYW5kIHRhcmdldFxyXG4gKi9cclxuXHJcblRIUkVFLlNwb3RMaWdodEhlbHBlciA9IGZ1bmN0aW9uICggbGlnaHQsIHNwaGVyZVNpemUgKSB7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy5saWdodCA9IGxpZ2h0O1xyXG5cclxuXHQvLyBwb3NpdGlvblxyXG5cclxuXHR0aGlzLnBvc2l0aW9uID0gbGlnaHQucG9zaXRpb247XHJcblxyXG5cdC8vIGRpcmVjdGlvblxyXG5cclxuXHR0aGlzLmRpcmVjdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dGhpcy5kaXJlY3Rpb24uc3ViVmVjdG9ycyggbGlnaHQudGFyZ2V0LnBvc2l0aW9uLCBsaWdodC5wb3NpdGlvbiApO1xyXG5cclxuXHQvLyBjb2xvclxyXG5cclxuXHR2YXIgaW50ZW5zaXR5ID0gVEhSRUUuTWF0aC5jbGFtcCggbGlnaHQuaW50ZW5zaXR5LCAwLCAxICk7XHJcblxyXG5cdHRoaXMuY29sb3IgPSBsaWdodC5jb2xvci5jbG9uZSgpO1xyXG5cdHRoaXMuY29sb3IubXVsdGlwbHlTY2FsYXIoIGludGVuc2l0eSApO1xyXG5cclxuXHR2YXIgaGV4Q29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpO1xyXG5cclxuXHQvLyBsaWdodCBoZWxwZXJcclxuXHJcblx0dmFyIGJ1bGJHZW9tZXRyeSA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeSggc3BoZXJlU2l6ZSwgMTYsIDggKTtcclxuXHR2YXIgcmF5c0dlb21ldHJ5ID0gbmV3IFRIUkVFLkFzdGVyaXNrR2VvbWV0cnkoIHNwaGVyZVNpemUgKiAxLjI1LCBzcGhlcmVTaXplICogMi4yNSApO1xyXG5cdHZhciBjb25lR2VvbWV0cnkgPSBuZXcgVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeSggMC4wMDAxLCAxLCAxLCA4LCAxLCB0cnVlICk7XHJcblxyXG5cdHZhciBjb25lTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHRjb25lTWF0cml4LnJvdGF0ZVgoIC1NYXRoLlBJLzIgKTtcclxuXHRjb25lTWF0cml4LnRyYW5zbGF0ZSggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIC0wLjUsIDAgKSApO1xyXG5cdGNvbmVHZW9tZXRyeS5hcHBseU1hdHJpeCggY29uZU1hdHJpeCApO1xyXG5cclxuXHR2YXIgYnVsYk1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBoZXhDb2xvciwgZm9nOiBmYWxzZSB9ICk7XHJcblx0dmFyIHJheXNNYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogaGV4Q29sb3IsIGZvZzogZmFsc2UgfSApO1xyXG5cdHZhciBjb25lTWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGhleENvbG9yLCBmb2c6IGZhbHNlLCB3aXJlZnJhbWU6IHRydWUsIG9wYWNpdHk6IDAuMywgdHJhbnNwYXJlbnQ6IHRydWUgfSApO1xyXG5cclxuXHR0aGlzLmxpZ2h0U3BoZXJlID0gbmV3IFRIUkVFLk1lc2goIGJ1bGJHZW9tZXRyeSwgYnVsYk1hdGVyaWFsICk7XHJcblx0dGhpcy5saWdodENvbmUgPSBuZXcgVEhSRUUuTWVzaCggY29uZUdlb21ldHJ5LCBjb25lTWF0ZXJpYWwgKTtcclxuXHJcblx0dmFyIGNvbmVMZW5ndGggPSBsaWdodC5kaXN0YW5jZSA/IGxpZ2h0LmRpc3RhbmNlIDogMTAwMDA7XHJcblx0dmFyIGNvbmVXaWR0aCA9IGNvbmVMZW5ndGggKiBNYXRoLnRhbiggbGlnaHQuYW5nbGUgKiAwLjUgKSAqIDI7XHJcblx0dGhpcy5saWdodENvbmUuc2NhbGUuc2V0KCBjb25lV2lkdGgsIGNvbmVXaWR0aCwgY29uZUxlbmd0aCApO1xyXG5cclxuXHR0aGlzLmxpZ2h0UmF5cyA9IG5ldyBUSFJFRS5MaW5lKCByYXlzR2VvbWV0cnksIHJheXNNYXRlcmlhbCwgVEhSRUUuTGluZVBpZWNlcyApO1xyXG5cclxuXHR0aGlzLmd5cm9zY29wZSA9IG5ldyBUSFJFRS5HeXJvc2NvcGUoKTtcclxuXHJcblx0dGhpcy5neXJvc2NvcGUuYWRkKCB0aGlzLmxpZ2h0U3BoZXJlICk7XHJcblx0dGhpcy5neXJvc2NvcGUuYWRkKCB0aGlzLmxpZ2h0UmF5cyApO1xyXG5cclxuXHR0aGlzLmFkZCggdGhpcy5neXJvc2NvcGUgKTtcclxuXHR0aGlzLmFkZCggdGhpcy5saWdodENvbmUgKTtcclxuXHJcblx0dGhpcy5sb29rQXQoIGxpZ2h0LnRhcmdldC5wb3NpdGlvbiApO1xyXG5cclxuXHR0aGlzLmxpZ2h0U3BoZXJlLnByb3BlcnRpZXMuaXNHaXptbyA9IHRydWU7XHJcblx0dGhpcy5saWdodFNwaGVyZS5wcm9wZXJ0aWVzLmdpem1vU3ViamVjdCA9IGxpZ2h0O1xyXG5cdHRoaXMubGlnaHRTcGhlcmUucHJvcGVydGllcy5naXptb1Jvb3QgPSB0aGlzO1xyXG5cclxuXHQvLyBsaWdodCB0YXJnZXQgaGVscGVyXHJcblxyXG5cdHRoaXMudGFyZ2V0U3BoZXJlID0gbnVsbDtcclxuXHJcblx0aWYgKCBsaWdodC50YXJnZXQucHJvcGVydGllcy50YXJnZXRJbnZlcnNlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0dmFyIHRhcmdldEdlbyA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeSggc3BoZXJlU2l6ZSwgOCwgNCApO1xyXG5cdFx0dmFyIHRhcmdldE1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBoZXhDb2xvciwgd2lyZWZyYW1lOiB0cnVlLCBmb2c6IGZhbHNlIH0gKTtcclxuXHJcblx0XHR0aGlzLnRhcmdldFNwaGVyZSA9IG5ldyBUSFJFRS5NZXNoKCB0YXJnZXRHZW8sIHRhcmdldE1hdGVyaWFsICk7XHJcblx0XHR0aGlzLnRhcmdldFNwaGVyZS5wb3NpdGlvbiA9IGxpZ2h0LnRhcmdldC5wb3NpdGlvbjtcclxuXHJcblx0XHR0aGlzLnRhcmdldFNwaGVyZS5wcm9wZXJ0aWVzLmlzR2l6bW8gPSB0cnVlO1xyXG5cdFx0dGhpcy50YXJnZXRTcGhlcmUucHJvcGVydGllcy5naXptb1N1YmplY3QgPSBsaWdodC50YXJnZXQ7XHJcblx0XHR0aGlzLnRhcmdldFNwaGVyZS5wcm9wZXJ0aWVzLmdpem1vUm9vdCA9IHRoaXMudGFyZ2V0U3BoZXJlO1xyXG5cclxuXHRcdHZhciBsaW5lTWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZURhc2hlZE1hdGVyaWFsKCB7IGNvbG9yOiBoZXhDb2xvciwgZGFzaFNpemU6IDQsIGdhcFNpemU6IDQsIG9wYWNpdHk6IDAuNzUsIHRyYW5zcGFyZW50OiB0cnVlLCBmb2c6IGZhbHNlIH0gKTtcclxuXHRcdHZhciBsaW5lR2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuXHRcdGxpbmVHZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCB0aGlzLnBvc2l0aW9uLmNsb25lKCkgKTtcclxuXHRcdGxpbmVHZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCB0aGlzLnRhcmdldFNwaGVyZS5wb3NpdGlvbi5jbG9uZSgpICk7XHJcblx0XHRsaW5lR2VvbWV0cnkuY29tcHV0ZUxpbmVEaXN0YW5jZXMoKTtcclxuXHJcblx0XHR0aGlzLnRhcmdldExpbmUgPSBuZXcgVEhSRUUuTGluZSggbGluZUdlb21ldHJ5LCBsaW5lTWF0ZXJpYWwgKTtcclxuXHRcdHRoaXMudGFyZ2V0TGluZS5wcm9wZXJ0aWVzLmlzR2l6bW8gPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vXHJcblxyXG5cdHRoaXMucHJvcGVydGllcy5pc0dpem1vID0gdHJ1ZTtcclxuXHJcbn1cclxuXHJcblRIUkVFLlNwb3RMaWdodEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLlNwb3RMaWdodEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHQvLyB1cGRhdGUgYXJyb3cgb3JpZW50YXRpb25cclxuXHQvLyBwb2ludGluZyBmcm9tIGxpZ2h0IHRvIHRhcmdldFxyXG5cclxuXHR0aGlzLmRpcmVjdGlvbi5zdWJWZWN0b3JzKCB0aGlzLmxpZ2h0LnRhcmdldC5wb3NpdGlvbiwgdGhpcy5saWdodC5wb3NpdGlvbiApO1xyXG5cclxuXHQvLyB1cGRhdGUgbGlnaHQgY29uZSBvcmllbnRhdGlvbiBhbmQgc2l6ZVxyXG5cclxuXHR0aGlzLmxvb2tBdCggdGhpcy5saWdodC50YXJnZXQucG9zaXRpb24gKTtcclxuXHJcblx0dmFyIGNvbmVMZW5ndGggPSB0aGlzLmxpZ2h0LmRpc3RhbmNlID8gdGhpcy5saWdodC5kaXN0YW5jZSA6IDEwMDAwO1xyXG5cdHZhciBjb25lV2lkdGggPSBjb25lTGVuZ3RoICogTWF0aC50YW4oIHRoaXMubGlnaHQuYW5nbGUgKiAwLjUgKSAqIDI7XHJcblx0dGhpcy5saWdodENvbmUuc2NhbGUuc2V0KCBjb25lV2lkdGgsIGNvbmVXaWR0aCwgY29uZUxlbmd0aCApO1xyXG5cclxuXHQvLyB1cGRhdGUgYXJyb3csIHNwaGVyZXMsIHJheXMgYW5kIGxpbmUgY29sb3JzIHRvIGxpZ2h0IGNvbG9yICogbGlnaHQgaW50ZW5zaXR5XHJcblxyXG5cdHZhciBpbnRlbnNpdHkgPSBUSFJFRS5NYXRoLmNsYW1wKCB0aGlzLmxpZ2h0LmludGVuc2l0eSwgMCwgMSApO1xyXG5cclxuXHR0aGlzLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKTtcclxuXHR0aGlzLmNvbG9yLm11bHRpcGx5U2NhbGFyKCBpbnRlbnNpdHkgKTtcclxuXHJcblx0dGhpcy5saWdodFNwaGVyZS5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmNvbG9yICk7XHJcblx0dGhpcy5saWdodFJheXMubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5jb2xvciApO1xyXG5cdHRoaXMubGlnaHRDb25lLm1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMuY29sb3IgKTtcclxuXHJcblx0Ly8gT25seSB1cGRhdGUgdGFyZ2V0U3BoZXJlIGFuZCB0YXJnZXRMaW5lIGlmIGF2YWlsYWJsZVxyXG5cdGlmICggdGhpcy50YXJnZXRTcGhlcmUgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0dGhpcy50YXJnZXRTcGhlcmUubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5jb2xvciApO1xyXG5cdFx0dGhpcy50YXJnZXRMaW5lLm1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMuY29sb3IgKTtcclxuXHJcblx0XHQvLyB1cGRhdGUgdGFyZ2V0IGxpbmUgdmVydGljZXNcclxuXHJcblx0XHR0aGlzLnRhcmdldExpbmUuZ2VvbWV0cnkudmVydGljZXNbIDAgXS5jb3B5KCB0aGlzLmxpZ2h0LnBvc2l0aW9uICk7XHJcblx0XHR0aGlzLnRhcmdldExpbmUuZ2VvbWV0cnkudmVydGljZXNbIDEgXS5jb3B5KCB0aGlzLmxpZ2h0LnRhcmdldC5wb3NpdGlvbiApO1xyXG5cclxuXHRcdHRoaXMudGFyZ2V0TGluZS5nZW9tZXRyeS5jb21wdXRlTGluZURpc3RhbmNlcygpO1xyXG5cdFx0dGhpcy50YXJnZXRMaW5lLmdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkltbWVkaWF0ZVJlbmRlck9iamVjdCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggcmVuZGVyQ2FsbGJhY2sgKSB7IH07XHJcblxyXG59O1xyXG5cclxuVEhSRUUuSW1tZWRpYXRlUmVuZGVyT2JqZWN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG4vKipcclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5MZW5zRmxhcmUgPSBmdW5jdGlvbiAoIHRleHR1cmUsIHNpemUsIGRpc3RhbmNlLCBibGVuZGluZywgY29sb3IgKSB7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy5sZW5zRmxhcmVzID0gW107XHJcblxyXG5cdHRoaXMucG9zaXRpb25TY3JlZW4gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHRoaXMuY3VzdG9tVXBkYXRlQ2FsbGJhY2sgPSB1bmRlZmluZWQ7XHJcblxyXG5cdGlmKCB0ZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0dGhpcy5hZGQoIHRleHR1cmUsIHNpemUsIGRpc3RhbmNlLCBibGVuZGluZywgY29sb3IgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLkxlbnNGbGFyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuXHJcblxyXG4vKlxyXG4gKiBBZGQ6IGFkZHMgYW5vdGhlciBmbGFyZVxyXG4gKi9cclxuXHJcblRIUkVFLkxlbnNGbGFyZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKCB0ZXh0dXJlLCBzaXplLCBkaXN0YW5jZSwgYmxlbmRpbmcsIGNvbG9yLCBvcGFjaXR5ICkge1xyXG5cclxuXHRpZiggc2l6ZSA9PT0gdW5kZWZpbmVkICkgc2l6ZSA9IC0xO1xyXG5cdGlmKCBkaXN0YW5jZSA9PT0gdW5kZWZpbmVkICkgZGlzdGFuY2UgPSAwO1xyXG5cdGlmKCBvcGFjaXR5ID09PSB1bmRlZmluZWQgKSBvcGFjaXR5ID0gMTtcclxuXHRpZiggY29sb3IgPT09IHVuZGVmaW5lZCApIGNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApO1xyXG5cdGlmKCBibGVuZGluZyA9PT0gdW5kZWZpbmVkICkgYmxlbmRpbmcgPSBUSFJFRS5Ob3JtYWxCbGVuZGluZztcclxuXHJcblx0ZGlzdGFuY2UgPSBNYXRoLm1pbiggZGlzdGFuY2UsIE1hdGgubWF4KCAwLCBkaXN0YW5jZSApICk7XHJcblxyXG5cdHRoaXMubGVuc0ZsYXJlcy5wdXNoKCB7IHRleHR1cmU6IHRleHR1cmUsIFx0XHRcdC8vIFRIUkVFLlRleHR1cmVcclxuXHRcdCAgICAgICAgICAgICAgICAgICAgc2l6ZTogc2l6ZSwgXHRcdFx0XHQvLyBzaXplIGluIHBpeGVscyAoLTEgPSB1c2UgdGV4dHVyZS53aWR0aClcclxuXHRcdCAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2U6IGRpc3RhbmNlLCBcdFx0Ly8gZGlzdGFuY2UgKDAtMSkgZnJvbSBsaWdodCBzb3VyY2UgKDA9YXQgbGlnaHQgc291cmNlKVxyXG5cdFx0ICAgICAgICAgICAgICAgICAgICB4OiAwLCB5OiAwLCB6OiAwLFx0XHRcdC8vIHNjcmVlbiBwb3NpdGlvbiAoLTEgPT4gMSkgeiA9IDAgaXMgb250b3AgeiA9IDEgaXMgYmFja1xyXG5cdFx0ICAgICAgICAgICAgICAgICAgICBzY2FsZTogMSwgXHRcdFx0XHRcdC8vIHNjYWxlXHJcblx0XHQgICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uOiAxLCBcdFx0XHRcdC8vIHJvdGF0aW9uXHJcblx0XHQgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IG9wYWNpdHksXHRcdFx0Ly8gb3BhY2l0eVxyXG5cdFx0XHRcdFx0XHRcdGNvbG9yOiBjb2xvcixcdFx0XHRcdC8vIGNvbG9yXHJcblx0XHQgICAgICAgICAgICAgICAgICAgIGJsZW5kaW5nOiBibGVuZGluZyB9ICk7XHRcdC8vIGJsZW5kaW5nXHJcblxyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFVwZGF0ZSBsZW5zIGZsYXJlcyB1cGRhdGUgcG9zaXRpb25zIG9uIGFsbCBmbGFyZXMgYmFzZWQgb24gdGhlIHNjcmVlbiBwb3NpdGlvblxyXG4gKiBTZXQgbXlMZW5zRmxhcmUuY3VzdG9tVXBkYXRlQ2FsbGJhY2sgdG8gYWx0ZXIgdGhlIGZsYXJlcyBpbiB5b3VyIHByb2plY3Qgc3BlY2lmaWMgd2F5LlxyXG4gKi9cclxuXHJcblRIUkVFLkxlbnNGbGFyZS5wcm90b3R5cGUudXBkYXRlTGVuc0ZsYXJlcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIGYsIGZsID0gdGhpcy5sZW5zRmxhcmVzLmxlbmd0aDtcclxuXHR2YXIgZmxhcmU7XHJcblx0dmFyIHZlY1ggPSAtdGhpcy5wb3NpdGlvblNjcmVlbi54ICogMjtcclxuXHR2YXIgdmVjWSA9IC10aGlzLnBvc2l0aW9uU2NyZWVuLnkgKiAyO1xyXG5cclxuXHRmb3IoIGYgPSAwOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0ZmxhcmUgPSB0aGlzLmxlbnNGbGFyZXNbIGYgXTtcclxuXHJcblx0XHRmbGFyZS54ID0gdGhpcy5wb3NpdGlvblNjcmVlbi54ICsgdmVjWCAqIGZsYXJlLmRpc3RhbmNlO1xyXG5cdFx0ZmxhcmUueSA9IHRoaXMucG9zaXRpb25TY3JlZW4ueSArIHZlY1kgKiBmbGFyZS5kaXN0YW5jZTtcclxuXHJcblx0XHRmbGFyZS53YW50ZWRSb3RhdGlvbiA9IGZsYXJlLnggKiBNYXRoLlBJICogMC4yNTtcclxuXHRcdGZsYXJlLnJvdGF0aW9uICs9ICggZmxhcmUud2FudGVkUm90YXRpb24gLSBmbGFyZS5yb3RhdGlvbiApICogMC4yNTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2ggPSBmdW5jdGlvbiggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xyXG5cclxuXHRUSFJFRS5NZXNoLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cclxuXHR0aGlzLmFuaW1hdGlvbnNNYXAgPSB7fTtcclxuXHR0aGlzLmFuaW1hdGlvbnNMaXN0ID0gW107XHJcblxyXG5cdC8vIHByZXBhcmUgZGVmYXVsdCBhbmltYXRpb25cclxuXHQvLyAoYWxsIGZyYW1lcyBwbGF5ZWQgdG9nZXRoZXIgaW4gMSBzZWNvbmQpXHJcblxyXG5cdHZhciBudW1GcmFtZXMgPSB0aGlzLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGg7XHJcblxyXG5cdHZhciBuYW1lID0gXCJfX2RlZmF1bHRcIjtcclxuXHJcblx0dmFyIHN0YXJ0RnJhbWUgPSAwO1xyXG5cdHZhciBlbmRGcmFtZSA9IG51bUZyYW1lcyAtIDE7XHJcblxyXG5cdHZhciBmcHMgPSBudW1GcmFtZXMgLyAxO1xyXG5cclxuXHR0aGlzLmNyZWF0ZUFuaW1hdGlvbiggbmFtZSwgc3RhcnRGcmFtZSwgZW5kRnJhbWUsIGZwcyApO1xyXG5cdHRoaXMuc2V0QW5pbWF0aW9uV2VpZ2h0KCBuYW1lLCAxICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWVzaC5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5jcmVhdGVBbmltYXRpb24gPSBmdW5jdGlvbiAoIG5hbWUsIHN0YXJ0LCBlbmQsIGZwcyApIHtcclxuXHJcblx0dmFyIGFuaW1hdGlvbiA9IHtcclxuXHJcblx0XHRzdGFydEZyYW1lOiBzdGFydCxcclxuXHRcdGVuZEZyYW1lOiBlbmQsXHJcblxyXG5cdFx0bGVuZ3RoOiBlbmQgLSBzdGFydCArIDEsXHJcblxyXG5cdFx0ZnBzOiBmcHMsXHJcblx0XHRkdXJhdGlvbjogKCBlbmQgLSBzdGFydCApIC8gZnBzLFxyXG5cclxuXHRcdGxhc3RGcmFtZTogMCxcclxuXHRcdGN1cnJlbnRGcmFtZTogMCxcclxuXHJcblx0XHRhY3RpdmU6IGZhbHNlLFxyXG5cclxuXHRcdHRpbWU6IDAsXHJcblx0XHRkaXJlY3Rpb246IDEsXHJcblx0XHR3ZWlnaHQ6IDEsXHJcblxyXG5cdFx0ZGlyZWN0aW9uQmFja3dhcmRzOiBmYWxzZSxcclxuXHRcdG1pcnJvcmVkTG9vcDogZmFsc2VcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF0gPSBhbmltYXRpb247XHJcblx0dGhpcy5hbmltYXRpb25zTGlzdC5wdXNoKCBhbmltYXRpb24gKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuYXV0b0NyZWF0ZUFuaW1hdGlvbnMgPSBmdW5jdGlvbiAoIGZwcyApIHtcclxuXHJcblx0dmFyIHBhdHRlcm4gPSAvKFthLXpdKykoXFxkKykvO1xyXG5cclxuXHR2YXIgZmlyc3RBbmltYXRpb24sIGZyYW1lUmFuZ2VzID0ge307XHJcblxyXG5cdHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgaWwgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0dmFyIG1vcnBoID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF07XHJcblx0XHR2YXIgY2h1bmtzID0gbW9ycGgubmFtZS5tYXRjaCggcGF0dGVybiApO1xyXG5cclxuXHRcdGlmICggY2h1bmtzICYmIGNodW5rcy5sZW5ndGggPiAxICkge1xyXG5cclxuXHRcdFx0dmFyIG5hbWUgPSBjaHVua3NbIDEgXTtcclxuXHRcdFx0dmFyIG51bSA9IGNodW5rc1sgMiBdO1xyXG5cclxuXHRcdFx0aWYgKCAhIGZyYW1lUmFuZ2VzWyBuYW1lIF0gKSBmcmFtZVJhbmdlc1sgbmFtZSBdID0geyBzdGFydDogSW5maW5pdHksIGVuZDogLUluZmluaXR5IH07XHJcblxyXG5cdFx0XHR2YXIgcmFuZ2UgPSBmcmFtZVJhbmdlc1sgbmFtZSBdO1xyXG5cclxuXHRcdFx0aWYgKCBpIDwgcmFuZ2Uuc3RhcnQgKSByYW5nZS5zdGFydCA9IGk7XHJcblx0XHRcdGlmICggaSA+IHJhbmdlLmVuZCApIHJhbmdlLmVuZCA9IGk7XHJcblxyXG5cdFx0XHRpZiAoICEgZmlyc3RBbmltYXRpb24gKSBmaXJzdEFuaW1hdGlvbiA9IG5hbWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZvciAoIHZhciBuYW1lIGluIGZyYW1lUmFuZ2VzICkge1xyXG5cclxuXHRcdHZhciByYW5nZSA9IGZyYW1lUmFuZ2VzWyBuYW1lIF07XHJcblx0XHR0aGlzLmNyZWF0ZUFuaW1hdGlvbiggbmFtZSwgcmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCwgZnBzICk7XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5maXJzdEFuaW1hdGlvbiA9IGZpcnN0QW5pbWF0aW9uO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zZXRBbmltYXRpb25EaXJlY3Rpb25Gb3J3YXJkID0gZnVuY3Rpb24gKCBuYW1lICkge1xyXG5cclxuXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG5cdGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuXHRcdGFuaW1hdGlvbi5kaXJlY3Rpb24gPSAxO1xyXG5cdFx0YW5pbWF0aW9uLmRpcmVjdGlvbkJhY2t3YXJkcyA9IGZhbHNlO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkRpcmVjdGlvbkJhY2t3YXJkID0gZnVuY3Rpb24gKCBuYW1lICkge1xyXG5cclxuXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG5cdGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuXHRcdGFuaW1hdGlvbi5kaXJlY3Rpb24gPSAtMTtcclxuXHRcdGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkZQUyA9IGZ1bmN0aW9uICggbmFtZSwgZnBzICkge1xyXG5cclxuXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG5cdGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuXHRcdGFuaW1hdGlvbi5mcHMgPSBmcHM7XHJcblx0XHRhbmltYXRpb24uZHVyYXRpb24gPSAoIGFuaW1hdGlvbi5lbmQgLSBhbmltYXRpb24uc3RhcnQgKSAvIGFuaW1hdGlvbi5mcHM7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uRHVyYXRpb24gPSBmdW5jdGlvbiAoIG5hbWUsIGR1cmF0aW9uICkge1xyXG5cclxuXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG5cdGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuXHRcdGFuaW1hdGlvbi5kdXJhdGlvbiA9IGR1cmF0aW9uO1xyXG5cdFx0YW5pbWF0aW9uLmZwcyA9ICggYW5pbWF0aW9uLmVuZCAtIGFuaW1hdGlvbi5zdGFydCApIC8gYW5pbWF0aW9uLmR1cmF0aW9uO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbldlaWdodCA9IGZ1bmN0aW9uICggbmFtZSwgd2VpZ2h0ICkge1xyXG5cclxuXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG5cdGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuXHRcdGFuaW1hdGlvbi53ZWlnaHQgPSB3ZWlnaHQ7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uVGltZSA9IGZ1bmN0aW9uICggbmFtZSwgdGltZSApIHtcclxuXHJcblx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xyXG5cclxuXHRpZiAoIGFuaW1hdGlvbiApIHtcclxuXHJcblx0XHRhbmltYXRpb24udGltZSA9IHRpbWU7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuZ2V0QW5pbWF0aW9uVGltZSA9IGZ1bmN0aW9uICggbmFtZSApIHtcclxuXHJcblx0dmFyIHRpbWUgPSAwO1xyXG5cclxuXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG5cdGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuXHRcdHRpbWUgPSBhbmltYXRpb24udGltZTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGltZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuZ2V0QW5pbWF0aW9uRHVyYXRpb24gPSBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG5cdHZhciBkdXJhdGlvbiA9IC0xO1xyXG5cclxuXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG5cdGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuXHRcdGR1cmF0aW9uID0gYW5pbWF0aW9uLmR1cmF0aW9uO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBkdXJhdGlvbjtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUucGxheUFuaW1hdGlvbiA9IGZ1bmN0aW9uICggbmFtZSApIHtcclxuXHJcblx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xyXG5cclxuXHRpZiAoIGFuaW1hdGlvbiApIHtcclxuXHJcblx0XHRhbmltYXRpb24udGltZSA9IDA7XHJcblx0XHRhbmltYXRpb24uYWN0aXZlID0gdHJ1ZTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oIFwiYW5pbWF0aW9uW1wiICsgbmFtZSArIFwiXSB1bmRlZmluZWRcIiApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnN0b3BBbmltYXRpb24gPSBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG5cdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcclxuXHJcblx0aWYgKCBhbmltYXRpb24gKSB7XHJcblxyXG5cdFx0YW5pbWF0aW9uLmFjdGl2ZSA9IGZhbHNlO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICggZGVsdGEgKSB7XHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgaWwgPSB0aGlzLmFuaW1hdGlvbnNMaXN0Lmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNMaXN0WyBpIF07XHJcblxyXG5cdFx0aWYgKCAhIGFuaW1hdGlvbi5hY3RpdmUgKSBjb250aW51ZTtcclxuXHJcblx0XHR2YXIgZnJhbWVUaW1lID0gYW5pbWF0aW9uLmR1cmF0aW9uIC8gYW5pbWF0aW9uLmxlbmd0aDtcclxuXHJcblx0XHRhbmltYXRpb24udGltZSArPSBhbmltYXRpb24uZGlyZWN0aW9uICogZGVsdGE7XHJcblxyXG5cdFx0aWYgKCBhbmltYXRpb24ubWlycm9yZWRMb29wICkge1xyXG5cclxuXHRcdFx0aWYgKCBhbmltYXRpb24udGltZSA+IGFuaW1hdGlvbi5kdXJhdGlvbiB8fCBhbmltYXRpb24udGltZSA8IDAgKSB7XHJcblxyXG5cdFx0XHRcdGFuaW1hdGlvbi5kaXJlY3Rpb24gKj0gLTE7XHJcblxyXG5cdFx0XHRcdGlmICggYW5pbWF0aW9uLnRpbWUgPiBhbmltYXRpb24uZHVyYXRpb24gKSB7XHJcblxyXG5cdFx0XHRcdFx0YW5pbWF0aW9uLnRpbWUgPSBhbmltYXRpb24uZHVyYXRpb247XHJcblx0XHRcdFx0XHRhbmltYXRpb24uZGlyZWN0aW9uQmFja3dhcmRzID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIGFuaW1hdGlvbi50aW1lIDwgMCApIHtcclxuXHJcblx0XHRcdFx0XHRhbmltYXRpb24udGltZSA9IDA7XHJcblx0XHRcdFx0XHRhbmltYXRpb24uZGlyZWN0aW9uQmFja3dhcmRzID0gZmFsc2U7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0YW5pbWF0aW9uLnRpbWUgPSBhbmltYXRpb24udGltZSAlIGFuaW1hdGlvbi5kdXJhdGlvbjtcclxuXHJcblx0XHRcdGlmICggYW5pbWF0aW9uLnRpbWUgPCAwICkgYW5pbWF0aW9uLnRpbWUgKz0gYW5pbWF0aW9uLmR1cmF0aW9uO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIga2V5ZnJhbWUgPSBhbmltYXRpb24uc3RhcnRGcmFtZSArIFRIUkVFLk1hdGguY2xhbXAoIE1hdGguZmxvb3IoIGFuaW1hdGlvbi50aW1lIC8gZnJhbWVUaW1lICksIDAsIGFuaW1hdGlvbi5sZW5ndGggLSAxICk7XHJcblx0XHR2YXIgd2VpZ2h0ID0gYW5pbWF0aW9uLndlaWdodDtcclxuXHJcblx0XHRpZiAoIGtleWZyYW1lICE9PSBhbmltYXRpb24uY3VycmVudEZyYW1lICkge1xyXG5cclxuXHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGFuaW1hdGlvbi5sYXN0RnJhbWUgXSA9IDA7XHJcblx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBhbmltYXRpb24uY3VycmVudEZyYW1lIF0gPSAxICogd2VpZ2h0O1xyXG5cclxuXHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGtleWZyYW1lIF0gPSAwO1xyXG5cclxuXHRcdFx0YW5pbWF0aW9uLmxhc3RGcmFtZSA9IGFuaW1hdGlvbi5jdXJyZW50RnJhbWU7XHJcblx0XHRcdGFuaW1hdGlvbi5jdXJyZW50RnJhbWUgPSBrZXlmcmFtZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG1peCA9ICggYW5pbWF0aW9uLnRpbWUgJSBmcmFtZVRpbWUgKSAvIGZyYW1lVGltZTtcclxuXHJcblx0XHRpZiAoIGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgKSBtaXggPSAxIC0gbWl4O1xyXG5cclxuXHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBhbmltYXRpb24uY3VycmVudEZyYW1lIF0gPSBtaXggKiB3ZWlnaHQ7XHJcblx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgYW5pbWF0aW9uLmxhc3RGcmFtZSBdID0gKCAxIC0gbWl4ICkgKiB3ZWlnaHQ7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkxlbnNGbGFyZVBsdWdpbiA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIF9nbCwgX3JlbmRlcmVyLCBfcHJlY2lzaW9uLCBfbGVuc0ZsYXJlID0ge307XHJcblxyXG5cdHRoaXMuaW5pdCA9IGZ1bmN0aW9uICggcmVuZGVyZXIgKSB7XHJcblxyXG5cdFx0X2dsID0gcmVuZGVyZXIuY29udGV4dDtcclxuXHRcdF9yZW5kZXJlciA9IHJlbmRlcmVyO1xyXG5cclxuXHRcdF9wcmVjaXNpb24gPSByZW5kZXJlci5nZXRQcmVjaXNpb24oKTtcclxuXHJcblx0XHRfbGVuc0ZsYXJlLnZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggOCArIDggKTtcclxuXHRcdF9sZW5zRmxhcmUuZmFjZXMgPSBuZXcgVWludDE2QXJyYXkoIDYgKTtcclxuXHJcblx0XHR2YXIgaSA9IDA7XHJcblx0XHRfbGVuc0ZsYXJlLnZlcnRpY2VzWyBpKysgXSA9IC0xOyBfbGVuc0ZsYXJlLnZlcnRpY2VzWyBpKysgXSA9IC0xO1x0Ly8gdmVydGV4XHJcblx0XHRfbGVuc0ZsYXJlLnZlcnRpY2VzWyBpKysgXSA9IDA7ICBfbGVuc0ZsYXJlLnZlcnRpY2VzWyBpKysgXSA9IDA7XHQvLyB1di4uLiBldGMuXHJcblxyXG5cdFx0X2xlbnNGbGFyZS52ZXJ0aWNlc1sgaSsrIF0gPSAxOyAgX2xlbnNGbGFyZS52ZXJ0aWNlc1sgaSsrIF0gPSAtMTtcclxuXHRcdF9sZW5zRmxhcmUudmVydGljZXNbIGkrKyBdID0gMTsgIF9sZW5zRmxhcmUudmVydGljZXNbIGkrKyBdID0gMDtcclxuXHJcblx0XHRfbGVuc0ZsYXJlLnZlcnRpY2VzWyBpKysgXSA9IDE7ICBfbGVuc0ZsYXJlLnZlcnRpY2VzWyBpKysgXSA9IDE7XHJcblx0XHRfbGVuc0ZsYXJlLnZlcnRpY2VzWyBpKysgXSA9IDE7ICBfbGVuc0ZsYXJlLnZlcnRpY2VzWyBpKysgXSA9IDE7XHJcblxyXG5cdFx0X2xlbnNGbGFyZS52ZXJ0aWNlc1sgaSsrIF0gPSAtMTsgX2xlbnNGbGFyZS52ZXJ0aWNlc1sgaSsrIF0gPSAxO1xyXG5cdFx0X2xlbnNGbGFyZS52ZXJ0aWNlc1sgaSsrIF0gPSAwOyAgX2xlbnNGbGFyZS52ZXJ0aWNlc1sgaSsrIF0gPSAxO1xyXG5cclxuXHRcdGkgPSAwO1xyXG5cdFx0X2xlbnNGbGFyZS5mYWNlc1sgaSsrIF0gPSAwOyBfbGVuc0ZsYXJlLmZhY2VzWyBpKysgXSA9IDE7IF9sZW5zRmxhcmUuZmFjZXNbIGkrKyBdID0gMjtcclxuXHRcdF9sZW5zRmxhcmUuZmFjZXNbIGkrKyBdID0gMDsgX2xlbnNGbGFyZS5mYWNlc1sgaSsrIF0gPSAyOyBfbGVuc0ZsYXJlLmZhY2VzWyBpKysgXSA9IDM7XHJcblxyXG5cdFx0Ly8gYnVmZmVyc1xyXG5cclxuXHRcdF9sZW5zRmxhcmUudmVydGV4QnVmZmVyICAgICA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcclxuXHRcdF9sZW5zRmxhcmUuZWxlbWVudEJ1ZmZlciAgICA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcclxuXHJcblx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgX2xlbnNGbGFyZS52ZXJ0ZXhCdWZmZXIgKTtcclxuXHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBfbGVuc0ZsYXJlLnZlcnRpY2VzLCBfZ2wuU1RBVElDX0RSQVcgKTtcclxuXHJcblx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBfbGVuc0ZsYXJlLmVsZW1lbnRCdWZmZXIgKTtcclxuXHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIF9sZW5zRmxhcmUuZmFjZXMsIF9nbC5TVEFUSUNfRFJBVyApO1xyXG5cclxuXHRcdC8vIHRleHR1cmVzXHJcblxyXG5cdFx0X2xlbnNGbGFyZS50ZW1wVGV4dHVyZSAgICAgID0gX2dsLmNyZWF0ZVRleHR1cmUoKTtcclxuXHRcdF9sZW5zRmxhcmUub2NjbHVzaW9uVGV4dHVyZSA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XHJcblxyXG5cdFx0X2dsLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgX2xlbnNGbGFyZS50ZW1wVGV4dHVyZSApO1xyXG5cdFx0X2dsLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCAwLCBfZ2wuUkdCLCAxNiwgMTYsIDAsIF9nbC5SR0IsIF9nbC5VTlNJR05FRF9CWVRFLCBudWxsICk7XHJcblx0XHRfZ2wudGV4UGFyYW1ldGVyaSggX2dsLlRFWFRVUkVfMkQsIF9nbC5URVhUVVJFX1dSQVBfUywgX2dsLkNMQU1QX1RPX0VER0UgKTtcclxuXHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCBfZ2wuVEVYVFVSRV8yRCwgX2dsLlRFWFRVUkVfV1JBUF9ULCBfZ2wuQ0xBTVBfVE9fRURHRSApO1xyXG5cdFx0X2dsLnRleFBhcmFtZXRlcmkoIF9nbC5URVhUVVJFXzJELCBfZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBfZ2wuTkVBUkVTVCApO1xyXG5cdFx0X2dsLnRleFBhcmFtZXRlcmkoIF9nbC5URVhUVVJFXzJELCBfZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBfZ2wuTkVBUkVTVCApO1xyXG5cclxuXHRcdF9nbC5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIF9sZW5zRmxhcmUub2NjbHVzaW9uVGV4dHVyZSApO1xyXG5cdFx0X2dsLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCAwLCBfZ2wuUkdCQSwgMTYsIDE2LCAwLCBfZ2wuUkdCQSwgX2dsLlVOU0lHTkVEX0JZVEUsIG51bGwgKTtcclxuXHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCBfZ2wuVEVYVFVSRV8yRCwgX2dsLlRFWFRVUkVfV1JBUF9TLCBfZ2wuQ0xBTVBfVE9fRURHRSApO1xyXG5cdFx0X2dsLnRleFBhcmFtZXRlcmkoIF9nbC5URVhUVVJFXzJELCBfZ2wuVEVYVFVSRV9XUkFQX1QsIF9nbC5DTEFNUF9UT19FREdFICk7XHJcblx0XHRfZ2wudGV4UGFyYW1ldGVyaSggX2dsLlRFWFRVUkVfMkQsIF9nbC5URVhUVVJFX01BR19GSUxURVIsIF9nbC5ORUFSRVNUICk7XHJcblx0XHRfZ2wudGV4UGFyYW1ldGVyaSggX2dsLlRFWFRVUkVfMkQsIF9nbC5URVhUVVJFX01JTl9GSUxURVIsIF9nbC5ORUFSRVNUICk7XHJcblxyXG5cdFx0aWYgKCBfZ2wuZ2V0UGFyYW1ldGVyKCBfZ2wuTUFYX1ZFUlRFWF9URVhUVVJFX0lNQUdFX1VOSVRTICkgPD0gMCApIHtcclxuXHJcblx0XHRcdF9sZW5zRmxhcmUuaGFzVmVydGV4VGV4dHVyZSA9IGZhbHNlO1xyXG5cdFx0XHRfbGVuc0ZsYXJlLnByb2dyYW0gPSBjcmVhdGVQcm9ncmFtKCBUSFJFRS5TaGFkZXJGbGFyZXNbIFwibGVuc0ZsYXJlXCIgXSwgX3ByZWNpc2lvbiApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRfbGVuc0ZsYXJlLmhhc1ZlcnRleFRleHR1cmUgPSB0cnVlO1xyXG5cdFx0XHRfbGVuc0ZsYXJlLnByb2dyYW0gPSBjcmVhdGVQcm9ncmFtKCBUSFJFRS5TaGFkZXJGbGFyZXNbIFwibGVuc0ZsYXJlVmVydGV4VGV4dHVyZVwiIF0sIF9wcmVjaXNpb24gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0X2xlbnNGbGFyZS5hdHRyaWJ1dGVzID0ge307XHJcblx0XHRfbGVuc0ZsYXJlLnVuaWZvcm1zID0ge307XHJcblxyXG5cdFx0X2xlbnNGbGFyZS5hdHRyaWJ1dGVzLnZlcnRleCAgICAgICA9IF9nbC5nZXRBdHRyaWJMb2NhdGlvbiAoIF9sZW5zRmxhcmUucHJvZ3JhbSwgXCJwb3NpdGlvblwiICk7XHJcblx0XHRfbGVuc0ZsYXJlLmF0dHJpYnV0ZXMudXYgICAgICAgICAgID0gX2dsLmdldEF0dHJpYkxvY2F0aW9uICggX2xlbnNGbGFyZS5wcm9ncmFtLCBcInV2XCIgKTtcclxuXHJcblx0XHRfbGVuc0ZsYXJlLnVuaWZvcm1zLnJlbmRlclR5cGUgICAgID0gX2dsLmdldFVuaWZvcm1Mb2NhdGlvbiggX2xlbnNGbGFyZS5wcm9ncmFtLCBcInJlbmRlclR5cGVcIiApO1xyXG5cdFx0X2xlbnNGbGFyZS51bmlmb3Jtcy5tYXAgICAgICAgICAgICA9IF9nbC5nZXRVbmlmb3JtTG9jYXRpb24oIF9sZW5zRmxhcmUucHJvZ3JhbSwgXCJtYXBcIiApO1xyXG5cdFx0X2xlbnNGbGFyZS51bmlmb3Jtcy5vY2NsdXNpb25NYXAgICA9IF9nbC5nZXRVbmlmb3JtTG9jYXRpb24oIF9sZW5zRmxhcmUucHJvZ3JhbSwgXCJvY2NsdXNpb25NYXBcIiApO1xyXG5cdFx0X2xlbnNGbGFyZS51bmlmb3Jtcy5vcGFjaXR5ICAgICAgICA9IF9nbC5nZXRVbmlmb3JtTG9jYXRpb24oIF9sZW5zRmxhcmUucHJvZ3JhbSwgXCJvcGFjaXR5XCIgKTtcclxuXHRcdF9sZW5zRmxhcmUudW5pZm9ybXMuY29sb3IgICAgICAgICAgPSBfZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBfbGVuc0ZsYXJlLnByb2dyYW0sIFwiY29sb3JcIiApO1xyXG5cdFx0X2xlbnNGbGFyZS51bmlmb3Jtcy5zY2FsZSAgICAgICAgICA9IF9nbC5nZXRVbmlmb3JtTG9jYXRpb24oIF9sZW5zRmxhcmUucHJvZ3JhbSwgXCJzY2FsZVwiICk7XHJcblx0XHRfbGVuc0ZsYXJlLnVuaWZvcm1zLnJvdGF0aW9uICAgICAgID0gX2dsLmdldFVuaWZvcm1Mb2NhdGlvbiggX2xlbnNGbGFyZS5wcm9ncmFtLCBcInJvdGF0aW9uXCIgKTtcclxuXHRcdF9sZW5zRmxhcmUudW5pZm9ybXMuc2NyZWVuUG9zaXRpb24gPSBfZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBfbGVuc0ZsYXJlLnByb2dyYW0sIFwic2NyZWVuUG9zaXRpb25cIiApO1xyXG5cclxuXHR9O1xyXG5cclxuXHJcblx0LypcclxuXHQgKiBSZW5kZXIgbGVucyBmbGFyZXNcclxuXHQgKiBNZXRob2Q6IHJlbmRlcnMgMTZ4MTYgMHhmZjAwZmYtY29sb3JlZCBwb2ludHMgc2NhdHRlcmVkIG92ZXIgdGhlIGxpZ2h0IHNvdXJjZSBhcmVhLFxyXG5cdCAqICAgICAgICAgcmVhZHMgdGhlc2UgYmFjayBhbmQgY2FsY3VsYXRlcyBvY2NsdXNpb24uXHJcblx0ICogICAgICAgICBUaGVuIF9sZW5zRmxhcmUudXBkYXRlX2xlbnNGbGFyZXMoKSBpcyBjYWxsZWQgdG8gcmUtcG9zaXRpb24gYW5kXHJcblx0ICogICAgICAgICB1cGRhdGUgdHJhbnNwYXJlbmN5IG9mIGZsYXJlcy4gVGhlbiB0aGV5IGFyZSByZW5kZXJlZC5cclxuXHQgKlxyXG5cdCAqL1xyXG5cclxuXHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggc2NlbmUsIGNhbWVyYSwgdmlld3BvcnRXaWR0aCwgdmlld3BvcnRIZWlnaHQgKSB7XHJcblxyXG5cdFx0dmFyIGZsYXJlcyA9IHNjZW5lLl9fd2ViZ2xGbGFyZXMsXHJcblx0XHRcdG5GbGFyZXMgPSBmbGFyZXMubGVuZ3RoO1xyXG5cclxuXHRcdGlmICggISBuRmxhcmVzICkgcmV0dXJuO1xyXG5cclxuXHRcdHZhciB0ZW1wUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHZhciBpbnZBc3BlY3QgPSB2aWV3cG9ydEhlaWdodCAvIHZpZXdwb3J0V2lkdGgsXHJcblx0XHRcdGhhbGZWaWV3cG9ydFdpZHRoID0gdmlld3BvcnRXaWR0aCAqIDAuNSxcclxuXHRcdFx0aGFsZlZpZXdwb3J0SGVpZ2h0ID0gdmlld3BvcnRIZWlnaHQgKiAwLjU7XHJcblxyXG5cdFx0dmFyIHNpemUgPSAxNiAvIHZpZXdwb3J0SGVpZ2h0LFxyXG5cdFx0XHRzY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IyKCBzaXplICogaW52QXNwZWN0LCBzaXplICk7XHJcblxyXG5cdFx0dmFyIHNjcmVlblBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDEsIDAgKSxcclxuXHRcdFx0c2NyZWVuUG9zaXRpb25QaXhlbHMgPSBuZXcgVEhSRUUuVmVjdG9yMiggMSwgMSApO1xyXG5cclxuXHRcdHZhciB1bmlmb3JtcyA9IF9sZW5zRmxhcmUudW5pZm9ybXMsXHJcblx0XHRcdGF0dHJpYnV0ZXMgPSBfbGVuc0ZsYXJlLmF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0Ly8gc2V0IF9sZW5zRmxhcmUgcHJvZ3JhbSBhbmQgcmVzZXQgYmxlbmRpbmdcclxuXHJcblx0XHRfZ2wudXNlUHJvZ3JhbSggX2xlbnNGbGFyZS5wcm9ncmFtICk7XHJcblxyXG5cdFx0X2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KCBfbGVuc0ZsYXJlLmF0dHJpYnV0ZXMudmVydGV4ICk7XHJcblx0XHRfZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoIF9sZW5zRmxhcmUuYXR0cmlidXRlcy51diApO1xyXG5cclxuXHRcdC8vIGxvb3AgdGhyb3VnaCBhbGwgbGVucyBmbGFyZXMgdG8gdXBkYXRlIHRoZWlyIG9jY2x1c2lvbiBhbmQgcG9zaXRpb25zXHJcblx0XHQvLyBzZXR1cCBnbCBhbmQgY29tbW9uIHVzZWQgYXR0cmlicy91bmZvcm1zXHJcblxyXG5cdFx0X2dsLnVuaWZvcm0xaSggdW5pZm9ybXMub2NjbHVzaW9uTWFwLCAwICk7XHJcblx0XHRfZ2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5tYXAsIDEgKTtcclxuXHJcblx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgX2xlbnNGbGFyZS52ZXJ0ZXhCdWZmZXIgKTtcclxuXHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnZlcnRleCwgMiwgX2dsLkZMT0FULCBmYWxzZSwgMiAqIDgsIDAgKTtcclxuXHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnV2LCAyLCBfZ2wuRkxPQVQsIGZhbHNlLCAyICogOCwgOCApO1xyXG5cclxuXHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIF9sZW5zRmxhcmUuZWxlbWVudEJ1ZmZlciApO1xyXG5cclxuXHRcdF9nbC5kaXNhYmxlKCBfZ2wuQ1VMTF9GQUNFICk7XHJcblx0XHRfZ2wuZGVwdGhNYXNrKCBmYWxzZSApO1xyXG5cclxuXHRcdHZhciBpLCBqLCBqbCwgZmxhcmUsIHNwcml0ZTtcclxuXHJcblx0XHRmb3IgKCBpID0gMDsgaSA8IG5GbGFyZXM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRzaXplID0gMTYgLyB2aWV3cG9ydEhlaWdodDtcclxuXHRcdFx0c2NhbGUuc2V0KCBzaXplICogaW52QXNwZWN0LCBzaXplICk7XHJcblxyXG5cdFx0XHQvLyBjYWxjIG9iamVjdCBzY3JlZW4gcG9zaXRpb25cclxuXHJcblx0XHRcdGZsYXJlID0gZmxhcmVzWyBpIF07XHJcblxyXG5cdFx0XHR0ZW1wUG9zaXRpb24uc2V0KCBmbGFyZS5tYXRyaXhXb3JsZC5lbGVtZW50c1sxMl0sIGZsYXJlLm1hdHJpeFdvcmxkLmVsZW1lbnRzWzEzXSwgZmxhcmUubWF0cml4V29ybGQuZWxlbWVudHNbMTRdICk7XHJcblxyXG5cdFx0XHR0ZW1wUG9zaXRpb24uYXBwbHlNYXRyaXg0KCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XHJcblx0XHRcdHRlbXBQb3NpdGlvbi5hcHBseVByb2plY3Rpb24oIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4ICk7XHJcblxyXG5cdFx0XHQvLyBzZXR1cCBhcnJheXMgZm9yIGdsIHByb2dyYW1zXHJcblxyXG5cdFx0XHRzY3JlZW5Qb3NpdGlvbi5jb3B5KCB0ZW1wUG9zaXRpb24gKVxyXG5cclxuXHRcdFx0c2NyZWVuUG9zaXRpb25QaXhlbHMueCA9IHNjcmVlblBvc2l0aW9uLnggKiBoYWxmVmlld3BvcnRXaWR0aCArIGhhbGZWaWV3cG9ydFdpZHRoO1xyXG5cdFx0XHRzY3JlZW5Qb3NpdGlvblBpeGVscy55ID0gc2NyZWVuUG9zaXRpb24ueSAqIGhhbGZWaWV3cG9ydEhlaWdodCArIGhhbGZWaWV3cG9ydEhlaWdodDtcclxuXHJcblx0XHRcdC8vIHNjcmVlbiBjdWxsXHJcblxyXG5cdFx0XHRpZiAoIF9sZW5zRmxhcmUuaGFzVmVydGV4VGV4dHVyZSB8fCAoXHJcblx0XHRcdFx0c2NyZWVuUG9zaXRpb25QaXhlbHMueCA+IDAgJiZcclxuXHRcdFx0XHRzY3JlZW5Qb3NpdGlvblBpeGVscy54IDwgdmlld3BvcnRXaWR0aCAmJlxyXG5cdFx0XHRcdHNjcmVlblBvc2l0aW9uUGl4ZWxzLnkgPiAwICYmXHJcblx0XHRcdFx0c2NyZWVuUG9zaXRpb25QaXhlbHMueSA8IHZpZXdwb3J0SGVpZ2h0ICkgKSB7XHJcblxyXG5cdFx0XHRcdC8vIHNhdmUgY3VycmVudCBSR0IgdG8gdGVtcCB0ZXh0dXJlXHJcblxyXG5cdFx0XHRcdF9nbC5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTEgKTtcclxuXHRcdFx0XHRfZ2wuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCBfbGVuc0ZsYXJlLnRlbXBUZXh0dXJlICk7XHJcblx0XHRcdFx0X2dsLmNvcHlUZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgMCwgX2dsLlJHQiwgc2NyZWVuUG9zaXRpb25QaXhlbHMueCAtIDgsIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnkgLSA4LCAxNiwgMTYsIDAgKTtcclxuXHJcblxyXG5cdFx0XHRcdC8vIHJlbmRlciBwaW5rIHF1YWRcclxuXHJcblx0XHRcdFx0X2dsLnVuaWZvcm0xaSggdW5pZm9ybXMucmVuZGVyVHlwZSwgMCApO1xyXG5cdFx0XHRcdF9nbC51bmlmb3JtMmYoIHVuaWZvcm1zLnNjYWxlLCBzY2FsZS54LCBzY2FsZS55ICk7XHJcblx0XHRcdFx0X2dsLnVuaWZvcm0zZiggdW5pZm9ybXMuc2NyZWVuUG9zaXRpb24sIHNjcmVlblBvc2l0aW9uLngsIHNjcmVlblBvc2l0aW9uLnksIHNjcmVlblBvc2l0aW9uLnogKTtcclxuXHJcblx0XHRcdFx0X2dsLmRpc2FibGUoIF9nbC5CTEVORCApO1xyXG5cdFx0XHRcdF9nbC5lbmFibGUoIF9nbC5ERVBUSF9URVNUICk7XHJcblxyXG5cdFx0XHRcdF9nbC5kcmF3RWxlbWVudHMoIF9nbC5UUklBTkdMRVMsIDYsIF9nbC5VTlNJR05FRF9TSE9SVCwgMCApO1xyXG5cclxuXHJcblx0XHRcdFx0Ly8gY29weSByZXN1bHQgdG8gb2NjbHVzaW9uTWFwXHJcblxyXG5cdFx0XHRcdF9nbC5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKTtcclxuXHRcdFx0XHRfZ2wuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCBfbGVuc0ZsYXJlLm9jY2x1c2lvblRleHR1cmUgKTtcclxuXHRcdFx0XHRfZ2wuY29weVRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCAwLCBfZ2wuUkdCQSwgc2NyZWVuUG9zaXRpb25QaXhlbHMueCAtIDgsIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnkgLSA4LCAxNiwgMTYsIDAgKTtcclxuXHJcblxyXG5cdFx0XHRcdC8vIHJlc3RvcmUgZ3JhcGhpY3NcclxuXHJcblx0XHRcdFx0X2dsLnVuaWZvcm0xaSggdW5pZm9ybXMucmVuZGVyVHlwZSwgMSApO1xyXG5cdFx0XHRcdF9nbC5kaXNhYmxlKCBfZ2wuREVQVEhfVEVTVCApO1xyXG5cclxuXHRcdFx0XHRfZ2wuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUxICk7XHJcblx0XHRcdFx0X2dsLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgX2xlbnNGbGFyZS50ZW1wVGV4dHVyZSApO1xyXG5cdFx0XHRcdF9nbC5kcmF3RWxlbWVudHMoIF9nbC5UUklBTkdMRVMsIDYsIF9nbC5VTlNJR05FRF9TSE9SVCwgMCApO1xyXG5cclxuXHJcblx0XHRcdFx0Ly8gdXBkYXRlIG9iamVjdCBwb3NpdGlvbnNcclxuXHJcblx0XHRcdFx0ZmxhcmUucG9zaXRpb25TY3JlZW4uY29weSggc2NyZWVuUG9zaXRpb24gKVxyXG5cclxuXHRcdFx0XHRpZiAoIGZsYXJlLmN1c3RvbVVwZGF0ZUNhbGxiYWNrICkge1xyXG5cclxuXHRcdFx0XHRcdGZsYXJlLmN1c3RvbVVwZGF0ZUNhbGxiYWNrKCBmbGFyZSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGZsYXJlLnVwZGF0ZUxlbnNGbGFyZXMoKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyByZW5kZXIgZmxhcmVzXHJcblxyXG5cdFx0XHRcdF9nbC51bmlmb3JtMWkoIHVuaWZvcm1zLnJlbmRlclR5cGUsIDIgKTtcclxuXHRcdFx0XHRfZ2wuZW5hYmxlKCBfZ2wuQkxFTkQgKTtcclxuXHJcblx0XHRcdFx0Zm9yICggaiA9IDAsIGpsID0gZmxhcmUubGVuc0ZsYXJlcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRzcHJpdGUgPSBmbGFyZS5sZW5zRmxhcmVzWyBqIF07XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBzcHJpdGUub3BhY2l0eSA+IDAuMDAxICYmIHNwcml0ZS5zY2FsZSA+IDAuMDAxICkge1xyXG5cclxuXHRcdFx0XHRcdFx0c2NyZWVuUG9zaXRpb24ueCA9IHNwcml0ZS54O1xyXG5cdFx0XHRcdFx0XHRzY3JlZW5Qb3NpdGlvbi55ID0gc3ByaXRlLnk7XHJcblx0XHRcdFx0XHRcdHNjcmVlblBvc2l0aW9uLnogPSBzcHJpdGUuejtcclxuXHJcblx0XHRcdFx0XHRcdHNpemUgPSBzcHJpdGUuc2l6ZSAqIHNwcml0ZS5zY2FsZSAvIHZpZXdwb3J0SGVpZ2h0O1xyXG5cclxuXHRcdFx0XHRcdFx0c2NhbGUueCA9IHNpemUgKiBpbnZBc3BlY3Q7XHJcblx0XHRcdFx0XHRcdHNjYWxlLnkgPSBzaXplO1xyXG5cclxuXHRcdFx0XHRcdFx0X2dsLnVuaWZvcm0zZiggdW5pZm9ybXMuc2NyZWVuUG9zaXRpb24sIHNjcmVlblBvc2l0aW9uLngsIHNjcmVlblBvc2l0aW9uLnksIHNjcmVlblBvc2l0aW9uLnogKTtcclxuXHRcdFx0XHRcdFx0X2dsLnVuaWZvcm0yZiggdW5pZm9ybXMuc2NhbGUsIHNjYWxlLngsIHNjYWxlLnkgKTtcclxuXHRcdFx0XHRcdFx0X2dsLnVuaWZvcm0xZiggdW5pZm9ybXMucm90YXRpb24sIHNwcml0ZS5yb3RhdGlvbiApO1xyXG5cclxuXHRcdFx0XHRcdFx0X2dsLnVuaWZvcm0xZiggdW5pZm9ybXMub3BhY2l0eSwgc3ByaXRlLm9wYWNpdHkgKTtcclxuXHRcdFx0XHRcdFx0X2dsLnVuaWZvcm0zZiggdW5pZm9ybXMuY29sb3IsIHNwcml0ZS5jb2xvci5yLCBzcHJpdGUuY29sb3IuZywgc3ByaXRlLmNvbG9yLmIgKTtcclxuXHJcblx0XHRcdFx0XHRcdF9yZW5kZXJlci5zZXRCbGVuZGluZyggc3ByaXRlLmJsZW5kaW5nLCBzcHJpdGUuYmxlbmRFcXVhdGlvbiwgc3ByaXRlLmJsZW5kU3JjLCBzcHJpdGUuYmxlbmREc3QgKTtcclxuXHRcdFx0XHRcdFx0X3JlbmRlcmVyLnNldFRleHR1cmUoIHNwcml0ZS50ZXh0dXJlLCAxICk7XHJcblxyXG5cdFx0XHRcdFx0XHRfZ2wuZHJhd0VsZW1lbnRzKCBfZ2wuVFJJQU5HTEVTLCA2LCBfZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gcmVzdG9yZSBnbFxyXG5cclxuXHRcdF9nbC5lbmFibGUoIF9nbC5DVUxMX0ZBQ0UgKTtcclxuXHRcdF9nbC5lbmFibGUoIF9nbC5ERVBUSF9URVNUICk7XHJcblx0XHRfZ2wuZGVwdGhNYXNrKCB0cnVlICk7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGNyZWF0ZVByb2dyYW0gKCBzaGFkZXIsIHByZWNpc2lvbiApIHtcclxuXHJcblx0XHR2YXIgcHJvZ3JhbSA9IF9nbC5jcmVhdGVQcm9ncmFtKCk7XHJcblxyXG5cdFx0dmFyIGZyYWdtZW50U2hhZGVyID0gX2dsLmNyZWF0ZVNoYWRlciggX2dsLkZSQUdNRU5UX1NIQURFUiApO1xyXG5cdFx0dmFyIHZlcnRleFNoYWRlciA9IF9nbC5jcmVhdGVTaGFkZXIoIF9nbC5WRVJURVhfU0hBREVSICk7XHJcblxyXG5cdFx0dmFyIHByZWZpeCA9IFwicHJlY2lzaW9uIFwiICsgcHJlY2lzaW9uICsgXCIgZmxvYXQ7XFxuXCI7XHJcblxyXG5cdFx0X2dsLnNoYWRlclNvdXJjZSggZnJhZ21lbnRTaGFkZXIsIHByZWZpeCArIHNoYWRlci5mcmFnbWVudFNoYWRlciApO1xyXG5cdFx0X2dsLnNoYWRlclNvdXJjZSggdmVydGV4U2hhZGVyLCBwcmVmaXggKyBzaGFkZXIudmVydGV4U2hhZGVyICk7XHJcblxyXG5cdFx0X2dsLmNvbXBpbGVTaGFkZXIoIGZyYWdtZW50U2hhZGVyICk7XHJcblx0XHRfZ2wuY29tcGlsZVNoYWRlciggdmVydGV4U2hhZGVyICk7XHJcblxyXG5cdFx0X2dsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIgKTtcclxuXHRcdF9nbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIHZlcnRleFNoYWRlciApO1xyXG5cclxuXHRcdF9nbC5saW5rUHJvZ3JhbSggcHJvZ3JhbSApO1xyXG5cclxuXHRcdHJldHVybiBwcm9ncmFtO1xyXG5cclxuXHR9O1xyXG5cclxufTtcclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuU2hhZG93TWFwUGx1Z2luID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgX2dsLFxyXG5cdF9yZW5kZXJlcixcclxuXHRfZGVwdGhNYXRlcmlhbCwgX2RlcHRoTWF0ZXJpYWxNb3JwaCwgX2RlcHRoTWF0ZXJpYWxTa2luLCBfZGVwdGhNYXRlcmlhbE1vcnBoU2tpbixcclxuXHJcblx0X2ZydXN0dW0gPSBuZXcgVEhSRUUuRnJ1c3R1bSgpLFxyXG5cdF9wcm9qU2NyZWVuTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKSxcclxuXHJcblx0X21pbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblx0X21heCA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblxyXG5cdF9tYXRyaXhQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdHRoaXMuaW5pdCA9IGZ1bmN0aW9uICggcmVuZGVyZXIgKSB7XHJcblxyXG5cdFx0X2dsID0gcmVuZGVyZXIuY29udGV4dDtcclxuXHRcdF9yZW5kZXJlciA9IHJlbmRlcmVyO1xyXG5cclxuXHRcdHZhciBkZXB0aFNoYWRlciA9IFRIUkVFLlNoYWRlckxpYlsgXCJkZXB0aFJHQkFcIiBdO1xyXG5cdFx0dmFyIGRlcHRoVW5pZm9ybXMgPSBUSFJFRS5Vbmlmb3Jtc1V0aWxzLmNsb25lKCBkZXB0aFNoYWRlci51bmlmb3JtcyApO1xyXG5cclxuXHRcdF9kZXB0aE1hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKCB7IGZyYWdtZW50U2hhZGVyOiBkZXB0aFNoYWRlci5mcmFnbWVudFNoYWRlciwgdmVydGV4U2hhZGVyOiBkZXB0aFNoYWRlci52ZXJ0ZXhTaGFkZXIsIHVuaWZvcm1zOiBkZXB0aFVuaWZvcm1zIH0gKTtcclxuXHRcdF9kZXB0aE1hdGVyaWFsTW9ycGggPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoIHsgZnJhZ21lbnRTaGFkZXI6IGRlcHRoU2hhZGVyLmZyYWdtZW50U2hhZGVyLCB2ZXJ0ZXhTaGFkZXI6IGRlcHRoU2hhZGVyLnZlcnRleFNoYWRlciwgdW5pZm9ybXM6IGRlcHRoVW5pZm9ybXMsIG1vcnBoVGFyZ2V0czogdHJ1ZSB9ICk7XHJcblx0XHRfZGVwdGhNYXRlcmlhbFNraW4gPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoIHsgZnJhZ21lbnRTaGFkZXI6IGRlcHRoU2hhZGVyLmZyYWdtZW50U2hhZGVyLCB2ZXJ0ZXhTaGFkZXI6IGRlcHRoU2hhZGVyLnZlcnRleFNoYWRlciwgdW5pZm9ybXM6IGRlcHRoVW5pZm9ybXMsIHNraW5uaW5nOiB0cnVlIH0gKTtcclxuXHRcdF9kZXB0aE1hdGVyaWFsTW9ycGhTa2luID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKCB7IGZyYWdtZW50U2hhZGVyOiBkZXB0aFNoYWRlci5mcmFnbWVudFNoYWRlciwgdmVydGV4U2hhZGVyOiBkZXB0aFNoYWRlci52ZXJ0ZXhTaGFkZXIsIHVuaWZvcm1zOiBkZXB0aFVuaWZvcm1zLCBtb3JwaFRhcmdldHM6IHRydWUsIHNraW5uaW5nOiB0cnVlIH0gKTtcclxuXHJcblx0XHRfZGVwdGhNYXRlcmlhbC5fc2hhZG93UGFzcyA9IHRydWU7XHJcblx0XHRfZGVwdGhNYXRlcmlhbE1vcnBoLl9zaGFkb3dQYXNzID0gdHJ1ZTtcclxuXHRcdF9kZXB0aE1hdGVyaWFsU2tpbi5fc2hhZG93UGFzcyA9IHRydWU7XHJcblx0XHRfZGVwdGhNYXRlcmlhbE1vcnBoU2tpbi5fc2hhZG93UGFzcyA9IHRydWU7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCBzY2VuZSwgY2FtZXJhICkge1xyXG5cclxuXHRcdGlmICggISAoIF9yZW5kZXJlci5zaGFkb3dNYXBFbmFibGVkICYmIF9yZW5kZXJlci5zaGFkb3dNYXBBdXRvVXBkYXRlICkgKSByZXR1cm47XHJcblxyXG5cdFx0dGhpcy51cGRhdGUoIHNjZW5lLCBjYW1lcmEgKTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy51cGRhdGUgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEgKSB7XHJcblxyXG5cdFx0dmFyIGksIGlsLCBqLCBqbCwgbixcclxuXHJcblx0XHRzaGFkb3dNYXAsIHNoYWRvd01hdHJpeCwgc2hhZG93Q2FtZXJhLFxyXG5cdFx0cHJvZ3JhbSwgYnVmZmVyLCBtYXRlcmlhbCxcclxuXHRcdHdlYmdsT2JqZWN0LCBvYmplY3QsIGxpZ2h0LFxyXG5cdFx0cmVuZGVyTGlzdCxcclxuXHJcblx0XHRsaWdodHMgPSBbXSxcclxuXHRcdGsgPSAwLFxyXG5cclxuXHRcdGZvZyA9IG51bGw7XHJcblxyXG5cdFx0Ly8gc2V0IEdMIHN0YXRlIGZvciBkZXB0aCBtYXBcclxuXHJcblx0XHRfZ2wuY2xlYXJDb2xvciggMSwgMSwgMSwgMSApO1xyXG5cdFx0X2dsLmRpc2FibGUoIF9nbC5CTEVORCApO1xyXG5cclxuXHRcdF9nbC5lbmFibGUoIF9nbC5DVUxMX0ZBQ0UgKTtcclxuXHRcdF9nbC5mcm9udEZhY2UoIF9nbC5DQ1cgKTtcclxuXHJcblx0XHRpZiAoIF9yZW5kZXJlci5zaGFkb3dNYXBDdWxsRmFjZSA9PT0gVEhSRUUuQ3VsbEZhY2VGcm9udCApIHtcclxuXHJcblx0XHRcdF9nbC5jdWxsRmFjZSggX2dsLkZST05UICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdF9nbC5jdWxsRmFjZSggX2dsLkJBQ0sgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0X3JlbmRlcmVyLnNldERlcHRoVGVzdCggdHJ1ZSApO1xyXG5cclxuXHRcdC8vIHByZXByb2Nlc3MgbGlnaHRzXHJcblx0XHQvLyBcdC0gc2tpcCBsaWdodHMgdGhhdCBhcmUgbm90IGNhc3Rpbmcgc2hhZG93c1xyXG5cdFx0Ly9cdC0gY3JlYXRlIHZpcnR1YWwgbGlnaHRzIGZvciBjYXNjYWRlZCBzaGFkb3cgbWFwc1xyXG5cclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IHNjZW5lLl9fbGlnaHRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0bGlnaHQgPSBzY2VuZS5fX2xpZ2h0c1sgaSBdO1xyXG5cclxuXHRcdFx0aWYgKCAhIGxpZ2h0LmNhc3RTaGFkb3cgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdGlmICggKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQgKSAmJiBsaWdodC5zaGFkb3dDYXNjYWRlICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCBuID0gMDsgbiA8IGxpZ2h0LnNoYWRvd0Nhc2NhZGVDb3VudDsgbiArKyApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgdmlydHVhbExpZ2h0O1xyXG5cclxuXHRcdFx0XHRcdGlmICggISBsaWdodC5zaGFkb3dDYXNjYWRlQXJyYXlbIG4gXSApIHtcclxuXHJcblx0XHRcdFx0XHRcdHZpcnR1YWxMaWdodCA9IGNyZWF0ZVZpcnR1YWxMaWdodCggbGlnaHQsIG4gKTtcclxuXHRcdFx0XHRcdFx0dmlydHVhbExpZ2h0Lm9yaWdpbmFsQ2FtZXJhID0gY2FtZXJhO1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIGd5cm8gPSBuZXcgVEhSRUUuR3lyb3Njb3BlKCk7XHJcblx0XHRcdFx0XHRcdGd5cm8ucG9zaXRpb24gPSBsaWdodC5zaGFkb3dDYXNjYWRlT2Zmc2V0O1xyXG5cclxuXHRcdFx0XHRcdFx0Z3lyby5hZGQoIHZpcnR1YWxMaWdodCApO1xyXG5cdFx0XHRcdFx0XHRneXJvLmFkZCggdmlydHVhbExpZ2h0LnRhcmdldCApO1xyXG5cclxuXHRcdFx0XHRcdFx0Y2FtZXJhLmFkZCggZ3lybyApO1xyXG5cclxuXHRcdFx0XHRcdFx0bGlnaHQuc2hhZG93Q2FzY2FkZUFycmF5WyBuIF0gPSB2aXJ0dWFsTGlnaHQ7XHJcblxyXG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyggXCJDcmVhdGVkIHZpcnR1YWxMaWdodFwiLCB2aXJ0dWFsTGlnaHQgKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0dmlydHVhbExpZ2h0ID0gbGlnaHQuc2hhZG93Q2FzY2FkZUFycmF5WyBuIF07XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHVwZGF0ZVZpcnR1YWxMaWdodCggbGlnaHQsIG4gKTtcclxuXHJcblx0XHRcdFx0XHRsaWdodHNbIGsgXSA9IHZpcnR1YWxMaWdodDtcclxuXHRcdFx0XHRcdGsgKys7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGxpZ2h0c1sgayBdID0gbGlnaHQ7XHJcblx0XHRcdFx0ayArKztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gcmVuZGVyIGRlcHRoIG1hcFxyXG5cclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IGxpZ2h0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGxpZ2h0ID0gbGlnaHRzWyBpIF07XHJcblxyXG5cdFx0XHRpZiAoICEgbGlnaHQuc2hhZG93TWFwICkge1xyXG5cclxuXHRcdFx0XHR2YXIgc2hhZG93RmlsdGVyID0gVEhSRUUuTGluZWFyRmlsdGVyO1xyXG5cclxuXHRcdFx0XHRpZiAoIF9yZW5kZXJlci5zaGFkb3dNYXBUeXBlID09PSBUSFJFRS5QQ0ZTb2Z0U2hhZG93TWFwICkge1xyXG5cclxuXHRcdFx0XHRcdHNoYWRvd0ZpbHRlciA9IFRIUkVFLk5lYXJlc3RGaWx0ZXI7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dmFyIHBhcnMgPSB7IG1pbkZpbHRlcjogc2hhZG93RmlsdGVyLCBtYWdGaWx0ZXI6IHNoYWRvd0ZpbHRlciwgZm9ybWF0OiBUSFJFRS5SR0JBRm9ybWF0IH07XHJcblxyXG5cdFx0XHRcdGxpZ2h0LnNoYWRvd01hcCA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlclRhcmdldCggbGlnaHQuc2hhZG93TWFwV2lkdGgsIGxpZ2h0LnNoYWRvd01hcEhlaWdodCwgcGFycyApO1xyXG5cdFx0XHRcdGxpZ2h0LnNoYWRvd01hcFNpemUgPSBuZXcgVEhSRUUuVmVjdG9yMiggbGlnaHQuc2hhZG93TWFwV2lkdGgsIGxpZ2h0LnNoYWRvd01hcEhlaWdodCApO1xyXG5cclxuXHRcdFx0XHRsaWdodC5zaGFkb3dNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCAhIGxpZ2h0LnNoYWRvd0NhbWVyYSApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlNwb3RMaWdodCApIHtcclxuXHJcblx0XHRcdFx0XHRsaWdodC5zaGFkb3dDYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGxpZ2h0LnNoYWRvd0NhbWVyYUZvdiwgbGlnaHQuc2hhZG93TWFwV2lkdGggLyBsaWdodC5zaGFkb3dNYXBIZWlnaHQsIGxpZ2h0LnNoYWRvd0NhbWVyYU5lYXIsIGxpZ2h0LnNoYWRvd0NhbWVyYUZhciApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQgKSB7XHJcblxyXG5cdFx0XHRcdFx0bGlnaHQuc2hhZG93Q2FtZXJhID0gbmV3IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSggbGlnaHQuc2hhZG93Q2FtZXJhTGVmdCwgbGlnaHQuc2hhZG93Q2FtZXJhUmlnaHQsIGxpZ2h0LnNoYWRvd0NhbWVyYVRvcCwgbGlnaHQuc2hhZG93Q2FtZXJhQm90dG9tLCBsaWdodC5zaGFkb3dDYW1lcmFOZWFyLCBsaWdodC5zaGFkb3dDYW1lcmFGYXIgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCBcIlVuc3VwcG9ydGVkIGxpZ2h0IHR5cGUgZm9yIHNoYWRvd1wiICk7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRzY2VuZS5hZGQoIGxpZ2h0LnNoYWRvd0NhbWVyYSApO1xyXG5cclxuXHRcdFx0XHRpZiAoIF9yZW5kZXJlci5hdXRvVXBkYXRlU2NlbmUgKSBzY2VuZS51cGRhdGVNYXRyaXhXb3JsZCgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBsaWdodC5zaGFkb3dDYW1lcmFWaXNpYmxlICYmICEgbGlnaHQuY2FtZXJhSGVscGVyICkge1xyXG5cclxuXHRcdFx0XHRsaWdodC5jYW1lcmFIZWxwZXIgPSBuZXcgVEhSRUUuQ2FtZXJhSGVscGVyKCBsaWdodC5zaGFkb3dDYW1lcmEgKTtcclxuXHRcdFx0XHRsaWdodC5zaGFkb3dDYW1lcmEuYWRkKCBsaWdodC5jYW1lcmFIZWxwZXIgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggbGlnaHQuaXNWaXJ0dWFsICYmIHZpcnR1YWxMaWdodC5vcmlnaW5hbENhbWVyYSA9PSBjYW1lcmEgKSB7XHJcblxyXG5cdFx0XHRcdHVwZGF0ZVNoYWRvd0NhbWVyYSggY2FtZXJhLCBsaWdodCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c2hhZG93TWFwID0gbGlnaHQuc2hhZG93TWFwO1xyXG5cdFx0XHRzaGFkb3dNYXRyaXggPSBsaWdodC5zaGFkb3dNYXRyaXg7XHJcblx0XHRcdHNoYWRvd0NhbWVyYSA9IGxpZ2h0LnNoYWRvd0NhbWVyYTtcclxuXHJcblx0XHRcdHNoYWRvd0NhbWVyYS5wb3NpdGlvbi5nZXRQb3NpdGlvbkZyb21NYXRyaXgoIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdF9tYXRyaXhQb3NpdGlvbi5nZXRQb3NpdGlvbkZyb21NYXRyaXgoIGxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRzaGFkb3dDYW1lcmEubG9va0F0KCBfbWF0cml4UG9zaXRpb24gKTtcclxuXHRcdFx0c2hhZG93Q2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XHJcblxyXG5cdFx0XHRzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLmdldEludmVyc2UoIHNoYWRvd0NhbWVyYS5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0aWYgKCBsaWdodC5jYW1lcmFIZWxwZXIgKSBsaWdodC5jYW1lcmFIZWxwZXIudmlzaWJsZSA9IGxpZ2h0LnNoYWRvd0NhbWVyYVZpc2libGU7XHJcblx0XHRcdGlmICggbGlnaHQuc2hhZG93Q2FtZXJhVmlzaWJsZSApIGxpZ2h0LmNhbWVyYUhlbHBlci51cGRhdGUoKTtcclxuXHJcblx0XHRcdC8vIGNvbXB1dGUgc2hhZG93IG1hdHJpeFxyXG5cclxuXHRcdFx0c2hhZG93TWF0cml4LnNldCggMC41LCAwLjAsIDAuMCwgMC41LFxyXG5cdFx0XHRcdFx0XHRcdCAgMC4wLCAwLjUsIDAuMCwgMC41LFxyXG5cdFx0XHRcdFx0XHRcdCAgMC4wLCAwLjAsIDAuNSwgMC41LFxyXG5cdFx0XHRcdFx0XHRcdCAgMC4wLCAwLjAsIDAuMCwgMS4wICk7XHJcblxyXG5cdFx0XHRzaGFkb3dNYXRyaXgubXVsdGlwbHkoIHNoYWRvd0NhbWVyYS5wcm9qZWN0aW9uTWF0cml4ICk7XHJcblx0XHRcdHNoYWRvd01hdHJpeC5tdWx0aXBseSggc2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xyXG5cclxuXHRcdFx0Ly8gdXBkYXRlIGNhbWVyYSBtYXRyaWNlcyBhbmQgZnJ1c3R1bVxyXG5cclxuXHRcdFx0X3Byb2pTY3JlZW5NYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggc2hhZG93Q2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIHNoYWRvd0NhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcclxuXHRcdFx0X2ZydXN0dW0uc2V0RnJvbU1hdHJpeCggX3Byb2pTY3JlZW5NYXRyaXggKTtcclxuXHJcblx0XHRcdC8vIHJlbmRlciBzaGFkb3cgbWFwXHJcblxyXG5cdFx0XHRfcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCBzaGFkb3dNYXAgKTtcclxuXHRcdFx0X3JlbmRlcmVyLmNsZWFyKCk7XHJcblxyXG5cdFx0XHQvLyBzZXQgb2JqZWN0IG1hdHJpY2VzICYgZnJ1c3R1bSBjdWxsaW5nXHJcblxyXG5cdFx0XHRyZW5kZXJMaXN0ID0gc2NlbmUuX193ZWJnbE9iamVjdHM7XHJcblxyXG5cdFx0XHRmb3IgKCBqID0gMCwgamwgPSByZW5kZXJMaXN0Lmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHR3ZWJnbE9iamVjdCA9IHJlbmRlckxpc3RbIGogXTtcclxuXHRcdFx0XHRvYmplY3QgPSB3ZWJnbE9iamVjdC5vYmplY3Q7XHJcblxyXG5cdFx0XHRcdHdlYmdsT2JqZWN0LnJlbmRlciA9IGZhbHNlO1xyXG5cclxuXHRcdFx0XHRpZiAoIG9iamVjdC52aXNpYmxlICYmIG9iamVjdC5jYXN0U2hhZG93ICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggISAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggfHwgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUGFydGljbGVTeXN0ZW0gKSB8fCAhICggb2JqZWN0LmZydXN0dW1DdWxsZWQgKSB8fCBfZnJ1c3R1bS5pbnRlcnNlY3RzT2JqZWN0KCBvYmplY3QgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdG9iamVjdC5fbW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIHNoYWRvd0NhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsIG9iamVjdC5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0XHRcdFx0d2ViZ2xPYmplY3QucmVuZGVyID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHJlbmRlciByZWd1bGFyIG9iamVjdHNcclxuXHJcblx0XHRcdHZhciBvYmplY3RNYXRlcmlhbCwgdXNlTW9ycGhpbmcsIHVzZVNraW5uaW5nO1xyXG5cclxuXHRcdFx0Zm9yICggaiA9IDAsIGpsID0gcmVuZGVyTGlzdC5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0d2ViZ2xPYmplY3QgPSByZW5kZXJMaXN0WyBqIF07XHJcblxyXG5cdFx0XHRcdGlmICggd2ViZ2xPYmplY3QucmVuZGVyICkge1xyXG5cclxuXHRcdFx0XHRcdG9iamVjdCA9IHdlYmdsT2JqZWN0Lm9iamVjdDtcclxuXHRcdFx0XHRcdGJ1ZmZlciA9IHdlYmdsT2JqZWN0LmJ1ZmZlcjtcclxuXHJcblx0XHRcdFx0XHQvLyBjdWxsaW5nIGlzIG92ZXJyaWRlbiBnbG9iYWxseSBmb3IgYWxsIG9iamVjdHNcclxuXHRcdFx0XHRcdC8vIHdoaWxlIHJlbmRlcmluZyBkZXB0aCBtYXBcclxuXHJcblx0XHRcdFx0XHQvLyBuZWVkIHRvIGRlYWwgd2l0aCBNZXNoRmFjZU1hdGVyaWFsIHNvbWVob3dcclxuXHRcdFx0XHRcdC8vIGluIHRoYXQgY2FzZSBqdXN0IHVzZSB0aGUgZmlyc3Qgb2YgbWF0ZXJpYWwubWF0ZXJpYWxzIGZvciBub3dcclxuXHRcdFx0XHRcdC8vIChwcm9wZXIgc29sdXRpb24gd291bGQgcmVxdWlyZSB0byBicmVhayBvYmplY3RzIGJ5IG1hdGVyaWFsc1xyXG5cdFx0XHRcdFx0Ly8gIHNpbWlsYXJseSB0byByZWd1bGFyIHJlbmRlcmluZyBhbmQgdGhlbiBzZXQgY29ycmVzcG9uZGluZ1xyXG5cdFx0XHRcdFx0Ly8gIGRlcHRoIG1hdGVyaWFscyBwZXIgZWFjaCBjaHVuayBpbnN0ZWFkIG9mIGp1c3Qgb25jZSBwZXIgb2JqZWN0KVxyXG5cclxuXHRcdFx0XHRcdG9iamVjdE1hdGVyaWFsID0gZ2V0T2JqZWN0TWF0ZXJpYWwoIG9iamVjdCApO1xyXG5cclxuXHRcdFx0XHRcdHVzZU1vcnBoaW5nID0gb2JqZWN0Lmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGggPiAwICYmIG9iamVjdE1hdGVyaWFsLm1vcnBoVGFyZ2V0cztcclxuXHRcdFx0XHRcdHVzZVNraW5uaW5nID0gb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuU2tpbm5lZE1lc2ggJiYgb2JqZWN0TWF0ZXJpYWwuc2tpbm5pbmc7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBvYmplY3QuY3VzdG9tRGVwdGhNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdFx0XHRcdG1hdGVyaWFsID0gb2JqZWN0LmN1c3RvbURlcHRoTWF0ZXJpYWw7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggdXNlU2tpbm5pbmcgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRtYXRlcmlhbCA9IHVzZU1vcnBoaW5nID8gX2RlcHRoTWF0ZXJpYWxNb3JwaFNraW4gOiBfZGVwdGhNYXRlcmlhbFNraW47XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggdXNlTW9ycGhpbmcgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRtYXRlcmlhbCA9IF9kZXB0aE1hdGVyaWFsTW9ycGg7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdG1hdGVyaWFsID0gX2RlcHRoTWF0ZXJpYWw7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmICggYnVmZmVyIGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRfcmVuZGVyZXIucmVuZGVyQnVmZmVyRGlyZWN0KCBzaGFkb3dDYW1lcmEsIHNjZW5lLl9fbGlnaHRzLCBmb2csIG1hdGVyaWFsLCBidWZmZXIsIG9iamVjdCApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRfcmVuZGVyZXIucmVuZGVyQnVmZmVyKCBzaGFkb3dDYW1lcmEsIHNjZW5lLl9fbGlnaHRzLCBmb2csIG1hdGVyaWFsLCBidWZmZXIsIG9iamVjdCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gc2V0IG1hdHJpY2VzIGFuZCByZW5kZXIgaW1tZWRpYXRlIG9iamVjdHNcclxuXHJcblx0XHRcdHJlbmRlckxpc3QgPSBzY2VuZS5fX3dlYmdsT2JqZWN0c0ltbWVkaWF0ZTtcclxuXHJcblx0XHRcdGZvciAoIGogPSAwLCBqbCA9IHJlbmRlckxpc3QubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdHdlYmdsT2JqZWN0ID0gcmVuZGVyTGlzdFsgaiBdO1xyXG5cdFx0XHRcdG9iamVjdCA9IHdlYmdsT2JqZWN0Lm9iamVjdDtcclxuXHJcblx0XHRcdFx0aWYgKCBvYmplY3QudmlzaWJsZSAmJiBvYmplY3QuY2FzdFNoYWRvdyApIHtcclxuXHJcblx0XHRcdFx0XHRvYmplY3QuX21vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLCBvYmplY3QubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdFx0XHRfcmVuZGVyZXIucmVuZGVySW1tZWRpYXRlT2JqZWN0KCBzaGFkb3dDYW1lcmEsIHNjZW5lLl9fbGlnaHRzLCBmb2csIF9kZXB0aE1hdGVyaWFsLCBvYmplY3QgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyByZXN0b3JlIEdMIHN0YXRlXHJcblxyXG5cdFx0dmFyIGNsZWFyQ29sb3IgPSBfcmVuZGVyZXIuZ2V0Q2xlYXJDb2xvcigpLFxyXG5cdFx0Y2xlYXJBbHBoYSA9IF9yZW5kZXJlci5nZXRDbGVhckFscGhhKCk7XHJcblxyXG5cdFx0X2dsLmNsZWFyQ29sb3IoIGNsZWFyQ29sb3IuciwgY2xlYXJDb2xvci5nLCBjbGVhckNvbG9yLmIsIGNsZWFyQWxwaGEgKTtcclxuXHRcdF9nbC5lbmFibGUoIF9nbC5CTEVORCApO1xyXG5cclxuXHRcdGlmICggX3JlbmRlcmVyLnNoYWRvd01hcEN1bGxGYWNlID09PSBUSFJFRS5DdWxsRmFjZUZyb250ICkge1xyXG5cclxuXHRcdFx0X2dsLmN1bGxGYWNlKCBfZ2wuQkFDSyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gY3JlYXRlVmlydHVhbExpZ2h0KCBsaWdodCwgY2FzY2FkZSApIHtcclxuXHJcblx0XHR2YXIgdmlydHVhbExpZ2h0ID0gbmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQoKTtcclxuXHJcblx0XHR2aXJ0dWFsTGlnaHQuaXNWaXJ0dWFsID0gdHJ1ZTtcclxuXHJcblx0XHR2aXJ0dWFsTGlnaHQub25seVNoYWRvdyA9IHRydWU7XHJcblx0XHR2aXJ0dWFsTGlnaHQuY2FzdFNoYWRvdyA9IHRydWU7XHJcblxyXG5cdFx0dmlydHVhbExpZ2h0LnNoYWRvd0NhbWVyYU5lYXIgPSBsaWdodC5zaGFkb3dDYW1lcmFOZWFyO1xyXG5cdFx0dmlydHVhbExpZ2h0LnNoYWRvd0NhbWVyYUZhciA9IGxpZ2h0LnNoYWRvd0NhbWVyYUZhcjtcclxuXHJcblx0XHR2aXJ0dWFsTGlnaHQuc2hhZG93Q2FtZXJhTGVmdCA9IGxpZ2h0LnNoYWRvd0NhbWVyYUxlZnQ7XHJcblx0XHR2aXJ0dWFsTGlnaHQuc2hhZG93Q2FtZXJhUmlnaHQgPSBsaWdodC5zaGFkb3dDYW1lcmFSaWdodDtcclxuXHRcdHZpcnR1YWxMaWdodC5zaGFkb3dDYW1lcmFCb3R0b20gPSBsaWdodC5zaGFkb3dDYW1lcmFCb3R0b207XHJcblx0XHR2aXJ0dWFsTGlnaHQuc2hhZG93Q2FtZXJhVG9wID0gbGlnaHQuc2hhZG93Q2FtZXJhVG9wO1xyXG5cclxuXHRcdHZpcnR1YWxMaWdodC5zaGFkb3dDYW1lcmFWaXNpYmxlID0gbGlnaHQuc2hhZG93Q2FtZXJhVmlzaWJsZTtcclxuXHJcblx0XHR2aXJ0dWFsTGlnaHQuc2hhZG93RGFya25lc3MgPSBsaWdodC5zaGFkb3dEYXJrbmVzcztcclxuXHJcblx0XHR2aXJ0dWFsTGlnaHQuc2hhZG93QmlhcyA9IGxpZ2h0LnNoYWRvd0Nhc2NhZGVCaWFzWyBjYXNjYWRlIF07XHJcblx0XHR2aXJ0dWFsTGlnaHQuc2hhZG93TWFwV2lkdGggPSBsaWdodC5zaGFkb3dDYXNjYWRlV2lkdGhbIGNhc2NhZGUgXTtcclxuXHRcdHZpcnR1YWxMaWdodC5zaGFkb3dNYXBIZWlnaHQgPSBsaWdodC5zaGFkb3dDYXNjYWRlSGVpZ2h0WyBjYXNjYWRlIF07XHJcblxyXG5cdFx0dmlydHVhbExpZ2h0LnBvaW50c1dvcmxkID0gW107XHJcblx0XHR2aXJ0dWFsTGlnaHQucG9pbnRzRnJ1c3R1bSA9IFtdO1xyXG5cclxuXHRcdHZhciBwb2ludHNXb3JsZCA9IHZpcnR1YWxMaWdodC5wb2ludHNXb3JsZCxcclxuXHRcdFx0cG9pbnRzRnJ1c3R1bSA9IHZpcnR1YWxMaWdodC5wb2ludHNGcnVzdHVtO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRwb2ludHNXb3JsZFsgaSBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdFx0cG9pbnRzRnJ1c3R1bVsgaSBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG5lYXJaID0gbGlnaHQuc2hhZG93Q2FzY2FkZU5lYXJaWyBjYXNjYWRlIF07XHJcblx0XHR2YXIgZmFyWiA9IGxpZ2h0LnNoYWRvd0Nhc2NhZGVGYXJaWyBjYXNjYWRlIF07XHJcblxyXG5cdFx0cG9pbnRzRnJ1c3R1bVsgMCBdLnNldCggLTEsIC0xLCBuZWFyWiApO1xyXG5cdFx0cG9pbnRzRnJ1c3R1bVsgMSBdLnNldCggIDEsIC0xLCBuZWFyWiApO1xyXG5cdFx0cG9pbnRzRnJ1c3R1bVsgMiBdLnNldCggLTEsICAxLCBuZWFyWiApO1xyXG5cdFx0cG9pbnRzRnJ1c3R1bVsgMyBdLnNldCggIDEsICAxLCBuZWFyWiApO1xyXG5cclxuXHRcdHBvaW50c0ZydXN0dW1bIDQgXS5zZXQoIC0xLCAtMSwgZmFyWiApO1xyXG5cdFx0cG9pbnRzRnJ1c3R1bVsgNSBdLnNldCggIDEsIC0xLCBmYXJaICk7XHJcblx0XHRwb2ludHNGcnVzdHVtWyA2IF0uc2V0KCAtMSwgIDEsIGZhclogKTtcclxuXHRcdHBvaW50c0ZydXN0dW1bIDcgXS5zZXQoICAxLCAgMSwgZmFyWiApO1xyXG5cclxuXHRcdHJldHVybiB2aXJ0dWFsTGlnaHQ7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gU3luY2hyb25pemUgdmlydHVhbCBsaWdodCB3aXRoIHRoZSBvcmlnaW5hbCBsaWdodFxyXG5cclxuXHRmdW5jdGlvbiB1cGRhdGVWaXJ0dWFsTGlnaHQoIGxpZ2h0LCBjYXNjYWRlICkge1xyXG5cclxuXHRcdHZhciB2aXJ0dWFsTGlnaHQgPSBsaWdodC5zaGFkb3dDYXNjYWRlQXJyYXlbIGNhc2NhZGUgXTtcclxuXHJcblx0XHR2aXJ0dWFsTGlnaHQucG9zaXRpb24uY29weSggbGlnaHQucG9zaXRpb24gKTtcclxuXHRcdHZpcnR1YWxMaWdodC50YXJnZXQucG9zaXRpb24uY29weSggbGlnaHQudGFyZ2V0LnBvc2l0aW9uICk7XHJcblx0XHR2aXJ0dWFsTGlnaHQubG9va0F0KCB2aXJ0dWFsTGlnaHQudGFyZ2V0ICk7XHJcblxyXG5cdFx0dmlydHVhbExpZ2h0LnNoYWRvd0NhbWVyYVZpc2libGUgPSBsaWdodC5zaGFkb3dDYW1lcmFWaXNpYmxlO1xyXG5cdFx0dmlydHVhbExpZ2h0LnNoYWRvd0RhcmtuZXNzID0gbGlnaHQuc2hhZG93RGFya25lc3M7XHJcblxyXG5cdFx0dmlydHVhbExpZ2h0LnNoYWRvd0JpYXMgPSBsaWdodC5zaGFkb3dDYXNjYWRlQmlhc1sgY2FzY2FkZSBdO1xyXG5cclxuXHRcdHZhciBuZWFyWiA9IGxpZ2h0LnNoYWRvd0Nhc2NhZGVOZWFyWlsgY2FzY2FkZSBdO1xyXG5cdFx0dmFyIGZhclogPSBsaWdodC5zaGFkb3dDYXNjYWRlRmFyWlsgY2FzY2FkZSBdO1xyXG5cclxuXHRcdHZhciBwb2ludHNGcnVzdHVtID0gdmlydHVhbExpZ2h0LnBvaW50c0ZydXN0dW07XHJcblxyXG5cdFx0cG9pbnRzRnJ1c3R1bVsgMCBdLnogPSBuZWFyWjtcclxuXHRcdHBvaW50c0ZydXN0dW1bIDEgXS56ID0gbmVhclo7XHJcblx0XHRwb2ludHNGcnVzdHVtWyAyIF0ueiA9IG5lYXJaO1xyXG5cdFx0cG9pbnRzRnJ1c3R1bVsgMyBdLnogPSBuZWFyWjtcclxuXHJcblx0XHRwb2ludHNGcnVzdHVtWyA0IF0ueiA9IGZhclo7XHJcblx0XHRwb2ludHNGcnVzdHVtWyA1IF0ueiA9IGZhclo7XHJcblx0XHRwb2ludHNGcnVzdHVtWyA2IF0ueiA9IGZhclo7XHJcblx0XHRwb2ludHNGcnVzdHVtWyA3IF0ueiA9IGZhclo7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gRml0IHNoYWRvdyBjYW1lcmEncyBvcnRobyBmcnVzdHVtIHRvIGNhbWVyYSBmcnVzdHVtXHJcblxyXG5cdGZ1bmN0aW9uIHVwZGF0ZVNoYWRvd0NhbWVyYSggY2FtZXJhLCBsaWdodCApIHtcclxuXHJcblx0XHR2YXIgc2hhZG93Q2FtZXJhID0gbGlnaHQuc2hhZG93Q2FtZXJhLFxyXG5cdFx0XHRwb2ludHNGcnVzdHVtID0gbGlnaHQucG9pbnRzRnJ1c3R1bSxcclxuXHRcdFx0cG9pbnRzV29ybGQgPSBsaWdodC5wb2ludHNXb3JsZDtcclxuXHJcblx0XHRfbWluLnNldCggSW5maW5pdHksIEluZmluaXR5LCBJbmZpbml0eSApO1xyXG5cdFx0X21heC5zZXQoIC1JbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHkgKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA4OyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHAgPSBwb2ludHNXb3JsZFsgaSBdO1xyXG5cclxuXHRcdFx0cC5jb3B5KCBwb2ludHNGcnVzdHVtWyBpIF0gKTtcclxuXHRcdFx0VEhSRUUuU2hhZG93TWFwUGx1Z2luLl9fcHJvamVjdG9yLnVucHJvamVjdFZlY3RvciggcCwgY2FtZXJhICk7XHJcblxyXG5cdFx0XHRwLmFwcGx5TWF0cml4NCggc2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xyXG5cclxuXHRcdFx0aWYgKCBwLnggPCBfbWluLnggKSBfbWluLnggPSBwLng7XHJcblx0XHRcdGlmICggcC54ID4gX21heC54ICkgX21heC54ID0gcC54O1xyXG5cclxuXHRcdFx0aWYgKCBwLnkgPCBfbWluLnkgKSBfbWluLnkgPSBwLnk7XHJcblx0XHRcdGlmICggcC55ID4gX21heC55ICkgX21heC55ID0gcC55O1xyXG5cclxuXHRcdFx0aWYgKCBwLnogPCBfbWluLnogKSBfbWluLnogPSBwLno7XHJcblx0XHRcdGlmICggcC56ID4gX21heC56ICkgX21heC56ID0gcC56O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRzaGFkb3dDYW1lcmEubGVmdCA9IF9taW4ueDtcclxuXHRcdHNoYWRvd0NhbWVyYS5yaWdodCA9IF9tYXgueDtcclxuXHRcdHNoYWRvd0NhbWVyYS50b3AgPSBfbWF4Lnk7XHJcblx0XHRzaGFkb3dDYW1lcmEuYm90dG9tID0gX21pbi55O1xyXG5cclxuXHRcdC8vIGNhbid0IHJlYWxseSBmaXQgbmVhci9mYXJcclxuXHRcdC8vc2hhZG93Q2FtZXJhLm5lYXIgPSBfbWluLno7XHJcblx0XHQvL3NoYWRvd0NhbWVyYS5mYXIgPSBfbWF4Lno7XHJcblxyXG5cdFx0c2hhZG93Q2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBGb3IgdGhlIG1vbWVudCBqdXN0IGlnbm9yZSBvYmplY3RzIHRoYXQgaGF2ZSBtdWx0aXBsZSBtYXRlcmlhbHMgd2l0aCBkaWZmZXJlbnQgYW5pbWF0aW9uIG1ldGhvZHNcclxuXHQvLyBPbmx5IHRoZSBmaXJzdCBtYXRlcmlhbCB3aWxsIGJlIHRha2VuIGludG8gYWNjb3VudCBmb3IgZGVjaWRpbmcgd2hpY2ggZGVwdGggbWF0ZXJpYWwgdG8gdXNlIGZvciBzaGFkb3cgbWFwc1xyXG5cclxuXHRmdW5jdGlvbiBnZXRPYmplY3RNYXRlcmlhbCggb2JqZWN0ICkge1xyXG5cclxuXHRcdHJldHVybiBvYmplY3QubWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsXHJcblx0XHRcdD8gb2JqZWN0Lm1hdGVyaWFsLm1hdGVyaWFsc1sgMCBdXHJcblx0XHRcdDogb2JqZWN0Lm1hdGVyaWFsO1xyXG5cclxuXHR9O1xyXG5cclxufTtcclxuXHJcblRIUkVFLlNoYWRvd01hcFBsdWdpbi5fX3Byb2plY3RvciA9IG5ldyBUSFJFRS5Qcm9qZWN0b3IoKTtcclxuLyoqXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuU3ByaXRlUGx1Z2luID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgX2dsLCBfcmVuZGVyZXIsIF9wcmVjaXNpb24sIF9zcHJpdGUgPSB7fTtcclxuXHJcblx0dGhpcy5pbml0ID0gZnVuY3Rpb24gKCByZW5kZXJlciApIHtcclxuXHJcblx0XHRfZ2wgPSByZW5kZXJlci5jb250ZXh0O1xyXG5cdFx0X3JlbmRlcmVyID0gcmVuZGVyZXI7XHJcblxyXG5cdFx0X3ByZWNpc2lvbiA9IHJlbmRlcmVyLmdldFByZWNpc2lvbigpO1xyXG5cclxuXHRcdF9zcHJpdGUudmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCA4ICsgOCApO1xyXG5cdFx0X3Nwcml0ZS5mYWNlcyAgICA9IG5ldyBVaW50MTZBcnJheSggNiApO1xyXG5cclxuXHRcdHZhciBpID0gMDtcclxuXHJcblx0XHRfc3ByaXRlLnZlcnRpY2VzWyBpKysgXSA9IC0xOyBfc3ByaXRlLnZlcnRpY2VzWyBpKysgXSA9IC0xO1x0Ly8gdmVydGV4IDBcclxuXHRcdF9zcHJpdGUudmVydGljZXNbIGkrKyBdID0gMDsgIF9zcHJpdGUudmVydGljZXNbIGkrKyBdID0gMDtcdC8vIHV2IDBcclxuXHJcblx0XHRfc3ByaXRlLnZlcnRpY2VzWyBpKysgXSA9IDE7ICBfc3ByaXRlLnZlcnRpY2VzWyBpKysgXSA9IC0xO1x0Ly8gdmVydGV4IDFcclxuXHRcdF9zcHJpdGUudmVydGljZXNbIGkrKyBdID0gMTsgIF9zcHJpdGUudmVydGljZXNbIGkrKyBdID0gMDtcdC8vIHV2IDFcclxuXHJcblx0XHRfc3ByaXRlLnZlcnRpY2VzWyBpKysgXSA9IDE7ICBfc3ByaXRlLnZlcnRpY2VzWyBpKysgXSA9IDE7XHQvLyB2ZXJ0ZXggMlxyXG5cdFx0X3Nwcml0ZS52ZXJ0aWNlc1sgaSsrIF0gPSAxOyAgX3Nwcml0ZS52ZXJ0aWNlc1sgaSsrIF0gPSAxO1x0Ly8gdXYgMlxyXG5cclxuXHRcdF9zcHJpdGUudmVydGljZXNbIGkrKyBdID0gLTE7IF9zcHJpdGUudmVydGljZXNbIGkrKyBdID0gMTtcdC8vIHZlcnRleCAzXHJcblx0XHRfc3ByaXRlLnZlcnRpY2VzWyBpKysgXSA9IDA7ICBfc3ByaXRlLnZlcnRpY2VzWyBpKysgXSA9IDE7XHQvLyB1diAzXHJcblxyXG5cdFx0aSA9IDA7XHJcblxyXG5cdFx0X3Nwcml0ZS5mYWNlc1sgaSsrIF0gPSAwOyBfc3ByaXRlLmZhY2VzWyBpKysgXSA9IDE7IF9zcHJpdGUuZmFjZXNbIGkrKyBdID0gMjtcclxuXHRcdF9zcHJpdGUuZmFjZXNbIGkrKyBdID0gMDsgX3Nwcml0ZS5mYWNlc1sgaSsrIF0gPSAyOyBfc3ByaXRlLmZhY2VzWyBpKysgXSA9IDM7XHJcblxyXG5cdFx0X3Nwcml0ZS52ZXJ0ZXhCdWZmZXIgID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cdFx0X3Nwcml0ZS5lbGVtZW50QnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cclxuXHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBfc3ByaXRlLnZlcnRleEJ1ZmZlciApO1xyXG5cdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIF9zcHJpdGUudmVydGljZXMsIF9nbC5TVEFUSUNfRFJBVyApO1xyXG5cclxuXHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIF9zcHJpdGUuZWxlbWVudEJ1ZmZlciApO1xyXG5cdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgX3Nwcml0ZS5mYWNlcywgX2dsLlNUQVRJQ19EUkFXICk7XHJcblxyXG5cdFx0X3Nwcml0ZS5wcm9ncmFtID0gY3JlYXRlUHJvZ3JhbSggVEhSRUUuU2hhZGVyU3ByaXRlWyBcInNwcml0ZVwiIF0sIF9wcmVjaXNpb24gKTtcclxuXHJcblx0XHRfc3ByaXRlLmF0dHJpYnV0ZXMgPSB7fTtcclxuXHRcdF9zcHJpdGUudW5pZm9ybXMgPSB7fTtcclxuXHJcblx0XHRfc3ByaXRlLmF0dHJpYnV0ZXMucG9zaXRpb24gICAgICAgICAgID0gX2dsLmdldEF0dHJpYkxvY2F0aW9uICggX3Nwcml0ZS5wcm9ncmFtLCBcInBvc2l0aW9uXCIgKTtcclxuXHRcdF9zcHJpdGUuYXR0cmlidXRlcy51diAgICAgICAgICAgICAgICAgPSBfZ2wuZ2V0QXR0cmliTG9jYXRpb24gKCBfc3ByaXRlLnByb2dyYW0sIFwidXZcIiApO1xyXG5cclxuXHRcdF9zcHJpdGUudW5pZm9ybXMudXZPZmZzZXQgICAgICAgICAgICAgPSBfZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBfc3ByaXRlLnByb2dyYW0sIFwidXZPZmZzZXRcIiApO1xyXG5cdFx0X3Nwcml0ZS51bmlmb3Jtcy51dlNjYWxlICAgICAgICAgICAgICA9IF9nbC5nZXRVbmlmb3JtTG9jYXRpb24oIF9zcHJpdGUucHJvZ3JhbSwgXCJ1dlNjYWxlXCIgKTtcclxuXHJcblx0XHRfc3ByaXRlLnVuaWZvcm1zLnJvdGF0aW9uICAgICAgICAgICAgID0gX2dsLmdldFVuaWZvcm1Mb2NhdGlvbiggX3Nwcml0ZS5wcm9ncmFtLCBcInJvdGF0aW9uXCIgKTtcclxuXHRcdF9zcHJpdGUudW5pZm9ybXMuc2NhbGUgICAgICAgICAgICAgICAgPSBfZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBfc3ByaXRlLnByb2dyYW0sIFwic2NhbGVcIiApO1xyXG5cdFx0X3Nwcml0ZS51bmlmb3Jtcy5hbGlnbm1lbnQgICAgICAgICAgICA9IF9nbC5nZXRVbmlmb3JtTG9jYXRpb24oIF9zcHJpdGUucHJvZ3JhbSwgXCJhbGlnbm1lbnRcIiApO1xyXG5cclxuXHRcdF9zcHJpdGUudW5pZm9ybXMuY29sb3IgICAgICAgICAgICAgICAgPSBfZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBfc3ByaXRlLnByb2dyYW0sIFwiY29sb3JcIiApO1xyXG5cdFx0X3Nwcml0ZS51bmlmb3Jtcy5tYXAgICAgICAgICAgICAgICAgICA9IF9nbC5nZXRVbmlmb3JtTG9jYXRpb24oIF9zcHJpdGUucHJvZ3JhbSwgXCJtYXBcIiApO1xyXG5cdFx0X3Nwcml0ZS51bmlmb3Jtcy5vcGFjaXR5ICAgICAgICAgICAgICA9IF9nbC5nZXRVbmlmb3JtTG9jYXRpb24oIF9zcHJpdGUucHJvZ3JhbSwgXCJvcGFjaXR5XCIgKTtcclxuXHJcblx0XHRfc3ByaXRlLnVuaWZvcm1zLnVzZVNjcmVlbkNvb3JkaW5hdGVzID0gX2dsLmdldFVuaWZvcm1Mb2NhdGlvbiggX3Nwcml0ZS5wcm9ncmFtLCBcInVzZVNjcmVlbkNvb3JkaW5hdGVzXCIgKTtcclxuXHRcdF9zcHJpdGUudW5pZm9ybXMuc2l6ZUF0dGVudWF0aW9uICAgXHQgID0gX2dsLmdldFVuaWZvcm1Mb2NhdGlvbiggX3Nwcml0ZS5wcm9ncmFtLCBcInNpemVBdHRlbnVhdGlvblwiICk7XHJcblx0XHRfc3ByaXRlLnVuaWZvcm1zLnNjcmVlblBvc2l0aW9uICAgIFx0ICA9IF9nbC5nZXRVbmlmb3JtTG9jYXRpb24oIF9zcHJpdGUucHJvZ3JhbSwgXCJzY3JlZW5Qb3NpdGlvblwiICk7XHJcblx0XHRfc3ByaXRlLnVuaWZvcm1zLm1vZGVsVmlld01hdHJpeCAgICAgID0gX2dsLmdldFVuaWZvcm1Mb2NhdGlvbiggX3Nwcml0ZS5wcm9ncmFtLCBcIm1vZGVsVmlld01hdHJpeFwiICk7XHJcblx0XHRfc3ByaXRlLnVuaWZvcm1zLnByb2plY3Rpb25NYXRyaXggICAgID0gX2dsLmdldFVuaWZvcm1Mb2NhdGlvbiggX3Nwcml0ZS5wcm9ncmFtLCBcInByb2plY3Rpb25NYXRyaXhcIiApO1xyXG5cclxuXHRcdF9zcHJpdGUudW5pZm9ybXMuZm9nVHlwZSBcdFx0ICBcdCAgPSBfZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBfc3ByaXRlLnByb2dyYW0sIFwiZm9nVHlwZVwiICk7XHJcblx0XHRfc3ByaXRlLnVuaWZvcm1zLmZvZ0RlbnNpdHkgXHRcdCAgPSBfZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBfc3ByaXRlLnByb2dyYW0sIFwiZm9nRGVuc2l0eVwiICk7XHJcblx0XHRfc3ByaXRlLnVuaWZvcm1zLmZvZ05lYXIgXHRcdCAgXHQgID0gX2dsLmdldFVuaWZvcm1Mb2NhdGlvbiggX3Nwcml0ZS5wcm9ncmFtLCBcImZvZ05lYXJcIiApO1xyXG5cdFx0X3Nwcml0ZS51bmlmb3Jtcy5mb2dGYXIgXHRcdCAgXHQgID0gX2dsLmdldFVuaWZvcm1Mb2NhdGlvbiggX3Nwcml0ZS5wcm9ncmFtLCBcImZvZ0ZhclwiICk7XHJcblx0XHRfc3ByaXRlLnVuaWZvcm1zLmZvZ0NvbG9yIFx0XHQgIFx0ICA9IF9nbC5nZXRVbmlmb3JtTG9jYXRpb24oIF9zcHJpdGUucHJvZ3JhbSwgXCJmb2dDb2xvclwiICk7XHJcblxyXG5cdFx0X3Nwcml0ZS51bmlmb3Jtcy5hbHBoYVRlc3QgXHRcdCAgXHQgID0gX2dsLmdldFVuaWZvcm1Mb2NhdGlvbiggX3Nwcml0ZS5wcm9ncmFtLCBcImFscGhhVGVzdFwiICk7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCBzY2VuZSwgY2FtZXJhLCB2aWV3cG9ydFdpZHRoLCB2aWV3cG9ydEhlaWdodCApIHtcclxuXHJcblx0XHR2YXIgc3ByaXRlcyA9IHNjZW5lLl9fd2ViZ2xTcHJpdGVzLFxyXG5cdFx0XHRuU3ByaXRlcyA9IHNwcml0ZXMubGVuZ3RoO1xyXG5cclxuXHRcdGlmICggISBuU3ByaXRlcyApIHJldHVybjtcclxuXHJcblx0XHR2YXIgYXR0cmlidXRlcyA9IF9zcHJpdGUuYXR0cmlidXRlcyxcclxuXHRcdFx0dW5pZm9ybXMgPSBfc3ByaXRlLnVuaWZvcm1zO1xyXG5cclxuXHRcdHZhciBpbnZBc3BlY3QgPSB2aWV3cG9ydEhlaWdodCAvIHZpZXdwb3J0V2lkdGg7XHJcblxyXG5cdFx0dmFyIGhhbGZWaWV3cG9ydFdpZHRoID0gdmlld3BvcnRXaWR0aCAqIDAuNSxcclxuXHRcdFx0aGFsZlZpZXdwb3J0SGVpZ2h0ID0gdmlld3BvcnRIZWlnaHQgKiAwLjU7XHJcblxyXG5cdFx0Ly8gc2V0dXAgZ2xcclxuXHJcblx0XHRfZ2wudXNlUHJvZ3JhbSggX3Nwcml0ZS5wcm9ncmFtICk7XHJcblxyXG5cdFx0X2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KCBhdHRyaWJ1dGVzLnBvc2l0aW9uICk7XHJcblx0XHRfZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoIGF0dHJpYnV0ZXMudXYgKTtcclxuXHJcblx0XHRfZ2wuZGlzYWJsZSggX2dsLkNVTExfRkFDRSApO1xyXG5cdFx0X2dsLmVuYWJsZSggX2dsLkJMRU5EICk7XHJcblxyXG5cdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIF9zcHJpdGUudmVydGV4QnVmZmVyICk7XHJcblx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5wb3NpdGlvbiwgMiwgX2dsLkZMT0FULCBmYWxzZSwgMiAqIDgsIDAgKTtcclxuXHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnV2LCAyLCBfZ2wuRkxPQVQsIGZhbHNlLCAyICogOCwgOCApO1xyXG5cclxuXHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIF9zcHJpdGUuZWxlbWVudEJ1ZmZlciApO1xyXG5cclxuXHRcdF9nbC51bmlmb3JtTWF0cml4NGZ2KCB1bmlmb3Jtcy5wcm9qZWN0aW9uTWF0cml4LCBmYWxzZSwgY2FtZXJhLnByb2plY3Rpb25NYXRyaXguZWxlbWVudHMgKTtcclxuXHJcblx0XHRfZ2wuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICk7XHJcblx0XHRfZ2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5tYXAsIDAgKTtcclxuXHJcblx0XHR2YXIgb2xkRm9nVHlwZSA9IDA7XHJcblx0XHR2YXIgc2NlbmVGb2dUeXBlID0gMDtcclxuXHRcdHZhciBmb2cgPSBzY2VuZS5mb2c7XHJcblxyXG5cdFx0aWYgKCBmb2cgKSB7XHJcblxyXG5cdFx0XHRfZ2wudW5pZm9ybTNmKCB1bmlmb3Jtcy5mb2dDb2xvciwgZm9nLmNvbG9yLnIsIGZvZy5jb2xvci5nLCBmb2cuY29sb3IuYiApO1xyXG5cclxuXHRcdFx0aWYgKCBmb2cgaW5zdGFuY2VvZiBUSFJFRS5Gb2cgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC51bmlmb3JtMWYoIHVuaWZvcm1zLmZvZ05lYXIsIGZvZy5uZWFyICk7XHJcblx0XHRcdFx0X2dsLnVuaWZvcm0xZiggdW5pZm9ybXMuZm9nRmFyLCBmb2cuZmFyICk7XHJcblxyXG5cdFx0XHRcdF9nbC51bmlmb3JtMWkoIHVuaWZvcm1zLmZvZ1R5cGUsIDEgKTtcclxuXHRcdFx0XHRvbGRGb2dUeXBlID0gMTtcclxuXHRcdFx0XHRzY2VuZUZvZ1R5cGUgPSAxO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggZm9nIGluc3RhbmNlb2YgVEhSRUUuRm9nRXhwMiApIHtcclxuXHJcblx0XHRcdFx0X2dsLnVuaWZvcm0xZiggdW5pZm9ybXMuZm9nRGVuc2l0eSwgZm9nLmRlbnNpdHkgKTtcclxuXHJcblx0XHRcdFx0X2dsLnVuaWZvcm0xaSggdW5pZm9ybXMuZm9nVHlwZSwgMiApO1xyXG5cdFx0XHRcdG9sZEZvZ1R5cGUgPSAyO1xyXG5cdFx0XHRcdHNjZW5lRm9nVHlwZSA9IDI7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdF9nbC51bmlmb3JtMWkoIHVuaWZvcm1zLmZvZ1R5cGUsIDAgKTtcclxuXHRcdFx0b2xkRm9nVHlwZSA9IDA7XHJcblx0XHRcdHNjZW5lRm9nVHlwZSA9IDA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHJcblx0XHQvLyB1cGRhdGUgcG9zaXRpb25zIGFuZCBzb3J0XHJcblxyXG5cdFx0dmFyIGksIHNwcml0ZSwgbWF0ZXJpYWwsIHNjcmVlblBvc2l0aW9uLCBzaXplLCBmb2dUeXBlLCBzY2FsZSA9IFtdO1xyXG5cclxuXHRcdGZvciggaSA9IDA7IGkgPCBuU3ByaXRlczsgaSArKyApIHtcclxuXHJcblx0XHRcdHNwcml0ZSA9IHNwcml0ZXNbIGkgXTtcclxuXHRcdFx0bWF0ZXJpYWwgPSBzcHJpdGUubWF0ZXJpYWw7XHJcblxyXG5cdFx0XHRpZiAoICEgc3ByaXRlLnZpc2libGUgfHwgbWF0ZXJpYWwub3BhY2l0eSA9PT0gMCApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0aWYgKCAhIG1hdGVyaWFsLnVzZVNjcmVlbkNvb3JkaW5hdGVzICkge1xyXG5cclxuXHRcdFx0XHRzcHJpdGUuX21vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLCBzcHJpdGUubWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHRzcHJpdGUueiA9IC0gc3ByaXRlLl9tb2RlbFZpZXdNYXRyaXguZWxlbWVudHNbIDE0IF07XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRzcHJpdGUueiA9IC0gc3ByaXRlLnBvc2l0aW9uLno7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHNwcml0ZXMuc29ydCggcGFpbnRlclNvcnRTdGFibGUgKTtcclxuXHJcblx0XHQvLyByZW5kZXIgYWxsIHNwcml0ZXNcclxuXHJcblx0XHRmb3IoIGkgPSAwOyBpIDwgblNwcml0ZXM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRzcHJpdGUgPSBzcHJpdGVzWyBpIF07XHJcblx0XHRcdG1hdGVyaWFsID0gc3ByaXRlLm1hdGVyaWFsO1xyXG5cclxuXHRcdFx0aWYgKCAhIHNwcml0ZS52aXNpYmxlIHx8IG1hdGVyaWFsLm9wYWNpdHkgPT09IDAgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwubWFwICYmIG1hdGVyaWFsLm1hcC5pbWFnZSAmJiBtYXRlcmlhbC5tYXAuaW1hZ2Uud2lkdGggKSB7XHJcblxyXG5cdFx0XHRcdF9nbC51bmlmb3JtMWYoIHVuaWZvcm1zLmFscGhhVGVzdCwgbWF0ZXJpYWwuYWxwaGFUZXN0ICk7XHJcblxyXG5cdFx0XHRcdGlmICggbWF0ZXJpYWwudXNlU2NyZWVuQ29vcmRpbmF0ZXMgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0xaSggdW5pZm9ybXMudXNlU2NyZWVuQ29vcmRpbmF0ZXMsIDEgKTtcclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtM2YoXHJcblx0XHRcdFx0XHRcdHVuaWZvcm1zLnNjcmVlblBvc2l0aW9uLFxyXG5cdFx0XHRcdFx0XHQoICggc3ByaXRlLnBvc2l0aW9uLnggKiBfcmVuZGVyZXIuZGV2aWNlUGl4ZWxSYXRpbyApIC0gaGFsZlZpZXdwb3J0V2lkdGggICkgLyBoYWxmVmlld3BvcnRXaWR0aCxcclxuXHRcdFx0XHRcdFx0KCBoYWxmVmlld3BvcnRIZWlnaHQgLSAoIHNwcml0ZS5wb3NpdGlvbi55ICogX3JlbmRlcmVyLmRldmljZVBpeGVsUmF0aW8gKSApIC8gaGFsZlZpZXdwb3J0SGVpZ2h0LFxyXG5cdFx0XHRcdFx0XHRNYXRoLm1heCggMCwgTWF0aC5taW4oIDEsIHNwcml0ZS5wb3NpdGlvbi56ICkgKVxyXG5cdFx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0XHRzY2FsZVsgMCBdID0gX3JlbmRlcmVyLmRldmljZVBpeGVsUmF0aW87XHJcblx0XHRcdFx0XHRzY2FsZVsgMSBdID0gX3JlbmRlcmVyLmRldmljZVBpeGVsUmF0aW87XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0xaSggdW5pZm9ybXMudXNlU2NyZWVuQ29vcmRpbmF0ZXMsIDAgKTtcclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtMWkoIHVuaWZvcm1zLnNpemVBdHRlbnVhdGlvbiwgbWF0ZXJpYWwuc2l6ZUF0dGVudWF0aW9uID8gMSA6IDAgKTtcclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtTWF0cml4NGZ2KCB1bmlmb3Jtcy5tb2RlbFZpZXdNYXRyaXgsIGZhbHNlLCBzcHJpdGUuX21vZGVsVmlld01hdHJpeC5lbGVtZW50cyApO1xyXG5cclxuXHRcdFx0XHRcdHNjYWxlWyAwIF0gPSAxO1xyXG5cdFx0XHRcdFx0c2NhbGVbIDEgXSA9IDE7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBzY2VuZS5mb2cgJiYgbWF0ZXJpYWwuZm9nICkge1xyXG5cclxuXHRcdFx0XHRcdGZvZ1R5cGUgPSBzY2VuZUZvZ1R5cGU7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0Zm9nVHlwZSA9IDA7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBvbGRGb2dUeXBlICE9PSBmb2dUeXBlICkge1xyXG5cclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtMWkoIHVuaWZvcm1zLmZvZ1R5cGUsIGZvZ1R5cGUgKTtcclxuXHRcdFx0XHRcdG9sZEZvZ1R5cGUgPSBmb2dUeXBlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHNpemUgPSAxIC8gKCBtYXRlcmlhbC5zY2FsZUJ5Vmlld3BvcnQgPyB2aWV3cG9ydEhlaWdodCA6IDEgKTtcclxuXHJcblx0XHRcdFx0c2NhbGVbIDAgXSAqPSBzaXplICogaW52QXNwZWN0ICogc3ByaXRlLnNjYWxlLnhcclxuXHRcdFx0XHRzY2FsZVsgMSBdICo9IHNpemUgKiBzcHJpdGUuc2NhbGUueTtcclxuXHJcblx0XHRcdFx0X2dsLnVuaWZvcm0yZiggdW5pZm9ybXMudXZTY2FsZSwgbWF0ZXJpYWwudXZTY2FsZS54LCBtYXRlcmlhbC51dlNjYWxlLnkgKTtcclxuXHRcdFx0XHRfZ2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dk9mZnNldCwgbWF0ZXJpYWwudXZPZmZzZXQueCwgbWF0ZXJpYWwudXZPZmZzZXQueSApO1xyXG5cdFx0XHRcdF9nbC51bmlmb3JtMmYoIHVuaWZvcm1zLmFsaWdubWVudCwgbWF0ZXJpYWwuYWxpZ25tZW50LngsIG1hdGVyaWFsLmFsaWdubWVudC55ICk7XHJcblxyXG5cdFx0XHRcdF9nbC51bmlmb3JtMWYoIHVuaWZvcm1zLm9wYWNpdHksIG1hdGVyaWFsLm9wYWNpdHkgKTtcclxuXHRcdFx0XHRfZ2wudW5pZm9ybTNmKCB1bmlmb3Jtcy5jb2xvciwgbWF0ZXJpYWwuY29sb3IuciwgbWF0ZXJpYWwuY29sb3IuZywgbWF0ZXJpYWwuY29sb3IuYiApO1xyXG5cclxuXHRcdFx0XHRfZ2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5yb3RhdGlvbiwgc3ByaXRlLnJvdGF0aW9uICk7XHJcblx0XHRcdFx0X2dsLnVuaWZvcm0yZnYoIHVuaWZvcm1zLnNjYWxlLCBzY2FsZSApO1xyXG5cclxuXHRcdFx0XHRfcmVuZGVyZXIuc2V0QmxlbmRpbmcoIG1hdGVyaWFsLmJsZW5kaW5nLCBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uLCBtYXRlcmlhbC5ibGVuZFNyYywgbWF0ZXJpYWwuYmxlbmREc3QgKTtcclxuXHRcdFx0XHRfcmVuZGVyZXIuc2V0RGVwdGhUZXN0KCBtYXRlcmlhbC5kZXB0aFRlc3QgKTtcclxuXHRcdFx0XHRfcmVuZGVyZXIuc2V0RGVwdGhXcml0ZSggbWF0ZXJpYWwuZGVwdGhXcml0ZSApO1xyXG5cdFx0XHRcdF9yZW5kZXJlci5zZXRUZXh0dXJlKCBtYXRlcmlhbC5tYXAsIDAgKTtcclxuXHJcblx0XHRcdFx0X2dsLmRyYXdFbGVtZW50cyggX2dsLlRSSUFOR0xFUywgNiwgX2dsLlVOU0lHTkVEX1NIT1JULCAwICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHJlc3RvcmUgZ2xcclxuXHJcblx0XHRfZ2wuZW5hYmxlKCBfZ2wuQ1VMTF9GQUNFICk7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGNyZWF0ZVByb2dyYW0gKCBzaGFkZXIsIHByZWNpc2lvbiApIHtcclxuXHJcblx0XHR2YXIgcHJvZ3JhbSA9IF9nbC5jcmVhdGVQcm9ncmFtKCk7XHJcblxyXG5cdFx0dmFyIGZyYWdtZW50U2hhZGVyID0gX2dsLmNyZWF0ZVNoYWRlciggX2dsLkZSQUdNRU5UX1NIQURFUiApO1xyXG5cdFx0dmFyIHZlcnRleFNoYWRlciA9IF9nbC5jcmVhdGVTaGFkZXIoIF9nbC5WRVJURVhfU0hBREVSICk7XHJcblxyXG5cdFx0dmFyIHByZWZpeCA9IFwicHJlY2lzaW9uIFwiICsgcHJlY2lzaW9uICsgXCIgZmxvYXQ7XFxuXCI7XHJcblxyXG5cdFx0X2dsLnNoYWRlclNvdXJjZSggZnJhZ21lbnRTaGFkZXIsIHByZWZpeCArIHNoYWRlci5mcmFnbWVudFNoYWRlciApO1xyXG5cdFx0X2dsLnNoYWRlclNvdXJjZSggdmVydGV4U2hhZGVyLCBwcmVmaXggKyBzaGFkZXIudmVydGV4U2hhZGVyICk7XHJcblxyXG5cdFx0X2dsLmNvbXBpbGVTaGFkZXIoIGZyYWdtZW50U2hhZGVyICk7XHJcblx0XHRfZ2wuY29tcGlsZVNoYWRlciggdmVydGV4U2hhZGVyICk7XHJcblxyXG5cdFx0X2dsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIgKTtcclxuXHRcdF9nbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIHZlcnRleFNoYWRlciApO1xyXG5cclxuXHRcdF9nbC5saW5rUHJvZ3JhbSggcHJvZ3JhbSApO1xyXG5cclxuXHRcdHJldHVybiBwcm9ncmFtO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBwYWludGVyU29ydFN0YWJsZSAoIGEsIGIgKSB7XHJcblxyXG5cdFx0aWYgKCBhLnogIT09IGIueiApIHtcclxuXHJcblx0XHRcdHJldHVybiBiLnogLSBhLno7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHJldHVybiBiLmlkIC0gYS5pZDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG59O1xyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5EZXB0aFBhc3NQbHVnaW4gPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xyXG5cdHRoaXMucmVuZGVyVGFyZ2V0ID0gbnVsbDtcclxuXHJcblx0dmFyIF9nbCxcclxuXHRfcmVuZGVyZXIsXHJcblx0X2RlcHRoTWF0ZXJpYWwsIF9kZXB0aE1hdGVyaWFsTW9ycGgsIF9kZXB0aE1hdGVyaWFsU2tpbiwgX2RlcHRoTWF0ZXJpYWxNb3JwaFNraW4sXHJcblxyXG5cdF9mcnVzdHVtID0gbmV3IFRIUkVFLkZydXN0dW0oKSxcclxuXHRfcHJvalNjcmVlbk1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG5cdHRoaXMuaW5pdCA9IGZ1bmN0aW9uICggcmVuZGVyZXIgKSB7XHJcblxyXG5cdFx0X2dsID0gcmVuZGVyZXIuY29udGV4dDtcclxuXHRcdF9yZW5kZXJlciA9IHJlbmRlcmVyO1xyXG5cclxuXHRcdHZhciBkZXB0aFNoYWRlciA9IFRIUkVFLlNoYWRlckxpYlsgXCJkZXB0aFJHQkFcIiBdO1xyXG5cdFx0dmFyIGRlcHRoVW5pZm9ybXMgPSBUSFJFRS5Vbmlmb3Jtc1V0aWxzLmNsb25lKCBkZXB0aFNoYWRlci51bmlmb3JtcyApO1xyXG5cclxuXHRcdF9kZXB0aE1hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKCB7IGZyYWdtZW50U2hhZGVyOiBkZXB0aFNoYWRlci5mcmFnbWVudFNoYWRlciwgdmVydGV4U2hhZGVyOiBkZXB0aFNoYWRlci52ZXJ0ZXhTaGFkZXIsIHVuaWZvcm1zOiBkZXB0aFVuaWZvcm1zIH0gKTtcclxuXHRcdF9kZXB0aE1hdGVyaWFsTW9ycGggPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoIHsgZnJhZ21lbnRTaGFkZXI6IGRlcHRoU2hhZGVyLmZyYWdtZW50U2hhZGVyLCB2ZXJ0ZXhTaGFkZXI6IGRlcHRoU2hhZGVyLnZlcnRleFNoYWRlciwgdW5pZm9ybXM6IGRlcHRoVW5pZm9ybXMsIG1vcnBoVGFyZ2V0czogdHJ1ZSB9ICk7XHJcblx0XHRfZGVwdGhNYXRlcmlhbFNraW4gPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoIHsgZnJhZ21lbnRTaGFkZXI6IGRlcHRoU2hhZGVyLmZyYWdtZW50U2hhZGVyLCB2ZXJ0ZXhTaGFkZXI6IGRlcHRoU2hhZGVyLnZlcnRleFNoYWRlciwgdW5pZm9ybXM6IGRlcHRoVW5pZm9ybXMsIHNraW5uaW5nOiB0cnVlIH0gKTtcclxuXHRcdF9kZXB0aE1hdGVyaWFsTW9ycGhTa2luID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKCB7IGZyYWdtZW50U2hhZGVyOiBkZXB0aFNoYWRlci5mcmFnbWVudFNoYWRlciwgdmVydGV4U2hhZGVyOiBkZXB0aFNoYWRlci52ZXJ0ZXhTaGFkZXIsIHVuaWZvcm1zOiBkZXB0aFVuaWZvcm1zLCBtb3JwaFRhcmdldHM6IHRydWUsIHNraW5uaW5nOiB0cnVlIH0gKTtcclxuXHJcblx0XHRfZGVwdGhNYXRlcmlhbC5fc2hhZG93UGFzcyA9IHRydWU7XHJcblx0XHRfZGVwdGhNYXRlcmlhbE1vcnBoLl9zaGFkb3dQYXNzID0gdHJ1ZTtcclxuXHRcdF9kZXB0aE1hdGVyaWFsU2tpbi5fc2hhZG93UGFzcyA9IHRydWU7XHJcblx0XHRfZGVwdGhNYXRlcmlhbE1vcnBoU2tpbi5fc2hhZG93UGFzcyA9IHRydWU7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCBzY2VuZSwgY2FtZXJhICkge1xyXG5cclxuXHRcdGlmICggISB0aGlzLmVuYWJsZWQgKSByZXR1cm47XHJcblxyXG5cdFx0dGhpcy51cGRhdGUoIHNjZW5lLCBjYW1lcmEgKTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy51cGRhdGUgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEgKSB7XHJcblxyXG5cdFx0dmFyIGksIGlsLCBqLCBqbCwgbixcclxuXHJcblx0XHRwcm9ncmFtLCBidWZmZXIsIG1hdGVyaWFsLFxyXG5cdFx0d2ViZ2xPYmplY3QsIG9iamVjdCwgbGlnaHQsXHJcblx0XHRyZW5kZXJMaXN0LFxyXG5cclxuXHRcdGZvZyA9IG51bGw7XHJcblxyXG5cdFx0Ly8gc2V0IEdMIHN0YXRlIGZvciBkZXB0aCBtYXBcclxuXHJcblx0XHRfZ2wuY2xlYXJDb2xvciggMSwgMSwgMSwgMSApO1xyXG5cdFx0X2dsLmRpc2FibGUoIF9nbC5CTEVORCApO1xyXG5cclxuXHRcdF9yZW5kZXJlci5zZXREZXB0aFRlc3QoIHRydWUgKTtcclxuXHJcblx0XHQvLyB1cGRhdGUgc2NlbmVcclxuXHJcblx0XHRpZiAoIF9yZW5kZXJlci5hdXRvVXBkYXRlU2NlbmUgKSBzY2VuZS51cGRhdGVNYXRyaXhXb3JsZCgpO1xyXG5cclxuXHRcdC8vIHVwZGF0ZSBjYW1lcmEgbWF0cmljZXMgYW5kIGZydXN0dW1cclxuXHJcblx0XHRjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLmdldEludmVyc2UoIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdF9wcm9qU2NyZWVuTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XHJcblx0XHRfZnJ1c3R1bS5zZXRGcm9tTWF0cml4KCBfcHJvalNjcmVlbk1hdHJpeCApO1xyXG5cclxuXHRcdC8vIHJlbmRlciBkZXB0aCBtYXBcclxuXHJcblx0XHRfcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCB0aGlzLnJlbmRlclRhcmdldCApO1xyXG5cdFx0X3JlbmRlcmVyLmNsZWFyKCk7XHJcblxyXG5cdFx0Ly8gc2V0IG9iamVjdCBtYXRyaWNlcyAmIGZydXN0dW0gY3VsbGluZ1xyXG5cclxuXHRcdHJlbmRlckxpc3QgPSBzY2VuZS5fX3dlYmdsT2JqZWN0cztcclxuXHJcblx0XHRmb3IgKCBqID0gMCwgamwgPSByZW5kZXJMaXN0Lmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0d2ViZ2xPYmplY3QgPSByZW5kZXJMaXN0WyBqIF07XHJcblx0XHRcdG9iamVjdCA9IHdlYmdsT2JqZWN0Lm9iamVjdDtcclxuXHJcblx0XHRcdHdlYmdsT2JqZWN0LnJlbmRlciA9IGZhbHNlO1xyXG5cclxuXHRcdFx0aWYgKCBvYmplY3QudmlzaWJsZSApIHtcclxuXHJcblx0XHRcdFx0aWYgKCAhICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTWVzaCB8fCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5QYXJ0aWNsZVN5c3RlbSApIHx8ICEgKCBvYmplY3QuZnJ1c3R1bUN1bGxlZCApIHx8IF9mcnVzdHVtLmludGVyc2VjdHNPYmplY3QoIG9iamVjdCApICkge1xyXG5cclxuXHRcdFx0XHRcdG9iamVjdC5fbW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsIG9iamVjdC5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0XHRcdHdlYmdsT2JqZWN0LnJlbmRlciA9IHRydWU7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gcmVuZGVyIHJlZ3VsYXIgb2JqZWN0c1xyXG5cclxuXHRcdHZhciBvYmplY3RNYXRlcmlhbCwgdXNlTW9ycGhpbmcsIHVzZVNraW5uaW5nO1xyXG5cclxuXHRcdGZvciAoIGogPSAwLCBqbCA9IHJlbmRlckxpc3QubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHR3ZWJnbE9iamVjdCA9IHJlbmRlckxpc3RbIGogXTtcclxuXHJcblx0XHRcdGlmICggd2ViZ2xPYmplY3QucmVuZGVyICkge1xyXG5cclxuXHRcdFx0XHRvYmplY3QgPSB3ZWJnbE9iamVjdC5vYmplY3Q7XHJcblx0XHRcdFx0YnVmZmVyID0gd2ViZ2xPYmplY3QuYnVmZmVyO1xyXG5cclxuXHRcdFx0XHQvLyB0b2RvOiBjcmVhdGUgcHJvcGVyIGRlcHRoIG1hdGVyaWFsIGZvciBwYXJ0aWNsZXNcclxuXHJcblx0XHRcdFx0aWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5QYXJ0aWNsZVN5c3RlbSAmJiAhb2JqZWN0LmN1c3RvbURlcHRoTWF0ZXJpYWwgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0b2JqZWN0TWF0ZXJpYWwgPSBnZXRPYmplY3RNYXRlcmlhbCggb2JqZWN0ICk7XHJcblxyXG5cdFx0XHRcdGlmICggb2JqZWN0TWF0ZXJpYWwgKSBfcmVuZGVyZXIuc2V0TWF0ZXJpYWxGYWNlcyggb2JqZWN0Lm1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHRcdHVzZU1vcnBoaW5nID0gb2JqZWN0Lmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGggPiAwICYmIG9iamVjdE1hdGVyaWFsLm1vcnBoVGFyZ2V0cztcclxuXHRcdFx0XHR1c2VTa2lubmluZyA9IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlNraW5uZWRNZXNoICYmIG9iamVjdE1hdGVyaWFsLnNraW5uaW5nO1xyXG5cclxuXHRcdFx0XHRpZiAoIG9iamVjdC5jdXN0b21EZXB0aE1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRcdG1hdGVyaWFsID0gb2JqZWN0LmN1c3RvbURlcHRoTWF0ZXJpYWw7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHVzZVNraW5uaW5nICkge1xyXG5cclxuXHRcdFx0XHRcdG1hdGVyaWFsID0gdXNlTW9ycGhpbmcgPyBfZGVwdGhNYXRlcmlhbE1vcnBoU2tpbiA6IF9kZXB0aE1hdGVyaWFsU2tpbjtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggdXNlTW9ycGhpbmcgKSB7XHJcblxyXG5cdFx0XHRcdFx0bWF0ZXJpYWwgPSBfZGVwdGhNYXRlcmlhbE1vcnBoO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdG1hdGVyaWFsID0gX2RlcHRoTWF0ZXJpYWw7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBidWZmZXIgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcclxuXHJcblx0XHRcdFx0XHRfcmVuZGVyZXIucmVuZGVyQnVmZmVyRGlyZWN0KCBjYW1lcmEsIHNjZW5lLl9fbGlnaHRzLCBmb2csIG1hdGVyaWFsLCBidWZmZXIsIG9iamVjdCApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdF9yZW5kZXJlci5yZW5kZXJCdWZmZXIoIGNhbWVyYSwgc2NlbmUuX19saWdodHMsIGZvZywgbWF0ZXJpYWwsIGJ1ZmZlciwgb2JqZWN0ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc2V0IG1hdHJpY2VzIGFuZCByZW5kZXIgaW1tZWRpYXRlIG9iamVjdHNcclxuXHJcblx0XHRyZW5kZXJMaXN0ID0gc2NlbmUuX193ZWJnbE9iamVjdHNJbW1lZGlhdGU7XHJcblxyXG5cdFx0Zm9yICggaiA9IDAsIGpsID0gcmVuZGVyTGlzdC5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdHdlYmdsT2JqZWN0ID0gcmVuZGVyTGlzdFsgaiBdO1xyXG5cdFx0XHRvYmplY3QgPSB3ZWJnbE9iamVjdC5vYmplY3Q7XHJcblxyXG5cdFx0XHRpZiAoIG9iamVjdC52aXNpYmxlICkge1xyXG5cclxuXHRcdFx0XHRvYmplY3QuX21vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLCBvYmplY3QubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdFx0X3JlbmRlcmVyLnJlbmRlckltbWVkaWF0ZU9iamVjdCggY2FtZXJhLCBzY2VuZS5fX2xpZ2h0cywgZm9nLCBfZGVwdGhNYXRlcmlhbCwgb2JqZWN0ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHJlc3RvcmUgR0wgc3RhdGVcclxuXHJcblx0XHR2YXIgY2xlYXJDb2xvciA9IF9yZW5kZXJlci5nZXRDbGVhckNvbG9yKCksXHJcblx0XHRjbGVhckFscGhhID0gX3JlbmRlcmVyLmdldENsZWFyQWxwaGEoKTtcclxuXHJcblx0XHRfZ2wuY2xlYXJDb2xvciggY2xlYXJDb2xvci5yLCBjbGVhckNvbG9yLmcsIGNsZWFyQ29sb3IuYiwgY2xlYXJBbHBoYSApO1xyXG5cdFx0X2dsLmVuYWJsZSggX2dsLkJMRU5EICk7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIEZvciB0aGUgbW9tZW50IGp1c3QgaWdub3JlIG9iamVjdHMgdGhhdCBoYXZlIG11bHRpcGxlIG1hdGVyaWFscyB3aXRoIGRpZmZlcmVudCBhbmltYXRpb24gbWV0aG9kc1xyXG5cdC8vIE9ubHkgdGhlIGZpcnN0IG1hdGVyaWFsIHdpbGwgYmUgdGFrZW4gaW50byBhY2NvdW50IGZvciBkZWNpZGluZyB3aGljaCBkZXB0aCBtYXRlcmlhbCB0byB1c2VcclxuXHJcblx0ZnVuY3Rpb24gZ2V0T2JqZWN0TWF0ZXJpYWwoIG9iamVjdCApIHtcclxuXHJcblx0XHRyZXR1cm4gb2JqZWN0Lm1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaEZhY2VNYXRlcmlhbFxyXG5cdFx0XHQ/IG9iamVjdC5tYXRlcmlhbC5tYXRlcmlhbHNbIDAgXVxyXG5cdFx0XHQ6IG9iamVjdC5tYXRlcmlhbDtcclxuXHJcblx0fTtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICpcclxuICovXHJcblxyXG5USFJFRS5TaGFkZXJGbGFyZXMgPSB7XHJcblxyXG5cdCdsZW5zRmxhcmVWZXJ0ZXhUZXh0dXJlJzoge1xyXG5cclxuXHRcdHZlcnRleFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIGxvd3AgaW50IHJlbmRlclR5cGU7XCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBzY3JlZW5Qb3NpdGlvbjtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzIgc2NhbGU7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCByb3RhdGlvbjtcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgb2NjbHVzaW9uTWFwO1wiLFxyXG5cclxuXHRcdFx0XCJhdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbjtcIixcclxuXHRcdFx0XCJhdHRyaWJ1dGUgdmVjMiB1djtcIixcclxuXHJcblx0XHRcdFwidmFyeWluZyB2ZWMyIHZVVjtcIixcclxuXHRcdFx0XCJ2YXJ5aW5nIGZsb2F0IHZWaXNpYmlsaXR5O1wiLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcdFwidlVWID0gdXY7XCIsXHJcblxyXG5cdFx0XHRcdFwidmVjMiBwb3MgPSBwb3NpdGlvbjtcIixcclxuXHJcblx0XHRcdFx0XCJpZiggcmVuZGVyVHlwZSA9PSAyICkge1wiLFxyXG5cclxuXHRcdFx0XHRcdFwidmVjNCB2aXNpYmlsaXR5ID0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuMSwgMC4xICkgKSArXCIsXHJcblx0XHRcdFx0XHRcdFx0XHRcdCAgXCJ0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC41LCAwLjEgKSApICtcIixcclxuXHRcdFx0XHRcdFx0XHRcdFx0ICBcInRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjksIDAuMSApICkgK1wiLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHQgIFwidGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuOSwgMC41ICkgKSArXCIsXHJcblx0XHRcdFx0XHRcdFx0XHRcdCAgXCJ0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC45LCAwLjkgKSApICtcIixcclxuXHRcdFx0XHRcdFx0XHRcdFx0ICBcInRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuOSApICkgK1wiLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHQgIFwidGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuMSwgMC45ICkgKSArXCIsXHJcblx0XHRcdFx0XHRcdFx0XHRcdCAgXCJ0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC4xLCAwLjUgKSApICtcIixcclxuXHRcdFx0XHRcdFx0XHRcdFx0ICBcInRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuNSApICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ2VmlzaWJpbGl0eSA9ICggICAgICAgdmlzaWJpbGl0eS5yIC8gOS4wICkgKlwiLFxyXG5cdFx0XHRcdFx0XHRcdFx0ICBcIiggMS4wIC0gdmlzaWJpbGl0eS5nIC8gOS4wICkgKlwiLFxyXG5cdFx0XHRcdFx0XHRcdFx0ICBcIiggICAgICAgdmlzaWJpbGl0eS5iIC8gOS4wICkgKlwiLFxyXG5cdFx0XHRcdFx0XHRcdFx0ICBcIiggMS4wIC0gdmlzaWJpbGl0eS5hIC8gOS4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJwb3MueCA9IGNvcyggcm90YXRpb24gKSAqIHBvc2l0aW9uLnggLSBzaW4oIHJvdGF0aW9uICkgKiBwb3NpdGlvbi55O1wiLFxyXG5cdFx0XHRcdFx0XCJwb3MueSA9IHNpbiggcm90YXRpb24gKSAqIHBvc2l0aW9uLnggKyBjb3MoIHJvdGF0aW9uICkgKiBwb3NpdGlvbi55O1wiLFxyXG5cclxuXHRcdFx0XHRcIn1cIixcclxuXHJcblx0XHRcdFx0XCJnbF9Qb3NpdGlvbiA9IHZlYzQoICggcG9zICogc2NhbGUgKyBzY3JlZW5Qb3NpdGlvbi54eSApLnh5LCBzY3JlZW5Qb3NpdGlvbi56LCAxLjAgKTtcIixcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKCBcIlxcblwiICksXHJcblxyXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwidW5pZm9ybSBsb3dwIGludCByZW5kZXJUeXBlO1wiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCBtYXA7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBjb2xvcjtcIixcclxuXHJcblx0XHRcdFwidmFyeWluZyB2ZWMyIHZVVjtcIixcclxuXHRcdFx0XCJ2YXJ5aW5nIGZsb2F0IHZWaXNpYmlsaXR5O1wiLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcdC8vIHBpbmsgc3F1YXJlXHJcblxyXG5cdFx0XHRcdFwiaWYoIHJlbmRlclR5cGUgPT0gMCApIHtcIixcclxuXHJcblx0XHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IHZlYzQoIDEuMCwgMC4wLCAxLjAsIDAuMCApO1wiLFxyXG5cclxuXHRcdFx0XHQvLyByZXN0b3JlXHJcblxyXG5cdFx0XHRcdFwifSBlbHNlIGlmKCByZW5kZXJUeXBlID09IDEgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQoIG1hcCwgdlVWICk7XCIsXHJcblxyXG5cdFx0XHRcdC8vIGZsYXJlXHJcblxyXG5cdFx0XHRcdFwifSBlbHNlIHtcIixcclxuXHJcblx0XHRcdFx0XHRcInZlYzQgdGV4dHVyZSA9IHRleHR1cmUyRCggbWFwLCB2VVYgKTtcIixcclxuXHRcdFx0XHRcdFwidGV4dHVyZS5hICo9IG9wYWNpdHkgKiB2VmlzaWJpbGl0eTtcIixcclxuXHRcdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTtcIixcclxuXHRcdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yLnJnYiAqPSBjb2xvcjtcIixcclxuXHJcblx0XHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XHRcIn1cIlxyXG5cdFx0XS5qb2luKCBcIlxcblwiIClcclxuXHJcblx0fSxcclxuXHJcblxyXG5cdCdsZW5zRmxhcmUnOiB7XHJcblxyXG5cdFx0dmVydGV4U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gbG93cCBpbnQgcmVuZGVyVHlwZTtcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIHNjcmVlblBvc2l0aW9uO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMiBzY2FsZTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHJvdGF0aW9uO1wiLFxyXG5cclxuXHRcdFx0XCJhdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbjtcIixcclxuXHRcdFx0XCJhdHRyaWJ1dGUgdmVjMiB1djtcIixcclxuXHJcblx0XHRcdFwidmFyeWluZyB2ZWMyIHZVVjtcIixcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XHRcInZVViA9IHV2O1wiLFxyXG5cclxuXHRcdFx0XHRcInZlYzIgcG9zID0gcG9zaXRpb247XCIsXHJcblxyXG5cdFx0XHRcdFwiaWYoIHJlbmRlclR5cGUgPT0gMiApIHtcIixcclxuXHJcblx0XHRcdFx0XHRcInBvcy54ID0gY29zKCByb3RhdGlvbiApICogcG9zaXRpb24ueCAtIHNpbiggcm90YXRpb24gKSAqIHBvc2l0aW9uLnk7XCIsXHJcblx0XHRcdFx0XHRcInBvcy55ID0gc2luKCByb3RhdGlvbiApICogcG9zaXRpb24ueCArIGNvcyggcm90YXRpb24gKSAqIHBvc2l0aW9uLnk7XCIsXHJcblxyXG5cdFx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFx0XHRcImdsX1Bvc2l0aW9uID0gdmVjNCggKCBwb3MgKiBzY2FsZSArIHNjcmVlblBvc2l0aW9uLnh5ICkueHksIHNjcmVlblBvc2l0aW9uLnosIDEuMCApO1wiLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oIFwiXFxuXCIgKSxcclxuXHJcblx0XHRmcmFnbWVudFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSBsb3dwIGludCByZW5kZXJUeXBlO1wiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCBtYXA7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgb2NjbHVzaW9uTWFwO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgY29sb3I7XCIsXHJcblxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMiB2VVY7XCIsXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFx0Ly8gcGluayBzcXVhcmVcclxuXHJcblx0XHRcdFx0XCJpZiggcmVuZGVyVHlwZSA9PSAwICkge1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdmVjNCggdGV4dHVyZTJEKCBtYXAsIHZVViApLnJnYiwgMC4wICk7XCIsXHJcblxyXG5cdFx0XHRcdC8vIHJlc3RvcmVcclxuXHJcblx0XHRcdFx0XCJ9IGVsc2UgaWYoIHJlbmRlclR5cGUgPT0gMSApIHtcIixcclxuXHJcblx0XHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCggbWFwLCB2VVYgKTtcIixcclxuXHJcblx0XHRcdFx0Ly8gZmxhcmVcclxuXHJcblx0XHRcdFx0XCJ9IGVsc2Uge1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiZmxvYXQgdmlzaWJpbGl0eSA9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuMSApICkuYSArXCIsXHJcblx0XHRcdFx0XHRcdFx0XHRcdCAgIFwidGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuOSwgMC41ICkgKS5hICtcIixcclxuXHRcdFx0XHRcdFx0XHRcdFx0ICAgXCJ0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC41LCAwLjkgKSApLmEgK1wiLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHQgICBcInRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjEsIDAuNSApICkuYTtcIixcclxuXHJcblx0XHRcdFx0XHRcInZpc2liaWxpdHkgPSAoIDEuMCAtIHZpc2liaWxpdHkgLyA0LjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcInZlYzQgdGV4dHVyZSA9IHRleHR1cmUyRCggbWFwLCB2VVYgKTtcIixcclxuXHRcdFx0XHRcdFwidGV4dHVyZS5hICo9IG9wYWNpdHkgKiB2aXNpYmlsaXR5O1wiLFxyXG5cdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlO1wiLFxyXG5cdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IucmdiICo9IGNvbG9yO1wiLFxyXG5cclxuXHRcdFx0XHRcIn1cIixcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKCBcIlxcblwiIClcclxuXHJcblx0fVxyXG5cclxufTtcclxuLyoqXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqXHJcbiAqL1xyXG5cclxuVEhSRUUuU2hhZGVyU3ByaXRlID0ge1xyXG5cclxuXHQnc3ByaXRlJzoge1xyXG5cclxuXHRcdHZlcnRleFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIGludCB1c2VTY3JlZW5Db29yZGluYXRlcztcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGludCBzaXplQXR0ZW51YXRpb247XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIHNjcmVlblBvc2l0aW9uO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBtYXQ0IHByb2plY3Rpb25NYXRyaXg7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCByb3RhdGlvbjtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzIgc2NhbGU7XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMyIGFsaWdubWVudDtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzIgdXZPZmZzZXQ7XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMyIHV2U2NhbGU7XCIsXHJcblxyXG5cdFx0XHRcImF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1wiLFxyXG5cdFx0XHRcImF0dHJpYnV0ZSB2ZWMyIHV2O1wiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzIgdlVWO1wiLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcdFwidlVWID0gdXZPZmZzZXQgKyB1diAqIHV2U2NhbGU7XCIsXHJcblxyXG5cdFx0XHRcdFwidmVjMiBhbGlnbmVkUG9zaXRpb24gPSBwb3NpdGlvbiArIGFsaWdubWVudDtcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWMyIHJvdGF0ZWRQb3NpdGlvbjtcIixcclxuXHRcdFx0XHRcInJvdGF0ZWRQb3NpdGlvbi54ID0gKCBjb3MoIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueCAtIHNpbiggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi55ICkgKiBzY2FsZS54O1wiLFxyXG5cdFx0XHRcdFwicm90YXRlZFBvc2l0aW9uLnkgPSAoIHNpbiggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi54ICsgY29zKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnkgKSAqIHNjYWxlLnk7XCIsXHJcblxyXG5cdFx0XHRcdFwidmVjNCBmaW5hbFBvc2l0aW9uO1wiLFxyXG5cclxuXHRcdFx0XHRcImlmKCB1c2VTY3JlZW5Db29yZGluYXRlcyAhPSAwICkge1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiZmluYWxQb3NpdGlvbiA9IHZlYzQoIHNjcmVlblBvc2l0aW9uLnh5ICsgcm90YXRlZFBvc2l0aW9uLCBzY3JlZW5Qb3NpdGlvbi56LCAxLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XCJ9IGVsc2Uge1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiZmluYWxQb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCAwLjAsIDAuMCwgMC4wLCAxLjAgKTtcIixcclxuXHRcdFx0XHRcdFwiZmluYWxQb3NpdGlvbi54eSArPSByb3RhdGVkUG9zaXRpb24gKiAoIHNpemVBdHRlbnVhdGlvbiA9PSAxID8gMS4wIDogZmluYWxQb3NpdGlvbi56ICk7XCIsXHJcblxyXG5cdFx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFx0XHRcImdsX1Bvc2l0aW9uID0gZmluYWxQb3NpdGlvbjtcIixcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKCBcIlxcblwiICksXHJcblxyXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGNvbG9yO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gaW50IGZvZ1R5cGU7XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGZvZ0NvbG9yO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgZm9nRGVuc2l0eTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IGZvZ05lYXI7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBmb2dGYXI7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBhbHBoYVRlc3Q7XCIsXHJcblxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMiB2VVY7XCIsXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWM0IHRleHR1cmUgPSB0ZXh0dXJlMkQoIG1hcCwgdlVWICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiaWYgKCB0ZXh0dXJlLmEgPCBhbHBoYVRlc3QgKSBkaXNjYXJkO1wiLFxyXG5cclxuXHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IHZlYzQoIGNvbG9yICogdGV4dHVyZS54eXosIHRleHR1cmUuYSAqIG9wYWNpdHkgKTtcIixcclxuXHJcblx0XHRcdFx0XCJpZiAoIGZvZ1R5cGUgPiAwICkge1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiZmxvYXQgZGVwdGggPSBnbF9GcmFnQ29vcmQueiAvIGdsX0ZyYWdDb29yZC53O1wiLFxyXG5cdFx0XHRcdFx0XCJmbG9hdCBmb2dGYWN0b3IgPSAwLjA7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJpZiAoIGZvZ1R5cGUgPT0gMSApIHtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiZm9nRmFjdG9yID0gc21vb3Roc3RlcCggZm9nTmVhciwgZm9nRmFyLCBkZXB0aCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwifSBlbHNlIHtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiY29uc3QgZmxvYXQgTE9HMiA9IDEuNDQyNjk1O1wiLFxyXG5cdFx0XHRcdFx0XHRcImZsb2F0IGZvZ0ZhY3RvciA9IGV4cDIoIC0gZm9nRGVuc2l0eSAqIGZvZ0RlbnNpdHkgKiBkZXB0aCAqIGRlcHRoICogTE9HMiApO1wiLFxyXG5cdFx0XHRcdFx0XHRcImZvZ0ZhY3RvciA9IDEuMCAtIGNsYW1wKCBmb2dGYWN0b3IsIDAuMCwgMS4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IgPSBtaXgoIGdsX0ZyYWdDb2xvciwgdmVjNCggZm9nQ29sb3IsIGdsX0ZyYWdDb2xvci53ICksIGZvZ0ZhY3RvciApO1wiLFxyXG5cclxuXHRcdFx0XHRcIn1cIixcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKCBcIlxcblwiIClcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIEV4cG9ydCB0aGUgVEhSRUUgb2JqZWN0IGZvciAqKk5vZGUuanMqKiwgd2l0aFxyXG4vLyBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBmb3IgdGhlIG9sZCBgcmVxdWlyZSgpYCBBUEkuIElmIHdlJ3JlIGluXHJcbi8vIHRoZSBicm93c2VyLCBhZGQgYF9gIGFzIGEgZ2xvYmFsIG9iamVjdCB2aWEgYSBzdHJpbmcgaWRlbnRpZmllcixcclxuLy8gZm9yIENsb3N1cmUgQ29tcGlsZXIgXCJhZHZhbmNlZFwiIG1vZGUuXHJcbmlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcclxuICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IFRIUkVFO1xyXG4gIH1cclxuICBleHBvcnRzLlRIUkVFID0gVEhSRUU7XHJcbn0gZWxzZSB7XHJcbiAgdGhpc1snVEhSRUUnXSA9IFRIUkVFO1xyXG59XHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL2RtaWxsZXQvUHJvamVjdHMvZnB0L2ZwdC1vbGQvfi90aHJlZS90aHJlZS5qc1xuICoqIG1vZHVsZSBpZCA9IDMyXG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMSAyXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 33 */
/***/ function(module, exports) {

	eval("// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL34vbm9kZS1saWJzLWJyb3dzZXIvfi9wcm9jZXNzL2Jyb3dzZXIuanM/NmYwZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVIiwiZmlsZSI6IjMzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS9+L25vZGUtbGlicy1icm93c2VyL34vcHJvY2Vzcy9icm93c2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxIDJcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _three = __webpack_require__(32);\n\nvar _three2 = _interopRequireDefault(_three);\n\nvar _voxelMesh = __webpack_require__(35);\n\nvar _voxelMesh2 = _interopRequireDefault(_voxelMesh);\n\nvar _voxelTexture = __webpack_require__(36);\n\nvar _voxelTexture2 = _interopRequireDefault(_voxelTexture);\n\nvar _voxel = __webpack_require__(14);\n\nvar _voxel2 = _interopRequireDefault(_voxel);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar TerrainView = function () {\n\t_createClass(TerrainView, null, [{\n\t\tkey: 'create',\n\t\tvalue: function create(terrain) {\n\t\t\treturn new TerrainView(terrain);\n\t\t}\n\t}]);\n\n\tfunction TerrainView(terrain) {\n\t\t_classCallCheck(this, TerrainView);\n\n\t\tthis.terrain = terrain;\n\t\tthis.three = new _three2.default.Object3D();\n\t\tthis.materials = new _voxelTexture2.default({\n\t\t\tgame: {\n\t\t\t\tTHREE: _three2.default\n\t\t\t},\n\t\t\ttexturePath: '/client/textures/',\n\t\t\tmaterialType: _three2.default.MeshLambertMaterial,\n\t\t\tmaterialParams: {},\n\t\t\tmaterialFlatColor: false\n\t\t});\n\n\t\tthis.materialNames = [['grass', 'dirt', 'grass_dirt'], 'brick', 'dirt', 'obsidian', 'plank', 'shama', 'whitewool'];\n\t\tthis.materials.load(this.materialNames);\n\n\t\tthis.showAllChunks();\n\t}\n\n\t_createClass(TerrainView, [{\n\t\tkey: 'showChunkAtPosition',\n\t\tvalue: function showChunkAtPosition(pos) {\n\t\t\tvar voxels = this.terrain.get('voxels'),\n\t\t\t    chunkID = voxels.chunkAtPosition(pos).join('|'),\n\t\t\t    chunk = voxels.chunks[chunkID];\n\t\t\tthis.showChunk(chunk);\n\t\t}\n\t}, {\n\t\tkey: 'showAllChunks',\n\t\tvalue: function showAllChunks() {\n\t\t\tvar chunks = this.terrain.get('voxels').chunks;\n\t\t\tfor (var chunkIndex in chunks) {\n\t\t\t\tthis.showChunk(chunks[chunkIndex]);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'showChunk',\n\t\tvalue: function showChunk(chunk) {\n\t\t\tvar chunkIndex = chunk.position.join('|');\n\n\t\t\tvar voxels = this.terrain.get('voxels'),\n\t\t\t    bounds = voxels.getBounds.apply(this.voxels, chunk.position),\n\t\t\t    scale = new _three2.default.Vector3(1, 1, 1),\n\t\t\t    mesher = _voxel2.default.meshers.culled,\n\t\t\t    mesh = (0, _voxelMesh2.default)(chunk, mesher, scale, _three2.default);\n\t\t\tvoxels.chunks[chunkIndex] = chunk;\n\t\t\tif (voxels.meshes[chunkIndex]) {\n\t\t\t\tif (voxels.meshes[chunkIndex].surfaceMesh) {\n\t\t\t\t\tthis.three.remove(voxels.meshes[chunkIndex].surfaceMesh);\n\t\t\t\t}\n\t\t\t\tif (voxels.meshes[chunkIndex].wireMesh) {\n\t\t\t\t\tthis.three.remove(voxels.meshes[chunkIndex].wireMesh);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvoxels.meshes[chunkIndex] = mesh;\n\n\t\t\tif (this.meshType === 'wireMesh') {\n\t\t\t\tmesh.createWireMesh(0x111111);\n\t\t\t} else {\n\t\t\t\tmesh.createSurfaceMesh(this.materials.material);\n\t\t\t\tmesh.surfaceMesh.castShadow = mesh.surfaceMesh.receiveShadow = true;\n\t\t\t}\n\n\t\t\tthis.materials.paint(mesh);\n\n\t\t\tmesh.setPosition(bounds[0][0] * 32, bounds[0][1] * 32, bounds[0][2] * 32);\n\n\t\t\tmesh.addToScene(this.three);\n\n\t\t\treturn mesh;\n\t\t}\n\t}]);\n\n\treturn TerrainView;\n}();\n\nexports.default = TerrainView;\n;//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi92aWV3L1RlcnJhaW5WaWV3LmpzPzVmZDkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7SUFFcUIsVztjQUFBLFc7O3lCQUVOLE8sRUFBUztBQUN0QixVQUFPLElBQUksV0FBSixDQUFnQixPQUFoQixDQUFQO0FBQ0E7OztBQUVELFVBTm9CLFdBTXBCLENBQVksT0FBWixFQUFxQjtBQUFBLHdCQU5ELFdBTUM7O0FBQ3BCLE9BQUssT0FBTCxHQUFlLE9BQWY7QUFDQSxPQUFLLEtBQUwsR0FBYSxJQUFJLGdCQUFNLFFBQVYsRUFBYjtBQUNBLE9BQUssU0FBTCxHQUFpQiwyQkFBWTtBQUM1QixTQUFNO0FBQ0w7QUFESyxJQURzQjtBQUk1QixnQkFBYSxtQkFKZTtBQUs1QixpQkFBZSxnQkFBTSxtQkFMTztBQU01QixtQkFBZ0IsRUFOWTtBQU81QixzQkFBbUI7QUFQUyxHQUFaLENBQWpCOztBQVVBLE9BQUssYUFBTCxHQUFxQixDQUFDLENBQUMsT0FBRCxFQUFVLE1BQVYsRUFBa0IsWUFBbEIsQ0FBRCxFQUFrQyxPQUFsQyxFQUEyQyxNQUEzQyxFQUFtRCxVQUFuRCxFQUErRCxPQUEvRCxFQUF3RSxPQUF4RSxFQUFpRixXQUFqRixDQUFyQjtBQUNBLE9BQUssU0FBTCxDQUFlLElBQWYsQ0FBb0IsS0FBSyxhQUF6Qjs7QUFFQSxPQUFLLGFBQUw7QUFDQTs7Y0F2Qm1CLFc7O3NDQXlCQSxHLEVBQUs7QUFDeEIsT0FBSSxTQUFTLEtBQUssT0FBTCxDQUFhLEdBQWIsQ0FBaUIsUUFBakIsQ0FBYjtPQUNDLFVBQVUsT0FBTyxlQUFQLENBQXVCLEdBQXZCLEVBQTRCLElBQTVCLENBQWlDLEdBQWpDLENBRFg7T0FFQyxRQUFRLE9BQU8sTUFBUCxDQUFjLE9BQWQsQ0FGVDtBQUdBLFFBQUssU0FBTCxDQUFlLEtBQWY7QUFDQTs7O2tDQUVlO0FBQ2YsT0FBSSxTQUFTLEtBQUssT0FBTCxDQUFhLEdBQWIsQ0FBaUIsUUFBakIsRUFBMkIsTUFBeEM7QUFDQSxRQUFLLElBQUksVUFBVCxJQUF1QixNQUF2QixFQUErQjtBQUM5QixTQUFLLFNBQUwsQ0FBZSxPQUFPLFVBQVAsQ0FBZjtBQUNBO0FBQ0Q7Ozs0QkFFUyxLLEVBQU87QUFDaEIsT0FBSSxhQUFhLE1BQU0sUUFBTixDQUFlLElBQWYsQ0FBb0IsR0FBcEIsQ0FBakI7O0FBRUEsT0FBSSxTQUFTLEtBQUssT0FBTCxDQUFhLEdBQWIsQ0FBaUIsUUFBakIsQ0FBYjtPQUNDLFNBQVMsT0FBTyxTQUFQLENBQWlCLEtBQWpCLENBQXVCLEtBQUssTUFBNUIsRUFBb0MsTUFBTSxRQUExQyxDQURWO09BRUMsUUFBUSxJQUFJLGdCQUFNLE9BQVYsQ0FBa0IsQ0FBbEIsRUFBcUIsQ0FBckIsRUFBd0IsQ0FBeEIsQ0FGVDtPQUdDLFNBQVMsZ0JBQU0sT0FBTixDQUFjLE1BSHhCO09BSUMsT0FBTyx5QkFBVSxLQUFWLEVBQWlCLE1BQWpCLEVBQXlCLEtBQXpCLGtCQUpSO0FBS0EsVUFBTyxNQUFQLENBQWMsVUFBZCxJQUE0QixLQUE1QjtBQUNBLE9BQUksT0FBTyxNQUFQLENBQWMsVUFBZCxDQUFKLEVBQStCO0FBQzlCLFFBQUksT0FBTyxNQUFQLENBQWMsVUFBZCxFQUEwQixXQUE5QixFQUEyQztBQUMxQyxVQUFLLEtBQUwsQ0FBVyxNQUFYLENBQWtCLE9BQU8sTUFBUCxDQUFjLFVBQWQsRUFBMEIsV0FBNUM7QUFDQTtBQUNELFFBQUksT0FBTyxNQUFQLENBQWMsVUFBZCxFQUEwQixRQUE5QixFQUF3QztBQUN2QyxVQUFLLEtBQUwsQ0FBVyxNQUFYLENBQWtCLE9BQU8sTUFBUCxDQUFjLFVBQWQsRUFBMEIsUUFBNUM7QUFDQTtBQUNEO0FBQ0QsVUFBTyxNQUFQLENBQWMsVUFBZCxJQUE0QixJQUE1Qjs7QUFFQSxPQUFJLEtBQUssUUFBTCxLQUFrQixVQUF0QixFQUFrQztBQUNqQyxTQUFLLGNBQUwsQ0FBb0IsUUFBcEI7QUFDQSxJQUZELE1BRU87QUFDTixTQUFLLGlCQUFMLENBQXVCLEtBQUssU0FBTCxDQUFlLFFBQXRDO0FBQ0EsU0FBSyxXQUFMLENBQWlCLFVBQWpCLEdBQThCLEtBQUssV0FBTCxDQUFpQixhQUFqQixHQUFpQyxJQUEvRDtBQUNBOztBQUVELFFBQUssU0FBTCxDQUFlLEtBQWYsQ0FBcUIsSUFBckI7O0FBRUEsUUFBSyxXQUFMLENBQWlCLE9BQU8sQ0FBUCxFQUFVLENBQVYsSUFBYSxFQUE5QixFQUFrQyxPQUFPLENBQVAsRUFBVSxDQUFWLElBQWEsRUFBL0MsRUFBbUQsT0FBTyxDQUFQLEVBQVUsQ0FBVixJQUFhLEVBQWhFOztBQUVBLFFBQUssVUFBTCxDQUFnQixLQUFLLEtBQXJCOztBQUVBLFVBQU8sSUFBUDtBQUNBOzs7UUF4RW1CLFc7OztrQkFBQSxXO0FBeUVwQiIsImZpbGUiOiIzNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCB2b3hlbE1lc2ggZnJvbSAndm94ZWwtbWVzaCc7XG5pbXBvcnQgVGV4dHVyZSBmcm9tICd2b3hlbC10ZXh0dXJlJztcbmltcG9ydCB2b3hlbCBmcm9tICd2b3hlbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRlcnJhaW5WaWV3IHtcblxuXHRzdGF0aWMgY3JlYXRlKHRlcnJhaW4pIHtcblx0XHRyZXR1cm4gbmV3IFRlcnJhaW5WaWV3KHRlcnJhaW4pO1xuXHR9XG5cblx0Y29uc3RydWN0b3IodGVycmFpbikge1xuXHRcdHRoaXMudGVycmFpbiA9IHRlcnJhaW47XG5cdFx0dGhpcy50aHJlZSA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuXHRcdHRoaXMubWF0ZXJpYWxzID0gbmV3IFRleHR1cmUoe1xuXHRcdFx0Z2FtZToge1xuXHRcdFx0XHRUSFJFRTogVEhSRUVcblx0XHRcdH0sXG5cdFx0XHR0ZXh0dXJlUGF0aDogJy9jbGllbnQvdGV4dHVyZXMvJyxcblx0XHRcdG1hdGVyaWFsVHlwZTogIFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwsXG5cdFx0XHRtYXRlcmlhbFBhcmFtczoge30sXG5cdFx0XHRtYXRlcmlhbEZsYXRDb2xvcjogZmFsc2Vcblx0XHR9KTtcblxuXHRcdHRoaXMubWF0ZXJpYWxOYW1lcyA9IFtbJ2dyYXNzJywgJ2RpcnQnLCAnZ3Jhc3NfZGlydCddLCAnYnJpY2snLCAnZGlydCcsICdvYnNpZGlhbicsICdwbGFuaycsICdzaGFtYScsICd3aGl0ZXdvb2wnXTtcblx0XHR0aGlzLm1hdGVyaWFscy5sb2FkKHRoaXMubWF0ZXJpYWxOYW1lcyk7XG5cblx0XHR0aGlzLnNob3dBbGxDaHVua3MoKTtcblx0fVxuXG5cdHNob3dDaHVua0F0UG9zaXRpb24ocG9zKSB7XG5cdFx0bGV0IHZveGVscyA9IHRoaXMudGVycmFpbi5nZXQoJ3ZveGVscycpLFxuXHRcdFx0Y2h1bmtJRCA9IHZveGVscy5jaHVua0F0UG9zaXRpb24ocG9zKS5qb2luKCd8JyksXG5cdFx0XHRjaHVuayA9IHZveGVscy5jaHVua3NbY2h1bmtJRF07XG5cdFx0dGhpcy5zaG93Q2h1bmsoY2h1bmspO1xuXHR9XG5cblx0c2hvd0FsbENodW5rcygpIHtcblx0XHRsZXQgY2h1bmtzID0gdGhpcy50ZXJyYWluLmdldCgndm94ZWxzJykuY2h1bmtzO1xuXHRcdGZvciAodmFyIGNodW5rSW5kZXggaW4gY2h1bmtzKSB7XG5cdFx0XHR0aGlzLnNob3dDaHVuayhjaHVua3NbY2h1bmtJbmRleF0pO1xuXHRcdH1cblx0fVxuXG5cdHNob3dDaHVuayhjaHVuaykge1xuXHRcdHZhciBjaHVua0luZGV4ID0gY2h1bmsucG9zaXRpb24uam9pbignfCcpO1xuXG5cdFx0bGV0IHZveGVscyA9IHRoaXMudGVycmFpbi5nZXQoJ3ZveGVscycpLFxuXHRcdFx0Ym91bmRzID0gdm94ZWxzLmdldEJvdW5kcy5hcHBseSh0aGlzLnZveGVscywgY2h1bmsucG9zaXRpb24pLFxuXHRcdFx0c2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMygxLCAxLCAxKSxcblx0XHRcdG1lc2hlciA9IHZveGVsLm1lc2hlcnMuY3VsbGVkLFxuXHRcdFx0bWVzaCA9IHZveGVsTWVzaChjaHVuaywgbWVzaGVyLCBzY2FsZSwgVEhSRUUpO1xuXHRcdHZveGVscy5jaHVua3NbY2h1bmtJbmRleF0gPSBjaHVuaztcblx0XHRpZiAodm94ZWxzLm1lc2hlc1tjaHVua0luZGV4XSkge1xuXHRcdFx0aWYgKHZveGVscy5tZXNoZXNbY2h1bmtJbmRleF0uc3VyZmFjZU1lc2gpIHtcblx0XHRcdFx0dGhpcy50aHJlZS5yZW1vdmUodm94ZWxzLm1lc2hlc1tjaHVua0luZGV4XS5zdXJmYWNlTWVzaCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodm94ZWxzLm1lc2hlc1tjaHVua0luZGV4XS53aXJlTWVzaCkge1xuXHRcdFx0XHR0aGlzLnRocmVlLnJlbW92ZSh2b3hlbHMubWVzaGVzW2NodW5rSW5kZXhdLndpcmVNZXNoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dm94ZWxzLm1lc2hlc1tjaHVua0luZGV4XSA9IG1lc2g7XG5cblx0XHRpZiAodGhpcy5tZXNoVHlwZSA9PT0gJ3dpcmVNZXNoJykge1xuXHRcdFx0bWVzaC5jcmVhdGVXaXJlTWVzaCgweDExMTExMSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1lc2guY3JlYXRlU3VyZmFjZU1lc2godGhpcy5tYXRlcmlhbHMubWF0ZXJpYWwpO1xuXHRcdFx0bWVzaC5zdXJmYWNlTWVzaC5jYXN0U2hhZG93ID0gbWVzaC5zdXJmYWNlTWVzaC5yZWNlaXZlU2hhZG93ID0gdHJ1ZTtcblx0XHR9XG5cblx0XHR0aGlzLm1hdGVyaWFscy5wYWludChtZXNoKTtcblxuXHRcdG1lc2guc2V0UG9zaXRpb24oYm91bmRzWzBdWzBdKjMyLCBib3VuZHNbMF1bMV0qMzIsIGJvdW5kc1swXVsyXSozMik7XG5cblx0XHRtZXNoLmFkZFRvU2NlbmUodGhpcy50aHJlZSk7XG5cblx0XHRyZXR1cm4gbWVzaDtcblx0fVxufTtcblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi92aWV3L1RlcnJhaW5WaWV3LmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	eval("var THREE = __webpack_require__(32)\n\nmodule.exports = function(data, mesher, scaleFactor, three) {\n  return new Mesh(data, mesher, scaleFactor, three)\n}\n\nmodule.exports.Mesh = Mesh\n\nfunction Mesh(data, mesher, scaleFactor, three) {\n  this.THREE = three || THREE\n  this.data = data\n  var geometry = this.geometry = new this.THREE.Geometry()\n  this.scale = scaleFactor || new this.THREE.Vector3(10, 10, 10)\n  \n  var result = mesher( data.voxels, data.dims )\n  this.meshed = result\n\n  geometry.vertices.length = 0\n  geometry.faces.length = 0\n\n  for (var i = 0; i < result.vertices.length; ++i) {\n    var q = result.vertices[i]\n    geometry.vertices.push(new this.THREE.Vector3(q[0], q[1], q[2]))\n  } \n  \n  for (var i = 0; i < result.faces.length; ++i) {\n    geometry.faceVertexUvs[0].push(this.faceVertexUv(i))\n    \n    var q = result.faces[i]\n    if (q.length === 5) {\n      var f = new this.THREE.Face4(q[0], q[1], q[2], q[3])\n      f.color = new this.THREE.Color(q[4])\n      geometry.faces.push(f)\n    } else if (q.length == 4) {\n      var f = new this.THREE.Face3(q[0], q[1], q[2])\n      f.color = new this.THREE.Color(q[3])\n      geometry.faces.push(f)\n    }\n  }\n  \n  geometry.computeFaceNormals()\n\n  geometry.verticesNeedUpdate = true\n  geometry.elementsNeedUpdate = true\n  geometry.normalsNeedUpdate = true\n\n  geometry.computeBoundingBox()\n  geometry.computeBoundingSphere()\n\n}\n\nMesh.prototype.createWireMesh = function(hexColor) {    \n  var wireMaterial = new this.THREE.MeshBasicMaterial({\n    color : hexColor || 0xffffff,\n    wireframe : true\n  })\n  wireMesh = new this.THREE.Mesh(this.geometry, wireMaterial)\n  wireMesh.scale = this.scale\n  wireMesh.doubleSided = true\n  this.wireMesh = wireMesh\n  return wireMesh\n}\n\nMesh.prototype.createSurfaceMesh = function(material) {\n  material = material || new this.THREE.MeshNormalMaterial()\n  var surfaceMesh  = new this.THREE.Mesh( this.geometry, material )\n  surfaceMesh.scale = this.scale\n  surfaceMesh.doubleSided = false\n  this.surfaceMesh = surfaceMesh\n  return surfaceMesh\n}\n\nMesh.prototype.addToScene = function(scene) {\n  if (this.wireMesh) scene.add( this.wireMesh )\n  if (this.surfaceMesh) scene.add( this.surfaceMesh )\n}\n\nMesh.prototype.setPosition = function(x, y, z) {\n  if (this.wireMesh) this.wireMesh.position = new this.THREE.Vector3(x, y, z)\n  if (this.surfaceMesh) this.surfaceMesh.position = new this.THREE.Vector3(x, y, z)\n}\n\nMesh.prototype.faceVertexUv = function(i) {\n  var vs = [\n    this.meshed.vertices[i*4+0],\n    this.meshed.vertices[i*4+1],\n    this.meshed.vertices[i*4+2],\n    this.meshed.vertices[i*4+3]\n  ]\n  var spans = {\n    x0: vs[0][0] - vs[1][0],\n    x1: vs[1][0] - vs[2][0],\n    y0: vs[0][1] - vs[1][1],\n    y1: vs[1][1] - vs[2][1],\n    z0: vs[0][2] - vs[1][2],\n    z1: vs[1][2] - vs[2][2]\n  }\n  var size = {\n    x: Math.max(Math.abs(spans.x0), Math.abs(spans.x1)),\n    y: Math.max(Math.abs(spans.y0), Math.abs(spans.y1)),\n    z: Math.max(Math.abs(spans.z0), Math.abs(spans.z1))\n  }\n  if (size.x === 0) {\n    if (spans.y0 > spans.y1) {\n      var width = size.y\n      var height = size.z\n    }\n    else {\n      var width = size.z\n      var height = size.y\n    }\n  }\n  if (size.y === 0) {\n    if (spans.x0 > spans.x1) {\n      var width = size.x\n      var height = size.z\n    }\n    else {\n      var width = size.z\n      var height = size.x\n    }\n  }\n  if (size.z === 0) {\n    if (spans.x0 > spans.x1) {\n      var width = size.x\n      var height = size.y\n    }\n    else {\n      var width = size.y\n      var height = size.x\n    }\n  }\n  if ((size.z === 0 && spans.x0 < spans.x1) || (size.x === 0 && spans.y0 > spans.y1)) {\n    return [\n      new this.THREE.Vector2(height, 0),\n      new this.THREE.Vector2(0, 0),\n      new this.THREE.Vector2(0, width),\n      new this.THREE.Vector2(height, width)\n    ]\n  } else {\n    return [\n      new this.THREE.Vector2(0, 0),\n      new this.THREE.Vector2(0, height),\n      new this.THREE.Vector2(width, height),\n      new this.THREE.Vector2(width, 0)\n    ]\n  }\n}\n;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2RtaWxsZXQvUHJvamVjdHMvZnB0L2ZwdC1vbGQvfi92b3hlbC1tZXNoL2luZGV4LmpzP2FlMjkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQiw0QkFBNEI7QUFDN0M7QUFDQTtBQUNBLEc7O0FBRUEsaUJBQWlCLHlCQUF5QjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsb0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIzNS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBUSFJFRSA9IHJlcXVpcmUoJ3RocmVlJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkYXRhLCBtZXNoZXIsIHNjYWxlRmFjdG9yLCB0aHJlZSkge1xuICByZXR1cm4gbmV3IE1lc2goZGF0YSwgbWVzaGVyLCBzY2FsZUZhY3RvciwgdGhyZWUpXG59XG5cbm1vZHVsZS5leHBvcnRzLk1lc2ggPSBNZXNoXG5cbmZ1bmN0aW9uIE1lc2goZGF0YSwgbWVzaGVyLCBzY2FsZUZhY3RvciwgdGhyZWUpIHtcbiAgdGhpcy5USFJFRSA9IHRocmVlIHx8IFRIUkVFXG4gIHRoaXMuZGF0YSA9IGRhdGFcbiAgdmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeSA9IG5ldyB0aGlzLlRIUkVFLkdlb21ldHJ5KClcbiAgdGhpcy5zY2FsZSA9IHNjYWxlRmFjdG9yIHx8IG5ldyB0aGlzLlRIUkVFLlZlY3RvcjMoMTAsIDEwLCAxMClcbiAgXG4gIHZhciByZXN1bHQgPSBtZXNoZXIoIGRhdGEudm94ZWxzLCBkYXRhLmRpbXMgKVxuICB0aGlzLm1lc2hlZCA9IHJlc3VsdFxuXG4gIGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCA9IDBcbiAgZ2VvbWV0cnkuZmFjZXMubGVuZ3RoID0gMFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0LnZlcnRpY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHEgPSByZXN1bHQudmVydGljZXNbaV1cbiAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKG5ldyB0aGlzLlRIUkVFLlZlY3RvcjMocVswXSwgcVsxXSwgcVsyXSkpXG4gIH0gXG4gIFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdC5mYWNlcy5sZW5ndGg7ICsraSkge1xuICAgIGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbMF0ucHVzaCh0aGlzLmZhY2VWZXJ0ZXhVdihpKSlcbiAgICBcbiAgICB2YXIgcSA9IHJlc3VsdC5mYWNlc1tpXVxuICAgIGlmIChxLmxlbmd0aCA9PT0gNSkge1xuICAgICAgdmFyIGYgPSBuZXcgdGhpcy5USFJFRS5GYWNlNChxWzBdLCBxWzFdLCBxWzJdLCBxWzNdKVxuICAgICAgZi5jb2xvciA9IG5ldyB0aGlzLlRIUkVFLkNvbG9yKHFbNF0pXG4gICAgICBnZW9tZXRyeS5mYWNlcy5wdXNoKGYpXG4gICAgfSBlbHNlIGlmIChxLmxlbmd0aCA9PSA0KSB7XG4gICAgICB2YXIgZiA9IG5ldyB0aGlzLlRIUkVFLkZhY2UzKHFbMF0sIHFbMV0sIHFbMl0pXG4gICAgICBmLmNvbG9yID0gbmV3IHRoaXMuVEhSRUUuQ29sb3IocVszXSlcbiAgICAgIGdlb21ldHJ5LmZhY2VzLnB1c2goZilcbiAgICB9XG4gIH1cbiAgXG4gIGdlb21ldHJ5LmNvbXB1dGVGYWNlTm9ybWFscygpXG5cbiAgZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZVxuICBnZW9tZXRyeS5lbGVtZW50c05lZWRVcGRhdGUgPSB0cnVlXG4gIGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlID0gdHJ1ZVxuXG4gIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveCgpXG4gIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpXG5cbn1cblxuTWVzaC5wcm90b3R5cGUuY3JlYXRlV2lyZU1lc2ggPSBmdW5jdGlvbihoZXhDb2xvcikgeyAgICBcbiAgdmFyIHdpcmVNYXRlcmlhbCA9IG5ldyB0aGlzLlRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAgICBjb2xvciA6IGhleENvbG9yIHx8IDB4ZmZmZmZmLFxuICAgIHdpcmVmcmFtZSA6IHRydWVcbiAgfSlcbiAgd2lyZU1lc2ggPSBuZXcgdGhpcy5USFJFRS5NZXNoKHRoaXMuZ2VvbWV0cnksIHdpcmVNYXRlcmlhbClcbiAgd2lyZU1lc2guc2NhbGUgPSB0aGlzLnNjYWxlXG4gIHdpcmVNZXNoLmRvdWJsZVNpZGVkID0gdHJ1ZVxuICB0aGlzLndpcmVNZXNoID0gd2lyZU1lc2hcbiAgcmV0dXJuIHdpcmVNZXNoXG59XG5cbk1lc2gucHJvdG90eXBlLmNyZWF0ZVN1cmZhY2VNZXNoID0gZnVuY3Rpb24obWF0ZXJpYWwpIHtcbiAgbWF0ZXJpYWwgPSBtYXRlcmlhbCB8fCBuZXcgdGhpcy5USFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwoKVxuICB2YXIgc3VyZmFjZU1lc2ggID0gbmV3IHRoaXMuVEhSRUUuTWVzaCggdGhpcy5nZW9tZXRyeSwgbWF0ZXJpYWwgKVxuICBzdXJmYWNlTWVzaC5zY2FsZSA9IHRoaXMuc2NhbGVcbiAgc3VyZmFjZU1lc2guZG91YmxlU2lkZWQgPSBmYWxzZVxuICB0aGlzLnN1cmZhY2VNZXNoID0gc3VyZmFjZU1lc2hcbiAgcmV0dXJuIHN1cmZhY2VNZXNoXG59XG5cbk1lc2gucHJvdG90eXBlLmFkZFRvU2NlbmUgPSBmdW5jdGlvbihzY2VuZSkge1xuICBpZiAodGhpcy53aXJlTWVzaCkgc2NlbmUuYWRkKCB0aGlzLndpcmVNZXNoIClcbiAgaWYgKHRoaXMuc3VyZmFjZU1lc2gpIHNjZW5lLmFkZCggdGhpcy5zdXJmYWNlTWVzaCApXG59XG5cbk1lc2gucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24oeCwgeSwgeikge1xuICBpZiAodGhpcy53aXJlTWVzaCkgdGhpcy53aXJlTWVzaC5wb3NpdGlvbiA9IG5ldyB0aGlzLlRIUkVFLlZlY3RvcjMoeCwgeSwgeilcbiAgaWYgKHRoaXMuc3VyZmFjZU1lc2gpIHRoaXMuc3VyZmFjZU1lc2gucG9zaXRpb24gPSBuZXcgdGhpcy5USFJFRS5WZWN0b3IzKHgsIHksIHopXG59XG5cbk1lc2gucHJvdG90eXBlLmZhY2VWZXJ0ZXhVdiA9IGZ1bmN0aW9uKGkpIHtcbiAgdmFyIHZzID0gW1xuICAgIHRoaXMubWVzaGVkLnZlcnRpY2VzW2kqNCswXSxcbiAgICB0aGlzLm1lc2hlZC52ZXJ0aWNlc1tpKjQrMV0sXG4gICAgdGhpcy5tZXNoZWQudmVydGljZXNbaSo0KzJdLFxuICAgIHRoaXMubWVzaGVkLnZlcnRpY2VzW2kqNCszXVxuICBdXG4gIHZhciBzcGFucyA9IHtcbiAgICB4MDogdnNbMF1bMF0gLSB2c1sxXVswXSxcbiAgICB4MTogdnNbMV1bMF0gLSB2c1syXVswXSxcbiAgICB5MDogdnNbMF1bMV0gLSB2c1sxXVsxXSxcbiAgICB5MTogdnNbMV1bMV0gLSB2c1syXVsxXSxcbiAgICB6MDogdnNbMF1bMl0gLSB2c1sxXVsyXSxcbiAgICB6MTogdnNbMV1bMl0gLSB2c1syXVsyXVxuICB9XG4gIHZhciBzaXplID0ge1xuICAgIHg6IE1hdGgubWF4KE1hdGguYWJzKHNwYW5zLngwKSwgTWF0aC5hYnMoc3BhbnMueDEpKSxcbiAgICB5OiBNYXRoLm1heChNYXRoLmFicyhzcGFucy55MCksIE1hdGguYWJzKHNwYW5zLnkxKSksXG4gICAgejogTWF0aC5tYXgoTWF0aC5hYnMoc3BhbnMuejApLCBNYXRoLmFicyhzcGFucy56MSkpXG4gIH1cbiAgaWYgKHNpemUueCA9PT0gMCkge1xuICAgIGlmIChzcGFucy55MCA+IHNwYW5zLnkxKSB7XG4gICAgICB2YXIgd2lkdGggPSBzaXplLnlcbiAgICAgIHZhciBoZWlnaHQgPSBzaXplLnpcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgd2lkdGggPSBzaXplLnpcbiAgICAgIHZhciBoZWlnaHQgPSBzaXplLnlcbiAgICB9XG4gIH1cbiAgaWYgKHNpemUueSA9PT0gMCkge1xuICAgIGlmIChzcGFucy54MCA+IHNwYW5zLngxKSB7XG4gICAgICB2YXIgd2lkdGggPSBzaXplLnhcbiAgICAgIHZhciBoZWlnaHQgPSBzaXplLnpcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgd2lkdGggPSBzaXplLnpcbiAgICAgIHZhciBoZWlnaHQgPSBzaXplLnhcbiAgICB9XG4gIH1cbiAgaWYgKHNpemUueiA9PT0gMCkge1xuICAgIGlmIChzcGFucy54MCA+IHNwYW5zLngxKSB7XG4gICAgICB2YXIgd2lkdGggPSBzaXplLnhcbiAgICAgIHZhciBoZWlnaHQgPSBzaXplLnlcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgd2lkdGggPSBzaXplLnlcbiAgICAgIHZhciBoZWlnaHQgPSBzaXplLnhcbiAgICB9XG4gIH1cbiAgaWYgKChzaXplLnogPT09IDAgJiYgc3BhbnMueDAgPCBzcGFucy54MSkgfHwgKHNpemUueCA9PT0gMCAmJiBzcGFucy55MCA+IHNwYW5zLnkxKSkge1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgdGhpcy5USFJFRS5WZWN0b3IyKGhlaWdodCwgMCksXG4gICAgICBuZXcgdGhpcy5USFJFRS5WZWN0b3IyKDAsIDApLFxuICAgICAgbmV3IHRoaXMuVEhSRUUuVmVjdG9yMigwLCB3aWR0aCksXG4gICAgICBuZXcgdGhpcy5USFJFRS5WZWN0b3IyKGhlaWdodCwgd2lkdGgpXG4gICAgXVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgdGhpcy5USFJFRS5WZWN0b3IyKDAsIDApLFxuICAgICAgbmV3IHRoaXMuVEhSRUUuVmVjdG9yMigwLCBoZWlnaHQpLFxuICAgICAgbmV3IHRoaXMuVEhSRUUuVmVjdG9yMih3aWR0aCwgaGVpZ2h0KSxcbiAgICAgIG5ldyB0aGlzLlRIUkVFLlZlY3RvcjIod2lkdGgsIDApXG4gICAgXVxuICB9XG59XG47XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9kbWlsbGV0L1Byb2plY3RzL2ZwdC9mcHQtb2xkL34vdm94ZWwtbWVzaC9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDM1XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMSAyXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	eval("var tic = __webpack_require__(37)();\nvar createAtlas = __webpack_require__(38);\nvar isTransparent = __webpack_require__(39).transparent;\n\nfunction Texture(opts) {\n  if (!(this instanceof Texture)) return new Texture(opts || {});\n  var self = this;\n  this.game = opts.game; delete opts.game;\n  this.THREE = this.game.THREE;\n  this.materials = [];\n  this.transparents = [];\n  this.texturePath = opts.texturePath || '/textures/';\n  this.loading = 0;\n  this.ao = __webpack_require__(40)(this.game);\n\n  var useFlatColors = opts.materialFlatColor === true;\n  delete opts.materialFlatColor;\n\n  this.options = defaults(opts || {}, {\n    crossOrigin: 'Anonymous',\n    materialParams: defaults(opts.materialParams || {}, {\n      ambient: 0xbbbbbb,\n      transparent: false,\n      side: this.THREE.DoubleSide,\n    }),\n    materialTransparentParams: defaults(opts.materialTransparentParams || {}, {\n      ambient: 0xbbbbbb,\n      transparent: true,\n      side: this.THREE.DoubleSide,\n      //depthWrite: false,\n      //depthTest: false\n    }),\n    materialType: this.THREE.MeshLambertMaterial,\n    applyTextureParams: function(map) {\n      map.magFilter = self.THREE.NearestFilter;\n      map.minFilter = self.THREE.LinearMipMapLinearFilter;\n    }\n  });\n\n  // create a canvas for the texture atlas\n  this.canvas = (typeof document !== 'undefined') ? document.createElement('canvas') : {};\n  this.canvas.width = opts.atlasWidth || 512;\n  this.canvas.height = opts.atlasHeight || 512;\n  var ctx = this.canvas.getContext('2d');\n  ctx.fillStyle = 'black';\n  ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n\n  // create core atlas and texture\n  this.atlas = createAtlas(this.canvas);\n  this.atlas.tilepad = true;\n  this._atlasuv = false;\n  this._atlaskey = false;\n  this.texture = new this.THREE.Texture(this.canvas);\n  this.options.applyTextureParams(this.texture);\n\n  if (useFlatColors) {\n    // If were using simple colors\n    this.material = new this.THREE.MeshBasicMaterial({\n      vertexColors: this.THREE.VertexColors\n    });\n  } else {\n    var opaque = new this.options.materialType(this.options.materialParams);\n    opaque.map = this.texture;\n    var transparent = new this.options.materialType(this.options.materialTransparentParams);\n    transparent.map = this.texture;\n    this.material = new this.THREE.MeshFaceMaterial([\n      opaque,\n      transparent\n    ]);\n  }\n\n  // a place for meshes to wait while textures are loading\n  this._meshQueue = [];\n}\nmodule.exports = Texture;\n\nTexture.prototype.load = function(names, done) {\n  var self = this;\n  if (!Array.isArray(names)) names = [names];\n  done = done || function() {};\n  this.loading++;\n\n  var materialSlice = names.map(self._expandName);\n  self.materials = self.materials.concat(materialSlice);\n\n  // load onto the texture atlas\n  var load = Object.create(null);\n  materialSlice.forEach(function(mats) {\n    mats.forEach(function(mat) {\n      if (mat.slice(0, 1) === '#') return;\n      // todo: check if texture already exists\n      load[mat] = true;\n    });\n  });\n  if (Object.keys(load).length > 0) {\n    each(Object.keys(load), self.pack.bind(self), function() {\n      self._afterLoading();\n      done(materialSlice);\n    });\n  } else {\n    self._afterLoading();\n  }\n};\n\nTexture.prototype.pack = function(name, done) {\n  var self = this;\n  function pack(img) {\n    var node = self.atlas.pack(img);\n    if (node === false) {\n      self.atlas = self.atlas.expand(img);\n      self.atlas.tilepad = true;\n    }\n    done();\n  }\n  if (typeof name === 'string') {\n    var img = new Image();\n    img.id = name;\n    img.crossOrigin = self.options.crossOrigin;\n    img.src = self.texturePath + ext(name);\n    img.onload = function() {\n      if (isTransparent(img)) {\n        self.transparents.push(name);\n      }\n      pack(img);\n    };\n    img.onerror = function() {\n      console.error('Couldn\\'t load URL [' + img.src + ']');\n      done();\n    };\n  } else {\n    pack(name);\n  }\n  return self;\n};\n\nTexture.prototype.find = function(name) {\n  var self = this;\n  var type = 0;\n  self.materials.forEach(function(mats, i) {\n    mats.forEach(function(mat) {\n      if (mat === name) {\n        type = i + 1;\n        return false;\n      }\n    });\n    if (type !== 0) return false;\n  });\n  return type;\n};\n\nTexture.prototype._expandName = function(name) {\n  if (name === null) return Array(6);\n  if (name.top) return [name.back, name.front, name.top, name.bottom, name.left, name.right];\n  if (!Array.isArray(name)) name = [name];\n  // load the 0 texture to all\n  if (name.length === 1) name = [name[0],name[0],name[0],name[0],name[0],name[0]];\n  // 0 is top/bottom, 1 is sides\n  if (name.length === 2) name = [name[1],name[1],name[0],name[0],name[1],name[1]];\n  // 0 is top, 1 is bottom, 2 is sides\n  if (name.length === 3) name = [name[2],name[2],name[0],name[1],name[2],name[2]];\n  // 0 is top, 1 is bottom, 2 is front/back, 3 is left/right\n  if (name.length === 4) name = [name[2],name[2],name[0],name[1],name[3],name[3]];\n  return name;\n};\n\nTexture.prototype._afterLoading = function() {\n  var self = this;\n  function alldone() {\n    self.loading--;\n    self._atlasuv = self.atlas.uv(self.canvas.width, self.canvas.height);\n    self._atlaskey = Object.create(null);\n    self.atlas.index().forEach(function(key) {\n      self._atlaskey[key.name] = key;\n    });\n    self.texture.needsUpdate = true;\n    self.material.needsUpdate = true;\n    //window.open(self.canvas.toDataURL());\n    if (self._meshQueue.length > 0) {\n      self._meshQueue.forEach(function(queue, i) {\n        self.paint.apply(queue.self, queue.args);\n        delete self._meshQueue[i];\n      });\n    }\n  }\n  self._powerof2(function() {\n    setTimeout(alldone, 100);\n  });\n};\n\n// Ensure the texture stays at a power of 2 for mipmaps\n// this is cheating :D\nTexture.prototype._powerof2 = function(done) {\n  var w = this.canvas.width;\n  var h = this.canvas.height;\n  function pow2(x) {\n    x--;\n    x |= x >> 1;\n    x |= x >> 2;\n    x |= x >> 4;\n    x |= x >> 8;\n    x |= x >> 16;\n    x++;\n    return x;\n  }\n  if (h > w) w = h;\n  var old = this.canvas.getContext('2d').getImageData(0, 0, this.canvas.width, this.canvas.height);\n  this.canvas.width = this.canvas.height = pow2(w);\n  this.canvas.getContext('2d').putImageData(old, 0, 0);\n  done();\n};\n\nTexture.prototype.paint = function(mesh, materials) {\n  var self = this;\n\n  // if were loading put into queue\n  if (self.loading > 0) {\n    self._meshQueue.push({self: self, args: arguments});\n    return false;\n  }\n\n  var isVoxelMesh = (materials) ? false : true;\n  if (!isVoxelMesh) materials = self._expandName(materials);\n\n  mesh.geometry.faces.forEach(function(face, i) {\n    if (mesh.geometry.faceVertexUvs[0].length < 1) return;\n\n    if (isVoxelMesh) {\n      var index = Math.floor(face.color.b*255 + face.color.g*255*255 + face.color.r*255*255*255);\n      materials = self.materials[index - 1];\n      if (!materials) materials = self.materials[0];\n    }\n\n    // BACK, FRONT, TOP, BOTTOM, LEFT, RIGHT\n    var name = materials[0] || '';\n    if      (face.normal.z === 1)  name = materials[1] || '';\n    else if (face.normal.y === 1)  name = materials[2] || '';\n    else if (face.normal.y === -1) name = materials[3] || '';\n    else if (face.normal.x === -1) name = materials[4] || '';\n    else if (face.normal.x === 1)  name = materials[5] || '';\n\n    // if just a simple color\n    if (name.slice(0, 1) === '#') {\n      self.ao(face, name);\n      return;\n    }\n\n    var atlasuv = self._atlasuv[name];\n    if (!atlasuv) return;\n\n    // If a transparent texture use transparent material\n    face.materialIndex = (self.transparents.indexOf(name) !== -1) ? 1 : 0;\n\n    // 0 -- 1\n    // |    |\n    // 3 -- 2\n    // faces on these meshes are flipped vertically, so we map in reverse\n    // TODO: tops need rotate\n    if (isVoxelMesh) {\n      if (face.normal.z === -1 || face.normal.x === 1) {\n        atlasuv = uvrot(atlasuv, 90);\n      }\n      atlasuv = uvinvert(atlasuv);\n    } else {\n      atlasuv = uvrot(atlasuv, -90);\n    }\n    for (var j = 0; j < mesh.geometry.faceVertexUvs[0][i].length; j++) {\n      mesh.geometry.faceVertexUvs[0][i][j].set(atlasuv[j][0], 1 - atlasuv[j][1]);\n    }\n  });\n\n  mesh.geometry.uvsNeedUpdate = true;\n};\n\nTexture.prototype.sprite = function(name, w, h, cb) {\n  var self = this;\n  if (typeof w === 'function') { cb = w; w = null; }\n  if (typeof h === 'function') { cb = h; h = null; }\n  w = w || 16; h = h || w;\n  self.loading++;\n  var img = new Image();\n  img.src = self.texturePath + ext(name);\n  img.onerror = cb;\n  img.onload = function() {\n    var canvases = [];\n    for (var x = 0; x < img.width; x += w) {\n      for (var y = 0; y < img.height; y += h) {\n        var canvas = document.createElement('canvas');\n        canvas.width = w; canvas.height = h;\n        canvas.name = name + '_' + x + '_' + y;\n        canvas.getContext('2d').drawImage(img, x, y, w, h, 0, 0, w, h);\n        canvases.push(canvas);\n      }\n    }\n    var textures = [];\n    each(canvases, function(canvas, next) {\n      var tex = new Image();\n      tex.name = canvas.name;\n      tex.src = canvas.toDataURL();\n      tex.onload = function() {\n        self.pack(tex, next);\n      };\n      tex.onerror = next;\n      textures.push([\n        tex.name, tex.name, tex.name,\n        tex.name, tex.name, tex.name\n      ]);\n    }, function() {\n      self._afterLoading();\n      delete canvases;\n      self.materials = self.materials.concat(textures);\n      cb(textures);\n    });\n  };\n  return self;\n};\n\nTexture.prototype.animate = function(mesh, names, delay) {\n  var self = this;\n  delay = delay || 1000;\n  if (!Array.isArray(names) || names.length < 2) return false;\n  var i = 0;\n  var mat = new this.options.materialType(this.options.materialParams);\n  mat.map = this.texture;\n  mat.transparent = true;\n  mat.needsUpdate = true;\n  tic.interval(function() {\n    self.paint(mesh, names[i % names.length]);\n    i++;\n  }, delay);\n  return mat;\n};\n\nTexture.prototype.tick = function(dt) {\n  tic.tick(dt);\n};\n\nfunction uvrot(coords, deg) {\n  if (deg === 0) return coords;\n  var c = [];\n  var i = (4 - Math.ceil(deg / 90)) % 4;\n  for (var j = 0; j < 4; j++) {\n    c.push(coords[i]);\n    if (i === 3) i = 0; else i++;\n  }\n  return c;\n}\n\nfunction uvinvert(coords) {\n  var c = coords.slice(0);\n  return [c[3], c[2], c[1], c[0]];\n}\n\nfunction ext(name) {\n  return (String(name).indexOf('.') !== -1) ? name : name + '.png';\n}\n\nfunction defaults(obj) {\n  [].slice.call(arguments, 1).forEach(function(from) {\n    if (from) for (var k in from) if (obj[k] == null) obj[k] = from[k];\n  });\n  return obj;\n}\n\nfunction each(arr, it, done) {\n  var count = 0;\n  arr.forEach(function(a) {\n    it(a, function() {\n      count++;\n      if (count >= arr.length) done();\n    });\n  });\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2RtaWxsZXQvUHJvamVjdHMvZnB0L2ZwdC1vbGQvfi92b3hlbC10ZXh0dXJlL2luZGV4LmpzPzQyOTciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9DQUFvQztBQUNwQztBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsNEJBQTRCO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG1CQUFtQiw4Q0FBOEM7QUFDakU7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVEsVUFBVTtBQUNsRCxnQ0FBZ0MsUUFBUSxVQUFVO0FBQ2xELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQyxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIIiwiZmlsZSI6IjM2LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHRpYyA9IHJlcXVpcmUoJ3RpYycpKCk7XG52YXIgY3JlYXRlQXRsYXMgPSByZXF1aXJlKCdhdGxhc3BhY2snKTtcbnZhciBpc1RyYW5zcGFyZW50ID0gcmVxdWlyZSgnb3BhcXVlJykudHJhbnNwYXJlbnQ7XG5cbmZ1bmN0aW9uIFRleHR1cmUob3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVGV4dHVyZSkpIHJldHVybiBuZXcgVGV4dHVyZShvcHRzIHx8IHt9KTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLmdhbWUgPSBvcHRzLmdhbWU7IGRlbGV0ZSBvcHRzLmdhbWU7XG4gIHRoaXMuVEhSRUUgPSB0aGlzLmdhbWUuVEhSRUU7XG4gIHRoaXMubWF0ZXJpYWxzID0gW107XG4gIHRoaXMudHJhbnNwYXJlbnRzID0gW107XG4gIHRoaXMudGV4dHVyZVBhdGggPSBvcHRzLnRleHR1cmVQYXRoIHx8ICcvdGV4dHVyZXMvJztcbiAgdGhpcy5sb2FkaW5nID0gMDtcbiAgdGhpcy5hbyA9IHJlcXVpcmUoJ3ZveGVsLWZha2VhbycpKHRoaXMuZ2FtZSk7XG5cbiAgdmFyIHVzZUZsYXRDb2xvcnMgPSBvcHRzLm1hdGVyaWFsRmxhdENvbG9yID09PSB0cnVlO1xuICBkZWxldGUgb3B0cy5tYXRlcmlhbEZsYXRDb2xvcjtcblxuICB0aGlzLm9wdGlvbnMgPSBkZWZhdWx0cyhvcHRzIHx8IHt9LCB7XG4gICAgY3Jvc3NPcmlnaW46ICdBbm9ueW1vdXMnLFxuICAgIG1hdGVyaWFsUGFyYW1zOiBkZWZhdWx0cyhvcHRzLm1hdGVyaWFsUGFyYW1zIHx8IHt9LCB7XG4gICAgICBhbWJpZW50OiAweGJiYmJiYixcbiAgICAgIHRyYW5zcGFyZW50OiBmYWxzZSxcbiAgICAgIHNpZGU6IHRoaXMuVEhSRUUuRG91YmxlU2lkZSxcbiAgICB9KSxcbiAgICBtYXRlcmlhbFRyYW5zcGFyZW50UGFyYW1zOiBkZWZhdWx0cyhvcHRzLm1hdGVyaWFsVHJhbnNwYXJlbnRQYXJhbXMgfHwge30sIHtcbiAgICAgIGFtYmllbnQ6IDB4YmJiYmJiLFxuICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgICBzaWRlOiB0aGlzLlRIUkVFLkRvdWJsZVNpZGUsXG4gICAgICAvL2RlcHRoV3JpdGU6IGZhbHNlLFxuICAgICAgLy9kZXB0aFRlc3Q6IGZhbHNlXG4gICAgfSksXG4gICAgbWF0ZXJpYWxUeXBlOiB0aGlzLlRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwsXG4gICAgYXBwbHlUZXh0dXJlUGFyYW1zOiBmdW5jdGlvbihtYXApIHtcbiAgICAgIG1hcC5tYWdGaWx0ZXIgPSBzZWxmLlRIUkVFLk5lYXJlc3RGaWx0ZXI7XG4gICAgICBtYXAubWluRmlsdGVyID0gc2VsZi5USFJFRS5MaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXI7XG4gICAgfVxuICB9KTtcblxuICAvLyBjcmVhdGUgYSBjYW52YXMgZm9yIHRoZSB0ZXh0dXJlIGF0bGFzXG4gIHRoaXMuY2FudmFzID0gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykgOiB7fTtcbiAgdGhpcy5jYW52YXMud2lkdGggPSBvcHRzLmF0bGFzV2lkdGggfHwgNTEyO1xuICB0aGlzLmNhbnZhcy5oZWlnaHQgPSBvcHRzLmF0bGFzSGVpZ2h0IHx8IDUxMjtcbiAgdmFyIGN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIGN0eC5maWxsU3R5bGUgPSAnYmxhY2snO1xuICBjdHguZmlsbFJlY3QoMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodCk7XG5cbiAgLy8gY3JlYXRlIGNvcmUgYXRsYXMgYW5kIHRleHR1cmVcbiAgdGhpcy5hdGxhcyA9IGNyZWF0ZUF0bGFzKHRoaXMuY2FudmFzKTtcbiAgdGhpcy5hdGxhcy50aWxlcGFkID0gdHJ1ZTtcbiAgdGhpcy5fYXRsYXN1diA9IGZhbHNlO1xuICB0aGlzLl9hdGxhc2tleSA9IGZhbHNlO1xuICB0aGlzLnRleHR1cmUgPSBuZXcgdGhpcy5USFJFRS5UZXh0dXJlKHRoaXMuY2FudmFzKTtcbiAgdGhpcy5vcHRpb25zLmFwcGx5VGV4dHVyZVBhcmFtcyh0aGlzLnRleHR1cmUpO1xuXG4gIGlmICh1c2VGbGF0Q29sb3JzKSB7XG4gICAgLy8gSWYgd2VyZSB1c2luZyBzaW1wbGUgY29sb3JzXG4gICAgdGhpcy5tYXRlcmlhbCA9IG5ldyB0aGlzLlRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAgICAgIHZlcnRleENvbG9yczogdGhpcy5USFJFRS5WZXJ0ZXhDb2xvcnNcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgb3BhcXVlID0gbmV3IHRoaXMub3B0aW9ucy5tYXRlcmlhbFR5cGUodGhpcy5vcHRpb25zLm1hdGVyaWFsUGFyYW1zKTtcbiAgICBvcGFxdWUubWFwID0gdGhpcy50ZXh0dXJlO1xuICAgIHZhciB0cmFuc3BhcmVudCA9IG5ldyB0aGlzLm9wdGlvbnMubWF0ZXJpYWxUeXBlKHRoaXMub3B0aW9ucy5tYXRlcmlhbFRyYW5zcGFyZW50UGFyYW1zKTtcbiAgICB0cmFuc3BhcmVudC5tYXAgPSB0aGlzLnRleHR1cmU7XG4gICAgdGhpcy5tYXRlcmlhbCA9IG5ldyB0aGlzLlRIUkVFLk1lc2hGYWNlTWF0ZXJpYWwoW1xuICAgICAgb3BhcXVlLFxuICAgICAgdHJhbnNwYXJlbnRcbiAgICBdKTtcbiAgfVxuXG4gIC8vIGEgcGxhY2UgZm9yIG1lc2hlcyB0byB3YWl0IHdoaWxlIHRleHR1cmVzIGFyZSBsb2FkaW5nXG4gIHRoaXMuX21lc2hRdWV1ZSA9IFtdO1xufVxubW9kdWxlLmV4cG9ydHMgPSBUZXh0dXJlO1xuXG5UZXh0dXJlLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24obmFtZXMsIGRvbmUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAoIUFycmF5LmlzQXJyYXkobmFtZXMpKSBuYW1lcyA9IFtuYW1lc107XG4gIGRvbmUgPSBkb25lIHx8IGZ1bmN0aW9uKCkge307XG4gIHRoaXMubG9hZGluZysrO1xuXG4gIHZhciBtYXRlcmlhbFNsaWNlID0gbmFtZXMubWFwKHNlbGYuX2V4cGFuZE5hbWUpO1xuICBzZWxmLm1hdGVyaWFscyA9IHNlbGYubWF0ZXJpYWxzLmNvbmNhdChtYXRlcmlhbFNsaWNlKTtcblxuICAvLyBsb2FkIG9udG8gdGhlIHRleHR1cmUgYXRsYXNcbiAgdmFyIGxvYWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBtYXRlcmlhbFNsaWNlLmZvckVhY2goZnVuY3Rpb24obWF0cykge1xuICAgIG1hdHMuZm9yRWFjaChmdW5jdGlvbihtYXQpIHtcbiAgICAgIGlmIChtYXQuc2xpY2UoMCwgMSkgPT09ICcjJykgcmV0dXJuO1xuICAgICAgLy8gdG9kbzogY2hlY2sgaWYgdGV4dHVyZSBhbHJlYWR5IGV4aXN0c1xuICAgICAgbG9hZFttYXRdID0gdHJ1ZTtcbiAgICB9KTtcbiAgfSk7XG4gIGlmIChPYmplY3Qua2V5cyhsb2FkKS5sZW5ndGggPiAwKSB7XG4gICAgZWFjaChPYmplY3Qua2V5cyhsb2FkKSwgc2VsZi5wYWNrLmJpbmQoc2VsZiksIGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5fYWZ0ZXJMb2FkaW5nKCk7XG4gICAgICBkb25lKG1hdGVyaWFsU2xpY2UpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHNlbGYuX2FmdGVyTG9hZGluZygpO1xuICB9XG59O1xuXG5UZXh0dXJlLnByb3RvdHlwZS5wYWNrID0gZnVuY3Rpb24obmFtZSwgZG9uZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGZ1bmN0aW9uIHBhY2soaW1nKSB7XG4gICAgdmFyIG5vZGUgPSBzZWxmLmF0bGFzLnBhY2soaW1nKTtcbiAgICBpZiAobm9kZSA9PT0gZmFsc2UpIHtcbiAgICAgIHNlbGYuYXRsYXMgPSBzZWxmLmF0bGFzLmV4cGFuZChpbWcpO1xuICAgICAgc2VsZi5hdGxhcy50aWxlcGFkID0gdHJ1ZTtcbiAgICB9XG4gICAgZG9uZSgpO1xuICB9XG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgaW1nLmlkID0gbmFtZTtcbiAgICBpbWcuY3Jvc3NPcmlnaW4gPSBzZWxmLm9wdGlvbnMuY3Jvc3NPcmlnaW47XG4gICAgaW1nLnNyYyA9IHNlbGYudGV4dHVyZVBhdGggKyBleHQobmFtZSk7XG4gICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGlzVHJhbnNwYXJlbnQoaW1nKSkge1xuICAgICAgICBzZWxmLnRyYW5zcGFyZW50cy5wdXNoKG5hbWUpO1xuICAgICAgfVxuICAgICAgcGFjayhpbWcpO1xuICAgIH07XG4gICAgaW1nLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0NvdWxkblxcJ3QgbG9hZCBVUkwgWycgKyBpbWcuc3JjICsgJ10nKTtcbiAgICAgIGRvbmUoKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHBhY2sobmFtZSk7XG4gIH1cbiAgcmV0dXJuIHNlbGY7XG59O1xuXG5UZXh0dXJlLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB0eXBlID0gMDtcbiAgc2VsZi5tYXRlcmlhbHMuZm9yRWFjaChmdW5jdGlvbihtYXRzLCBpKSB7XG4gICAgbWF0cy5mb3JFYWNoKGZ1bmN0aW9uKG1hdCkge1xuICAgICAgaWYgKG1hdCA9PT0gbmFtZSkge1xuICAgICAgICB0eXBlID0gaSArIDE7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAodHlwZSAhPT0gMCkgcmV0dXJuIGZhbHNlO1xuICB9KTtcbiAgcmV0dXJuIHR5cGU7XG59O1xuXG5UZXh0dXJlLnByb3RvdHlwZS5fZXhwYW5kTmFtZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgaWYgKG5hbWUgPT09IG51bGwpIHJldHVybiBBcnJheSg2KTtcbiAgaWYgKG5hbWUudG9wKSByZXR1cm4gW25hbWUuYmFjaywgbmFtZS5mcm9udCwgbmFtZS50b3AsIG5hbWUuYm90dG9tLCBuYW1lLmxlZnQsIG5hbWUucmlnaHRdO1xuICBpZiAoIUFycmF5LmlzQXJyYXkobmFtZSkpIG5hbWUgPSBbbmFtZV07XG4gIC8vIGxvYWQgdGhlIDAgdGV4dHVyZSB0byBhbGxcbiAgaWYgKG5hbWUubGVuZ3RoID09PSAxKSBuYW1lID0gW25hbWVbMF0sbmFtZVswXSxuYW1lWzBdLG5hbWVbMF0sbmFtZVswXSxuYW1lWzBdXTtcbiAgLy8gMCBpcyB0b3AvYm90dG9tLCAxIGlzIHNpZGVzXG4gIGlmIChuYW1lLmxlbmd0aCA9PT0gMikgbmFtZSA9IFtuYW1lWzFdLG5hbWVbMV0sbmFtZVswXSxuYW1lWzBdLG5hbWVbMV0sbmFtZVsxXV07XG4gIC8vIDAgaXMgdG9wLCAxIGlzIGJvdHRvbSwgMiBpcyBzaWRlc1xuICBpZiAobmFtZS5sZW5ndGggPT09IDMpIG5hbWUgPSBbbmFtZVsyXSxuYW1lWzJdLG5hbWVbMF0sbmFtZVsxXSxuYW1lWzJdLG5hbWVbMl1dO1xuICAvLyAwIGlzIHRvcCwgMSBpcyBib3R0b20sIDIgaXMgZnJvbnQvYmFjaywgMyBpcyBsZWZ0L3JpZ2h0XG4gIGlmIChuYW1lLmxlbmd0aCA9PT0gNCkgbmFtZSA9IFtuYW1lWzJdLG5hbWVbMl0sbmFtZVswXSxuYW1lWzFdLG5hbWVbM10sbmFtZVszXV07XG4gIHJldHVybiBuYW1lO1xufTtcblxuVGV4dHVyZS5wcm90b3R5cGUuX2FmdGVyTG9hZGluZyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGZ1bmN0aW9uIGFsbGRvbmUoKSB7XG4gICAgc2VsZi5sb2FkaW5nLS07XG4gICAgc2VsZi5fYXRsYXN1diA9IHNlbGYuYXRsYXMudXYoc2VsZi5jYW52YXMud2lkdGgsIHNlbGYuY2FudmFzLmhlaWdodCk7XG4gICAgc2VsZi5fYXRsYXNrZXkgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHNlbGYuYXRsYXMuaW5kZXgoKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgc2VsZi5fYXRsYXNrZXlba2V5Lm5hbWVdID0ga2V5O1xuICAgIH0pO1xuICAgIHNlbGYudGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgc2VsZi5tYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgLy93aW5kb3cub3BlbihzZWxmLmNhbnZhcy50b0RhdGFVUkwoKSk7XG4gICAgaWYgKHNlbGYuX21lc2hRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICBzZWxmLl9tZXNoUXVldWUuZm9yRWFjaChmdW5jdGlvbihxdWV1ZSwgaSkge1xuICAgICAgICBzZWxmLnBhaW50LmFwcGx5KHF1ZXVlLnNlbGYsIHF1ZXVlLmFyZ3MpO1xuICAgICAgICBkZWxldGUgc2VsZi5fbWVzaFF1ZXVlW2ldO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHNlbGYuX3Bvd2Vyb2YyKGZ1bmN0aW9uKCkge1xuICAgIHNldFRpbWVvdXQoYWxsZG9uZSwgMTAwKTtcbiAgfSk7XG59O1xuXG4vLyBFbnN1cmUgdGhlIHRleHR1cmUgc3RheXMgYXQgYSBwb3dlciBvZiAyIGZvciBtaXBtYXBzXG4vLyB0aGlzIGlzIGNoZWF0aW5nIDpEXG5UZXh0dXJlLnByb3RvdHlwZS5fcG93ZXJvZjIgPSBmdW5jdGlvbihkb25lKSB7XG4gIHZhciB3ID0gdGhpcy5jYW52YXMud2lkdGg7XG4gIHZhciBoID0gdGhpcy5jYW52YXMuaGVpZ2h0O1xuICBmdW5jdGlvbiBwb3cyKHgpIHtcbiAgICB4LS07XG4gICAgeCB8PSB4ID4+IDE7XG4gICAgeCB8PSB4ID4+IDI7XG4gICAgeCB8PSB4ID4+IDQ7XG4gICAgeCB8PSB4ID4+IDg7XG4gICAgeCB8PSB4ID4+IDE2O1xuICAgIHgrKztcbiAgICByZXR1cm4geDtcbiAgfVxuICBpZiAoaCA+IHcpIHcgPSBoO1xuICB2YXIgb2xkID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5nZXRJbWFnZURhdGEoMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodCk7XG4gIHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy5jYW52YXMuaGVpZ2h0ID0gcG93Mih3KTtcbiAgdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5wdXRJbWFnZURhdGEob2xkLCAwLCAwKTtcbiAgZG9uZSgpO1xufTtcblxuVGV4dHVyZS5wcm90b3R5cGUucGFpbnQgPSBmdW5jdGlvbihtZXNoLCBtYXRlcmlhbHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIC8vIGlmIHdlcmUgbG9hZGluZyBwdXQgaW50byBxdWV1ZVxuICBpZiAoc2VsZi5sb2FkaW5nID4gMCkge1xuICAgIHNlbGYuX21lc2hRdWV1ZS5wdXNoKHtzZWxmOiBzZWxmLCBhcmdzOiBhcmd1bWVudHN9KTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgaXNWb3hlbE1lc2ggPSAobWF0ZXJpYWxzKSA/IGZhbHNlIDogdHJ1ZTtcbiAgaWYgKCFpc1ZveGVsTWVzaCkgbWF0ZXJpYWxzID0gc2VsZi5fZXhwYW5kTmFtZShtYXRlcmlhbHMpO1xuXG4gIG1lc2guZ2VvbWV0cnkuZmFjZXMuZm9yRWFjaChmdW5jdGlvbihmYWNlLCBpKSB7XG4gICAgaWYgKG1lc2guZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1swXS5sZW5ndGggPCAxKSByZXR1cm47XG5cbiAgICBpZiAoaXNWb3hlbE1lc2gpIHtcbiAgICAgIHZhciBpbmRleCA9IE1hdGguZmxvb3IoZmFjZS5jb2xvci5iKjI1NSArIGZhY2UuY29sb3IuZyoyNTUqMjU1ICsgZmFjZS5jb2xvci5yKjI1NSoyNTUqMjU1KTtcbiAgICAgIG1hdGVyaWFscyA9IHNlbGYubWF0ZXJpYWxzW2luZGV4IC0gMV07XG4gICAgICBpZiAoIW1hdGVyaWFscykgbWF0ZXJpYWxzID0gc2VsZi5tYXRlcmlhbHNbMF07XG4gICAgfVxuXG4gICAgLy8gQkFDSywgRlJPTlQsIFRPUCwgQk9UVE9NLCBMRUZULCBSSUdIVFxuICAgIHZhciBuYW1lID0gbWF0ZXJpYWxzWzBdIHx8ICcnO1xuICAgIGlmICAgICAgKGZhY2Uubm9ybWFsLnogPT09IDEpICBuYW1lID0gbWF0ZXJpYWxzWzFdIHx8ICcnO1xuICAgIGVsc2UgaWYgKGZhY2Uubm9ybWFsLnkgPT09IDEpICBuYW1lID0gbWF0ZXJpYWxzWzJdIHx8ICcnO1xuICAgIGVsc2UgaWYgKGZhY2Uubm9ybWFsLnkgPT09IC0xKSBuYW1lID0gbWF0ZXJpYWxzWzNdIHx8ICcnO1xuICAgIGVsc2UgaWYgKGZhY2Uubm9ybWFsLnggPT09IC0xKSBuYW1lID0gbWF0ZXJpYWxzWzRdIHx8ICcnO1xuICAgIGVsc2UgaWYgKGZhY2Uubm9ybWFsLnggPT09IDEpICBuYW1lID0gbWF0ZXJpYWxzWzVdIHx8ICcnO1xuXG4gICAgLy8gaWYganVzdCBhIHNpbXBsZSBjb2xvclxuICAgIGlmIChuYW1lLnNsaWNlKDAsIDEpID09PSAnIycpIHtcbiAgICAgIHNlbGYuYW8oZmFjZSwgbmFtZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGF0bGFzdXYgPSBzZWxmLl9hdGxhc3V2W25hbWVdO1xuICAgIGlmICghYXRsYXN1dikgcmV0dXJuO1xuXG4gICAgLy8gSWYgYSB0cmFuc3BhcmVudCB0ZXh0dXJlIHVzZSB0cmFuc3BhcmVudCBtYXRlcmlhbFxuICAgIGZhY2UubWF0ZXJpYWxJbmRleCA9IChzZWxmLnRyYW5zcGFyZW50cy5pbmRleE9mKG5hbWUpICE9PSAtMSkgPyAxIDogMDtcblxuICAgIC8vIDAgLS0gMVxuICAgIC8vIHwgICAgfFxuICAgIC8vIDMgLS0gMlxuICAgIC8vIGZhY2VzIG9uIHRoZXNlIG1lc2hlcyBhcmUgZmxpcHBlZCB2ZXJ0aWNhbGx5LCBzbyB3ZSBtYXAgaW4gcmV2ZXJzZVxuICAgIC8vIFRPRE86IHRvcHMgbmVlZCByb3RhdGVcbiAgICBpZiAoaXNWb3hlbE1lc2gpIHtcbiAgICAgIGlmIChmYWNlLm5vcm1hbC56ID09PSAtMSB8fCBmYWNlLm5vcm1hbC54ID09PSAxKSB7XG4gICAgICAgIGF0bGFzdXYgPSB1dnJvdChhdGxhc3V2LCA5MCk7XG4gICAgICB9XG4gICAgICBhdGxhc3V2ID0gdXZpbnZlcnQoYXRsYXN1dik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF0bGFzdXYgPSB1dnJvdChhdGxhc3V2LCAtOTApO1xuICAgIH1cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc2guZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1swXVtpXS5sZW5ndGg7IGorKykge1xuICAgICAgbWVzaC5nZW9tZXRyeS5mYWNlVmVydGV4VXZzWzBdW2ldW2pdLnNldChhdGxhc3V2W2pdWzBdLCAxIC0gYXRsYXN1dltqXVsxXSk7XG4gICAgfVxuICB9KTtcblxuICBtZXNoLmdlb21ldHJ5LnV2c05lZWRVcGRhdGUgPSB0cnVlO1xufTtcblxuVGV4dHVyZS5wcm90b3R5cGUuc3ByaXRlID0gZnVuY3Rpb24obmFtZSwgdywgaCwgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAodHlwZW9mIHcgPT09ICdmdW5jdGlvbicpIHsgY2IgPSB3OyB3ID0gbnVsbDsgfVxuICBpZiAodHlwZW9mIGggPT09ICdmdW5jdGlvbicpIHsgY2IgPSBoOyBoID0gbnVsbDsgfVxuICB3ID0gdyB8fCAxNjsgaCA9IGggfHwgdztcbiAgc2VsZi5sb2FkaW5nKys7XG4gIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgaW1nLnNyYyA9IHNlbGYudGV4dHVyZVBhdGggKyBleHQobmFtZSk7XG4gIGltZy5vbmVycm9yID0gY2I7XG4gIGltZy5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2FudmFzZXMgPSBbXTtcbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGltZy53aWR0aDsgeCArPSB3KSB7XG4gICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGltZy5oZWlnaHQ7IHkgKz0gaCkge1xuICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHc7IGNhbnZhcy5oZWlnaHQgPSBoO1xuICAgICAgICBjYW52YXMubmFtZSA9IG5hbWUgKyAnXycgKyB4ICsgJ18nICsgeTtcbiAgICAgICAgY2FudmFzLmdldENvbnRleHQoJzJkJykuZHJhd0ltYWdlKGltZywgeCwgeSwgdywgaCwgMCwgMCwgdywgaCk7XG4gICAgICAgIGNhbnZhc2VzLnB1c2goY2FudmFzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHRleHR1cmVzID0gW107XG4gICAgZWFjaChjYW52YXNlcywgZnVuY3Rpb24oY2FudmFzLCBuZXh0KSB7XG4gICAgICB2YXIgdGV4ID0gbmV3IEltYWdlKCk7XG4gICAgICB0ZXgubmFtZSA9IGNhbnZhcy5uYW1lO1xuICAgICAgdGV4LnNyYyA9IGNhbnZhcy50b0RhdGFVUkwoKTtcbiAgICAgIHRleC5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5wYWNrKHRleCwgbmV4dCk7XG4gICAgICB9O1xuICAgICAgdGV4Lm9uZXJyb3IgPSBuZXh0O1xuICAgICAgdGV4dHVyZXMucHVzaChbXG4gICAgICAgIHRleC5uYW1lLCB0ZXgubmFtZSwgdGV4Lm5hbWUsXG4gICAgICAgIHRleC5uYW1lLCB0ZXgubmFtZSwgdGV4Lm5hbWVcbiAgICAgIF0pO1xuICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5fYWZ0ZXJMb2FkaW5nKCk7XG4gICAgICBkZWxldGUgY2FudmFzZXM7XG4gICAgICBzZWxmLm1hdGVyaWFscyA9IHNlbGYubWF0ZXJpYWxzLmNvbmNhdCh0ZXh0dXJlcyk7XG4gICAgICBjYih0ZXh0dXJlcyk7XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiBzZWxmO1xufTtcblxuVGV4dHVyZS5wcm90b3R5cGUuYW5pbWF0ZSA9IGZ1bmN0aW9uKG1lc2gsIG5hbWVzLCBkZWxheSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGRlbGF5ID0gZGVsYXkgfHwgMTAwMDtcbiAgaWYgKCFBcnJheS5pc0FycmF5KG5hbWVzKSB8fCBuYW1lcy5sZW5ndGggPCAyKSByZXR1cm4gZmFsc2U7XG4gIHZhciBpID0gMDtcbiAgdmFyIG1hdCA9IG5ldyB0aGlzLm9wdGlvbnMubWF0ZXJpYWxUeXBlKHRoaXMub3B0aW9ucy5tYXRlcmlhbFBhcmFtcyk7XG4gIG1hdC5tYXAgPSB0aGlzLnRleHR1cmU7XG4gIG1hdC50cmFuc3BhcmVudCA9IHRydWU7XG4gIG1hdC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIHRpYy5pbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICBzZWxmLnBhaW50KG1lc2gsIG5hbWVzW2kgJSBuYW1lcy5sZW5ndGhdKTtcbiAgICBpKys7XG4gIH0sIGRlbGF5KTtcbiAgcmV0dXJuIG1hdDtcbn07XG5cblRleHR1cmUucHJvdG90eXBlLnRpY2sgPSBmdW5jdGlvbihkdCkge1xuICB0aWMudGljayhkdCk7XG59O1xuXG5mdW5jdGlvbiB1dnJvdChjb29yZHMsIGRlZykge1xuICBpZiAoZGVnID09PSAwKSByZXR1cm4gY29vcmRzO1xuICB2YXIgYyA9IFtdO1xuICB2YXIgaSA9ICg0IC0gTWF0aC5jZWlsKGRlZyAvIDkwKSkgJSA0O1xuICBmb3IgKHZhciBqID0gMDsgaiA8IDQ7IGorKykge1xuICAgIGMucHVzaChjb29yZHNbaV0pO1xuICAgIGlmIChpID09PSAzKSBpID0gMDsgZWxzZSBpKys7XG4gIH1cbiAgcmV0dXJuIGM7XG59XG5cbmZ1bmN0aW9uIHV2aW52ZXJ0KGNvb3Jkcykge1xuICB2YXIgYyA9IGNvb3Jkcy5zbGljZSgwKTtcbiAgcmV0dXJuIFtjWzNdLCBjWzJdLCBjWzFdLCBjWzBdXTtcbn1cblxuZnVuY3Rpb24gZXh0KG5hbWUpIHtcbiAgcmV0dXJuIChTdHJpbmcobmFtZSkuaW5kZXhPZignLicpICE9PSAtMSkgPyBuYW1lIDogbmFtZSArICcucG5nJztcbn1cblxuZnVuY3Rpb24gZGVmYXVsdHMob2JqKSB7XG4gIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKS5mb3JFYWNoKGZ1bmN0aW9uKGZyb20pIHtcbiAgICBpZiAoZnJvbSkgZm9yICh2YXIgayBpbiBmcm9tKSBpZiAob2JqW2tdID09IG51bGwpIG9ialtrXSA9IGZyb21ba107XG4gIH0pO1xuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBlYWNoKGFyciwgaXQsIGRvbmUpIHtcbiAgdmFyIGNvdW50ID0gMDtcbiAgYXJyLmZvckVhY2goZnVuY3Rpb24oYSkge1xuICAgIGl0KGEsIGZ1bmN0aW9uKCkge1xuICAgICAgY291bnQrKztcbiAgICAgIGlmIChjb3VudCA+PSBhcnIubGVuZ3RoKSBkb25lKCk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvZG1pbGxldC9Qcm9qZWN0cy9mcHQvZnB0LW9sZC9+L3ZveGVsLXRleHR1cmUvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAzNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDEgMlxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 37 */
/***/ function(module, exports) {

	eval("/*\n * tic\n * https://github.com/shama/tic\n *\n * Copyright (c) 2013 Kyle Robinson Young\n * Licensed under the MIT license.\n */\n\nfunction Tic() { this._things = []; }\nmodule.exports = function() { return new Tic(); };\n\nTic.prototype._stack = function(thing) {\n  var self = this;\n  self._things.push(thing);\n  var i = self._things.length - 1;\n  return function() { delete self._things[i]; }\n};\n\nTic.prototype.interval = Tic.prototype.setInterval = function(fn, at) {\n  return this._stack({\n    fn: fn, at: at, args: Array.prototype.slice.call(arguments, 2),\n    elapsed: 0, once: false\n  });\n};\n\nTic.prototype.timeout = Tic.prototype.setTimeout = function(fn, at) {\n  return this._stack({\n    fn: fn, at: at, args: Array.prototype.slice.call(arguments, 2),\n    elapsed: 0, once: true\n  });\n};\n\nTic.prototype.tick = function(dt) {\n  var self = this;\n  self._things.forEach(function(thing, i) {\n    thing.elapsed += dt;\n    if (thing.elapsed > thing.at) {\n      thing.elapsed -= thing.at;\n      thing.fn.apply(thing.fn, thing.args || []);\n      if (thing.once) {\n        delete self._things[i];\n      }\n    }\n  });\n};\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2RtaWxsZXQvUHJvamVjdHMvZnB0L2ZwdC1vbGQvfi92b3hlbC10ZXh0dXJlL34vdGljL2luZGV4LmpzPzg5NjEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLG1CQUFtQjtBQUNuQyw2QkFBNkIsa0JBQWtCOztBQUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3QkFBd0I7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsImZpbGUiOiIzNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiB0aWNcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zaGFtYS90aWNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMgS3lsZSBSb2JpbnNvbiBZb3VuZ1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICovXG5cbmZ1bmN0aW9uIFRpYygpIHsgdGhpcy5fdGhpbmdzID0gW107IH1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7IHJldHVybiBuZXcgVGljKCk7IH07XG5cblRpYy5wcm90b3R5cGUuX3N0YWNrID0gZnVuY3Rpb24odGhpbmcpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLl90aGluZ3MucHVzaCh0aGluZyk7XG4gIHZhciBpID0gc2VsZi5fdGhpbmdzLmxlbmd0aCAtIDE7XG4gIHJldHVybiBmdW5jdGlvbigpIHsgZGVsZXRlIHNlbGYuX3RoaW5nc1tpXTsgfVxufTtcblxuVGljLnByb3RvdHlwZS5pbnRlcnZhbCA9IFRpYy5wcm90b3R5cGUuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbihmbiwgYXQpIHtcbiAgcmV0dXJuIHRoaXMuX3N0YWNrKHtcbiAgICBmbjogZm4sIGF0OiBhdCwgYXJnczogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSxcbiAgICBlbGFwc2VkOiAwLCBvbmNlOiBmYWxzZVxuICB9KTtcbn07XG5cblRpYy5wcm90b3R5cGUudGltZW91dCA9IFRpYy5wcm90b3R5cGUuc2V0VGltZW91dCA9IGZ1bmN0aW9uKGZuLCBhdCkge1xuICByZXR1cm4gdGhpcy5fc3RhY2soe1xuICAgIGZuOiBmbiwgYXQ6IGF0LCBhcmdzOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpLFxuICAgIGVsYXBzZWQ6IDAsIG9uY2U6IHRydWVcbiAgfSk7XG59O1xuXG5UaWMucHJvdG90eXBlLnRpY2sgPSBmdW5jdGlvbihkdCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYuX3RoaW5ncy5mb3JFYWNoKGZ1bmN0aW9uKHRoaW5nLCBpKSB7XG4gICAgdGhpbmcuZWxhcHNlZCArPSBkdDtcbiAgICBpZiAodGhpbmcuZWxhcHNlZCA+IHRoaW5nLmF0KSB7XG4gICAgICB0aGluZy5lbGFwc2VkIC09IHRoaW5nLmF0O1xuICAgICAgdGhpbmcuZm4uYXBwbHkodGhpbmcuZm4sIHRoaW5nLmFyZ3MgfHwgW10pO1xuICAgICAgaWYgKHRoaW5nLm9uY2UpIHtcbiAgICAgICAgZGVsZXRlIHNlbGYuX3RoaW5nc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL2RtaWxsZXQvUHJvamVjdHMvZnB0L2ZwdC1vbGQvfi92b3hlbC10ZXh0dXJlL34vdGljL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxIDJcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	eval("var require;var require;!function(e){if(true)module.exports=e();else if(\"function\"==typeof define&&define.amd)define([],e);else{var f;\"undefined\"!=typeof window?f=window:\"undefined\"!=typeof global?f=global:\"undefined\"!=typeof self&&(f=self),f.atlaspack=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/*\n * atlaspack\n * https://github.com/shama/atlaspack\n *\n * Copyright (c) 2014 Kyle Robinson Young\n * Licensed under the MIT license.\n *\n * Based on Nick Welch's binpack: https://github.com/mackstann/binpack\n */\n\nfunction Rect(x, y, w, h) {\n  this.x = x; this.y = y;\n  this.w = w; this.h = h;\n}\n\nRect.prototype.fitsIn = function(outer) {\n  return outer.w >= this.w && outer.h >= this.h;\n};\n\nRect.prototype.sameSizeAs = function(other) {\n  return this.w === other.w && this.h === other.h;\n};\n\nfunction Atlas(x, y, w, h) {\n  if (arguments.length === 1) {\n    this.canvas = x;\n    x = y = 0;\n    w = this.canvas.width;\n    h = this.canvas.height;\n  }\n  if (arguments.length === 2) {\n    w = x; h = y; x = y = 0;\n  }\n  this.left = this.right = null;\n  this.rect = new Rect(x, y, w, h);\n  this.filled = false;\n  this.tilepad = false;\n  this._cache = [];\n  this._uvcache = Object.create(null);\n}\nmodule.exports = function() {\n  if (arguments.length === 1) { return new Atlas(arguments[0]); }\n  if (arguments.length === 2) { return new Atlas(arguments[0], arguments[1]); }\n  return new Atlas(arguments[0], arguments[1], arguments[2], arguments[3]);\n};\nmodule.exports.Atlas = Atlas;\nmodule.exports.Rect = Rect;\n\n// pack image/rect to the atlas\nAtlas.prototype.pack = function(rect) {\n  this._cache = [];\n  this._uvcache = Object.create(null);\n  rect = this._toRect(rect);\n\n  if (this.img && this.tilepad) {\n    rect = this._tilepad(rect);\n  }\n\n  if (this.left !== null) {\n    return this._ontoCanvas(this.left.pack(rect) || this.right.pack(rect));\n  }\n  // if atlas filled or wont fit\n  if (this.filled || !rect.fitsIn(this.rect)) {\n    return false;\n  }\n  // if this atlas has been filled\n  if (rect.sameSizeAs(this.rect)) {\n    this.filled = true;\n    return this._ontoCanvas(this);\n  }\n  if ((this.rect.w - rect.w) > (this.rect.h - rect.h)) {\n    this.left = new Atlas(this.rect.x, this.rect.y, rect.w, this.rect.h);\n    this.right = new Atlas(this.rect.x + rect.w, this.rect.y, this.rect.w - rect.w, this.rect.h);\n  } else {\n    this.left = new Atlas(this.rect.x, this.rect.y, this.rect.w, rect.h);\n    this.right = new Atlas(this.rect.x, this.rect.y + rect.h, this.rect.w, this.rect.h - rect.h);\n  }\n  return this._ontoCanvas(this.left.pack(rect));\n};\n\nAtlas.prototype.expand = function(rect) {\n  var self = this;\n  rect = this._toRect(rect);\n\n  if (this.img && this.tilepad) {\n    rect = this._tilepad(rect);\n  }\n\n  var atlas;\n  if (this.rect.w < this.rect.h) {\n    atlas = new Atlas(0, 0, this.rect.w + rect.w, this.rect.h);\n    atlas.right = new Atlas(this.rect.w, 0, rect.w, this.rect.h);\n    atlas.left = this;\n  } else {\n    atlas = new Atlas(0, 0, this.rect.w, this.rect.h + rect.h);\n    atlas.right = new Atlas(0, this.rect.h, this.rect.w, rect.h);\n    atlas.left = this;\n  }\n\n  ['canvas', 'context', 'img'].forEach(function(p) {\n    if (self[p]) {\n      atlas[p] = self[p];\n      self[p] = null;\n    }\n  });\n\n  // resize canvas\n  if (atlas.canvas) {\n    if (!atlas.context) {\n      atlas.context = atlas.canvas.getContext('2d');\n    }\n    var old = atlas.context.getImageData(0, 0, atlas.canvas.width, atlas.canvas.height);\n    atlas.canvas.width = atlas.rect.w;\n    atlas.canvas.height = atlas.rect.h;\n    atlas.context.putImageData(old, 0, 0);\n  }\n\n  return (atlas.pack(rect) === false) ? atlas.expand(rect) : atlas;\n};\n\nAtlas.prototype.index = function() {\n  var self = this;\n  if (self._cache.length > 0) {\n    return self._cache;\n  }\n  (function loop(atlas) {\n    if (atlas.left !== null) {\n      loop(atlas.left);\n      loop(atlas.right);\n    } else if (atlas.rect.name) {\n      self._cache.push(atlas.rect);\n    }\n  }(self));\n  return self._cache;\n};\n\nAtlas.prototype.uv = function(w, h) {\n  var self = this;\n  w = w || self.rect.w;\n  h = h || self.rect.h;\n  var isPad = this.tilepad;\n  (function loop(atlas) {\n    if (atlas.left !== null) {\n      loop(atlas.left);\n      loop(atlas.right);\n    } else if (typeof atlas.rect.name !== 'undefined') {\n      var p = (isPad) ? atlas.rect.w / 4 : 0;\n      self._uvcache[atlas.rect.name] = [\n        [atlas.rect.x + p, atlas.rect.y + p],\n        [(atlas.rect.x + p) + (atlas.rect.w - (p * 2)), atlas.rect.y + p],\n        [(atlas.rect.x + p) + (atlas.rect.w - (p * 2)), (atlas.rect.y + p) + (atlas.rect.h - (p * 2))],\n        [(atlas.rect.x + p), (atlas.rect.y + p) + (atlas.rect.h - (p * 2))],\n      ].map(function(uv) {\n        if (uv[0] !== 0) {\n          uv[0] = uv[0] / w;\n        }\n        if (uv[1] !== 0) {\n          uv[1] = uv[1] / h;\n        }\n        return uv;\n      });\n    }\n  }(self));\n  return self._uvcache;\n};\n\nAtlas.prototype.json = function(input) {\n  var self = this;\n  if (input) {\n    if (typeof input === 'string') input = JSON.parse(input);\n    return (function loop(obj) {\n      if (!obj || !obj.rect) return;\n      var atlas = new Atlas(obj.rect.x, obj.rect.y, obj.rect.w, obj.rect.h);\n      if (obj.left) atlas.left = loop(obj.left);\n      if (obj.right) atlas.right = loop(obj.right);\n      return atlas;\n    }(input));\n  } else {\n    return JSON.stringify(function loop(atlas) {\n      var obj = {\n        left: null, right: null,\n        rect: atlas.rect, filled: atlas.filled\n      };\n      if (atlas.left !== null) {\n        obj.left = loop(atlas.left);\n        obj.right = loop(atlas.right);\n      }\n      return obj;\n    }(self), null, 2);\n  }\n};\n\n// Pads the image by tiling itself around itself\nAtlas.prototype._tilepad = function(rect) {\n  var img = this.img;\n  if (!img) return rect;\n\n  var p = img.width / 2;\n\n  var canvas = document.createElement('canvas');\n  canvas.name = img.name || img.src;\n  canvas.id = img.id || '';\n  canvas.width = img.width + img.width;\n  canvas.height = img.height + img.height;\n  var ctx = canvas.getContext('2d');\n\n  var pattern = ctx.createPattern(img, 'repeat');\n  ctx.fillStyle = pattern;\n  ctx.translate(p, p);\n  ctx.fillRect(-p, -p, canvas.width + p, canvas.height + p);\n  ctx.translate(-p, -p);\n\n  this.img = canvas;\n\n  return new Rect(rect.x, rect.y, this.img.width, this.img.height);\n};\n\n// if has an image and canvas, draw to the canvas as we go\nAtlas.prototype._ontoCanvas = function(node) {\n  if (node && this.img && this.canvas) {\n    if (!this.context) {\n      this.context = this.canvas.getContext('2d');\n    }\n    this.context.clearRect(node.rect.x, node.rect.y, node.rect.w, node.rect.h);\n    this.context.drawImage(this.img, node.rect.x, node.rect.y, node.rect.w, node.rect.h);\n    node.rect.name = this.img.id || this.img.name || this.img.src || null;\n  }\n  return node;\n};\n\n// make sure we're always working with rects\nAtlas.prototype._toRect = function(rect) {\n  // if rect is an image\n  if (rect.nodeName && rect.nodeName === 'IMG') {\n    this.img = rect;\n    rect = new Rect(rect.x, rect.y, rect.width, rect.height);\n  }\n  // if rect is an object\n  if (!(rect instanceof Rect)) {\n    rect = new Rect(rect.x || 0, rect.y || 0, rect.w || rect.width, rect.h || rect.height);\n  }\n  return rect;\n};\n\nAtlas.prototype._debug = function() {\n  if (!this.canvas) { return; }\n  var context = this.canvas.getContext('2d');\n  this.index().forEach(function(rect) {\n    context.lineWidth = 1;\n    context.strokeStyle = 'red';\n    context.strokeRect(rect.x, rect.y, rect.w, rect.h);\n  });\n};\n\n},{}]},{},[1])\n(1)\n});;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2RtaWxsZXQvUHJvamVjdHMvZnB0L2ZwdC1vbGQvfi92b3hlbC10ZXh0dXJlL34vYXRsYXNwYWNrL2luZGV4LmpzPzhiMjMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IllBQUEseUJBQWEsMkJBQTJFLDJEQUEyRCxLQUFLLE1BQU0sNEhBQTRILFlBQVksMEJBQTBCLDBCQUEwQixnQkFBZ0IsVUFBVSxVQUFVLDBDQUEwQyw4QkFBd0Isb0JBQW9CLDhDQUE4QyxZQUFZLFlBQVksbUNBQW1DLGlCQUFpQixnQkFBZ0Isc0JBQXNCLG9CQUFvQiwwQ0FBMEMsWUFBWSxXQUFXLFlBQVksU0FBUyxHQUFHO0FBQ2p1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2IsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZ0NBQWdDO0FBQy9ELCtCQUErQiw4Q0FBOEM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSxDQUFDLEdBQUcsRUFBRSxHQUFHO0FBQ1Q7QUFDQSxDQUFDIiwiZmlsZSI6IjM4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiIWZ1bmN0aW9uKGUpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlKW1vZHVsZS5leHBvcnRzPWUoKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZClkZWZpbmUoW10sZSk7ZWxzZXt2YXIgZjtcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P2Y9d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Zj1nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGYmJihmPXNlbGYpLGYuYXRsYXNwYWNrPWUoKX19KGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpfXZhciBmPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChmLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGYsZi5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkoezE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLypcbiAqIGF0bGFzcGFja1xuICogaHR0cHM6Ly9naXRodWIuY29tL3NoYW1hL2F0bGFzcGFja1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNCBLeWxlIFJvYmluc29uIFlvdW5nXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKlxuICogQmFzZWQgb24gTmljayBXZWxjaCdzIGJpbnBhY2s6IGh0dHBzOi8vZ2l0aHViLmNvbS9tYWNrc3Rhbm4vYmlucGFja1xuICovXG5cbmZ1bmN0aW9uIFJlY3QoeCwgeSwgdywgaCkge1xuICB0aGlzLnggPSB4OyB0aGlzLnkgPSB5O1xuICB0aGlzLncgPSB3OyB0aGlzLmggPSBoO1xufVxuXG5SZWN0LnByb3RvdHlwZS5maXRzSW4gPSBmdW5jdGlvbihvdXRlcikge1xuICByZXR1cm4gb3V0ZXIudyA+PSB0aGlzLncgJiYgb3V0ZXIuaCA+PSB0aGlzLmg7XG59O1xuXG5SZWN0LnByb3RvdHlwZS5zYW1lU2l6ZUFzID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgcmV0dXJuIHRoaXMudyA9PT0gb3RoZXIudyAmJiB0aGlzLmggPT09IG90aGVyLmg7XG59O1xuXG5mdW5jdGlvbiBBdGxhcyh4LCB5LCB3LCBoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdGhpcy5jYW52YXMgPSB4O1xuICAgIHggPSB5ID0gMDtcbiAgICB3ID0gdGhpcy5jYW52YXMud2lkdGg7XG4gICAgaCA9IHRoaXMuY2FudmFzLmhlaWdodDtcbiAgfVxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHcgPSB4OyBoID0geTsgeCA9IHkgPSAwO1xuICB9XG4gIHRoaXMubGVmdCA9IHRoaXMucmlnaHQgPSBudWxsO1xuICB0aGlzLnJlY3QgPSBuZXcgUmVjdCh4LCB5LCB3LCBoKTtcbiAgdGhpcy5maWxsZWQgPSBmYWxzZTtcbiAgdGhpcy50aWxlcGFkID0gZmFsc2U7XG4gIHRoaXMuX2NhY2hlID0gW107XG4gIHRoaXMuX3V2Y2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHsgcmV0dXJuIG5ldyBBdGxhcyhhcmd1bWVudHNbMF0pOyB9XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7IHJldHVybiBuZXcgQXRsYXMoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0pOyB9XG4gIHJldHVybiBuZXcgQXRsYXMoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdKTtcbn07XG5tb2R1bGUuZXhwb3J0cy5BdGxhcyA9IEF0bGFzO1xubW9kdWxlLmV4cG9ydHMuUmVjdCA9IFJlY3Q7XG5cbi8vIHBhY2sgaW1hZ2UvcmVjdCB0byB0aGUgYXRsYXNcbkF0bGFzLnByb3RvdHlwZS5wYWNrID0gZnVuY3Rpb24ocmVjdCkge1xuICB0aGlzLl9jYWNoZSA9IFtdO1xuICB0aGlzLl91dmNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmVjdCA9IHRoaXMuX3RvUmVjdChyZWN0KTtcblxuICBpZiAodGhpcy5pbWcgJiYgdGhpcy50aWxlcGFkKSB7XG4gICAgcmVjdCA9IHRoaXMuX3RpbGVwYWQocmVjdCk7XG4gIH1cblxuICBpZiAodGhpcy5sZWZ0ICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuX29udG9DYW52YXModGhpcy5sZWZ0LnBhY2socmVjdCkgfHwgdGhpcy5yaWdodC5wYWNrKHJlY3QpKTtcbiAgfVxuICAvLyBpZiBhdGxhcyBmaWxsZWQgb3Igd29udCBmaXRcbiAgaWYgKHRoaXMuZmlsbGVkIHx8ICFyZWN0LmZpdHNJbih0aGlzLnJlY3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGlmIHRoaXMgYXRsYXMgaGFzIGJlZW4gZmlsbGVkXG4gIGlmIChyZWN0LnNhbWVTaXplQXModGhpcy5yZWN0KSkge1xuICAgIHRoaXMuZmlsbGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcy5fb250b0NhbnZhcyh0aGlzKTtcbiAgfVxuICBpZiAoKHRoaXMucmVjdC53IC0gcmVjdC53KSA+ICh0aGlzLnJlY3QuaCAtIHJlY3QuaCkpIHtcbiAgICB0aGlzLmxlZnQgPSBuZXcgQXRsYXModGhpcy5yZWN0LngsIHRoaXMucmVjdC55LCByZWN0LncsIHRoaXMucmVjdC5oKTtcbiAgICB0aGlzLnJpZ2h0ID0gbmV3IEF0bGFzKHRoaXMucmVjdC54ICsgcmVjdC53LCB0aGlzLnJlY3QueSwgdGhpcy5yZWN0LncgLSByZWN0LncsIHRoaXMucmVjdC5oKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxlZnQgPSBuZXcgQXRsYXModGhpcy5yZWN0LngsIHRoaXMucmVjdC55LCB0aGlzLnJlY3QudywgcmVjdC5oKTtcbiAgICB0aGlzLnJpZ2h0ID0gbmV3IEF0bGFzKHRoaXMucmVjdC54LCB0aGlzLnJlY3QueSArIHJlY3QuaCwgdGhpcy5yZWN0LncsIHRoaXMucmVjdC5oIC0gcmVjdC5oKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fb250b0NhbnZhcyh0aGlzLmxlZnQucGFjayhyZWN0KSk7XG59O1xuXG5BdGxhcy5wcm90b3R5cGUuZXhwYW5kID0gZnVuY3Rpb24ocmVjdCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJlY3QgPSB0aGlzLl90b1JlY3QocmVjdCk7XG5cbiAgaWYgKHRoaXMuaW1nICYmIHRoaXMudGlsZXBhZCkge1xuICAgIHJlY3QgPSB0aGlzLl90aWxlcGFkKHJlY3QpO1xuICB9XG5cbiAgdmFyIGF0bGFzO1xuICBpZiAodGhpcy5yZWN0LncgPCB0aGlzLnJlY3QuaCkge1xuICAgIGF0bGFzID0gbmV3IEF0bGFzKDAsIDAsIHRoaXMucmVjdC53ICsgcmVjdC53LCB0aGlzLnJlY3QuaCk7XG4gICAgYXRsYXMucmlnaHQgPSBuZXcgQXRsYXModGhpcy5yZWN0LncsIDAsIHJlY3QudywgdGhpcy5yZWN0LmgpO1xuICAgIGF0bGFzLmxlZnQgPSB0aGlzO1xuICB9IGVsc2Uge1xuICAgIGF0bGFzID0gbmV3IEF0bGFzKDAsIDAsIHRoaXMucmVjdC53LCB0aGlzLnJlY3QuaCArIHJlY3QuaCk7XG4gICAgYXRsYXMucmlnaHQgPSBuZXcgQXRsYXMoMCwgdGhpcy5yZWN0LmgsIHRoaXMucmVjdC53LCByZWN0LmgpO1xuICAgIGF0bGFzLmxlZnQgPSB0aGlzO1xuICB9XG5cbiAgWydjYW52YXMnLCAnY29udGV4dCcsICdpbWcnXS5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICBpZiAoc2VsZltwXSkge1xuICAgICAgYXRsYXNbcF0gPSBzZWxmW3BdO1xuICAgICAgc2VsZltwXSA9IG51bGw7XG4gICAgfVxuICB9KTtcblxuICAvLyByZXNpemUgY2FudmFzXG4gIGlmIChhdGxhcy5jYW52YXMpIHtcbiAgICBpZiAoIWF0bGFzLmNvbnRleHQpIHtcbiAgICAgIGF0bGFzLmNvbnRleHQgPSBhdGxhcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB9XG4gICAgdmFyIG9sZCA9IGF0bGFzLmNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGF0bGFzLmNhbnZhcy53aWR0aCwgYXRsYXMuY2FudmFzLmhlaWdodCk7XG4gICAgYXRsYXMuY2FudmFzLndpZHRoID0gYXRsYXMucmVjdC53O1xuICAgIGF0bGFzLmNhbnZhcy5oZWlnaHQgPSBhdGxhcy5yZWN0Lmg7XG4gICAgYXRsYXMuY29udGV4dC5wdXRJbWFnZURhdGEob2xkLCAwLCAwKTtcbiAgfVxuXG4gIHJldHVybiAoYXRsYXMucGFjayhyZWN0KSA9PT0gZmFsc2UpID8gYXRsYXMuZXhwYW5kKHJlY3QpIDogYXRsYXM7XG59O1xuXG5BdGxhcy5wcm90b3R5cGUuaW5kZXggPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAoc2VsZi5fY2FjaGUubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBzZWxmLl9jYWNoZTtcbiAgfVxuICAoZnVuY3Rpb24gbG9vcChhdGxhcykge1xuICAgIGlmIChhdGxhcy5sZWZ0ICE9PSBudWxsKSB7XG4gICAgICBsb29wKGF0bGFzLmxlZnQpO1xuICAgICAgbG9vcChhdGxhcy5yaWdodCk7XG4gICAgfSBlbHNlIGlmIChhdGxhcy5yZWN0Lm5hbWUpIHtcbiAgICAgIHNlbGYuX2NhY2hlLnB1c2goYXRsYXMucmVjdCk7XG4gICAgfVxuICB9KHNlbGYpKTtcbiAgcmV0dXJuIHNlbGYuX2NhY2hlO1xufTtcblxuQXRsYXMucHJvdG90eXBlLnV2ID0gZnVuY3Rpb24odywgaCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHcgPSB3IHx8IHNlbGYucmVjdC53O1xuICBoID0gaCB8fCBzZWxmLnJlY3QuaDtcbiAgdmFyIGlzUGFkID0gdGhpcy50aWxlcGFkO1xuICAoZnVuY3Rpb24gbG9vcChhdGxhcykge1xuICAgIGlmIChhdGxhcy5sZWZ0ICE9PSBudWxsKSB7XG4gICAgICBsb29wKGF0bGFzLmxlZnQpO1xuICAgICAgbG9vcChhdGxhcy5yaWdodCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXRsYXMucmVjdC5uYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIHAgPSAoaXNQYWQpID8gYXRsYXMucmVjdC53IC8gNCA6IDA7XG4gICAgICBzZWxmLl91dmNhY2hlW2F0bGFzLnJlY3QubmFtZV0gPSBbXG4gICAgICAgIFthdGxhcy5yZWN0LnggKyBwLCBhdGxhcy5yZWN0LnkgKyBwXSxcbiAgICAgICAgWyhhdGxhcy5yZWN0LnggKyBwKSArIChhdGxhcy5yZWN0LncgLSAocCAqIDIpKSwgYXRsYXMucmVjdC55ICsgcF0sXG4gICAgICAgIFsoYXRsYXMucmVjdC54ICsgcCkgKyAoYXRsYXMucmVjdC53IC0gKHAgKiAyKSksIChhdGxhcy5yZWN0LnkgKyBwKSArIChhdGxhcy5yZWN0LmggLSAocCAqIDIpKV0sXG4gICAgICAgIFsoYXRsYXMucmVjdC54ICsgcCksIChhdGxhcy5yZWN0LnkgKyBwKSArIChhdGxhcy5yZWN0LmggLSAocCAqIDIpKV0sXG4gICAgICBdLm1hcChmdW5jdGlvbih1dikge1xuICAgICAgICBpZiAodXZbMF0gIT09IDApIHtcbiAgICAgICAgICB1dlswXSA9IHV2WzBdIC8gdztcbiAgICAgICAgfVxuICAgICAgICBpZiAodXZbMV0gIT09IDApIHtcbiAgICAgICAgICB1dlsxXSA9IHV2WzFdIC8gaDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXY7XG4gICAgICB9KTtcbiAgICB9XG4gIH0oc2VsZikpO1xuICByZXR1cm4gc2VsZi5fdXZjYWNoZTtcbn07XG5cbkF0bGFzLnByb3RvdHlwZS5qc29uID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAoaW5wdXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykgaW5wdXQgPSBKU09OLnBhcnNlKGlucHV0KTtcbiAgICByZXR1cm4gKGZ1bmN0aW9uIGxvb3Aob2JqKSB7XG4gICAgICBpZiAoIW9iaiB8fCAhb2JqLnJlY3QpIHJldHVybjtcbiAgICAgIHZhciBhdGxhcyA9IG5ldyBBdGxhcyhvYmoucmVjdC54LCBvYmoucmVjdC55LCBvYmoucmVjdC53LCBvYmoucmVjdC5oKTtcbiAgICAgIGlmIChvYmoubGVmdCkgYXRsYXMubGVmdCA9IGxvb3Aob2JqLmxlZnQpO1xuICAgICAgaWYgKG9iai5yaWdodCkgYXRsYXMucmlnaHQgPSBsb29wKG9iai5yaWdodCk7XG4gICAgICByZXR1cm4gYXRsYXM7XG4gICAgfShpbnB1dCkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShmdW5jdGlvbiBsb29wKGF0bGFzKSB7XG4gICAgICB2YXIgb2JqID0ge1xuICAgICAgICBsZWZ0OiBudWxsLCByaWdodDogbnVsbCxcbiAgICAgICAgcmVjdDogYXRsYXMucmVjdCwgZmlsbGVkOiBhdGxhcy5maWxsZWRcbiAgICAgIH07XG4gICAgICBpZiAoYXRsYXMubGVmdCAhPT0gbnVsbCkge1xuICAgICAgICBvYmoubGVmdCA9IGxvb3AoYXRsYXMubGVmdCk7XG4gICAgICAgIG9iai5yaWdodCA9IGxvb3AoYXRsYXMucmlnaHQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9KHNlbGYpLCBudWxsLCAyKTtcbiAgfVxufTtcblxuLy8gUGFkcyB0aGUgaW1hZ2UgYnkgdGlsaW5nIGl0c2VsZiBhcm91bmQgaXRzZWxmXG5BdGxhcy5wcm90b3R5cGUuX3RpbGVwYWQgPSBmdW5jdGlvbihyZWN0KSB7XG4gIHZhciBpbWcgPSB0aGlzLmltZztcbiAgaWYgKCFpbWcpIHJldHVybiByZWN0O1xuXG4gIHZhciBwID0gaW1nLndpZHRoIC8gMjtcblxuICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gIGNhbnZhcy5uYW1lID0gaW1nLm5hbWUgfHwgaW1nLnNyYztcbiAgY2FudmFzLmlkID0gaW1nLmlkIHx8ICcnO1xuICBjYW52YXMud2lkdGggPSBpbWcud2lkdGggKyBpbWcud2lkdGg7XG4gIGNhbnZhcy5oZWlnaHQgPSBpbWcuaGVpZ2h0ICsgaW1nLmhlaWdodDtcbiAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gIHZhciBwYXR0ZXJuID0gY3R4LmNyZWF0ZVBhdHRlcm4oaW1nLCAncmVwZWF0Jyk7XG4gIGN0eC5maWxsU3R5bGUgPSBwYXR0ZXJuO1xuICBjdHgudHJhbnNsYXRlKHAsIHApO1xuICBjdHguZmlsbFJlY3QoLXAsIC1wLCBjYW52YXMud2lkdGggKyBwLCBjYW52YXMuaGVpZ2h0ICsgcCk7XG4gIGN0eC50cmFuc2xhdGUoLXAsIC1wKTtcblxuICB0aGlzLmltZyA9IGNhbnZhcztcblxuICByZXR1cm4gbmV3IFJlY3QocmVjdC54LCByZWN0LnksIHRoaXMuaW1nLndpZHRoLCB0aGlzLmltZy5oZWlnaHQpO1xufTtcblxuLy8gaWYgaGFzIGFuIGltYWdlIGFuZCBjYW52YXMsIGRyYXcgdG8gdGhlIGNhbnZhcyBhcyB3ZSBnb1xuQXRsYXMucHJvdG90eXBlLl9vbnRvQ2FudmFzID0gZnVuY3Rpb24obm9kZSkge1xuICBpZiAobm9kZSAmJiB0aGlzLmltZyAmJiB0aGlzLmNhbnZhcykge1xuICAgIGlmICghdGhpcy5jb250ZXh0KSB7XG4gICAgICB0aGlzLmNvbnRleHQgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRleHQuY2xlYXJSZWN0KG5vZGUucmVjdC54LCBub2RlLnJlY3QueSwgbm9kZS5yZWN0LncsIG5vZGUucmVjdC5oKTtcbiAgICB0aGlzLmNvbnRleHQuZHJhd0ltYWdlKHRoaXMuaW1nLCBub2RlLnJlY3QueCwgbm9kZS5yZWN0LnksIG5vZGUucmVjdC53LCBub2RlLnJlY3QuaCk7XG4gICAgbm9kZS5yZWN0Lm5hbWUgPSB0aGlzLmltZy5pZCB8fCB0aGlzLmltZy5uYW1lIHx8IHRoaXMuaW1nLnNyYyB8fCBudWxsO1xuICB9XG4gIHJldHVybiBub2RlO1xufTtcblxuLy8gbWFrZSBzdXJlIHdlJ3JlIGFsd2F5cyB3b3JraW5nIHdpdGggcmVjdHNcbkF0bGFzLnByb3RvdHlwZS5fdG9SZWN0ID0gZnVuY3Rpb24ocmVjdCkge1xuICAvLyBpZiByZWN0IGlzIGFuIGltYWdlXG4gIGlmIChyZWN0Lm5vZGVOYW1lICYmIHJlY3Qubm9kZU5hbWUgPT09ICdJTUcnKSB7XG4gICAgdGhpcy5pbWcgPSByZWN0O1xuICAgIHJlY3QgPSBuZXcgUmVjdChyZWN0LngsIHJlY3QueSwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuICB9XG4gIC8vIGlmIHJlY3QgaXMgYW4gb2JqZWN0XG4gIGlmICghKHJlY3QgaW5zdGFuY2VvZiBSZWN0KSkge1xuICAgIHJlY3QgPSBuZXcgUmVjdChyZWN0LnggfHwgMCwgcmVjdC55IHx8IDAsIHJlY3QudyB8fCByZWN0LndpZHRoLCByZWN0LmggfHwgcmVjdC5oZWlnaHQpO1xuICB9XG4gIHJldHVybiByZWN0O1xufTtcblxuQXRsYXMucHJvdG90eXBlLl9kZWJ1ZyA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuY2FudmFzKSB7IHJldHVybjsgfVxuICB2YXIgY29udGV4dCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIHRoaXMuaW5kZXgoKS5mb3JFYWNoKGZ1bmN0aW9uKHJlY3QpIHtcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IDE7XG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICdyZWQnO1xuICAgIGNvbnRleHQuc3Ryb2tlUmVjdChyZWN0LngsIHJlY3QueSwgcmVjdC53LCByZWN0LmgpO1xuICB9KTtcbn07XG5cbn0se31dfSx7fSxbMV0pXG4oMSlcbn0pOztcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL2RtaWxsZXQvUHJvamVjdHMvZnB0L2ZwdC1vbGQvfi92b3hlbC10ZXh0dXJlL34vYXRsYXNwYWNrL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxIDJcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 39 */
/***/ function(module, exports) {

	eval("function opaque(image) {\n  var canvas, ctx\n\n  if (image.nodeName.toLowerCase() === 'img') {\n    canvas = document.createElement('canvas')\n    canvas.width = image.width\n    canvas.height = image.height\n    ctx = canvas.getContext('2d')\n    ctx.drawImage(image, 0, 0)\n  } else {\n    canvas = image\n    ctx = canvas.getContext('2d')\n  }\n\n  var imageData = ctx.getImageData(0, 0, canvas.height, canvas.width)\n    , data = imageData.data\n\n  for (var i = 3, l = data.length; i < l; i += 4)\n    if (data[i] !== 255)\n      return false\n\n  return true\n};\n\nmodule.exports = opaque\nmodule.exports.opaque = opaque\nmodule.exports.transparent = function(image) {\n  return !opaque(image)\n};//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2RtaWxsZXQvUHJvamVjdHMvZnB0L2ZwdC1vbGQvfi92b3hlbC10ZXh0dXJlL34vb3BhcXVlL2luZGV4LmpzPzI1YzUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0NBQWtDLE9BQU87QUFDekM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMzkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBvcGFxdWUoaW1hZ2UpIHtcbiAgdmFyIGNhbnZhcywgY3R4XG5cbiAgaWYgKGltYWdlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbWcnKSB7XG4gICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgICBjYW52YXMud2lkdGggPSBpbWFnZS53aWR0aFxuICAgIGNhbnZhcy5oZWlnaHQgPSBpbWFnZS5oZWlnaHRcbiAgICBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDApXG4gIH0gZWxzZSB7XG4gICAgY2FudmFzID0gaW1hZ2VcbiAgICBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuICB9XG5cbiAgdmFyIGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLmhlaWdodCwgY2FudmFzLndpZHRoKVxuICAgICwgZGF0YSA9IGltYWdlRGF0YS5kYXRhXG5cbiAgZm9yICh2YXIgaSA9IDMsIGwgPSBkYXRhLmxlbmd0aDsgaSA8IGw7IGkgKz0gNClcbiAgICBpZiAoZGF0YVtpXSAhPT0gMjU1KVxuICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgcmV0dXJuIHRydWVcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gb3BhcXVlXG5tb2R1bGUuZXhwb3J0cy5vcGFxdWUgPSBvcGFxdWVcbm1vZHVsZS5leHBvcnRzLnRyYW5zcGFyZW50ID0gZnVuY3Rpb24oaW1hZ2UpIHtcbiAgcmV0dXJuICFvcGFxdWUoaW1hZ2UpXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL2RtaWxsZXQvUHJvamVjdHMvZnB0L2ZwdC1vbGQvfi92b3hlbC10ZXh0dXJlL34vb3BhcXVlL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxIDJcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 40 */
/***/ function(module, exports) {

	eval("module.exports = function(game) {\n  var THREE = game.THREE;\n  var colorCache = Object.create(null);\n\n  var ao = function(face, light, dark) {\n    if (arguments.length === 1) {\n      light = face.color;\n      dark = getDark(light);\n    } else if (arguments.length === 2) {\n      light = convertColor(light);\n      dark = getDark(light);\n    } else {\n      light = convertColor(light);\n      dark = convertColor(dark);\n    }\n    face.color = light;\n\n    // TODO: AO should be figured better than this\n    if (face.normal.y === 1)       face.vertexColors = [light, light, light, light];\n    else if (face.normal.y === -1) face.vertexColors = [dark,  dark,  dark,  dark];\n    else if (face.normal.x === 1)  face.vertexColors = [dark,  light, light, dark];\n    else if (face.normal.x === -1) face.vertexColors = [dark,  dark,  light, light];\n    else if (face.normal.z === 1)  face.vertexColors = [dark,  dark,  light, light];\n    else                           face.vertexColors = [dark,  light, light, dark];\n  };\n\n  ao.onGeometry = function(geom, light, dark) {\n    for (var i = 0; i < geom.faces.length; ++i) {\n      ao(geom.faces[i], light, dark);\n    }\n  };\n\n  ao.onChunk = function(chunk, light, dark) {\n    var pos = ('position' in chunk) ? chunk.position : chunk;\n    var mesh = game.voxels.meshes[pos.join('|')];\n    if (mesh) {\n      ao.onGeometry(mesh.geometry, light, dark);\n    }\n  };\n\n  var getDark = function(light) {\n    var hex = light.getHexString();\n    if (colorCache[hex]) return colorCache[hex];\n    var hsl = light.getHSL();\n    var dark = light.clone();\n    dark.setHSL(hsl.h, hsl.s, hsl.l - 0.1);\n    return colorCache[hex] = dark;\n  };\n\n  var convertColor = function(color) {\n    if (color instanceof THREE.Color) return color;\n    if (colorCache[color]) return colorCache[color];\n    return colorCache[color] = new THREE.Color(color);\n  };\n\n  return ao;\n};\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2RtaWxsZXQvUHJvamVjdHMvZnB0L2ZwdC1vbGQvfi92b3hlbC10ZXh0dXJlL34vdm94ZWwtZmFrZWFvL2luZGV4LmpzPzU3MjYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwiZmlsZSI6IjQwLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihnYW1lKSB7XG4gIHZhciBUSFJFRSA9IGdhbWUuVEhSRUU7XG4gIHZhciBjb2xvckNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICB2YXIgYW8gPSBmdW5jdGlvbihmYWNlLCBsaWdodCwgZGFyaykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaWdodCA9IGZhY2UuY29sb3I7XG4gICAgICBkYXJrID0gZ2V0RGFyayhsaWdodCk7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICBsaWdodCA9IGNvbnZlcnRDb2xvcihsaWdodCk7XG4gICAgICBkYXJrID0gZ2V0RGFyayhsaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpZ2h0ID0gY29udmVydENvbG9yKGxpZ2h0KTtcbiAgICAgIGRhcmsgPSBjb252ZXJ0Q29sb3IoZGFyayk7XG4gICAgfVxuICAgIGZhY2UuY29sb3IgPSBsaWdodDtcblxuICAgIC8vIFRPRE86IEFPIHNob3VsZCBiZSBmaWd1cmVkIGJldHRlciB0aGFuIHRoaXNcbiAgICBpZiAoZmFjZS5ub3JtYWwueSA9PT0gMSkgICAgICAgZmFjZS52ZXJ0ZXhDb2xvcnMgPSBbbGlnaHQsIGxpZ2h0LCBsaWdodCwgbGlnaHRdO1xuICAgIGVsc2UgaWYgKGZhY2Uubm9ybWFsLnkgPT09IC0xKSBmYWNlLnZlcnRleENvbG9ycyA9IFtkYXJrLCAgZGFyaywgIGRhcmssICBkYXJrXTtcbiAgICBlbHNlIGlmIChmYWNlLm5vcm1hbC54ID09PSAxKSAgZmFjZS52ZXJ0ZXhDb2xvcnMgPSBbZGFyaywgIGxpZ2h0LCBsaWdodCwgZGFya107XG4gICAgZWxzZSBpZiAoZmFjZS5ub3JtYWwueCA9PT0gLTEpIGZhY2UudmVydGV4Q29sb3JzID0gW2RhcmssICBkYXJrLCAgbGlnaHQsIGxpZ2h0XTtcbiAgICBlbHNlIGlmIChmYWNlLm5vcm1hbC56ID09PSAxKSAgZmFjZS52ZXJ0ZXhDb2xvcnMgPSBbZGFyaywgIGRhcmssICBsaWdodCwgbGlnaHRdO1xuICAgIGVsc2UgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWNlLnZlcnRleENvbG9ycyA9IFtkYXJrLCAgbGlnaHQsIGxpZ2h0LCBkYXJrXTtcbiAgfTtcblxuICBhby5vbkdlb21ldHJ5ID0gZnVuY3Rpb24oZ2VvbSwgbGlnaHQsIGRhcmspIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdlb20uZmFjZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGFvKGdlb20uZmFjZXNbaV0sIGxpZ2h0LCBkYXJrKTtcbiAgICB9XG4gIH07XG5cbiAgYW8ub25DaHVuayA9IGZ1bmN0aW9uKGNodW5rLCBsaWdodCwgZGFyaykge1xuICAgIHZhciBwb3MgPSAoJ3Bvc2l0aW9uJyBpbiBjaHVuaykgPyBjaHVuay5wb3NpdGlvbiA6IGNodW5rO1xuICAgIHZhciBtZXNoID0gZ2FtZS52b3hlbHMubWVzaGVzW3Bvcy5qb2luKCd8JyldO1xuICAgIGlmIChtZXNoKSB7XG4gICAgICBhby5vbkdlb21ldHJ5KG1lc2guZ2VvbWV0cnksIGxpZ2h0LCBkYXJrKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldERhcmsgPSBmdW5jdGlvbihsaWdodCkge1xuICAgIHZhciBoZXggPSBsaWdodC5nZXRIZXhTdHJpbmcoKTtcbiAgICBpZiAoY29sb3JDYWNoZVtoZXhdKSByZXR1cm4gY29sb3JDYWNoZVtoZXhdO1xuICAgIHZhciBoc2wgPSBsaWdodC5nZXRIU0woKTtcbiAgICB2YXIgZGFyayA9IGxpZ2h0LmNsb25lKCk7XG4gICAgZGFyay5zZXRIU0woaHNsLmgsIGhzbC5zLCBoc2wubCAtIDAuMSk7XG4gICAgcmV0dXJuIGNvbG9yQ2FjaGVbaGV4XSA9IGRhcms7XG4gIH07XG5cbiAgdmFyIGNvbnZlcnRDb2xvciA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgaWYgKGNvbG9yIGluc3RhbmNlb2YgVEhSRUUuQ29sb3IpIHJldHVybiBjb2xvcjtcbiAgICBpZiAoY29sb3JDYWNoZVtjb2xvcl0pIHJldHVybiBjb2xvckNhY2hlW2NvbG9yXTtcbiAgICByZXR1cm4gY29sb3JDYWNoZVtjb2xvcl0gPSBuZXcgVEhSRUUuQ29sb3IoY29sb3IpO1xuICB9O1xuXG4gIHJldHVybiBhbztcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9kbWlsbGV0L1Byb2plY3RzL2ZwdC9mcHQtb2xkL34vdm94ZWwtdGV4dHVyZS9+L3ZveGVsLWZha2Vhby9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDQwXG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMSAyXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _three = __webpack_require__(32);\n\nvar _three2 = _interopRequireDefault(_three);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar MeshComponent = function () {\n\t_createClass(MeshComponent, null, [{\n\t\tkey: 'create',\n\t\tvalue: function create() {\n\t\t\treturn new MeshComponent();\n\t\t}\n\t}]);\n\n\tfunction MeshComponent() {\n\t\t_classCallCheck(this, MeshComponent);\n\n\t\tvar geometry = new _three2.default.CubeGeometry(1, 1, 1);\n\t\tvar material = new _three2.default.MeshLambertMaterial({ color: 0x0000ff, wireframe: false });\n\t\tthis.three = new _three2.default.Mesh(geometry, material);\n\t\tthis.three.castShadow = this.three.receiveShadow = true;\n\t\tthis.three.useQuaternion = true;\n\t}\n\n\treturn MeshComponent;\n}();\n\nexports.default = MeshComponent;//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi92aWV3L01lc2hDb21wb25lbnQuanM/MTVjYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUNBOzs7Ozs7OztJQUVNLGE7Y0FBQSxhOzsyQkFFVztBQUNmLFVBQU8sSUFBSSxhQUFKLEVBQVA7QUFDQTs7O0FBRUQsVUFOSyxhQU1MLEdBQWM7QUFBQSx3QkFOVCxhQU1TOztBQUNiLE1BQUksV0FBVyxJQUFJLGdCQUFNLFlBQVYsQ0FBdUIsQ0FBdkIsRUFBMEIsQ0FBMUIsRUFBNkIsQ0FBN0IsQ0FBZjtBQUNBLE1BQUksV0FBVyxJQUFJLGdCQUFNLG1CQUFWLENBQThCLEVBQUMsT0FBTyxRQUFSLEVBQWtCLFdBQVcsS0FBN0IsRUFBOUIsQ0FBZjtBQUNBLE9BQUssS0FBTCxHQUFhLElBQUksZ0JBQU0sSUFBVixDQUFlLFFBQWYsRUFBeUIsUUFBekIsQ0FBYjtBQUNBLE9BQUssS0FBTCxDQUFXLFVBQVgsR0FBd0IsS0FBSyxLQUFMLENBQVcsYUFBWCxHQUEyQixJQUFuRDtBQUNBLE9BQUssS0FBTCxDQUFXLGFBQVgsR0FBMkIsSUFBM0I7QUFDQTs7UUFaSSxhOzs7a0JBZ0JTLGEiLCJmaWxlIjoiNDEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCBUSFJFRSBmcm9tICd0aHJlZSc7XG5cbmNsYXNzIE1lc2hDb21wb25lbnQge1xuXG5cdHN0YXRpYyBjcmVhdGUoKSB7XG5cdFx0cmV0dXJuIG5ldyBNZXNoQ29tcG9uZW50KCk7XG5cdH1cblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRsZXQgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQ3ViZUdlb21ldHJ5KDEsIDEsIDEpO1xuXHRcdGxldCBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsKHtjb2xvcjogMHgwMDAwZmYsIHdpcmVmcmFtZTogZmFsc2V9KTtcblx0XHR0aGlzLnRocmVlID0gbmV3IFRIUkVFLk1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcblx0XHR0aGlzLnRocmVlLmNhc3RTaGFkb3cgPSB0aGlzLnRocmVlLnJlY2VpdmVTaGFkb3cgPSB0cnVlO1xuXHRcdHRoaXMudGhyZWUudXNlUXVhdGVybmlvbiA9IHRydWU7XG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBNZXNoQ29tcG9uZW50O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi92aWV3L01lc2hDb21wb25lbnQuanNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _Level = __webpack_require__(10);\n\nvar _Level2 = _interopRequireDefault(_Level);\n\nvar _voxel = __webpack_require__(14);\n\nvar _voxel2 = _interopRequireDefault(_voxel);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar TestLevel1 = _Level2.default.createClass({\n\tgenerateVoxel: _voxel2.default.generator['Hill']\n});\n\nTestLevel1.create = function () {\n\treturn new TestLevel1();\n};\n\nexports.default = TestLevel1;//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbGV2ZWxzL1Rlc3RMZXZlbDEuanM/ZjA5MiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQSxJQUFJLGFBQWEsZ0JBQU0sV0FBTixDQUFrQjtBQUNsQyxnQkFBZSxnQkFBTSxTQUFOLENBQWdCLE1BQWhCO0FBRG1CLENBQWxCLENBQWpCOztBQUlBLFdBQVcsTUFBWCxHQUFvQixZQUFXO0FBQzlCLFFBQU8sSUFBSSxVQUFKLEVBQVA7QUFDQSxDQUZEOztrQkFJZSxVIiwiZmlsZSI6IjQyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgTGV2ZWwgZnJvbSAnLi9MZXZlbCc7XG5pbXBvcnQgdm94ZWwgZnJvbSAndm94ZWwnO1xuXG5sZXQgVGVzdExldmVsMSA9IExldmVsLmNyZWF0ZUNsYXNzKHtcblx0Z2VuZXJhdGVWb3hlbDogdm94ZWwuZ2VuZXJhdG9yWydIaWxsJ11cbn0pO1xuXG5UZXN0TGV2ZWwxLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gbmV3IFRlc3RMZXZlbDEoKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFRlc3RMZXZlbDE7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9sZXZlbHMvVGVzdExldmVsMS5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _EventObject = __webpack_require__(44);\n\nvar _EventObject2 = _interopRequireDefault(_EventObject);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ClientConnection = function () {\n\t_createClass(ClientConnection, null, [{\n\t\tkey: 'create',\n\t\tvalue: function create() {\n\t\t\treturn new ClientConnection();\n\t\t}\n\t}]);\n\n\tfunction ClientConnection() {\n\t\t_classCallCheck(this, ClientConnection);\n\n\t\tthis._eo = _EventObject2.default.create();\n\t\tthis._queue = [];\n\t\tthis.connected = false;\n\t\tthis._ws = new WebSocket('ws://localhost:3001/');\n\n\t\tthis._ws.onopen = function () {\n\t\t\tthis.connected = true;\n\t\t\tthis._sendNext();\n\t\t}.bind(this);\n\n\t\tthis._ws.onmessage = function (raw) {\n\t\t\tvar msg = JSON.parse(raw.data);\n\t\t\tthis._handleMessage(msg);\n\t\t}.bind(this);\n\t}\n\n\t_createClass(ClientConnection, [{\n\t\tkey: 'send',\n\t\tvalue: function send(type, data) {\n\t\t\tthis._queue.push({\n\t\t\t\ttype: type,\n\t\t\t\tdata: data\n\t\t\t});\n\t\t\tthis._sendNext();\n\t\t}\n\t}, {\n\t\tkey: 'onMessage',\n\t\tvalue: function onMessage(type, callback) {\n\t\t\treturn this._eo.on('message:' + type, callback);\n\t\t}\n\t}, {\n\t\tkey: '_sendNext',\n\t\tvalue: function _sendNext() {\n\t\t\tif (!this.connected) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar msg = this._queue.shift();\n\t\t\tif (!msg) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._ws.send(JSON.stringify(msg));\n\t\t\tthis._sendNext();\n\t\t}\n\t}, {\n\t\tkey: '_handleMessage',\n\t\tvalue: function _handleMessage(msg) {\n\t\t\tthis._eo.triggerEvent('message:' + msg.type, msg.data);\n\t\t}\n\t}]);\n\n\treturn ClientConnection;\n}();\n\nexports.default = ClientConnection;//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9DbGllbnRDb25uZWN0aW9uLmpzPzY5YzEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFDQTs7Ozs7Ozs7SUFFTSxnQjtjQUFBLGdCOzsyQkFFVztBQUNmLFVBQU8sSUFBSSxnQkFBSixFQUFQO0FBQ0E7OztBQUVELFVBTkssZ0JBTUwsR0FBYztBQUFBLHdCQU5ULGdCQU1TOztBQUNiLE9BQUssR0FBTCxHQUFXLHNCQUFZLE1BQVosRUFBWDtBQUNBLE9BQUssTUFBTCxHQUFjLEVBQWQ7QUFDQSxPQUFLLFNBQUwsR0FBaUIsS0FBakI7QUFDQSxPQUFLLEdBQUwsR0FBVyxJQUFJLFNBQUosQ0FBYyxzQkFBZCxDQUFYOztBQUVBLE9BQUssR0FBTCxDQUFTLE1BQVQsR0FBa0IsWUFBVztBQUM1QixRQUFLLFNBQUwsR0FBaUIsSUFBakI7QUFDQSxRQUFLLFNBQUw7QUFDQSxHQUhpQixDQUdoQixJQUhnQixDQUdYLElBSFcsQ0FBbEI7O0FBS0EsT0FBSyxHQUFMLENBQVMsU0FBVCxHQUFxQixVQUFTLEdBQVQsRUFBYztBQUNsQyxPQUFJLE1BQU0sS0FBSyxLQUFMLENBQVcsSUFBSSxJQUFmLENBQVY7QUFDQSxRQUFLLGNBQUwsQ0FBb0IsR0FBcEI7QUFDQSxHQUhvQixDQUduQixJQUhtQixDQUdkLElBSGMsQ0FBckI7QUFJQTs7Y0FyQkksZ0I7O3VCQXVCQSxJLEVBQU0sSSxFQUFNO0FBQ2hCLFFBQUssTUFBTCxDQUFZLElBQVosQ0FBaUI7QUFDaEIsVUFBTSxJQURVO0FBRWhCLFVBQU07QUFGVSxJQUFqQjtBQUlBLFFBQUssU0FBTDtBQUNBOzs7NEJBRVMsSSxFQUFNLFEsRUFBVTtBQUN6QixVQUFPLEtBQUssR0FBTCxDQUFTLEVBQVQsQ0FBWSxhQUFhLElBQXpCLEVBQStCLFFBQS9CLENBQVA7QUFDQTs7OzhCQUVXO0FBQ1gsT0FBSSxDQUFDLEtBQUssU0FBVixFQUFxQjtBQUNwQjtBQUNBO0FBQ0QsT0FBSSxNQUFNLEtBQUssTUFBTCxDQUFZLEtBQVosRUFBVjtBQUNBLE9BQUksQ0FBQyxHQUFMLEVBQVU7QUFDVDtBQUNBO0FBQ0QsUUFBSyxHQUFMLENBQVMsSUFBVCxDQUFjLEtBQUssU0FBTCxDQUFlLEdBQWYsQ0FBZDtBQUNBLFFBQUssU0FBTDtBQUNBOzs7aUNBRWMsRyxFQUFLO0FBQ25CLFFBQUssR0FBTCxDQUFTLFlBQVQsQ0FBc0IsYUFBYSxJQUFJLElBQXZDLEVBQTZDLElBQUksSUFBakQ7QUFDQTs7O1FBakRJLGdCOzs7a0JBcURTLGdCIiwiZmlsZSI6IjQzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgRXZlbnRPYmplY3QgZnJvbSAnLi4vc2hhcmVkL0V2ZW50T2JqZWN0JztcblxuY2xhc3MgQ2xpZW50Q29ubmVjdGlvbiB7XG5cblx0c3RhdGljIGNyZWF0ZSgpIHtcblx0XHRyZXR1cm4gbmV3IENsaWVudENvbm5lY3Rpb24oKTtcblx0fVxuXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHRoaXMuX2VvID0gRXZlbnRPYmplY3QuY3JlYXRlKCk7XG5cdFx0dGhpcy5fcXVldWUgPSBbXTtcblx0XHR0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX3dzID0gbmV3IFdlYlNvY2tldCgnd3M6Ly9sb2NhbGhvc3Q6MzAwMS8nKTtcblxuXHRcdHRoaXMuX3dzLm9ub3BlbiA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5jb25uZWN0ZWQgPSB0cnVlO1xuXHRcdFx0dGhpcy5fc2VuZE5leHQoKTtcblx0XHR9LmJpbmQodGhpcyk7XG5cblx0XHR0aGlzLl93cy5vbm1lc3NhZ2UgPSBmdW5jdGlvbihyYXcpIHtcblx0XHRcdGxldCBtc2cgPSBKU09OLnBhcnNlKHJhdy5kYXRhKTtcblx0XHRcdHRoaXMuX2hhbmRsZU1lc3NhZ2UobXNnKTtcblx0XHR9LmJpbmQodGhpcyk7XG5cdH1cblxuXHRzZW5kKHR5cGUsIGRhdGEpIHtcblx0XHR0aGlzLl9xdWV1ZS5wdXNoKHtcblx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRkYXRhOiBkYXRhXG5cdFx0fSk7XG5cdFx0dGhpcy5fc2VuZE5leHQoKTtcblx0fVxuXG5cdG9uTWVzc2FnZSh0eXBlLCBjYWxsYmFjaykge1xuXHRcdHJldHVybiB0aGlzLl9lby5vbignbWVzc2FnZTonICsgdHlwZSwgY2FsbGJhY2spO1xuXHR9XG5cblx0X3NlbmROZXh0KCkge1xuXHRcdGlmICghdGhpcy5jb25uZWN0ZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0bGV0IG1zZyA9IHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG5cdFx0aWYgKCFtc2cpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5fd3Muc2VuZChKU09OLnN0cmluZ2lmeShtc2cpKTtcblx0XHR0aGlzLl9zZW5kTmV4dCgpO1xuXHR9XG5cblx0X2hhbmRsZU1lc3NhZ2UobXNnKSB7XG5cdFx0dGhpcy5fZW8udHJpZ2dlckV2ZW50KCdtZXNzYWdlOicgKyBtc2cudHlwZSwgbXNnLmRhdGEpO1xuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2xpZW50Q29ubmVjdGlvbjtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vQ2xpZW50Q29ubmVjdGlvbi5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 44 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar EventObject = function () {\n\t_createClass(EventObject, null, [{\n\t\tkey: \"create\",\n\t\tvalue: function create() {\n\t\t\treturn new EventObject();\n\t\t}\n\t}]);\n\n\tfunction EventObject() {\n\t\t_classCallCheck(this, EventObject);\n\n\t\tthis._handlers = [];\n\t}\n\n\t_createClass(EventObject, [{\n\t\tkey: \"on\",\n\t\tvalue: function on(type, callback) {\n\t\t\tvar handler = Handler.create(this, callback);\n\t\t\tthis._getHandlers(type).push(handler);\n\t\t\treturn handler;\n\t\t}\n\t}, {\n\t\tkey: \"triggerEvent\",\n\t\tvalue: function triggerEvent(type) {\n\t\t\tfor (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t\t\t\targs[_key - 1] = arguments[_key];\n\t\t\t}\n\n\t\t\tvar handlers = this._getHandlers(type);\n\t\t\thandlers.forEach(function (handler) {\n\t\t\t\thandler.trigger(args);\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: \"_getHandlers\",\n\t\tvalue: function _getHandlers(type) {\n\t\t\tif (!this._handlers[type]) {\n\t\t\t\tthis._handlers[type] = [];\n\t\t\t}\n\t\t\treturn this._handlers[type];\n\t\t}\n\t}]);\n\n\treturn EventObject;\n}();\n\nvar Handler = function () {\n\t_createClass(Handler, null, [{\n\t\tkey: \"create\",\n\t\tvalue: function create(target, callback) {\n\t\t\treturn new Handler(target, callback);\n\t\t}\n\t}]);\n\n\tfunction Handler(target, callback) {\n\t\t_classCallCheck(this, Handler);\n\n\t\tthis.target = target;\n\t\tthis.callback = callback;\n\t}\n\n\t_createClass(Handler, [{\n\t\tkey: \"trigger\",\n\t\tvalue: function trigger(args) {\n\t\t\tthis.callback.apply(this.target, args);\n\t\t}\n\t}]);\n\n\treturn Handler;\n}();\n\nexports.default = EventObject;//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc2hhcmVkL0V2ZW50T2JqZWN0LmpzPzkyNDQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztJQUNNLFc7Y0FBQSxXOzsyQkFFVztBQUNmLFVBQU8sSUFBSSxXQUFKLEVBQVA7QUFDQTs7O0FBRUQsVUFOSyxXQU1MLEdBQWM7QUFBQSx3QkFOVCxXQU1TOztBQUNiLE9BQUssU0FBTCxHQUFpQixFQUFqQjtBQUNBOztjQVJJLFc7O3FCQVVGLEksRUFBTSxRLEVBQVU7QUFDbEIsT0FBSSxVQUFVLFFBQVEsTUFBUixDQUFlLElBQWYsRUFBcUIsUUFBckIsQ0FBZDtBQUNBLFFBQUssWUFBTCxDQUFrQixJQUFsQixFQUF3QixJQUF4QixDQUE2QixPQUE3QjtBQUNBLFVBQU8sT0FBUDtBQUNBOzs7K0JBRVksSSxFQUFlO0FBQUEscUNBQU4sSUFBTTtBQUFOLFFBQU07QUFBQTs7QUFDM0IsT0FBSSxXQUFXLEtBQUssWUFBTCxDQUFrQixJQUFsQixDQUFmO0FBQ0EsWUFBUyxPQUFULENBQWlCLFVBQVMsT0FBVCxFQUFrQjtBQUNsQyxZQUFRLE9BQVIsQ0FBZ0IsSUFBaEI7QUFDQSxJQUZEO0FBR0E7OzsrQkFFWSxJLEVBQU07QUFDbEIsT0FBSSxDQUFDLEtBQUssU0FBTCxDQUFlLElBQWYsQ0FBTCxFQUEyQjtBQUMxQixTQUFLLFNBQUwsQ0FBZSxJQUFmLElBQXVCLEVBQXZCO0FBQ0E7QUFDRCxVQUFPLEtBQUssU0FBTCxDQUFlLElBQWYsQ0FBUDtBQUNBOzs7UUE1QkksVzs7O0lBZ0NBLE87Y0FBQSxPOzt5QkFFUyxNLEVBQVEsUSxFQUFVO0FBQy9CLFVBQU8sSUFBSSxPQUFKLENBQVksTUFBWixFQUFvQixRQUFwQixDQUFQO0FBQ0E7OztBQUVELFVBTkssT0FNTCxDQUFZLE1BQVosRUFBb0IsUUFBcEIsRUFBOEI7QUFBQSx3QkFOekIsT0FNeUI7O0FBQzdCLE9BQUssTUFBTCxHQUFjLE1BQWQ7QUFDQSxPQUFLLFFBQUwsR0FBZ0IsUUFBaEI7QUFDQTs7Y0FUSSxPOzswQkFXRyxJLEVBQU07QUFDYixRQUFLLFFBQUwsQ0FBYyxLQUFkLENBQW9CLEtBQUssTUFBekIsRUFBaUMsSUFBakM7QUFDQTs7O1FBYkksTzs7O2tCQWtCUyxXIiwiZmlsZSI6IjQ0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5jbGFzcyBFdmVudE9iamVjdCB7XG5cblx0c3RhdGljIGNyZWF0ZSgpIHtcblx0XHRyZXR1cm4gbmV3IEV2ZW50T2JqZWN0KCk7XG5cdH1cblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLl9oYW5kbGVycyA9IFtdO1xuXHR9XG5cblx0b24odHlwZSwgY2FsbGJhY2spIHtcblx0XHRsZXQgaGFuZGxlciA9IEhhbmRsZXIuY3JlYXRlKHRoaXMsIGNhbGxiYWNrKTtcblx0XHR0aGlzLl9nZXRIYW5kbGVycyh0eXBlKS5wdXNoKGhhbmRsZXIpO1xuXHRcdHJldHVybiBoYW5kbGVyO1xuXHR9XG5cblx0dHJpZ2dlckV2ZW50KHR5cGUsIC4uLmFyZ3MpIHtcblx0XHRsZXQgaGFuZGxlcnMgPSB0aGlzLl9nZXRIYW5kbGVycyh0eXBlKTtcblx0XHRoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZXIpIHtcblx0XHRcdGhhbmRsZXIudHJpZ2dlcihhcmdzKTtcblx0XHR9KTtcblx0fVxuXG5cdF9nZXRIYW5kbGVycyh0eXBlKSB7XG5cdFx0aWYgKCF0aGlzLl9oYW5kbGVyc1t0eXBlXSkge1xuXHRcdFx0dGhpcy5faGFuZGxlcnNbdHlwZV0gPSBbXTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2hhbmRsZXJzW3R5cGVdO1xuXHR9XG5cbn1cblxuY2xhc3MgSGFuZGxlciB7XG5cblx0c3RhdGljIGNyZWF0ZSh0YXJnZXQsIGNhbGxiYWNrKSB7XG5cdFx0cmV0dXJuIG5ldyBIYW5kbGVyKHRhcmdldCwgY2FsbGJhY2spO1xuXHR9XG5cblx0Y29uc3RydWN0b3IodGFyZ2V0LCBjYWxsYmFjaykge1xuXHRcdHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuXHRcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcblx0fVxuXG5cdHRyaWdnZXIoYXJncykge1xuXHRcdHRoaXMuY2FsbGJhY2suYXBwbHkodGhpcy50YXJnZXQsIGFyZ3MpO1xuXHR9XG5cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBFdmVudE9iamVjdDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9zaGFyZWQvRXZlbnRPYmplY3QuanNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _ServerSession = __webpack_require__(46);\n\nvar _ServerSession2 = _interopRequireDefault(_ServerSession);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ClientSession = function () {\n\t_createClass(ClientSession, null, [{\n\t\tkey: 'create',\n\t\tvalue: function create(clientConnection) {\n\t\t\treturn new ClientSession(clientConnection);\n\t\t}\n\t}]);\n\n\tfunction ClientSession(clientConnection) {\n\t\t_classCallCheck(this, ClientSession);\n\n\t\tthis.connection = clientConnection;\n\n\t\tthis.authenticated = false;\n\t\tthis.sessionId = null;\n\t\tthis.sessionToken = null;\n\n\t\tthis.connection.onMessage(_ServerSession2.default.SET_SESSION, function (sessionInfo) {\n\t\t\tthis.sessionId = sessionInfo.id;\n\t\t\tthis.sessionToken = sessionInfo.token;\n\t\t\tthis.authenticated = true;\n\t\t\tlocalStorage.setItem(ClientSession.STORAGE_KEY, JSON.stringify({\n\t\t\t\tid: this.sessionId,\n\t\t\t\ttoken: this.sessionToken\n\t\t\t}));\n\t\t\tconsole.log('session established:', this.sessionId);\n\t\t}.bind(this));\n\n\t\tthis.connection.onMessage(_ServerSession2.default.SESSION_REFUSED, function () {\n\t\t\tthis.register();\n\t\t}.bind(this));\n\n\t\tvar connectionInfo = localStorage.getItem(ClientSession.STORAGE_KEY);\n\t\tif (connectionInfo) {\n\t\t\tconnectionInfo = JSON.parse(connectionInfo);\n\t\t\tthis.sessionId = connectionInfo.id;\n\t\t\tthis.sessionToken = connectionInfo.token;\n\t\t}\n\n\t\tif (this.sessionId || this.sessionId === 0) {\n\t\t\tthis.authenticate();\n\t\t} else {\n\t\t\tthis.register();\n\t\t}\n\t}\n\n\t_createClass(ClientSession, [{\n\t\tkey: 'authenticate',\n\t\tvalue: function authenticate() {\n\t\t\tthis.connection.send(_ServerSession2.default.SET_SESSION, {\n\t\t\t\tid: this.sessionId,\n\t\t\t\ttoken: this.sessionToken\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: 'register',\n\t\tvalue: function register() {\n\t\t\tthis.connection.send(_ServerSession2.default.GET_SESSION);\n\t\t}\n\t}]);\n\n\treturn ClientSession;\n}();\n\nexports.default = ClientSession;\n\n\nClientSession.STORAGE_KEY = 'fpt-session';//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9DbGllbnRTZXNzaW9uLmpzPzM5YTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFDQTs7Ozs7Ozs7SUFFcUIsYTtjQUFBLGE7O3lCQUVOLGdCLEVBQWtCO0FBQy9CLFVBQU8sSUFBSSxhQUFKLENBQWtCLGdCQUFsQixDQUFQO0FBQ0E7OztBQUVELFVBTm9CLGFBTXBCLENBQVksZ0JBQVosRUFBOEI7QUFBQSx3QkFOVixhQU1VOztBQUM3QixPQUFLLFVBQUwsR0FBa0IsZ0JBQWxCOztBQUVBLE9BQUssYUFBTCxHQUFxQixLQUFyQjtBQUNBLE9BQUssU0FBTCxHQUFpQixJQUFqQjtBQUNBLE9BQUssWUFBTCxHQUFvQixJQUFwQjs7QUFFQSxPQUFLLFVBQUwsQ0FBZ0IsU0FBaEIsQ0FDQyx3QkFBYyxXQURmLEVBRUMsVUFBUyxXQUFULEVBQXNCO0FBQ3JCLFFBQUssU0FBTCxHQUFpQixZQUFZLEVBQTdCO0FBQ0EsUUFBSyxZQUFMLEdBQW9CLFlBQVksS0FBaEM7QUFDQSxRQUFLLGFBQUwsR0FBcUIsSUFBckI7QUFDQSxnQkFBYSxPQUFiLENBQXFCLGNBQWMsV0FBbkMsRUFBZ0QsS0FBSyxTQUFMLENBQWU7QUFDOUQsUUFBSSxLQUFLLFNBRHFEO0FBRTlELFdBQU8sS0FBSztBQUZrRCxJQUFmLENBQWhEO0FBSUEsV0FBUSxHQUFSLENBQVksc0JBQVosRUFBb0MsS0FBSyxTQUF6QztBQUNBLEdBVEQsQ0FTRSxJQVRGLENBU08sSUFUUCxDQUZEOztBQWNBLE9BQUssVUFBTCxDQUFnQixTQUFoQixDQUNDLHdCQUFjLGVBRGYsRUFFQyxZQUFXO0FBQ1YsUUFBSyxRQUFMO0FBQ0EsR0FGRCxDQUVFLElBRkYsQ0FFTyxJQUZQLENBRkQ7O0FBT0EsTUFBSSxpQkFBaUIsYUFBYSxPQUFiLENBQXFCLGNBQWMsV0FBbkMsQ0FBckI7QUFDQSxNQUFJLGNBQUosRUFBb0I7QUFDbkIsb0JBQWlCLEtBQUssS0FBTCxDQUFXLGNBQVgsQ0FBakI7QUFDQSxRQUFLLFNBQUwsR0FBaUIsZUFBZSxFQUFoQztBQUNBLFFBQUssWUFBTCxHQUFvQixlQUFlLEtBQW5DO0FBQ0E7O0FBRUQsTUFBSSxLQUFLLFNBQUwsSUFBa0IsS0FBSyxTQUFMLEtBQW1CLENBQXpDLEVBQTRDO0FBQzNDLFFBQUssWUFBTDtBQUNBLEdBRkQsTUFFTztBQUNOLFFBQUssUUFBTDtBQUNBO0FBQ0Q7O2NBOUNtQixhOztpQ0FnREw7QUFDZCxRQUFLLFVBQUwsQ0FBZ0IsSUFBaEIsQ0FDQyx3QkFBYyxXQURmLEVBRUM7QUFDQyxRQUFJLEtBQUssU0FEVjtBQUVDLFdBQU8sS0FBSztBQUZiLElBRkQ7QUFPQTs7OzZCQUVVO0FBQ1YsUUFBSyxVQUFMLENBQWdCLElBQWhCLENBQXFCLHdCQUFjLFdBQW5DO0FBQ0E7OztRQTVEbUIsYTs7O2tCQUFBLGE7OztBQWdFckIsY0FBYyxXQUFkLEdBQTRCLGFBQTVCIiwiZmlsZSI6IjQ1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgU2VydmVyU2Vzc2lvbiBmcm9tICcuLi9zZXJ2ZXIvU2VydmVyU2Vzc2lvbic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENsaWVudFNlc3Npb24ge1xuXHRcblx0c3RhdGljIGNyZWF0ZShjbGllbnRDb25uZWN0aW9uKSB7XG5cdFx0cmV0dXJuIG5ldyBDbGllbnRTZXNzaW9uKGNsaWVudENvbm5lY3Rpb24pO1xuXHR9XG5cblx0Y29uc3RydWN0b3IoY2xpZW50Q29ubmVjdGlvbikge1xuXHRcdHRoaXMuY29ubmVjdGlvbiA9IGNsaWVudENvbm5lY3Rpb247XG5cblx0XHR0aGlzLmF1dGhlbnRpY2F0ZWQgPSBmYWxzZTtcblx0XHR0aGlzLnNlc3Npb25JZCA9IG51bGw7XG5cdFx0dGhpcy5zZXNzaW9uVG9rZW4gPSBudWxsO1xuXG5cdFx0dGhpcy5jb25uZWN0aW9uLm9uTWVzc2FnZShcblx0XHRcdFNlcnZlclNlc3Npb24uU0VUX1NFU1NJT04sXG5cdFx0XHRmdW5jdGlvbihzZXNzaW9uSW5mbykge1xuXHRcdFx0XHR0aGlzLnNlc3Npb25JZCA9IHNlc3Npb25JbmZvLmlkO1xuXHRcdFx0XHR0aGlzLnNlc3Npb25Ub2tlbiA9IHNlc3Npb25JbmZvLnRva2VuO1xuXHRcdFx0XHR0aGlzLmF1dGhlbnRpY2F0ZWQgPSB0cnVlO1xuXHRcdFx0XHRsb2NhbFN0b3JhZ2Uuc2V0SXRlbShDbGllbnRTZXNzaW9uLlNUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeSh7XG5cdFx0XHRcdFx0aWQ6IHRoaXMuc2Vzc2lvbklkLFxuXHRcdFx0XHRcdHRva2VuOiB0aGlzLnNlc3Npb25Ub2tlblxuXHRcdFx0XHR9KSk7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdzZXNzaW9uIGVzdGFibGlzaGVkOicsIHRoaXMuc2Vzc2lvbklkKTtcblx0XHRcdH0uYmluZCh0aGlzKVxuXHRcdCk7XG5cblx0XHR0aGlzLmNvbm5lY3Rpb24ub25NZXNzYWdlKFxuXHRcdFx0U2VydmVyU2Vzc2lvbi5TRVNTSU9OX1JFRlVTRUQsXG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5yZWdpc3RlcigpO1xuXHRcdFx0fS5iaW5kKHRoaXMpXG5cdFx0KTtcblxuXHRcdGxldCBjb25uZWN0aW9uSW5mbyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKENsaWVudFNlc3Npb24uU1RPUkFHRV9LRVkpO1xuXHRcdGlmIChjb25uZWN0aW9uSW5mbykge1xuXHRcdFx0Y29ubmVjdGlvbkluZm8gPSBKU09OLnBhcnNlKGNvbm5lY3Rpb25JbmZvKTtcblx0XHRcdHRoaXMuc2Vzc2lvbklkID0gY29ubmVjdGlvbkluZm8uaWQ7XG5cdFx0XHR0aGlzLnNlc3Npb25Ub2tlbiA9IGNvbm5lY3Rpb25JbmZvLnRva2VuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLnNlc3Npb25JZCB8fCB0aGlzLnNlc3Npb25JZCA9PT0gMCkge1xuXHRcdFx0dGhpcy5hdXRoZW50aWNhdGUoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5yZWdpc3RlcigpO1xuXHRcdH1cblx0fVxuXG5cdGF1dGhlbnRpY2F0ZSgpIHtcblx0XHR0aGlzLmNvbm5lY3Rpb24uc2VuZChcblx0XHRcdFNlcnZlclNlc3Npb24uU0VUX1NFU1NJT04sXG5cdFx0XHR7XG5cdFx0XHRcdGlkOiB0aGlzLnNlc3Npb25JZCxcblx0XHRcdFx0dG9rZW46IHRoaXMuc2Vzc2lvblRva2VuXG5cdFx0XHR9XG5cdFx0KTtcblx0fVxuXG5cdHJlZ2lzdGVyKCkge1xuXHRcdHRoaXMuY29ubmVjdGlvbi5zZW5kKFNlcnZlclNlc3Npb24uR0VUX1NFU1NJT04pO1xuXHR9XG5cbn1cblxuQ2xpZW50U2Vzc2lvbi5TVE9SQUdFX0tFWSA9ICdmcHQtc2Vzc2lvbic7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL0NsaWVudFNlc3Npb24uanNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 46 */
/***/ function(module, exports) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ServerSession = function () {\n\t_createClass(ServerSession, null, [{\n\t\tkey: 'create',\n\t\tvalue: function create() {\n\t\t\treturn new ServerSession();\n\t\t}\n\t}]);\n\n\tfunction ServerSession() {\n\t\t_classCallCheck(this, ServerSession);\n\n\t\tthis.id = null;\n\t\tthis.token = null;\n\t\tthis.connection = null;\n\t}\n\n\treturn ServerSession;\n}();\n\nServerSession.GET_SESSION = 'get-session';\nServerSession.SET_SESSION = 'set-session';\nServerSession.SESSION_REFUSED = 'session-refused';\n\nexports.default = ServerSession;//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc2VydmVyL1NlcnZlclNlc3Npb24uanM/MmMyYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0lBQ00sYTtjQUFBLGE7OzJCQUVXO0FBQ2YsVUFBTyxJQUFJLGFBQUosRUFBUDtBQUNBOzs7QUFFRCxVQU5LLGFBTUwsR0FBYztBQUFBLHdCQU5ULGFBTVM7O0FBQ2IsT0FBSyxFQUFMLEdBQVUsSUFBVjtBQUNBLE9BQUssS0FBTCxHQUFhLElBQWI7QUFDQSxPQUFLLFVBQUwsR0FBa0IsSUFBbEI7QUFDQTs7UUFWSSxhOzs7QUFjTixjQUFjLFdBQWQsR0FBNEIsYUFBNUI7QUFDQSxjQUFjLFdBQWQsR0FBNEIsYUFBNUI7QUFDQSxjQUFjLGVBQWQsR0FBZ0MsaUJBQWhDOztrQkFFZSxhIiwiZmlsZSI6IjQ2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5jbGFzcyBTZXJ2ZXJTZXNzaW9uIHtcblx0XG5cdHN0YXRpYyBjcmVhdGUoKSB7XG5cdFx0cmV0dXJuIG5ldyBTZXJ2ZXJTZXNzaW9uKCk7XG5cdH1cblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLmlkID0gbnVsbDtcblx0XHR0aGlzLnRva2VuID0gbnVsbDtcblx0XHR0aGlzLmNvbm5lY3Rpb24gPSBudWxsO1xuXHR9XG5cbn1cblxuU2VydmVyU2Vzc2lvbi5HRVRfU0VTU0lPTiA9ICdnZXQtc2Vzc2lvbic7XG5TZXJ2ZXJTZXNzaW9uLlNFVF9TRVNTSU9OID0gJ3NldC1zZXNzaW9uJztcblNlcnZlclNlc3Npb24uU0VTU0lPTl9SRUZVU0VEID0gJ3Nlc3Npb24tcmVmdXNlZCc7XG5cbmV4cG9ydCBkZWZhdWx0IFNlcnZlclNlc3Npb247XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9zZXJ2ZXIvU2VydmVyU2Vzc2lvbi5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(32);\n\nvar _three2 = _interopRequireDefault(_three);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @author qiao / https://github.com/qiao\n * @author mrdoob / http://mrdoob.com\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / https://github.com/WestLangley\n */\n\n_three2.default.OrbitControls = function (object, domElement) {\n\n\t_three2.default.EventDispatcher.call(this);\n\n\tthis.object = object;\n\tthis.domElement = domElement !== undefined ? domElement : document;\n\n\t// API\n\n\tthis.center = new _three2.default.Vector3();\n\n\tthis.userZoom = true;\n\tthis.userZoomSpeed = 1.0;\n\n\tthis.userRotate = true;\n\tthis.userRotateSpeed = 1.0;\n\n\tthis.autoRotate = false;\n\tthis.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\n\tthis.minPolarAngle = 0; // radians\n\tthis.maxPolarAngle = Math.PI; // radians\n\n\tthis.minDistance = 0;\n\tthis.maxDistance = Infinity;\n\n\t// internals\n\n\tvar scope = this;\n\n\tvar EPS = 0.000001;\n\tvar PIXELS_PER_ROUND = 1800;\n\n\tvar rotateStart = new _three2.default.Vector2();\n\tvar rotateEnd = new _three2.default.Vector2();\n\tvar rotateDelta = new _three2.default.Vector2();\n\n\tvar zoomStart = new _three2.default.Vector2();\n\tvar zoomEnd = new _three2.default.Vector2();\n\tvar zoomDelta = new _three2.default.Vector2();\n\n\tvar phiDelta = 0;\n\tvar thetaDelta = 0;\n\tvar scale = 1;\n\n\tvar lastPosition = new _three2.default.Vector3();\n\n\tvar STATE = { NONE: -1, ROTATE: 0, ZOOM: 1 };\n\tvar state = STATE.NONE;\n\n\t// events\n\n\tvar changeEvent = { type: 'change' };\n\n\tthis.rotateLeft = function (angle) {\n\n\t\tif (angle === undefined) {\n\n\t\t\tangle = getAutoRotationAngle();\n\t\t}\n\n\t\tthetaDelta -= angle;\n\t};\n\n\tthis.rotateRight = function (angle) {\n\n\t\tif (angle === undefined) {\n\n\t\t\tangle = getAutoRotationAngle();\n\t\t}\n\n\t\tthetaDelta += angle;\n\t};\n\n\tthis.rotateUp = function (angle) {\n\n\t\tif (angle === undefined) {\n\n\t\t\tangle = getAutoRotationAngle();\n\t\t}\n\n\t\tphiDelta -= angle;\n\t};\n\n\tthis.rotateDown = function (angle) {\n\n\t\tif (angle === undefined) {\n\n\t\t\tangle = getAutoRotationAngle();\n\t\t}\n\n\t\tphiDelta += angle;\n\t};\n\n\tthis.zoomIn = function (zoomScale) {\n\n\t\tif (zoomScale === undefined) {\n\n\t\t\tzoomScale = getZoomScale();\n\t\t}\n\n\t\tscale /= zoomScale;\n\t};\n\n\tthis.zoomOut = function (zoomScale) {\n\n\t\tif (zoomScale === undefined) {\n\n\t\t\tzoomScale = getZoomScale();\n\t\t}\n\n\t\tscale *= zoomScale;\n\t};\n\n\tthis.update = function () {\n\n\t\tvar position = this.object.position;\n\t\tvar offset = position.clone().sub(this.center);\n\n\t\t// angle from z-axis around y-axis\n\n\t\tvar theta = Math.atan2(offset.x, offset.z);\n\n\t\t// angle from y-axis\n\n\t\tvar phi = Math.atan2(Math.sqrt(offset.x * offset.x + offset.z * offset.z), offset.y);\n\n\t\tif (this.autoRotate) {\n\n\t\t\tthis.rotateLeft(getAutoRotationAngle());\n\t\t}\n\n\t\ttheta += thetaDelta;\n\t\tphi += phiDelta;\n\n\t\t// restrict phi to be between desired limits\n\t\tphi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, phi));\n\n\t\t// restrict phi to be betwee EPS and PI-EPS\n\t\tphi = Math.max(EPS, Math.min(Math.PI - EPS, phi));\n\n\t\tvar radius = offset.length() * scale;\n\n\t\t// restrict radius to be between desired limits\n\t\tradius = Math.max(this.minDistance, Math.min(this.maxDistance, radius));\n\n\t\toffset.x = radius * Math.sin(phi) * Math.sin(theta);\n\t\toffset.y = radius * Math.cos(phi);\n\t\toffset.z = radius * Math.sin(phi) * Math.cos(theta);\n\n\t\tposition.copy(this.center).add(offset);\n\n\t\tthis.object.lookAt(this.center);\n\n\t\tthetaDelta = 0;\n\t\tphiDelta = 0;\n\t\tscale = 1;\n\n\t\tif (lastPosition.distanceTo(this.object.position) > 0) {\n\n\t\t\tthis.dispatchEvent(changeEvent);\n\n\t\t\tlastPosition.copy(this.object.position);\n\t\t}\n\t};\n\n\tfunction getAutoRotationAngle() {\n\n\t\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\t}\n\n\tfunction getZoomScale() {\n\n\t\treturn Math.pow(0.95, scope.userZoomSpeed);\n\t}\n\n\tfunction onMouseDown(event) {\n\n\t\tif (!scope.userRotate) return;\n\n\t\tevent.preventDefault();\n\n\t\tif (event.button === 0 || event.button === 2) {\n\n\t\t\tstate = STATE.ROTATE;\n\n\t\t\trotateStart.set(event.clientX, event.clientY);\n\t\t} else if (event.button === 1) {\n\n\t\t\tstate = STATE.ZOOM;\n\n\t\t\tzoomStart.set(event.clientX, event.clientY);\n\t\t}\n\n\t\tdocument.addEventListener('mousemove', onMouseMove, false);\n\t\tdocument.addEventListener('mouseup', onMouseUp, false);\n\t}\n\n\tfunction onMouseMove(event) {\n\n\t\tevent.preventDefault();\n\n\t\tif (state === STATE.ROTATE) {\n\n\t\t\trotateEnd.set(event.clientX, event.clientY);\n\t\t\trotateDelta.subVectors(rotateEnd, rotateStart);\n\n\t\t\tscope.rotateLeft(2 * Math.PI * rotateDelta.x / PIXELS_PER_ROUND * scope.userRotateSpeed);\n\t\t\tscope.rotateUp(2 * Math.PI * rotateDelta.y / PIXELS_PER_ROUND * scope.userRotateSpeed);\n\n\t\t\trotateStart.copy(rotateEnd);\n\t\t} else if (state === STATE.ZOOM) {\n\n\t\t\tzoomEnd.set(event.clientX, event.clientY);\n\t\t\tzoomDelta.subVectors(zoomEnd, zoomStart);\n\n\t\t\tif (zoomDelta.y > 0) {\n\n\t\t\t\tscope.zoomIn();\n\t\t\t} else {\n\n\t\t\t\tscope.zoomOut();\n\t\t\t}\n\n\t\t\tzoomStart.copy(zoomEnd);\n\t\t}\n\t}\n\n\tfunction onMouseUp(event) {\n\n\t\tif (!scope.userRotate) return;\n\n\t\tdocument.removeEventListener('mousemove', onMouseMove, false);\n\t\tdocument.removeEventListener('mouseup', onMouseUp, false);\n\n\t\tstate = STATE.NONE;\n\t}\n\n\tfunction onMouseWheel(event) {\n\n\t\tif (!scope.userZoom) return;\n\n\t\tvar delta = 0;\n\n\t\tif (event.wheelDelta) {\n\t\t\t// WebKit / Opera / Explorer 9\n\n\t\t\tdelta = event.wheelDelta;\n\t\t} else if (event.detail) {\n\t\t\t// Firefox\n\n\t\t\tdelta = -event.detail;\n\t\t}\n\n\t\tif (delta > 0) {\n\n\t\t\tscope.zoomOut();\n\t\t} else {\n\n\t\t\tscope.zoomIn();\n\t\t}\n\t}\n\n\tthis.domElement.addEventListener('contextmenu', function (event) {\n\t\tevent.preventDefault();\n\t}, false);\n\tthis.domElement.addEventListener('mousedown', onMouseDown, false);\n\tthis.domElement.addEventListener('mousewheel', onMouseWheel, false);\n\tthis.domElement.addEventListener('DOMMouseScroll', onMouseWheel, false); // firefox\n};\n\nexports.default = _three2.default.OrbitControls;//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9USFJFRS5PcmJpdENvbnRyb2xzLmpzPzA1NDYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFTQSxnQkFBTSxhQUFOLEdBQXNCLFVBQVcsTUFBWCxFQUFtQixVQUFuQixFQUFnQzs7QUFFckQsaUJBQU0sZUFBTixDQUFzQixJQUF0QixDQUE0QixJQUE1Qjs7QUFFQSxNQUFLLE1BQUwsR0FBYyxNQUFkO0FBQ0EsTUFBSyxVQUFMLEdBQW9CLGVBQWUsU0FBakIsR0FBK0IsVUFBL0IsR0FBNEMsUUFBOUQ7Ozs7QUFJQSxNQUFLLE1BQUwsR0FBYyxJQUFJLGdCQUFNLE9BQVYsRUFBZDs7QUFFQSxNQUFLLFFBQUwsR0FBZ0IsSUFBaEI7QUFDQSxNQUFLLGFBQUwsR0FBcUIsR0FBckI7O0FBRUEsTUFBSyxVQUFMLEdBQWtCLElBQWxCO0FBQ0EsTUFBSyxlQUFMLEdBQXVCLEdBQXZCOztBQUVBLE1BQUssVUFBTCxHQUFrQixLQUFsQjtBQUNBLE1BQUssZUFBTCxHQUF1QixHQUF2QixDOztBQUVBLE1BQUssYUFBTCxHQUFxQixDQUFyQixDO0FBQ0EsTUFBSyxhQUFMLEdBQXFCLEtBQUssRUFBMUIsQzs7QUFFQSxNQUFLLFdBQUwsR0FBbUIsQ0FBbkI7QUFDQSxNQUFLLFdBQUwsR0FBbUIsUUFBbkI7Ozs7QUFJQSxLQUFJLFFBQVEsSUFBWjs7QUFFQSxLQUFJLE1BQU0sUUFBVjtBQUNBLEtBQUksbUJBQW1CLElBQXZCOztBQUVBLEtBQUksY0FBYyxJQUFJLGdCQUFNLE9BQVYsRUFBbEI7QUFDQSxLQUFJLFlBQVksSUFBSSxnQkFBTSxPQUFWLEVBQWhCO0FBQ0EsS0FBSSxjQUFjLElBQUksZ0JBQU0sT0FBVixFQUFsQjs7QUFFQSxLQUFJLFlBQVksSUFBSSxnQkFBTSxPQUFWLEVBQWhCO0FBQ0EsS0FBSSxVQUFVLElBQUksZ0JBQU0sT0FBVixFQUFkO0FBQ0EsS0FBSSxZQUFZLElBQUksZ0JBQU0sT0FB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ekMsRUFBb0QsS0FBcEQ7O0FBRUEsVUFBUSxNQUFNLElBQWQ7QUFFQTs7QUFFRCxVQUFTLFlBQVQsQ0FBdUIsS0FBdkIsRUFBK0I7O0FBRTlCLE1BQUssQ0FBRSxNQUFNLFFBQWIsRUFBd0I7O0FBRXhCLE1BQUksUUFBUSxDQUFaOztBQUVBLE1BQUssTUFBTSxVQUFYLEVBQXdCOzs7QUFFdkIsV0FBUSxNQUFNLFVBQWQ7QUFFQSxHQUpELE1BSU8sSUFBSyxNQUFNLE1BQVgsRUFBb0I7OztBQUUxQixXQUFRLENBQUUsTUFBTSxNQUFoQjtBQUVBOztBQUVELE1BQUssUUFBUSxDQUFiLEVBQWlCOztBQUVoQixTQUFNLE9BQU47QUFFQSxHQUpELE1BSU87O0FBRU4sU0FBTSxNQUFOO0FBRUE7QUFFRDs7QUFFRCxNQUFLLFVBQUwsQ0FBZ0IsZ0JBQWhCLENBQWtDLGFBQWxDLEVBQWlELFVBQVcsS0FBWCxFQUFtQjtBQUFFLFFBQU0sY0FBTjtBQUF5QixFQUEvRixFQUFpRyxLQUFqRztBQUNBLE1BQUssVUFBTCxDQUFnQixnQkFBaEIsQ0FBa0MsV0FBbEMsRUFBK0MsV0FBL0MsRUFBNEQsS0FBNUQ7QUFDQSxNQUFLLFVBQUwsQ0FBZ0IsZ0JBQWhCLENBQWtDLFlBQWxDLEVBQWdELFlBQWhELEVBQThELEtBQTlEO0FBQ0EsTUFBSyxVQUFMLENBQWdCLGdCQUFoQixDQUFrQyxnQkFBbEMsRUFBb0QsWUFBcEQsRUFBa0UsS0FBbEUsRTtBQUVBLENBM1NEOztrQkE2U2UsZ0JBQU0sYSIsImZpbGUiOiI0Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IFRIUkVFIGZyb20gJ3RocmVlJztcblxuLyoqXG4gKiBAYXV0aG9yIHFpYW8gLyBodHRwczovL2dpdGh1Yi5jb20vcWlhb1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbVxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwczovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqL1xuXG5USFJFRS5PcmJpdENvbnRyb2xzID0gZnVuY3Rpb24gKCBvYmplY3QsIGRvbUVsZW1lbnQgKSB7XG5cblx0VEhSRUUuRXZlbnREaXNwYXRjaGVyLmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLm9iamVjdCA9IG9iamVjdDtcblx0dGhpcy5kb21FbGVtZW50ID0gKCBkb21FbGVtZW50ICE9PSB1bmRlZmluZWQgKSA/IGRvbUVsZW1lbnQgOiBkb2N1bWVudDtcblxuXHQvLyBBUElcblxuXHR0aGlzLmNlbnRlciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0dGhpcy51c2VyWm9vbSA9IHRydWU7XG5cdHRoaXMudXNlclpvb21TcGVlZCA9IDEuMDtcblxuXHR0aGlzLnVzZXJSb3RhdGUgPSB0cnVlO1xuXHR0aGlzLnVzZXJSb3RhdGVTcGVlZCA9IDEuMDtcblxuXHR0aGlzLmF1dG9Sb3RhdGUgPSBmYWxzZTtcblx0dGhpcy5hdXRvUm90YXRlU3BlZWQgPSAyLjA7IC8vIDMwIHNlY29uZHMgcGVyIHJvdW5kIHdoZW4gZnBzIGlzIDYwXG5cblx0dGhpcy5taW5Qb2xhckFuZ2xlID0gMDsgLy8gcmFkaWFuc1xuXHR0aGlzLm1heFBvbGFyQW5nbGUgPSBNYXRoLlBJOyAvLyByYWRpYW5zXG5cblx0dGhpcy5taW5EaXN0YW5jZSA9IDA7XG5cdHRoaXMubWF4RGlzdGFuY2UgPSBJbmZpbml0eTtcblxuXHQvLyBpbnRlcm5hbHNcblxuXHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdHZhciBFUFMgPSAwLjAwMDAwMTtcblx0dmFyIFBJWEVMU19QRVJfUk9VTkQgPSAxODAwO1xuXG5cdHZhciByb3RhdGVTdGFydCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cdHZhciByb3RhdGVFbmQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXHR2YXIgcm90YXRlRGVsdGEgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG5cdHZhciB6b29tU3RhcnQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXHR2YXIgem9vbUVuZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cdHZhciB6b29tRGVsdGEgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG5cdHZhciBwaGlEZWx0YSA9IDA7XG5cdHZhciB0aGV0YURlbHRhID0gMDtcblx0dmFyIHNjYWxlID0gMTtcblxuXHR2YXIgbGFzdFBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHR2YXIgU1RBVEUgPSB7IE5PTkUgOiAtMSwgUk9UQVRFIDogMCwgWk9PTSA6IDEgfTtcblx0dmFyIHN0YXRlID0gU1RBVEUuTk9ORTtcblxuXHQvLyBldmVudHNcblxuXHR2YXIgY2hhbmdlRXZlbnQgPSB7IHR5cGU6ICdjaGFuZ2UnIH07XG5cblxuXHR0aGlzLnJvdGF0ZUxlZnQgPSBmdW5jdGlvbiAoIGFuZ2xlICkge1xuXG5cdFx0aWYgKCBhbmdsZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRhbmdsZSA9IGdldEF1dG9Sb3RhdGlvbkFuZ2xlKCk7XG5cblx0XHR9XG5cblx0XHR0aGV0YURlbHRhIC09IGFuZ2xlO1xuXG5cdH07XG5cblx0dGhpcy5yb3RhdGVSaWdodCA9IGZ1bmN0aW9uICggYW5nbGUgKSB7XG5cblx0XHRpZiAoIGFuZ2xlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGFuZ2xlID0gZ2V0QXV0b1JvdGF0aW9uQW5nbGUoKTtcblxuXHRcdH1cblxuXHRcdHRoZXRhRGVsdGEgKz0gYW5nbGU7XG5cblx0fTtcblxuXHR0aGlzLnJvdGF0ZVVwID0gZnVuY3Rpb24gKCBhbmdsZSApIHtcblxuXHRcdGlmICggYW5nbGUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0YW5nbGUgPSBnZXRBdXRvUm90YXRpb25BbmdsZSgpO1xuXG5cdFx0fVxuXG5cdFx0cGhpRGVsdGEgLT0gYW5nbGU7XG5cblx0fTtcblxuXHR0aGlzLnJvdGF0ZURvd24gPSBmdW5jdGlvbiAoIGFuZ2xlICkge1xuXG5cdFx0aWYgKCBhbmdsZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRhbmdsZSA9IGdldEF1dG9Sb3RhdGlvbkFuZ2xlKCk7XG5cblx0XHR9XG5cblx0XHRwaGlEZWx0YSArPSBhbmdsZTtcblxuXHR9O1xuXG5cdHRoaXMuem9vbUluID0gZnVuY3Rpb24gKCB6b29tU2NhbGUgKSB7XG5cblx0XHRpZiAoIHpvb21TY2FsZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR6b29tU2NhbGUgPSBnZXRab29tU2NhbGUoKTtcblxuXHRcdH1cblxuXHRcdHNjYWxlIC89IHpvb21TY2FsZTtcblxuXHR9O1xuXG5cdHRoaXMuem9vbU91dCA9IGZ1bmN0aW9uICggem9vbVNjYWxlICkge1xuXG5cdFx0aWYgKCB6b29tU2NhbGUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0em9vbVNjYWxlID0gZ2V0Wm9vbVNjYWxlKCk7XG5cblx0XHR9XG5cblx0XHRzY2FsZSAqPSB6b29tU2NhbGU7XG5cblx0fTtcblxuXHR0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBwb3NpdGlvbiA9IHRoaXMub2JqZWN0LnBvc2l0aW9uO1xuXHRcdHZhciBvZmZzZXQgPSBwb3NpdGlvbi5jbG9uZSgpLnN1YiggdGhpcy5jZW50ZXIgKVxuXG5cdFx0Ly8gYW5nbGUgZnJvbSB6LWF4aXMgYXJvdW5kIHktYXhpc1xuXG5cdFx0dmFyIHRoZXRhID0gTWF0aC5hdGFuMiggb2Zmc2V0LngsIG9mZnNldC56ICk7XG5cblx0XHQvLyBhbmdsZSBmcm9tIHktYXhpc1xuXG5cdFx0dmFyIHBoaSA9IE1hdGguYXRhbjIoIE1hdGguc3FydCggb2Zmc2V0LnggKiBvZmZzZXQueCArIG9mZnNldC56ICogb2Zmc2V0LnogKSwgb2Zmc2V0LnkgKTtcblxuXHRcdGlmICggdGhpcy5hdXRvUm90YXRlICkge1xuXG5cdFx0XHR0aGlzLnJvdGF0ZUxlZnQoIGdldEF1dG9Sb3RhdGlvbkFuZ2xlKCkgKTtcblxuXHRcdH1cblxuXHRcdHRoZXRhICs9IHRoZXRhRGVsdGE7XG5cdFx0cGhpICs9IHBoaURlbHRhO1xuXG5cdFx0Ly8gcmVzdHJpY3QgcGhpIHRvIGJlIGJldHdlZW4gZGVzaXJlZCBsaW1pdHNcblx0XHRwaGkgPSBNYXRoLm1heCggdGhpcy5taW5Qb2xhckFuZ2xlLCBNYXRoLm1pbiggdGhpcy5tYXhQb2xhckFuZ2xlLCBwaGkgKSApO1xuXG5cdFx0Ly8gcmVzdHJpY3QgcGhpIHRvIGJlIGJldHdlZSBFUFMgYW5kIFBJLUVQU1xuXHRcdHBoaSA9IE1hdGgubWF4KCBFUFMsIE1hdGgubWluKCBNYXRoLlBJIC0gRVBTLCBwaGkgKSApO1xuXG5cdFx0dmFyIHJhZGl1cyA9IG9mZnNldC5sZW5ndGgoKSAqIHNjYWxlO1xuXG5cdFx0Ly8gcmVzdHJpY3QgcmFkaXVzIHRvIGJlIGJldHdlZW4gZGVzaXJlZCBsaW1pdHNcblx0XHRyYWRpdXMgPSBNYXRoLm1heCggdGhpcy5taW5EaXN0YW5jZSwgTWF0aC5taW4oIHRoaXMubWF4RGlzdGFuY2UsIHJhZGl1cyApICk7XG5cblx0XHRvZmZzZXQueCA9IHJhZGl1cyAqIE1hdGguc2luKCBwaGkgKSAqIE1hdGguc2luKCB0aGV0YSApO1xuXHRcdG9mZnNldC55ID0gcmFkaXVzICogTWF0aC5jb3MoIHBoaSApO1xuXHRcdG9mZnNldC56ID0gcmFkaXVzICogTWF0aC5zaW4oIHBoaSApICogTWF0aC5jb3MoIHRoZXRhICk7XG5cblx0XHRwb3NpdGlvbi5jb3B5KCB0aGlzLmNlbnRlciApLmFkZCggb2Zmc2V0ICk7XG5cblx0XHR0aGlzLm9iamVjdC5sb29rQXQoIHRoaXMuY2VudGVyICk7XG5cblx0XHR0aGV0YURlbHRhID0gMDtcblx0XHRwaGlEZWx0YSA9IDA7XG5cdFx0c2NhbGUgPSAxO1xuXG5cdFx0aWYgKCBsYXN0UG9zaXRpb24uZGlzdGFuY2VUbyggdGhpcy5vYmplY3QucG9zaXRpb24gKSA+IDAgKSB7XG5cblx0XHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggY2hhbmdlRXZlbnQgKTtcblxuXHRcdFx0bGFzdFBvc2l0aW9uLmNvcHkoIHRoaXMub2JqZWN0LnBvc2l0aW9uICk7XG5cblx0XHR9XG5cblx0fTtcblxuXG5cdGZ1bmN0aW9uIGdldEF1dG9Sb3RhdGlvbkFuZ2xlKCkge1xuXG5cdFx0cmV0dXJuIDIgKiBNYXRoLlBJIC8gNjAgLyA2MCAqIHNjb3BlLmF1dG9Sb3RhdGVTcGVlZDtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Wm9vbVNjYWxlKCkge1xuXG5cdFx0cmV0dXJuIE1hdGgucG93KCAwLjk1LCBzY29wZS51c2VyWm9vbVNwZWVkICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIG9uTW91c2VEb3duKCBldmVudCApIHtcblxuXHRcdGlmICggIXNjb3BlLnVzZXJSb3RhdGUgKSByZXR1cm47XG5cblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0aWYgKCBldmVudC5idXR0b24gPT09IDAgfHwgZXZlbnQuYnV0dG9uID09PSAyICkge1xuXG5cdFx0XHRzdGF0ZSA9IFNUQVRFLlJPVEFURTtcblxuXHRcdFx0cm90YXRlU3RhcnQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XG5cblx0XHR9IGVsc2UgaWYgKCBldmVudC5idXR0b24gPT09IDEgKSB7XG5cblx0XHRcdHN0YXRlID0gU1RBVEUuWk9PTTtcblxuXHRcdFx0em9vbVN0YXJ0LnNldCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xuXG5cdFx0fVxuXG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlLCBmYWxzZSApO1xuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZXVwJywgb25Nb3VzZVVwLCBmYWxzZSApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBvbk1vdXNlTW92ZSggZXZlbnQgKSB7XG5cblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0aWYgKCBzdGF0ZSA9PT0gU1RBVEUuUk9UQVRFICkge1xuXG5cdFx0XHRyb3RhdGVFbmQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XG5cdFx0XHRyb3RhdGVEZWx0YS5zdWJWZWN0b3JzKCByb3RhdGVFbmQsIHJvdGF0ZVN0YXJ0ICk7XG5cblx0XHRcdHNjb3BlLnJvdGF0ZUxlZnQoIDIgKiBNYXRoLlBJICogcm90YXRlRGVsdGEueCAvIFBJWEVMU19QRVJfUk9VTkQgKiBzY29wZS51c2VyUm90YXRlU3BlZWQgKTtcblx0XHRcdHNjb3BlLnJvdGF0ZVVwKCAyICogTWF0aC5QSSAqIHJvdGF0ZURlbHRhLnkgLyBQSVhFTFNfUEVSX1JPVU5EICogc2NvcGUudXNlclJvdGF0ZVNwZWVkICk7XG5cblx0XHRcdHJvdGF0ZVN0YXJ0LmNvcHkoIHJvdGF0ZUVuZCApO1xuXG5cdFx0fSBlbHNlIGlmICggc3RhdGUgPT09IFNUQVRFLlpPT00gKSB7XG5cblx0XHRcdHpvb21FbmQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XG5cdFx0XHR6b29tRGVsdGEuc3ViVmVjdG9ycyggem9vbUVuZCwgem9vbVN0YXJ0ICk7XG5cblx0XHRcdGlmICggem9vbURlbHRhLnkgPiAwICkge1xuXG5cdFx0XHRcdHNjb3BlLnpvb21JbigpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHNjb3BlLnpvb21PdXQoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR6b29tU3RhcnQuY29weSggem9vbUVuZCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBvbk1vdXNlVXAoIGV2ZW50ICkge1xuXG5cdFx0aWYgKCAhIHNjb3BlLnVzZXJSb3RhdGUgKSByZXR1cm47XG5cblx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAnbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUsIGZhbHNlICk7XG5cdFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ21vdXNldXAnLCBvbk1vdXNlVXAsIGZhbHNlICk7XG5cblx0XHRzdGF0ZSA9IFNUQVRFLk5PTkU7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIG9uTW91c2VXaGVlbCggZXZlbnQgKSB7XG5cblx0XHRpZiAoICEgc2NvcGUudXNlclpvb20gKSByZXR1cm47XG5cblx0XHR2YXIgZGVsdGEgPSAwO1xuXG5cdFx0aWYgKCBldmVudC53aGVlbERlbHRhICkgeyAvLyBXZWJLaXQgLyBPcGVyYSAvIEV4cGxvcmVyIDlcblxuXHRcdFx0ZGVsdGEgPSBldmVudC53aGVlbERlbHRhO1xuXG5cdFx0fSBlbHNlIGlmICggZXZlbnQuZGV0YWlsICkgeyAvLyBGaXJlZm94XG5cblx0XHRcdGRlbHRhID0gLSBldmVudC5kZXRhaWw7XG5cblx0XHR9XG5cblx0XHRpZiAoIGRlbHRhID4gMCApIHtcblxuXHRcdFx0c2NvcGUuem9vbU91dCgpO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0c2NvcGUuem9vbUluKCk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAnY29udGV4dG1lbnUnLCBmdW5jdGlvbiAoIGV2ZW50ICkgeyBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyB9LCBmYWxzZSApO1xuXHR0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNlZG93bicsIG9uTW91c2VEb3duLCBmYWxzZSApO1xuXHR0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNld2hlZWwnLCBvbk1vdXNlV2hlZWwsIGZhbHNlICk7XG5cdHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAnRE9NTW91c2VTY3JvbGwnLCBvbk1vdXNlV2hlZWwsIGZhbHNlICk7IC8vIGZpcmVmb3hcblxufTtcblxuZXhwb3J0IGRlZmF1bHQgVEhSRUUuT3JiaXRDb250cm9scztcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vVEhSRUUuT3JiaXRDb250cm9scy5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _Entity = __webpack_require__(13);\n\nvar _Entity2 = _interopRequireDefault(_Entity);\n\nvar _PhysicsComponent = __webpack_require__(26);\n\nvar _PhysicsComponent2 = _interopRequireDefault(_PhysicsComponent);\n\nvar _ViewComponent = __webpack_require__(49);\n\nvar _ViewComponent2 = _interopRequireDefault(_ViewComponent);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar TestBall = _Entity2.default.createClass({\n\tconstructor: function constructor(options) {\n\t\tvar physics = _PhysicsComponent2.default.create({\n\t\t\tposition: options.position,\n\t\t\trotation: options.rotation\n\t\t});\n\t\tthis.set('physics', physics);\n\t\tvar viewComponent = _ViewComponent2.default.create({\n\t\t\tphysics: physics\n\t\t});\n\t\tthis.set('view', viewComponent);\n\t}\n});\n\nTestBall.create = function (options) {\n\treturn new TestBall(options);\n};\n\nmodule.exports = TestBall;//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vZ2FtZS90ZXN0QmFsbC9UZXN0QmFsbC5qcz81MzRlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQSxJQUFJLFdBQVcsaUJBQU8sV0FBUCxDQUFtQjtBQUNqQyxjQUFhLHFCQUFTLE9BQVQsRUFBa0I7QUFDOUIsTUFBSSxVQUFVLDJCQUFpQixNQUFqQixDQUF3QjtBQUNyQyxhQUFVLFFBQVEsUUFEbUI7QUFFckMsYUFBVSxRQUFRO0FBRm1CLEdBQXhCLENBQWQ7QUFJQSxPQUFLLEdBQUwsQ0FBUyxTQUFULEVBQW9CLE9BQXBCO0FBQ0EsTUFBSSxnQkFBZ0Isd0JBQWMsTUFBZCxDQUFxQjtBQUN4QyxZQUFTO0FBRCtCLEdBQXJCLENBQXBCO0FBR0EsT0FBSyxHQUFMLENBQVMsTUFBVCxFQUFpQixhQUFqQjtBQUNBO0FBWGdDLENBQW5CLENBQWY7O0FBY0EsU0FBUyxNQUFULEdBQWtCLFVBQVMsT0FBVCxFQUFrQjtBQUNuQyxRQUFPLElBQUksUUFBSixDQUFhLE9BQWIsQ0FBUDtBQUNBLENBRkQ7O0FBSUEsT0FBTyxPQUFQLEdBQWlCLFFBQWpCIiwiZmlsZSI6IjQ4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgRW50aXR5IGZyb20gJy4uL2Vjcy9FbnRpdHknO1xuaW1wb3J0IFBoeXNpY3NDb21wb25lbnQgZnJvbSAnLi4vcGh5c2ljcy9QaHlzaWNzQ29tcG9uZW50JztcbmltcG9ydCBWaWV3Q29tcG9uZW50IGZyb20gJy4uL3ZpZXcvVmlld0NvbXBvbmVudCc7XG5cbmxldCBUZXN0QmFsbCA9IEVudGl0eS5jcmVhdGVDbGFzcyh7XG5cdGNvbnN0cnVjdG9yOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0bGV0IHBoeXNpY3MgPSBQaHlzaWNzQ29tcG9uZW50LmNyZWF0ZSh7XG5cdFx0XHRwb3NpdGlvbjogb3B0aW9ucy5wb3NpdGlvbixcblx0XHRcdHJvdGF0aW9uOiBvcHRpb25zLnJvdGF0aW9uXG5cdFx0fSk7XG5cdFx0dGhpcy5zZXQoJ3BoeXNpY3MnLCBwaHlzaWNzKTtcblx0XHRsZXQgdmlld0NvbXBvbmVudCA9IFZpZXdDb21wb25lbnQuY3JlYXRlKHtcblx0XHRcdHBoeXNpY3M6IHBoeXNpY3Ncblx0XHR9KTtcblx0XHR0aGlzLnNldCgndmlldycsIHZpZXdDb21wb25lbnQpO1xuXHR9XG59KTtcblxuVGVzdEJhbGwuY3JlYXRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IFRlc3RCYWxsKG9wdGlvbnMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUZXN0QmFsbDtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL2dhbWUvdGVzdEJhbGwvVGVzdEJhbGwuanNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 49 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ViewComponent = function () {\n\t_createClass(ViewComponent, null, [{\n\t\tkey: \"create\",\n\t\tvalue: function create() {\n\t\t\treturn new ViewComponent();\n\t\t}\n\t}]);\n\n\tfunction ViewComponent() {\n\t\t_classCallCheck(this, ViewComponent);\n\t}\n\n\treturn ViewComponent;\n}();\n\nexports.default = ViewComponent;//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vZ2FtZS92aWV3L1ZpZXdDb21wb25lbnQuanM/NDUyOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0lBQ00sYTtjQUFBLGE7OzJCQUVXO0FBQ2YsVUFBTyxJQUFJLGFBQUosRUFBUDtBQUNBOzs7QUFFRCxVQU5LLGFBTUwsR0FBYztBQUFBLHdCQU5ULGFBTVM7QUFFYjs7UUFSSSxhOzs7a0JBWVMsYSIsImZpbGUiOiI0OS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuY2xhc3MgVmlld0NvbXBvbmVudCB7XG5cblx0c3RhdGljIGNyZWF0ZSgpIHtcblx0XHRyZXR1cm4gbmV3IFZpZXdDb21wb25lbnQoKTtcblx0fVxuXG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBWaWV3Q29tcG9uZW50O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vZ2FtZS92aWV3L1ZpZXdDb21wb25lbnQuanNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _System = __webpack_require__(4);\n\nvar _System2 = _interopRequireDefault(_System);\n\nvar _three = __webpack_require__(32);\n\nvar _three2 = _interopRequireDefault(_three);\n\nvar _PhysicsDebugComponent = __webpack_require__(51);\n\nvar _PhysicsDebugComponent2 = _interopRequireDefault(_PhysicsDebugComponent);\n\nvar _ConstraintDebugView = __webpack_require__(54);\n\nvar _ConstraintDebugView2 = _interopRequireDefault(_ConstraintDebugView);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar PhysicsDebugView = _System2.default.createClass({\n\n\tconstructor: function constructor(fptGameView) {\n\n\t\tthis.view = fptGameView;\n\n\t\tthis.three = new _three2.default.Object3D();\n\n\t\tthis.threeConstraints = new _three2.default.Object3D();\n\t\tthis.three.add(this.threeConstraints);\n\n\t\tthis.threeShapes = new _three2.default.Object3D();\n\t\tthis.three.add(this.threeShapes);\n\n\t\tthis.view.scene.add(this.three);\n\n\t\tthis.entities = fptGameView.game.entities;\n\n\t\tthis._constraints = [];\n\t},\n\n\ttick: function tick(ms) {\n\t\tthis.entities.forEach(function (entity) {\n\t\t\tthis.tickEntity(entity);\n\t\t}.bind(this));\n\n\t\tthis.tickConstraints();\n\t},\n\n\ttickEntity: function tickEntity(entity) {\n\t\tvar pieces = entity.get('pieces');\n\n\t\tif (pieces) {\n\t\t\tpieces.forEach(function (piece) {\n\t\t\t\tthis.tickEntity(piece);\n\t\t\t}.bind(this));\n\t\t}\n\n\t\tvar view = entity.get('physicsDebugView'),\n\t\t    physics = entity.get('physics');\n\n\t\tif (view && !physics) {\n\t\t\tthis.threeShapes.remove(view.three);\n\t\t}\n\n\t\tif (!view && physics) {\n\t\t\tview = new _PhysicsDebugComponent2.default(entity);\n\t\t\tentity.set('physicsDebugView', view);\n\t\t}\n\n\t\tif (view && physics && !view.three.parent) {\n\t\t\tthis.threeShapes.add(view.three);\n\t\t}\n\n\t\tif (view) {\n\t\t\tview.tick();\n\t\t}\n\t},\n\n\ttickConstraints: function tickConstraints() {\n\t\tvar cannonConstraints = this.view.game.physics.world.constraints;\n\t\tcannonConstraints.forEach(function (cannonConstraint) {\n\t\t\tif (!this._constraints.find(function (constraintDebugView) {\n\t\t\t\treturn constraintDebugView.cannon === cannonConstraint;\n\t\t\t}.bind(this))) {\n\t\t\t\tvar view = new _ConstraintDebugView2.default(cannonConstraint);\n\t\t\t\tthis._constraints.push(view);\n\t\t\t\tthis.threeConstraints.add(view.three);\n\t\t\t}\n\t\t}.bind(this));\n\n\t\tif (cannonConstraints.length !== this._constraints.length) {\n\t\t\tthis._constraints = this._constraints.some(function (view) {\n\t\t\t\tif (cannonConstraints.indexOf(view.cannon) === -1) {\n\t\t\t\t\tthis.threeConstraints.remove(view.three);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}.bind(this));\n\t\t}\n\n\t\tthis._constraints.forEach(function (view) {\n\t\t\tview.tick();\n\t\t});\n\t}\n\n});\n\nPhysicsDebugView.create = function (fptGameView) {\n\treturn new PhysicsDebugView(fptGameView);\n};\n\nexports.default = PhysicsDebugView;//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi92aWV3L1BoeXNpY3NEZWJ1Z1ZpZXcuanM/NjMwZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUEsSUFBSSxtQkFBbUIsaUJBQU8sV0FBUCxDQUFtQjs7QUFFekMsY0FBYSxxQkFBUyxXQUFULEVBQXNCOztBQUVsQyxPQUFLLElBQUwsR0FBWSxXQUFaOztBQUVBLE9BQUssS0FBTCxHQUFhLElBQUksZ0JBQU0sUUFBVixFQUFiOztBQUVBLE9BQUssZ0JBQUwsR0FBd0IsSUFBSSxnQkFBTSxRQUFWLEVBQXhCO0FBQ0EsT0FBSyxLQUFMLENBQVcsR0FBWCxDQUFlLEtBQUssZ0JBQXBCOztBQUVBLE9BQUssV0FBTCxHQUFtQixJQUFJLGdCQUFNLFFBQVYsRUFBbkI7QUFDQSxPQUFLLEtBQUwsQ0FBVyxHQUFYLENBQWUsS0FBSyxXQUFwQjs7QUFFQSxPQUFLLElBQUwsQ0FBVSxLQUFWLENBQWdCLEdBQWhCLENBQW9CLEtBQUssS0FBekI7O0FBRUEsT0FBSyxRQUFMLEdBQWdCLFlBQVksSUFBWixDQUFpQixRQUFqQzs7QUFFQSxPQUFLLFlBQUwsR0FBb0IsRUFBcEI7QUFFQSxFQXBCd0M7O0FBc0J6QyxPQUFNLGNBQVMsRUFBVCxFQUFhO0FBQ2xCLE9BQUssUUFBTCxDQUFjLE9BQWQsQ0FBc0IsVUFBUyxNQUFULEVBQWlCO0FBQ3RDLFFBQUssVUFBTCxDQUFnQixNQUFoQjtBQUNBLEdBRnFCLENBRXBCLElBRm9CLENBRWYsSUFGZSxDQUF0Qjs7QUFJQSxPQUFLLGVBQUw7QUFDQSxFQTVCd0M7O0FBOEJ6QyxhQUFZLG9CQUFTLE1BQVQsRUFBaUI7QUFDNUIsTUFBSSxTQUFTLE9BQU8sR0FBUCxDQUFXLFFBQVgsQ0FBYjs7QUFFQSxNQUFJLE1BQUosRUFBWTtBQUNYLFVBQU8sT0FBUCxDQUFlLFVBQVMsS0FBVCxFQUFnQjtBQUM5QixTQUFLLFVBQUwsQ0FBZ0IsS0FBaEI7QUFDQSxJQUZjLENBRWIsSUFGYSxDQUVSLElBRlEsQ0FBZjtBQUdBOztBQUVELE1BQUksT0FBTyxPQUFPLEdBQVAsQ0FBVyxrQkFBWCxDQUFYO01BQ0MsVUFBVSxPQUFPLEdBQVAsQ0FBVyxTQUFYLENBRFg7O0FBR0EsTUFBSSxRQUFRLENBQUMsT0FBYixFQUFzQjtBQUNyQixRQUFLLFdBQUwsQ0FBaUIsTUFBakIsQ0FBd0IsS0FBSyxLQUE3QjtBQUNBOztBQUVELE1BQUksQ0FBQyxJQUFELElBQVMsT0FBYixFQUFzQjtBQUNyQixVQUFPLG9DQUEwQixNQUExQixDQUFQO0FBQ0EsVUFBTyxHQUFQLENBQVcsa0JBQVgsRUFBK0IsSUFBL0I7QUFDQTs7QUFFRCxNQUFJLFFBQVEsT0FBUixJQUFtQixDQUFDLEtBQUssS0FBTCxDQUFXLE1BQW5DLEVBQTJDO0FBQzFDLFFBQUssV0FBTCxDQUFpQixHQUFqQixDQUFxQixLQUFLLEtBQTFCO0FBQ0E7O0FBRUQsTUFBSSxJQUFKLEVBQVU7QUFDVCxRQUFLLElBQUw7QUFDQTtBQUNELEVBMUR3Qzs7QUE0RHpDLGtCQUFpQiwyQkFBVztBQUMzQixNQUFJLG9CQUFvQixLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsT0FBZixDQUF1QixLQUF2QixDQUE2QixXQUFyRDtBQUNBLG9CQUFrQixPQUFsQixDQUEwQixVQUFTLGdCQUFULEVBQTJCO0FBQ3BELE9BQ0MsQ0FBQyxLQUFLLFlBQUwsQ0FBa0IsSUFBbEIsQ0FBdUIsVUFBUyxtQkFBVCxFQUE4QjtBQUNyRCxXQUFPLG9CQUFvQixNQUFwQixLQUErQixnQkFBdEM7QUFDQSxJQUZ1QixDQUV0QixJQUZzQixDQUVqQixJQUZpQixDQUF2QixDQURGLEVBSUU7QUFDRCxRQUFJLE9BQU8sa0NBQXdCLGdCQUF4QixDQUFYO0FBQ0EsU0FBSyxZQUFMLENBQWtCLElBQWxCLENBQXVCLElBQXZCO0FBQ0EsU0FBSyxnQkFBTCxDQUFzQixHQUF0QixDQUEwQixLQUFLLEtBQS9CO0FBQ0E7QUFDRCxHQVZ5QixDQVV4QixJQVZ3QixDQVVuQixJQVZtQixDQUExQjs7QUFZQSxNQUFJLGtCQUFrQixNQUFsQixLQUE2QixLQUFLLFlBQUwsQ0FBa0IsTUFBbkQsRUFBMkQ7QUFDMUQsUUFBSyxZQUFMLEdBQW9CLEtBQUssWUFBTCxDQUFrQixJQUFsQixDQUF1QixVQUFTLElBQVQsRUFBZTtBQUN6RCxRQUFJLGtCQUFrQixPQUFsQixDQUEwQixLQUFLLE1BQS9CLE1BQTJDLENBQUMsQ0FBaEQsRUFBbUQ7QUFDbEQsVUFBSyxnQkFBTCxDQUFzQixNQUF0QixDQUE2QixLQUFLLEtBQWxDO0FBQ0EsWUFBTyxLQUFQO0FBQ0E7QUFDRCxXQUFPLElBQVA7QUFDQSxJQU4wQyxDQU16QyxJQU55QyxDQU1wQyxJQU5vQyxDQUF2QixDQUFwQjtBQU9BOztBQUVELE9BQUssWUFBTCxDQUFrQixPQUFsQixDQUEwQixVQUFTLElBQVQsRUFBZTtBQUN4QyxRQUFLLElBQUw7QUFDQSxHQUZEO0FBR0E7O0FBdkZ3QyxDQUFuQixDQUF2Qjs7QUEyRkEsaUJBQWlCLE1BQWpCLEdBQTBCLFVBQVMsV0FBVCxFQUFzQjtBQUMvQyxRQUFPLElBQUksZ0JBQUosQ0FBcUIsV0FBckIsQ0FBUDtBQUNBLENBRkQ7O2tCQUllLGdCIiwiZmlsZSI6IjUwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgU3lzdGVtIGZyb20gJy4uLy4uL2dhbWUvZWNzL1N5c3RlbSc7XG5pbXBvcnQgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0IFBoeXNpY3NEZWJ1Z0NvbXBvbmVudCBmcm9tICcuL1BoeXNpY3NEZWJ1Z0NvbXBvbmVudCc7XG5pbXBvcnQgQ29uc3RyYWludERlYnVnVmlldyBmcm9tICcuL2RlYnVnL0NvbnN0cmFpbnREZWJ1Z1ZpZXcnO1xuXG5sZXQgUGh5c2ljc0RlYnVnVmlldyA9IFN5c3RlbS5jcmVhdGVDbGFzcyh7XG5cdFxuXHRjb25zdHJ1Y3RvcjogZnVuY3Rpb24oZnB0R2FtZVZpZXcpIHtcblxuXHRcdHRoaXMudmlldyA9IGZwdEdhbWVWaWV3O1xuXG5cdFx0dGhpcy50aHJlZSA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuXG5cdFx0dGhpcy50aHJlZUNvbnN0cmFpbnRzID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XG5cdFx0dGhpcy50aHJlZS5hZGQodGhpcy50aHJlZUNvbnN0cmFpbnRzKTtcblxuXHRcdHRoaXMudGhyZWVTaGFwZXMgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcblx0XHR0aGlzLnRocmVlLmFkZCh0aGlzLnRocmVlU2hhcGVzKTtcblxuXHRcdHRoaXMudmlldy5zY2VuZS5hZGQodGhpcy50aHJlZSk7XG5cblx0XHR0aGlzLmVudGl0aWVzID0gZnB0R2FtZVZpZXcuZ2FtZS5lbnRpdGllcztcblxuXHRcdHRoaXMuX2NvbnN0cmFpbnRzID0gW107XG5cblx0fSxcblxuXHR0aWNrOiBmdW5jdGlvbihtcykge1xuXHRcdHRoaXMuZW50aXRpZXMuZm9yRWFjaChmdW5jdGlvbihlbnRpdHkpIHtcblx0XHRcdHRoaXMudGlja0VudGl0eShlbnRpdHkpO1xuXHRcdH0uYmluZCh0aGlzKSk7XG5cblx0XHR0aGlzLnRpY2tDb25zdHJhaW50cygpO1xuXHR9LFxuXG5cdHRpY2tFbnRpdHk6IGZ1bmN0aW9uKGVudGl0eSkge1xuXHRcdGxldCBwaWVjZXMgPSBlbnRpdHkuZ2V0KCdwaWVjZXMnKTtcblxuXHRcdGlmIChwaWVjZXMpIHtcblx0XHRcdHBpZWNlcy5mb3JFYWNoKGZ1bmN0aW9uKHBpZWNlKSB7XG5cdFx0XHRcdHRoaXMudGlja0VudGl0eShwaWVjZSk7XG5cdFx0XHR9LmJpbmQodGhpcykpO1xuXHRcdH1cblxuXHRcdGxldCB2aWV3ID0gZW50aXR5LmdldCgncGh5c2ljc0RlYnVnVmlldycpLFxuXHRcdFx0cGh5c2ljcyA9IGVudGl0eS5nZXQoJ3BoeXNpY3MnKTtcblxuXHRcdGlmICh2aWV3ICYmICFwaHlzaWNzKSB7XG5cdFx0XHR0aGlzLnRocmVlU2hhcGVzLnJlbW92ZSh2aWV3LnRocmVlKTtcblx0XHR9XG5cblx0XHRpZiAoIXZpZXcgJiYgcGh5c2ljcykge1xuXHRcdFx0dmlldyA9IG5ldyBQaHlzaWNzRGVidWdDb21wb25lbnQoZW50aXR5KTtcblx0XHRcdGVudGl0eS5zZXQoJ3BoeXNpY3NEZWJ1Z1ZpZXcnLCB2aWV3KTtcblx0XHR9XG5cblx0XHRpZiAodmlldyAmJiBwaHlzaWNzICYmICF2aWV3LnRocmVlLnBhcmVudCkge1xuXHRcdFx0dGhpcy50aHJlZVNoYXBlcy5hZGQodmlldy50aHJlZSk7XG5cdFx0fVxuXG5cdFx0aWYgKHZpZXcpIHtcblx0XHRcdHZpZXcudGljaygpO1xuXHRcdH1cblx0fSxcblxuXHR0aWNrQ29uc3RyYWludHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjYW5ub25Db25zdHJhaW50cyA9IHRoaXMudmlldy5nYW1lLnBoeXNpY3Mud29ybGQuY29uc3RyYWludHM7XG5cdFx0Y2Fubm9uQ29uc3RyYWludHMuZm9yRWFjaChmdW5jdGlvbihjYW5ub25Db25zdHJhaW50KSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdCF0aGlzLl9jb25zdHJhaW50cy5maW5kKGZ1bmN0aW9uKGNvbnN0cmFpbnREZWJ1Z1ZpZXcpIHtcblx0XHRcdFx0XHRyZXR1cm4gY29uc3RyYWludERlYnVnVmlldy5jYW5ub24gPT09IGNhbm5vbkNvbnN0cmFpbnQ7XG5cdFx0XHRcdH0uYmluZCh0aGlzKSlcblx0XHRcdCkge1xuXHRcdFx0XHRsZXQgdmlldyA9IG5ldyBDb25zdHJhaW50RGVidWdWaWV3KGNhbm5vbkNvbnN0cmFpbnQpO1xuXHRcdFx0XHR0aGlzLl9jb25zdHJhaW50cy5wdXNoKHZpZXcpO1xuXHRcdFx0XHR0aGlzLnRocmVlQ29uc3RyYWludHMuYWRkKHZpZXcudGhyZWUpO1xuXHRcdFx0fVxuXHRcdH0uYmluZCh0aGlzKSk7XG5cblx0XHRpZiAoY2Fubm9uQ29uc3RyYWludHMubGVuZ3RoICE9PSB0aGlzLl9jb25zdHJhaW50cy5sZW5ndGgpIHtcblx0XHRcdHRoaXMuX2NvbnN0cmFpbnRzID0gdGhpcy5fY29uc3RyYWludHMuc29tZShmdW5jdGlvbih2aWV3KSB7XG5cdFx0XHRcdGlmIChjYW5ub25Db25zdHJhaW50cy5pbmRleE9mKHZpZXcuY2Fubm9uKSA9PT0gLTEpIHtcblx0XHRcdFx0XHR0aGlzLnRocmVlQ29uc3RyYWludHMucmVtb3ZlKHZpZXcudGhyZWUpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH0uYmluZCh0aGlzKSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fY29uc3RyYWludHMuZm9yRWFjaChmdW5jdGlvbih2aWV3KSB7XG5cdFx0XHR2aWV3LnRpY2soKTtcblx0XHR9KTtcblx0fVxuXG59KTtcblxuUGh5c2ljc0RlYnVnVmlldy5jcmVhdGUgPSBmdW5jdGlvbihmcHRHYW1lVmlldykge1xuXHRyZXR1cm4gbmV3IFBoeXNpY3NEZWJ1Z1ZpZXcoZnB0R2FtZVZpZXcpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgUGh5c2ljc0RlYnVnVmlldztcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vdmlldy9QaHlzaWNzRGVidWdWaWV3LmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _three = __webpack_require__(32);\n\nvar _three2 = _interopRequireDefault(_three);\n\nvar _compare = __webpack_require__(52);\n\nvar _compare2 = _interopRequireDefault(_compare);\n\nvar _clone = __webpack_require__(53);\n\nvar _clone2 = _interopRequireDefault(_clone);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar PhysicsDebugComponent = function () {\n\tfunction PhysicsDebugComponent(entity) {\n\t\t_classCallCheck(this, PhysicsDebugComponent);\n\n\t\tthis.entity = entity;\n\n\t\tvar three = new _three2.default.Object3D();\n\t\tvar physics = entity.get('physics');\n\n\t\tthis.threeAxis = new ThreeAxis();\n\t\tthree.add(this.threeAxis);\n\n\t\tthis.three = three;\n\t}\n\n\t_createClass(PhysicsDebugComponent, [{\n\t\tkey: 'tick',\n\t\tvalue: function tick() {\n\t\t\tthis.tickShapes();\n\t\t\tthis.tickPosition();\n\t\t}\n\t}, {\n\t\tkey: 'tickPosition',\n\t\tvalue: function tickPosition() {\n\t\t\tvar physics = this.entity.get('physics');\n\n\t\t\tif (physics) {\n\t\t\t\tvar position = physics.position;\n\t\t\t\tthis.three.position.set(position.x, position.y, position.z);\n\n\t\t\t\tvar rotation = physics.rotation;\n\t\t\t\tthis.three.useQuaternion = true;\n\t\t\t\tthis.three.quaternion.set(rotation.x, rotation.y, rotation.z, rotation.w);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'tickShapes',\n\t\tvalue: function tickShapes() {\n\t\t\tvar _this = this;\n\n\t\t\tvar physics = this.entity.get('physics');\n\n\t\t\tif (physics) {\n\t\t\t\tvar _ret = function () {\n\n\t\t\t\t\tif (_this.oldShapes && _compare2.default.arrays(_this.oldShapes, physics.cannon.shapes) === true) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tv: void 0\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\tif (_this.threeShapes) {\n\t\t\t\t\t\t_this.three.remove(_this.threeShapes);\n\t\t\t\t\t}\n\n\t\t\t\t\t_this.threeShapes = new _three2.default.Object3D();\n\t\t\t\t\t_this.three.add(_this.threeShapes);\n\n\t\t\t\t\tvar material = new _three2.default.MeshLambertMaterial({\n\t\t\t\t\t\tcolor: 0xff0000,\n\t\t\t\t\t\twireframe: true\n\t\t\t\t\t});\n\n\t\t\t\t\t_this.oldShapes = _clone2.default.array(physics.cannon.shapes);\n\n\t\t\t\t\tphysics.cannon.shapes.forEach(function (cannonShape, i) {\n\t\t\t\t\t\tvar mesh = new _three2.default.Mesh(new _three2.default.CubeGeometry(cannonShape.halfExtents.x * 2, cannonShape.halfExtents.y * 2, cannonShape.halfExtents.z * 2), material);\n\t\t\t\t\t\tvar position = physics.cannon.shapeOffsets[i];\n\t\t\t\t\t\tmesh.position.set(position.x, position.y, position.z);\n\t\t\t\t\t\tvar rotation = physics.cannon.shapeOrientations[i];\n\t\t\t\t\t\tmesh.useQuaternion = true;\n\t\t\t\t\t\tmesh.quaternion.set(rotation.x, rotation.y, rotation.z, rotation.w);\n\t\t\t\t\t\tthis.threeShapes.add(mesh);\n\t\t\t\t\t}.bind(_this));\n\t\t\t\t}();\n\n\t\t\t\tif ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n\t\t\t}\n\t\t}\n\t}]);\n\n\treturn PhysicsDebugComponent;\n}();\n\n;\n\nfunction ThreeAxis() {\n\treturn ThreeAxis.prototype.clone();\n}\n\nThreeAxis.prototype = function () {\n\n\tvar three = new _three2.default.Object3D();\n\n\tvar LENGTH = 2;\n\tvar HALF_LENGTH = LENGTH / 2;\n\tvar THICKNESS = .001;\n\n\tvar xAxis = new _three2.default.Mesh(new _three2.default.CubeGeometry(LENGTH, THICKNESS, THICKNESS), new _three2.default.MeshBasicMaterial({\n\t\tcolor: 0xff0000,\n\t\twireframe: true\n\t}));\n\txAxis.position.setX(HALF_LENGTH);\n\txAxis.castShadow = xAxis.receiveShadow = false;\n\tthree.add(xAxis);\n\n\tvar yAxis = new _three2.default.Mesh(new _three2.default.CubeGeometry(THICKNESS, LENGTH, THICKNESS), new _three2.default.MeshBasicMaterial({\n\t\tcolor: 0x00ff00,\n\t\twireframe: true\n\t}));\n\tyAxis.position.setY(HALF_LENGTH);\n\tyAxis.castShadow = yAxis.receiveShadow = false;\n\tthree.add(yAxis);\n\n\tvar zAxis = new _three2.default.Mesh(new _three2.default.CubeGeometry(THICKNESS, THICKNESS, LENGTH), new _three2.default.MeshBasicMaterial({\n\t\tcolor: 0x0000ff,\n\t\twireframe: true\n\t}));\n\tzAxis.position.setZ(HALF_LENGTH);\n\tzAxis.castShadow = zAxis.receiveShadow = false;\n\tthree.add(zAxis);\n\n\treturn three;\n}();\n\nexports.default = PhysicsDebugComponent;//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi92aWV3L1BoeXNpY3NEZWJ1Z0NvbXBvbmVudC5qcz80ODZlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7O0lBRU0scUI7QUFFTCxVQUZLLHFCQUVMLENBQVksTUFBWixFQUFvQjtBQUFBLHdCQUZmLHFCQUVlOztBQUNuQixPQUFLLE1BQUwsR0FBYyxNQUFkOztBQUVBLE1BQUksUUFBUSxJQUFJLGdCQUFNLFFBQVYsRUFBWjtBQUNBLE1BQUksVUFBVSxPQUFPLEdBQVAsQ0FBVyxTQUFYLENBQWQ7O0FBRUEsT0FBSyxTQUFMLEdBQWlCLElBQUksU0FBSixFQUFqQjtBQUNBLFFBQU0sR0FBTixDQUFVLEtBQUssU0FBZjs7QUFFQSxPQUFLLEtBQUwsR0FBYSxLQUFiO0FBQ0E7O2NBWkkscUI7O3lCQWNFO0FBQ04sUUFBSyxVQUFMO0FBQ0EsUUFBSyxZQUFMO0FBQ0E7OztpQ0FFYztBQUNkLE9BQUksVUFBVSxLQUFLLE1BQUwsQ0FBWSxHQUFaLENBQWdCLFNBQWhCLENBQWQ7O0FBRUEsT0FBSSxPQUFKLEVBQWE7QUFDWixRQUFJLFdBQVcsUUFBUSxRQUF2QjtBQUNBLFNBQUssS0FBTCxDQUFXLFFBQVgsQ0FBb0IsR0FBcEIsQ0FBd0IsU0FBUyxDQUFqQyxFQUFvQyxTQUFTLENBQTdDLEVBQWdELFNBQVMsQ0FBekQ7O0FBRUEsUUFBSSxXQUFXLFFBQVEsUUFBdkI7QUFDQSxTQUFLLEtBQUwsQ0FBVyxhQUFYLEdBQTJCLElBQTNCO0FBQ0EsU0FBSyxLQUFMLENBQVcsVUFBWCxDQUFzQixHQUF0QixDQUEwQixTQUFTLENBQW5DLEVBQXNDLFNBQVMsQ0FBL0MsRUFBa0QsU0FBUyxDQUEzRCxFQUE4RCxTQUFTLENBQXZFO0FBQ0E7QUFDRDs7OytCQUVZO0FBQUE7O0FBQ1osT0FBSSxVQUFVLEtBQUssTUFBTCxDQUFZLEdBQVosQ0FBZ0IsU0FBaEIsQ0FBZDs7QUFFQSxPQUFJLE9B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QjtBQUNBLE9BQU0sVUFBTixHQUFtQixNQUFNLGFBQU4sR0FBc0IsS0FBekM7QUFDQSxPQUFNLEdBQU4sQ0FBVSxLQUFWOztBQUVBLEtBQUksUUFBUSxJQUFJLGdCQUFNLElBQVYsQ0FDWCxJQUFJLGdCQUFNLFlBQVYsQ0FBdUIsU0FBdkIsRUFBa0MsU0FBbEMsRUFBNkMsTUFBN0MsQ0FEVyxFQUVYLElBQUksZ0JBQU0saUJBQVYsQ0FBNEI7QUFDM0IsU0FBTyxRQURvQjtBQUUzQixhQUFXO0FBRmdCLEVBQTVCLENBRlcsQ0FBWjtBQU9BLE9BQU0sUUFBTixDQUFlLElBQWYsQ0FBb0IsV0FBcEI7QUFDQSxPQUFNLFVBQU4sR0FBbUIsTUFBTSxhQUFOLEdBQXNCLEtBQXpDO0FBQ0EsT0FBTSxHQUFOLENBQVUsS0FBVjs7QUFFQSxRQUFPLEtBQVA7QUFFQSxDQTNDcUIsRUFBdEI7O2tCQTZDZSxxQiIsImZpbGUiOiI1MS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCBjb21wYXJlIGZyb20gJy4uLy4uL3NoYXJlZC9jb21wYXJlJztcbmltcG9ydCBjbG9uZSBmcm9tICcuLi8uLi9zaGFyZWQvY2xvbmUnO1xuXG5jbGFzcyBQaHlzaWNzRGVidWdDb21wb25lbnQge1xuXG5cdGNvbnN0cnVjdG9yKGVudGl0eSkge1xuXHRcdHRoaXMuZW50aXR5ID0gZW50aXR5O1xuXG5cdFx0bGV0IHRocmVlID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XG5cdFx0bGV0IHBoeXNpY3MgPSBlbnRpdHkuZ2V0KCdwaHlzaWNzJyk7XG5cblx0XHR0aGlzLnRocmVlQXhpcyA9IG5ldyBUaHJlZUF4aXMoKTtcblx0XHR0aHJlZS5hZGQodGhpcy50aHJlZUF4aXMpO1xuXG5cdFx0dGhpcy50aHJlZSA9IHRocmVlO1xuXHR9XG5cblx0dGljaygpIHtcblx0XHR0aGlzLnRpY2tTaGFwZXMoKTtcblx0XHR0aGlzLnRpY2tQb3NpdGlvbigpO1xuXHR9XG5cblx0dGlja1Bvc2l0aW9uKCkge1xuXHRcdGxldCBwaHlzaWNzID0gdGhpcy5lbnRpdHkuZ2V0KCdwaHlzaWNzJyk7XG5cblx0XHRpZiAocGh5c2ljcykge1xuXHRcdFx0bGV0IHBvc2l0aW9uID0gcGh5c2ljcy5wb3NpdGlvbjtcblx0XHRcdHRoaXMudGhyZWUucG9zaXRpb24uc2V0KHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHBvc2l0aW9uLnopO1xuXG5cdFx0XHRsZXQgcm90YXRpb24gPSBwaHlzaWNzLnJvdGF0aW9uO1xuXHRcdFx0dGhpcy50aHJlZS51c2VRdWF0ZXJuaW9uID0gdHJ1ZTtcblx0XHRcdHRoaXMudGhyZWUucXVhdGVybmlvbi5zZXQocm90YXRpb24ueCwgcm90YXRpb24ueSwgcm90YXRpb24ueiwgcm90YXRpb24udyk7XG5cdFx0fVxuXHR9XG5cblx0dGlja1NoYXBlcygpIHtcblx0XHRsZXQgcGh5c2ljcyA9IHRoaXMuZW50aXR5LmdldCgncGh5c2ljcycpO1xuXG5cdFx0aWYgKHBoeXNpY3MpIHtcblxuXHRcdFx0aWYgKHRoaXMub2xkU2hhcGVzICYmIGNvbXBhcmUuYXJyYXlzKHRoaXMub2xkU2hhcGVzLCBwaHlzaWNzLmNhbm5vbi5zaGFwZXMpID09PSB0cnVlKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMudGhyZWVTaGFwZXMpIHtcblx0XHRcdFx0dGhpcy50aHJlZS5yZW1vdmUodGhpcy50aHJlZVNoYXBlcyk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMudGhyZWVTaGFwZXMgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcblx0XHRcdHRoaXMudGhyZWUuYWRkKHRoaXMudGhyZWVTaGFwZXMpO1xuXG5cdFx0XHRsZXQgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCh7XG5cdFx0XHRcdGNvbG9yOiAweGZmMDAwMCxcblx0XHRcdFx0d2lyZWZyYW1lOiB0cnVlXG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5vbGRTaGFwZXMgPSBjbG9uZS5hcnJheShwaHlzaWNzLmNhbm5vbi5zaGFwZXMpO1xuXG5cdFx0XHRwaHlzaWNzLmNhbm5vbi5zaGFwZXMuZm9yRWFjaChmdW5jdGlvbihjYW5ub25TaGFwZSwgaSkge1xuXHRcdFx0XHRsZXQgbWVzaCA9IG5ldyBUSFJFRS5NZXNoKFxuXHRcdFx0XHRcdG5ldyBUSFJFRS5DdWJlR2VvbWV0cnkoXG5cdFx0XHRcdFx0XHRjYW5ub25TaGFwZS5oYWxmRXh0ZW50cy54ICogMixcblx0XHRcdFx0XHRcdGNhbm5vblNoYXBlLmhhbGZFeHRlbnRzLnkgKiAyLFxuXHRcdFx0XHRcdFx0Y2Fubm9uU2hhcGUuaGFsZkV4dGVudHMueiAqIDJcblx0XHRcdFx0XHQpLFxuXHRcdFx0XHRcdG1hdGVyaWFsXG5cdFx0XHRcdCk7XG5cdFx0XHRcdGxldCBwb3NpdGlvbiA9IHBoeXNpY3MuY2Fubm9uLnNoYXBlT2Zmc2V0c1tpXTtcblx0XHRcdFx0bWVzaC5wb3NpdGlvbi5zZXQocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgcG9zaXRpb24ueik7XG5cdFx0XHRcdGxldCByb3RhdGlvbiA9IHBoeXNpY3MuY2Fubm9uLnNoYXBlT3JpZW50YXRpb25zW2ldO1xuXHRcdFx0XHRtZXNoLnVzZVF1YXRlcm5pb24gPSB0cnVlO1xuXHRcdFx0XHRtZXNoLnF1YXRlcm5pb24uc2V0KHJvdGF0aW9uLngsIHJvdGF0aW9uLnksIHJvdGF0aW9uLnosIHJvdGF0aW9uLncpO1xuXHRcdFx0XHR0aGlzLnRocmVlU2hhcGVzLmFkZChtZXNoKTtcblx0XHRcdH0uYmluZCh0aGlzKSk7XG5cblx0XHR9XG5cdH1cblx0XHRcbn07XG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIFRocmVlQXhpcygpIHtcblx0cmV0dXJuIFRocmVlQXhpcy5wcm90b3R5cGUuY2xvbmUoKTtcbn1cblxuVGhyZWVBeGlzLnByb3RvdHlwZSA9IChmdW5jdGlvbigpIHtcblxuXHRsZXQgdGhyZWUgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcblxuXHRsZXQgTEVOR1RIID0gMjtcblx0bGV0IEhBTEZfTEVOR1RIID0gTEVOR1RILzI7XG5cdGxldCBUSElDS05FU1MgPSAuMDAxO1xuXG5cdGxldCB4QXhpcyA9IG5ldyBUSFJFRS5NZXNoKFxuXHRcdG5ldyBUSFJFRS5DdWJlR2VvbWV0cnkoTEVOR1RILCBUSElDS05FU1MsIFRISUNLTkVTUyksXG5cdFx0bmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcblx0XHRcdGNvbG9yOiAweGZmMDAwMCxcblx0XHRcdHdpcmVmcmFtZTogdHJ1ZVxuXHRcdH0pXG5cdCk7XG5cdHhBeGlzLnBvc2l0aW9uLnNldFgoSEFMRl9MRU5HVEgpO1xuXHR4QXhpcy5jYXN0U2hhZG93ID0geEF4aXMucmVjZWl2ZVNoYWRvdyA9IGZhbHNlO1xuXHR0aHJlZS5hZGQoeEF4aXMpO1xuXG5cdGxldCB5QXhpcyA9IG5ldyBUSFJFRS5NZXNoKFxuXHRcdG5ldyBUSFJFRS5DdWJlR2VvbWV0cnkoVEhJQ0tORVNTLCBMRU5HVEgsIFRISUNLTkVTUyksXG5cdFx0bmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcblx0XHRcdGNvbG9yOiAweDAwZmYwMCxcblx0XHRcdHdpcmVmcmFtZTogdHJ1ZVxuXHRcdH0pXG5cdCk7XG5cdHlBeGlzLnBvc2l0aW9uLnNldFkoSEFMRl9MRU5HVEgpO1xuXHR5QXhpcy5jYXN0U2hhZG93ID0geUF4aXMucmVjZWl2ZVNoYWRvdyA9IGZhbHNlO1xuXHR0aHJlZS5hZGQoeUF4aXMpO1xuXG5cdGxldCB6QXhpcyA9IG5ldyBUSFJFRS5NZXNoKFxuXHRcdG5ldyBUSFJFRS5DdWJlR2VvbWV0cnkoVEhJQ0tORVNTLCBUSElDS05FU1MsIExFTkdUSCksXG5cdFx0bmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcblx0XHRcdGNvbG9yOiAweDAwMDBmZixcblx0XHRcdHdpcmVmcmFtZTogdHJ1ZVxuXHRcdH0pXG5cdCk7XG5cdHpBeGlzLnBvc2l0aW9uLnNldFooSEFMRl9MRU5HVEgpO1xuXHR6QXhpcy5jYXN0U2hhZG93ID0gekF4aXMucmVjZWl2ZVNoYWRvdyA9IGZhbHNlO1xuXHR0aHJlZS5hZGQoekF4aXMpO1xuXG5cdHJldHVybiB0aHJlZTtcblxufSkoKTtcblxuZXhwb3J0IGRlZmF1bHQgUGh5c2ljc0RlYnVnQ29tcG9uZW50O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi92aWV3L1BoeXNpY3NEZWJ1Z0NvbXBvbmVudC5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 52 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar compare = {\n\tarrays: function arrays(a, b) {\n\t\tif (a === b) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (a.length !== b.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (a.find(function (val, i) {\n\t\t\treturn b[i] !== val;\n\t\t})) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n};\n\nexports.default = compare;//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc2hhcmVkL2NvbXBhcmUuanM/M2VlOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQSxJQUFJLFVBQVU7QUFDYixTQUFRLGdCQUFTLENBQVQsRUFBWSxDQUFaLEVBQWU7QUFDdEIsTUFBSSxNQUFNLENBQVYsRUFBYTtBQUNaLFVBQU8sSUFBUDtBQUNBOztBQUVELE1BQUksRUFBRSxNQUFGLEtBQWEsRUFBRSxNQUFuQixFQUEyQjtBQUMxQixVQUFPLEtBQVA7QUFDQTs7QUFFRCxNQUFJLEVBQUUsSUFBRixDQUNILFVBQVMsR0FBVCxFQUFhLENBQWIsRUFBZ0I7QUFBRSxVQUFPLEVBQUUsQ0FBRixNQUFTLEdBQWhCO0FBQXNCLEdBRHJDLENBQUosRUFFRztBQUNGLFVBQU8sS0FBUDtBQUNBOztBQUVELFNBQU8sSUFBUDtBQUNBO0FBakJZLENBQWQ7O2tCQW9CZSxPIiwiZmlsZSI6IjUyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5sZXQgY29tcGFyZSA9IHtcblx0YXJyYXlzOiBmdW5jdGlvbihhLCBiKSB7XG5cdFx0aWYgKGEgPT09IGIpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRcblx0XHRpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdFxuXHRcdGlmIChhLmZpbmQoXG5cdFx0XHRmdW5jdGlvbih2YWwsaSkgeyByZXR1cm4gYltpXSAhPT0gdmFsOyB9XG5cdFx0KSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjb21wYXJlO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc2hhcmVkL2NvbXBhcmUuanNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 53 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar clone = {\n\tarray: function array(arr) {\n\t\treturn [].concat(arr);\n\t}\n};\n\nexports.default = clone;//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc2hhcmVkL2Nsb25lLmpzPzhmMTYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQ0EsSUFBSSxRQUFRO0FBQ1gsUUFBTyxlQUFTLEdBQVQsRUFBYztBQUNwQixTQUFPLEdBQUcsTUFBSCxDQUFVLEdBQVYsQ0FBUDtBQUNBO0FBSFUsQ0FBWjs7a0JBTWUsSyIsImZpbGUiOiI1My5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxubGV0IGNsb25lID0ge1xuXHRhcnJheTogZnVuY3Rpb24oYXJyKSB7XG5cdFx0cmV0dXJuIFtdLmNvbmNhdChhcnIpO1xuXHR9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbG9uZTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4uL3NoYXJlZC9jbG9uZS5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _three = __webpack_require__(32);\n\nvar _three2 = _interopRequireDefault(_three);\n\nvar _cannon = __webpack_require__(9);\n\nvar _cannon2 = _interopRequireDefault(_cannon);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ConstraintDebugView = function () {\n\tfunction ConstraintDebugView(cannonConstraint) {\n\t\t_classCallCheck(this, ConstraintDebugView);\n\n\t\tthis.cannon = cannonConstraint;\n\t\tthis.three = new _three2.default.Object3D();\n\t\tthis.threeBodyA = new _three2.default.Mesh(new _three2.default.SphereGeometry(.2, 4, 4), new _three2.default.MeshBasicMaterial({\n\t\t\twireframe: true,\n\t\t\tcolor: 0xff0000\n\t\t}));\n\t\tthis.threeBodyB = this.threeBodyA.clone();\n\t\tthis.three.add(this.threeBodyA);\n\t\tthis.three.add(this.threeBodyB);\n\t}\n\n\t_createClass(ConstraintDebugView, [{\n\t\tkey: 'tick',\n\t\tvalue: function tick() {\n\t\t\tvar pivotA = this.cannon.pivotA || new _cannon2.default.Vec3();\n\t\t\tvar pivotB = this.cannon.pivotB || new _cannon2.default.Vec3();\n\t\t\tvar vectorA = this.cannon.bodyA.pointToWorldFrame(pivotA);\n\t\t\tvar vectorB = this.cannon.bodyB.pointToWorldFrame(pivotB);\n\n\t\t\tthis.threeBodyA.position.set(vectorA.x, vectorA.y, vectorA.z);\n\t\t\tthis.threeBodyB.position.set(vectorB.x, vectorB.y, vectorB.z);\n\t\t}\n\t}]);\n\n\treturn ConstraintDebugView;\n}();\n\nexports.default = ConstraintDebugView;\n;//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi92aWV3L2RlYnVnL0NvbnN0cmFpbnREZWJ1Z1ZpZXcuanM/MDk0NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7O0lBRXFCLG1CO0FBRXBCLFVBRm9CLG1CQUVwQixDQUFZLGdCQUFaLEVBQThCO0FBQUEsd0JBRlYsbUJBRVU7O0FBQzdCLE9BQUssTUFBTCxHQUFjLGdCQUFkO0FBQ0EsT0FBSyxLQUFMLEdBQWEsSUFBSSxnQkFBTSxRQUFWLEVBQWI7QUFDQSxPQUFLLFVBQUwsR0FBa0IsSUFBSSxnQkFBTSxJQUFWLENBQ2pCLElBQUksZ0JBQU0sY0FBVixDQUF5QixFQUF6QixFQUE2QixDQUE3QixFQUFnQyxDQUFoQyxDQURpQixFQUVqQixJQUFJLGdCQUFNLGlCQUFWLENBQTRCO0FBQzNCLGNBQVcsSUFEZ0I7QUFFM0IsVUFBTztBQUZvQixHQUE1QixDQUZpQixDQUFsQjtBQU9BLE9BQUssVUFBTCxHQUFrQixLQUFLLFVBQUwsQ0FBZ0IsS0FBaEIsRUFBbEI7QUFDQSxPQUFLLEtBQUwsQ0FBVyxHQUFYLENBQWUsS0FBSyxVQUFwQjtBQUNBLE9BQUssS0FBTCxDQUFXLEdBQVgsQ0FBZSxLQUFLLFVBQXBCO0FBQ0E7O2NBZm1CLG1COzt5QkFpQmI7QUFDTixPQUFJLFNBQVMsS0FBSyxNQUFMLENBQVksTUFBWixJQUFzQixJQUFJLGlCQUFPLElBQVgsRUFBbkM7QUFDQSxPQUFJLFNBQVMsS0FBSyxNQUFMLENBQVksTUFBWixJQUFzQixJQUFJLGlCQUFPLElBQVgsRUFBbkM7QUFDQSxPQUFJLFVBQVUsS0FBSyxNQUFMLENBQVksS0FBWixDQUFrQixpQkFBbEIsQ0FBb0MsTUFBcEMsQ0FBZDtBQUNBLE9BQUksVUFBVSxLQUFLLE1BQUwsQ0FBWSxLQUFaLENBQWtCLGlCQUFsQixDQUFvQyxNQUFwQyxDQUFkOztBQUVBLFFBQUssVUFBTCxDQUFnQixRQUFoQixDQUF5QixHQUF6QixDQUE2QixRQUFRLENBQXJDLEVBQXdDLFFBQVEsQ0FBaEQsRUFBbUQsUUFBUSxDQUEzRDtBQUNBLFFBQUssVUFBTCxDQUFnQixRQUFoQixDQUF5QixHQUF6QixDQUE2QixRQUFRLENBQXJDLEVBQXdDLFFBQVEsQ0FBaEQsRUFBbUQsUUFBUSxDQUEzRDtBQUNBOzs7UUF6Qm1CLG1COzs7a0JBQUEsbUI7QUEyQnBCIiwiZmlsZSI6IjU0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0IENBTk5PTiBmcm9tICdjYW5ub24nO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb25zdHJhaW50RGVidWdWaWV3IHtcblx0XG5cdGNvbnN0cnVjdG9yKGNhbm5vbkNvbnN0cmFpbnQpIHtcblx0XHR0aGlzLmNhbm5vbiA9IGNhbm5vbkNvbnN0cmFpbnQ7XG5cdFx0dGhpcy50aHJlZSA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuXHRcdHRoaXMudGhyZWVCb2R5QSA9IG5ldyBUSFJFRS5NZXNoKFxuXHRcdFx0bmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KC4yLCA0LCA0KSxcblx0XHRcdG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XG5cdFx0XHRcdHdpcmVmcmFtZTogdHJ1ZSxcblx0XHRcdFx0Y29sb3I6IDB4ZmYwMDAwXG5cdFx0XHR9KVxuXHRcdCk7XG5cdFx0dGhpcy50aHJlZUJvZHlCID0gdGhpcy50aHJlZUJvZHlBLmNsb25lKCk7XG5cdFx0dGhpcy50aHJlZS5hZGQodGhpcy50aHJlZUJvZHlBKTtcblx0XHR0aGlzLnRocmVlLmFkZCh0aGlzLnRocmVlQm9keUIpO1xuXHR9XG5cblx0dGljaygpIHtcblx0XHR2YXIgcGl2b3RBID0gdGhpcy5jYW5ub24ucGl2b3RBIHx8IG5ldyBDQU5OT04uVmVjMygpO1xuXHRcdHZhciBwaXZvdEIgPSB0aGlzLmNhbm5vbi5waXZvdEIgfHwgbmV3IENBTk5PTi5WZWMzKCk7XG5cdFx0dmFyIHZlY3RvckEgPSB0aGlzLmNhbm5vbi5ib2R5QS5wb2ludFRvV29ybGRGcmFtZShwaXZvdEEpO1xuXHRcdHZhciB2ZWN0b3JCID0gdGhpcy5jYW5ub24uYm9keUIucG9pbnRUb1dvcmxkRnJhbWUocGl2b3RCKTtcblxuXHRcdHRoaXMudGhyZWVCb2R5QS5wb3NpdGlvbi5zZXQodmVjdG9yQS54LCB2ZWN0b3JBLnksIHZlY3RvckEueik7XG5cdFx0dGhpcy50aHJlZUJvZHlCLnBvc2l0aW9uLnNldCh2ZWN0b3JCLngsIHZlY3RvckIueSwgdmVjdG9yQi56KTtcblx0fVxuXG59O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi92aWV3L2RlYnVnL0NvbnN0cmFpbnREZWJ1Z1ZpZXcuanNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ }
/******/ ]);